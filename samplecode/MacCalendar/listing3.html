<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>MacCalendar - /MacCalendar.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">MacCalendar</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxHumanInterfaceToolbox-date.html" target="_blank">Carbon > Human Interface Toolbox</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">MacCalendar</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/MacCalendar.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/DrawCalendar.c</option>
<option value="listing2.html">/DrawCalendar.h</option>
<option value="listing3.html">/MacCalendar.c</option>
<option value="listing4.html">/MacCalendar.h</option>
<option value="listing5.html">/MacCalendar.r</option>
<option value="listing6.html">/MacCalendarCommon.h</option>
<option value="listing7.html">/MacCalendarSetup.c</option>
<option value="listing8.html">/MacCalendarSetup.h</option>
<option value="listing9.html">/MacCalendarSetup.r</option></select>
				</p>
				</form>
				<p><strong><a href="MacCalendar.zip">Download Sample</a></strong> (&#147;MacCalendar.zip&#148;, 37.4K)<BR>
<strong><a href="MacCalendar.dmg">Download Sample</a></strong> (&#147;MacCalendar.dmg&#148;, 94.6K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    MacCalendar  Contains:  Control strip module for displaying a calendar.  Written by:  Martin Minow  Copyright:  &copy; 1994-1997 by Apple Computer, Inc., all rights reserved.  Change History (most recent first):  You may incorporate this sample code into your applications without  restriction, though the sample code has been provided &quot;AS IS&quot; and the  responsibility for its operation is 100% yours.  However, what you are  not permitted to do is to redistribute the source as &quot;DSC Sample Code&quot;  after having made changes. If you're going to re-distribute the source,  we require that you make it clear in the source that the code was  descended from Apple Sample Code, but that you've made changes.  Based on the Status Bar Sample.c by Steve Christensen.    File Type      sdev  File Creator    SCAL  -- registered with DTS  Resource Type    sdev  Resource ID      0  Resource Attributes  purgeable  Other options (MetroWerks, Think C 7.0):    Set Require Prototypes, Check Pointer Types, All other warnings.    Do not set trigraph recognition.    Enable Apple extensions.  MetroWerks link/project options:    Link single segment    Set Project type &quot;Code Segment&quot;, Standard Header.*//////////////////////////////////////////////////////////////////////////// Pick up resource constants common to both control strip// module and application.#include &quot;MacCalendarCommon.h&quot;/////////////////////////////////////////////////////////////////////////// Pick up resource constants common to both C and Rez for// the control strip module.#include &quot;MacCalendar.h&quot;/////////////////////////////////////////////////////////////////////////// Pick up prototype for the core drawing code.#include &quot;DrawCalendar.h&quot;/////////////////////////////////////////////////////////////////////////// Pick up system types.#include &lt;Fonts.h&gt;#include &lt;Memory.h&gt;#include &lt;Menus.h&gt;#include &lt;Quickdraw.h&gt;#include &lt;Resources.h&gt;#include &lt;ToolUtils.h&gt;#include &lt;Types.h&gt;#include &lt;Windows.h&gt;#include &lt;Icons.h&gt;#include &lt;ControlStrip.h&gt;#include &lt;Gestalt.h&gt;/////////////////////////////////////////////////////////////////////////// Metrowerks uses A4 to reference globals. The A4-setup code was copied from the// WDEF.c sample included in the Metrowerks DR3 distribution. MPW and Think C// use PC-relative addressing in a single-segment code module. #ifdef __MWERKS__#include &lt;A4Stuff.h&gt;  //  also included in &lt;MacHeaders&gt;#include &lt;SetupA4.h&gt;  //  required to handle callback functions#endif/////////////////////////////////////////////////////////////////////////// Lots of global constants./* * Define the patterns as C-strings so they can be addressed as constants * within the program. */#define kWhitePattern    ((ConstPatternParam) &quot;\000\000\000\000\000\000\000\000&quot;)#define kBlackPattern    ((ConstPatternParam) &quot;\377\377\377\377\377\377\377\377&quot;)enum {  kIconWidth = 16      // Width of the icon on the control strip itself.};// Name under which our preferences are saved.#define kCalendarPrefName  &quot;\pMacCalendar Preferences&quot;// Indices into the STRN_Info STR# resource.enum {  kStringHelp = 1,  kStringFontName,  kStringFontSize,  kStringFirstDayOfWeek,  kStringDayNames};/* * This record defines the information we need to draw the calendar. It is initialized * when we are called with the sdevInitModule message, and passed to and from the * Status Bar manager. */typedef struct GlobalRecord {  Handle        iconSuite;        /* Status bar icon              */  Handle        textStrings;      /* Balloon help string etc.          */  PicHandle      rightArrowPicture;    /* Popup arrow                */  SavedSettingsHandle  settings;        /* Preference settings            */  UInt32        lastSavedModCount;    /* The modCount setting when we last saved. */} GlobalRecord, *GlobalPtr, **GlobalHandle;/////////////////////////////////////////////////////////////////////////// Save current status for restarts.static OSErrCtlStripSavePreferences(    GlobalPtr        globalPtr  ){    OSErr          status;    status = SBSavePreferences(kCalendarPrefName, (Handle) globalPtr-&gt;settings);    if (status == noErr) {      globalPtr-&gt;lastSavedModCount = (**globalPtr-&gt;settings).modCount;    }    return(status);}/////////////////////////////////////////////////////////////////////////// Terminationstatic voidCtlStripCleanUp(    GlobalHandle      globalHandle  ){    register GlobalPtr    globalPtr;    if (globalHandle != nil) {      HLock((Handle) globalHandle);      globalPtr = *globalHandle;      if (globalPtr-&gt;iconSuite != NULL)        DisposeIconSuite(globalPtr-&gt;iconSuite, TRUE);      if (globalPtr-&gt;textStrings != NULL)        DisposeHandle(globalPtr-&gt;textStrings);      if (globalPtr-&gt;rightArrowPicture != NULL)        DisposeHandle((Handle) globalPtr-&gt;rightArrowPicture);      if (globalPtr-&gt;settings != NULL)        DisposeHandle((Handle) globalPtr-&gt;settings);      (void) ReplaceGestaltValue(kControlStripCreator, 0);      DisposeHandle((Handle) globalHandle);    }}/////////////////////////////////////////////////////////////////////////// Initializationstatic longCtlStripInitialize(void){    register GlobalHandle  globalHandle;    register GlobalPtr    globalPtr;    long          result;    Str255          work;    SavedSettingsHandle    prefsHandle;    long          tempLong;    long          gestaltResponse;    globalHandle = nil;        // We're using GestaltValue, so we have to make sure we have    // System 7.5.        result = Gestalt(gestaltSystemVersion, &amp;gestaltResponse);    if (result == noErr) {      if (gestaltResponse &lt; 0x0750) {        result = unimpErr;      }    }        // Register ourselves with Gestalt.  This will trigger    // an error if we've been installed twice, which will cause the    // second instance to fail sooner rather than fail later.        if (result == noErr) {      result = NewGestaltValue(kControlStripCreator, 0);    }    if (result == noErr) {      globalHandle = (GlobalHandle) NewHandleSysClear(sizeof (GlobalRecord));      result = noErr;      if (globalHandle == NULL)        result = MemError();      else {        HLock((Handle) globalHandle);        globalPtr = *globalHandle;        /*         * Load and detach the icon suite         */        result = SBGetDetachIconSuite(&amp;(globalPtr-&gt;iconSuite), ICON_StatusBar, svAllSmallData);      }    }    if (result == noErr) {      globalPtr-&gt;textStrings = GetResource('STR#', STRN_Info);      result = ResError();    }    if (result == noErr) {      DetachResource(globalPtr-&gt;textStrings);      globalPtr-&gt;rightArrowPicture = GetPicture(PICT_RightArrow);      if (globalPtr-&gt;rightArrowPicture == NULL)        result = ResError();    }    if (result == noErr) {      DetachResource((Handle) globalPtr-&gt;rightArrowPicture);      /*       * Get the saved preferences, if any, and configure the drawing       * environment. Note that the sample status bar doesn't dispose       * of the prefsHandle but I maintain that this is a bug.  While       * the control strip documentation doesn't mention whether the       * handle returned by SBLoadPreferences is a resource or a memory       * handle, my testing indicates it's a memory handle.       */      prefsHandle = nil;      result = SBLoadPreferences(kCalendarPrefName, (Handle *) &amp;prefsHandle);      if (result == noErr       &amp;&amp; prefsHandle != nil       &amp;&amp; GetHandleSize((Handle) prefsHandle) == sizeof (SavedSettings)       &amp;&amp; (**prefsHandle).signature == kControlStripCreator       &amp;&amp; (**prefsHandle).prefVersion == kPrefVersion) {         /*          * Use the saved preference resource          */        globalPtr-&gt;settings = prefsHandle;        (**(globalPtr-&gt;settings)).modCount = 0;        globalPtr-&gt;lastSavedModCount = 0;      }      else {        /*         * Hmm, we don't have any preferences. Build a new preference resource.         */        if (prefsHandle != nil) {          DisposeHandle( (Handle) prefsHandle);        }        prefsHandle = (SavedSettingsHandle) NewHandleSysClear(sizeof(SavedSettings));        globalPtr-&gt;settings = prefsHandle;        result = MemError();        if (result == noErr) {          (**(globalPtr-&gt;settings)).signature = kControlStripCreator;          (**(globalPtr-&gt;settings)).prefVersion = kPrefVersion;          (**(globalPtr-&gt;settings)).modCount = 0;          globalPtr-&gt;lastSavedModCount = 1;                    SBGetDetachedIndString(work, globalPtr-&gt;textStrings, kStringDayNames);          pstrcpy((**(globalPtr-&gt;settings)).dayNameString, work);                    SBGetDetachedIndString(work, globalPtr-&gt;textStrings, kStringFontName);          pstrcpy((**(globalPtr-&gt;settings)).fontName, work);                    SBGetDetachedIndString(work, globalPtr-&gt;textStrings, kStringFontSize);          StringToNum(work, &amp;tempLong);          (**(globalPtr-&gt;settings)).fontSize = tempLong;                    SBGetDetachedIndString(work, globalPtr-&gt;textStrings, kStringFirstDayOfWeek);          StringToNum(work, &amp;tempLong);          (**(globalPtr-&gt;settings)).firstDayOfWeek = tempLong;        }      }    }    // Now that we successfully started up, publish our globals using    // Gestalt.        if (result == noErr) {      result = ReplaceGestaltValue(kControlStripCreator, (long) globalPtr-&gt;settings);    }    /*     * We've finished all initialization. If there is an error, exit through     * CtlStripCleanUp to dispose of handles and other junk. If initialization     * are successful, unlock the handle and return the handle cast to a long.     */    if (result != noErr) {      CtlStripCleanUp(globalHandle);    }    else {      HUnlock((Handle) globalHandle);      result = (long) globalHandle;    }    return (result);}/////////////////////////////////////////////////////////////////////////// Draw the icon in the status bar.static longCtlStripDrawStatusIcon(    GlobalPtr        globalPtr,    const Rect        *statusRect  ){    Rect          viewRect;    short          arrowHeight;    viewRect = *statusRect;    viewRect.right = viewRect.left + kIconWidth;    (void) PlotIconSuite(&amp;viewRect, atNone, ttNone, globalPtr-&gt;iconSuite);    /*     * Draw an right-arrow to show that we have a popup menu. Well, we don't     * actually have a popup menu, but we do pop up a calendar when clicked on.     */    arrowHeight = height(PicFrame(rightArrowPicture));    viewRect.left = viewRect.right;    viewRect.right += width(PicFrame(rightArrowPicture));    viewRect.top += ((height(viewRect) - arrowHeight) &gt;&gt; 1);    viewRect.bottom = viewRect.top + arrowHeight;    DrawPicture(globalPtr-&gt;rightArrowPicture, &amp;viewRect);    return (0);}/////////////////////////////////////////////////////////////////////////// Position the calendar with respect to the status bar. If there is enough room// above, put it above, else put it below. Left and right operate similarly.enum {  kCtlStripFrame = 4      /* The frame above/below the icon itself */};static voidGetDisplayRect(    const Rect        *statusRect,    Point          displaySize,    Rect          *windowRect  ){    Rect          sBarRect;    sBarRect = *statusRect;    LocalToGlobal((Point *) &amp;sBarRect.top);    LocalToGlobal((Point *) &amp;sBarRect.bottom);    if (sBarRect.top - kCtlStripFrame - displaySize.v - (GetMBarHeight() + 2) &gt; 0) {      /*       * The calendar is displayed above the status bar.       */      windowRect-&gt;bottom = sBarRect.top - kCtlStripFrame - 1;      windowRect-&gt;top = windowRect-&gt;bottom - displaySize.v;    }    else {      /*       * The calendar is displayed below the status bar.       */      windowRect-&gt;top = sBarRect.bottom + kCtlStripFrame + 1;      windowRect-&gt;bottom = windowRect-&gt;top + displaySize.v;    }    if (sBarRect.right - displaySize.h &gt; 0) {      /*       * The calendar is displayed to the left of the calendar icon.       */      windowRect-&gt;right = sBarRect.right;      windowRect-&gt;left = windowRect-&gt;right - displaySize.h;    }    else {      /*       * The calendar is displayed to the right of the calendar icon.       */      windowRect-&gt;left = sBarRect.left;      windowRect-&gt;right = windowRect-&gt;left + displaySize.h;    }}/////////////////////////////////////////////////////////////////////////// Build the triangular &quot;next month&quot; and &quot;previous month&quot; buttons.enum {  kButtonSeparation = 4          /* 1.0d3, was 2          */};static voidMakeTriangularButtons(    const Rect        *monthRect,    PolyHandle        *leftButton,    PolyHandle        *rightButton,    Rect          *leftButtonRect,    Rect          *rightButtonRect  ){    FontInfo        fontInfo;    short          buttonSize;    short          halfSize;    Rect          bothButtonRect;    GetFontInfo(&amp;fontInfo);    buttonSize = (fontInfo.ascent &amp; ~1);  /* Round down to even value    */    halfSize = buttonSize / 2;    bothButtonRect = *monthRect;    bothButtonRect.bottom -= (1 + fontInfo.leading);    bothButtonRect.top = bothButtonRect.bottom - buttonSize;    bothButtonRect.left =      (width(*monthRect) &gt;&gt; 1) - buttonSize - kButtonSeparation;    bothButtonRect.right =      (width(*monthRect) &gt;&gt; 1) + buttonSize + kButtonSeparation;    *leftButtonRect = bothButtonRect;/* 1.0d4 +  */    leftButtonRect-&gt;right = leftButtonRect-&gt;left + halfSize;    *rightButtonRect = bothButtonRect;    rightButtonRect-&gt;left = rightButtonRect-&gt;right - halfSize;    *leftButton = OpenPoly();      MoveTo(halfSize, 0);      LineTo(halfSize, buttonSize);      LineTo(0, halfSize);      LineTo(halfSize, 0);    ClosePoly();    OffsetPoly(*leftButton, leftButtonRect-&gt;left, leftButtonRect-&gt;top);    *rightButton = OpenPoly();      MoveTo(0, 0);      LineTo(halfSize, halfSize);      LineTo(0, buttonSize);      LineTo(0, 0);    ClosePoly();    OffsetPoly(*rightButton, rightButtonRect-&gt;left, rightButtonRect-&gt;top);/* 1.0d4 -  */}/////////////////////////////////////////////////////////////////////////// Now that we've done setup, do the actual mouse tracking. If the mouse hits the// right button, advance the month and draw it. If it hits the left button, draw// the previous month.static voidDrawCalendarAndTrackMouse(    GlobalPtr        globalPtr,    WindowPtr        windowPtr,    const Rect        *monthRect  ){    Rect          leftButtonRect;    Rect          rightButtonRect;    PolyHandle        leftButton;    PolyHandle        rightButton;    unsigned long      nowSeconds;    DateTimeRec        now;    Point          mousePt;    short          thisYear;    short          thisMonth;    typedef enum {      inNoButton = 0,      inLeftButton = 1,      inRightButton = 2    } WhichButton;    WhichButton        inButton;    WhichButton        wasInButton;    unsigned long      nextMonthTick;    Boolean          redrawButtons;    FrameRect(monthRect);    MakeTriangularButtons(      monthRect,      &amp;leftButton,      &amp;rightButton,      &amp;leftButtonRect,      &amp;rightButtonRect    );    GetDateTime(&amp;nowSeconds);    SecondsToDate(nowSeconds, &amp;now);    inButton = wasInButton = inNoButton;    thisYear = thisMonth = 0;    InitCursor();    while (WaitMouseUp()) {      if (thisYear != now.year || thisMonth != now.month) {        /*         * Draw the new month. Also make sure the buttons are drawn.         */        redrawButtons = TRUE;        EraseRect(&amp;windowPtr-&gt;portRect);        FrameRect(monthRect);        switch (wasInButton) {        case inLeftButton:          FillPoly(leftButton, kWhitePattern);          break;        case inRightButton:          FillPoly(rightButton, kWhitePattern);          break;        }        FramePoly(leftButton);        FramePoly(rightButton);        DrawCalendar(          globalPtr-&gt;settings,          now.year,          now.month,          &amp;windowPtr-&gt;portRect        );        thisYear = now.year;        thisMonth = now.month;      }                      /* If drawing new month    */      /*       * Get the mouse and track it while it is in one of our buttons       */      GetMouse(&amp;mousePt);      if (PtInRect(mousePt, &amp;leftButtonRect))        inButton = inLeftButton;      else if (PtInRect(mousePt, &amp;rightButtonRect))        inButton = inRightButton;      else {        inButton = inNoButton;      }      if (redrawButtons || inButton != wasInButton) {        switch (wasInButton) {        case inLeftButton:  FillPoly(leftButton, kWhitePattern);  break;        case inRightButton:  FillPoly(rightButton, kWhitePattern);  break;        }        switch (inButton) {        case inLeftButton:  FillPoly(leftButton, kBlackPattern);  break;        case inRightButton:  FillPoly(rightButton, kBlackPattern);  break;        }        FramePoly(leftButton);        FramePoly(rightButton);        if (inButton != wasInButton &amp;&amp; inButton != inNoButton)          nextMonthTick = 0;          /* Force new month drawing  */        redrawButtons = FALSE;        wasInButton = inButton;      }                      /* If button click change  */      if (inButton != inNoButton &amp;&amp; TickCount() &gt; nextMonthTick) {        /*         * The user has clicked in a button, or has held the mouse         * down in a button for one second. Draw the appropriate month.         */        nextMonthTick = TickCount() + 60;        switch (inButton) {        case inLeftButton:          if (--now.month &lt;= 0) {        /* Previous month or year  */            now.month = 12;            --now.year;          }          break;        case inRightButton:          if (++now.month &gt; 12) {        /* Next month or year    */            now.month = 1;            ++now.year;          }          break;        }                    /* Which button was clicked  */      }                      /* Moving to a new month  */    }                        /* Loop while mouse down  */    KillPoly(leftButton);    KillPoly(rightButton);}/////////////////////////////////////////////////////////////////////////// Click in the status bar iconstatic longCtlStripMouseClick(    GlobalPtr        globalPtr,    const Rect        *statusRect  ){    Rect          windowRect;    WindowPtr        windowPtr;    GrafPtr          savePort;    Point          displaySize;    Rect          monthRect;    displaySize = GetCalendarDisplaySize(globalPtr-&gt;settings);    displaySize.h += 2;    displaySize.v += 2;    GetDisplayRect(statusRect, displaySize, &amp;windowRect);    windowPtr = NewWindow(          NULL,          &amp;windowRect,          &quot;\p&quot;,          TRUE,          plainDBox,          (WindowPtr) -1L,          FALSE,                /* No go-away box      */          0                  /* No refCon        */        );    if (windowPtr != NULL) {      GetPort(&amp;savePort);      SetPort(windowPtr);      GetCalendarMonthRect(        globalPtr-&gt;settings,        &amp;windowPtr-&gt;portRect,        &amp;monthRect      );      if (StillDown()) {        /*         * Design the two triangular buttons that will be displayed on the         * bottom line of the calendar and create the polygons. Then draw         * the calendar and track the mouse while it's held down.         */        DrawCalendarAndTrackMouse(          globalPtr,          windowPtr,          &amp;monthRect        );      }      SetPort(savePort);      DisposeWindow(windowPtr);    }    return (0);}/////////////////////////////////////////////////////////////////////////// Periodically we check the globals that we publish via Gestalt.  If they// have been modified, we return sdevNeedToSave so that the Control Strip// will call our CtlStripSavePreferences routine when an appropriate time// to save comes around (ie the hard disk spins up).static longCtlStripPeriodicTickle(    GlobalPtr        globalPtr,    const Rect        *statusRect  ){    #pragma unused(statusRect)    OSErr result;        result = 0;    if (globalPtr-&gt;lastSavedModCount != (**globalPtr-&gt;settings).modCount) {      result = (1 &lt;&lt; sdevNeedToSave);    }    return (result);}/////////////////////////////////////////////////////////////////////////// This &quot;main&quot; program is called by the Control Strip manager.  Note that,// unlike the rest of this program, we must define a prototype for main// because we can't just declare it &quot;static&quot;.pascal long          main(    unsigned long      message,    GlobalHandle      globalHandle,    const Rect        *statusRect,    GrafPtr          statusPort  );pascal longmain(    unsigned long      message,    GlobalHandle      globalHandle,    const Rect        *statusRect,    GrafPtr          statusPort  ){    #pragma unused(statusPort)    short          savedState;    register GlobalPtr    globalPtr;    long          result;    Str255          helpString;#ifdef __MWERKS__    long          oldA4 = SetCurrentA4();#endif    if (globalHandle != nil) {      /*       * We have already allocated the global record. Save its lock state, lock       * the handle, and get the global pointer (so we can write (*globalPtr).something)       */      savedState = HGetState((Handle) globalHandle);      HLock((Handle) globalHandle);      globalPtr = *globalHandle;    }    result = 0;                  /* Unknown message result    */    switch (message) {    case sdevInitModule:            /* Initialize the module    */      /*       * Initialization always sets globalHandle to NULL to avoid the HSetState       * at the exit routine. If CtlStripInitialize succeeds, it sets the result       * to the global parameter.       */      globalHandle = NULL;      result = CtlStripInitialize();      /* Do the initialization and  */      break;                  /* Return global or error code  */    case sdevCloseModule:            /* Clean up before closing    */      CtlStripCleanUp(globalHandle);      globalHandle = NULL;      break;    case sdevFeatures:              /* Return feature bits      */      result = (  (1&lt;&lt;sdevWantMouseClicks)  /* We handle mouse down      */            | (1&lt;&lt;sdevDontAutoTrack)    /* We track the mouse, too    */            | (1&lt;&lt;sdevHasCustomHelp)    /* Custom help string      */          );      break;    case sdevGetDisplayWidth:          /* Return display width      */      result = kIconWidth  + width(PicFrame(rightArrowPicture));      break;    case sdevPeriodicTickle:          /* Nothing else is happening  */      result = CtlStripPeriodicTickle(globalPtr, statusRect);      break;    case sdevDrawStatus:            /* Draw the status bar info    */      result = CtlStripDrawStatusIcon(globalPtr, statusRect);      break;    case sdevMouseClick:            /* Status bar click        */      result = CtlStripMouseClick(globalPtr, statusRect);      break;    case sdevSaveSettings:            /* Save changed settings    */      result = CtlStripSavePreferences(globalPtr);      break;    case sdevShowBalloonHelp:          /* Display custom balloon help  */      /*       * We don't really have a custom help string, but this shows how to do it.       */      SBGetDetachedIndString(helpString, globalPtr-&gt;textStrings, kStringHelp);      SBShowHelpString(statusRect, helpString);      break;    default:      // Ignore unknown messages.      break;    }        if (globalHandle != NULL)          /* If we have globals allocated  */      HSetState((Handle) globalHandle, savedState);  /* Restore lock state  */  #ifdef __MWERKS__    SetA4(oldA4);#endif    return (result);}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/MacCalendar/listing3.html%3Fid%3DDTS10000190-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/MacCalendar/listing3.html%3Fid%3DDTS10000190-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/MacCalendar/listing3.html%3Fid%3DDTS10000190-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>