<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Soundboard - /GWLayers.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGames-date.html">Games</a> &gt; <A HREF="javascript:location.replace('index.html');">Soundboard</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Games/index.html" target="_blank">Reference Library > Games</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Soundboard</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/GWLayers.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/CAttachment.cp</option>
<option value="listing2.html">/CAttachment.h</option>
<option value="listing3.html">/CFilterControl.cp</option>
<option value="listing4.html">/CFilterControl.h</option>
<option value="listing5.html">/CGrayBox.cp</option>
<option value="listing6.html">/CGrayBox.h</option>
<option value="listing7.html">/CQuickTimeWindow.cp</option>
<option value="listing8.html">/CQuickTimeWindow.h</option>
<option value="listing9.html">/CSliderControl.cp</option>
<option value="listing10.html">/CSliderControl.h</option>
<option value="listing11.html">/CSoundboardApp.cp</option>
<option value="listing12.html">/CSoundboardApp.h</option>
<option value="listing13.html">/CSoundboardWindow.cp</option>
<option value="listing14.html">/CSoundboardWindow.h</option>
<option value="listing15.html">/GWLayers.c</option>
<option value="listing16.html">/GWLayers.h</option>
<option value="listing17.html">/MCPlayMovie.h</option></select>
				</p>
				</form>
				<p><strong><a href="Soundboard.zip">Download Sample</a></strong> (&#147;Soundboard.zip&#148;, 57.3K)<BR>
<strong><a href="Soundboard.dmg">Download Sample</a></strong> (&#147;Soundboard.dmg&#148;, 119.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*** Apple Macintosh Developer Technical Support**** Program:      DTS.Lib** File:        GWLayers.c** Written by:  Eric Soldan and Forrest Tanaka**** Copyright &copy; 1989-1993 Apple Computer, Inc.** All rights reserved.*//* You may incorporate this sample code into your applications without** restriction, though the sample code has been provided &quot;AS IS&quot; and the** responsibility for its operation is 100% yours.  However, what you are** not permitted to do is to redistribute the source as &quot;DSC Sample Code&quot;** after having made changes. If you're going to re-distribute the source,** we require that you make it clear in the source that the code was** descended from Apple Sample Code, but that you've made changes. *//* This is an implementation of off-screen GWorld handling.  This particular** implementation uses GWorlds in a hierarchical manner, with each layer in** the hierarchy having its own tasks to handle at its specific level.** The advantage to this is that it can conform to many applications.  Each** application may need a different number of layers, and each layer may** need to perform a different kind of operation.  By having an unlimited** number of layers, and by having each layer handle its own application** specific tasks, off-screen GWorld handling can be standardized.**** A common use for off-screen stuff is to move an object around in a ** window over a background.  To accomplish this, we need 3 layers.** These are:**** 1) The window layer.  This layer transfers a rectangle of pixels from**    the middle layer into the window layer, once the middle layer is ready.**    The rectangle transferred would be large enough to cover the old**    location and the new location, thus moving the piece without having**    to turn it off in the old location as a separate step.  This gives a**    very smooth appearance when moving an object.** 2) A middle layer that is used to apply the object being moved to the**    background plus removing the object from the old location.  Once these**    two tasks are done, the off-screen work area is ready to be transferred**    to the window layer.** 3) A background image against which the object moves.  This is used to**    restore the middle layer at the location where the object being moved**    was last at.**** The top layer object relates to the window, and therefore we don't need an** off-screen GWorld for it.  A call to create this layer might look like the below:**** err = NewLayer(&amp;windowLayer,   Layer object handle is returned here.**                nil,            Top layer, so there is no above layer.**                nil,            Uses default layer procedure.**                window,         Window used by the layer object.**                0,              Desired depth (0 for screen depth).**                0);             Custom layer init data, if any.**** If NewLayer succeeds, the layer object handle is returned in windowLayer.** If it fails, nil is returned in windowLayer, plus an error is returned.** If windowLayer is successfully created, then we can proceed to create the** next two layers.  In the case below, we are creating an off-screen layer** that has a pixmap the same size and depth as windowLayer.  If this is** what we want for the middle layer, then we can again use the default** LayerProc for the kLayerInit message.  All we need to do is to call the** default layerProc with a kLayerInit message.  We want the standard** action for initialization, but we want our own update action.  That's** why we have a custom layerProc for the middle layer.  The call would look** something like the below:**** err = NewLayer(&amp;middleLayer,     Layer object handle is returned here.**                windowLayer,      Layer above this layer.**                MiddleLayerProc,  Custom layerProc.**                nil,              Create a pixmap for layer.**                0,                Pixmap created as same size/depth as above layer.**                0);**** The background layer would be created similarly.  When you are finished with** the layers, you can dispose of them one at a time with DisposeLayer, or you** can dispose of all of them in the layer chain with DisposeThisAndBelowLayers.**** Inserting a layer is done by position, and not by which layer it goes above** or below.  The reason for this is that the layer positions are most likely** absolute, and therefore it is better to indicate their position with an** absolute number instead of always relating it to some other layer.  If it** is necessary to insert a layer specifically above or below some other layer,** it would be done as follows:**       InsertLayer(newLayer, aboveLayer, GetLayerPosition(aboveLayer) + 1);**       InsertLayer(newLayer, belowLayer, GetLayerPosition(belowLayer));**** The sample applications DTS.Draw and Kibitz uses the off-screen layer code.** For a sample usage, see the file Window2.c in DTS.Draw, or Offscreen.c in Kibitz.*//*****************************************************************************/#ifndef __ERRORS__#include &lt;Errors.h&gt;#endif#ifndef __GESTALTEQU__#include &lt;GestaltEqu.h&gt;#endif#ifndef __GWLAYERS__#include &quot;GWLayers.h&quot;#endif#ifndef __RESOURCES__#include &lt;Resources.h&gt;#endif#ifndef __TRAPS__#include &lt;Traps.h&gt;#endif#ifndef __WINDOWS__#include &lt;Windows.h&gt;#endif#define kQDOriginal 0static OSErr  DefaultLayerInit(LayerObj theLayer);static OSErr  DefaultLayerUpdate(LayerObj theLayer);static OSErr  DefaultLayerDispose(LayerObj theLayer);static OSErr  MakeLayerWorld(GWorldPtr *layerWorld, LayerObj theLayer, Rect bnds);static void    KillLayerWorld(LayerObj theLayer);static void    SmartGetGWorld(CGrafPtr *port, GDHandle *gdh);static void    SmartSetGWorld(CGrafPtr port, GDHandle gdh);static short  GetQDVersion(void);static short  GetSystemVersion(void);static short  NumToolboxTraps(void);static Boolean  TrapExists(short theTrap);static TrapType  GetTrapType(short theTrap);/*****************************************************************************//*****************************************************************************/#ifdef applec#pragma segment ATGGWLayers#endif/*****************************************************************************//*****************************************************************************/OSErr  NewLayer(LayerObj *newLayer, LayerObj aboveLayer, LayerProc theProc,         GrafPtr basePort, short depth, unsigned long theData){  OSErr    err;  LayerRecPtr  lptr;  CGrafPtr  scratchPort;  GDHandle  baseGDevice;  *newLayer = (LayerObj)NewHandleClear(sizeof(LayerRec));  err = MemError();  if (err) return(err);    /* If not enough memory for layer object, return nil and error. */  SmartGetGWorld(&amp;scratchPort, &amp;baseGDevice);  if (!theProc)    theProc = DefaultLayerProc;      /* If layer proc is nil, then they want the default behavior. */  lptr = **newLayer;  lptr-&gt;layerPort     = basePort;  lptr-&gt;layerGDevice  = baseGDevice;  lptr-&gt;layerDepth    = depth;  lptr-&gt;xferMode      = srcCopy;  lptr-&gt;layerProc     = theProc;  lptr-&gt;layerData     = theData;    /* Layer object is now initialized, except for layers that need a GWorld    ** created.  This will occur when the layer proc is called with an    ** initialization message.  (All fields not explicitly set are 0.) */  InsertLayer(*newLayer, aboveLayer, GetLayerPosition(aboveLayer) + 1);    /* Connect the layer to the layer chain.  The default initialization    ** behavior may need this, as it may create a GWorld of the same size    ** as the above layer.  If it isn't connected to the layer chain, then    ** there is no above layer. */  err = (*theProc)(*newLayer, kLayerInit);  if (err) {    DisposeLayer(*newLayer);    *newLayer = nil;      /* There wasn't enough memory to create the off-screen GWorld, so      ** dispose of the layer object.  Since we failed, we need to return      ** nil and the error. */  }  return(err);}/*****************************************************************************/void  DetachLayer(LayerObj theLayer){  LayerObj  aboveLayer, belowLayer;  if (theLayer) {    aboveLayer = (*theLayer)-&gt;aboveLayer;    belowLayer = (*theLayer)-&gt;belowLayer;    if (aboveLayer)      (*aboveLayer)-&gt;belowLayer = belowLayer;    if (belowLayer)      (*belowLayer)-&gt;aboveLayer = aboveLayer;    (*theLayer)-&gt;aboveLayer = (*theLayer)-&gt;belowLayer = nil;  }}/*****************************************************************************/OSErr  DisposeLayer(LayerObj theLayer){  OSErr  err;  err = noErr;  if (theLayer) {    err = (*((*theLayer)-&gt;layerProc))(theLayer, kLayerDispose);    DetachLayer(theLayer);    DisposeHandle((Handle)theLayer);  }  return(err);}/*****************************************************************************/OSErr  DisposeThisAndBelowLayers(LayerObj theLayer){  OSErr  err, err2;  err = noErr;  if (theLayer) {    err2 = DisposeThisAndBelowLayers((*theLayer)-&gt;belowLayer);    err  = DisposeLayer(theLayer);    if (!err)      err = err2;  }  return(err);}/*****************************************************************************/short  GetLayerPosition(LayerObj theLayer){  short  pos;  if (!theLayer) return(0);  for (pos = 0; (theLayer = (*theLayer)-&gt;aboveLayer) != nil; ++pos) {};  return(pos);}/*****************************************************************************/LayerObj  GetTopLayer(LayerObj theLayer){  for (; (*theLayer)-&gt;aboveLayer; theLayer = (*theLayer)-&gt;aboveLayer) {};  return(theLayer);}/*****************************************************************************/LayerObj  GetBottomLayer(LayerObj theLayer){  for (; (*theLayer)-&gt;belowLayer; theLayer = (*theLayer)-&gt;belowLayer) {};  return(theLayer);}/*****************************************************************************/void  InsertLayer(LayerObj theLayer, LayerObj referenceLayer, short pos){  LayerObj  aboveLayer, belowLayer;  short    i;  if (theLayer) {    if (theLayer == referenceLayer) {      /* If theLayer layer is the same as referenceLayer... */      belowLayer = (*theLayer)-&gt;belowLayer;      if (belowLayer)        referenceLayer = belowLayer;      aboveLayer = (*theLayer)-&gt;aboveLayer;      if (aboveLayer)        referenceLayer = aboveLayer;          /* Try to make the reference layer not the same as theLayer.          ** If it is the same as theLayer, then when theLayer is          ** removed from the old hierarchy, we lose the ability to re-add          ** it to the hierarchy in a new location. */    }    DetachLayer(theLayer);      /* Remove layer from its old hierarchy, if any. */    if (!referenceLayer) return;      /* If there isn't a valid alternative reference, then theLayer      ** IS the hierarchy and no action is taken. */    aboveLayer = nil;    belowLayer = GetTopLayer(referenceLayer);      /* aboveLayer now nil.  belowLayer now is top layer.  These      ** are the correct values if the layer being added is to be      ** the new top layer.  This will be the case if pos is 0.      ** We now walk the linked list pos number of times to get the      ** correct position.  We also terminate if we reach the end      ** of the linked list, no matter what pos is.  This will allow      ** values of pos that are too big to insert the layer at the      ** end of the linked list. */    for (i = 0; ((belowLayer) &amp;&amp; (i != pos)); ++i) {      aboveLayer = belowLayer;      belowLayer = (*belowLayer)-&gt;belowLayer;    }      /* We now have correct values for aboveLayer and belowLayer.  Note that      ** these values may be nil, which would be correct. */    (*theLayer)-&gt;aboveLayer = aboveLayer;    if (aboveLayer)      (*aboveLayer)-&gt;belowLayer = theLayer;    (*theLayer)-&gt;belowLayer = belowLayer;    if (belowLayer)      (*belowLayer)-&gt;aboveLayer = theLayer;  }}/*****************************************************************************//*****************************************************************************/OSErr  UpdateLayer(LayerObj theLayer){  OSErr  err;  err = noErr;  if (theLayer) {    err = UpdateLayer((*theLayer)-&gt;belowLayer);      /* Handle the updates from the bottom up. */    if (!err)      err = (*((*theLayer)-&gt;layerProc))(theLayer, kLayerUpdate);        /* Chain possible errors through each level of recursion. */  }  return(err);}/*****************************************************************************/Rect  GetEffectiveSrcRect(LayerObj theLayer){  Rect  srcRect;  if (!theLayer)    SetRect(&amp;srcRect, 0, 0, 0, 0);  else {    srcRect = (*theLayer)-&gt;srcRect;    if (EmptyRect(&amp;srcRect))      srcRect = ((*theLayer)-&gt;layerPort)-&gt;portRect;  }  return(srcRect);}/*****************************************************************************/Rect  GetEffectiveDstRect(LayerObj theLayer){  Rect  dstRect;  if (!theLayer)    SetRect(&amp;dstRect, 0, 0, 0, 0);  else {    dstRect = (*theLayer)-&gt;dstRect;    if (EmptyRect(&amp;dstRect))      dstRect = ((*theLayer)-&gt;layerPort)-&gt;portRect;  }  return(dstRect);}/*****************************************************************************/OSErr  DefaultLayerProc(LayerObj theLayer, short message){  OSErr  err;  err = noErr;  if (theLayer) {    switch (message) {    /* Dispatch to the correct default behavior. */      case kLayerInit:        err = DefaultLayerInit(theLayer);        break;      case kLayerDispose:        err = DefaultLayerDispose(theLayer);        break;      case kLayerUpdate:        err = DefaultLayerUpdate(theLayer);        break;      default:        break;    }  }  return(err);}/*****************************************************************************/Rect  UpdateUpdateRects(LayerObj theLayer){  Rect  lastUpdate, thisUpdate, dstRect;  if (theLayer) {    lastUpdate = (*theLayer)-&gt;lastUpdate;    (*theLayer)-&gt;lastUpdate = thisUpdate = (*theLayer)-&gt;thisUpdate;    SetRect(&amp;((*theLayer)-&gt;thisUpdate), 0, 0, 0, 0);    if ((*theLayer)-&gt;includeLastUpdate) {      (*theLayer)-&gt;includeLastUpdate = false;      if (EmptyRect(&amp;lastUpdate))        lastUpdate = thisUpdate;      if (EmptyRect(&amp;thisUpdate))        thisUpdate = lastUpdate;      UnionRect(&amp;thisUpdate, &amp;lastUpdate, &amp;thisUpdate);        /* We are going to update the last and current update rects.        ** This will allow the appearance of movement for a foreground        ** object.  The old location is cleared, plus the new location        ** is updated. */      dstRect = GetEffectiveDstRect(theLayer);      SectRect(&amp;thisUpdate, &amp;dstRect, &amp;thisUpdate);    }  }  else SetRect(&amp;thisUpdate, 0, 0, 0, 0);  return(thisUpdate);}/*****************************************************************************/void  InvalLayer(LayerObj theLayer, Rect invalRect, Boolean includeLastUpdate){  Rect    thisUpdate, srcRect, dstRect;  LayerObj  belowLayer;  short    ow, oh;  long    dw, dh, sw, sh;  if (theLayer) {    belowLayer = (*theLayer)-&gt;belowLayer;    dstRect    = GetEffectiveDstRect(theLayer);    SectRect(&amp;dstRect, &amp;invalRect, &amp;invalRect);    if (!EmptyRect(&amp;invalRect)) {        /* If there is something to invalidate... */      thisUpdate = (*theLayer)-&gt;thisUpdate;  /* There may be a prior unhandled update... */      if (EmptyRect(&amp;thisUpdate))        thisUpdate = invalRect;        /* UnionRect doesn't */      UnionRect(&amp;thisUpdate, &amp;invalRect, &amp;(*theLayer)-&gt;thisUpdate);  /* like empty rects. */      if (belowLayer) {        /* If we have a below layer, then pass the update down.  The effectiveSrcRct        ** rect for the below layer may be a different size than the effectiveDstRct.        ** If this is the case, we want to scale invalRect to invalidate a proportional        ** area in the below layer. */        srcRect = GetEffectiveSrcRect(belowLayer);        dw = dstRect.right  - dstRect.left;    /* Calculate widths and heights for */        dh = dstRect.bottom - dstRect.top;    /* srcRect and dstRect. */        sw = srcRect.right  - srcRect.left;        sh = srcRect.bottom - srcRect.top;        OffsetRect(&amp;invalRect, -dstRect.left, -dstRect.top);          /* We want to align the upper-left corner of the srcRect and dstRect          ** so that the scaling also aligns the invalRect into the correct          ** place in the below layer's effectiveSrcRect.  invalRect is now          ** positioned relative to a dstRect with a upper-left corner of 0,0. */        if (dw != sw) {    /* Width dstRect different than srcRect. */          ow = invalRect.right  - invalRect.left;          invalRect.left  = (short)((invalRect.left  * sw) / dw);          invalRect.right = (short)((invalRect.right * sw) / dw);          if ((((invalRect.right  - invalRect.left) * dw) / sw) != ow)            ++invalRect.right;              /* We can possibly lose a fraction of a pixel on the right edge when              ** scaling the invalRect.  It won't hurt if we inval just a bit too              ** much, whereas invalidating too little is a bad thing. */        }        if (dh != sh) {    /* Height dstRect different than srcRect. */          oh = invalRect.bottom - invalRect.top;          invalRect.top    = (short)((invalRect.top    * sh) / dh);          invalRect.bottom = (short)((invalRect.bottom * sh) / dh);          if ((((invalRect.bottom - invalRect.top ) * dh) / sh) != oh)            ++invalRect.bottom;        }        OffsetRect(&amp;invalRect, srcRect.left, srcRect.top);          /* Displace the new invalRect correctly relative to the srcRect. */      }    }    if (includeLastUpdate)      (*theLayer)-&gt;includeLastUpdate = true;        /* If requested to update last position as well, flag it. */    InvalLayer(belowLayer, invalRect, includeLastUpdate);      /* Invalidate the below layer with the new (possibly scaled) invalRect. */  }}/*****************************************************************************/void  SetLayerWorld(LayerObj theLayer){  CGrafPtr  keepPort;  GDHandle  keepGDevice;  /* This is a convenient call for setting a GWorld, while remembering what  ** the previous GWorld was.  This should be balanced with a call to  ** ResetLayerWorld.  A count of how many times this is called is kept  ** so that the old GWorld is cached only if SetLayerWorld is currently  ** in balance with ResetLayerWorld.  This keeps the oldest kept GWorld  ** from being overwritten by subsequent calls. */  if (theLayer) {    if (!(*theLayer)-&gt;cachedCount++) {      SmartGetGWorld(&amp;keepPort, &amp;keepGDevice);      (*theLayer)-&gt;cachedPort    = keepPort;      (*theLayer)-&gt;cachedGDevice = keepGDevice;    }    SmartSetGWorld((CGrafPtr)(*theLayer)-&gt;layerPort, (*theLayer)-&gt;layerGDevice);    LockLayerWorld(theLayer);  }}/*****************************************************************************/void  ResetLayerWorld(LayerObj theLayer){  /* This is used to undo a call to SetLayerWorld.  Calls to ResetLayerWorld  ** should be balanced with previous calls to SetLayerWorld. */  if (theLayer) {    UnlockLayerWorld(theLayer);    if (!--(*theLayer)-&gt;cachedCount)      SmartSetGWorld((*theLayer)-&gt;cachedPort, (*theLayer)-&gt;cachedGDevice);  }}/*****************************************************************************/void  LockLayerWorld(LayerObj theLayer){  Handle  bitmap;  /* This is a convenient way to lock down the pixels for a layer's GWorld.  ** A locked count is kept to make sure that the GWorld is locked only the  ** first time this is called.  Calls to LockLayerWorld will most likely  ** be balanced by calls to UnlockLayerWorld, but not necessarily.  It may  ** be desirable to keep a GWorld call locked.  In this case, right after  ** creating the layer (and indirectly its GWorld), call LockLayerWorld.  ** This will initially lock it.  Subsequent calls would be balanced, and  ** therefore there will always be one more LockLayerWorld call than  ** UnlockLayerWorld calls.  This will keep it locked. */  if (theLayer) {    if ((*theLayer)-&gt;layerOwnsPort) {      if (!(*theLayer)-&gt;lockedCount++) {        bitmap = (*theLayer)-&gt;layerBitmap;        if (bitmap) {          HLock(bitmap);          (*theLayer)-&gt;layerPort-&gt;portBits.baseAddr = *bitmap;        }        else          LockPixels(GetGWorldPixMap((GWorldPtr)(*theLayer)-&gt;layerPort));      }    }  }}/*****************************************************************************/void  UnlockLayerWorld(LayerObj theLayer){  /* This undoes what LockLayerWorld does.  Calls to UnlockLayerWorld will  ** generally be balanced with calls to LockLayerWorld. */  if (theLayer) {    if ((*theLayer)-&gt;layerOwnsPort) {      if (!--(*theLayer)-&gt;lockedCount) {        if ((*theLayer)-&gt;layerBitmap)          HUnlock((*theLayer)-&gt;layerBitmap);        else          UnlockPixels(GetGWorldPixMap((GWorldPtr)(*theLayer)-&gt;layerPort));      }    }  }}/*****************************************************************************/RgnHandle  ScreenDepthRegion(short depth){  RgnHandle    retRgn, tmpRgn;  GDHandle    device;  PixMapHandle  pmap;  Rect      rct;  GrafPtr      mainPort;  retRgn = NewRgn();  if (GetQDVersion() == kQDOriginal) {    if (depth == 1) {      GetWMgrPort(&amp;mainPort);      rct = mainPort-&gt;portRect;      RectRgn(retRgn, &amp;rct);    }  }  else {    tmpRgn = NewRgn();    for (device = GetDeviceList(); device; device = GetNextDevice(device)) {      if (        (TestDeviceAttribute(device, screenDevice)) &amp;&amp;        (TestDeviceAttribute(device, screenActive))      ) {        pmap = (*device)-&gt;gdPMap;        if ((*pmap)-&gt;pixelSize &gt;= depth) {          rct = (*device)-&gt;gdRect;          RectRgn(tmpRgn, &amp;rct);          UnionRgn(retRgn, tmpRgn, retRgn);        }      }    }    DisposeRgn(tmpRgn);  }  return(retRgn);}/*****************************************************************************/CIconHandle  ReadCIcon(short iconID){  Handle  hndl;  if (TrapExists(_PlotCIcon))    return(GetCIcon(iconID));  hndl = GetResource('cicn', iconID);  DetachResource(hndl);  return((CIconHandle)hndl);}/*****************************************************************************/void  KillCIcon(CIconHandle icon){  if (!icon) return;  if (TrapExists(_PlotCIcon))    DisposeCIcon(icon);  else    DisposeHandle((Handle)icon);}/*****************************************************************************/void  DrawCIcon(CIconHandle icon, Rect destRect){  WindowPtr  curPort;  short    depth;  if (!icon) return;  if (TrapExists(_PlotCIcon)) {    depth = 8;    if (GetSystemVersion() &lt; 0x0700) {      depth = 1;      GetPort(&amp;curPort);      if (curPort-&gt;portBits.rowBytes &amp; 0x8000)        depth = (*(((CGrafPtr)curPort)-&gt;portPixMap))-&gt;pixelSize;    }  }  else depth = 1;  if (depth &gt; 1)    PlotCIcon(&amp;destRect, icon);  else    DrawCIconByDepth(icon, destRect, 1, true);}/*****************************************************************************/void  DrawCIconNoMask(CIconHandle icon, Rect destRect){  Rect  iconRect;  char  oldMask[128], *mptr;  short  maskSize, i;  if (!icon) return;  mptr = (Ptr)(*icon)-&gt;iconMaskData;  iconRect = (*icon)-&gt;iconPMap.bounds;  maskSize = (iconRect.bottom - iconRect.top) * (*icon)-&gt;iconMask.rowBytes;  for (i = 0; i &lt; maskSize; ++i) {    oldMask[i] = mptr[i];    mptr[i] = 0xFF;  }  DrawCIcon(icon, destRect);  mptr = (Ptr)(*icon)-&gt;iconMaskData;  for (i = 0; i &lt; maskSize; ++i) mptr[i] = oldMask[i];}/*****************************************************************************/void  DrawCIconByDepth(CIconHandle icon, Rect destRect, short depth, Boolean useMask){  GrafPtr    curPort;  char    savedIconState;  char    savedDataState;  short    offset;  BitMapPtr  bmap;  Rect    iconRect;  if (!icon) return;  GetPort(&amp;curPort);  if (!depth) {    if (!(curPort-&gt;portBits.rowBytes &amp; 0x8000))      depth = 1;    else      depth = (*(((CGrafPtr)curPort)-&gt;portPixMap))-&gt;pixelSize;  }  savedIconState = HGetState((Handle)icon);    /* Lock down things. */  HLock((Handle)icon);  if (depth &gt; 1) {    savedDataState = HGetState((*icon)-&gt;iconData);    HLock((*icon)-&gt;iconData);    (*icon)-&gt;iconPMap.baseAddr = *((*icon)-&gt;iconData);      /* Point the icon's pixMap at the color icon data. */  }  iconRect = (*icon)-&gt;iconPMap.bounds;    /* Find out the dimensions of the icon. */  (*icon)-&gt;iconMask.baseAddr = (Ptr)(*icon)-&gt;iconMaskData;    /* Point the mask's bitMap at the mask data. */  offset  = iconRect.bottom - iconRect.top;  offset *= (*icon)-&gt;iconMask.rowBytes;  (*icon)-&gt;iconBMap.baseAddr = (*icon)-&gt;iconMask.baseAddr + offset;    /* Point the icon's bitMap at the b/w icon data. */  bmap = (depth == 1) ? (BitMapPtr)&amp;((*icon)-&gt;iconBMap) : (BitMapPtr)&amp;((*icon)-&gt;iconPMap);  if (useMask)    CopyMask(bmap, &amp;((*icon)-&gt;iconMask), &amp;curPort-&gt;portBits, &amp;iconRect, &amp;iconRect, &amp;destRect);  else    CopyBits(bmap, &amp;curPort-&gt;portBits, &amp;iconRect, &amp;destRect, srcCopy, nil);  HSetState((Handle)icon, savedIconState);    /* Unlock things. */  if (depth &gt; 1)    HSetState((*icon)-&gt;iconData, savedDataState);}/*****************************************************************************//*****************************************************************************//*****************************************************************************/static OSErr  DefaultLayerInit(LayerObj theLayer){  LayerObj  aboveLayer;  GWorldPtr  layerWorld;    /* GWorld for this layer. */  Rect    parentRect;    /* Rectangle of parent in global coordinates. */  GrafPtr    parentPort;    /* Parent layer's GrafPort. */  GDHandle  parentGDevice;  /* Parent layer's GDevice. */  CGrafPtr  keepPort;    /* Saved GrafPort. */  GDHandle  keepGDevice;  /* Saved GDevice. */  Point    org;  OSErr    err;  short    depth;  err = noErr;  if (theLayer) {    if (!(*theLayer)-&gt;layerPort) {      aboveLayer = (*theLayer)-&gt;aboveLayer;      if (aboveLayer) {        /* The default behavior is to create a GWorld the same size        ** as the above layer, if there is one.  If there isn't an above        ** layer and we were expected to create a GWorld, we have problems.        ** This situation can't be resolved and is handled as a paramErr. */        if (!((*theLayer)-&gt;layerDepth))          (*theLayer)-&gt;layerDepth = (*aboveLayer)-&gt;layerDepth;        SmartGetGWorld(&amp;keepPort, &amp;keepGDevice);    /* Keep the GWorld. */        parentPort    = (*aboveLayer)-&gt;layerPort;        parentGDevice = (*aboveLayer)-&gt;layerGDevice;          /* Grab the parent layer's GrafPort and GDevice. */          SmartSetGWorld((CGrafPtr)parentPort, parentGDevice);        parentRect = GetEffectiveDstRect(aboveLayer);          /* The default behavior is to use the portRect of the above          ** port.  This behavior can be overridden if desired by setting          ** dstRect.  dstRect is initialized to be empty, but if          ** it is specifically set, then this layer should map into          ** just the dstRect and not the portRect.  This is useful if          ** the off-screen image is to be displayed in only a portion          ** of a window. */        org.h = parentRect.left;        org.v = parentRect.top;        LocalToGlobal(((Point *)&amp;parentRect) + 0);        LocalToGlobal(((Point *)&amp;parentRect) + 1);          /* Put the parent layer's destination rect in global coordinates. */          if (GetQDVersion())          err = NewGWorld(&amp;layerWorld, (*theLayer)-&gt;layerDepth, &amp;parentRect, nil, nil, 0);            /* Create the GWorld for this layer.  It will be created with the            ** requested depth.  If the requested depth is 0, then it will be            ** created with a depth great enough for the deepest monitor the            ** parentRect intersects. */        else          err = MakeLayerWorld(&amp;layerWorld, theLayer, parentRect);            /* Create a bitmap for those systems without GWorlds. */        if (err == noErr) {          (*theLayer)-&gt;layerOwnsPort = true;          SetPort((*theLayer)-&gt;layerPort = (GrafPtr)layerWorld);            /* Save the new GWorld in the layer object. */          SetOrigin(org.h, org.v);            /* Set the origin so that this GWorld maps directly into the            ** area to be copied into (dstRect or portRect) for the            ** above layer. */          if (!((*theLayer)-&gt;layerDepth)) {            if (((GrafPtr)layerWorld)-&gt;portBits.rowBytes &amp; 0x8000)              depth = (*(((CGrafPtr)layerWorld)-&gt;portPixMap))-&gt;pixelSize;            else              depth = 1;            (*theLayer)-&gt;layerDepth = depth;          }        }        SmartSetGWorld(keepPort, keepGDevice);    /* Restore the kept GWorld. */      }      else {        err = paramErr;          /* We were expected to create an off-screen GWorld of the          ** same size as the above layer, but we didn't have an above          ** layer.  This is an error.  The parameters passed to NewLayer          ** were inappropriate for the situation, so return a paramErr. */      }    }  }  return(err);}/*****************************************************************************/static OSErr  DefaultLayerUpdate(LayerObj theLayer){  LayerObj  belowLayer;  GrafPtr    belowPort, thisPort;  GDHandle  thisGDevice;  CGrafPtr  keepPort;  GDHandle  keepGDevice;  Rect    thisUpdate, belowRect, thisRect;  short    xfer;  RgnHandle  rgn;  /* The default update behavior is to copy the area to be updated from the  ** below layer into the indicated layer.  We only need to update layer if  ** there is a below layer.  The bottom-most layer update doesn't do anything.  ** As a default, the bottom-most layer is considered background and does not  ** get updated. */  if (theLayer) {    belowLayer = (*theLayer)-&gt;belowLayer;    if (belowLayer) {      /* Get this layer's GWorld and below layer's port. */      thisPort    = (*theLayer)-&gt;layerPort;      thisGDevice = (*theLayer)-&gt;layerGDevice;      belowPort   = (*belowLayer)-&gt;layerPort;      /* Save current GWorld and set the parent's GWorld. */      SmartGetGWorld(&amp;keepPort, &amp;keepGDevice);      SmartSetGWorld((CGrafPtr)thisPort, thisGDevice);      thisUpdate = UpdateUpdateRects(theLayer);      rgn = NewRgn();      RectRgn(rgn, &amp;thisUpdate);      belowRect = GetEffectiveSrcRect(belowLayer);      thisRect  = GetEffectiveDstRect(theLayer);        /* As a default behavior, we CopyBits the below layer into this layer. */      LockLayerWorld(belowLayer);      LockLayerWorld(theLayer);      xfer = (*theLayer)-&gt;xferMode;      CopyBits(&amp;belowPort-&gt;portBits, &amp;thisPort-&gt;portBits, &amp;belowRect, &amp;thisRect, xfer, rgn);      UnlockLayerWorld(theLayer);      UnlockLayerWorld(belowLayer);      DisposeRgn(rgn);      SmartSetGWorld(keepPort, keepGDevice);    /* Restore to the kept GWorld. */    }  }  return(noErr);}/*****************************************************************************/static OSErr  DefaultLayerDispose(LayerObj theLayer){  GWorldPtr  theWorld;  if (theLayer) {    if ((*theLayer)-&gt;layerOwnsPort) {      theWorld = (GWorldPtr)(*theLayer)-&gt;layerPort;      if (theWorld) {        if ((*theLayer)-&gt;layerBitmap)          KillLayerWorld(theLayer);        else          DisposeGWorld(theWorld);      }    }  }  return(noErr);}/*****************************************************************************/static OSErr  MakeLayerWorld(GWorldPtr *layerWorld, LayerObj theLayer, Rect bnds){  GrafPtr  oldPort;  GrafPtr  newPort;  Handle  bitmap;  OSErr  err;  OffsetRect(&amp;bnds, -bnds.left, -bnds.top);  /* Make sure upper-left is 0,0. */  GetPort(&amp;oldPort);    /* Need this to restore the port after OpenPort. */  newPort = (GrafPtr)NewPtr(sizeof(GrafPort));    /* Allocate the grafPort. */  err = MemError();  if (err)    return(err);    /* Failed to allocate the off-screen port. */  /* The call to OpenPort does the following:  ** 1) allocates space for visRgn (set to screenBits.bounds) and clipRgn (set wide open)  ** 2) sets portBits to screenBits  ** 3) sets portRect to screenBits.bounds, etc. (see IM I-163,164)  ** 4) side effect: does a SetPort(&amp;offScreen) */  OpenPort(newPort);  SetPort(oldPort);    /* Now make bitmap the size of the bounds that caller supplied. */  newPort-&gt;portRect = bnds;  newPort-&gt;portBits.bounds = bnds;  RectRgn(newPort-&gt;visRgn, &amp;bnds);  SetRectRgn(newPort-&gt;clipRgn, -32000, -32000, 32000, 32000);    /* Avoid wide-open clipRgn, to be safe.  */  /* rowBytes is size of row, it must be rounded up to an even number of bytes. */  newPort-&gt;portBits.rowBytes = ((bnds.right - bnds.left + 15) &gt;&gt; 4) &lt;&lt; 1;  bitmap = NewHandle(newPort-&gt;portBits.rowBytes * (long)(bnds.bottom - bnds.top));  err = MemError();  if (err) {    ClosePort(newPort);      /* Dump the visRgn and clipRgn. */    DisposePtr((Ptr)newPort);  /* Dump the GrafPort. */    return(err);  }  (*theLayer)-&gt;layerBitmap = bitmap;  *layerWorld              = (GWorldPtr)newPort;  return(noErr);}/*****************************************************************************/static void  KillLayerWorld(LayerObj theLayer){  DisposeHandle((*theLayer)-&gt;layerBitmap);  (*theLayer)-&gt;layerBitmap = nil;  ClosePort((*theLayer)-&gt;layerPort);  DisposePtr((Ptr)(*theLayer)-&gt;layerPort);  (*theLayer)-&gt;layerPort = nil;}/*****************************************************************************/static void  SmartGetGWorld(CGrafPtr *port, GDHandle *gdh){  if (GetQDVersion())    GetGWorld(port, gdh);  else {    *gdh = nil;    GetPort((GrafPtr *)port);  }}/*****************************************************************************/static void  SmartSetGWorld(CGrafPtr port, GDHandle gdh){  if (GetQDVersion())    SetGWorld(port, gdh);  else    SetPort((GrafPtr)port);}/*****************************************************************************/static short  GetQDVersion(){  static long  gestaltResult = -1;  if (gestaltResult == -1) {    if (Gestalt(gestaltQuickdrawVersion, &amp;gestaltResult))      gestaltResult = 0;  }  return((gestaltResult &gt;&gt; 8) &amp; 0xFF);}/*****************************************************************************/static short  GetSystemVersion(){  static long  gestaltResult;  if (!gestaltResult) {    if (Gestalt(gestaltSystemVersion, &amp;gestaltResult))      gestaltResult = 0;  }  return(gestaltResult);}/*****************************************************************************/static Boolean  TrapExists(short theTrap){  TrapType  theTrapType;  theTrapType = GetTrapType(theTrap);  if ((theTrapType == ToolTrap) &amp;&amp; ((theTrap &amp;= 0x07FF) &gt;= NumToolboxTraps()))    theTrap = _Unimplemented;  return(NGetTrapAddress(_Unimplemented, ToolTrap) != NGetTrapAddress(theTrap, theTrapType));}/*****************************************************************************/static short  NumToolboxTraps(void){  if (NGetTrapAddress(_InitGraf, ToolTrap) == NGetTrapAddress(0xAA6E, ToolTrap))    return(0x200);  else    return(0x400);}/*****************************************************************************/static TrapType  GetTrapType(short theTrap){  /* OS traps start with A0, Tool with A8 or AA. */  if ((theTrap &amp; 0x0800) == 0)          /* per D.A. */    return(OSTrap);  else    return(ToolTrap);}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Soundboard/listing15.html%3Fid%3DDTS10000059-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Soundboard/listing15.html%3Fid%3DDTS10000059-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Soundboard/listing15.html%3Fid%3DDTS10000059-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>