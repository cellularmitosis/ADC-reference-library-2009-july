<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Cocoa Event-Handling Guide: Handling Key Events</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Handling Key Events"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/10000060i-CH7" title="Handling Key Events"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../EventsOtherInput-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000447" target="_top">Events &amp; Other Input</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/10000060i-CH1-SW1">Cocoa Event-Handling Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../HandlingMouseEvents/HandlingMouseEvents.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../TrackingAreaObjects/TrackingAreaObjects.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/10000060i-CH7-SW1" title="Handling Key Events"></a><h1>Handling Key Events</h1><p>A Mac OS X system generates key events when a user presses a key on a keyboard or presses several keys simultaneously. When more than one key is pressed, one or more of those keys modifies the significance of the “main” key that is pressed. The most commonly used modifier keys are the Command, Control, Option (Alt), and Shift keys. In certain contexts and combinations, key presses represent commands to the operating system or the frontmost application and not characters to be inserted into text.</p><p>This chapter discusses how you handle key events, particularly key-down events.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="HandlingKeyEvents.html#//apple_ref/doc/uid/10000060i-CH7-SW12">Overview of Key Events</a>
				
			<br/>
			
        
			
			
				<a href="HandlingKeyEvents.html#//apple_ref/doc/uid/10000060i-CH7-SW2">Overriding the keyDown: Method</a>
				
			<br/>
			
        
			
			
				<a href="HandlingKeyEvents.html#//apple_ref/doc/uid/10000060i-CH7-SW11">Handling Key Equivalents</a>
				
			<br/>
			
        
			
			
				<a href="HandlingKeyEvents.html#//apple_ref/doc/uid/10000060i-CH7-SW9">Keyboard Interface Control</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/10000060i-CH7-SW12" title="Overview of Key Events"></a><h2>Overview of Key Events</h2><p>The salient facts about key events, as presented in <span class="content_text"><a href="../EventObjectsTypes/EventObjectsTypes.html#//apple_ref/doc/uid/10000060i-CH4-SW5">“Key Events”</a></span> and <span class="content_text"><a href="../EventArchitecture/EventArchitecture.html#//apple_ref/doc/uid/10000060i-CH3-SW10">“The Path of Key Events,”</a></span> are the following:</p><ul class="ul"><li class="li"><p>Key events are of three specific types (<code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/tdef/NSEventType" target="_top">NSEventType</a></code>), each of which is associated with an <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/cl/NSResponder" target="_top">NSResponder</a></code> method:</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Event-type constant</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Event method</p></th></tr><tr><td  scope="row"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/econst/NSKeyDown" target="_top">NSKeyDown</a></code></p></td><td ><p><code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/keyDown:" target="_top">keyDown:</a></code></p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/econst/NSKeyUp" target="_top">NSKeyUp</a></code></p></td><td ><p><code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/keyUp:" target="_top">keyUp:</a></code></p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/econst/NSFlagsChanged" target="_top">NSFlagsChanged</a></code></p></td><td ><p><code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/flagsChanged:" target="_top">flagsChanged:</a></code></p></td></tr></table></div><p>The <code>flagsChanged:</code> method can be useful for detecting the pressing of modifier keys without any other key being pressed simultaneously. For example, if the user presses the Option key by itself, your responder object can detect this in its implementation of <code>flagsChanged:</code>.</p></li><li class="li"><p><em>Most</em> key events—that is, those representing characters to be inserted as text—are dispatched by the <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/cl/NSWindow" target="_top">NSWindow</a></code> object associated with the key window to the first responder.</p></li><li class="li"><p>If the first responder does not handle the event, it passes the event up the responder chain (see <span class="content_text"><a href="../EventArchitecture/EventArchitecture.html#//apple_ref/doc/uid/10000060i-CH3-SW2">“The Responder Chain”</a></span>).</p></li><li class="li"><p>The delivery path of a key event varies according to whether the event represents a character, a key equivalent, a keyboard action, or a keyboard interface control command. The global application object (<code>NSApp</code>) first looks for key equivalents and then keyboard interface control commands and handles them specially (see <span class="content_text"><a href="../EventArchitecture/EventArchitecture.html#//apple_ref/doc/uid/10000060i-CH3-SW10">“The Path of Key Events”</a></span> for details). If the event is neither of these, it dispatches it to the <code>NSWindow</code> object representing the key window, which in turn dispatches the event to the first responder in a <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/keyDown:" target="_top">keyDown:</a></code> message.</p></li><li class="li"><p>The responder object determines what the key event represents and handles it appropriately. At this point, the key event could represent any one of the following things: </p><ul class="nested"><li class="nested li"><p>A keyboard action, which is a key or key combination bound to an action-message selector in a key bindings dictionary (see <span class="content_text"><a href="../TextDefaultsBindings/TextDefaultsBindings.html#//apple_ref/doc/uid/20000468-611005">“Key Bindings”</a></span>).</p></li><li class="nested li"><p>An application-specific command or action (one not using the key bindings dictionary)</p></li><li class="nested li"><p>A character or characters to insert into text</p></li></ul><p>See <span class="content_text">“Overriding the keyDown: Method”</span> for more information. </p></li><li class="li"><p>As with key event messages, a keyboard action message is passed up the responder chain if the first responder does not handle it.</p></li></ul><a name="//apple_ref/doc/uid/10000060i-CH7-SW2" title="Overriding the keyDown: Method"></a><h2>Overriding the keyDown: Method</h2><p>Most responder objects (such as custom views) handle key events by overriding the <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/keyDown:" target="_top">keyDown:</a></code> method declared by <code>NSResponder</code>. The object can handle the event in any way it sees fit. A text object typically interprets the message as a request to insert text, while a drawing object might only be interested in a few keys, such as Delete and the arrow keys as commands to delete and move selected items. As with mouse events, a responder object often wants to query the passed-in <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/cl/NSEvent" target="_top">NSEvent</a></code> object to find out more about the event and obtain the data it needs to handle it. Some of the more useful <code>NSEvent</code> methods for key events are the following: </p><ul class="ul"><li class="li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/characters" target="_top">characters</a></code> and <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/charactersIgnoringModifiers" target="_top">charactersIgnoringModifiers</a></code>—The responder can extract the Unicode character data associated with the event and insert it as text or interpret it as commands. The <code>charactersIgnoringModifiers</code> method ignores any modifier keystroke (except for Shift) when returning the character data. Note that both method names are plural because a keystroke can produce more than one character (for example, “à” is composed of ‘a’ and ‘`‘). </p></li><li class="li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/modifierFlags" target="_top">modifierFlags</a></code>—Using this method the responder can determine if any modifier keys were pressed.</p></li><li class="li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/isARepeat" target="_top">isARepeat</a></code>—This method tells the responder whether the same key was pressed rapidly in succession.</p></li></ul><p>Within an implementation of a <code>keyDown:</code> method, a responder can extract the character data contained by the associated <code>NSEvent</code> object and insert it into displayed text; or it can interpret the character data as a key or key combination that is either bound to a keyboard action or requests some application-specific behavior. However, the Application Kit provides some convenient shortcuts for doing this, described below. </p><a name="//apple_ref/doc/uid/10000060i-CH7-SW13" title="Handling Keyboard Actions and Inserting Text"></a><h3>Handling Keyboard Actions and Inserting Text</h3><p>Responder objects that deal with text, such as text views, have to be prepared to handle key events that can either be characters to insert or keyboard actions. As noted in <span class="content_text"><a href="../EventArchitecture/EventArchitecture.html#//apple_ref/doc/uid/10000060i-CH3-SW10">“The Path of Key Events,”</a></span> keyboard actions are a special kind of action message that depends on the key bindings mechanism, which binds specific keystrokes (for example, Control-e) to specific commands related to the text (for example, move the insertion point to the end of the current line). These commands are implemented in methods defined by <code>NSResponder</code> to give per-view functional interpretations of those physical keystrokes. </p><div class="notebox"><a name="//apple_ref/doc/uid/10000060i-CH7-SW14" title="Note"></a><p><strong>Note:</strong>&nbsp;Views that receive and edit text must conform to the <code><a href="../../../Reference/ApplicationKit/Protocols/NSTextInput_Protocol/Reference/Reference.html#//apple_ref/occ/intf/NSTextInput" target="_top">NSTextInput</a></code> protocol. Adopting this protocol allows a custom view to interact properly with the text input management system. The Application Kit classes <code><a href="../../../Reference/ApplicationKit/Classes/NSText_Class/Reference/Reference.html#//apple_ref/occ/cl/NSText" target="_top">NSText</a></code> and <code><a href="../../../Reference/ApplicationKit/Classes/NSTextView_Class/Reference/Reference.html#//apple_ref/occ/cl/NSTextView" target="_top">NSTextView</a></code> implement <code>NSTextInput</code>, so if you subclass these classes you get the protocol conformance “for free.“</p></div><p>In handling a key event in <code>keyDown:</code>, a view object that expects to insert text first determines whether the character or characters of the <code>NSEvent</code> object represent a keyboard action. If they do, it sends the associated action message; if they don’t, it inserts the characters as text. Specifically, the view can do one of two things in its implementation:</p><ul class="spaceabove"><li class="li"><p>It can extract the event object’s characters using the <code>characters</code> method of <code>NSEvent</code> and interpret these to see if they are associated with a known keyboard action. If they are, it invokes the appropriate action method in itself or a superview. This approach is discouraged.</p></li><li class="li"><p>It can pass the event to Cocoa’s text input management system by invoking the <code>NSResponder</code> method <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/interpretKeyEvents:" target="_top">interpretKeyEvents:</a></code>. The input management system checks the pressed key against entries in all relevant key-binding dictionaries and, if there is a match, sends a <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/doCommandBySelector:" target="_top">doCommandBySelector:</a></code> message back to the view. Otherwise, it sends an <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/insertText:" target="_top">insertText:</a></code> message back to the view, and the view implements this method to extract and display the text.</p></li></ul><p><span class="content_text">Listing 5-1</span> shows how the second approach might look in code.</p><a name="//apple_ref/doc/uid/10000060i-CH7-SW3" title="Listing 5-1Using the input management system to interpret a key event"></a><p class="codesample"><strong>Listing 5-1&nbsp;&nbsp;</strong>Using the input management system to interpret a key event</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)keyDown:(NSEvent *)theEvent {<span></span></pre></td></tr><tr><td scope="row"><pre>    [self interpretKeyEvents:[NSArray arrayWithObject:theEvent]];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// The following action methods are declared in NSResponder.h<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)insertTab:(id)sender {<span></span></pre></td></tr><tr><td scope="row"><pre>    if ([[self window] firstResponder] == self) {<span></span></pre></td></tr><tr><td scope="row"><pre>        [[self window] selectNextKeyView:self];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)insertBacktab:(id)sender {<span></span></pre></td></tr><tr><td scope="row"><pre>    if ([[self window] firstResponder] == self) {<span></span></pre></td></tr><tr><td scope="row"><pre>        [[self window] selectPreviousKeyView:self];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)insertText:(id)string {<span></span></pre></td></tr><tr><td scope="row"><pre>    [super insertText:string];  // have superclass insert it<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Note that this example includes an override of <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/insertText:" target="_top">insertText:</a></code> that simply invokes the superclass implementation. This is done to clarify the role of the input manager but is not really necessary. The default (<code>NSResponder</code>) implementation of <code>doCommandBySelector:</code> determines if the view responds to the keyboard-action selector and, if the view does respond, it invokes the action method; if the view doesn’t respond, <code>doCommandBySelector:</code> is sent to the next responder (and so on up the responder chain). Therefore, a view should only implement the action methods corresponding to the actions that it wants to handle. Another implication of input-manager behavior is that if the key-bindings dictionary matches a physical keystroke with a keyboard action, the responder object simply needs to override the associated action method to handle that keystroke. For example, to handle the default binding of the Escape key, the responder would override the <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/cancelOperation:" target="_top">cancelOperation:</a></code> method of <code>NSResponder</code>.</p><p>A case in point of a superview handling a keyboard-action message initiated by a subview is the way the <code><a href="../../../Reference/ApplicationKit/Classes/NSScrollView_Class/Reference/Reference.html#//apple_ref/occ/cl/NSScrollView" target="_top">NSScrollView</a></code> object handles page-down commands. This scroll-view object is a compound object consisting of a document view, a clip view (an <code><a href="../../../Reference/ApplicationKit/Classes/NSClipView_Class/Reference/Reference.html#//apple_ref/occ/cl/NSClipView" target="_top">NSClipView</a></code> object) and a scroller (an <code><a href="../../../Reference/ApplicationKit/Classes/NSScroller_Class/Reference/Reference.html#//apple_ref/occ/cl/NSScroller" target="_top">NSScroller</a></code> object). Because it is the containing or coordinating object, the <code>NSScrollView</code> object is the superview of all other objects in this grouping. Now say your custom view is the document view of the scroll view. If you implement <code>keyDown:</code> to send <code>interpretKeyEvents:</code> to the input manager but do not implement the <code>scrollPageDown:</code> action method, the document view will still be scrolled within the scroll view when the user presses the Page Down key (or whatever key binding is in effect for that function). This happens because each next responder in the responder chain is queried to see if it responds to <code>scrollPageDown:</code>. The <code>NSScrollView</code> class provides a default implementation, so this implementation is invoked.</p><p>Applications other that those that deal with text can use the input management system to their benefit. For example, a custom view in a drawing application might use arrow keys to "nudge” graphical objects precise distances. In the standard key bindings dictionary the arrow keys are bound to the <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/moveUp:" target="_top">moveUp:</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/moveDown:" target="_top">moveDown:</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/moveLeft:" target="_top">moveLeft:</a></code>, and <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/moveRight:" target="_top">moveRight:</a></code> methods of <code>NSResponder</code>. So code similar to that shown in <span class="content_text">Listing 5-2</span> would work to nudge the graphical objects around.</p><a name="//apple_ref/doc/uid/10000060i-CH7-SW4" title="Listing 5-2Handling arrow-key characters using the input management system"></a><p class="codesample"><strong>Listing 5-2&nbsp;&nbsp;</strong>Handling arrow-key characters using the input management system</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)keyDown:(NSEvent *)theEvent {<span></span></pre></td></tr><tr><td scope="row"><pre>    // Arrow keys are associated with the numeric keypad<span></span></pre></td></tr><tr><td scope="row"><pre>    if ([theEvent modifierFlags] &amp; NSNumericPadKeyMask) {<span></span></pre></td></tr><tr><td scope="row"><pre>        [self interpretKeyEvents:[NSArray arrayWithObject:theEvent]];<span></span></pre></td></tr><tr><td scope="row"><pre>    } else {<span></span></pre></td></tr><tr><td scope="row"><pre>        [super keyDown:theEvent];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>-(IBAction)moveUp:(id)sender<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [self offsetLocationByX:0 andY: 10.0];<span></span></pre></td></tr><tr><td scope="row"><pre>    [[self window] invalidateCursorRectsForView:self];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>-(IBAction)moveDown:(id)sender<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [self offsetLocationByX:0 andY:-10.0];<span></span></pre></td></tr><tr><td scope="row"><pre>    [[self window] invalidateCursorRectsForView:self];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>-(IBAction)moveLeft:(id)sender<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [self offsetLocationByX:-10.0 andY:0.0];<span></span></pre></td></tr><tr><td scope="row"><pre>    [[self window] invalidateCursorRectsForView:self];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>-(IBAction)moveRight:(id)sender<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [self offsetLocationByX:10.0 andY:0.0];<span></span></pre></td></tr><tr><td scope="row"><pre>    [[self window] invalidateCursorRectsForView:self];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>In most instances, the <code>interpretKeyEvents:</code> approach is preferable to the interpret-yourself approach. This recommendation is particularly true for those custom views in applications such as word processors and graphical editors that do the lion’s share of the work. The major factor favoring the use of the text input management system is that, with it, you don’t need to hard-wire function to physical key. What if the user is using a portable computer that is lacking a function key hard-wired by the application? The better, more flexible approach is to specify alternative key bindings in a dictionary. Another advantage of the text input management system is that it allows key events to be interpreted as text not directly available on the keyboard, such as Kanji and some accented characters. </p><div class="notebox"><a name="//apple_ref/doc/uid/10000060i-CH7-SW15" title="Note"></a><p><strong>Note:</strong>&nbsp;For more information on key bindings and the text input system, see <span class="content_text"><a href="../TextDefaultsBindings/TextDefaultsBindings.html#//apple_ref/doc/uid/20000468-CJBDEADF">“Text System Defaults and Key Bindings.”</a></span></p></div><a name="//apple_ref/doc/uid/10000060i-CH7-SW16" title="Specially Interpreting Keystrokes"></a><h3>Specially Interpreting Keystrokes</h3><p>Although using the text input management system is advantageous, you can interpret physical keys yourself in <code>keyDown:</code> and handle them in an application-specific way. The <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/cl/NSEvent" target="_top">NSEvent</a></code> class declares dozens of constants that identify particular keys either by key symbol or key function; <span class="content_text"><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/doc/uid/20000016-17420" target="_top">“Constants”</a></span> in <em><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/index.html#//apple_ref/doc/uid/TP40004039" target="_top">NSEvent Class Reference</a></em> in the reference documentation for that class describes these constants.  <span class="content_text">Listing 5-3</span> shows a sampling. </p><a name="//apple_ref/doc/uid/10000060i-CH7-SW5" title="Listing 5-3Some key constants defined by NSResponder"></a><p class="codesample"><strong>Listing 5-3&nbsp;&nbsp;</strong>Some key constants defined by NSResponder</p><div class="codesample"><table><tr><td scope="row"><pre>enum {<span></span></pre></td></tr><tr><td scope="row"><pre>    NSUpArrowFunctionKey            = 0xF700,<span></span></pre></td></tr><tr><td scope="row"><pre>    NSDownArrowFunctionKey          = 0xF701,<span></span></pre></td></tr><tr><td scope="row"><pre>    NSLeftArrowFunctionKey          = 0xF702,<span></span></pre></td></tr><tr><td scope="row"><pre>    NSRightArrowFunctionKey         = 0xF703,<span></span></pre></td></tr><tr><td scope="row"><pre>    NSF1FunctionKey                 = 0xF704,<span></span></pre></td></tr><tr><td scope="row"><pre>    NSF2FunctionKey                 = 0xF705,<span></span></pre></td></tr><tr><td scope="row"><pre>    NSF3FunctionKey                 = 0xF706,<span></span></pre></td></tr><tr><td scope="row"><pre>    // other constants here<span></span></pre></td></tr><tr><td scope="row"><pre>    NSUndoFunctionKey               = 0xF743,<span></span></pre></td></tr><tr><td scope="row"><pre>    NSRedoFunctionKey               = 0xF744,<span></span></pre></td></tr><tr><td scope="row"><pre>    NSFindFunctionKey               = 0xF745,<span></span></pre></td></tr><tr><td scope="row"><pre>    NSHelpFunctionKey               = 0xF746,<span></span></pre></td></tr><tr><td scope="row"><pre>    NSModeSwitchFunctionKey         = 0xF747<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><p>Also, the text system defines constants representing commonly-used Unicode characters, such as tab, delete, and carriage return. For a list of these constants, see <span class="content_text"><a href="../../../Reference/ApplicationKit/Classes/NSText_Class/Reference/Reference.html#//apple_ref/doc/uid/20000367-20750" target="_top">“Constants”</a></span> in <em><a href="../../../Reference/ApplicationKit/Classes/NSText_Class/index.html#//apple_ref/doc/uid/TP40004128" target="_top">NSText Class Reference</a></em>.</p><p>In your implementation of <code>keyDown:</code> you can compare one of these constants to the character data of the key-event object to determine if a certain key was pressed and then act accordingly. As you may recall, the <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/characters" target="_top">characters</a></code> or <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/charactersIgnoringModifiers" target="_top">charactersIgnoringModifiers</a></code> methods return an <code><a href="../../../Reference/Foundation/Classes/NSString_Class/Reference/NSString.html#//apple_ref/occ/cl/NSString" target="_top">NSString</a></code> object for a key value instead of a character because a keystroke might generate multiple characters. (In fact, these methods could even return an empty string if a dead key—a key with no character mapped to it—is pressed.) If your implementation of <code>keyDown:</code> is handling a single-character key value, such as an arrow key, you can examine the length of the returned string and, if it is a single character, access that character using the <code>NSString</code> method <code><a href="../../../Reference/Foundation/Classes/NSString_Class/Reference/NSString.html#//apple_ref/occ/instm/NSString/characterAtIndex:" target="_top">characterAtIndex:</a></code> with an index of 0. Then test that character against one of the <code>NSResponder</code> constants. </p><p><span class="content_text">Listing 5-4</span> shows how you might perform the same graphical-object “nudging” as done in <span class="content_text"><a href="HandlingKeyEvents.html#//apple_ref/doc/uid/10000060i-CH7-SW4">Listing 5-2</a></span>, but this time the responder object itself determines whether an arrow key was pressed.  </p><a name="//apple_ref/doc/uid/10000060i-CH7-SW6" title="Listing 5-4Handling arrow-key characters by interpreting the physical key"></a><p class="codesample"><strong>Listing 5-4&nbsp;&nbsp;</strong>Handling arrow-key characters by interpreting the physical key</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)keyDown:(NSEvent *)theEvent {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if ([theEvent modifierFlags] &amp; NSNumericPadKeyMask) { // arrow keys have this mask<span></span></pre></td></tr><tr><td scope="row"><pre>        NSString *theArrow = [theEvent charactersIgnoringModifiers];<span></span></pre></td></tr><tr><td scope="row"><pre>        unichar keyChar = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>        if ( [theArrow length] == 0 )<span></span></pre></td></tr><tr><td scope="row"><pre>            return;            // reject dead keys<span></span></pre></td></tr><tr><td scope="row"><pre>        if ( [theArrow length] == 1 ) {<span></span></pre></td></tr><tr><td scope="row"><pre>            keyChar = [theArrow characterAtIndex:0];<span></span></pre></td></tr><tr><td scope="row"><pre>            if ( keyChar == NSLeftArrowFunctionKey ) {<span></span></pre></td></tr><tr><td scope="row"><pre>                [self offsetLocationByX:-10.0 andY:0.0];<span></span></pre></td></tr><tr><td scope="row"><pre>                [[self window] invalidateCursorRectsForView:self];<span></span></pre></td></tr><tr><td scope="row"><pre>                return;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            if ( keyChar == NSRightArrowFunctionKey ) {<span></span></pre></td></tr><tr><td scope="row"><pre>                [self offsetLocationByX:10.0 andY:0.0];<span></span></pre></td></tr><tr><td scope="row"><pre>                [[self window] invalidateCursorRectsForView:self];<span></span></pre></td></tr><tr><td scope="row"><pre>                return;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            if ( keyChar == NSUpArrowFunctionKey ) {<span></span></pre></td></tr><tr><td scope="row"><pre>                [self offsetLocationByX:0 andY: 10.0];<span></span></pre></td></tr><tr><td scope="row"><pre>                [[self window] invalidateCursorRectsForView:self];<span></span></pre></td></tr><tr><td scope="row"><pre>                return;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            if ( keyChar == NSDownArrowFunctionKey ) {<span></span></pre></td></tr><tr><td scope="row"><pre>                [self offsetLocationByX:0 andY:-10.0];<span></span></pre></td></tr><tr><td scope="row"><pre>                [[self window] invalidateCursorRectsForView:self];<span></span></pre></td></tr><tr><td scope="row"><pre>                return;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            [super keyDown:theEvent];<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    [super keyDown:theEvent];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>You can also convert an <code>NSResponder</code> constant to a string object and then compare that object to the value returned by <code>characters</code> or <code>charactersIgnoringModifiers</code>, as in this example:</p><div class="codesample"><table><tr><td scope="row"><pre>        unichar la = NSLeftArrowFunctionKey;<span></span></pre></td></tr><tr><td scope="row"><pre>        NSString *laStr = [[[NSString alloc] initWithCharacters:&amp;la length:1] autorelease];<span></span></pre></td></tr><tr><td scope="row"><pre>        if ([theArrow isEqual:laStr]) {<span></span></pre></td></tr><tr><td scope="row"><pre>            [self offsetLocationByX:-10.0 andY:0.0];<span></span></pre></td></tr><tr><td scope="row"><pre>            [[self window] invalidateCursorRectsForView:self];<span></span></pre></td></tr><tr><td scope="row"><pre>            return;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr></table></div><p>However, this approach is more memory-intensive.</p><a name="//apple_ref/doc/uid/10000060i-CH7-SW11" title="Handling Key Equivalents"></a><h2>Handling Key Equivalents</h2><p>A key equivalent is a character bound to some view in a window. This binding causes that view to perform a specified action when the user types that character, typically while pressing a modifier key (in most cases the Command key). A key equivalent must be a character that can be typed with no modifier keys, or with Shift only.</p><p>An application routes a key-equivalent event by sending it first down the view hierarchy of a window. The global <code>NSApplication</code> object dispatches events it recognizes as potential key equivalents (based on the presence of modifier flags) in its <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/instm/NSApplication/sendEvent:" target="_top">sendEvent:</a></code> method. It sends a <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/performKeyEquivalent:" target="_top">performKeyEquivalent:</a></code> message to the key <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/cl/NSWindow" target="_top">NSWindow</a></code> object. This object passes key equivalents down its view hierarchy by invoking the <code>NSView</code> default implementation of <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/performKeyEquivalent:" target="_top">performKeyEquivalent:</a></code>, which forwards the message to each of its subviews (including contextual and pop-up menus) until one responds <code><a href="../../../Reference/ObjCRuntimeRef/Reference/reference.html#//apple_ref/doc/c_ref/YES" target="_top">YES</a></code>; if none does, it returns <code><a href="../../../Reference/ObjCRuntimeRef/Reference/reference.html#//apple_ref/doc/c_ref/NO" target="_top">NO</a></code>. If no object in the view hierarchy handles the key equivalent, <code>NSApp</code> then sends <code>performKeyEquivalent:</code> to the menus in the menu bar. <code>NSWindow</code> subclasses are discouraged from overriding <code>performKeyEquivalent:</code>. </p><div class="notebox"><a name="//apple_ref/doc/uid/10000060i-CH7-SW17" title="Note"></a><p><strong>Note:</strong>&nbsp;Beginning with Mac OS X v10.5, if a key equivalent is not recognized, <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/cl/NSWindow" target="_top">NSWindow</a></code> sends it as an <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/econst/NSKeyDown" target="_top">NSKeyDown</a></code> event to the first responder. This behavior enables custom key-binding entries with Command-key modifiers. In addition, <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/cl/NSApplication" target="_top">NSApplication</a></code> sends a Control-key event to the key window via <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/performKeyEquivalent:" target="_top">performKeyEquivalent:</a></code> before sending it as an <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/econst/NSKeyDown" target="_top">NSKeyDown</a></code> event through the responder chain. This behavior allows more reliable use of Control-key events as menu key equivalents. </p></div><p>Some Cocoa classes, such as <code><a href="../../../Reference/ApplicationKit/Classes/NSButton_Class/Reference/Reference.html#//apple_ref/occ/cl/NSButton" target="_top">NSButton</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSMenu_Class/Reference/Reference.html#//apple_ref/occ/cl/NSMenu" target="_top">NSMenu</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSMatrix_Class/Reference/Reference.html#//apple_ref/occ/cl/NSMatrix" target="_top">NSMatrix</a></code>, and <code><a href="../../../Reference/ApplicationKit/Classes/NSSavePanel_Class/Reference/Reference.html#//apple_ref/occ/cl/NSSavePanel" target="_top">NSSavePanel</a></code>, provide default implementations of <code>performKeyEquivalent:</code>. For example, you can set the Return key as the key equivalent of an <code>NSButton</code> object and, when this key is pressed, the button acts as if it has been clicked. However, subclasses of other Application Kit classes (including custom views) need to provide their own implementations of <code>performKeyEquivalent:</code>. The implementation should extract the characters for a key equivalent from the passed-in <code>NSEvent</code> object using the <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/charactersIgnoringModifiers" target="_top">charactersIgnoringModifiers</a></code> method and then examine them to determine if they are a key equivalent it recognizes. It handles the key equivalent much as it would handle a key event in <code>keyDown:</code> (see <span class="content_text"><a href="HandlingKeyEvents.html#//apple_ref/doc/uid/10000060i-CH7-SW2">“Overriding the keyDown: Method”</a></span>). After handling the key equivalent, the implementation should return <code>YES</code>. If it doesn’t handle the key equivalent, it should either invoke the superclass implementation of <code>performKeyEquivalent:</code> or (if you know the superclass doesn’t handle the key equivalent) return <code>NO</code> to indicate that the key equivalent should be passed further down the view hierarchy or to the menus in the menu bar. </p><a name="//apple_ref/doc/uid/10000060i-CH7-SW9" title="Keyboard Interface Control"></a><h2>Keyboard Interface Control</h2><p>The Cocoa event-dispatch architecture treats certain key events as commands to move control focus to a different user-interface object in a window, to simulate a mouse click on an object, to dismiss modal windows, and to make selections in objects that allow selections. This capability is called keyboard interface control. Most of the user-interface objects involved in keyboard interface control are <code><a href="../../../Reference/ApplicationKit/Classes/NSControl_Class/Reference/Reference.html#//apple_ref/occ/cl/NSControl" target="_top">NSControl</a></code> objects, but objects that aren’t controls can participate as well. When an object has control focus, the Application Kit draws a light-blue key-focus ring around the object’s border. If full keyboard access is enabled, the keys listed in <span class="content_text">Table 5-1</span> have the stated effect.</p><a name="//apple_ref/doc/uid/10000060i-CH7-SW7" title="Table 5-1Keys used in keyboard interface control"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 5-1&nbsp;&nbsp;</strong>Keys used in keyboard interface control</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Key</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Effect</p></th></tr><tr><td  scope="row"><p>Tab</p></td><td ><p>Move to next key view.</p></td></tr><tr><td  scope="row"><p>Shift-Tab</p></td><td ><p>Move to previous key view.</p></td></tr><tr><td  scope="row"><p>Space</p></td><td ><p>Select, as with mouse click in a check box (for example), or toggle state. In selection lists, selects or deselects highlighted item.</p></td></tr><tr><td  scope="row"><p>Arrow keys</p></td><td ><p>Move within compound view, such as <code><a href="../../../Reference/ApplicationKit/Classes/NSForm_Class/Reference/Reference.html#//apple_ref/occ/cl/NSForm" target="_top">NSForm</a></code> objects.</p></td></tr><tr><td  scope="row"><p>Control-Tab (Control-Shift-Tab)</p></td><td ><p>Go to next (previous) key view from views where tab characters have other significance (for example, <code><a href="../../../Reference/ApplicationKit/Classes/NSTextView_Class/Reference/Reference.html#//apple_ref/occ/cl/NSTextView" target="_top">NSTextView</a></code> objects). </p></td></tr><tr><td  scope="row"><p>Option or Shift</p></td><td ><p>Extend the selection, not affecting other selected items.</p></td></tr></table></div><p>Some objects found on Interface Builder palettes do not participate in keyboard interface control, such as <code><a href="../../../Reference/ApplicationKit/Classes/NSImageView_Class/Reference/Reference.html#//apple_ref/occ/cl/NSImageView" target="_top">NSImageView</a></code>, <code><a href="../../../Reference/WebKit/Classes/WebView_Class/Reference/Reference.html#//apple_ref/occ/cl/WebView" target="_top">WebView</a></code>, and <code><a href="../../../../GraphicsImaging/Reference/QuartzFramework/Classes/PDFView_Class/Reference/Reference.html#//apple_ref/occ/cl/PDFView" target="_top">PDFView</a></code> objects.</p><p>In addition to the key view loop, a window can have a default button cell, which uses the Return (or Enter) key as its key equivalent. Programmatically, you can send <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/instm/NSWindow/setDefaultButtonCell:" target="_top">setDefaultButtonCell:</a></code> to an <code>NSWindow</code> object to set this button cell; you can also set it in Interface Builder by setting a button cell’s key equivalent to ‘<code>\r</code>’ in the Attributes pane of the Get Info window. The default button cell draws itself as a focal element for keyboard interface control unless another button cell is focused on. In this case, it temporarily draws itself as normal and disables its key equivalent. The Escape key is another default key for a keyboard interface control in a window; it immediately aborts a modal loop.</p><p>The user-interface objects that are connected together in a window make up the window’s key view loop. A key view loop is a sequence of <code>NSView</code> objects connected to each other through their <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/nextKeyView" target="_top">nextKeyView</a></code> property (the <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/previousKeyView" target="_top">previousKeyView</a></code> property when going in reverse direction). The last view in this sequence “loops” back to the first view. By default, <code>NSWindow</code> assigns an initial first responder and constructs a key view loop with the objects it finds. If you want greater control over the key view loop you should set it up using Interface Builder. See the Help pages for Interface Builder for details of the procedure.</p><p>For its instances to participate in key-view loops, a custom view must return <code>YES</code> from <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/acceptsFirstResponder" target="_top">acceptsFirstResponder</a></code>. By doing so, it affects the value returned by the <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/canBecomeKeyView" target="_top">canBecomeKeyView</a></code> method.  The <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/acceptsFirstResponder" target="_top">acceptsFirstResponder</a></code> method controls whether a responder accepts first responder status when its window asks it to (that is, when makeFirstResponder: is called with the responder as the parameter). The <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/canBecomeKeyView" target="_top">canBecomeKeyView</a></code> method controls whether the Application Kit allows tabbing to a view. It calls <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/acceptsFirstResponder" target="_top">acceptsFirstResponder</a></code>, but it also checks for other information before determining the value to return, such as whether the view is hidden and whether full keyboard access is on. The <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/canBecomeKeyView" target="_top">canBecomeKeyView</a></code> method is rarely overridden while <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/acceptsFirstResponder" target="_top">acceptsFirstResponder</a></code> is frequently overridden.</p><p>The <code>NSView</code> and <code>NSWindow</code> classes define a number of methods for setting up and traversing the key view loop programmatically. <span class="content_text">Table 5-2</span> lists some of the more useful ones.</p><a name="//apple_ref/doc/uid/10000060i-CH7-SW8" title="Table 5-2Some key-view loop methods"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 5-2&nbsp;&nbsp;</strong>Some key-view loop methods</caption><tr><td  scope="row"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/nextKeyView" target="_top">nextKeyView</a></code> (<code>NSView</code>)</p><p><code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/previousKeyView" target="_top">previousKeyView</a></code> (<code>NSView</code>)</p></td><td ><p>Returns the next and previous view objects in the key view loop.</p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/setNextKeyView:" target="_top">setNextKeyView:</a></code> (<code>NSView</code>)</p></td><td ><p>Sets the next key view in the loop.</p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/instm/NSWindow/selectNextKeyView:" target="_top">selectNextKeyView:</a></code> (<code>NSWindow</code>)</p><p><code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/instm/NSWindow/selectPreviousKeyView:" target="_top">selectPreviousKeyView:</a></code> (<code>NSWindow</code>)</p></td><td ><p>Searches the view hierarchy for a candidate next (previous) key view and, if it finds one, makes it the first responder.</p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/canBecomeKeyView" target="_top">canBecomeKeyView</a></code> (<code>NSView</code>)</p></td><td ><p>Returns whether the receiver can become a key view.</p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/nextValidKeyView" target="_top">nextValidKeyView</a></code> (<code>NSView</code>)</p><p><code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/previousValidKeyView" target="_top">previousValidKeyView</a></code> (<code>NSView</code>)</p></td><td ><p>Returns the closest view object in the key view loop that follows the receiver and accepts first responder status.</p></td></tr></table></div><p>The code in <span class="content_text">Listing 5-5</span> illustrates how one might use some of these methods to manipulate the key-view loop. </p><a name="//apple_ref/doc/uid/10000060i-CH7-SW10" title="Listing 5-5Manipulating the key-view loop"></a><p class="codesample"><strong>Listing 5-5&nbsp;&nbsp;</strong>Manipulating the key-view loop</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)textDidEndEditing:(NSNotification *)notification {<span></span></pre></td></tr><tr><td scope="row"><pre>    NSTextView *text = [notification object];<span></span></pre></td></tr><tr><td scope="row"><pre>    unsigned whyEnd = [[[notification userInfo] objectForKey:@"NSTextMovement"] unsignedIntValue];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSTextView *newKeyView = text;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Unscroll the previous text.<span></span></pre></td></tr><tr><td scope="row"><pre>    [text scrollRangeToVisible:NSMakeRange(0, 0)];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (whyEnd == NSTabTextMovement) {<span></span></pre></td></tr><tr><td scope="row"><pre>        newKeyView = (NSTextView *)[text nextKeyView];<span></span></pre></td></tr><tr><td scope="row"><pre>    } else if (whyEnd == NSBacktabTextMovement) {<span></span></pre></td></tr><tr><td scope="row"><pre>        newKeyView = (NSTextView *)[text previousKeyView];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Set the new key view and select its whole contents.<span></span></pre></td></tr><tr><td scope="row"><pre>    [[text window] makeFirstResponder:newKeyView];<span></span></pre></td></tr><tr><td scope="row"><pre>    [newKeyView setSelectedRange:NSMakeRange(0, [[newKeyView textStorage] length])];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p></p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../HandlingMouseEvents/HandlingMouseEvents.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../TrackingAreaObjects/TrackingAreaObjects.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-02-04<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/EventOverview/HandlingKeyEvents/HandlingKeyEvents.html%3Fid%3D10000060i-5.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/EventOverview/HandlingKeyEvents/HandlingKeyEvents.html%3Fid%3D10000060i-5.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/EventOverview/HandlingKeyEvents/HandlingKeyEvents.html%3Fid%3D10000060i-5.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>