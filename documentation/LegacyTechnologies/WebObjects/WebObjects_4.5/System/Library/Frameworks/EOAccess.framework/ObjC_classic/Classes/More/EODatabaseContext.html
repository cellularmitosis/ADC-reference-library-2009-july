<HTML>		<HEAD>		<TITLE>					</TITLE>		</HEAD>	<body bgcolor="#ffffff"><!--start of banner --><!--#include virtual="/includes/framesetheader" --><!-- end of banner --><!--start of path --><font face="Geneva,Helvetica,Arial" size="1"><b>PATH<spacer type="horizontal" size="5">&nbsp;</b> <a href="../../../../../../../webobjects.html" target="_top">WebObjects 4.5 Documentation</a> <b>&gt;</b>EOAccess Reference</font><br><br><!--end of path --><a href="../../EOAccessTOC.html"><img src="../../../../../../../images/up.gif" border="0" alt="Table of Contents"></a> <a name = "EODatabaseContext"><h1><FONT COLOR=\"#000066\"><a name="//apple_ref/occ/cl/EODatabaseContext">EODatabaseContext</a></FONT></h1><br></a><br><a name = "BGJEBBCH"><h2>EODatabaseContext's Interactionwith Other Classes</h2></a><p>The relationship between EODatabaseContext and other classesin the control and access layers is illustrated in  <a frame= "conv" href="#CEFEEAAI">Figure 0-3</a>.</p><center><a name = "CEFEEAAI"><p><b>The Role of anEODatabaseContext</b></p></a><img src = "../Art/DbcnTxt.GIF" alt = "[image: ../Art/DbcnTxt.eps]"></center><p>As a subclass of EOCooperatingObjectStore, EODatabaseContextacts as one of possibly several EOCooperatingObjectStores for anEOObjectStoreCoordinator, which mediates between EOEditingContextsand EOCooperatingObjectStores. (EOObjectStore, EOCooperatingObjectStore,and EOObjectStoreCoordinator are provided by the control layer.)</p><p>An EODatabaseContext creates an EOAdaptorContext when initialized,and uses this object to communicate with the database server.</p><br><a name = "BGJBBGFF"><h2>Creating and Using an EODatabaseContext</h2></a><p>Though you can create an EODatabaseContext explicitly by usingthe class method  <a frame= "conv" href="../EODatabaseContext.html#//apple_ref/occ/clm/EODatabaseContext/registeredDatabaseContextForModel:editingContext:">registeredDatabaseContextForModel:editingContext:</a>,you should rarely need to do so. If you're using the "higher-level"objects EOEditingContexts (EOControl) and EODatabaseDataSources,the database contexts those objects need are created automatically,on demand. When you create database data source (typically for usewith a display group-the interface layer's EODisplayGroup orWebObject's WODisplayGroup), it registers a database context that'scapable of fetching objects for the data source's entities. Ifobjects fetched into an editing context (described more in the followingsection) have references to objects from EOModels that are basedon another database, an EODatabaseContext is creates and registeredfor each of the additional databases.</p><p>EODatabaseContexts are created on demand when an EOObjectStoreCoordinator(EOControl) posts an <code>EOCooperatingObjectStoreNeeded</code> notification.The EODatabaseContext class registers for the notification, andit provides the coordinator with a new EODatabaseContext instancethat can handle the request. For more discussion of this topic,see the chapter "Application Configurations" in the <i>EnterpriseObjects Framework Developer's Guide</i>.</p><p>For the most part, you don't need to programmatically interactwith an EODatabaseContext. However, some of the reasons you mightwant to are as follows:</p><ul><li>To implement your own locking strategy, eitherapplication-wide, or on a per-fetch basis. This is described inthe section  <a frame= "conv" href="#CCJCGJAG">"Updating And Locking Strategies" </a>.</li><li>To do performance tuning, which is described in the section  <a frame= "conv" href="#BGJDIIGI">"Faulting" </a>.</li><li>To intervene when objects are created and fetched to providecustom behavior. This is described in the section  <a frame= "conv" href="#BGJCJCCE">"Delegate Methods" </a>,and in the individual delegate method descriptions in the section  <a frame= "conv" href="../../Protocols/EODatabaseContextDelegate.html#CFBBBAJG">"Instance Methods" (page 462)</a>.</li></ul><br><a name = "BGJBDBIE"><h2>Fetching and Saving Objects</h2></a><p>Conceptually, an EODatabaseContext fetches and saves objectson behalf of an EOEditingContext (EOControl). However, the two objectsdon't interact with each other directly-an EOObjectStoreCoordinator(EOControl) acts as a mediator between them. The relationship between EOEditingContext,EOObjectStoreCoordinator, and EODatabaseContext is illustrated in  <a frame= "conv" href="#CEFEBIJA">Figure 0-4</a>. Thisconfiguration includes one EOObjectStoreCoordinator, and can includeone or more EOEditingContexts, and one or more EODatabaseContexts.</p><center><a name = "CEFEBIJA"><p><b>EOEditingContexts,EOObjectStoreCoordinators, and EODatabaseContexts</b></p></a><img src = "../Art/DBBASC2.GIF" alt = "[image: ../Art/DBBASC2.eps]"></center><p>When an editing context fetches objects, the request is passedthrough the coordinator, which forwards it to the appropriate databasecontext based on the fetch specification or global ID. When thedatabase context receives a request to fetch or write informationto the database, it tries to use one of its EODatabaseChannels.If all of its channels are busy, it broadcasts an  <a frame= "conv" href="../EODatabaseContext.html#DAGDFDFF">EODatabaseChannelNeededNotification</a> inthe hopes that an observer can provide a new channel or that anexisting channel can be freed up. This observer could be a managerthat decides how many database cursors can be opened by a particularclient.</p><p>EODatabaseContext knows how to interact with other EOCooperatingObjectStoresto save changes made to an object graph in more than one databaseserver. For a more detailed discussion of this subject, see theclass specifications for EOObjectStoreCoordinator and EOCooperatingObjectStore.</p><br><a name = "BGJDIBIG"><h2>Using a Custom Query</h2></a><p>EODatabaseContext defines a hint for use with an EOFetchSpecification(EOControl) in the  <a frame= "conv" href="../EODatabaseContext.html#//apple_ref/occ/instm/EODatabaseContext/objectsWithFetchSpecification:editingContext:">objectsWithFetchSpecification:editingContext:</a> method.Named by the key <code>EOCustomQueryExpressionHintKey</code>,the hint's value is a SQL string for performing the fetch. The expressionmust query the same attributes in the same order that EnterpriseObjects Framework would if it were generating the SELECT expressiondynamically. If this key is supplied, other characteristics of theEOFetchSpecification such as <b>isDeep</b>, <b>qualifier</b>,and <b>sortOrderings</b> are ignored-in thatsense this key is more of a directive than a hint. For more informationon hint keys, see the method description for <b>objectsWithFetchSpecification:editingContext:</b>.</p><br><a name = "BGJDIIGI"><h2>Faulting</h2></a><p>When an EODatabaseContext fetches an object, it examines therelationships defined in the model and creates objects representingthe destinations of the fetched object's relationships. For example,if you fetch an employee object, you can ask for its manager andimmediately receive an object; you don't have to get the manager'semployee ID from the object you just fetched and fetch the manageryourself.</p><p>However, EODatabaseContext doesn't immediately fetch datafor the destination objects of relationships since fetching is fairlyexpensive. To avoid this waste of time and resources, the destinationobjects are created as EOFault objects which act as placeholders.EOFaults (or faults) come in two varieties: single object faultsfor to-one relationships, and array faults for to-many relationships.</p><p>When an EOFault is accessed (sent a message), it triggersits EODatabaseContext to fetch its data and transform it into aninstance of the appropriate object class. This preserves both theobject's <b>id</b> and its EOGlobalID.</p><p>You can fine-tune faulting behavior for additional performancegains by using two different mechanisms: batch faulting, and prefetchingrelationships.</p><br><h2>Batch Faulting</h2><p>When you access a fault, its data is fetched from the database.However, triggering one fault has no effect on other faults-itjust fetches the object or array of objects for the one fault. Youcan take advantage of this expensive round trip to the databaseserver by batching faults together. EODatabaseContext provides the  <a frame= "conv" href="../EODatabaseContext.html#//apple_ref/occ/instm/EODatabaseContext/batchFetchRelationship:forSourceObjects:editingContext:">batchFetchRelationship:forSourceObjects:editingContext:</a> method fordoing this. For example, given an array of Employee objects, thismethod can fetch all of their departments with one round trip tothe server, rather than asking the server for each of the employee's departmentsindividually. You can use the delegate methods <a frame= "conv" href="../../Protocols/EODatabaseContextDelegate.html#//apple_ref/occ/intfm/EODatabaseContext Delegate/databaseContext:shouldFetchArrayFault:">databaseContext:shouldFetchArrayFault:</a> and <a frame= "conv" href="../../Protocols/EODatabaseContextDelegate.html#//apple_ref/occ/intfm/EODatabaseContext Delegate/databaseContext:shouldFetchObjectFault:">databaseContext:shouldFetchObjectFault:</a> tofine-tune batch faulting behavior.</p><p>You can also set batch faulting in an EOModel. In that approach,you specify the <em>number</em> of faultsthat should be triggered along with the first fault; you don'tactually control which faults are triggered the way you do with <b>batchFetchRelationship:forSourceObjects:editingContext:</b>.For more information on setting batch faulting in an EOModel, seethe book <i>Enterprise Objects Framework Tools and Techniques</i>.</p><br><a name = "BGJCJCCE"><h2>Delegate Methods</h2></a><p>An EODatabaseContext shares its delegate with its EODatabaseChannels.These delegate methods are actually sent from EODatabaseChannel,but they're defined in EODatabaseContext for ease of access:</p><p>You can use the EODatabaseContext delegate methods to intervenewhen objects are created and when they're fetched from the database.This gives you more fine-grained control over such issues as howan object's primary key is generated ( <a frame= "conv" href="../../Protocols/EODatabaseContextDelegate.html#//apple_ref/occ/intfm/EODatabaseContext Delegate/databaseContext:newPrimaryKeyForObject:entity:">databaseContext:newPrimaryKeyForObject:entity:</a>),how and if objects are locked ( <a frame= "conv" href="../../Protocols/EODatabaseContextDelegate.html#//apple_ref/occ/intfm/EODatabaseContext Delegate/databaseContext:shouldLockObjectWithGlobalID:snapshot:">databaseContext:shouldLockObjectWithGlobalID:snapshot:</a>),what fetch specification is used to fetch objects ( <a frame= "conv" href="../../Protocols/EODatabaseContextDelegate.html#//apple_ref/occ/intfm/EODatabaseContext Delegate/databaseContext:shouldSelectObjectsWithFetchSpecification:databaseChannel:">databaseContext:shouldSelectObjectsWithFetchSpecification:databaseChannel:</a>),how batch faulting is performed ( <a frame= "conv" href="../../Protocols/EODatabaseContextDelegate.html#//apple_ref/occ/intfm/EODatabaseContext Delegate/databaseContext:shouldFetchArrayFault:">databaseContext:shouldFetchArrayFault:</a> and  <a frame= "conv" href="../../Protocols/EODatabaseContextDelegate.html#//apple_ref/occ/intfm/EODatabaseContext Delegate/databaseContext:shouldFetchObjectFault:">databaseContext:shouldFetchObjectFault:</a>),and so on. For more information, see the individual delegate methoddescriptions in the section  <a frame= "conv" href="../../Protocols/EODatabaseContextDelegate.html#CFBBBAJG">"Instance Methods" (page 462)</a>.</p><br><a name = "BGJDCJAF"><h2>Snapshots</h2></a><p>An EODatabase records snapshots for its EODatabaseContexts.These snapshots form the application's view of the current stateof the database server. This global view is overridden locally bydatabase contexts, which form their own snapshots as they make changesduring a transaction. When a database context commits its top-leveltransaction, it reconciles all changed snapshots with the globalview of the database object, so that other database contexts (exceptthose with open transactions) immediately use the new snapshotsas well.</p><br><a name = "CCJCGJAG"><h2>Updating And Locking Strategies</h2></a><p>EODatabaseContext supports three updating strategies defined bythe EOUpdateStrategy type as integer values:</p><br><table border = \"1\"><tr><td scope="row"><b>Type</b></td><td><b>Description</b></td></tr><tr><td scope="row"><code>EOUpdateWithOptimisticLocking</code></td><td>Thedefault update strategy. Under optimistic locking, objects aren'tlocked immediately on being fetched from the server. Instead, wheneveryou attempt to save updates to an object in the database, the object'ssnapshot is used to ensure that the values in the correspondingdatabase row haven't changed since the object was fetched. As longas the snapshot matches the values in the database, the update isallowed to proceed.</td></tr><tr><td scope="row"><code>EOUpdateWithPessimisticLocking</code></td><td>Causesobjects to be locked in the database when they're selected. Thisensures that no one else can modify the objects until the transactionends. However, this doesn't necessarily mean that either the selector the update operation will succeed.</td></tr><tr><td scope="row"><code>EOUpdateWithNoLocking</code></td><td>Objectsare never locked. No comparisons are made between the snapshot andthe row to ensure that the values in the corresponding databaserow haven't changed since the object was fetched.</td></tr></table><br><p>EODatabaseContext also supports "on-demand" locking, inwhich specific optimistic locks can be promoted to database locksduring the course of program execution. You can either use  <a frame= "conv" href="../EODatabaseContext.html#//apple_ref/occ/instm/EODatabaseContext/lockObjectWithGlobalID:editingContext:">lockObjectWithGlobalID:editingContext:</a> tolock a database row for a particular object, or  <a frame= "conv" href="../EODatabaseContext.html#//apple_ref/occ/instm/EODatabaseContext/objectsWithFetchSpecification:editingContext:">objectsWithFetchSpecification:editingContext:</a> tofetch objects with a fetch specification that includes locking. </p><p>For more discussion of locking strategies, see the chapter"Behind the Scenes" in the <i>Enterprise Objects FrameworkDeveloper's Guide</i>.</p><dd></dd><br><a href="../../EOAccessTOC.html"><img src="../../../../../../../images/up.gif" border="0" alt="Table of Contents"></a> </BODY></HTML>