<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/1998/REC-html40-19980424/loose.dtd">
<html><head>
    <title>DNS Service Discovery</title>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
 <meta name="generator" content="HeaderDoc" />
<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css">
<style type="text/css"><!--.keyword {background:#ffffff; color:#761550;}.template {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.function {background:#ffffff; color:#000000;}.string {background: #ffffff; color:#891315;}.preprocessor {background:#ffffff; color:#236e25}.comment {background:#ffffff; color:#236e25}.char {background: #ffffff; color:#0000ff;}.var {background:#ffffff; color:#000000;}.type {background:#ffffff; color:#761550;}.param {background:#ffffff; color:#000000;}.graybox {         border-top: 1px solid #919699;         border-left: 1px solid #919699;         margin-bottom: 10px;         }  .graybox th {         padding: 4px 8px 4px 8px;         background: #E2E2E2;         font-size: 12px;         font-weight: bold;         border-bottom: 1px solid #919699;         border-right: 1px solid #919699;         }  .graybox td {         padding: 8px;         font-size: 12px;         text-align: left;         vertical-align: top;         border-bottom: 1px solid #919699;         border-right: 1px solid #919699;         }  --></style></head><body bgcolor="#ffffff">
<!-- start of header -->

<!-- start of header -->
<!--#include virtual="/includes/framesetheader"-->
<!-- end of header -->

<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <a href="../../../../../reference/Networking/index.html#//apple_ref/doc/uid/TP30001281-TP30000429" target="_top">Networking</a> <b>&gt;</b> <a href="../../../../../reference/Networking/idxBonjour-date.html#//apple_ref/doc/uid/TP30001281-TP30000429-TP30000566" target="_top">Bonjour</a> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/dns_service_discovery" target="_top">DNS Service Discovery API Reference for C</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>


<!-- end of header -->
<a name="top"></a>
<a name="//apple_ref/doc/header/dns_sd.h" title="DNS Service Discovery"></a>
<hr><table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h1><a name="DNSServiceDiscovery">DNS Service Discovery</a></h1>
</td></tr></table><div class="spec_sheet_info_box"><table cellspacing="0" class="specbox">
<tr><td scope="row"><b>Includes:</b></td><td><div style="margin-bottom:1px"><div class="content_text"><a href="../../../../Darwin/Reference/usr_APIs/types/index.html#//apple_ref/doc/header/types.h" target="_top">&lt;sys/types.h&gt;</a><br>
<a href="../../../../Darwin/Reference/usr_APIs/types/index.html#//apple_ref/doc/header/types.h" target="_top">&lt;sys/types.h&gt;</a><br>
<!-- a -->&lt;windows.h&gt;<!-- /a --><br>
<!-- a -->&lt;stdint.h&gt;<!-- /a --></div></div></td></tr>
</table></div>
<h2>Overview</h2>
</h5><p><!-- begin discussion -->This section describes the functions, callbacks, and data structures
that make up the DNS Service Discovery API.
<br><br>
The DNS Service Discovery API is part of Bonjour, Apple's implementation
of zero-configuration networking (ZEROCONF).
<br><br>
Bonjour allows you to register a network service, such as a
printer or file server, so that it can be found by name or browsed
for by service type and domain. Using Bonjour, applications can
discover what services are available on the network, along with
all the information -- such as name, IP address, and port --
necessary to access a particular service.
<br><br>
In effect, Bonjour combines the functions of a local DNS server and
AppleTalk. Bonjour allows applications to provide user-friendly printer
and server browsing, among other things, over standard IP networks.
This behavior is a result of combining protocols such as multicast and
DNS to add new functionality to the network (such as multicast DNS).
<br><br>
Bonjour gives applications easy access to services over local IP
networks without requiring the service or the application to support
an AppleTalk or a Netbeui stack, and without requiring a DNS server
for the local network.
 <!-- end discussion --></p>
<hr><br><h2>Functions</h2>
<a name="HeaderDoc_functions"></a>
<dl>
<dt><tt><a href="CompositePage.html#//apple_ref/c/func/DNSServiceAddRecord" target="doc">DNSServiceAddRecord</a></tt></dt>
<dd></dd>
<dt><tt><a href="CompositePage.html#//apple_ref/c/func/DNSServiceBrowse" target="doc">DNSServiceBrowse</a></tt></dt>
<dd></dd>
<dt><tt><a href="CompositePage.html#//apple_ref/c/func/DNSServiceConstructFullName" target="doc">DNSServiceConstructFullName</a></tt></dt>
<dd></dd>
<dt><tt><a href="CompositePage.html#//apple_ref/c/func/DNSServiceCreateConnection" target="doc">DNSServiceCreateConnection</a></tt></dt>
<dd></dd>
<dt><tt><a href="CompositePage.html#//apple_ref/c/func/DNSServiceEnumerateDomains" target="doc">DNSServiceEnumerateDomains</a></tt></dt>
<dd></dd>
<dt><tt><a href="CompositePage.html#//apple_ref/c/func/DNSServiceGetAddrInfo" target="doc">DNSServiceGetAddrInfo</a></tt></dt>
<dd></dd>
<dt><tt><a href="CompositePage.html#//apple_ref/c/func/DNSServiceGetProperty" target="doc">DNSServiceGetProperty</a></tt></dt>
<dd></dd>
<dt><tt><a href="CompositePage.html#//apple_ref/c/func/DNSServiceNATPortMappingCreate" target="doc">DNSServiceNATPortMappingCreate</a></tt></dt>
<dd></dd>
<dt><tt><a href="CompositePage.html#//apple_ref/c/func/DNSServiceProcessResult" target="doc">DNSServiceProcessResult</a></tt></dt>
<dd></dd>
<dt><tt><a href="CompositePage.html#//apple_ref/c/func/DNSServiceQueryRecord" target="doc">DNSServiceQueryRecord</a></tt></dt>
<dd></dd>
<dt><tt><a href="CompositePage.html#//apple_ref/c/func/DNSServiceReconfirmRecord" target="doc">DNSServiceReconfirmRecord</a></tt></dt>
<dd></dd>
<dt><tt><a href="CompositePage.html#//apple_ref/c/func/DNSServiceRefDeallocate" target="doc">DNSServiceRefDeallocate</a></tt></dt>
<dd></dd>
<dt><tt><a href="CompositePage.html#//apple_ref/c/func/DNSServiceRefSockFD" target="doc">DNSServiceRefSockFD</a></tt></dt>
<dd></dd>
<dt><tt><a href="CompositePage.html#//apple_ref/c/func/DNSServiceRegister" target="doc">DNSServiceRegister</a></tt></dt>
<dd></dd>
<dt><tt><a href="CompositePage.html#//apple_ref/c/func/DNSServiceRegisterRecord" target="doc">DNSServiceRegisterRecord</a></tt></dt>
<dd></dd>
<dt><tt><a href="CompositePage.html#//apple_ref/c/func/DNSServiceRemoveRecord" target="doc">DNSServiceRemoveRecord</a></tt></dt>
<dd></dd>
<dt><tt><a href="CompositePage.html#//apple_ref/c/func/DNSServiceResolve" target="doc">DNSServiceResolve</a></tt></dt>
<dd></dd>
<dt><tt><a href="CompositePage.html#//apple_ref/c/func/DNSServiceUpdateRecord" target="doc">DNSServiceUpdateRecord</a></tt></dt>
<dd></dd>
<dt><tt><a href="CompositePage.html#//apple_ref/c/func/TXTRecordContainsKey" target="doc">TXTRecordContainsKey</a></tt></dt>
<dd></dd>
<dt><tt><a href="CompositePage.html#//apple_ref/c/func/TXTRecordCreate" target="doc">TXTRecordCreate</a></tt></dt>
<dd></dd>
<dt><tt><a href="CompositePage.html#//apple_ref/c/func/TXTRecordDeallocate" target="doc">TXTRecordDeallocate</a></tt></dt>
<dd></dd>
<dt><tt><a href="CompositePage.html#//apple_ref/c/func/TXTRecordGetBytesPtr" target="doc">TXTRecordGetBytesPtr</a></tt></dt>
<dd></dd>
<dt><tt><a href="CompositePage.html#//apple_ref/c/func/TXTRecordGetCount" target="doc">TXTRecordGetCount</a></tt></dt>
<dd></dd>
<dt><tt><a href="CompositePage.html#//apple_ref/c/func/TXTRecordGetItemAtIndex" target="doc">TXTRecordGetItemAtIndex</a></tt></dt>
<dd></dd>
<dt><tt><a href="CompositePage.html#//apple_ref/c/func/TXTRecordGetLength" target="doc">TXTRecordGetLength</a></tt></dt>
<dd></dd>
<dt><tt><a href="CompositePage.html#//apple_ref/c/func/TXTRecordGetValuePtr" target="doc">TXTRecordGetValuePtr</a></tt></dt>
<dd></dd>
<dt><tt><a href="CompositePage.html#//apple_ref/c/func/TXTRecordRemoveValue" target="doc">TXTRecordRemoveValue</a></tt></dt>
<dd></dd>
<dt><tt><a href="CompositePage.html#//apple_ref/c/func/TXTRecordSetValue" target="doc">TXTRecordSetValue</a></tt></dt>
<dd></dd>
</dl>
<hr><!-- headerDoc=func;  uid=//apple_ref/c/func/DNSServiceAddRecord;  name=DNSServiceAddRecord -->
<a name="//apple_ref/c/func/DNSServiceAddRecord"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="DNSServiceAddRecord">DNSServiceAddRecord</a></h3>
</td></tr></table><hr><p></p><pre><!-- a --><span class="type">DNSServiceErrorType</span><!-- /a --> <a href="CompositePage.html#//apple_ref/c/func/DNSServiceAddRecord" class="function"><span class="function">DNSServiceAddRecord</span></a> ( 
    <!-- a --><span class="type">DNSServiceRef</span><!-- /a --> <span class="param">sdRef</span>, 
    <!-- a --><span class="type">DNSRecordRef</span><!-- /a --> *<span class="param">RecordRef</span>, 
    <!-- a --><span class="type">DNSServiceFlags</span><!-- /a --> <span class="param">flags</span>, 
    <!-- a --><span class="type">uint16_t</span><!-- /a --> <span class="param">rrtype</span>, 
    <!-- a --><span class="type">uint16_t</span><!-- /a --> <span class="param">rdlen</span>, 
    <span class="keyword">const</span> <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> *<span class="param">rdata</span>, 
    <!-- a --><span class="type">uint32_t</span><!-- /a --> <span class="param">ttl</span> );  </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->DNSServiceAddRecord()
<br><br>
Add a record to a registered service. The name of the record will be the same as the
registered service's name.
The record can later be updated or deregistered by passing the RecordRef initialized
by this function to DNSServiceUpdateRecord() or DNSServiceRemoveRecord().
<br><br>
Note that the DNSServiceAddRecord/UpdateRecord/RemoveRecord are *NOT* thread-safe
with respect to a single DNSServiceRef. If you plan to have multiple threads
in your program simultaneously add, update, or remove records from the same
DNSServiceRef, then it's the caller's responsibility to use a mutext lock
or take similar appropriate precautions to serialize those calls.
<br><br>
<br><br>
Parameters;
<br><br>
sdRef:           A DNSServiceRef initialized by DNSServiceRegister().
<br><br>
RecordRef:       A pointer to an uninitialized DNSRecordRef. Upon succesfull completion of this
call, this ref may be passed to DNSServiceUpdateRecord() or DNSServiceRemoveRecord().
If the above DNSServiceRef is passed to DNSServiceRefDeallocate(), RecordRef is also
invalidated and may not be used further.
<br><br>
flags:           Currently ignored, reserved for future use.
<br><br>
rrtype:          The type of the record (e.g. kDNSServiceType_TXT, kDNSServiceType_SRV, etc)
<br><br>
rdlen:           The length, in bytes, of the rdata.
<br><br>
rdata:           The raw rdata to be contained in the added resource record.
<br><br>
ttl:             The time to live of the resource record, in seconds. Pass 0 to use a default value.
<br><br>
return value:    Returns kDNSServiceErr_NoError on success, otherwise returns an
error code indicating the error that occurred (the RecordRef is not initialized).
 <!-- end discussion --></p>
<p></p><hr><!-- headerDoc=func;  uid=//apple_ref/c/func/DNSServiceBrowse;  name=DNSServiceBrowse -->
<a name="//apple_ref/c/func/DNSServiceBrowse"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="DNSServiceBrowse">DNSServiceBrowse</a></h3>
</td></tr></table><hr><p></p><pre><!-- a --><span class="type">DNSServiceErrorType</span><!-- /a --> <a href="CompositePage.html#//apple_ref/c/func/DNSServiceBrowse" class="function"><span class="function">DNSServiceBrowse</span></a> ( 
    <!-- a --><span class="type">DNSServiceRef</span><!-- /a --> *<span class="param">sdRef</span>, 
    <!-- a --><span class="type">DNSServiceFlags</span><!-- /a --> <span class="param">flags</span>, 
    <!-- a --><span class="type">uint32_t</span><!-- /a --> <span class="param">interfaceIndex</span>, 
    <span class="keyword">const</span> <!-- a --><span class="type">char</span><!-- /a --> *<span class="param">regtype</span>, 
    <span class="keyword">const</span> <!-- a --><span class="type">char</span><!-- /a --> *<span class="param">domain</span>, <span class="comment">/* may be NULL */</span>
    <a href="CompositePage.html#//apple_ref/c/tdef/DNSServiceBrowseReply" class="type"><span class="type">DNSServiceBrowseReply</span></a> <span class="param">callBack</span>, 
    <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> *<span class="param">context</span> <span class="comment">/* may be NULL */</span>
    );  </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->DNSServiceBrowse() Parameters:
<br><br>
sdRef:           A pointer to an uninitialized DNSServiceRef. If the call succeeds
then it initializes the DNSServiceRef, returns kDNSServiceErr_NoError,
and the browse operation will run indefinitely until the client
terminates it by passing this DNSServiceRef to DNSServiceRefDeallocate().
<br><br>
flags:           Currently ignored, reserved for future use.
<br><br>
interfaceIndex:  If non-zero, specifies the interface on which to browse for services
(the index for a given interface is determined via the if_nametoindex()
family of calls.) Most applications will pass 0 to browse on all available
interfaces. See "Constants for specifying an interface index" for more details.
<br><br>
regtype:         The service type being browsed for followed by the protocol, separated by a
dot (e.g. "_ftp._tcp"). The transport protocol must be "_tcp" or "_udp".
A client may optionally specify a single subtype to perform filtered browsing:
e.g. browsing for "_primarytype._tcp,_subtype" will discover only those
instances of "_primarytype._tcp" that were registered specifying "_subtype"
in their list of registered subtypes.
<br><br>
domain:          If non-NULL, specifies the domain on which to browse for services.
Most applications will not specify a domain, instead browsing on the
default domain(s).
<br><br>
callBack:        The function to be called when an instance of the service being browsed for
is found, or if the call asynchronously fails.
<br><br>
context:         An application context pointer which is passed to the callback function
(may be NULL).
<br><br>
return value:    Returns kDNSServiceErr_NoError on success (any subsequent, asynchronous
errors are delivered to the callback), otherwise returns an error code indicating
the error that occurred (the callback is not invoked and the DNSServiceRef
is not initialized).
 <!-- end discussion --></p>
<p></p><hr><!-- headerDoc=func;  uid=//apple_ref/c/func/DNSServiceConstructFullName;  name=DNSServiceConstructFullName -->
<a name="//apple_ref/c/func/DNSServiceConstructFullName"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="DNSServiceConstructFullName">DNSServiceConstructFullName</a></h3>
</td></tr></table><hr><p></p><pre><!-- a --><span class="type">int</span><!-- /a --> <a href="CompositePage.html#//apple_ref/c/func/DNSServiceConstructFullName" class="function"><span class="function">DNSServiceConstructFullName</span></a> ( 
    <!-- a --><span class="type">char</span><!-- /a --> *<span class="param">fullName</span>, 
    <span class="keyword">const</span> <!-- a --><span class="type">char</span><!-- /a --> *<span class="param">service</span>, <span class="comment">/* may be NULL */</span>
    <span class="keyword">const</span> <!-- a --><span class="type">char</span><!-- /a --> *<span class="param">regtype</span>, 
    <span class="keyword">const</span> <!-- a --><span class="type">char</span><!-- /a --> *<span class="param">domain</span> );  </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->DNSServiceConstructFullName()
<br><br>
Concatenate a three-part domain name (as returned by the above callbacks) into a
properly-escaped full domain name. Note that callbacks in the above functions ALREADY ESCAPE
strings where necessary.
<br><br>
Parameters:
<br><br>
fullName:        A pointer to a buffer that where the resulting full domain name is to be written.
The buffer must be kDNSServiceMaxDomainName (1005) bytes in length to
accommodate the longest legal domain name without buffer overrun.
<br><br>
service:         The service name - any dots or backslashes must NOT be escaped.
May be NULL (to construct a PTR record name, e.g.
"_ftp._tcp.apple.com.").
<br><br>
regtype:         The service type followed by the protocol, separated by a dot
(e.g. "_ftp._tcp").
<br><br>
domain:          The domain name, e.g. "apple.com.". Literal dots or backslashes,
if any, must be escaped, e.g. "1st\. Floor.apple.com."
<br><br>
return value:    Returns 0 on success, -1 on error.
<br><br>
 <!-- end discussion --></p>
<p></p><hr><!-- headerDoc=func;  uid=//apple_ref/c/func/DNSServiceCreateConnection;  name=DNSServiceCreateConnection -->
<a name="//apple_ref/c/func/DNSServiceCreateConnection"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="DNSServiceCreateConnection">DNSServiceCreateConnection</a></h3>
</td></tr></table><hr><p></p><pre><!-- a --><span class="type">DNSServiceErrorType</span><!-- /a --> <a href="CompositePage.html#//apple_ref/c/func/DNSServiceCreateConnection" class="function"><span class="function">DNSServiceCreateConnection</span></a>(
    <!-- a --><span class="type">DNSServiceRef</span><!-- /a --> *<span class="param">sdRef</span>);  </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->DNSServiceCreateConnection()
<br><br>
Create a connection to the daemon allowing efficient registration of
multiple individual records.
<br><br>
<br><br>
Parameters:
<br><br>
sdRef:           A pointer to an uninitialized DNSServiceRef. Deallocating
the reference (via DNSServiceRefDeallocate()) severs the
connection and deregisters all records registered on this connection.
<br><br>
return value:    Returns kDNSServiceErr_NoError on success, otherwise returns
an error code indicating the specific failure that occurred (in which
case the DNSServiceRef is not initialized).
 <!-- end discussion --></p>
<p></p><hr><!-- headerDoc=func;  uid=//apple_ref/c/func/DNSServiceEnumerateDomains;  name=DNSServiceEnumerateDomains -->
<a name="//apple_ref/c/func/DNSServiceEnumerateDomains"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="DNSServiceEnumerateDomains">DNSServiceEnumerateDomains</a></h3>
</td></tr></table><hr><p></p><pre><!-- a --><span class="type">DNSServiceErrorType</span><!-- /a --> <a href="CompositePage.html#//apple_ref/c/func/DNSServiceEnumerateDomains" class="function"><span class="function">DNSServiceEnumerateDomains</span></a> ( 
    <!-- a --><span class="type">DNSServiceRef</span><!-- /a --> *<span class="param">sdRef</span>, 
    <!-- a --><span class="type">DNSServiceFlags</span><!-- /a --> <span class="param">flags</span>, 
    <!-- a --><span class="type">uint32_t</span><!-- /a --> <span class="param">interfaceIndex</span>, 
    <a href="CompositePage.html#//apple_ref/c/tdef/DNSServiceDomainEnumReply" class="type"><span class="type">DNSServiceDomainEnumReply</span></a> <span class="param">callBack</span>, 
    <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> *<span class="param">context</span> <span class="comment">/* may be NULL */</span>
    );  </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->DNSServiceEnumerateDomains() Parameters:
<br><br>
<br><br>
sdRef:           A pointer to an uninitialized DNSServiceRef. If the call succeeds
then it initializes the DNSServiceRef, returns kDNSServiceErr_NoError,
and the enumeration operation will run indefinitely until the client
terminates it by passing this DNSServiceRef to DNSServiceRefDeallocate().
<br><br>
flags:           Possible values are:
kDNSServiceFlagsBrowseDomains to enumerate domains recommended for browsing.
kDNSServiceFlagsRegistrationDomains to enumerate domains recommended
for registration.
<br><br>
interfaceIndex:  If non-zero, specifies the interface on which to look for domains.
(the index for a given interface is determined via the if_nametoindex()
family of calls.) Most applications will pass 0 to enumerate domains on
all interfaces. See "Constants for specifying an interface index" for more details.
<br><br>
callBack:        The function to be called when a domain is found or the call asynchronously
fails.
<br><br>
context:         An application context pointer which is passed to the callback function
(may be NULL).
<br><br>
return value:    Returns kDNSServiceErr_NoError on success (any subsequent, asynchronous
errors are delivered to the callback), otherwise returns an error code indicating
the error that occurred (the callback is not invoked and the DNSServiceRef
is not initialized).
 <!-- end discussion --></p>
<p></p><hr><!-- headerDoc=func;  uid=//apple_ref/c/func/DNSServiceGetAddrInfo;  name=DNSServiceGetAddrInfo -->
<a name="//apple_ref/c/func/DNSServiceGetAddrInfo"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="DNSServiceGetAddrInfo">DNSServiceGetAddrInfo</a></h3>
</td></tr></table><hr><p></p><pre><!-- a --><span class="type">DNSServiceErrorType</span><!-- /a --> <a href="CompositePage.html#//apple_ref/c/func/DNSServiceGetAddrInfo" class="function"><span class="function">DNSServiceGetAddrInfo</span></a> ( 
    <!-- a --><span class="type">DNSServiceRef</span><!-- /a --> *<span class="param">sdRef</span>, 
    <!-- a --><span class="type">DNSServiceFlags</span><!-- /a --> <span class="param">flags</span>, 
    <!-- a --><span class="type">uint32_t</span><!-- /a --> <span class="param">interfaceIndex</span>, 
    <!-- a --><span class="type">DNSServiceProtocol</span><!-- /a --> <span class="param">protocol</span>, 
    <span class="keyword">const</span> <!-- a --><span class="type">char</span><!-- /a --> *<span class="param">hostname</span>, 
    <a href="CompositePage.html#//apple_ref/c/tdef/DNSServiceGetAddrInfoReply" class="type"><span class="type">DNSServiceGetAddrInfoReply</span></a> <span class="param">callBack</span>, 
    <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> *<span class="param">context</span> <span class="comment">/* may be NULL */</span>
    );  </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->DNSServiceGetAddrInfo() Parameters:
<br><br>
sdRef:           A pointer to an uninitialized DNSServiceRef. If the call succeeds then it
initializes the DNSServiceRef, returns kDNSServiceErr_NoError, and the query
begins and will last indefinitely until the client terminates the query
by passing this DNSServiceRef to DNSServiceRefDeallocate().
<br><br>
flags:           kDNSServiceFlagsForceMulticast or kDNSServiceFlagsLongLivedQuery.
Pass kDNSServiceFlagsLongLivedQuery to create a "long-lived" unicast
query in a non-local domain. Without setting this flag, unicast queries
will be one-shot - that is, only answers available at the time of the call
will be returned. By setting this flag, answers (including Add and Remove
events) that become available after the initial call is made will generate
callbacks. This flag has no effect on link-local multicast queries.
<br><br>
interfaceIndex:  The interface on which to issue the query.  Passing 0 causes the query to be
sent on all active interfaces via Multicast or the primary interface via Unicast.
<br><br>
protocol:        Pass in kDNSServiceProtocol_IPv4 to look up IPv4 addresses, or kDNSServiceProtocol_IPv6
to look up IPv6 addresses, or both to look up both kinds. If neither flag is
set, the system will apply an intelligent heuristic, which is (currently)
that it will attempt to look up both, except:
<br><br>
* If "hostname" is a wide-area unicast DNS hostname (i.e. not a ".local." name)
but this host has no routable IPv6 address, then the call will not try to
look up IPv6 addresses for "hostname", since any addresses it found would be
unlikely to be of any use anyway. Similarly, if this host has no routable
IPv4 address, the call will not try to look up IPv4 addresses for "hostname".
<br><br>
* If "hostname" is a link-local multicast DNS hostname (i.e. a ".local." name)
but this host has no IPv6 address of any kind, then it will not try to look
up IPv6 addresses for "hostname". Similarly, if this host has no IPv4 address
of any kind, the call will not try to look up IPv4 addresses for "hostname".
<br><br>
hostname:        The fully qualified domain name of the host to be queried for.
<br><br>
callBack:        The function to be called when the query succeeds or fails asynchronously.
<br><br>
context:         An application context pointer which is passed to the callback function
(may be NULL).
<br><br>
return value:    Returns kDNSServiceErr_NoError on success (any subsequent, asynchronous
errors are delivered to the callback), otherwise returns an error code indicating
the error that occurred.
 <!-- end discussion --></p>
<p></p><hr><!-- headerDoc=func;  uid=//apple_ref/c/func/DNSServiceGetProperty;  name=DNSServiceGetProperty -->
<a name="//apple_ref/c/func/DNSServiceGetProperty"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="DNSServiceGetProperty">DNSServiceGetProperty</a></h3>
</td></tr></table><hr><p></p><pre><!-- a --><span class="type">DNSServiceErrorType</span><!-- /a --> <a href="CompositePage.html#//apple_ref/c/func/DNSServiceGetProperty" class="function"><span class="function">DNSServiceGetProperty</span></a> ( 
    <span class="keyword">const</span> <!-- a --><span class="type">char</span><!-- /a --> *<span class="param">property</span>, <span class="comment">/* Requested property (i.e. kDNSServiceProperty_DaemonVersion) */</span>
    <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> *<span class="param">result</span>, <span class="comment">/* Pointer to place to store result */</span>
    <!-- a --><span class="type">uint32_t</span><!-- /a --> *<span class="param">size</span> <span class="comment">/* size of result location */</span>
    );  </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->DNSServiceGetProperty() Parameters:
<br><br>
property:        The requested property.
Currently the only property defined is kDNSServiceProperty_DaemonVersion.
<br><br>
result:          Place to store result.
For retrieving DaemonVersion, this should be the address of a uint32_t.
<br><br>
size:            Pointer to uint32_t containing size of the result location.
For retrieving DaemonVersion, this should be sizeof(uint32_t).
On return the uint32_t is updated to the size of the data returned.
For DaemonVersion, the returned size is always sizeof(uint32_t), but
future properties could be defined which return variable-sized results.
<br><br>
return value:    Returns kDNSServiceErr_NoError on success, or kDNSServiceErr_ServiceNotRunning
if the daemon (or "system service" on Windows) is not running.
 <!-- end discussion --></p>
<p></p><hr><!-- headerDoc=func;  uid=//apple_ref/c/func/DNSServiceNATPortMappingCreate;  name=DNSServiceNATPortMappingCreate -->
<a name="//apple_ref/c/func/DNSServiceNATPortMappingCreate"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="DNSServiceNATPortMappingCreate">DNSServiceNATPortMappingCreate</a></h3>
</td></tr></table><hr><p></p><pre><!-- a --><span class="type">DNSServiceErrorType</span><!-- /a --> <a href="CompositePage.html#//apple_ref/c/func/DNSServiceNATPortMappingCreate" class="function"><span class="function">DNSServiceNATPortMappingCreate</span></a> ( 
    <!-- a --><span class="type">DNSServiceRef</span><!-- /a --> *<span class="param">sdRef</span>, 
    <!-- a --><span class="type">DNSServiceFlags</span><!-- /a --> <span class="param">flags</span>, 
    <!-- a --><span class="type">uint32_t</span><!-- /a --> <span class="param">interfaceIndex</span>, 
    <!-- a --><span class="type">DNSServiceProtocol</span><!-- /a --> <span class="param">protocol</span>, <span class="comment">/* TCP and/or UDP */</span>
    <!-- a --><span class="type">uint16_t</span><!-- /a --> <span class="param">privatePort</span>, <span class="comment">/* network byte order */</span>
    <!-- a --><span class="type">uint16_t</span><!-- /a --> <span class="param">publicPort</span>, <span class="comment">/* network byte order */</span>
    <!-- a --><span class="type">uint32_t</span><!-- /a --> <span class="param">ttl</span>, <span class="comment">/* time to live in seconds */</span>
    <a href="CompositePage.html#//apple_ref/c/tdef/DNSServiceNATPortMappingReply" class="type"><span class="type">DNSServiceNATPortMappingReply</span></a> <span class="param">callBack</span>, 
    <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> *<span class="param">context</span> <span class="comment">/* may be NULL */</span>
    );  </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->DNSServiceNATPortMappingCreate() Parameters:
<br><br>
sdRef:           A pointer to an uninitialized DNSServiceRef. If the call succeeds then it
initializes the DNSServiceRef, returns kDNSServiceErr_NoError, and the nat
port mapping will last indefinitely until the client terminates the port
mapping request by passing this DNSServiceRef to DNSServiceRefDeallocate().
<br><br>
flags:           Currently ignored, reserved for future use.
<br><br>
interfaceIndex:  The interface on which to create port mappings in a NAT gateway. Passing 0 causes
the port mapping request to be sent on the primary interface.
<br><br>
protocol:        To request a port mapping, pass in kDNSServiceProtocol_UDP, or kDNSServiceProtocol_TCP,
or (kDNSServiceProtocol_UDP | kDNSServiceProtocol_TCP) to map both.
The local listening port number must also be specified in the privatePort parameter.
To just discover the NAT gateway's public IP address, pass zero for protocol,
privatePort, publicPort and ttl.
<br><br>
privatePort:     The port number in network byte order on the local machine which is listening for packets.
<br><br>
publicPort:      The requested public port in network byte order in the NAT gateway that you would
like to map to the private port. Pass 0 if you don't care which public port is chosen for you.
<br><br>
ttl:             The requested renewal period of the NAT port mapping, in seconds.
If the client machine crashes, suffers a power failure, is disconnected from
the network, or suffers some other unfortunate demise which causes it to vanish
unexpectedly without explicitly removing its NAT port mappings, then the NAT gateway
will garbage-collect old stale NAT port mappings when their lifetime expires.
Requesting a short TTL causes such orphaned mappings to be garbage-collected
more promptly, but consumes system resources and network bandwidth with
frequent renewal packets to keep the mapping from expiring.
Requesting a long TTL is more efficient on the network, but in the event of the
client vanishing, stale NAT port mappings will not be garbage-collected as quickly.
Most clients should pass 0 to use a system-wide default value.
<br><br>
callBack:        The function to be called when the port mapping request succeeds or fails asynchronously.
<br><br>
context:         An application context pointer which is passed to the callback function
(may be NULL).
<br><br>
return value:    Returns kDNSServiceErr_NoError on success (any subsequent, asynchronous
errors are delivered to the callback), otherwise returns an error code indicating
the error that occurred.
<br><br>
If you don't actually want a port mapped, and are just calling the API
because you want to find out the NAT's public IP address (e.g. for UI
display) then pass zero for protocol, privatePort, publicPort and ttl.
 <!-- end discussion --></p>
<p></p><hr><!-- headerDoc=func;  uid=//apple_ref/c/func/DNSServiceProcessResult;  name=DNSServiceProcessResult -->
<a name="//apple_ref/c/func/DNSServiceProcessResult"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="DNSServiceProcessResult">DNSServiceProcessResult</a></h3>
</td></tr></table><hr><p></p><pre><!-- a --><span class="type">DNSServiceErrorType</span><!-- /a --> <a href="CompositePage.html#//apple_ref/c/func/DNSServiceProcessResult" class="function"><span class="function">DNSServiceProcessResult</span></a>(
    <!-- a --><span class="type">DNSServiceRef</span><!-- /a --> <span class="param">sdRef</span>);  </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->DNSServiceProcessResult()
<br><br>
Read a reply from the daemon, calling the appropriate application callback. This call will
block until the daemon's response is received. Use DNSServiceRefSockFD() in
conjunction with a run loop or select() to determine the presence of a response from the
server before calling this function to process the reply without blocking. Call this function
at any point if it is acceptable to block until the daemon's response arrives. Note that the
client is responsible for ensuring that DNSServiceProcessResult() is called whenever there is
a reply from the daemon - the daemon may terminate its connection with a client that does not
process the daemon's responses.
<br><br>
sdRef:           A DNSServiceRef initialized by any of the DNSService calls
that take a callback parameter.
<br><br>
return value:    Returns kDNSServiceErr_NoError on success, otherwise returns
an error code indicating the specific failure that occurred.
 <!-- end discussion --></p>
<p></p><hr><!-- headerDoc=func;  uid=//apple_ref/c/func/DNSServiceQueryRecord;  name=DNSServiceQueryRecord -->
<a name="//apple_ref/c/func/DNSServiceQueryRecord"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="DNSServiceQueryRecord">DNSServiceQueryRecord</a></h3>
</td></tr></table><hr><p></p><pre><!-- a --><span class="type">DNSServiceErrorType</span><!-- /a --> <a href="CompositePage.html#//apple_ref/c/func/DNSServiceQueryRecord" class="function"><span class="function">DNSServiceQueryRecord</span></a> ( 
    <!-- a --><span class="type">DNSServiceRef</span><!-- /a --> *<span class="param">sdRef</span>, 
    <!-- a --><span class="type">DNSServiceFlags</span><!-- /a --> <span class="param">flags</span>, 
    <!-- a --><span class="type">uint32_t</span><!-- /a --> <span class="param">interfaceIndex</span>, 
    <span class="keyword">const</span> <!-- a --><span class="type">char</span><!-- /a --> *<span class="param">fullname</span>, 
    <!-- a --><span class="type">uint16_t</span><!-- /a --> <span class="param">rrtype</span>, 
    <!-- a --><span class="type">uint16_t</span><!-- /a --> <span class="param">rrclass</span>, 
    <a href="CompositePage.html#//apple_ref/c/tdef/DNSServiceQueryRecordReply" class="type"><span class="type">DNSServiceQueryRecordReply</span></a> <span class="param">callBack</span>, 
    <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> *<span class="param">context</span> <span class="comment">/* may be NULL */</span>
    );  </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->DNSServiceQueryRecord() Parameters:
<br><br>
sdRef:           A pointer to an uninitialized DNSServiceRef. If the call succeeds
then it initializes the DNSServiceRef, returns kDNSServiceErr_NoError,
and the query operation will run indefinitely until the client
terminates it by passing this DNSServiceRef to DNSServiceRefDeallocate().
<br><br>
flags:           kDNSServiceFlagsForceMulticast or kDNSServiceFlagsLongLivedQuery.
Pass kDNSServiceFlagsLongLivedQuery to create a "long-lived" unicast
query in a non-local domain. Without setting this flag, unicast queries
will be one-shot - that is, only answers available at the time of the call
will be returned. By setting this flag, answers (including Add and Remove
events) that become available after the initial call is made will generate
callbacks. This flag has no effect on link-local multicast queries.
<br><br>
interfaceIndex:  If non-zero, specifies the interface on which to issue the query
(the index for a given interface is determined via the if_nametoindex()
family of calls.) Passing 0 causes the name to be queried for on all
interfaces. See "Constants for specifying an interface index" for more details.
<br><br>
fullname:        The full domain name of the resource record to be queried for.
<br><br>
rrtype:          The numerical type of the resource record to be queried for
(e.g. kDNSServiceType_PTR, kDNSServiceType_SRV, etc)
<br><br>
rrclass:         The class of the resource record (usually kDNSServiceClass_IN).
<br><br>
callBack:        The function to be called when a result is found, or if the call
asynchronously fails.
<br><br>
context:         An application context pointer which is passed to the callback function
(may be NULL).
<br><br>
return value:    Returns kDNSServiceErr_NoError on success (any subsequent, asynchronous
errors are delivered to the callback), otherwise returns an error code indicating
the error that occurred (the callback is never invoked and the DNSServiceRef
is not initialized).
 <!-- end discussion --></p>
<p></p><hr><!-- headerDoc=func;  uid=//apple_ref/c/func/DNSServiceReconfirmRecord;  name=DNSServiceReconfirmRecord -->
<a name="//apple_ref/c/func/DNSServiceReconfirmRecord"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="DNSServiceReconfirmRecord">DNSServiceReconfirmRecord</a></h3>
</td></tr></table><hr><p></p><pre><!-- a --><span class="type">DNSServiceErrorType</span><!-- /a --> <a href="CompositePage.html#//apple_ref/c/func/DNSServiceReconfirmRecord" class="function"><span class="function">DNSServiceReconfirmRecord</span></a> ( 
    <!-- a --><span class="type">DNSServiceFlags</span><!-- /a --> <span class="param">flags</span>, 
    <!-- a --><span class="type">uint32_t</span><!-- /a --> <span class="param">interfaceIndex</span>, 
    <span class="keyword">const</span> <!-- a --><span class="type">char</span><!-- /a --> *<span class="param">fullname</span>, 
    <!-- a --><span class="type">uint16_t</span><!-- /a --> <span class="param">rrtype</span>, 
    <!-- a --><span class="type">uint16_t</span><!-- /a --> <span class="param">rrclass</span>, 
    <!-- a --><span class="type">uint16_t</span><!-- /a --> <span class="param">rdlen</span>, 
    <span class="keyword">const</span> <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> *<span class="param">rdata</span> );  </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->DNSServiceReconfirmRecord
<br><br>
Instruct the daemon to verify the validity of a resource record that appears
to be out of date (e.g. because TCP connection to a service's target failed.)
Causes the record to be flushed from the daemon's cache (as well as all other
daemons' caches on the network) if the record is determined to be invalid.
Use this routine conservatively. Reconfirming a record necessarily consumes
network bandwidth, so this should not be done indiscriminately.
<br><br>
Parameters:
<br><br>
flags:           Pass kDNSServiceFlagsForce to force immediate deletion of record,
instead of after some number of reconfirmation queries have gone unanswered.
<br><br>
interfaceIndex:  Specifies the interface of the record in question.
The caller must specify the interface.
This API (by design) causes increased network traffic, so it requires
the caller to be precise about which record should be reconfirmed.
It is not possible to pass zero for the interface index to perform
a "wildcard" reconfirmation, where *all* matching records are reconfirmed.
<br><br>
fullname:        The resource record's full domain name.
<br><br>
rrtype:          The resource record's type (e.g. kDNSServiceType_PTR, kDNSServiceType_SRV, etc)
<br><br>
rrclass:         The class of the resource record (usually kDNSServiceClass_IN).
<br><br>
rdlen:           The length, in bytes, of the resource record rdata.
<br><br>
rdata:           The raw rdata of the resource record.
<br><br>
 <!-- end discussion --></p>
<p></p><hr><!-- headerDoc=func;  uid=//apple_ref/c/func/DNSServiceRefDeallocate;  name=DNSServiceRefDeallocate -->
<a name="//apple_ref/c/func/DNSServiceRefDeallocate"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="DNSServiceRefDeallocate">DNSServiceRefDeallocate</a></h3>
</td></tr></table><hr><p></p><pre><a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <a href="CompositePage.html#//apple_ref/c/func/DNSServiceRefDeallocate" class="function"><span class="function">DNSServiceRefDeallocate</span></a>(
    <!-- a --><span class="type">DNSServiceRef</span><!-- /a --> <span class="param">sdRef</span>);  </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->DNSServiceRefDeallocate()
<br><br>
Terminate a connection with the daemon and free memory associated with the DNSServiceRef.
Any services or records registered with this DNSServiceRef will be deregistered. Any
Browse, Resolve, or Query operations called with this reference will be terminated.
<br><br>
Note: If the reference's underlying socket is used in a run loop or select() call, it should
be removed BEFORE DNSServiceRefDeallocate() is called, as this function closes the reference's
socket.
<br><br>
Note: If the reference was initialized with DNSServiceCreateConnection(), any DNSRecordRefs
created via this reference will be invalidated by this call - the resource records are
deregistered, and their DNSRecordRefs may not be used in subsequent functions. Similarly,
if the reference was initialized with DNSServiceRegister, and an extra resource record was
added to the service via DNSServiceAddRecord(), the DNSRecordRef created by the Add() call
is invalidated when this function is called - the DNSRecordRef may not be used in subsequent
functions.
<br><br>
Note: This call is to be used only with the DNSServiceRef defined by this API. It is
not compatible with dns_service_discovery_ref objects defined in the legacy Mach-based
DNSServiceDiscovery.h API.
<br><br>
sdRef:           A DNSServiceRef initialized by any of the DNSService calls.
<br><br>
 <!-- end discussion --></p>
<p></p><hr><!-- headerDoc=func;  uid=//apple_ref/c/func/DNSServiceRefSockFD;  name=DNSServiceRefSockFD -->
<a name="//apple_ref/c/func/DNSServiceRefSockFD"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="DNSServiceRefSockFD">DNSServiceRefSockFD</a></h3>
</td></tr></table><hr><p></p><pre><!-- a --><span class="type">int</span><!-- /a --> <a href="CompositePage.html#//apple_ref/c/func/DNSServiceRefSockFD" class="function"><span class="function">DNSServiceRefSockFD</span></a>(
    <!-- a --><span class="type">DNSServiceRef</span><!-- /a --> <span class="param">sdRef</span>);  </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->DNSServiceRefSockFD()
<br><br>
Access underlying Unix domain socket for an initialized DNSServiceRef.
The DNS Service Discovery implementation uses this socket to communicate between the client and
the mDNSResponder daemon. The application MUST NOT directly read from or write to this socket.
Access to the socket is provided so that it can be used as a kqueue event source, a CFRunLoop
event source, in a select() loop, etc. When the underlying event management subsystem (kqueue/
select/CFRunLoop etc.) indicates to the client that data is available for reading on the
socket, the client should call DNSServiceProcessResult(), which will extract the daemon's
reply from the socket, and pass it to the appropriate application callback. By using a run
loop or select(), results from the daemon can be processed asynchronously. Alternatively,
a client can choose to fork a thread and have it loop calling "DNSServiceProcessResult(ref);"
If DNSServiceProcessResult() is called when no data is available for reading on the socket, it
will block until data does become available, and then process the data and return to the caller.
When data arrives on the socket, the client is responsible for calling DNSServiceProcessResult(ref)
in a timely fashion -- if the client allows a large backlog of data to build up the daemon
may terminate the connection.
<br><br>
sdRef:           A DNSServiceRef initialized by any of the DNSService calls.
<br><br>
return value:    The DNSServiceRef's underlying socket descriptor, or -1 on
error.
 <!-- end discussion --></p>
<p></p><hr><!-- headerDoc=func;  uid=//apple_ref/c/func/DNSServiceRegister;  name=DNSServiceRegister -->
<a name="//apple_ref/c/func/DNSServiceRegister"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="DNSServiceRegister">DNSServiceRegister</a></h3>
</td></tr></table><hr><p></p><pre><!-- a --><span class="type">DNSServiceErrorType</span><!-- /a --> <a href="CompositePage.html#//apple_ref/c/func/DNSServiceRegister" class="function"><span class="function">DNSServiceRegister</span></a> ( 
    <!-- a --><span class="type">DNSServiceRef</span><!-- /a --> *<span class="param">sdRef</span>, 
    <!-- a --><span class="type">DNSServiceFlags</span><!-- /a --> <span class="param">flags</span>, 
    <!-- a --><span class="type">uint32_t</span><!-- /a --> <span class="param">interfaceIndex</span>, 
    <span class="keyword">const</span> <!-- a --><span class="type">char</span><!-- /a --> *<span class="param">name</span>, <span class="comment">/* may be NULL */</span>
    <span class="keyword">const</span> <!-- a --><span class="type">char</span><!-- /a --> *<span class="param">regtype</span>, 
    <span class="keyword">const</span> <!-- a --><span class="type">char</span><!-- /a --> *<span class="param">domain</span>, <span class="comment">/* may be NULL */</span>
    <span class="keyword">const</span> <!-- a --><span class="type">char</span><!-- /a --> *<span class="param">host</span>, <span class="comment">/* may be NULL */</span>
    <!-- a --><span class="type">uint16_t</span><!-- /a --> <span class="param">port</span>, 
    <!-- a --><span class="type">uint16_t</span><!-- /a --> <span class="param">txtLen</span>, 
    <span class="keyword">const</span> <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> *<span class="param">txtRecord</span>, <span class="comment">/* may be NULL */</span>
    <a href="CompositePage.html#//apple_ref/c/tdef/DNSServiceRegisterReply" class="type"><span class="type">DNSServiceRegisterReply</span></a> <span class="param">callBack</span>, <span class="comment">/* may be NULL */</span>
    <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> *<span class="param">context</span> <span class="comment">/* may be NULL */</span>
    );  </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->DNSServiceRegister() Parameters:
<br><br>
sdRef:           A pointer to an uninitialized DNSServiceRef. If the call succeeds
then it initializes the DNSServiceRef, returns kDNSServiceErr_NoError,
and the registration will remain active indefinitely until the client
terminates it by passing this DNSServiceRef to DNSServiceRefDeallocate().
<br><br>
interfaceIndex:  If non-zero, specifies the interface on which to register the service
(the index for a given interface is determined via the if_nametoindex()
family of calls.) Most applications will pass 0 to register on all
available interfaces. See "Constants for specifying an interface index" for more details.
<br><br>
flags:           Indicates the renaming behavior on name conflict (most applications
will pass 0). See flag definitions above for details.
<br><br>
name:            If non-NULL, specifies the service name to be registered.
Most applications will not specify a name, in which case the computer
name is used (this name is communicated to the client via the callback).
If a name is specified, it must be 1-63 bytes of UTF-8 text.
If the name is longer than 63 bytes it will be automatically truncated
to a legal length, unless the NoAutoRename flag is set,
in which case kDNSServiceErr_BadParam will be returned.
<br><br>
regtype:         The service type followed by the protocol, separated by a dot
(e.g. "_ftp._tcp"). The service type must be an underscore, followed
by 1-14 characters, which may be letters, digits, or hyphens.
The transport protocol must be "_tcp" or "_udp". New service types
should be registered at <http://www.dns-sd.org/ServiceTypes.html>.
<br><br>
Additional subtypes of the primary service type (where a service
type has defined subtypes) follow the primary service type in a
comma-separated list, with no additional spaces, e.g.
"_primarytype._tcp,_subtype1,_subtype2,_subtype3"
Subtypes provide a mechanism for filtered browsing: A client browsing
for "_primarytype._tcp" will discover all instances of this type;
a client browsing for "_primarytype._tcp,_subtype2" will discover only
those instances that were registered with "_subtype2" in their list of
registered subtypes.
<br><br>
The subtype mechanism can be illustrated with some examples using the
dns-sd command-line tool:
<br><br>
% dns-sd -R Simple _test._tcp "" 1001 &
% dns-sd -R Better _test._tcp,HasFeatureA "" 1002 &
% dns-sd -R Best   _test._tcp,HasFeatureA,HasFeatureB "" 1003 &
<br><br>
Now:
% dns-sd -B _test._tcp             # will find all three services
% dns-sd -B _test._tcp,HasFeatureA # finds "Better" and "Best"
% dns-sd -B _test._tcp,HasFeatureB # finds only "Best"
<br><br>
domain:          If non-NULL, specifies the domain on which to advertise the service.
Most applications will not specify a domain, instead automatically
registering in the default domain(s).
<br><br>
host:            If non-NULL, specifies the SRV target host name. Most applications
will not specify a host, instead automatically using the machine's
default host name(s). Note that specifying a non-NULL host does NOT
create an address record for that host - the application is responsible
for ensuring that the appropriate address record exists, or creating it
via DNSServiceRegisterRecord().
<br><br>
port:            The port, in network byte order, on which the service accepts connections.
Pass 0 for a "placeholder" service (i.e. a service that will not be discovered
by browsing, but will cause a name conflict if another client tries to
register that same name). Most clients will not use placeholder services.
<br><br>
txtLen:          The length of the txtRecord, in bytes. Must be zero if the txtRecord is NULL.
<br><br>
txtRecord:       The TXT record rdata. A non-NULL txtRecord MUST be a properly formatted DNS
TXT record, i.e. <length byte> <data> <length byte> <data> ...
Passing NULL for the txtRecord is allowed as a synonym for txtLen=1, txtRecord="",
i.e. it creates a TXT record of length one containing a single empty string.
RFC 1035 doesn't allow a TXT record to contain *zero* strings, so a single empty
string is the smallest legal DNS TXT record.
As with the other parameters, the DNSServiceRegister call copies the txtRecord
data; e.g. if you allocated the storage for the txtRecord parameter with malloc()
then you can safely free that memory right after the DNSServiceRegister call returns.
<br><br>
callBack:        The function to be called when the registration completes or asynchronously
fails. The client MAY pass NULL for the callback -  The client will NOT be notified
of the default values picked on its behalf, and the client will NOT be notified of any
asynchronous errors (e.g. out of memory errors, etc.) that may prevent the registration
of the service. The client may NOT pass the NoAutoRename flag if the callback is NULL.
The client may still deregister the service at any time via DNSServiceRefDeallocate().
<br><br>
context:         An application context pointer which is passed to the callback function
(may be NULL).
<br><br>
return value:    Returns kDNSServiceErr_NoError on success (any subsequent, asynchronous
errors are delivered to the callback), otherwise returns an error code indicating
the error that occurred (the callback is never invoked and the DNSServiceRef
is not initialized).
 <!-- end discussion --></p>
<p></p><hr><!-- headerDoc=func;  uid=//apple_ref/c/func/DNSServiceRegisterRecord;  name=DNSServiceRegisterRecord -->
<a name="//apple_ref/c/func/DNSServiceRegisterRecord"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="DNSServiceRegisterRecord">DNSServiceRegisterRecord</a></h3>
</td></tr></table><hr><p></p><pre><!-- a --><span class="type">DNSServiceErrorType</span><!-- /a --> <a href="CompositePage.html#//apple_ref/c/func/DNSServiceRegisterRecord" class="function"><span class="function">DNSServiceRegisterRecord</span></a> ( 
    <!-- a --><span class="type">DNSServiceRef</span><!-- /a --> <span class="param">sdRef</span>, 
    <!-- a --><span class="type">DNSRecordRef</span><!-- /a --> *<span class="param">RecordRef</span>, 
    <!-- a --><span class="type">DNSServiceFlags</span><!-- /a --> <span class="param">flags</span>, 
    <!-- a --><span class="type">uint32_t</span><!-- /a --> <span class="param">interfaceIndex</span>, 
    <span class="keyword">const</span> <!-- a --><span class="type">char</span><!-- /a --> *<span class="param">fullname</span>, 
    <!-- a --><span class="type">uint16_t</span><!-- /a --> <span class="param">rrtype</span>, 
    <!-- a --><span class="type">uint16_t</span><!-- /a --> <span class="param">rrclass</span>, 
    <!-- a --><span class="type">uint16_t</span><!-- /a --> <span class="param">rdlen</span>, 
    <span class="keyword">const</span> <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> *<span class="param">rdata</span>, 
    <!-- a --><span class="type">uint32_t</span><!-- /a --> <span class="param">ttl</span>, 
    <a href="CompositePage.html#//apple_ref/c/tdef/DNSServiceRegisterRecordReply" class="type"><span class="type">DNSServiceRegisterRecordReply</span></a> <span class="param">callBack</span>, 
    <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> *<span class="param">context</span> <span class="comment">/* may be NULL */</span>
    );  </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->DNSServiceRegisterRecord() Parameters:
<br><br>
sdRef:           A DNSServiceRef initialized by DNSServiceCreateConnection().
<br><br>
RecordRef:       A pointer to an uninitialized DNSRecordRef. Upon succesfull completion of this
call, this ref may be passed to DNSServiceUpdateRecord() or DNSServiceRemoveRecord().
(To deregister ALL records registered on a single connected DNSServiceRef
and deallocate each of their corresponding DNSServiceRecordRefs, call
DNSServiceRefDealloocate()).
<br><br>
flags:           Possible values are kDNSServiceFlagsShared or kDNSServiceFlagsUnique
(see flag type definitions for details).
<br><br>
interfaceIndex:  If non-zero, specifies the interface on which to register the record
(the index for a given interface is determined via the if_nametoindex()
family of calls.) Passing 0 causes the record to be registered on all interfaces.
See "Constants for specifying an interface index" for more details.
<br><br>
fullname:        The full domain name of the resource record.
<br><br>
rrtype:          The numerical type of the resource record (e.g. kDNSServiceType_PTR, kDNSServiceType_SRV, etc)
<br><br>
rrclass:         The class of the resource record (usually kDNSServiceClass_IN)
<br><br>
rdlen:           Length, in bytes, of the rdata.
<br><br>
rdata:           A pointer to the raw rdata, as it is to appear in the DNS record.
<br><br>
ttl:             The time to live of the resource record, in seconds. Pass 0 to use a default value.
<br><br>
callBack:        The function to be called when a result is found, or if the call
asynchronously fails (e.g. because of a name conflict.)
<br><br>
context:         An application context pointer which is passed to the callback function
(may be NULL).
<br><br>
return value:    Returns kDNSServiceErr_NoError on success (any subsequent, asynchronous
errors are delivered to the callback), otherwise returns an error code indicating
the error that occurred (the callback is never invoked and the DNSRecordRef is
not initialized).
 <!-- end discussion --></p>
<p></p><hr><!-- headerDoc=func;  uid=//apple_ref/c/func/DNSServiceRemoveRecord;  name=DNSServiceRemoveRecord -->
<a name="//apple_ref/c/func/DNSServiceRemoveRecord"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="DNSServiceRemoveRecord">DNSServiceRemoveRecord</a></h3>
</td></tr></table><hr><p></p><pre><!-- a --><span class="type">DNSServiceErrorType</span><!-- /a --> <a href="CompositePage.html#//apple_ref/c/func/DNSServiceRemoveRecord" class="function"><span class="function">DNSServiceRemoveRecord</span></a> ( 
    <!-- a --><span class="type">DNSServiceRef</span><!-- /a --> <span class="param">sdRef</span>, 
    <!-- a --><span class="type">DNSRecordRef</span><!-- /a --> <span class="param">RecordRef</span>, 
    <!-- a --><span class="type">DNSServiceFlags</span><!-- /a --> <span class="param">flags</span> );  </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->DNSServiceRemoveRecord
<br><br>
Remove a record previously added to a service record set via DNSServiceAddRecord(), or deregister
an record registered individually via DNSServiceRegisterRecord().
<br><br>
Parameters:
<br><br>
sdRef:           A DNSServiceRef initialized by DNSServiceRegister() (if the
record being removed was registered via DNSServiceAddRecord()) or by
DNSServiceCreateConnection() (if the record being removed was registered via
DNSServiceRegisterRecord()).
<br><br>
recordRef:       A DNSRecordRef initialized by a successful call to DNSServiceAddRecord()
or DNSServiceRegisterRecord().
<br><br>
flags:           Currently ignored, reserved for future use.
<br><br>
return value:    Returns kDNSServiceErr_NoError on success, otherwise returns an
error code indicating the error that occurred.
 <!-- end discussion --></p>
<p></p><hr><!-- headerDoc=func;  uid=//apple_ref/c/func/DNSServiceResolve;  name=DNSServiceResolve -->
<a name="//apple_ref/c/func/DNSServiceResolve"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="DNSServiceResolve">DNSServiceResolve</a></h3>
</td></tr></table><hr><p></p><pre><!-- a --><span class="type">DNSServiceErrorType</span><!-- /a --> <a href="CompositePage.html#//apple_ref/c/func/DNSServiceResolve" class="function"><span class="function">DNSServiceResolve</span></a> ( 
    <!-- a --><span class="type">DNSServiceRef</span><!-- /a --> *<span class="param">sdRef</span>, 
    <!-- a --><span class="type">DNSServiceFlags</span><!-- /a --> <span class="param">flags</span>, 
    <!-- a --><span class="type">uint32_t</span><!-- /a --> <span class="param">interfaceIndex</span>, 
    <span class="keyword">const</span> <!-- a --><span class="type">char</span><!-- /a --> *<span class="param">name</span>, 
    <span class="keyword">const</span> <!-- a --><span class="type">char</span><!-- /a --> *<span class="param">regtype</span>, 
    <span class="keyword">const</span> <!-- a --><span class="type">char</span><!-- /a --> *<span class="param">domain</span>, 
    <a href="CompositePage.html#//apple_ref/c/tdef/DNSServiceResolveReply" class="type"><span class="type">DNSServiceResolveReply</span></a> <span class="param">callBack</span>, 
    <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> *<span class="param">context</span> <span class="comment">/* may be NULL */</span>
    );  </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->DNSServiceResolve() Parameters
<br><br>
sdRef:           A pointer to an uninitialized DNSServiceRef. If the call succeeds
then it initializes the DNSServiceRef, returns kDNSServiceErr_NoError,
and the resolve operation will run indefinitely until the client
terminates it by passing this DNSServiceRef to DNSServiceRefDeallocate().
<br><br>
flags:           Specifying kDNSServiceFlagsForceMulticast will cause query to be
performed with a link-local mDNS query, even if the name is an
apparently non-local name (i.e. a name not ending in ".local.")
<br><br>
interfaceIndex:  The interface on which to resolve the service. If this resolve call is
as a result of a currently active DNSServiceBrowse() operation, then the
interfaceIndex should be the index reported in the DNSServiceBrowseReply
callback. If this resolve call is using information previously saved
(e.g. in a preference file) for later use, then use interfaceIndex 0, because
the desired service may now be reachable via a different physical interface.
See "Constants for specifying an interface index" for more details.
<br><br>
name:            The name of the service instance to be resolved, as reported to the
DNSServiceBrowseReply() callback.
<br><br>
regtype:         The type of the service instance to be resolved, as reported to the
DNSServiceBrowseReply() callback.
<br><br>
domain:          The domain of the service instance to be resolved, as reported to the
DNSServiceBrowseReply() callback.
<br><br>
callBack:        The function to be called when a result is found, or if the call
asynchronously fails.
<br><br>
context:         An application context pointer which is passed to the callback function
(may be NULL).
<br><br>
return value:    Returns kDNSServiceErr_NoError on success (any subsequent, asynchronous
errors are delivered to the callback), otherwise returns an error code indicating
the error that occurred (the callback is never invoked and the DNSServiceRef
is not initialized).
 <!-- end discussion --></p>
<p></p><hr><!-- headerDoc=func;  uid=//apple_ref/c/func/DNSServiceUpdateRecord;  name=DNSServiceUpdateRecord -->
<a name="//apple_ref/c/func/DNSServiceUpdateRecord"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="DNSServiceUpdateRecord">DNSServiceUpdateRecord</a></h3>
</td></tr></table><hr><p></p><pre><!-- a --><span class="type">DNSServiceErrorType</span><!-- /a --> <a href="CompositePage.html#//apple_ref/c/func/DNSServiceUpdateRecord" class="function"><span class="function">DNSServiceUpdateRecord</span></a> ( 
    <!-- a --><span class="type">DNSServiceRef</span><!-- /a --> <span class="param">sdRef</span>, 
    <!-- a --><span class="type">DNSRecordRef</span><!-- /a --> <span class="param">RecordRef</span>, <span class="comment">/* may be NULL */</span>
    <!-- a --><span class="type">DNSServiceFlags</span><!-- /a --> <span class="param">flags</span>, 
    <!-- a --><span class="type">uint16_t</span><!-- /a --> <span class="param">rdlen</span>, 
    <span class="keyword">const</span> <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> *<span class="param">rdata</span>, 
    <!-- a --><span class="type">uint32_t</span><!-- /a --> <span class="param">ttl</span> );  </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->DNSServiceUpdateRecord
<br><br>
Update a registered resource record. The record must either be:
- The primary txt record of a service registered via DNSServiceRegister()
- A record added to a registered service via DNSServiceAddRecord()
- An individual record registered by DNSServiceRegisterRecord()
<br><br>
<br><br>
Parameters:
<br><br>
sdRef:           A DNSServiceRef that was initialized by DNSServiceRegister()
or DNSServiceCreateConnection().
<br><br>
RecordRef:       A DNSRecordRef initialized by DNSServiceAddRecord, or NULL to update the
service's primary txt record.
<br><br>
flags:           Currently ignored, reserved for future use.
<br><br>
rdlen:           The length, in bytes, of the new rdata.
<br><br>
rdata:           The new rdata to be contained in the updated resource record.
<br><br>
ttl:             The time to live of the updated resource record, in seconds.
<br><br>
return value:    Returns kDNSServiceErr_NoError on success, otherwise returns an
error code indicating the error that occurred.
 <!-- end discussion --></p>
<p></p><hr><!-- headerDoc=func;  uid=//apple_ref/c/func/TXTRecordContainsKey;  name=TXTRecordContainsKey -->
<a name="//apple_ref/c/func/TXTRecordContainsKey"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="TXTRecordContainsKey">TXTRecordContainsKey</a></h3>
</td></tr></table><hr><p></p><pre><!-- a --><span class="type">int</span><!-- /a --> <a href="CompositePage.html#//apple_ref/c/func/TXTRecordContainsKey" class="function"><span class="function">TXTRecordContainsKey</span></a> ( 
    <!-- a --><span class="type">uint16_t</span><!-- /a --> <span class="param">txtLen</span>, 
    <span class="keyword">const</span> <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> *<span class="param">txtRecord</span>, 
    <span class="keyword">const</span> <!-- a --><span class="type">char</span><!-- /a --> *<span class="param">key</span> );  </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->TXTRecordContainsKey()
<br><br>
Allows you to determine if a given TXT Record contains a specified key.
<br><br>
txtLen:          The size of the received TXT Record.
<br><br>
txtRecord:       Pointer to the received TXT Record bytes.
<br><br>
key:             A null-terminated ASCII string containing the key name.
<br><br>
return value:    Returns 1 if the TXT Record contains the specified key.
Otherwise, it returns 0.
 <!-- end discussion --></p>
<p></p><hr><!-- headerDoc=func;  uid=//apple_ref/c/func/TXTRecordCreate;  name=TXTRecordCreate -->
<a name="//apple_ref/c/func/TXTRecordCreate"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="TXTRecordCreate">TXTRecordCreate</a></h3>
</td></tr></table><hr><p></p><pre><a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <a href="CompositePage.html#//apple_ref/c/func/TXTRecordCreate" class="function"><span class="function">TXTRecordCreate</span></a> ( 
    <a href="CompositePage.html#//apple_ref/c/tdef/TXTRecordRef" class="type"><span class="type">TXTRecordRef</span></a> *<span class="param">txtRecord</span>, 
    <!-- a --><span class="type">uint16_t</span><!-- /a --> <span class="param">bufferLen</span>, 
    <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> *<span class="param">buffer</span> );  </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->TXTRecordCreate()
<br><br>
Creates a new empty TXTRecordRef referencing the specified storage.
<br><br>
If the buffer parameter is NULL, or the specified storage size is not
large enough to hold a key subsequently added using TXTRecordSetValue(),
then additional memory will be added as needed using malloc().
<br><br>
On some platforms, when memory is low, malloc() may fail. In this
case, TXTRecordSetValue() will return kDNSServiceErr_NoMemory, and this
error condition will need to be handled as appropriate by the caller.
<br><br>
You can avoid the need to handle this error condition if you ensure
that the storage you initially provide is large enough to hold all
the key/value pairs that are to be added to the record.
The caller can precompute the exact length required for all of the
key/value pairs to be added, or simply provide a fixed-sized buffer
known in advance to be large enough.
A no-value (key-only) key requires  (1 + key length) bytes.
A key with empty value requires     (1 + key length + 1) bytes.
A key with non-empty value requires (1 + key length + 1 + value length).
For most applications, DNS-SD TXT records are generally
less than 100 bytes, so in most cases a simple fixed-sized
256-byte buffer will be more than sufficient.
Recommended size limits for DNS-SD TXT Records are discussed in
<http://files.dns-sd.org/draft-cheshire-dnsext-dns-sd.txt>
<br><br>
Note: When passing parameters to and from these TXT record APIs,
the key name does not include the '=' character. The '=' character
is the separator between the key and value in the on-the-wire
packet format; it is not part of either the key or the value.
<br><br>
txtRecord:       A pointer to an uninitialized TXTRecordRef.
<br><br>
bufferLen:       The size of the storage provided in the "buffer" parameter.
<br><br>
buffer:          Optional caller-supplied storage used to hold the TXTRecord data.
This storage must remain valid for as long as
the TXTRecordRef.
 <!-- end discussion --></p>
<p></p><hr><!-- headerDoc=func;  uid=//apple_ref/c/func/TXTRecordDeallocate;  name=TXTRecordDeallocate -->
<a name="//apple_ref/c/func/TXTRecordDeallocate"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="TXTRecordDeallocate">TXTRecordDeallocate</a></h3>
</td></tr></table><hr><p></p><pre><a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <a href="CompositePage.html#//apple_ref/c/func/TXTRecordDeallocate" class="function"><span class="function">TXTRecordDeallocate</span></a> ( 
    <a href="CompositePage.html#//apple_ref/c/tdef/TXTRecordRef" class="type"><span class="type">TXTRecordRef</span></a> *<span class="param">txtRecord</span> );  </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->TXTRecordDeallocate()
<br><br>
Releases any resources allocated in the course of preparing a TXT Record
using TXTRecordCreate()/TXTRecordSetValue()/TXTRecordRemoveValue().
Ownership of the buffer provided in TXTRecordCreate() returns to the client.
<br><br>
txtRecord:           A TXTRecordRef initialized by calling TXTRecordCreate().
<br><br>
 <!-- end discussion --></p>
<p></p><hr><!-- headerDoc=func;  uid=//apple_ref/c/func/TXTRecordGetBytesPtr;  name=TXTRecordGetBytesPtr -->
<a name="//apple_ref/c/func/TXTRecordGetBytesPtr"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="TXTRecordGetBytesPtr">TXTRecordGetBytesPtr</a></h3>
</td></tr></table><hr><p></p><pre><span class="keyword">const</span> <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span> <a href="CompositePage.html#//apple_ref/c/func/TXTRecordGetBytesPtr" class="function"><span class="function">TXTRecordGetBytesPtr</span></a> ( 
    <span class="keyword">const</span> <a href="CompositePage.html#//apple_ref/c/tdef/TXTRecordRef" class="type"><span class="type">TXTRecordRef</span></a> *<span class="param">txtRecord</span> );  </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->TXTRecordGetBytesPtr()
<br><br>
Allows you to retrieve a pointer to the raw bytes within a TXTRecordRef.
<br><br>
txtRecord:       A TXTRecordRef initialized by calling TXTRecordCreate().
<br><br>
return value:    Returns a pointer to the raw bytes inside the TXTRecordRef
which you can pass directly to DNSServiceRegister() or
to DNSServiceUpdateRecord().
 <!-- end discussion --></p>
<p></p><hr><!-- headerDoc=func;  uid=//apple_ref/c/func/TXTRecordGetCount;  name=TXTRecordGetCount -->
<a name="//apple_ref/c/func/TXTRecordGetCount"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="TXTRecordGetCount">TXTRecordGetCount</a></h3>
</td></tr></table><hr><p></p><pre><!-- a --><span class="type">uint16_t</span><!-- /a --> <a href="CompositePage.html#//apple_ref/c/func/TXTRecordGetCount" class="function"><span class="function">TXTRecordGetCount</span></a> ( 
    <!-- a --><span class="type">uint16_t</span><!-- /a --> <span class="param">txtLen</span>, 
    <span class="keyword">const</span> <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> *<span class="param">txtRecord</span> );  </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->TXTRecordGetCount()
<br><br>
Returns the number of keys stored in the TXT Record. The count
can be used with TXTRecordGetItemAtIndex() to iterate through the keys.
<br><br>
txtLen:          The size of the received TXT Record.
<br><br>
txtRecord:       Pointer to the received TXT Record bytes.
<br><br>
return value:    Returns the total number of keys in the TXT Record.
<br><br>
 <!-- end discussion --></p>
<p></p><hr><!-- headerDoc=func;  uid=//apple_ref/c/func/TXTRecordGetItemAtIndex;  name=TXTRecordGetItemAtIndex -->
<a name="//apple_ref/c/func/TXTRecordGetItemAtIndex"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="TXTRecordGetItemAtIndex">TXTRecordGetItemAtIndex</a></h3>
</td></tr></table><hr><p></p><pre><!-- a --><span class="type">DNSServiceErrorType</span><!-- /a --> <a href="CompositePage.html#//apple_ref/c/func/TXTRecordGetItemAtIndex" class="function"><span class="function">TXTRecordGetItemAtIndex</span></a> ( 
    <!-- a --><span class="type">uint16_t</span><!-- /a --> <span class="param">txtLen</span>, 
    <span class="keyword">const</span> <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> *<span class="param">txtRecord</span>, 
    <!-- a --><span class="type">uint16_t</span><!-- /a --> <span class="param">index</span>, 
    <!-- a --><span class="type">uint16_t</span><!-- /a --> <span class="param">keyBufLen</span>, 
    <!-- a --><span class="type">char</span><!-- /a --> *<span class="param">key</span>, 
    <!-- a --><span class="type">uint8_t</span><!-- /a --> *<span class="param">valueLen</span>, 
    <span class="keyword">const</span> <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> *<span class="type">*</span><span class="param">value</span> );  </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->TXTRecordGetItemAtIndex()
<br><br>
Allows you to retrieve a key name and value pointer, given an index into
a TXT Record. Legal index values range from zero to TXTRecordGetCount()-1.
It's also possible to iterate through keys in a TXT record by simply
calling TXTRecordGetItemAtIndex() repeatedly, beginning with index zero
and increasing until TXTRecordGetItemAtIndex() returns kDNSServiceErr_Invalid.
<br><br>
On return:
For keys with no value, *value is set to NULL and *valueLen is zero.
For keys with empty value, *value is non-NULL and *valueLen is zero.
For keys with non-empty value, *value is non-NULL and *valueLen is non-zero.
<br><br>
txtLen:          The size of the received TXT Record.
<br><br>
txtRecord:       Pointer to the received TXT Record bytes.
<br><br>
index:           An index into the TXT Record.
<br><br>
keyBufLen:       The size of the string buffer being supplied.
<br><br>
key:             A string buffer used to store the key name.
On return, the buffer contains a null-terminated C string
giving the key name. DNS-SD TXT keys are usually
8 characters or less. To hold the maximum possible
key name, the buffer should be 256 bytes long.
</li></ol>
valueLen:        On output, will be set to the size of the "value" data.
<br><br>
value:           On output, *value is set to point to location within TXT
Record bytes that holds the value data.
<br><br>
return value:    Returns kDNSServiceErr_NoError on success.
Returns kDNSServiceErr_NoMemory if keyBufLen is too short.
Returns kDNSServiceErr_Invalid if index is greater than
TXTRecordGetCount()-1.
 <!-- end discussion --></p>
<p></p><hr><!-- headerDoc=func;  uid=//apple_ref/c/func/TXTRecordGetLength;  name=TXTRecordGetLength -->
<a name="//apple_ref/c/func/TXTRecordGetLength"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="TXTRecordGetLength">TXTRecordGetLength</a></h3>
</td></tr></table><hr><p></p><pre><!-- a --><span class="type">uint16_t</span><!-- /a --> <a href="CompositePage.html#//apple_ref/c/func/TXTRecordGetLength" class="function"><span class="function">TXTRecordGetLength</span></a> ( 
    <span class="keyword">const</span> <a href="CompositePage.html#//apple_ref/c/tdef/TXTRecordRef" class="type"><span class="type">TXTRecordRef</span></a> *<span class="param">txtRecord</span> );  </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->TXTRecordGetLength()
<br><br>
Allows you to determine the length of the raw bytes within a TXTRecordRef.
<br><br>
txtRecord:       A TXTRecordRef initialized by calling TXTRecordCreate().
<br><br>
return value:    Returns the size of the raw bytes inside a TXTRecordRef
which you can pass directly to DNSServiceRegister() or
to DNSServiceUpdateRecord().
Returns 0 if the TXTRecordRef is empty.
 <!-- end discussion --></p>
<p></p><hr><!-- headerDoc=func;  uid=//apple_ref/c/func/TXTRecordGetValuePtr;  name=TXTRecordGetValuePtr -->
<a name="//apple_ref/c/func/TXTRecordGetValuePtr"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="TXTRecordGetValuePtr">TXTRecordGetValuePtr</a></h3>
</td></tr></table><hr><p></p><pre><span class="keyword">const</span> <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span> <a href="CompositePage.html#//apple_ref/c/func/TXTRecordGetValuePtr" class="function"><span class="function">TXTRecordGetValuePtr</span></a> ( 
    <!-- a --><span class="type">uint16_t</span><!-- /a --> <span class="param">txtLen</span>, 
    <span class="keyword">const</span> <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> *<span class="param">txtRecord</span>, 
    <span class="keyword">const</span> <!-- a --><span class="type">char</span><!-- /a --> *<span class="param">key</span>, 
    <!-- a --><span class="type">uint8_t</span><!-- /a --> *<span class="param">valueLen</span> );  </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->TXTRecordGetValuePtr()
<br><br>
Allows you to retrieve the value for a given key from a TXT Record.
<br><br>
txtLen:          The size of the received TXT Record
<br><br>
txtRecord:       Pointer to the received TXT Record bytes.
<br><br>
key:             A null-terminated ASCII string containing the key name.
<br><br>
valueLen:        On output, will be set to the size of the "value" data.
<br><br>
return value:    Returns NULL if the key does not exist in this TXT record,
or exists with no value (to differentiate between
these two cases use TXTRecordContainsKey()).
Returns pointer to location within TXT Record bytes
if the key exists with empty or non-empty value.
For empty value, valueLen will be zero.
For non-empty value, valueLen will be length of value data.
 <!-- end discussion --></p>
<p></p><hr><!-- headerDoc=func;  uid=//apple_ref/c/func/TXTRecordRemoveValue;  name=TXTRecordRemoveValue -->
<a name="//apple_ref/c/func/TXTRecordRemoveValue"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="TXTRecordRemoveValue">TXTRecordRemoveValue</a></h3>
</td></tr></table><hr><p></p><pre><!-- a --><span class="type">DNSServiceErrorType</span><!-- /a --> <a href="CompositePage.html#//apple_ref/c/func/TXTRecordRemoveValue" class="function"><span class="function">TXTRecordRemoveValue</span></a> ( 
    <a href="CompositePage.html#//apple_ref/c/tdef/TXTRecordRef" class="type"><span class="type">TXTRecordRef</span></a> *<span class="param">txtRecord</span>, 
    <span class="keyword">const</span> <!-- a --><span class="type">char</span><!-- /a --> *<span class="param">key</span> );  </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->TXTRecordRemoveValue()
<br><br>
Removes a key from a TXTRecordRef. The "key" must be an
ASCII string which exists in the TXTRecordRef.
<br><br>
txtRecord:       A TXTRecordRef initialized by calling TXTRecordCreate().
<br><br>
key:             A key name which exists in the TXTRecordRef.
<br><br>
return value:    Returns kDNSServiceErr_NoError on success.
Returns kDNSServiceErr_NoSuchKey if the "key" does not
exist in the TXTRecordRef.
 <!-- end discussion --></p>
<p></p><hr><!-- headerDoc=func;  uid=//apple_ref/c/func/TXTRecordSetValue;  name=TXTRecordSetValue -->
<a name="//apple_ref/c/func/TXTRecordSetValue"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="TXTRecordSetValue">TXTRecordSetValue</a></h3>
</td></tr></table><hr><p></p><pre><!-- a --><span class="type">DNSServiceErrorType</span><!-- /a --> <a href="CompositePage.html#//apple_ref/c/func/TXTRecordSetValue" class="function"><span class="function">TXTRecordSetValue</span></a> ( 
    <a href="CompositePage.html#//apple_ref/c/tdef/TXTRecordRef" class="type"><span class="type">TXTRecordRef</span></a> *<span class="param">txtRecord</span>, 
    <span class="keyword">const</span> <!-- a --><span class="type">char</span><!-- /a --> *<span class="param">key</span>, 
    <!-- a --><span class="type">uint8_t</span><!-- /a --> <span class="param">valueSize</span>, <span class="comment">/* may be zero */</span>
    <span class="keyword">const</span> <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> *<span class="param">value</span> <span class="comment">/* may be NULL */</span>
    );  </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->TXTRecordSetValue()
<br><br>
Adds a key (optionally with value) to a TXTRecordRef. If the "key" already
exists in the TXTRecordRef, then the current value will be replaced with
the new value.
Keys may exist in four states with respect to a given TXT record:
- Absent (key does not appear at all)
- Present with no value ("key" appears alone)
- Present with empty value ("key=" appears in TXT record)
- Present with non-empty value ("key=value" appears in TXT record)
For more details refer to "Data Syntax for DNS-SD TXT Records" in
<http://files.dns-sd.org/draft-cheshire-dnsext-dns-sd.txt>
<br><br>
txtRecord:       A TXTRecordRef initialized by calling TXTRecordCreate().
<br><br>
key:             A null-terminated string which only contains printable ASCII
values (0x20-0x7E), excluding '=' (0x3D). Keys should be
8 characters or less (not counting the terminating null).
</li></ol>
valueSize:       The size of the value.
<br><br>
value:           Any binary value. For values that represent
textual data, UTF-8 is STRONGLY recommended.
For values that represent textual data, valueSize
should NOT include the terminating null (if any)
at the end of the string.
If NULL, then "key" will be added with no value.
If non-NULL but valueSize is zero, then "key=" will be
added with empty value.
<br><br>
return value:    Returns kDNSServiceErr_NoError on success.
Returns kDNSServiceErr_Invalid if the "key" string contains
illegal characters.
Returns kDNSServiceErr_NoMemory if adding this key would
exceed the available storage.
 <!-- end discussion --></p>
<p></p><h2>Typedefs</h2>
<hr><!-- headerDoc=tdef;  uid=//apple_ref/c/tdef/DNSServiceBrowseReply;  name=DNSServiceBrowseReply -->
<a name="//apple_ref/c/tdef/DNSServiceBrowseReply"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="DNSServiceBrowseReply">DNSServiceBrowseReply</a></h3>
</td></tr></table><hr><p></p><pre><span class="keyword">typedef</span> <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> ( *<!-- a --><span class="function">DNSServiceBrowseReply</span><!-- /a -->) ( 
    <!-- a --><span class="type">DNSServiceRef</span><!-- /a --> <span class="param">sdRef</span>, 
    <!-- a --><span class="type">DNSServiceFlags</span><!-- /a --> <span class="param">flags</span>, 
    <!-- a --><span class="type">uint32_t</span><!-- /a --> <span class="param">interfaceIndex</span>, 
    <!-- a --><span class="type">DNSServiceErrorType</span><!-- /a --> <span class="param">errorCode</span>, 
    <span class="keyword">const</span> <!-- a --><span class="type">char</span><!-- /a --> *<span class="param">serviceName</span>, 
    <span class="keyword">const</span> <!-- a --><span class="type">char</span><!-- /a --> *<span class="param">regtype</span>, 
    <span class="keyword">const</span> <!-- a --><span class="type">char</span><!-- /a --> *<span class="param">replyDomain</span>, 
    <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> *<span class="param">context</span> );  </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->Browse for instances of a service.
<br><br>
<br><br>
DNSServiceBrowseReply() Parameters:
<br><br>
sdRef:           The DNSServiceRef initialized by DNSServiceBrowse().
<br><br>
flags:           Possible values are kDNSServiceFlagsMoreComing and kDNSServiceFlagsAdd.
See flag definitions for details.
<br><br>
interfaceIndex:  The interface on which the service is advertised. This index should
be passed to DNSServiceResolve() when resolving the service.
<br><br>
errorCode:       Will be kDNSServiceErr_NoError (0) on success, otherwise will
indicate the failure that occurred. Other parameters are undefined if
the errorCode is nonzero.
<br><br>
serviceName:     The discovered service name. This name should be displayed to the user,
and stored for subsequent use in the DNSServiceResolve() call.
<br><br>
regtype:         The service type, which is usually (but not always) the same as was passed
to DNSServiceBrowse(). One case where the discovered service type may
not be the same as the requested service type is when using subtypes:
The client may want to browse for only those ftp servers that allow
anonymous connections. The client will pass the string "_ftp._tcp,_anon"
to DNSServiceBrowse(), but the type of the service that's discovered
is simply "_ftp._tcp". The regtype for each discovered service instance
should be stored along with the name, so that it can be passed to
DNSServiceResolve() when the service is later resolved.
<br><br>
domain:          The domain of the discovered service instance. This may or may not be the
same as the domain that was passed to DNSServiceBrowse(). The domain for each
discovered service instance should be stored along with the name, so that
it can be passed to DNSServiceResolve() when the service is later resolved.
<br><br>
context:         The context pointer that was passed to the callout.
<br><br>
 <!-- end discussion --></p>
<p></p><hr><!-- headerDoc=tdef;  uid=//apple_ref/c/tdef/DNSServiceDomainEnumReply;  name=DNSServiceDomainEnumReply -->
<a name="//apple_ref/c/tdef/DNSServiceDomainEnumReply"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="DNSServiceDomainEnumReply">DNSServiceDomainEnumReply</a></h3>
</td></tr></table><hr><p></p><pre><span class="keyword">typedef</span> <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> ( *<!-- a --><span class="function">DNSServiceDomainEnumReply</span><!-- /a -->) ( 
    <!-- a --><span class="type">DNSServiceRef</span><!-- /a --> <span class="param">sdRef</span>, 
    <!-- a --><span class="type">DNSServiceFlags</span><!-- /a --> <span class="param">flags</span>, 
    <!-- a --><span class="type">uint32_t</span><!-- /a --> <span class="param">interfaceIndex</span>, 
    <!-- a --><span class="type">DNSServiceErrorType</span><!-- /a --> <span class="param">errorCode</span>, 
    <span class="keyword">const</span> <!-- a --><span class="type">char</span><!-- /a --> *<span class="param">replyDomain</span>, 
    <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> *<span class="param">context</span> );  </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->DNSServiceEnumerateDomains()
<br><br>
Asynchronously enumerate domains available for browsing and registration.
<br><br>
The enumeration MUST be cancelled via DNSServiceRefDeallocate() when no more domains
are to be found.
<br><br>
Note that the names returned are (like all of DNS-SD) UTF-8 strings,
and are escaped using standard DNS escaping rules.
(See "Notes on DNS Name Escaping" earlier in this file for more details.)
A graphical browser displaying a hierarchical tree-structured view should cut
the names at the bare dots to yield individual labels, then de-escape each
label according to the escaping rules, and then display the resulting UTF-8 text.
<br><br>
DNSServiceDomainEnumReply Callback Parameters:
<br><br>
sdRef:           The DNSServiceRef initialized by DNSServiceEnumerateDomains().
<br><br>
flags:           Possible values are:
kDNSServiceFlagsMoreComing
kDNSServiceFlagsAdd
kDNSServiceFlagsDefault
<br><br>
interfaceIndex:  Specifies the interface on which the domain exists. (The index for a given
interface is determined via the if_nametoindex() family of calls.)
<br><br>
errorCode:       Will be kDNSServiceErr_NoError (0) on success, otherwise indicates
the failure that occurred (other parameters are undefined if errorCode is nonzero).
<br><br>
replyDomain:     The name of the domain.
<br><br>
context:         The context pointer passed to DNSServiceEnumerateDomains.
<br><br>
 <!-- end discussion --></p>
<p></p><hr><!-- headerDoc=tdef;  uid=//apple_ref/c/tdef/DNSServiceGetAddrInfoReply;  name=DNSServiceGetAddrInfoReply -->
<a name="//apple_ref/c/tdef/DNSServiceGetAddrInfoReply"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="DNSServiceGetAddrInfoReply">DNSServiceGetAddrInfoReply</a></h3>
</td></tr></table><hr><p></p><pre><span class="keyword">typedef</span> <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> ( *<!-- a --><span class="function">DNSServiceGetAddrInfoReply</span><!-- /a -->) ( 
    <!-- a --><span class="type">DNSServiceRef</span><!-- /a --> <span class="param">sdRef</span>, 
    <!-- a --><span class="type">DNSServiceFlags</span><!-- /a --> <span class="param">flags</span>, 
    <!-- a --><span class="type">uint32_t</span><!-- /a --> <span class="param">interfaceIndex</span>, 
    <!-- a --><span class="type">DNSServiceErrorType</span><!-- /a --> <span class="param">errorCode</span>, 
    <span class="keyword">const</span> <!-- a --><span class="type">char</span><!-- /a --> *<span class="param">hostname</span>, 
    <span class="keyword">const</span> <span class="keyword">struct</span> <!-- a --><span class="type">sockaddr</span><!-- /a --> *<span class="param">address</span>, 
    <!-- a --><span class="type">uint32_t</span><!-- /a --> <span class="param">ttl</span>, 
    <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> *<span class="param">context</span> );  </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->DNSServiceGetAddrInfo
<br><br>
Queries for the IP address of a hostname by using either Multicast or Unicast DNS.
<br><br>
<br><br>
DNSServiceGetAddrInfoReply() parameters:
<br><br>
sdRef:           The DNSServiceRef initialized by DNSServiceGetAddrInfo().
<br><br>
flags:           Possible values are kDNSServiceFlagsMoreComing and
kDNSServiceFlagsAdd.
<br><br>
interfaceIndex:  The interface to which the answers pertain.
<br><br>
errorCode:       Will be kDNSServiceErr_NoError on success, otherwise will
indicate the failure that occurred.  Other parameters are
undefined if errorCode is nonzero.
<br><br>
hostname:        The fully qualified domain name of the host to be queried for.
<br><br>
address:         IPv4 or IPv6 address.
<br><br>
ttl:             If the client wishes to cache the result for performance reasons,
the TTL indicates how long the client may legitimately hold onto
this result, in seconds. After the TTL expires, the client should
consider the result no longer valid, and if it requires this data
again, it should be re-fetched with a new query. Of course, this
only applies to clients that cancel the asynchronous operation when
they get a result. Clients that leave the asynchronous operation
running can safely assume that the data remains valid until they
get another callback telling them otherwise.
<br><br>
context:         The context pointer that was passed to the callout.
<br><br>
 <!-- end discussion --></p>
<p></p><hr><!-- headerDoc=tdef;  uid=//apple_ref/c/tdef/DNSServiceNATPortMappingReply;  name=DNSServiceNATPortMappingReply -->
<a name="//apple_ref/c/tdef/DNSServiceNATPortMappingReply"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="DNSServiceNATPortMappingReply">DNSServiceNATPortMappingReply</a></h3>
</td></tr></table><hr><p></p><pre><span class="keyword">typedef</span> <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> ( *<!-- a --><span class="function">DNSServiceNATPortMappingReply</span><!-- /a -->) ( 
    <!-- a --><span class="type">DNSServiceRef</span><!-- /a --> <span class="param">sdRef</span>, 
    <!-- a --><span class="type">DNSServiceFlags</span><!-- /a --> <span class="param">flags</span>, 
    <!-- a --><span class="type">uint32_t</span><!-- /a --> <span class="param">interfaceIndex</span>, 
    <!-- a --><span class="type">DNSServiceErrorType</span><!-- /a --> <span class="param">errorCode</span>, 
    <!-- a --><span class="type">uint32_t</span><!-- /a --> <span class="param">publicAddress</span>, <span class="comment">/* four byte IPv4 address in network byte order */</span>
    <!-- a --><span class="type">DNSServiceProtocol</span><!-- /a --> <span class="param">protocol</span>, 
    <!-- a --><span class="type">uint16_t</span><!-- /a --> <span class="param">privatePort</span>, 
    <!-- a --><span class="type">uint16_t</span><!-- /a --> <span class="param">publicPort</span>, <span class="comment">/* may be different than the requested port */</span>
    <!-- a --><span class="type">uint32_t</span><!-- /a --> <span class="param">ttl</span>, <span class="comment">/* may be different than the requested ttl */</span>
    <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> *<span class="param">context</span> );  </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->DNSServiceNATPortMappingCreate
<br><br>
Request a port mapping in the NAT gateway which maps a port on the local machine
to a public port on the NAT.
The port mapping will be renewed indefinitely until the client process exits, or
explicitly terminates the port mapping request by calling DNSServiceRefDeallocate().
The client callback will be invoked, informing the client of the NAT gateway's
public IP address and the public port that has been allocated for this client.
The client should then record this public IP address and port using whatever
directory service mechanism it is using to enable peers to connect to it.
(Clients advertising services using Wide-Area DNS-SD DO NOT need to use this API
-- when a client calls DNSServiceRegister() NAT mappings are automatically created
and the public IP address and port for the service are recorded in the global DNS.
Only clients using some directory mechanism other than Wide-Area DNS-SD need to use
this API to explicitly map their own ports.)
It's possible that the client callback could be called multiple times, for example
if the NAT gateway's IP address changes, or if a configuration change results in a
different public port being mapped for this client. Over the lifetime of any long-lived
port mapping, the client should be prepared to handle these notifications of changes
in the environment, and should update its recorded address and/or port as appropriate.
<br><br>
<br><br>
DNSServiceNATPortMappingReply() parameters:
<br><br>
sdRef:           The DNSServiceRef initialized by DNSServiceNATPortMappingCreate().
<br><br>
flags:           Currently unused, reserved for future use.
<br><br>
interfaceIndex:  The interface through which the NAT gateway is reached.
<br><br>
errorCode:       Will be kDNSServiceErr_NoError on success, otherwise will
indicate the failure that occurred. Other parameters are
undefined if errorCode is nonzero.
<br><br>
publicAddress:   Four byte IPv4 address in network byte order.
<br><br>
protocol:        Will be kDNSServiceProtocol_UDP or kDNSServiceProtocol_TCP or both.
<br><br>
privatePort:     The port on the local machine that was mapped.
<br><br>
publicPort:      The actual public port in the NAT gateway that was mapped.
This is very likely to be different than the requested public port.
<br><br>
ttl:             The lifetime of the NAT port mapping created on the gateway.
This controls how quickly stale mappings will be garbage-collected
if the client machine crashes, suffers a power failure, is disconnected
from the network, or suffers some other unfortunate demise which
causes it to vanish without explicitly removing its NAT port mapping.
It's possible that the ttl value will differ from the requested ttl value.
<br><br>
context:         The context pointer that was passed to the callout.
<br><br>
 <!-- end discussion --></p>
<p></p><hr><!-- headerDoc=tdef;  uid=//apple_ref/c/tdef/DNSServiceQueryRecordReply;  name=DNSServiceQueryRecordReply -->
<a name="//apple_ref/c/tdef/DNSServiceQueryRecordReply"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="DNSServiceQueryRecordReply">DNSServiceQueryRecordReply</a></h3>
</td></tr></table><hr><p></p><pre><span class="keyword">typedef</span> <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> ( *<!-- a --><span class="function">DNSServiceQueryRecordReply</span><!-- /a -->) ( 
    <!-- a --><span class="type">DNSServiceRef</span><!-- /a --> <span class="param">DNSServiceRef</span>, 
    <!-- a --><span class="type">DNSServiceFlags</span><!-- /a --> <span class="param">flags</span>, 
    <!-- a --><span class="type">uint32_t</span><!-- /a --> <span class="param">interfaceIndex</span>, 
    <!-- a --><span class="type">DNSServiceErrorType</span><!-- /a --> <span class="param">errorCode</span>, 
    <span class="keyword">const</span> <!-- a --><span class="type">char</span><!-- /a --> *<span class="param">fullname</span>, 
    <!-- a --><span class="type">uint16_t</span><!-- /a --> <span class="param">rrtype</span>, 
    <!-- a --><span class="type">uint16_t</span><!-- /a --> <span class="param">rrclass</span>, 
    <!-- a --><span class="type">uint16_t</span><!-- /a --> <span class="param">rdlen</span>, 
    <span class="keyword">const</span> <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> *<span class="param">rdata</span>, 
    <!-- a --><span class="type">uint32_t</span><!-- /a --> <span class="param">ttl</span>, 
    <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> *<span class="param">context</span> );  </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->DNSServiceQueryRecord
<br><br>
Query for an arbitrary DNS record.
<br><br>
<br><br>
DNSServiceQueryRecordReply() Callback Parameters:
<br><br>
sdRef:           The DNSServiceRef initialized by DNSServiceQueryRecord().
<br><br>
flags:           Possible values are kDNSServiceFlagsMoreComing and
kDNSServiceFlagsAdd. The Add flag is NOT set for PTR records
with a ttl of 0, i.e. "Remove" events.
<br><br>
interfaceIndex:  The interface on which the query was resolved (the index for a given
interface is determined via the if_nametoindex() family of calls).
See "Constants for specifying an interface index" for more details.
<br><br>
errorCode:       Will be kDNSServiceErr_NoError on success, otherwise will
indicate the failure that occurred. Other parameters are undefined if
errorCode is nonzero.
<br><br>
fullname:        The resource record's full domain name.
<br><br>
rrtype:          The resource record's type (e.g. kDNSServiceType_PTR, kDNSServiceType_SRV, etc)
<br><br>
rrclass:         The class of the resource record (usually kDNSServiceClass_IN).
<br><br>
rdlen:           The length, in bytes, of the resource record rdata.
<br><br>
rdata:           The raw rdata of the resource record.
<br><br>
ttl:             If the client wishes to cache the result for performance reasons,
the TTL indicates how long the client may legitimately hold onto
this result, in seconds. After the TTL expires, the client should
consider the result no longer valid, and if it requires this data
again, it should be re-fetched with a new query. Of course, this
only applies to clients that cancel the asynchronous operation when
they get a result. Clients that leave the asynchronous operation
running can safely assume that the data remains valid until they
get another callback telling them otherwise.
<br><br>
context:         The context pointer that was passed to the callout.
<br><br>
 <!-- end discussion --></p>
<p></p><hr><!-- headerDoc=tdef;  uid=//apple_ref/c/tdef/DNSServiceRegisterRecordReply;  name=DNSServiceRegisterRecordReply -->
<a name="//apple_ref/c/tdef/DNSServiceRegisterRecordReply"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="DNSServiceRegisterRecordReply">DNSServiceRegisterRecordReply</a></h3>
</td></tr></table><hr><p></p><pre><span class="keyword">typedef</span> <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> ( *<!-- a --><span class="function">DNSServiceRegisterRecordReply</span><!-- /a -->) ( 
    <!-- a --><span class="type">DNSServiceRef</span><!-- /a --> <span class="param">sdRef</span>, 
    <!-- a --><span class="type">DNSRecordRef</span><!-- /a --> <span class="param">RecordRef</span>, 
    <!-- a --><span class="type">DNSServiceFlags</span><!-- /a --> <span class="param">flags</span>, 
    <!-- a --><span class="type">DNSServiceErrorType</span><!-- /a --> <span class="param">errorCode</span>, 
    <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> *<span class="param">context</span> );  </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->DNSServiceRegisterRecord
<br><br>
Register an individual resource record on a connected DNSServiceRef.
<br><br>
Note that name conflicts occurring for records registered via this call must be handled
by the client in the callback.
<br><br>
<br><br>
DNSServiceRegisterRecordReply() parameters:
<br><br>
sdRef:           The connected DNSServiceRef initialized by
DNSServiceCreateConnection().
<br><br>
RecordRef:       The DNSRecordRef initialized by DNSServiceRegisterRecord(). If the above
DNSServiceRef is passed to DNSServiceRefDeallocate(), this DNSRecordRef is
invalidated, and may not be used further.
<br><br>
flags:           Currently unused, reserved for future use.
<br><br>
errorCode:       Will be kDNSServiceErr_NoError on success, otherwise will
indicate the failure that occurred (including name conflicts.)
Other parameters are undefined if errorCode is nonzero.
<br><br>
context:         The context pointer that was passed to the callout.
<br><br>
 <!-- end discussion --></p>
<p></p><hr><!-- headerDoc=tdef;  uid=//apple_ref/c/tdef/DNSServiceRegisterReply;  name=DNSServiceRegisterReply -->
<a name="//apple_ref/c/tdef/DNSServiceRegisterReply"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="DNSServiceRegisterReply">DNSServiceRegisterReply</a></h3>
</td></tr></table><hr><p></p><pre><span class="keyword">typedef</span> <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> ( *<!-- a --><span class="function">DNSServiceRegisterReply</span><!-- /a -->) ( 
    <!-- a --><span class="type">DNSServiceRef</span><!-- /a --> <span class="param">sdRef</span>, 
    <!-- a --><span class="type">DNSServiceFlags</span><!-- /a --> <span class="param">flags</span>, 
    <!-- a --><span class="type">DNSServiceErrorType</span><!-- /a --> <span class="param">errorCode</span>, 
    <span class="keyword">const</span> <!-- a --><span class="type">char</span><!-- /a --> *<span class="param">name</span>, 
    <span class="keyword">const</span> <!-- a --><span class="type">char</span><!-- /a --> *<span class="param">regtype</span>, 
    <span class="keyword">const</span> <!-- a --><span class="type">char</span><!-- /a --> *<span class="param">domain</span>, 
    <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> *<span class="param">context</span> );  </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->Register a service that is discovered via Browse() and Resolve() calls.
<br><br>
<br><br>
DNSServiceRegisterReply() Callback Parameters:
<br><br>
sdRef:           The DNSServiceRef initialized by DNSServiceRegister().
<br><br>
flags:           When a name is successfully registered, the callback will be
invoked with the kDNSServiceFlagsAdd flag set. When Wide-Area
DNS-SD is in use, it is possible for a single service to get
more than one success callback (e.g. one in the "local" multicast
DNS domain, and another in a wide-area unicast DNS domain).
If a successfully-registered name later suffers a name conflict
or similar problem and has to be deregistered, the callback will
be invoked with the kDNSServiceFlagsAdd flag not set. The callback
is *not* invoked in the case where the caller explicitly terminates
the service registration by calling DNSServiceRefDeallocate(ref);
<br><br>
errorCode:       Will be kDNSServiceErr_NoError on success, otherwise will
indicate the failure that occurred (including name conflicts,
if the kDNSServiceFlagsNoAutoRename flag was used when registering.)
Other parameters are undefined if errorCode is nonzero.
<br><br>
name:            The service name registered (if the application did not specify a name in
DNSServiceRegister(), this indicates what name was automatically chosen).
<br><br>
regtype:         The type of service registered, as it was passed to the callout.
<br><br>
domain:          The domain on which the service was registered (if the application did not
specify a domain in DNSServiceRegister(), this indicates the default domain
on which the service was registered).
<br><br>
context:         The context pointer that was passed to the callout.
<br><br>
 <!-- end discussion --></p>
<p></p><hr><!-- headerDoc=tdef;  uid=//apple_ref/c/tdef/DNSServiceResolveReply;  name=DNSServiceResolveReply -->
<a name="//apple_ref/c/tdef/DNSServiceResolveReply"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="DNSServiceResolveReply">DNSServiceResolveReply</a></h3>
</td></tr></table><hr><p></p><pre><span class="keyword">typedef</span> <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> ( *<!-- a --><span class="function">DNSServiceResolveReply</span><!-- /a -->) ( 
    <!-- a --><span class="type">DNSServiceRef</span><!-- /a --> <span class="param">sdRef</span>, 
    <!-- a --><span class="type">DNSServiceFlags</span><!-- /a --> <span class="param">flags</span>, 
    <!-- a --><span class="type">uint32_t</span><!-- /a --> <span class="param">interfaceIndex</span>, 
    <!-- a --><span class="type">DNSServiceErrorType</span><!-- /a --> <span class="param">errorCode</span>, 
    <span class="keyword">const</span> <!-- a --><span class="type">char</span><!-- /a --> *<span class="param">fullname</span>, 
    <span class="keyword">const</span> <!-- a --><span class="type">char</span><!-- /a --> *<span class="param">hosttarget</span>, 
    <!-- a --><span class="type">uint16_t</span><!-- /a --> <span class="param">port</span>, 
    <!-- a --><span class="type">uint16_t</span><!-- /a --> <span class="param">txtLen</span>, 
    <span class="keyword">const</span> <span class="keyword">unsigned</span> <!-- a --><span class="type">char</span><!-- /a --> *<span class="param">txtRecord</span>, 
    <a href="../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> *<span class="param">context</span> );  </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->DNSServiceResolve()
<br><br>
Resolve a service name discovered via DNSServiceBrowse() to a target host name, port number, and
txt record.
<br><br>
Note: Applications should NOT use DNSServiceResolve() solely for txt record monitoring - use
DNSServiceQueryRecord() instead, as it is more efficient for this task.
<br><br>
Note: When the desired results have been returned, the client MUST terminate the resolve by calling
DNSServiceRefDeallocate().
<br><br>
Note: DNSServiceResolve() behaves correctly for typical services that have a single SRV record
and a single TXT record. To resolve non-standard services with multiple SRV or TXT records,
DNSServiceQueryRecord() should be used.
<br><br>
DNSServiceResolveReply Callback Parameters:
<br><br>
sdRef:           The DNSServiceRef initialized by DNSServiceResolve().
<br><br>
flags:           Possible values: kDNSServiceFlagsMoreComing
<br><br>
interfaceIndex:  The interface on which the service was resolved.
<br><br>
errorCode:       Will be kDNSServiceErr_NoError (0) on success, otherwise will
indicate the failure that occurred. Other parameters are undefined if
the errorCode is nonzero.
<br><br>
fullname:        The full service domain name, in the form <servicename>.<protocol>.<domain>.
(This name is escaped following standard DNS rules, making it suitable for
passing to standard system DNS APIs such as res_query(), or to the
special-purpose functions included in this API that take fullname parameters.
See "Notes on DNS Name Escaping" earlier in this file for more details.)
<br><br>
hosttarget:      The target hostname of the machine providing the service. This name can
be passed to functions like gethostbyname() to identify the host's IP address.
<br><br>
port:            The port, in network byte order, on which connections are accepted for this service.
<br><br>
txtLen:          The length of the txt record, in bytes.
<br><br>
txtRecord:       The service's primary txt record, in standard txt record format.
<br><br>
context:         The context pointer that was passed to the callout.
<br><br>
NOTE: In earlier versions of this header file, the txtRecord parameter was declared "const char *"
This is incorrect, since it contains length bytes which are values in the range 0 to 255, not -128 to +127.
Depending on your compiler settings, this change may cause signed/unsigned mismatch warnings.
These should be fixed by updating your own callback function definition to match the corrected
function signature using "const unsigned char *txtRecord". Making this change may also fix inadvertent
bugs in your callback function, where it could have incorrectly interpreted a length byte with value 250
as being -6 instead, with various bad consequences ranging from incorrect operation to software crashes.
If you need to maintain portable code that will compile cleanly with both the old and new versions of
this header file, you should update your callback function definition to use the correct unsigned value,
and then in the place where you pass your callback function to DNSServiceResolve(), use a cast to eliminate
the compiler warning, e.g.:
DNSServiceResolve(sd, flags, index, name, regtype, domain, (DNSServiceResolveReply)MyCallback, context);
This will ensure that your code compiles cleanly without warnings (and more importantly, works correctly)
with both the old header and with the new corrected version.
<br><br>
 <!-- end discussion --></p>
<p></p><hr><!-- headerDoc=tdef;  uid=//apple_ref/c/tdef/TXTRecordRef;  name=TXTRecordRef -->
<a name="//apple_ref/c/tdef/TXTRecordRef"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="TXTRecordRef">TXTRecordRef</a></h3>
</td></tr></table><hr><p></p><pre><span class="keyword">typedef</span> <span class="keyword">union</span> <!-- a --><span class="type">_TXTRecordRef_t</span><!-- /a --> {
    <!-- a --><span class="type">char</span><!-- /a --> <!-- a --><span class="type">PrivateData</span><!-- /a -->[<span class="number">16</span>];
    <!-- a --><span class="type">char</span><!-- /a --> *<span class="var">ForceNaturalAlignment</span>;
} <span class="var">TXTRecordRef</span>;  </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->TXTRecordRef
<br><br>
Opaque internal data type.
Note: Represents a DNS-SD TXT record.
 <!-- end discussion --></p>
<p></p><h2>Enumerations</h2>
<hr><!-- headerDoc=title:tag;  uid=//apple_ref/doc/title:tag/Generalflags;  name=General flags -->
<a name="//apple_ref/doc/title:tag/Generalflags"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="Generalflags">General flags</a></h3>
</td></tr></table><hr><p></p><pre><span class="keyword">enum</span> {  
    <!-- a --><span class="type">kDNSServiceFlagsMoreComing</span><!-- /a --> = <span class="number">0x1</span>,   
    <!-- a --><span class="type">kDNSServiceFlagsAdd</span><!-- /a --> = <span class="number">0x2</span>,  
    <!-- a --><span class="type">kDNSServiceFlagsDefault</span><!-- /a --> = <span class="number">0x4</span>,   
    <!-- a --><span class="type">kDNSServiceFlagsNoAutoRename</span><!-- /a --> = <span class="number">0x8</span>,   
    <!-- a --><span class="type">kDNSServiceFlagsShared</span><!-- /a --> = <span class="number">0x10</span>,   
    <!-- a --><span class="type">kDNSServiceFlagsUnique</span><!-- /a --> = <span class="number">0x20</span>,    
    <!-- a --><span class="type">kDNSServiceFlagsBrowseDomains</span><!-- /a --> = <span class="number">0x40</span>,  
    <!-- a --><span class="type">kDNSServiceFlagsRegistrationDomains</span><!-- /a --> = <span class="number">0x80</span>,   
    <!-- a --><span class="type">kDNSServiceFlagsLongLivedQuery</span><!-- /a --> = <span class="number">0x100</span>,   
    <!-- a --><span class="type">kDNSServiceFlagsAllowRemoteQuery</span><!-- /a --> = <span class="number">0x200</span>,   
    <!-- a --><span class="type">kDNSServiceFlagsForceMulticast</span><!-- /a --> = <span class="number">0x400</span>,   
    <!-- a --><span class="type">kDNSServiceFlagsForce</span><!-- /a --> = <span class="number">0x800</span>,   
    <!-- a --><span class="type">kDNSServiceFlagsReturnIntermediates</span><!-- /a --> = <span class="number">0x1000</span>,   
    <span class="">#define</span><span class="preprocessor"> </span><!-- a --><span class="preprocessor">kDNSServiceFlagsReturnCNAME</span><!-- /a --><span class="preprocessor"> </span><!-- a --><span class="preprocessor">kDNSServiceFlagsReturnIntermediates</span><!-- /a -->   
    <!-- a --><span class="type">kDNSServiceFlagsNonBrowsable</span><!-- /a --> = <span class="number">0x2000</span>,   
    <!-- a --><span class="type">kDNSServiceFlagsShareConnection</span><!-- /a --> = <span class="number">0x4000</span>  
};  </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Constants</font></h5>
<blockquote>
<dl>
<dt><a name="//apple_ref/doc/title:econst/kDNSServiceFlagsMoreComing"><code>kDNSServiceFlagsMoreComing</code></a></dt><dd>MoreComing indicates to a callback that at least one more result is
queued and will be delivered following immediately after this one.
When the MoreComing flag is set, applications should not immediately
update their UI, because this can result in a great deal of ugly flickering
on the screen, and can waste a great deal of CPU time repeatedly updating
the screen with content that is then immediately erased, over and over.
Applications should wait until until MoreComing is not set, and then
update their UI when no more changes are imminent.
<br><br>
When MoreComing is not set, that doesn't mean there will be no more
answers EVER, just that there are no more answers immediately
available right now at this instant. If more answers become available
in the future they will be delivered as usual.</dd>
<dt><a name="//apple_ref/doc/title:econst/kDNSServiceFlagsAdd"><code>kDNSServiceFlagsAdd</code></a></dt><dd>Flags for domain enumeration and browse/query reply callbacks.
An enumeration callback with the "Add"
flag NOT set indicates a "Remove", i.e. the domain is no longer
valid.</dd>
<dt><a name="//apple_ref/doc/title:econst/kDNSServiceFlagsDefault"><code>kDNSServiceFlagsDefault</code></a></dt><dd>Flags for domain enumeration and browse/query reply callbacks.
"Default" applies only to enumeration and is only valid in
conjunction with "Add".</dd>
<dt><a name="//apple_ref/doc/title:econst/kDNSServiceFlagsNoAutoRename"><code>kDNSServiceFlagsNoAutoRename</code></a></dt><dd>Flag for specifying renaming behavior on name conflict when registering
non-shared records. By default, name conflicts are automatically handled
by renaming the service. NoAutoRename overrides this behavior - with this
flag set, name conflicts will result in a callback. The NoAutorename flag
is only valid if a name is explicitly specified when registering a service
(i.e. the default name is not used.)</dd>
<dt><a name="//apple_ref/doc/title:econst/kDNSServiceFlagsShared"><code>kDNSServiceFlagsShared</code></a></dt><dd>Flag for registering individual records on a connected
DNSServiceRef. Shared indicates that there may be multiple records
with this name on the network (e.g. PTR records).</dd>
<dt><a name="//apple_ref/doc/title:econst/kDNSServiceFlagsUnique"><code>kDNSServiceFlagsUnique</code></a></dt><dd>Flag for registering individual records on a connected
DNSServiceRef. Unique indicates that the
record's name is to be unique on the network (e.g. SRV records).</dd>
<dt><a name="//apple_ref/doc/title:econst/kDNSServiceFlagsBrowseDomains"><code>kDNSServiceFlagsBrowseDomains</code></a></dt><dd>Flags for specifying domain enumeration type in DNSServiceEnumerateDomains.
BrowseDomains enumerates domains recommended for browsing.</dd>
<dt><a name="//apple_ref/doc/title:econst/kDNSServiceFlagsRegistrationDomains"><code>kDNSServiceFlagsRegistrationDomains</code></a></dt><dd>Flags for specifying domain enumeration type in DNSServiceEnumerateDomains.
RegistrationDomains enumerates domains recommended for registration.</dd>
<dt><a name="//apple_ref/doc/title:econst/kDNSServiceFlagsLongLivedQuery"><code>kDNSServiceFlagsLongLivedQuery</code></a></dt><dd>Flag for creating a long-lived unicast query for the DNSServiceQueryRecord call.</dd>
<dt><a name="//apple_ref/doc/title:econst/kDNSServiceFlagsAllowRemoteQuery"><code>kDNSServiceFlagsAllowRemoteQuery</code></a></dt><dd>Flag for creating a record for which we will answer remote queries
(queries from hosts more than one hop away; hosts not directly connected to the local link).</dd>
<dt><a name="//apple_ref/doc/title:econst/kDNSServiceFlagsForceMulticast"><code>kDNSServiceFlagsForceMulticast</code></a></dt><dd>Flag for signifying that a query or registration should be performed exclusively via multicast
DNS, even for a name in a domain (e.g. foo.apple.com.) that would normally imply unicast DNS.</dd>
<dt><a name="//apple_ref/doc/title:econst/kDNSServiceFlagsForce"><code>kDNSServiceFlagsForce</code></a></dt><dd>Flag for signifying a "stronger" variant of an operation.
Currently defined only for DNSServiceReconfirmRecord(), where it forces a record to
be removed from the cache immediately, instead of querying for a few seconds before
concluding that the record is no longer valid and then removing it. This flag should
be used with caution because if a service browsing PTR record is indeed still valid
on the network, forcing its removal will result in a user-interface flap -- the
discovered service instance will disappear, and then re-appear moments later.</dd>
<dt><a name="//apple_ref/doc/title:econst/kDNSServiceFlagsReturnIntermediates"><code>kDNSServiceFlagsReturnIntermediates</code></a></dt><dd>Flag for returning intermediate results.
For example, if a query results in an authoritative NXDomain (name does not exist)
then that result is returned to the client. However the query is not implicitly
cancelled -- it remains active and if the answer subsequently changes
(e.g. because a VPN tunnel is subsequently established) then that positive
result will still be returned to the client.
Similarly, if a query results in a CNAME record, then in addition to following
the CNAME referral, the intermediate CNAME result is also returned to the client.
When this flag is not set, NXDomain errors are not returned, and CNAME records
are followed silently without informing the client of the intermediate steps.</dd>
</dl>
</blockquote>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->Most DNS-SD API functions and callbacks include a DNSServiceFlags parameter.
As a general rule, any given bit in the 32-bit flags field has a specific fixed meaning,
regardless of the function or callback being used. For any given function or callback,
typically only a subset of the possible flags are meaningful, and all others should be zero.
The discussion section for each API call describes which flags are valid for that call
and callback. In some cases, for a particular call, it may be that no flags are currently
defined, in which case the DNSServiceFlags parameter exists purely to allow future expansion.
In all cases, developers should expect that in future releases, it is possible that new flag
values will be defined, and write code with this in mind. For example, code that tests
<br><br>
if (flags == kDNSServiceFlagsAdd) ...
<br><br>
will fail if, in a future release, another bit in the 32-bit flags field is also set.
The reliable way to test whether a particular bit is set is not with an equality test,
but with a bitwise mask:
<br><br>
if (flags & kDNSServiceFlagsAdd) ...<!-- end discussion --></p>
<p></p><h2>#defines</h2>
<hr><!-- headerDoc=title:macro;  uid=//apple_ref/doc/title:macro/Constantsforspecifyinganinterfaceindex;  name=Constants for specifying an interface index -->
<a name="//apple_ref/doc/title:macro/Constantsforspecifyinganinterfaceindex"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="Constantsforspecifyinganinterfaceindex">Constants for specifying an interface index</a></h3>
</td></tr></table><hr><p></p><b>See Also:</b><blockquote><dl>
<dt><a href="CompositePage.html#//apple_ref/c/macro/kDNSServiceInterfaceIndexAny">kDNSServiceInterfaceIndexAny</a></dt><dd></dd><dt><a href="CompositePage.html#//apple_ref/c/macro/kDNSServiceInterfaceIndexLocalOnly">kDNSServiceInterfaceIndexLocalOnly</a></dt><dd></dd><dt><a href="CompositePage.html#//apple_ref/c/macro/kDNSServiceInterfaceIndexUnicast">kDNSServiceInterfaceIndexUnicast</a></dt><dd></dd></dl></blockquote>
<pre><span class="">#define</span><span class="preprocessor"> </span><a href="CompositePage.html#//apple_ref/c/macro/kDNSServiceInterfaceIndexAny" class="preprocessor"><span class="preprocessor">kDNSServiceInterfaceIndexAny</span></a><span class="preprocessor"> </span><span class="preprocessor">0</span> 
<span class="">#define</span><span class="preprocessor"> </span><a href="CompositePage.html#//apple_ref/c/macro/kDNSServiceInterfaceIndexLocalOnly" class="preprocessor"><span class="preprocessor">kDNSServiceInterfaceIndexLocalOnly</span></a><span class="preprocessor"> </span><span class="ignore"></span><span class="ignore"></span><span class="ignore"></span><span class="ignore"></span><span class="ignore"></span> 
<span class="">#define</span><span class="preprocessor"> </span><a href="CompositePage.html#//apple_ref/c/macro/kDNSServiceInterfaceIndexUnicast" class="preprocessor"><span class="preprocessor">kDNSServiceInterfaceIndexUnicast</span></a><span class="preprocessor"> </span><span class="ignore"></span><span class="ignore"></span><span class="ignore"></span><span class="ignore"></span><span class="ignore"></span> 
  <span class="keyword">typedef</span> <!-- a --><span class="type">uint32_t</span><!-- /a --> <span class="var">DNSServiceFlags</span>;  
</pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion --><br><br>
Specific interface indexes are identified via a 32-bit unsigned integer returned
by the if_nametoindex() family of calls.
<br><br>
If the client passes 0 for interface index, that means "do the right thing",
which (at present) means, "if the name is in an mDNS local multicast domain
(e.g. 'local.', '254.169.in-addr.arpa.', '{8,9,A,B}.E.F.ip6.arpa.') then multicast
on all applicable interfaces, otherwise send via unicast to the appropriate
DNS server." Normally, most clients will use 0 for interface index to
automatically get the default sensible behaviour.
<br><br>
If the client passes a positive interface index, then for multicast names that
indicates to do the operation only on that one interface. For unicast names the
interface index is ignored unless kDNSServiceFlagsForceMulticast is also set.
<br><br>
If the client passes kDNSServiceInterfaceIndexLocalOnly when registering
a service, then that service will be found *only* by other local clients
on the same machine that are browsing using kDNSServiceInterfaceIndexLocalOnly
or kDNSServiceInterfaceIndexAny.
If a client has a 'private' service, accessible only to other processes
running on the same machine, this allows the client to advertise that service
in a way such that it does not inadvertently appear in service lists on
all the other machines on the network.
<br><br>
If the client passes kDNSServiceInterfaceIndexLocalOnly when browsing
then it will find *all* records registered on that same local machine.
Clients explicitly wishing to discover *only* LocalOnly services can
accomplish this by inspecting the interfaceIndex of each service reported
to their DNSServiceBrowseReply() callback function, and discarding those
where the interface index is not kDNSServiceInterfaceIndexLocalOnly.<!-- end discussion --></p>
<p></p><hr><!-- headerDoc=macro;  uid=//apple_ref/c/macro/kDNSServiceInterfaceIndexAny;  name=kDNSServiceInterfaceIndexAny -->
<a name="//apple_ref/c/macro/kDNSServiceInterfaceIndexAny"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="kDNSServiceInterfaceIndexAny">kDNSServiceInterfaceIndexAny</a></h3>
</td></tr></table><hr><p></p><b>See Also:</b><blockquote><dl>
<dt><a href="CompositePage.html#//apple_ref/doc/title:macro/Constantsforspecifyinganinterfaceindex">Constants for specifying an interface index</a></dt><dd></dd></dl></blockquote>
<pre><span class="">#define</span><span class="preprocessor"> </span><a href="CompositePage.html#//apple_ref/c/macro/kDNSServiceInterfaceIndexAny" class="preprocessor"><span class="preprocessor">kDNSServiceInterfaceIndexAny</span></a><span class="preprocessor"> </span><span class="preprocessor">0</span> </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion --><br><br>
Specific interface indexes are identified via a 32-bit unsigned integer returned
by the if_nametoindex() family of calls.
<br><br>
If the client passes 0 for interface index, that means "do the right thing",
which (at present) means, "if the name is in an mDNS local multicast domain
(e.g. 'local.', '254.169.in-addr.arpa.', '{8,9,A,B}.E.F.ip6.arpa.') then multicast
on all applicable interfaces, otherwise send via unicast to the appropriate
DNS server." Normally, most clients will use 0 for interface index to
automatically get the default sensible behaviour.
<br><br>
If the client passes a positive interface index, then for multicast names that
indicates to do the operation only on that one interface. For unicast names the
interface index is ignored unless kDNSServiceFlagsForceMulticast is also set.
<br><br>
If the client passes kDNSServiceInterfaceIndexLocalOnly when registering
a service, then that service will be found *only* by other local clients
on the same machine that are browsing using kDNSServiceInterfaceIndexLocalOnly
or kDNSServiceInterfaceIndexAny.
If a client has a 'private' service, accessible only to other processes
running on the same machine, this allows the client to advertise that service
in a way such that it does not inadvertently appear in service lists on
all the other machines on the network.
<br><br>
If the client passes kDNSServiceInterfaceIndexLocalOnly when browsing
then it will find *all* records registered on that same local machine.
Clients explicitly wishing to discover *only* LocalOnly services can
accomplish this by inspecting the interfaceIndex of each service reported
to their DNSServiceBrowseReply() callback function, and discarding those
where the interface index is not kDNSServiceInterfaceIndexLocalOnly.<!-- end discussion --></p>
<p></p><hr><!-- headerDoc=macro;  uid=//apple_ref/c/macro/kDNSServiceInterfaceIndexLocalOnly;  name=kDNSServiceInterfaceIndexLocalOnly -->
<a name="//apple_ref/c/macro/kDNSServiceInterfaceIndexLocalOnly"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="kDNSServiceInterfaceIndexLocalOnly">kDNSServiceInterfaceIndexLocalOnly</a></h3>
</td></tr></table><hr><p><b>Value:</b> 0xffffffff (-1)<br>
</p><b>See Also:</b><blockquote><dl>
<dt><a href="CompositePage.html#//apple_ref/doc/title:macro/Constantsforspecifyinganinterfaceindex">Constants for specifying an interface index</a></dt><dd></dd></dl></blockquote>
<pre><span class="">#define</span><span class="preprocessor"> </span><a href="CompositePage.html#//apple_ref/c/macro/kDNSServiceInterfaceIndexLocalOnly" class="preprocessor"><span class="preprocessor">kDNSServiceInterfaceIndexLocalOnly</span></a><span class="preprocessor"> </span><span class="ignore"></span><span class="ignore"></span><span class="ignore"></span><span class="ignore"></span><span class="ignore"></span> </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion --><br><br>
Specific interface indexes are identified via a 32-bit unsigned integer returned
by the if_nametoindex() family of calls.
<br><br>
If the client passes 0 for interface index, that means "do the right thing",
which (at present) means, "if the name is in an mDNS local multicast domain
(e.g. 'local.', '254.169.in-addr.arpa.', '{8,9,A,B}.E.F.ip6.arpa.') then multicast
on all applicable interfaces, otherwise send via unicast to the appropriate
DNS server." Normally, most clients will use 0 for interface index to
automatically get the default sensible behaviour.
<br><br>
If the client passes a positive interface index, then for multicast names that
indicates to do the operation only on that one interface. For unicast names the
interface index is ignored unless kDNSServiceFlagsForceMulticast is also set.
<br><br>
If the client passes kDNSServiceInterfaceIndexLocalOnly when registering
a service, then that service will be found *only* by other local clients
on the same machine that are browsing using kDNSServiceInterfaceIndexLocalOnly
or kDNSServiceInterfaceIndexAny.
If a client has a 'private' service, accessible only to other processes
running on the same machine, this allows the client to advertise that service
in a way such that it does not inadvertently appear in service lists on
all the other machines on the network.
<br><br>
If the client passes kDNSServiceInterfaceIndexLocalOnly when browsing
then it will find *all* records registered on that same local machine.
Clients explicitly wishing to discover *only* LocalOnly services can
accomplish this by inspecting the interfaceIndex of each service reported
to their DNSServiceBrowseReply() callback function, and discarding those
where the interface index is not kDNSServiceInterfaceIndexLocalOnly.<!-- end discussion --></p>
<p></p><hr><!-- headerDoc=macro;  uid=//apple_ref/c/macro/kDNSServiceInterfaceIndexUnicast;  name=kDNSServiceInterfaceIndexUnicast -->
<a name="//apple_ref/c/macro/kDNSServiceInterfaceIndexUnicast"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="kDNSServiceInterfaceIndexUnicast">kDNSServiceInterfaceIndexUnicast</a></h3>
</td></tr></table><hr><p><b>Value:</b> 0xfffffffe (-2)<br>
</p><b>See Also:</b><blockquote><dl>
<dt><a href="CompositePage.html#//apple_ref/doc/title:macro/Constantsforspecifyinganinterfaceindex">Constants for specifying an interface index</a></dt><dd></dd></dl></blockquote>
<pre><span class="">#define</span><span class="preprocessor"> </span><a href="CompositePage.html#//apple_ref/c/macro/kDNSServiceInterfaceIndexUnicast" class="preprocessor"><span class="preprocessor">kDNSServiceInterfaceIndexUnicast</span></a><span class="preprocessor"> </span><span class="ignore"></span><span class="ignore"></span><span class="ignore"></span><span class="ignore"></span><span class="ignore"></span> </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion --><br><br>
Specific interface indexes are identified via a 32-bit unsigned integer returned
by the if_nametoindex() family of calls.
<br><br>
If the client passes 0 for interface index, that means "do the right thing",
which (at present) means, "if the name is in an mDNS local multicast domain
(e.g. 'local.', '254.169.in-addr.arpa.', '{8,9,A,B}.E.F.ip6.arpa.') then multicast
on all applicable interfaces, otherwise send via unicast to the appropriate
DNS server." Normally, most clients will use 0 for interface index to
automatically get the default sensible behaviour.
<br><br>
If the client passes a positive interface index, then for multicast names that
indicates to do the operation only on that one interface. For unicast names the
interface index is ignored unless kDNSServiceFlagsForceMulticast is also set.
<br><br>
If the client passes kDNSServiceInterfaceIndexLocalOnly when registering
a service, then that service will be found *only* by other local clients
on the same machine that are browsing using kDNSServiceInterfaceIndexLocalOnly
or kDNSServiceInterfaceIndexAny.
If a client has a 'private' service, accessible only to other processes
running on the same machine, this allows the client to advertise that service
in a way such that it does not inadvertently appear in service lists on
all the other machines on the network.
<br><br>
If the client passes kDNSServiceInterfaceIndexLocalOnly when browsing
then it will find *all* records registered on that same local machine.
Clients explicitly wishing to discover *only* LocalOnly services can
accomplish this by inspecting the interfaceIndex of each service reported
to their DNSServiceBrowseReply() callback function, and discarding those
where the interface index is not kDNSServiceInterfaceIndexLocalOnly.<!-- end discussion --></p>
<p></p><hr><!-- headerDoc=macro;  uid=//apple_ref/c/macro/kDNSServiceMaxDomainName;  name=kDNSServiceMaxDomainName -->
<a name="//apple_ref/c/macro/kDNSServiceMaxDomainName"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="kDNSServiceMaxDomainName">kDNSServiceMaxDomainName</a></h3>
</td></tr></table><hr><p></p><pre><span class="">#define</span><span class="preprocessor"> </span><a href="CompositePage.html#//apple_ref/c/macro/kDNSServiceMaxDomainName" class="preprocessor"><span class="preprocessor">kDNSServiceMaxDomainName</span></a><span class="preprocessor"> </span><span class="preprocessor">1005</span> </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->Maximum length, in bytes, of a domain name represented as an *escaped* C-String
including the final trailing dot, and the C-String terminating NULL at the end.
 <!-- end discussion --></p>
<p></p><hr><!-- headerDoc=macro;  uid=//apple_ref/c/macro/kDNSServiceMaxServiceName;  name=kDNSServiceMaxServiceName -->
<a name="//apple_ref/c/macro/kDNSServiceMaxServiceName"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="kDNSServiceMaxServiceName">kDNSServiceMaxServiceName</a></h3>
</td></tr></table><hr><p></p><pre><span class="">#define</span><span class="preprocessor"> </span><a href="CompositePage.html#//apple_ref/c/macro/kDNSServiceMaxServiceName" class="preprocessor"><span class="preprocessor">kDNSServiceMaxServiceName</span></a><span class="preprocessor"> </span><span class="preprocessor">64</span> </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->Maximum length, in bytes, of a service name represented as a
literal C-String, including the terminating NULL at the end.
 <!-- end discussion --></p>
<p></p><hr><!-- headerDoc=macro;  uid=//apple_ref/c/macro/kDNSServiceProperty_DaemonVersion;  name=kDNSServiceProperty_DaemonVersion -->
<a name="//apple_ref/c/macro/kDNSServiceProperty_DaemonVersion"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><h3><a name="kDNSServiceProperty_DaemonVersion">kDNSServiceProperty_DaemonVersion</a></h3>
</td></tr></table><hr><p></p><pre><span class="">#define</span><span class="preprocessor"> </span><a href="CompositePage.html#//apple_ref/c/macro/kDNSServiceProperty_DaemonVersion" class="preprocessor"><span class="preprocessor">kDNSServiceProperty_DaemonVersion</span></a><span class="preprocessor"> </span><span class="preprocessor">"</span><!-- a --><span class="preprocessor">DaemonVersion</span><!-- /a --><span class="preprocessor">"</span> </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5><p><!-- begin discussion -->When requesting kDNSServiceProperty_DaemonVersion, the result pointer must point
to a 32-bit unsigned integer, and the size parameter must be set to sizeof(uint32_t).
<br><br>
On return, the 32-bit unsigned integer contains the version number, formatted as follows:
Major part of the build number * 10000 +
minor part of the build number *   100
<br><br>
For example, Mac OS X 10.4.9 has mDNSResponder-108.4, which would be represented as
version 1080400. This allows applications to do simple greater-than and less-than comparisons:
e.g. an application that requires at least mDNSResponder-108.4 can check:
<br><br>
if (version >= 1080400) ...
<br><br>
Example usage:
<br><br>
uint32_t version;
uint32_t size = sizeof(version);
DNSServiceErrorType err = DNSServiceGetProperty(kDNSServiceProperty_DaemonVersion, &version, &size);
if (!err) printf("Bonjour version is %d.%d\n", version / 10000, version / 100 % 100);
 <!-- end discussion --></p>
<p></p><p><!-- start of footer -->

	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Networking/Reference/DNSServiceDiscovery_CRef/dns_sd/CompositePage.html%3Fid%3DTP40002994-2.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Networking/Reference/DNSServiceDiscovery_CRef/dns_sd/CompositePage.html%3Fid%3DTP40002994-2.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Networking/Reference/DNSServiceDiscovery_CRef/dns_sd/CompositePage.html%3Fid%3DTP40002994-2.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>



<!-- end of footer -->
Last Updated: 2008-04-22
</p></body></html>
