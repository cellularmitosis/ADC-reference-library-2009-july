<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>TriGrids - /Sources/TriGridShell.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">TriGrids</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">TriGrids</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Sources/TriGridShell.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Headers/GeometrySample.h</option>
<option value="listing2.html">/Headers/MathUtilities.h</option>
<option value="listing3.html">/Headers/Textures2.h</option>
<option value="listing4.html">/Headers/TriGrid3DSupport.h</option>
<option value="listing5.html">/Headers/TriGridShell.h</option>
<option value="listing6.html">/Sources/GeometrySample.c</option>
<option value="listing7.html">/Sources/TriGrid3DSupport.c</option>
<option value="listing8.html">/Sources/TriGridShell.c</option>
<option value="listing9.html">/Sources/TriGridTextures.c</option></select>
				</p>
				</form>
				<p><strong><a href="TriGrids.zip">Download Sample</a></strong> (&#147;TriGrids.zip&#148;, 46.4K)<BR>
<strong><a href="TriGrids.dmg">Download Sample</a></strong> (&#147;TriGrids.dmg&#148;, 108.2K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">//// This is box, the QuickDraw 3D starter program.  Written for the// Getting started with QuickDraw 3D Develop article.  This app does not have // graceful error handling - it's purpose is to illustrate a very basic QuickDraw // 3D program.//// Nick Thompson - January 6th 1994//// Modification History:////  1/6/95    nick  initial version based on cube//  12/31/94  nick  cube modifications for QuickDraw 3d sample code//  03/22/95  rdd    adapted from BoxShell.c: added simple picking//            and trigrid selection via number keys//  04/12/95  rdd    added SetCameraLocation.//  04/14/95  rdd   added menu support.//  // system headers#include &lt;Dialogs.h&gt;#include &lt;Devices.h&gt;#include &lt;DiskInit.h&gt;#include &lt;Fonts.h&gt;#include &lt;Menus.h&gt;#include &lt;QDOffScreen.h&gt;#include &lt;QuickDraw.h&gt;#include &lt;Resources.h&gt;#include &lt;SegLoad.h&gt;#include &lt;StandardFile.h&gt;#include &lt;TextEdit.h&gt;#include &lt;ToolUtils.h&gt;// for QuickDraw 3D#include &quot;QD3D.h&quot;#include &quot;QD3DMath.h&quot;#include &quot;QD3DCamera.h&quot;#include &quot;QD3DDrawContext.h&quot;#include &quot;QD3DShader.h&quot;#include &quot;QD3DTransform.h&quot;#include &quot;QD3DGroup.h&quot;#include &quot;QD3DPick.h&quot;#include &quot;TriGridShell.h&quot;#include &quot;TriGrid3DSupport.h&quot;#include &quot;GeometrySample.h&quot;#include &quot;Textures2.h&quot;//-------------------------------------------------------------------------------------------struct _documentRecord {  TQ3ViewObject  fView ;          // the view for the scene  TQ3GroupObject  fModel ;        // object in the scene being modelled  TQ3StyleObject  fInterpolation ;    // interpolation style used when rendering  TQ3StyleObject  fBackFacing ;      // whether to draw shapes that face away from the camera  TQ3StyleObject  fFillStyle ;      // whether drawn as solid filled object or decomposed to components  TQ3Matrix4x4  fRotation ;        // the transform for the model  unsigned short  fGeometryNum ;      // triGrid geometry 1-9 (menu item number)  unsigned short  fTextureType ;      // method of uv parameterization for texture (menu item number)  unsigned short  fPictureNum ;      // PICT (menu item number)};typedef struct _documentRecord DocumentRec, *DocumentPtr, **DocumentHdl ;//-------------------------------------------------------------------------------------------// function prototypesstatic void     InitToolbox( void ) ;static Boolean    SetUpMenus (void) ;static void      IntializeMenuItems (DocumentPtr theDocument) ;static void     MainEventLoop( void ) ;static void     HandleKeyPress(EventRecord *pEvent) ;static void      DoAboutBox (void);static void      DoMenuCommand (long menuResult) ;static void     HandleOSEvent(EventRecord *event) ;static void      InitDocumentData( DocumentPtr theDocument ) ;static TQ3Status  DocumentDraw3DData( DocumentPtr theDocument ) ;static void      DisposeDocumentData( DocumentPtr theDocument) ;static void      SetCameraLocation (TQ3ViewObject view, float x, float y, float z);static void      ChangeGeometry (DocumentPtr theDocument) ;static void      DoPicking(EventRecord *event) ;//-------------------------------------------------------------------------------------------//Boolean     gQuitFlag     = false ;WindowPtr    gMainWindow    = nil ;DocumentRec    gDocument ;Handle      ghMenuBar ;short      gNumPictures ;//-------------------------------------------------------------------------------------------// main()// entry point for the application, initialize the toolbox, initialize QuickDraw 3D// and enter the main event loop.  On exit from the main event loop, we want to call// the QuickDraw 3D exit function to clean up QuickDraw 3d.void main(void){  TQ3Status  myStatus;  InitToolbox() ;  SetUpMenus () ;  //  Initialize QuickDraw 3D, open a connection to the QuickDraw 3D library  myStatus = Q3Initialize();  if ( myStatus == kQ3Failure )    DebugStr(&quot;\pErInitialize returned failure.&quot;);        // set up our globals  gQuitFlag = false ;  gMainWindow = GetNewCWindow(kWindowRsrcID, nil, (WindowPtr)-1);  InitDocumentData( &amp;gDocument ) ;  IntializeMenuItems ( &amp;gDocument ) ;  MainEventLoop();    DisposeDocumentData( &amp;gDocument ) ;    //  Close our connection to the QuickDraw 3D library  myStatus = Q3Exit();  if ( myStatus == kQ3Failure )    DebugStr(&quot;\pErExit returned failure.&quot;);  }//-------------------------------------------------------------------------------------------//void InitDocumentData( DocumentPtr theDocument ) {  // sets up the 3d data for the scene  // Create view for QuickDraw 3D.  theDocument-&gt;fView = MyNewView( (WindowPtr)gMainWindow ) ;  // the drawing styles:  theDocument-&gt;fInterpolation = Q3InterpolationStyle_New(kQ3InterpolationStyleNone) ;  theDocument-&gt;fBackFacing = Q3BackfacingStyle_New(kQ3BackfacingStyleBoth ) ;  theDocument-&gt;fFillStyle = Q3FillStyle_New(kQ3FillStyleFilled ) ;  // set the rotation matrix the identity matrix  Q3Matrix4x4_SetIdentity(&amp;theDocument-&gt;fRotation);      theDocument-&gt;fGeometryNum = iFlat ;  theDocument-&gt;fTextureType = iNoTexture ;  theDocument-&gt;fPictureNum  = iPictureFirst ;  // the main display group:  theDocument-&gt;fModel = MyNewModel() ;  ChangeGeometry (theDocument);}void DisposeDocumentData( DocumentPtr theDocument){  if(theDocument-&gt;fView)    Q3Object_Dispose(theDocument-&gt;fView) ;        // the view for the scene  if(theDocument-&gt;fModel)    Q3Object_Dispose(theDocument-&gt;fModel) ;        // object in the scene being modelled  if(theDocument-&gt;fInterpolation)    Q3Object_Dispose(theDocument-&gt;fInterpolation) ;    // interpolation style used when rendering  if(theDocument-&gt;fBackFacing)    Q3Object_Dispose(theDocument-&gt;fBackFacing) ;    // whether to draw shapes that face away from the camera  if(theDocument-&gt;fFillStyle)    Q3Object_Dispose(theDocument-&gt;fFillStyle) ;      // whether drawn as solid filled object or decomposed to components}//-----------------------------------------------------------------------------// TQ3Status DocumentDraw3DData( DocumentPtr theDocument ){    Q3View_StartRendering(theDocument-&gt;fView );  do {    Q3Style_Submit( theDocument-&gt;fInterpolation, theDocument-&gt;fView );    Q3Style_Submit( theDocument-&gt;fBackFacing, theDocument-&gt;fView );    Q3Style_Submit( theDocument-&gt;fFillStyle, theDocument-&gt;fView );    Q3MatrixTransform_Submit( &amp;theDocument-&gt;fRotation, theDocument-&gt;fView );    Q3DisplayGroup_Submit( theDocument-&gt;fModel, theDocument-&gt;fView );  } while (Q3View_EndRendering(theDocument-&gt;fView) == kQ3ViewStatusRetraverse );  return kQ3Success ;}//----------------------------------------------------------------------------------//void InitToolbox(){  Handle    menuBar = nil;  MaxApplZone() ;  MoreMasters() ; MoreMasters() ; MoreMasters() ;     InitGraf( &amp;qd.thePort );  InitFonts();  InitWindows();  InitCursor();  FlushEvents( everyEvent, 0 ) ;  // initialize application globals    gQuitFlag = false;  }//-------------------------------------------------------------------------------------------//Boolean SetUpMenus (void){  Boolean    goodMenus;  goodMenus = true;  ghMenuBar = GetNewMBar (kMenuBarRsrc);  if (ghMenuBar != nil)  {    SetMenuBar (ghMenuBar);    AppendResMenu (GetMenuHandle (mApple), (ResType) 'DRVR');    DrawMenuBar ();  }  else  {    DebugStr (&quot;\pSetUpMenus: Couldn't find menu bar.&quot;);    ghMenuBar = nil;    goodMenus = false;  }   return (goodMenus);}//-------------------------------------------------------------------------------------------//void IntializeMenuItems (DocumentPtr theDocument){  MenuHandle  hMenu;  Str255    menuPrefix = {&quot;\pPicture &quot;},        itemText,        numString;  long    item;  short    rsrcID;  ResType    rsrcType;  Handle    hPict;  hMenu = GetMenuHandle(mTexture);  gNumPictures = Count1Resources ('PICT');  /* PICT resources to be used as textures must be numbered starting with kFirstPICTRsrcID */  SetResLoad (false);  for (item = 0; item &lt; gNumPictures; item++)  {    itemText[0] = 0;    hPict = GetResource ('PICT', kFirstPICTRsrcID + item);    if (hPict != NULL)      GetResInfo (hPict, &amp;rsrcID, &amp;rsrcType, itemText);    else      break;    if (itemText[0] == 0)    {      BlockMove ((Ptr) menuPrefix, (Ptr) itemText, (Size) menuPrefix[0]+1);      NumToString (item+1, numString);      itemText[0] += numString[0];      BlockMove ((Ptr) &amp;numString[1], (Ptr) itemText[itemText[0]+1], (Size) numString[0]);    }    AppendMenu (hMenu, itemText);  }  SetResLoad (true);  gNumPictures = item;  if (theDocument-&gt;fTextureType == iNoTexture)  {    for (item = iPictureFirst; item &lt; iPictureFirst + gNumPictures; item++)      DisableItem(hMenu, item);  }  CheckItem (GetMenuHandle (mGeometry), theDocument-&gt;fGeometryNum, true);  CheckItem (hMenu, theDocument-&gt;fTextureType, true);  CheckItem (hMenu, theDocument-&gt;fPictureNum,  true);}//-------------------------------------------------------------------------------------------//void MainEventLoop(){  EventRecord   event;  WindowPtr     window;  short         thePart;  Rect          screenRect, updateRect;  Point      aPoint = {100, 100};    while( !gQuitFlag )  {    if (WaitNextEvent( everyEvent, &amp;event, 0, nil ))    {      switch (event.what) {        case mouseDown:                  thePart = FindWindow( event.where, &amp;window );                    switch( thePart ) {            case inMenuBar:               DoMenuCommand (MenuSelect (event.where));              break;            case inSysWindow:              SystemClick (&amp;event, window);              break;            case inDrag:              screenRect = (**GetGrayRgn()).rgnBBox;              DragWindow( window, event.where, &amp;screenRect );              break ;                      case inContent:              if (window != FrontWindow())                SelectWindow( window );                DoPicking(&amp;event);              break ;                      case inGoAway:              if (TrackGoAway( window, event.where )) {                DisposeWindow ( window );                gQuitFlag = true;              }              break ;                          default:            case inGrow:            case inZoomIn:            case inZoomOut:              break ;          }          break ;                                  case updateEvt:          window = (WindowPtr)event.message;          updateRect = (**(window-&gt;visRgn)).rgnBBox;          SetPort( window ) ;          BeginUpdate( window );          DocumentDraw3DData( &amp;gDocument ) ;          EndUpdate( window );          break ;                  case keyDown:        case autoKey:          HandleKeyPress(&amp;event);          break;                  case diskEvt:          if ( HiWord(event.message) != noErr )             (void) DIBadMount(aPoint, event.message);          break;                  case osEvt:        case activateEvt:          break;      }    }    else {      // we received a null event, rotate the cube      TQ3Matrix4x4  tmp;      Rect      theRect = ((GrafPtr)gMainWindow)-&gt;portRect ;            SetPort((GrafPtr)gMainWindow) ;      Q3Matrix4x4_SetRotate_XYZ(&amp;tmp, 0.1, 0.12, 0.08);      Q3Matrix4x4_Multiply(&amp;gDocument.fRotation, &amp;tmp, &amp;gDocument.fRotation);      InvalRect( &amp;theRect ) ;    }  }}//-------------------------------------------------------------------------------------------//void HandleKeyPress(EventRecord *pEvent){  char      charCode;  charCode = pEvent-&gt;message &amp; charCodeMask;  if (pEvent-&gt;modifiers &amp; btnState)  {    /* Button is UP with a key */    if (pEvent-&gt;modifiers &amp; cmdKey)    {      DoMenuCommand (MenuKey (charCode));    }  }  else  {    /* Button is DOWN with a key */  }}//-------------------------------------------------------------------------------------------//void DoAboutBox (void){  DialogPtr  theDialog;  short    itemHit;  theDialog = GetNewDialog(kDialogRsrcID, nil, (WindowPtr)-1);  if (theDialog == nil)    return;      do  {    ModalDialog (nil, &amp;itemHit);  }  while (itemHit != ok);  DisposeDialog (theDialog);}//-------------------------------------------------------------------------------------------//void DoMenuCommand (long menuResult){  short    menuID,        itemNumber;  if (! menuResult)    return;  menuID     = HiWord (menuResult);  itemNumber = LoWord (menuResult);  switch (menuID)  {    case mApple:      switch (itemNumber)      {      case iAbout:        DoAboutBox();      break;      default:        {          MenuHandle  hMenu;          Str255    deskAccName;          GrafPtr    oldPort;          hMenu = GetMenuHandle (menuID);          if (hMenu != nil)          {            GetPort (&amp;oldPort);            GetMenuItemText (hMenu, itemNumber, deskAccName);            (void) OpenDeskAcc (deskAccName);            SetPort (oldPort);          }        }        break;      }      break;    case mFile:      switch (itemNumber)      {      case iNew:      break;      case iOpen:      break;      case iClose:    break;      case iQuit:        gQuitFlag = true;break;      default: SysBeep(1);break;      }      break;    case mEdit:      if (! SystemEdit (itemNumber - 1))        switch (itemNumber)        {        case iUndo:    break;        case iCut:    break;        case iCopy:    break;        case iPaste:  break;        case iClear:  break;        }      break;    case mGeometry:      if (itemNumber != gDocument.fGeometryNum)      {        CheckItem (GetMenuHandle (mGeometry), gDocument.fGeometryNum, false);        gDocument.fGeometryNum = itemNumber;        CheckItem (GetMenuHandle (mGeometry), gDocument.fGeometryNum, true);        ChangeGeometry (&amp;gDocument);      }      break;    case mTexture:      if (itemNumber &gt;= iNoTexture  &amp;&amp;  itemNumber &lt;= iFaceTexture)      {        if (itemNumber != gDocument.fTextureType)        {          long  item;          if (gDocument.fTextureType == iNoTexture)          {            for (item = iPictureFirst; item &lt; iPictureFirst + gNumPictures; item++)              EnableItem(GetMenuHandle (menuID), item);          }          else          if (itemNumber == iNoTexture)          {            for (item = iPictureFirst; item &lt; iPictureFirst + gNumPictures; item++)              DisableItem(GetMenuHandle (menuID), item);          }          CheckItem (GetMenuHandle (mTexture), gDocument.fTextureType, false);          gDocument.fTextureType = itemNumber;          CheckItem (GetMenuHandle (mTexture), gDocument.fTextureType, true);          ChangeGeometry (&amp;gDocument);        }      }      else      if (itemNumber &gt;= iPictureFirst  &amp;&amp; itemNumber &lt;= iPictureFirst + gNumPictures - 1)      {        if (itemNumber != gDocument.fPictureNum)        {          CheckItem (GetMenuHandle (mTexture), gDocument.fPictureNum, false);          gDocument.fPictureNum = itemNumber;          CheckItem (GetMenuHandle (mTexture), gDocument.fPictureNum, true);          ChangeGeometry (&amp;gDocument);        }      }      break;    default:      break;  }  /*  switch (menuID)  */  HiliteMenu (0);}//-------------------------------------------------------------------------------------------//void SetCameraLocation (TQ3ViewObject view, float x, float y, float z){  TQ3CameraObject  camera;  TQ3CameraData  cameraData;  Q3View_GetCamera(view, &amp;camera);  if (camera != nil)  {    Q3Camera_GetData(camera, &amp;cameraData);    Q3Point3D_Set(&amp;cameraData.placement.cameraLocation, x, y, z);    Q3Camera_SetData(camera, &amp;cameraData);    Q3Object_Dispose(camera);  }}//-------------------------------------------------------------------------------------------//void ChangeGeometry (DocumentPtr theDocument){  TQ3Status      status;  TQ3Object      object;  TQ3GroupPosition  position;  unsigned long    triGridLibNum;  if (theDocument-&gt;fModel == nil)    return;  status = Q3Group_GetFirstPositionOfType(theDocument-&gt;fModel, kQ3ShapeTypeGeometry, &amp;position);  if (status == kQ3Success  &amp;&amp;  position != nil)  {    object = Q3Group_RemovePosition(theDocument-&gt;fModel, position);    Q3Object_Dispose(object);    object = NULL;  }  switch (theDocument-&gt;fTextureType)  {    case iNoTexture:    triGridLibNum = (theDocument-&gt;fGeometryNum-1) + kGeometryLibraryRange_Simple;      break;    case iGeometryTexture:  triGridLibNum = (theDocument-&gt;fGeometryNum-1) + kGeometryLibraryRange_UVGeoAttributes;  break;    case iFaceTexture:    triGridLibNum = (theDocument-&gt;fGeometryNum-1) + kGeometryLibraryRange_UVFaceAttributes;break;  }  object = NewLibraryTriGrid(triGridLibNum);  if (object == NULL)    return;  Q3Group_AddObject (theDocument-&gt;fModel, object);  /* Add diffuse color if no texture */  if (theDocument-&gt;fTextureType == iNoTexture)  {    TQ3AttributeSet    attrSet;    TQ3ColorRGB      rgbColor;    attrSet = Q3AttributeSet_New();    if (attrSet != NULL)    {      Q3ColorRGB_Set(&amp;rgbColor, 0.0, 0.75, 0.75);      status = Q3AttributeSet_Add(attrSet, kQ3AttributeTypeDiffuseColor, &amp;rgbColor);      if (status == kQ3Success)      {        Q3Geometry_SetAttributeSet(object, attrSet);        Q3Object_Dispose(attrSet);      }    }  }  else    /* Add texture shader */    AddResourceTextureToGroup(theDocument-&gt;fPictureNum - iPictureFirst + kFirstPICTRsrcID, theDocument-&gt;fModel);  Q3Object_Dispose(object);  /* (These cameral locations could be calculated) */  switch (theDocument-&gt;fGeometryNum)  {  case iFlat:      SetCameraLocation (theDocument-&gt;fView, 0.0, 0.0,  4.0);  break;  case iTorus:    SetCameraLocation (theDocument-&gt;fView, 0.0, 0.0, 10.0);  break;  case iWaveyTorus:  SetCameraLocation (theDocument-&gt;fView, 0.0, 0.0, 10.0);  break;  case iSplash:    SetCameraLocation (theDocument-&gt;fView, 0.0, 0.0, 25.0);  break;  case iSphere:    SetCameraLocation (theDocument-&gt;fView, 0.0, 0.0,  7.0);  break;  case iCone:      SetCameraLocation (theDocument-&gt;fView, 0.0, 0.0,  9.0);  break;  case iPipe:      SetCameraLocation (theDocument-&gt;fView, 0.0, 0.0, 10.0);  break;  case iSteps:    SetCameraLocation (theDocument-&gt;fView, 0.0, 0.0, 30.0);  break;  case iSpring:    SetCameraLocation (theDocument-&gt;fView, 0.0, 0.0, 11.0);  break;  }}//-------------------------------------------------------------------------------------------//void DoPicking(EventRecord *event){  Point          screenPoint;  TQ3WindowPointPickData  withData;  unsigned long      numPicked;  TQ3PickObject      pickObject;  TQ3Status        status;  TQ3ViewStatus      viewStatus;    withData.data.sort       =  kQ3PickSortNone;  withData.data.numHitsToReturn=  kQ3ReturnAllHits;  withData.data.mask       =  kQ3PickDetailMaskObject;                    screenPoint = event-&gt;where;  GlobalToLocal (&amp;screenPoint);  withData.point.x = screenPoint.h;  withData.point.y = screenPoint.v;  withData.vertexTolerance = withData.edgeTolerance = 2.0;  pickObject = Q3WindowPointPick_New(&amp;withData);  status = Q3View_StartPicking(gDocument.fView, pickObject);  if (status == kQ3Failure)    debugstr (&quot;DoPicking: Q3View_StartPicking failed.&quot;);  do {    status = Q3DisplayGroup_Submit(gDocument.fModel, gDocument.fView);    if (status == kQ3Failure)      debugstr (&quot;DoPicking: Q3View_StartPicking failed.&quot;);    viewStatus = Q3View_EndPicking(gDocument.fView);  } while (viewStatus == kQ3ViewStatusRetraverse);  if (viewStatus != kQ3ViewStatusDone)    debugstr (&quot;DoPicking: Q3View_EndPicking failed.&quot;);  if (Q3Pick_GetNumHits(pickObject, &amp;numPicked) &amp;&amp; (numPicked != 0)) {    SetCursor(*GetCursor(plusCursor));    SysBeep(1);  } else {    SetCursor(&amp;qd.arrow);  }  Q3Object_Dispose(pickObject);}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/TriGrids/listing8.html%3Fid%3DDTS10000105-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/TriGrids/listing8.html%3Fid%3DDTS10000105-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/TriGrids/listing8.html%3Fid%3DDTS10000105-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>