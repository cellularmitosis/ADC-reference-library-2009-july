<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Handling Events in Alert and Dialog Boxes(IM:Tb)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING385></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Toolbox-384.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Toolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Toolbox-490.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Toolbox-386.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Toolbox-2.html"><B>Macintosh Toolbox Essentials</B></A> / <BR><DD><A HREF="Toolbox-370.html"><B>Chapter 6 - Dialog Manager</B></A> / <A HREF="Toolbox-378.html"><B>Using the Dialog Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING385-0></A>
<H2><A NAME=MARKER-9-295></A>Handling Events in Alert and Dialog Boxes</H2>
 The next two sections explain how the Dialog Manager uses the Control Manager to handle events in controls automatically and how it uses TextEdit to handle events in editable text items automatically. The information in these two sections, <A HREF=#MARKER-9-298>"Responding to Events in Controls"</A> and <A HREF=#MARKER-9-312>"Responding to Events in Editable Text Items,"</A> applies to all alert boxes and all types of dialog boxes: modal, modeless, and movable modal. <P>
 To display and handle events in alert boxes, you can use the Dialog Manager functions <CODE>Alert</CODE>, <CODE>NoteAlert</CODE>, <CODE>CautionAlert</CODE>, and <CODE>StopAlert</CODE>. The Dialog Manager handles all of the events generated by the user until the user clicks a button (typically the OK or Cancel button). When the user clicks a button, the alert box functions invert the button that was clicked, close the alert box, and report the user's selection to your application. Your application is responsible for performing the appropriate action associated with that button. This is described in detail in <A HREF=#MARKER-9-323>"Responding to Events in Alert Boxes" beginning on page 6-74</A>.<P>
 For modal dialog boxes, you use the <CODE>ModalDialog</CODE> procedure. The Dialog Manager handles most of the user interaction until the user selects an item. The <CODE>ModalDialog</CODE> procedure then reports that the user selected an enabled item, and your application is responsible for performing the action associated with that item. Your application typically calls <CODE>ModalDialog</CODE> repeatedly, responding to clicks on enabled items as reported by <CODE>ModalDialog</CODE>, until the user clicks OK or Cancel. This is described in detail in <A HREF=#MARKER-9-332>"Responding to Events in Modal Dialog Boxes" beginning on page 6-75</A>.<P>
 For alert boxes and modal dialog boxes, you should also supply an event filter function as one of the parameters to the alert box functions or the <CODE>ModalDialog</CODE> procedure. As the user interacts with the alert or modal dialog box, these routines pass events to your event filter function before handling each event. Your event filter function can handle any events not handled by the Dialog Manager or, if necessary, can choose to handle events normally handled by the Dialog Manager. This is described in detail in <A HREF=#MARKER-9-340>"Writing an Event Filter Function for Alert and Modal Dialog Boxes" beginning on page 6-79</A>.<P>
 To handle events in modeless or movable modal dialog boxes, you can use the <CODE>IsDialogEvent</CODE> function to determine whether the event occurred while a dialog box was the frontmost window. For every type of event that occurs when the dialog box is active (including null events), <CODE>IsDialogEvent</CODE> returns <CODE>TRUE</CODE>; otherwise, it returns <CODE>FALSE</CODE>. When <CODE>IsDialogEvent</CODE> returns <CODE>TRUE</CODE>, you can use the <CODE>DialogSelect</CODE> function to handle key-down events in editable text items automatically, to handle update and activate events automatically, and to report the enabled items that the user clicks. You then respond appropriately to clicks in your active items.<P>
 Alternatively, you can handle events in modeless and movable modal dialog boxes much as you handle events in other windows. That is, when you receive an event you can first determine the type of event that occurred and then take the appropriate action according to which window is in front. If a modeless or movable modal dialog box is in front, you can provide code that takes any actions specific to that dialog box and call the <CODE>DialogSelect</CODE> function to handle any events that your code doesn't handle. The sections <A HREF=#MARKER-9-359>"Responding to Mouse Events in Modeless and Movable Modal Dialog Boxes" beginning on page 6-82</A>, <A HREF=#MARKER-9-368>"Responding to Keyboard Events in Modeless and Movable Modal Dialog Boxes" beginning on page 6-87</A>, and <A HREF=#MARKER-9-375>"Responding to Activate and Update Events in Modeless and Movable Modal Dialog Boxes" beginning on page 6-90</A> all take this alternate approach.<P>
<A NAME=HEADING385-7></A>
<H3><A NAME=MARKER-9-298></A>Responding to Events in Controls</H3>
 <A NAME=MARKER-2-299></A><A NAME=MARKER-2-300></A><A NAME=MARKER-2-301></A><A NAME=MARKER-2-302></A><A NAME=MARKER-2-303></A><A NAME=MARKER-2-304></A><A NAME=MARKER-2-305></A>The Dialog Manager greatly simplifies the work necessary for you to implement buttons, checkboxes, pop-up menus, and radio buttons. For alert boxes and all types of dialog boxes--modal, modeless, and movable modal--the Dialog Manager uses Control Manager routines to display controls automatically, highlight controls appropriately, and report to your application when mouse-down events occur within controls. For example, when the user moves the cursor to an enabled button and holds down the mouse button, the Dialog Manager uses the Control Manager function <CODE>TrackControl</CODE> to invert the button. When the user releases the mouse button with the enabled button still inverted, the Dialog Manager uses <CODE>TrackControl</CODE> to report which item was clicked. Your application then responds appropriately--for example, by performing the operation associated with the OK button, by deselecting any other radio button when a radio button is clicked, or by canceling the current operation when the Cancel button is clicked.<A NAME=MARKER-2-306></A><P>
 For clicks in checkboxes, pop-up menus, and radio buttons, your application usually uses the Control Manager routines <CODE>GetControlValue</CODE> and <CODE>SetControlValue</CODE> <BR>to get and appropriately set the items' values. The chapter "Control Manager" in this book explains these routines in detail, but this chapter also offers examples of how <BR>to use these routines in your alert and dialog boxes. Because the Control Manager does not know how radio buttons are grouped, it doesn't automatically turn one off when <BR>the user clicks another one. Instead, it's up to your application to handle this by using the <CODE>GetControlValue</CODE> and <CODE>SetControlValue</CODE> routines.<P>
 When the user clicks the OK button, your application performs whatever action is necessary according to the values returned by <CODE>GetControlValue</CODE> for each of the various checkboxes and radio buttons displayed in your alert or dialog box.<P>
 When <CODE>ModalDialog</CODE> and <CODE>DialogSelect</CODE> call <CODE>TrackControl</CODE>, they do not allow you to specify any special action procedures necessary for anything more complex than a button, radio button, or checkbox. If you need a more complex control that, for example, measures how long the user holds down the mouse button or how far the user has moved an indicator, you can create your own control (or picture or application-defined item that draws a control-like object) in your dialog box. If you use the <CODE>ModalDialog</CODE> procedure, you must then provide an event filter function that appropriately handles events within that item, and if you use the <CODE>DialogSelect</CODE> function, you must test for and respond to those events yourself. Alternatively, you can use Window Manager routines to display an appropriate window and then use the Control Manager to create and manage such complex controls yourself. See the chapters "Window Manager" and "Control Manager" in this book for more information.<A NAME=MARKER-2-307></A><A NAME=MARKER-2-308></A><A NAME=MARKER-2-309></A><A NAME=MARKER-2-310></A><P>
<A NAME=HEADING385-12></A>
<H3><A NAME=MARKER-9-312></A>Responding to Events in Editable Text Items</H3>
 <A NAME=MARKER-9-326></A><A NAME=MARKER-2-314></A><A NAME=MARKER-2-315></A>When the user enters or edits text in an editable text item in your dialog boxes, the Dialog Manager calls TextEdit to handle the events automatically. (You generally shouldn't include editable text items in alert boxes.) You typically disable editable text items because you generally don't need to be informed every time the user types a character or clicks one of them. Instead you need to determine the text only when the OK button is clicked. As illustrated in <A HREF=Toolbox-382.html#MARKER-9-206>Listing 6-12 on page 6-49</A>, use <CODE>GetDialogItemText</CODE> to determine the final value of the editable text item after the user clicks the OK button.<P>
 When you use the <CODE>ModalDialog</CODE> procedure to handle events in modal dialog boxes and when you use the <CODE>DialogSelect</CODE> function for modeless or movable modal dialog boxes, the Dialog Manager calls TextEdit to handle keystrokes and mouse actions within editable text items, so that<P>
<UL>
<LI>when the user clicks the item, a blinking vertical bar appears that indicates an insertion point where text may be entered
<LI>when the user drags over text in the item, the text is highlighted; when the user double-clicks a word, the word is highlighted; the highlighted selection is then replaced by what the user types
<LI>when the user holds down the Shift key while clicking or dragging, the highlighted selection is extended or shortened appropriately
<LI>when the user presses the Backspace key, the highlighted selection or the character preceding the insertion point is deleted
<LI>when the user presses the Tab key, the cursor automatically advances to the next editable text item in the item list resource, wrapping around to the first if there are no more items<P>
</UL>
 If your modeless or movable modal dialog box contains any editable text items, call <CODE>DialogSelect</CODE> even when <CODE>WaitNextEvent</CODE> returns <CODE>FALSE</CODE>. This is necessary because the <CODE>DialogSelect</CODE> function calls the <CODE>TEIdle</CODE> procedure to make the text cursor blink within your editable text items during null events; otherwise, the text cursor will not blink. <A HREF=#MARKER-9-316>Listing 6-25</A> illustrates an application-defined routine, <CODE>DoIdle</CODE>, that calls <CODE>DialogSelect</CODE> whenever the application receives null events while its modeless <BR>dialog box is the frontmost window.<P>
<B>Listing 6-25  <A NAME=MARKER-9-316></A>Using <CODE>DialogSelect</CODE> during null events</B><P>
<PRE>
PROCEDURE DoIdle (event: EventRecord);
VAR
   window:     WindowPtr;
   windowType: Integer;
   itemHit:    Integer;
   result:     Boolean;
BEGIN
   window := FrontWindow;
   {determine which type of window--document, }
   { modeless dialog box, etc.--is in front}
   windowType := MyGetWindowType(window);
   CASE windowType OF
   kMyDocWindow:  {document window is frontmost}
      ;  {see examples in &quot;Event Manager&quot; chapter}
   kMyGlobalChangesModelessDialog:  {modeless dialog is frontmost}
      result := DialogSelect(event, window, itemHit);
   END; {of CASE}
END;
</PRE>
 Generally, your application should handle menu bar access when you display dialog boxes containing editable text items. Leave your Edit menu enabled, and use the <CODE>DialogCut<DFN>, DialogCopy, DialogPaste, and DialogDelete procedures to support the Cut, Copy, Paste, and Clear commands and their keyboard equivalents. You should also provide your own code to support the Undo command. </DFN></CODE><A HREF=Toolbox-384.html#MARKER-9-257>"Adjusting Menus for Modal Dialog Boxes" beginning on page 6-61</A> and <A HREF=Toolbox-384.html#MARKER-9-280>"Adjusting Menus for Movable Modal and Modeless Dialog Boxes" on page 6-66</A> describe how to allow users to access your Edit menu when you display dialog boxes.<P>
 If you don't supply your own event filter function and the user presses the Return or Enter key while a modal dialog box is onscreen, the Dialog Manager treats the event as a click on the default button (that is, the first item in the list) regardless of whether the dialog box contains an editable text item. If your event filter function responds to the user pressing Return and Enter by moving the cursor in editable text items, don't display a bold outline around any buttons. If your event filter function responds to the user pressing Return and Enter as if the user clicks the default button, then you should display a bold outline around the default button. See <A HREF=#MARKER-9-340>"Writing an Event Filter Function for Alert and Modal Dialog Boxes" beginning on page 6-79</A> for an example of how to map the Return and Enter keys to the default button in your dialog boxes.<P>
 Initially, an editable text item may contain default text or no text. You can provide default text either by specifying a text string as the last element for that item in the item list resource or by using the <CODE>SetDialogItemText</CODE> procedure, which is described on <A HREF=Toolbox-419.html#MARKER-9-520>page 6-131</A>.<P>
 When a dialog box that contains editable text items is first displayed, the insertion <BR>point usually appears in the first editable text item in the item list resource. You may instead want to use the <CODE>SelectDialogItemText</CODE> procedure so that the dialog box appears with text selected, or so that an insertion point or a text selection reappears if <BR>the user makes an error while entering text. For example, the user who accidentally types nonnumeric input when a number is required can be given the opportunity to type the entry again. The <CODE>SelectDialogItemText</CODE> procedure is described in detail on <BR><A HREF=Toolbox-420.html#MARKER-9-526>page 6-131</A>.<P>
 By default, the Dialog Manager displays editable text items in the system font. To maintain visual consistency across applications for your users and to make it easier to localize your application, you should not change the font or font size.<A NAME=MARKER-2-317></A><A NAME=MARKER-2-342></A><A NAME=MARKER-2-319></A><A NAME=MARKER-2-320></A><A NAME=MARKER-2-321></A><A NAME=MARKER-2-322></A><P>
<A NAME=HEADING385-28></A>
<H3><A NAME=MARKER-9-323></A>Responding to Events in Alert Boxes</H3>
 <A NAME=MARKER-2-324></A><A NAME=MARKER-2-325></A>After displaying an alert box or playing an alert sound, the <CODE>Alert</CODE>, <CODE>StopAlert</CODE>, <CODE>CautionAlert</CODE>, and <CODE>NoteAlert</CODE> functions call the <CODE>ModalDialog</CODE> <DFN>procedure</DFN> to handle events automatically for you.<P>
 The <CODE>ModalDialog</CODE> procedure, in turn, gets each event by calling the Event Manager function <CODE>GetNextEvent</CODE>. If the event is a mouse-down event outside the content region of the alert box, <CODE>ModalDialog</CODE> emits the system alert sound and gets the next event.<P>
 The <CODE>Alert</CODE>, <CODE>StopAlert</CODE>, <CODE>CautionAlert</CODE>, and <CODE>NoteAlert</CODE> functions continue calling <CODE>ModalDialog</CODE> until the user selects an enabled control (typically a button). At this time these functions remove the alert box from the screen and return the item number of the selected control. Your application then responds as appropriate for a click on this item.<P>
 For example, the code that supports the alert box displayed in <A HREF=#MARKER-9-327>Figure 6-39</A> must respond to three different events--one for each button that the user may click.<P>
<B>Figure 6-39  <A NAME=MARKER-9-327></A>Three buttons for which <CODE>CautionAlert</CODE> reports events</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/DM-S-11.jpg"><P>
 <A HREF=Toolbox-382.html#MARKER-9-200>Listing 6-9 on page 6-47</A> shows an application-defined routine, named <CODE>MyCloseDocument</CODE>, for the Close command. If the document has been modified <BR>since the last save, <CODE>MyCloseDocument</CODE> displays the alert box illustrated in <A HREF=#MARKER-9-327>Figure 6-39</A> before closing the window. After <CODE>MyCloseDocument</CODE> displays the caution alert, it <BR>tests for the item number that <CODE>CautionAlert</CODE> returns after it removes the alert box. <BR>If the user clicks the Save button, <CODE>CautionAlert</CODE> returns its item number, and <CODE>MyCloseDocument</CODE> calls other application-defined routines to save the file, close the file, and close the window. If the user clicks the Don't Save button, <CODE>MyCloseDocument</CODE> closes the window without saving the file. The only other possible response is for the user to click the Cancel button, in which case <CODE>MyCloseDocument</CODE> does nothing--the Dialog Manager removes the alert box, and <CODE>MyCloseDocument</CODE> simply leaves the document window as it is.<P>
 The standard event filter function allows users to press the Return or Enter key in lieu of clicking the default button. When one of these keys is pressed, the standard event filter function returns <CODE>TRUE</CODE> to <CODE>ModalDialog</CODE>, which in turn causes <CODE>Alert</CODE>, <CODE>StopAlert</CODE>, <CODE>CautionAlert</CODE>, and <CODE>NoteAlert</CODE> to return the item number of the default button. When you write your own event filter function, it should emulate the standard filter function by responding in this way to keyboard events involving the Return and Enter keys. <P>
 For events inside the alert box, <CODE>ModalDialog</CODE> passes the event to an event filter function before handling the event. The event filter function provides a secondary event-handling loop for handling events that <CODE>ModalDialog</CODE> doesn't handle and for overriding events that <CODE>ModalDialog</CODE> would otherwise handle. You should provide a simple event filter function for every alert box and modal dialog box in your application.<P>
 You specify a pointer to your event filter function in the second parameter to the <CODE>Alert</CODE>, <CODE>StopAlert</CODE>, <CODE>CautionAlert</CODE>, and <CODE>NoteAlert</CODE> functions. In the <CODE>MyCloseDocument</CODE> routine shown on <A HREF=Toolbox-382.html#MARKER-9-200>page 6-47</A>, a pointer to the <CODE>MyEventFilter</CODE> function is specified. In most cases, you can use the same event filter function in every one of your alert and modal dialog boxes. An example of a simple event filter function that allows background applications to receive update events and performs the other necessary event handling is provided in <A HREF=#MARKER-9-340>"Writing an Event Filter Function for Alert and Modal Dialog Boxes" beginning on page 6-79</A>. <P>
 Unless your event filter function handles the event in its own way and returns <CODE>TRUE</CODE>, <CODE>ModalDialog</CODE> handles the event inside the alert box as follows:<P>
<UL>
<LI>In response to an activate or update event for the alert box, <CODE>ModalDialog</CODE> activates or updates its window.<A NAME=MARKER-2-328></A>
<LI>If the user presses the mouse button while the cursor is in a control, the Control Manager function <CODE>TrackControl</CODE> tracks the mouse. If the user releases the <BR>mouse button while the cursor is in an enabled control, <CODE>Alert</CODE>, <CODE>StopAlert</CODE>, <CODE>CautionAlert</CODE>, and <CODE>NoteAlert</CODE> remove the alert box and return the control's <BR>item number. (Generally, buttons should be the only controls you use in alert boxes.)
<LI>If the user presses the mouse button while the cursor is in any enabled item other than a control, <CODE>Alert</CODE>, <CODE>StopAlert</CODE>, <CODE>CautionAlert</CODE>, and <CODE>NoteAlert</CODE> remove the alert box and return the item number. (Generally, button controls should be the only enabled items in alert boxes.)
<LI>If the user presses the mouse button while the cursor is in a disabled item, or if it is <BR>in no item, or if any other event occurs, <CODE>Alert</CODE>, <CODE>StopAlert</CODE>, <CODE>CautionAlert</CODE>, and <CODE>NoteAlert</CODE> do nothing.<A NAME=MARKER-2-356></A><A NAME=MARKER-2-330></A><A NAME=MARKER-2-331></A><P>
</UL>
<A NAME=HEADING385-44></A>
<H3><A NAME=MARKER-9-332></A>Responding to Events in Modal Dialog Boxes</H3>
 <A NAME=MARKER-2-333></A><A NAME=MARKER-2-334></A><A NAME=MARKER-2-335></A>Call the <CODE>ModalDialog</CODE> procedure immediately after displaying a modal dialog box. <BR>This procedure repeatedly handles events inside the modal dialog box until an event involving an enabled item--such as a click in a radio button--occurs. If the event is a mouse-down event outside the content region of the dialog box, <CODE>ModalDialog</CODE> emits the system alert sound and gets the next event. After receiving an event involving an enabled item, <CODE>ModalDialog</CODE> returns the item number. Normally you then do whatever is appropriate in response to an event in that item. Your application should continue calling <CODE>ModalDialog</CODE> until the user selects the OK or Cancel button, at which point your application should close the dialog box.<P>
 For example, if the user clicks a radio button, your application should get the value <BR>of that button, turn off any other selected radio button within its group, and call <CODE>ModalDialog</CODE> again to get the next event. If the user clicks the Cancel button, your application should restore the user's work to its state just before the user invoked the dialog box, and then your application should remove the dialog box from the screen.<P>
<DL>
<DT><B>Note</B>
<DD>Do not use <CODE>ModalDialog</CODE> for modeless or movable modal <BR>dialog boxes.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 The code that supports the modal dialog box shown in <A HREF=#MARKER-9-336>Figure 6-40</A> must respond to events in four controls: two checkboxes and two buttons.<P>
<B>Figure 6-40  <A NAME=MARKER-9-336></A>Four items for which <CODE>ModalDialog</CODE> reports events</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/DM-S-07.jpg"><P>
 <A HREF=#MARKER-9-337>Listing 6-26</A> illustrates an application-defined routine, MySpellCheckDialog, that responds to events in these four controls.<P>
<B>Listing 6-26  <A NAME=MARKER-9-337></A>Responding to events in a modal dialog box</B><P>
<PRE>
FUNCTION MySpellCheckDialog: OSErr;
VAR
   docWindow:           WindowPtr;
   ignoreCapsCheck:     Boolean;
   ignoreSlangCheck:    Boolean;
   spellDialog:         DialogPtr;
   itemHit, itemType:   Integer;
   itemHandle:          Handle;
   itemRect:            Rect;
   capsVal:             Integer;
   slangVal:            Integer;
   event:               EventRecord;
BEGIN
   capsVal := 0;
   slangVal := 0;
   ignoreCapsCheck := FALSE;
   ignoreSlangCheck := FALSE;
   MySpellCheckDialog := kSuccess;{assume success}
   docWindow := FrontWindow;     {get front window}
   IF docWindow &lt;&gt; NIL THEN
      DoActivate(docWindow, FALSE, event);   {deactivate document window}
   spellDialog := GetNewDialog(kSpellCheckID, NIL, Pointer(-1));
   IF spellDialog = NIL THEN
   BEGIN
      MySpellCheckDialog := kFailed;
      Exit(MySpellCheckDialog);
   END;
   MyAdjustMenus;             {adjust menus as needed}
   GetDialogItem(spellDialog, kUserItem, itemType, itemHandle, itemRect);
   SetDialogItem(spellDialog, kUserItem, itemType,  
                 Handle(@MyDrawDefaultButtonOutline), itemRect);
   ShowWindow(spellDialog);   {show dialog box with default button outlined}
   REPEAT
      ModalDialog(@MyEventFilter, itemHit);  {get events}
      IF itemHit = kAllCaps THEN    {user clicked Ignore Words in All Caps}
      BEGIN
         {get the control handle to the checkbox}
         GetDialogItem(spellDialog, kAllCaps, itemType, itemHandle, 
                       itemRect);
         {get the last value of the checkbox}
         capsVal := GetControlValue(ControlHandle(itemHandle));
         {toggle the value of the checkbox}
         capsVal := 1 - capsVal;
         {set the checkbox to the new value}
         SetControlValue(ControlHandle(itemHandle), capsVal);
      END;
      IF itemHit = kSlang THEN   {user clicked Ignore Slang Terms}
      BEGIN
         {get checkbox's handle, get its value, toggle it, then reset it}
         GetDialogItem(spellDialog, kSlang, itemType, itemHandle, itemRect);
         slangVal := GetControlValue(ControlHandle(itemHandle));
         slangVal := 1 - slangVal;
         SetControlValue(ControlHandle(itemHandle), slangVal);
      END;
   UNTIL ((itemHit = kSpellCheck) OR (itemHit = kCancel));
   DisposeDialog(spellDialog);      {close the dialog box}
   IF itemHit = kSpellCheck THEN    {user clicked Spell Check button}
   BEGIN
      IF capsVal = 1 THEN           {user wants to ignore all caps}
         ignoreCapsCheck := TRUE;
      IF slangVal = 1 THEN          {user wants to ignore slang}
         ignoreSlangCheck := TRUE;

      {now start the spell check}
      SpellCheckMyDoc(ignoreCapsCheck, ignoreSlangcheck);
   END;
END;
</PRE>
 The <CODE>MySpellCheckDialog</CODE> routine calls <CODE>ModalDialog</CODE> immediately after using <CODE>GetNewDialog</CODE> to create and display the dialog box. The <CODE>MySpellCheckDialog</CODE> routine repeatedly responds to events in the two checkboxes until the user clicks either the Spell Check or the Cancel button. When the user clicks either of the checkboxes (which are the third and fourth items in the item list resource), <CODE>MySpellCheckDialog</CODE> uses the <CODE>GetDialogItem</CODE> procedure to get a handle to the checkbox. The <CODE>MySpellCheckDialog</CODE> routine coerces this handle to a control handle and passes <BR>it to the Control Manager function <CODE>GetControlValue</CODE> to get the last value of the control (1 if the checkbox was selected or 0 if it was unselected). Subtracting this <BR>value from 1, <CODE>MySpellCheckDialog</CODE> derives a new value for the control. Then <CODE>MySpellCheckDialog</CODE> passes this value to the Control Manager procedure <CODE>SetControlValue</CODE> to set the new value. The Control Manager responds by drawing <BR>an X in the box if the value of the control is 1 or removing the X if the value of the <BR>control is 0.<P>
 As soon as the user clicks the Spell Check or Cancel button (which are the first and second items in the item list resource), <CODE>MySpellCheckDialog</CODE> stops responding to events in the checkboxes. This routine uses the <CODE>DisposeDialog</CODE> procedure (which is explained in <A HREF=#MARKER-9-380>"Closing Dialog Boxes" beginning on page 6-93</A>) to remove the dialog box. If the user clicks the Cancel button, <CODE>MySpellCheckDialog</CODE> does no further processing of the information in the dialog box. If, however, the user clicks the Spell Check button, <CODE>MySpellCheckDialog</CODE> calls another application-defined routine, <CODE>SpellCheckMyDoc<DFN>,</DFN></CODE> to check the document for spelling errors according to the preferences that the user communicated in the checkboxes.<P>
 For events inside the dialog box, <CODE>ModalDialog</CODE> passes the event to an event filter function before handling the event. In this example, the application specifies a pointer to its own event filter function, <CODE>MyEventFilter</CODE>. As described in the next section, your application should provide an event filter function. You can use the same event filter function in most or all of your alert and modal dialog boxes. <P>
 Unless your event filter function handles the event and returns <CODE>TRUE</CODE>, <CODE>ModalDialog</CODE> handles the event as follows:<P>
<UL>
<LI>In response to an activate or update event for the dialog box, <CODE>ModalDialog</CODE> activates or updates its window.<A NAME=MARKER-2-338></A>
<LI>If the user presses the mouse button while the cursor is in an editable text item, <CODE>ModalDialog</CODE> responds to the mouse activity as appropriate--that is, either by displaying an insertion point or by selecting text. If a key-down event occurs and there's an editable text item, text entry and editing are handled as described in <A HREF=#MARKER-9-312>"Responding to Events in Editable Text Items" beginning on page 6-72</A>. If the editable text item is enabled, <CODE>ModalDialog</CODE> returns its item number after it receives either the mouse-down or key-down event. Normally, editable text items are disabled, and you use the <CODE>GetDialogItemText</CODE> procedure to read the information in the items only after the user clicks the OK button. <A HREF=Toolbox-382.html#MARKER-9-206>Listing 6-12 on page 6-49</A> illustrates this technique.
<LI>If the user presses the mouse button while the cursor is in a control, <CODE>ModalDialog</CODE> calls the Control Manager function <CODE>TrackControl</CODE>. If the user releases the mouse button while the cursor is in an enabled control, <CODE>ModalDialog</CODE> returns the control's item number. Your application should respond appropriately; for example, <A HREF=#MARKER-9-337>Listing 6-26</A> uses an application-defined routine that checks the spelling of a document when the user clicks the Spell Check button.
<LI>If the user presses the mouse button while the cursor is in any other enabled item in the dialog box, <CODE>ModalDialog</CODE> returns the item's number, and your application should respond appropriately. Generally, only controls should be enabled. If your application creates a complex control--such as one that measures how far a dial is moved--your application must provide an event filter function to handle mouse events in that item.
<LI>If the user presses the mouse button while the cursor is in a disabled item or in no item, or if any other event occurs, <CODE>ModalDialog</CODE> does nothing.<A NAME=MARKER-2-339></A><P>
</UL>
<A NAME=HEADING385-63></A>
<H3><A NAME=MARKER-9-340></A>Writing an Event Filter Function for Alert and Modal Dialog Boxes</H3>
 <A NAME=MARKER-2-341></A><A NAME=MARKER-2-342></A><A NAME=MARKER-2-343></A><A NAME=MARKER-2-344></A><A NAME=MARKER-2-345></A><A NAME=MARKER-2-346></A><A NAME=MARKER-9-388></A><A NAME=MARKER-2-348></A>For alert and modal dialog boxes, the Dialog Manager provides a standard event filter function that checks whether the user has pressed the Enter or Return key and, if so, returns the item number of the default button. In early versions of Macintosh system software, when a single application controlled the computer, the standard event filter function for alert boxes and most modal dialog boxes was usually sufficient. However, because the standard event filter function does not permit background applications to receive or respond to update events, it is no longer sufficient. <P>
 Thus, your application should provide a simple event filter function that performs these functions and also allows inactive windows to receive update events. You can use the same event filter function in most or all of your alert and modal dialog boxes.<P>
 You can also use your event filter function to handle other events that <CODE>ModalDialog</CODE> doesn't handle--such as the Command-period key-down event, disk-inserted events, keyboard equivalents, and mouse-down events (if necessary) for application-defined items that you provide. <P>
 For example, the standard event filter function ignores key-down events for the Command key. When your application allows the user to access your menus after you display a dialog box, your event filter function should handle keyboard equivalents for menu commands and return <CODE>TRUE</CODE>. <P>
 At a minimum, your event filter function should perform the following tasks:<P>
<UL>
<LI>return <CODE>TRUE</CODE> and the item number for the default button if the user presses the Return or Enter key
<LI>return <CODE>TRUE</CODE> and the item number for the Cancel button if the user presses the Esc key or the Command-period key combination
<LI>update your windows in response to update events (this also allows background applications to receive update events) and return <CODE>FALSE</CODE> 
<LI>return <CODE>FALSE</CODE> for all events that your event filter function doesn't handle<P>
</UL>
 You can also use the event filter function to test for and respond to keyboard equivalents and more complex events--for instance, the user dragging the cursor in an application- defined item. For example, if you provide an application-defined item that requires you to measure how long the user holds down the mouse button or how far the user drags the cursor, use the event filter function to handle events inside that item. <P>
 If it seems that you will spend time replicating much of your primary event loop in this event filter function, you might consider handling all the events in your main event loop instead of using the Dialog Manager's <CODE>Alert</CODE>, <CODE>NoteAlert</CODE>, <CODE>StopAlert</CODE>, and <CODE>CautionAlert</CODE> functions or <CODE>ModalDialog</CODE> procedure.<P>
 Your own event filter function should have three parameters and return a Boolean value. For example, this is how to declare an event filter function named <CODE>MyEventFilter</CODE>:<P>
<PRE>
FUNCTION MyEventFilter (theDialog: DialogPtr; 
                        VAR theEvent: EventRecord;
                        VAR itemHit: Integer): Boolean;
</PRE>
 After receiving an event that it does not handle, your function should return <CODE>FALSE</CODE>. When your function returns <CODE>FALSE</CODE>, <CODE>ModalDialog</CODE> handles the event, which you pass <BR>in the parameter <CODE>theEvent</CODE>. (Your function can also change the event to simulate a different event and return <CODE>FALSE</CODE>, which passes the altered event to the Dialog Manager for handling.) If your function does handle the event, your function should return <CODE>TRUE</CODE> as a function result and, in the <CODE>itemHit</CODE> parameter, the number of the item that it handled. The <CODE>ModalDialog</CODE> procedure and, in turn, the <CODE>Alert</CODE>, <CODE>NoteAlert</CODE>, <CODE>StopAlert</CODE>, and <CODE>CautionAlert</CODE> functions then return this item number in their own <CODE>itemHit</CODE> parameter.<P>
 Because <CODE>ModalDialog</CODE> calls the <CODE>GetNextEvent</CODE> function with a mask that excludes disk-inserted events, your event filter function can call the Event Manager procedure <CODE>SetSystemEventMask</CODE> to accept disk-inserted events. See the chapter "Event Manager" in this book for a discussion about handling disk-inserted events.<A NAME=MARKER-2-349></A><P>
 For alert and modal dialog boxes, the Dialog Manager provides a standard event filter function that checks whether the user has pressed the Enter or Return key and, if so, returns the item number of the default button. Your event filter function should always check whether the Return key or Enter key was pressed and, if so, return the item number of the default button in the <CODE>itemHit</CODE> parameter and a function result of <CODE>TRUE</CODE>. Your event filter function should also check whether the Esc key was pressed and, if so, return the item number for the Cancel button in the <CODE>itemHit</CODE> parameter and a function result of <CODE>TRUE</CODE>. Your event filter function should also respond to the Command-period key-down event as if the user had clicked the Cancel button.<P>
 To give visual feedback indicating which item has been selected, you should invert buttons that are activated by keyboard equivalents for all alert and dialog boxes. A <BR>good rule of thumb is to invert a button for 8 ticks, long enough to be noticeable but <BR>not so long as to be annoying. The Control Manager performs this action whenever <BR>a user clicks a button, and your application should do this whenever a user presses the keyboard equivalent of a button click.<P>
 For modal dialog boxes that contain editable text items, your application should handle menu bar access to allow use of your Edit menu and its Cut, Copy, Paste, Clear, and Undo commands, as explained in <A HREF=Toolbox-384.html#MARKER-9-257>"Adjusting Menus for Modal Dialog Boxes" beginning on page 6-61</A>. Your event filter function should then test for and handle mouse-down events in the menu bar and key-down events for keyboard equivalents of Edit menu commands. Your application should respond to users' choices from the Edit menu by using the procedures <CODE>DialogCut</CODE>, <CODE>DialogCopy</CODE>, <CODE>DialogPaste</CODE>, and <CODE>DialogDelete</CODE> to support the Cut, Copy, Paste, and Clear commands.<P>
 <A HREF=#MARKER-9-350>Listing 6-27</A> shows <CODE>MyEventFilter</CODE>, which begins by handling update events in windows other than the alert or dialog box. (By responding to update events for your application's own inactive windows in this way, you allow <CODE>ModalDialog</CODE> to perform <BR>a minor switch when necessary so that background applications can update their windows, too.) <P>
 Next, <CODE>MyEventFilter</CODE> handles activate events. This event filter function then handles key-down events for the Return and Enter keys as if the user had clicked the default button, and it handles key-down events for the Esc key as if the user had clicked the Cancel button. (See <I><A HREF="../Text/Text-2.html">Inside Macintosh: Text</A></I> for information about character codes for the Return, Enter, and Esc keys.) Your event filter function can then include tests for other events, such as disk-inserted events and keyboard equivalents.<P>
<B>Listing 6-27  <A NAME=MARKER-9-350></A>A typical event filter function for alert and modal dialog boxes</B><P>
<PRE>
FUNCTION MyEventFilter(theDialog: DialogPtr;
                        VAR theEvent: EventRecord;
                        VAR itemHit: Integer): Boolean;
VAR
   key:        Char;
   itemType:   Integer;
   itemHandle: Handle;
   itemRect:   Rect;
   finalTicks: LongInt;
BEGIN
   MyEventFilter := FALSE; {assume Dialog Mgr will handle it}
   IF (theEvent.what = updateEvt) AND
      (WindowPtr(theEvent.message) &lt;&gt; theDialog) THEN
      DoUpdate(WindowPtr(theEvent.message))  {update the window behind}
   ELSE IF (theEvent.what = activateEvt) AND (WindowPtr(theEvent.message)
            &lt;&gt; theDialog) THEN
      DoActivate(WindowPtr(theEvent.message), 
                   (BAnd(theEvent.modifiers, activeFlag) &lt;&gt; 0), theEvent)
   ELSE
      CASE theEvent.what OF
         keyDown, autoKey:    {user pressed a key}
         BEGIN
            key := Char(BAnd(theEvent.message, charCodeMask));
            IF (key = Char(kReturnKey)) OR (key = Char(kEnterKey)) THEN
            BEGIN    {respond as if user clicked Spell Check}
               GetDialogItem(theDialog, kSpellCheck, itemType, itemHandle, 
                             itemRect);
                     {invert the Spell Check button for user feedback}
               HiliteControl(ControlHandle(itemHandle), inButton);
               Delay(kVisualDelay, finalTicks); {invert button for 8 ticks}
               HiliteControl(ControlHandle(itemHandle), 0);
               myEventFilter := TRUE;  {event's being handled}
               itemHit := kSpellCheck; {return the default button}
            END;
            IF (key = Char(kEscapeKey)) OR   {user pressed Esc key}
               (Boolean(BAnd(theEvent.modifiers, cmdKey)) AND
               (key = Char(kPeriodKey))) THEN   {user pressed Cmd-pd}
            BEGIN    {handle as if user clicked Cancel}
               GetDialogItem(theDialog, kCancel, itemType, itemHandle, 
                             itemRect);
                     {invert the Cancel button for user feedback}
               HiliteControl(ControlHandle(itemHandle), inButton);
               Delay(kVisualDelay, finalTicks); {invert button for 8 ticks}
               HiliteControl(ControlHandle(itemHandle), 0);
               MyEventFilter := TRUE;  {event's being handled}
               itemHit := kCancel;  {return the Cancel button}
            END;  {of Cancel}
            {handle any other keyboard equivalents here}
         END;  {of keydown, autokey}
         {handle disk-inserted and other events here, as needed}
         OTHERWISE
      END;  {of CASE}
END;
</PRE>
 To use this event filter function for an alert box, the application specifies a pointer to <CODE>MyEventFilter</CODE> when it calls one of the <CODE>Alert</CODE> functions, as shown in <A HREF=Toolbox-384.html#MARKER-9-253>Listing 6-19 on page 6-59</A>. To use this event filter function for a modal dialog box, the application specifies a pointer to <CODE>MyEventFilter</CODE> when it calls <CODE>ModalDialog</CODE>, as shown in <BR><A HREF=#MARKER-9-337>Listing 6-26 on page 6-76</A>.<A NAME=MARKER-2-351></A><A NAME=MARKER-2-352></A><A NAME=MARKER-2-353></A><A NAME=MARKER-2-355></A><A NAME=MARKER-2-356></A><A NAME=MARKER-2-357></A><A NAME=MARKER-2-358></A><P>
<A NAME=HEADING385-88></A>
<H3><A NAME=MARKER-9-359></A>Responding to Mouse Events in Modeless and <BR>Movable Modal Dialog Boxes</H3>
 <A NAME=MARKER-2-360></A><A NAME=MARKER-2-361></A>To handle events in modeless and movable modal dialog boxes, you can use the <CODE>IsDialogEvent</CODE> function to determine when events occur while a dialog box is the frontmost window. For such events, you can then use the <CODE>DialogSelect</CODE> function to handle key-down events in editable text items automatically, to handle update and activate events automatically, and to report the enabled items that the user clicks. You must also use additional Toolbox routines to handle other types of keyboard events and other events in the dialog box. <CODE></CODE><P>
<DL>
<DT><B>WARNING</B>
<DD>The <CODE>IsDialogEvent</CODE> and <CODE>DialogSelect</CODE> functions are unreliable when running in versions of system software previous to System 7. <EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 Alternatively, and probably most efficiently, your application can respond to events in modeless and movable modal dialog boxes by first determining the type of event that occurred and then taking the appropriate action according to which type of window is <BR>in front. If a modeless or movable modal dialog box is in front, you can provide code <BR>that takes any actions specific to that dialog box. You can then use the <CODE>DialogSelect</CODE> function instead of the Control Manager functions <CODE>FindControl</CODE> and <CODE>TrackControl</CODE> to handle mouse events in your dialog boxes. The <CODE>DialogSelect</CODE> function also handles update events, activate events, and events in editable text items. (If your modeless or movable modal dialog box contains editable text items, you should call <CODE>DialogSelect</CODE> during null events to cause the text cursor to blink.) <P>
 If you choose to determine whether events involve movable modal or modeless dialog boxes without the aid of the <CODE>IsDialogEvent</CODE> function, your application should be prepared to handle the following mouse events:<P>
<UL>
<LI>clicks in the menu bar, which your application has adjusted as appropriate for the dialog box. Be sure to use the procedures <CODE>DialogCut</CODE>, <CODE>DialogCopy</CODE>, <CODE>DialogPaste</CODE>, and <CODE>DialogDelete</CODE> to support the Cut, Copy, Paste, and Clear commands in editable text items in your dialog boxes.
<LI>clicks in the content region of an active movable modal or modeless dialog box. You can use the <CODE>DialogSelect</CODE> function to aid you in handling the event.
<LI>clicks in the content region of an inactive modeless dialog box. In this case, your application should make the modeless dialog box active by making it the front-<BR>most window.
<LI>clicks in the content region of an inactive window whenever a movable modal or modeless dialog box is active. For movable modal dialog boxes, your application should emit the system alert sound, whereas for modeless dialog boxes, your application should bring the inactive window to the front.
<LI>mouse-down events in the drag region (that is, the title bar) of an active movable modal or modeless dialog box. Your application should use the Window Manager procedure <CODE>DragWindow</CODE> to move the dialog box in response to the user's actions.
<LI>mouse-down events in the drag region of an inactive window when a movable <BR>modal dialog box is active. Your application should <I>not</I> move the inactive window <BR>in response to the user's actions. Instead, your application should play the system alert sound.
<LI>clicks in the close box of a modeless dialog box. Your application should dispose of or hide the modeless dialog box, whichever action is more appropriate.<P>
</UL>
 <A HREF=#MARKER-9-363>Figure 6-41</A> shows a simple modeless dialog box with editable text items.<P>
 <A HREF=#MARKER-9-364>Listing 6-28</A> illustrates an application-defined procedure that handles mouse-down events for all windows, including the modeless dialog box shown in <A HREF=#MARKER-9-363>Figure 6-41</A>.<P>
<B>Figure 6-41  <A NAME=MARKER-9-363></A>A modeless dialog box for which <CODE>DialogSelect</CODE> reports events</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/DM-S-36.jpg"><P>
<B>Listing 6-28  <A NAME=MARKER-9-364></A>Handling mouse-down events for all windows</B><P>
<PRE>
PROCEDURE DoMouseDown (event: EventRecord);  
VAR 
   part:             Integer;   
   thisWindow:       WindowPtr; 
BEGIN                          
   {find general location of the cursor at the time of mouse-down event}
   part := FindWindow(event.where, thisWindow);
   CASE part OF   {take action based on the cursor location}
   inMenuBar: ;   {cursor in menu bar; respond with Menu Manager routines}
   inSysWindow: ; {cursor in a DA; use SystemClick here}
   inContent:     {cursor in the content area of one of this app's windows}    
      IF thisWindow &lt;&gt; FrontWindow THEN 
      BEGIN {mouse-down in a window other than the front }
            { window--make the clicked window the front window, }
            { unless the front window is a movable modal dialog box}
         IF MyIsMovableModal(FrontWindow) THEN
            SysBeep(30)    {emit system alert sound}
         ELSE
            SelectWindow(thisWindow); 
      END
      ELSE  {mouse-down in the content area of front window} 
         DoContentClick(thisWindow, event);
   inDrag:                 {handle mouse-down in drag area}    
      IF (thisWindow &lt;&gt; FrontWindow) AND (MyIsMovableModal(FrontWindow)) 
      THEN 
         SysBeep(30)    {emit system alert sound}
      ELSE
        DragWindow(thisWindow, event.where, GetGrayRgn^^.rgnBBox);
   inGrow: ;            {handle mouse-down in zoom box here}    
   inGoAway:            {handle mouse-down in close box here}
      IF TrackGoAway(thisWindow, event.where) THEN 
         DoCloseCmd;
   inZoomIn, inZoomOut: ;  {handle zoom box region for standard windows}
   END;     {end of CASE}
END;  {of DoMouseDown}
</PRE>
 The <CODE>DoMouseDown</CODE> routine first uses the Window Manager function <CODE>FindWindow</CODE> to determine approximately where the cursor is when the mouse button is pressed. When the user presses the mouse button while the cursor is in the content area of a window, <CODE>DoMouseDown</CODE> first checks whether the mouse-down event occurs in the currently active window by comparing the window pointer returned by <CODE>FindWindow</CODE> with that returned by the Window Manager function <CODE>FrontWindow</CODE>.<P>
 When the mouse-down event occurs in an inactive window, <CODE>DoMouseDown</CODE> uses another application-defined routine, <CODE>MyIsMovableModal</CODE>, to check whether the active window is a movable modal dialog box. If so, <CODE>DoMouseDown</CODE> plays the system alert sound. Otherwise, <CODE>DoMouseDown</CODE> uses the Window Manager procedure <CODE>SelectWindow</CODE> <BR>to make the selected window active. (Although not illustrated in this book, the <CODE>MyIsMovableModal</CODE> routine uses the Window Manager function <CODE>GetWVariant</CODE> to determine whether the variation code for the front window is <CODE>movableDBoxProc</CODE>. If so, <CODE>MyIsMovableModal</CODE> returns <CODE>TRUE</CODE>.) See the chapter "Window Manager" in this book for more information about the <CODE>SelectWindow</CODE> and <CODE>GetWVariant</CODE> routines.<P>
 As in this example, you must ensure that the movable dialog box is modal within your application. That is, the user should not be able to switch to another of your application's windows while the movable modal dialog box is active. Instead, your application should emit the system alert sound. Notice as well that when the mouse-down event occurs in the drag region of any window, <CODE>DoMouseDown</CODE> checks whether the drag region belongs to an inactive window while a movable modal dialog box is active. If it does, <CODE>DoMouseDown</CODE> again plays the system alert sound. (However, by clicking other applica- tions' windows or by selecting other applications from the Application and Apple menus, users should be able to switch your application to the background when you display a movable modal dialog box--an action users cannot perform with fixed- position modal dialog boxes.)<P>
 If a user presses the mouse button while the cursor is in the content region of the active window, <CODE>DoMouseDown</CODE> calls another application-defined routine, <CODE>DoContentClick</CODE>, <BR>to further handle mouse events. <A HREF=#MARKER-9-365>Listing 6-29</A> shows how this routine in turn uses the <CODE>DialogSelect</CODE> function to handle the mouse-down event after the application determines that it occurs in the modeless dialog box shown in <A HREF=#MARKER-9-363>Figure 6-41 on page 6-83</A>.<P>
<B>Listing 6-29  <A NAME=MARKER-9-365></A>Using the <CODE>DialogSelect</CODE> function for responding to mouse-down events</B><P>
<PRE>
PROCEDURE DoContentClick (thisWindow: windowPtr; event: EventRecord);
VAR
   itemHit:    Integer;
   refCon:     Integer;
BEGIN
   windowType := MyGetWindowType(thisWindow);
   CASE windowType OF
      kMyDocWindow: ;
         {handle clicks in document window here; see the chapter &quot;Control }
         { Manager&quot; for sample code for this case}
      kGlobalChangesID:    {user clicked Global Changes dialog box}
         BEGIN
            IF DialogSelect(event, DialogPtr(thisWindow), itemHit) THEN
            BEGIN
               IF itemHit = kChange THEN     {user clicked Change}
                  ;  {use GetDialogItem and GetDialogItemText to get }
                     { the text strings and replace one string with the }
                     { other here}
               IF itemHit = kStop THEN    {user clicked Stop}
                  ;  {stop making changes here}
            END;
         END; {of CASE for kGlobalChangesID}
      {handle other window types here}
   END;  {of CASE}
END;
</PRE>
 In this example, when the user clicks the Change button, <CODE>DialogSelect</CODE> returns its item number. Within the user's document, the application then performs a global search and replace. (<A HREF=Toolbox-382.html#MARKER-9-206>Listing 6-12 on page 6-49</A> illustrates how an application can use the <CODE>GetDialogItem</CODE> and <CODE>GetDialogItemText</CODE> procedures for this purpose.) Generally, only controls should be enabled in a dialog box; therefore, your application normally responds only when <CODE>DialogSelect</CODE> returns <CODE>TRUE</CODE> after the user clicks an enabled control. For example, if the event is an activate or update event for a dialog box, <CODE>DialogSelect</CODE> activates or updates it and returns <CODE>FALSE</CODE>, so your application does not need to respond to the event.<P>
 At this point, you may also want to check for and respond to any special events that you do not wish to pass to <CODE>DialogSelect</CODE> or that require special processing before you pass them to <CODE>DialogSelect</CODE>. You would need to do this, for example, if the dialog box needs to respond to disk-inserted events.<A NAME=MARKER-2-366></A><P>
<DL>
<DT><B>IMPORTANT</B>
<DD>When <CODE>DialogSelect</CODE> calls <CODE>TrackControl</CODE>, it does not allow you to specify any action procedures necessary for a more complex control--<BR>for example, a control that measures how long the user holds down <BR>the mouse button or one that measures how far the user has moved <BR>an indicator. For instances like this, you can create a picture or an application-defined item that draws a control-like object; you must then test for and respond to those events yourself before passing events to <CODE>DialogSelect</CODE>. Or, you can use the Control Manager functions <CODE>FindControl</CODE> and <CODE>TrackControl</CODE> to process the mouse events inside the controls of your dialog box.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 <A HREF=#MARKER-9-364>Listing 6-28 on page 6-84</A> calls one of its application-defined routines, <CODE>DoCloseCmd</CODE>, whenever the user clicks the close box of the active window. If the active window is a modeless dialog box, you might find it more efficient to hide the window rather than remove its data structures. <A HREF=#MARKER-9-367>Listing 6-30</A> shows how you can use the Window Manager routine <CODE>HideWindow</CODE> to hide the Global Changes modeless dialog box when the user clicks its close box. The next time the user chooses the Global Changes command, the dialog box is already available, in the same location and with the same text selected as when it was last used. (<A HREF=Toolbox-384.html#MARKER-9-255>Listing 6-20 on page 6-60</A> illustrates how first to create and later redisplay this modeless dialog box.)<P>
<B>Listing 6-30  Hiding a modeless dialog box in response to a Close command<A NAME=MARKER-9-367></A></B><P>
<PRE>
PROCEDURE DoCloseCmd;
VAR
   myWindow: WindowPtr;
   myData: MyDocRecHnd;
   windowType: Integer;
BEGIN
   myWindow := FrontWindow;
   windowType := MyGetWindowType(myWindow);
   CASE windowType OF
      kMyGlobalChangesModelessDialog: 
         HideWindow(myWindow);
      kMySpellModelessDialog: 
         HideWindow(myWindow);
      kMyDocWindow: 
         BEGIN
            myData := MyDocRecHnd(GetWRefCon(myWindow));
            MyCloseDocument(myData);
         END;  {of kMyDocWindow case}
      kDAWindow:
         CloseDeskAcc(WindowPeek(myWindow)^.windowKind);
   END; {of CASE}
END;
</PRE>
<A NAME=HEADING385-118></A>
<H3><A NAME=MARKER-9-368></A>Responding to Keyboard Events in Modeless and <BR>Movable Modal Dialog Boxes</H3>
 <A NAME=MARKER-2-369></A>If you adopt the previously described strategy of determining--without the aid of the <CODE>IsDialogEvent</CODE> function--whether events involve movable modal or modeless dialog boxes, your application should be prepared to handle the following keyboard events:<P>
<UL>
<LI>keyboard equivalents, such as Command-C to copy, to which your application should respond appropriately
<LI>key-down events for the Return and Enter keys, to which your application should respond as if the user had clicked the default button
<LI>key-down events for the Esc or Command-period keystrokes, to which your application should respond as if the user had clicked the Cancel button
<LI>key-down and auto-key events in editable text items, for which your application can use the <CODE>DialogSelect</CODE> function, which in turn calls TextEdit to handle keystrokes within editable text items automatically<A NAME=MARKER-11-561></A><P>
</UL>
 <A HREF=#MARKER-9-371>Listing 6-31</A> illustrates how an application can check for keyboard equivalents whenever it receives key-down events. If the user holds down the Command key while pressing another key, the application calls another of its application-defined procedures, <CODE>DoMenuCommand</CODE>, which handles keyboard equivalents for menu commands. See the chapter "Menu Manager" in this book for an example of a <CODE>DoMenuCommand</CODE> procedure. Remember that when a movable modal dialog box or a modeless dialog box is active, your application should adjust the menus appropriately, and use the procedures <CODE>DialogCut</CODE>, <CODE>DialogCopy</CODE>, <CODE>DialogPaste</CODE>, and <CODE>DialogDelete</CODE> to support the Cut, Copy, Paste, and Clear commands in editable text items.<P>
<B>Listing 6-31  <A NAME=MARKER-9-371></A>Checking for key-down events involving the Command key</B><P>
<PRE>
PROCEDURE DoKeyDown (event: EventRecord);
VAR
   key:  Char;
BEGIN
   key := CHR(BAnd(event.message, charCodeMask));
   IF BAnd(event.modifiers, cmdKey) &lt;&gt; 0 THEN
   BEGIN                      {Command key down}
      IF event.what = keyDown THEN
      BEGIN 
         MyAdjustMenus;             {adjust the menus as needed}
         DoMenuCommand(MenuKey(key));  {handle the menu command}
      END;
   END
   ELSE
      MyHandleKeyDown(event);
END;
</PRE>
 After determining that a key-down event does not involve a keyboard equivalent, <A HREF=#MARKER-9-371>Listing 6-31</A> calls another of its own routines, <CODE>MyHandleKeyDown</CODE>, which is shown <BR>in <A HREF=#MARKER-9-372>Listing 6-32</A>.<P>
<B>Listing 6-32  <A NAME=MARKER-9-372></A>Checking for key-down events in a modeless dialog box</B><P>
<PRE>
PROCEDURE MyHandleKeyDown (event: EventRecord);
VAR
   window:        WindowPtr;
   windowType:    Integer;
BEGIN
   window := FrontWindow;
   {determine the type of window--document, modeless, etc.}


   windowType := MyGetWindowType(window);
   IF windowType = kMyDocWindow THEN   {key-down in doc window}
   BEGIN    {handle keystrokes in document window here}
   END
   ELSE     {key-down in modeless dialog box}
      MyHandleKeyDownInModeless(event, windowType);
END;
</PRE>
 The <CODE>MyHandleKeyDown</CODE> routine determines what type of window is active when <BR>the user presses a key. If a modeless dialog box is the frontmost window, <CODE>MyHandleKeyDown</CODE> automatically calls another application-defined routine, <CODE>MyHandleKeyDownInModeless</CODE>, to respond to key-down events in modeless dialog boxes. The <CODE>MyHandleKeyDownInModeless</CODE> routine is shown in <A HREF=#MARKER-9-373>Listing 6-33</A>.<P>
<B>Listing 6-33  <A NAME=MARKER-9-373></A>Responding to key-down events in a modeless dialog box</B><P>
<PRE>
PROCEDURE MyHandleKeyDownInModeless(event: EventRecord; windowType: Integer);
VAR
   key:        Char;
   itemType:   Integer;
   itemHandle: Handle;
   itemRect:   Rect;
   finalTicks: LongInt;
   handled:    Boolean;
   item:       Integer;
   theDialog:  DialogPtr;
BEGIN
   handled := FALSE;
   theDialog := FrontWindow;
   CASE windowType OF
      kGlobalChangesID:    {key-down in Global Changes dialog box}
      BEGIN
         key := Char(BAnd(event.message, charCodeMask));
         IF (key = Char(kReturnKey)) OR (key = Char(kEnterKey)) THEN
         BEGIN    {respond as if user clicked Change}
            GetDialogItem(theDialog, kChange, itemType, itemHandle, 
                          itemRect);
                  {invert the Change button for 8 ticks for user feedback}
            HiliteControl(ControlHandle(itemHandle), inButton);
            Delay(kVisualDelay, finalTicks);
            HiliteControl(ControlHandle(itemHandle), 0);
               {use GetDialogItem and GetDialogItemText to get the text }
               { strings and replace one string with the other here}
            handled := TRUE;  {event's been handled}
         END;
         IF (key = Char(kEscapeKey)) OR   {user pressed Esc key}
            (Boolean(BAnd(event.modifiers, cmdKey)) AND
               (key = Char(kPeriodKey))) THEN   {user typed Cmd-pd}
         BEGIN    {handle as if user clicked Stop}
            GetDialogItem(theDialog, kStop, itemType, itemHandle, 
                          itemRect);
                  {invert the Stop button for 8 ticks for user feedback}
            HiliteControl(ControlHandle(itemHandle), inButton);
            Delay(kVisualDelay, finalTicks);
            HiliteControl(ControlHandle(itemHandle), 0);
               {cancel the current operation here}
            handled := TRUE;  {event's been handled}
         END;
         IF NOT handled THEN  {let DialogSelect handle keydown events in }
                              { editable text items}
            handled := DialogSelect(event, theDialog, item);
      END;  {of case kGlobalChangesID}
   {handle other modeless and movable modal dialog boxes here}
   END;  {of CASE}
END;
</PRE>
 When <CODE>MyHandleKeyDownInModeless</CODE> determines that the front window is the Global Changes modeless dialog box, it checks whether the user pressed Return or Enter. If so, <CODE>MyHandleKeyDownInModeless</CODE> responds as if the user had clicked the default button: Change. The <CODE>MyHandleKeyDownInModeless</CODE> routine uses the Control Manager procedure <CODE>HiliteControl</CODE> to highlight the Change button for 8 ticks. (<A HREF=#MARKER-9-350>Listing 6-27 on page 6-81</A> illustrates how to use <CODE>HiliteControl</CODE> to highlight the button from within a modal dialog box's event filter function.)<P>
 When the user presses Esc or Command-period, <CODE>MyHandleKeyDownInModeless</CODE> responds as if the user had clicked the Cancel button.<P>
 Finally, <CODE>MyHandleKeyDownInModeless</CODE> uses the <CODE>DialogSelect</CODE> function, which in turn calls TextEdit to handle keystrokes within editable text items.<A NAME=MARKER-2-374></A><P>
<A NAME=HEADING385-137></A>
<H3><A NAME=MARKER-9-375></A>Responding to Activate and Update Events in Modeless and Movable Modal Dialog Boxes</H3>
 <A NAME=MARKER-2-376></A>If you adopt the previously described strategy of determining--without the aid of the <CODE>IsDialogEvent</CODE> function--whether events involve movable modal or modeless dialog boxes, your application should be prepared to handle activate and update events for both movable modal and modeless dialog boxes. You can use <CODE>DialogSelect</CODE> to assist you in handling activate and update events. For faster performance, you may instead want to use the <CODE>UpdateDialog</CODE> function when handling update events. Both <CODE>DialogSelect</CODE> and <CODE>UpdateDialog</CODE> use the QuickDraw procedure <CODE>SetPort</CODE> to make the dialog box the current graphics port before redrawing or updating it.<P>
 <A NAME=MARKER-2-377></A>You should use the Control Manager procedure <CODE>HiliteControl</CODE> to make the buttons and other controls inactive in a modeless or movable modal dialog box when you deactivate it. The <CODE>HiliteControl</CODE> procedure dims inactive buttons, radio buttons, checkboxes, and pop-up menus to indicate to the user that clicking these items has no effect while the dialog box is in the background. When you activate a modeless or movable modal dialog box again, you should use <CODE>HiliteControl</CODE> to make the controls active again.<P>
 The application-defined <CODE>DoActivateGlobalChangesDialog</CODE> routine shown in <A HREF=#MARKER-9-378>Listing 6-34</A> illustrates how to use <CODE>HiliteControl</CODE> to make the Change button active when activating a modeless dialog box and how to make the Change and Stop buttons inactive when deactivating the dialog box.<P>
<B>Listing 6-34  <A NAME=MARKER-9-378></A>Activating a modeless dialog box</B><P>
<PRE>
PROCEDURE DoActivateGlobalChangesDialog (window: WindowPtr;
                                         event: EventRecord);
VAR
   activate:   Boolean;
   handled:    Boolean;
   item:       Integer;
   itemType:   Integer;
   itemHandle: Handle;
   itemRect:   Rect;
BEGIN
   MyCheckEvent(event); {get a valid event record to pass to DialogSelect}
   activate := (BAnd(event.modifiers, activeFlag) &lt;&gt; 0);
   IF activate THEN     {activate the modeless dialog box}
   BEGIN
      {highlight editable text}
      SelectDialogItemText(window, kFindText, 0, 32767);
      {make the Change button active (make the Stop button active }
      { only during a change operation)}
      GetDialogItem(DialogPtr(window), kChange, itemType, itemHandle,
                    itemRect);
      HiliteControl(ControlHandle(itemHandle), 0); {make Change active}
      {draw a bold outline around the newly activated Change button}
      MyDrawDefaultButtonOutline(DialogPtr(window), kChange);
   END
   ELSE     {dim the Change and Stop buttons for a deactivate dialog box}
   BEGIN
      GetDialogItem(DialogPtr(window), kChange, itemType, itemHandle,
                    itemRect);
      HiliteControl(ControlHandle(itemHandle), 255);  {dim Change button}
      {draw a gray outline around the newly dimmed Change button}
      MyDrawDefaultButtonOutline(DialogPtr(window), kChange);
      GetDialogItem(DialogPtr(window), kStop, itemType, itemHandle,
                    itemRect);
      HiliteControl(ControlHandle(itemHandle), 255);  {dim Stop button}
   END;                          
   {let Dialog Manager handle activate events}
   handled := DialogSelect(event, window, item);
   MyAdjustMenus;    {adjust the menus appropriately}
END;
</PRE>
 The <CODE>DoActivateGlobalChangesDialog</CODE> routine uses <CODE>DialogSelect</CODE> to handle activate events in the modeless dialog box. In response to an activate event, <CODE>DialogSelect</CODE> handles the event and returns <CODE>FALSE</CODE>. The <CODE>DialogSelect</CODE> function sets the current graphics port to the modeless dialog box whenever the user makes it active.<P>
 Because <CODE>DialogSelect</CODE> expects three parameters, one of which must be an event record, <CODE>DoActivateGlobalChangesDialog</CODE> uses the application-defined routine <CODE>MyCheckEvent</CODE> to verify that the event is a valid event. If it's not, <CODE>MyCheckEvent</CODE> creates and returns a valid event record for an activate event.<P>
 Because <CODE>DialogSelect</CODE> doesn't call any draw procedures for items in response to activate events, <CODE>DoActivateGlobalChangesDialog</CODE> calls the application-defined draw routine <CODE>MyDrawDefaultButtonOutline</CODE> to draw either a black outline around the default button when activating the dialog box or a gray outline when deactivating it. The <CODE>MyDrawDefaultButtonOutline</CODE> routine is shown in <A HREF=Toolbox-383.html#MARKER-9-228>Listing 6-17 on page 6-59</A>.<P>
 Because users can switch out of your application when you display a movable modal dialog box, your application must handle activate events for it, too.<P>
 You can also use <CODE>DialogSelect</CODE> to handle update events. In response to an update event, <CODE>DialogSelect</CODE> calls the Window Manager procedure <CODE>BeginUpdate</CODE>, the Dialog Manager procedure <CODE>DrawDialog</CODE> to redraw the entire dialog box, and then the Window Manager procedure <CODE>EndUpdate</CODE>. However, a faster way to update the dialog box is to use the <CODE>UpdateDialog</CODE> procedure, which redraws only the update region of a dialog box. As shown in <A HREF=#MARKER-9-379>Listing 6-35</A>, you should call <CODE>BeginUpdate</CODE> before using <CODE>UpdateDialog</CODE>, and then call <CODE>EndUpdate</CODE>.<P>
<B>Listing 6-35  <A NAME=MARKER-9-379></A>Updating a modeless dialog box</B><P>
<PRE>
PROCEDURE DoUpdate (window: WindowPtr);
VAR
      windowType: Integer;
BEGIN
   windowType := MyGetWindowType(window);
   CASE windowType OF
      kMyDocWindow: 
         ;  {update document windows here}
      kMyGlobalChangesModelessDialog: 
         BEGIN
            BeginUpdate(window);
            UpdateDialog(window, window^.visRgn);
            EndUpdate(window);
         END;
      {handle cases for other window types here}
   END; {of CASE}
END;
</PRE>
<A NAME=HEADING385-150></A>
<H3><A NAME=MARKER-9-380></A>Closing Dialog Boxes</H3>
 <A NAME=MARKER-2-381></A>When you no longer need a dialog box, you can dispose of it by using either the <CODE>CloseDialog</CODE> procedure if you allocated the memory for the dialog box or the <CODE>DisposeDialog</CODE> procedure if you did not. Or, you can merely make it invisible by using the Window Manager procedure <CODE>HideWindow</CODE>.<P>
 Generally, your application should not allocate memory for modal dialog boxes or movable modal dialog boxes, but it should allocate memory for modeless dialog boxes. Under these circumstances, your application should use <CODE>DisposeDialog</CODE> to dispose <BR>of either a fixed or movable modal dialog box when the user clicks the OK or Cancel button, and it should use <CODE>CloseDialog</CODE> to dispose of a modeless dialog box when the user clicks the close box or chooses Close from the File menu. <P>
 You do not close alert boxes; the Dialog Manager does that for you automatically by calling the <CODE>DisposeDialog</CODE> procedure after the user responds to the alert box by clicking any enabled button.<P>
 The <CODE>CloseDialog</CODE> procedure removes a dialog box from the screen and deletes it from the window list. It also releases the memory occupied by <P>
<UL>
<LI>the data structures associated with the dialog box (such as its structure, content, and update regions)
<LI>all the items in the dialog box (except for pictures and icons, which might be shared by other resources) and any data structures associated with them--for example, the region occupied by the scroll box of a scroll bar<P>
</UL>
 The <CODE>CloseDialog</CODE> procedure does not dispose of the dialog record or the item list resource. Unlike <CODE>GetNewDialog</CODE>, <CODE>NewDialog</CODE> does not use a copy of the item list resource. So, if you create a dialog box with <CODE>NewDialog</CODE>, you may want to use <CODE>CloseDialog</CODE> to keep the item list resource in memory even if you didn't supply a pointer to the memory. <P>
 The <CODE>DisposeDialog</CODE> procedure calls <CODE>CloseDialog</CODE> and, in addition, releases the memory occupied by the dialog's item list resource and the dialog record. If you passed <CODE>NIL</CODE> as a parameter to <CODE>GetNewDialog</CODE> or <CODE>NewDialog</CODE> to let the Dialog Manager allocate memory in the heap, call <CODE>DisposeDialog</CODE> when you're done with a dialog box.<P>
 For modeless and movable modal dialog boxes, you might find it more efficient to hide the dialog box rather than remove its data structures. <A HREF=#MARKER-9-367>Listing 6-30 on page 6-87</A> uses the Window Manager routine <CODE>HideWindow</CODE> to hide the Global Changes modeless dialog box <P>
 when the user clicks its close box. The next time the user invokes the Global Changes command, the dialog box is already available, in the same location and with the same text selected as when it was last used.<P>
 If you adjust the menus when you display a dialog box, be sure to return them to an appropriate state when you close the dialog box, as described in <A HREF=Toolbox-384.html#MARKER-9-257>"Adjusting Menus for Modal Dialog Boxes" beginning on page 6-68</A> and <A HREF=Toolbox-384.html#MARKER-9-280>"Adjusting Menus for Movable Modal and Modeless Dialog Boxes" on page 6-73</A>.<A NAME=MARKER-2-382></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Toolbox-384.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Toolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Toolbox-490.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Toolbox-386.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Toolbox-3.html">&copy; Apple Computer, Inc.</A><br>11 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
