<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Shell Scripting Primer: Shell Script Basics</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Shell Script Basics"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40004268-CH237" title="Shell Script Basics"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP40003594" target="_top">Open Source</a> &gt; <a href="../../../Scripting-date.html#//apple_ref/doc/uid/TP30000440-TP40003594-TP30000569" target="_top">Scripting &amp; Automation</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP40004268-TP40003516-SW1">Shell Scripting Primer</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Introduction/Introduction.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../SubroutinesandScoping/SubroutinesandScoping.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40004268-CH237-SW3" title="Shell Script Basics"></a><h1>Shell Script Basics</h1><p>Writing a shell script is like riding a bike. You fall off and scrape your knees a lot at first. With a bit more experience, you become comfortable riding them around town, but also quickly discover why most people drive cars for longer trips.</p><p>Shell scripting is generally considered to be a glue language, ideal for creating small pieces of code that connect other tools together. While shell scripts can be used for more complex tasks, they are usually not the best choice.</p><p>If you have ever successfully trued a bicycle wheel (or paid someone else to do so), that’s similar to learning the basics of shell scripting. If you don’t true your scripts, they wobble. Put another way, it is often easy to write a script, but it can be more challenging to write a script that consistently works well.</p>
<p>This chapter introduces the basic concepts of shell scripting. It was not intended to be a complete reference on writing shell scripts, nor could it be. It does, however, provide a good starting point for beginners first learning this black art. The other chapters in this document provide additional breadth and depth.</p>


<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW19">Shell Script Dialects</a>
				
			<br/>
			
        
			
			
				<a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW16">She Sells C Shells</a>
				
			<br/>
			
        
			
			
				<a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW22">Tips for Shell Users</a>
				
			<br/>
			
        
			
			
				<a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW8">Shell Variables and Printing</a>
				
			<br/>
			
        
			
			
				<a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW17">Exporting Shell Variables</a>
				
			<br/>
			
        
			
			
				<a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW20">Shell Script Input and Output Using printf and read</a>
				
			<br/>
			
        
			
			
				<a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW21">Bulk I/O Using the cat Command</a>
				
			<br/>
			
        
			
			
				<a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW23">Pipes and Redirection</a>
				
			<br/>
			
        
			
			
				<a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW5">Basic Control Statements</a>
				
			<br/>
			
        
			
			
				<a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW14">Variables, Expansion, and Quoting</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40004268-CH237-SW19" title="Shell Script Dialects"></a><h2>Shell Script Dialects</h2><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_444"></a><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_445"></a>
<p>There are many different dialects of shell scripts, each with their own quirks, and some with their own syntax entirely. Because of these differences, the road to good shell scripting can be fraught with peril, leading to script failures, misbehavior, and even outright data loss.</p><p>To that end, the first lesson you must learn before writing a shell script is that there are two fundamentally different sets of shell script syntax: the Bourne shell syntax and the C shell syntax. The C shell syntax is more comfortable to many C programmers because the syntax is somewhat similar. However, the Bourne shell syntax is significantly more flexible and thus more widely used. For this reason, this document only covers the Bourne shell syntax.</p>
<p>The second hard lesson you will invariably learn is that each dialect of Bourne shell syntax differs slightly. This document includes only pure Bourne shell syntax and a few BASH-specific extensions. Where BASH-specific syntax is used, it is clearly noted.</p><p>The terminology and subtle syntactic differences can be confusing—even a bit overwhelming at times; had Dorothy in <em>The Wizard of Oz</em> been a programmer, you might have heard her exclaim, "BASH and ZSH and CSH, Oh My!" Fortunately, once you get the basics, things generally fall into place as long as you avoid using shell-specific features. Stay on the narrow road and your code will be portable.</p><p>Some common shells are listed below, grouped by script syntax:</p><p><strong>Bourne-compatible shells</strong></p><ul class="ul"><li class="li"><p><code><a href="../../../../Darwin/Reference/ManPages/man1/sh.1.html#//apple_ref/doc/man/1/sh" target="_top">sh</a></code></p></li><li class="li"><p><code><a href="../../../../Darwin/Reference/ManPages/man1/bash.1.html#//apple_ref/doc/man/1/bash" target="_top">bash</a></code></p></li><li class="li"><p><code><a href="../../../../Darwin/Reference/ManPages/man1/zsh.1.html#//apple_ref/doc/man/1/zsh" target="_top">zsh</a></code></p></li><li class="li"><p><code><a href="../../../../Darwin/Reference/ManPages/man1/ksh.1.html#//apple_ref/doc/man/1/ksh" target="_top">ksh</a></code></p></li></ul><p><strong>C-shell-compatible shells</strong></p><ul class="ul"><li class="li"><p><code><a href="../../../../Darwin/Reference/ManPages/man1/csh.1.html#//apple_ref/doc/man/1/csh" target="_top">csh</a></code><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_446"></a></p></li><li class="li"><p><code><a href="../../../../Darwin/Reference/ManPages/man1/tcsh.1.html#//apple_ref/doc/man/1/tcsh" target="_top">tcsh</a></code></p></li><li class="li"><p><code>bcsh</code> (C shell to Bourne shell translator/emulator)</p></li></ul><p>Many of these shells have more than one variation. Most of these variations are denoted by prefixing the name of an existing shell with additional letters that are short for whatever differentiates them from the original shell. For example:</p><ul class="ul"><li class="li"><p>The shell <code>pdksh</code> is a variant of <code>ksh</code>. Being a public domain rewrite of AT&amp;T's <code>ksh</code>, it stands for "Public Domain Korn SHell." (This is a bit of a misnomer, as a few bits are under a BSD-like open source license. However, the name remains.)</p></li><li class="li"><p>The shell <code>tcsh</code> is an extension of <code>csh</code>. It stands for the TENEX C SHell, as some of its enhancements were inspired by the TENEX operating system.</p></li><li class="li"><p>The shell <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_447"></a><code>bash</code> is an extension of <code>sh</code>. It stands for the Bourne Again SHell. (Oddly enough, it is not a variation of <code>ash</code>, the Almquist SHell, though both are Bourne shell variants. This should not be confused with the <code>dash</code> shell—an <code>ash</code>-derived shell used in some Linux distributions—whose name stands for the Debian Almquist SHell.)</p></li></ul><p>And so on. In general, with the exception of <code>csh</code> and <code>tcsh</code>, it is usually safe to assume that any modern login shell is compatible with Bourne shell syntax.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH237-SW32" title="Note"></a><p><strong>Note:</strong>&nbsp;Because the C shell syntax is not well suited to scripting beyond a very basic level, this document does not cover C shell variants in depth. For more information, see <span class="content_text"><a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW16">“She Sells C Shells.”</a></span></p></div><a name="//apple_ref/doc/uid/TP40004268-CH237-SW16" title="She Sells C Shells"></a><h2>She Sells C Shells</h2><p>The C shell is popular among some users as a shell for interacting with the computer because it allows simple scripts to be written more easily. However, the C shell scripting language is limited in a number of ways, many of which are hard to work around. For this reason, use of the C shell scripting language for writing complex scripts is not recommended. For more information, read “CSH Programming Considered Harmful” at <span class="content_text"><a href="http://www.faqs.org/faqs/unix-faq/shell/csh-whynot/" target="_blank">http://www.faqs.org/faqs/unix-faq/shell/csh-whynot/</a></span>. While many of the language flaws it describes are fixed by some modern C shells, if you are writing a script that must work on multiple computers across different operating systems, you cannot always guarantee that the installed C shell will support those extensions.</p><p>However, the C shell scripting language has its uses, particularly for writing scripts that set up environment variables for interactive shell environments, execute a handful of commands in order, or perform other relatively lightweight chores. To support such uses, the C shell syntax is presented alongside the Bourne shell syntax within this "basics” chapter where possible.</p><p>Outside of this chapter, this document does not generally cover the C shell syntax. If after reading this, you still want to write a more complex script using the C shell programming language, you can find more information in on the C shell in the manual page for <code><a href="../../../../Darwin/Reference/ManPages/man1/csh.1.html#//apple_ref/doc/man/1/csh" target="_top">csh</a></code>.</p><a name="//apple_ref/doc/uid/TP40004268-CH237-SW22" title="Tips for Shell Users"></a><h2>Tips for Shell Users</h2><p>While this document is primarily focused on writing shell scripts, there are a few helpful tips that can be useful to shell users and programmers alike. This section includes a few of those tips.</p><a name="//apple_ref/doc/uid/TP40004268-CH237-SW27" title="The alias Builtin"></a><h3>The alias Builtin</h3><p>Various Bourne shells also offer a number of other builtin commands that you may find useful, one of the more useful for command-line users being <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_448"></a><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_449"></a><code><a href="../../../../Darwin/Reference/ManPages/man1/alias.1.html#//apple_ref/doc/man/1/alias" target="_top">alias</a></code>. This command allows you to assign a short name to replace a longer command. While the <code>alias</code> builtin is not frequently used in shell scripts (unless you are intentionally trying to obfuscate your code), it is very convenient when using the shell interactively. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>alias listsource="ls *.c *.h"<span></span></pre></td></tr></table></div><p>Typing the command <code>listsource</code> after entering this line will result in listing all of the <code>.c</code> and <code>.h</code> files in the current directory.</p><p>For more information, see the man page <code><a href="../../../../Darwin/Reference/ManPages/man1/builtins.1.html#//apple_ref/doc/man/1/builtins" target="_top">builtins</a></code>, or for ZSH, <code><a href="../../../../Darwin/Reference/ManPages/man1/zshbuiltins.1.html#//apple_ref/doc/man/1/zshbuiltins" target="_top">zshbuiltins</a></code>.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH237-SW33" title="C Shell Note"></a><p><strong>C Shell Note:</strong>&nbsp;The C shell syntax is similar, but not identical. In the C shell, the equals sign is replaced with a space. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>alias listsource "ls *.c *.h"<span></span></pre></td></tr></table></div></div><a name="//apple_ref/doc/uid/TP40004268-CH237-SW28" title="Entering Special Characters"></a><h3>Entering Special Characters</h3><p><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_450"></a>Some shells treat tabs and other control characters in special ways. When writing a script in a text file, the reuse of these characters for shell-specific purposes is not generally an issue. However, when entering commands on the command line, it may get in the way if you need to enter any of these characters as part of a command for some reason.</p><p>To enter a tab or other control character on the command line, type control-v followed by the tab key or other control character. The control-v tells the shell to treat whatever character comes next literally without interpreting it in any way during entry.</p><p>For example, to enter the ASCII bell character (control-G), you can type the following:</p><div class="codesample"><table><tr><td scope="row"><pre>echo "control-V control-G"<span></span></pre></td></tr></table></div><p>This will be seen on your screen as:</p><div class="codesample"><table><tr><td scope="row"><pre>echo "^G"<span></span></pre></td></tr></table></div><p>When you press return, your computer should beep.<a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_451"></a></p><a name="//apple_ref/doc/uid/TP40004268-CH237-SW8" title="Shell Variables and Printing"></a><h2>Shell Variables and Printing</h2>
<p><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_452"></a>What follows is a very basic shell script that prints “Hello, world!” to the screen:</p>
<div class="codesample"><table><tr><td scope="row"><pre>#! /bin/sh<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>echo "Hello, world!"<span></span></pre></td></tr></table></div>
<p>The first thing you should notice is that the script starts with ‘<code>#!</code>’. This is known as an interpreter line. If you don’t specify an interpreter line, the default is usually the Bourne shell (<code>/bin/sh</code>). However, it is best to specify this line anyway for consistency.</p>
<p>The second thing you should notice is the <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_453"></a><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_454"></a><code><a href="../../../../Darwin/Reference/ManPages/man1/echo.1.html#//apple_ref/doc/man/1/echo" target="_top">echo</a></code> command. The <code>echo</code> command is nearly universal in shell scripting as a means for printing something to the user’s screen. (Technically speaking, <code>echo</code> is generally a shell builtin, but it also exists as as standalone command, <code>/bin/echo</code>. You can read more about the difference between the builtin version and the standalone version in <span class="content_text"><a href="../PortingScriptstoMacOSX/PortingScriptstoMacOSX.html#//apple_ref/doc/uid/TP40004268-TP40003517-SW12">“echo”</a></span> and <span class="content_text"><a href="../performance/performance.html#//apple_ref/doc/uid/TP40004268-TP40003520-SW14">“Use Shell Builtins Wherever Possible.”</a></span>)</p><p>If you’d like, you can try this script by saving those lines in a text file (say “hello_world.sh”) in your home directory. Then, in Terminal, type:</p><div class="codesample"><table><tr><td scope="row"><pre>chmod u+x hello_world.sh<span></span></pre></td></tr><tr><td scope="row"><pre>./hello_world.sh<span></span></pre></td></tr></table></div>
<p>Of course, this script isn’t particularly useful. It just prints the words “Hello, world!“ to your screen. To make this more interesting, the next script throws in a few variables.</p>
<div class="codesample"><table><tr><td scope="row"><pre>#! /bin/sh<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>FIRST_ARGUMENT="$1"<span></span></pre></td></tr><tr><td scope="row"><pre>echo "Hello, world $FIRST_ARGUMENT!"<span></span></pre></td></tr></table></div><p><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_455"></a><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_456"></a>Type or paste this script into the text editor of your choice (TextEdit, for example) and save the file in your home directory in a file called <code>test.sh</code>. Then type ‘<code>chmod a+x test.sh</code>’ in Terminal to make it executable. Finally, run it with ‘<code>./test.sh leaders</code>’. You should see “Hello, world leaders!” printed to your screen.</p>
<p>This script provides an example of a variable assignment. The variable <code>$1</code> contains the first argument passed to the shell script. In this example, the script makes a copy and stores it into a variable called <code>FIRST_ARGUMENT</code>, then prints that variable.</p>
<p>You should immediately notice that, depending on use, variables may or may not begin with a dollar sign. If you are dereferencing the variable, you precede it with a dollar sign. The shell inserts the contents of the variable at that point in the script.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_26" title="Important:"></a><p><strong>Important:</strong>&nbsp;You generally do <em>not</em> want to prefix the variable on the left side of an assignment statement with a dollar sign. Because <code>FIRST_ARGUMENT</code> starts out empty, if you used a dollar sign, the first line:</p><p><div class="codesample"><table><tr><td scope="row"><pre>$FIRST_ARGUMENT="$1" # DO NOT DO THIS!<span></span></pre></td></tr></table></div>would evaluate to the following completely gibberish:</p><p>
<div class="codesample"><table><tr><td scope="row"><pre>="myfirstcommandlineargument"<span></span></pre></td></tr></table></div>
This is clearly not what you want (and produces an error). Because of the order in which the statement is evaluated, the above assignment statement would still fail with an error even if <code>FIRST_ARGUMENT</code> were nonempty.</p><p></p></div>
<p>You should also notice the double quotation marks. These are important, as any command-line argument could potentially contain spaces. Normally, when executing a command, spaces are treated as separating multiple arguments, and thus, shell scripts can behave differently when variables containing spaces are involved. By enclosing the variables in double quotes, they are treated as part of a single argument even if the value stored in the variable contains a space.</p><p>Had you omitted those quotes, if the first argument contained spaces (for example, the phrase “leaders and citizens” in the previous example), that statement might evaluate to something like this:</p><div class="codesample"><table><tr><td scope="row"><pre>FIRST_ARGUMENT=This is a test<span></span></pre></td></tr></table></div><p>The shell interprets this as two statements: an assignment statement (<code>FIRST_ARGUMENT=This</code>) and a command (<code>is</code>) with two arguments (<code>a</code> and <code>test</code>). Because there is no semicolon between the two statements, it further interprets the assignment statement as an attempt to modify the environment passed to the <code>is</code> command (a technique described in <span class="content_text"><a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW12">“Overriding Environment Variables for Child Processes (Bourne Shell)”</a></span>). This is clearly not what you intended to do.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH237-SW34" title="Compatibility Note"></a><p><strong>Compatibility Note:</strong>&nbsp;In <code><a href="../../../../Darwin/Reference/ManPages/man1/zsh.1.html#//apple_ref/doc/man/1/zsh" target="_top">zsh</a></code>, if you omit the quotation marks in the original <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_457"></a>assignment statement, the script still works because ZSH does not split the contents of variables into separate words. When run as <code>/bin/sh</code>, however, ZSH emulates the Bourne shell behavior for compatibility.</p></div><p>For another example, if you typed the command:</p><div class="codesample"><table><tr><td scope="row"><pre>./test.sh "leaders and citizens"<span></span></pre></td></tr></table></div><p>the script prints “Hello, world leaders and citizens!” because the quotation marks on the command line cause everything within them to be grouped as a single argument and the quotation marks in the first line of the script create a similar grouping. If you omit the quotes on the command line, the first argument is “leaders”, and the script prints “Hello, world leaders!” instead.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH237-SW35" title="Note"></a><p><strong>Note:</strong>&nbsp;Expansion of variables, occurs <em>after</em> the statement itself is fully parsed by the shell. Thus, as long as the variable is enclosed in double quote marks, you will not get any execution errors even if the variable’s value contains double-quote marks.</p>However, if you are using double quote marks within a literal string, you must quote that string properly. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>MYSTRING="The word of the day is \"sedentary\"."<span></span></pre></td></tr></table></div>This also applies to literal strings within commands entered on the command line. For example, the command:</p><div class="codesample"><table><tr><td scope="row"><pre>./test.sh "\"leaders\""<span></span></pre></td></tr></table></div>prints the phrase “Hello, world “leaders”!”</p>The details of quotes as they apply to variable expansion are explained in <span class="content_text"><a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW14">“Variables, Expansion, and Quoting.”</a></span></p></div><p>Shell scripts also allow the use of single quote marks. Variables between single quotes are not replaced by their contents. Be sure to use double quotes unless you are intentionally trying to display the actual name of the variable. You can also use single quotes as a way to avoid the shell interpreting the contents of the string in any way. These differences are described further in <span class="content_text"><a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW14">“Variables, Expansion, and Quoting.”</a></span></p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH237-SW36" title="C Shell Note"></a><p><strong>C Shell Note:</strong>&nbsp;The syntax for assignment statements in the C shell is rather different. Instead of an assignment statement, the C shell uses the <code>set</code> and <code>setenv</code> builtins to set variables as shown below:</p><div class="codesample"><table><tr><td scope="row"><pre>set VALUE = "Four"<span></span></pre></td></tr><tr><td scope="row"><pre># or...<span></span></pre></td></tr><tr><td scope="row"><pre>setenv VALUE "Four"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>echo "$VALUE score and seven years ago...."<span></span></pre></td></tr></table></div>The functional difference between <code>set</code> and <code>setenv</code> is described in <span class="content_text"><a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW17">“Exporting Shell Variables.”</a></span></p>Also, the C shell handling of backslashes within double-quoted strings is different. In the C shell, the previous example should be changed to:</p><div class="codesample"><table><tr><td scope="row"><pre>MYSTRING="The word of the day is "\""sedentary"\""."<span></span></pre></td></tr><tr><td scope="row"><pre>./test.sh \""leaders"\"<span></span></pre></td></tr></table></div>to achieve the desired effect. This difference is described further in <span class="content_text"><a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW14">“Variables, Expansion, and Quoting.”</a></span><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_458"></a></p></div><a name="//apple_ref/doc/uid/TP40004268-CH237-SW17" title="Exporting Shell Variables"></a><h2>Exporting Shell Variables</h2><p><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_459"></a><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_460"></a><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_461"></a>One key feature of shell scripts is that variables are typically limited in their scope to the currently running script. The scoping of variables is described in more detail in <span class="content_text"><a href="../SubroutinesandScoping/SubroutinesandScoping.html#//apple_ref/doc/uid/TP40004268-TP40003513-SW1">“Result Codes, Subroutines, Scoping, and Sourcing.”</a></span> For now, though, it suffices to say that variables generally do not get passed on to scripts or tools that they execute.</p><p>Normally, this is what you want. Most variables in a shell script do not have any meaning to the tools that they execute, and thus represent clutter and the potential for variable namespace collisions if they are exported. Occasionally, however, you will find it necessary to make a variable's value available to an outside tool. To do this, you must export the variable. These exported variables are commonly known as environment variables because they are outside the scope of the script itself, but affect its execution.</p><p>A classic example of an environment variable that is significant to scripts and tools is the <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_462"></a><code>PATH</code> variable. This variable specifies a list of locations that the shell searches when executing programs by name (without specifying a complete path). For example, when you type <code>ls</code> on the command line, the shell searches in the locations specified in <code>PATH</code> (in the order specified) until it finds an executable called <code>ls</code> (or runs out of locations, whichever comes first).</p><p>The details of exporting shell variables differ considerably between the Bourne shell and the C shell. Thus, the following sections explain these details in a shell-specific fashion.</p><a name="//apple_ref/doc/uid/TP40004268-CH237-SW11" title="Using the export Builtin (Bourne Shell)"></a><h3>Using the export Builtin (Bourne Shell)</h3><p><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_463"></a><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_464"></a>Generally speaking, the first time you assign a value to an environment variable such as the <code>PATH</code> variable, the Bourne shell creates a new, <em>local</em> copy of this shell variable that is specific to your script. Any tool executed from your script is passed the original value of <code>PATH</code> inherited from whatever script, tool, or shell that launched it.</p><p><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_465"></a>With the BASH shell, however, any variable inherited from the environment is automatically exported by the shell. Thus, in some versions of Mac OS X, if you modify inherited environment variables (such as <code>PATH</code>) in a script, your local changes will be seen automatically by any tool or script that your script executes. Thus, in these versions of Mac OS X, you do not have to explicitly use the <code>export</code> statement when modifying the <code>PATH</code> variable.</p><p>Because different Bourne shell variants handle these external environment variables differently (even among different versions of Mac OS X), this creates two minor portability problems:</p><ul class="spaceabove"><li class="li"><p>A script written without the <code>export</code> statement may work on some versions of Mac OS X, but will fail on others. You can solve this portability problem by using the <code>export</code> builtin, as described in this section.</p></li><li class="li"><p>A shell script that changes variables such as <code>PATH</code> will alter the behavior of any script that it executes, which may or may not be desirable. You can solve this problem by overriding the <code>PATH</code> environment variable when you execute each individual tool, as described in <span class="content_text"><a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW12">“Overriding Environment Variables for Child Processes (Bourne Shell).”</a></span></p></li></ul><p>To guarantee that your modifications to a shell variable are passed to any script or tool that your shell script calls, you <em>must</em> use the <code><a href="../../../../Darwin/Reference/ManPages/man1/export.1.html#//apple_ref/doc/man/1/export" target="_top">export</a></code> builtin. You do not have to use this command every time you change the value; the variable remains exported until the shell script exits.</p><p>For example:</p><div class="codesample"><table><tr><td scope="row"><pre>export PATH="/usr/local/bin:$PATH"<span></span></pre></td></tr><tr><td scope="row"><pre># or<span></span></pre></td></tr><tr><td scope="row"><pre>PATH="/usr/local/bin:$PATH"<span></span></pre></td></tr><tr><td scope="row"><pre>export PATH<span></span></pre></td></tr></table></div><p>Either of these statements has the same effect—specifically, they export the local notion of the <code>PATH</code> environment variable to any command that your script executes from now on. There is a small catch, however. You cannot later undo this export to restore the original global declaration. Thus, if you need to retain the original value, you must store it somewhere yourself.</p><p>In the following example, the script stores the original value of the <code>PATH</code> environment variable, exports an altered version, executes a command, and restores the old version.</p><div class="codesample"><table><tr><td scope="row"><pre>ORIGPATH="$PATH"<span></span></pre></td></tr><tr><td scope="row"><pre>PATH="/usr/local/bin:$PATH"<span></span></pre></td></tr><tr><td scope="row"><pre>export PATH<span></span></pre></td></tr><tr><td scope="row"><pre># Execute some command here---perhaps a<span></span></pre></td></tr><tr><td scope="row"><pre># modified ls command....<span></span></pre></td></tr><tr><td scope="row"><pre>ls<span></span></pre></td></tr><tr><td scope="row"><pre>PATH="$ORIGPATH"<span></span></pre></td></tr></table></div><p>If you need to find out whether an environment variable (whether inherited by your script or explicitly set with the <code>export</code> directive) was set to empty or was never set in the first place, you can use the <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_466"></a><code><a href="../../../../Darwin/Reference/ManPages/man1/printenv.1.html#//apple_ref/doc/man/1/printenv" target="_top">printenv</a></code> command to obtain a complete list of defined variables and use <code><a href="../../../../Darwin/Reference/ManPages/man1/grep.1.html#//apple_ref/doc/man/1/grep" target="_top">grep</a></code> to see if it is in the list. (You should note that although <code>printenv</code> is a csh builtin, it is also a standalone command in <code>/usr/bin</code>.)</p><p>For example:</p><div class="codesample"><table><tr><td scope="row"><pre>DEFINED=`printenv | grep -c '^VARIABLE='`<span></span></pre></td></tr></table></div>	<p>The resulting variable will contain 1 if the variable is defined in the environment or 0 if it is not.</p><a name="//apple_ref/doc/uid/TP40004268-CH237-SW12" title="Overriding Environment Variables for Child Processes (Bourne Shell)"></a><h3>Overriding Environment Variables for Child Processes (Bourne Shell)</h3><p><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_467"></a>Because the BASH Bourne shell variant automatically exports all variables inherited from its environment, any changes you make to preexisting environment variables such as <code>PATH</code> are automatically inherited by any tool or script that your script executes. (This is not true for other Bourne shell variants; see <span class="content_text"><a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW11">“Using the export Builtin (Bourne Shell)”</a></span> for further explanation.)</p><p>While automatic export is usually convenient, you may sometimes wish to change a preexisting environment variable without modifying the environment of any script or tool that your script executes. For example, if your script executes a number of tools in <code>/usr/local/bin</code>, it may be convenient to change the value of <code>PATH</code> to include <code>/usr/local/bin</code>. However, you may not want child processes to also look in <code>/usr/local/bin</code>.</p><p>This problem is easily solved by overriding the environment variable <code>PATH</code> on a per-execution basis. Consider the following script:</p><div class="codesample"><table><tr><td scope="row"><pre>#!/bin/sh<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>echo $MYVAR<span></span></pre></td></tr></table></div><p>This script prints the value of the variable <code>MYVAR</code>. Normally, this variable is empty, so this script just prints a blank line. Save the script as <code>printmyvar.sh</code>, then type the following commands:</p><div class="codesample"><table><tr><td scope="row"><pre>chmod a+x printmyvar.sh      # makes the script executable<span></span></pre></td></tr><tr><td scope="row"><pre>MYVAR=7 ./printmyvar.sh      # runs the script<span></span></pre></td></tr><tr><td scope="row"><pre>echo "MYVAR IS $MYVAR"       # prints the variable<span></span></pre></td></tr></table></div><p>Notice that the assignment statement <code>MYVAR=7</code> applies <code>only</code> to the command that follows it. The value of <code>MYVAR</code> is altered in the environment of the command <code>./printmyvar.sh</code>, so the script prints the number 7. However, the original (empty) value is restored after executing that command, so the echo statement afterwards prints an empty string for the value of <code>MYVAR</code>.</p><p>Thus, to modify the <code>PATH</code> variable locally but execute a command with the original <code>PATH</code> value, you can write a script like this:</p><div class="codesample"><table><tr><td scope="row"><pre>#!/bin/sh<span></span></pre></td></tr><tr><td scope="row"><pre>GLOBAL_PATH="$PATH"<span></span></pre></td></tr><tr><td scope="row"><pre>PATH=/usr/local/bin<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>PATH="$GLOBAL_PATH" /bin/ls<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40004268-CH237-SW18" title="Using the setenv Builtin (C shell)"></a><h3>Using the setenv Builtin (C shell)</h3><p><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_468"></a><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_469"></a>In the C shell, variables are exported if you set them with <code>setenv</code>, but not it you set them with <code>set</code>. Thus, if you want your shell variable modifications to be seen by any tool or script that you call, you should use the <code>setenv</code> builtin. This builtin is the C shell equivalent to issuing an assignment statement with the <code>export</code> builtin in the Bourne shell.</p><div class="codesample"><table><tr><td scope="row"><pre>setenv VALUE "Four"<span></span></pre></td></tr><tr><td scope="row"><pre>echo "VALUE is '$VALUE'."<span></span></pre></td></tr></table></div><p>If you want your shell variables to only be available to your script, you should use the <code>set</code> builtin (described in <span class="content_text"><a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW8">“Shell Variables and Printing”</a></span>). The <code>set</code> builtin is equivalent to a simple assignment statement in the Bourne shell.</p><div class="codesample"><table><tr><td scope="row"><pre>set VALUE = "Four"<span></span></pre></td></tr><tr><td scope="row"><pre>echo "VALUE is '$VALUE'."<span></span></pre></td></tr></table></div><p>Notice that the local variable version requires an equals sign (<code>=</code>), but the exported environment version does not (and produces an error if you put one in).</p><p>To remove variables in the C shell, you can use the <code>unsetenv</code> or <code>unset</code> builtin. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>setenv VALUE "Four"<span></span></pre></td></tr><tr><td scope="row"><pre>unsetenv VALUE<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>set VALUE = "Four"<span></span></pre></td></tr><tr><td scope="row"><pre>unset VALUE<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>echo "VALUE is '$VALUE'."<span></span></pre></td></tr></table></div><p>This will generate an error message. In the C shell, it is not possible to print the value of an undefined variable, so if you think you may need to print the value later, you should set it to an empty string rather than using <code>unset</code> or <code>unsetenv</code>.</p><p>If you need to test an environment variable (<em>not</em> a shell-local variable) that may or may not be part of your environment (a variable set by whatever process called your script), you can use the <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_470"></a><code><a href="../../../../Darwin/Reference/ManPages/man1/printenv.1.html#//apple_ref/doc/man/1/printenv" target="_top">printenv</a></code> builtin. This prints the value of a variable if set, but prints nothing if the variable is not set, and thus behaves just like the variable behaves in the Bourne shell.</p><p>For example:</p><div class="codesample"><table><tr><td scope="row"><pre>set X = `printenv VALUE`<span></span></pre></td></tr><tr><td scope="row"><pre>echo "X is "\"$X\"<span></span></pre></td></tr></table></div><p>This prints <code>X is ""</code> if the variable is either empty or undefined. Otherwise, it prints the value of the variable between the quotation marks.</p><p>If you need to find out if a variable is simply empty or is actually not set, you can also use <code>printenv</code> to obtain a complete list of defined variables and use <code><a href="../../../../Darwin/Reference/ManPages/man1/grep.1.html#//apple_ref/doc/man/1/grep" target="_top">grep</a></code> to see if it is in the list. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>set DEFINED = `printenv | grep -c '^VARIABLE='`<span></span></pre></td></tr></table></div>	<p>The resulting variable will contain 1 if the variable is defined in the environment or 0 if it is not.<a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_471"></a></p><a name="//apple_ref/doc/uid/TP40004268-CH237-SW29" title="Overriding Environment Variables for Child Processes (C Shell)"></a><h3>Overriding Environment Variables for Child Processes (C Shell)</h3><p>Unlike the Bourne shell, the C shell does not provide a built-in syntax for overriding environment variables when executing external commands. However, it is possible to simulate this either by using the <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_472"></a><code><a href="../../../../Darwin/Reference/ManPages/man1/env.1.html#//apple_ref/doc/man/1/env" target="_top">env</a></code> command.</p><p>The best and simplest way to do this is with the <code>env</code> command. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>env PATH="/usr/local/bin" /bin/ls<span></span></pre></td></tr></table></div><p>As an alternative, you can use the <code>set</code> builtin to make a temporary copy of any variable you need to override, change the value, execute the command, and restore the value from the temporary copy.</p><p>You should notice, however, that whether you use the <code>env</code> command or manually make a copy, the <code>PATH</code> variable is altered <em>prior to</em> searching for the command. Because the <code>PATH</code> variable controls where the shell looks for programs to execute, you must therefore explicitly provide a <em>complete</em> path to the <code>ls</code> command or it will not be found (unless you have a copy in <code>/usr/local/bin</code>, of course). The <code>PATH</code> environment variable is explained in <span class="content_text"><a href="../AdvancedTechniques/AdvancedTechniques.html#//apple_ref/doc/uid/TP40004268-TP40003521-SW20">“Special Shell Variables.”</a></span></p><p>As a workaround, you can determine the path of the executable using the <code><a href="../../../../Darwin/Reference/ManPages/man1/which.1.html#//apple_ref/doc/man/1/which" target="_top">which</a></code> command prior to altering the <code>PATH</code> environment variable.</p><div class="codesample"><table><tr><td scope="row"><pre>set GLOBAL_PATH = "$PATH"<span></span></pre></td></tr><tr><td scope="row"><pre>set LS = `which ls`<span></span></pre></td></tr><tr><td scope="row"><pre>setenv PATH "/usr/local/bin"<span></span></pre></td></tr><tr><td scope="row"><pre>$LS<span></span></pre></td></tr><tr><td scope="row"><pre>setenv PATH "$GLOBAL_PATH"<span></span></pre></td></tr><tr><td scope="row"><pre>unset GLOBAL_PATH<span></span></pre></td></tr></table></div><p>Or, using <code>env</code>:</p><div class="codesample"><table><tr><td scope="row"><pre>set LS = `which ls`<span></span></pre></td></tr><tr><td scope="row"><pre>env PATH='/usr/local/bin' $LS<span></span></pre></td></tr></table></div><p>The use of the backtick (`) operator in this fashion is described in <span class="content_text"><a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW10">“Inline Execution.”</a></span></p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH237-SW37" title="Security Note"></a><p><strong>Security Note:</strong>&nbsp;<a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_473"></a>If your purpose for overriding an environment variable is to prevent disclosure of sensitive information to a potentially untrusted process, you should be aware that if you use <code>setenv</code> for the copy, the called process has access to that temporary copy just as it had access to the original variable. To avoid this, be sure to create the temporary copy using the <code>set</code> builtin instead of <code>setenv</code>.<a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_474"></a></p></div><a name="//apple_ref/doc/uid/TP40004268-CH237-SW20" title="Shell Script Input and Output Using printf and read"></a><h2>Shell Script Input and Output Using printf and read</h2><p>Next, you might ask what to do if you need to get input from the user. The Bourne shell syntax provides basic input with very little effort.</p><div class="codesample"><table><tr><td scope="row"><pre>#!/bin/sh<span></span></pre></td></tr><tr><td scope="row"><pre>printf "What is your name?  -> "<span></span></pre></td></tr><tr><td scope="row"><pre>read NAME<span></span></pre></td></tr><tr><td scope="row"><pre>echo "Hello, $NAME.  Nice to meet you."<span></span></pre></td></tr></table></div><p>You will notice two things about this script. The first is that it introduces the <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_475"></a><code><a href="../../../../Darwin/Reference/ManPages/man1/printf.1.html#//apple_ref/doc/man/1/printf" target="_top">printf</a></code> command. This command is used because, unlike <code>echo</code>, the <code>printf</code> command does not automatically add a newline to the end of the line of output. This behavior is useful when you need to use multiple lines of code to output a single line of text. It also just happens to be handy for prompts.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH237-SW38" title="Note"></a><p><strong>Note:</strong>&nbsp;In most operating systems, you can tell <code>echo</code> to suppress the newline. However, the syntax for doing so varies. Thus, <code>printf</code> is recommended for printing prompts. See <span class="content_text"><a href="../PortingScriptstoMacOSX/PortingScriptstoMacOSX.html#//apple_ref/doc/uid/TP40004268-TP40003517-SW2">“Designing Scripts for Cross-Platform Deployment”</a></span> for more information and other alternatives.</p></div><p>The second thing you'll notice is the <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_476"></a><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_477"></a><code>read</code> command. This command takes a line of input and separates it into a series of arguments. Each of these arguments is assigned to the variables in the <code>read</code> statement in the order of appearance. Any additional input fields are appended to the last entry.</p><p>You can modify the behavior of the <code>read</code> command by modifying the shell variable <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_478"></a><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_479"></a><code>IFS</code> (short for internal field separators). The default behavior is to split inputs everywhere there is a space, tab, or newline. By changing this variable, you can make the shell split the input fields by tabs, newlines, semicolons, or even the letter 'q'. This change in behavior is demonstrated in the following example:</p><div class="codesample"><table><tr><td scope="row"><pre>#!/bin/sh<span></span></pre></td></tr><tr><td scope="row"><pre>printf "Type three numbers separated by 'q'. -> "<span></span></pre></td></tr><tr><td scope="row"><pre>IFS="q"<span></span></pre></td></tr><tr><td scope="row"><pre>read NUMBER1 NUMBER2 NUMBER3<span></span></pre></td></tr><tr><td scope="row"><pre>echo "You said: $NUMBER1, $NUMBER2, $NUMBER3"<span></span></pre></td></tr></table></div><p>If, for example, you run this script and enter <code>1q3q57q65</code>, the script replies with <code>You said: 1, 3, 57q65</code>. The third value contains <code>57q65</code> because only three values are requested in the read statement.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH237-SW39" title="Note"></a><p><strong>Note:</strong>&nbsp;The <code>read</code> statement <em>always</em> stops reading at the first newline encountered. Thus, if you set <code>IFS</code> to a newline, you cannot read multiple entries with a single <code>read</code> statement.</p></div><div class="warningbox"><img src="../../../../Resources/Images/icon_warning.gif" alt="!" width="20" height="20" border="0" class="warningicon" /><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_27" title="Warning:"></a><p><strong>Warning:</strong>&nbsp;Changing IFS may cause unexpected consequences for variable expansion. For more information, see <span class="content_text"><a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW9">“Variable Expansion and Field Separators.”</a></span></p><p></p><div class="clear"></div></div><p>But what if you don’t know how many parameters the user will specify? Obviously, a single read statement cannot split the input up into an arbitrary number of variables, and the Bourne shell does not contain true arrays. Fortunately, the <code><a href="../../../../Darwin/Reference/ManPages/man1/eval.1.html#//apple_ref/doc/man/1/eval" target="_top">eval</a></code> builtin can be used to simulate an array using multiple shell variables. This technique is described in <span class="content_text"><a href="../AdvancedTechniques/AdvancedTechniques.html#//apple_ref/doc/uid/TP40004268-TP40003521-SW1">“Data Structures, Arrays, and Indirection.”</a></span></p><p>Alternatively, you can use the <code>for</code> statement, which splits a single variable into multiple pieces based on the internal field separators. This statement is described in <span class="content_text"><a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW7">“The for Statement.”</a></span></p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH237-SW40" title="C Shell Note"></a><p><strong>C Shell Note:</strong>&nbsp;<a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_480"></a>In the C shell, the syntax for reading is completely different. The following script is the C shell equivalent of the script earlier in this section:</p><div class="codesample"><table><tr><td scope="row"><pre>printf "What is your name?  -> "<span></span></pre></td></tr><tr><td scope="row"><pre>set NAME = "$&lt;"<span></span></pre></td></tr><tr><td scope="row"><pre>echo "Hello, $NAME.  Nice to meet you."<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_481"></a>The C shell does not provide a way to read multiple values in a single command, though you can approximate this with careful use of <code><a href="../../../../Darwin/Reference/ManPages/man1/sed.1.html#//apple_ref/doc/man/1/sed" target="_top">sed</a></code> as described in <span class="content_text"><a href="../RegularExpressionsUnfettered/RegularExpressionsUnfettered.html#//apple_ref/doc/uid/TP40004268-CH238-SW7">“Regular Expressions Unfettered”</a></span> or <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_482"></a><code><a href="../../../../Darwin/Reference/ManPages/man1/cut.1.html#//apple_ref/doc/man/1/cut" target="_top">cut</a></code>. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>#!/bin/csh<span></span></pre></td></tr><tr><td scope="row"><pre>printf "Type three numbers separated by 'q'. -> "<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>set LINE = "$&lt;"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>set NUMBER1 = `echo "$LINE" | cut -f 1 -d 'q'`<span></span></pre></td></tr><tr><td scope="row"><pre>set NUMBER2 = `echo "$LINE" | cut -f 2 -d 'q'`<span></span></pre></td></tr><tr><td scope="row"><pre>set NUMBER3 = `echo "$LINE" | cut -f 3 -d 'q'`<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>echo "You said: $NUMBER1, $NUMBER2, $NUMBER3"<span></span></pre></td></tr></table></div></div><a name="//apple_ref/doc/uid/TP40004268-CH237-SW21" title="Bulk I/O Using the cat Command"></a><h2>Bulk I/O Using the cat Command</h2><p>For small I/O, the <code><a href="../../../../Darwin/Reference/ManPages/man1/echo.1.html#//apple_ref/doc/man/1/echo" target="_top">echo</a></code> command is well suited. However, when you need to create large amounts of data, it may be convenient to send multiple lines to a file simultaneously. For these purposes, the <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_483"></a><code><a href="../../../../Darwin/Reference/ManPages/man1/cat.1.html#//apple_ref/doc/man/1/cat" target="_top">cat</a></code> command can be particularly useful.</p><p>By itself, the <code>cat</code> command really doesn’t do anything that can’t be done using redirect operators (except for printing the contents of a file to the user’s screen). However, by combining it with the special operator <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_484"></a><code>&lt;&lt;</code>, you can use it to send a large quantity of text to a file (or to the screen) without having to use the <code>echo</code> command on every line.</p><p>For example:</p><div class="codesample"><table><tr><td scope="row"><pre>cat > mycprogram.c &lt;&lt; EOF<span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;stdio.h><span></span></pre></td></tr><tr><td scope="row"><pre>int main(int argc, char *argv[])<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    char array[] = { 0x25, 115, 0 };<span></span></pre></td></tr><tr><td scope="row"><pre>    char array2[] = { 68, 0x61, 118, 0x69, 0144, 040,<span></span></pre></td></tr><tr><td scope="row"><pre>                        0107, 97, 0x74, 119, 0157, 0x6f,<span></span></pre></td></tr><tr><td scope="row"><pre>                        100, 0x20, 0x72, 117, 'l', 0x65,<span></span></pre></td></tr><tr><td scope="row"><pre>                        115, 041, 012, 0 };<span></span></pre></td></tr><tr><td scope="row"><pre>    printf(array, array2);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>EOF<span></span></pre></td></tr></table></div><p>This example script takes the text after the line containing the <code>cat</code> command up to (but not including) the line that <em>begins</em> with <code>EOF</code> and stores it into the file <code>mycprogram.c</code>. Note that the token <code>EOF</code> can be replaced with any token, so long as the following conditions are met:</p><ul class="ul"><li class="li"><p>The token must not contain spaces unless you surround it with quotation marks. (These outer quotation marks are not considered part of the token unless you quote them.)</p></li><li class="li"><p>Shell variables in the name of the token are <em>not</em> expanded, so the <code>$</code> character is just like any other ordinary character.</p></li><li class="li"><p>The token after the <code>&lt;&lt;</code> in the starting line must match the token at the beginning of the last line.</p></li><li class="li"><p>The end-of-block token must be the only thing that appears on the line. If it shares the line with any other characters (<em>including</em> whitespace), it will be treated as part of the text to be output.</p></li><li class="li"><p>The end-of-block token you choose must never appear as a line in the intended output string.</p></li></ul><p>This technique is also frequently used for printing instructions to the user from an interactive shell script. This avoids the clutter of dozens of lines of <code>echo</code> commands and makes the text much easier to read and edit in an external text editor (if desired).</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_28" title="Note"></a><p><strong>Note:</strong>&nbsp;Although shell variables cannot be used to define the token itself, by default, shell variables <code>are</code> expanded within the string to be printed. To disable this expansion, surround the token with single or double quote marks. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>cat &lt;&lt; 'EOF'<span></span></pre></td></tr><tr><td scope="row"><pre>The variable in this line will not be expanded: $PATH<span></span></pre></td></tr><tr><td scope="row"><pre>EOF<span></span></pre></td></tr></table></div>Notice that <code>EOF</code> does not appear in quotes in the actual text. This is a key difference between the Bourne shell and C shell behavior. If you want to explicitly look for EOF within single quotes, you would write it like this:</p><div class="codesample"><table><tr><td scope="row"><pre>cat &lt;&lt; "'EOF'"<span></span></pre></td></tr><tr><td scope="row"><pre>...<span></span></pre></td></tr><tr><td scope="row"><pre>'EOF'<span></span></pre></td></tr></table></div>or</p><div class="codesample"><table><tr><td scope="row"><pre>cat &lt;&lt; \''EOF'\'<span></span></pre></td></tr><tr><td scope="row"><pre>...<span></span></pre></td></tr><tr><td scope="row"><pre>'EOF'<span></span></pre></td></tr></table></div></div><p>Another classic example of this use of <code>cat</code> in action is the <code>.shar</code> file format, created by the tool <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_485"></a><code><a href="../../../../Darwin/Reference/ManPages/man1/shar.1.html#//apple_ref/doc/man/1/shar" target="_top">shar</a></code> (short for SHell ARchive). This tool takes a list of files as input and uses them to create a giant shell script which, when executed, recreates those original files. To avoid the risk of the end-of-block token appearing in the input file, it prepends each line with a special character, then strips that character off on output.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH237-SW41" title="C Shell Note"></a><p><strong>C Shell Note:</strong>&nbsp;The multiline <code>cat</code> syntax in the C shell is the same as in the Bourne shell, with one key difference: the entire token is treated as literal text for matching purposes, including backslashes and quotation marks. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>cat &lt;&lt; 'EOF'<span></span></pre></td></tr><tr><td scope="row"><pre>The variable in this line will not be expanded: $PATH<span></span></pre></td></tr><tr><td scope="row"><pre>'EOF'<span></span></pre></td></tr></table></div>For another example:</p><div class="codesample"><table><tr><td scope="row"><pre>cat &lt;&lt; \''EOF'\'<span></span></pre></td></tr><tr><td scope="row"><pre>The variable in this line will not be expanded: $PATH<span></span></pre></td></tr><tr><td scope="row"><pre>\''EOF'\'<span></span></pre></td></tr></table></div>In both cases, the quotation marks still behave as a switch to control whether or not to expand variables within the output.</p></div>
<a name="//apple_ref/doc/uid/TP40004268-CH237-SW23" title="Pipes and Redirection"></a><h2>Pipes and Redirection</h2>
<p><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_486"></a>As you may already be aware, the true power of shell scripting lies not in the scripts themselves, but in the ability to read and write files and chain multiple programs together in interesting ways.</p><p>Each program in a UNIX-based or UNIX-like system has three basic file descriptors (normally a reference to a file or socket) reserved for basic input and output: <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_487"></a>standard input (often abbreviated <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_488"></a>stdin), <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_489"></a>standard output (<a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_490"></a>stdout), and <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_491"></a>standard error (<a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_492"></a>stderr).</p><p>The first, standard input, normally takes input from the user's keyboard (when the shell window is in the foreground, of course). The second, standard output, normally contains the output text from the program. The third, standard error, is generally reserved for warning or error messages that are not part of the normal output of the program. This distinction between standard output and standard error is a very important one, as explained in <span class="content_text"><a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW1">“Pipes and File Descriptor Redirection (Bourne Shell).”</a></span></p><a name="//apple_ref/doc/uid/TP40004268-CH237-SW2" title="Basic File Redirection"></a><h3>Basic File Redirection</h3><p>One of the most common types of I/O in shell scripts is reading and writing files. Fortunately, it is also relatively simple to do. Reading and writing <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_493"></a><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_494"></a>files in shell scripts works exactly like getting input from or sending output to the user, but with the standard input redirected to come from a file or with the standard output redirected to a file.</p><p>For example, the following command creates a file called <code>MyFile</code> and fills it with a single line of text:</p><div class="codesample"><table><tr><td scope="row"><pre>echo "a single line of text" > MyFile<span></span></pre></td></tr></table></div><p>Appending data is just as easy. The following command appends another line of text to the file <code>MyFile</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>echo "another line of text" >> MyFile<span></span></pre></td></tr></table></div><p>You should notice that the redirect operator (<a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_495"></a><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_496"></a><code>></code>) creates a file, while the append operator (<a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_497"></a><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_498"></a><code>>></code>) appends to the file.</p><p>Many (but not all) Bourne-compatible shells support a third operator in this family, the merging redirect operator (<a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_499"></a><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_500"></a><code>>&amp;</code>). The most common use of this merging redirect operator is to redirect standard error and standard output simultaneously to a file. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>ls . THISISNOTAFILE >&amp; filelistwitherrors<span></span></pre></td></tr></table></div><p>This creates a file called <code>filelistwitherrors</code>, containing both a listing of the current directory and an error message about the nonexistence of the file <code>THISISNOTAFILE</code>. The standard output and standard error streams are merged and written out to the resulting file.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_29" title="Compatibility Note"></a><p><strong>Compatibility Note:</strong>&nbsp;Not all Bourne shell variants support the <code>>&amp;</code> operator when used in this way. This simplified behavior is not specified by POSIX, and a few shells (most notably <code>ash</code> and its Debian derivative, <code>dash</code>) generate an error if you try to use this operator without specifying a file descriptor number after the <code>>&amp;</code>. For maximum portability, you should redirect standard output to a file, then separately combine standard error into standard output like this:</p><div class="codesample"><table><tr><td scope="row"><pre>ls . THISISNOTAFILE > filelistwitherrors 2>&amp;1<span></span></pre></td></tr></table></div>See <span class="content_text"><a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW1">“Pipes and File Descriptor Redirection (Bourne Shell)”</a></span> for more information about using file descriptor redirection to combine file descriptors.</p></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH237-SW42" title="Note"></a><p><strong>Note:</strong>&nbsp;The merging redirect operator (<code>>&amp;</code>) is a very powerful operator. Additional uses beyond basic use are described in more detail in <span class="content_text"><a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW1">“Pipes and File Descriptor Redirection (Bourne Shell).”</a></span></p></div><a name="//apple_ref/doc/uid/TP40004268-CH237-SW1" title="Pipes and File Descriptor Redirection (Bourne Shell)"></a><h3>Pipes and File Descriptor Redirection (Bourne Shell)</h3><p>The simplest example of the use of <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_501"></a>pipes is to pipe the standard output of one program to the standard input of another program. Type the following on the command line:</p><div class="codesample"><table><tr><td scope="row"><pre>ls -l | grep 'rwx'<span></span></pre></td></tr></table></div><p>You will see all of the files whose permissions (or name) contain the letters <code>rwx</code> in order. The <code><a href="../../../../Darwin/Reference/ManPages/man1/ls.1.html#//apple_ref/doc/man/1/ls" target="_top">ls</a></code> command lists files to its standard output, and the <code><a href="../../../../Darwin/Reference/ManPages/man1/grep.1.html#//apple_ref/doc/man/1/grep" target="_top">grep</a></code> command takes its input and sends any lines that match a particular pattern to its standard output. Between those two commands is the pipe operator (<code>|</code>). This tells the shell to connect the standard output of <code>ls</code> to the standard input of <code>grep</code>.</p><p>Where the distinction between standard output becomes significant is when the <code>ls</code> command gives an error.</p><div class="codesample"><table><tr><td scope="row"><pre>ls -l THISFILEDOESNOTEXIST | grep 'rwx'<span></span></pre></td></tr></table></div><p>You should notice that the <code>ls</code> command issued an error message (unless you have a file called <code>THISFILEDOESNOTEXIST</code> in your home directory, of course). If the <code>ls</code> command had sent this error message to its standard output, it would have been gobbled up by the <code>grep</code> command, since it does not match the pattern <code>rwx</code>. Instead, the <code>ls</code> command sent the message to its standard error descriptor, which resulted in the message going directly to your screen.</p><p>In some cases, however, it can be useful to <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_502"></a>redirect the error messages along with the output. You can do this by using a special form of the combining redirection operator (<code>>&amp;</code>).</p><p>Before you can begin, though, you need to know the file descriptor numbers. Descriptor 0 is standard input, descriptor 1 is standard output, and descriptor 2 is standard error. Thus, the following command combines standard error into standard output, then pipes the result to grep:</p><div class="codesample"><table><tr><td scope="row"><pre>ls -l THISFILEDOESNOTEXIST 2>&amp;1 | grep 'rwx'<span></span></pre></td></tr></table></div><p>This operator is also often useful if your script needs to send a message to standard error. The following command sends “an error message” to standard error:</p><div class="codesample"><table><tr><td scope="row"><pre>echo "an error message" 1>&amp;2<span></span></pre></td></tr></table></div><p>This works by taking the standard output (descriptor 1) of the echo command and redirects it to standard error (descriptor 2).</p><p>You should notice that the ampersand (<code>&amp;</code>) appears to behave somewhat differently than it did in <span class="content_text"><a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW2">“Basic File Redirection.”</a></span> Because the ampersand is followed immediately by a number, this causes the output of one data stream to be merged into another stream. In actuality, however, the effect is the same (assuming your shell supports the use of <code>>&amp;</code> by itself).</p><p>The redirect (<code>></code>) operator implicitly redirects standard output. When combined with an ampersand and followed by a filename, in some shells, it merges standard output and standard error and writes the result to a file, though this behavior is not portable. By specifying numbers, your script is effectively overriding which file descriptor to use as its source and specifying a file descriptor to receive the result instead of a file.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_30" title="Note"></a><p><strong>Note:</strong>&nbsp;<a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_503"></a>Be careful when mixing normal redirection with file descriptor merging. The following command combines standard output and standard error into a single output file.</p><div class="codesample"><table><tr><td scope="row"><pre>ls . BOGUSFILENAME > filelistwitherrors 2>&amp;1<span></span></pre></td></tr></table></div>If you reverse the order of the redirects, however, only standard output is written into the file.</p><div class="codesample"><table><tr><td scope="row"><pre>ls . BOGUSFILENAME 2>&amp;1 > just the file<span></span></pre></td></tr></table></div>Further, if you pipe the result of the second version above into another utility, it will receive the standard error output from the <code>ls</code> command.</p></div><a name="//apple_ref/doc/uid/TP40004268-CH237-SW24" title="Pipes and File Descriptor Redirection (C Shell)"></a><h3>Pipes and File Descriptor Redirection (C Shell)</h3><p>The C shell does not support the full set of file descriptor redirection that the Bourne shell supports. In some cases, alternatives are provided. For example, you can <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_504"></a>pipe standard output and standard error to the same process using the <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_505"></a><code>|&amp;</code> operator as shown in the following snippet:</p><div class="codesample"><table><tr><td scope="row"><pre>ls -l THISFILEDOESNOTEXIST |&amp; grep 'rwx'<span></span></pre></td></tr></table></div><p>Some other operations, however, are not possible. You cannot, for example, redirect standard error without redirecting standard output. At best, if you can determine that your standard output will always be <code>/dev/tty</code>, you can work around this by redirecting standard output to <code>/dev/tty</code> first, then redirecting both the now-empty standard output and standard error using the <code>>&amp;</code> operator. For example, to redirect only standard error to <code>/dev/null</code>, you could do this:</p><div class="codesample"><table><tr><td scope="row"><pre>(ls > /dev/tty) >&amp; /dev/null<span></span></pre></td></tr></table></div><p>This technique is <em>not</em> recommended for general use, however, as it will send output to your screen if anyone runs your script with standard output set to a file or pipe.</p><p>You can also work around this using a file, but not in an interactive way. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>(ls > /tmp/mytemporarylslisting) >&amp; /dev/null<span></span></pre></td></tr><tr><td scope="row"><pre>cat /tmp/mytemporarylslisting<span></span></pre></td></tr></table></div><p>It is, however, possible to discard standard output and capture standard input. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>(ls / /bogusfile > /dev/null) |&amp; more<span></span></pre></td></tr></table></div><p>It is not possible to redirect messages to standard error using the C shell unless you write a Bourne shell script or C program to do the redirection for you.<a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_506"></a></p>
<a name="//apple_ref/doc/uid/TP40004268-CH237-SW5" title="Basic Control Statements"></a><h2>Basic Control Statements</h2>
<p><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_507"></a>The examples up to this point have been very basic, linear programs. This section introduces some control flow statements that allow for more complex programs.</p><a name="//apple_ref/doc/uid/TP40004268-CH237-SW6" title="The if Statement"></a><h3>The if Statement</h3><p><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_508"></a>The first control statement you should be aware of in shell scripting is the <code>if</code> statement. This statement behaves very much like the <code>if</code> statement in other programming languages, with a few subtle distinctions.</p><p>The first distinction is that the test performed by the <code>if</code> statement is actually the execution of a command. When the shell encounters an <code>if</code> statement, it executes the statement that immediately follows it. Depending on the return value, it will execute whatever follows the <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_509"></a><code>then</code> statement. Otherwise, it will execute whatever follows the else statement.</p><p>The second distinction is that in shell scripts, many things that look like language keywords are actually programs. For example, the following code executes <code>/bin/true</code> and <code>/bin/false</code>.</p><div class="codesample"><table><tr><td scope="row"><pre># always execute<span></span></pre></td></tr><tr><td scope="row"><pre>if true; then<span></span></pre></td></tr><tr><td scope="row"><pre>    ls<span></span></pre></td></tr><tr><td scope="row"><pre>else<span></span></pre></td></tr><tr><td scope="row"><pre>    echo "true is false."<span></span></pre></td></tr><tr><td scope="row"><pre>fi<span></span></pre></td></tr><tr><td scope="row"><pre># never execute<span></span></pre></td></tr><tr><td scope="row"><pre>if false; then<span></span></pre></td></tr><tr><td scope="row"><pre>    ls<span></span></pre></td></tr><tr><td scope="row"><pre>fi<span></span></pre></td></tr></table></div><p>In both of these cases, an executable is being run—specifically, <code>/bin/true</code> and <code>/bin/false</code>. Any executable could be used here.</p><p>A return of zero (0) is considered to be true (success), and any other value is considered to be false (failure). Thus, if the executable returns zero (0), the commands following the <code>then</code> statement will be executed. Otherwise, the statements following the <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_510"></a><code>else</code> clause (if one exists) will be executed.</p><p>The reason for this seemingly backwards definition of <code>true</code> and <code>false</code> is that most UNIX tools exit with an exit status of zero upon success and a nonzero exit status on failure, with positive numbers usually indicating a user mistake and negative numbers usually indicating a more serious failure of some sort. Thus, you can easily test to see if a program completed successfully by seeing if the exit status is the same as that of <code>true</code>.</p><p>One related statement that you should be familiar with is <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_511"></a><code>elif</code>. This statement is similar to saying <code>else if</code> except that it does not require an additional <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_512"></a><code>fi</code> at the end of the conditional, and thus results in more readable code.</p><p>For example:</p><div class="codesample"><table><tr><td scope="row"><pre>#/bin/sh<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>read A<span></span></pre></td></tr><tr><td scope="row"><pre>if [ "x$A" = "xfoo" ] ; then<span></span></pre></td></tr><tr><td scope="row"><pre>    echo "Foo"<span></span></pre></td></tr><tr><td scope="row"><pre>elif [ "x$A" = "xbar" ] ; then<span></span></pre></td></tr><tr><td scope="row"><pre>    echo "Bar"<span></span></pre></td></tr><tr><td scope="row"><pre>else<span></span></pre></td></tr><tr><td scope="row"><pre>    echo "Other"<span></span></pre></td></tr><tr><td scope="row"><pre>fi<span></span></pre></td></tr></table></div><p>This example reads a string from standard input and prints one of three things, depending on whether you typed “foo”, “bar’, or anything else. (The bracket syntax used in this example is explained in the next section, <span class="content_text"><a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW4">“The test Command and Bracket Notation.”</a></span>)</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH237-SW43" title="C Shell Note"></a><p><strong>C Shell Note:</strong>&nbsp;The C shell syntax is similar to C. There are two forms:</p><div class="codesample"><table><tr><td scope="row"><pre>#!/bin/csh<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>set A = "$&lt;"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if ( "x${A}" == "xfoo" ) echo "Foo (single line)"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if ( "x${A}" == "xfoo" ) then<span></span></pre></td></tr><tr><td scope="row"><pre>    echo "Foo"<span></span></pre></td></tr><tr><td scope="row"><pre>else if ( "x${A}" == "xbar" ) then<span></span></pre></td></tr><tr><td scope="row"><pre>    echo "Bar"<span></span></pre></td></tr><tr><td scope="row"><pre>else<span></span></pre></td></tr><tr><td scope="row"><pre>    echo "Other"<span></span></pre></td></tr><tr><td scope="row"><pre>endif<span></span></pre></td></tr></table></div>Note that the <code>echo "x"</code> or <code>then</code> statement <em>must</em> appear on the same line as the <code>if</code> statement. If it does not, you get an “empty if” error and the script terminates.</p></div><a name="//apple_ref/doc/uid/TP40004268-CH237-SW4" title="The test Command and Bracket Notation"></a><h3>The test Command and Bracket Notation</h3><p><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_513"></a><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_514"></a>While the <code>if</code> statement can be used to run any executable, the most common use of the <code>if</code> statement is to test whether some condition is true or false, much like you would in a C program or other programming language. For example, the <code>if</code> statement is commonly used to see if two strings are equal.</p><p>Because the <code>if</code> statement runs a command, in order to use the <code>if</code> statement in this fashion, you will need a program to run that performs the comparison desired. Fortunately, one is built into the OS: <code><a href="../../../../Darwin/Reference/ManPages/man1/test.1.html#//apple_ref/doc/man/1/test" target="_top">test</a></code>. The <code>test</code> executable is rarely run directly, however. Generally, it is invoked by running <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_515"></a><code><a href="../../../../Darwin/Reference/ManPages/man1/[.1.html#//apple_ref/doc/man/1/[" target="_top">[</a></code>, which is just a symbolic link or hard link to <code>/bin/test</code>.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH237-SW44" title="Note"></a><p><strong>Note:</strong>&nbsp;While the open bracket is a command, and there is a man page, you will have a hard time getting to it on the command line. Use:</p><div class="codesample"><table><tr><td scope="row"><pre>man \\[<span></span></pre></td></tr></table></div>to see it (or just look at the man page for <code><a href="../../../../Darwin/Reference/ManPages/man1/test.1.html#//apple_ref/doc/man/1/test" target="_top">test</a></code>).</p></div><p>In this form, the syntax of an <code>if</code> statement more closely resembles other languages. Consider the following example:</p><div class="codesample"><table><tr><td scope="row"><pre>#! /bin/sh<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>FIRST_ARGUMENT="$1"<span></span></pre></td></tr><tr><td scope="row"><pre>if [ x$FIRST_ARGUMENT = "xSilly" ] ; then<span></span></pre></td></tr><tr><td scope="row"><pre>    echo "Silly human, scripts are for kiddies."<span></span></pre></td></tr><tr><td scope="row"><pre>else<span></span></pre></td></tr><tr><td scope="row"><pre>    echo "Hello, world $FIRST_ARGUMENT!"<span></span></pre></td></tr><tr><td scope="row"><pre>fi<span></span></pre></td></tr></table></div><p>There are two things you should notice. First, the space before the equal sign is critical. This space is the difference between assignment (no space) and comparison (space). The spaces around the brackets are also critical, as failure to include these spaces will result in a syntax error. (Remember, the open bracket is really just a command, and it expects that its last argument will be a close bracket by itself.)</p><p>Second, you should notice that the two arguments to the comparison are preceded by an ‘x’. The reason for this is that the variable substitution occurs before this statement is executed. If you omit the ‘x’ and the value in <code>$FIRST_ARGUMENT</code> is empty this statement evaluates to “<code>if [ = "Silly" ]</code>”, which is a blatant syntax error.</p><p>Another way to solve the empty variable problem is through the use of double quote marks. That way, even if the variable is empty, there is a placeholder. The following example uses double quote marks to test to see if a variable is empty:</p><div class="codesample"><table><tr><td scope="row"><pre>if [ "$VARIABLE" = "" ] ; then<span></span></pre></td></tr><tr><td scope="row"><pre>    echo "Empty variable \$VARIABLE"<span></span></pre></td></tr><tr><td scope="row"><pre>fi<span></span></pre></td></tr></table></div><p>Now this example introduces another special character, the backslash. It is also known as a quote character because the character immediately after it is treated as though it were within quotes. Thus, in this case, the snippet prints the name of the variable <code>$VARIABLE</code> rather than its contents. The use of backslash (and other similar characters) is described further in <span class="content_text"><a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW13">“Quoting Special Characters.”</a></span></p><p>The <code>test</code> command can also be used for various other tests, including the testing for the existence of a file, basic numerical comparisons, checking whether a path points to a directory, an executable, or a symbolic link, and so on. For example, the <code>-d</code> flag checks whether its argument is a directory, as shown in this snippet:</p><div class="codesample"><table><tr><td scope="row"><pre>if [ -d "/System/Library/Frameworks" ] ; then<span></span></pre></td></tr><tr><td scope="row"><pre>    echo "/System/Library/Frameworks is a directory."<span></span></pre></td></tr><tr><td scope="row"><pre>fi<span></span></pre></td></tr></table></div><p>A complete list of flags and operators supported by the test command can be found in the man page <code><a href="../../../../Darwin/Reference/ManPages/man1/test.1.html#//apple_ref/doc/man/1/test" target="_top">test</a></code>.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH237-SW45" title="C Shell Note"></a><p><strong>C Shell Note:</strong>&nbsp;While the test command can be used in the C shell, it is somewhat unusual to do so; the <code>if</code> and <code>while</code> statements in the C shell do not use it as part of their normal syntax.</p></div><a name="//apple_ref/doc/uid/TP40004268-CH237-SW25" title="The while Statement"></a><h3>The while Statement</h3><p><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_516"></a>In addition to the <code>if</code> statement, the Bourne shell also supports a <code>while</code> statement. Its syntax is similar.</p><div class="codesample"><table><tr><td scope="row"><pre>while true; do<span></span></pre></td></tr><tr><td scope="row"><pre>    ls<span></span></pre></td></tr><tr><td scope="row"><pre>done<span></span></pre></td></tr></table></div><p>Like the <code>if</code> statement’s <code>then</code> and <code>fi</code>, the while statement is bracketed by <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_517"></a><code>do</code> and <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_518"></a><code>done</code>. Much like the <code>if</code> statement, the while statement takes a single argument, which contains a command to execute. Thus, it is common to use the bracket command with <code>while</code> just as you do with <code>if</code> (as described in <span class="content_text"><a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW4">“The test Command and Bracket Notation”</a></span>). For example:</p><div class="codesample"><table><tr><td scope="row"><pre>while [ "x$FOO" != "x" ] ; do<span></span></pre></td></tr><tr><td scope="row"><pre>    FOO="$(cat)";<span></span></pre></td></tr><tr><td scope="row"><pre>done<span></span></pre></td></tr></table></div><p>Of course, this is a rather silly example. However, it does demonstrate one of the more powerful features in the Bourne shell scripting language: the <code>$()</code> operator, which inserts the output of one command into the middle of a statement. In the case above, the <code>cat</code> command is executed, and its standard output is stored in the variable <code>FOO</code>. This technique is described more in <span class="content_text"><a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW10">“Inline Execution.”</a></span></p><p>At any time during a loop, you can terminate the loop early with the <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_519"></a><code>break</code> statement or skip ahead to the next iteration of the loop with the <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_520"></a><code>continue</code> statement. When working with nested loops, these statements may be followed by an optional numerical argument to alter execution of the enclosing loops. For example, consider the following statements:</p><div class="codesample"><table><tr><td scope="row"><pre>break 2<span></span></pre></td></tr><tr><td scope="row"><pre>continue 2<span></span></pre></td></tr></table></div><p>The first statement breaks out of not only the top level <code>while</code> or <code>for</code> statement, but also the <code>while</code> or <code>for</code> statement that contains it. The second statement not only causes the remainder of the current loop to be skipped, but also causes the remainder of the loop that encloses it to be skipped.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH237-SW46" title="C Shell Note"></a><p><strong>C Shell Note:</strong>&nbsp;The C shell syntax is similar:</p><div class="codesample"><table><tr><td scope="row"><pre>set FOO = "x"<span></span></pre></td></tr><tr><td scope="row"><pre>while (${FOO} != "")<span></span></pre></td></tr><tr><td scope="row"><pre>    set FOO = `cat`<span></span></pre></td></tr><tr><td scope="row"><pre>end<span></span></pre></td></tr></table></div>Just as in C, the <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_521"></a><code>break</code> and <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_522"></a><code>continue</code> statements are also supported for further loop control. <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_523"></a>However, it does not support breaking or continuing at any nesting level other than the topmost level.</p></div><a name="//apple_ref/doc/uid/TP40004268-CH237-SW7" title="The for Statement"></a><h3>The for Statement</h3><p>The most unusual control structure in this chapter is the <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_524"></a><code>for</code> statement. It can take two very different forms depending on what you want to do.</p><p>In a standard Bourne shell, the <code>for</code> statement in shell scripts is completely unlike its C equivalent (which requires numerical computation, as described in <span class="content_text"><a href="../PaintbyNumbers/PaintbyNumbers.html#//apple_ref/doc/uid/TP40004268-TP40003512-SW1">“Paint by Numbers”</a></span>), and actually behaves much like the <code>foreach</code> statement in various languages.</p><p>In some modern Bourne shell variants, you can also do a numerical version of a for loop. The syntax is nearly identical to the C syntax for for loops.</p><p>The two syntaxes are covered in the following sections.</p><a name="//apple_ref/doc/uid/TP40004268-CH237-SW47" title="Standard for Loops"></a><h4>Standard for Loops</h4><p><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_525"></a>The <code>for</code> statement in Bourne shell scripts iterates through the items in a list. For each item, it sets the loop variable to the item, then executes a series of statements.</p><p>In the next example, the list is <code>*.JPG</code>. When the shell performs globbing on this (see <span class="content_text"><a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW15">“Special Characters Explained”</a></span> for more information), it replaces the <code>*.JPG</code> with a list of files in the current directory that end in <code>.JPG</code>.</p><p>Without going into details about the regular expression syntax used by the <code><a href="../../../../Darwin/Reference/ManPages/man1/sed.1.html#//apple_ref/doc/man/1/sed" target="_top">sed</a></code> command (this syntax is described in more detail in <span class="content_text"><a href="../RegularExpressionsUnfettered/RegularExpressionsUnfettered.html#//apple_ref/doc/uid/TP40004268-CH238-SW7">“Regular Expressions Unfettered”</a></span>), the following script renames every file in the current directory that ends with <code>.JPG</code> to end in <code>.jpg</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>#!/bin/sh<span></span></pre></td></tr><tr><td scope="row"><pre>for i in *.JPG ; do<span></span></pre></td></tr><tr><td scope="row"><pre>    mv "$i" "$(echo $i | sed 's/\.JPG$/.x/')"<span></span></pre></td></tr><tr><td scope="row"><pre>    mv "$(echo $i | sed 's/\.JPG$/.x/')" "$(echo $i | sed 's/\.JPG$/.jpg/')"<span></span></pre></td></tr><tr><td scope="row"><pre>done<span></span></pre></td></tr></table></div><p>The <code>for</code> statement (by default) splits the file list on unquoted spaces. For example, the following script will print the letters “a” and “b” on separate lines, then print “c d” on a third line:</p><div class="codesample"><table><tr><td scope="row"><pre>#!/bin/sh<span></span></pre></td></tr><tr><td scope="row"><pre>for i in a b c\ d ; do<span></span></pre></td></tr><tr><td scope="row"><pre>    echo $i<span></span></pre></td></tr><tr><td scope="row"><pre>done<span></span></pre></td></tr></table></div><p>Under certain circumstances, you can change the way that the <code>for</code> statement splits lists by changing the contents of the variable <code>IFS</code>. The details of when this does and does not work are described in <span class="content_text"><a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW9">“Variable Expansion and Field Separators.”</a></span></p><p>At any time during a loop, you can terminate the loop early with the <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_526"></a><code>break</code> statement or skip ahead to the next iteration of the loop with the <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_527"></a><code>continue</code> statement. When working with nested loops, these statements may be followed by an optional numerical argument to alter execution of the enclosing loops. For example, consider the following statements:</p><div class="codesample"><table><tr><td scope="row"><pre>break 2<span></span></pre></td></tr><tr><td scope="row"><pre>continue 2<span></span></pre></td></tr></table></div><p>The first statement breaks out of not only the top level <code>while</code> or <code>for</code> statement, but also the <code>while</code> or <code>for</code> statement that contains it. The second statement not only causes the remainder of the current loop to be skipped, but also causes the remainder of the loop that encloses it to be skipped.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH237-SW48" title="C Shell Note"></a><p><strong>C Shell Note:</strong>&nbsp;The C shell <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_528"></a><code>foreach</code> statement is similar.</p><div class="codesample"><table><tr><td scope="row"><pre>#!/bin/csh<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>foreach i ( *.JPG )<span></span></pre></td></tr><tr><td scope="row"><pre>    mv "${i}" `echo ${i} | sed 's/\.JPG$/.x/'`<span></span></pre></td></tr><tr><td scope="row"><pre>    mv `echo ${i} | sed 's/\.JPG$/.x/'` `echo ${i} | sed 's/\.JPG$/.jpg/'`<span></span></pre></td></tr><tr><td scope="row"><pre>end<span></span></pre></td></tr></table></div>While the C shell supports the <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_529"></a><code>break</code> and <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_530"></a><code>continue</code> statements in a <code>foreach</code> loop, <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_531"></a>it does not support breaking or continuing at any nesting level other than the topmost level.</p></div><a name="//apple_ref/doc/uid/TP40004268-CH237-SW31" title="Extended for Loops"></a><h4>Extended for Loops</h4><p><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_532"></a><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_533"></a><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_534"></a>Most modern Bourne shells (including BASH) provide an extension for numerical for loops using a variant of the built-in math operator (double parentheses). You can see this style of <code>for</code> loop in the following script. It takes a single argument and counts from 1 up to the number specified in that argument. To demonstrate the concept as succinctly as possible, it makes no attempt to validate its input. You, however, should always do so in your scripts.</p><div class="codesample"><table><tr><td scope="row"><pre>#!/bin/bash<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre># This is an extension that is supported in<span></span></pre></td></tr><tr><td scope="row"><pre># bash, zsh, and many other recent sh variants,<span></span></pre></td></tr><tr><td scope="row"><pre># but is not always valid.<span></span></pre></td></tr><tr><td scope="row"><pre>#<span></span></pre></td></tr><tr><td scope="row"><pre># Usage: for5.sh &lt;number><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>for (( i = 1 ; i &lt;= $1 ; i++ )) ; do<span></span></pre></td></tr><tr><td scope="row"><pre>        echo "I is $i"<span></span></pre></td></tr><tr><td scope="row"><pre>done<span></span></pre></td></tr></table></div><p>For maximum portability, however, you should use a <code>while</code> loop, as shown below:</p><div class="codesample"><table><tr><td scope="row"><pre>i=1<span></span></pre></td></tr><tr><td scope="row"><pre>while [ $i -le $1 ] ; do<span></span></pre></td></tr><tr><td scope="row"><pre>    echo "I is $i"<span></span></pre></td></tr><tr><td scope="row"><pre>    i=`expr $i '+' 1`<span></span></pre></td></tr><tr><td scope="row"><pre>done<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40004268-CH237-SW26" title="The case statement"></a><h3>The case statement</h3><p>The final control statement in this chapter is the <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_535"></a><code>case</code> statement. The <code>case</code> statement in shell scripts is similar to the C <code>switch</code> statement. It allows you to execute multiple commands depending on the value of a variable. The syntax is as follows:</p><div class="codesample"><table><tr><td scope="row"><pre>case expression in<span></span></pre></td></tr><tr><td scope="row"><pre>    [(] value | value | value | ... ) command; command; ... ;;<span></span></pre></td></tr><tr><td scope="row"><pre>    [(] value | value | value | ... ) command; command; ... ;;<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_536"></a>esac<span></span></pre></td></tr></table></div><p>You should notice three things about this syntax. First, each case is terminated by a double semicolon. Second, the opening parenthesis is optional and is frequently dropped by script authors. Third, a single set of commands can be applied to any number of values separated by the pipe (vertical bar) character <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_537"></a>(<code>|</code>).</p><p>For example, the following code sample prints the English names for the numbers 0–9, then prints them again.</p><div class="codesample"><table><tr><td scope="row"><pre>#!/bin/sh<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>LOOP=0<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>while [ $LOOP -lt 20 ] ; do<span></span></pre></td></tr><tr><td scope="row"><pre>        # The next line is explained in the<span></span></pre></td></tr><tr><td scope="row"><pre>        # math chapter.<span></span></pre></td></tr><tr><td scope="row"><pre>        VAL=`expr $LOOP % 10`<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        case "$VAL" in<span></span></pre></td></tr><tr><td scope="row"><pre>                ( 0 ) echo "ZERO" ;;<span></span></pre></td></tr><tr><td scope="row"><pre>                ( 1 ) echo "ONE" ;;<span></span></pre></td></tr><tr><td scope="row"><pre>                ( 2 ) echo "TWO" ;;<span></span></pre></td></tr><tr><td scope="row"><pre>                ( 3 ) echo "THREE" ;;<span></span></pre></td></tr><tr><td scope="row"><pre>                ( 4 ) echo "FOUR" ;;<span></span></pre></td></tr><tr><td scope="row"><pre>                ( 5 ) echo "FIVE" ;;<span></span></pre></td></tr><tr><td scope="row"><pre>                ( 6 ) echo "SIX" ;;<span></span></pre></td></tr><tr><td scope="row"><pre>                ( 7 ) echo "SEVEN" ;;<span></span></pre></td></tr><tr><td scope="row"><pre>                ( 8 ) echo "EIGHT" ;;<span></span></pre></td></tr><tr><td scope="row"><pre>                ( 9 ) echo "NINE" ;;<span></span></pre></td></tr><tr><td scope="row"><pre>                ( * ) echo "This shouldn't happen." ;;<span></span></pre></td></tr><tr><td scope="row"><pre>        esac<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        # The next line is explained in the<span></span></pre></td></tr><tr><td scope="row"><pre>        # math chapter.<span></span></pre></td></tr><tr><td scope="row"><pre>        LOOP=$((LOOP + 1))<span></span></pre></td></tr><tr><td scope="row"><pre>done<span></span></pre></td></tr></table></div><p>You should notice the <code>( * )</code> case at the end. It is equivalent to the <code>default</code> case in C. While that case will never be reached in this example, if you change the value of the modulo from 10 to any larger value, you will see that this case executes when no previous case matches the value of the expression.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH237-SW49" title="C Shell Note"></a><p><strong>C Shell Note:</strong>&nbsp;The C shell <code><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_538"></a>switch</code> statement is functionally equivalent, but behaves somewhat differently.</p>Like in C, each <code>case</code> statement falls through into the following case statement until the shell encounters a <code>breaksw</code> statement, which causes execution to immediately jump out of the entire <code>switch</code> statement.</p><div class="codesample"><table><tr><td scope="row"><pre>#!/bin/csh<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>set LOOP = 0<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>while ( ${LOOP} &lt;= 20 )<span></span></pre></td></tr><tr><td scope="row"><pre>    set VAL = `expr ${LOOP} % 10`<span></span></pre></td></tr><tr><td scope="row"><pre>    switch (${VAL})<span></span></pre></td></tr><tr><td scope="row"><pre>        case 0:<span></span></pre></td></tr><tr><td scope="row"><pre>            echo "ZERO" ; breaksw<span></span></pre></td></tr><tr><td scope="row"><pre>        case 1:<span></span></pre></td></tr><tr><td scope="row"><pre>            echo "ONE" ; breaksw<span></span></pre></td></tr><tr><td scope="row"><pre>        case 2:<span></span></pre></td></tr><tr><td scope="row"><pre>            echo "TWO" ; breaksw<span></span></pre></td></tr><tr><td scope="row"><pre>        case 3:<span></span></pre></td></tr><tr><td scope="row"><pre>            echo "THREE" ; breaksw<span></span></pre></td></tr><tr><td scope="row"><pre>        case 4:<span></span></pre></td></tr><tr><td scope="row"><pre>            echo "FOUR" ; breaksw<span></span></pre></td></tr><tr><td scope="row"><pre>        case 5:<span></span></pre></td></tr><tr><td scope="row"><pre>            echo "FIVE" ; breaksw<span></span></pre></td></tr><tr><td scope="row"><pre>        case 6:<span></span></pre></td></tr><tr><td scope="row"><pre>            echo "SIX" ; breaksw<span></span></pre></td></tr><tr><td scope="row"><pre>        case 7:<span></span></pre></td></tr><tr><td scope="row"><pre>            echo "SEVEN" ; breaksw<span></span></pre></td></tr><tr><td scope="row"><pre>        case 8:<span></span></pre></td></tr><tr><td scope="row"><pre>            echo "EIGHT" ; breaksw<span></span></pre></td></tr><tr><td scope="row"><pre>        case 9:<span></span></pre></td></tr><tr><td scope="row"><pre>            echo "NINE" ; breaksw<span></span></pre></td></tr><tr><td scope="row"><pre>        default:<span></span></pre></td></tr><tr><td scope="row"><pre>            echo "This shouldn't happen."<span></span></pre></td></tr><tr><td scope="row"><pre>    endsw<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    set LOOP = `expr ${LOOP} + 1`<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>end<span></span></pre></td></tr></table></div></div><a name="//apple_ref/doc/uid/TP40004268-CH237-SW30" title="The expr Command"></a><h3>The expr Command</h3><p>No discussion of tests and comparisons would be complete without mentioning the <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_539"></a><code><a href="../../../../Darwin/Reference/ManPages/man1/expr.1.html#//apple_ref/doc/man/1/expr" target="_top">expr</a></code> command. This command can perform various string comparisons and basic integer math. The math portions of the <code>expr</code> command are described in <span class="content_text"><a href="../PaintbyNumbers/PaintbyNumbers.html#//apple_ref/doc/uid/TP40004268-TP40003512-SW2">“The expr Command Also Does Math.”</a></span></p><p>The <code>expr</code> command is fairly straightforward. Each expression or token passed to the command must be surrounded by quotes if it may contain multiple words or characters that the shell considers special. For example, to compare two strings alphabetically, you could use the following command:</p><div class="codesample"><table><tr><td scope="row"><pre>expr "This is a test" '&lt;' "I am a person"<span></span></pre></td></tr></table></div><p>The following version fails miserably because the shell interprets the less-than sign as a redirect and tries to read from a file called “I am a person”:</p><div class="codesample"><table><tr><td scope="row"><pre>expr "This is a test" &lt; "I am a person"<span></span></pre></td></tr></table></div><p>The details of quoting are described further in <span class="content_text"><a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW14">“Variables, Expansion, and Quoting.”</a></span></p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH237-SW60" title="Note"></a><p><strong>Note:</strong>&nbsp;Be careful when using the <code>expr</code> command. Any expression that generates a numerical value (including the string comparison in the previous example) effectively generates two seemingly contradictory results. It returns one value through its exit status and a different numerical value by way of its standard output.</p>The exit status is zero if a logical expression evaluates to true and one if the expression evaluates to false. The output printed to standard output is one if a logical expression evaluates to true and zero if the expression evaluates to false. Notice that these values are reversed. Be sure to use the exit status when comparing the result to the output of commands like <code><a href="../../../../Darwin/Reference/ManPages/man1/true.1.html#//apple_ref/doc/man/1/true" target="_top">true</a></code>, not the value printed to standard output.</p>This disparity is only really confusing for computations that return a logical true or false value, of course. The behavior can be explained fairly simply: the <code>expr</code> command returns a “success” exit status, zero, if the command prints a value other than zero or an empty string. If it prints a zero or an empty string, its exit status is one (failure).</p></div><p>The <code>expr</code> command supports the usual complement of string comparisons (equality, inequality, less-than, greater-than, less-than-or-equal, and greater-than-or-equal).</p><p>In addition to these comparisons, the <code>expr</code> command can do several other tests: a logical “or” operator, a logical “and” operator, and a (fairly limited) basic regular expression matching operator.</p><p>While normally used for logic purposes, you can use the “or” operator to substitute a default string using the or operator like this:</p><div class="codesample"><table><tr><td scope="row"><pre>#!/bin/sh<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>NAME=`expr "$1" '|' "Untitled"`<span></span></pre></td></tr><tr><td scope="row"><pre>echo "The chosen name was $NAME"<span></span></pre></td></tr></table></div><p><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_540"></a>The “or” operator (|) prints the value of the first expression (<code>"$1"</code> in this example) if it is nonempty and contains something other than the number zero (0). Otherwise, if the second string is nonempty and contains something other than the number zero, it prints the second expression (<code>"Untitled"</code> in this example). If both strings are empty or zero, it prints the number zero. The exit status of the command is zero on success, one if both strings are empty or zero.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH237-SW50" title="Note"></a><p><strong>Note:</strong>&nbsp;Because the <code>expr</code> command does not distinguish between the number zero (0) and an empty string, you should not use <code>expr</code> to test for an empty string if there is a possibility that the string might be <code>"0"</code>.</p></div><p><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_541"></a>The “and” operator (<code>&amp;</code>) is similar, returning either the first string (if both strings are nonempty) or zero (if either string is empty).</p><p><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_542"></a>Finally, the <code>expr</code> command can work with basic regular expressions (<em>not</em> extended regular expressions) to a limited degree.</p><p>To count the number of characters from the beginning of the string (all expressions are implicitly anchored to the start of the string) up to and including the last letter ‘i’, you could write an expression like this:</p><div class="codesample"><table><tr><td scope="row"><pre>STRING="This is a test"<span></span></pre></td></tr><tr><td scope="row"><pre>expr "$STRING" : ".*i"<span></span></pre></td></tr></table></div><p>The string to the right side of the colon is a relatively simple regular expression. The period character matches a single character. The asterisk modifies the behavior of the period so that it matches zero or more characters. (Read <span class="content_text"><a href="../RegularExpressionsUnfettered/RegularExpressionsUnfettered.html#//apple_ref/doc/uid/TP40004268-CH238-SW7">“Regular Expressions Unfettered”</a></span> for further explanation.) If the string does not match the expression, the <code>expr</code> command returns zero (0), which corresponds with the number of characters matched.</p><p>The most common use for this syntax is obtaining the length of a string, as shown in this snippet:</p><div class="codesample"><table><tr><td scope="row"><pre>STRING="This is a test"<span></span></pre></td></tr><tr><td scope="row"><pre>expr "$STRING" : ".*"<span></span></pre></td></tr></table></div><p>This same syntax can be used to return the text captured by the first set of parentheses in a basic regular expression. For example, to print the four characters immediately prior to the last occurrence of “est”, you could write an expression like this one:</p><div class="codesample"><table><tr><td scope="row"><pre>STRING="This is a test" expr "$STRING" : '.*\(....\)est'<span></span></pre></td></tr></table></div><p>Because this expression contains capturing parentheses, if the first string does not match the expression, the <code>expr</code> command prints an empty string.</p><p>For more information about writing basic regular expressions, read <span class="content_text"><a href="../RegularExpressionsUnfettered/RegularExpressionsUnfettered.html#//apple_ref/doc/uid/TP40004268-CH238-SW7">“Regular Expressions Unfettered.”</a></span></p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH237-SW51" title="C Shell Note"></a><p><strong>C Shell Note:</strong>&nbsp;This behaves the same in C shell as it does in the Bourne shell (apart from the usual syntax differences). For example:</p><div class="codesample"><table><tr><td scope="row"><pre>#!/bin/csh<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>set NAME = `expr "${1}" '|' "Untitled"`<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>echo "The chosen name was ${NAME}"<a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_543"></a><span></span></pre></td></tr></table></div></div><a name="//apple_ref/doc/uid/TP40004268-CH237-SW14" title="Variables, Expansion, and Quoting"></a><h2>Variables, Expansion, and Quoting</h2><p><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_544"></a><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_545"></a>In both the Bourne shell and the C shell, lines of code are processed in multiple passes. The first pass is a parsing pass in which the basic structure of the line of code is extracted. In this pass, quotation marks serve as delimiters between individual pieces of information. For example, you can print a letter immediately after the contents of a variable without a space by closing (and reopening if necessary) the enclosing double quotes immediately after the variable name.</p><p>The second pass is an expansion pass. In this pass, any variable is expanded and any inline execution is performed. If a variable contains special characters, the resulting text is further expanded unless that variable is surrounded by double quotes. This may cause unexpected behavior if, for example, a variable contains a wildcard character.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH237-SW52" title="Note"></a><p><strong>Note:</strong>&nbsp;While the expansion of a variable or command inline will not cause a syntax error by itself, it can change the behavior of the <code><a href="../../../../Darwin/Reference/ManPages/man1/eval.1.html#//apple_ref/doc/man/1/eval" target="_top">eval</a></code> builtin. See <span class="content_text"><a href="../AdvancedTechniques/AdvancedTechniques.html#//apple_ref/doc/uid/TP40004268-TP40003521-SW1">“Data Structures, Arrays, and Indirection”</a></span> for more information.</p></div><p>Finally, the third pass is an execution pass. In this pass, the code is actually executed.</p><p>In some cases, you may need to change the way variable expansion takes place. You might want to use a nonstandard character to split a variable containing a list, change the way the shell handles special characters, or execute a command and substitute its output in the middle of another command. These techniques are described in the sections that follow.</p><a name="//apple_ref/doc/uid/TP40004268-CH237-SW9" title="Variable Expansion and Field Separators"></a><h3>Variable Expansion and Field Separators</h3><p><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_546"></a>In Bourne shell scripts, two operations are affected by the value of the <code>IFS</code> (internal field separators) shell variable: the <code>read</code> statement and variable expansion. The effect on the <code>read</code> statement is described separately in <span class="content_text"><a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW20">“Shell Script Input and Output Using printf and read.”</a></span></p><p>Whenever the shell expands a variable, the value of <code>IFS</code> comes into play. For example, the following script will print “a” and “b” on separate lines, then “c d” on a third line:</p><div class="codesample"><table><tr><td scope="row"><pre>#!/bin/sh<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>IFS=":"<span></span></pre></td></tr><tr><td scope="row"><pre>LIST="a:b:c d"<span></span></pre></td></tr><tr><td scope="row"><pre>for i in $LIST ; do<span></span></pre></td></tr><tr><td scope="row"><pre>        echo $i<span></span></pre></td></tr><tr><td scope="row"><pre>done<span></span></pre></td></tr></table></div><p>This occurs <em>only</em> because the value on the right side of the <code>for</code> statement contains a variable (<code>LIST</code>) that is expanded by the shell. When the shell expands the variable, it replaces the colon with a space and quotes any spaces in the original string. In effect, by the time the <code>for</code> statement sees the values, the right side of the for statement contains <code>a b c\ d</code>, just as in the example shown in <span class="content_text"><a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW7">“The for Statement.”</a></span></p><p>If you insert the exact contents of <code>LIST</code> on the right side of the variable, this script will instead print “a:b:c” on one line and “d” on the other. This demonstrates why it is very important to choose record separators correctly.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH237-SW53" title="Cross-Platform Compatibility Note"></a><p><strong>Cross-Platform Compatibility Note:</strong>&nbsp;<a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_547"></a>This treatment of record separators is consistent in all modern Bourne shell variants (ASH, BASH, DASH, KSH, ZSH, newer versions of the <code>sh</code> interpreter, and so on). Some earlier Bourne shell variants use <code>IFS</code> when the shell splits a list even if no expansion is involved.</p>To avoid unexpected behavior, you should avoid setting nonstandard values for <code>IFS</code> except when you are expanding a shell variable that depends on this.</p>As an exception, it is safe to modify <code>IFS</code> during a <code>read</code> statement. Be sure to save the original value in another variable and restore it afterwards, however, to avoid unexpected behavior elsewhere in the script.</p></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH237-SW54" title="C Shell Note"></a><p><strong>C Shell Note:</strong>&nbsp;<a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_548"></a>Most versions of csh do not allow you to alter the field separator. If you need more precise control over field separators, you can use the <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_549"></a><code><a href="../../../../Darwin/Reference/ManPages/man1/cut.1.html#//apple_ref/doc/man/1/cut" target="_top">cut</a></code> command in a <code>while</code> loop, incrementing a counter.</p><div class="codesample"><table><tr><td scope="row"><pre>#!/bin/csh<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>set IFS = ":"<span></span></pre></td></tr><tr><td scope="row"><pre>set LIST = "a:b:c d"<span></span></pre></td></tr><tr><td scope="row"><pre>set POS = 1<span></span></pre></td></tr><tr><td scope="row"><pre>set i = `echo "${LIST}" | cut -f ${POS} -d ':'`<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre># Repeat until you get an empty field.  This only works if<span></span></pre></td></tr><tr><td scope="row"><pre># you know you should never encounter an empty field.  Otherwise,<span></span></pre></td></tr><tr><td scope="row"><pre># you must know the number of fields.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>while ( "x${i}" != "x" )<span></span></pre></td></tr><tr><td scope="row"><pre>    echo $i<span></span></pre></td></tr><tr><td scope="row"><pre>    set POS = `expr ${POS} '+' 1`<span></span></pre></td></tr><tr><td scope="row"><pre>    set i = `echo "${LIST}" | cut -f ${POS} -d ':'`<span></span></pre></td></tr><tr><td scope="row"><pre>end<span></span></pre></td></tr></table></div>If you cannot guarantee that there are no empty fields in the list, you must first count the fields and use a counter in your loop test. To learn how to count the fields, see <span class="content_text"><a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW30">“The expr Command.”</a></span> To learn how to use counters, read <span class="content_text"><a href="../PaintbyNumbers/PaintbyNumbers.html#//apple_ref/doc/uid/TP40004268-TP40003512-SW2">“The expr Command Also Does Math,”</a></span> substituting the C shell syntax as described in <span class="content_text"><a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW8">“Shell Variables and Printing”</a></span> and <span class="content_text"><a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW10">“Inline Execution”</a></span> as appropriate.<a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_550"></a></p></div><a name="//apple_ref/doc/uid/TP40004268-CH237-SW15" title="Special Characters Explained"></a><h3>Special Characters Explained</h3><p><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_551"></a><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_552"></a>There are several special characters in shell scripts: a dollar sign (<code><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_553"></a><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_554"></a>$</code>), an asterisk (<code><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_555"></a><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_556"></a>*</code>), a question mark (<code><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_557"></a>?</code>), curly braces (<code><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_558"></a>{</code> and <code>}</code>), square brackets (<code><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_559"></a>[</code> and <code>]</code>), parentheses (<code><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_560"></a>(</code> and <code>)</code>), single and double quote marks (<code><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_561"></a><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_562"></a><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_563"></a><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_564"></a>'</code> and <code>"</code>), the backtick mark (<a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_565"></a><code>`</code>, sometimes called the left single quote mark), and the backslash (<code><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_566"></a>\</code>). These characters are treated differently by the shell.</p><p>Most of these special characters are used in filename expansion, also known as <em>globbing</em>. Globbing characters obey different expansion rules than other characters.</p><p>The characters behave as follows:</p><ul class="spaceabove"><li class="li"><p><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_567"></a><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_568"></a>Dollar sign ($)—the first character in variable expansion, shell builtin math, and inline execution. Variable names beginning with a dollar sign are expanded regardless of whether they appear inside double quotes. If used outside of double quotes, any globbing characters within the contents of the variable are also expanded. Variable names within the contents are not expanded, however.</p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_569"></a><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_570"></a><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_571"></a>Asterisk (*)—a wildcard character that matches any number of characters in a filename. For example, <code>ls *.jpg</code> matches all files that end with the extension <code>.jpg</code>. The asterisk is used in globbing.</p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_572"></a>Question mark (?)—a wildcard character that matches a single character in a filename. For example, <code>ls a?t.jpg</code> matches both <code>ant.jpg</code> and <code>art.jpg</code>. The question mark is used in globbing.</p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_573"></a><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_574"></a>Curly braces—matches any of a series of options in a filename. For example, <code>ls *.{jpg,gif}</code> matches every file ending with either <code>.jpg</code> or <code>.gif</code>. Curly braces are used in globbing.</p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_575"></a><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_576"></a>Square brackets—matches any of a series of characters in a filename. For example, <code>ls a[rn]t.jpg</code> matches <code>art.jpg</code> and <code>ant.jpg</code>, but does not match <code>aft.jpg</code>. If the first character is a caret (<code>^</code>), it matches every character except for the characters listed.</p><p>The syntax of these <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_577"></a>character classes is similar to character classes in regular expressions, but there are a number of subtle differences. For more information, see the Open Group’s page on pattern matching notation at <span class="content_text"><a href="http://www.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_13" target="_blank">http://www.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_13</a></span>.</p><p>Square brackets are used in globbing.</p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_578"></a><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_579"></a>Parentheses—these characters serve multiple purposes, depending on context:</p><ul class="nested"><li class="nested li"><p>Used to mark the beginning of a new subroutine. This is described in <span class="content_text"><a href="../SubroutinesandScoping/SubroutinesandScoping.html#//apple_ref/doc/uid/TP40004268-TP40003513-SW1">“Result Codes, Subroutines, Scoping, and Sourcing.”</a></span></p></li><li class="nested li"><p>Used to group a chain of operations. This is described in <span class="content_text"><a href="../SubroutinesandScoping/SubroutinesandScoping.html#//apple_ref/doc/uid/TP40004268-TP40003513-SW8">“Chaining Execution.”</a></span></p></li><li class="nested li"><p>Used for math in some Bourne shell variants. This is described in <span class="content_text"><a href="../PaintbyNumbers/PaintbyNumbers.html#//apple_ref/doc/uid/TP40004268-TP40003512-SW5">“The Easy Way: Parentheses.”</a></span></p></li><li class="nested li"><p>Used in <code>for</code> loop iterators supported by some Bourne shell variants. This is described in <span class="content_text"><a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW31">“Extended for Loops.”</a></span></p></li></ul></li><li class="li"><p><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_580"></a><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_581"></a><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_582"></a>Double-quote marks—disables argument splitting on word boundaries (spaces) and shell expansion of most special characters within the quote marks, with a few exceptions:</p><ul class="nested"><li class="nested li"><p>Variables <em>are</em> expanded within double quote marks. The contents of variables, however, are <em>not</em> expanded in any way even if they contain globbing characters.</p></li><li class="nested li"><p>Inline execution is also expanded within double quote marks.</p></li><li class="nested li"><p>The backslash character still functions within double quote marks in the Bourne shell and variants thereof, but not in C shell variants.</p></li></ul><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH237-SW55" title="Note"></a><p><strong>Note:</strong>&nbsp;Although globbing-related characters are not generally expanded within double quotes, expansion of globbing characters within strings enclosed in double quotes may still occur if the double quotes are on the right side of a variable assignment and the variable is later used without double quotes. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>FOO="*.c"   # *.c does not get expanded here<span></span></pre></td></tr><tr><td scope="row"><pre>ls $FOO     # *.c DOES get expanded here<span></span></pre></td></tr></table></div></div></li><li class="li"><p><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_583"></a><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_584"></a>Single-quote marks—disables argument splitting on word boundaries (spaces) and disables <em>all</em> shell expansion (including variables). The backslash is treated just like any other literal character when it appears within single quotes. For example, <code>'\"'</code> is a string that contains a backslash and a double quote mark.</p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_585"></a>Backtick marks—roughly equivalent to <code>$()</code>, these are used to delimit code for inline execution. This technique is described in <span class="content_text"><a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW10">“Inline Execution.”</a></span></p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_586"></a>Backslash—causes the next character to be treated as a literal character, overriding the special behaviors explained in this section. This technique is described further in <span class="content_text"><a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW13">“Quoting Special Characters.”</a></span></p></li></ul><p>If your script accepts user input, these characters can produce unexpected results if you do not quote them properly. Consider the following example:</p><div class="codesample"><table><tr><td scope="row"><pre>#!/bin/sh<span></span></pre></td></tr><tr><td scope="row"><pre>echo "Filename?"<span></span></pre></td></tr><tr><td scope="row"><pre>read NAME<span></span></pre></td></tr><tr><td scope="row"><pre>ls $NAME<span></span></pre></td></tr><tr><td scope="row"><pre>ls "$NAME"<span></span></pre></td></tr></table></div><p>If a user types <code>*.jpg</code> at the prompt, the first command lists all files ending in <code>.jpg</code> because the variable is expanded first, and then the expression within it is expanded. The second command lists a single file (or prints an error if you don’t have a file named <code>*.jpg</code>).</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH237-SW56" title="C Shell Note"></a><p><strong>C Shell Note:</strong>&nbsp;<a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_587"></a>In Bourne shell variants, globbing occurs anywhere a variable is expanded or a globbing character appears as literal text outside of quotation marks. In the C shell, it is slightly more limited.</p>Within expressions such as the right half of an <code>if</code> statement, the C shell provides two additional operators: the <code>=~</code> and <code>!~</code> operators. These are similar to string comparison operators, except that the right side is treated using filename globbing rules (for example, foo* matches files named foo, foot, fool, and so on). Although this operator visually resembles the regular expression operator in Perl, this C shell operator does <em>not</em> perform a regular expression comparison.<a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_588"></a><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_589"></a><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_590"></a></p></div><a name="//apple_ref/doc/uid/TP40004268-CH237-SW13" title="Quoting Special Characters"></a><h3>Quoting Special Characters</h3><p><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_591"></a><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_592"></a><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_593"></a>Sometimes, when writing shell scripts, you may need to explicitly include quotation marks, dollar signs, or other special characters in your output. The way that you do this depends on the context.</p><p>If the string you wish to quote is not within quote marks, it probably should be. Otherwise, you have to deal with <em>all</em> of the shell special characters (described in <span class="content_text"><a href="shell_scripts.html#//apple_ref/doc/uid/TP40004268-CH237-SW15">“Special Characters Explained”</a></span>) plus any new special characters that might be added in the future. Protecting against special characters is particularly important if your script takes arbitrary user input and passes it as an argument to a command.</p><p>However, if your script is not handling user input, you can quote a single character by simply preceding it with a backslash (<code>\</code>). This tells the shell to treat it as a literal character instead of interpreting it normally. For example, the following code sample prints the word “Hello” enclosed in double-quotation marks.</p><div class="codesample"><table><tr><td scope="row"><pre>echo \"Hello\"<span></span></pre></td></tr></table></div><p>If the character you wish to quote is within double quotes, the same rules apply. The only difference is that with the exception of dollar signs and the double-quote marks themselves, you don’t need to quote special characters in this context. For example, to print the name of a variable followed by its value, you could write a statement like the following, which prints “The value of $VAR is 3” (with no quotes):</p><div class="codesample"><table><tr><td scope="row"><pre>VAR=3<span></span></pre></td></tr><tr><td scope="row"><pre>echo "The value of \$VAR is $VAR"<span></span></pre></td></tr></table></div><p>Similarly, you can quote a backslash with another backslash if you need to print it. For example, the following statement prints “This \ is a backslash.“ (again, without quotes):</p><div class="codesample"><table><tr><td scope="row"><pre>echo "This \\ is a backslash."<span></span></pre></td></tr></table></div><p>If the character you wish to quote is within single quotes, shell expansion of special characters is disabled entirely. Thus, the only characters that are special are the single-quote marks themselves, because they terminate the single-quote context.</p><p>Because special character handling is disabled, a backslash does <em>not</em> quote anything between single-quote marks. Instead, a backslash is interpreted as literal text. Thus, to include a literal single quote within a double-quote context, you must terminate the single-quote context, then include the single quote (either by quoting it with a backslash or by surrounding it with double quotes), then start a new single-quote context. </p><p>For example, the following lines of code both print a popular phrase from an American children’s television show:</p><div class="codesample"><table><tr><td scope="row"><pre>echo 'It'\''s a beautiful day in the neighborhood.'<span></span></pre></td></tr><tr><td scope="row"><pre>echo 'Won'"'"'t you be my neighbor?'<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH237-SW57" title="C Shell Note"></a><p><strong>C Shell Note:</strong>&nbsp;<a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_594"></a><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_595"></a>The C shell does not support using a backslash to quote a character within a double-quoted string. Thus, in the C shell, you print a backslash like this:</p><div class="codesample"><table><tr><td scope="row"><pre>echo "This \ is a backslash."<span></span></pre></td></tr></table></div>To print a literal dollar sign for a variable name, you must either put the dollar sign in single quotes or quote it with a backslash <em>outside</em> of any quote marks. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>echo "This is "'$'"FOO"<span></span></pre></td></tr><tr><td scope="row"><pre>echo "This is "\$"FOO"<span></span></pre></td></tr></table></div>Both statements print the words “This is $FOO”.</p>Similarly, to print a quotation mark, you must either surround it with the opposite type of quotation mark or quote it outside of quotation marks. For example, the following statement will not work:</p><div class="codesample"><table><tr><td scope="row"><pre>echo "This is \"wrong\" and will cause csh to exit with an error"<span></span></pre></td></tr></table></div>This fails because the first backslash is treated as part of the string, which is terminated with the quotation mark immediately after it. Because the third quotation mark is not within a string, however, the backslash quotes it, turning it into a literal character. Thus, it does not start a new string. The fourth quotation mark (at the end of the line) then begins a string. As a result, there is no matching double quote mark to end the string and CSH exits with an unmatched quotation mark error.</p>Instead, you can use either of the following syntaxes:</p><div class="codesample"><table><tr><td scope="row"><pre>echo "You probably meant "\""this"\"" or "'"'" this"'"'"."<span></span></pre></td></tr></table></div>In the first part, the string is terminated with a double quote mark followed by a quoted double quote mark (displayed literally), followed by opening a new string with a double quote mark. In the second part, the string is terminated with a double quote mark, followed by a double quote mark within single quotes, followed by opening a new string with a double quote mark.</p>The construction of code that takes advantage of this parsing difference to execute different code depending on whether it is executing in a Bourne shell or a C shell is left as an exercise for the reader.<a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_596"></a></p></div><a name="//apple_ref/doc/uid/TP40004268-CH237-SW10" title="Inline Execution"></a><h3>Inline Execution</h3><p><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_597"></a>The Bourne shell provides two operators for executing a command and placing its output in the middle of another command or string. These operators are the <code><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_598"></a>$()</code> operator and the <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_599"></a>backtick (<code><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_600"></a>`</code>) operator (not to be confused with a normal single quote).</p><p>These operators are often used with commands that generate a list of filenames to pass them as the argument list to another command. For example, the <a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_601"></a><code><a href="../../../../Darwin/Reference/ManPages/man1/grep.1.html#//apple_ref/doc/man/1/grep" target="_top">grep</a></code> command, when passed the <code>-l</code> flag, returns a list of files that match. This technique is often combined with the <code>-r</code> flag, which makes grep search recursively for files within any directories that it encounters in its file list. Thus, if you want to edit any files whose contents contain the word "<code>myname</code>" with <code><a href="../../../../Darwin/Reference/ManPages/man1/vi.1.html#//apple_ref/doc/man/1/vi" target="_top">vi</a></code>, for example, you could do it like this:</p><div class="codesample"><table><tr><td scope="row"><pre>vi $(grep -rl myname directory_of_files)<span></span></pre></td></tr></table></div><p>You can, however, use this to execute any command. There is one small caveat you should be aware of, however. The backtick operator cannot be nested. For example, the following command produces an error:</p><div class="codesample"><table><tr><td scope="row"><pre>FOO=1; BAR=3<span></span></pre></td></tr><tr><td scope="row"><pre>echo "Try this command: `echo $FOO + "`expr $BAR + 1`"`"<span></span></pre></td></tr></table></div><p>This fails because the echo command ends at the second backtick. Thus, the command executed is <code>echo $FOO + "</code>. If you need to nest inline execution, you can use the <code>$()</code> operator for the nested command. For example, the previous example can be written correctly as follows:</p><div class="codesample"><table><tr><td scope="row"><pre>FOO=1; BAR=3<span></span></pre></td></tr><tr><td scope="row"><pre>echo "Try this command: `echo $FOO + "$(expr $BAR + 1)"`"<span></span></pre></td></tr></table></div><p>You should notice that double-quotation marks can be safely nested within a command enclosed by either backticks or the <code>$()</code> operator.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH237-SW58" title="Note"></a><p><strong>Note:</strong>&nbsp;<a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_602"></a>Evaluation of inline commands, much like expansion of variables, occurs <em>after</em> the statement itself is fully parsed. Thus, it is safe to use either the backtick (<code>`</code>) or <code>$()</code> operator even if the command may produce double-quote marks in its output. You do not need to quote the resulting content in any way.</p></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40004268-CH237-SW59" title="C Shell Note"></a><p><strong>C Shell Note:</strong>&nbsp;The C shell only partially supports this.</p>The C shell does not support the <code>$()</code> syntax.</p><a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_603"></a>The C shell support for the backtick syntax is somewhat limited in that newline characters in the result are always stripped and replaced with spaces. If you need to preserve newlines, you should store the results in a temporary file instead of in a shell variable, then operate on the resulting file.<a name="//apple_ref/doc/uid/TP40004268-CH237-DontLinkElementID_604"></a></p></div>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Introduction/Introduction.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../SubroutinesandScoping/SubroutinesandScoping.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2003, 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-04-08<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/OpenSource/Conceptual/ShellScripting/shell_scripts/shell_scripts.html%3Fid%3DTP40004268-5.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/OpenSource/Conceptual/ShellScripting/shell_scripts/shell_scripts.html%3Fid%3DTP40004268-5.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/OpenSource/Conceptual/ShellScripting/shell_scripts/shell_scripts.html%3Fid%3DTP40004268-5.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>