<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>GlyphaIVOld - /G4Utilities.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/Games/index.html">Games</a> &gt; <a href="../../samplecode/Games/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">GlyphaIVOld</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Not Recommended Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>The information in this document is <strong>Not Recommended</strong> and should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Games/idxGraphicsImaging-date.html" target="_blank">Games > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">GlyphaIVOld</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/G4Utilities.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/G4Enemy.c</option>
<option value="listing2.html">/G4Externs.h</option>
<option value="listing3.html">/G4Graphics.c</option>
<option value="listing4.html">/G4Interface.c</option>
<option value="listing5.html">/G4Lava.c</option>
<option value="listing6.html">/G4Main.c</option>
<option value="listing7.html">/G4Play.c</option>
<option value="listing8.html">/G4Prefs.c</option>
<option value="listing9.html">/G4SetUpTakeDown.c</option>
<option value="listing10.html">/G4Sound.c</option>
<option value="listing11.html">/G4Utilities.c</option></select>
				</p>
				</form>
				<p><strong><a href="GlyphaIVOld.zip">Download Sample</a></strong> (&#147;GlyphaIVOld.zip&#148;, 106.6K)<BR>
<strong><a href="GlyphaIVOld.dmg">Download Sample</a></strong> (&#147;GlyphaIVOld.dmg&#148;, 175.8K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    G4Utilities.c  Contains:  xxx put contents here xxx  Version:  xxx put version here xxx  Copyright:  &copy; 1998 by Apple Computer, Inc., all rights reserved.  File Ownership:    DRI:        xxx put dri here xxx    Other Contact:    xxx put other contact here xxx    Technology:      xxx put technology here xxx  Writers:    (sjb)  Steve Bollinger  Change History (most recent first):     &lt;2&gt;    7/1/98  sjb    Update to CWPro 2*///============================================================================//----------------------------------------------------------------------------//                  Utilities.c//----------------------------------------------------------------------------//============================================================================// These functions are sort of universal utility functions.  They aren't specific\xC9// to Glypha per se.  I use these (and others) in many, many games.  Many of them\xC9// as well are useful for any app you might write for the Mac.#include &quot;G4Externs.h&quot;#include &lt;Processes.h&gt;#include &lt;SegLoad.h&gt;#include &lt;Traps.h&gt;#include &lt;Resources.h&gt;#include &lt;TextUtils.h&gt;#include &lt;LowMem.h&gt;#define kActive            0#define kInactive          255GDHandle  thisGDevice;long    tickNext;//==============================================================  Functions//--------------------------------------------------------------  RandomInt// Takes a short (range) and returns a random number from zero to range - 1.short RandomInt (short range){  register long  rawResult;    rawResult = Random();  if (rawResult &lt; 0L)    rawResult *= -1L;  rawResult = (rawResult * (long)range) / 32768L;    return ((short)rawResult);}//--------------------------------------------------------------  RedAlert// Generic error function.  This is called when there is no hope of recovering// from the error.  A simple alert is brought up and the text passed in (theStr)// is displayed.  When the user clicks the Okay button, we quit to the Finder.void RedAlert (StringPtr theStr){  #define    kRedAlertID    128  short    whoCares;#if GENERATINGPOWERPC  // make sure we are at full color  DSpContext_FadeGammaIn( NULL, NULL );  if( gTheContext )  {    DSpContext_SetState( gTheContext, kDSpContextState_Inactive );    DSpContext_Release( gTheContext );    DSpShutdown();  }  #endif    ParamText(theStr, &quot;\p&quot;, &quot;\p&quot;, &quot;\p&quot;);    // Replace ^0 in alert with error mssg.  whoCares = Alert(kRedAlertID, 0L);      // Bring up alert.  ExitToShell();                // Quit to Finder.}//--------------------------------------------------------------  FindOurDevice// Get a handle to the MainDevice (monitor with the Menubar).void FindOurDevice (void){  thisGDevice = GetMainDevice();  if (thisGDevice == 0L)            // If a nil handle is returned...    RedAlert(&quot;\pCouldn't Find Our Device&quot;);  // call our universal error alert.}//--------------------------------------------------------------  LoadGraphic// Handy function that loads a PICT graphic, get's its bounds and draws it.// The port drawn to is assumed the current port.  No scaling is done.void LoadGraphic (short resID){  Rect    bounds;  PicHandle  thePicture;    thePicture = GetPicture(resID);        // Load graphic from resource fork.  if (thePicture == 0L)            // Check to see if nil (did it load?)    RedAlert(&quot;\pA Graphic Couldn't Be Loaded&quot;);    HLock((Handle)thePicture);          // If we made it this far, lock handle.  bounds = (*thePicture)-&gt;picFrame;      // Get a copy of the picture's bounds.  HUnlock((Handle)thePicture);        // We can unlock the picture now.  OffsetRect(&amp;bounds, -bounds.left, -bounds.top);  // Offset bounds rect to (0, 0).  DrawPicture(thePicture, &amp;bounds);      // Draw picture to current port.    ReleaseResource((Handle)thePicture);    // Dispose of picture from heap.}//--------------------------------------------------------------  CreateOffScreenPixMap// Handles the creation of an offscreen pixmap.  Depth is assumed to be that of the\xC9// current gDevice.  If the allocation fails (low memory, etc.) we quit to Finder.void CreateOffScreenPixMap (Rect *theRect, CGrafPtr *offScreen){  CTabHandle  thisColorTable;  GDHandle  oldDevice;  CGrafPtr  newCGrafPtr;  Ptr      theseBits;  long    sizeOfOff, offRowBytes;  OSErr    theErr;  short    thisDepth;    oldDevice = GetGDevice();  SetGDevice(thisGDevice);  newCGrafPtr = 0L;  newCGrafPtr = (CGrafPtr)NewPtrClear(sizeof(CGrafPort));  if (newCGrafPtr != 0L)  {    OpenCPort(newCGrafPtr);    thisDepth = (**(*newCGrafPtr).portPixMap).pixelSize;    offRowBytes = ((((long)thisDepth *         (long)(theRect-&gt;right - theRect-&gt;left)) + 15L) &gt;&gt; 4L) &lt;&lt; 1L;    sizeOfOff = (long)(theRect-&gt;bottom - theRect-&gt;top) * offRowBytes;    OffsetRect(theRect, -theRect-&gt;left, -theRect-&gt;top);    theseBits = NewPtr(sizeOfOff);    if (theseBits != 0L)    {      (**(*newCGrafPtr).portPixMap).baseAddr = theseBits;      (**(*newCGrafPtr).portPixMap).rowBytes = (short)offRowBytes + 0x8000;      (**(*newCGrafPtr).portPixMap).bounds = *theRect;      thisColorTable = (**(**thisGDevice).gdPMap).pmTable;      theErr = HandToHand((Handle *)&amp;thisColorTable);      (**(*newCGrafPtr).portPixMap).pmTable = thisColorTable;      ClipRect(theRect);      RectRgn(newCGrafPtr-&gt;visRgn, theRect);      ForeColor(blackColor);      BackColor(whiteColor);      EraseRect(theRect);    }    else    {      CloseCPort(newCGrafPtr);          DisposePtr((Ptr)newCGrafPtr);      newCGrafPtr = 0L;      RedAlert(&quot;\pCouldn't Allocate Enough Memory&quot;);    }  }  else    RedAlert(&quot;\pCouldn't Allocate Enough Memory&quot;);    *offScreen = newCGrafPtr;  SetGDevice(oldDevice);}//--------------------------------------------------------------  CreateOffScreenBitMap// Creates an offscreen bitmap.  Depth is of course 1 (b &amp; w).  If this function\xC9// fails to create the bitmap, we post an alert and quit to the Finder.void CreateOffScreenBitMap (Rect *theRect, GrafPtr *offScreen){  GrafPtr    theBWPort;  BitMap    theBitMap;    long    theRowBytes;    theBWPort = (GrafPtr)(NewPtr(sizeof(GrafPort)));  OpenPort(theBWPort);  theRowBytes = (long)((theRect-&gt;right - theRect-&gt;left + 15L) / 16L) * 2L;  theBitMap.rowBytes = (short)theRowBytes;  theBitMap.baseAddr = NewPtr((long)theBitMap.rowBytes *     (theRect-&gt;bottom - theRect-&gt;top));  if (theBitMap.baseAddr == 0L)    RedAlert(&quot;\pCouldn't Create Bitmaps&quot;);  theBitMap.bounds = *theRect;  if (MemError() != noErr)    RedAlert(&quot;\pCouldn't Create Bitmaps&quot;);  SetPortBits(&amp;theBitMap);  ClipRect(theRect);  RectRgn(theBWPort-&gt;visRgn, theRect);  EraseRect(theRect);  *offScreen = theBWPort;}//--------------------------------------------------------------  ZeroRectCorner// Offset rect to (0, 0).  This means the upper left corner of the rect is // moved to the origin - to (0, 0) - to the upperleft corner of the port.void ZeroRectCorner (Rect *theRect){  theRect-&gt;right -= theRect-&gt;left;  // Move right edge by amount of left.  theRect-&gt;bottom -= theRect-&gt;top;  // Move bottom edge by amount of top.  theRect-&gt;left = 0;          // Can now set left to zero.  theRect-&gt;top = 0;          // Can set top edge to zero as well.}//--------------------------------------------------------------  FlashShort// This is a simple debugging function that will display the short passed to it\xC9// in the upper left corner of the screen.  It's a handy way to watch the value\xC9// of a variable while the program is running.void FlashShort (short theValue){  GrafPtr      wasPort, tempPort;  Str255      tempStr;  Rect      tempRect;    GetPort(&amp;wasPort);            // Remember old grafPort.    tempPort = (GrafPtr)NewPtrClear(sizeof(GrafPort));  OpenPort(tempPort);            // Create a new empty port.    NumToString((long)theValue, tempStr);  // Convert value passed in to a string.  MoveTo(20, 40);              // Move the pen to the upperleft corner.  SetRect(&amp;tempRect, 18, 20, 122, 42);  // Create a rect up there as well.  EraseRect(&amp;tempRect);          // Erase the rect (to make a white hole).  DrawString(tempStr);          // And draw our text into that hole.    ClosePort(tempPort);          // Get rid of out temp port.  SetPort((GrafPtr)wasPort);        // And set port back to the old one.}//--------------------------------------------------------------  LogNextTick// Simple function to set a global (tickNext) to the current TickCount() plus\xC9// some offset.  We'll then wait for TickCount() to exceed that global.  We use\xC9// this function and the function below to regulate animation speeds (remember\xC9// your game may be run on a slow Mac or a fast one - we need a way to keep the\xC9// motion consistent.  I love when the comments are longer than the function.// (Not really.)void LogNextTick (long howMany){  tickNext = TickCount() + howMany;    // Get machine's TickCount() and add to it.}//--------------------------------------------------------------  WaitForNextTick// This is the companion function to the above function (LogNextTick()).// We do nothing but loop until TickCount() catches up with (or passes) our\xC9// global variable tickNext.void WaitForNextTick (void){  do  {  }  while (TickCount() &lt; tickNext);      // Loop until TickCount() catches up.}//--------------------------------------------------------------  TrapExists  // A nice &quot;test function&quot; that test for the existence of some ToolBox trap.// Returns TRUE if the function exists, FALSE if it doesn't.Boolean TrapExists (short trapNumber){  #define    kUnimpTrap    0x9F          // Test trap number against unimplemented trap number.  return ((NGetTrapAddress(trapNumber, ToolTrap) !=      NGetTrapAddress(kUnimpTrap, ToolTrap)));}//--------------------------------------------------------------  DoWeHaveGestalt  // This function specifically tests for the availablity of the Gestalt() function.// It returns TRUE if Gestalt() exists, FALSE if it doesn't.Boolean DoWeHaveGestalt (void){  #define    kGestaltTrap  0xAD          // Call above function (TrapExists()) with the Gestalt() trap number.  return (TrapExists(kGestaltTrap));}//--------------------------------------------------------------  CenterAlert// Handy function to center any alert within the main monitor.void CenterAlert (short alertID){  AlertTHndl  alertHandle;  Rect    theScreen, alertRect;  short    horiOff, vertOff;  Byte    wasState;    theScreen = qd.screenBits.bounds;    // Get main monitor's bounds.  theScreen.top += LMGetMBarHeight();    // Account for menubar height.                      // Get handle to alert resource.  alertHandle = (AlertTHndl)GetResource('ALRT', alertID);  if (alertHandle != 0L)          // Make sure we got it!  {                    // Remember its &quot;state&quot; (locked, etc.)    wasState = HGetState((Handle)alertHandle);    HLock((Handle)alertHandle);      // We'll lock it.                      // Get a copy of it's bounds and zero.    alertRect = (**alertHandle).boundsRect;    OffsetRect(&amp;alertRect, -alertRect.left, -alertRect.top);                      // Calculate offsets for centering bounds.    horiOff = ((theScreen.right - theScreen.left) - alertRect.right) / 2;      vertOff = ((theScreen.bottom - theScreen.top) - alertRect.bottom) / 3;                      // And offset the bounds copy.    OffsetRect(&amp;alertRect, horiOff, vertOff + LMGetMBarHeight());                      // Set alerts bounds to our centered rect.    (**alertHandle).boundsRect = alertRect;    HSetState((Handle)alertHandle, wasState);  }}//--------------------------------------------------------------  RectWide// Handy function for returning the absolute width of a rectangle.short RectWide (Rect *theRect){  return (theRect-&gt;right - theRect-&gt;left);}//--------------------------------------------------------------  RectTall// Handy function for returning the absolute height of a rectangle.short RectTall (Rect *theRect){  return (theRect-&gt;bottom - theRect-&gt;top);}//--------------------------------------------------------------  CenterRectInRect// Nice utility function that takes two rectangles and centers the first\xC9// rectangle within the second.void CenterRectInRect (Rect *rectA, Rect *rectB){  short  widthA, tallA;    widthA = RectWide(rectA);        // Get width of 1st rect.  tallA = RectTall(rectA);        // Get height of 1st rect.                      // Do the math (center horizontally).  rectA-&gt;left = rectB-&gt;left + (RectWide(rectB) - widthA) / 2;  rectA-&gt;right = rectA-&gt;left + widthA;                      // Do the math (center vertically).  rectA-&gt;top = rectB-&gt;top + (RectTall(rectB) - tallA) / 2;  rectA-&gt;bottom = rectA-&gt;top + tallA;}//--------------------------------------------------------------  PasStringCopy// This is a nice function that helps to free you from dealing with C strings.// It takes one Pascal-style string and copies it to a second.void PasStringCopy (StringPtr p1, StringPtr p2){  register short    stringLength;    stringLength = *p2++ = *p1++;  // Get 1st string's length.  while (--stringLength &gt;= 0)    // Loop through each character in 1st string.    *p2++ = *p1++;        // And copy to 2nd string.}//--------------------------------------------------------------  CenterDialog// Like CenterAlert(), this function centers a Dialog on the main monitor.void CenterDialog (short dialogID){  DialogTHndl  dlogHandle;  Rect    theScreen, dlogBounds;  short    hPos, vPos;  Byte    wasState;    theScreen = qd.screenBits.bounds;      // Get main monitor's bounds.  theScreen.top += LMGetMBarHeight();      // Add menuBar's height.                        // Load up dialog from resource.  dlogHandle = (DialogTHndl)GetResource('DLOG', dialogID);  if (dlogHandle != 0L)            // If it loaded....!  {                      // Remember handle state.    wasState = HGetState((Handle)dlogHandle);    HLock((Handle)dlogHandle);        // We're going to lock it.                        // Get a copy of the dialog's bounds.    dlogBounds = (**dlogHandle).boundsRect;    OffsetRect(&amp;dlogBounds, -dlogBounds.left, -dlogBounds.top);                        // Calculate how much to offset.    hPos = ((theScreen.right - theScreen.left) - dlogBounds.right) / 2;    vPos = ((theScreen.bottom - theScreen.top) - dlogBounds.bottom) / 3;                        // Offset ourt copy of the bounds.    OffsetRect(&amp;dlogBounds, hPos, vPos + LMGetMBarHeight());                        // Set dlg's bounds to centered rect.    (**dlogHandle).boundsRect = dlogBounds;    HSetState((Handle)dlogHandle, wasState);// Restore handle's state.  }}//--------------------------------------------------------------  DrawDefaultButton// A nice dialog function.  This draws the bold default outline around\xC9// item #1 in the dialog passed in.void DrawDefaultButton (DialogPtr theDialog){  Rect    itemRect;  Handle    itemHandle;  short    itemType;                    // Get at the item's bounds.  GetDialogItem(theDialog, 1, &amp;itemType, &amp;itemHandle, &amp;itemRect);  InsetRect(&amp;itemRect, -4, -4);    // Inset (outset?) bounds by -4 pixels.  PenSize(3, 3);            // Set the pen 3 pixels thick.  FrameRoundRect(&amp;itemRect, 16, 16);  // Draw the button outline.  PenNormal();            // And restore pen to 1 pixel thick.}//--------------------------------------------------------------  PasStringCopyNum// Another function to keep you from using C strings.  This one copies only a\xC9// certain number of characters from one Pascal-style string to a second.void PasStringCopyNum (StringPtr p1, StringPtr p2, short charsToCopy){  short    i;    if (charsToCopy &gt; *p1)    // If trying to copy more chars than there are\xC9    charsToCopy = *p1;    // Reduce the number of chars to copy to this size    *p2 = charsToCopy;      // Set 2nd string's length to charsToCopy.    *p2++;            // Point to first character in 2nd string.  *p1++;            // Point to first character in 1st string.    for (i = 0; i &lt; charsToCopy; i++)    *p2++ = *p1++;      // Copy the specified number of chars over.}//--------------------------------------------------------------  GetDialogString// Handy dialog function that returns a dialog item string.  This will be\xC9// especially handy for getting the high score name the player enters.void GetDialogString (DialogPtr theDialog, short item, StringPtr theString){  Rect    itemRect;  Handle    itemHandle;  short    itemType;                    // Get handle to dialog item.  GetDialogItem(theDialog, item, &amp;itemType, &amp;itemHandle, &amp;itemRect);  GetDialogItemText(itemHandle, theString);  // Extract text from item handle.}//--------------------------------------------------------------  SetDialogString// Like the above function, but this one sets a dialog items string to whatever\xC9// you pass in.  We'll use this to set a default high score name.void SetDialogString (DialogPtr theDialog, short item, StringPtr theString){  Rect    itemRect;  Handle    itemHandle;  short    itemType;                    // Get handle to dialog item.  GetDialogItem(theDialog, item, &amp;itemType, &amp;itemHandle, &amp;itemRect);  SetDialogItemText(itemHandle, theString);  // Set the items text to theString.}//--------------------------------------------------------------  SetDialogNumToStr// This one is like SetDialogString() above, but it takes a number (long)\xC9// instead of a string (the function will convert the long to a string for us).void SetDialogNumToStr (DialogPtr theDialog, short item, long theNumber){  Str255    theString;  Rect    itemRect;  Handle    itemHandle;  short    itemType;    NumToString(theNumber, theString);  // Convert long to a string.  GetDialogItem(theDialog, item, &amp;itemType, &amp;itemHandle, &amp;itemRect);  SetDialogItemText(itemHandle, theString);  // Set the item's text to this number/string.}//--------------------------------------------------------------  GetDialogNumFromStr// This one is like GetDialogString() above, but returns a long (number)\xC9// instead of a string (it does this by converting the string to a long).void GetDialogNumFromStr (DialogPtr theDialog, short item, long *theNumber){  Str255    theString;  Rect    itemRect;  Handle    itemHandle;  short    itemType;                    // Get a handle to the dialog item.  GetDialogItem(theDialog, item, &amp;itemType, &amp;itemHandle, &amp;itemRect);  GetDialogItemText(itemHandle, theString);  // Get the item's text.  StringToNum(theString, theNumber);  // Convert the text to a long.}//--------------------------------------------------------------  DisableControl// Another dialog utility for &quot;graying out&quot; buttons or other controls in a dialog.void DisableControl (DialogPtr theDialog, short whichItem){  Rect    iRect;  Handle    iHandle;  short    iType;                    // Get a handle to the dialog item.  GetDialogItem(theDialog, whichItem, &amp;iType, &amp;iHandle, &amp;iRect);                    // Set it's &quot;hilite state&quot; to &quot;grayed out&quot;.  HiliteControl((ControlHandle)iHandle, kInactive);}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/GlyphaIVOld/listing11.html%3Fid%3DDTS10000053-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/GlyphaIVOld/listing11.html%3Fid%3DDTS10000053-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/GlyphaIVOld/listing11.html%3Fid%3DDTS10000053-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>