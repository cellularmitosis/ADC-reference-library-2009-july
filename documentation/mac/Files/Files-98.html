<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Locking and Unlocking File Ranges (IM: F)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING98></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Files-97.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Files-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Files-390.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Files-99.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Files-2.html"><B>Files</B></A> / <BR><DD><A HREF="Files-72.html"><B>Chapter 2 - File Manager</B></A> / <A HREF="Files-89.html"><B>Using the File Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING98-0></A>
<H2><A NAME=MARKER-9-391></A>Locking and Unlocking File Ranges</H2>
 <A NAME=MARKER-2-392></A><A NAME=MARKER-9-86></A>A file can be opened with shared read/write permission to allow several users to share the data in the file. When a user needs to modify a portion of a file that has been opened with shared read/write permission, it is usually desirable to make that portion of the file unavailable to other users while the changes are made. You can call the <CODE>PBLockRange</CODE> function to lock a range of bytes before modifying the file and then <CODE>PBUnlockRange</CODE> to unlock that range after your changes are safely recorded in the file.<A NAME=MARKER-2-395></A><P>
 Locking a range of bytes in a file gives the user exclusive read/write access to that range and makes it inaccessible to other users. Other users can neither write nor read the bytes in that range until you unlock it. If other users attempt to read data from a portion of a file that you have locked, they receive the <CODE>fLckdErr</CODE> result code.<P>
 The functions <CODE>PBLockRange</CODE> and <CODE>PBUnlockRange</CODE> are effective only on files that are located on volumes that are sharable. If you call <CODE>PBLockRange</CODE> on a file that is not located on a remote server volume or that is not currently being shared, no range locking occurs. Moreover, <CODE>PBLockRange</CODE> does not return a result code indicating that no range locking has occurred. As a result, you should usually check whether range locking will be effective on a file before attempting to lock the desired range.<P>
 <A HREF=#MARKER-9-396>Listing 2-9</A> illustrates how you can check to make sure that calling <CODE>PBLockRange</CODE> will have the desired effect.<P>
<B>Listing 2-9  <A NAME=MARKER-9-396></A>Determining whether a file can have ranges locked</B><P>
<PRE>
FUNCTION RangesCanBeLocked (fRefNum: Integer): Boolean;
VAR
   myParmBlk:  ParamBlockRec;             {basic parameter block}
   myErr:      OSErr;
BEGIN
   WITH myParmBlk DO
      BEGIN
         ioRefNum := fRefNum;
         ioReqCount := 1;                 {lock a single byte}
         ioPosMode := fsFromStart;        {at the beginning of the file}
         ioPosOffset := 0;
      END;
   myErr := PBLockRange(@myParmBlk, FALSE);{lock the byte; ignore result}
   myErr := PBLockRange(@myParmBlk, FALSE);{lock the byte again}


   CASE myErr OF
      fLckdErr,                           {byte was locked by another user}
      afpRangeOverlap,                    {byte was locked by this user}
      afpNoMoreLocks:                     {max number of locks already used}
         BEGIN
            RangesCanBeLocked := TRUE;    {range locking is supported}
            IF myErr = afpRangeOverlap THEN  {unlock the byte we locked}
               myErr := PBUnlockRange(@myParmBlk, FALSE);
         END;
      OTHERWISE
         RangesCanBeLocked := FALSE;      {range locking is not supported}
   END; {of CASE}
END;
</PRE>
 The function RangesCanBeLocked takes a file reference number of an open file as <BR>a parameter; this is the reference number of the file in which a range of bytes is to <BR>be locked. The function attempts to locks the first byte in the file and immediately <BR>attempts to lock it again. If the second range locking fails with the result code <CODE>afpRangeOverlap</CODE>, the first call to <CODE>PBLockRange</CODE> was successful. If the second call to <CODE>PBLockRange</CODE> fails with the result code <CODE>fLckdErr</CODE>, the byte was already locked by another user. Similarly, if the second call to <CODE>PBLockRange</CODE> fails with the result code <CODE>afpNoMoreLocks</CODE>, the maximum number of range locks has been reached. In these three cases, range locking is supported by the volume containing the specified file. If any other result code (including <CODE>noErr</CODE>) is returned, range locking is not supported by that volume or for some reason the capabilities of the volume cannot be determined.<P>
<DL>
<DT><B>Note</B>
<DD>Local file sharing can be started or stopped (via the Sharing Setup control panel) while your application is running. For this reason, each time you want to lock a range, it's best to check that byte ranges in that file can be locked.<EM></EM><A NAME=MARKER-2-397></A>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 <A NAME=MARKER-2-398></A>You can unlock a locked range of bytes by calling <CODE>PBUnlockRange</CODE>. Note that the range to be unlocked must be the exact same range of bytes that was previously locked using <CODE>PBLockRange</CODE>. (You can lock and unlock different byte ranges in any order, however.) If for some reason you need to unlock a range of bytes and do not know where the range started or how long the range is, you must close the file to unlock the range. When a file is closed, all locked ranges held by a user are unlocked.<A NAME=MARKER-2-54></A><P>
 If you want to append data to a shared file, you can use <CODE>PBLockRange</CODE> to lock the range of bytes from the file's current logical end-of-file to the last possible addressable byte of the file. Once you have locked that range, you can write data into it. <A HREF=#MARKER-9-400>Listing 2-10</A> shows how to determine the current logical end-of-file and lock the appropriate range.<P>
<B>Listing 2-10  <A NAME=MARKER-9-400></A>Locking a file range to append data to the file</B><P>
<PRE>
FUNCTION LockRangeForAppending (fRefNum: Integer; VAR EOF: LongInt): OSErr;
VAR
   myParmBlk:  ParamBlockRec;             {basic parameter block}
   myErr:      OSErr;
   myEOF:      LongInt;                   {current EOF}
BEGIN
   myParmBlk.ioCompletion := NIL;
   myParmBlk.ioRefNum := fRefNum;
   myErr := PBGetEOF(@myParmBlk, FALSE);  {get the current EOF}
   IF myErr &lt;&gt; noErr THEN
      BEGIN
         LockRangeForAppending := myErr;
         Exit(LockRangeForAppending);     {trouble reading EOF}
      END;
   myEOF := LongInt(myParmBlk.ioMisc);    {save the current EOF}
   WITH myParmBlk DO
      BEGIN
         ioReqCount := -1;                {all addressable bytes}
         ioPosMode := fsFromStart;        {start range...}
         ioPosOffset := myEOF;            {...at the current end-of-file}
      END;
   myErr := PBLockRange(@myParmBlk, FALSE);{lock the specified range}
   EOF := myEOF;                          {return current EOF to caller}
   LockRangeForAppending := myErr;
END;
</PRE>
 The function <CODE>LockRangeForAppending</CODE> first determines the current logical end-of-file. It is important to get this value immediately before you attempt to lock a range that depends on it because another user of the shared file might have changed the end-of-file since you last read it. Then <CODE>LockRangeForAppending</CODE> locks the range beginning at the current end-of-file and extending for the maximum number of bytes (specified using the special value -1).<P>
 In effect, this technique locks a range where data does not yet exist. Practically speaking, locking the entire addressable range of a file prevents another user from appending data to the file until you unlock that range. Note that <CODE>LockRangeForAppending</CODE> returns the current logical end-of-file to the caller so that the caller can unlock the correct range of bytes after appending the data.<P>
 You can also call <CODE>PBLockRange</CODE> to lock a range of bytes when you want to truncate a file. Locking the end portion of a file to be deleted prevents another user from using that portion during the truncation. Instead of setting the <CODE>ioPosOffset</CODE> field of the parameter block to the logical end-of-file (as in <A HREF=#MARKER-9-400>Listing 2-10</A>), simply set it to what will be the last byte after the file is truncated. Similarly, you can lock an entire file fork by setting the <CODE>ioPosOffset</CODE> field to 0.<A NAME=MARKER-2-401></A><A NAME=MARKER-2-402></A><A NAME=MARKER-2-403></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Files-97.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Files-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Files-390.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Files-99.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Files-3.html">&copy; Apple Computer, Inc.</A><br>2 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
