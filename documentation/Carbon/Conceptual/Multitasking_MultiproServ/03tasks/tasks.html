<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Multiprocessing Services Programming Guide: Using Multiprocessing Services</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Using Multiprocessing Services"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30000267" title="Using Multiprocessing Services"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000420" target="_top">Carbon</a> &gt; <a href="../../../ProcessManagement-date.html#//apple_ref/doc/uid/TP30000440-TP30000420-TP30000456" target="_top">Process Management</a> &gt; <a href="../01introduction/introduction.html#//apple_ref/doc/uid/TP30000251-BAJFIFGE">Multiprocessing Services Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../02concepts/concepts.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../appendixa/appendixa.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30000267-SW1" title="Using Multiprocessing Services"></a><h1>Using Multiprocessing Services</h1><p>This chapter describes how to incorporate Multiprocessing Services into your Mac OS application. You should read this chapter if you are interested in adding preemptive tasks to your application. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_33" title="Note"></a><p><strong>Note:</strong>&nbsp;This document describes version 2.1 of Multiprocessing Services. For a list of functions changed or added between versions 1.4 and 2.1, see <span class="content_text"><a href="../appendixa/appendixa.html#//apple_ref/doc/uid/TP30000266-SW1">“Preemptive Task–Safe Mac OS System Software Functions.”</a></span> Applications built using older versions of Multiprocessing Services can execute without modification under version 2.1. </p></div><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_34" title="Important:"></a><p><strong>Important:</strong>&nbsp;<a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_92"></a>Preemptive tasks cannot execute 68K code. If you must call 68K code in a task, you must do so through a remote procedure call as described in <span class="content_text"><a href="tasks.html#//apple_ref/doc/uid/TP30000267-SW2">“Making Remote Procedure Calls.”</a></span></p><p></p></div>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="tasks.html#//apple_ref/doc/uid/TP30000267-DontLinkElementID_17">Multiprocessing Services in Mac OS 9 and Mac OS X</a>
				
			<br/>
			
        
			
			
				<a href="tasks.html#//apple_ref/doc/uid/TP30000267-DontLinkElementID_18">Compatibility with Older System Software</a>
				
			<br/>
			
        
			
			
				<a href="tasks.html#//apple_ref/doc/uid/TP30000267-SW13">Criteria for Creating Tasks</a>
				
			<br/>
			
        
			
			
				<a href="tasks.html#//apple_ref/doc/uid/TP30000267-DontLinkElementID_19">Checking for the Availability of Multiprocessing Services</a>
				
			<br/>
			
        
			
			
				<a href="tasks.html#//apple_ref/doc/uid/TP30000267-DontLinkElementID_20">Determining the Number of Processors</a>
				
			<br/>
			
        
			
			
				<a href="tasks.html#//apple_ref/doc/uid/TP30000267-SW8">Creating Tasks</a>
				
			<br/>
			
        
			
			
				<a href="tasks.html#//apple_ref/doc/uid/TP30000267-DontLinkElementID_21">Terminating Tasks</a>
				
			<br/>
			
        
			
			
				<a href="tasks.html#//apple_ref/doc/uid/TP30000267-DontLinkElementID_22">Synchronizing and Notifying Tasks</a>
				
			<br/>
			
        
			
			
				<a href="tasks.html#//apple_ref/doc/uid/TP30000267-SW6">Allocating Memory in Tasks</a>
				
			<br/>
			
        
			
			
				<a href="tasks.html#//apple_ref/doc/uid/TP30000267-DontLinkElementID_24">Using Task-Specific Storage</a>
				
			<br/>
			
        
			
			
				<a href="tasks.html#//apple_ref/doc/uid/TP30000267-DontLinkElementID_25">Using Timers</a>
				
			<br/>
			
        
			
			
				<a href="tasks.html#//apple_ref/doc/uid/TP30000267-SW2">Making Remote Procedure Calls</a>
				
			<br/>
			
        
			
			
				<a href="tasks.html#//apple_ref/doc/uid/TP30000267-DontLinkElementID_26">Handling Exceptions and Debugging</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_17" title="Multiprocessing Services in Mac OS 9 and Mac OS X"></a><h2>Multiprocessing Services in Mac OS 9 and Mac OS X</h2><p><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_93"></a><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_94"></a><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_95"></a><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_96"></a>Multiprocessing Services 2.1 runs on system software Mac OS 9 and later. All PowerPC Macintosh computers are supported.. </p><p>Multiprocessing Services 2.1 is packaged as part of the Mac OS System file, so you cannot install version 2.1 on older versions of system software. </p><p>Multiprocessing Services allows your application to create preemptive tasks within your application’s process (or execution context). However, the individual applications are still cooperatively scheduled by the Process Manager. In Mac OS X, both applications and tasks created by applications will be preemptively scheduled. Multiprocessing Services is Carbon-compliant, so applications built following the Carbon specification can run transparently on both Mac OS 8&amp;9 and Mac OS X systems.</p><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_18" title="Compatibility with Older System Software"></a><h2>Compatibility with Older System Software</h2><p>Multiprocessing Services 2.0 was introduced with Mac OS 8.6. Unlike earlier versions of Multiprocessing Services, you can create and execute preemptive tasks with virtual memory turned on. Multiprocessing Services 2.0 runs on all Power Macintosh computers except for 6100/7100/8100 and 5200/6200 series computers.</p><p>Multiprocessing Services 1.0 functions can run on System 7.5.2 and later if the Multiprocessing Services 1.x shared library is available. Pre-2.0 versions of the library were installed as part of system software for Mac OS 8 through Mac OS 8.5 but must be explicitly installed for earlier releases. The 1.x versions of the Multiprocessing Services library can run on all PowerPC Macintosh computers. </p><p>For a listing of functions introduced with versions 1.0, 2.0, and 2.1 of Multiprocessing Services, see <span class="content_text"><a href="../appendixa/appendixa.html#//apple_ref/doc/uid/TP30000266-SW1">“Preemptive Task–Safe Mac OS System Software Functions.”</a></span></p><a name="//apple_ref/doc/uid/TP30000267-SW13" title="Criteria for Creating Tasks"></a><h2>Criteria for Creating Tasks</h2><p>Although you can in theory designate almost any type of code as a task, in practice you should use the following guidelines to make best use of the available processors and to avoid unnecessary bottlenecks. </p><ul class="ul"><li class="li"><p>Tasks should generally perform faceless processing, such as calculation-intensive work or I/O operations. </p></li><li class="li"><p>The work performed by a task should be substantially more than the time required to process the request and result notifications. If it takes much longer to notify a task and retrieve results than to execute the task itself, an application’s performance will be dramatically worse with multiprocessing. Assuming a typical intertask signaling time is 20-50 microseconds, your tasks should take at least 200-500 microseconds to execute. If you want to explicitly calculate the intertask signaling time, you can use the sample code provided in <span class="content_text"><a href="../appendixa/appendixa.html#//apple_ref/doc/uid/TP30000266-SW1">“Preemptive Task–Safe Mac OS System Software Functions.”</a></span></p></li><li class="li"><p>If your task needs to allocate memory in Mac OS 9 and earlier, you must allocate the memory prior to signaling the task, or use the function <code>MPAllocateAligned</code>. </p></li><li class="li"><p>Tasks should not call 68K code. The 68K emulator runs only cooperatively within the Mac OS task, and not within any preemptive task. If you must call 68K code, you can do so using a remote procedure call. See <span class="content_text"><a href="tasks.html#//apple_ref/doc/uid/TP30000267-SW2">“Making Remote Procedure Calls”</a></span> for more information. </p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_97"></a><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_98"></a>You can call only preemptive task–safe Mac OS system software functions directly from a task. See Multiprocessing Gestalt Constants and <span class="content_text"><a href="../appendixa/appendixa.html#//apple_ref/doc/uid/TP30000266-SW1">“Preemptive Task–Safe Mac OS System Software Functions”</a></span> to determine which functions are preemptive task–safe. Other (unsafe) system software functions must be called indirectly through remote procedure calls. See <span class="content_text"><a href="tasks.html#//apple_ref/doc/uid/TP30000267-SW2">“Making Remote Procedure Calls”</a></span> for more information.</p></li><li class="li"><p>Tasks should not access low-memory global data. A task may be executing at any time, including when applications that did not create them are running. </p></li><li class="li"><p>Tasks should not call into unknown code. If you allow third parties to specify a callback function, you should never call that function from a task, since you cannot control what the callback will do. Calling back into non-reentrant code could easily corrupt data or cause a system crash. </p></li><li class="li"><p>Avoid global variables. The main cause of non-reentrancy is the manipulation of global data. Tasks that manipulate global variables, global states, or buffers pointed to by global variables must use synchronization techniques to prevent other tasks from attempting to do so at the same time. Read-only global data are allowed.</p></li><li class="li"><p>Do not call any Multiprocessing Services functions at interrupt time unless you are signaling a notification mechanism. See <span class="content_text"><a href="tasks.html#//apple_ref/doc/uid/TP30000267-SW3">“Notifying Tasks at Interrupt Time”</a></span> for more information.</p></li></ul><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_19" title="Checking for the Availability of Multiprocessing Services"></a><h2>Checking for the Availability of Multiprocessing Services</h2><p><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_99"></a>You should always determine the availability of Multiprocessing Services before attempting to call any of its functions. If you are programming in C, you should do so by calling the Boolean macro <code>MPLibraryIsLoaded</code>. A return value of true indicates that the Multiprocessing Services library is present and available for use. <span class="content_text"><a href="tasks.html#//apple_ref/doc/uid/TP30000267-SW4">Listing 2-1</a></span> in <span class="content_text"><a href="tasks.html#//apple_ref/doc/uid/TP30000267-SW8">“Creating Tasks”</a></span> shows an example of using the <code>MPLibraryIsLoaded</code> macro. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_35" title="Note"></a><p><strong>Note:</strong>&nbsp;For historical reasons, the Multiprocessing Services shared library may be prepared by the Code Fragment Manager and yet still be unusable; checking for resolved imported symbols is not enough to ensure that the functions are available. Therefore, you must always check for the presence of Multiprocessing Services by using the <code>MPLibraryIsLoaded</code> macro. </p></div><p>You probably want your application to run even if Multiprocessing Services is not available, so you should specify a weak link to the Multiprocessing Services shared library. Doing so allows your application to run even if the shared library is not present. </p><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_20" title="Determining the Number of Processors"></a><h2>Determining the Number of Processors</h2><p><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_100"></a><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_101"></a><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_102"></a>You may want to determine the number of processors available on the host computer before creating any tasks. Typically, you would create one task per processor; even if only one processor is present, it is generally more efficient to assign faceless work to a task and have the cooperatively scheduled main application handle only user interaction. </p><p>Multiprocessing Services uses two functions to determine the number of processors. The function <code>MPProcessors</code> returns the number of physical processors available on the host computer. The function <code>MPProcessorsScheduled</code> returns the number of active processors available (that is, the number that are currently available to execute tasks). The number of active processors may vary over time (due to changing priorities, power consumption issues, and so on). </p><a name="//apple_ref/doc/uid/TP30000267-SW8" title="Creating Tasks"></a><h2>Creating Tasks</h2><p><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_103"></a><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_104"></a>After determining how many processors are available, you can go ahead and create tasks for your application. </p><p>Each task must be a function that takes one pointer-sized parameter and returns a result of type <code>OSStatus</code> when it finishes. The input parameter can be any information that the task needs to perform its function. Some examples of input are:</p><ul class="ul"><li class="li"><p>A message queue ID that indicates which queue the task should go to for information</p></li><li class="li"><p>A pointer to a structure containing data to process</p></li><li class="li"><p>A pointer to a C++ object</p></li><li class="li"><p>A pointer to a task-specific block of memory through which the application can communicate information for the life of the task</p></li></ul><p>You create a task by calling the function <code>MPCreateTask</code>. The code in <span class="content_text">Listing 2-1</span> shows how you can create a number of identical tasks. Identical tasks can be useful when you want to divide up a large calculation (such as a image filtering operation) among several processors to improve performance. </p><a name="//apple_ref/doc/uid/TP30000267-SW4" title="Listing 2-1Creating tasks"></a><p class="codesample"><strong>Listing 2-1&nbsp;&nbsp;</strong>Creating tasks</p><div class="codesample"><table><tr><td scope="row"><pre>#define kMPStackSize 0 // use default stack size<span></span></pre></td></tr><tr><td scope="row"><pre>#define kMPTaskOptions 0 // use no options<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>typedef struct {<span></span></pre></td></tr><tr><td scope="row"><pre>    long firstThing;<span></span></pre></td></tr><tr><td scope="row"><pre>    long totalThings;<span></span></pre></td></tr><tr><td scope="row"><pre>    } sWorkParams, *sWorkParamsPtr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>typedef struct {<span></span></pre></td></tr><tr><td scope="row"><pre>    MPTaskID taskID;<span></span></pre></td></tr><tr><td scope="row"><pre>    MPQueueID requestQueue;<span></span></pre></td></tr><tr><td scope="row"><pre>    MPQueueID resultQueue;<span></span></pre></td></tr><tr><td scope="row"><pre>    sWorkParams params;<span></span></pre></td></tr><tr><td scope="row"><pre>    } sTaskData, *sTaskDataPtr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>sTaskDataPtr myTaskData;<span></span></pre></td></tr><tr><td scope="row"><pre>UInt32 numProcessors;<span></span></pre></td></tr><tr><td scope="row"><pre>MPQueueID notificationQueue;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void CreateMPTasks( void ) {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 i;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    theErr = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Assume single processor mode */<span></span></pre></td></tr><tr><td scope="row"><pre>    numProcessors = 1;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Initialize remaining globals */<span></span></pre></td></tr><tr><td scope="row"><pre>    myTaskData = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    notificationQueue = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* If the library is present then create the tasks */<span></span></pre></td></tr><tr><td scope="row"><pre>    if( MPLibraryIsLoaded() ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        numProcessors = MPProcessorsScheduled();<span></span></pre></td></tr><tr><td scope="row"><pre>        myTaskData = (sTaskDataPtr)NewPtrClear<span></span></pre></td></tr><tr><td scope="row"><pre>                ( numProcessors * sizeof( sTaskData ) );<span></span></pre></td></tr><tr><td scope="row"><pre>        theErr = MemError();<span></span></pre></td></tr><tr><td scope="row"><pre>        if( theErr == noErr  )<span></span></pre></td></tr><tr><td scope="row"><pre>                theErr = MPCreateQueue( &amp;notificationQueue );<span></span></pre></td></tr><tr><td scope="row"><pre>        for( i = 0; i &lt; numProcessors &amp;&amp; theErr == noErr; i++ ) {<span></span></pre></td></tr><tr><td scope="row"><pre>            if( theErr == noErr )<span></span></pre></td></tr><tr><td scope="row"><pre>                    theErr = MPCreateQueue(&amp;myTaskData[i].requestQueue );<span></span></pre></td></tr><tr><td scope="row"><pre>            if( theErr == noErr )<span></span></pre></td></tr><tr><td scope="row"><pre>                    theErr = MPCreateQueue(&amp;myTaskData[i].resultQueue );<span></span></pre></td></tr><tr><td scope="row"><pre>            if( theErr == noErr )<span></span></pre></td></tr><tr><td scope="row"><pre>                    theErr = MPCreateTask( MyTask, &amp;myTaskData[i],<span></span></pre></td></tr><tr><td scope="row"><pre>                        kMPStackSize, notificationQueue,<span></span></pre></td></tr><tr><td scope="row"><pre>                        NULL, NULL, kMPTaskOptions,<span></span></pre></td></tr><tr><td scope="row"><pre>                        &amp;myTaskData[i].taskID );<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* If something went wrong, just go back to single processor mode */<span></span></pre></td></tr><tr><td scope="row"><pre>    if( theErr != noErr ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        StopMPTasks();<span></span></pre></td></tr><tr><td scope="row"><pre>        numProcessors = 1;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr></table></div><p>The <code>sTaskData</code> structure defines a number of values to be used with the task, such as the task ID, the IDs of the message queues used with the task, and a pointer to parameters to pass to the task. A pointer to a structure of this type is passed in the function <code>MPCreateTask</code>. </p><p><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_105"></a><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_106"></a>The variable <code>notificationQueueID</code> holds the ID of the notification queue to associate with the tasks. When a task terminates, it sends a message to this queue. After sending a termination request, the application typically polls this queue to determine when the task has actually terminated. </p><p>The <code>CreateMPTasks</code> function creates as many identical tasks as there are available processors (as stored in <code>numProcessors</code>). If for some reason the tasks cannot be created (for example, if Multiprocessing Services is not available), the variable <code>numProcessors</code> is set to 1 and the application should do the work of the tasks itself without making any Multiprocessing Services calls. </p><p><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_107"></a>Before creating the tasks, <code>CreateMPTasks</code> calls the function <code>MPCreateQueue</code> to create a notification queue to be used by all the tasks. It then calls the Memory Manager function <code>NewPtrClear</code> to allocate memory for all the <code>myTaskData</code> structures required (in the case of this example, one per task). </p><p>Next, <code>CreateMPTasks</code> iterates over the number of requested tasks. For each iteration, it does the following:</p><ul class="ul"><li class="li"><p>Makes two calls to <code>MPCreateQueue</code> to create a request queue and a result queue for each task. The IDs for these queues are stored in the task’s <code>myTaskData</code> structure. </p></li><li class="li"><p>Fills out the <code>myTaskData</code> structure for that task as necessary. </p></li><li class="li"><p>Calls the function <code>MPCreateTask</code>. When calling this function, you must specify the following values:</p><ul class="nested"><li class="nested li"><p>the entry point of the task and its input parameters</p></li><li class="nested li"><p>the size of the stack to associate with the task</p></li><li class="nested li"><p>the notification queue to associate with the task (by passing the ID of the queue obtained in the function <code>MPCreateQueue</code>.)</p></li></ul></li></ul><p>Each task is assigned its own unique ID, which is passed back in the <code>taskID</code> field of the <code>myTaskData</code> task structure. </p><p><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_108"></a><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_109"></a>Although not a requirement, you can assign a relative weight to each task by calling the function <code>MPSetTaskWeigh</code>. The task weight is a value that indicates the amount of processor attention to give this task relative to all other eligible tasks. If, as in this example, you create a number of identical tasks, each would probably be given equal weight. </p><p>The sample task in <span class="content_text">Listing 2-2</span> calls one of two different functions depending on the request is placed on its queue. </p><a name="//apple_ref/doc/uid/TP30000267-SW5" title="Listing 2-2A sample task"></a><p class="codesample"><strong>Listing 2-2&nbsp;&nbsp;</strong>A sample task</p><div class="codesample"><table><tr><td scope="row"><pre>#define kMyRequestOne                   1<span></span></pre></td></tr><tr><td scope="row"><pre>#define kMyRequestTwo                   2<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#define kMyResultException      -1<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>OSStatus MyTask( void *parameter ) {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    sTaskDataPtr p;<span></span></pre></td></tr><tr><td scope="row"><pre>    Boolean finished;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 message;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    theErr = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Get a pointer to this task's unique data */<span></span></pre></td></tr><tr><td scope="row"><pre>    p = (sTaskDataPtr)parameter ;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Process each request handed to the task and return a result */<span></span></pre></td></tr><tr><td scope="row"><pre>    finished = false;<span></span></pre></td></tr><tr><td scope="row"><pre>    while( !finished ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        theErr = MPWaitOnQueue( p->requestQueue, (void **)&amp;message,<span></span></pre></td></tr><tr><td scope="row"><pre>                NULL, NULL, kDurationForever );<span></span></pre></td></tr><tr><td scope="row"><pre>        if( theErr == noErr ) {<span></span></pre></td></tr><tr><td scope="row"><pre>/* Pick a function to call and pass in the parameters.  */<span></span></pre></td></tr><tr><td scope="row"><pre>/* The parameters should be set up prior to sending the */<span></span></pre></td></tr><tr><td scope="row"><pre>/* message just received. Note that we could also just  */<span></span></pre></td></tr><tr><td scope="row"><pre>/* pass in a pointer to the desired function instead of */<span></span></pre></td></tr><tr><td scope="row"><pre>/* using a selector.                                                    */<span></span></pre></td></tr><tr><td scope="row"><pre>            switch( message ) {<span></span></pre></td></tr><tr><td scope="row"><pre>                case kMyRequestOne:<span></span></pre></td></tr><tr><td scope="row"><pre>                    theErr = fMyTaskFunctionOne( &amp;p->params );<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre>                case kMyRequestTwo:<span></span></pre></td></tr><tr><td scope="row"><pre>                    theErr = fMyTaskFunctionTwo( &amp;p->params );<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre>                default:<span></span></pre></td></tr><tr><td scope="row"><pre>                    finished = true;<span></span></pre></td></tr><tr><td scope="row"><pre>                    theErr = kMyResultException;<span></span></pre></td></tr><tr><td scope="row"><pre>                }<span></span></pre></td></tr><tr><td scope="row"><pre>            MPNotifyQueue( p->resultQueue, (void *)theErr, NULL, NULL );<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>        else<span></span></pre></td></tr><tr><td scope="row"><pre>            finished = true;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Task is finished now */<span></span></pre></td></tr><tr><td scope="row"><pre>    return( theErr );<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr></table></div><p>This task takes one parameter, a pointer to its task data structure. This structure contains all the information that is needed for the life of the task, such as the request and result queues created for it, and any input necessary when processing a task request. The input parameters are passed along to the requested function. </p><p><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_110"></a>After some initialization, the task sets the <code>finished</code> flag to <code>false</code> and then spends the rest of its time in a <code>while</code> loop processing message requests. The task calls the function <code>MPWaitOnQueue</code>, which waits indefinitely until a message appears on its request queue. In this case, the message indicates which function the task is to call. When a message is received, <code>MyTask</code> checks the request message to determine which function is desired and calls through to that function. Upon return, it posts a message on the result queue by calling <code>MPNotifyQueue</code> and then calls <code>MPWaitOnQueue</code> again to wait for the next message. </p><p>Note that if you are creating tasks on-the-fly, you may want to have your task dispose of its task record (pointed to by <code>p</code>) upon completion of the task. For more information about allocating and disposing of memory in tasks, see <span class="content_text"><a href="tasks.html#//apple_ref/doc/uid/TP30000267-SW6">“Allocating Memory in Tasks.”</a></span></p><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_21" title="Terminating Tasks"></a><h2>Terminating Tasks</h2><p>In general, you should avoid terminating a task directly. Instead, you should let the task exit normally, either because it has finished its assigned work, or because you posted a quit notification. Doing so allows the task to dispose of any resources or structures it may have allocated. In addition, in Mac OS X, MP tasks may use additional system resources that do not expect to have the task abruptly terminated.<a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_111"></a><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_112"></a></p><p>If you must terminate a task, you should call the function <code>MPTerminateTask</code>, ideally when the task is blocked waiting on an MP synchronization construct (queue, event, semaphore, or critical region). Doing so deletes the task, but you are still responsible for disposing of any memory you may have allocated for the task. In addition, because the tasks run asynchronously, the task may not actually terminate until sometime after the <code>MPTerminateTask</code> function returns. Therefore, you should not assume that the task has terminated until you have received a termination message from the notification queue you specified in the function <code>MPCreateTask</code>. See the discussion of <code>MPTerminateTask</code> in <em><a href="../../../Reference/Multiprocessing_Services/index.html#//apple_ref/doc/uid/TP30000145" target="_top">Multiprocessing Services Reference</a></em> in Carbon Process Management documentation for additional considerations. </p><p><span class="content_text">Listing 2-3</span> shows how you might terminate the tasks created in <span class="content_text"><a href="tasks.html#//apple_ref/doc/uid/TP30000267-SW4">Listing 2-1</a></span>. </p><a name="//apple_ref/doc/uid/TP30000267-SW7" title="Listing 2-3Terminating tasks "></a><p class="codesample"><strong>Listing 2-3&nbsp;&nbsp;</strong>Terminating tasks </p><div class="codesample"><table><tr><td scope="row"><pre>void StopMPTasks(void)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 i;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (myTaskData != NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        for (i = 0; i &lt; numProcessors; i++)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            if (myTaskData[i].TaskID != NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                MPTerminateTask(myTaskData[i].TaskID, noErr);<span></span></pre></td></tr><tr><td scope="row"><pre>                MPWaitOnQueue(notificationQueue, NULL, NULL, NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>                    kDurationForever);<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            if (myTaskData[i].fRequestQueue != NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>                MPDeleteQueue(myTaskData[i].RequestQueue);<span></span></pre></td></tr><tr><td scope="row"><pre>            if (myTaskData[i].fResultQueue != NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>                MPDeleteQueue (myTaskData[i].ResultQueue);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        if (notificationQueue != NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            MPDeleteQueue (notificationQueue);<span></span></pre></td></tr><tr><td scope="row"><pre>            notificationQueue = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        DisposePtr((Ptr)myTaskData);<span></span></pre></td></tr><tr><td scope="row"><pre>        myTaskData = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The <code>StopMPTasks</code> function iterates through all the task data structures that were created in <code>CreateMPTasks</code> and checks for those with valid task IDs. It then calls the function <code>MPTerminateTask</code> for each valid task ID. </p><p>After making the termination call, <code>StopMPTasks</code> then waits for a message to appear on the notification queue indicating that the task has in fact been terminated. It does so by waiting continuously on the notification queue until the termination message arrives. It then clears the task ID and disposes of the queues allocated for the task. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_36" title="Note"></a><p><strong>Note:</strong>&nbsp;If you call <code>MPWaitOnQueue</code> from a cooperative task, you should specify only the <code>kDurationImmediate</code> wait time. You must use a <code>while</code> loop that continuously calls <code>MPWaitOnQueue</code> until the termination message appears in the notification queue. Doing so also allows you to process events that may occur between calls. For additional information, see “Synchronizing and Notifying Tasks”.</p></div><p>After terminating all the existing tasks, <code>StopMPTasks</code> then deletes the notification queue and disposes of the task data structures. </p><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_22" title="Synchronizing and Notifying Tasks"></a><h2>Synchronizing and Notifying Tasks</h2><p><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_113"></a><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_114"></a>As described in <span class="content_text"><a href="../02concepts/concepts.html#//apple_ref/doc/uid/TP30000268-SW1">“About Multitasking on the Mac OS”</a></span> tasks often need to coordinate with the main application or with other tasks to avoid data corruption or synchronization problems. To coordinate tasks, Multiprocessing Services provides three simple notification mechanisms (semaphores, event groups, and message queues), one complex one (kernel notifications), and critical regions. </p><p>Of the three simple notification mechanisms, message queues are the easiest to use, but they are the slowest. Typically a task has two message queues associated with it. It takes messages off an input queue, processes the information accordingly, and, when done, posts a message to an output queue. </p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_37" title="Important:"></a><p><strong>Important:</strong>&nbsp;You should never use only one instance of a notification mechanism to convey both input and output information, because doing so can easily cause confusion. For example, after posting a request, an application will at some point start waiting for results. If it waits on the same mechanism where the request was posted, the request itself may appear to be the result. The application may then clear the request in the mistaken belief that it was a result and no actual work gets done. </p><p></p></div><p>Before notifying a task, your application should make sure that everything the task needs is in memory. That is, you should have created any necessary queues and allocated space for any data the task may require. For each task, your application establishes the parameters of the work that it wants the task to perform and then it must signal the task through either a queue or a semaphore to begin performing that work. The specific work that the task is to perform can be completely defined within a message, or possibly within a block of memory reserved for that task. You can also pass in a pointer to the function that the task should call to perform the work. Doing so allows one task to perform many different types of chores.</p><p><span class="content_text">Listing 2-4</span> shows a function that divides up a large amount of data among multiple tasks, placing requests on each task’s request queue and waiting for the results. </p><a name="//apple_ref/doc/uid/TP30000267-SW9" title="Listing 2-4Assigning work to tasks"></a><p class="codesample"><strong>Listing 2-4&nbsp;&nbsp;</strong>Assigning work to tasks</p><div class="codesample"><table><tr><td scope="row"><pre>OSErr NotifyTasks( UInt32 realFirstThing, UInt32 realTotalThings ) {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 i;<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr theErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 thingsPerTask;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 message;<span></span></pre></td></tr><tr><td scope="row"><pre>    sWorkParams appData;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    theErr = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    thingsPerTask = realTotalThings / numProcessors;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Start each task working on a unique piece of the total data */<span></span></pre></td></tr><tr><td scope="row"><pre>    for( i = 0; i &lt; numProcessors; i++ ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        myTaskData[i].params.firstThing =<span></span></pre></td></tr><tr><td scope="row"><pre>                                    realFirstThing + thingsPerTask * i;<span></span></pre></td></tr><tr><td scope="row"><pre>        myTaskData[i].params.totalThings = thingsPerTask;<span></span></pre></td></tr><tr><td scope="row"><pre>        message = kMyRequestOne;<span></span></pre></td></tr><tr><td scope="row"><pre>        MPNotifyQueue( myTaskData[i].requestQueue, (void *)message,<span></span></pre></td></tr><tr><td scope="row"><pre>            NULL, NULL );<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Now wait for the tasks to finish */<span></span></pre></td></tr><tr><td scope="row"><pre>    for( i = 0; i &lt; numProcessors; i++ )<span></span></pre></td></tr><tr><td scope="row"><pre>        MPWaitOnQueue( myTaskData[i].resultQueue, (void **)&amp;message,<span></span></pre></td></tr><tr><td scope="row"><pre>            NULL, NULL, kDurationForever );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return( theErr );<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>For each task, it calls <code>MPNotifyQueue</code> to place the pointer to the task’s portion of the data on the task’s request queue. It then calls <code>MPWaitOnQueue</code> to wait for confirmation that the task has completed. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_38" title="Note"></a><p><strong>Note:</strong>&nbsp;A message queue message is passed to the queue as three pointer-sized parameters. Because the message in <span class="content_text">Listing 2-4</span> is only 32 bits long, the remaining two parameters are set to <code>NULL</code>. </p></div><p>If you want to use semaphores or event groups instead of message queues, you would call the following functions to set up, notify, and wait on them, in a manner similar to that shown in <span class="content_text"><a href="tasks.html#//apple_ref/doc/uid/TP30000267-SW9">Listing 2-4</a></span>:</p><ul class="ul"><li class="li"><p><code>MPCreateSemaphore</code>, <code>MPSignalSemaphore</code>, <code>MPWaitOnSemaphore</code>, and <code>MPDeleteSemaphore</code> for semaphores</p></li><li class="li"><p><code>MPCreateEvent</code>, <code>MPSetEvent</code>, <code>MPWaitForEvent</code>, and <code>MPDeleteEvent</code> for event groups</p></li></ul><p>However, if you use the simpler notification mechanisms, you have to find another way to pass the function pointer to the task. One possibility is to assign the pointer to a field in the task’s task data structure. </p><p>To use kernel notifications, you should call the following functions:</p><ul class="ul"><li class="li"><p><code>MPCreateNotification</code>, <code>MPCauseNotification</code>, <code>MPModifyNotification</code>, and <code>MPDeleteNotification</code></p></li></ul><p>There is no function for waiting on a kernel notification, as the task would wait on the appropriate subcomponents of the kernel notification (for example, a semaphore and a message queue).</p><p><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_115"></a>Note that the example in <span class="content_text"><a href="tasks.html#//apple_ref/doc/uid/TP30000267-SW9">Listing 2-4</a></span> will wait forever (<code>kDurationForever</code>) for a message to appear on its result queue. While this method is fine if called from a preemptive task, it can cause problems if called from a cooperative task. If the task takes a significant amount of time to execute, the calling task “hangs” for that time, since it can’t call <code>WaitNextEvent</code> to give other applications processor time. If you want to wait on a task from a cooperative task, your application should post the message and then return to its event loop. From within the event loop it can then poll the result queue using <code>kDurationImmediate</code> waits until a message appears. </p><p>If you specify <code>kDurationImmediate</code> for the waiting time for either <code>MPWaitOnQueue</code>, <code>MPWaitOnSemaphore</code>, <code>MPWaitForEvent</code>, or <code>MPEnterCriticalRegion</code>, the function always returns immediately. If the return value is <code>kMPTimeoutErr</code>, then the task generated no new results since the last time the application checked. That is, no message was available, the semaphore was zero, or the critical region was being executed by another processor. If the value is <code>noErr</code>, a result was present and obtained by the call. </p><a name="//apple_ref/doc/uid/TP30000267-SW12" title="Handling Periodic Actions"></a><h3>Handling Periodic Actions</h3><p><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_116"></a>You can use notification mechanisms to do more than simply signal tasks. For example, <span class="content_text">Listing 2-5</span> shows a task that uses a semaphore to do periodic actions.</p><a name="//apple_ref/doc/uid/TP30000267-SW10" title="Listing 2-5Using a semaphore to perform periodic actions"></a><p class="codesample"><strong>Listing 2-5&nbsp;&nbsp;</strong>Using a semaphore to perform periodic actions</p><div class="codesample"><table><tr><td scope="row"><pre>void MyTask(void) {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    MPSemaphoreID delay;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    MPCreateSemaphore(1, 0, &amp;delay); // a binary semaphore<span></span></pre></td></tr><tr><td scope="row"><pre>    while(true)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            DoIt();    // do something interesting<span></span></pre></td></tr><tr><td scope="row"><pre>            (void) MPWaitOnSemaphore(delay, 10 * kDurationMillisecond);<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr></table></div><p>This example uses a semaphore solely to create a delay. After each call to the <code>DoIt</code> function, <code>MyTask</code> waits for a notification that never arrives and times out after 10ms. </p><p>You can combine the delaying and notification aspects of a semaphore to add more flexibility as shown in <span class="content_text">Listing 2-6</span>.</p><a name="//apple_ref/doc/uid/TP30000267-SW11" title="Listing 2-6Performing actions periodically and on demand"></a><p class="codesample"><strong>Listing 2-6&nbsp;&nbsp;</strong>Performing actions periodically and on demand</p><div class="codesample"><table><tr><td scope="row"><pre>main(void) {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    MPSemaphoreID delay;<span></span></pre></td></tr><tr><td scope="row"><pre>    …<span></span></pre></td></tr><tr><td scope="row"><pre>    MPCreateSemaphore(2, 0, &amp;delay);<span></span></pre></td></tr><tr><td scope="row"><pre>    MPCreateTask(…);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    while(true) {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Event loop.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        if ( /* something important happened */ )<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                MPSignalSemaphore(delay);<span></span></pre></td></tr><tr><td scope="row"><pre>                }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void MyTask(void) {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    while(true) {<span></span></pre></td></tr><tr><td scope="row"><pre>        DoIt();    // Do interesting things.<span></span></pre></td></tr><tr><td scope="row"><pre>        (void) MPWaitOnSemaphore(work, 100 * kDurationMillisecond);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr></table></div><p>In this example, the <code>MyTask</code> task runs essentially as before, except that the main application creates the semaphore. If no signal is sent to the semaphore, the <code>DoIt</code> function in <code>MyTask</code> executes every 100ms. However, in this example the application can signal the semaphore, which unblocks the task and allows the <code>DoIt</code> function to execute. That is, the <code>DoIt</code> function executes whenever the application signals the semaphore, or every 100ms otherwise. </p><a name="//apple_ref/doc/uid/TP30000267-SW3" title="Notifying Tasks at Interrupt Time"></a><h3>Notifying Tasks at Interrupt Time</h3><p><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_117"></a><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_118"></a>If you want to send a notification to a task from a 68K-style interrupt handler, you can do so using the functions <code>MPSignalSemaphore</code>, <code>MPSetEvent</code>, or <code>MPNotifyQueue</code>. The <code>MPSignalSemaphore</code> and <code>MPSetEvent</code> functions are always interrupt-safe, while the <code>MPNotifyQueue</code> function becomes interrupt-safe if you reserve notifications on the message queue. See the <code>MPSetQueueReserve</code> function description for more information about reserving notifications. </p><div class="warningbox"><img src="../../../../Resources/Images/icon_warning.gif" alt="!" width="20" height="20" border="0" class="warningicon" /><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_39" title="Warning:"></a><p><strong>Warning:</strong>&nbsp;Aside from these three notification functions, only <code>MPCurrentTaskID</code> , <code>MPBlockClear</code>, <code>MPBlockCopy</code>, <code>MPDataToCode</code>, <code>MPTaskIsPreemptive</code>, and <code>MPYield</code> are interrupt-safe; attempting to call other Multiprocessing Services functions at interrupt time, or at a deferred-task time, may cause a system crash. </p><p></p><div class="clear"></div></div><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_23" title="Using Critical Regions"></a><h3>Using Critical Regions</h3><p><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_119"></a>If your tasks need access to code that is non-reentrant, (that is, only one task can be executing the code at any particular time), you must designate that code as being a critical region. You do so by calling the function <code>MPCreateCriticalRegion</code>. Doing so returns a critical region ID that you use to identify the region when you want to enter or exit it later. To enter a critical region, the task must call <code>MPEnterCriticalRegion</code> and specify the ID of the region to enter. This function acts much like the functions that wait on message queues and semaphores; if the critical region is not currently available, the task can wait for a specified time for it to become available (after which it will time out). </p><p>After the task has completed using the critical region, you must call <code>MPExitCriticalRegion</code>. Doing so “frees” the critical region so that another task that is waiting on it can enter. Note that a task can call <code>MPEnterCriticalRegion</code> multiple times during execution (as in a recursive call) as long as it balances each such call with <code>MPExitCriticalRegion</code> when it leaves the critical region. </p><p>Note that the area of code designated as a critical region is not “tagged” as such in any way. You must make sure that your code is synchronized to properly isolate the critical region. For example, if you have a critical region that will be shared by two different tasks, you must create the critical region outside the tasks that will require it and pass the critical region ID to the tasks. This method ensures that, even if multiple instances of a task were created and running, only one could access a particular critical region at a time. </p><p>If a task contains more than one critical region, each critical region must have its own unique ID; otherwise, a task entering a critical region may block another task from entering a different critical region.</p><a name="//apple_ref/doc/uid/TP30000267-SW6" title="Allocating Memory in Tasks"></a><h2>Allocating Memory in Tasks</h2><p>In Mac OS X, if you need to allocate memory for a task, you can use <code>malloc</code> or the usual Core Foundation allocator functions, and free it using <code>free</code> or <code>CFRelease</code> respectively.<a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_120"></a></p><p>However, in Mac OS 9 and earlier, you must call the function <code>MPAllocateAligned</code>. Doing so returns a pointer to allocated memory with the alignment you specify. Prior to Mac OS X, you should always use the Multiprocessing Services memory allocation functions if your task needs to allocate, deallocate, or otherwise manipulate memory. For example, if your task deallocates its task data structure after it has finished processing, it must call <code>MPFree</code>. Note however, that since the memory is being deallocated by a preemptive task, you must have initially allocated the task record by calling <code>MPAllocateAligned</code>, even if this allocation didn’t occur in a preemptive task. </p><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_24" title="Using Task-Specific Storage"></a><h2>Using Task-Specific Storage</h2><p><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_121"></a>Task-specific storage is useful for storing small pieces of data, such as pointers to task-specific information. For example, if you create several identical tasks, each of which requires some unique data, you can store that data as task-specific storage. Task-specific storage locations are cross-referenced by an index value and the task ID, so the same code can easily refer to “per-instance” variables. Each such storage location holds a pointer-sized value. </p><p>Task-specific storage is automatically allocated when a task is created; the amount is fixed and cannot change for the life of the task. To access the task-specific storage, you call the function <code>MPAllocateTaskStorageIndex</code>. Doing so returns an index number which references a storage location in each available task in the process. Subsequent calls to <code>MPAllocateTaskStorageIndex</code> return new task index values to access more of the task-specific storage. Note that, aside from the fact that each index value is unique, you should not assume anything about the actual values of the index. For example, you cannot assume that successive calls to <code>MPAllocateTaskStorageIndex</code> will monotonically increase the index value. </p><p>Since the amount of task-specific storage is fixed, you may use up the available storage (and corresponding index values) if you make many <code>MPAllocateTaskStorageIndex</code> calls. In such cases, further calls to <code>MPAllocateTaskStorageIndex</code> return an error indicating insufficient resources. </p><p>You call <code>MPSetTaskStorageValue</code> and <code>MPGetTaskStorageValue</code> to set and retrieve the storage data. After you are finished using the storage locations, you must call <code>MPDeallocateTaskStorageIndex</code> to free the index. </p><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_25" title="Using Timers"></a><h2>Using Timers</h2><p><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_122"></a>On occasion you may want to use timers in your preemptive tasks. For example, say you want a task to send a message to a given queue every 20 milliseconds. To do so, you can set a timer to block your task for 20ms after sending the notification by calling the function <code>MPDelayUntil</code>. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_40" title="Note"></a><p><strong>Note:</strong>&nbsp;Note that in some cases you may want to use notification mechanisms to accomplish periodic actions, as described in <span class="content_text"><a href="tasks.html#//apple_ref/doc/uid/TP30000267-SW12">“Handling Periodic Actions.”</a></span> </p></div><p>In addition, you can create timers that will signal a specified notification mechanism after the timer expires. For example, say you have a task that is prompting the user to enter a name and password. Once you bring up the input dialog box, you may have another task (or the application) create a timer object to expire after five minutes. If the user has not entered a password during those five minutes, the timer expires and sends a message to the task, signaling that it should terminate. </p><p>You create a timer using the function <code>MPCreateTimer</code> and arm it by calling the function <code>MPArmTimer</code>. To specify the notification mechanisms to signal when the timer expires, you call the function <code>MPSetTimerNotify</code>. Note that you can signal one notification mechanism of each type if desired. For example, the timer can send a message to a queue and also set a bit in an event group when it expires. </p><p><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_123"></a>The timers in Multiprocessing Services use time units of type <code>AbsoluteTime</code>, which increases monotonically since the host computer was started up. You can obtain the time since startup by calling the function <code>UpTime</code>. Multiprocessing Services also provides the functions <code>DurationToAbsolute</code> and <code>AbsoluteToDuration</code>which let you convert time between units of <code>AbsoluteTime</code> and units of type <code>Duration</code>. Note that you should not make any assumptions about what the <code>AbsoluteTime</code> units are based upon. </p><a name="//apple_ref/doc/uid/TP30000267-SW2" title="Making Remote Procedure Calls"></a><h2>Making Remote Procedure Calls</h2><p><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_124"></a><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_125"></a><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_126"></a>At times a preemptive task may need to call a system software function, and doing so may cause problems. For example, many calls to Mac OS system software manipulate global variables, so data could easily be corrupted if more than one task attempts to make similar calls. To work around this problem, Multiprocessing Services allows you to make remote procedure calls if you need to call system software from a preemptive task. A remote procedure call also allows your task to call 68K code. </p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_41" title="Important:"></a><p><strong>Important:</strong>&nbsp;<a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_127"></a><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_128"></a>A subset of system software calls, as described in <span class="content_text"><a href="../appendixa/appendixa.html#//apple_ref/doc/uid/TP30000266-SW1">“Preemptive Task–Safe Mac OS System Software Functions,”</a></span> are preemptive task–safe in Mac OS 9. However, with the exception of the functions in Multiprocessing Services, you should assume that all other system calls are unsafe. Even if some system software function appears to work today when called from a preemptive task, unless explicitly stated otherwise there is no guarantee that subsequent versions of the same routine will continue to work in future versions of system software. In the Mac OS 8 and Mac OS 9 implementations of Multiprocessing Services, the only exceptions to this rule are the atomic memory operations (such as <code>AddAtomic</code>) exported in the <code>InterfaceLib</code> shared library. Even these functions may switch to 68K mode if the operands to them are not properly aligned. </p><p></p></div><p>To make a remote procedure call, you must designate an application-defined function that will make the actual calls to system software. You then pass a pointer to this function as well as any required parameters in the <code>MPRemoteCall</code> function. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_42" title="Note"></a><p><strong>Note:</strong>&nbsp;Since your application-defined function must be written in PowerPC code, you do not need to build a universal procedure pointer to pass to the <code>MPRemoteCall</code> function. </p></div><p>When you call the function <code>MPRemoteCall</code> from a task, that task is blocked, and the application-defined function you designated then executes as a cooperatively scheduled task, which can make system software calls with no danger. </p><p>Note that when you call <code>MPRemoteCall</code>, you can designate which context (or process) you want your application-defined function to execute in. If you specify that the function should execute in the same context that owns the task, the function has access to data available to the main application (just as if the application had called the function). However, the function cannot execute until the owning context becomes active (and then not until the application calls <code>WaitNextEvent</code>). Alternatively, you can designate that the function execute in any available context. Doing so minimizes possible lag time, but the function cannot access any resources specific to the task’s context. </p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_43" title="Important:"></a><p><strong>Important:</strong>&nbsp;<a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_129"></a>In the future, individual application processes may not always share the same address space, so in general you should never attempt to access code or data in another process. </p><p></p></div><p>After your application-defined function returns, the task is unblocked and execution proceeds normally. </p><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_26" title="Handling Exceptions and Debugging"></a><h2>Handling Exceptions and Debugging</h2><p><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_130"></a><a name="//apple_ref/doc/uid/TP30000267-DontLinkElementID_131"></a>Multiprocessing Services provides a number of functions you can use to handle exceptions and to aid in debugging. </p><p>By default, if you do not register an exception handler, and no debuggers are registered, a task terminates when it takes an exception. If debuggers or exception handlers exist, then the task is suspended when an exception occurs and a message is sent to the appropriate debugger or handler. </p><p>If desired, you can install an exception handler for a task by calling the function <code>MPSetExceptionHandler</code>. When an exception occurs, a message is sent to a designated queue, which your exception handler can wait upon. </p><p>In addition, you can register one or more debuggers with Multiprocessing Services by calling the function <code>MPRegisterDebugger</code>. When calling <code>MPRegisterDebugger</code>, you must specify the queue to which you want the exception message to be sent as well as a debugger level. The debugger level is simply an integer that indicates where to place this debugger in the hierarchy of registered debuggers. In addition, When an exception occurs, the order of notification for handlers is as follows:</p><ul class="ul"><li class="li"><p>The debugger with the highest debugger level (for example, a debugger registered at level 3 will have precedence over one registered as level 2).</p></li><li class="li"><p>The debugger with the next highest level (and so on, for all the registered debuggers).</p></li><li class="li"><p>The task’s exception handler. </p></li><li class="li"><p>The task’s termination function.</p></li></ul><p>At each level, the handler can choose to do either of the following:</p><ul class="ul"><li class="li"><p>Set or retrieve the task’s register or stack information using <code>MPSetTaskState</code> or <code>MPExtractTaskState</code>.</p></li><li class="li"><p>Call <code>MPDisposeTaskException</code>, which allows you to do any of the following:</p><ul class="nested"><li class="nested li"><p>Resume the task.</p></li><li class="nested li"><p>Resume the task and enable single-stepping or branch-stepping. </p></li><li class="nested li"><p>Propagate the exception to the next lower level. For example, instead of handling the exception itself, a debugger can pass the exception message to the next debugger (or exception handler) in the hierarchy. </p></li></ul></li></ul><p>If you want to throw an exception to a task, you can use the <code>MPThrowException</code> function. </p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../02concepts/concepts.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../appendixa/appendixa.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-10-31<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Carbon/Conceptual/Multitasking_MultiproServ/03tasks/tasks.html%3Fid%3DTP40000853-2.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Carbon/Conceptual/Multitasking_MultiproServ/03tasks/tasks.html%3Fid%3DTP40000853-2.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Carbon/Conceptual/Multitasking_MultiproServ/03tasks/tasks.html%3Fid%3DTP40000853-2.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>