<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Scriptable Print SimpleText - /TextDrag.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxPrinting-date.html">Printing</a> &gt; <A HREF="javascript:location.replace('index.html');">Scriptable Print SimpleText</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Printing/index.html" target="_blank">Reference Library > Printing</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Scriptable Print SimpleText</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/TextDrag.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/AboutBox.c</option>
<option value="listing2.html">/AboutBox.h</option>
<option value="listing3.html">/AboutBox.r</option>
<option value="listing4.html">/aete.r</option>
<option value="listing5.html">/AGFile.h</option>
<option value="listing6.html">/Clipboard.c</option>
<option value="listing7.html">/Clipboard.h</option>
<option value="listing8.html">/Clipboard.r</option>
<option value="listing9.html">/CoercePrGeneral.h</option>
<option value="listing10.html">/ExtendPrintRecord.c</option>
<option value="listing11.html">/ExtendPrintRecord.h</option>
<option value="listing12.html">/Localize.r</option>
<option value="listing13.html">/MacIncludes.h</option>
<option value="listing14.html">/MovieFile.c</option>
<option value="listing15.html">/MovieFile.h</option>
<option value="listing16.html">/MovieFile.r</option>
<option value="listing17.html">/PICTFile.c</option>
<option value="listing18.html">/PICTFile.h</option>
<option value="listing19.html">/PICTFile.r</option>
<option value="listing20.html">/PrintAETypes.h</option>
<option value="listing21.html">/ScriptablePrinting.c</option>
<option value="listing22.html">/ScriptablePrinting.h</option>
<option value="listing23.html">/SimpleText.c</option>
<option value="listing24.html">/SimpleText.h</option>
<option value="listing25.html">/SimpleText.r</option>
<option value="listing26.html">/TextDrag.c</option>
<option value="listing27.html">/TextFile.a</option>
<option value="listing28.html">/TextFile.c</option>
<option value="listing29.html">/TextFile.h</option>
<option value="listing30.html">/TextFile.r</option>
<option value="listing31.html">/ThreeDMetafile.c</option>
<option value="listing32.html">/ThreeDMetafile.h</option>
<option value="listing33.html">/ThreeDMetafile.r</option></select>
				</p>
				</form>
				<p><strong><a href="Scriptable_Print_SimpleText.zip">Download Sample</a></strong> (&#147;Scriptable_Print_SimpleText.zip&#148;, 212.5K)<BR>
<strong><a href="Scriptable_Print_SimpleText.dmg">Download Sample</a></strong> (&#147;Scriptable_Print_SimpleText.dmg&#148;, 290.1K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/***  File:    TextDrag.c****  Contains:  Text document dragging support for SimpleText****  Version:  SimpleText 1.4 or later**** Copyright 1993-1999 Apple Computer. All rights reserved.****  You may incorporate this sample code into your applications without**  restriction, though the sample code has been provided &quot;AS IS&quot; and the**  responsibility for its operation is 100% yours.  However, what you are**  not permitted to do is to redistribute the source as &quot;DSC Sample Code&quot;**  after having made changes. If you're going to re-distribute the source,**  we require that you make it clear in the source that the code was**  descended from Apple Sample Code, but that you've made changes.*/#include &quot;MacIncludes.h&quot;#include &quot;TextFile.h&quot;#pragma segment Text// --------------------------------------------------------------------------------------------------------------// FORWARD EXTERNAL DECLARES// --------------------------------------------------------------------------------------------------------------extern Boolean IsOnlyThisFlavor(DragReference theDragRef, FlavorType theType);extern Boolean IsDropInFinderTrash(AEDesc *dropLocation);extern OSErr SaveCurrentUndoState(WindowDataPtr pData, short newCommandID);// --------------------------------------------------------------------------------------------------------------// INTERNAL DEFINES// --------------------------------------------------------------------------------------------------------------// Dragging private globalsextern Boolean  gCanAccept;// --------------------------------------------------------------------------------------------------------------// GLOBALS USED ONLY BY THESE ROUTINES// --------------------------------------------------------------------------------------------------------------static Boolean  gCaretShow;static long    gCaretTime;static short  gCaretOffset, gLastOffset, gInsertPosition;static Boolean  gCursorInContent;static unsigned long gAutoScrollTicks;// --------------------------------------------------------------------------------------------------------------// INTERNAL ROUTINES// --------------------------------------------------------------------------------------------------------------extern void AdjustTE(WindowDataPtr pData, Boolean doScroll);// --------------------------------------------------------------------------------------------------------------//// GetSelectionSize -//static short GetSelectionSize(TEHandle hTE){  return((**(hTE)).selEnd - (**(hTE)).selStart);} // GetSelectionSize// --------------------------------------------------------------------------------------------------------------//// GetSelectedTextPtr//static Ptr GetSelectedTextPtr(TEHandle hTE){  return((*(**(hTE)).hText) + (**(hTE)).selStart);} // GetSelectedTextPtr// --------------------------------------------------------------------------------------------------------------////  TEIsFrontOfLine - Given a text offset and a TextEdit handle, returns true if the given//            offset is at the beginning of a line start.//static short TEIsFrontOfLine(short textOffset, TEHandle hTE){  short theLine = 0;  if ((**hTE).teLength == 0)    return true;  if (textOffset &gt;= (**hTE).teLength)    return( (*((**hTE).hText))[(**hTE).teLength - 1] == 0x0D );  while ((**hTE).lineStarts[theLine] &lt; textOffset)    theLine++;  return( (**hTE).lineStarts[theLine] == textOffset );} // TEIsFrontOfLine// --------------------------------------------------------------------------------------------------------------////  TEGetLine - Given an offset and a TextEdit handle, returns the line number that contains the offset.//static short TEGetLine(short textOffset, TEHandle hTE){    short theLine = 0;  if (textOffset &gt; (**hTE).teLength)    return((**hTE).nLines);  else    {    while ((**hTE).lineStarts[theLine] &lt; textOffset)      ++theLine;    }      return theLine;} // TEGetLine// --------------------------------------------------------------------------------------------------------------////  DrawCaret - Draws a caret in a TextEdit field at the given offset by inverting the image of the//        caret onto the screen. DrawCaret expects the port to be set to the port that the//        TextEdit record is in.//static void DrawCaret(short textOffset, TEHandle hTE){    Point theLoc;  short lineHeight, theLine;  //  //  Get the coordinates and the line of the offset to draw the caret.  //  theLoc  = TEGetPoint(textOffset, hTE);  theLine = TEGetLine(textOffset, hTE);    // %%% Most heinously bogus - 21-Dec-93 JM3  //  //  For some reason, TextEdit dosen't return the proper coordinates  //  of the last offset in the field if the last character in the record  //  is a carriage return. TEGetPoint returns a point that is one line  //  higher than expected. The following code fixes this problem.  if ((textOffset == (**hTE).teLength) &amp;&amp; (*((**hTE).hText))[(**hTE).teLength - 1] == 0x0D)    theLoc.v += TEGetHeight(theLine, theLine, hTE);  //  //  Always invert the caret when drawing.  //  PenMode(patXor);  //  //  Get the height of the line that the offset points to.  //  lineHeight = TEGetHeight(theLine, theLine, hTE);  //  //  Draw the appropriate caret image.  //  MoveTo(theLoc.h - 1, theLoc.v - 1);  Line(0, 1 - lineHeight);  PenNormal();} // DrawCaret// --------------------------------------------------------------------------------------------------------------////  HitTest - Given a point in global coordinates, HitTest returns an offset into the text if the//        point is inside the given TERecord. If the point is not in the text, HitTest returns//        -1.//static short HitTest(Point theLoc, TEHandle hTE){    WindowRef  theWindow;  short    textOffset = -1;  if (FindWindow(theLoc, &amp;theWindow) == inContent)    {    SetPort((GrafPtr) GetWindowPort(theWindow));    GlobalToLocal(&amp;theLoc);    if (PtInRect(theLoc, &amp;((** hTE).viewRect)) &amp;&amp; PtInRect(theLoc, &amp;((** hTE).viewRect)))      {      textOffset = TEGetOffset(theLoc, hTE);      if ((TEIsFrontOfLine(textOffset, hTE)) &amp;&amp; (textOffset) &amp;&amp;        ((*((** hTE).hText))[textOffset - 1] != 0x0D) &amp;&amp;        (TEGetPoint(textOffset - 1, hTE).h &lt; theLoc.h))        {        --textOffset;        }      }    }  return textOffset;} // HitTest// --------------------------------------------------------------------------------------------------------------//// GetCharAtOffset - Given a text offset and a TEHandle, returns the character located at that offset in//           the TERecord.//static char GetCharAtOffset(short offset, TEHandle hTE){  if (offset &lt; 0)    return 0x0D;  return(((char *) *((**hTE).hText))[offset]);} // GetCharAtOffset// --------------------------------------------------------------------------------------------------------------//// WhiteSpace - Determines if the input character is white space.//static Boolean WhiteSpace(char theChar){  return((theChar == ' ') || (theChar == 0x0D));} // WhiteSpace// --------------------------------------------------------------------------------------------------------------//// WhiteSpaceAtOffset - Given a text offset into a TERecord, determines if the character at that location is//            whitespace.//static Boolean WhiteSpaceAtOffset(short offset, TEHandle hTE){  char theChar;  if ((offset &lt; 0) || (offset &gt; (**hTE).teLength - 1))    return true;  theChar = ((char *) *((**hTE).hText))[offset];  return(WhiteSpace(theChar));} // WhiteSpaceAtOffset// --------------------------------------------------------------------------------------------------------------//// InsertTextAtOffset -//static short InsertTextAtOffset(short textOffset, char *theBuf, long textSize, StScrpHandle styleHand, TEHandle hTE){  short  charactersAdded = 0;    if (textSize == 0)    return charactersAdded;  //  If we're inserting at the end of a word and the selection does not begin with  //  a space, insert a space before the insertion.  if (!WhiteSpaceAtOffset(textOffset - 1, hTE) &amp;&amp;     WhiteSpaceAtOffset(textOffset, hTE) &amp;&amp;    !WhiteSpace(theBuf[0]))    {    TESetSelect(textOffset, textOffset, hTE);    TEKey(' ', hTE);    ++textOffset;    ++charactersAdded;    }  //  If we're inserting at the beginning of a word and the selection does not end  //  with a space, insert a space after the insertion.  if ( WhiteSpaceAtOffset(textOffset - 1, hTE) &amp;&amp;    !WhiteSpaceAtOffset(textOffset, hTE) &amp;&amp;    !WhiteSpace(theBuf[textSize - 1]))    {    TESetSelect(textOffset, textOffset, hTE);    TEKey(' ', hTE);    ++charactersAdded;    }  // Before we insert this text, make sure we set the selection range to a single character.  // This assures that we won't overwrite the text in the previous selection.    TESetSelect(textOffset, textOffset, hTE);  TEStyleInsert(theBuf, textSize, styleHand, hTE);  return charactersAdded;  } // InsertTextAtOffset// --------------------------------------------------------------------------------------------------------------// OOP INTERFACE ROUTINES// --------------------------------------------------------------------------------------------------------------OSErr TextDragTracking(WindowRef pWindow, void *pData, DragReference theDragRef, short message){#pragma unused(pWindow)  unsigned long  attributes;  RgnHandle    hilightRgn;  Point      localMouseLoc, dragMouseLoc;  short      textOffset;  long      theTime = TickCount();  WindowDataPtr  theData = (WindowDataPtr) pData;  GetDragAttributes(theDragRef, &amp;attributes);  switch(message)    {    case kDragTrackingEnterWindow:      gCanAccept = IsOnlyThisFlavor(theDragRef, 'TEXT');      gCaretTime   = theTime;      gCaretOffset = gLastOffset = -1;      gCaretShow   = true;      gCursorInContent = false;      gAutoScrollTicks = 0;      break;        case kDragTrackingInWindow:      if (gCanAccept)        {              GetDragMouse(theDragRef, &amp;dragMouseLoc, 0L);        localMouseLoc = dragMouseLoc;        GlobalToLocal(&amp;localMouseLoc);        if (attributes &amp; kDragInsideSenderWindow)          {          short deltaV = 0;          if ((localMouseLoc.v &lt; 16) &amp;&amp; (localMouseLoc.v &gt; 0))            deltaV = theData-&gt;vScrollAmount;          if (localMouseLoc.v &gt; GetWindowPort(pWindow)-&gt;portRect.bottom - 16)            deltaV = - theData-&gt;vScrollAmount;          if (deltaV == 0)            {            gAutoScrollTicks = 0;            }          else            {            if (gAutoScrollTicks == 0)              {              gAutoScrollTicks = theTime;              }            else              {              if (theTime - gAutoScrollTicks &gt; 10)  // 10 ticks to start is what the H.I. doc says                {                // remove the drag-destination caret if it's showing                if (gCaretOffset != -1)                  {                  DrawCaret(gCaretOffset, ((TextDataPtr) pData)-&gt;hTE);                  gCaretOffset = -1;                  }                  SetControlAndClipAmount(theData-&gt;vScroll, &amp;deltaV);                if (deltaV != 0)                  {                  DragPreScroll(theDragRef, 0, deltaV);                  DoScrollContent(pWindow, theData, 0, deltaV);                  DragPostScroll(theDragRef);                  }                                gAutoScrollTicks = theTime - 7;  // let's wait 3 more ticks until next jump                }              }            }          }        if (attributes &amp; kDragHasLeftSenderWindow)          {          if (PtInRect(localMouseLoc, &amp;(theData-&gt;contentRect)))            {            if (!gCursorInContent)              {              hilightRgn = NewRgn();              RectRgn(hilightRgn, &amp;theData-&gt;contentRect);              ShowDragHilite(theDragRef, hilightRgn, true);                        DisposeRgn(hilightRgn);              }            gCursorInContent = true;            }          else            {            if (gCursorInContent)              {              HideDragHilite(theDragRef);              gCursorInContent = false;              }            }          }        }      textOffset = HitTest(dragMouseLoc, ((TextDataPtr)pData)-&gt;hTE);      //  If this application is the sender, do not allow tracking through      //  the selection in the window that sourced the drag.      if (attributes &amp; kDragInsideSenderWindow)        {        if ((textOffset &gt;= (**((TextDataPtr)pData)-&gt;hTE).selStart) &amp;&amp;          (textOffset &lt;= (**((TextDataPtr)pData)-&gt;hTE).selEnd))          {            textOffset = -1;          }        }      gInsertPosition = textOffset;      //  Reset the flashing counter if the offset has moved. This makes the      //  caret blink only after the caret has stopped moving long enough.      if (textOffset != gLastOffset)        {        gCaretTime = theTime;        gCaretShow = true;        }            gLastOffset = textOffset;      //  Flash the caret, blinky-blinky-blinky.      if (theTime - gCaretTime &gt; GetCaretTime())        {        gCaretShow = !gCaretShow;        gCaretTime = theTime;        }            if (!gCaretShow)        textOffset = -1;      //  If the caret offset has changed, move the caret on the screen.      if (textOffset != gCaretOffset)        {        if (gCaretOffset != -1)          DrawCaret(gCaretOffset, ((TextDataPtr)pData)-&gt;hTE);        if (textOffset != -1)          DrawCaret(textOffset, ((TextDataPtr)pData)-&gt;hTE);        }      gCaretOffset = textOffset;      break;    case kDragTrackingLeaveWindow:        //  If the caret is on the screen, remove it.      if (gCaretOffset != -1)        {        DrawCaret(gCaretOffset, ((TextDataPtr)pData)-&gt;hTE);        gCaretOffset = -1;        }      // Remove the window hilighting, if any.        if ((gCursorInContent) &amp;&amp; (attributes &amp; kDragHasLeftSenderWindow))        HideDragHilite(theDragRef);      break;            } // switch (message)    return noErr;} // TextDragTracking// --------------------------------------------------------------------------------------------------------------OSErr TextDragReceive(WindowRef pWindow, void *pData, DragReference theDragRef){  OSErr      error;  unsigned short  items, index;  DragAttributes  attributes;  ItemReference  theItem;  Ptr        textData;  StScrpHandle  styleHand;  Size      textSize, styleSize, totalTextSize;  short      mouseDownModifiers, mouseUpModifiers, moveText, selStart, selEnd;  long      totalTextStart;  long      additionalChars;  TEHandle    hTE;  Boolean      wasActive;    if ((!gCanAccept)  || (gInsertPosition == -1))    return dragNotAcceptedErr;  hTE = ((TextDataPtr) pData)-&gt;hTE;  // We're going to try our best to insert some text, so first save off the beginning of where  // we'll do it.  totalTextStart = gInsertPosition;  totalTextSize = 0L;  // draw in this window, and activate the text editing record so that selections  // happen properly  SetPort((GrafPtr) GetWindowPort(pWindow));  wasActive = (*hTE)-&gt;active != 0;  // can't test window == FrontWindow (might not be front app)  if (!wasActive)    TEActivate(hTE);  GetDragAttributes(theDragRef, &amp;attributes);  GetDragModifiers(theDragRef, 0L, &amp;mouseDownModifiers, &amp;mouseUpModifiers);  moveText = (attributes &amp; kDragInsideSenderWindow) &amp;&amp;         (!((mouseDownModifiers &amp; optionKey) | (mouseUpModifiers &amp; optionKey)));  //  Loop through all of the drag items contained in this drag and snag all of the 'TEXT'.  CountDragItems(theDragRef, &amp;items);    for (index = 1; index &lt;= items; index++)    {    //  Get the item's reference number, so we can refer to it.    GetDragItemReferenceNumber(theDragRef, index, &amp;theItem);    //  Try to get the size for a 'TEXT' flavor. If this returns noErr,    //  then we know that a 'TEXT' flavor exists in the item.        error = GetFlavorDataSize(theDragRef, theItem, 'TEXT', &amp;textSize);    if (error == noErr)      {          // If the current length, plus the drag data would make the document too large, say so.      if (((*hTE)-&gt;teLength + textSize) &gt; kMaxLength)        return eDocumentTooLarge;      textData = NewPtr(textSize);        // If we couldn't get a chunk of memory for the text, bail.      if(textData == 0L)        return memFullErr;      GetFlavorData(theDragRef, theItem, 'TEXT', textData, &amp;textSize, 0);      // Let's see if there is an optional 'styl' flavor.      styleHand = 0L;            error = GetFlavorDataSize(theDragRef, theItem, 'styl', &amp;styleSize);      // If there was no 'styl' data, or it somehow was zero in length, don't      // attempt to insert it along with the text, 'cause we'd fail miserably.      if ((error == noErr) &amp;&amp; (styleSize != 0))        {        styleHand = (StScrpHandle) NewHandle(styleSize);              // If we couldn't get a chunk of memory for the styles, also bail.        if (styleHand == 0L)          {            DisposePtr(textData);          return memFullErr;          }        HLock((Handle) styleHand);        GetFlavorData(theDragRef, theItem, 'styl', *styleHand, &amp;styleSize, 0L);        HUnlock((Handle) styleHand);              }      //  If the caret or highlighting is on the screen, remove it/them.        if (gCaretOffset != -1)        {        DrawCaret(gCaretOffset, hTE);        gCaretOffset = -1;        }            if (attributes &amp; kDragHasLeftSenderWindow)        HideDragHilite(theDragRef);      // save away any changes, so that we can undo them      SaveCurrentUndoState(pData, cTypingCommand);            // If this window is also the sender, delete the source selection text if the      // option key is not being held down.      if (moveText)        {        selStart = (**hTE).selStart;        selEnd   = (**hTE).selEnd;                if ( WhiteSpaceAtOffset(selStart - 1, hTE) &amp;&amp;          !WhiteSpaceAtOffset(selStart,     hTE) &amp;&amp;          !WhiteSpaceAtOffset(selEnd - 1,   hTE) &amp;&amp;           WhiteSpaceAtOffset(selEnd,       hTE))          {                      if (GetCharAtOffset(selEnd, hTE) == ' ')            (**hTE).selEnd++;          }                if (gInsertPosition &gt; selStart)          {          selEnd = (**hTE).selEnd;          gInsertPosition -= (selEnd - selStart);          totalTextStart -= (selEnd - selStart);          }                TEDelete(hTE);          }      // We can finally insert the text and style data into our record.      additionalChars = InsertTextAtOffset(gInsertPosition, textData, textSize, styleHand, hTE);            // In case we're inserting multiple chunks of text, we need to update the location of where we      // need to insert the next block.      gInsertPosition += textSize + additionalChars;      totalTextSize += textSize + additionalChars;            DisposePtr(textData);      if (styleHand)        DisposeHandle((Handle) styleHand);      }    }  // Select everything we've just inserted.  TESetSelect(totalTextStart, totalTextStart + totalTextSize, hTE);  AdjustTE(pData, false);  AdjustScrollBars(pWindow, false, false, nil);  ((WindowDataPtr) pData)-&gt;changed = true;  // if we had to activate the edit record, deactivate it after we are all done  if (!wasActive)    TEDeactivate(hTE);  return noErr;} // TextDragReceive// --------------------------------------------------------------------------------------------------------------Boolean DragText(WindowRef pWindow, void *pData, EventRecord *pEvent, RgnHandle hilightRgn){  Point      theLoc = {0,0};  RgnHandle    dragRegion, tempRegion;  DragReference  theDragRef;  StScrpHandle  theStyleHand = 0L;  OSErr      error;  AEDesc      dropLocation;  DragAttributes  attributes;  short      mouseDownModifiers, mouseUpModifiers, copyText;  //  Copy the hilight region into dragRegion and offset it into global coordinates.  CopyRgn(hilightRgn, dragRegion = NewRgn());  LocalToGlobal(&amp;theLoc);  OffsetRgn(dragRegion, theLoc.h, theLoc.v);  //  Wait for the mouse to move or the mouse button to be released. If the mouse button was  //  released before the mouse moves, return false. Returing false from DragText means that  //  a drag operation did not occur.  if (!WaitMouseMoved(pEvent-&gt;where))    return false;  NewDrag(&amp;theDragRef);  AddDragItemFlavor(theDragRef, 1, 'TEXT', GetSelectedTextPtr(((TextDataPtr)pData)-&gt;hTE), GetSelectionSize(((TextDataPtr)pData)-&gt;hTE), 0);  theStyleHand = TEGetStyleScrapHandle(((TextDataPtr)pData)-&gt;hTE);  // Just be a little paranoid and see if we did get a handle.  if (theStyleHand)    {    HLock((Handle) theStyleHand);    AddDragItemFlavor(theDragRef, 1, 'styl', (Ptr) *theStyleHand, GetHandleSize((Handle) theStyleHand), 0);    DisposeHandle((Handle) theStyleHand);    }  //  Set the item's bounding rectangle in global coordinates.  SetDragItemBounds(theDragRef, 1, &amp;(**dragRegion).rgnBBox);  //  Prepare the drag region.  tempRegion = NewRgn();  CopyRgn(dragRegion, tempRegion);  InsetRgn(tempRegion, 1, 1);  DiffRgn(dragRegion, tempRegion, dragRegion);  DisposeRgn(tempRegion);  //  Drag the text. TrackDrag will return userCanceledErr if the drop whooshed back for any reason.  error = TrackDrag(theDragRef, pEvent, dragRegion);  if ((error != noErr) &amp;&amp; (error != userCanceledErr))    return true;  //  Check to see if the drop occurred in the Finder's Trash. If the drop occurred  //  in the Finder's Trash and a copy operation wasn't specified, delete the  //  source selection. Note that we can continute to get the attributes, drop location  //  modifiers, etc. of the drag until we dispose of it using DisposeDrag.  GetDragAttributes(theDragRef, &amp;attributes);  if (!(attributes &amp; kDragInsideSenderApplication))    {    GetDropLocation(theDragRef, &amp;dropLocation);    GetDragModifiers(theDragRef, 0L, &amp;mouseDownModifiers, &amp;mouseUpModifiers);    copyText = (mouseDownModifiers | mouseUpModifiers) &amp; optionKey;    if ((!copyText) &amp;&amp; (IsDropInFinderTrash(&amp;dropLocation)))      {      TEDelete(((TextDataPtr)pData)-&gt;hTE);      AdjustTE(pData, false);      AdjustScrollBars(pWindow, false, false, nil);      ((WindowDataPtr) pData)-&gt;changed = true;      }    AEDisposeDesc(&amp;dropLocation);    }  // Dispose of this drag, 'cause we're done.  DisposeDrag(theDragRef);  DisposeRgn(dragRegion);  return true;} // DragText</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Scriptable_Print_SimpleText/listing26.html%3Fid%3DDTS10000305-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Scriptable_Print_SimpleText/listing26.html%3Fid%3DDTS10000305-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Scriptable_Print_SimpleText/listing26.html%3Fid%3DDTS10000305-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>