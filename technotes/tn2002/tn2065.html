<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html><head>
<!-- BEGIN META TAG INFO -->
<link rel="home" href="http://developer.apple.com/">
<link rel="find" href="http://developer.apple.com/search/">
<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
<script language="JavaScript" type="text/javascript" src="../../documentation/js/busnav.js"></script>
<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<!-- END META TAG INFO -->
<!-- BEGIN TITLE -->
<title>Technical Note TN2065: do shell script in AppleScript</title>
<!-- END TITLE -->
</head>
<!-- BEGIN BODY OPEN -->
<body bgcolor="#ffffff"><a name="//apple_ref/doc/uid/DTS10003093" title="do shell script in AppleScript"></a>
<!--END BODY OPEN -->
<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->
<a name="top"></a>
<!-- BEGIN LOGO AND SEARCH -->
<!--#include virtual="/includes/adcnavbar"-->
<!-- END LOGO AND SEARCH -->
<!-- START BREADCRUMB -->
<div id="breadcrumb"><table width="680" border="0" cellpadding="0" cellspacing="0"><tr>
<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
<td><img width="340" height="10" src="images/1dot.gif" alt=""></td></tr><tr valign="middle"><td align="left" colspan="2">
<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/ScriptingAutomation/index.html">Scripting & Automation</a> &gt; <a href="../../technicalnotes/ScriptingAutomation/idxAppleScript-date.html">AppleScript</a> &gt; 
</td></tr><tr><td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td></tr></table></div>
<!-- END BREADCRUMB -->

<!-- START MAIN CONTENT -->
<!-- START TITLE GRAPHIC AND INTRO-->
<table width="680" border="0" cellpadding="0" cellspacing="0"><tr align="left" valign="top">
<td><h1>
<div id="pagehead">Technical Note TN2065</div>
<div id="pageheadsub">do shell script in AppleScript</div>
</h1></td></tr></table>
<!-- END TITLE GRAPHIC AND INTRO -->
<!-- BEGIN WIDE COLUMN -->
<table width="680" border="0" cellpadding="0" cellspacing="0"><tr align="left" valign="top"><td align="left" width="680">
<!-- BEGIN CONTENTS -->
<table width="680" border="0" cellpadding="0" cellspacing="0"><tr align="left" valign="top"><td><p>This Technote answers frequently asked questions about AppleScript&rsquo;s do shell script command, which was introduced in AppleScript 1.8.</p></td></tr><tr><td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br><img height="1" width="680" src="images/1dot_919699.gif" alt=""><br><img width="680" height="20" src="images/1dot.gif" alt=""></td></tr></table><table width="680" border="0" cellpadding="0" cellspacing="0"><tr align="left" valign="top"><td width="680"><ul><li><a href="#TNTAG1">Issuing Commands</a></li><li><a href="#TNTAG2">Getting an Answer</a></li><li><a href="#TNTAG3">Dealing with Text</a></li><li><a href="#TNTAG4">Dealing with Files</a></li><li><a href="#TNTAG5">Other Concerns</a></li><li><a href="#TNTAG6">Gory Details</a></li><li><a href="#TNT_HISTORY_TAG">Document Revision History</a></li></ul></td></tr><tr><td colspan="3" scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br><img height="1" width="680" src="images/1dot_919699.gif" alt=""><br><img width="680" height="20" src="images/1dot.gif" alt=""></td></tr></table><p>This technical note addresses common questions about how to use do shell script. It does not attempt to explain what you can do with a Unix shell script or how to write one; for that, find an appropriate Unix text or consult a local expert. It is structured as question-and-answer, so you can either skip right to your problem, or read through from beginning to end.</p><p>Some answers refer to &quot;man pages&quot;; these are reference documents included in Mac OS X. (The &quot;man&quot; is short for &quot;manual.&quot;) To see the man page for a command, open a Terminal window and type <code>man</code> followed by the command name, for example, <code>man echo</code>.</p><A NAME="TNTAG1"></A><H2>Issuing Commands</H2><h2>Q: How do I pass an AppleScript variable to my shell command?</h2><p>A: Since the command argument to do shell script is really just a string, you can build the string at run time using the AppleScript concatenation operator <code>&amp;</code>.  For example, to pass the variable as a command parameter, you would do this:</p><pre class="sourcecodebox">set hostname to &quot;www.apple.com&quot;
do shell script &quot;ping -c1 &quot; &amp; hostname</pre><p>Some commands require data to be fed to standard input.  do shell script does not directly support this, but you can fake it using <code>echo</code> and a pipe:</p><pre class="sourcecodebox">set input to &quot;hello&quot;
do shell script &quot;echo &quot; &amp; input &amp; &quot; | tr a-z A-Z&quot;
-- &quot;HELLO&quot;</pre><p>In general, you should quote any variables using <code>quoted form of</code>; see <A HREF="#TNTAG3">Dealing with Text</A> for details.</p><h2>Q: My command works fine in Terminal, but when I try to use it in do shell script, I get an error about &quot;command not found.&quot;  What&rsquo;s going on?</h2><p>A: There are two possibilities. First, do shell script always uses /bin/sh to interpret your command, not your default shell, which Terminal uses. (To find out what your default shell is, say <code>echo $SHELL</code> in Terminal.)  While some commands are the same between shells, others are not, and you may have used one of them. If you write your do shell script scripts in Terminal first, always use sh. You can start sh by typing <code>/bin/sh</code>; type <code>exit</code> to get back to your normal shell.</p><p>Second, when you use just a command name instead of a complete path, the shell uses a list of directories (known as your PATH) to try and find the complete path to the command. For security and portability reasons, do shell script ignores the configuration files that an interactive shell would read, so you don&rsquo;t get the customizations you would have in Terminal. Use the full path to the command, for example, <code>/sbin/ifconfig</code> instead of just <code>ifconfig</code>. To find the full path in Terminal, say <code>which command-name</code>, for example, <code>which ifconfig</code>; to see the list of places do shell script will search, say <code>do shell script &quot;echo $PATH&quot;</code>.</p><p>(This answer glosses over a few details &mdash; see <A HREF="#TNTAG6">Gory Details</A> if you care.)</p><h2>Q: Why doesn&rsquo;t do shell script work exactly like Terminal?</h2><p>A: For two reasons: first, it helps guarantee that scripts will run on different systems without modification. If do shell script used your default shell or PATH, your script would probably break if you gave it to someone else. Second, it matches shell escape mechanisms in other languages, such as Perl.</p><h2>Q: How do I run my command with a shell other than sh?</h2><p>A: Include the shell you want to use explicitly in the command. There are a variety of ways to pass commands to your shell of choice. You could write the command to a file and then execute the file like this:</p><pre class="sourcecodebox">do shell script &quot;/bin/tcsh my-command-file-path&quot;</pre><p>Some shells will accept a script as a parameter, like this:</p><pre class="sourcecodebox">do shell script &quot;/bin/tcsh -c 'my-command'&quot;</pre><p>And most will accept a script from standard input, like this:</p><pre class="sourcecodebox">do shell script &quot;echo my-command | /bin/tcsh&quot;</pre><p>When in doubt, read the documentation for your preferred shell. When you put the command in the do shell script string, you will probably have to quote the command as described below, or sh will interpret special characters in the command.</p><h2>Q: How can I use more than one command in a single do shell script? For example, I want to cd to some directory and then do some work, but it doesn&rsquo;t remember the working directory from one invocation to the next.</h2><p>A: Each invocation of do shell script uses a new shell process, so state such as changes to variables and the working directory is not saved from one to the next. To do several commands in a single invocation, separate the commands with semicolons like this:</p><pre class="sourcecodebox">do shell script &quot;cd ~/Documents; ls&quot;
-- result: &quot;Welcome.txt&quot;</pre><p>Using a line feed (ASCII character 10) also works.</p><h2>Q: How do I get administrator privileges for a command?</h2><p>A: Use the <code>administrator privileges</code>, <code>user name</code> and <code>password</code> parameters like this:</p><pre class="sourcecodebox">do shell script &quot;command&quot; user name &quot;me&quot; password &quot;mypassword&quot; with administrator privileges</pre><p><code>user name</code> and <code>password</code> are optional; if you omit the user name, do shell script assumes it to be the current user; if you omit the password, it will ask for a password when it runs.  Once a script is correctly authenticated, it will not ask for authentication again for five minutes.  As of Mac OS X 10.4, this grace period does not extend to any other scripts or to the rest of the system; manually calling <code>sudo -k</code> is unnecessary.</p><p>For security reasons, you may not tell another application to do shell script with administrator privileges.  Put the command outside of any tell block, or put it inside a tell me block.</p><p>Bear in mind that administrator privileges allow you to change any file anywhere in the system. You can render your system unbootable or even erase the entire disk with a few well-placed commands, so exercise caution. Better yet, don&rsquo;t use administrator privileges unless you absolutely have to. Unless you are doing system-level development, you should never need to change anything in /System &mdash; changing /Library should suffice.</p><div class="notebox"><p><strong>Note:</strong> Using sudo(8) with <code>with administrator privileges</code> is generally unnecessary and creates security holes; simply remove the &quot;sudo&quot;.</p></div><div class="notebox"><p><strong>WARNING:</strong> In Mac OS X 10.4.0 and 10.4.1, <code>with administrator privileges</code> executes the command with only the effective user id set to root.  This causes trouble for some commands that rely on the real user id &mdash; for example, Perl will turn on its &quot;taint mode&quot; security checks, and sudo(8) will hang.  To work around the problem (assuming you cannot simply remove a use of sudo; see above), preface your command with a small Perl script to set the real user id, like this:</p><pre class="sourcecodebox">do shell script &quot;/usr/bin/perl -Ue '$&lt; = $&gt;; system(@ARGV)' my_command&quot; with administrator privileges</pre><p>Mac OS X 10.4.2 sets both the real and effective user ids; the workaround described here will be unnecessary, but harmless.</p></div><div class="notebox"><p><strong>WARNING:</strong> Prior to Mac OS X 10.4, <code>with administrator privileges</code> did not work correctly with multiple commands.  You had to turn your multiple commands into a single invocation of sh, like this:</p><pre class="sourcecodebox">set normal_command to &quot;command1; command2&quot;
do shell script &quot;sh -c &quot; &amp; quoted form of normal_command with administrator privileges</pre><p>As of Mac OS X 10.4, you can use <code>with administrator privileges</code> with multiple commands as described in &quot;how can I use more than one command&quot; above; no workaround is necessary.</p></div><h2>Q: How long can my command be? What&rsquo;s the maximum number of characters?</h2><p>A: There is no precise answer to this question. (See <A HREF="#TNTAG6">Gory Details</A> for the reasons why.) However, the approximate answer is that a single command can be up to about 262,000 characters long &mdash; technically, 262,000 bytes, assuming one byte per character. Non-ASCII characters will use at least two bytes per character &mdash; see <A HREF="#TNTAG3">Dealing with Text</A> for more details.</p><div class="notebox"><p><strong>Note:</strong> This limit used to be smaller; in Mac OS X 10.2 it was about 65,000 bytes.  The shell command <code>sysctl kern.argmax</code> will give you the current limit in bytes.</p></div><p>Overrunning the limit will cause do shell script to return an error of type 255. Most people who hit the limit are trying to feed inline data to their command. Consider writing the data to a file and reading it from there instead.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG2"></A><H2>Getting an Answer</H2><h2>Q: How does do shell script get the result?  How do I return a shell variable to my AppleScript?</h2><p>A: Shell commands can write their results to one of two output streams: standard output and standard error. Standard output is for normal output, while standard error is for error messages and diagnostics. Assuming your script completes successfully &mdash; if it doesn&rsquo;t, see the next question &mdash; the result is whatever text was printed to standard output, possibly with some modifications.  Most commands print their results to standard output automatically, so you don&rsquo;t need to do anything extra.  If your answer is in a variable, you will need to print it yourself using <code>echo</code> (most shells) or <code>print</code> (many languages, such as Perl and Awk).  For example:</p><p class="smalltext"><strong>Listing 1:</strong> Set the AppleScript variable mySlug to a date slug in yyyy-mm-dd format.</p><pre class="sourcecodebox">set mySlug to do shell script &quot;date +%Y-%m-%d&quot;
-- see the 'date' man page for details on the format string.</pre><p class="smalltext"><strong>Listing 2:</strong> The same thing, but as a Perl script.</p><pre class="sourcecodebox">set mySlug to do shell script &not;
    &quot;perl -e 'my (undef, undef, undef, $d, $m, $y) = localtime;
              my $date = sprintf(&quot;%4d-%02d-%02d&quot;, $y+1900, $m+1, $d);
              print $date'&quot;</pre><p>By default, do shell script transforms all the line endings in the result to Mac-style carriage returns (&quot;\r&quot; or ASCII character 13), and removes a single trailing line ending, if one exists. This means, for example, that the result of <code>do shell script &quot;echo foo; echo bar&quot;</code> is <code>&quot;foo\rbar&quot;</code>, not the <code>&quot;foo\nbar\n&quot;</code> that echo actually returned. You can suppress both of these behaviors by adding the <code>without altering line endings</code> parameter. For dealing with non-ASCII data, see <A HREF="#TNTAG3">Dealing with Text</A>.</p><h2>Q: How does do shell script report errors?</h2><p>A: All shell commands return an integer status when they finish: zero means success; anything else means failure. If the script exits with a non-zero status, do shell script throws an AppleScript error with the status as the error number. (The man page for a command should tell you what status codes it can return. Most commands simply use 1 for all errors.) If the script printed something to the standard error stream, that text becomes the error message in AppleScript. If there was no error text, the normal output (if any) is used as the error message.</p><h2>Q: When I run my command in Terminal, I get a bunch of output, but when using do shell script, some of it is missing.</h2><p>A: When running in Terminal, standard output and standard error are both sent to the same place, so it&rsquo;s difficult to tell them apart. do shell script, on the other hand, keeps the two streams separate. If you want to combine them, follow the command with <code>2&gt;&amp;1</code> like this:</p><pre class="sourcecodebox">do shell script &quot;command 2&gt;&amp;1&quot;</pre><p>See the sh man page under &quot;Redirection&quot; for more details.</p><h2>Q: How much output can a command return?</h2><p>A: A single command can return up to 1GB of data.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG3"></A><H2>Dealing with Text</H2><h2>Q: My command doesn&rsquo;t work right when a parameter has spaces or certain punctuation &mdash; parentheses, $, *, etc.</h2><p>A: Because the shell separates parameters with spaces, and some punctuation marks have special meanings, you must take special steps to make the shell treat your string as one parameter with literal spaces, parentheses, etc. This is called &quot;quoting,&quot; and there are several ways to do it, but the simplest and most effective is to use the <code>quoted form</code> property of strings.</p><p>For example, consider this (buggy) handler, which takes a string and appends it to a file named &quot;stuff&quot; in your home directory:</p><pre class="sourcecodebox">to append_message(s)
    do shell script &quot;echo &quot; &amp; s &amp; &quot; &gt;&gt; ~/stuff&quot;
end append_message</pre><p>It works fine for most strings, but if we call it with a string like &quot;$100&quot;, the string that ends up in the file is &quot;00&quot;, because the shell thinks that &quot;$1&quot; is a variable whose value is an empty string. (Variables in sh begin with a dollar sign.) To fix the script, change it like this:</p><pre class="sourcecodebox">do shell script &quot;echo &quot; &amp; quoted form of s &amp; &quot; &gt;&gt; ~/stuff&quot;</pre><p>The <code>quoted form</code> property gives the string in a form that is safe from further interpretation by the shell, no matter what its contents are. For more details on quoting, see the sh man page under &quot;Quoting.&quot;</p><h2>Q: I need to put double quotes and backslashes in my shell command, but AppleScript gives me a syntax error when I try.</h2><p>A: Strings in AppleScript go from an opening double quote to a closing double quote. To put a literal double quote in your string you must &quot;escape&quot; it with a backslash character, like this:</p><pre class="sourcecodebox">&quot;a \&quot;quote\&quot; mark&quot;</pre><p>The backslash means &quot;treat the next character specially.&quot; This means that getting a literal backslash requires two backslashes, like this:</p><pre class="sourcecodebox">&quot;a back\\slash&quot;</pre><p>Putting this all together, you might have something like this:</p><pre class="sourcecodebox">set s to &quot;this is a test.&quot;
do shell script &quot;echo &quot; &amp; quoted form of s &amp; &quot; | perl -n -e 'print \&quot;\\U$_\&quot;'&quot;
-- result: &quot;THIS IS A TEST.&quot;</pre><p>Despite all the extra backslashes in the script, the actual string passed to perl&rsquo;s -e option is</p><pre class="sourcecodebox">print &quot;\U$_&quot;</pre><h2>Q: Whenever my shell script returns a double quote or backslash, it comes out with an extra backslash in front of it.</h2><p>A: The result window shows you the result in &quot;source&quot; form, such that you could paste it into a script and compile it. This means that string results have quotes around them, and special characters such as double quotes and backslashes are escaped as described above. The extra backslash is not really part of the string, it&rsquo;s merely how it&rsquo;s displayed. If you pass the string to <code>display dialog</code> or write it to a file, you&rsquo;ll see it without the extra backslashes.</p><h2>Q: What does do shell script do with non-ASCII text (accented characters, Japanese, etc.)?</h2><p>A: From AppleScript&rsquo;s point of view, do shell script accepts and produces Unicode text.  do shell script passes the commands to the shell and interprets their output using UTF-8.  If a command produces bytes that are not valid UTF-8, do shell script will interpret them using the primary system encoding.</p><p>Realize that most shell commands are completely ignorant of Unicode and UTF-8. UTF-8 looks like ASCII for ASCII characters &mdash; for example, <code>A</code> is the byte 0x41 in both ASCII and UTF-8 &mdash; but any non-ASCII character is represented as a sequence of bytes. As far as the shell commands are concerned, however, one byte equals one character, and they make no attempt to interpret anything outside the ASCII range. This means that they will preserve UTF-8 sequences and can do exact byte-for-byte matches: for example, <code>echo &quot;&trade;&quot;</code> will produce a trademark symbol, and <code>grep &quot;&copy;&quot;</code> will find every line with a copyright symbol. However, they cannot intelligently sort, alter, or compare UTF-8 sequences: for example, character-set matching commands like <code>tr</code> or the [] construct in <code>sed</code> will attempt to match each byte of the sequence independently, <code>sort</code> will sort accented characters out of order, and <code>grep -i</code> or <code>find -iname</code> will not match &quot;&eacute;&quot; against &quot;&Eacute;&quot;. Perl is a notable exception to this; see the perlunicode man page for more details.</p><div class="notebox"><p><strong>Note:</strong> Prior to AppleScript 1.8.3, do shell script interpreted input and output using the primary system encoding, which made it extremely difficult to deal with files that had non-ASCII characters in their names.</p><p>Prior to Mac OS X 10.4, output that is not valid UTF-8 will produce the error &quot;can&rsquo;t make some data into the expected type.&quot; Workarounds include writing the output to a file and then reading it using AppleScript&rsquo;s read command or piping through vis.  As of 10.4, output that is not valid UTF-8 will be interpreted using the primary system encoding.</p></div><h2>Q: What are the rules for line endings?</h2><p>A: There are two different line ending conventions in Mac OS X: Mac-style (lines end with return: &quot;\r&quot; or ASCII character 13) and Unix-style (lines end with line-feed: &quot;\n&quot; or ASCII character 10). Shell commands typically only handle Unix-style line endings, so giving them Mac-style text will produce less-than-useful results. For example, grep would consider the entire input to have only one line, so you would get at most one match.</p><p>If your data is coming from AppleScript, you can transform the line endings there or generate line feeds in the first place &mdash; <code>&quot;\n&quot;</code> or <code>ASCII character 10</code> both yield a line feed. If your data is coming from a file, you can make the shell script transform the line endings by using tr. For example, the following will find lines that contain &quot;something&quot; in any plain text file. (The &quot;quoted form of POSIX path of f&quot; idiom is discussed under <A HREF="#TNTAG4">Dealing with Files</A>.)</p><pre class="sourcecodebox">set f to choose file
do shell script &quot;tr '\\r' '\\n' &gt; &quot; &amp; quoted form of POSIX path of f &amp; &quot; | grep something&quot;</pre><p>AppleScript itself is line ending-agnostic &mdash; the <code>paragraph</code> element of string and Unicode text objects considers Mac, Unix, and Windows-style line endings to be equivalent. There is generally no need to use <code>text item delimiters</code> to get the lines of Unix-style text; <code>paragraph n</code> or <code>every paragraph</code> will work just as well. (However, if you wanted to consider only Unix-style line endings, text item delimiters would be the proper solution. Also, prior to AppleScript 1.9.1, Unicode text objects only considered return and the Unicode paragraph-separator character to be paragraph breaks.)</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG4"></A><H2>Dealing with Files</H2><h2>Q: I have an AppleScript file or alias object; how do I pass it to a shell command?</h2><p>A: The shell specifies files using POSIX path names, which are strings with slashes separating the path components (for example, <code>/folder1/folder2/file</code>). To get the POSIX path of an AppleScript file or alias object, use the <code>POSIX path</code> property. (However, see the following question.) For example:</p><pre class="sourcecodebox">POSIX path of file &quot;HD:Users:me:Documents:Welcome.txt&quot;
-- result: &quot;/Users/me/Documents/Welcome.txt&quot;</pre><p>To go the other way &mdash; say your shell command returns a POSIX path as a result &mdash; use the <code>POSIX file</code> class.  <code>POSIX file</code> with a path name evaluates to a normal file object that you can then pass to other AppleScript commands. For example:</p><pre class="sourcecodebox">set p to do shell script &quot;echo ~&quot;
POSIX file p
-- result: file &quot;HD:Users:me:&quot;</pre><h2>Q: POSIX path doesn&rsquo;t work right if the file has certain characters in its name &mdash; spaces, parentheses, $, *, etc.</h2><p>A: This is a special case of quoting: you must quote the path to make the shell interpret all the punctuation literally. To do this, use the quoted form of the path. For example, this will work with any file, no matter what its name is:</p><pre class="sourcecodebox">choose file
do shell script &quot;ls -l &quot; &amp; quoted form of the POSIX path of the result
-- result: &quot;-rw-r--r-- 1 me unknown 1 Oct 25 17:48 Look! a file!&quot;</pre><h2>Q: Why doesn&rsquo;t POSIX path just quote everything for me?</h2><p>A: For two reasons: first, there are uses for POSIX paths that have nothing to do with shell parameters, and quoting the path would be wrong in such cases. Second, quoted form is useful for things other than file paths. Therefore, there are two orthogonal operations instead of one combined one.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG5"></A><H2>Other Concerns</H2><h2>Q: How do I control an interactive tool like ftp or telnet with do shell script?</h2><p>A: The short answer is that you don&rsquo;t. do shell script is designed to start the command and then let it run with no interaction until it completes, much like the backquote operator in Perl and most Unix shells.</p><p>However, there are ways around this. You can script Terminal and send a series of commands to the same window (though this only works in Mac OS X 10.2 and later), or you could use a Unix package designed for scripting interactive tools, such as <A HREF="http://expect.nist.gov/">expect</A>. Also, many interactive commands have non-interactive equivalents. For example, <code>curl</code> can substitute for <code>ftp</code> in most cases.</p><h2>Q: My script will produce output over a long time. How do I read the results as they come in?</h2><p>A: Again, the short answer is that you don&rsquo;t &mdash; do shell script will not return until the command is done. In Unix terms, it cannot be used to create a pipe. What you can do, however, is to put the command into the background (see the next question), send its output to a file, and then read the file as it fills up.</p><h2>Q: I want to start a background server process; how do I make do shell script not wait until the command completes?</h2><p>A: Use <code>do shell script &quot;command &amp;&gt; file_path &amp;&quot;</code>. do shell script will return immediately with no result and your AppleScript script will be running in parallel with your shell script. The shell script&rsquo;s output will go into file_path; if you don&rsquo;t care about the output, use <code>/dev/null</code>. There is no direct support for getting or manipulating the background process from AppleScript, but see the next question.</p><div class="notebox"><p><strong>Note:</strong> Saying <code>&amp;&gt; file_path</code> is semantically equivalent to <code>&gt; file_path 2&gt;&amp;1</code>, and will direct both standard output and standard error to <code>file_path</code>.  If you need them to go to different places, direct standard output using <code>&gt;</code> and standard error using <code>2&gt;</code>.  For example,&nbsp;to send standard error to a file but ignore standard output, do this:</p><pre class="sourcecodebox">do shell script &quot;command &gt; /dev/null 2&gt; file_path</pre><p>See the sh man page under &quot;Redirection&quot; for more details.</p></div><h2>Q: I have started a background process; how do I get its process ID so I can control it with other shell commands?</h2><p>A: You can use a feature of sh to do this: the special variable <code>$!</code> is the ID of the most recent background command, so you can echo it as the last command in your shell script, like this:</p><pre class="sourcecodebox">do shell script &quot;my_command &amp;&gt; /dev/null &amp; echo $!&quot;
-- result: 621
set pid to the result
do shell script &quot;renice +20 -p &quot; &amp; pid
-- change my_command's scheduling priority.
do shell script &quot;kill &quot; &amp; pid
-- my_command is terminated.</pre><h2>Q: I&rsquo;m trying to use top, but it fails saying &quot;can&rsquo;t get terminal attributes&quot; or &quot;error opening terminal: unknown.&quot;</h2><p>A: top in its default mode does all sorts of clever things to create a dynamically updating display, none of which work if the output device does not support cursor control, as do shell script does not. However, top has an option that makes it run in logging mode, which works with file-like devices like do shell script. Use <code>top -l1</code> instead, or see the top man page for more options.</p><p>This same problem will apply to any other command that assumes the presence of a terminal. Fortunately, most of them are interactive front ends to more primitive commands that do not assume a terminal.</p><h2>Q: What&rsquo;s the default working directory for do shell script commands?</h2><p>A: do shell script inherits the working directory of its parent process. For most applications, such as Script Editor, this is /. For osascript, it&rsquo;s the working directory of the shell when you launched osascript. You should not rely on the default working directory being anything in particular. If you need the working directory to be someplace specific, set it to that yourself.</p><h2>Q: Does it make a difference which application I tell to do shell script?</h2><p>A: For the most predictable results, always put do shell script calls outside of any tell block, or use <code>tell me</code>. In practice, it usually doesn&rsquo;t matter unless you are running your AppleScript from osascript, but it doesn&rsquo;t hurt to be safe. (Also, telling another application to do shell script, or indeed any scripting addition, will block any other work that application might do until the scripting addition finishes. This is often considered a bad thing.)</p><p>The issue is that which application you tell determines the environment for the shell script &mdash; the working directory, environment variables, and so on. Most applications have the same environment, but relying on this is a maintenance risk. If your AppleScript is running in osascript, the working environment comes from the shell osascript was run from, which is completely separate from any other application. Consider the following exchange in sh running in Terminal:</p><pre class="sourcecodebox">$ VAR=something; export VAR
$ osascript -e 'do shell script &quot;echo $VAR&quot;'
something
$ osascript -e 'tell application &quot;Finder&quot; to do shell script &quot;echo $VAR&quot;'
(nothing)</pre><p>For more on how this works, see <A HREF="#TNTAG6">Gory Details</A>.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNTAG6"></A><H2>Gory Details</H2><p>This section is for those who want to know all the niggling details of how do shell script works. If you just want to make your script work right, you probably don&rsquo;t need to read it.</p><h2>Q: What shell does do shell script use, really?</h2><p>A: do shell script always calls /bin/sh. However, in Mac OS X, /bin/sh is really a copy of another shell that emulates sh. In 10.2 and later, this is bash; prior to that it was zsh.</p><h2>Q: How long can my command be, really?</h2><p>A: Calling do shell script creates a new sh process, and is therefore subject to the system&rsquo;s normal limits on passing data to new processes: the arguments (in this case, the text of your command plus about 40 bytes of overhead) and any environment variables may not be larger than kern.argmax, which is currently 262,144 bytes. Because do shell script inherits its parent&rsquo;s environment (see the next question), the exact amount of space available for command text depends on the calling environment. In practical terms, this comes out to somewhat more than 261,000 bytes, but unusual environment settings might reduce that substantially.</p><h2>Q: Where does the shell environment come from &mdash; environment variables, working directory, and so on?</h2><p>A: do shell script inherits the environment of its parent process. Because of how scripting additions like do shell script work, the parent process is the application for the tell block surrounding the do shell script call. If there is no surrounding tell block, or if you tell me, the parent is the application running the script.</p><p>The environment covers the working directory, any environment variables, and several other attributes &mdash; see the execve(2) man page for a complete list. As mentioned in Issuing Commands, do shell script does not read the configuration files that an interactive shell running in Terminal would.</p><p>Any application launched from the Finder gets the same default environment: a working directory of / and the environment variables HOME, LANG, PATH, USER, and SHELL. (You can define more environment variables if you wish; see <A HREF="../../qa/qa2001/qa1067.html">Technical Q&amp;A QA1067, Setting environment variables for user processes</A> for details.) Most applications do not change their environment, but relying on this is a maintenance risk.</p><p>osascript(1) inherits its environment from the shell it&rsquo;s run from: the working directory is the working directory of the shell; any environment variables defined in the shell will also be defined in osascript, and therefore in do shell script. For example:</p><pre class="sourcecodebox">$ VAR=something; export VAR
$ osascript -e 'do shell script &quot;echo $VAR&quot;'
something</pre><p>sh defines a number of environment variables of its own, but those are the same no matter how it&rsquo;s run.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNT_HISTORY_TAG"></A><H2>Document Revision History</H2><table cellspacing="0" class="graybox" width="680"><tr><th width="100">Date</th><th width="580">Notes</th></tr><tr><td scope="row">2006-03-23</td><td>Document security restriction on telling other applications with administrator privileges.</td></tr><tr><td scope="row">2005-07-20</td><td>Updated &quot;administrator privileges&quot; question to reflect changes in 10.4.2.</td></tr><tr><td scope="row">2005-05-06</td><td>Changes for Mac OS X 10.4 (Tiger).</td></tr><tr><td scope="row">2003-01-27</td><td>New Document</td></tr></table><p><b>Posted:</b> 2006-03-23</p>
<!-- END CONTENTS -->
</td></tr></table>
<!-- END WIDE COLUMN -->
<!-- END MAIN CONTENT -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn2002/tn2065.html%3Fid%3DDTS10003093-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn2002/tn2065.html%3Fid%3DDTS10003093-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn2002/tn2065.html%3Fid%3DDTS10003093-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

<!-- START BOTTOM APPLE NAVIGATION -->
<!--#include virtual="/includes/footer"-->
<!-- END BOTTOM APPLE NAVIGATION -->
<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->
</body></html>