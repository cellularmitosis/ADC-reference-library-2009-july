<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Porting CodeWarrior Projects to Xcode: Xcode From a CodeWarrior Perspective</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Xcode From a CodeWarrior Perspective"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/20001709" title="Xcode From a CodeWarrior Perspective"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000436" target="_top">Tools</a> &gt; <a href="../../../Xcode-date.html#//apple_ref/doc/uid/TP30000440-TP30000436-TP30000557" target="_top">Xcode</a> &gt; <a href="../migration_overview/migration_overview.html#//apple_ref/doc/uid/TP40001286-TPXREF101">Porting CodeWarrior Projects to Xcode</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../migration_overview/migration_overview.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../mig_bef_converting/migration_before_convert.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/20001709-TPXREF101" title="Xcode From a CodeWarrior Perspective"></a><h1>Xcode From a CodeWarrior Perspective </h1><p>This chapter introduces key features of Xcode from the perspective of CodeWarrior users. Understanding the similarities and differences in these features should help you put your CodeWarrior experience to work in Xcode. It will also be useful in converting your CodeWarrior projects.</p><div class="importantbox"><a name="//apple_ref/doc/uid/20001709-DontLinkElementID_12" title="Important:"></a><p><strong>Important:</strong>&nbsp;This chapter concentrates on differences between Xcode and CodeWarrior, and does not provide a comprehensive overview of Xcode. For a more complete feature list, see <em><!--a target="_top" -->Xcode 2.2 User Guide<!--/a--></em>. For a brief tutorial introduction to Xcode, see <em><a href="../../XcodeQuickTour/index.html#//apple_ref/doc/uid/TP30000890" target="_top">Xcode Quick Tour for Mac OS X</a></em>.</p><p></p></div><p>Though there are many minor differences between Xcode and CodeWarrior, you’ll find that Xcode supports most of the features CodeWarrior users are familiar with. Xcode also provides a great deal of flexibility in organizing the environment for the way you like to work, as described in <span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-SW14">“Customizing the Environment.”</a></span></p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="migration_differences.html#//apple_ref/doc/uid/20001709-TPXREF128">The Basic Development Environment</a>
				
			<br/>
			
        
			
			
				<a href="migration_differences.html#//apple_ref/doc/uid/20001709-TPXREF141">Limitations</a>
				
			<br/>
			
        
			
			
				<a href="migration_differences.html#//apple_ref/doc/uid/20001709-TPXREF140">Companion Applications</a>
				
			<br/>
			
        
			
			
				<a href="migration_differences.html#//apple_ref/doc/uid/20001709-SW13">Header Files</a>
				
			<br/>
			
        
			
			
				<a href="migration_differences.html#//apple_ref/doc/uid/20001709-BAJDIJDB">Framework-Style Headers</a>
				
			<br/>
			
        
			
			
				<a href="migration_differences.html#//apple_ref/doc/uid/20001709-BCIJCHII">Cross-Development</a>
				
			<br/>
			
        
			
			
				<a href="migration_differences.html#//apple_ref/doc/uid/20001709-BABIIEII">Precompiled Headers and Prefix Files</a>
				
			<br/>
			
        
			
			
				<a href="migration_differences.html#//apple_ref/doc/uid/20001709-TPXREF154">Pragma Statements</a>
				
			<br/>
			
        
			
			
				<a href="migration_differences.html#//apple_ref/doc/uid/20001709-BABFDBGA">C and C++ Libraries</a>
				
			<br/>
			
        
			
			
				<a href="migration_differences.html#//apple_ref/doc/uid/20001709-TPXREF143">Support for wchar_t and wstring</a>
				
			<br/>
			
        
			
			
				<a href="migration_differences.html#//apple_ref/doc/uid/20001709-BAJEGBEG">The GCC Compiler</a>
				
			<br/>
			
        
			
			
				<a href="migration_differences.html#//apple_ref/doc/uid/20001709-BABFEFCD">C++ Code in C Files</a>
				
			<br/>
			
        
			
			
				<a href="migration_differences.html#//apple_ref/doc/uid/20001709-TPXREF151">Inline ASM</a>
				
			<br/>
			
        
			
			
				<a href="migration_differences.html#//apple_ref/doc/uid/20001709-BABDHIBF">The Linker</a>
				
			<br/>
			
        
			
			
				<a href="migration_differences.html#//apple_ref/doc/uid/20001709-BCIBCHCJ">The Information Property List and .plc Files</a>
				
			<br/>
			
        
			
			
				<a href="migration_differences.html#//apple_ref/doc/uid/20001709-BCIIHGEH">Working With Resources</a>
				
			<br/>
			
        
			
			
				<a href="migration_differences.html#//apple_ref/doc/uid/20001709-TPXREF133">Building Code</a>
				
			<br/>
			
        
			
			
				<a href="migration_differences.html#//apple_ref/doc/uid/20001709-BABFBHHF">Exporting Symbols</a>
				
			<br/>
			
        
			
			
				<a href="migration_differences.html#//apple_ref/doc/uid/20001709-TPXREF134">Debugging</a>
				
			<br/>
			
        
			
			
				<a href="migration_differences.html#//apple_ref/doc/uid/20001709-CIHGFBJI">Prebinding</a>
				
			<br/>
			
        
			
			
				<a href="migration_differences.html#//apple_ref/doc/uid/20001709-BABHEHCG">Source Trees</a>
				
			<br/>
			
        
			
			
				<a href="migration_differences.html#//apple_ref/doc/uid/20001709-TPXREF130">Source Control</a>
				
			<br/>
			
        
			
			
				<a href="migration_differences.html#//apple_ref/doc/uid/20001709-BAJDGDJG">PowerPlant</a>
				
			<br/>
			
        
			
			
				<a href="migration_differences.html#//apple_ref/doc/uid/20001709-BABFEJJG">Maintaining Parallel Projects in Xcode and CodeWarrior</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/20001709-TPXREF128" title="The Basic Development Environment"></a><h2>The Basic Development Environment</h2><p>Like CodeWarrior, Xcode is focused on the use of projects, targets, and files. But it also takes advantage of some of the popular user interface features found in iTunes and other Apple consumer applications, such as useful grouping of files and other items, fast searching for items, and a clean, relatively simple interface.</p><p>The development environments for Xcode and CodeWarrior contain the same major components, including project window, text editor, build system, debugger, symbol navigation, find facilities, and help system. One significant difference is that Xcode includes a number of open source components, including the GCC compiler and GDB debugger, as well as other tools written by the UNIX open-source community.</p><p>Behind the user interface, Xcode performs many tasks by launching command-line tools as Mach processes. That allows Xcode to implement features such as distributed and multiprocessor builds, where each GCC compile can be handled by a separate CPU, even on separate machines.</p><a name="//apple_ref/doc/uid/20001709-TPXREF142" title="Some Special Features of Xcode"></a><h3>Some Special Features of Xcode</h3><p>Xcode supports several features with no exact equivalent in CodeWarrior, and others that put a new twist on everyday features. For details on how to use these features, as well as possible limitations, see <em><!--a target="_top" -->Xcode 2.2 User Guide<!--/a--></em>.</p><p>Making life easier for many common tasks:</p><ul class="spaceabove"><li class="li"><p><strong>Fast searching</strong> allows you to quickly find a file, symbol, warning, error, or other item in a list by filtering out any items that don’t match the characters you type. You can search using string matching, regular expressions, or wildcard patterns.</p></li><li class="li"><p><strong>Smart groups</strong> let you intelligently organize your project’s content and data, using groups that match a certain rule or pattern. For example, built-in smart groups include the Errors and Warnings group and the Find Results group.</p></li><li class="li"><p><strong>Inspectors</strong> allow you to examine and edit the objects in your project.</p></li><li class="li"><p><strong>Integrated Mac OS X API documentation</strong> provides full access to all installed Mac OS X documentation, with rapid API searching by language. It includes many searching and viewing options to help find the programming information you need. Automatic detection of documentation updates lets you download the latest technical information from Apple. </p></li></ul><p>For improving your building and debugging experience:</p><ul class="spaceabove"><li class="li"><p><strong>Distributed builds</strong> can dramatically reduce build time for large projects by distributing compiles to available computers on the network.</p></li><li class="li"><p><strong>ZeroLink</strong> shortens link time for development builds and allows you to very quickly relaunch your application after making changes.</p></li><li class="li"><p><strong>Fix and Continue</strong> improves your debugging efficiency by allowing you to change the source in a file, recompile just that file, and run the changed code without stopping the current debugging session. (The Fix icon looks like a tape dispenser.)</p></li></ul><a name="//apple_ref/doc/uid/20001709-TPXREF156" title="The Project Window"></a><h3><a name="//apple_ref/doc/uid/20001709-SW3" title="The Project Window"></a>The Project Window</h3><p><span class="content_text">Figure 1-1</span> shows the Xcode project window for a simple Carbon application.</p><br/><div><a name="//apple_ref/doc/uid/20001709-BABDBAGG" title="Figure 1-1Xcode project window for a simple Carbon application"></a><p><strong>Figure 1-1&nbsp;&nbsp;</strong>Xcode project window for a simple Carbon application</p><img src = "../art/mig_project_window.gif" alt = "Xcode project window for a simple Carbon application" width="615" height="412"></div><br/><p>You can get a complete listing of Xcode features in <em><!--a target="_top" -->Xcode 2.2 User Guide<!--/a--></em>, but the following list highlights some of the most frequently used interface features.</p><ul class="spaceabove"><li class="li"><p>Instead of tabs (as in CodeWarrior and Project Builder), the default project window in Xcode uses a hierarchical list of groups in the Groups &amp; Files list. Xcode includes several different project window layouts, however, including one that provides a tabbed interface to your project's contents.</p></li><li class="li"><p>The contents of the selected item or items in the Groups &amp; Files list are listed in a detail view.</p></li><li class="li"><p>Text you type in the Search field is used to filter items in the detail view. The Search field supports simple string matching, regular expressions, and wildcard patterns. </p></li><li class="li"><p>For source files, the detail view shows build status, SCM status, size, errors, warnings, and so on.</p></li><li class="li"><p> Some of the items that can appear in the Groups &amp; Files list include:</p><ul class="nested"><li class="nested li"><p>The project group, at the top of the Groups &amp; Files list, shows all of the files, frameworks, and libraries included in the project. The previous figure shows the project group "CarbonTest."</p><p>Source groups, identified by yellow folder icons, can contain other source groups. They help you organize the files in your project into more manageable chunks.</p></li><li class="nested li"><p>The Targets group contains all the targets in the project.</p></li><li class="nested li"><p>The Executables group contains all of the executable environments defined in the project. Executable environments specify the executable file that is launched when you run or debug; typically, this corresponds to a product that the project builds. </p></li></ul><p>The following items in the Groups &amp; Files list are smart groups:</p><ul class="nested"><li class="nested li"><p>The Errors and Warnings group lists the errors and warnings generated when you build your project.</p></li><li class="nested li"><p>The SCM group lets you view the project files currently under version control, as well as their current state.</p></li><li class="nested li"><p>The Bookmarks group contains all of the locations you have saved as bookmarks for this project.</p></li><li class="nested li"><p>The Find Results group contains the results of any searches you perform in your project. Each search creates a new entry in this group.</p></li><li class="nested li"><p>The Project Symbols group lists all of the symbols defined in your project.</p></li><li class="nested li"><p>The NIB Files group contains any <code>.nib</code> files used to create your product's user interface.</p></li><li class="nested li"><p>The Implementation Files group contains all of the implementation files in your project, such as those ending in <code>.cpp</code> , <code>.c</code> , and <code>.m</code> .</p></li></ul><p>You can define your own smart groups and the rules for what they contain. User-defined smart groups are indicated with a purple folder icon.</p></li><li class="li"><p>Inspector windows and Info windows handle much of the interesting work, allowing you to easily display and edit project data. (These windows differ in that inspector windows are floating utility windows that track the current selection, while Info windows are standard windows that continue to display information about the same item.)</p><p>Among other things, you can use these windows to:</p><ul class="nested"><li class="nested li"><p>display per-project settings</p></li><li class="nested li"><p>display per-target settings</p><p><span class="content_text">Figure 1-2</span> shows the target inspector. A useful feature of the build settings interface is a section below the build settings table that provides a description of the currently selected build setting. If this section isn’t visible, you can display it by dragging the separator bar.</p><div class="item_figure"><a name="//apple_ref/doc/uid/20001709-BABFCCAD" title="Figure 1-2Inspector window showing Language settings in Build pane"></a><p><strong>Figure 1-2&nbsp;&nbsp;</strong>Inspector window showing Language settings in Build pane</p><img src = "../art/mig_compiler_settings.gif" alt = "Inspector window showing Language settings in Build pane" width="331" height="425"></div></li><li class="nested li"><p>display per-file settings and information, such as location, encoding, tab settings, line endings, and so on</p></li><li class="nested li"><p>select multiple project items—such as files or targets—and change settings on all of them (for settings for which this makes sense)</p></li></ul></li><li class="li"><p>The Find string is persistent across dialogs (and even many Mac OS applications).</p></li><li class="li"><p>Xcode uses shell paths (slash-delimited) exclusively, not colon-delimited paths.</p></li><li class="li"><p>Xcode supports per-file compiler settings.</p></li><li class="li"><p>The Xcode editor supports code completion; as you type identifiers and keywords, Xcode suggests likely matches based on the current context.</p></li></ul><a name="//apple_ref/doc/uid/20001709-SW14" title="Customizing the Environment"></a><h3>Customizing the Environment</h3><p>If your fingers are hard-wired for CodeWarrior keystroke equivalents (or BBEdit, or even MPW), don’t worry. Xcode provides many features you can customize to fit the way you like to work. These include all the standard features you can set up in the Xcode Preferences window, such as indentation style, syntax coloring, Source Code Management (SCM) options, and so on.</p><p>Xcode provides additional control over your environment with the following features:</p><ul class="spaceabove"><li class="li"><p>You can customize Command-key equivalents for menu items, as well as keystroke equivalents for editing tasks, to use the keystrokes you are most familiar with. Xcode provides predefined sets that are compatible with BBEdit, CodeWarrior, and even MPW (Macintosh Programmer’s Workshop, the Apple development environment for Mac OS 9). To learn more about customizing keystroke equivalents, see <span class="content_text"><a href="../../XcodeUserGuide20/Contents/Resources/en.lproj/custom_key_equivalents/custom_key_equivalents.html#//apple_ref/doc/uid/TP40001440-CH260" target="_top">Customizing Key Equivalents</a></span> in <em><!--a target="_top" -->Xcode 2.2 User Guide<!--/a--></em>.</p></li><li class="li"><p>You can select from a number of different project window layouts, to choose the configuration that works best for you. These layouts are: </p><ul class="nested"><li class="nested li"><p>Condensed. This layout provides a project window that contains tabs for Files, Targets, and all other smart groups. You use separate windows for tasks other than project navigation. This layout should be the most familiar to CodeWarrior users.</p></li><li class="nested li"><p>All-In-One. This layout provides a single window for all of the tasks typical of software development, such as debugging, viewing build results, and searching.</p></li><li class="nested li"><p>Default. This layout provides the default Xcode project window, described in <span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-TPXREF156">“The Project Window.”</a></span></p></li></ul><p>For more on project window layouts, see <span class="content_text"><!--a target="_top" -->The Project Window<!--/a--></span> in <em><!--a target="_top" -->Xcode 2.2 User Guide<!--/a--></em>.</p></li><li class="li"><p>You can choose what information Xcode displays in the project window, by customizing the set of smart groups that appear there.  You can rearrange, show, and hide any of the groups that appear in the project window. </p></li><li class="li"><p>You can choose the editors to use for files in your project. You can use the Xcode editor or use an external editor such as BBEdit or Emacs. Or you can choose to open a file with the application chosen for it by the Finder.</p></li><li class="li"><p>You can easily customize the toolbar for any project window, adding or removing items, or choosing the default set.</p></li><li class="li"><p>You can conveniently use shell scripts in Xcode in several ways:</p><ul class="nested"><!--a  --><Item><Para>You can select text in any file and execute it as a shell command.</Para></Item><Item><Para>You can have Xcode run a startup shell script each time you launch it.</Para><Para>A default version of the startup script creates the User Scripts menu from any available menu definition files (which are just shell scripts). Xcode provides default menu definition files that add useful items to the User Scripts menu and demonstrate how to work with menu scripts.</Para><Para>You can customize the built-in startup script and menu definition files, or you can create your own.</Para></Item><Item><Para>Xcode provides a number of built-in script variables and utility scripts you can use in menu scripts or other user scripts.</Para></Item><Item><Para>You can add a shell-file build phase that lets you add the execution of shell script files to the build process for a target. (Select a target and choose Project > New Build Phase > New Run Script Build Phase.)</Para></Item><!--/a--></ul></li></ul><p>For details on how to customize, see <span class="content_text"><!--a target="_top" -->Customizing Xcode<!--/a--></span> in <em><!--a target="_top" -->Xcode 2.2 User Guide<!--/a--></em>.</p><a name="//apple_ref/doc/uid/20001709-TPXREF141" title="Limitations"></a><h2><a name="//apple_ref/doc/uid/20001709-SW12" title="Limitations"></a>Limitations</h2><p>Throughout this document, you will find comparisons between CodeWarrior and Xcode, including differences, issues, and in many cases, alternate approaches. This section lists some Xcode limitations to be aware of, with links to further information where available.</p><ul class="ul"><li class="li"><p>Compile and build speed are greatly improved, and will get faster, but do not yet equal CodeWarrior.</p></li><li class="li"><p>GCC provides limited support for CodeWarrior pragmas.</p><p>See <span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-TPXREF154">“Pragma Statements.”</a></span></p></li><li class="li"><p>There is no support for <code>wchar_t</code> and <code>wstring</code> prior to Mac OS X version 10.3 (Panther).</p><p>See <span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-TPXREF143">“Support for wchar_t and wstring.”</a></span></p></li><li class="li"><p>There is no projectwide graphical tree browser; however, Xcode 2.0 and later include a class modeling tool that you can use to make individual graphical models of your project's classes.</p></li></ul><p>While not strictly a limitation, there are many differences between GCC and the Metrowerks compilers. Information on these differences is provided in many places in this document. For a jumping-off point, see <span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-BAJEGBEG">“The GCC Compiler.”</a></span></p><a name="//apple_ref/doc/uid/20001709-TPXREF140" title="Companion Applications"></a><h2>Companion Applications</h2><p>CodeWarrior provides the Constructor application for designing user interfaces based on the PowerPlant framework. Xcode provides the Interface Builder application for creating graphical user interfaces for Mac OS X applications. Interface Builder works with both Carbon and Cocoa applications and lets you lay out interface objects (including windows, controls, menus, and so on), resize them, set their attributes, and make connections to other objects and to source code. The layout tools in Interface Builder include built-in support for the Aqua interface guidelines. You can, of course, continue to use Constructor even when moving your code to Xcode.</p><p>To learn more about using Interface Builder with Carbon applications, see <em><a href="../../../../Carbon/Conceptual/UnarchivingIOwithIBS/index.html#//apple_ref/doc/uid/TP30001005" target="_top">Unarchiving Interface Objects With Interface Builder Services</a></em> and <em><a href="../../../../Carbon/Reference/Interface_Builder/index.html#//apple_ref/doc/uid/TP30000050" target="_top">Interface Builder Services Reference</a></em>.</p><p>CodeWarrior provides the Profiler application for examining the behavior of a running application and fine-tuning performance. Xcode Tools includes the Shark and Sampler profiling tools. For tracking memory usage and bugs, Xcode provides the MallocDebug application, which helps debug memory problems that you would debug on Mac OS 9 with CodeWarrior’s ZoneRanger. To learn more about performance optimization and available tools, see <em><a href="../../../../Performance/Conceptual/PerformanceOverview/index.html#//apple_ref/doc/uid/TP40001410" target="_top">Performance Overview</a></em>.</p><div class="notebox"><a name="//apple_ref/doc/uid/20001709-DontLinkElementID_13" title="Note"></a><p><strong>Note:</strong>&nbsp;For descriptions of the wide range of development tools available with Xcode, see <span class="content_text"><a href="../../../../MacOSX/Conceptual/OSX_Technology_Overview/Tools/Tools.html#//apple_ref/doc/uid/TP40001067-CH272" target="_top">Mac OS X Developer Tools </a></span>in <em><a href="../../../../MacOSX/Conceptual/OSX_Technology_Overview/index.html#//apple_ref/doc/uid/TP40001067" target="_top">Mac OS X Technology Overview</a></em>, as well as the documents available in the <span class="content_text"><a href="../../../index.html#//apple_ref/doc/uid/TP30000436" target="_top">Tools Documentation</a></span> area.</p></div><a name="//apple_ref/doc/uid/20001709-SW13" title="Header Files"></a><h2>Header Files</h2><p>For a CodeWarrior project, you don’t have to explicitly add header files. Instead, you can add recursive access paths, and as long as the header files are somewhere on a specified path, CodeWarrior will find them. (You may notice that this causes a delay on opening projects and can cause errors if you have different headers with the same name.)</p><p>Xcode also supports recursive search paths; however, it is generally recommended that your project include explicit references to its header files. For example, when you add a <code>.c</code> file to your Xcode project, you don’t typically add a search path for the associated header file. Instead, you drag the actual header file into a group in the Groups &amp; Files list in the project to add a reference to the header. </p><p>The Build pane in the target and project inspector windows includes build settings for Header, Framework, and Library search paths. By default, these paths are empty; access paths defined in your CodeWarrior project are not brought over by the importer. If you specify a search path in one of these build settings, Xcode uses that path to locate header files during compiling and linking. </p><p>To have Xcode search the contents of the entire directory tree located at a given path, select the Recursive option next to that path. This option is not enabled by default when you add a new search path. You should be aware, however, that using recursive search paths can result in longer build times and cause problems if you have multiple files with the same name. For more on using search paths in Xcode, see <span class="content_text"><!--a target="_top" -->Build Settings<!--/a--></span> in <em><!--a target="_top" -->Xcode 2.2 User Guide<!--/a--></em>.</p><a name="//apple_ref/doc/uid/20001709-BAJDIJDB" title="Framework-Style Headers"></a><h2>Framework-Style Headers</h2><p>One important transition in moving to Mac OS X development is the switch from including individual headers to including framework-style headers in your source code files. A framework is a type of bundle that packages shared resources, such as a dynamic shared library and its associated resource files, header files, and reference documentation. An umbrella framework is a framework that includes a number of related frameworks. The Carbon framework (<code>Carbon.framework</code>) is an umbrella framework that contains just one header, <code>Carbon.h</code>. That header in turn includes headers from many additional frameworks, such as Core Services, HIToolbox, and others.</p><p>A framework-style include statement specifies a framework (typically an umbrella framework) and its main header file. For example, a Carbon source file should use the statement <code>#include &lt;Carbon/Carbon.h></code>, rather than separate include statements for each individual header file it may require. Using framework-style includes will help ensure that your project builds correctly and remains reliable over time.</p><div class="notebox"><a name="//apple_ref/doc/uid/20001709-DontLinkElementID_14" title="Note"></a><p><strong>Note:</strong>&nbsp;You can add system frameworks by dragging them into the Groups &amp; Files list of your Xcode project (from <code>/System/Library/Frameworks</code>), or with the Project > Add to Project menu item.</p></div><p>For related information, see <span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-SW13">“Header Files,”</a></span> <span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-BABIIEII">“Precompiled Headers and Prefix Files,”</a></span> <span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-BCIJCHII">“Cross-Development,”</a></span> <span class="content_text"><a href="../mig_bef_converting/migration_before_convert.html#//apple_ref/doc/uid/20001710-TPXREF134">“Use Framework Headers,”</a></span> and <span class="content_text"><a href="../mig_bef_converting/migration_before_convert.html#//apple_ref/doc/uid/20001710-BEHEAEFB">“Use C99 Standard in Language Settings.”</a></span> For more information on frameworks in Mac OS X, see <em><a href="../../../../MacOSX/Conceptual/BPFrameworks/index.html#//apple_ref/doc/uid/10000183i" target="_top">Framework Programming Guide</a></em>.</p><a name="//apple_ref/doc/uid/20001709-BCIJCHII" title="Cross-Development"></a><h2>Cross-Development</h2><p>Cross-development refers to the ability to develop software that can be deployed on, and take advantage of features from, specified versions of Mac OS X, including versions different from the one you are developing on. CodeWarrior provides some support for cross-development for versions of the Mac OS through Universal Interfaces, but those headers have not been updated for recent versions of Mac OS X.</p><p>Xcode supports cross-development for various versions of Mac OS X. You can specify which version of Mac OS X headers and libraries to build with, as well as the earliest Mac OS X system version on which the software will run.</p><p>To use cross-development for a target in an Xcode project, you make two selections:</p><ul class="ul"><li class="li"><p>In the General pane of the inspector window for the project group, you use the Cross-Develop Using Target SDK pop-up to select an OS version to develop for, such as Mac OS X 10.4.0. All targets in the project are built as though you were building in that version of the operating system.</p></li><li class="li"><p>In the Build pane of the inspector window for the target or project, you choose a Mac OS X deployment version, such as 10.2. For this target or project, this specifies the earliest Mac OS X system version on which your software will run.</p></li></ul><p>You can also use the SDK headers and libraries to support cross-development in CodeWarrior projects. For details, see <span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-BABFEJJG">“Maintaining Parallel Projects in Xcode and CodeWarrior.”</a></span></p><p>For detailed documentation on cross-development, see <em><a href="../../cross_development/index.html#//apple_ref/doc/uid/10000163i" target="_top">Cross-Development Programming Guide</a></em>.</p><a name="//apple_ref/doc/uid/20001709-BABIIEII" title="Precompiled Headers and Prefix Files"></a><h2>Precompiled Headers and Prefix Files</h2><p>Precompiled headers are binary files that represent the compiler's intermediate form of the headers required to compile a source file. Generally, all source files in a given target use a large common subset of system and project headers, so by precompiling these headers into intermediate form once and reusing it for many source files, the compiler can build source files more quickly.</p><p>CodeWarrior users must manage precompiled headers manually. In CodeWarrior, you can use a precompiled header interchangeably with a normal header file. It can be included in an <code>#include</code> directive or used as a prefix header in a target's Target Settings. You can create a precompiled header file using the Precompile menu item, or by including a <code>.pch</code> file in your project (you use a <code>#pragma</code> directive in that file to define the name of the precompiled header itself, which usually has a <code>.mch</code> suffix). In many larger projects, developers have separate targets (or even whole projects) that just build common precompiled headers that are shared among multiple projects.</p><p>In Xcode, precompiled headers are generated automatically and invisibly by the development environment. By setting the Prefix Header build setting of a target to your <code>.pch</code> file (or any other header file that contains <code>#include</code> statements for your framework headers and common target headers), Xcode will generate the precompiled header file and use it when compiling every source file in that target. (The Precompile Prefix Header build setting must also be enabled.)</p><p>The precompiled header is regenerated whenever any files it depends on are changed, so you don't need to manually build or maintain the precompiled header.</p><p>You can see the Prefix Header and Precompile Prefix Header build settings in the Build pane in <span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-TPXREF155">Figure 1-3</a></span>. For more information on using precompiled headers in Xcode, see <span class="content_text"><!--a target="_top" -->Optimizing the Edit-Build-Debug Cycle<!--/a--></span> in <em><!--a target="_top" -->Xcode 2.2 User Guide<!--/a--></em>.</p><a name="//apple_ref/doc/uid/20001709-TPXREF154" title="Pragma Statements"></a><h2>Pragma Statements</h2><p>A pragma statement is a directive for providing additional information to the preprocessor or compiler beyond what is conveyed in the language itself. There are a small number of pragma types defined by the C standard; individual compilers may support any number of additional types and values.</p><p>The CodeWarrior compiler supports a number of pragmas, including pragma equivalents for most of the compiler settings you can set in the user interface. It also supports some pragmas you can’t set in the user interface. Some examples of pragmas CodeWarrior supports are <code>#pragma unused</code> and <code>#pragma once</code>. In CodeWarrior, pragmas can turn a feature on and off within an individual compilation unit. For example, you can use the pragma statements <code>#pragma export on</code> and <code>#pragma export off</code> in a source file to bracket any symbols you want to export from a shared library.</p><p>Xcode supports some CodeWarrior-defined pragmas. However, Xcode supplies build settings for many of the features the CodeWarrior compiler supports through pragmas. These settings should be set automatically when you import a CodeWarrior project, but you can also add, delete, or modify build settings. <span class="content_text">Figure 1-3</span> shows some of the Language settings you can set for a target in the Build pane in an inspector window in Xcode.</p><div class="notebox"><a name="//apple_ref/doc/uid/20001709-DontLinkElementID_15" title="Note"></a><p><strong>Note:</strong>&nbsp; When a file is compiled, build settings are passed to the compiler as command line flags. If a GCC compiler option is not available in the Xcode user interface, you can set individual flags with the Other C Flags setting.</p></div><br/><div><a name="//apple_ref/doc/uid/20001709-TPXREF155" title="Figure 1-3Some GCC build settings in an inspector window"></a><p><strong>Figure 1-3&nbsp;&nbsp;</strong>Some GCC build settings in an inspector window</p><img src = "../art/mig_compiler_settings.gif" alt = "Some GCC build settings in an inspector window" width="331" height="425"></div><br/><p>Although language settings can be set on a file, target, or project basis, you cannot use them for inline control of compiler options. As a result, the smallest unit for which you can set a compiler option is a single source file. To modify build settings on a target-wide basis, select the target in the Groups &amp; Files list and open an Info window (by clicking the Info button or by choosing File > Get Info). Select the Build pane, then make your changes.</p><div class="notebox"><a name="//apple_ref/doc/uid/20001709-DontLinkElementID_16" title="Note"></a><p><strong>Note:</strong>&nbsp;You also modify the settings in an inspector window, which you open by holding the Option key and choosing File > Show Inspector.</p></div><p>Xcode provides a different interface for modifying options for a single file (or several files). You can add additional compiler flags for one or more files with the following steps:</p><ol class="ol"><li class="li"><p>Open the target in the Groups &amp; Files list.</p></li><li class="li"><p>Open the Compile Sources build phase.</p></li><li class="li"><p>Select the file (or files) for which you want to modify the settings.</p></li><li class="li"><p>Open an Info window by choosing File > Get Info.</p></li><li class="li"><p>Select the Build pane (shown in <span class="content_text">Figure 1-4</span> for a multiple selection).</p><div class="item_figure"><a name="//apple_ref/doc/uid/20001709-BABDGDCD" title="Figure 1-4Adding compiler flags for one or more files"></a><p><strong>Figure 1-4&nbsp;&nbsp;</strong>Adding compiler flags for one or more files</p><img src = "../art/mig_add_compiler_flags.gif" alt = "Adding compiler flags for one or more files" width="331" height="425"></div></li><li class="li"><p>Add any desired compiler flags. Multiple flags should be separated by spaces.</p></li></ol><p>If your CodeWarrior project follows the common pattern of placing pragmas in a header file that is included by other source files, you won’t have to make changes to individual files—you can just set the corresponding values for an entire target or a subset of files. However, if you have code that uses pragmas to turn settings on and off within a single file, and if you need to maintain that level of control, you may need to break up some files so that code that shares common build settings is in one file.</p><p>For additional information on modifying your source files, see <span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-BABFEJJG">“Maintaining Parallel Projects in Xcode and CodeWarrior.”</a></span> For information on using pragmas with respect to identifying export symbols, see <span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-BABFBHHF">“Exporting Symbols.”</a></span></p><p>For further information on setting per-target and per-file compiler options in Xcode, see <span class="content_text"><!--a target="_top" -->Build Settings<!--/a--></span> in <em><!--a target="_top" -->Xcode 2.2 User Guide<!--/a--></em>. For a list of pragmas supported by GCC, see the sections "Pragmas" in <em><a href="../../../gcc-4.0.1/cpp/index.html#//apple_ref/doc/uid/TP40001839" target="_top">GNU C 4.0 Preprocessor User Guide</a></em> and  "Pragmas Accepted by GCC" in <em><a href="../../../gcc-4.0.1/gcc/index.html#//apple_ref/doc/uid/TP40001838" target="_top">GNU C/C++/Objective-C 4.0.1 Compiler User Guide</a></em>.</p><p>For more information on code changes you may need to make as a result of pragma statements in your CodeWarrior code, see <span class="content_text"><a href="../mig_after_importing/mig_after_importing.html#//apple_ref/doc/uid/20001712-SW2">“Create a Prefix File for PowerPlant.”</a></span></p><a name="//apple_ref/doc/uid/20001709-BABFDBGA" title="C and C++ Libraries"></a><h2><a name="//apple_ref/doc/uid/20001709-SW4" title="C and C++ Libraries"></a>C and C++ Libraries</h2><p>When you create Carbon applications in CodeWarrior, you can link against MSL C and C++ libraries (in debug and nodebug variants) to create CFM-style executables that can run in Mac OS 9 or Mac OS X. There is no system-supplied C library in Mac OS 9, so your application relies on the development environment, which for CodeWarrior, means the MSL libraries.</p><p>In Mac OS X, there are system-supplied C and C++ libraries. The C library comes in static and dynamic variants. The dynamic version is strongly recommended for most software, though you may need to link the static version in certain situations (such as for KEXTs, which must load when the dynamic loader isn’t available). </p><p>Beginning with Mac OS X 10.3.9, the standard C++ library is packaged as a dynamic shared library. In prior versions of Mac OS X, the C++ library is packaged as a static library. Packaging the standard C++ library as a dynamic shared library provides a number of benefits, such as smaller binaries and improved performance. To link against the shared library version, <code>libstdc++.dylib</code>, you must use GCC 4.0. If your application must run on versions of Mac OS X prior to 10.3.9, however, you must link against the static library, <code>libstdc++.a</code> . To learn more about the C++ runtime and using the shared library version of <code>libstdc++</code> , see  <em><a href="../../CppRuntimeEnv/index.html#//apple_ref/doc/uid/TP40001666" target="_top">C++ Runtime Environment Programming Guide</a></em>.</p><p>CodeWarrior also supplies MSL libraries to create Mach-O style executables that run on Mac OS X only. In some cases, the MSL library calls through to the Mac OS X System framework library, and in some cases it provides missing features (such as <code>wchar_t</code> support, not available in Mac OS X prior to Panther).</p><p>If your CodeWarrior project is already building a Mach-O style executable, you should have an easier time in moving it to Xcode. If not, you should consider converting it, as described in <span class="content_text"><a href="../mig_bef_converting/migration_before_convert.html#//apple_ref/doc/uid/20001710-TPXREF101">“Preparing a CodeWarrior Project for Importing.”</a></span> You’ll primarily be changing linker settings, access paths, and precompiled headers. In addition, if you load plug-ins via CFM, you’ll need to rewrite that code to use the CFBundle or CFPlugin APIs.</p><div class="importantbox"><a name="//apple_ref/doc/uid/20001709-DontLinkElementID_17" title="Important:"></a><p><strong>Important:</strong>&nbsp;Static libraries currently will not be linked in Xcode unless they are named according to the format <code>lib*.a</code>. That is, they must start with <code>lib</code> and have the extension <code>.a</code>.</p><p></p></div><p>For related information, see <span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-BAJEGBEG">“The GCC Compiler.”</a></span></p><a name="//apple_ref/doc/uid/20001709-BABDGDBH" title="Runtime and Library Issues"></a><h3>Runtime and Library Issues</h3><p>The following are some runtime and library issues you may encounter in switching from MSL libraries to the Mac OS X C and C++ libraries:</p><ul class="spaceabove"><li class="li"><p>There is no runtime support for <code>wchar_t</code> and <code>wstring</code> prior to Mac OS X version 10.3 (Panther). For details, see <span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-TPXREF143">“Support for wchar_t and wstring.”</a></span></p></li><li class="li"><p>While CodeWarrior supplies nonstandard flags to perform diagnostics on use of the standard template library (STL), Xcode does not include a debug version of the STL.</p></li><li class="li"><p>Some code will be larger when built with the Xcode standard C and C++ libraries because, unlike the MSL library, they do not currently support container optimization for templates.</p></li><li class="li"><p>The standard C library function <code>clock</code> (or <code>ctime</code> for C++) returns a value of type <code>clock_t</code> in units of <code>CLOCKS_PER_SEC</code>, defined in <code>time.h</code>. This constant currently has a value of 100, which results in a low resolution that is inadequate for some tasks. CodeWarrior defines <code>CLOCKS_PER_SEC</code> as 1000000, for microsecond resolution.</p></li><li class="li"><p>The function <code>itoa</code> is not a standard C library function and it is not included in the system libraries provided by Mac OS X. CodeWarrior does supply this function, in the header <code>extras.h</code>. If your code uses this function, you should replace it with <code>printf</code> or some other equivalent function.</p></li></ul><a name="//apple_ref/doc/uid/20001709-TPXREF143" title="Support for wchar_t and wstring"></a><h2>Support for wchar_t and wstring</h2><p>The standard C and C++ wide character type <code>wchar_t</code> and the <code>wstring</code> template class that makes use of it are supported in the system libraries for Mac OS X version 10.3 and later. As a result, you can freely use these data types in software created with Xcode that will run only in Panther and later. However, if you need to use these data types in software that will run in versions of Mac OS X prior to Panther, you should obtain a third-party standard C library, such as the one available from <span class="content_text"><a href="http://www.dinkumware.com" target="_blank">Dinkumware, Ltd.</a></span>.</p><div class="importantbox"><a name="//apple_ref/doc/uid/20001709-DontLinkElementID_18" title="Important:"></a><p><strong>Important:</strong>&nbsp;Although <code>wchar_t</code> and <code>wstring</code> are standards, they are somewhat vaguely defined and ambiguous ones. Mac OS X provides far better support for Wide and Unicode characters through the CFString APIs. Apple strongly recommends using these APIs on Mac OS X, as almost all other Mac OS X frameworks expect wide character strings to be in this format, and none support <code>wchar_t</code> and <code>wstring</code>.</p><p></p></div><p>CodeWarrior supports <code>wchar_t</code> and <code>wstring</code> for CFM applications because they are supported in the MSL C and C++ libraries for CFM. However, because MSL libraries for Mach-O in CodeWarrior do not anticipate <code>wchar_t</code> support in the Apple standard C libraries, <code>wchar_t</code> support is turned off in the MSL Mach-O standard library projects. This means that if you use CodeWarrior in Mac OS X v.10.3 or later, you'll get build errors when you rebuild the CodeWarrior MSL libraries because <code>wchar_t</code> support is turned off but the Mac OS X headers now use <code>wchar_t</code>.</p><p>To resolve this issue, when rebuilding your MSL libraries on Panther, you should select the “Enable wchar_t Support” checkbox in the C/C++ Language settings for the Mach-O library projects.</p><a name="//apple_ref/doc/uid/20001709-BAJEGBEG" title="The GCC Compiler"></a><h2><a name="//apple_ref/doc/uid/20001709-SW5" title="The GCC Compiler"></a>The GCC Compiler</h2><p>CodeWarrior provides a proprietary compiler that supports C and C++ and includes support for Altivec. CodeWarrior and Xcode C and C++ libraries are discussed in <span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-BABFDBGA">“C and C++ Libraries.”</a></span></p><p>Xcode uses the open-source GNU C Compiler, or GCC. When you compile C, C++, Objective-C, or Objective-C++ code in Xcode, you’re using GCC. The default version of GCC for Xcode 2.2 is 4.0. For versions of Xcode earlier than Xcode 2.0, the default version of GCC is 3.3.  If necessary, you can choose from the the available GCC versions by selecting a target in the project window, opening an inspector window, and selecting the Rules pane. There you can use the pop-up menus to view the current system rules and to add rules for which compiler to use for C, C++, and other types of files in that target. For related information, see <span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-BABDFBDB">“More on GCC Compiler Versions.”</a></span></p><div class="notebox"><a name="//apple_ref/doc/uid/20001709-DontLinkElementID_19" title="Note"></a><p><strong>Note:</strong>&nbsp;Versions of the Xcode Tools package prior to Xcode 2.0 also included GCC versions 2.95 and 3.1; these versions are not included with subsequent versions of the tools.</p></div><p>When you import a CodeWarrior project, the rule for processing C files is left unchanged. This means that C files are compiled with the current system version of GCC, which depending on the system, is either 3.3 or 4.0. This document assumes that you will use version 4.0 to build your imported project.</p><p>Compile speed has improved dramatically in GCC 3.3 and 4.0, but does not yet quite equal CodeWarrior. However, Xcode sports features such as distributed and multiprocessor builds, where each compile is handled by a separate CPU, even on separate machines. These features can dramatically reduce build time for large projects. Xcode also provides additional features to improve the overall development process, including ZeroLink and Fix and Continue, described in <span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-TPXREF142">“Some Special Features of Xcode.”</a></span></p><div class="notebox"><a name="//apple_ref/doc/uid/20001709-DontLinkElementID_20" title="Note"></a><p><strong>Note:</strong>&nbsp;You can view the full compile commands, as well as other detailed build information, in a display area in the Build Results window. You can open the Build Results window with Build > Build Results. You can open the display area by clicking the build log button at the bottom of the window's topmost pane.</p></div><p><span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-TPXREF155">Figure 1-3</a></span> shows some GCC build settings in an inspector window for an Xcode target. Build settings in the Xcode user interface are converted to command-line options to GCC when you compile your source code. If you want to use a feature of GCC that isn’t available in the Xcode user interface, you can add flags to the Other C Flags setting. To view this setting, see the detailed steps provided in <span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-TPXREF151">“Inline ASM.”</a></span> Multiple flags should be separated by spaces.</p><p>There are a number of significant differences between GCC and the CodeWarrior compiler. One that you’re likely to notice right away is that GCC has a reputation for strictness, and is likely to generate many warnings for code that may produce few warnings in CodeWarrior. Because C and C++ are very permissive languages, most of these warnings have been found to be useful over the years. Getting a compiler error or warning about suspect code can save days or even weeks of difficult debugging.</p><p>Still, you have options to reduce the number of warnings. To change the warnings for a selected target, open the inspector window, select the Build pane, and choose Warnings under GNU C/C++ Compiler in the Collections menu. You can then select any of the warning settings and see a description for it displayed beneath the list of settings, as shown in <span class="content_text">Figure 1-5</span>.</p><br/><div><a name="//apple_ref/doc/uid/20001709-BABIJAHG" title="Figure 1-5Warnings settings in an inspector window"></a><p><strong>Figure 1-5&nbsp;&nbsp;</strong>Warnings settings in an inspector window</p><img src = "../art/mig_warning_settings.gif" alt = "Warnings settings in an inspector window" width="346" height="463"></div><br/><p>You can also set additional GCC warnings by modifying the Other Warning Flags build setting in the Build pane.</p><a name="//apple_ref/doc/uid/20001709-BABDFBDB" title="More on GCC Compiler Versions"></a><h3><a name="//apple_ref/doc/uid/20001709-SW6" title="More on GCC Compiler Versions"></a>More on GCC Compiler Versions</h3><p>The C++ ABI changed between GCC 4.0 and GCC 3.3 (the default compiler for Xcode 1.5 and earlier). The GCC 3.3 compiler in turn has a different ABI than either the GCC 3.1 compiler (the default compiler for the December 2002 release of the Developer Tools) or the GCC 2.95 compiler (the default compiler for earlier releases of the Developer Tools). All your C++ code, including libraries and frameworks, must be built with the same compiler. Note that you should not use the GCC 4.0 compiler to build C++ programs for versions of Mac OS X prior to 10.3.9. </p><p> IOKit-based device drivers and other kernel extensions built with the GCC 4.0 compiler will run in Mac OS X versions 10.2 through 10.4. You must use GCC 2.95.2 for kernel extensions that need to run on Mac OS X version 10.1.</p><a name="//apple_ref/doc/uid/20001709-TPXREF157" title="Additional Compiler Information"></a><h3>Additional Compiler Information</h3><p>Additional compiler-related differences are described throughout this document, especially in the following sections:</p><ul class="spaceabove"><li class="li"><p><span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-BABFEFCD">“C++ Code in C Files”</a></span></p></li><li class="li"><p><span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-TPXREF151">“Inline ASM”</a></span></p></li><li class="li"><p><span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-BABFDBGA">“C and C++ Libraries”</a></span></p></li><li class="li"><p><span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-BABIIEII">“Precompiled Headers and Prefix Files”</a></span></p></li><li class="li"><p><span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-TPXREF154">“Pragma Statements”</a></span></p></li><li class="li"><p><span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-BCIJCHII">“Cross-Development”</a></span></p></li><li class="li"><p><span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-TPXREF143">“Support for wchar_t and wstring”</a></span></p></li><li class="li"><p><span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-TPXREF148">“Code Differences”</a></span></p></li><li class="li"><p><span class="content_text"><a href="../mig_bef_converting/migration_before_convert.html#//apple_ref/doc/uid/20001710-TPXREF135">“Migrate from MSL to System C and C++ Libraries”</a></span></p></li><li class="li"><p><span class="content_text"><a href="../mig_bef_converting/migration_before_convert.html#//apple_ref/doc/uid/20001710-BEHEAEFB">“Use C99 Standard in Language Settings”</a></span></p></li><li class="li"><p><span class="content_text"><a href="../mig_after_importing/mig_after_importing.html#//apple_ref/doc/uid/20001712-CHDBIGGB">“Make Code Changes for GCC Compatibility”</a></span></p></li><li class="li"><p><span class="content_text"><a href="../mig_after_importing/mig_after_importing.html#//apple_ref/doc/uid/20001712-TPXREF166">“Make Changes to PowerPlant”</a></span></p></li></ul><p>Current documentation for GCC (through version 4.0) is available in <span class="content_text"><a href="../../../index.html#//apple_ref/doc/uid/TP30000436" target="_top">Tools Documentation</a></span>.</p><a name="//apple_ref/doc/uid/20001709-BABFEFCD" title="C++ Code in C Files"></a><h2><a name="//apple_ref/doc/uid/20001709-SW7" title="C++ Code in C Files"></a>C++ Code in C Files</h2><p>GCC is literal in its interpretation of file suffixes. While CodeWarrior applies the C++ preprocessor and parser to C++ and C files alike, GCC will emit errors if C++ code is used in <code>.c</code> files. You can override this by  changing the file's type to a C++ filetype (<code>sourcecode.cpp</code>) in the General pane of the file inspector. As long as the Compile Sources As (GCC_INPUT_FILETYPE) build setting is set to According to File Suffix, changing the filetype will cause Xcode to use the <code>-x c++</code> option when compiling files whose type is a C++ filetype. Any explicitly set value for the Compile Sources As build setting overrides the filetype you specify in the General pane of the file inspector.</p><p>By default, when you import a CodeWarrior project, the Compile Sources As build setting is set to According to File Suffix. However, if you have Force C++ compilation set in your CodeWarrior target settings, the importer in Xcode 2.2 sets the Compile Sources As build setting for that target to <code>sourcecode.cpp.cpp</code>.</p><a name="//apple_ref/doc/uid/20001709-TPXREF151" title="Inline ASM"></a><h2>Inline ASM</h2><p>GCC supports CodeWarrior-style inline asm code. To enable this support, you add the following flag to your build settings:</p><div class="codesample"><table><tr><td scope="row"><pre>-fasm-blocks<span></span></pre></td></tr></table></div><p>When you import a CodeWarrior project that uses inline asm into Xcode, this flag is not set automatically,  so you will have to add it yourself. You can do so with the following steps:</p><ol class="ol"><li class="li"><p>Select a target in the project window.</p></li><li class="li"><p>Open an inspector window like the one shown in <span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-TPXREF155">Figure 1-3</a></span> by clicking the Info button or choosing File > Get Info.</p></li><li class="li"><p>Select the Build pane.</p></li><li class="li"><p>If the GNU C/C++ Compiler settings aren’t visible, select GNU C/C++ Compiler from the Collection menu.</p></li><li class="li"><p>Click the checkbox in the Value column next to the CodeWarrior-Style Inline Assembly setting.</p></li></ol><div class="importantbox"><a name="//apple_ref/doc/uid/20001709-DontLinkElementID_21" title="Important:"></a><p><strong>Important:</strong>&nbsp;There is a setting Allow 'asm', 'inline', 'typeof' in the Language Settings in the Build pane. This setting, which is enabled by default, is not related to CodeWarrior-style inline asm support. It governs the use of the old-style GNU asm statements, which are not actually part of the ISO standard.</p><p></p></div><p>In general, the GCC implementation works the same as the CodeWarrior implementation, and any discrepancies you note should be reported as bugs (see <span class="content_text"><a href="../migration_overview/migration_overview.html#//apple_ref/doc/uid/TP40001286-BAJFBFCH">“Feedback and Mail List”</a></span>). For example, if your project contains hand-tweaked asm code, it should work correctly in the new project, unless your code specifically targets CFM-related features. (CFM refers to the executable architecture supported by the Code Fragment Manager in Mac OS 9.)</p><p> Function calls, such as <code>bl foo</code>, don’t currently work, and are treated as though <code>foo</code> is a label whose definition is missing.</p><p>Calling conventions are generally the same as for CFM, but global variables are not available through the TOC register <code>r2</code>. For instance, in CFM, if <code>aglob</code> is a global, then <code>lwz aglob(r2)</code> works to get the value of <code>aglob</code> into <code>r3</code>. The Mach-O equivalent is complicated, involving multiple internal labels, and at present can’t be handled with inline asm.</p><p>GCC passes the inline asm through to the assembler and doesn’t interpret it, so any errors reported from the asm code come from the assembler. In unusual cases, such as when a typedef has the same name as an op code, GCC may parse the code differently from CodeWarrior. For example, the code in listing <span class="content_text">Listing 1-1</span> will result in warnings and a body with one <code>nop</code> if using CodeWarrior, and a body with two instructions (<code>mr r1,r2</code> and <code>nop 0</code> if using GCC. (This should probably be considered a bug in GCC’s implementation.)</p><a name="//apple_ref/doc/uid/20001709-BABJGEDI" title="Listing 1-1A typedef with the same name as an op code"></a><p class="codesample"><strong>Listing 1-1&nbsp;&nbsp;</strong>A typedef with the same name as an op code</p><div class="codesample"><table><tr><td scope="row"><pre>typedef int mr;<span></span></pre></td></tr><tr><td scope="row"><pre>asm int foo()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre> mr r1,r2;<span></span></pre></td></tr><tr><td scope="row"><pre> nop<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>For a related issue, see <span class="content_text"><a href="../mig_after_importing/mig_after_importing.html#//apple_ref/doc/uid/20001712-TPXREF171">“Inlining Thresholds.”</a></span></p><a name="//apple_ref/doc/uid/20001709-BABDHIBF" title="The Linker"></a><h2>The Linker</h2><p>In CodeWarrior, you can choose from among several linkers in the Target Settings pane. The “Macintosh PowerPC linker” creates executables based on the format specified by the Code Fragment Manager (CFM) architecture. The “Apple Mach-O PowerPC linker” makes use of Apple’s <code>ld</code> linker and <code>libtool</code> command-line tool. The “Mac OS X PowerPC Mach-O linker” also creates Mach-O executables, but uses the Metrowerks Mac OS linker.</p><p>Xcode uses the <code>ld</code> linker, which is designed to work with Mach-O object files, and supports dynamic shared libraries, two-level and flat name spaces, and other features.</p><p>The <code>ld</code> linker supports the automatic stripping of unused (dead) code beginning with the June 2004 release of the Xcode tools. For more information, see <span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-BABCJBJH">“Dead Code Stripping.”</a></span> Using the <code>ld</code> linker may also result in larger binary files than in your CodeWarrior project. You can display man page documentation for the linker in Xcode with Help > Open man page, or in a Terminal window by typing <code>man ld</code>. </p><a name="//apple_ref/doc/uid/20001709-BABCJBJH" title="Dead Code Stripping"></a><h3>Dead Code Stripping</h3><p>The CodeWarrior linker supports dead code stripping (the removal of unused code). Beginning with version 1.5, Xcode also supports dead code stripping. To enable dead code stripping in your project, do the following:</p><ol class="ol"><li class="li"><p>Select a target in the project window.</p></li><li class="li"><p>Open an inspector window like the one shown in <span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-TPXREF155">Figure 1-3</a></span> by clicking the Info button or choosing File > Get Info.</p></li><li class="li"><p>Select the Build pane.</p></li><li class="li"><p>If the Linking settings aren’t visible, select Linking from the Collection menu.</p></li><li class="li"><p>Click the checkbox in the Value column next to the Dead Code Stripping setting.</p></li></ol><p>In versions of Xcode prior to Xcode 1.5, a project may generate errors at link time because it contains unused code that refers to undefined symbols. For more information on this issue, see <span class="content_text"><a href="../mig_after_importing/mig_after_importing.html#//apple_ref/doc/uid/20001712-TPXREF168">“Resolve Undefined Symbols.”</a></span></p><p>You can of course take your own steps to eliminate code you know will never be called. Or, if you have reasons for not stripping certain unused code, you can take steps to avoid exporting symbols for that code. For example, if you create an order file, you can increase the likelihood that dead code in your application will never actually be loaded.</p><p>From a performance standpoint, it is always worthwhile to reduce both your code size and the number of exported symbols. For more information in this document, see <span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-BABFBHHF">“Exporting Symbols.”</a></span> The document <em><a href="../../../../Performance/Conceptual/CodeFootprint/index.html#//apple_ref/doc/uid/10000149i" target="_top">Code Size Performance Guidelines</a></em> contains the following sections:</p><ul class="spaceabove"><li class="li"><p><span class="content_text"><a href="../../../../Performance/Conceptual/CodeFootprint/Articles/ImprovingLocality.html#//apple_ref/doc/uid/20001862" target="_top">“Improving Locality of Reference”</a></span> describes how to create an order file.</p></li><li class="li"><p><span class="content_text"><a href="../../../../Performance/Conceptual/CodeFootprint/Articles/ReducingExports.html#//apple_ref/doc/uid/20001864" target="_top">“Minimizing Your Exported Symbols”</a></span> describes how to reduce the symbols exported by your application.</p></li></ul><p>To learn more about support for dead code stripping in Xcode see “Dead Code Stripping” in the chapter <span class="content_text"><!--a target="_top" -->“Linking”<!--/a--></span> in <em><!--a target="_top" -->Xcode 2.2 User Guide<!--/a--></em>.</p><a name="//apple_ref/doc/uid/20001709-BCIBCHCJ" title="The Information Property List and .plc Files"></a><h2>The Information Property List and .plc Files</h2><p>Any packaged Mac OS X software, including applications, bundles, plug-ins, and frameworks, requires an information property list file named <code>Info.plist</code>. That file contains key-value pairs that specify various information that is used at runtime, such as the version number for the software. This information is used by the application and by Launch Services (an API for launching applications in Mac OS X) as well.</p><p>In CodeWarrior, projects that create packaged Mac OS X software use a <code>.plc</code> file to specify information for the <code>Info.plist</code> file. For example, if you use CodeWarrior project stationery to create a project for a Mach-O based Mac OS X application or a bundled Carbon application, the project includes a default <code>.plc</code> file. CodeWarrior reads the <code>.plc</code> file at build time, follows any included header files or prefix file chains, and creates a property list from it, according to settings you specify in the Property List pane of the target settings window.</p><p>An advantage of this approach is that you can define symbols in header files and include them into both your code and your <code>.plc</code> file. As a result, you can be confident you are using the same data in both your code and your <code>Info.plist</code> file.</p><p>Xcode provides a user interface for directly specifying property list settings, but it does not support conversion of a <code>.plc</code> file into an information property list, so you cannot share symbols between your code and your property list file. However, Xcode does obtain information for the property list from your CodeWarrior project during the import process.</p><p>You supply or modify property list information by opening an Inspector window for a target, and making changes in the Properties pane. Xcode also supports preprocessing of the <code>Info.plist</code> file using the GNU C preprocessor; you can include headers, use conditional statements, and define preprocessor macros for use when preprocessing the file. You can also reference any build settings in effect for the target; Xcode evaluates those build settings and replaces them with the appropriate value at build time. For more information on editing property lists in Xcode, see <em><!--a target="_top" -->Xcode 2.2 User Guide<!--/a--></em>. For details, see <span class="content_text"><a href="../mig_after_importing/mig_after_importing.html#//apple_ref/doc/uid/20001712-TPXREF165">“Move Settings From the .plc File to an Info.plist File.”</a></span></p><a name="//apple_ref/doc/uid/20001709-BCIIHGEH" title="Working With Resources"></a><h2>Working With Resources</h2><p>CodeWarrior and Xcode both work with Resource Manager <code>.r</code> and <code>.rsrc</code> resource files. In CodeWarrior, you can set Rez Options, Derez Options, and Common Options in the Rez target settings pane. In Xcode, you can set Resource Manager settings in the Build pane of a target inspector window. If you drag resources into your Xcode project, or import them as part of a CodeWarrior project, Xcode should place those resources in the Build ResourceManager Resources build phase. Xcode compiles <code>.r</code> files in this build phase and copies any <code>.rsrc</code> files into the product bundle. For more information on build phases in Xcode, see <span class="content_text"><!--a target="_top" -->Build Phases<!--/a--></span> in <em><!--a target="_top" -->Xcode 2.2 User Guide<!--/a--></em>.</p><p>Xcode does not provide a user interface to rez and derez individual files, but the Rez and DeRez tools are available in <code>/Developer/Tools</code> and you can run them from the command line and in scripts. There are man pages for Rez and DeRez, but documentation for the rez language is a bit hard to find. It’s documented in Appendix C of  <span class="content_text"><a href="http://developer.apple.com/tools/mpw-tools/books.html#Building" target="_top">Building and Managing Programs with MPW</a></span>.</p><div class="importantbox"><a name="//apple_ref/doc/uid/20001709-DontLinkElementID_22" title="Important:"></a><p><strong>Important:</strong>&nbsp;Due to a bug in Rez, if output is written to a data-fork file (as it almost always is when building with Xcode), then all <code>.rsrc</code> files included with an include statement must also be data-fork files.</p><p></p></div><p>In Mac OS X and for Carbon applications generally, resources should be put in the data fork of a separate resource file, not in the resource fork of the executable, as described in the section "<em>Move Resources to Data Fork–Based Files</em>" in <em><a href="../../../../Carbon/Conceptual/carbon_porting_guide/index.html#//apple_ref/doc/uid/TP30000991" target="_top">Carbon Porting Guide</a></em>. The primary reason for moving application resources out of resource forks is to enable applications to be seamlessly moved around different file systems without loss of their resources.</p><p>In addition to using <code>.r</code> and <code>.rsrc</code> files for resources, Carbon applications can use Interface Builder resource files (called nib files because they have an extension of <code>.nib</code>). When you create a new project in Xcode, the Carbon Application project template creates a nib-based Carbon application. Interface Builder provides an easy-to-use graphical method for designing and implementing a GUI, so there is potentially a lot to gain by using nib files for your resources. Interface Builder is described in <span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-TPXREF140">“Companion Applications.”</a></span> To learn more about using Interface Builder with Carbon applications, see <em><a href="../../IBTips/index.html#//apple_ref/doc/uid/10000179i" target="_top">Interface Builder</a></em>, <em><a href="../../../../Carbon/Conceptual/UnarchivingIOwithIBS/index.html#//apple_ref/doc/uid/TP30001005" target="_top">Unarchiving Interface Objects With Interface Builder Services</a></em> and <em><a href="../../../../Carbon/Reference/Interface_Builder/index.html#//apple_ref/doc/uid/TP30000050" target="_top">Interface Builder Services Reference</a></em>.</p><p>Mac OS X also provides a very useful mechanism for storing language-dependent resources in localized directories within an application or other bundle. By using APIs such as CFBundle, your application can work with localized resources in a seamless manner. For more information on resources, application packaging, and bundles, see the document <em><a href="../../../../MacOSX/Conceptual/OSX_Technology_Overview/index.html#//apple_ref/doc/uid/TP40001067" target="_top">Mac OS X Technology Overview</a></em>, as well as the document <em><a href="../../../../CoreFoundation/Conceptual/CFBundles/index.html#//apple_ref/doc/uid/10000123i" target="_top">Bundle Programming Guide</a></em>.</p><a name="//apple_ref/doc/uid/20001709-TPXREF133" title="Building Code"></a><h2>Building Code</h2><p>In CodeWarrior, you can have one or more named build targets, each of which specifies a set of files and project settings used to build an output file. The project manager keeps track of project dependencies and calls on the build system to build the current target.</p><p>With Xcode, you also define named targets, containing all the files and instructions required to create a final product. In addition, you can define different build configurations for each target, which allow you to build the target with different build settings without creating a whole new target.</p><p>The following sections describe the Xcode build system and compare various build-related features in CodeWarrior and Xcode. For additional details on building code, such as how to modify build settings, start a build, display the Build Results window, and so on, see <span class="content_text"><!--a target="_top" -->“The Build System”<!--/a--></span> in <em><!--a target="_top" -->Xcode 2.2 User Guide<!--/a--></em>.</p><a name="//apple_ref/doc/uid/20001709-BABIFFBF" title="Native Build System"></a><h3>Native Build System</h3><p>Xcode includes a fast, accurate dependency system built into the IDE (hence “native”). While Xcode fully supports legacy Project Builder projects that use a JAM-based build system, all new projects and targets—including targets imported from CodeWarrior projects—use the native build system.</p><div class="notebox"><a name="//apple_ref/doc/uid/20001709-DontLinkElementID_23" title="Note"></a><p><strong>Note:</strong>&nbsp;In Project Builder version 2.0 and earlier, the dependency analysis among project files was done by an external tool called JAM (“Just Another Make”) developed by Perforce Software. JAM-based targets will continue to be supported in Xcode until native targets support all of the same functionality.</p></div><p>Native targets have certain advantages over JAM targets. Because the dependency checking is done in the IDE itself, it is faster, which means that your builds start faster. In addition, many Xcode features, including Zero Link, Fix and Continue, Distributed Builds, and SDK Support, are only implemented for native targets.</p><p>Native targets use inspector windows for viewing and editing target settings, while JAM targets use an older-style Target Settings window. JAM targets are represented in the Xcode user interface by the traditional bull’s-eye icon, while the icon for a native target varies according to the product type—for example, applications are represented by a stylized “A” icon.</p><div class="notebox"><a name="//apple_ref/doc/uid/20001709-DontLinkElementID_24" title="Note"></a><p><strong>Note:</strong>&nbsp;The Targets group <em>always</em> uses the bull’s-eye icon. Individual targets within the group use the icons as described.</p></div><a name="//apple_ref/doc/uid/20001709-TPXREF153" title="Build Configurations"></a><h3><a name="//apple_ref/doc/uid/20001709-SW1" title="Build Configurations"></a>Build Configurations</h3><p>A build configuration is a variation on a target that lets you build a target using different build settings without creating a whole new target. If you need to create products that differ only in their build settings, you might create one target with several build configuration. If you need to create products that differ in other types of settings (such as build phases or information property list entries), you should create separate targets for each.</p><p>The list of build configuration names is defined at the project level. To add or remove build configurations, select the project source group in the project window, click the Info button to open an inspector window, and select the Configurations pane, which is shown in <span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-BABEHEIG">Figure 1-6</a></span>. By default, new projects created in Xcode contain both Debug and Release build configurations, described below. Projects you import from CodeWarrior have a single build configuration, named Imported CodeWarrior Settings.</p><br/><div><a name="//apple_ref/doc/uid/20001709-BABEHEIG" title="Figure 1-6The Configurations pane"></a><p><strong>Figure 1-6&nbsp;&nbsp;</strong>The Configurations pane</p><img src = "../art/mig_configs.gif" alt = "The Configurations pane" width="345" height="462"></div><br/><p>To add a build configuration to a project, select an existing build configuration and copy it. </p><p>Although build configuration names are defined at the project level, each target in the project, and the project itself, can define a different set of build settings for a build configuration. You edit the build settings in a build configuration in the Build pane of the target or project inspector.  In this pane, select the build configuration you want to edit in the Configuration menu, then add or delete settings and insert or modify values in the list below the menu. You use the minus and plus buttons at the bottom of the list to add or delete settings.</p><p>To select the current build configuration, use the Active Build Configuration pop-up menu in the toolbar of the project or Build Results window or choose Set Active Build Configuration.</p><a name="//apple_ref/doc/uid/20001709-TPXREF129" title="Creating Debug and Non-Debug Products"></a><h3><a name="//apple_ref/doc/uid/20001709-SW8" title="Creating Debug and Non-Debug Products"></a>Creating Debug and Non-Debug Products</h3><p>In Xcode, Debug and Release build configurations typically take the place of CodeWarrior’s Debug and Final targets, respectively. When you create a new project, by default the project contains these two build configurations. You are free to modify their definitions at the target or project levels, or to add other build configurations. By default, the Debug build configuration produces debug symbols and turns off code optimization, while the Release build configuration does the opposite.</p><p>As mentioned in the previous section, projects imported from CodeWarrior contain a single build configuration, called Imported CodeWarrior Settings, which contains the target settings brought over from your CodeWarrior targets. You can easily create Debug and Release build configurations by duplicating the Imported CodeWarrior Settings configuration and customizing each of the new Debug and Release configurations with the appropriate settings.</p><div class="notebox"><a name="//apple_ref/doc/uid/20001709-DontLinkElementID_25" title="Note"></a><p><strong>Note:</strong>&nbsp;If you import a CodeWarrior project that has both Debug and Final targets, the new Xcode project will also have both Debug and Final targets.</p></div><p>In both CodeWarrior and Xcode, you can define a common prefix file that includes all the headers needed by a project to create debug or non-debug products. You can then define separate headers that set required preprocessor definitions (for example, <code>#define debug 1</code>), then include the appropriate header into the prefix file, depending on which type of product you want to build.</p><p>In CodeWarrior, this requires separate prefix files because the only way to set a macro is with a <code>#define</code> statement in a file (you can’t set values on a command line).</p><p>In Xcode, you can take another approach. You can have one common prefix file for all targets. You can then define preprocessor options in the target settings. This allows you, for example, to define a master <code>debug</code> flag you can test for anywhere in your code. Since it’s part of the target settings, the prefix file will be precompiled differently, depending on the target settings for the product.</p><p>In fact, it’s recommended that you delete any redundant targets and move the differentiating flags from the prefix headers to the appropriate build configuration of the primary target.  The targets with the fewest settings are the best candidates to replace with a build configuration.</p><a name="//apple_ref/doc/uid/20001709-BAJGBGDB" title="Automating the Build Process"></a><h3><a name="//apple_ref/doc/uid/20001709-SW9" title="Automating the Build Process"></a>Automating the Build Process</h3><p>CodeWarrior provides a substantial AppleScript dictionary, with terminology that allows some automation of the build process.</p><p>Xcode also has a substantial scripting dictionary, and provides AppleScript terminology for controlling many aspects of the build process. To examine the Xcode terminology, you can:</p><ul class="spaceabove"><li class="li"><p>Drag the Xcode application icon onto Script Editor in the Finder. </p></li><li class="li"><p>Choose File > Open Dictionary in Xcode</p></li><li class="li"><p>Choose File > Open Dictionary in Script Editor</p></li></ul><p>You’ll find classes such as <code>bookmark</code>, <code>breakpoint</code>, <code>source directory</code>, and <code>target dependency</code>, along with events such as <code>build</code> and <code>clean</code>, to name just a few.</p><p>You can also call the <code>xcodebuild</code> tool from a shell window or a script to build a project. The <code>xcodebuild</code> tool reads your project file and builds it just as if you had used the Build command from within Xcode, although there are some differences you should read about in <em><!--a target="_top" -->Xcode 2.2 User Guide<!--/a--></em>.</p><p>In addition, you can use the <code>osascript</code> and <code>osaexecute</code> commands to run AppleScript scripts from a shell window or shell script. These commands can target Xcode or any other scriptable application. You can use the Terminal application, available in <code>/Applications/Utilities</code>, to open shell windows, execute shell scripts, and so on.</p><p>Finally, you can use AppleScript’s <code>do shell script</code> command to launch the <code>xcodebuild</code> command-line tool from an AppleScript script. However, if you’re writing an AppleScript script anyway, it probably makes more sense to use the Xcode scripting terminology.</p><a name="//apple_ref/doc/uid/20001709-TPXREF152" title="Makefiles"></a><h3>Makefiles</h3><p>CodeWarrior has a Makefile Importer wizard to import makefiles.</p><p>The Xcode project importer does not import makefiles, and the IDE has no automated support for setting up a project to follow the rules in a makefile. However, it is often the case that developers don’t necessarily want to convert a makefile into a project, they would just like to use the makefile with a project. Xcode supports that goal with the external target.</p><p>An external target is a target that Xcode doesn’t maintain build rules for. For all other targets, Xcode stores information on how its product should be built and installed. As you add and remove files, Xcode keeps track of how to compile them for you. For a legacy target, you have to maintain that information yourself, usually by creating your own build file.</p><div class="importantbox"><a name="//apple_ref/doc/uid/20001709-DontLinkElementID_26" title="Important:"></a><p><strong>Important:</strong>&nbsp;External targets cannot take advantage of some Xcode features, such as ZeroLink and Fix and Continue.</p><p></p></div><p>You add an external target by choosing Project > New Target and selecting External Target.</p><a name="//apple_ref/doc/uid/20001709-BABFBHHF" title="Exporting Symbols"></a><h2>Exporting Symbols</h2><p>As part of building a shared library, plug-in, or other software that will export symbols, you want to specify which symbols are available to clients of the software. The fewer symbols your software exports, the more quickly it will load at runtime. In addition, you typically do not want to expose internal entry points, due to both competitive and support issues.</p><p>CodeWarrior provides several options for specifying which symbols a shared library will export.</p><ul class="ul"><li class="li"><p>Use an export (or <code>.exp</code>) file. When you run the Make command on a library target, CodeWarrior creates a <code>.exp</code> file containing all the global variables and routines in the project. After creating this file, you can comment out any symbols you don’t want to export, including CodeWarrior runtime symbols. You then add the <code>.exp</code> file to the appropriate target and rebuild the project.</p><div class="notebox"><a name="//apple_ref/doc/uid/20001709-DontLinkElementID_27" title="Note"></a><p><strong>Note:</strong>&nbsp;CodeWarrior also supports the use of a <code>.axp</code> file, which lists symbols that should not be exported. CodeWarrior exports all symbols other than those listed in this file.</p></div></li><li class="li"><p>You can use the pragma statements <code>#pragma export on</code> and <code>#pragma export off</code> to bracket any symbols you want to export. CodeWarrior exports only symbols bracketed by these statements.</p></li><li class="li"><p>Combine the two previous mechanisms. Only the bracketed symbols are placed in the <code>.exp</code> file, which you can still edit as necessary.</p></li></ul><p>You can include your export file in an Xcode project as well, by setting the Exported Symbols File build setting to the name of your export file. Xcode passes the appropriate options to the static linker. </p><div class="notebox"><a name="//apple_ref/doc/uid/20001709-DontLinkElementID_28" title="Note"></a><p><strong>Note:</strong>&nbsp;The static linker also supports the <code>-unexported_symbols_list</code> option to specify a file containing symbols that should not be exported. However, there is currently no built-in build setting in the Xcode interface for setting this option. </p></div><p>You can’t use the pragma statements <code>#pragma export on</code> and <code>#pragma export off</code> to specify export symbols in Xcode because GCC does not support these pragma statements. However, GCC does have its own pragmas for controlling symbol visibility, described in <em><a href="../../CppRuntimeEnv/index.html#//apple_ref/doc/uid/TP40001666" target="_top">C++ Runtime Environment Programming Guide</a></em>.</p><p>Beginning with Xcode 2.2, the importer interprets the Export Symbols setting in your CodeWarrior target. Based on the following values for that setting, the importer configures the corresponding Xcode target differently:</p><ul class="ul"><li class="li"><p>None. The importer enables the Symbols Hidden by Default (GCC_SYMBOLS_PRIVATE_EXTERN) and Inline Functions Hidden (GCC_INLINES_ARE_PRIVATE_EXTERN) build settings for the new Xcode target. When these build settings are enabled, all symbols are declared 'private extern' unless explicitly marked otherwise.</p></li><li class="li"><p>All Globals. The importer disables the Symbols Hidden by Default (GCC_SYMBOLS_PRIVATE_EXTERN) build setting in the new Xcode target. </p></li><li class="li"><p>'Use ".exp" file' or 'Use #pragma and ".exp" file.' The importer sets the Exported Symbols File (EXPORTED_SYMBOLS_FILE) build setting to the path to the first export file that it finds in your CW target. It also enables the Symbols Hidden by Default and Inline Functions Hidden build settings.</p><p>Note that, while CodeWarrior targets may have multiple <code>.exp</code> files, an Xcode target can have only one. If your CW target has more than one export file, the importer uses the first one it encounters and ignores the rest. </p></li></ul><p>The importer does not interpret the Referenced Globals or Use #pragma settings.</p><p>For related information in this document, see <span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-BABDGDBH">“Runtime and Library Issues,”</a></span> <span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-BABCJBJH">“Dead Code Stripping,”</a></span> and <span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-TPXREF154">“Pragma Statements.”</a></span></p><p>For additional information on examining and managing your software’s exported symbols, and on other techniques for producing more efficient code, see <em><a href="../../../../Performance/Conceptual/CodeFootprint/index.html#//apple_ref/doc/uid/10000149i" target="_top">Code Size Performance Guidelines</a></em>. In particular, the section <span class="content_text"><a href="../../../../Performance/Conceptual/CodeFootprint/Articles/ReducingExports.html#//apple_ref/doc/uid/20001864" target="_top">“Minimizing Your Exported Symbols”</a></span> describes how to reduce the symbols exported by your application.</p><a name="//apple_ref/doc/uid/20001709-TPXREF134" title="Debugging"></a><h2><a name="//apple_ref/doc/uid/20001709-SW10" title="Debugging"></a>Debugging</h2><p>Basic debugging is very similar in CodeWarrior and Xcode, though Xcode uses the open source GDB debugger and provides some additional features, such as Fix and Continue (live patching), to make debugging more efficient. Xcode supplies a graphical interface to GDB, but you can also use the command line interface (in place of or in parallel to the UI) to get full access to any GDB feature not supported in the user interface. <span class="content_text">Figure 1-7</span> shows the debugger window stopped in a simple Carbon application. </p><br/><div><a name="//apple_ref/doc/uid/20001709-BABJDAIH" title="Figure 1-7A debug window in Xcode"></a><p><strong>Figure 1-7&nbsp;&nbsp;</strong>A debug window in Xcode</p><img src = "../art/mig_debug_window.gif" alt = "A debug window in Xcode" width="702" height="458"></div><br/><p>For GDB documentation, see <em><a href="../../../gdb/gdb/gdb_toc.html#//apple_ref/doc/uid/TP40000996" target="_top">Debugging with GDB</a></em>.Note that some debugging features are currently unavailable in Xcode: for example, you cannot set event points in the UI.</p><p>In CodeWarrior, “event points” are the general name for a set of actions that the CodeWarrior IDE debugger can perform at a breakpoint (such as perform a test, log a message, play a sound, speak a phrase, or execute a script). A “watch point” is a range of memory that you are watching while debugging to note changes; the debugger stops execution when it notices that a certain range of memory has been changed.</p><p>Beginning with Xcode 2.1, Xcode includes support for both breakpoint actions and watchpoints. Similar to event points, breakpoint actions let you perform an action at a breakpoint. Xcode includes breakpoint actions that let you execute a script, print a message to the console, send a command to the debugger, and more. </p><p>While CodeWarrior supplies nonstandard flags to perform diagnostics on use of the standard template library (STL), Xcode does not include a debug version of the STL. However, Xcode does support breaking on C++ <code>try</code>, <code>catch</code> and <code>throw</code> constructs, and allows stepping through template instantiation.</p><a name="//apple_ref/doc/uid/20001709-CIHGFBJI" title="Prebinding"></a><h2><a name="//apple_ref/doc/uid/20001709-SW11" title="Prebinding"></a>Prebinding</h2><p><strong>Prebinding</strong> is the process of computing at build time the addresses for the symbols imported by libraries and applications, so that less work needs to be performed by the dynamic linker at runtime.</p><div class="notebox"><a name="//apple_ref/doc/uid/20001709-DontLinkElementID_29" title="Note"></a><p><strong>Note:</strong>&nbsp; Prebinding is essential for applications running on Mac OS X version 10.3.3 or earlier. If your application is running on Mac OS X version 10.3.4 or later, you no longer need to prebind your application.</p></div><p>If a user installs your software on a system with a set of libraries that is different than those present when the application was built, the prebinding information cannot be used and application launch is slower. If you use the PackageMaker application to package your software and let users install it with the Installer application, Installer automatically attempts to update prebinding information for the software it installs by running the <code>update_prebinding</code> tool. If your software uses drag-and-drop installation, you can provide instructions for how to run this tool through a Read Me file, printed documentation, or other mechanism.</p><p>Prebinding is only applicable for Mach-O executables. (Mach-O is the native executable format in Mac OS X and is the only format supported by Xcode.) In addition, there are some circumstances where prebinding information cannot be updated or used. For details, see the following:</p><ul class="ul"><li class="li"><p><span class="content_text"><a href="../../../../Performance/Conceptual/LaunchTime/Articles/Prebinding.html#//apple_ref/doc/uid/20001858" target="_top">“Prebinding Your Application”</a></span> in <em><a href="../../../../Performance/Conceptual/LaunchTime/index.html#//apple_ref/doc/uid/10000148i" target="_top">Launch Time Performance Guidelines</a></em>.</p></li><li class="li"><p>The man pages for <code>update_prebinding</code> and <code>redo_prebinding</code>. (You can search for and view man pages in Xcode with Help > Open man page.)</p></li></ul><p>For more information on distributing your software, see <em><a href="../../SoftwareDistribution/index.html#//apple_ref/doc/uid/10000145i" target="_top">Software Delivery Guide</a></em>.</p><a name="//apple_ref/doc/uid/20001709-BABHEHCG" title="Source Trees"></a><h2>Source Trees</h2><p>CodeWarrior supports the use of source trees, a kind of root path commonly used in projects that will be worked on by developers in different locations and on different machines. Source trees can be used to define common access paths and target outputs. Global source trees (defined in the CodeWarrior preferences) apply to all projects, while project source trees (defined in the Target Settings for a project) apply only to files in that project.</p><p>Xcode supports only a global source tree, defined in the Source Trees pane of the Preferences window (though it does also support search paths for headers, libraries, and frameworks, on a project basis).</p><p>When you import a CodeWarrior project (see <span class="content_text"><a href="../mig_importing/migration_importing.html#//apple_ref/doc/uid/20001711-TPXREF110">“Importing a Project”</a></span>), Xcode determines the location of the CodeWarrior root folder (commonly referred to as <code>{Compiler}</code> in CodeWarrior’s access paths). It then adds an entry to the Source Trees list in the Preferences window, with the Setting Name “CodeWarrior,” Display Name “CodeWarrior Folder,” and the specified path. If a Source Tree entry for CodeWarrior already exists, it is overwritten.</p><p>Depending on where CodeWarrior is located, a typical path will look something like <code>/Applications/Metrowerks_CodeWarrior_8.0/Metrowerks CodeWarrior</code>. This CodeWarrior-relative source tree is very useful for building projects that use PowerPlant.</p><div class="notebox"><a name="//apple_ref/doc/uid/20001709-DontLinkElementID_30" title="Note"></a><p><strong>Note:</strong>&nbsp;If your project uses source trees, make sure that everyone working on the project has those source trees defined. (The source trees can point at different places, of course, but the names should be the same.)</p></div><a name="//apple_ref/doc/uid/20001709-TPXREF130" title="Source Control"></a><h2>Source Control</h2><p>CodeWarrior provides a Version Control System (VCS) menu that supports Perforce and other systems through plug-ins. Plug-ins can provide features that are very specific to the particular system, but are not tightly integrated into CodeWarrior itself.</p><p>Xcode takes a different approach. It currently supports three systems: the open source standard Concurrent Versions System (CVS), Subversion, and Perforce. Whichever system you choose, the Source Code Management (SCM) menu has the same commands. The number of supported commands is deliberately kept limited, but the commands are more tightly integrated into the environment. You’ll find the most commonly used source control commands, but no access is provided to more specific (and possibly obscure) commands that are supported only by a particular system. This allows for a cleaner integration; for example, status output is more usefully integrated into the user interface.</p><div class="importantbox"><a name="//apple_ref/doc/uid/20001709-DontLinkElementID_31" title="Important:"></a><p><strong>Important:</strong>&nbsp;Diff and Compare commands in Xcode do not currently deal correctly with Mac-style line endings.</p><p></p></div><a name="//apple_ref/doc/uid/20001709-BAJDGDJG" title="PowerPlant"></a><h2>PowerPlant</h2><p>If you move a project that uses CodeWarrior’s PowerPlant framework to Xcode, you’ll have to build PowerPlant as part of the project. When you import such a project, Xcode should add all the required PowerPlant files to the new Xcode project. You’ll then have to supply a prefix file and make a few minor modifications to the PowerPlant source code to build successfully with GCC 4.0. These steps are described in <span class="content_text"><a href="../mig_after_importing/mig_after_importing.html#//apple_ref/doc/uid/20001712-TPXREF166">“Make Changes to PowerPlant.”</a></span></p><a name="//apple_ref/doc/uid/20001709-BABFEJJG" title="Maintaining Parallel Projects in Xcode and CodeWarrior"></a><h2>Maintaining Parallel Projects in Xcode and CodeWarrior</h2><p>This section provides tips on maintaining parallel projects in Xcode and CodeWarrior that operate on the same code base.</p><a name="//apple_ref/doc/uid/20001709-TPXREF144" title="Executable Format"></a><h3>Executable Format</h3><p>The more similar the CodeWarrior and Xcode projects are, the easier the task will be, so unless you absolutely need a Mac OS 9 product, convert your CodeWarrior project to use the Mach-O executable format (as all Xcode projects must do).</p><p>When you use Mach-O with CodeWarrior, you can choose either the Metrowerks linker or the Apple linker, and choose to use either MSL or the standard Mac OS X libraries. Again, it's simplest to have consistency between your products, so unless you're using specific features of the Metrowerks linker or MSL, it’s recommended that you use the Apple linker and Mac OS X standard libraries.</p><a name="//apple_ref/doc/uid/20001709-TPXREF145" title="Framework and System Headers"></a><h3>Framework and System Headers</h3><p>Most CodeWarrior projects are still built against Universal Interfaces. These headers have not been updated for current versions of Mac OS X, so projects that use them don't have access to all the functions and constants that are available in the latest headers.</p><p>If you convert your project to Mach-O, you'll most likely also move it to using framework-style headers. This means that your source files should include just the Carbon framework header (or any other framework headers you need), rather than the raft of individual header files traditionally used in CarbonLib or Classic development. To include the Carbon framework header, you use a statement like this:</p><div class="codesample"><table><tr><td scope="row"><pre>    #include &lt;Carbon/Carbon.h><span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/20001709-DontLinkElementID_32" title="Note"></a><p><strong>Note:</strong>&nbsp;When you include the Carbon framework header, it in turn includes a number of other framework headers.</p></div><p>If you haven't converted to framework-style headers (or are building for CFM in CodeWarrior, which doesn't allow you to use framework includes), you can use the Xcode SDK Support feature to get access to the headers of the current system (or a past or future version, if you wish). Just change your system access path from <code>{Compiler}MacOS support</code> to <code>/Developer/SDKs/MacOSX10.2.8.sdk/Developer/Headers/CFMSupport</code> (to get the Jaguar headers) and add an access path to <code>/Developer/SDKs/MacOSX10.2.8.sdk/System/Library/CFMSupport</code> (to get the Carbon CFM link libraries). Of course, you can use different SDKs depending on which OS you wish to target, and you can use weak linking as usual to run on older systems.</p><p>You can find additional information on weak linking in <span class="content_text"><a href="../../../../../technotes/tn2002/tn2064.html" target="_top">Technote 2064, “Ensuring Backwards Binary Compatibility—Weak Linking and Availability Macros on Mac OS X”</a></span>.</p><p>See <span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-BCIJCHII">“Cross-Development”</a></span> for information on using SDK support in Xcode.</p><a name="//apple_ref/doc/uid/20001709-TPXREF146" title="Using Precompiled Headers and Prefix Files"></a><h3>Using Precompiled Headers and Prefix Files</h3><p>Because CodeWarrior compiler and Xcode use different precompiled header mechanisms, you'll have to have separate precomps for each environment. You can manage this by using the automatic-precompilation features of both environments; Metrowerks will automatically precompile a header file that ends in <code>.pch</code>, and Xcode automatically precompiles any prefix file. So the recommended way to set this up is as follows. For Xcode:</p><ol class="ol"><li class="li"><p>Create a <code>.pch</code> file that #includes all the headers you want to precompile (framework, project, and utility).</p></li><li class="li"><p>Use that <code>.pch</code> file as the prefix file in the appropriate targets of your project by entering the name in the “Prefix Header” Language setting in the Build pane for each target.</p></li><li class="li"><p>Enable the “Precompile Prefix Header” Language setting in the Build pane for each target.</p></li></ol><p>For CodeWarrior:</p><ol class="ol"><li class="li"><p>In the <code>.pch</code> file, add the following directive:</p><div class="codesample"><table><tr><td scope="row"><pre> #ifdef __MWERKS_<span></span></pre></td></tr><tr><td scope="row"><pre>        #pragma precompile_target "Precomps.mch"<span></span></pre></td></tr><tr><td scope="row"><pre>   #endif<span></span></pre></td></tr></table></div></li><li class="li"><p>Use the filename defined in the previous step (<code>Precomps.mch</code>) as your prefix file in appropriate targets of your project.</p></li><li class="li"><p>Create a CodeWarrior target that contains just the <code>.pch</code> file; when built, this will generate the <code>.mch</code> file.</p></li><li class="li"><p>Make other targets depend on the target that generates the <code>.mch</code> file.</p></li></ol><p>For related information, see <span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-BABIIEII">“Precompiled Headers and Prefix Files.”</a></span></p><a name="//apple_ref/doc/uid/20001709-TPXREF147" title="Property Lists"></a><h3>Property Lists</h3><p>CodeWarrior uses a property list compiler and special property list source files (<code>.plc</code> files) to generate <code>Info.plist</code> files for packages. Xcode uses GUI settings in the target inspector window to set those values, and generates the <code>Info.plist</code> file automatically. If you change property list settings, you'll have to change them in both places; it's worth inserting a comment into your <code>.plc</code> file to remind other people that if they make changes there, they should change the Xcode project file as well.</p><p>For more information on working with property lists, see <span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-BCIBCHCJ">“The Information Property List and .plc Files.”</a></span></p><a name="//apple_ref/doc/uid/20001709-TPXREF148" title="Code Differences"></a><h3>Code Differences</h3><p>While both CodeWarrior and GCC compilers do a good job of implementing standard C and C++ features, they differ on which compiler-specific extensions are supported. You should isolate compiler-specific code using the following preprocessor directives:</p><a name="//apple_ref/doc/uid/20001709-TPXREF150" title="Listing 1-2Preprocessor directives for isolating compiler specific code"></a><p class="codesample"><strong>Listing 1-2&nbsp;&nbsp;</strong>Preprocessor directives for isolating compiler specific code</p><div class="codesample"><table><tr><td scope="row"><pre>#ifdef __MWERKS__<span></span></pre></td></tr><tr><td scope="row"><pre>    // CodeWarrior-only code should go here<span></span></pre></td></tr><tr><td scope="row"><pre>#endif<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#ifdef __GNUC__<span></span></pre></td></tr><tr><td scope="row"><pre>    // GCC-only code should go here<span></span></pre></td></tr><tr><td scope="row"><pre>#endif<span></span></pre></td></tr></table></div><p>The following are some examples of CodeWarrior-only code you should isolate. You’ll find more details on these items in <span class="content_text"><a href="../mig_after_importing/mig_after_importing.html#//apple_ref/doc/uid/20001712-CHDBIGGB">“Make Code Changes for GCC Compatibility”</a></span>:</p><ul class="spaceabove"><li class="li"><p>Most CodeWarrior-defined <code>#pragma</code> directives. Though GCC ignores them, it's good discipline to remind yourself that they're compiler-specific.</p></li><li class="li"><p>Metrowerks-specific extensions to BSD functionality, such as <code>FSp_fopen()</code>, <code>SIOUX</code>, <code>console.h</code>, and so on.</p></li><li class="li"><p>C-style cases and functional casts in an argument list (standards-compliant but not supported in GCC).</p></li><li class="li"><p>Instantiating a <code>struct</code> with a member template within a template definition (standards-compliant but not supported in GCC).</p></li><li class="li"><p><code>#if true</code> (CodeWarrior-specific extension).</p></li><li class="li"><p>Anonymous unused arguments in C function definitions (legal in C99 but unsupported in GCC).</p></li><li class="li"><p>Structs in <code>vararg</code> lists (Metrowerks extension).</p></li><li class="li"><p>Using a const global variable in the definition of another const global (Metrowerks extension).</p></li><li class="li"><p>A class declared as a friend of template specialization that accesses private members.</p></li></ul><p>Some examples of GCC-only code:</p><ul class="spaceabove"><li class="li"><p>GCC inline assembler. GCC 3.3 and 4.0 can assemble CodeWarrior-style inline assembler, but CodeWarrior cannot handle the GCC syntax for inline assembly.</p></li></ul><a name="//apple_ref/doc/uid/20001709-TPXREF149" title="Linking"></a><h3>Linking</h3><p>CodeWarrior offers a choice of using in-code <code>#pragma</code> statements or an <code>.exp</code> file to control which symbols are exported from your end-product libraries; GCC uses only the <code>.exp</code> file.</p><p>For more information on exporting symbols, see <span class="content_text"><a href="migration_differences.html#//apple_ref/doc/uid/20001709-BABFBHHF">“Exporting Symbols.”</a></span></p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../migration_overview/migration_overview.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../mig_bef_converting/migration_before_convert.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2003, 2006 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2006-10-26<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeveloperTools/Conceptual/MovingProjectsToXcode/migration_differences/migration_differences.html%3Fid%3D20001708-5.6&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeveloperTools/Conceptual/MovingProjectsToXcode/migration_differences/migration_differences.html%3Fid%3D20001708-5.6&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeveloperTools/Conceptual/MovingProjectsToXcode/migration_differences/migration_differences.html%3Fid%3D20001708-5.6&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>