<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Shared Environments (IM: F)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING78></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Files-77.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Files-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Files-390.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Files-79.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Files-2.html"><B>Files</B></A> / <BR><DD><A HREF="Files-72.html"><B>Chapter 2 - File Manager</B></A> / <A HREF="Files-73.html"><B>About the File Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING78-0></A>
<H2>Shared Environments<A NAME=MARKER-2-228></A></H2>
 Any operating environment that supports multiple users and multiple access to data or applications is known as a <B>shared environment.</B> A shared environment can be a number of workstations attached to a network as well as a single workstation executing a multi-user operating system such as A/UX.<P>
 The File Manager supports access both to locally mounted volumes and to volumes located on devices attached to remote machines on a network. For example, AppleShare, Apple's file-server application, allows users to share data, applications, and disk storage over a network. System software version 7.0 introduced File Sharing, a local version of AppleShare that allows users to make some or all of the files on a volume available over the network. To do so, a user establishes a volume or directory as a <B>share point,</B> making <BR>it available for use by registered users or guests on the network.<A NAME=MARKER-2-229></A><P>
 It is a virtual certainty that some users will run your application in a shared environment. The File Manager, Chooser, and other system software components cooperate to make access to remote volumes largely transparent to your application. As a result, most applications do not need to accommodate shared environments explicitly. You can read and write files, for instance, regardless of whether they are located on a local or a remote volume.<P>
 If your application performs certain operations on files, however, you might be able to save considerable time by using special shared environment routines. Suppose, for example, that you want to copy a file to another directory on a volume. In the general case, you handle this by reading a buffer of data from the source file and then writing it to the destination file. If the source and destination volumes are remote, however, this technique might involve the copying of a lot of data over the network. To optimize remote file copying, the File Manager provides the PBHCopyFile function, which copies a remote file without sending the data across the network. Similarly, the <CODE>PBHMoveRename</CODE> function allows you to move and optionally rename a file located on a remote volume.<P>
 The File Manager provides routines that allow you to control other aspects of a shared environment, including<A NAME=MARKER-2-231></A><P>
<UL>
<LI>providing multiple users with shared read/write access to files
<LI>locking and unlocking byte ranges within a file to ensure exclusive access to data during updates
<LI>enabling and disabling sharing on local volumes and directories
<LI>getting and setting access privileges for directories
<LI>determining volume mounting and login information so that any volume can be unmounted and remounted easily<P>
</UL>
 <A HREF=#MARKER-9-177>Table 2-8</A> lists the File Manager routines that you can use in a shared environment. Note that all of these are low-level routines.
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><A NAME=MARKER-9-177></A><B>Table 2-8 Shared environment routines</B></CAPTION>
<TH>Routine<TH>Description<TR>
<TD>PBHOpenDeny<TD>Open a file's data fork using the access deny modes.<TR>
<TD>PBHOpenRFDeny<TD>Open a file's resource fork using the access deny modes.<TR>
<TD>PBLockRange<TD>Lock a portion of a shared file.<TR>
<TD>PBUnlockRange<TD>Unlock a previously locked portion of a shared file.<TR>
<TD>PBShare<TD>Establish a volume or directory as a share point.<TR>
<TD>PBUnshare<TD>Remove a share point from a shared environment.<TR>
<TD>PBGetUGEntry<TD>Get a list of users and groups on the local file server.<TR>
<TD>PBHGetDirAccess<TD>Get the access control information for a directory.<TR>
<TD>PBHSetDirAccess<TD>Set the access control information for a directory.<TR>
<TD>PBGetVolMountInfoSize<TD>Get the size of a volume mounting information record.<TR>
<TD>PBGetVolMountInfo<TD>Get volume mounting information.<TR>
<TD>PBVolumeMount<TD>Mount a volume.<TR>
<TD>PBHGetLogInInfo<TD>Get the method used to log on to a shared volume.<TR>
<TD>PBHMapID<TD>Get the name of a user or group from its ID.<TR>
<TD>PBHMapName<TD>Get the ID of a user or group from its name.<TR>
<TD>PBHCopyFile<TD>Copy a file on a remote volume.<TR>
<TD>PBHMoveRename<TD>Move (and perhaps rename) a file on a remote volume.</TABLE>
<P>
 The following sections describe the capabilities provided by these routines.<A NAME=MARKER-2-232></A><P>
<A NAME=HEADING78-13></A>
<H3><A NAME=MARKER-9-233></A>Shared File Access Permissions</H3>
 <A NAME=MARKER-2-234></A>In a shared environment, files can be shared at a file or subfile level. At a file level, a project schedule could be read by many users simultaneously but updated by only one user at a time. At a subfile level, different records of a data base file could be updated by several users at the same time.<P>
 The access modes provided by the standard file-opening routines prove insufficient for shared files. Two additional open functions, <CODE>PBHOpenDeny</CODE> and <CODE>PBHOpenRFDeny</CODE>, allow the ability to deny access as well. These <B>deny modes</B> are cumulative, combining to determine the current access permissions for a file. For instance, if the first opening routine denies reading to others and the second denies writing, both reading and writing are then denied for the file.<A NAME=MARKER-2-235></A><A NAME=MARKER-2-236></A><P>
 <A HREF=#MARKER-9-237>Figure 2-1</A> shows how new access and deny modes are granted or refused according to a file's current access and deny modes. An unshaded square indicates that a new open call with the listed permissions would succeed; otherwise, the new open call would fail.<P>
<B>Figure 2-1  <A NAME=MARKER-9-237></A>Access and deny mode synchronization</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/FM_L-12.jpg"> <p>
 You specify deny modes by setting bits in the <CODE>ioDenyModes</CODE> field of the parameter <BR>block passed to <CODE>PBHOpenDeny</CODE> or <CODE>PBHOpenRFDeny</CODE>. Currently four bits of this field <BR>are meaningful:
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Bit<TH>Meaning<TR>
<TD>0<TD>If set, request read permission<TR>
<TD>1<TD>If set, request write permission<TR>
<TD>4<TD>If set, deny other users read permission to this file<TR>
<TD>5<TD>If set, deny other users write permission to this file</TABLE>
<P>
 The combination of access and deny requests allows four common opening possibilities:<P>
<UL>
<LI><B>Browsing access. </B>You request browsing access by specifying both read and deny-write modes (<CODE>ioDenyModes</CODE> set to $0021). Browsing access is traditional read-only access; it permits multiple readers but no writers. This access mode is useful for shared files that do not change often, such as help files, configuration files, and dictionaries.<A NAME=MARKER-2-238></A>
<LI><B>Exclusive access.</B> You request exclusive access by specifying both read and write access and both deny-read and deny-write access (<CODE>ioDenyModes</CODE> set to $0033). Most applications that are not specifically designed to share file data use this permission setting. An exclusive access opening call succeeds only if there are no existing paths to the file. After a successful opening call, all future attempts to establish access paths to the file are denied until the exclusive-access path is closed.<A NAME=MARKER-2-239></A>
<LI><B>Access as a single writer with multiple readers.</B> You request access as the single writer with multiple readers by specifying both read and write access and deny-write access (<CODE>ioDenyModes</CODE> set to $0023). This access method allows additional users to gain read-only access to browse a document being modified by the initial writer. The writer's application is responsible for range locking the file (by calling <CODE>PBLockRange</CODE>) before writing to it, to prevent reading when the file is inconsistent.<A NAME=MARKER-2-240></A>
<LI><B>Shared access.</B> You request shared access by specifying both read and write access (<CODE>ioDenyModes</CODE> set to $0003). Shared access should be used by applications that support full multi-user access to its documents. Range locking is needed to prevent other users from accessing information undergoing change. Each user must also check for and handle any errors that result from access by other users. You might prefer to use a semaphore to flag records in the document as they are checked out, rather than use range locking exclusively.<A NAME=MARKER-2-241></A><P>
</UL>
 You can open a shared file using either the deny modes described here or the file access permissions described in <A HREF=Files-74.html#MARKER-9-202>"File Manipulation" on page 2-7</A>. If you use the original permissions when you open a file located in a shared directory, the File Manager translates those permissions into the corresponding access and deny modes. The basic rule followed in this translation is to allow a single writer or multiple readers, but not both. The translation from the original permissions to the deny-mode permissions is shown in <A HREF=#MARKER-9-178>Table 2-9</A>. 
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><A NAME=MARKER-9-178></A><B>Table 2-9 Access mode translation</B><A NAME=MARKER-2-179></A></CAPTION>
<TH>HFS permissions<TH>Deny-mode permissions<TR>
<TD><CODE>fsCurPerm</CODE><TD>Exclusive access, or browsing access if exclusive access <BR>is unavailable.<TR>
<TD>fsRdPerm<TD>Browsing access.<TR>
<TD><CODE>fsWrPerm</CODE><TD>Exclusive access.<TR>
<TD><CODE>fsRdWrPerm</CODE><TD>Exclusive access, or browsing access if exclusive access <BR>is unavailable.<TR>
<TD><CODE>fsRdWrShPerm</CODE><TD>Shared access.</TABLE>
<P>
 Notice that <CODE>fsCurPerm</CODE> and <CODE>fsRdWrPerm</CODE> are retried as read-only (browsing access) if exclusive access is not available. In addition, whenever browsing access is requested (that is, when you directly request <CODE>fsRdPerm</CODE>, or when a request for <CODE>fsCurPerm</CODE> or <CODE>fsRdWrPerm</CODE> is retried because exclusive access is not available) and cannot be granted, the AppleShare external file system searches through the open file control blocks (FCBs) for another AFP access path to the file. If an AFP access path to that file is found, a read-only access path is returned that shares the AFP access path.<A NAME=MARKER-2-242></A><A NAME=MARKER-2-243></A><A NAME=MARKER-2-244></A><A NAME=MARKER-2-245></A><P>
<A NAME=HEADING78-27></A>
<H3><A NAME=MARKER-9-246></A><A NAME=MARKER-2-247></A>Directory Access Privileges</H3>
 AppleShare allows users to assign <B>directory access privileges</B> to individual directories, controlling who has access to the files and folders in the directory. A directory may <BR>be kept private, shared by a group of registered users, or shared with all users on <BR>the network.<A NAME=MARKER-2-248></A><P>
 Users are organized into groups. Users can belong to more than one group. Information about users and their privileges is maintained by AppleShare. Each directory has access privileges assigned for each of these three classifications of users: owner, group, and everyone. The following privileges can be assigned:<P>
<UL>
<LI><B>See Folders.</B> A user with this access privilege (also called <B>search privilege</B>) can see other directories in the specified directory.<A NAME=MARKER-2-249></A><A NAME=MARKER-2-250></A>
<LI><B>See Files.</B> A user with this access privilege (also called <B>read privilege</B>) can see the icons and open documents or applications in that directory as well.<A NAME=MARKER-2-251></A><A NAME=MARKER-2-252></A>
<LI><B>Make Changes.</B> A user with this access privilege (also called <B>write privilege</B>) can create, modify, rename, or delete any file or directory contained in the specified directory. Directory deletion requires additional privileges. It is possible to have Make Changes privileges without also having See Folders or See Files privileges; this would allow users to put items into a directory but not view the contents of that directory.<A NAME=MARKER-2-253></A><A NAME=MARKER-2-254></A><P>
</UL>
 For instance, a user might assign privileges to a particular directory allowing the owner to read, write, and search the directory, and allowing everyone else (whether in the group or not) only to search the directory.<P>
 On directories shared using File Sharing, you can also assign <B>blank access privileges.</B> In this case, the File Manager ignores any other access privileges and uses the access privileges of the directory's parent. On the local machine, directories in a shared area have blank access privileges, until set otherwise.<A NAME=MARKER-2-255></A><A NAME=MARKER-2-256></A><P>
<DL>
<DT><B>Note</B>
<DD>You cannot assign blank access privileges to a volume's root directory.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 You can use the <CODE>PBHGetDirAccess</CODE> and <CODE>PBHSetDirAccess</CODE> functions to determine and change the access privileges for a directory. The access privileges are passed in the 4-byte <CODE>ioACAccess</CODE> field of the <CODE>accessParam</CODE> variant of the HFS parameter block passed to these two functions. The 4 bytes are interpreted separately; byte 0 is the high-order byte.
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Byte<TH>Meaning<TR>
<TD>0<TD>User's access privileges<TR>
<TD>1<TD>Everyone's access privileges<TR>
<TD>2<TD>Group's access privileges<TR>
<TD>3<TD>Owner's access privileges</TABLE>
<P>
 <P>
 The bits in each byte encode access privilege information, as illustrated in <A HREF=#MARKER-9-257>Figure 2-2</A>. (The high-order byte is on top, and the high-order bit is on the left.) Note that the user's privileges byte also indicates whether the user owns the directory and whether the directory has blank access privileges.<P>
<B>Figure 2-2  <A NAME=MARKER-9-257></A>Access privileges information in the <CODE>ioACAccess</CODE> field</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/FM_L-15.jpg"> <p>
 If bit 31 is set, then the user is the owner of the specified directory. If bit 28 is set, the specified directory has blank access privileges. If bit 28 is clear, the 3 low-order bits of each byte encode the write, read, and search privileges, respectively. If one of these bits <BR>is set, the directory privileges permit the indicated access to the specified individual.<P>
 The 3 low-order bits of the byte encoding the user's access privilege information are <BR>the logical <CODE>OR</CODE> of the corresponding bits in whichever of the other 3 bytes apply to the user. For example, if the user is the owner of a directory and is in the directory's group, then the 3 low-order bits of the user byte are the logical <CODE>OR</CODE> of the corresponding bits in the other 3 bytes. If, however, the user is not the owner and is not in the directory's group, the user privilege bits have the same values as the corresponding ones in the everyone byte.<P>
 You can use <CODE>PBHSetDirAccess</CODE> to set the low-order 3 bits of all the privileges bytes except the user's privileges byte. In the user's privileges byte, you can set only the blank access privileges bit (bit 28).<P>
<DL>
<DT><B>Note</B>
<DD>Not all volumes support blank access privileges. You can call the <CODE>PBHGetVolParms</CODE> function to determine whether a particular volume supports blank access privileges.<EM></EM><A NAME=MARKER-2-258></A>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING78-45></A>
<H3>Remote Volume Mounting</H3>
 <A NAME=MARKER-2-260></A>Typically, the user mounts remote shared volumes through the Chooser or by opening an alias file. The File Manager in system software version 7.0 and later provides a set of calls for collecting the mounting information from a mounted volume and then using that information to mount the volume again later, without going through the Chooser.<P>
 Ordinarily, before you can mount a volume programmatically, you must record its mounting information while it's mounted. Because the size of the mounting information can vary, you first call the <CODE>PBGetVolMountInfoSize</CODE> function, which returns the <BR>size of the record you'll need to allocate to hold the mounting information. You then allocate the record and call <CODE>PBGetVolMountInfo</CODE>, passing a pointer to the record. <BR>When you want to mount the volume later, you can pass the record directly to the <CODE>PBVolumeMount</CODE> function.<P>
<DL>
<DT><B>Note</B>
<DD>The functions for mounting volumes programmatically are low-level functions designed for specialized applications. Even if your application needs to track and access volumes automatically, it can ordinarily use the Alias Manager, described in the chapter "Alias Manager" in this book. The Alias Manager can record mounting information and later remount most volumes, even those that do not support the programmatic mounting functions.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 The programmatic mounting functions can now be used to mount AppleShare volumes. The functions have been designed so that they can eventually be used to mount local Macintosh volumes, such as partitions on devices that support partitioning, and local or remote volumes managed by non-Macintosh file systems.<A NAME=MARKER-2-261></A><P>
<A NAME=HEADING78-50></A>
<H3><A NAME=MARKER-9-262></A>Privilege Information in Foreign File Systems</H3>
 <A NAME=MARKER-2-263></A>Virtually every file system has its own privilege model, that is, conventions for controlling access to stored files and directories. A number of non-Macintosh file systems support access from a Macintosh computer by mapping their native privilege models onto the model defined by the <B>AppleTalk Filing Protocol (AFP).</B> Most applications that manipulate files in foreign file systems can rely on the intervening software to translate AFP privileges into whatever is required by the remote system.<A NAME=MARKER-2-259></A><A NAME=MARKER-2-269></A><A NAME=MARKER-2-270></A><P>
 The correlation is not always simple, however, and some applications require more control over the files stored on the foreign system. The A/UX privilege model, for example, recognizes four kinds of access: read, write, execute, and search. The AFP model recognizes read, write, deny-read, and deny-write access. If a shell program running on the Macintosh Operating System wants to allow the user to set native A/UX privileges on a remote file, it has to communicate with the A/UX file system using the <BR>A/UX privilege model.<P>
 System software version 7.0 provides two new functions, <CODE>PBGetForeignPrivs</CODE> and <CODE>PBSetForeignPrivs</CODE>, for manipulating privileges in a non-Macintosh file system. These access-control functions were designed for use by shell programs, such as the Finder, that need to use the native privilege model of the foreign file system. Most applications can rely on using shared environment functions, which are recognized by file systems that support the Macintosh privilege model. The new access-control functions do not relieve a foreign file system of the need to map its own privilege model onto the shared environment functions.<P>
 Like all other low-level File Manager functions, the access-control functions exchange information with your application through parameter blocks. The meanings of some fields vary according to the foreign file system used. These fields are currently defined for A/UX, and you can define them for other file systems.<P>
 You can identify the foreign file system through the <CODE>PBHGetVolParms</CODE> function. The attributes buffer introduced in system software version 7.0 for the <CODE>PBHGetVolParms</CODE> function contains a field for the foreign privilege model, <CODE>vMForeignPrivID</CODE>.<A NAME=MARKER-2-271></A><P>
<DL>
<DT><B>Note</B>
<DD>The value of <CODE>vMForeignPrivID</CODE> does not specify whether the remote volume supports the AFP access-control functions. You can determine whether the volume supports the AFP access-control functions by checking the <CODE>bAccessCntl</CODE> bit in the <CODE>vMAttrib</CODE> field.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 A value of 0 for <CODE>vMForeignPrivID</CODE> signifies an HFS volume that supports no foreign privilege models. The field currently has one other defined value.<P>
<PRE>
CONST
   fsUnixPriv = 1;            {A/UX privilege model}
</PRE>
 For an updated list of supported models and their constants and fields, contact Macintosh Developer Technical Support.<P>
 A volume can support no more than one foreign privilege model.<P>
 The access-control functions store information in an HFS parameter block of type <CODE>foreignPrivParam</CODE>. The parameter block can store access-control information in one or both of<P>
<UL>
<LI>a buffer of any length, whose location and size are stored in the parameter block
<LI>4 long words of data stored in the parameter block itself<P>
</UL>
 <A NAME=MARKER-2-273></A><A NAME=MARKER-2-274></A>The meanings of the fields in the parameter block depend on the definitions established by the foreign file system. For example, the A/UX operating system uses the ioForeignPrivBuffer field to point to a 16-byte buffer that describes the access rights for the specified file or directory. The buffer is divided into four fields, as follows:
<TABLE BORDER="0" CELLPADDING=3><TD>Bytes<TD colspan=2>Description<TR>
<TD>0-3<TD colspan=2>The user ID of the owner of the file or directory.<TR>
<TD>4-7<TD colspan=2>The group ID of the owner of the file or directory.<TR>
<TD>8-11<TD colspan=2>Mode bits specifying the type of access available to the owner of the file or directory, the group of the file or directory, and to everyone else. The value in this field is a logical <CODE>OR</CODE> of some of the following octal values:<TR>
<TD>&nbsp;<TD>Value<TD>Meaning<TR>
<TD>&nbsp;<TD>0001<TD>Executable by others.<TR>
<TD>&nbsp;<TD>0002<TD>Writable by others.<TR>
<TD>&nbsp;<TD>0004<TD>Readable by others.<TR>
<TD>&nbsp;<TD>0010<TD>Executable by the group.<TR>
<TD>&nbsp;<TD>0020<TD>Writable by the group.<TR>
<TD>&nbsp;<TD>0040<TD>Readable by the group.<TR>
<TD>&nbsp;<TD>0100<TD>Executable by the owner.<TR>
<TD>&nbsp;<TD>0200<TD>Writable by the owner.<TR>
<TD>&nbsp;<TD>0400<TD>Readable by the owner.<TR>
<TD>&nbsp;<TD>2000<TD>Set group ID on execution.<TR>
<TD>&nbsp;<TD>4000<TD>Set user ID on execution.<TR>
<TD>&nbsp;<TD colspan=2>(Execute privileges on a directory mean that the directory is searchable.) You can also use these octal masks to test or set common acess rights:<TR>
<TD>&nbsp;<TD>Mask<TD>Meaning<TR>
<TD>&nbsp;<TD>0007<TD>Executable, writable, and readable by others.<TR>
<TD>&nbsp;<TD>0070<TD>Executable, writable, and readable by the group.<TR>
<TD>&nbsp;<TD>0700<TD>Executable, writable, and readable by the owner.<TR>
<TD>12-15<TD colspan=2>The active user's access rights. The value in this field is a logical <CODE>OR</CODE> of some of the following octal values:<TR>
<TD>&nbsp;<TD>Value<TD>Meaning<TR>
<TD>&nbsp;<TD>0001<TD>Executable by user.<TR>
<TD>&nbsp;<TD>0002<TD>Writable by user.<TR>
<TD>&nbsp;<TD>0004<TD>Readable by user.<TR>
<TD>&nbsp;<TD>0010<TD>Set if user owns this file or directory.<TR>
<TD>&nbsp;<TD colspan=2>Note that you cannot change the owner of a file or directory using <CODE>PBSetForeignPrivs</CODE>. Accordingly, the value 0010 is meaningful for <CODE>PBGetForeignPrivs</CODE> only.<A NAME=MARKER-9-48></A><A NAME=MARKER-2-181></A><A NAME=MARKER-2-182></A><A NAME=MARKER-2-183></A><A NAME=MARKER-2-184></A><A NAME=MARKER-2-185></A><A NAME=MARKER-2-186></A><A NAME=MARKER-2-187></A></TABLE>
<P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Files-77.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Files-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Files-390.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Files-79.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Files-3.html">&copy; Apple Computer, Inc.</A><br>2 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
