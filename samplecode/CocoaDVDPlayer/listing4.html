<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>CocoaDVDPlayer - /Sources/Controller.m</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/GraphicsImaging/index.html">Graphics & Imaging</a> &gt; <a href="../../samplecode/GraphicsImaging/idxVideo-date.html">Video</a> &gt; <A HREF="javascript:location.replace('index.html');">CocoaDVDPlayer</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">CocoaDVDPlayer</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Sources/Controller.m</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Sources/Bookmark.h</option>
<option value="listing2.html">/Sources/Bookmark.m</option>
<option value="listing3.html">/Sources/Controller.h</option>
<option value="listing4.html">/Sources/Controller.m</option>
<option value="listing5.html">/Sources/ControlWindow.h</option>
<option value="listing6.html">/Sources/ControlWindow.m</option>
<option value="listing7.html">/Sources/main.m</option>
<option value="listing8.html">/Sources/PlaybackTime.h</option>
<option value="listing9.html">/Sources/PlaybackTime.m</option>
<option value="listing10.html">/Sources/VideoWindow.h</option>
<option value="listing11.html">/Sources/VideoWindow.m</option></select>
				</p>
				</form>
				<p><strong><a href="CocoaDVDPlayer.zip">Download Sample</a></strong> (&#147;CocoaDVDPlayer.zip&#148;, 119.9K)<BR>
<strong><a href="CocoaDVDPlayer.dmg">Download Sample</a></strong> (&#147;CocoaDVDPlayer.dmg&#148;, 167.1K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*

File: Controller.m

Abstract: Implementation file for the Controller class in CocoaDVDPlayer, an ADC
Reference Library sample project.

Version: 1.0

IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc.
(&quot;Apple&quot;) in consideration of your agreement to the following terms, and your
use, installation, modification or redistribution of this Apple software
constitutes acceptance of these terms.  If you do not agree with these terms,
please do not use, install, modify or redistribute this Apple software.

In consideration of your agreement to abide by the following terms, and subject
to these terms, Apple grants you a personal, non-exclusive license, under
Apple's copyrights in this original Apple software (the &quot;Apple Software&quot;), to
use, reproduce, modify and redistribute the Apple Software, with or without
modifications, in source and/or binary forms; provided that if you redistribute
the Apple Software in its entirety and without modifications, you must retain
this notice and the following text and disclaimers in all such redistributions
of the Apple Software. Neither the name, trademarks, service marks or logos of
Apple Computer, Inc. may be used to endorse or promote products derived from the
Apple Software without specific prior written permission from Apple.  Except as
expressly stated in this notice, no other rights or licenses, express or
implied, are granted by Apple herein, including but not limited to any patent
rights that may be infringed by your derivative works or by other works in which
the Apple Software may be incorporated.

The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE MAKES NO
WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED
WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN
COMBINATION WITH YOUR PRODUCTS.

IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR
DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF
CONTRACT, TORT (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF
APPLE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Copyright &copy; 2005 Apple Computer, Inc., All Rights Reserved

*/

#import &lt;DVDPlayback/DVDPlayback.h&gt;
#import &quot;Controller.h&quot;


/*
********************************************************************************
**
**    Class: DVDEvent
**
********************************************************************************
*/

/* This is a private class that's used to pass DVD playback event information
from the callback function MyDVDEventHandler (which runs in a thread other than
the main thread) to the method handleDVDEvent, which runs in the main thread and
actually does the work. */

@interface DVDEvent : NSObject
{
  DVDEventCode mEventCode;
  UInt32 mEventData1, mEventData2;
}

- (id) initWithData:(DVDEventCode)eventCode 
  data1:(UInt32)eventData1 
  data2:(UInt32)eventData2;

- (DVDEventCode) eventCode;
- (UInt32) eventData1;
- (UInt32) eventData2;

@end


@implementation DVDEvent

- (id) initWithData: (DVDEventCode)eventCode 
  data1:(UInt32)eventData1 
  data2:(UInt32)eventData2 
{
  [super init];
  mEventCode = eventCode;
  mEventData1 = eventData1;
  mEventData2 = eventData2;
  return self;
}


- (DVDEventCode) eventCode { return mEventCode; }
- (UInt32) eventData1 { return mEventData1; }
- (UInt32) eventData2 { return mEventData2; }

@end


/*
********************************************************************************
**
**    Class: Controller
**
********************************************************************************
*/

/* These methods are used inside this file only. Instead of declaring them in
Controller.h, we declare them here in a category that extends the class. */

@interface Controller (InternalMethods)

- (BOOL) searchMountedDVDDisc;
- (BOOL) hasMedia;
- (BOOL) openMedia:(NSString *)inPath isVolume:(BOOL)isVolume;

- (UInt16) setAudioVolume:(BOOL)up;
- (int) displayAlertWithMessage:(NSString *)msgKey withInfo:(NSString *)infoKey;

- (void) beginSession;
- (void) endSession;
- (void) closeMedia;
- (void) deviceDidMount:(NSNotification *)notification;
- (void) handleDVDEvent:(DVDEvent *)event;
- (void) handleDVDError:(DVDErrorCode)errorCode;
- (void) machineDidWake:(NSNotification *)notification;
- (void) machineWillSleep:(NSNotification *)notification;
- (void) logMediaInfo;
- (void) resetUI;

void MyDVDErrorHandler (
  DVDErrorCode inErrorCode, 
  UInt32 inRefCon);

void MyDVDEventHandler (
  DVDEventCode inEventCode, 
  UInt32 inEventData1, 
  UInt32 inEventData2, 
  UInt32 inRefCon);

@end


@implementation Controller

/* Our init method defines our initial state and registers for
notifications. The DVD playback session is initialized later, in the method
applicationDidFinishLaunching. */

- (id)init
{
  [super init];
  
  mBookmarks = [[NSMutableArray alloc] init];
  mDVDState = kDVDStateUnknown;
  mEventCallBackID = 0;
  mVolumePath = nil;

  /* register for several notifications posted to the shared workspace
  notification center */

  NSNotificationCenter *center = 
    [[NSWorkspace sharedWorkspace] notificationCenter];

  [center addObserver:self 
    selector:@selector(deviceDidMount:) 
    name:NSWorkspaceDidMountNotification 
    object:NULL];
    
  [center addObserver:self 
    selector:@selector(machineWillSleep:)
    name:NSWorkspaceWillSleepNotification 
    object:NULL];
    
  [center addObserver:self 
    selector:@selector(machineDidWake:)
    name:NSWorkspaceDidWakeNotification 
    object:NULL];


  /* make sure we're the delegate of the NSApplication instance */
  [[NSApplication sharedApplication] setDelegate:self];

  return self;
}


/* The dealloc message is normally received when our creator releases us.
Cocoa doesn't seem to do this automatically when the application terminates,
so we release ourself in the method applicationWillTerminate. */

- (void) dealloc 
{
  [mBookmarks release];
  [[[NSWorkspace sharedWorkspace] notificationCenter] removeObserver:self];
  [[NSNotificationCenter defaultCenter] removeObserver:self];
  [super dealloc];
}


/* The deviceDidMount notification is received when the system mounts a
removable volume. We registered for this notification in our init method. If no
media is playing, we naively assume the user has inserted a new DVD disc and
respond by sending the openMedia message. No harm is done if the volume is not a
DVD, just a few wasted cycles. */

- (void) deviceDidMount:(NSNotification *)notification 
{
  if (mDVDState != kDVDStatePlaying)
  {
    NSString *devicePath = 
      [[notification userInfo] objectForKey:@&quot;NSDevicePath&quot;];
    NSLog(@&quot;Device did mount: %@&quot;, devicePath);

    /* DVD volumes have a VIDEO_TS media folder at the root level */
    NSString *mediaPath = [devicePath stringByAppendingString:@&quot;/VIDEO_TS&quot;];

    [self openMedia:mediaPath isVolume:YES];
  }
}


/* The machineWillSleep notification is received when the system is about to
sleep. We registered for this notification in our init method. We respond
by notifying DVD Playback Services. */

- (void) machineWillSleep:(NSNotification *)notification 
{
  OSStatus result = DVDSleep();
  NSAssert1 (!result, @&quot;DVDSleep returned %d&quot;, result);
}


/* The machineDidWake notification is received when the system is no longer 
sleeping. We registered for this notification in our init method. We respond by
notifying DVD Playback Services. */

- (void) machineDidWake:(NSNotification *)notification 
{
  OSStatus result = DVDWakeUp();
  NSAssert1 (!result, @&quot;DVDWakeUp returned %d&quot;, result);
}


/* This method is declared in the NSMenuValidation protocol. As the delegate of
the application object, we get a validateMenuItem message whenever the user
displays one of the CocoaDVDPlayer menus. We respond by changing the appearance
of several menu items, based on our state. */

- (BOOL) validateMenuItem:(NSMenuItem *)inItem 
{
  SEL action = [inItem action];
  
  /* File menu */

  if (action == @selector(onMediaFolder:)) {
    if ([self hasMedia] == NO) {
      [inItem setTitle:@&quot;Open Media Folder...&quot;];
      [inItem setKeyEquivalent:@&quot;o&quot;];
    }
    else {
      [inItem setTitle:@&quot;Close Media Folder&quot;];
      [inItem setKeyEquivalent:@&quot;w&quot;];
    }
  }

  /* Controls menu */

  if (action == @selector(onMute:)) {
    Boolean isMuted;
    DVDIsMuted (&amp;isMuted);
    if (isMuted)
      /* display check mark */
      [inItem setState: NSOnState];
    else
      /* hide check mark */
      [inItem setState: NSOffState];
  }

  /* Window menu */

  if (action == @selector(onShowController:)) {
    if ([mControlWindow isVisible]) 
      [inItem setTitle:@&quot;Hide Controller&quot;];
    else 
      [inItem setTitle:@&quot;Show Controller&quot;];
  }

  /* always enable the menu item */
  return YES;
}


/* The setAudioVolume message is sent by the two action methods onVolumeUp
and onVolumeDown, in response to a user request to increase or decrease the
audio level. The audio level is an integer in the range minLevel (0) to maxLevel
(255). We change the level by an increment of 16, which is 1/16 of the total
range. */

- (UInt16) setAudioVolume:(BOOL)up 
{
  /* get range and current audio level */
  UInt16 minLevel, curLevel, maxLevel;
  DVDGetAudioVolumeInfo (&amp;minLevel, &amp;curLevel, &amp;maxLevel);

  /* default action is to maintain the current level */
  UInt16 newLevel = curLevel;

  /* compute how much we are going to change */
  UInt16 delta = (maxLevel - minLevel + 1) / 16;

  if (up) {
    /* compute the next level in the up direction, clamping the value to maxLevel */
    newLevel = MIN(curLevel + delta, maxLevel);
  }
  else {
    /* compute the next level in the down direction, clamping the value to minLevel */
    newLevel = MAX(curLevel - delta, minLevel);
  }

  /* set the new audio level */
  OSStatus result = DVDSetAudioVolume (newLevel);
  NSAssert1 (!result, @&quot;DVDSetAudioVolume returned %d&quot;, result);

  /* return the new level, which we use to adjust the audio slider */
  return newLevel;
}


/* After the application finishes launching, we search for mounted volumes that
might be DVD media. We attempt to open each volume for playback. We can open
only one media folder at a time, so we stop when we succeed. */

- (BOOL) searchMountedDVDDisc
{
  BOOL foundDVD = NO;

  /* get an array of strings containing the full pathnames of all
  currently mounted removable media */
  NSArray *volumes = [[NSWorkspace sharedWorkspace] mountedRemovableMedia];

  int i, count = [volumes count];
  for (i = 0; i &lt; count; i++)
  {
    /* get the next volume path, and append the standard name for the
    media folder on a DVD-Video volume */
    NSString *path = [[volumes objectAtIndex:i] stringByAppendingString:@&quot;/VIDEO_TS&quot;];

    foundDVD = [self openMedia:path isVolume:YES];

    if (foundDVD) {
      /* we just opened a DVD volume */
      break;
    }
  }

  return foundDVD;
}


/* This method displays a modal alert panel with a short and long text
message. Both messages should be stored in a Localizable.strings file inside
the application bundle. You pass in the two string keys that correspond to the
text you want to display. */

- (int) displayAlertWithMessage:(NSString *)msgKey withInfo:(NSString *)infoKey
{
  NSString *messageText = nil;
  NSString *informativeText = nil;
  NSBundle *bundle = [NSBundle bundleForClass:[self class]];

  if (bundle) {
    messageText = [bundle localizedStringForKey:msgKey 
      value:@&quot;No translation&quot; table:@&quot;Localizable&quot;];
  
    informativeText = [bundle localizedStringForKey:infoKey
      value:@&quot;No translation&quot; table:@&quot;Localizable&quot;];
  }

  NSAlert *alert = [[NSAlert alloc] init];
  [alert setAlertStyle: NSCriticalAlertStyle];
  [alert setMessageText: messageText];
  [alert setInformativeText: informativeText];
  int result = [alert runModal];
  [alert release];
  return result;
}


/* This method starts a new playback session, registers our DVD event and DVD
error handlers, and defines the rate at which timer events arrive. */

- (void) beginSession
{
  /* start a new playback session */

  NSLog(@&quot;Step 1: Begin Session&quot;);

  OSStatus result = DVDInitialize();
  if (result != noErr) {
    /* we can't do anything useful now, so we handle the error and exit */
    NSLog(@&quot;DVDInitialize returned %d&quot;, result);
    if (result == kDVDErrorInitializingLib) {
      /* notify user that another client is using the framework */
      [self displayAlertWithMessage:@&quot;frameworkBusy&quot; withInfo:@&quot;frameworkBusyInfo&quot;];
    }
    [NSApp terminate:self];
  }

  /* install our handler for playback events */

  DVDEventCode eventCodes[] = {
    kDVDEventDisplayMode, 
    kDVDEventError,
    /* registering for and handling this event makes the use of
    DVDGetState unnecessary */
    kDVDEventPlayback, 
    kDVDEventPTT, 
    kDVDEventTitle, 
    kDVDEventTitleTime,
    kDVDEventVideoStandard, 
  };

  result = DVDRegisterEventCallBack (
    MyDVDEventHandler, 
    eventCodes, 
    sizeof(eventCodes)/sizeof(DVDEventCode), 
    (UInt32)self, 
    &amp;mEventCallBackID);

  NSAssert1 (!result, @&quot;DVDRegisterEventCallBack returned %d&quot;, result);

  /* install a handler for unrecoverable errors */

  result = DVDSetFatalErrorCallBack (MyDVDErrorHandler, (UInt32) self);
  NSAssert1 (!result, @&quot;DVDSetFatalErrorCallBack returned %d&quot;, result);

  /* Change the period for the recurring kDVDEventTitleTime event to 1000
  milliseconds. This makes it more likely that the playback time advances at
  least one second on each update. */

  result = DVDSetTimeEventRate (1000);
  NSAssert1 (!result, @&quot;DVDSetTimeEventRate returned %d&quot;, result);
}


/* This method determines whether a specified path represents a valid DVD-Video
media folder. As a side effect, we also pass back the FSRef to the folder. The
caller is responsible for allocating the FSRef. */

- (BOOL) isValidMedia:(NSString *)inPath folder:(FSRef *)fileRefP
{
  BOOL isDir;
  Boolean isValid = false;
  NSFileManager *manager = [NSFileManager defaultManager];
  if ([manager fileExistsAtPath:inPath isDirectory:&amp;isDir] &amp;&amp; isDir)
  {
    const char *cPath = [inPath cStringUsingEncoding:NSASCIIStringEncoding];
    // NSLog(@&quot;checking %@&quot;, inPath);
    OSStatus result = FSPathMakeRef ((UInt8*)cPath, fileRefP, NULL);
    if (result == noErr) {
      DVDIsValidMediaRef (fileRefP, &amp;isValid);
    }
  }

  return isValid;
}

/* We send ourself the openMedia message: (1) when the application launches and
finds removable media, (2) when the deviceDidMount notification is received, or
(3) when the user chooses the menu item Open Media Folder and selects a folder
to open. In cases 1 and 2, we call DVDOpenMediavolume. In case 3, we always call
DVDOpenMediaFile even if the folder is actually on a DVD disc volume. */

- (BOOL) openMedia:(NSString *)inPath isVolume:(BOOL)isVolume
{
  FSRef fileRef;
  BOOL mediaIsOpen = NO;

  if ([self isValidMedia:inPath folder:&amp;fileRef])
  {
    OSStatus result;

    if ([self hasMedia] == YES) {
      [self closeMedia];
    }

    if (isVolume) {
      result = DVDOpenMediaVolume (&amp;fileRef);
      NSAssert1 (!result, @&quot;DVDOpenMediaVolume returned %d&quot;, result);
      if (result == noErr) {
        mVolumePath = inPath;
        [mVolumePath retain];
      }
    }
    else {
      result = DVDOpenMediaFile (&amp;fileRef);
      NSAssert1 (!result, @&quot;DVDOpenMediaFile returned %d&quot;, result);
    }

    if (result == noErr) {
      NSLog(@&quot;Step 5: Open Media&quot;);
      NSLog(@&quot;Media Folder: %@&quot;, inPath);
      mediaIsOpen = YES;
      [self logMediaInfo];
    }

    if (result == kDVDErrordRegionCodeUninitialized) {
      /* The drive region code has not been initialized. Refer to the
      readme file for information on handling this situation. */
      [self displayAlertWithMessage:@&quot;noRegionCode&quot; withInfo:@&quot;noRegionCodeInfo&quot;];
      [NSApp terminate:self];
    }
  }

  return mediaIsOpen;
}


/* We send ourself the closeMedia message (1) when a media folder is open and
the user closes the folder, (2) when the user selects a new media folder to open
and another media folder is already open, or (3) when the session is ending. */

- (void) closeMedia 
{
  if ([self hasMedia] == NO)
    return;

  NSLog(@&quot;Step 7: Close Media&quot;);

  if (mVolumePath) {
    OSStatus result = DVDCloseMediaVolume();
    NSAssert1 (!result, @&quot;DVDCloseMediaVolume returned %d&quot;, result);
    [mVolumePath release];
    mVolumePath = nil;
  }
  else {
    OSStatus result = DVDCloseMediaFile();
    NSAssert1 (!result, @&quot;DVDCloseMediaFile returned %d&quot;, result);
  } 

  /* clear all information in Controller window */
  [self resetUI];

  /* delete any bookmarks */
  [mBookmarks removeAllObjects];
}


/* If a playback session is active, this method closes media, unregisters the
event callback, and ends the session. We send ourself the endSession message
when the application is about to terminate. */

- (void) endSession
{
  /* mEventCallBackID is non-zero only if a session is active */
  if (mEventCallBackID) 
  {
    [self closeMedia];
    NSLog(@&quot;Step 8: End Session&quot;);
    DVDUnregisterEventCallBack (mEventCallBackID);
    OSStatus result = DVDDispose();
    NSAssert1 (!result, @&quot;DVDDispose returned %d&quot;, result);
    mEventCallBackID = 0;
  }
}


/* This method clears the title number, scene number, and playing time in the
Controller window. We send ourself the resetUI message (1) when the application
is finished launching, (2) when we close a media folder, or (3) when the user
clicks the Stop button twice in succession. */

- (void) resetUI 
{
  [mTitleText setStringValue:@&quot;-&quot;];
  [mSceneText setStringValue:@&quot;-&quot;];
  [mTimeText setTimeElapsed:0 timeRemaining:0];
}


/* This method shows how to get information about the open media and the DVD
drive. The media ID is generated by DVD Playback Services and is not stored
inside the media itself. CocoaDVDPlayer does not implement the &quot;Change Drive
Region Code&quot; feature, but the user may want to know what the current drive
region code is and how many changes remain. */

- (void) logMediaInfo 
{
  if ([self hasMedia] == NO)
    return;

  /* retrieve and display the 64-bit media ID */

  DVDDiscID id;
  DVDGetMediaUniqueID (id);
  unsigned x1 = *(unsigned *)&amp;id[0];
  unsigned x2 = *(unsigned *)&amp;id[4];
  NSLog(@&quot;Media ID: %#.8x%.8x&quot;, x1, x2);

  /* retrieve and display region code information */

  DVDRegionCode discRegions = kDVDRegionCodeUninitialized;
  DVDRegionCode driveRegion = kDVDRegionCodeUninitialized;
  SInt16 numChangesLeft = -1;
  DVDGetDiscRegionCode (&amp;discRegions); 
  DVDGetDriveRegionCode (&amp;driveRegion, &amp;numChangesLeft);
  NSLog(@&quot;Disc Regions: 0x%x&quot;, discRegions);
  NSLog(@&quot;Drive Region: 0x%x&quot;, driveRegion);
  NSLog(@&quot;Changes Left: %d&quot;, numChangesLeft);

  /* DVD Playback Services checks for a region match whenever you open
  media, so this code is redundant. The code is included here to show how
  it's done. */

  if ((~driveRegion &amp; ~discRegions) != ~driveRegion) {
    NSLog(@&quot;Warning: region code mismatch&quot;);
  }
} 

/* This method is a wrapper around the DVDHasMedia function. */

- (BOOL) hasMedia 
{
  Boolean hasMedia = FALSE;
  OSStatus result = DVDHasMedia (&amp;hasMedia);
  NSAssert1 (!result, @&quot;DVDHasMedia returned %d&quot;, result);
  if (hasMedia) { return YES; }
  else { return NO; }
} 


/* This is our DVD event callback function. It's always called in a thread other
than the main thread. We need to handle the event in the main thread because we
may want to update the UI, which involves drawing. Therefore we pass the event
information to the handleDVDEvent method, which runs in the main thread and
actually does the work. Cocoa requires that we package the information inside an
object. */

void MyDVDEventHandler (
  DVDEventCode inEventCode, 
  UInt32 inEventData1, 
  UInt32 inEventData2, 
  UInt32 inRefCon
) 
{
  Controller *controller = (Controller *)inRefCon;

  /* decouple the event from the callback thread */
  DVDEvent *dvdEvent = [[DVDEvent alloc] initWithData:inEventCode 
    data1:inEventData1 
    data2:inEventData2];

  [controller performSelectorOnMainThread:@selector(handleDVDEvent:) 
    withObject:dvdEvent 
    waitUntilDone:FALSE];

  [dvdEvent release];
}

/* This method does the work of handling the DVD events that we registered to
receive in the beginSession method. */

- (void) handleDVDEvent:(DVDEvent *)event 
{
  [event retain];

  switch ([event eventCode]) {
    case kDVDEventTitleTime: {
      [mTimeText setTimeElapsed: [event eventData1] 
        timeRemaining: ([event eventData2] - [event eventData1])];
      break;
    }
    case kDVDEventTitle: {
      [mTitleText setIntValue:[event eventData1]];
      [mVideoWindow setWindowSize:kVideoSizeCurrent];
      break;
    }
    case kDVDEventPTT: {
      [mSceneText setIntValue:[event eventData1]];
      // NSLog(@&quot;Scene changed to %d&quot;, [event eventData1]);
      break;
    }
    case kDVDEventError:
      [self handleDVDError:[event eventData1]];
      break;

    case kDVDEventPlayback: {
      mDVDState = [event eventData1];
      // NSLog(@&quot;DVD state changed to %d&quot;, mDVDState);
      break;
    }
    case kDVDEventVideoStandard:
    case kDVDEventDisplayMode: {
      [mVideoWindow setWindowSize:kVideoSizeCurrent];
      break;
    }
  }

  [event release];
}


/* This function and method handle the fatal error event that we registered to
receive in the beginSession method. Typically a fatal error means an I/O problem
such as a damaged disc has made it impossible to continue with playback. You
should always implement this callback and respond by ending the playback
session. */

void MyDVDErrorHandler (DVDErrorCode inErrorCode, UInt32 inRefCon)
{
  Controller *controller = (Controller *)inRefCon;
  [controller handleDVDError:inErrorCode];
}

- (void) handleDVDError:(DVDErrorCode)errorCode
{
  NSLog(@&quot;fatal error %d&quot;, errorCode);
  [NSApp terminate:self];
}


/*
********************************************************************************
**
**    NSApplication delegate methods
**
********************************************************************************
*/

/* As the delegate of NSApp (the NSApplication instance), we're automatically
registered to receive these notifications. We use them to begin and end the
playback session cleanly. */

- (void)applicationDidFinishLaunching:(NSNotification *)notification 
{
  [self beginSession];
  [self resetUI];
  [mVideoWindow setupVideoWindow];
  [self searchMountedDVDDisc];
}


/* Elsewhere in this file, we send ourself the terminate message when an
unrecoverable error occurs. To ensure that we also receive the
applicationWillTerminate message, we need to indicate that it's all right to
quit immediately. */

- (NSApplicationTerminateReply) applicationShouldTerminate:(NSApplication *)sender
{
  return NSTerminateNow;
}


/* When this method is called, the application is about to terminate in response
to a user action or because an unrecoverable error occurred. */

- (void)applicationWillTerminate:(NSNotification *)notification
{  
  /* end the playback session */
  [self endSession];

  /* ensure that our dealloc method is called */
  [self release];
}


/*
********************************************************************************
**
**    UI actions
**
********************************************************************************
*/

#pragma mark Controller UI Actions

/* This method implements the actions for Open/Close Media Folder in the File
menu. */

- (IBAction) onMediaFolder:(id)sender
{

  /* If media is currently open, the user wants to close it. */

  if ([self hasMedia] == YES) {
    [self closeMedia];
    return;
  }

  /* The user wants to open a media folder. We display a modal Open dialog
  that's configured to open a single folder. If the user selects a folder and
  clicks the Open button, we attempt to open the media. */

  NSOpenPanel *panel = [NSOpenPanel openPanel];
  [panel setCanChooseFiles:NO];
  [panel setCanChooseDirectories:YES];
  [panel setAllowsMultipleSelection:NO];
  
  if ([panel runModalForTypes:nil] == NSOKButton)
  {
    NSString *folderPath = [[panel filenames] objectAtIndex:0];
    [self openMedia:folderPath isVolume:NO];
  }
}


/* This method implements the action for the Play button in the Control window.
It's also invoked in our onKeyDown method if media is paused and the user
presses the space bar. */

- (IBAction) onPlay:(id)sender 
{
   /* If media is open and not playing, we initiate playback. */

  if ([self hasMedia] == NO) {
    return;
  }

  if (mDVDState != kDVDStatePlaying) {
    NSLog(@&quot;Step 6: Play&quot;);
    OSStatus result = DVDPlay();
    NSAssert1 (!result, @&quot;DVDPlay returned %d&quot;, result);
  }
}


/* This method implements the action for the Pause button in the Control window.
It's also invoked in our onKeyDown method if media is playing and the user
presses the space bar. */

- (IBAction) onPause:(id)sender 
{
   /* If media is open and not paused, we pause playback. */

  if ([self hasMedia] == NO) {
    return;
  }

  if (mDVDState != kDVDStatePaused) {
    OSStatus result = DVDPause();
    NSAssert1 (!result, @&quot;DVDPause returned %d&quot;, result);
  }
}


/* This method implements the action for the Stop button in the Control window.
If we call DVDStop twice in succession, DVD Playback Services rewinds to the
beginning of the media. */

- (IBAction) onStop:(id)sender 
{
  if ([self hasMedia] == NO) {
    return;
  }

  if (mDVDState == kDVDStateStopped) {
    /* we're going to rewind, so we clear the UI information */
    [self resetUI];
  }

  OSStatus result = DVDStop();
  NSAssert1 (!result, @&quot;DVDStop returned %d&quot;, result);
}


/* This method implements the action for the Eject button in the Control window. */

- (IBAction) onEject:(id)sender 
{
  /* if mVolumePath is defined, removable media is open */
  
  if (mVolumePath) {
    NSString *volumePath = [NSString stringWithString:mVolumePath];
    [self closeMedia];
    [[NSWorkspace sharedWorkspace] unmountAndEjectDeviceAtPath:volumePath];
  }
}


/* This method implements the action for the Scan Forward button in the Control window. */

- (IBAction) onScanForward:(id)sender 
{
  if (mDVDState == kDVDStatePlaying) {
    OSStatus result = DVDScan (kDVDScanRate4x, kDVDScanDirectionForward);
    NSAssert1 (!result, @&quot;DVDScan returned %d&quot;, result);
  }
}


/* This method implements the action for the Scan Backward button in the Control window. */

- (IBAction) onScanBackward:(id)sender 
{
  if (mDVDState == kDVDStatePlaying) {
    OSStatus result = DVDScan (kDVDScanRate4x, kDVDScanDirectionBackward);
    NSAssert1 (!result, @&quot;DVDScan returned %d&quot;, result);
  }
}


/* This method implements the action for the Previous Scene button in the
Control window. Scene, chapter, and part of title (PTT) all mean the same thing. */

- (IBAction) onPreviousScene:(id)sender 
{
  if (mDVDState == kDVDStatePlaying) {
    OSStatus result = DVDPreviousChapter();
    NSAssert1 (!result, @&quot;DVDPreviousChapter returned %d&quot;, result);
  }
}


/* This method implements the action for the Next Scene button in the Control window. */

- (IBAction) onNextScene:(id)sender 
{
  if (mDVDState == kDVDStatePlaying) {
    OSStatus result = DVDNextChapter();
    NSAssert1 (!result, @&quot;DVDNextChapter returned %d&quot;, result);
  }
}


/* This method implements the action for the Menu button in the Control window.
If a title is playing, we go to the associated menu. If a menu is displayed, we
go to the associated title. */

- (IBAction) onToggleMenu:(id)sender 
{
  if ((mDVDState == kDVDStatePlaying) || 
    (mDVDState == kDVDStatePlayingStill) || 
    (mDVDState == kDVDStatePaused))
  {
    Boolean onMenu = false;
    DVDMenu whichMenu;
    OSStatus result = DVDIsOnMenu (&amp;onMenu, &amp;whichMenu);
    NSAssert1 (!result, @&quot;DVDIsOnMenu returned %d&quot;, result);
    // NSLog(@&quot;onMenu = %d, whichMenu = %d&quot;, onMenu, whichMenu);

    if (onMenu) {
      result = DVDReturnToTitle();
      NSAssert1 (!result, @&quot;DVDReturnToTitle returned %d&quot;, result);
    } else {
      result = DVDGoToMenu (kDVDMenuRoot);
      NSAssert1 (!result, @&quot;DVDGoToMenu returned %d&quot;, result);
    }  
  }
}


/* This method implements the action for the Next Camera Angle button in the
Control window. */

- (IBAction) onNextAngle:(id)sender 
{
  if (mDVDState == kDVDStatePlaying) 
  {
    UInt16 numAngles = 0, angle = 0;
    OSStatus result = DVDGetNumAngles (&amp;numAngles);
    result = DVDGetAngle (&amp;angle);
    if (++angle &gt; numAngles) 
      angle = 1;
    result = DVDSetAngle (angle);
    NSAssert1 (!result, @&quot;DVDSetAngle returned %d&quot;, result);
  }
}


/* This method implements the action for the New Bookmark button in the Control
window. Each time the user clicks this button, we add a new bookmark to the
mBookmarks array. To learn how bookmarks are implemented, see the Bookmark
class. */

- (IBAction) onNewBookmark:(id)sender 
{
  /* bookmarks to still or moving frames are ok */
  if ((mDVDState == kDVDStatePlaying) || (mDVDState == kDVDStatePlayingStill)) 
  {
    DVDBookmark *bookmark = [[DVDBookmark alloc] init];
    [mBookmarks addObject:bookmark];
    /* the array retains it, so we can safely release the bookmark now */
    [bookmark release];
  }
}


/* This method implements the action for the Goto Next Bookmark button in the
Control window. It simply cycles though the bookmarks in the mBookmarks array. */

- (IBAction) onNextBookmark:(id)sender 
{
  unsigned count = [mBookmarks count];
  if (count) {
    /* index of next bookmark in array */
    static unsigned next;
    [[mBookmarks objectAtIndex:next] gotoBookmark];
    if (++next == count) {
      /* reset to first bookmark */
      next = 0;
    }
  }
}


/* This method implements the action for the (Audio) Volume Up item in the
Controls menu. */

- (IBAction) onVolumeDown:(id)sender 
{
  UInt16 newLevel = [self setAudioVolume:NO];
  [mAudioControl setFloatValue:newLevel];
}


/* This method implements the action for the (Audio) Volume Down item in the
Controls menu. */

- (IBAction) onVolumeUp:(id)sender 
{
  UInt16 newLevel = [self setAudioVolume:YES];
  [mAudioControl setFloatValue:newLevel];
}


/* This method implements the action for the (Audio) Mute item in the Controls
menu. */

- (IBAction) onMute:(id)sender 
{
  Boolean isMuted;
  OSStatus result = DVDIsMuted (&amp;isMuted);
  result = DVDMute (!isMuted);
  NSAssert1 (!result, @&quot;DVDMute returned %d&quot;, result);
}


/* This method implements the action for the audio volume slider control in the
Control window. */

- (IBAction) onAudioVolume:(id)sender 
{
  OSStatus result = DVDSetAudioVolume ([sender floatValue]);
  NSAssert1 (!result, @&quot;DVDSetAudioVolume returned %d&quot;, result);
}


/* This method implements the action for the Show/Hide Controller item in the Window
menu. */

- (IBAction)onShowController:(id)sender 
{
  if ([mControlWindow isVisible]) {
    [mControlWindow orderOut:self];
  } else {
    [mControlWindow orderFront:self];
  }
}


/* This method implements the action for the Maximum Size item in the Video menu. */

- (IBAction) onVideoMax:(id)sender 
{
  [mVideoWindow setWindowSize:kVideoSizeMax];
}


/* This method implements the action for the Normal Size item in the Video menu. */

- (IBAction) onVideoNormal:(id)sender 
{
  [mVideoWindow setWindowSize:kVideoSizeNormal];
}


/* This method implements the action for the Small Size item in the Video menu. */

- (IBAction) onVideoSmall:(id)sender 
{
  [mVideoWindow setWindowSize:kVideoSizeSmall];
}


/* Both the video window and the control window pass their key down events to
this method. We want to respond to these events in the same manner, regardless
of which window is currently the key window. */

- (BOOL) onKeyDown: (NSEvent *)theEvent 
{
  NSString *keyString = [theEvent characters];
  unichar key = [keyString characterAtIndex:0];
  BOOL keyIsHandled = YES;
  OSStatus result = noErr;
  
  switch (key) {
    case NSUpArrowFunctionKey:
      result = DVDDoUserNavigation (kDVDUserNavigationMoveUp);
      break;
    case NSDownArrowFunctionKey:
      result = DVDDoUserNavigation (kDVDUserNavigationMoveDown);
      break;
    case NSLeftArrowFunctionKey:
      result = DVDDoUserNavigation (kDVDUserNavigationMoveLeft);
      break;
    case NSRightArrowFunctionKey:
      result = DVDDoUserNavigation (kDVDUserNavigationMoveRight);
      break;
    case NSCarriageReturnCharacter:
    case NSEnterCharacter:
      result = DVDDoUserNavigation (kDVDUserNavigationEnter);
      break;
    case ' ':
      /* space bar toggles between play and pause */
      if (mDVDState == kDVDStatePlaying)
        [self onPause:self];
      else if (mDVDState == kDVDStatePaused)
          [self onPlay:self];
      break;
    default:
      keyIsHandled = NO;
      break;
  }

  NSAssert1 (!result, @&quot;DVDDoUserNavigation returned %d&quot;, result);
  return keyIsHandled;
}

@end
</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/CocoaDVDPlayer/listing4.html%3Fid%3DDTS10003792-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/CocoaDVDPlayer/listing4.html%3Fid%3DDTS10003792-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/CocoaDVDPlayer/listing4.html%3Fid%3DDTS10003792-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>