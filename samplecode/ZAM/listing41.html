<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>ZAM - /GameSource/Sprite.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGames-date.html">Games</a> &gt; <A HREF="javascript:location.replace('index.html');">ZAM</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Games/index.html" target="_blank">Reference Library > Games</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">ZAM</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/GameSource/Sprite.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/CoreHeaders/CoreGlobals.h</option>
<option value="listing2.html">/CoreHeaders/EventLoop.h</option>
<option value="listing3.html">/CoreHeaders/MenuDispatch.h</option>
<option value="listing4.html">/CoreHeaders/WindowDispatch.h</option>
<option value="listing5.html">/CoreSource/AdjustMenus.c</option>
<option value="listing6.html">/CoreSource/AEventCoreDisp.c</option>
<option value="listing7.html">/CoreSource/Document.c</option>
<option value="listing8.html">/CoreSource/ErrMsg.c</option>
<option value="listing9.html">/CoreSource/EventLoop.c</option>
<option value="listing10.html">/CoreSource/GetBackTime.c</option>
<option value="listing11.html">/CoreSource/InitMac.c</option>
<option value="listing12.html">/CoreSource/Main.c</option>
<option value="listing13.html">/CoreSource/MenuDispatch.c</option>
<option value="listing14.html">/CoreSource/WindowDispatch.c</option>
<option value="listing15.html">/Dude #includes.c</option>
<option value="listing16.html">/GameHeaders/Document.h</option>
<option value="listing17.html">/GameHeaders/FixGraf.h</option>
<option value="listing18.html">/GameHeaders/GameAEvents.h</option>
<option value="listing19.html">/GameHeaders/GameDef.h</option>
<option value="listing20.html">/GameHeaders/GameSounds.h</option>
<option value="listing21.html">/GameHeaders/MissileSprite.h</option>
<option value="listing22.html">/GameHeaders/Sprite.h</option>
<option value="listing23.html">/GameHeaders/SpriteFrameRates.h</option>
<option value="listing24.html">/GameHeaders/TankSprite.h</option>
<option value="listing25.html">/GameHeaders/xqueue.h</option>
<option value="listing26.html">/GameHeaders/xthing.h</option>
<option value="listing27.html">/GameHeaders/ZAM.h</option>
<option value="listing28.html">/GameSource/DirectionTable.c</option>
<option value="listing29.html">/GameSource/ExplosionSprites.c</option>
<option value="listing30.html">/GameSource/FixGraf.c</option>
<option value="listing31.html">/GameSource/GameAEvents.c</option>
<option value="listing32.html">/GameSource/GameMenu.c</option>
<option value="listing33.html">/GameSource/GameSounds.c</option>
<option value="listing34.html">/GameSource/IncidentalSounds.c</option>
<option value="listing35.html">/GameSource/InitGame.c</option>
<option value="listing36.html">/GameSource/MissileAEvents.c</option>
<option value="listing37.html">/GameSource/MissileSprite.c</option>
<option value="listing38.html">/GameSource/pixiZAM - direct blitter/pixiZAM.c</option>
<option value="listing39.html">/GameSource/pixiZAM - direct blitter/pixiZAM.h</option>
<option value="listing40.html">/GameSource/SlamPixels.c</option>
<option value="listing41.html">/GameSource/Sprite.c</option>
<option value="listing42.html">/GameSource/Sprite.proto.h</option>
<option value="listing43.html">/GameSource/SpriteColission.c</option>
<option value="listing44.html">/GameSource/SpriteFrameSet.c</option>
<option value="listing45.html">/GameSource/SpriteLayer.c</option>
<option value="listing46.html">/GameSource/TankSprite.c</option>
<option value="listing47.html">/GameSource/xqueue.c</option>
<option value="listing48.html">/GameSource/xthing.c</option>
<option value="listing49.html">/GameSource/ZAMProtos.h</option>
<option value="listing50.html">/UtilCode/CoreAssertion.c</option>
<option value="listing51.html">/UtilCode/CoreAssertion.h</option>
<option value="listing52.html">/UtilCode/DialogUtil.c</option>
<option value="listing53.html">/UtilCode/GrafUtils.c</option>
<option value="listing54.html">/UtilCode/GrafUtils.h</option>
<option value="listing55.html">/UtilCode/GWorldUtils.c</option>
<option value="listing56.html">/UtilCode/GWorldUtils.h</option>
<option value="listing57.html">/UtilCode/IsPressed.c</option>
<option value="listing58.html">/UtilCode/WindowUtil.c</option></select>
				</p>
				</form>
				<p><strong><a href="ZAM.zip">Download Sample</a></strong> (&#147;ZAM.zip&#148;, 73.3K)<BR>
<strong><a href="ZAM.dmg">Download Sample</a></strong> (&#147;ZAM.dmg&#148;, 125.6K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">#include &quot;CoreAssertion.h&quot;#include &quot;ZAMProtos.h&quot;/*  What is  a sprite?  In the context of this code a sprite is a small graphic object on the screen that has  multiple frames, kind of like a movie.  These sprites are loaded from a series of Cicn resources  which are handy because they have a mask built right into the structure, so it is easier to  associate the data together.    So, a sprite is like a little movie, you give it a frame rate and a movement rate,  and this sprite manager will move it automatically for you, depending on flag settings.  With the flags you can turn off default behavior.  It is also flexible in that it allows you  to install callback routines for each animation frame drawn, and each time a sprite is moved.  Also, each sprite has a colission handler, and when you request that colissions be checked for  your sprite colission handler will be called when it overlaps another sprite.    This is all done with built in features of the Macintosh and QuickDraw.  Thanks Bill and Kon.    Some of this code is hairy and messy.  If I were starting this over again today, knowing what  I do now having done it once, I would do it differently.  Hopefully, since I am making this  code available to you, you will see what I mean and be able to implement your own animation  architecture that fits your needs and works for you.    CoMation(tm) Architecture by Brigham Stevens    Be sure to put CoMation on the box of your game or MultiMedia application if you  are sychronizing interactive animation between multiple computers.  Thats right.    You can say  CoMation Architecture Support right on your box, and the customers will  clamor for more.      Hey for more excellent examples of Macintosh animation, see SpriteWorld by Tony Myles.  I  think it is on the developer CD, perhaps in the same area as this one.*//* this is where all the sprites are kept *//* applications should keep their own references to the sprites *//* see TankSprites, MissileSprites, and ExplosionSprites for examples of using *//* most of the routines here */static spriteLayerPtr  MasterSpriteHead;static spriteLayerPtr  MasterSpriteTail;void AnimateSprites(void)/*  This function is what you call once each time through your main loop.  It will erase and draw all the sprites that are flagged for update.  This handles the layering by doing all the necessary erasing first.  A sprite is erased by CopyBitsing the background in over its previous location.    Then the sprites are drawn in layer order.  NOTE that this does NOT happen unless  at least one sprite was erased.  This may be a flaw, but it saves time.    The sprites are drawn using a mask region, which has to be moved to the current position  each time.  That is what MoveCellMaskRgnToRect.   A Cell is an animation cell, or frame.  Each frame in a sprite frame set has its own mask region.    There are a lot of flags used by this, so be careful.  Sometimes the flags gave me grief, but  I wanted to make it flexible.  Also, lots of the flags were added in for the AppleEvent  support.    Remember, if I was going to do this again, it would be done a lot differently.  But, this  works pretty well as it is.*/{  register spritePtr      spr;  register spriteLayerPtr    sprLayer;  register frameCellPtr    curFrame;  register PixMapHandle    srcPix;  register PixMapHandle    destPix;  register Boolean      needToDraw = false;    /* Erase all sprites that need to be erased */  for(sprLayer = MasterSpriteTail; sprLayer != nil; sprLayer = sprLayer-&gt;prev) {    if( (sprLayer-&gt;layerFlags &amp; kLayerDirty) != 0) {      needToDraw = true;      for(spr = sprLayer-&gt;sprites; spr != nil; spr = spr-&gt;next) {        if( (spr-&gt;spriteFlags &amp; kNeedsToBeErased) != 0) {          curFrame = spr-&gt;frameList-&gt;finfo.curImage;          srcPix = PreserveGraf(sprLayer-&gt;backdrop);          destPix = PreserveGraf(sprLayer-&gt;tween);                  //  ERASE from backdrop to the tween layer                    CopyBits(*srcPix,               *destPix,               &amp;spr-&gt;prevBounds,               &amp;spr-&gt;prevBounds,               srcCopy,               nil);                    RestoreGraf();          RestoreGraf();                    spr-&gt;spriteFlags &amp;= ~kNeedsToBeErased;        }      }    }  }        /* draw all sprites in layer order */  if( needToDraw ) {    for(sprLayer = MasterSpriteTail; sprLayer != nil; sprLayer = sprLayer-&gt;prev) {      for(spr = sprLayer-&gt;sprites; spr != nil; spr = spr-&gt;next) {        if(spr-&gt;visible) {          curFrame = spr-&gt;frameList-&gt;finfo.curImage;                        srcPix = PreserveGraf(curFrame-&gt;image);          destPix = PreserveGraf(sprLayer-&gt;tween);            MoveCellMaskRgnToRect(curFrame, &amp;spr-&gt;bounds);                  //  DRAW the sprite into the offscreen tween layer                    CopyBits(*srcPix,               *destPix,               &amp;curFrame-&gt;image-&gt;portRect,               &amp;spr-&gt;bounds,               srcCopy,               curFrame-&gt;mask);                    RestoreGraf();          RestoreGraf();                    spr-&gt;prevBounds = spr-&gt;bounds;        }      }    }  }    /* draw all sprites that need to be updated on the screen */  if( needToDraw ) {    for(sprLayer = MasterSpriteTail; sprLayer != nil; sprLayer = sprLayer-&gt;prev) {      if( (sprLayer-&gt;layerFlags &amp; kLayerDirty) != 0) {        for(spr = sprLayer-&gt;sprites; spr != nil; spr = spr-&gt;next) {          if(spr-&gt;spriteFlags &amp; kNeedsToBeDrawn) {            srcPix = PreserveGraf(sprLayer-&gt;tween);            destPix = PreserveGraf((GWorldPtr)sprLayer-&gt;window);                //  DRAW the sprite to the window on screen                        CopyBits(*srcPix,                 *destPix,                 &amp;spr-&gt;updateBounds,                 &amp;spr-&gt;updateBounds,                 srcCopy,                 nil);                        RestoreGraf();            RestoreGraf();                        spr-&gt;spriteFlags &amp;= ~kNeedsToBeDrawn;          }        }        sprLayer-&gt;layerFlags &amp;=  ~kLayerDirty;      }    }  }}void SpriteUpdateEvent(void)/*  Call this from your event loop when a window containing sprites  has an update event.  This just refreshes the screen from the  offscreen sprite world, which should be current.*/{    PixMapHandle  srcPix;  PixMapHandle  destPix;      if(MasterSpriteHead) {    srcPix = PreserveGraf(MasterSpriteHead-&gt;tween);    destPix = PreserveGraf((GWorldPtr)MasterSpriteHead-&gt;window);    CopyBits(*srcPix,         *destPix,         &amp;MasterSpriteHead-&gt;tween-&gt;portRect,         &amp;MasterSpriteHead-&gt;tween-&gt;portRect,         srcCopy,         nil);        RestoreGraf();    RestoreGraf();  }}void InitSprites(void)/*  Call this routine very early in the program.  It pre-allocates memory for all the sprite records as non-relocatable blocks.  As you can see, it does not pre-allocate anything, which may slow things down  if you are dynamically allocating memory at runtime.  I changed this to simplify the  use of Sprites, but my program pre-allocates all the sprites anyway.*/{  MasterSpriteHead = nil;  MasterSpriteTail = nil;  }OSErr  CreateSpriteLayer(spriteLayerPtr *retSprite,               GWorldPtr tween,               GWorldPtr backdrop,               WindowPtr spriteWin)/*  Sprites live in layers that define which sprites overlap each other.  Layers also make it easy to group sprites for colission detection.  Thanks Tony for the layering concept.  My first cut through this  was not using layers, just one big gantic sprite list.  Yep, gantic.*/{  OSErr      err = noErr;  spriteLayerPtr  sl;    sl = (spriteLayerPtr)NewPtrClear(sizeof(spriteLayer));  if(!sl) {    err = MemError();    ErrMsgCode(&quot;\pCreateSpriteLayer NewPtrClear failed.&quot;,err);  }    if(err == noErr) {    sl-&gt;tween = tween;    sl-&gt;backdrop = backdrop;    sl-&gt;window = spriteWin;  }  /* add this layer to the layer list */  /* layers are created in front to back order */  if(MasterSpriteTail) {    sl-&gt;prev = MasterSpriteTail;    MasterSpriteTail-&gt;next = sl;    MasterSpriteTail = sl;  } else {    MasterSpriteHead = MasterSpriteTail = sl;  }  *retSprite = sl;    return err;}void StopSpriteAction(spritePtr spr)/*  This removes the sprites from the time manager queue  if they are currently active.  The Time Manager seems like it removes tasks when they complete  because it has been changed to only insert them when they are primed,  so, this will only remove the task if the bit is set indicating that it is  active.  PrimeTime sets this bit.*/{  if( (spr-&gt;frameTask.timer.qType &amp; TaskActiveFlag) != 0) {    (void)RmvTime(&amp;spr-&gt;frameTask.timer);  }  if( (spr-&gt;moveTask.timer.qType &amp; TaskActiveFlag) != 0) {    (void)RmvTime(&amp;spr-&gt;moveTask.timer);  }}void StopSpriteLayerAction(spriteLayerPtr sprLayer)/*  Freeze an entire sprite layer.  This does not deallocate the sprite at all.    Only stops it from moving around so much.*/{  spritePtr  killSprite;    for(killSprite = sprLayer-&gt;sprites; killSprite != nil; killSprite = killSprite-&gt;prev)    StopSpriteAction(killSprite);}void KillSprites(void)/*  Perhaps a misleading name,   because this does not deallocate either.  This just stops all Layers at once.  I guess I never wrote a sprite deallocator, because it is complicated because  frame sets are shared.  I should add a user count to the frame set so that they  know when no one else is using it, then the deallocator could be written.    However, since ZAM only loads sprites once, I don't need one, so I'm not writing it.*/{  spriteLayerPtr  killLayer;    for(killLayer = MasterSpriteTail; killLayer != nil; killLayer = killLayer-&gt;prev)    StopSpriteLayerAction(killLayer);}void AddSpriteToLayer(spritePtr spr, spriteLayerPtr sprLayer)/*  Yes, this will take the sprite and make it a member of the layer.*/{  spr-&gt;next = sprLayer-&gt;sprites;  sprLayer-&gt;sprites-&gt;prev = spr-&gt;next;  sprLayer-&gt;sprites = spr;}void RemoveSpriteFromLayer(spritePtr spr, spriteLayerPtr sprLayer){  if(spr-&gt;next) {    spr-&gt;next-&gt;prev = spr-&gt;prev;  }    if(spr-&gt;prev) {    spr-&gt;prev-&gt;next = spr-&gt;next;  }    spr-&gt;prev = nil;  spr-&gt;next = nil;  }void MoveCellMaskRgnToRect(frameCellPtr curFrame, Rect *r)/*  Offset a region to move it with the sprite.  The maskLoc is the original topLeft of the region, and  it is needed to preserve the region position within the sprite rectangle*/{  Point        rgnOffset;    /* translate the region position to the new image position */  rgnOffset.h = r-&gt;left - (**curFrame-&gt;mask).rgnBBox.left         + curFrame-&gt;maskLoc.h;  rgnOffset.v = r-&gt;top - (**curFrame-&gt;mask).rgnBBox.top         + curFrame-&gt;maskLoc.v;  OffsetRgn(curFrame-&gt;mask, rgnOffset.h, rgnOffset.v);}OSErr CreateEmptySprite(spriteLayerPtr  sprLayer,            spritePtr  *newSprite,     /* new sprite returned here */            long    spriteFlags,            long    moveTimeInterval,            long    frameTimeInterval,            long    refCon)    /* application value *//*  Create a new sprite from parameters specified with no frame set.  To add a frame set, either use CreateEmptyFrameSet, and then SetSpriteFrameSet  to copy a frame set to it.    Some things about this are bad.  FrameSet headers are block moved around  when the frame sets are shared.  This is not good, but it is not that much memory.  See SpriteFrameSet.c for more info on frame sets.*/{  spritePtr  tSprite;  OSErr    err = noErr;    tSprite = (spritePtr)NewPtrClear(sizeof(sprite));  if(tSprite == nil) {    err = paramErr;    ErrMsg(&quot;\pNo More Sprites may be allocated. ****EXITING****.&quot;);  } else {    tSprite-&gt;usrNext = nil;    tSprite-&gt;usrPrev = nil;    tSprite-&gt;moveHandler = nil;    tSprite-&gt;visible = false;    tSprite-&gt;loc.h = 0;    tSprite-&gt;loc.v = 0;    tSprite-&gt;vel.h = 0;    tSprite-&gt;vel.v = 0;    tSprite-&gt;frameList = nil;    tSprite-&gt;refCon = refCon;    tSprite-&gt;spriteFlags = spriteFlags;    tSprite-&gt;inUse = false;    tSprite-&gt;moveTimeInterval = moveTimeInterval;    tSprite-&gt;frameTimeInterval = frameTimeInterval;    tSprite-&gt;ownerLayer = sprLayer;        *newSprite = tSprite;    AddSpriteToLayer(tSprite, sprLayer);  }      return err;}OSErr CreateColorIconSprite(spriteLayerPtr  sprLayer,              spritePtr  *newSprite,   /* new sprite returned here */              short    startID,   /* starting resource ID of cicn */              short    numFrames,  /* number of resources to load */              long    spriteFlags,              long    moveTimeInterval,              long    frameTimeInterval,              long    refCon)    /* application value *//*  Create a new sprite from parameters specified  starting location for all sprites is 0,0  velocity is 0,0  bounds taken from icon dimensions - GWORLD of first frame  assumes that all icons have the same dimension  center - calcd from bounds  dimension - h width v = height calcd from bounds  frameList - built from color icons starting from startID  visible - set to false    Sprites created with this can then be copied.  See MissileSprites.c (LoadMIssileSprites)  for an example, or ExplosionSprites.c.*/{  spritePtr  tSprite;  OSErr    err;    /*  create an empty sprite first */  err = CreateEmptySprite(sprLayer,              &amp;tSprite,   /* new sprite returned here */              spriteFlags,              moveTimeInterval,              frameTimeInterval,              refCon);  /* application value */    /* now create the frameset list, and attach it to the sprite */      if(err == noErr) {    err = CreateColorIconFrameSet(&amp;tSprite-&gt;frameList, startID,  numFrames);    if(err != noErr) {        ErrMsgCode(&quot;\pError in CreateColorIconFrameSet!&quot;,err);    } else {      *newSprite = tSprite;    }  }    return err;}void SetSpriteLoc(spritePtr spr, Fixed h, Fixed v)/*  Change the position of the sprite on the screen*/{  Boolean showIt = false;    if(spr-&gt;visible) {    showIt = true;    HideSprite(spr);  }    spr-&gt;prevBounds = spr-&gt;bounds;  spr-&gt;loc.h = h;  spr-&gt;loc.v = v;    spr-&gt;bounds.top =  FixToInt(spr-&gt;loc.v) - spr-&gt;frameList-&gt;finfo.center.v;  spr-&gt;bounds.left = FixToInt(spr-&gt;loc.h) - spr-&gt;frameList-&gt;finfo.center.v;          spr-&gt;bounds.bottom = spr-&gt;bounds.top + spr-&gt;frameList-&gt;finfo.dimension.v;  spr-&gt;bounds.right = spr-&gt;bounds.left + spr-&gt;frameList-&gt;finfo.dimension.h;    MyUnionRect(&amp;spr-&gt;prevBounds, &amp;spr-&gt;bounds, &amp;spr-&gt;updateBounds);  spr-&gt;spriteFlags |= kNeedsToBeErased | kNeedsToBeDrawn;  if(showIt)    ShowSprite(spr);} void ShowSprite(spritePtr spr)/*  Make the sprite visibile.*/{  if(!spr-&gt;visible) {    spr-&gt;visible = true;    spr-&gt;spriteFlags |= kNeedsToBeDrawn;  }}void HideSprite(spritePtr spr)/*  hide the sprite on the screen  and draw it.  In this case if the sprite was not ever  previously drawn, the drawing routine will  not draw anything.*/{  if(spr-&gt;visible) {    spr-&gt;visible = false;    spr-&gt;spriteFlags |= kNeedsToBeErased;  }}void StartSpriteAction(spritePtr spr)/*  This launches the XThing tasks for updating the sprites, which in turn  uses the Time Manger.  XThings are periodical tasks that run as close  if any of the intervals are zero, then the task is not launched */{  if(spr-&gt;frameTimeInterval) {    (void)StartXThing(&amp;spr-&gt;frameTask, spr-&gt;frameTimeInterval,         (updateProc)SpriteFrameTask, (long)spr);  }    if(spr-&gt;moveTimeInterval) {    (void)StartXThing(&amp;spr-&gt;moveTask, spr-&gt;moveTimeInterval,         (updateProc)SpriteMoveTask, (long)spr);  }}void StartRemoteSpriteAction(spritePtr spr)/*  Same as above, only the timer is never fired.  Instead, they are manually updated when a network message is  received saying to update the sprite.*/{    (void)AddXThing(&amp;spr-&gt;frameTask, spr-&gt;frameTimeInterval,         (updateProc)SpriteFrameTask, (long)spr);      (void)AddXThing(&amp;spr-&gt;moveTask, spr-&gt;moveTimeInterval,         (updateProc)SpriteMoveTask, (long)spr);}Boolean SpriteFrameTask(xthing *xtp, spritePtr spr)/*  This is the XThing task that changes the frame of the sprite.    If the kFrameTaskBeforeUpdate bit it set in spriteFlags and if there  is a global frame task installed, then it will be called before  the frame of the sprite is changed.    If the kDefaultFrameAdvance bit is set, then the task  will go ahead and advance the frame on to the next one.    if the kFrameTaskAfterUpdate bit is set, then the task will  also call the global frame task after the frame is advanced.    Finally, if the current frame has a callback set up, then it will be called.    All of the callbacks return a boolean that determines if this task is to be rescheduled.*/{  register frameCellPtr  curFrame;  register frameSetPtr    frameset;  register long      frameDelay;  register Boolean      reTimeTask = true;    frameset = spr-&gt;frameList;  if( (spr-&gt;spriteFlags &amp; kFrameTaskBeforeUpdate) != 0) {    if(spr-&gt;frameHandler) {      reTimeTask = (*spr-&gt;frameHandler)(spr, nil);    }  }    if( (spr-&gt;spriteFlags &amp; kDefaultFrameAdvance) != 0) {    frameset-&gt;finfo.frameIndex++;      if(frameset-&gt;finfo.frameIndex &gt;= frameset-&gt;finfo.frameCount) {      frameset-&gt;finfo.frameIndex  = 0;    }        curFrame = &amp;frameset-&gt;flist[frameset-&gt;finfo.frameIndex];    frameset-&gt;finfo.prevImage = frameset-&gt;finfo.curImage;    frameset-&gt;finfo.curImage = curFrame;    spr-&gt;updateBounds = spr-&gt;bounds;    spr-&gt;spriteFlags |= kNeedsToBeDrawn | kNeedsToBeErased;    spr-&gt;ownerLayer-&gt;layerFlags |= kLayerDirty;  }    if( (spr-&gt;spriteFlags &amp; kFrameTaskAfterUpdate) != 0) {    if(spr-&gt;frameHandler) {      reTimeTask = (*spr-&gt;frameHandler)(spr, (struct frameCell *)-1);    }  }  /* check if this frame has a callback and call it */  curFrame = &amp;frameset-&gt;flist[frameset-&gt;finfo.frameIndex];  if(curFrame-&gt;frameCB) {    reTimeTask = (*curFrame-&gt;frameCB)(spr,  (struct frameCell *)curFrame);  }    if( (spr-&gt;spriteFlags &amp; kRemoteSprite) != 0)    reTimeTask = false;    return reTimeTask;  }Boolean SpriteMoveTask(xthing *xtp, spritePtr spr)/*  This procedure moves the sprites in the default way,  applying the velocity to the location, and then recalculating the  bounds based on this position.    This procedure changes fields that DrawSprite depends upon:    updateBounds covers the total area of the screen that needs to be changed,  incorporating the previous position and the current position.    prevBounds is the position the sprite WAS in.  This is used for erasing the  previous image.    prevImage is the previous frameCell the sprite was drawn with.  This is used to  erase the previous image.  */{  moveProc  moveJSR;  Boolean    result = true;  short    adjustPos;  Boolean    reAdjustNecessary;    if( (spr-&gt;vel.h != 0) || (spr-&gt;vel.v != 0) ) {    spr-&gt;prevBounds = spr-&gt;bounds;  /* save previous location */          /* the sprite location is the center of the sprite */      if(spr-&gt;spriteFlags &amp; kRemoteUpdate) {      spr-&gt;loc = spr-&gt;remoteLoc;    /* slam the sprite */    } else {      spr-&gt;loc.h += spr-&gt;vel.h;    /* offset the sprite */      spr-&gt;loc.v += spr-&gt;vel.v;        }        /* build the sprite integer rectangle location from the fixed center point */    spr-&gt;bounds.top =  FixToInt(spr-&gt;loc.v) - spr-&gt;frameList-&gt;finfo.center.v;    spr-&gt;bounds.left = FixToInt(spr-&gt;loc.h) - spr-&gt;frameList-&gt;finfo.center.v;            spr-&gt;bounds.bottom = spr-&gt;bounds.top + spr-&gt;frameList-&gt;finfo.dimension.v;    spr-&gt;bounds.right = spr-&gt;bounds.left + spr-&gt;frameList-&gt;finfo.dimension.h;      /* calculate the entire area that needs updating */    MyUnionRect(&amp;spr-&gt;bounds, &amp;spr-&gt;prevBounds, &amp;spr-&gt;updateBounds);      spr-&gt;frameList-&gt;finfo.prevImage = spr-&gt;frameList-&gt;finfo.curImage;        /* set the update flag if we have moved a whole pixel at least */    if(spr-&gt;prevBounds.top != spr-&gt;bounds.top) {      spr-&gt;spriteFlags |= kNeedsToBeDrawn | kNeedsToBeErased;      spr-&gt;ownerLayer-&gt;layerFlags |= kLayerDirty;    }    else if(spr-&gt;prevBounds.left != spr-&gt;bounds.left) {      spr-&gt;spriteFlags |= kNeedsToBeDrawn | kNeedsToBeErased;      spr-&gt;ownerLayer-&gt;layerFlags |= kLayerDirty;    }      /* this constrains the sprite to within the constrain rectangle */    if(spr-&gt;spriteFlags &amp; kConstrainToRect) {      reAdjustNecessary = false;      if(spr-&gt;bounds.right &gt; spr-&gt;constrainRect.right) {        adjustPos = spr-&gt;bounds.right - spr-&gt;constrainRect.right;        spr-&gt;loc.h -= ff(adjustPos);        reAdjustNecessary = true;      } else if(spr-&gt;bounds.left &lt; spr-&gt;constrainRect.left) {        adjustPos =   spr-&gt;constrainRect.left - spr-&gt;bounds.left;        spr-&gt;loc.h += ff(adjustPos);        reAdjustNecessary = true;      }            if(spr-&gt;bounds.bottom &gt; spr-&gt;constrainRect.bottom) {        adjustPos = spr-&gt;bounds.bottom - spr-&gt;constrainRect.bottom;        spr-&gt;loc.v -= ff(adjustPos);        reAdjustNecessary = true;      } else if(spr-&gt;bounds.top &lt; spr-&gt;constrainRect.top) {        adjustPos = spr-&gt;constrainRect.top - spr-&gt;bounds.top;        spr-&gt;loc.v += ff(adjustPos);        reAdjustNecessary = true;      }      if(reAdjustNecessary) {        spr-&gt;bounds.top =  FixToInt(spr-&gt;loc.v) - spr-&gt;frameList-&gt;finfo.center.v;        spr-&gt;bounds.left = FixToInt(spr-&gt;loc.h) - spr-&gt;frameList-&gt;finfo.center.v;                spr-&gt;bounds.bottom = spr-&gt;bounds.top + spr-&gt;frameList-&gt;finfo.dimension.v;        spr-&gt;bounds.right = spr-&gt;bounds.left + spr-&gt;frameList-&gt;finfo.dimension.h;      }    }  }      /* check if there is a move callback */  if(spr-&gt;moveHandler) {    moveJSR = (moveProc)spr-&gt;moveHandler;    result = (*moveJSR)(spr);  }     /* remote sprites are not timed by the time manager.  They are moved when an update is rcvd */  if( (spr-&gt;spriteFlags &amp; kRemoteSprite) != 0)    result = false;  /* tell XThing if we want to be added back as time manager task */  return result;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/ZAM/listing41.html%3Fid%3DDTS10000063-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/ZAM/listing41.html%3Fid%3DDTS10000063-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/ZAM/listing41.html%3Fid%3DDTS10000063-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>