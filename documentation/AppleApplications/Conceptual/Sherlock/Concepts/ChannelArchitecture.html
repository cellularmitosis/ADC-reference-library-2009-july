<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Sherlock Channels (Legacy): Architecture of Sherlock Channels</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Architecture of Sherlock Channels"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	<meta name="ROBOTS" content="NOINDEX"/>
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/20001082" title="Architecture of Sherlock Channels"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../LegacyTechnologies/index.html#//apple_ref/doc/uid/TP30000440-TP30000470" target="_top">Legacy Documents</a> &gt; <a href="../../../../LegacyTechnologies/InternetWeb-date.html#//apple_ref/doc/uid/TP30000440-TP30000470-TP30000526" target="_top">Internet &amp; Web</a> &gt; <a href="../index.html" target="_top">Sherlock Channels (Legacy)</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Sherlock.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="DevelopingChannels.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>
        
        <script type="text/javascript" language="JavaScript">placeWatermark()</script>
<div id="legacyOuterWrapper"><div align="center" id="watermark">
<div class="legacybox">
<h1>Legacy Document<span class="closebutton"><a href="javascript:closeWatermark()"><img src="../../../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
Sherlock is unsupported in Mac OS X v10.5 and later.</p></div></div></div>
        <a name="//apple_ref/doc/uid/20001082-SW1" title="Architecture of Sherlock Channels"></a><hr /><H1><a name="//apple_ref/doc/uid/20001082-BCIFBBHG" title="Architecture of Sherlock Channels"></a>Architecture of Sherlock Channels</H1><p>This article provides an overview of Sherlock channels and their architecture. It describes the components involved in creating channels, how they fit together, and how they work within the Sherlock environment.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <!-- TopicBook.pm uses this template for its miniTOCs, but needs a different title. -->
    <h4>Contents:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="ChannelArchitecture.html#//apple_ref/doc/uid/20001082-110224">Sherlock Overview</a>
				
			<br/>
			
        
			
			
				<a href="ChannelArchitecture.html#//apple_ref/doc/uid/20001082-126148">Channel Architecture</a>
				
			<br/>
			
        
			
			
				<a href="ChannelArchitecture.html#//apple_ref/doc/uid/20001082-116810">Web Services</a>
				
			<br/>
			
        
			
			
				<a href="ChannelArchitecture.html#//apple_ref/doc/uid/20001082-117675">Data Caching Strategies</a>
				
			<br/>
			
        
			
			
				<a href="ChannelArchitecture.html#//apple_ref/doc/uid/20001082-117352">Version Information</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/20001082-110224" title="Sherlock Overview"></a><h2>Sherlock Overview</h2><p>Sherlock is an application that incorporates Internet search capabilities into a flexible and extensible environment. The Sherlock application manages the infrastructure and support for <strong>channels</strong>, which do the work of gathering and displaying information. </p><p>A channel is a search-engine interface that uses the Sherlock infrastructure to access network-based resources and display the results to the user. Channels are not search engines in themselves; they take advantage of search engines on local intranets and the Internet to find information. However, channels can do more than just search for strings of characters. Channels can have a context in which to interpret the data they receive from a search engine. Using this context, the channel can then narrow the search criteria or perform additional searches to focus on information the user really wants. </p><p>You can develop channels to display a range of content, from movie showtimes to stock quotes, to yellow pages listings to news. You decide the level of detail you want to include in your channel and what context is required to achieve that detail. You then use that context to gather related information for the user. For example, a generic restaurant channel could use a postal code to provide restaurant listings in the user’s area. A more complex restaurant channel could then use other web services to obtain driving directions or restaurant reviews. Your job as a channel developer is to set up the channel context to acquire the relevant data. </p><p><span class="content_text">Figure 1</span> shows Sherlock’s stock channel, which displays information about the user’s selected stocks, current prices, and news. When the user selects a stock, the channel displays a list of headlines. Selecting a headline then displays the article associated with that headline. All of this information is gathered dynamically by the channel. The only information the user provides is the stock symbol or company name.</p><br/><div><a name="//apple_ref/doc/uid/20001082-126123-BCIEFGEA" title="Figure 1Sherlock stock channel"></a><p><a name="//apple_ref/doc/uid/20001082-126123" title="Figure 1Sherlock stock channel"></a><strong>Figure 1&nbsp;&nbsp;</strong>Sherlock stock channel</p><img src = "art/stock_screen.gif" alt = "Sherlock stock channel" width="551" height="475"></div><br/><p>Most of window content you see in <span class="content_text">Figure 1</span> is provided by the channel. Sherlock manages the interface and code provided by the channel but is not responsible for providing the channel’s behavior. The only portion of the window that Sherlock manages is the toolbar along the top edge. For more information on channel interfaces and how to create them, see <span class="content_text"><a href="DevelopingChannels.html#//apple_ref/doc/uid/20001083-113606">“The Channel’s Interface.”</a></span> </p><a name="//apple_ref/doc/uid/20001082-126148" title="Channel Architecture"></a><h2>Channel Architecture</h2><p>The original architecture for Sherlock channels was relatively simple. The channel developer’s main job was to provide a direct mapping between Sherlock data fields and the developer’s search engine. The Sherlock application would then display search results as a weighted result set pulled from various sources. The new channel architecture gives you much more freedom to display information the way you want. </p><a name="//apple_ref/doc/uid/20001082-115862" title="Overview"></a><h3>Overview</h3><p>The goal of a Sherlock channel is to provide the user with relevant information for a specific topic. While you can use channels to act as a front-end for search engines, doing so does not take advantage of the power offered by Sherlock. The new architecture gives you a chance to create an intelligent search agent that gathers specific information and displays it in an intuitive way to the user. </p><p>The way you gather information in a channel is through a combination of search engines and web services. Search engines are a good starting point for finding basic text. However, web services are also becoming more prominent and are capable of offering more specific types of information. The script languages used by Sherlock make it easy to build XML queries and use them to communicate with SOAP services, among others.</p><p>Once you have the data you want, you must display it. Instead of the traditional search results table, Sherlock now supports the creation of custom user interfaces using Aqua controls. You can define an interface for your channel that is as complex or as simple as you want it to be. In either case, the result is a channel that behaves more like a Cocoa application than a web page of search results.</p><a name="//apple_ref/doc/uid/20001082-116120" title="Channel Structure"></a><h3>Channel Structure</h3><p>The way you create a channel has changed somewhat from previous versions of Sherlock. Whereas a channel used to consist of a mapping between the search engine syntax and the Sherlock syntax, channels now provide a user interface and script code to drive that interface. Sherlock still relies heavily on XML as a way of organizing the channel contents; however, channels also use the JavaScript and XQuery scripting languages to provide dynamic responses to data changes. </p><p>The channel itself now more closely resembles an application bundle containing resources and code files. The user interface for a channel is stored in a nib file that you create using Interface Builder. Your script code resides in an XML file, where it can be organized into small functions, called <strong>triggers</strong>, that respond to specific changes and events in your channel. </p><p>The Sherlock application provides the runtime environment in which channels operate. Sherlock provides a tremendous amount of infrastructure to support channels, including data storage, network services, and the script interpreters for your JavaScript and XQuery code. The most prominent piece of infrastructure is the <strong>data store</strong>, which acts as a repository for your channel’s data. The data store also acts as the connection point between your channel’s user interface and code, providing the place where the two exchange data. </p><p><span class="content_text">Figure 2</span> shows the basic content of a channel and how that content relates to the Sherlock application and infrastructure. Each channel contains a nib file with the channel’s user interface. Code resides in the XML triggers file. Sherlock uses the channel’s XML configuration file to locate channel resources, including the nib file, XML triggers, and any additional resources. The Sherlock application coordinates interactions between your channel’s files and the Sherlock infrastructure. </p><br/><div><a name="//apple_ref/doc/uid/20001082-116160-BCIIEIED" title="Figure 2Basic channel structure"></a><p><a name="//apple_ref/doc/uid/20001082-116160" title="Figure 2Basic channel structure"></a><strong>Figure 2&nbsp;&nbsp;</strong>Basic channel structure</p><img src = "art/sherlock_chann_struct.gif" alt = "Basic channel structure" width="467" height="464"></div><br/><a name="//apple_ref/doc/uid/20001082-116174" title="Understanding the Data Store"></a><a name="//apple_ref/doc/uid/20001082-116174-BCIDDEED" title="Understanding the Data Store"></a><h3>Understanding the Data Store</h3><p>Understanding the data store and what it does is important for the development of Sherlock channels. The main function of the data store is, as its name implies, to store the data created by your channel or entered by the user. However, the data store has other behaviors that are important to the design and implementation of channels. </p><p>When a user selects your channel, Sherlock loads your channel’s interface from the nib file you provide and incorporates it into the main Sherlock window. Because the Sherlock application runs the Sherlock window, your channel code has no direct connection to your user interface. Instead, Sherlock runs the interface and uses the data store as an intermediary for communications between the interface and your channel code.</p><p>Whenever the user interacts with your channel’s user interface, Sherlock updates the data store to reflect the interaction. The data store is both a repository of information and a source of notifications for your channel. If the user types a value in a text field, Sherlock stores that value in an appropriate location in the data store and generates a notification that the data changed. If the user clicks a button, Sherlock does not modify any data store values, but it does generate a notification.</p><p>Information in the data store is organized on the concept of paths. A <strong>path</strong> is a string that uniquely identifies an object or property in the data store. Paths are not themselves objects that you manipulate. They are merely labels for data and services in the data store. You can use a path name to get or set the value for a control in your channel’s interface. You can also send a notification to a particular path. The result of sending a notification is that Sherlock executes the script code for the trigger that associates itself with the notified path. </p><p>Every relevant view and control in your user interface must have a path. You assign path names using a special palette in Interface Builder. This palette (available as part of the Sherlock SDK) adds a new tab to the Info Window that lets you enter path name information for the controls and views of your interface. The path information is stored in your nib file and read by Sherlock when it loads your channel. <span class="content_text">Figure 3</span> shows the Info Window with the Sherlock tab. </p><br/><div><a name="//apple_ref/doc/uid/20001082-116215-BCIBAGGH" title="Figure 3Sherlock tab of the Info Window"></a><p><a name="//apple_ref/doc/uid/20001082-116215" title="Figure 3Sherlock tab of the Info Window"></a><strong>Figure 3&nbsp;&nbsp;</strong>Sherlock tab of the Info Window</p><img src = "art/ib_palette_info.gif" alt = "Sherlock tab of the Info Window" width="202" height="311"></div><br/><p>On the Sherlock tab, the control name is only part of the path name for that control. Your user interface must have a top-level view in which all other views and controls are embedded. The name of this view is prepended to the names of all other embedded views and controls. Sherlock includes only the top-level view in the path name for a control. It does not include the names of any other intervening views. </p><p>To access a property of a control, your script code must know the path to the control and the name of the desired property. <span class="content_text">Figure 4</span> shows a channel with a main view and several controls. The diagram to the right shows the organization and path names for each of the controls. To locate a property of a control, you would build a path with the name of the main view, the control name, and the property name, separating each name from the others with a period. For example, to access the data in the <code>SearchString</code> text field, you would create the path “<code>mainView.SearchString.objectValue</code>” and pass that path to the method for getting the data. For information on the properties defined for controls and views, see <span class="content_text"><a href="ScriptExtensions.html#//apple_ref/doc/uid/20001085-158702">“Control Properties.”</a></span></p><br/><div><a name="//apple_ref/doc/uid/20001082-116254-BCIGDHIB" title="Figure 4Object containment hierarchy for a view"></a><p><a name="//apple_ref/doc/uid/20001082-116254" title="Figure 4Object containment hierarchy for a view"></a><strong>Figure 4&nbsp;&nbsp;</strong>Object containment hierarchy for a view</p><img src = "art/hierarchy_view.gif" alt = "Object containment hierarchy for a view" width="232" height="222"></div><br/><p>Sherlock defines specific paths for several predefined services and uses. Your channel can use these paths to store data persistently or to customize aspects of your channel such as its printing behavior. Some of these paths represent temporary variables, while others generate special notifications. You can define triggers for any of these paths to respond to its changes or notifications. </p><p>Channels do not share data with other channels or other instances of the same channel by default. Each window in Sherlock contains its own instantiation of a particular channel, and as such maintains its own separate copy of the data store. The only way to share data between channels is through the persistent storage paths of the data store. For more information, see <span class="content_text"><a href="ScriptExtensions.html#//apple_ref/doc/uid/20001085-124492">“Persistent Storage Paths.”</a></span></p><a name="//apple_ref/doc/uid/20001082-116469" title="Understanding Triggers"></a><a name="//apple_ref/doc/uid/20001082-116469-BCIEIEIF" title="Understanding Triggers"></a><h3>Understanding Triggers</h3><p>A trigger is an event handler that responds to changes in the data store or to explicit notifications sent by Sherlock or your channel. You use triggers to respond to events in your channel’s user interface and to handle other explicit or implicit notifications. The implementation of your trigger defines the behavior of your channel. </p><p>You define a trigger using the <code>&lt;trigger></code> tag in your channel’s XML Triggers file. The content of this tag is the script code you want to execute. Every trigger must be associated with a specific path in the data store. Sherlock calls your trigger when a notification is sent to that path, whether because of a change in the data at that location or because of an explicit notification sent by Sherlock or your code. You specify the trigger’s path using the <code>path</code> attribute. You can include additional attributes to specify other information needed by the trigger. See <span class="content_text"><a href="ScriptExtensions.html#//apple_ref/doc/uid/20001085-134716">“Trigger Tag Syntax”</a></span> for more information. </p><p><span class="content_text">Figure 5</span> shows the relationship between a channel’s user interface and its triggers. The search button action has a specific path in the data store. When the user clicks the button, Sherlock generates a notification at that path to notify the channel that the button was pressed. Sherlock finds the trigger that responds to that path and executes its script code, passing in any additional information requested by the trigger. </p><br/><div><a name="//apple_ref/doc/uid/20001082-116321-BCIFHBHF" title="Figure 5Relationship between the channel interface and triggers"></a><p><a name="//apple_ref/doc/uid/20001082-116321" title="Figure 5Relationship between the channel interface and triggers"></a><strong>Figure 5&nbsp;&nbsp;</strong>Relationship between the channel interface and triggers</p><img src = "art/channel_inter_trigg.gif" alt = "Relationship between the channel interface and triggers" width="396" height="503"></div><br/><p>The script code for your triggers can be written using either JavaScript or XQuery, which is part of the XML Query specification. Each language has its strengths and weaknesses depending on the intended use. JavaScript is well suited for triggers that need to make dynamic decisions based on the current state of the channel. XQuery is well suited for performing operations that require complex text processing of data, such as generating query strings and parsing search results. Apple provides extensions to both languages for accessing Sherlock functionality. For more information on these extensions, see <span class="content_text"><a href="ScriptExtensions.html#//apple_ref/doc/uid/20001085-BAJBFIAE">“Sherlock Reference.”</a></span> </p><a name="//apple_ref/doc/uid/20001082-116342" title="Deploying Channels"></a><h3>Deploying Channels</h3><p>Unlike previous versions of Sherlock, which required the user to download a plug-in and install it locally, Sherlock now supports channel deployment over the Web. Web deployment simplifies the task of installing channels and also provides an easy way to update the channel content automatically. Sherlock caches the files of a channel and downloads them again when it detects any changes. </p><p>Sherlock also supports the grouping of channels together into a subscription. Subscriptions let the user enable or disable a group of channels all at once. They also make it easier for the user to download a group of channels initially. For example, Apple provides a subscription for three development-related channels. You can enable these channels from the Debug menu, when it is enabled.</p><a name="//apple_ref/doc/uid/20001082-116810" title="Web Services"></a><h2>Web Services</h2><p>Although many developers will want to create channels for use in Sherlock, you can also create web services for use by channels. A web service is a routine or library of routines that performs a specific operation. Developing web services for your channels is a very simple process. All you do is place one or more routines in an XML file and deploy that file on your website. </p><p>Unlike many web services which run on the server, Sherlock web services run locally in the user’s environment. Sherlock web services are essentially script files that the user’s machine downloads and executes. A channel can include a web service file directly or it can use the <code>sherlock-function</code> routine from an XQuery script to access a specific routine of the web service. </p><p>In addition to developing your own web services, you can access existing web services by writing your own protocol wrappers. For examples of how to create and use web services, see the article <span class="content_text"><a href="../Tasks/CreatingWebServices.html#//apple_ref/doc/uid/20001089-BCIIDJDC">“Using Web Services.”</a></span> </p><a name="//apple_ref/doc/uid/20001082-117675" title="Data Caching Strategies"></a><h2>Data Caching Strategies</h2><p>In order to improve performance, Sherlock provides caching facilities to store channel files and data locally. Because caching may not be appropriate all the time, Sherlock provides channel developers with some flexibility over when to employ it. This section discusses the caching strategies available to developers of Sherlock channels.</p><a name="//apple_ref/doc/uid/20001082-117686" title="Using Checkpoints"></a><h3>Using Checkpoints</h3><p>Although storing channel files on a server makes it easier to deploy updates to your channels, performance issues arise for users with slow network connections. Normally, when a channel is selected, Sherlock checks the modification dates of every file in the channel to see if any of the files changed. While it may not download every file, performing the network requests for these files can still take a noticeable amount of time. To eliminate this performance penalty, Sherlock supports the use of a checkpoint file to determine when a channel has changed.</p><p>If you implement checkpoint support, your channel configuration file acts as the checkpoint for your channel. The channel configuration file is the first file accessed by Sherlock when your channel is selected. This file contains a single <code>channel_info</code> tag with attributes telling Sherlock where to find your channel’s resources. With checkpoints enabled, Sherlock compares the modification date of the cached file with the one on the server. If the modification dates are the same, Sherlock knows that the channel has not changed and uses the cached files whose download date is later than the checkpoint file. </p><p>If you implement checkpoint support in your channel, it is your responsibility to touch the modification date of your channel configuration file whenever you modify your channel. If you do not, users may not receive updates to your channel.</p><p>If your company provides a subscription for several channels, you can also use checkpoints in your subscription files to further reduce the number of network requests. Subscription files contain links to one or more channels. If the modification date of the cached subscription file differs from the server-based file, Sherlock then proceeds to check for changes to the channels of the subscription; otherwise, it assumes all channels are up-to-date.</p><p>For more information on the <code>channel_info</code> tag and enabling checkpoints in channels, see <span class="content_text"><a href="ScriptExtensions.html#//apple_ref/doc/uid/20001085-133218">“Channel Information Tag Syntax.”</a></span> For information on creating a subscription, see <span class="content_text"><a href="../Tasks/InstallingAccessing.html#//apple_ref/doc/uid/20001087-110335">“Setting Up Subscriptions.”</a></span></p><a name="//apple_ref/doc/uid/20001082-117161" title="Favoring Cached Data"></a><h3>Favoring Cached Data</h3><p>Another place where Sherlock provides caching support is in the loading of files from the network. The <code>http-request</code> function in XQuery lets you request data from a network server. When you request a file for the first time using this method, Sherlock fetches it from the network and caches it. On subsequent requests, Sherlock compares the modification date of the cached file to the server file and returns the cached file if the dates are the same. However, you can eliminate this secondary network access by specifying some additional flags with the <code>http-request</code> function.</p><p>When you include the flag <code>FavorCache</code> in a request, Sherlock attempts to load the file from the cache. If the file is cached, Sherlock returns the cached copy without checking the network; otherwise, Sherlock loads the file from the network as usual. You can also use the <code>FavorCacheUpdate</code> flag to tell Sherlock to use the cached version now but to check the network for a newer version in the background. You may not get the newest file right away, but the next time you need it, the latest copy will be in the cache.</p><p>For more information on loading cached data files, see the description for <span class="content_text"><a href="ScriptExtensions.html#//apple_ref/doc/uid/20001085-126201">“http-request.”</a></span> </p><a name="//apple_ref/doc/uid/20001082-117352" title="Version Information"></a><h2>Version Information</h2><p>As new features are added to the Sherlock development environment, developers may be wary of adding those features to a channel because of problems with backwards compatibility. Because not all users will have the same version of Sherlock installed on their system, channels need a way to identify code with new features and prevent them from running in unsupported environments. Sherlock handles this through the use of version attributes on a channel’s tags. With version attributes, you can be sure that Sherlock runs new code in only those environments that support the new features.</p><p>Sherlock provides version information for three distinct portions of the system: the channel, the XQuery language, and the JavaScript language. Each tag that recognizes version information supports both a <code>version</code> and <code>maxVersion</code> attribute to specify the minimum and maximum supported versions, respectively. <span class="content_text">Table 1</span> shows the version information for Sherlock in different releases of Mac OS X.</p><a name="//apple_ref/doc/uid/20001082-118507-BCIIACIA" title="Table 1Sherlock version information"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><a name="//apple_ref/doc/uid/20001082-118507" title="Table 1Sherlock version information"></a><strong>Table 1&nbsp;&nbsp;</strong>Sherlock version information</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Item</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>10.2</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>10.2.2</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>10.2.3</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>10.2.5</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>10.3</p></th></tr><tr><td  scope="row"><p>Channel</p></td><td ><p>1.0</p></td><td ><p>1.1</p></td><td ><p>1.2</p></td><td ><p>1.3</p></td><td ><p>1.4</p></td></tr><tr><td  scope="row"><p>XQuery</p></td><td ><p>1.0</p></td><td ><p>1.0</p></td><td ><p>1.0</p></td><td ><p>1.0</p></td><td ><p>1.0</p></td></tr><tr><td  scope="row"><p>JavaScript</p></td><td ><p>1.0</p></td><td ><p>1.0</p></td><td ><p>1.0</p></td><td ><p>1.0</p></td><td ><p>1.0</p></td></tr></table></div><p>The channel version information is supported by the following tags: </p><ul class="ul"><li class="li"><p><code>&lt;channel></code> tags in a subscription file</p></li><li class="li"><p><code>&lt;channel_info></code> tag in a channel configuration file</p></li><li class="li"><p><code>&lt;scripts></code> tags in a code file</p></li></ul><p>Although Sherlock performs version checks of tags internally, you can also get the channel version information programmatically if needed. To get the channel version, use the <code>channel-version</code> function from XQuery or the <code>ChannelVersion</code> function of the System object from JavaScript.</p><div class="importantbox"><a name="//apple_ref/doc/uid/20001082-DontLinkElementID_2" title="Important:"></a><p><strong>Important:</strong>&nbsp;The version of Sherlock that shipped with the original Mac OS X version 10.2 does not recognize the <code>version</code> attribute in <code>channel_info</code> tags. If you have a channel that requires Mac OS X 10.2.2 or later, you should include initialization code in your channel that checks the current channel version programmatically. If the channel version is “1.0”, you can suggest upgrading to the latest system software using the System Update Preference panel.</p><p></p></div><p>The XQuery and JavaScript version information is checked by the following tags:</p><ul class="ul"><li class="li"><p><code>&lt;initialize></code> tag in a channel code file</p></li><li class="li"><p><code>&lt;trigger></code> tags in a channel code file</p></li><li class="li"><p><code>&lt;script></code> tags in a code file</p></li></ul><p>To get the current JavaScript version, use the <code>Version</code> method of the System object. To get the current XQuery version, use the <code><a href="../../../../Security/Reference/AuthorizationPluginRef/Reference/reference.html#//apple_ref/doc/c_ref/version" target="_top">version</a></code> function.</p><p>For more information on tag syntax and version attributes, see <span class="content_text"><a href="ScriptExtensions.html#//apple_ref/doc/uid/20001085-132603">“XML Tag Syntax.”</a></span> </p>

        <br/><br/> 

        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Sherlock.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="DevelopingChannels.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2002, 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-04-09<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/AppleApplications/Conceptual/Sherlock/Concepts/ChannelArchitecture.html%3Fid%3D10000121i-2.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/AppleApplications/Conceptual/Sherlock/Concepts/ChannelArchitecture.html%3Fid%3D10000121i-2.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/AppleApplications/Conceptual/Sherlock/Concepts/ChannelArchitecture.html%3Fid%3D10000121i-2.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>
