<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>WiredSprites - /Common Files/SpriteUtilities.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/QuickTime/index.html">QuickTime</a> &gt; <a href="../../samplecode/QuickTime/idxWiredMoviesandSprites-date.html">Wired Movies and Sprites</a> &gt; <A HREF="javascript:location.replace('index.html');">WiredSprites</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">WiredSprites</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Common Files/SpriteUtilities.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Application Files/ComApplication.c</option>
<option value="listing2.html">/Application Files/ComApplication.h</option>
<option value="listing3.html">/Application Files/ComResource.h</option>
<option value="listing4.html">/Application Files/QTWiredSprites.r</option>
<option value="listing5.html">/Application Files/WiredSpriteUtilities.c</option>
<option value="listing6.html">/Application Files/WiredSpriteUtilities.h</option>
<option value="listing7.html">/Clippings/AddMovieResource.txt</option>
<option value="listing8.html">/Clippings/AddOverrideSamples.txt</option>
<option value="listing9.html">/Clippings/AddSpriteActions.txt</option>
<option value="listing10.html">/Clippings/AddSpriteSampleToMedia.txt</option>
<option value="listing11.html">/Clippings/AssignImageGroupIDs.txt</option>
<option value="listing12.html">/Clippings/CreateKeyFrameSample.txt</option>
<option value="listing13.html">/Clippings/CreateMovieFile.txt</option>
<option value="listing14.html">/Clippings/InsertMediaIntoTrack.txt</option>
<option value="listing15.html">/Clippings/SetSpriteProperties.txt</option>
<option value="listing16.html">/Clippings/SpriteTrackProperties.txt</option>
<option value="listing17.html">/Common Files/ComFramework.c</option>
<option value="listing18.html">/Common Files/ComFramework.h</option>
<option value="listing19.html">/Common Files/EndianUtilities.c</option>
<option value="listing20.html">/Common Files/EndianUtilities.h</option>
<option value="listing21.html">/Common Files/ImageCompressionUtilities.c</option>
<option value="listing22.html">/Common Files/ImageCompressionUtilities.h</option>
<option value="listing23.html">/Common Files/MacFramework.c</option>
<option value="listing24.html">/Common Files/MacFramework.h</option>
<option value="listing25.html">/Common Files/MacPrefix.h</option>
<option value="listing26.html">/Common Files/QTUtilities.c</option>
<option value="listing27.html">/Common Files/QTUtilities.h</option>
<option value="listing28.html">/Common Files/SpriteUtilities.c</option>
<option value="listing29.html">/Common Files/SpriteUtilities.h</option>
<option value="listing30.html">/Common Files/WinFramework.c</option>
<option value="listing31.html">/Common Files/WinFramework.h</option>
<option value="listing32.html">/Common Files/WinPrefix.h</option>
<option value="listing33.html">/Completed Lab/QTWiredSprites.c</option>
<option value="listing34.html">/Completed Lab/QTWiredSprites.h</option>
<option value="listing35.html">/Start Code/QTWiredSprites.c</option>
<option value="listing36.html">/Start Code/QTWiredSprites.h</option></select>
				</p>
				</form>
				<p><strong><a href="WiredSprites.zip">Download Sample</a></strong> (&#147;WiredSprites.zip&#148;, 1.43M)<BR>
<strong><a href="WiredSprites.dmg">Download Sample</a></strong> (&#147;WiredSprites.dmg&#148;, 1.96M)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">//////////////  File:    SpriteUtilities.c////  Contains:  Utilities for adding sprite tracks to QuickTime movies.////  Written by:  Sean Allen//  Revised by:  Chris Flick and Tim Monroe////  Copyright:  &copy; 1997-1998 by Apple Computer, Inc., all rights reserved.////  Change History (most recent first):////     &lt;3&gt;     03/27/98  rtm    added error checking to AddPICTImageToKeyFrameSample to prevent crashes//                  if PICT resources not found//     &lt;2&gt;     03/27/98  cf    further fixes for Windows compiles//     &lt;1&gt;     03/26/98  rtm    made fixes for Windows compiles//     ////////////#ifndef _SPRITEUTILITIES_#include &quot;SpriteUtilities.h&quot;#endif#ifndef _IMAGECOMPRESSIONUTILITIES_#include &quot;ImageCompressionUtilities.h&quot;#endif#ifndef __ENDIANUTILITIES__#include &quot;EndianUtilities.h&quot;#endif#ifndef __RESOURCES__#include &lt;Resources.h&gt;#endif#ifndef __QUICKTIMECOMPONENTS__#include &lt;QuickTimeComponents.h&gt;#endif#ifndef __MEDIAHANDLERS__#include &lt;MediaHandlers.h&gt;#endif// exception handling macros#define    FailIf(a, e)     {if (a)   { err = e; goto bail; }}#define    FailOSErr(a)     {if (err = a)   goto bail;}#define    FailMemErr(a)    {a; if (err = MemError()) goto bail;}OSErr GetImageDescription( QTAtomContainer keySample, QTAtom imagesContainerAtom, short imageIndex, ImageDescriptionHandle imageDesc );OSErr SetImageGroupID( QTAtomContainer keySample, QTAtom imagesContainerAtom, short imageIndex, long groupID );OSErr GetImageGroupID( QTAtomContainer keySample, QTAtom imagesContainerAtom, short imageIndex, long *groupID );OSErr SetSpriteData( QTAtomContainer sprite, Point *location, short *visible, short *layer, short *imageIndex, ModifierTrackGraphicsModeRecord *graphicsMode, StringPtr spriteName, QTAtomContainer actionAtoms ){  OSErr  err = noErr;  QTAtom  propertyAtom;    if ( location ) {    MatrixRecord  matrix;        SetIdentityMatrix( &amp;matrix );    matrix.matrix[2][0] = ((long)location-&gt;h &lt;&lt; 16);    matrix.matrix[2][1] = ((long)location-&gt;v &lt;&lt; 16);        EndianUtils_MatrixRecord_NtoB( &amp;matrix );    if ( (propertyAtom = QTFindChildByIndex( sprite, 0, kSpritePropertyMatrix, 1, nil )) == 0 )      FailOSErr( QTInsertChild( sprite, 0, kSpritePropertyMatrix, 1, 0, sizeof(MatrixRecord), &amp;matrix, nil ) )    else      FailOSErr( QTSetAtomData( sprite, propertyAtom, sizeof(MatrixRecord), &amp;matrix ) );  }  if ( visible ) {    short tempVisible = *visible;        tempVisible = EndianS16_NtoB(tempVisible);        if ( (propertyAtom = QTFindChildByIndex( sprite, 0, kSpritePropertyVisible, 1, nil )) == 0 )      FailOSErr( QTInsertChild( sprite, 0, kSpritePropertyVisible, 1, 0, sizeof(short), &amp;tempVisible, nil ) )    else      FailOSErr( QTSetAtomData( sprite, propertyAtom, sizeof(short), &amp;tempVisible ) );  }  if ( layer ) {    short tempLayer = *layer;        tempLayer = EndianS16_NtoB(tempLayer);    if ( (propertyAtom = QTFindChildByIndex( sprite, 0, kSpritePropertyLayer, 1, nil )) == 0 )      FailOSErr( QTInsertChild( sprite, 0, kSpritePropertyLayer, 1, 0, sizeof(short), &amp;tempLayer, nil ) )    else      FailOSErr( QTSetAtomData( sprite, propertyAtom, sizeof(short), &amp;tempLayer ) );  }  if ( imageIndex ) {    short tempImageIndex = *imageIndex;    tempImageIndex = EndianS16_NtoB(tempImageIndex);        if ( (propertyAtom = QTFindChildByIndex( sprite, 0, kSpritePropertyImageIndex, 1, nil )) == 0 )      FailOSErr( QTInsertChild( sprite, 0, kSpritePropertyImageIndex, 1, 0, sizeof(short), &amp;tempImageIndex, nil ) )    else      FailOSErr( QTSetAtomData( sprite, propertyAtom, sizeof(short), &amp;tempImageIndex ) );  }  if ( graphicsMode ) {    ModifierTrackGraphicsModeRecord  tempGraphicsMode;        tempGraphicsMode.graphicsMode  = EndianU32_NtoB(graphicsMode-&gt;graphicsMode);    tempGraphicsMode.opColor.red   = EndianU16_NtoB(graphicsMode-&gt;opColor.red);    tempGraphicsMode.opColor.green  = EndianU16_NtoB(graphicsMode-&gt;opColor.green);    tempGraphicsMode.opColor.blue  = EndianU16_NtoB(graphicsMode-&gt;opColor.blue);    if ( (propertyAtom = QTFindChildByIndex( sprite, 0, kSpritePropertyGraphicsMode, 1, nil )) == 0 )      FailOSErr( QTInsertChild( sprite, 0, kSpritePropertyGraphicsMode, 1, 0, sizeof(tempGraphicsMode), &amp;tempGraphicsMode, nil ) )    else      FailOSErr( QTSetAtomData( sprite, propertyAtom, sizeof(tempGraphicsMode), &amp;tempGraphicsMode ) );  }  if( spriteName ) {    QTAtom spriteNameAtom;        if ( (spriteNameAtom = QTFindChildByIndex( sprite, 0, kSpriteNameAtomType, 1, nil )) == 0 )      FailOSErr( QTInsertChild( sprite, 0, kSpriteNameAtomType, 1, 0, spriteName[0]+1, spriteName, nil ) )    else      FailOSErr( QTSetAtomData( sprite, spriteNameAtom, spriteName[0]+1, spriteName ) );  }    if ( actionAtoms ) {    FailOSErr( QTInsertChildren( sprite, kParentAtomIsContainer, actionAtoms ) );  }  bail:  if ( err &amp;&amp; sprite )    QTRemoveChildren( sprite, 0 );  return err;}OSErr AddSpriteToSample( QTAtomContainer theSample, QTAtomContainer theSprite, QTAtomID spriteID ){  OSErr  err = noErr;  QTAtom  newSpriteAtom;    FailIf ( QTFindChildByID( theSample, 0, kSpriteAtomType, spriteID, nil ), paramErr );    FailOSErr( QTInsertChild( theSample, 0, kSpriteAtomType, spriteID, 0, 0, nil, &amp;newSpriteAtom ) );    // index of zero means append  FailOSErr( QTInsertChildren( theSample, newSpriteAtom, theSprite ) );bail:  return err;}OSErr AddSpriteSampleToMedia( Media theMedia, QTAtomContainer sample, TimeValue duration, Boolean isKeyFrame,            TimeValue *sampleTime ){  OSErr          err = noErr;  SampleDescriptionHandle sampleDesc = nil;    FailMemErr( sampleDesc = (SampleDescriptionHandle) NewHandleClear( sizeof(SpriteDescription ) ) );    FailOSErr( AddMediaSample(   theMedia, (Handle) sample, 0, GetHandleSize( sample ),                duration, sampleDesc, 1,                (short)(isKeyFrame ? 0 : mediaSampleNotSync), sampleTime ) );bail:  if ( sampleDesc )  DisposeHandle( (Handle) sampleDesc );  return err;}OSErr AddCompressedSpriteSampleToMedia( Media theMedia, QTAtomContainer sample, TimeValue duration, Boolean isKeyFrame,            OSType dataCompressorType,            TimeValue *sampleTime ){  OSErr          err = noErr;  SpriteDescriptionHandle sampleDesc = nil;  Handle          compressedSample = nil;  ComponentInstance    dataCompressorComponentInstance = nil;    err = OpenADefaultComponent(DataCompressorComponentType, dataCompressorType, &amp;dataCompressorComponentInstance);  if( err ) goto bail;  FailMemErr( sampleDesc = (SpriteDescriptionHandle) NewHandleClear( sizeof(SpriteDescription) ) );    if( dataCompressorComponentInstance != nil ) {    UInt32      compressBufferSize, actualCompressedSize, decompressSlop = 0;    UInt32      uncompressedSize;    SignedByte     saveState = HGetState( sample );        err = (OSErr)DataCodecGetCompressBufferSize( dataCompressorComponentInstance, GetHandleSize( sample ), &amp;compressBufferSize );    if(err) goto bail;        compressedSample = NewHandle( sizeof(UInt32) + compressBufferSize );    err = MemError();    if(err) goto bail;        HLockHi( sample );    HLockHi( compressedSample );    err = (OSErr)DataCodecCompress( dataCompressorComponentInstance, *sample,                 GetHandleSize(sample),                 *compressedSample + sizeof(UInt32),     // room for size at beginning                compressBufferSize,                 &amp;actualCompressedSize,                &amp;decompressSlop );        HSetState( sample, saveState );    HUnlock( compressedSample );        if(err) goto bail;        SetHandleSize( compressedSample, sizeof(UInt32) + actualCompressedSize );    err = MemError();    if(err) goto bail;    (**sampleDesc).decompressorType = EndianU32_NtoB(dataCompressorType);      uncompressedSize = GetHandleSize(sample);    (*(UInt32*) *compressedSample) = EndianU32_NtoB(uncompressedSize);    // add uncompressed size at beginning        FailOSErr( AddMediaSample(   theMedia, (Handle) compressedSample, 0, GetHandleSize( compressedSample ),                  duration, (SampleDescriptionHandle) sampleDesc, 1,                  (short)(isKeyFrame ? 0 : mediaSampleNotSync), sampleTime ) );  }  else  {    FailOSErr( AddMediaSample(   theMedia, (Handle) sample, 0, GetHandleSize( sample ),                  duration, (SampleDescriptionHandle) sampleDesc, 1,                  (short)(isKeyFrame ? 0 : mediaSampleNotSync), sampleTime ) );  }  bail:  if ( compressedSample )         DisposeHandle( compressedSample );  if ( sampleDesc )            DisposeHandle( (Handle) sampleDesc );  if ( dataCompressorComponentInstance )  CloseComponent( dataCompressorComponentInstance );    return err;}OSErr AddPICTImageToKeyFrameSample( QTAtomContainer keySample, short pictID, RGBColor *keyColor, QTAtomID id, FixedPoint *registrationPoint, StringPtr imageName ){  OSErr          err = noErr;  PicHandle        picture;  Handle          compressedPicture = NULL;  ImageDescriptionHandle  idh = NULL;    // get picture from resource  picture = (PicHandle) GetPicture( pictID );  if (picture == NULL)    err = resNotFound;  if(err) goto bail;    DetachResource( (Handle)picture );    // convert it to image data compressed by the animation compressor  err = RecompressPictureWithTransparency( picture, keyColor, nil, &amp;idh, &amp;compressedPicture );  if(err) goto bail;  // add it to the keySample  HLock( compressedPicture );  err = AddCompressedImageToKeyFrameSample( keySample, idh, GetHandleSize( compressedPicture ), *compressedPicture, id, registrationPoint, imageName );  bail:  if ( picture )        KillPicture( picture );  if ( compressedPicture )  DisposeHandle( compressedPicture );    if ( idh )          DisposeHandle( (Handle)idh );    return err;}OSErr AddCompressedImageToKeyFrameSample( QTAtomContainer keySample,         ImageDescriptionHandle idh, long dataSize, Ptr compressedDataPtr,         QTAtomID imageID, FixedPoint *registrationPoint, StringPtr imageName ){  OSErr    err = noErr;  Handle    imageData;  QTAtom    defaultsAtom, imagesContainerAtom, imageAtom;  ImageDescriptionHandle  bigEndianImageDescription = nil;#if TARGET_RT_LITTLE_ENDIAN  bigEndianImageDescription = (ImageDescriptionHandle) NewHandle(GetHandleSize((Handle)idh));  BlockMoveData( *idh, *bigEndianImageDescription, GetHandleSize((Handle)idh));  EndianUtils_ImageDescription_NtoB(bigEndianImageDescription);#else  bigEndianImageDescription = idh;      // already is big endian#endif  // append compressed picture data to imageDescription to obtain sprite image data  FailMemErr( imageData = NewHandle(0) );  FailMemErr( HandAndHand( (Handle)bigEndianImageDescription, imageData ) );  // imageData &lt;= imageData + bigEndianImageDescription  FailMemErr( PtrAndHand( compressedDataPtr, imageData, dataSize ) );    if ( (defaultsAtom = QTFindChildByIndex( keySample, 0, kSpriteSharedDataAtomType, 1, nil )) == 0 )    FailOSErr( QTInsertChild( keySample, 0, kSpriteSharedDataAtomType, 1, 0, 0, nil, &amp;defaultsAtom ) );      if ( (imagesContainerAtom = QTFindChildByIndex( keySample, defaultsAtom, kSpriteImagesContainerAtomType, 1, nil )) == 0 )    FailOSErr( QTInsertChild( keySample, defaultsAtom, kSpriteImagesContainerAtomType, 1, 0, 0, nil, &amp;imagesContainerAtom ) );  FailOSErr( QTInsertChild( keySample, imagesContainerAtom, kSpriteImageAtomType, imageID, 0, 0, nil, &amp;imageAtom ) );  HLock( imageData );  FailOSErr( QTInsertChild( keySample, imageAtom, kSpriteImageDataAtomType, 1, 0, GetHandleSize(imageData), *imageData, nil ) );  HUnlock( imageData );    if ( registrationPoint ) {    FixedPoint tempRegistrationPoint;        tempRegistrationPoint.x = EndianS32_NtoB(registrationPoint-&gt;x);    tempRegistrationPoint.y = EndianS32_NtoB(registrationPoint-&gt;y);        FailOSErr( QTInsertChild( keySample, imageAtom, kSpriteImageRegistrationAtomType, 1, 0, sizeof(tempRegistrationPoint), &amp;tempRegistrationPoint, nil ) );  }  else {    FixedPoint regPoint = { 0, 0 };        // Flipping {0,0} doesn't change anything so we don't flip        FailOSErr( QTInsertChild( keySample, imageAtom, kSpriteImageRegistrationAtomType, 1, 0, sizeof(regPoint), &amp;regPoint, nil ) );  }    if( imageName ) {    FailOSErr( QTInsertChild( keySample, imageAtom, kSpriteImageNameAtomType, 1, 0, imageName[0], &amp;imageName[1], nil ) );  }bail:#if TARGET_RT_LITTLE_ENDIAN  if(bigEndianImageDescription)    DisposeHandle((Handle)bigEndianImageDescription);#else  // bigEndianImageDescription is still idh, so don't dispose of it#endif  if ( imageData )  DisposeHandle( imageData );    return err;}OSErr AssignImageGroupIDsToKeyFrame( QTAtomContainer keySample ){  OSErr          err = noErr;  QTAtom          defaultsAtom, imagesContainerAtom;  ImageDescriptionHandle  firstImageDesc = nil, secondImageDesc = nil;  short          firstIndex, secondIndex, numImages;  CodecType        firstImageType, secondImageType;  long          groupID = 0, testID;    defaultsAtom = QTFindChildByIndex( keySample, 0, kSpriteSharedDataAtomType, 1, nil );  if ( ! defaultsAtom )  goto bail;    imagesContainerAtom = QTFindChildByIndex( keySample, defaultsAtom, kSpriteImagesContainerAtomType, 1, nil );  if ( ! imagesContainerAtom )  goto bail;    firstImageDesc = (ImageDescriptionHandle)NewHandle(0);  if ( firstImageDesc == nil ) { err = memFullErr; goto bail; }  secondImageDesc = (ImageDescriptionHandle)NewHandle(0);  if ( secondImageDesc == nil ) { err = memFullErr; goto bail; }  numImages = QTCountChildrenOfType( keySample, imagesContainerAtom, kSpriteImageAtomType );  for ( firstIndex = 1; firstIndex &lt;= numImages; firstIndex++ ) {    FailOSErr( SetImageGroupID( keySample, imagesContainerAtom, firstIndex, 0 ) );  }  for ( firstIndex = 1; firstIndex &lt;= (numImages - 1); firstIndex++ ) {    FailOSErr( GetImageGroupID( keySample, imagesContainerAtom, firstIndex, &amp;testID ) );    if ( testID == 0 ) {      groupID++;      FailOSErr( SetImageGroupID( keySample, imagesContainerAtom, firstIndex, groupID ) );            FailOSErr( GetImageDescription( keySample, imagesContainerAtom, firstIndex, firstImageDesc ) );      firstImageType = (**firstImageDesc).cType;            for ( secondIndex = (firstIndex + 1); secondIndex &lt;= numImages; secondIndex++ ) {        FailOSErr( GetImageGroupID( keySample, imagesContainerAtom, secondIndex, &amp;testID ) );        if ( testID == 0 ) {          FailOSErr( GetImageDescription( keySample, imagesContainerAtom, secondIndex, secondImageDesc ) );          secondImageType = (**secondImageDesc).cType;                  if ( firstImageType == secondImageType ) {            ImageSequence  seqID;            Boolean      equivalent;                        FailOSErr( DecompressSequenceBegin( &amp;seqID, firstImageDesc, nil, nil, nil, nil,                   ditherCopy, (RgnHandle)nil,  0, codecNormalQuality, anyCodec ) );                               CDSequenceEquivalentImageDescription( seqID, secondImageDesc, &amp;equivalent );            CDSequenceEnd( seqID );                        if ( equivalent ) {              FailOSErr( SetImageGroupID( keySample, imagesContainerAtom, secondIndex, groupID ) );            }          }        }      }    }  }  // assign an ID to the last image  FailOSErr( GetImageGroupID( keySample, imagesContainerAtom, numImages, &amp;testID ) );  if ( testID == 0 ) {    groupID++;    FailOSErr( SetImageGroupID( keySample, imagesContainerAtom, numImages, groupID ) );  }  bail:  if ( firstImageDesc )  DisposeHandle( (Handle)firstImageDesc );  if ( secondImageDesc )  DisposeHandle( (Handle)secondImageDesc );  return err;}// **** ImageDescriptionHandles are in native endianism, right? If so, we need to endian flip them before//    they're returned from GetImageDescription.OSErr GetImageDescription( QTAtomContainer keySample, QTAtom imagesContainerAtom, short imageIndex, ImageDescriptionHandle imageDesc ){  OSErr  err = noErr;  QTAtom  imageAtom, imageDataAtom;  UInt8  saveState;  UInt32  imageDescriptionSize;  imageAtom = QTFindChildByIndex( keySample, imagesContainerAtom, kSpriteImageAtomType, imageIndex, nil );  if ( imageAtom == 0 )  { err = cannotFindAtomErr; goto bail; }  imageDataAtom = QTFindChildByIndex( keySample, imageAtom, kSpriteImageDataAtomType, 1, nil );  if ( imageDataAtom == 0 )  { err = cannotFindAtomErr; goto bail; }  saveState = HGetState( (Handle)imageDesc );  HUnlock( (Handle)imageDesc );  // Copy the data (ImageDescription followed by image data) to a handle  FailOSErr( QTCopyAtomDataToHandle( keySample, imageDataAtom, (Handle)imageDesc ) );  imageDescriptionSize = EndianU32_BtoN((**imageDesc).idSize);  // Pull off anything following the image description (&amp; its color table, if any, and  //  any image description extensions.  SetHandleSize( (Handle)imageDesc, imageDescriptionSize );#if TARGET_RT_LITTLE_ENDIAN  EndianUtils_ImageDescription_BtoN( imageDesc );#endif  HSetState( (Handle)imageDesc, saveState );  err = MemError();  bail:  return err;}OSErr SetImageGroupID( QTAtomContainer keySample, QTAtom imagesContainerAtom, short imageIndex, long groupID ){  OSErr    err = noErr;  QTAtom    imageAtom, imageGroupAtom;    imageAtom = QTFindChildByIndex( keySample, imagesContainerAtom, kSpriteImageAtomType, imageIndex, nil );  if ( imageAtom == 0 )  { err = cannotFindAtomErr; goto bail; }  imageGroupAtom = QTFindChildByIndex( keySample, imageAtom, kSpriteImageGroupIDAtomType, 1, nil );  if ( imageGroupAtom == 0 ) {    FailOSErr( QTInsertChild( keySample, imageAtom, kSpriteImageGroupIDAtomType, 1, 1, 0, nil, &amp;imageGroupAtom ) );  }  groupID = EndianU32_NtoB(groupID);  FailOSErr( QTSetAtomData( keySample, imageGroupAtom, sizeof( groupID ), &amp;groupID ) );bail:  return err;} OSErr GetImageGroupID( QTAtomContainer keySample, QTAtom imagesContainerAtom, short imageIndex, long *groupID ){  OSErr    err = noErr;  QTAtom    imageAtom, imageGroupAtom;  imageAtom = QTFindChildByIndex( keySample, imagesContainerAtom, kSpriteImageAtomType, imageIndex, nil );  if ( imageAtom == 0 )  { err = cannotFindAtomErr; goto bail; }  imageGroupAtom = QTFindChildByIndex( keySample, imageAtom, kSpriteImageGroupIDAtomType, 1, nil );    if ( ! imageGroupAtom )    *groupID = 0;  else {    FailOSErr( QTCopyAtomDataToPtr( keySample, imageGroupAtom, false, sizeof(*groupID), (Ptr)groupID, nil ) );    *groupID = EndianU32_BtoN(*groupID);    // return native endian long  }  bail:  return err;} </pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/WiredSprites/listing28.html%3Fid%3DDTS10001044-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/WiredSprites/listing28.html%3Fid%3DDTS10001044-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/WiredSprites/listing28.html%3Fid%3DDTS10001044-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>