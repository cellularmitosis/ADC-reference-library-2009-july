<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>SCSI Find Devices - /SCSIFindNextDevice.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxHardwareDrivers-date.html">Hardware & Drivers</a> &gt; <A HREF="javascript:location.replace('index.html');">SCSI Find Devices</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/HardwareDrivers/idxSCSI-date.html" target="_blank">Hardware & Drivers > SCSI</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">SCSI Find Devices</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/SCSIFindNextDevice.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/SCSIFindDevices.h</option>
<option value="listing2.html">/SCSIFindDevicesMain.c</option>
<option value="listing3.html">/SCSIFindNextDevice.c</option></select>
				</p>
				</form>
				<p><strong><a href="SCSI_Find_Devices.zip">Download Sample</a></strong> (&#147;SCSI_Find_Devices.zip&#148;, 42.3K)<BR>
<strong><a href="SCSI_Find_Devices.dmg">Download Sample</a></strong> (&#147;SCSI_Find_Devices.dmg&#148;, 104.4K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    SCSIFindNextDevice.c  Contains:  Find all SCSI devices. The alogrithm first asks the SCSI Manager for the        number of buses, then loops through each bus for each device and LUN.        old SCSI Manager. This is made complex by the flexible SCSI Manager 4.3        architecture: it is possible for the asynchronous SCSI Manager to only         be available on a third-party bus interface, for example. Because of this,        we must always scan the bus using the original SCSI Manager even if the        asynchronous manager is present.  Written by: Martin Minow.    Copyright:  Copyright &copy; 1992-1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        7/14/1999  Karl Groethe  Updated for Metrowerks Codewarror Pro 2.1        */#include &lt;Errors.h&gt;#include &lt;Events.h&gt;#include &lt;Memory.h&gt;#include &lt;OSUtils.h&gt;#include &lt;Traps.h&gt;#include &lt;Types.h&gt;#include &quot;SCSIFindDevices.h&quot;#ifndef FALSE#define FALSE  0#define TRUE  1#endif/* * All functions use the same formal parameter to access the &quot;global&quot; record. */#define REC  (*scsiFindDevicesPtr)/* * These are the states that control the overall process. */enum {  kStateInitialize = 0,  kStateNextBus,  kStateNextTarget,  kStateNextLUN,  kStateCheckForHardWired,  kStateNextHardWiredTarget,  kStateNextHardWiredLUN,  kStateLastStateWithoutATrailingCommaBecauseWeCareAboutYou};/* * These are the commands that may be sent to the device. Request Sense is only * sent by the original SCSI Manager. */#define kScsiCmdInquiry        0x12#define kScsiCmdRequestSense    0x03/* * These are the device types that SCSI knows about. */  enum {  kScsiDevTypeDirect          = 0,  kScsiDevTypeSequential,  kScsiDevTypePrinter,  kScsiDevTypeProcessor,  kScsiDevTypeWorm,            /* Write-once, read multiple    */  kScsiDevTypeCDROM,  kScsiDevTypeScanner,  kScsiDevTypeOptical,  kScsiDevTypeChanger,  kScsiDevTypeComm,  kScsiDevTypeGraphicArts0A,  kScsiDevTypeGraphicArts0B,  kScsiDevTypeFirstReserved,        /* Start of reserved sequence    */  kScsiDevTypeUnknownOrMissing    = 0x1F,  kScsiDevTypeMask          = 0x1F};/* * These are device type modifiers. We need them to distinguish between &quot;unknown&quot; * and &quot;missing&quot; devices. */enum {  kScsiDevTypeQualifierConnected    = 0x00,  /* Exists and is connected    */  kScsiDevTypeQualifierNotConnected  = 0x20,  /* Logical unit exists      */  kScsiDevTypeQualifierReserved    = 0x40,  kScsiDevTypeQualifierMissing    = 0x60,  /* No such logical unit      */  kScsiDevTypeQualifierVendorSpecific  = 0x80,  /* Other bits are unspecified  */  kScsiDevTypeQualifierMask      = 0xE0};#define kScsiDevTypeMissing  \  (kScsiDevTypeUnknownOrMissing | kScsiDevTypeQualifierMissing)/* * This is the data that is returned after a GetExtendedStatus request. The * errorCode gives a general indication of the error, which may be qualified by * the additionalSenseCode and additionalSenseQualifier fields. These may be * device (vendor) specific values, however. The info[] field contains additional * information. For a media error, it contains the failing logical block number * (most-significant byte first). */struct SCSI_Sense_Data {          /* Request Sense result        */  unsigned char    errorCode;      /*  0  Class code, valid lbn    */  unsigned char    segmentNumber;    /*  1  Segment number        */  unsigned char    senseKey;      /*  2  Sense key and flags      */  unsigned char    info[4];  unsigned char    additionalSenseLength;  unsigned char    reservedForCopy[4];  unsigned char    additionalSenseCode;  unsigned char    additionalSenseQualifier;    unsigned char    fruCode;      /* Field replacable unit code    */  unsigned char    senseKeySpecific[2];  unsigned char    additional[101];};typedef struct SCSI_Sense_Data SCSI_Sense_Data;/* * The high-bit of errorCode signals whether there is a logical * block. The low value signals whether there is a valid sense */#define kScsiSenseHasLBN      0x80  /* Logical block number set      */#define kScsiSenseInfoValid      0x70  /* Is sense key valid?        */#define kScsiSenseInfoMask      0x70  /* Mask for sense info        *//* * These bits may be set in the sense key */#define kScsiSenseKeyMask      0x0F#define kScsiSenseILI        0x20  /* Illegal logical Length      */#define kScsiSenseEOM        0x40  /* End of media            */#define kScsiSenseFileMark      0x80  /* End of file mark          *//* * SCSI sense codes. (Returned after request sense). */#define   kScsiSenseNone        0x00  /* No error              */#define   kScsiSenseRecoveredErr    0x01  /* Warning              */#define   kScsiSenseNotReady      0x02  /* Device not ready          */#define   kScsiSenseMediumErr    0x03  /* Device medium error        */#define   kScsiSenseHardwareErr    0x04  /* Device hardware error      */#define   kScsiSenseIllegalReq    0x05  /* Illegal request for dev.      */#define   kScsiSenseUnitAtn      0x06  /* Unit attention (not err)      */#define   kScsiSenseDataProtect    0x07  /* Data protection          */#define   kScsiSenseBlankCheck    0x08  /* Tape-specific error        */#define   kScsiSenseVendorSpecific  0x09  /* Vendor-specific error      */#define   kScsiSenseCopyAborted    0x0a  /* Copy request cancelled      */#define   kScsiSenseAbortedCmd    0x0b  /* Initiator aborted cmd.      */#define   kScsiSenseEqual      0x0c  /* Comparison equal          */#define   kScsiSenseVolumeOverflow  0x0d  /* Write past end mark        */#define   kScsiSenseMiscompare    0x0e  /* Comparison failed        */#define   kScsiSenseCurrentErr    0x70#define   kScsiSenseDeferredErr    0x71/* * SCSI command status (from status phase) */#define   kScsiStatusGood      0x00  /* Normal completion        */#define   kScsiStatusCheckCondition  0x02  /* Need GetExtendedStatus      */#define   kScsiStatusConditionMet  0x04  /* For Compare Command?        */#define   kScsiStatusBusy      0x08  /* Device busy (self-test?)      */#define   kScsiStatusIntermediate  0x10  /* Intermediate status        */#define   kScsiStatusResConflict    0x18  /* Reservation conflict        */#define   kScsiStatusQueueFull    0x28  /* Target can't do command      */#define   kScsiStatusReservedMask  0x3e  /* Vendor specific?          *//* * This is the maximum number of times we try to grab the SCSI Bus */#define kMaxSCSIRetries        40    /* 10 seconds, 4 times/sec      *//* * This test is TRUE if the SCSI bus status indicates &quot;busy&quot; (which is the case * if either the BSY or SEL bit is set). */#ifndef kScsiStatBSY#define kScsiStatBSY        (1 &lt;&lt; 6)#endif#ifndef kScsiStatSEL#define kScsiStatSEL        (1 &lt;&lt; 1)#endif#define ScsiBusBusy()    ((SCSIStat() &amp; (kScsiStatBSY | kScsiStatSEL)) != 0)/* * These private routines do all the work. */static void          CheckForAsyncSCSI(    register SCSIFindDevicesPtr  scsiFindDevicesPtr  );static void          GetHighHostBusAdaptor(    register SCSIFindDevicesPtr  scsiFindDevicesPtr  );static OSErr        SetupForNextSCSIBus(    register SCSIFindDevicesPtr  scsiFindDevicesPtr  );static Boolean        IsRegisteredAsynchDevice(    register SCSIFindDevicesPtr  scsiFindDevicesPtr  );static Boolean        CheckForDevice(    register SCSIFindDevicesPtr  scsiFindDevicesPtr,    Boolean          useAsyncManager  );static OSErr        OriginalSCSI(    unsigned short      targetID,    Ptr            command,    Ptr            resultData,    unsigned long      resultSize,    long          *actualTransferSize  );static void          ClearMemory(    void          *recordPtr,    unsigned long      recordLength  );#define CLEAR(record)    ClearMemory(&amp;record, sizeof record);/* * This is the function that does all the work. Each time it is called, it finds * the next device (next logical unit, next target, next bus). The overall design * uses a state machine that continues within the function until one of three * things happen: it finds a device, it reaches the end of the device sequence, * or it gets an error. */OSErrSCSIFindNextDevice(    register SCSIFindDevicesPtr  scsiFindDevicesPtr  ){    OSErr            status;    Boolean            doNextState;        if (REC.deviceID.bus == 0xFF)      REC.state = kStateInitialize;    /*     * This is the overall state machine that processes application calls.     * Code in this section only organizes the lower-level routines. Many of     * the tests within the state switch change state. In all cases, they set     * doNextState TRUE and exit the switch. This, eventually, continues at     * the while statement which re-runs the state switch. A state-machine     * organization is not necessarily the best (and goto's would be slightly     * more efficient), but looping through a common switch statement     * simplified debugging.     */    doNextState = TRUE;    while (doNextState) {      doNextState = FALSE;      switch (REC.state) {      case kStateInitialize:        /*         * Initialization: check for the presence of the asynchronous         * SCSI Manager and get the last host bus. Then start with the         * first bus.         */        REC.scsiExecIOPB = NULL;        REC.execIOPBSize = 0;        CheckForAsyncSCSI(scsiFindDevicesPtr);        GetHighHostBusAdaptor(scsiFindDevicesPtr);        REC.state = kStateNextBus;        doNextState = TRUE;        break;      case kStateNextBus:        /*         * Look for the first/next bus. If we have a bus, we do some         * bus-specific initializations including, primarily, creating         * the SCSI parameter block.         */        if (REC.deviceID.bus == 0xFF)          REC.deviceID.bus = 0;      /* Do the first bus      */        else {          ++REC.deviceID.bus;        /* Do the next bus      */        }        if (REC.deviceID.bus &lt;= REC.lastHostBus) {          /*           * We have another bus to test. Make a SCSI parameter block           * that is properly sized for this bus.           */          status = SetupForNextSCSIBus(scsiFindDevicesPtr);          if (status == noErr) {            /*             * This bus exists: check its targets.             */            REC.deviceID.targetID = 0xFF;            REC.state = kStateNextTarget;            doNextState = TRUE;          }          else if (status == eofErr) {  /* eofErr is private    */            /*             * This bus does not exist. There may be gaps in the bus             * sequence if a third-party SCSI adaptor installs its             * own, private, SCSI Manager 4.3 on a machine that does             * not otherwise support asynchronous SCSI. Just continue             * with the next bus until we reach REC.lastHostBus.             */            REC.state = kStateNextBus;            doNextState = TRUE;          }          else {            /*             * Oops: this is a serious error. Since doNextState is             * FALSE, we will exit the while loop and return to the             * caller with a serious error.             */          }        }        else {          /*           * We've examined all of the buses accessable through SCSI           * Manager 4.3. Check for third-party devices that are only           * accessable through the original SCSI Manager (because they           * patch the SCSI Manager traps).           */          REC.deviceID.targetID = 0xFF;          REC.state = kStateCheckForHardWired;          doNextState = TRUE;        }        break;      case kStateNextTarget:        /*         * Look for the next device on this bus. If we run off the end,         * cycle back through the switch to look for the next bus.         */        if (REC.deviceID.targetID == 0xFF)          REC.deviceID.targetID = 0;      /* Do the first target  */        else {          ++REC.deviceID.targetID;      /* Do the next target  */        }        /*         * REC.initiatorID is set on a bus-by-bus basis. We cannot assume         * that it is always equal to seven. Skip over the initiator.         * REC.maxTargetID is normally seven; but it's provided to us         * by the SCSI Manager, so we'll use that value.         */         if (REC.deviceID.targetID == REC.initiatorID)          ++REC.deviceID.targetID;        if (REC.deviceID.targetID &gt; REC.maxTargetID) {          /*           * We've done all targets for this bus. Go on to the next bus.           */          REC.state = kStateNextBus;        }        else {          /*           * New target: do the first logical unit for this bus/target.           */          REC.deviceID.LUN = 0xFF;          REC.state = kStateNextLUN;        }        doNextState = TRUE;        break;      case kStateNextLUN:        /*         * We have a host bus and target ID. Cycle through the logical         * units for this target ID. We will always look at LUN zero.         * When we reach the end, the switch will take us to the next         * target ID.         */        if (REC.deviceID.LUN == 0xFF)          REC.deviceID.LUN = 0;        /* Do the first LUN    */        else {          ++REC.deviceID.LUN;          /* Do the next LUN    */        }        if (REC.deviceID.LUN &gt; REC.maxBusLUN) {          REC.state = kStateNextTarget;          doNextState = TRUE;        }        else {          /*           * Look for this LUN. Failures look for the next target.           */          if (CheckForDevice(scsiFindDevicesPtr, REC.useAsynchSCSI))             status = noErr;        /* This one exists    */          else {            /*             * This target/LUN was not found. Go on to the next             * SCSI bus ID. Note that we presume that there are no             * gaps in the LUN sequence.             */            REC.state = kStateNextTarget;            doNextState = TRUE;          }        }        break;      case kStateCheckForHardWired:        /*         * We have found all devices that can be accessed through the         * asynchronous SCSI Manager. Some third-party hardware interfaces         * do not use the asynchronous SCSI Manager, but patch original         * SCSI traps. If the asynchronous SCSI Manager is not available,         * we don't have to continue here (the above code found all         * devices. In this segment, we must hard-wire the initiator ID         * to seven, as there is no supported way to determine it from the         * SCSI Manager or operating system.         */        if (REC.isAsyncSCSIPresent == FALSE)          status = eofErr;        /* All done, thank you    */        else {          REC.deviceID.bus = 0;      /* Set the hard-wired data  */          REC.initiatorID = 7;          REC.maxTargetID = 7;          REC.state = kStateNextHardWiredTarget;          REC.deviceID.targetID = 0xFF;          doNextState = TRUE;        }        break;      case kStateNextHardWiredTarget:        /*         * Look at the next target on the built-in bus.         */        if (REC.deviceID.targetID == 0xFF)          REC.deviceID.targetID = 0;        else {          ++REC.deviceID.targetID;        }        if (REC.deviceID.targetID == REC.initiatorID)          ++REC.deviceID.targetID;        if (REC.deviceID.targetID &gt;= REC.maxTargetID)          status = eofErr;        /* All done, thank you    */        else {          REC.deviceID.LUN = 0xFF;          REC.state = kStateNextHardWiredLUN;          doNextState = TRUE;        }        break;      case kStateNextHardWiredLUN:        /*         * Look for the next LUN on the built-in bus.         */        if (REC.deviceID.LUN == 0xFF) {          REC.maxBusLUN = REC.maxLUN;          REC.deviceID.LUN = 0;        /* Do the first LUN    */        }        else {          ++REC.deviceID.LUN;          /* Do the next LUN    */        }        if (REC.deviceID.LUN &gt; REC.maxBusLUN) {          REC.state = kStateNextHardWiredTarget;          doNextState = TRUE;        }        else {          /*           * Look for this LUN. failures look for the next target.           * IsRegisteredAsynchDevice is TRUE if this device did not           * register with the asynchronous SCSI Manager.           */          if (IsRegisteredAsynchDevice(scsiFindDevicesPtr)) {            /*             * Since we know about this device, it would have been             * found by the first pass through the asynchronous             * SCSI Manager. So, we don't need to look at it here.             */            REC.state = kStateNextHardWiredLUN;            doNextState = TRUE;          }          else if (CheckForDevice(scsiFindDevicesPtr, FALSE)) {            /*             * This device was not registered, but it does exist             * if we check using the original SCSI Manager. Probably             * because someone patched the SCSI Manager traps.             * Return this to the caller.             */             status = noErr;        /* This one exists    */          }          else {            /*             * This target/LUN was not found. Go on to the next             * SCSI bus ID. Note that we presume that there are no             * gaps in the LUN sequence.             */            REC.state = kStateNextHardWiredTarget;            doNextState = TRUE;          }        }        break;      default:                  /* Illegal state    */        status = abortErr;            /* Can't happen      */        break;      }                      /* State switch      */    }                        /* While doNextState  */    if (status != noErr) {      /*       * We've done everything that we can. Re-initialize and release       * our saved parameter block.       */      REC.deviceID.bus = 0xFF;          /* Force reinitialize  */      if (REC.scsiExecIOPB != NULL) {        DisposePtr((Ptr) REC.scsiExecIOPB);        REC.scsiExecIOPB = NULL;      }    }    return (status);}/* * Check whether the Asynchronous SCSI trap is available. * Set REC.isAsyncSCSI appropriately. */static voidCheckForAsyncSCSI(    register SCSIFindDevicesPtr  scsiFindDevicesPtr  ){    TrapType        trapType;    short          theTrap;/* * TrapAvailable (see Inside Mac VI 3-8) */#define NumToolboxTraps() (                \    (NGetTrapAddress(_InitGraf, ToolTrap)      \        == NGetTrapAddress(0xAA6E, ToolTrap))  \      ? 0x200 : 0x400                \  )#define GetTrapType(theTrap) (              \    (((theTrap) &amp; 0x0800) != 0) ? ToolTrap : OSTrap  \  )    theTrap = _SCSIAtomic;    trapType = GetTrapType(theTrap);    if (trapType == ToolTrap) {      theTrap &amp;= 0x07FF;      if (theTrap &gt;= NumToolboxTraps())        theTrap = _Unimplemented;    }    REC.isAsyncSCSIPresent = (        NGetTrapAddress(theTrap, trapType)        != NGetTrapAddress(_Unimplemented, ToolTrap)      );#undef NumToolboxTraps#undef GetTrapType}/* * If we have the asynchronous SCSI Manager, find out how many buses are present * on this system. If we're limited to the original SCSI Manager, force a &quot;single * bus&quot; scan, since the function that actually calls the SCSI Manager ignores the * bus if the asynchronous manager is not present. */static voidGetHighHostBusAdaptor(    register SCSIFindDevicesPtr  scsiFindDevicesPtr  ){    OSErr              status;    SCSIBusInquiryPB        busInquiryPB;#define PB                (busInquiryPB)    if (REC.isAsyncSCSIPresent == FALSE)      REC.lastHostBus = 0;    else {      CLEAR(PB);      PB.scsiPBLength = sizeof PB;      PB.scsiFunctionCode = SCSIBusInquiry;      PB.scsiDevice.bus = 0xFF;      status = SCSIAction((SCSI_PB *) &amp;PB);      REC.lastHostBus = PB.scsiHiBusID;    }#undef PB}/* * Start to check a new SCSI bus. If we find a bus, allocate (or re-allocate) * the SCSIExecIO command block. Note that it is possible to have buses with * no devices, and gaps in the bus sequence. For example, in a Macintosh with * two buses (such as the Quadra 950 or PowerMac 8100), you can have a bus * with no devices.Also, if you install a third-party bus adaptor that supports * the asynchronous SCSI Manager on a machine with two buses, it would be * assigned bus 2 (with buses 0 and 1 referencing the internal system buses). * In this case, a system could have no devices on bus 0 or 1. */ static OSErrSetupForNextSCSIBus(    register SCSIFindDevicesPtr  scsiFindDevicesPtr  ){    OSErr            status;    SCSIBusInquiryPB      busInquiryPB;#define PB              (busInquiryPB)    /*     * If we don't support asynchronous SCSI, nothing happens here.     */    if (REC.isAsyncSCSIPresent == FALSE) {      REC.useAsynchSCSI = FALSE;      REC.initiatorID = 7;      REC.maxTargetID = 7;      REC.maxBusLUN = REC.maxLUN;      status = noErr;    }    else {      CLEAR(PB);      PB.scsiPBLength = sizeof PB;      PB.scsiFunctionCode = SCSIBusInquiry;      PB.scsiDevice.bus = REC.deviceID.bus;  /* Other values are zero  */      status = SCSIAction((SCSI_PB *) &amp;PB);      if (status == noErr) {        REC.useAsynchSCSI = TRUE;      /* Asynch works on this bus  */        REC.initiatorID = PB.scsiInitiatorID;        REC.maxTargetID = PB.scsiMaxTarget;        /*         * If we are running on a Quadra 840-AV with a CD300, the         * Macintosh will hang if it tries to access LUN 1. We check for         * this problem in two ways: by examining a global maxLUN flag,         * and by checking whether the bug was fixed, either by running         * on later hardware or by installing a System Update.         */        REC.enableATN =          (busInquiryPB.scsiWeirdStuff &amp; scsiTargetDrivenSDTRSafe) != 0;         REC.maxBusLUN = (REC.enableATN) ? REC.maxLUN : 0;        /*         * Allocate a parameter block for this request using the size that         * was returned in the busInquiry parameter block.         */        if (REC.execIOPBSize != PB.scsiIOpbSize) {          if (REC.scsiExecIOPB != NULL) {            DisposePtr((Ptr) REC.scsiExecIOPB);            REC.scsiExecIOPB = NULL;          }          REC.scsiExecIOPB =                (SCSIExecIOPB *) NewPtrClear(PB.scsiIOpbSize);          if (REC.scsiExecIOPB == NULL)            status = MemError();          else {            REC.execIOPBSize = PB.scsiIOpbSize;            status = noErr;          }        }      }      else if (PB.scsiDevice.bus == 0) {        /*         * If bus zero is not registered, it must be accessed via the         * original API. Set the initiatorID to the default 7 - there is         * no supported mechanism for determining the actual id (it's         * hidden inside the parameter RAM, but cannot be set by a         * published mechanism).         */        REC.useAsynchSCSI = FALSE;        REC.initiatorID = 7;        REC.maxTargetID = 7;        REC.maxBusLUN = REC.maxLUN;        status = noErr;      }      else {        /*         * This is a problem: this bus cannot be accessed unless it has         * been registered. For example, the second bus of a Quadra         * 950 cannot be accessed if the SCSI Manager extension is not         * installed and a third-party asynchronous SCSI Manager card         * is installed as bus 2. Return a private error to skip this bus.         */        status = eofErr;      }    }    return (status);#undef PB}/* * This is called if the asynchronous SCSI Manager is present to sweep up any * third party devices that did not register with the asynchronous SCSI Manager. */static BooleanIsRegisteredAsynchDevice(    register SCSIFindDevicesPtr  scsiFindDevicesPtr  ){    OSErr              status;    SCSIGetVirtualIDInfoPB      scsiGetVirtualIDInfo;     CLEAR(scsiGetVirtualIDInfo);     scsiGetVirtualIDInfo.scsiPBLength = sizeof scsiGetVirtualIDInfo;     scsiGetVirtualIDInfo.scsiOldCallID = REC.deviceID.targetID;     status = SCSIAction((SCSI_PB *) &amp;scsiGetVirtualIDInfo);     return (status == noErr);}/* * This is the only function that sends SCSI commands to a device. It will send a * Device Inquiry and, if Check Condition is returned, issue Request Sense. */static BooleanCheckForDevice(    register SCSIFindDevicesPtr  scsiFindDevicesPtr,    Boolean          useAsyncManager  ){    OSErr          status;    OSErr          requestSenseStatus;    SCSI_Sense_Data      senseData;#define SENSE  (senseData)    Boolean          result;    /*     * For the old SCSI Manager only.     */    unsigned char      command[6];    long          tempLong;        if (useAsyncManager) {#define PB  (*REC.scsiExecIOPB)      /*       * Setup the parameter block for the user's request.       */      PB.scsiPBLength = REC.execIOPBSize;      PB.scsiFunctionCode = SCSIExecIO;      PB.scsiTimeout = 1000;      PB.scsiDevice = REC.deviceID;      PB.scsiCDBLength = 6;      PB.scsiCDB.cdbBytes[0] = kScsiCmdInquiry;      PB.scsiCDB.cdbBytes[4] = sizeof REC.inquiry;      /*       * Stuff the LUN into the command for SCSI-1 devices.       */      /* PB.scsiCDB.cdbBytes[1] &amp;= ~0xE0; -- already zero */      PB.scsiCDB.cdbBytes[1] |= (REC.deviceID.LUN &amp; 0x03) &lt;&lt; 5;      /*       * Specify the transfer direction, if any, and setup the other SCSI       * operation flags. scsiSIMQNoFreeze prevents the SCSI Manager from       * blocking further operation if an error is detected.       */      PB.scsiFlags = scsiTransferPolled;      PB.scsiDataPtr = (unsigned char *) &amp;REC.inquiry;      PB.scsiDataLength = sizeof REC.inquiry;      PB.scsiDataType = scsiDataBuffer;      PB.scsiSensePtr = (unsigned char *) &amp;senseData;      PB.scsiSenseLength = sizeof senseData;      PB.scsiFlags = scsiSIMQNoFreeze | scsiDirectionIn | scsiDontDisconnect;      if (REC.enableATN == FALSE)        PB.scsiIOFlags |= scsiDisableSelectWAtn;      status = SCSIAction((SCSI_PB *) &amp;PB);      if (status == noErr)        status = PB.scsiResult;      /*       * Note: scsiDataRunError is issued if our transfer request was larger       * or smaller than the actual transfer length. We need to examine the       * actual transfer sizes to see how to handle this error. This is       * not necessarily complete or correct. The intent here is to supress       * the transfer length error when executing Device Inquiry or other       * administrative commands with variable-length result blocks.       */      REC.actualInquirySize = PB.scsiDataLength - PB.scsiDataResidual;      if (status == scsiDataRunError        /* Over/underrun error  */       &amp;&amp; REC.actualInquirySize &gt; 0)        /* And its a short read  */        status = noErr;              /* If so, ignore error  */            /*       * If the device issued Check Condition and the SCSI Manager was able       * to retrieve a Request Sense datum, change the error to our private       * &quot;Check Condition&quot; status.       */      if (status == scsiNonZeroStatus       &amp;&amp; (PB.scsiResultFlags &amp; scsiAutosenseValid) != 0) {         status = statusErr;         requestSenseStatus = noErr;      }#undef PB    }    else {      CLEAR(command);      command[0] = kScsiCmdInquiry;      command[4] = sizeof REC.inquiry;      /*       * Stuff the LUN into the command.       */      /* command[1] &amp;= ~0xE0;  -- already zero */      command[1] |= (REC.deviceID.LUN &amp; 0x03) &lt;&lt; 5;      status = OriginalSCSI(            REC.deviceID.targetID,            (Ptr) &amp;command,            (Ptr) &amp;REC.inquiry,            sizeof REC.inquiry,            &amp;REC.actualInquirySize          );      if (status == statusErr) {        /*         * Check condition         */        CLEAR(command);        command[0] = kScsiCmdRequestSense;        command[4] = sizeof senseData;        /*         * Stuff the LUN into the command.         */        /* command[1] &amp;= ~0xE0;  -- already zero */        command[1] |= (REC.deviceID.LUN &amp; 0x03) &lt;&lt; 5;        requestSenseStatus = OriginalSCSI(              REC.deviceID.targetID,              (Ptr) &amp;command,              (Ptr) &amp;senseData,              sizeof senseData,              &amp;tempLong            );        if (status == noErr)          status = statusErr;      }    }    /*     * Look at the result.     */    switch (status) {    case noErr:      if (REC.inquiry.devType == kScsiDevTypeMissing)        result = FALSE;      else {        result = TRUE;          /* Normal successful return    */      }      break;    case statusErr:      /*       * The target returned Check Condition. We need to look at the sense       * data, if any, to distinguish between an &quot;offline&quot; but present device,       * and a non-existant logical unit. Note: some drives return Check       * Condition, and &quot;no sense error&quot; if we try to access an incorrect       * logical unit. This might reasonably be remapped as &quot;illegal request.       */      if (requestSenseStatus != noErr       || (SENSE.errorCode &amp; kScsiSenseInfoMask) != kScsiSenseInfoValid)         result = FALSE;       else {        switch (SENSE.senseKey &amp; kScsiSenseKeyMask) {        case kScsiSenseIllegalReq:          result = FALSE;          break;        default:          /*           * Wierd: some drives seem to set the End of Media bit           * in the sense key if an invalid LUN is selected.           */          if ((SENSE.senseKey &amp; kScsiSenseEOM) != 0)            result = FALSE;          else {            result = TRUE;          }          break;        }      }      break;      default:              /* Other errors == no such device  */      result = FALSE;      break;    }    return (result);}/* * This is a very limited wrapper for the original SCSI Manager that can handle * Device Inquiry and Request Sense (only). */static OSErrOriginalSCSI(    unsigned short      targetID,    Ptr            command,    Ptr            resultData,    unsigned long      resultSize,    long          *actualTransferSize  ){    OSErr          status;    OSErr          completionStatus;    short          totalTries;      /* Get/Select retries    */    short          getTries;      /* Get retries        */    short          iCount;        /* Bus free counter      */    unsigned long      watchdog;      /* Timeout after this    */    SCSIInstr        tib[4];    short          messageByte;    short          statusByte;    *actualTransferSize = 0;    tib[0].scOpcode = scInc;    tib[0].scParam1 = (unsigned long) resultData;    tib[0].scParam2 = 1;    tib[1].scOpcode = scAdd;    tib[1].scParam1 = (unsigned long) actualTransferSize;    tib[1].scParam2 = 1;    tib[2].scOpcode = scLoop;    tib[2].scParam1 = (-2 * sizeof (SCSIInstr));    tib[2].scParam2 = resultSize;    tib[3].scOpcode = scStop;    tib[3].scParam1 = 0;    tib[3].scParam2 = 0;    /*     * Arbitrate for the scsi bus.  This will fail if some other device is     * accessing the bus at this time (which is unlikely).     *     *** Do not set breakpoints or call any functions that may require device     *** I/O (such as display code that accesses font resources between     *** SCSIGet and SCSIComplete,     *     */    for (totalTries = 0; totalTries &lt; kMaxSCSIRetries; totalTries++) {      for (getTries = 0; getTries &lt; 4; getTries++) {        /*         * Wait for the bus to go free.         */        watchdog = TickCount() + 300;    /* 5 second timeout      */        while (ScsiBusBusy()) {          if (TickCount() &gt; watchdog) {            status = scArbNBErr;            goto exit;          }        }        /*         * The bus is free, try to grab it         */        for (iCount = 0; iCount &lt; 4; iCount++) {          if ((status = SCSIGet()) == noErr)            break;        }        if (status == noErr)          break;              /* Success: we have the bus */        /*         * The bus became busy again. Try to wait for it to go free.         */        for (iCount = 0; iCount &lt; 100 &amp;&amp; ScsiBusBusy(); iCount++)          ;      } /* The getTries loop */      if (status != noErr) {        /*         * The SCSI Manager thinks the bus is not busy and not selected,         * but &quot;someone&quot; has set its internal semaphore that signals         * that the SCSI Manager itself is busy. The application will have         * to handle this problem. (We tried getTries * 4 times).         */        goto exit;      }      /*       * We now own the SCSI bus. Try to select the device.       */      if ((status = SCSISelect(targetID)) != noErr)        goto exit;      /*       * From this point on, we must exit through SCSIComplete() even if an       * error is detected. Send a command to the selected device. There are       * several failure modes, including an illegal command (such as a       * write to a read-only device). If the command failed because of       * &quot;device busy&quot;, we will try it again.       */      status = SCSICmd((Ptr) command, 6);      if (status == noErr)        status = SCSIRead((Ptr) tib);      /*       * SCSIComplete &quot;runs&quot; the bus-phase algorithm until the bitter end,       * returning the status and command-completion message bytes..       */      completionStatus = SCSIComplete(&amp;statusByte, &amp;messageByte, 60L);      /*       * If we have an error here, return as the &quot;final&quot; status.       *        */      if (completionStatus != noErr)        status = completionStatus;      else {        /*         * ScsiComplete is happy. If the device is busy, Pause for 1/4         * second and try again.         */        if (statusByte == kScsiStatusBusy) {          watchdog = TickCount() + 15;          while (TickCount() &lt; watchdog)            ;          continue;        /* Do next totalTries attempt    */        }      }      /*       * This is the normal exit (success) or final failure exit.       */      break;    } /* totalTries loop */exit:  /*     * Ignore phase errors if the buffer was large enough     */    if (status == scPhaseErr &amp;&amp; *actualTransferSize &lt;= resultSize)      status = noErr;    /*     * Return statusErr if the device returns Check Condition:     * Also, there is a bug in the combination of System 7.0.1 and the 53C96     * that may cause the real SCSI Status Byte to be in the Message byte.     */    if (statusByte == kScsiStatusGood     &amp;&amp; messageByte == kScsiStatusCheckCondition)      statusByte = kScsiStatusCheckCondition;    if (status == noErr &amp;&amp; statusByte == kScsiStatusCheckCondition)      status = statusErr;    return (status);}static voidClearMemory(    void          *recordPtr,    register unsigned long  recordLength  ){    register char      *ptr;        for (ptr = (char *) recordPtr; recordLength &gt; 0; --recordLength)      *ptr++ = 0; }</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/SCSI_Find_Devices/listing3.html%3Fid%3DDTS10000024-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/SCSI_Find_Devices/listing3.html%3Fid%3DDTS10000024-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/SCSI_Find_Devices/listing3.html%3Fid%3DDTS10000024-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>