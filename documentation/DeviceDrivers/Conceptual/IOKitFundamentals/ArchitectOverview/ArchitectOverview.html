<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>I/O Kit Fundamentals: Architectural Overview</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Architectural Overview"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP0000013" title="Architectural Overview"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../HardwareDrivers/index.html#//apple_ref/doc/uid/TP30000440-TP40003576" target="_top">Hardware &amp; Drivers</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP0000011-CH204-TPXREF101">I/O Kit Fundamentals</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Features/Features.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../TheRegistry/TheRegistry.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP0000013-BEHJDFCA" title="Architectural Overview"></a><h1>Architectural Overview</h1><p>As you can with any complex system, you can look at the design of the I/O Kit from various angles and at different granularities. This chapter introduces you to the more important <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_74"></a>architectural elements and conceptual domains of the I/O Kit:</p><ul class="ul"><li class="li"><p>Hardware modeling, the layering of driver objects, and the roles played by families, drivers, and nubs</p></li><li class="li"><p>The runtime environment of device drivers</p></li><li class="li"><p>The I/O Kit Registry and I/O Catalog</p></li><li class="li"><p>Driver matching</p></li><li class="li"><p>The I/O Kit class hierarchy</p></li><li class="li"><p>Device interfaces</p></li></ul><p>Keep in mind that this chapter is an overview, and so the discussion it devotes to each of these topics is intentionally brief. Later chapters cover most of these topics in more detail. In the case of device interfaces, the document <em><a href="../../AccessingHardware/index.html#//apple_ref/doc/uid/TP30000376" target="_top">Accessing Hardware From Applications</a></em> describes the technology in great detail.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="ArchitectOverview.html#//apple_ref/doc/uid/TP0000013-BEHEFHEH">Driver Layering</a>
				
			<br/>
			
        
			
			
				<a href="ArchitectOverview.html#//apple_ref/doc/uid/TP0000013-TPXREF107">The Runtime Environment of Device Drivers</a>
				
			<br/>
			
        
			
			
				<a href="ArchitectOverview.html#//apple_ref/doc/uid/TP0000013-BABJBCHC">The I/O Registry and the I/O Catalog</a>
				
			<br/>
			
        
			
			
				<a href="ArchitectOverview.html#//apple_ref/doc/uid/TP0000013-BABDJBGD">Driver Matching</a>
				
			<br/>
			
        
			
			
				<a href="ArchitectOverview.html#//apple_ref/doc/uid/TP0000013-BABBFJDG">The I/O Kit Class Hierarchy</a>
				
			<br/>
			
        
			
			
				<a href="ArchitectOverview.html#//apple_ref/doc/uid/TP0000013-BEHEGHEG">Controlling Devices From Outside the Kernel</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP0000013-BEHEFHEH" title="Driver Layering"></a><h2>Driver Layering</h2><a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_75"></a><a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_76"></a><p>Central to the design of the I/O Kit is a modular, layered runtime architecture that models the <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_77"></a>hardware of a Mac OS X system by capturing the dynamic relationships among the multiple pieces—hardware and software—involved in an I/O connection. The layers of the connection, comprising driver objects and the families these objects are members of, are stacked in provider-client relationships.</p><p>The chain of interconnected services or devices starts with a computer’s logic board (and the driver that controls it) and, through a process of discovery and “matching,” extends the connection with layers of driver objects controlling the system buses (PCI, USB, and so on) and the individual devices and services attached to these buses. </p><p>You can view the layering of driver objects in a running Mac OS X system using the <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_78"></a>I/O Registry Explorer application, included in the developer version of Mac OS X. The developer version also includes a <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_79"></a>command-line version of the application, <code>ioreg</code>, that you can run in a Terminal window to display current I/O Registry information.</p><p>This section examines the I/O Kit’s layered architecture and describes the major constituent elements: families, drivers, and nubs.</p><a name="//apple_ref/doc/uid/TP0000013-BABIDJAG" title="Families and Drivers"></a><h3>Families and Drivers</h3><a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_80"></a><p>An I/O Kit family is one or more C++ classes that implement software abstractions common to all devices of a particular type. The I/O Kit has families for bus protocols (such as SCSI Parallel, USB, and FireWire), for storage (disk) devices, for network services (including Ethernet), for human-interface devices (such as mice, keyboards, and joysticks), and for a host of other devices. </p><p>A <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_81"></a>driver becomes a member of a family through inheritance; the driver’s class is almost always a subclass of some class in a family. By being a member of a family, the driver inherits the data structures (instance variables) and the behaviors that are common to all members of the family. For example, all SCSI controllers have certain things they must do, such as scanning the SCSI bus; the SCSI Parallel family defines and implements this scanning functionality. Thus, you do not need to include scanning code in your new SCSI controller driver (unless you require a different scanning implementation). </p><p>Most I/O Kit development involves writing specific driver classes, each of which inherits from the superclass in the family that provides the functionality the driver requires. A driver for an Ethernet controller, for example, inherits from the IOEthernetController superclass in the Network family. The bulk of a driver’s interaction with its own family involves implementing member functions that the family invokes. These are typically <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_82"></a>client configuration and <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_83"></a>I/O requests. Some families also define objects and functions for your driver to use. The exact nature of these objects and functions depends on the family your driver works with.</p><p>However, a driver typically works with two families. In addition to the family a driver is a member of, the driver class must communicate with a<a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_84"></a> nub published by the family for the bus or protocol the device is attached to. A nub (as <span class="content_text"><a href="ArchitectOverview.html#//apple_ref/doc/uid/TP0000013-BEHDCDDC">“Drivers and Nubs”</a></span> explains in detail) is an object that defines an access point and communication channel for a given protocol. A family (usually representing a bus such as PCI or USB) acts as the driver’s provider through the nub that it creates. The driver uses the nub to attach into the I/O Registry and communicate with its device. As an example, a PCI Ethernet driver would use an <code>IOPCIDevice</code> nub from the PCI family to attach to and communicate over the PCI bus. A driver’s main interaction with the nub involves the issuing of requests or commands on whatever bus the nub is a client of. A SCSI device driver, for example, issues SCSI command blocks and checks results through the nub.</p><p>For more on families, particularly the nature and composition of superclasses in a family, see <span class="content_text"><a href="ArchitectOverview.html#//apple_ref/doc/uid/TP0000013-BABDGAEI">“The I/O Kit Family Classes”</a></span></p><a name="//apple_ref/doc/uid/TP0000013-BEHDCDDC" title="Drivers and Nubs"></a><h3>Drivers and Nubs</h3><p>The I/O Kit supports two broad types of driver objects. The first is the nub, an object that defines an access point and communication channel, usually for a given protocol, such as PCI, USB, or Ethernet. The second type is the specific driver for an individual device or service. The specific driver communicates with the hardware, through a nub, to perform I/O operations. Both drivers and nubs in the I/O Kit must inherit from the IOService class.</p><p>A <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_85"></a>driver is an I/O Kit object that manages a specific piece of hardware. Drivers are written as kernel extensions and are usually installed in the Extensions folder (at <code>/System/Library/Extensions</code>.) See <span class="content_text"><a href="../../../../Darwin/Conceptual/KernelProgramming/Extend/Extend.html#//apple_ref/doc/uid/TP30000905-CH220" target="_top">Kernel Extension Overview</a></span> in <em><a href="../../../../Darwin/Conceptual/KernelProgramming/index.html#//apple_ref/doc/uid/TP30000905" target="_top">Kernel Programming Guide</a></em> for more information about creating and installing kernel extensions.</p><p>When a driver is selected for a device, but before it is <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_86"></a><a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_87"></a>loaded into the kernel (as a kernel extension), all required families—in terms of superclasses and their dependencies—are loaded to provide the common functionality for the driver and others of its type. (Of course, if these families have already been loaded, this step is not necessary.) After all requirements for the driver are met, the driver is loaded and instantiated as an object. See <span class="content_text"><a href="ArchitectOverview.html#//apple_ref/doc/uid/TP0000013-BABDBBFF">“The Anatomy of an I/O Connection”</a></span> for an illustration of this process.</p><p>A nub is an I/O Kit object that represents a communication channel for a device or logical service and mediates access to the device and service. For example, a nub could represent a bus, a disk, a disk partition, a graphics adaptor, or a keyboard. It might help to think of a nub as the software representation of a device slot or connector. Nubs also provide services such as <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_88"></a>arbitration, power management, and driver matching (see <span class="content_text"><a href="ArchitectOverview.html#//apple_ref/doc/uid/TP0000013-BABJBCHC">“The I/O Registry and the I/O Catalog”</a></span>). </p><p>Nubs act as bridges between two drivers and, by extension, between two families. A driver communicates with a nub (and the nub’s family) as its client and may, through its family, publish a nub which finds (by matching) a driver for which it is a provider. Usually a driver publishes one nub for each individual device or service it controls; however, when a driver supports a specific piece of hardware it can act as its own nub.<a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_89"></a></p><a name="//apple_ref/doc/uid/TP0000013-BABDBBFF" title="The Anatomy of an I/O Connection"></a><h3>The Anatomy of an I/O Connection</h3><p>The I/O Kit’s layered architecture models the chain of connections between the system’s hardware buses and devices, gathering common functionality into classes your driver can interact with. Each layer is a client of the layer below it and a provider of services to the layer above it. Broad groupings of layers, defined by the I/O Kit families, define the functionality common to a general type of I/O provider, such as networking or PCI bus devices.</p><p>Consider <span class="content_text"><a href="ArchitectOverview.html#//apple_ref/doc/uid/TP0000013-CCDFDABE">Figure 2-1</a></span> which illustrates a typical layering of client and provider objects for a PCI-based Ethernet controller driver in the Network family.</p><br/><div><a name="//apple_ref/doc/uid/TP0000013-CCDFDABE" title="Figure 2-1Driver objects as clients and providers"></a><p><strong>Figure 2-1&nbsp;&nbsp;</strong>Driver objects as clients and providers</p><img src = "../art/driverstack.gif" alt = "Driver objects as clients and providers" width="149" height="168"></div><br/><p>As this diagram shows, your driver typically fits between two families, inheriting from a class in the upper-layer family and using the services of the lower-layer family. In the case of the <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_90"></a>Ethernet controller, the driver participates in a stack of C++ objects comprising instances of classes from the networking and PCI families:</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><tr><td  scope="row"><p>IONetworkStack (interface managing object)</p></td><td ><p>Connects I/O Kit objects to the BSD networking facilities.</p></td></tr><tr><td  scope="row"><p>IOEthernetInterface (nub)</p></td><td ><p>Manages device-independent data transmission and reception.</p></td></tr><tr><td  scope="row"><p>Controller Driver (driver)</p></td><td ><p>Operates the Ethernet controller through the IOPCIDevice object. This object inherits from a networking family class called IOEthernetController.</p></td></tr><tr><td  scope="row"><p>IOPCIDevice (nub)</p></td><td ><p>Match point for the controller; provides basic PCI bus interaction to the controller.</p></td></tr><tr><td  scope="row"><p>IOPCIBridge (driver)</p></td><td ><p>Manages the PCI bus. (Other objects provide services to the IOPCIBridge; their specific identities depend on the hardware configuration.)</p></td></tr></table></div><p>Another way to look at a stack of driver objects in a typical I/O connection is to consider the stack from a dynamic perspective. In other words, what happens when a Mac OS X system discovers a new device attached to it? How is the stack of driver objects constructed? For this, let’s use the example of a SCSI disk drive; the general order of creation or discovery in <span class="content_text"><a href="ArchitectOverview.html#//apple_ref/doc/uid/TP0000013-BABIAABE">Figure 2-2</a></span> is left to right.</p><br/><div><a name="//apple_ref/doc/uid/TP0000013-BABIAABE" title="Figure 2-2Driver objects in a connection for a SCSI disk driver"></a><p><strong>Figure 2-2&nbsp;&nbsp;</strong>Driver objects in a connection for a SCSI disk driver</p><img src = "../art/acchardwareiokitl001.gif" alt = "Driver objects in a connection for a SCSI disk driver" width="425" height="60"></div><br/><p>This figure illustrates how a <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_91"></a>SCSI disk driver, a member of the <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_92"></a>Storage family, is connected to the PCI bus. As each individual connection is made, the newly created driver or nub is also added to the I/O Registry (described in <span class="content_text"><a href="ArchitectOverview.html#//apple_ref/doc/uid/TP0000013-BABJBCHC">“The I/O Registry and the I/O Catalog”</a></span>). The chain of connections takes place in several steps:</p><ol class="ol"><li class="li"><p>The PCI bus controller driver, a member of the <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_93"></a>PCI family, discovers a PCI device and announces its presence by creating a nub (<code>IOPCIDevice</code>).</p></li><li class="li"><p>The nub identifies (matches) an appropriate device driver—in this case, a SCSI controller driver—and requests that it be loaded. Loading the SCSI controller driver causes the <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_94"></a>SCSI Parallel family, and all families that it depends on, to be loaded as well. The SCSI controller driver is given a reference to the <code>IOPCIDevice</code> nub.</p></li><li class="li"><p>The SCSI controller driver, which is a client of the PCI family and a provider of SCSI Parallel family services, scans the SCSI bus for devices that might be clients of these services. Upon finding such a device (a disk), the driver announces the device’s presence by creating a nub (<code>IOSCSIDevice</code>).</p></li><li class="li"><p>The nub, by going through the matching procedure, finds a device driver (a disk driver) that is appropriate for the device and requests that this driver be loaded. Loading the disk driver causes the Storage family, and all families that it depends on, to be loaded as well. The disk driver is now a client of the SCSI Parallel family and a member of the Storage family. The disk driver is given a reference to the <code>IOSCSIDevice</code> nub.</p></li></ol><p>In many cases, applications and other “user space” programs can use the I/O Kit’s device-interface technology to drive devices (including mass storage devices), obviating the need for a kernel-resident driver. See <span class="content_text"><a href="ArchitectOverview.html#//apple_ref/doc/uid/TP0000013-BEHEGHEG">“Controlling Devices From Outside the Kernel”</a></span> for an overview of this plug-in technology.<a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_95"></a><a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_96"></a></p><a name="//apple_ref/doc/uid/TP0000013-TPXREF107" title="The Runtime Environment of Device Drivers"></a><h2>The Runtime Environment of Device Drivers</h2><p>The I/O Kit provides a <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_97"></a>runtime environment with several powerful features for driver writers, including:</p><ul class="ul"><li class="li"><p>A dynamic, layered driver architecture that allows drivers to be loaded and unloaded at any time and delays reserving costly system resources until they’re needed</p></li><li class="li"><p>Standard facilities for managing data during common I/O operations</p></li><li class="li"><p>A robust system for protecting access to driver resources during I/O operations, which frees driver writers from having to write their own code to enable and disable interrupts and manage locks on the driver’s private resources</p></li><li class="li"><p>Access to services in the libkern C++ library (on which the I/O Kit itself is based) to manage collections, perform atomic operations, and byte-swap values for use on different kinds of hardware</p></li></ul><p>The following section summarizes each of these features.</p><a name="//apple_ref/doc/uid/TP0000013-TPXREF108" title="Runtime Features"></a><h3>Runtime Features</h3><p>I/O Kit drivers can be loaded and unloaded or activated and deactivated at any time, through events initiated by software—as when networking stacks are brought up and down—and by hardware—as when a USB device is added to or removed from the bus. Nearly all drivers must work within the context of a dynamically changing system. The I/O Kit makes this easier by defining a standard <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_98"></a><a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_99"></a>life cycle for driver objects. By implementing a small set of functions, summarized in <span class="content_text"><a href="ArchitectOverview.html#//apple_ref/doc/uid/TP0000013-TPXREF105">“The General I/O Kit Classes”</a></span> your driver can gracefully handle the addition and removal of devices and services, as well as changes induced by the power-management system.</p><p>Nearly all I/O operations require the same preparation in Mac OS X: </p><ul class="spaceabove"><li class="li"><p>Paging <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_100"></a><a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_101"></a>virtual memory into physical memory</p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_102"></a>Wiring memory down so it can’t be paged out during I/O operations</p></li><li class="li"><p>Building <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_103"></a>scatter/gather lists that describe the data buffers to read or write</p></li></ul><p>The I/O Kit provides a set of utility classes to help drivers prepare memory for I/O operations and to build scatter/gather lists, including the IOMemoryDescriptor and IOMemoryCursor classes. For more information on these facilities, see the chapter <span class="content_text"><a href="../DataMgmt/DataMgmt.html#//apple_ref/doc/uid/TP0000019-BCIFGGBI">“Managing Data”</a></span><a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_104"></a></p><p>Drivers running in a multithreaded system must be able to protect their resources from <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_105"></a>reentrant or concurrent access. The I/O Kit includes a small set of classes for this purpose. A work loop object runs a dedicated thread and manages a <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_106"></a>gating mechanism for exclusive access to data. Other objects, called <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_107"></a>event sources, use the gating mechanism to serialize function calls that access critical resources, closing the work loop gate before invoking the function. For more information on work loops and event sources, see the chapter <span class="content_text"><a href="../HandlingEvents/HandlingEvents.html#//apple_ref/doc/uid/TP0000018-BAJFFJAD">“Handling Events”</a></span></p><p>The <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_108"></a>libkern C++ library, on which the I/O Kit itself is based, provides services commonly needed by drivers, including: </p><ul class="spaceabove"><li class="li"><p>Arithmetic and logical operations that are guaranteed to be atomic</p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_109"></a>Byte-swapping of values between <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_110"></a>big-endian and <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_111"></a>little-endian formats</p></li><li class="li"><p>Classes for common collections of data such as strings, arrays, and dictionaries</p></li></ul><p>For more information on the libkern classes see <span class="content_text"><a href="ArchitectOverview.html#//apple_ref/doc/uid/TP0000013-TPXREF104">“The OS Classes”</a></span> as well as the libkern reference documentation installed with the Mac OS X Developer package. </p><a name="//apple_ref/doc/uid/TP0000013-TPXREF101" title="Kernel Programming Constraints "></a><h3>Kernel Programming Constraints </h3><a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_112"></a><p>Kernel code is always held resident in <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_113"></a>physical <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_114"></a>memory, and cannot be paged out by the <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_115"></a>virtual memory system. This makes kernel resources much more expensive than application program resources. Your driver should reside in the kernel if:</p><ul class="spaceabove"><li class="li"><p>It takes primary interrupts (in which case it must live in the kernel)</p></li><li class="li"><p>Its primary client resides in the kernel; for example, mass storage drivers because file-system stacks reside in the kernel</p></li></ul><p>Drivers for disks, network controllers, and keyboards, for example, reside in the kernel. If your driver is only occasionally used by one user-space program at a time, it should be loaded by the program and reside within it. Drivers for such devices as scanners and printers reside within user-space programs, using the I/O Kit’s device-interface mechanism to communicate with devices. For more information on device interfaces, see <span class="content_text"><a href="ArchitectOverview.html#//apple_ref/doc/uid/TP0000013-BEHEGHEG">“Controlling Devices From Outside the Kernel”</a></span> </p><p>Even if your driver resides in the kernel, you should minimize the amount of kernel-resident code and the amount of processing done by that code. For example, a dedicated application that controls an interrupt-driven hardware device should supply a driver that puts the minimum code in the kernel needed to service the interrupt, make the data available to its client, then return. For additional reasons to be cautious about programming in the kernel, see <span class="content_text"><a href="../Features/Features.html#//apple_ref/doc/uid/TP0000012-BBCFBAHF">“Should You Program in the Kernel? ”</a></span></p><p>If your driver must reside in the kernel, you should be aware of the following issues:</p><ul class="spaceabove"><li class="li"><p>Most importantly, the kernel is a single program—there is no <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_116"></a>memory protection between your driver and the rest of the kernel. A kernel-resident driver that behaves badly can crash or hang the operating system.</p></li><li class="li"><p>A more subtle issue is that <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_117"></a>function call stacks within the kernel are limited to 16 KB. Be careful not to declare large local variables in functions. Whenever possible, you should preallocate buffers and reuse them.</p></li></ul><p>Kernel-resident drivers have full access to kernel programming interfaces. However, because of their low level of operation, drivers should use only <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_118"></a>Mach calls and not <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_119"></a>BSD calls. Many parts of the BSD kernel code aren’t currently safe for multithreading or multiprocessing. In any case, drivers rarely need to perform Mach calls directly, as the I/O Kit provides interfaces to most of the kernel-level functionality needed by a driver.<a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_120"></a></p><a name="//apple_ref/doc/uid/TP0000013-BABJBCHC" title="The I/O Registry and the I/O Catalog"></a><h2>The I/O Registry and the I/O Catalog</h2><p>The <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_121"></a>I/O Registry is a dynamic database that records the network of driver objects participating in hardware connections on a Mac OS X system and tracks the <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_122"></a>provider-client relationships among those objects. A device driver must be recorded in the I/O Registry to participate in most I/O Kit services. </p><p>The I/O Registry is a critical part of the I/O Kit because it supports the dynamic features of the operating system, which allows users to add or remove devices (particularly FireWire or USB devices) to and from a running system and have them immediately available, without the need for a reboot. As hardware is added, the system automatically finds and loads the necessary drivers and updates the I/O Registry to reflect the new device configuration; when hardware is removed, the appropriate drivers are unloaded and the Registry is updated again. The Registry always resides in system memory and is not stored on disk or archived between boots.</p><p>The I/O Registry structures its data as an inverted tree. Each object in the tree descends from a parent node and can have one or more child nodes; if it is a “leaf” node, it has no children. Almost every node in the tree represents a driver object: a nub or an actual driver. These objects must inherit from the IORegistryEntry class (which is the superclass of IOService, the superclass of all driver classes). The central characteristic of IORegistryEntry objects is a list of associated properties. These properties reflect the personality used in <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_123"></a>driver matching (see <span class="content_text"><a href="ArchitectOverview.html#//apple_ref/doc/uid/TP0000013-BABDJBGD">“Driver Matching”</a></span>) and otherwise add information about a driver. The properties captured in the Registry derive from each driver’s information property list, a file in the driver KEXT containing key-value pairs describing the driver’s characteristics, settings, and requirements.<a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_124"></a></p><p>Another dynamic database, the <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_125"></a>I/O Catalog, works closely with the I/O Registry. The I/O Catalog maintains entries for all available drivers on a system. When a nub discovers a device, it requests a list of all drivers of the device’s family from the I/O Catalog. </p><p>You can examine the I/O Registry using the I/O Registry Explorer application and the <code>ioreg</code><a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_126"></a> command-line tool, both included in the Mac OS X Developer package. You can also programmatically explore and manipulate the properties of Registry entries using the member functions of the IORegistryEntry class. From applications and other programs in user space, you can search for and access driver information in the I/O Registry using APIs in the I/O Kit framework. </p><p>For more about the I/O Registry and the I/O Catalog see the chapter <span class="content_text"><a href="../TheRegistry/TheRegistry.html#//apple_ref/doc/uid/TP0000014-TP9">“The I/O Registry”</a></span> For further information about the IORegistryEntry class see <span class="content_text"><a href="../BaseClasses/BaseClasses.html#//apple_ref/doc/uid/TP0000016-BAJJHBFH">“Dynamic Driver Registration (IORegistryEntry)”</a></span> in the chapter “<span class="content_text"><a href="../BaseClasses/BaseClasses.html#//apple_ref/doc/uid/TP0000016-BAJJFCHJ">“The Base Classes”</a></span>”</p><a name="//apple_ref/doc/uid/TP0000013-BABDJBGD" title="Driver Matching"></a><h2>Driver Matching</h2><a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_127"></a><p>A primary function of nubs is to provide matching services, matching drivers to devices. Unlike in Mac OS 8 and 9, drivers are not loaded automatically simply because they are installed. In Mac OS X, a driver must first be matched to an existing device before that driver can be loaded. </p><p>Driver matching is an I/O Kit process in which a nub, after discovering a specific hardware device, searches for the driver or drivers most suited to that device. To support driver matching, each device driver defines one or more <strong>personalities</strong><a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_128"></a><a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_129"></a>that specify the kinds of devices it can support. This information is stored in XML dictionaries defined in the <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_130"></a>information property list in the driver’s bundle. The dictionary values specify whether a driver is a candidate for a particular device. <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_131"></a></p><p>When a nub detects a device, the I/O Kit finds and loads a driver for the nub in three distinct phases, using a subtractive process until a successful candidate is found. The phases of matching are:</p><ol class="ol"><li class="li"><p><strong>Class matching</strong>—eliminates drivers of the wrong device class<a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_132"></a>.</p></li><li class="li"><p><strong>Passive matching</strong>—examines each remaining driver’s personalities for properties specific to the device, eliminating those drivers that don’t match.<a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_133"></a></p></li><li class="li"><p><strong>Active matching</strong>—the remaining driver candidates probe the device to verify that they can drive it.<a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_134"></a></p></li></ol><p>When a matching driver is found, its code is loaded and an instance of the principal class listed in the personality is created. At this point the driver’s life cycle begins. See <span class="content_text"><a href="../BaseClasses/BaseClasses.html#//apple_ref/doc/uid/TP0000016-CCDGAAJB">“Driver Object Life Cycle”</a></span> in the chapter “<span class="content_text"><a href="../BaseClasses/BaseClasses.html#//apple_ref/doc/uid/TP0000016-BAJJFCHJ">“The Base Classes”</a></span>” for details. </p><p>For a detailed discussion of driver personalities and the matching process, see the chapter <span class="content_text"><a href="../Matching/Matching.html#//apple_ref/doc/uid/TP0000015-TP9">“Driver and Device Matching”</a></span></p><a name="//apple_ref/doc/uid/TP0000013-BABBFJDG" title="The I/O Kit Class Hierarchy"></a><h2>The I/O Kit Class Hierarchy</h2><a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_135"></a><p>The I/O Kit encompasses dozens of C++ classes and is itself an extension of the <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_136"></a>libkern C++ library, the foundation for loadable <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_137"></a>kernel modules. Taken together, the I/O Kit and libkern would seem to form a forbiddingly large and complex hierarchy of classes. Yet the essential structure of that hierarchy is fairly simple, as <span class="content_text"><a href="ArchitectOverview.html#//apple_ref/doc/uid/TP0000013-BABBBBAA">Figure 2-3</a></span> illustrates.</p><p>You can break down the extended I/O Kit class hierarchy into three broad groupings:</p><ul class="ul"><li class="li"><p>The classes of libkern (sometimes called the OS classes because of their “OS” prefix)</p></li><li class="li"><p>The I/O Kit base classes and helper classes</p></li><li class="li"><p>The classes of the I/O Kit families</p></li></ul><p>For information on where the binaries and header files of libkern and the I/O Kit library are installed, see <span class="content_text"><a href="../Features/Features.html#//apple_ref/doc/uid/TP0000012-BBCJACHC">“Frameworks and Libraries”</a></span> For detailed information on the features and interfaces of the base classes in this hierarchy—OSObject, OSMetaClass, IORegistryEntry, and IOService—see <span class="content_text"><a href="../BaseClasses/BaseClasses.html#//apple_ref/doc/uid/TP0000016-BAJJFCHJ">“The Base Classes”</a></span></p><br/><div><a name="//apple_ref/doc/uid/TP0000013-BABBBBAA" title="Figure 2-3I/O Kit extended class hierarchy"></a><p><strong>Figure 2-3&nbsp;&nbsp;</strong>I/O Kit extended class hierarchy</p><img src = "../art/class_diagram.gif" alt = "I/O Kit extended class hierarchy" width="428" height="394"></div><br/><div class="notebox"><a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_10" title="Note"></a><p><strong>Note:</strong>&nbsp; The appendix <span class="content_text"><a href="../HelperClassesChart/HelperClassesChart.html#//apple_ref/doc/uid/TP0000022-TPXREF101">“Base and Helper Class Hierarchy”</a></span> contains a hierarchy chart for the I/O Kit base and helper classes; the appendix <span class="content_text"><a href="../Families_Ref/Families_Ref.html#//apple_ref/doc/uid/TP0000021-BABCCBIJ">“I/O Kit Family Reference”</a></span>includes class hierarchy charts for most I/O Kit families.</p></div><a name="//apple_ref/doc/uid/TP0000013-TPXREF104" title="The OS Classes"></a><h3>The OS Classes</h3><p>The I/O Kit is built on top of the libkern C++ library; that is to say, the root superclass for the I/O Kit–specific classes is IORegistryEntry, which inherits from libkern’s OSObject. As is the I/O Kit, libkern is written in a subset of C++ suitable for use in loadable kernel modules. Specifically, the libkern C++ environment excludes the C++ exception-handling and the <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_138"></a>Runtime Type Information (RTTI) facilities. Instead the OS base classes implement a suitable equivalent of the RTTI feature, among other things.</p><p>At the root of the extended hierarchy is the <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_139"></a>OSObject class and closely related to this class is the OSMetaClass class. All other OS classes are “helper” classes for such things as collections and other data containers. The following summarizes the roles these classes play:</p><ul class="spaceabove"><li class="li"><p>OSMetaClass implements a runtime type information (RTTI) mechanism, enables some degree of object introspection, and supports runtime allocation of objects derived from OSObject by class name.<a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_140"></a></p></li><li class="li"><p>OSObject features APIs for reference counting (<code>retain</code> and <code>release</code>), memory management of retained objects, and the automatic disposal of objects when they are no longer needed. OSObject also provides a dynamic default implementation of the <code>init</code> and <code>free</code> methods.<a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_141"></a></p></li><li class="li"><p>The OS <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_142"></a>data containers are subclasses of OSObject whose instances encapsulate various types of data values (such as booleans, numbers, strings) and implement and iterate over collections such as arrays and dictionaries.</p><p>The OS data containers approximately match their user-space counterparts, the Core Foundation containers, in both name and behavior. Because the characteristics of the OS and Core Foundation classes are so similar, the system can easily convert a Core Foundation type to an OS type and vice versa. For example, a CFArray object is transformed into an OSArray when crossing the user-kernel boundary.</p></li></ul><p>The OS classes are generally useful for all code written for the kernel, not just device drivers. For example, <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_143"></a><a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_144"></a>kernel extensions implementing networking services or file systems can also take advantage of these classes. OSObject in particular is an essential common superclass for kernel code. For one <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_145"></a>kernel module (<a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_146"></a>KMOD) to reference objects created by another KMOD, the objects must ultimately derive from OSObject. Most I/O Kit classes assume that the objects being passed around are derived from OSObject.</p><p>If you are porting existing C++ code to the I/O Kit, you are not required to use the OS classes. But if you decide to forgo the features that the these classes provide, such as reference counting or data containers, you’ll probably need to implement them yourself.</p><p>For more on the OSObject and OSMetaClass classes, see <span class="content_text"><a href="../BaseClasses/BaseClasses.html#//apple_ref/doc/uid/TP0000016-BAJEGGFI">“The libkern Base Classes”</a></span> in the chapter “<span class="content_text"><a href="../BaseClasses/BaseClasses.html#//apple_ref/doc/uid/TP0000016-BAJJFCHJ">“The Base Classes”</a></span>”</p><a name="//apple_ref/doc/uid/TP0000013-TPXREF105" title="The General I/O Kit Classes"></a><h3>The General I/O Kit Classes</h3><p>The middle group of the extended class hierarchy comprises the IO Kit base classes— IORegistryEntry and <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_147"></a>IOService—and a set of helper classes for resource management, data management, and thread and input control. This group of I/O Kit classes is designated “general” because all device-driver classes can potentially make use of them.</p><p>The root class of the I/O Kit hierarchy is IORegistryEntry; by virtue of inheritance from <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_148"></a>IORegistryEntry, an I/O Kit object can be a node in the I/O Registry and have one or more property tables (driver personalities) associated with it. IORegistryEntry implements a number of features:</p><ul class="spaceabove"><li class="li"><p>It manages connection into the Registry through a driver’s <code>attach</code> and <code>detach</code> entry points</p></li><li class="li"><p>It manages the property tables defining driver personalities using <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_149"></a>OSDictionary objects</p></li><li class="li"><p>It implements locking in the Registry, allowing updates to the Registry to be made atomically</p></li></ul><p>IOService is the sole direct subclass of IORegistryEntry. Almost all I/O Kit family superclasses inherit, directly or indirectly, from IOService. Most importantly, IOService specifies the <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_150"></a><a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_151"></a>life cycle of device drivers within a dynamic runtime environment. Through matching pairs of virtual functions—such as <code>init</code>/<code>free</code>, <code>start</code>/<code>stop</code>, and <code>open</code>/<code>close</code>—IOService defines how driver objects initialize themselves, attach themselves into the I/O Registry, perform all necessary allocations, and then reverse the effects of these actions in the proper order. To support its management of driver life cycles, IOService provides matching services (assisting with probing, for instance) and instantiates drivers based on the existence of a provider. In addition, IOService includes member functions that are useful for various purposes, including:</p><ul class="spaceabove"><li class="li"><p><a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_152"></a>Notification and <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_153"></a>messaging</p></li><li class="li"><p>Power management</p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_154"></a>Device memory (mapping and accessing)</p></li><li class="li"><p>Device <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_155"></a>interrupts (registering, unregistering, enabling, causing, and so on)</p></li></ul><p>For more on the IORegistryEntry and IOService classes, see <span class="content_text"><a href="../BaseClasses/BaseClasses.html#//apple_ref/doc/uid/TP0000016-BAJEEGAF">“The I/O Kit Base Classes”</a></span> in the chapter “<span class="content_text"><a href="../BaseClasses/BaseClasses.html#//apple_ref/doc/uid/TP0000016-BAJJFCHJ">“The Base Classes”</a></span>”</p><p>Most I/O Kit helper classes have several functions related to the runtime environment of device drivers:</p><ul class="spaceabove"><li class="li"><p>Implementing work loops and <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_156"></a>event sources (interrupts, <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_157"></a>timers and <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_158"></a>commands) along with associated locks and queues</p></li><li class="li"><p>Implementing memory cursors and memory descriptors for managing the data involved in I/O transfers</p></li></ul><p>For more on the I/O Kit helper classes, see the chapters <span class="content_text"><a href="../HandlingEvents/HandlingEvents.html#//apple_ref/doc/uid/TP0000018-BAJFFJAD">“Handling Events”</a></span> and <span class="content_text"><a href="../DataMgmt/DataMgmt.html#//apple_ref/doc/uid/TP0000019-BCIFGGBI">“Managing Data”</a></span> </p><a name="//apple_ref/doc/uid/TP0000013-BABDGAEI" title="The I/O Kit Family Classes"></a><h3>The I/O Kit Family Classes</h3><p>Most drivers are instances of a subclass of a class in an I/O Kit family; the family classes, in turn, tend to be subclasses of IOService. Your driver class should be a direct subclass of the most appropriate family class for the driver you’re trying to write. For example, if you are writing an Ethernet controller driver, your driver class should be a subclass of IOEthernetController, not IONetworkController (the superclass of IOEthernetController). </p><p>The I/O Kit has over a dozen families, each with its own set of classes; these families include the following:<a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_159"></a></p><ul class="spaceabove"><li class="li"><p>ADB</p></li><li class="li"><p>ATA and ATAPI</p></li><li class="li"><p>Audio</p></li><li class="li"><p>FireWire</p></li><li class="li"><p>Graphics</p></li><li class="li"><p>HID (Human Interface Devices)</p></li><li class="li"><p>Network</p></li><li class="li"><p>PC Card</p></li><li class="li"><p>PCI and AGP</p></li><li class="li"><p>SBP-2</p></li><li class="li"><p>SCSI Architectural Model</p></li><li class="li"><p>SCSI Parallel</p></li><li class="li"><p>Serial</p></li><li class="li"><p>Storage</p></li><li class="li"><p>USB</p></li></ul><p>Apple will add additional families as they are developed. If you require a family for a device and it’s currently not <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_160"></a>supported, you can try writing your own family classes. However, don’t assume that a new family is required if one does not currently exist. In many cases, the IOService class provides all the services a driver requires; such “family-less” drivers can support many devices that are specific to certain vendors. For more information on families, see the chapter <span class="content_text"><a href="../Families/Families.html#//apple_ref/doc/uid/TP0000017-TPXREF101">“I/O Kit Families”</a></span> and the appendix <span class="content_text"><a href="../Families_Ref/Families_Ref.html#//apple_ref/doc/uid/TP0000021-BABCCBIJ">“I/O Kit Family Reference”</a></span></p><a name="//apple_ref/doc/uid/TP0000013-BEHEGHEG" title="Controlling Devices From Outside the Kernel"></a><h2>Controlling Devices From Outside the Kernel</h2><a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_161"></a><p>Perhaps one of the more compelling features of Mac OS X is the inviolable separation it enforces between the virtual address spaces of processes. Unless laborious arrangements are made for shared memory, one process cannot directly touch data mapped to another process’s address space. This separation enhances the stability and reliability of the system by preventing memory trashers and similar annoyances from bringing processes down. </p><p>Even more important is the separation between the address spaces of the kernel and of all other processes, which are sometimes said (from the perspective of the kernel) to inhabit “user space.” If an application or other program in user space somehow violates the address space of the kernel, the whole system can come crashing down. To make this separation between kernel and user space even more airtight, programs in user space cannot even directly call kernel APIs. They must make system calls to (indirectly) access kernel APIs.</p><p>Sometimes, however, a program in user space needs to control or configure a device, and thus needs access to I/O Kit services in the kernel. For example, a game might need to set monitor depth or sound volume, or a disk-backup program might need to act as the driver for a tape drive. Other examples of applications that must somehow interact with the kernel to drive hardware include those running or interpreting data from scanners, joysticks, and digital cameras.</p><p>To answer this requirement, the I/O Kit includes two mechanisms: <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_162"></a>device interfaces and <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_163"></a>POSIX device nodes. Through a plug-in architecture and well-defined interfaces, the device-interface mechanism enables a program in user space to communicate with a nub in the kernel that is appropriate to the type of device it wishes to control. Through the nub the program gains access to I/O Kit services and to the device itself. For storage, serial, and networking devices, applications can obtain the information they need from the I/O Kit to access and control these devices using POSIX APIs.</p><p>Keep in mind that there are some family services that the I/O Kit refuses to export to user space as device interfaces; these services are available only inside the kernel. An example is the PCI family. For reasons of stability and security, external access to PCI resources is forbidden. The appendix <span class="content_text"><a href="../Families_Ref/Families_Ref.html#//apple_ref/doc/uid/TP0000021-BABCCBIJ">“I/O Kit Family Reference”</a></span> identifies the families that export device interfaces.</p><p>This section summarizes information in <em><a href="../../AccessingHardware/index.html#//apple_ref/doc/uid/TP30000376" target="_top">Accessing Hardware From Applications</a></em>. Refer to this document for a complete description of device interfaces and how to use them.</p><a name="//apple_ref/doc/uid/TP0000013-TPXREF103" title="The Device-Interface Mechanism "></a><h3>The Device-Interface Mechanism </h3><a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_164"></a><p>A device interface is a <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_165"></a>plug-in interface between the kernel and a process in user space. The interface conforms to the plug-in architecture defined by <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_166"></a>Core Foundation Plug-in Services (<a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_167"></a>CFPlugIn), which, in turn, is compatible with the basics of Microsoft’s <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_168"></a>Component Object Model (COM). In the CFPlugIn model, the kernel acts as the plug-in host with its own set of well-defined I/O Kit interfaces, and the I/O Kit framework provides a set of plug-ins (device interfaces) for applications to use. </p><p>Conceptually, a device interface straddles the boundary between user space and the kernel. It handles <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_169"></a>negotiation, <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_170"></a>authentication, and similar tasks as if it were a kernel-resident driver. On the user-space side, it enables communication with the application (or other program) through its exported programmatic interfaces. On the kernel side it enables communication with an appropriate I/O Kit family through a nub created by a driver object of that family. From the kernel’s perspective, a device interface appears to be a driver and is known as a “<a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_171"></a>user client.” From the application’s perspective, the device interface appears as a set of functions that it can call and through which it can pass data to the kernel and receive data back from it. That’s because, at an elemental level, a device interface is a pointer to a table of function pointers (although it can also include data fields). Applications, once they obtain an instance of a device interface, can call any of the functions of the interface.</p><p><span class="content_text"><a href="ArchitectOverview.html#//apple_ref/doc/uid/TP0000013-BABDGJAF">Figure 2-4</a></span> illustrates the architecture of a device interface, showing an application that has acquired access to a SCSI hard disk through a device interface. It is best to view this diagram as a variation of <span class="content_text"><a href="ArchitectOverview.html#//apple_ref/doc/uid/TP0000013-BABIAABE">Figure 2-2</a></span> which shows the series of driver-object connections made for a kernel-resident SCSI disk driver.</p><br/><div><a name="//apple_ref/doc/uid/TP0000013-BABDGJAF" title="Figure 2-4An application controlling a SCSI device through a device interface."></a><p><strong>Figure 2-4&nbsp;&nbsp;</strong>An application controlling a SCSI device through a device interface.</p><img src = "../art/acchardwareiokitl002.gif" alt = "An application controlling a SCSI device through a device interface." width="226" height="237"></div><br/><p>At the start, the same series of actions—device discovery, nub creation, matching, driver loading—occurs from the PCI bus driver to the SCSI device nub. But then the SCSI device nub matches and loads the device interface as its driver instead of a kernel-resident driver. </p><p>Before an application can use the device-interface mechanism to access a device, it must find the device. It accomplishes this through a process called <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_172"></a>device matching. In device matching, an application creates a “matching dictionary” that specifies the properties of the target device, then calls an I/O Kit function, passing in the dictionary. The function searches the I/O Registry and returns one or more matching driver objects that the application can then use to load an appropriate device interface. For more on this topic, see <span class="content_text"><a href="../Matching/Matching.html#//apple_ref/doc/uid/TP0000015-TPXREF5">“Device Matching”</a></span> </p><p>If you develop a custom driver that is a not a subclass of a class in an I/O Kit family, and you want applications to be able to access the driver, you have to write your own device interface. Any code that communicates between user space and the kernel must use of one or more of the following facilities:</p><ul class="spaceabove"><li class="li"><p><a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_173"></a>BSD system calls</p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_174"></a>Mach IPC</p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_175"></a>Mach shared memory</p></li></ul><p>The I/O Kit uses primarily Mach IPC and Mach shared memory. In contrast, the networking and file-system components of Mac OS X use primarily BSD system calls. <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_176"></a></p><a name="//apple_ref/doc/uid/TP0000013-BABBFIAF" title="POSIX Device Files"></a><h3>POSIX Device Files</h3><a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_177"></a><p>BSD, a central component of the Mac OS X kernel environment, exports a number of programmatic interfaces that are consistent with the POSIX standard. These interfaces enable communication with serial, storage, and network devices through device files. In any UNIX-based system such as <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_178"></a>BSD, a device file is a special file located in <code>/dev</code> that represents a <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_179"></a>block or <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_180"></a>character device such as a terminal, disk drive, or printer. If you know the name of a device file (for example, <code>disk0s2</code> or <code>mt0</code>) your application can use POSIX functions such as <code><!--a-->open<!--/a--></code>, <code><!--a-->read<!--/a--></code>, <code><!--a-->write<!--/a--></code>, and <code><!--a-->close<!--/a--></code> to access and control the associated device.</p><p>The I/O Kit dynamically creates the device files in <code>/dev</code> as it discovers devices. Consequently, the set of device files is constantly changing; different devices might be attached to the device files in <code>/dev</code> at any one time, and the same devices might have different device-file names at different times. Because of this, your application cannot hard-code device file names. For a particular device, you must obtain from the I/O Kit the path to its device file through a procedure involving device matching. Once you have the path, you can use POSIX APIs to access the device.</p><p>Note that you can access <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_181"></a>networking services from user space using the <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_182"></a>BSD socket APIs. However, you should generally use <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_183"></a>sockets only if the higher-level networking APIs in the <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_184"></a>Carbon and <a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_185"></a>Cocoa environments do not provide you with the features you require.<a name="//apple_ref/doc/uid/TP0000013-DontLinkElementID_186"></a></p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Features/Features.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../TheRegistry/TheRegistry.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2001, 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-05-17<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeviceDrivers/Conceptual/IOKitFundamentals/ArchitectOverview/ArchitectOverview.html%3Fid%3DTP0000011-4.8&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeviceDrivers/Conceptual/IOKitFundamentals/ArchitectOverview/ArchitectOverview.html%3Fid%3DTP0000011-4.8&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeviceDrivers/Conceptual/IOKitFundamentals/ArchitectOverview/ArchitectOverview.html%3Fid%3DTP0000011-4.8&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>