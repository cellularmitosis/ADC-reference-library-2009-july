<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>PostScript Output Filters - /SectionReport/SectionReport.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxPrinting-date.html">Printing</a> &gt; <A HREF="javascript:location.replace('index.html');">PostScript Output Filters</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Printing/index.html" target="_blank">Reference Library > Printing</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">PostScript Output Filters</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/SectionReport/SectionReport.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Headers and Stub Libraries/Hints.h</option>
<option value="listing2.html">/Headers and Stub Libraries/PrintingPlugins.h</option>
<option value="listing3.html">/Headers and Stub Libraries/PrintingPlugins.r</option>
<option value="listing4.html">/Headers and Stub Libraries/PSLogFolder.h</option>
<option value="listing5.html">/Headers and Stub Libraries/PSOutputFilters.h</option>
<option value="listing6.html">/Headers and Stub Libraries/PSOutputFilters.r</option>
<option value="listing7.html">/Headers and Stub Libraries/PSSectionInfo.h</option>
<option value="listing8.html">/Headers and Stub Libraries/PSStreams.h</option>
<option value="listing9.html">/SampleFilter/Debug.h</option>
<option value="listing10.html">/SampleFilter/DebugMisc.h</option>
<option value="listing11.html">/SampleFilter/LibraryStuff/Hints.h</option>
<option value="listing12.html">/SampleFilter/LibraryStuff/PrintingPlugins.h</option>
<option value="listing13.html">/SampleFilter/LibraryStuff/PrintingPlugins.r</option>
<option value="listing14.html">/SampleFilter/LibraryStuff/PSOutputFilters.h</option>
<option value="listing15.html">/SampleFilter/LibraryStuff/PSOutputFilters.r</option>
<option value="listing16.html">/SampleFilter/LibraryStuff/PSSectionInfo.h</option>
<option value="listing17.html">/SampleFilter/LibraryStuff/PSStreams.h</option>
<option value="listing18.html">/SampleFilter/Macros.h</option>
<option value="listing19.html">/SampleFilter/NoDebug.h</option>
<option value="listing20.html">/SampleFilter/SampleFilter.r</option>
<option value="listing21.html">/SampleFilter/SampleFilterHints.h</option>
<option value="listing22.html">/SampleFilter/SampleFilterMain.c</option>
<option value="listing23.html">/SampleFilter/SampleFilterMain.h</option>
<option value="listing24.html">/SampleFilter/SampleFilterOutput.c</option>
<option value="listing25.html">/SampleFilter/SampleFilterPanel.c</option>
<option value="listing26.html">/SampleFilter/SampleFilterPanel.h</option>
<option value="listing27.html">/SampleFilter/SampleFilterResources.h</option>
<option value="listing28.html">/SampleFilter/Version.h</option>
<option value="listing29.html">/SectionReport/Debug.h</option>
<option value="listing30.html">/SectionReport/LibraryStuff/Hints.h</option>
<option value="listing31.html">/SectionReport/LibraryStuff/PrintingPlugins.h</option>
<option value="listing32.html">/SectionReport/LibraryStuff/PrintingPlugins.r</option>
<option value="listing33.html">/SectionReport/LibraryStuff/PSLogFolder.h</option>
<option value="listing34.html">/SectionReport/LibraryStuff/PSOutputFilters.h</option>
<option value="listing35.html">/SectionReport/LibraryStuff/PSOutputFilters.r</option>
<option value="listing36.html">/SectionReport/LibraryStuff/PSSectionInfo.h</option>
<option value="listing37.html">/SectionReport/NoDebug.h</option>
<option value="listing38.html">/SectionReport/SectionReport.c</option>
<option value="listing39.html">/SectionReport/SectionReport.r</option>
<option value="listing40.html">/SectionReport/Version.h</option></select>
				</p>
				</form>
				<p><strong><a href="PostScript_Output_Filters.zip">Download Sample</a></strong> (&#147;PostScript_Output_Filters.zip&#148;, 229.2K)<BR>
<strong><a href="PostScript_Output_Filters.dmg">Download Sample</a></strong> (&#147;PostScript_Output_Filters.dmg&#148;, 297.8K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/***  File:      SectionReport.c****  Description:  C source for the SectionReport filter.  ****  Version:    1.0    ****  Copyright 1999 Apple Computer. All rights reserved.****  You may incorporate this sample code into your applications without**  restriction, though the sample code has been provided &quot;AS IS&quot; and the**  responsibility for its operation is 100% yours.  However, what you are**  not permitted to do is to redistribute the source as &quot;ABC Sample Code&quot;**  after having made changes. If you're going to re-distribute the source,**  we require that you make it clear in the source that the code was**  descended from Apple Sample Code, but that you've made changes.***/#include &lt;FixMath.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &quot;PSOutputFilters.h&quot;#include &quot;PSSectionInfo.h&quot;#include &quot;PSLogFolder.h&quot;#if qDebug#include &lt;Types.h&gt;#include &lt;Traps.h&gt;#include &lt;stddef.h&gt;#include &lt;OSUtils.h&gt;#define ckLine(line)  #line#define ckLine2(line)  ckLine(line)#define ckAssert(cond)     if(!(cond)) DebugStr(&quot;\pFailed &quot; #cond &quot;:&quot;__FILE__ &quot; &quot; ckLine2(__LINE__))#else#define ckAssert(cond)    ((void)0)      #endif/*** Private Macros ***/#define Unused(x)  ((void) x)#define FixedToFloat(a) ((float)(a) / fixed1)#define FIXED2INT(i)    ((short)((i)&gt;&gt;16))/*** Private Variable Types ***//**/typedef struct FilterData{  SInt32  lastFilteredMsgId;    // to keep track of the last PSPosition id that we've seen  SInt16  fileRef;        // the fRef of our our open log file}FilterData;/*** Private Prototypes ***/static OSStatus logDSC(SInt16 fRef, PSSection section, PSSubsection subsection, void *info);static void concatResourceData(char *theString, DSCStructuredResourceData *theData);static OSStatus myWrite(short fRef, char *formatString);/*** Private Variables ***//*** Code ***/OSStatus psOutputFilterPreFlight(PSOutputFilterRef filter, Collection jobInfo, Handle papaH, void **refconP)/*  psOutputFilterPreFlight is called by PrintingLib to see if the filter wants to be  included in the filter chain for the current job. For this filter,  as long as we can allocate open our log file and  allocate our private data we want to be part of the chain.*/{  OSStatus err = noErr;  FilterData *filterDataP;  FSSpec mySpec;  Unused(filter);  Unused(papaH);  filterDataP = (FilterData *)NewPtrClear(sizeof(FilterData));    // this initializes the lastFilteredMsgId to 0  if(filterDataP){    /*      Build a fileSpec corresponding to an appropriate name for our log file. We'll use      the suffix '.dsc'.    */    err = psMakeLogFileSpec(jobInfo, &amp;mySpec, &quot;\p.dsc&quot;);          if(!err){      /*        This creates an appropriately serialized filename should a log file already        exist with the input name. We pass false to ensure that an existing file        is not deleted.      */      err = psMakeNumberedFilename(&amp;mySpec, NULL, false);      if(!err){        // create and open the data fork of the file.        err = HCreate(mySpec.vRefNum, mySpec.parID,                 mySpec.name, 'MPS ', 'TEXT');        if(!err)          err = HOpenDF(mySpec.vRefNum, mySpec.parID, mySpec.name, fsWrPerm, &amp;(filterDataP-&gt;fileRef));      }    }    if(err){      if(filterDataP)        DisposePtr((Ptr)filterDataP);      filterDataP = NULL;      }  }else    err = MemError();    *refconP = filterDataP;      return err;  }OSStatus psOutputFilterPostFlight(PSOutputFilterRef filter, void *refcon)/*    PrintingLib calls this routine when our filter is being removed from   the filter output chain. At this point we need to clean up.  Here we deallocate the memory we've allocated during our execution.*/{  FilterData *filterDataP = (FilterData *)refcon;  Unused(filter);    if (filterDataP) {    FSClose(filterDataP-&gt;fileRef);    DisposePtr((Ptr)filterDataP);  }    return noErr;}OSStatus psOutputFilterWrite(PSOutputFilterRef filter, void *refcon, const void *data, long nBytes, const PSPosition *pos)/*  Filter the PostScript data being sent through us.*/{  FilterData *filterDataP = (FilterData *)refcon;  OSStatus err = noErr;    // Only look at new message IDs.   if (filterDataP-&gt;lastFilteredMsgId != pos-&gt;id) {    filterDataP-&gt;lastFilteredMsgId = pos-&gt;id;    err = logDSC(filterDataP-&gt;fileRef, pos-&gt;section, pos-&gt;subsection, pos-&gt;info);  }  if(!err)    err = psWriteNextFilter(filter, data, nBytes, pos);    return err;}static OSStatus logDSC(SInt16 fRef, PSSection section, PSSubsection subsection, void *info){  OSStatus err = noErr;  Boolean dataToWrite = true;  char formatString[256];  StringPtr p;  char *sectionStr;    switch(subsection){    case kSubPSAdobeEPS:    case kSubPSAdobeQuery:    case kSubPSAdobe:      ckAssert(info != NULL);      if(info){        switch(section){          case kSectAnon:            sectionStr = &quot;Anon&quot;;            break;          case kSectQueryJob:            sectionStr = &quot;Query&quot;;            break;          case kSectCoverPage:            sectionStr = &quot;CoverPage&quot;;            break;          case kSectJob:            sectionStr = &quot;Job&quot;;            break;          case kSectPeek:            sectionStr = &quot;Peek&quot;;            break;          default:            sectionStr = &quot;Unknown&quot;;            break;        }        if(subsection == kSubPSAdobe)          sprintf(formatString, &quot;%%!PS-Adobe-%.1f    (%s)&quot;, FixedToFloat(*(Fixed *)info), sectionStr);        else{          if(subsection == kSubPSAdobeQuery)            sprintf(formatString, &quot;%%!PS-Adobe-%.1f Query    (%s)&quot;, FixedToFloat(*(Fixed *)info), sectionStr);          else{            if(subsection == kSubPSAdobeEPS)              sprintf(formatString, &quot;%%!PS-Adobe-%.1f EPSF-%.1f    (%s)&quot;, FixedToFloat(((EPSFVersion *)info)-&gt;dscVersion),                 FixedToFloat(((EPSFVersion *)info)-&gt;epsfVersion), sectionStr);            else              ckAssert(false);          }        }      }      break;    case kSubTitle:      ckAssert(info != NULL);      if(info)        sprintf(formatString, &quot;%%%%Title: (%#s)&quot;, info);      break;    case kSubTrailer:      ckAssert(info == NULL);      sprintf(formatString, &quot;%%%%Trailer&quot;);      break;    case kSubBeginSetup:      ckAssert(info == NULL);      sprintf(formatString, &quot;%%%%BeginSetup&quot;);      break;    case kSubEndSetup:      ckAssert(info == NULL);      sprintf(formatString, &quot;%%%%EndSetup&quot;);      break;     case kSubEndComments:      ckAssert(info == NULL);      sprintf(formatString, &quot;%%%%EndComments&quot;);      break;    case kSubBoundingBox:      ckAssert(info != NULL);      if(info){        sprintf(formatString, &quot;%%%%BoundingBox: %hd %hd %hd %hd&quot;,               ((DSCBBox *)info)-&gt;llx,               ((DSCBBox *)info)-&gt;lly,              ((DSCBBox *)info)-&gt;urx,              ((DSCBBox *)info)-&gt;ury            );      }      break;    case kSubBeginFeature:      ckAssert(info != NULL);      if(info){        sprintf(formatString, &quot;%%%%BeginFeature: *%#s %#s&quot;,               ((DSCFeature *)info)-&gt;feature,               ((DSCFeature *)info)-&gt;option            );      }      break;    case kSubEndFeature:      ckAssert(info == NULL);      sprintf(formatString, &quot;%%%%EndFeature&quot;);      break;    case kSubIncludeFeature:      ckAssert(info != NULL);      if(info){        sprintf(formatString, &quot;%%%%IncludeFeature: *%#s %#s&quot;,               ((DSCFeature *)info)-&gt;feature,               ((DSCFeature *)info)-&gt;option);      }      break;    case kSubRBIBeginNonPPDFeature:      ckAssert(info != NULL);      if(info){        sprintf(formatString, &quot;%%RBIBeginNonPPDFeature: %#s %#s&quot;,               ((DSCFeature *)info)-&gt;feature,               ((DSCFeature *)info)-&gt;option);      }      break;    case kSubRBIEndNonPPDFeature:      ckAssert(info == NULL);      sprintf(formatString, &quot;%%RBIEndNonPPDFeature&quot;);      break;    case kSubRBIIncludeNonPPDFeature:      ckAssert(info != NULL);      if(info){        sprintf(formatString, &quot;%%RBIIncludeNonPPDFeature: %#s %#s&quot;,               ((DSCFeature *)info)-&gt;feature,               ((DSCFeature *)info)-&gt;option);      }      break;    case kSubStartNup:    case kSubIncludeStartNup:      ckAssert(info != NULL);      if(info){        DSCNupData *nupdata = (DSCNupData *)info;        StringPtr directionStr;        StringPtr acrossStr;        StringPtr frameWidthStr;        Str63 rotationStr;        ckAssert(nupdata-&gt;size == sizeof(DSCNupData));        if(nupdata-&gt;numXpages != 1 || nupdata-&gt;numYpages != 1){          switch (nupdata-&gt;acrossBeforeDown){            case 0:              acrossStr = &quot;\pDown Before Across&quot;;              break;                          case 1:              acrossStr = &quot;\pAcross Before Down&quot;;              break;            default:              ckAssert(false);              acrossStr = &quot;\pUp Down: ***BOGUS DATA&quot;;              break;              }                    switch (nupdata-&gt;layoutDirection){            case 0:              directionStr = &quot;\pLeft To Right, &quot;;              break;                          case 1:              directionStr = &quot;\pRight To Left, &quot;;              break;            default:              ckAssert(false);              directionStr = &quot;\pDirection: ***BOGUS DATA, &quot;;              break;          }          sprintf((char *)rotationStr, &quot; rotation %.1f degrees, &quot;, FixedToFloat(nupdata-&gt;rotation));                }else{          acrossStr = &quot;\p&quot;;          directionStr = &quot;\p&quot;;          rotationStr[0] = 0;        }                  if(nupdata-&gt;numframes &gt; 0){          switch (nupdata-&gt;framewidth){            case -1:              frameWidthStr = &quot;\p&quot;;              break;                          case 1:              frameWidthStr = &quot;\pThin frames, &quot;;              break;            case 4:              frameWidthStr = &quot;\pHairline frames, &quot;;              break;            default:              ckAssert(false);              frameWidthStr = &quot;\pFrame width: ***BOGUS DATA, &quot;;              break;          }        }else{          frameWidthStr = &quot;\p&quot;;        }                if(subsection == kSubStartNup){          sprintf(formatString, &quot;%% startNup invocation - numXPages %ld, numYPages %ld,%s %ld frames, %#s%#s%#s&quot;,            nupdata-&gt;numXpages, nupdata-&gt;numYpages, rotationStr, nupdata-&gt;numframes,             frameWidthStr, directionStr, acrossStr           );        }else{          sprintf(formatString, &quot;%%RBIIncludeStartNup - numXPages %ld, numYPages %ld,%s %ld frames, %#s%#s%#s&quot;,            nupdata-&gt;numXpages, nupdata-&gt;numYpages, rotationStr, nupdata-&gt;numframes,             frameWidthStr, directionStr, acrossStr           );        }      }      break;        case kSubDocProcessColors:      ckAssert(info != NULL);      if(info){        DSCProcessColors *processColors = (DSCProcessColors *)info;        ckAssert(processColors-&gt;size == sizeof(DSCProcessColors));        sprintf(formatString, &quot;%%%%DocumentProcessColors:%s%s%s%s&quot;,           processColors-&gt;cyan ? &quot; Cyan&quot; : &quot;&quot;,          processColors-&gt;magenta ? &quot; Magenta&quot; : &quot;&quot;,          processColors-&gt;yellow ? &quot; Yellow&quot; : &quot;&quot;,          processColors-&gt;black ? &quot; Black&quot; : &quot;&quot;);      }      break;        case kSubNupFinalPage:      ckAssert(info == NULL);      sprintf(formatString, &quot;%%finalpage&quot;);      break;        case kSubFor:      ckAssert(info != NULL);      if(info)        sprintf(formatString, &quot;%%%%For: (%#s)&quot;, info);      break;    case kSubPage:      ckAssert(info != NULL);      if(info)        sprintf(formatString, &quot;%%%%Page: %ld %#s&quot;,             ((DSCPage *)info)-&gt;ordinal,             ((DSCPage *)info)-&gt;label);      break;    case kSubIncludeFont:      ckAssert(info != NULL);      if(info)        sprintf(formatString, &quot;%%%%IncludeFont: %#s&quot;,             ((DSCData *)info)-&gt;u.structuredResourceData.u.instanceName);      break;    case kSubBeginFont:      ckAssert(info != NULL);      if(info)        sprintf(formatString, &quot;%%%%BeginFont: %#s&quot;,             ((DSCData *)info)-&gt;u.structuredResourceData.u.instanceName);      break;    case kSubEndFont:      ckAssert(info == NULL);      sprintf(formatString, &quot;%%%%EndFont&quot;);      break;    case kSubIncludeResource:      ckAssert(info != NULL);      if(info){        if(!((DSCData *)info)-&gt;structured)          sprintf(formatString, &quot;%%%%IncludeResource: %#s %#s&quot;,           ((DSCData *)info)-&gt;u.unstructuredResourceData.resourceType,          ((DSCData *)info)-&gt;u.unstructuredResourceData.data);        else{          sprintf(formatString, &quot;%%%%IncludeResource: %#s %#s&quot;,              ((DSCData *)info)-&gt;u.structuredResourceData.resourceType,               ((DSCData *)info)-&gt;u.structuredResourceData.u.instanceName            );        }      }      break;    case kSubBeginResource:      ckAssert(info != NULL);      if(info){        if(!((DSCData *)info)-&gt;structured)          sprintf(formatString, &quot;%%%%BeginResource: %#s %#s&quot;,           ((DSCData *)info)-&gt;u.unstructuredResourceData.resourceType,          ((DSCData *)info)-&gt;u.unstructuredResourceData.data);        else{          sprintf(formatString, &quot;%%%%BeginResource: %#s %#s&quot;,              ((DSCData *)info)-&gt;u.structuredResourceData.resourceType,               ((DSCData *)info)-&gt;u.structuredResourceData.u.instanceName            );        }      }      break;    case kSubDocMedia:                          ckAssert(info != NULL);      if(info){        if(!((DSCData *)info)-&gt;structured)          sprintf(formatString, &quot;%%%%DocumentMedia: %#s&quot;,           ((DSCData *)info)-&gt;u.unstructuredData);        else{          ckAssert( ((DSCData *)info)-&gt;u.documentMedia.size == sizeof(DSCDocumentMedia));          sprintf(formatString, &quot;%%%%DocumentMedia: (%#s) %.1f %.1f %.1f (%#s) (%#s)&quot;,              ((DSCData *)info)-&gt;u.documentMedia.mediaName,               FixedToFloat(((DSCData *)info)-&gt;u.documentMedia.width),               FixedToFloat(((DSCData *)info)-&gt;u.documentMedia.height),               FixedToFloat(((DSCData *)info)-&gt;u.documentMedia.weight),               ((DSCData *)info)-&gt;u.documentMedia.color,               ((DSCData *)info)-&gt;u.documentMedia.type             );        }      }      break;    case kSubADOImageableArea:      ckAssert(info != NULL);      if(info)        sprintf(formatString, &quot;%%ADO_ImageableArea: %.1f %.1f %.1f %.1f&quot;,          FixedToFloat(((DSCFixedBBox *)info)-&gt;llx),           FixedToFloat(((DSCFixedBBox *)info)-&gt;lly),           FixedToFloat(((DSCFixedBBox *)info)-&gt;urx),           FixedToFloat(((DSCFixedBBox *)info)-&gt;ury) );      break;                                      case kSubBeginDoc:      ckAssert(info != NULL);      if(info){        if(!((DSCData *)info)-&gt;structured)          sprintf(formatString, &quot;%%%%BeginDocument: %#s %#s&quot;,           ((DSCData *)info)-&gt;u.unstructuredResourceData.resourceType,          ((DSCData *)info)-&gt;u.unstructuredResourceData.data);        else{          DSCDocument *theDocument = (DSCDocument *)&amp;(((DSCData *)info)-&gt;u.structuredResourceData.u.document);          sprintf(formatString, &quot;%%%%BeginDocument: (%#s) %.1f (%#s)&quot;,  theDocument-&gt;name,                  FixedToFloat(theDocument-&gt;version), theDocument-&gt;type);        }      }      break;    case kSubRouting:      ckAssert(info != NULL);      if(info)        sprintf(formatString, &quot;%%%%Routing: (%#s)&quot;, info);      break;    case kSubEndDoc:      ckAssert(info == NULL);      sprintf(formatString, &quot;%%%%EndDocument&quot;);      break;    case kSubDocFonts:      ckAssert(info != NULL);      if(info){        sprintf(formatString, &quot;%%%%DocumentFonts: &quot;);        myWrite(fRef, formatString);        concatResourceData(formatString, &amp;( ((DSCData *)info)-&gt;u.structuredResourceData));      }      break;    case kSubDocFontsAtEnd:      ckAssert(info == NULL);      sprintf(formatString, &quot;%%%%DocumentFonts: (atend)&quot;);      break;    case kSubDocNeededFonts:      ckAssert(info != NULL);      if(info){        sprintf(formatString, &quot;%%%%DocumentNeededFonts: &quot;);        myWrite(fRef, formatString);        concatResourceData(formatString, &amp;( ((DSCData *)info)-&gt;u.structuredResourceData));      }      break;    case kSubDocNeededFontsAtEnd:      ckAssert(info == NULL);      sprintf(formatString, &quot;%%%%DocumentNeededFonts: (atend)&quot;);      break;    case kSubDocSuppliedFonts:      ckAssert(info != NULL);      if(info){        sprintf(formatString, &quot;%%%%DocumentSuppliedFonts: &quot;);        myWrite(fRef, formatString);        concatResourceData(formatString, &amp;( ((DSCData *)info)-&gt;u.structuredResourceData));      }      break;    case kSubDocSuppliedFontsAtEnd:      ckAssert(info == NULL);      sprintf(formatString, &quot;%%%%DocumentSuppliedFonts: (atend)&quot;);      break;    case kSubDocSuppliedRes:      ckAssert(info != NULL);      if(info){        sprintf(formatString, &quot;%%%%DocumentSuppliedResources: &quot;);        myWrite(fRef, formatString);        if( ((DSCData *)info)-&gt;structured){          // structured resource data. For now only structure data is the instanceName type of data (font or Font)          sprintf(formatString, &quot;%#s &quot;, &amp;(((DSCData *)info)-&gt;u.structuredResourceData.resourceType));  // emit the resource type          myWrite(fRef, formatString);          concatResourceData(formatString, &amp;( ((DSCData *)info)-&gt;u.structuredResourceData) );        }else{          //unstructured resource data          sprintf(formatString, &quot;%#s %#s&quot;,           ((DSCData *)info)-&gt;u.unstructuredResourceData.resourceType,                  (((DSCData *)info)-&gt;u.unstructuredResourceData.data));        }      }      break;    case kSubDocSuppliedResAtEnd:      ckAssert(info == NULL);      sprintf(formatString, &quot;%%%%DocumentSuppliedResources: (atend)&quot;);      break;    case kSubDocNeededRes:      ckAssert(info != NULL);      if(info){        sprintf(formatString, &quot;%%%%DocumentNeededResources: &quot;);        myWrite(fRef, formatString);        if( ((DSCData *)info)-&gt;structured){          // structured resource data. For now only structure data is the instanceName type of data (font or Font)          sprintf(formatString, &quot;%#s &quot;, &amp;(((DSCData *)info)-&gt;u.structuredResourceData.resourceType));  // emit the resource type          myWrite(fRef, formatString);          concatResourceData(formatString, &amp;( ((DSCData *)info)-&gt;u.structuredResourceData) );        }else{          //unstructured resource data          sprintf(formatString, &quot;%#s %#s&quot;,           ((DSCData *)info)-&gt;u.unstructuredResourceData.resourceType,                  (((DSCData *)info)-&gt;u.unstructuredResourceData.data));        }      }      break;    case kSubDocNeededResAtEnd:      ckAssert(info == NULL);      sprintf(formatString, &quot;%%%%DocumentNeededResources: (atend)&quot;);      break;    case kSubRBIDocSuppliedFonts:      ckAssert(info != NULL);      if(info){        sprintf(formatString, &quot;%%RBIDocumentSuppliedFonts: &quot;);        myWrite(fRef, formatString);        concatResourceData(formatString, &amp;( ((DSCData *)info)-&gt;u.structuredResourceData));      }      break;    case kSubRBIDocSuppliedFontsAtEnd:      ckAssert(info == NULL);      sprintf(formatString, &quot;%%RBIDocumentSuppliedFonts: (atend)&quot;);      break;    /* this implementation of continue expects that the continued data is either structured or unstructured resource      data as opposed to any other type of data. To really do this correctly we'd need to look at the continuedSection      field of the DSCContinuationData to see what type of data it really is.        */    case kSubContinue:      ckAssert(info != NULL);      if(info){        sprintf(formatString, &quot;%%%%+ &quot;);        myWrite(fRef, formatString);        if( ((DSCContinuationData *)info)-&gt;data.structured){          PSSubsection continuedSection = ((DSCContinuationData *)info)-&gt;continuedSection;          // structured resource data. For now only structure data is the instanceName type of data (font or Font)          if(continuedSection == kSubDocNeededRes || continuedSection == kSubDocSuppliedRes){            sprintf(formatString, &quot;%#s &quot;, &amp;(((DSCContinuationData *)info)-&gt;data.u.structuredResourceData.resourceType));  // emit the resource type            myWrite(fRef, formatString);          }          concatResourceData(formatString, &amp;( ((DSCContinuationData *)info)-&gt;data.u.structuredResourceData) );        }else{          //unstructured resource data          sprintf(formatString, &quot;%#s %#s&quot;,           &amp;(((DSCContinuationData *)info)-&gt;data.u.unstructuredResourceData.resourceType),          &amp;(((DSCContinuationData *)info)-&gt;data.u.unstructuredResourceData.data));        }      }      break;    case kSubPages:      ckAssert(info != NULL);      if(info){        if(*(SInt32 *)info &gt; 0){          sprintf(formatString, &quot;%%%%Pages: %ld&quot;, *(SInt32 *)info);        }else{          sprintf(formatString, &quot;%%%%Pages: (atend)&quot;);              }      }      break;    case kSubBeginFile:      ckAssert(info != NULL);      if(info)        sprintf(formatString, &quot;%%%%BeginFile: %#s&quot;, info);      break;    case kSubEndFile:      ckAssert(info == NULL);      sprintf(formatString, &quot;%%%%EndFile&quot;);      break;    case kSubRBINumCopies:      ckAssert(info != NULL);      if(info){        if(*(SInt32 *)info &gt;= 0){          sprintf(formatString, &quot;%%RBINumCopies: %ld&quot;, *(SInt32 *)info);        }      }      break;    case kSubLangLevel:      ckAssert(info != NULL);      if(info)        sprintf(formatString, &quot;%%%%LanguageLevel: %ld&quot;, *(SInt32 *)info);      break;    case kSubDocData:      ckAssert(info != NULL);      if(info){        switch(*(DSCDocumentData *)info){          default:          case kDSCUnknownDocumentData:            p = &quot;\p*** BAD DATA ***&quot;;            break;          case kDSCClean7Bit:            p = &quot;\pClean7Bit&quot;;            break;          case kDSCClean8Bit:            p = &quot;\pClean8Bit&quot;;            break;                    case kDSCBinary:            p = &quot;\pBinary&quot;;            break;        }        sprintf(formatString, &quot;%%%%DocumentData: %#s&quot;, p);      }      break;    case kSubPageOrder:      ckAssert(info != NULL);      if(info){        switch(*(DSCPageOrder *)info){          default:          case kDSCUknownPageOrder:            p = &quot;\p*** BAD DATA ***&quot;;            break;                    case kDSCAtEndPageOrder:            p = &quot;\p(atend)&quot;;            break;          case kDSCPageOrderAscend:            p = &quot;\pAscend&quot;;            break;          case kDSCPageOrderDescend:            p = &quot;\pDescend&quot;;            break;                    case kDSCPageOrderSpecial:            p = &quot;\pSpecial&quot;;            break;        }        sprintf(formatString, &quot;%%%%PageOrder: %#s&quot;, p);      }      break;    case kSubProofMode:      ckAssert(info != NULL);      if(info){        switch(*(DSCProofMode *)info){          case kDSCUknownProofMode:            p = &quot;\p*** BAD DATA ***&quot;;            break;          case kDSCProofModeTrustMe:            p = &quot;\pTrustMe&quot;;            break;          case kDSCProofModeSubstitute:            p = &quot;\pSubstitute&quot;;            break;                    case kDSCProofModeNotify:            p = &quot;\pNotify&quot;;            break;        }        sprintf(formatString, &quot;%%%%ProofMode: %#s&quot;, p);      }      break;    case kSubDate:      ckAssert(info != NULL);      if(info)        sprintf(formatString, &quot;%%%%CreationDate: (%#s)&quot;, info);      break;    case kSubCreator:      ckAssert(info != NULL);      if(info)        sprintf(formatString, &quot;%%%%Creator: (%#s)&quot;, info);      break;    case kSubBeginDefaults:      ckAssert(info == NULL);      sprintf(formatString, &quot;%%%%BeginDefaults&quot;);      break;    case kSubEndDefaults:      ckAssert(info == NULL);      sprintf(formatString, &quot;%%%%EndDefaults&quot;);          break;    case kSubBeginProlog:      ckAssert(info == NULL);      sprintf(formatString, &quot;%%%%BeginProlog&quot;);      break;    case kSubEndProlog:      ckAssert(info == NULL);      sprintf(formatString, &quot;%%%%EndProlog&quot;);          break;    case kSubPageTrailer:      if(info != NULL)        sprintf(formatString, &quot;%%%%PageTrailer (for page number %ld)&quot;, *(SInt32 *)info);      else        sprintf(formatString, &quot;%%%%PageTrailer&quot;);      break;    case kSubEOFNoJobTermination:      ckAssert(info == NULL);      sprintf(formatString, &quot;%%%%EOF    (with no job termination)&quot;);          break;    case kSubTerminateJob:      ckAssert(info == NULL);      sprintf(formatString, &quot;%%job termination&quot;);          break;    case kSubEOF:      ckAssert(info == NULL);      sprintf(formatString, &quot;%%%%EOF    (with job termination)&quot;);          break;    case kSubRBIPCFileName:      ckAssert(info != NULL);      if(info){        StringPtr filename = (StringPtr)info;        sprintf(formatString, &quot;%%RBIPCFileName: (%#s)&quot;, filename);      }      break;          case kSubRBINupNess:      ckAssert(info != NULL);      if(info){        DSCNupNess *nupness = (DSCNupNess *)info;        sprintf(formatString, &quot;%%RBINupNess: %ld %ld&quot;,nupness-&gt;pagesX, nupness-&gt;pagesY);      }      break;    case kSubRBIProduct:      ckAssert(info != NULL);      if(info){        StringPtr filename = (StringPtr)info;        sprintf(formatString, &quot;%%RBIPPDFileVersion: (%#s)&quot;, filename);      }      break;    case kSubViewOrientation:      ckAssert(info != NULL);      if(info){        DSCViewingOrientation *viewingOrientation = (DSCViewingOrientation *)info;        ckAssert(viewingOrientation-&gt;size == sizeof(DSCViewingOrientation));        if(viewingOrientation-&gt;isAtEnd)          sprintf(formatString, &quot;%%%%ViewingOrientation: (atend)&quot;);        else          sprintf(formatString, &quot;%%%%ViewingOrientation: %d %d %d %d&quot;, viewingOrientation-&gt;a,              viewingOrientation-&gt;b, viewingOrientation-&gt;c, viewingOrientation-&gt;d);      }      break;    case kSubBeginColorspace:      ckAssert(info != NULL);      if(info)        sprintf(formatString, &quot;%%%%BeginResource: ColorSpace (%#s)&quot;, info);      break;          case kSubEndResource:      ckAssert(info == NULL);      sprintf(formatString, &quot;%%%%EndResource&quot;);      break;    case kSubInfoPages:                                  ckAssert(info != NULL);      if(info)        sprintf(formatString, &quot;/Pages %ld def&quot;, *(SInt32 *)info);      break;    case kSubInfoTitle:                                  ckAssert(info != NULL);      if(info)        sprintf(formatString, &quot;/Title(%#s)def&quot;, info);      break;          case kSubInfoCreator:                                ckAssert(info != NULL);      if(info)        sprintf(formatString, &quot;/Creator(%#s)def&quot;, info);      break;    case kSubInfoDate:      ckAssert(info != NULL);      if(info)        sprintf(formatString, &quot;/CreationDate(%#s)def&quot;, info);      break;    case kSubInfoFor:                                  ckAssert(info != NULL);      if(info)        sprintf(formatString, &quot;/For(%#s)def&quot;, info);      break;    case kSubBeginBitmapFont:      ckAssert(info != NULL);      if(info)        sprintf(formatString, &quot;%%RBIBeginBitmapFont: %#s&quot;, info);      break;    case kSubBeginTrueTypeFont:      ckAssert(info != NULL);      if(info)        sprintf(formatString, &quot;%%RBIBeginTrueTypeFont: %#s&quot;, info);      break;    case kSubEndBitmapFont:      ckAssert(info == NULL);      sprintf(formatString, &quot;%%RBIEndBitmapFont&quot;);      break;    case kSubEndTrueTypeFont:      ckAssert(info == NULL);      sprintf(formatString, &quot;%%RBIEndTrueTypeFont&quot;);      break;    case kSubBeginTrueTypeScaler:      ckAssert(info == NULL);      sprintf(formatString, &quot;%%RBIBeginFontRasterizer: TrueType&quot;);      break;    case kSubEndTrueTypeScaler:      ckAssert(info == NULL);      sprintf(formatString, &quot;%%RBIEndFontRasterizer: TrueType&quot;);      break;    case kSubPageOrientation:    case kSubOrientation:      ckAssert(info != NULL);      if(info){        switch(*(DSCOrientation *)info){          default:          case kDSCUknownOrientation:            p = &quot;\p*** BAD DATA ***&quot;;            break;          case kDSCAtEndOrientation:            p = &quot;\p(atend)&quot;;            break;          case kDSCPortraitOrientation:            p = &quot;\pPortrait&quot;;            break;                    case kDSCLandscapeOrientation:            p = &quot;\pLandscape&quot;;            break;        }        sprintf(formatString, &quot;%%%%%s: %#s&quot;, (subsection == kSubOrientation) ? &quot;Orientation&quot; : &quot;PageOrientation&quot;, p);      }      break;    case kSubBeginPageSetup:      if(info != NULL)        sprintf(formatString, &quot;%%%%BeginPageSetup (for page number %ld)&quot;, *(SInt32 *)info);      else        sprintf(formatString, &quot;%%%%BeginPageSetup&quot;);      break;    case kSubEndPageSetup:      if(info != NULL)        sprintf(formatString, &quot;%%%%EndPageSetup (for page number %ld)&quot;, *(SInt32 *)info);      else        sprintf(formatString, &quot;%%%%EndPageSetup&quot;);      break;    case kSubBeginPageSlotInvocation:      ckAssert(info == NULL);      sprintf(formatString, &quot;%%RBIBeginPageSlotInvocation&quot;);      break;    case kSubEndPageSlotInvocation:      ckAssert(info == NULL);      sprintf(formatString, &quot;%%RBIEndPageSlotInvocation&quot;);      break;    case kSubIncludePageSlotInvocation:      ckAssert(info == NULL);      sprintf(formatString, &quot;%%RBIIncludePageSlotInvocation&quot;);      break;    case kSubPageGStateSetup:      ckAssert(info == NULL);      sprintf(formatString, &quot;%%page gstate setup&quot;);      break;    case kSubPageMTSMatrixSetup:      ckAssert(info == NULL);      sprintf(formatString, &quot;%%mTS matrix setup&quot;);      break;    case kSubPSBegin:      ckAssert(info == NULL);      sprintf(formatString, &quot;psb&quot;);      break;    case kSubPSEnd:      ckAssert(info == NULL);      sprintf(formatString, &quot;pse&quot;);      break;      case kSubPSBeginNoSave:      ckAssert(info == NULL);      sprintf(formatString, &quot;%%psbegin-nosave&quot;);      break;    case kSubPSEndNoSave:      ckAssert(info == NULL);      sprintf(formatString, &quot;%%psend-nosave&quot;);      break;      case kSubPageSaveLevelSetup:      ckAssert(info == NULL);      sprintf(formatString, &quot;%%page level save&quot;);      break;    case kSubPageSaveLevelRestore:      ckAssert(info == NULL);      sprintf(formatString, &quot;%%page level restore&quot;);      break;      case kSubShowpage:      ckAssert(info == NULL);      sprintf(formatString, &quot;%%showpage&quot;);      break;      case kSubStatusSection:      dataToWrite = false;      break;    case kSubSetJobStatusStr:      ckAssert(info != NULL);      if(info){        DSCJobStatus *dscJobStatus = (DSCJobStatus *)info;        ckAssert(dscJobStatus-&gt;size == sizeof(DSCJobStatus));        if(dscJobStatus-&gt;currentPage &lt;= 0)          sprintf(formatString, &quot;(%#s)setjob&quot;, dscJobStatus-&gt;username);        else{          if(dscJobStatus-&gt;totalPages &lt; 1)            sprintf(formatString, &quot;(%#s; page: %ld)setjob&quot;,                   dscJobStatus-&gt;username, dscJobStatus-&gt;currentPage);          else            sprintf(formatString, &quot;(%#s; page: %ld of %ld)setjob&quot;,                     dscJobStatus-&gt;username,                     dscJobStatus-&gt;currentPage,                     dscJobStatus-&gt;totalPages);        }      }      break;    case kSubAnnotateFontKey:      ckAssert(info != NULL);      if(info){        DSCFontAnnotation *dscFontAnnotation = (DSCFontAnnotation *)info;        ckAssert(dscFontAnnotation-&gt;size == sizeof(DSCFontAnnotation));        sprintf(formatString, &quot;%%RBIFontKey: (%#s) %dpoint %#s&quot;,                 dscFontAnnotation-&gt;fontName, FIXED2INT(dscFontAnnotation-&gt;pointSize),                 dscFontAnnotation-&gt;styleString);      }      break;    default:      if(subsection == kSubAnon)        dataToWrite = false;      else        sprintf(formatString, &quot;Subsection not handled: %ld, infofield: %ld&quot;, subsection, info);          break;  }  if(dataToWrite){    strcat(formatString, &quot;\r&quot;);    err = myWrite(fRef, formatString);  }    ckAssert(err == noErr);      return err;}static OSStatus myWrite(short fRef, char *formatString){  OSStatus err = noErr;  SInt32 nBytes = (SInt32)strlen(formatString);  err = FSWrite(fRef, &amp;nBytes, formatString);  return err;} static void concatResourceData(char *theString, DSCStructuredResourceData *theData){  short bytesRemaining = 255;      // the max of the string (leave room for last space)  Byte *nextByte = (unsigned char *)theString;  Str63 *nextInstance = (Str63*) &amp;(theData-&gt;u.instanceName);  short count = theData-&gt;count;  while(count--){    short bytesToCopy = (*nextInstance)[0];    if(bytesToCopy &lt;= bytesRemaining){      memcpy(nextByte, ((Byte *)nextInstance)+1, bytesToCopy);    // copy the data      nextByte += bytesToCopy;      memcpy(nextByte, &quot; &quot;, 1);    // add a space      nextByte++;            // include the space      bytesRemaining -= bytesToCopy + 1;      nextInstance++;    }  }  if(bytesRemaining &gt; 0)*nextByte = 0;    // terminate the string with a NULL (it is a C string)}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/PostScript_Output_Filters/listing38.html%3Fid%3DDTS10000297-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/PostScript_Output_Filters/listing38.html%3Fid%3DDTS10000297-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/PostScript_Output_Filters/listing38.html%3Fid%3DDTS10000297-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>