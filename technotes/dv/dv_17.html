<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 03-24-01 --><!--Includes revisions to code listings--><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note DV17: Sony Driver: What Your Sony Drives For You</title><meta name="keywords" content="Mac OS 8 Sony Driver Hard Disk 20 drive icon"><meta name="Description" content="Technical Note DV17: This Technical Note covers the external(software)  interface to the Sony 3.5 floppy disk and HardDisk 20 driver. It describes  interface calls, includingthose for Modified Frequency Modulation (MFM)  driver versions.Calls documented include read/write (Prime) calls,  the controlcalls (format disk, verify disk, etc.), and Status calls (return format list, drive status). Technical Note includesdefinitions  of the error codes for each call, and some ofthe formats of the  returned values of these calls."><meta name="categories" content="Devices"><meta name="week-posted" content="Mar 26, 1990 - Apr 6, 1990"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002407" title="Sony Driver: What Your Sony Drives For You"></a><A NAME="top"></A><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxHardwareDrivers-date.html">Hardware & Drivers</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/HardwareDrivers/idxMassStorageDevices-date.html" target="_blank">Hardware & Drivers > Storage</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note DV17</div>
<div id="pageheadsub">Sony Driver: What Your Sony Drives For You</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                   <td background="images/tnmenubody.gif" width=300 align=left>                        <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->					<p id="menutext"><a href="#Section1">New Driver Calls</a><BR><BR><a href="#Section2">Prime (Read &amp; Write) Calls</a><BR><BR><a href="#Section3">Control Calls</a><BR><BR><a href="#Section4">Status Calls</a><BR><BR> <a href="#references">References</a><BR><BR>  <a href="#changes">Change History</a><BR><BR><A href="#downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>		<td width=300 valign="top" align=left>	<!-- begin_intro_text --><P id = "introtext">This Technical Note discusses the Sony driver control and status calls that areavailable on the Macintosh.</p><!-- end_intro_text --><!-- begin_date --><h3>Updated: [May 01 1990]</h3><!-- end_date -->                </TD>             </TR>          </TABLE> <!-- end_header_box --><BR><BR><hr width=500 align=center><BR><BR><!-- begin_content --><a name="Section1"></a><h2>New Driver Calls</h2><p>This Note covers the external (software) interface to the Sony 3.5" floppy diskand Hard Disk 20 driver.  It describes all the new calls, including those forModified Frequency Modulation (MFM) driver versions.  This discussion assumes ageneral understanding of the operation of Macintosh drivers.  As all of thesecalls are not available on all Macintosh models, the following table showswhich calls are available on which models:</p><p>All    <code>Read, Write, Kill, Eject, Set Tag Buffer, Drive Status</code></p><p>128K and later ROMs    <code>Verify Disk, Format Disk, Track Cache Control, ReturnPhysical Drive Icon</code></p><p>256K and later ROMS    <code>Return Media Icon, Return Drive Info</code></p><p>SuperDrive equipped    <code>Return Format List</code></p><p>IIfx only    <code>Diagnostic Raw Track Dump</code></p><P><A HREF="#top">Back to top</A></P><a name="Section2"></a><h2>Prime (Read &amp; Write) Calls</h2><p>Read and write calls to Macintosh drivers are described in general in <i>InsideMacintosh</i>, Volume II, The Device Manager, but for completeness, thisdiscussion also includes them.  The Device Manager prime routines expect tohave the following fields set up in the I/O parameter block:</p><p><code>ioCompletion</code> pointer to a completion routine (asynchronous calls) or<code>NIL</code> (synchronous calls)</p><p><code>ioVRefNum</code> drive number (for device calls) or volume reference number (forfile system calls)</p><p><code>ioRefNum</code> driver's reference number (-5 for floppy disks or -2 for Hard Disk 20)</p><p><code>ioBuffer</code> pointer to the location in memory where data is read to or written from</p><p><code>ioReqCount</code>    number of bytes to read from or write to the disk</p><p><code>ioPosMode</code> tells what the absolute starting point is:  beginning, end, orcurrent location (bit 6 is set to 1 to do a read-verify instead of a read)</p><p><code>ioPosOffset</code> offset in bytes relative to the starting point in <code>ioPosMode</code></p><p>When you make a call to the Sony driver's prime routine, register <code>A0</code>points to this I/O parameter block and register <code>A1</code> points to thedriver's Device Control Entry (DCE).  The Device Manager sets the <code>ioTrap</code> field of the parameter block to either $A002 for a read request or $A003 for a write request, so the driver can determine the appropriate action.  The Device Manager also sets the <code>dCtlPosition</code> field of the driver's DCE to the starting byte offset relative to the beginning of the disk.</p><p>You can call the Sony driver either synchronously or asynchronously; however,making an immediate "mode" call to the driver causes it to bomb.  The driverbegins a read or write request, returns control to the caller (either the user(asynchronous) or the Device Manager (synchronous)), then completes the requestasynchronously at the interrupt level.  When the request is completed oraborted, the driver returns one of the following result codes:</p><p><code>noErr</code>0 no error</p><p><code>wPrErr</code>-44 diskette is write protected</p><p><code>paramErr</code>-50    some of the requested blocks are past the end of the disk or<code>ioReqCount</code> is not an even multiple of 512 bytes</p><p><code>nsDrvErr</code>-56    no such drive number</p><p><code>noDriveErr</code>-64 drive not installed</p><p><code>offLinErr</code>-65 read or write request made to an ejected disk</p><p><code>noNybErr</code>-66    could not find five nibbles in 200 tries (Group CodedRecording (GCR)) or byte timeout (MFM)</p><p><code>noAdrMkErr</code>-67    could not find a valid address mark</p><p><code>dataVerErr</code>-68    read verify compare failed</p><p><code>badCkSmErr</code>-69    address mark checksum was incorrect</p><p><code>badBtSlpErr</code>-70 one of the address mark bit slip nibbles was incorrect (GCR)</p><p><code>noDtaMkErr</code>-71 could not find a data mark header</p><p><code>badDCkSum</code>-72 bad data mark checksum</p><p><code>badDBtSlp</code>-73 one of the data mark bit slip nibbles was incorrect (GCR)</p><p><code>wrUnderRun</code>-74 could not write fast enough to keep up with the IWM</p><p><code>cantStepErr</code>-75    step handshake failed during seek</p><p><code>tk0BadErr</code>-76 track zero detect sensor does not change during a head recalibration</p><p><code>initIWMErr</code>-77 unable to initialize IWM</p><p><code>twoSideErr</code>-78 tried to read a double-sided disk on a single-sided drive</p><p><code>spdAdjErr</code>-79 unable to correctly adjust the drive speed (GCR, 400K drives only)</p><p><code>seekErr</code>-80 wrong track number read in a sector's address field</p><P><A HREF="#top">Back to top</A></P><a name="Section3"></a><h2>Control Calls</h2><p>Control calls perform all of the operations not related to reading from or writing to a particular disk associated with this driver.  The control opcode is passed to the driver in the <code>csCode</code> field of the I/O parameter block (byte 26).  Control calls which return information do so by passing it back, starting at the <code>csParam</code> field of the I/O parameter block (byte 28).Following is a description of each control operation with any result codes it returns.</p><p><b>Kill I/O (csCode=1)</b></p><p>Kill I/O is called to abort any current I/O request in progress.  The Sonydriver does not support this control call and always returns a result code of -1.</p><p><b>Verify Disk (csCode=5)</b></p><p>Verify Disk reads every sector from the selected disk to verify that they allhave been written correctly.  If any sector is found to be bad, it abortsimmediately and returns one of the following error codes:</p><p><code>noErr</code>0 no error</p><p><code>controlErr</code>-17 verify failed (Hard Disk 20 only)</p><p><code>nsDrvErr</code>-56    no such drive number</p><p><code>noDriveErr</code>-64 drive not installed</p><p><code>noNybErr</code>-66    various read errors</p><p><code>badDBtSlp</code>-73 bad data bit slip error</p><p><code>cantStepErr</code>-75 step handshake failed during seek</p><p><code>initIWMErr</code>-77 unable to initialize IWM</p><p><code>pdAdjErr</code>-79    unable to correctly adjust disk speed</p><p><code>verErr</code>-84 track failed to verify</p><p><b>Format Disk (csCode=6)</b></p><p>If the selected disk is a floppy disk, Format Disk writes address headers anddata fields for every sector on the disk (for GCR disks only) and does alimited verification of the format by checking that the address field of thefirst sector on each track can be read.  If the selected disk is a Hard Disk20, Format Disk does not do an actual format of the media, but insteadinitializes the data of each sector to all zeroes.  If any error occurs(including write-protected media), Format Disk aborts the formatting andreturns an error code.</p><p>The <code>csParam</code> field is used to specify the type of format to be done onfloppy disks only.  In pre-SWIM versions of the driver, putting a $0001 at<code>csParam</code> creates a single-sided disk, while a non-$0001 value (usually$0002) creates a double-sided disk.  In the SWIM and later versions, this valueis an index of a list of possible formats for the given hardware and diskcombination (see the <b>Return Format List </b>(csCode = 6) status call for values).</p><p><code>noErr</code>0    no error</p><p><code>controlErr</code>-17    format failed (Hard Disk 20 only)</p><p><code>wPrErr</code>-44    disk is write-protected</p><p><code>paramErr</code>-50    format type is out of range</p><p><code>nsDrvErr</code>-56    no such drive number</p><p><code>noDriveErr</code>-64    drive not installed</p><p><code>noNybErr</code>-66    various read errors</p><p><code>badBtSlpErr</code>-70    ...</p><p><code>wrUnderRun</code>-74    write underrun occurred</p><p><code>cantStepErr</code>-75    step handshake failed during seek</p><p><code>initIWMErr</code>-77    unable to initialize IWM</p><p><code>spdAdjErr</code>-79    unable to correctly adjust disk speed</p><p><code>fmt1Err</code>-82    cannot find sector zero after track format</p><p><code>fmt2Err</code>-83    cannot get enough sync between sectors</p><p><code>noIndexErr</code>-83    timed out waiting for drive's index pulse (MFM only)</p><p><b>Eject Disk (csCode=7)</b></p><p>Eject Disk ejects the disk in the selected drive if that drive supportsremovable media.  Since Hard Disk 20 drives are not removable, if one isejected, the driver posts a <code>diskInserted</code> event so that the operatingsystem remounts the drive.</p><p><code>noErr</code>0    no error</p><p><code>nsDrvErr</code>-56    no such drive number</p><p><code>noDriveErr</code>-64    drive not installed</p><p><code>cantStepErr</code>-75    step handshake failed during seek</p><p><code>tk0BadErr</code>-76    track zero detect does not change during head recalibration</p><p><code>initIWMErr</code>-77    unable to initialize IWM</p><p><b>Set Tag Buffer (csCode=8)</b></p><p>If <code>csParam</code> is zero, then no separate tag buffer is used.  If<code>csParam</code> is non-zero, it is assumed to contain a pointer to a bufferwhere tag bytes from each block are read into or written from on each primecall.  Every time a block is read from the disk, the 12 tag bytes are copiedinto the file tags buffer at <code>TagData+2</code> ($2FC) and then into the user'stag buffer.  When a block is written, tag bytes are copied into the file tagbuffer from the user's tag buffer, and then written to the disk with the restof the block.  The position of a particular block's tag bytes in the user tagbuffer is determined by that block's position relative to the first block reador written on the <b>current</b> prime call.  The file tags for GCR disksinclude information that a scavenging utility could use to rebuild a disk ifthe directory structure were trashed.  Figure 1 illustrates the tags.  For moredetailed information about tag buffers, refer to <i>Inside Macintosh</i>,Volume II, The Disk Driver.</p><P align=center><img src="images/dv_17_001.gif" alt="File Tags" width=192 height=74></p><p align=center><b>Figure 1</b> - File Tags</p><p><b>Track Cache Control (csCode=9)</b></p><p>When the track cache is enabled, all of the sectors on the last track accessedduring a read request are read into a buffer in RAM.  The sectors that wereactually requested are also returned in the user's buffer.  On future readrequests, if the track is the same as the last read track, the sector data isread from the cache instead of the disk.  Write requests to the driver arepassed directly to the disk, and any of the sectors written that are in thecache are marked invalid.  Two bytes are passed at <code>csParam</code> to controlthe cache:</p><p><b> csParam csParam+1</b></p><p>=0: disable the cache &lt;0: remove the cache</p><p>!=0: enable the cache =0: do not remove or install</p><p>&gt;0: install the cache</p><p>When the cache is removed, 680x0 register <code>D0</code> contains the previoussize of the cache.</p><p><code>noErr</code>0    no error</p><p><code>memFullErr</code>-108    not enough room in heap zone to install track cache</p><p><b>Return Physical Drive Icon (csCode=21)</b></p><p>This call returns a pointer to an icon describing the selected drive's physicallocation.  The supported drive icons are shown in Figure 2.  Note that only theicons for a particular machine are included in that version of the driver.  TheHard Disk 20 icon is in the drive's ROM, so it is available only when a HardDisk 20 is connected.</p><P align=center><img src="images/dv_17_002.gif" alt="Physical Drive Icons" width=448 height=164></p><p align=center><b>Figure 2</b> - Physical Drive Icons</p><p><code>noErr</code>0    no error</p><p><code>controlErr</code>-17    icon does not exist or is not available (Hard Disk 20 only)</p><p><code>nsDrvErr</code>-56    no such drive number</p><p><code>noDriveErr</code>-64 drive not installed</p><p><b>Return Media Icon (csCode=22)</b></p><p>Return Media Icon returns a pointer to an icon for the selected drive's mediatype.  The Sony floppy disk icon is stored in the driver, while the Hard Disk20 icon is retrieved from the drive's ROM.</p><P align=center><img src="images/dv_17_003.gif" alt="Media Icons" width=160 height=57></p><p align=center><b>Figure 3</b> - Media Icons</p><p><code>noErr</code>0    no error</p><p><code>controlErr</code>-17    icon does not exist or is not available (Hard Disk 20 only)</p><p><code>nsDrvErr</code>-56    no such drive number</p><p><code>noDriveErr</code>-64    drive not installed</p><p><b>Return Drive Info (csCode=23)</b></p><p>Return Drive Info returns a 32-bit value in <code>csParam</code> that describes thelocation and attributes of the selected drive.</p><P align=center><img src="images/dv_17_004.gif" alt="Return Drive Info in csParam" width=320 height=84></p><p align=center><b>Figure 4</b> - Return Drive Info in csParam</p><p>As illustrated in Figure 4, most of the bits of this returned value arecurrently not used and left open for future expansion.  The drive type fieldoccupies bits zero to three and describes the kind of drive that is connected.Currently six different "types" are supported:</p><p>0 no such drive</p><p>1 unspecified drive</p><p>2 400K Sony</p><p>3 800K Sony</p><p>4 SuperDrive (400K/800K GCR, 720K/1440K     MFM)</p><p>5 <b>reserved</b></p><p>6 <b>reserved</b></p><p>7 Hard Disk 20</p><p>The attributes field occupies bits 8 to 11 and describes the location (internalor external, primary or secondary), drive interface (IWM or SCSI), and mediatype (fixed or removable).</p><p><code>noErr</code>0    no error</p><p><code>nsDrvErr</code>-56 no such drive number</p><p><code>noDriveErr</code>-64 drive not installed</p><p><b>Diagnostic Raw Track Dump (csCode=18244)</b></p><p>This control call reads all or part of a track and returns the raw data itfinds so applications can access a floppy disk at a very low level withouthaving to directly access the hardware.  This call is available in the ROM ofthe  Macintosh IIfx.  An application should check for the presence of thiscall, and if it's not available, either bail out or find another way to readthe raw data.  If you make the call and it is not supported on the machine,then it returns with a -17 <code>controlErr</code>.  This call is needed since theSWIM chip is <b>not</b> going to be directly addressable in the future.  Thefollowing parameters are passed starting at <code>csParam</code>:</p><p>+0    <code>clockBitsBuffer</code>longint    pointer to packed bit array (MFM disksonly), or <code>NIL</code></p><p>+4    <code>dataBuffer</code>longint pointer to raw track data, or <code>NIL</code></p><p>+8    <code>byteCount</code>longint number of bytes requested (dataBuffer must beable to hold this many bytes)</p><p>+12    <code>numDone</code> longint number of bytes actually read (&lt;=<code>byteCount</code>)</p><p>+16    <code>searchMode</code> word when to start collecting bytes:</p><p>0 =    as soon as spindle motor is up to speed</p><p>1 =    after reading an address field</p><p>2 =    after reading a data field</p><p>3 =    at the index mark (MFM disks only)</p><p>+18    <code>track</code> word    which track to read (0-79)</p><p>+20    <code>side</code> byte which side to read (0-1)</p><p>+21    <code>sector</code> byte which sector to synchronize on (GCR=0-8,9,10,11;MFM=1-9 or 1-18); however, any value &nbsp;</p><p>If <code>clockBitsBuffer</code> is not <code>NIL</code>, it points to a buffer thatmust be at least one-eighth the size of <code>dataBuffer</code>.  It consists of anarray of bits signifying whether or not the corresponding byte in<code>dataBuffer</code> is a mark or data byte.  If a bit is equal to one, the byteis an MFM mark byte, but if it is equal to zero, the byte is an MFM data byte.The relationship between bits in <code>clockBitsBuffer</code> and <code>dataBuffer</code> is shown in Figure 5.  The example shows a typical MFM address field.</p><P align=center><img src="images/dv_17_005.gif" alt="clockBitsBuffer versus dataBuffer" width=320 height=134></p><p align=center><b>Figure 5</b> - clockBitsBuffer versus dataBuffer</p><p><b>Note:</b> If both <code>clockBitsBuffer</code> and <code>dataBuffer</code> are<code>NIL</code>, the call does nothing.  This provides a way for applications todetermine if the call exists without first having to allocate large buffers.</p><p><b>Note:</b>    The <code>clockBitsBuffer</code> has random data in it for GCR disks,but the <code>dataBuffer</code> has valid information.</p><p><code>ByteCount</code> specifies the number of raw bytes to read.  It may not bepossible to read that many bytes on every Macintosh due to differences in theway that the hardware and software are implemented, so the call returns thenumber of bytes that were actually read in <code>numDone</code>.  If<code>byteCount</code> is zero, the call does nothing.</p><p><code>SearchMode</code> specifies when to begin actually collecting bytes.  The firstcase (0) implies that the location where reading begins is somewhat random.Cases 1 and 2 begin reading bytes as soon after the end of an address or datafield as possible.  If the read is done on an MFM disk, the call resynchronizesand begins reading at the next mark byte that follows a sync field.  The lastcase synchronizes with the drive's index signal and then begins reading as soonas it sees a mark byte that follows a sync field.</p><p>The <code>track</code>, <code>side</code>, and <code>sector</code> fields areself-explanatory.  Of course, the sector number is not needed or used when<code>searchMode</code> is either 0 or 3.</p><p><code>noErr</code> 0 no error</p><p><code>controlErr</code> -17 this call is not supported on the host Macintosh</p><p><code>paramErr</code> -50 one or more of the parameters is out of range</p><p><code>nsDrvErr</code> -56 no such drive number</p><p><code>noDriveErr</code>-64 drive not installed</p><p><code>offLinErr</code>-65 read or write request made to an ejected disk</p><p><code>noNybErr</code>-66 could not find five nibbles in 200 tries (GCR) or byte timeout (MFM)</p><p><code>noAdrMkErr</code> -67 could not find a valid address mark</p><p><code>badCkSmErr</code> -69 address mark checksum was incorrect</p><p><code>badBtSlpErr</code> -70 one of the address mark bit slip nibbles was incorrect (GCR)</p><p><code>noDtaMkErr</code> -71 could not find a data mark header</p><p><code>badDCkSum</code> -72 bad data mark checksum</p><p><code>badDBtSlp</code> -73 one of the data mark bit slip nibbles was incorrect (GCR)</p><p><code>cantStepErr</code> -75 step handshake failed during seek</p><p><code>twoSideErr</code> -78 tried to read a double-sided disk on a single-sided drive</p><p><code>spdAdjErr</code> -79 unable to correctly adjust the drive speed (GCR, 400K drives only)</p><p><code>eekErr</code> -80 wrong track number read in a sector's address field</p><p><code>sectNFErr</code> -81 sector number never found on a track</p><p><code>noIndexErr</code> -83 timed out waiting for index signal</p><P><A HREF="#top">Back to top</A></P><a name="Section4"></a><h2>Status Calls</h2><p>The Sony driver currently supports three status calls, which are described inthis section.  As with the control calls, the status opcode is passed to thedriver in the <code>csCode</code> field of the I/O parameter block (byte 26).  Thereturned status information is passed back starting at the <code>csParam</code>field of the I/O parameter block (byte 28).</p><p><b>Return Format List (csCode=6)</b></p><p>Return Format List is only supported in SWIM or later versions of the Sonydriver, whether or not MFM disks are supported.  It returns a list of allpossible disk formats that are supported with the current combination of diskcontroller, drive, and media.  On entry, <code>csParam</code> contains a valuespecifying the maximum number of formats to return (refer to Technical Note#262, Controlling Status Calls, for more information), and <code>csParam</code>+2contains a pointer to a table which contains the list.  On exit, <code>csParam</code> contains the number of formats returned (no more than specified) and the table contains the list of formats.  If no disk is inserted in the drive, the call returns a <code>noDriveErr</code> code.  The formatinformation is given in an eight-byte record as shown in Figure 6.</p><P align=center><img src="images/dv_17_006.gif" alt="Format Information From Return Format List" width=448 height=102></p><p align=center><b>Figure 6</b> - Format Information From Return Format List</p><p>If a <code>track</code>, <code>side</code>, or <code>sector</code> field is zero when theTSS valid bit is set to one, that field is considered to be a "don't care" asfar as describing the format of the disk.  When the TSS valid bit is zero, the<code>track</code>, <code>side</code>, and <code>sector</code> fields may be driver-defined.  The formats supported by the driver are as follows:</p><P align=center><img src="images/dv_17_007.gif" alt="dv_17_table1.gif" width=464 height=156></p><p><code>noErr</code>0    no error</p><p><code>paramErr</code>-50    error in user's parameter list</p><p><code>nsDrvErr</code>-56    no such drive number</p><p><code>noDriveErr</code>-64 drive not installed</p><p><b>Drive Status (csCode=8)</b></p><p>Drive Status returns information about a particular drive starting at<code>csParam</code>.  Drive Status returns only a <code>noErr</code> (0) message.</p><P align=center><img src="images/dv_17_008.gif" alt="dv_17_table2.gif" width=448 height=457></p><P><A HREF="#top">Back to top</A></P><a name="references"></a><h2>References</h2><P><i>Inside Macintosh</i>, Volumes II, IV &amp; V, The Disk Driver</p><P>Technical Note M.DV.HLControlAndStatus -- Controlling Status Calls.</p><P><A HREF="#top">Back to top</A></P><a name="changes"></a><h2>Change History</h2> <TABLE BORDER=0 CELLPADDING=3 WIDTH=544>            <TR>               <td width=100 align=left>                  <P ALIGN=center>01-April-1990</P>               </TD>               <td align="left">                  <P>Originally written.</P>               </TD>            </TR>             <TR>               <td width=100 align=left>                  <P ALIGN=center>01-May-1990</P>               </TD>               <td align="left">                  <P>Corrected Figure 2, since the Return PhysicalDrive Icon (<code>csCode = 21</code>) returns an error message instead of an iconon the Macintosh Plus.</P>               </TD>            </TR>            </table><P><A HREF="#top">Back to top</A></P>         <a name="downloads"></a>         <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center>                                    <img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (292K)</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/dv_17.pdf">Download</A></P>               </TD>            </TR>         </TABLE>         <BR>                  <P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/dv/dv_17.html%3Fid%3DDTS10002407-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/dv/dv_17.html%3Fid%3DDTS10002407-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/dv/dv_17.html%3Fid%3DDTS10002407-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --><hr width=500 align=center></BODY></HTML>