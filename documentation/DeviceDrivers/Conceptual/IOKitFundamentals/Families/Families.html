<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>I/O Kit Fundamentals: I/O Kit Families</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="I/O Kit Families"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP0000017" title="I/O Kit Families"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../HardwareDrivers/index.html#//apple_ref/doc/uid/TP30000440-TP40003576" target="_top">Hardware &amp; Drivers</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP0000011-CH204-TPXREF101">I/O Kit Fundamentals</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../BaseClasses/BaseClasses.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../HandlingEvents/HandlingEvents.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP0000017-TPXREF101" title="I/O Kit Families"></a><h1>I/O Kit Families</h1><a name="//apple_ref/doc/uid/TP0000017-DontLinkElementID_427"></a><p>In the I/O Kit, families are collections of classes that define and implement the abstractions common to all devices of a particular type. They provide the programmatic interfaces and generic support code for developing drivers that are members (providers) or clients of such families. </p><p>This chapter describes a number of concepts related to I/O Kit families:</p><ul class="ul"><li class="li"><p>The relation of drivers to families</p></li><li class="li"><p>Families as libraries, including the versioning and loading of libraries</p></li><li class="li"><p>The programmatic structure of families and naming conventions</p></li></ul><p>In addition, this chapter offers some tips for those who want to write their own I/O Kit families. For a reference to the current set of the I/O Kit families provided by Apple, see the appendix <span class="content_text"><a href="../Families_Ref/Families_Ref.html#//apple_ref/doc/uid/TP0000021-BABCCBIJ">“I/O Kit Family Reference”</a></span></p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="Families.html#//apple_ref/doc/uid/TP0000017-TPXREF102">Drivers and Families</a>
				
			<br/>
			
        
			
			
				<a href="Families.html#//apple_ref/doc/uid/TP0000017-TPXREF103">Families As Libraries</a>
				
			<br/>
			
        
			
			
				<a href="Families.html#//apple_ref/doc/uid/TP0000017-TPXREF106">The Programmatic Structure of Families</a>
				
			<br/>
			
        
			
			
				<a href="Families.html#//apple_ref/doc/uid/TP0000017-TPXREF109">Creating An I/O Kit Family</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP0000017-TPXREF102" title="Drivers and Families"></a><h2>Drivers and Families</h2><a name="//apple_ref/doc/uid/TP0000017-DontLinkElementID_428"></a><a name="//apple_ref/doc/uid/TP0000017-DontLinkElementID_429"></a><p>An I/O Kit family is a library that implements some bus protocol (for example, PCI or USB) or some common set of services. But the support that a family provides is generic. A family does not include any of the details for getting at hardware because it cannot make assumptions about the specific hardware under the general layer it represents. It’s the driver writer’s responsibility to write code that bridges between the concrete and the abstract—that is, between the hardware and the abstraction defined by the family. A driver must extend a family to support specific hardware or to acquire specific features.</p><p>Take the SCSI Parallel family as an example. The SCSI Parallel family encapsulates the SCSI Parallel Interface-5 specification, which is well-defined. One of the things the specification describes is how to go about scanning the bus and detecting devices. Because this is an expensive operation, many SCSI Parallel controllers include firmware that can cache information about detected devices. To take advantage of this caching optimization, you could design your controller driver—member of the SCSI Parallel family—so that it overrides the scanning functionality to interact with the firmware.</p><p>Families commonly perform certain generic tasks, such as scanning buses, querying clients, queuing and validating commands, recovering from errors, and matching and loading drivers. Drivers do the tasks that impinge on hardware in some way. To continue with the example of the SCSI Parallel family, the primary job of the SCSI Parallel controller driver, as member of the SCSI Parallel family, is to receive SCSI commands from its family, execute each command on the hardware, and send a notification when the command completes.</p><p>Some I/O Kit families are clearly delimited by the specifications they encapsulate. Other families, such as the Audio family, are not as easily defined because there is no single specification prescribing what the family should include. In cases such as these, Apple carefully chose the set of abstractions to incorporate in the family to make it flexible and comprehensive enough. All families must advertise their capabilities and it is up to the higher levels of the driver stack to manage these capabilities.</p><p>A driver is both a provider and a client in its relationships to I/O Kit families. A driver that is a provider for a family (through its nub) is also a member of that family; it should inherit from a particular class in the family that describes the service it exports (however augmented). On the other hand, a driver is a client of the family whose service it imports (through a nub of the family). For example, a SCSI disk driver would inherit from the storage family rather than the SCSI Parallel family, to which it would be a client (see <span class="content_text"><a href="Families.html#//apple_ref/doc/uid/TP0000017-BAJEIBDI">Figure 6-1</a></span>). A USB mouse driver would inherit from the HID (Human Interface Devices) family and would be a client of the USB family. A PCI Audio card driver would inherit from the Audio family and would be a client of the PCI family.</p><br/><div><a name="//apple_ref/doc/uid/TP0000017-BAJEIBDI" title="Figure 6-1A driver&acirc;&#128;&#153;s relationships with I/O Kit families"></a><p><strong>Figure 6-1&nbsp;&nbsp;</strong>A driver’s relationships with I/O Kit families</p><img src = "../art/driverandfamily.gif" alt = "A driver’s relationships with I/O Kit families" width="457" height="323"></div><br/><a name="//apple_ref/doc/uid/TP0000017-TPXREF103" title="Families As Libraries "></a><h2>Families As Libraries </h2><a name="//apple_ref/doc/uid/TP0000017-DontLinkElementID_430"></a><a name="//apple_ref/doc/uid/TP0000017-DontLinkElementID_431"></a><a name="//apple_ref/doc/uid/TP0000017-DontLinkElementID_432"></a><p>Families are implemented as <a name="//apple_ref/doc/uid/TP0000017-DontLinkElementID_433"></a>libraries packaged as <a name="//apple_ref/doc/uid/TP0000017-DontLinkElementID_434"></a>kernel extensions (KEXTs). They specify their defining attributes in an information property list and are installed in <code>/System/Library/Extensions</code>. Families are, mechanically, little different than ordinary drivers.</p><p>Two related characteristics distinguish a family from a driver. First, a driver expresses a dependency on a family using the <code>OSBundleLibraries</code> property; second, a family is loaded only as a byproduct of a driver listing it as a library. A driver specifies the libraries on which it depends as elements of the <code>OSBundleLibraries</code> dictionary. The I/O Kit guarantees that these libraries will be loaded into the kernel before it loads the driver and links it with its families. Note that libraries themselves declare the libraries (kernel extensions and the kernel itself) on which they depend using the <code>OSBundleLibraries</code> property.</p><p>You specify a library as a key-value pair in the <code>OSBundleLibraries</code> dictionary where the key is the bundle identifier (<code>CFBundleIdentifier</code>) of the library and the value is the earliest version of the library that the driver is compatible with. All versions are expressed in the <code>'vers'</code> resource style. <span class="content_text"><a href="Families.html#//apple_ref/doc/uid/TP0000017-BAJFBBEI">Listing 6-1</a></span> gives an example from the information property list of the AppleUSBAudio driver.</p><a name="//apple_ref/doc/uid/TP0000017-BAJFBBEI" title="Listing 6-1The OSBundleLibraries property"></a><p class="codesample"><strong>Listing 6-1&nbsp;&nbsp;</strong>The OSBundleLibraries property</p><div class="codesample"><table><tr><td scope="row"><pre>&lt;key>OSBundleLibraries&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;dict><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;key>com.apple.iokit.IOAudioFamily&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;string>1.0.0&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;key>com.apple.iokit.IOUSBFamily&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;string>1.8&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;/dict><span></span></pre></td></tr></table></div><p>Although the I/O Kit loads the libraries before it loads the driver that specifies these dependencies, and loads libraries in proper dependency order, there is no guarantee about the order in which it loads libraries that have no interdependencies.</p><p>Generally, developers should declare dependencies for their device driver or any other kernel extension. (If the KEXT doesn’t have an executable, dependency declaration is unnecessary.) What dependencies they need to declare depends on which symbols need to get resolved. If you include a header file of a family or other library, or if a header indirectly ends up including a library, you should declare that dependency. If you unsure whether a dependency exists, declare it anyway.</p><a name="//apple_ref/doc/uid/TP0000017-TPXREF104" title="Library Versioning"></a><h3>Library Versioning</h3><a name="//apple_ref/doc/uid/TP0000017-DontLinkElementID_435"></a><p>To be available for loading and linking into the kernel, a family or other library has to declare its compatibility information using two properties: <code>CFBundleVersion</code> and <code>OSBundleCompatibleVersion</code>. The <code>CFBundleVersion</code> property defines the forward limit of compatibility—that is, the current version. The <code>OSBundleCompatibleVersion</code> property defines the backward limit of compatibility by identifying the last <code>CFBundleVersion</code>-defined version of the library that broke binary compatibility with prior versions. </p><p>Every time you revise a driver or a family, you should increment your <code>CFBundleVersion</code> value appropriately. You reset the <code>OSBundleCompatibleVersion</code> value (to the current <code>CFBundleVersion</code>) only when the revision makes the binary incompatible with prior versions, as when you remove a function or other symbol, or change a class such that the vtable layout changes. If you are writing an I/O Kit family, make sure that you specify an <code>OSBundleCompatibleVersion</code> property for your library; otherwise, drivers and other kernel extensions cannot declare a dependency on it and thus cannot link against it.</p><p>For both drivers and families (and, indeed, all kernel extensions), make sure that you also set the version in the <a name="//apple_ref/doc/uid/TP0000017-DontLinkElementID_436"></a>kernel module and that this value is equivalent to the <code>CFBundleVersion</code> in the information property list. You set the version in the executable through the <code>MODULE_VERSION</code> setting in Xcode, in the target’s Customized Settings list (you find this in the target’s Build view). </p><a name="//apple_ref/doc/uid/TP0000017-TPXREF105" title="Library Loading"></a><h3>Library Loading</h3><p>The <a name="//apple_ref/doc/uid/TP0000017-DontLinkElementID_437"></a>KEXT manager functions as the kernel loader and linker. At boot time or whenever the system detects a newly attached device, the I/O Kit kicks off the matching process to find a suitable driver for a device. When such a driver is found, it is the KEXT manager’s job to load the driver into the kernel and link it with the libraries on which it depends.</p><p>But before it can do this, the KEXT manager must ensure that those libraries, and all the other libraries on which those libraries depend, are loaded first. To do this, the manager builds a dependency tree of all libraries and other kernel modules required for the driver. It builds this tree using the contents of the <code>OSBundleLibraries</code> property, first of the driver and then of each required library. </p><p>After it builds the dependency tree, the KEXT manager checks if the libraries that are the most remote from the driver in the tree are already loaded. If any of these libraries is not loaded, the manager loads it and calls its start routine (the routine varies according to type of KEXT). It then proceeds up the dependency tree in similar fashion—linking, loading, and starting—until all required libraries have been linked and loaded. See <span class="content_text"><a href="Families.html#//apple_ref/doc/uid/TP0000017-BAJBJEHE">Figure 6-2</a></span> for an illustration of this procedure.</p><br/><div><a name="//apple_ref/doc/uid/TP0000017-BAJBJEHE" title="Figure 6-2OSBundleLibraries and the dependency tree"></a><p><strong>Figure 6-2&nbsp;&nbsp;</strong>OSBundleLibraries and the dependency tree</p><img src = "../art/librarydependency.gif" alt = "OSBundleLibraries and the dependency tree" width="406" height="299"></div><br/><p>If the KEXT manager encounters a problem initializing a library, or it doesn’t find a library with a compatible version (based on the value of <code>OSBundleCompatibleVersion</code>), it stops and (usually) returns a failure code. The modules already loaded stay loaded for awhile. Generally, unloading of modules does not happen immediately when they are not used. The I/O Kit includes a feature that tracks idle time and unloads modules after a certain period of idleness<a name="//apple_ref/doc/uid/TP0000017-DontLinkElementID_438"></a>.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP0000017-DontLinkElementID_14" title="Important:"></a><p><strong>Important:</strong>&nbsp;The only way to load a kernel extension explicitly is to use the <code>kextload</code> command-line utility.<a name="//apple_ref/doc/uid/TP0000017-DontLinkElementID_439"></a></p><p></p></div><a name="//apple_ref/doc/uid/TP0000017-TPXREF106" title="The Programmatic Structure of Families"></a><h2>The Programmatic Structure of Families</h2><a name="//apple_ref/doc/uid/TP0000017-DontLinkElementID_440"></a><p>Although I/O Kit families tend to be quite different from each other, they have some structural elements in common. First, IOService is the common superclass for all I/O Kit families; at least one important class in each family, and possibly more, inherits from IOService (see <span class="content_text"><a href="../BaseClasses/BaseClasses.html#//apple_ref/doc/uid/TP0000016-BAJEEGAF">“The I/O Kit Base Classes”</a></span> for more information). And each family has one or more classes that present an interface to drivers.</p><a name="//apple_ref/doc/uid/TP0000017-TPXREF107" title="Typical Classes"></a><h3>Typical Classes</h3><a name="//apple_ref/doc/uid/TP0000017-DontLinkElementID_441"></a><p>A family typically defines two classes for drivers:</p><ul class="spaceabove"><li class="li"><p>A class describing the nub interface for drivers that are clients of the family</p></li><li class="li"><p>A superclass for drivers that are members of the family, and thus providers to its nubs</p></li></ul><p>In other words, I/O Kit families usually define an upward interface and a downward interface. These interfaces are required for the layering of driver objects involved in an I/O connection. The upward interface—the nub interface—presents to the rest of the system the hardware abstractions and rule definitions encapsulated by the family. The downward interface provides the subclassing interface for member drivers. Together, the interfaces define the up calls into the family and the down calls that member drivers are expected to make.</p><p>In addition to these two classes, families typically define a number of utility classes and support classes. The appendix <span class="content_text"><a href="../Families_Ref/Families_Ref.html#//apple_ref/doc/uid/TP0000021-BABCCBIJ">“I/O Kit Family Reference”</a></span> describes some of these classes.</p><p>Some families specify subclasses for particular varieties of client or member drivers. The Storage family, for example, defines a generic block storage class for nub objects (IOBlockStorageDevice) and then also provides specific subclasses for certain varieties: IOCDBlockStorageDevice and IODVDBlockStorageDevice. In addition, families can include classes for device interfaces (as subclasses of IOUserClient) as well as commands specific to the family (as subclasses of IOCommand). Families can also have various helper classes and header files for family-specific type definitions.</p><p>Some families do not include a public nub or provider class for drivers when there is little need for such drivers. And Apple has not provided families for all types of hardware. If you find that the I/O Kit does not have a family or interface for your needs, you can always create a driver that inherits directly from IOService. Such “family-less” drivers are sometimes necessary if the potential applications for the driver are few. They must incorporate the abstractions and range of functionality found in families as well as the hardware-specific code typical of drivers. Besides directly inheriting from IOService, family-less drivers frequently make use of the I/O Kit helper classes such as IOWorkLoop, the event-source classes, IOMemoryCursor, and IOMemoryDescriptor.</p><a name="//apple_ref/doc/uid/TP0000017-TPXREF108" title="Naming and Coding Conventions "></a><h3>Naming and Coding Conventions </h3><a name="//apple_ref/doc/uid/TP0000017-DontLinkElementID_442"></a><p>Generally, Apple’s position on class naming within families is that the name should indicate what the class represents. Often, this name is dictated by the specification for the hardware. For example, the PCI family defines the IOPCIBridge class for drivers that are providers for the family. The reason for this name is simple: the PCI bridge (as the specification makes clear) is what the PCI controller drivers control. When there is no clear naming precedent for a family’s classes, the I/O Kit follows a <a name="//apple_ref/doc/uid/TP0000017-DontLinkElementID_443"></a>naming convention of IO<em>FamilyName</em>Device for nub (client) classes and IO<em>FamilyName</em>Controller for provider classes. </p><div class="importantbox"><a name="//apple_ref/doc/uid/TP0000017-DontLinkElementID_15" title="Important:"></a><p><strong>Important:</strong>&nbsp;The general guideline of naming classes for what they represent applies equally to drivers. Drivers should be named for the device they control (but should not have the redundant suffix “Driver”).</p><p></p></div><p>If you are writing your own I/O Kit family, Apple recommends that you follow the same naming guidelines for your classes. And there are a few other general naming conventions to be aware of. Each class, function, type, and so on should have prefix that designates the vendor writing the software. Be sure not to use any of the prefixes that Apple reserves for itself (<span class="content_text"><a href="Families.html#//apple_ref/doc/uid/TP0000017-BAJCGEAF">Table 6-1</a></span>).</p><a name="//apple_ref/doc/uid/TP0000017-BAJCGEAF" title="Table 6-1API prefixes reserved by Apple"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 6-1&nbsp;&nbsp;</strong>API prefixes reserved by Apple</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Prefix</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Meaning</p></th></tr><tr><td  scope="row"><p>OS, os</p></td><td ><p>libkern or other kernel service</p></td></tr><tr><td  scope="row"><p>IO, io</p></td><td ><p>I/O Kit or I/O Kit family</p></td></tr><tr><td  scope="row"><p>MK, mk, mach_</p></td><td ><p>Mach kernel</p></td></tr><tr><td  scope="row"><p>Apple, APPLE, apple, AAPL, aapl, com_apple_</p></td><td ><p>Apple hardware support (for example, Apple-provided drivers)</p></td></tr></table></div><p>In addition, private, internal symbols should have an underscore “_” prefix, following the convention used by Apple. Do not access these private APIs from a KEXT. As with drivers, use of reverse DNS notation (substituting underscores for periods) is highly recommended to avoid naming conflicts.<a name="//apple_ref/doc/uid/TP0000017-DontLinkElementID_444"></a></p><a name="//apple_ref/doc/uid/TP0000017-TPXREF109" title="Creating An I/O Kit Family"></a><h2>Creating An I/O Kit Family</h2><a name="//apple_ref/doc/uid/TP0000017-DontLinkElementID_445"></a><p>There might be occasions when you deem it worthwhile to write your own I/O Kit family. Usually this happens when there is a standard or protocol for which no family exists, and you discern a need for interoperability among drivers for devices based on this protocol or standard. An example might be the IEEE488 standard for plotters and lab equipment.</p><p>If you decide to implement a family, here are a few guidelines to help you:</p><ul class="ul"><li class="li"><p>At the beginning, write the family and driver code together; don’t worry yet about the division of functionality and interface between driver and family. Just concentrate on coming up with a good object-oriented design, determining what objects are necessary and what relationships they should have.</p></li><li class="li"><p>After you have a working driver and have solved the stack for a particular device, separate the family code from the hardware-specific code. One approach that might be useful for locating family-generic code, especially for complex families, is to write two or more drivers for different hardware and then abstract away the common code.</p></li><li class="li"><p>Define what the family’s nub objects look like to drivers—that is, the APIs your clients will see. To do this, look at the specification and encapsulate the important features (it’s not necessary to include rarely or never-used features). Keep in mind that the nubs of most families do very little. Most often they encapsulate addressing and arbitration details.</p></li><li class="li"><p>Define the superclass for drivers that will be members of your family. </p></li><li class="li"><p>Keep the layering separation of a family airtight. A family should not include headers from any other family or driver and should not define the superclass of clients. </p></li></ul><p>There can also be situations that might call for the creation of a “superfamily”: a family that extends an existing family in a way similar to a subclass, but with a big difference; its aim is generality rather than specificity. Third-party vendors might want to have a superfamily to contain the code common to drivers based on different bus protocols. This would eliminate the need to load code that isn’t needed. For example, a mouse vendor might have a driver capable of driving both USB and ADB mice. If a system requires a USB mouse, you don’t want to have the ADB-specific code loaded as well. Thus the vendor might write a superfamily that acts as a service library; it would separate out the layers of code specific to a bus protocol into subfamilies and put the remaining code into the superfamily. Only the code specific to the currently used bus would be loaded.<a name="//apple_ref/doc/uid/TP0000017-DontLinkElementID_446"></a></p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../BaseClasses/BaseClasses.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../HandlingEvents/HandlingEvents.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2001, 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-05-17<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeviceDrivers/Conceptual/IOKitFundamentals/Families/Families.html%3Fid%3DTP0000011-4.8&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeviceDrivers/Conceptual/IOKitFundamentals/Families/Families.html%3Fid%3DTP0000011-4.8&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeviceDrivers/Conceptual/IOKitFundamentals/Families/Families.html%3Fid%3DTP0000011-4.8&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>