<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Using Graphics Devices (IM: Im)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING272></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!--end of header -->

<center>
<A HREF="QuickDraw-271.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="QuickDraw-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="QuickDraw-476.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="QuickDraw-273.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="QuickDraw-2.html"><B>Imaging With QuickDraw</B></A> / <BR><DD><A HREF="QuickDraw-270.html"><B>Chapter 5 - Graphics Devices</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING272-0></A>
<H1>Using Graphics Devices</H1>
 To use graphics devices, your application generally uses the QuickDraw routines described elsewhere in this book to draw images into a window; Color QuickDraw automatically displays your images in a manner appropriate for each graphics device that contains a portion of that window. <P>
<DL>
<DT><B>Note</B>
<DD>The pixel map for a window's color graphics port always consists of the pixel depth, color table, and boundary rectangle of the main screen, even if the window is created on or moved to an entirely different screen.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 Instead of drawing directly into an onscreen graphics port, your application can use an offscreen graphics world (described in the chapter "Offscreen Graphics Worlds") to create images with the ideal pixel depth and color table required by your application. Then your application can use the <CODE>CopyBits</CODE> procedure to copy the images to the screen. Color QuickDraw converts the colors of the images for appropriate display on grayscale graphics devices and on direct and indirect color graphics devices. The manner in which Color QuickDraw translates the colors specified by your application to different graphics devices is described in the chapter "Color QuickDraw." However, if Color QuickDraw were to translate the colors of a color wheel (such as that used by the Color Picker, described in <I><A HREF="../ACI/ACI-2.html">Advanced Color Imaging on the Mac OS</A></I>), the image would appear as solid black on a black-and-white screen.<P>
 Many applications can let Color QuickDraw manage multiple video devices of differing dimensions and pixel depths. If your application needs more control over video device management--if it needs certain pixel depths or sets of colors to function effectively, for example--you can take several steps.<P>
<UL>
<LI>If you need to know about the characteristics of available video devices, your application can use the <CODE>GetDeviceList</CODE> function to obtain a handle to the first <CODE>GDevice</CODE> record in the device list, the <CODE>GetGDevice</CODE> function to obtain a handle to the <CODE>GDevice</CODE> record for the current device, the <CODE>GetMainDevice</CODE> function to obtain a handle to the <CODE>GDevice</CODE> record for the main screen, or the <CODE>GetMaxDevice</CODE> function to obtain a handle to the <CODE>GDevice</CODE> record for the graphics device with the greatest pixel depth. Your application can then pass this handle to a routine like the <CODE>TestDeviceAttribute</CODE> function or the <CODE>HasDepth</CODE> function to determine various characteristics of a video device, or your application can examine the <CODE>gdRect</CODE> field of the <CODE>GDevice</CODE> record to determine the dimensions of the screen it represents.
<LI>If you want to optimize your application's drawing for the best possible display on whatever type of screen is the current device, your application can use the <CODE>DeviceLoop</CODE> procedure, described on <A HREF=QuickDraw-291.html#MARKER-9-138>page 5-28</A>, to determine the capabilities of the current device before drawing into a window on that device. 
<LI>If the current device is not suitable for the proper display of an image--for example, if the user has moved the window for your multicolored display of national flags to a black-and-white screen--your application can display the best image possible and display a message explaining that a more capable screen is required for better presentation of the image. Your application can use the <CODE>DeviceLoop</CODE> procedure to determine the capabilities of the current device.
<LI>If your application uses the <CODE>HasDepth</CODE> function to determine that the current device can support the pixel depth required for the proper display of your image, but the <CODE>DeviceLoop</CODE> procedure indicates that the user has changed the screen's display, your application can use the <CODE>SetDepth</CODE> function to change the pixel depth of the screen. Note that the <CODE>SetDepth</CODE> function is provided for applications that are able to run <BR>only on graphics devices of a particular depth. Your application should use it only after soliciting the user's permission with a dialog box.
<LI>If your application needs more control over colors on different indexed devices, your application can use the Palette Manager to arrange different sets of colors for particular images. Because the CLUT is variable on most video devices, your application can display up to 16 million colors, although on an 8-bit indexed device, for example, only 256 different colors can appear at once. See the chapter "Palette Manager" in <I><A HREF="../ACI/ACI-2.html">Advanced Color Imaging on the Mac OS</A></I> for more information.
<LI>If your application needs to work with offscreen images that have characteristics different from those on the available graphics devices, your application can create offscreen graphics worlds, which contain their own <CODE>GDevice</CODE> records. See the chapter "Offscreen Graphics Worlds" in this book for more information.<P>
</UL>
 <A NAME=MARKER-2-20></A>To use the routines described in this chapter, your application must check for the existence of Color QuickDraw by using the <CODE>Gestalt</CODE> function with the <CODE>gestaltQuickDrawVersion</CODE> selector. The <CODE>Gestalt</CODE> function returns a 4-byte value in its <CODE>response</CODE> parameter; the low-order word contains QuickDraw version data. In that low-order word, the high-order byte gives the major revision number and the low-order byte gives the minor revision number. If the value returned in the <CODE>response</CODE> parameter is greater than or equal to the value of the constant <CODE>gestalt32BitQD</CODE>, then the system supports Color QuickDraw and all of the routines described in this chapter.<P>
<A NAME=HEADING272-12></A>
<H2>Optimizing Your Images for Different Graphics Devices</H2>
 <A NAME=MARKER-2-249></A><A NAME=MARKER-9-210></A><A NAME=MARKER-9-125></A><A NAME=MARKER-9-167></A>The <CODE>DeviceLoop</CODE> procedure searches for graphics devices that intersect your window's drawing region, and it informs your application of each different graphics device it finds. The <CODE>DeviceLoop</CODE> procedure provides your application with information about the current device's pixel depth and other attributes. Your application can then choose what drawing technique to use for the current device. For example, your application might use inversion to achieve a highlighting effect on a 1-bit graphics device, and, by using the <CODE>HiliteColor</CODE> procedure described in the chapter "Color QuickDraw," it might specify a color like magenta as the highlight color on a color graphics device. <P>
 For example, you can call <CODE>DeviceLoop</CODE> after calling the Event Manager procedure <CODE>BeginUpdate</CODE> whenever your application needs to draw into a window, as shown in <A HREF=#MARKER-9-25>Listing 5-1</A>.<P>
<B>Listing 5-1  <A NAME=MARKER-9-25></A>Using the <CODE>DeviceLoop</CODE> procedure</B><P>
<PRE>
PROCEDURE DoUpdate (window: WindowPtr);
VAR
   windowType := Integer;
   myWindow: LongInt;
BEGIN
   windowType := MyGetWindowType(window);
   CASE windowType OF
   kSimpleRectanglesWindow: {simple case: window with 2 color rectangles}
      BEGIN
         BeginUpdate(window);
         myWindow := LongInt(window); {coerce window ptr for MyDrawingProc}
         DeviceLoop(window^.visRgn, @MyTrivialDrawingProc,
                    myWindow, []);
         EndUpdate;
      END;
   {handle other window types--documents, dialog boxes, etc.--here}
END;
</PRE>
 When you use the <CODE>DeviceLoop</CODE> procedure, you must supply a handle to a drawing region and a pointer to your own application-defined drawing procedure. In <A HREF=#MARKER-9-25>Listing 5-1</A>, a handle to the window's visible region and a pointer to an application-defined drawing procedure called <CODE>MyTrivialDrawingProc</CODE> are passed to <CODE>DeviceLoop</CODE>. For each graphics device it finds as the application updates its window, <CODE>DeviceLoop</CODE> calls <CODE>MyTrivialDrawingProc</CODE>.<P>
 Because <CODE>DeviceLoop</CODE> provides your drawing procedure with the pixel depth of the current device (along with other attributes passed to your drawing procedure in the <CODE>deviceFlags</CODE> parameter), your drawing procedure can optimize its drawing for whatever type of video device is the current device, as illustrated in <A HREF=#MARKER-9-26>Listing 5-2</A>.<P>
<B>Listing 5-2  <A NAME=MARKER-9-26></A>Drawing into different screens</B><P>
<PRE>
PROCEDURE MyTrivialDrawingProc (depth: Integer; 
                               deviceFlags: Integer; 
                               targetDevice: GDHandle; 
                               userData: LongInt);
VAR
   window: WindowPtr;
BEGIN
   window:= WindowPtr(userData);
   EraseRect(window^.portRect);
   CASE depth OF
   1:                            {black-and-white screen}
      MyDraw1BitRects(window);   {draw with ltGray, dkGray pats}
   2:
      MyDraw2BitRects(window); {draw with 2 of 4 available colors}
   {handle other screen depths here}
END;
</PRE>
<A NAME=HEADING272-21></A>
<H2>Zooming Windows on Multiscreen Systems</H2>
 <A NAME=MARKER-9-167></A>The zoom box in the upper-right corner of the standard document window allows the user to alternate quickly between two window positions and sizes: the <DFN>user state</DFN> and the <DFN>standard state.</DFN><P>
 The <B>user state</B> is the window size and location established by the user. If your application does not supply an initial user state, the user state is simply the size and location of the window when it was created, until the user resizes it.<A NAME=MARKER-9-168></A><P>
 The <B>standard state</B> is the window size and location that your application considers most convenient, considering the function of the document and the screen space available. In a word-processing application, for example, a standard-state window might show a <BR>full page, if possible, or a page of full width and as much length as fits on the screen. <BR>If the user changes the page size with the Page Setup command, the application might adjust the standard state to reflect the new page size. If your application does not define a standard state, the Window Manager automatically sets the standard state to the entire gray region on the main screen, minus a three-pixel border on all sides. (See <I>Macintosh Human Interface Guidelines</I> for a detailed description of how your application determines where to open and zoom windows.) The user cannot change a window's standard state<A NAME=MARKER-2-11></A>. (The user and standard states are stored in a data structure of type <CODE>WStateData</CODE> whose handle appears in the <CODE>dataHandle</CODE> field of the window record.)<P>
 <A HREF=#MARKER-9-32>Listing 5-3</A> illustrates an application-defined procedure, <CODE>DoZoomWindow</CODE>, which an application might call when<DFN> the user clicks the zoom box.</DFN> Because the user might have moved the window to a different screen since it was last zoomed, the procedure first determines which screen contains the largest area of the window and then calculates the ideal window size for that screen before zooming the window.<A NAME=MARKER-9-172></A> <P>
 The screen calculations in the <CODE>DoZoomWindow</CODE> procedure compare <CODE>GDevice</CODE> records stored in the device list. (If Color QuickDraw is not available, <CODE>DoZoomWindow</CODE> assumes that it's running on a computer with a single screen.)<A NAME=MARKER-9-173></A><P>
<B>Listing 5-3  <A NAME=MARKER-9-32></A>Zooming a window</B><P>
<PRE>
PROCEDURE DoZoomWindow (thisWindow: windowPtr; zoomInOrOut: Integer);
VAR
   gdNthDevice, gdZoomOnThisDevice: GDHandle;
   savePort:                        GrafPtr;
   windRect, zoomRect, theSect:     Rect;
   sectArea, greatestArea:          LongInt;
   wTitleHeight:                    Integer;
   sectFlag:                        Boolean;
BEGIN
   GetPort(savePort);
   SetPort(thisWindow);
   EraseRect(thisWindow^.portRect);    {erase to avoid flicker}
   IF zoomInOrOut = inZoomOut THEN     {zooming to standard state}
   BEGIN
      IF NOT gColorQDAvailable THEN    {assume a single screen and }
      BEGIN                            { set standard state to full screen}
         zoomRect := screenBits.bounds;
         InsetRect(zoomRect, 4, 4);
         WStateDataHandle(WindowPeek(thisWindow)^.dataHandle)^^.stdState
                                                               := zoomRect;
      END
      ELSE                    {locate window on available screens}
      BEGIN
         windRect := thisWindow^.portRect;
         LocalToGlobal(windRect.topLeft);    {convert to global coordinates}
         LocalToGlobal(windRect.botRight);
         {calculate height of window's title bar}
         wTitleHeight := windRect.top - 1 -
                      WindowPeek(thisWindow)^.strucRgn^^.rgnBBox.top;
         windRect.top := windRect.top - wTitleHeight;
         gdNthDevice := GetDeviceList;    {get the first screen}
         greatestArea := 0;         {initialize area to 0}
         {check window against all gdRects in gDevice list and remember }
         { which gdRect contains largest area of window}
         WHILE gdNthDevice &lt;&gt; NIL DO
         IF TestDeviceAttribute(gdNthDevice, screenDevice) THEN
            IF TestDeviceAttribute(gdNthDevice, screenActive) THEN
            BEGIN
               {The SectRect function calculates the intersection }
               { of the window rectangle and this GDevice's boundary }
               { rectangle and returns TRUE if the rectangles intersect, }
               { FALSE if they don't.}
               sectFlag := SectRect(windRect, gdNthDevice^^.gdRect,
                                     theSect);
               {determine which screen holds greatest window area}
               {first, calculate area of rectangle on current screen}
               WITH theSect DO   
                  sectArea := LongInt(right - left) * (bottom - top);
               IF sectArea &gt; greatestArea THEN
               BEGIN
                  greatestArea := sectArea;  {set greatest area so far}
                  gdZoomOnThisDevice := gdNthDevice;  {set zoom device}
               END;
               gdNthDevice := GetNextDevice(gdNthDevice);   {get next }
            END;  {of WHILE}                                { GDevice record}
         {if gdZoomOnThisDevice is on main device, allow for menu bar height}
         IF gdZoomOnThisDevice = GetMainDevice THEN
            wTitleHeight := wTitleHeight + GetMBarHeight;
         WITH gdZoomOnThisDevice^^.gdRect DO    {create the zoom rectangle}
         BEGIN
            {set the zoom rectangle to the full screen, minus window title }
            { height (and menu bar height if necessary), inset by 3 pixels}
            SetRect(zoomRect, left + 3, top + wTitleHeight + 3,
                   right - 3, bottom - 3);
            {If your application has a different &quot;most useful&quot; standard }
            { state, then size the zoom window accordingly.}
            
{set up the WStateData record for this window}
            WStateDataHandle(WindowPeek(thisWindow)^.dataHandle)^^.stdState
                                                                := zoomRect;
         END;
      END;
   END; {of inZoomOut}
   {if zoomInOrOut = inZoomIn, just let ZoomWindow zoom to user state}
   {zoom the window frame}
   ZoomWindow(thisWindow, zoomInOrOut, (thisWindow = FrontWindow));
   MyResizeWindow(thisWindow);   {application-defined window-sizing routine}
   SetPort(savePort);
END; (of DoZoomWindow)
</PRE>
 If the user is zooming the window to the standard state, <CODE>DoZoomWindow</CODE> calculates a new standard size and location based on the application's own considerations, the current location of the window, and the available screens. The <CODE>DoZoomWindow</CODE> procedure always places the standard state on the screen where the window is currently displayed or, if the window spans screens, on the screen containing the largest area <BR>of the window.<P>
 <A HREF=#MARKER-9-32>Listing 5-3</A> uses the QuickDraw routines <CODE>GetDeviceList</CODE>, <CODE>TestDeviceAttribute</CODE>, <CODE>GetNextDevice</CODE>, <CODE>SectRect</CODE>, and <CODE>GetMainDevice</CODE> to examine characteristics of the available screens as stored in <CODE>GDevice</CODE> records. Most of the code in <A HREF=#MARKER-9-32>Listing 5-3</A> is devoted to determining which screen should display the window in the standard state.<A NAME=MARKER-2-33></A> <P>
<DL>
<DT><B>IMPORTANT</B>
<DD>Never use the <CODE>bounds</CODE> field of a <CODE>PixMap</CODE> record to determine the size of the screen; instead use the value of the <CODE>gdRect</CODE> field of the <CODE>GDevice</CODE> record for the screen, as shown in <A HREF=#MARKER-9-32>Listing 5-3</A>.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 After calculating the standard state, if necessary, <CODE>DoZoomWindow</CODE> calls the <CODE>ZoomWindow</CODE> procedure to redraw the window frame in the new size and location and then calls the application-defined procedure <CODE>MyResizeWindow</CODE> to redraw the window's content region. For more information on zooming and resizing windows, see the chapter "Window Manager" in <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I>.<P>
<A NAME=HEADING272-34></A>
<H2>Setting a Device's Pixel Depth</H2>
 The Monitors control panel is the user interface for changing the pixel depth, color capabilities, and positions of video devices. Since the user can control the capabilities of the video device, your application should be flexible: although it may have a preferred pixel depth, your application should do its best to accommodate less than ideal conditions. <P>
 Your application can use the <CODE>SetDepth</CODE> function to change the pixel depth of a video device, but your application should do so only with the consent of the user. If your application must have a specific pixel depth, it can display a dialog box that offers the user a choice between changing to that depth or canceling display of the image. This dialog box saves the user the trouble of going to the Monitors control panel before returning to your application. (See the chapter "Dialog Manager" in <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I> for more information about creating and using dialog boxes.)<P>
 Before calling <CODE>SetDepth</CODE>, use the <CODE>HasDepth</CODE> function to determine whether the available hardware can support the pixel depth you require. The <CODE>SetDepth</CODE> function is described on <A HREF=QuickDraw-296.html#MARKER-9-167>page 5-33</A>, and the <CODE>HasDepth</CODE> function is described on <A HREF=QuickDraw-295.html#MARKER-9-154>page 5-32</A>.<A NAME=MARKER-9-229></A><A NAME=MARKER-9-189></A><P>
<A NAME=HEADING272-38></A>
<H2>Exceptional Cases When Working With Color Devices</H2>
 If your application always specifies colors in <CODE>RGBColor</CODE> records, Color QuickDraw automatically handles the colors on both indexed and direct devices. However, if your application does not specify colors in <CODE>RGBColor</CODE> records, your application may need to create and use special-purpose <CODE>CGrafPort</CODE>, <CODE>PixMap</CODE>, and <CODE>GDevice</CODE> records with the routines described in the chapter "Offscreen Graphics Worlds."<P>
 If your application must work with <CODE>CGrafPort</CODE>, <CODE>PixMap</CODE>, and <CODE>GDevice</CODE> records in ways beyond the scope of the routines described elsewhere in this book, the following guidelines may aid you in adapting Color QuickDraw to color graphics devices.<P>
<UL>
<LI>Don't draw directly to the screen. Create your own offscreen graphics world (as described in the chapter "Offscreen Graphics Worlds") and use the <CODE>CopyBits</CODE>, <CODE>CopyMask</CODE>, or <CODE>CopyDeepMask</CODE> routine (described in the chapter "Color QuickDraw") to transfer the image to the screen.
<LI>Don't directly change the <CODE>fgColor</CODE> or <CODE>bkColor</CODE> fields of a <CODE>GrafPort</CODE> record and expect them to be used as the pixel values. Color QuickDraw recalculates these values for each graphics device. If you want to draw with a color with a particular <I>index value,</I> use a palette with explicit colors, as described in <I><A HREF="../ACI/ACI-2.html">Advanced Color Imaging on the Mac OS</A></I>. For device-independent colors, use the <CODE>RGBForeColor</CODE> and <CODE>RGBBackColor</CODE> procedures, described in the chapter "Color QuickDraw" in this book.
<LI>Don't copy a <CODE>GDevice</CODE> record's <CODE>PixMap</CODE> record. Instead, use the <CODE>NewPixMap</CODE> function or the <CODE>CopyPixMap</CODE> procedure, and fill all the fields. (These routines are described in the chapter "Color QuickDraw.") The <CODE>NewPixMap</CODE> function returns a <CODE>PixMap</CODE> record that is cloned from the <CODE>PixMap</CODE> record pointed to by the global variable <CODE>TheGDevice</CODE>. If you don't want a copy of the main screen's <CODE>PixMap</CODE> record--for example, you want one that is a different pixel depth--then you must fill out more fields than just <CODE>pixelSize</CODE>: you must fill out the <CODE>pixelType</CODE>, <CODE>cmpCount</CODE>, and <CODE>cmpSize</CODE> fields. Set the <CODE>pmVersion</CODE> field to 0 when initializing your own <CODE>PixMap</CODE> record. For future compatibility you should also set the <CODE>packType</CODE>, <CODE>packSize</CODE>, <CODE>planeBytes</CODE>, and <CODE>pmReserved</CODE> fields to 0. Don't assume a <CODE>PixMap</CODE> record has a color table--a pixel map for a direct device doesn't need one. For compatibility, a <CODE>PixMap</CODE> record for a direct device should have a dummy handle in the <CODE>pmTable</CODE> field that points to a <CODE>ColorTable</CODE> record with a seed value equal to <CODE>cmpSize</CODE> <CODE></CODE> <CODE>cmpCount</CODE> and a <CODE>ctSize</CODE> field set to 0.
<LI>Fill out all the fields of a new <CODE>GDevice</CODE> record. When creating an offscreen <CODE>GDevice</CODE> record by calling <CODE>NewGDevice</CODE> with the <CODE>mode</CODE> parameter set to -1, you must fill out the fields of the <CODE>GDevice</CODE> record (for instance, the <CODE>gdType</CODE> field) yourself. If you want a copy of an existing <CODE>GDevice</CODE> record, copy the <CODE>gdType</CODE> field from it. If you explicitly want an indexed device, assign the <CODE>clutType</CODE> constant to the <CODE>gdType</CODE> field. <P>
</UL>

</BLOCKQUOTE>
<HR>
<center>
<A HREF="QuickDraw-271.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="QuickDraw-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="QuickDraw-476.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="QuickDraw-273.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="QuickDraw-3.html">&copy; Apple Computer, Inc.</A><br>7 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
