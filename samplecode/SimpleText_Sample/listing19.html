<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>SimpleText Sample - /SimpleText.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">SimpleText Sample</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/index.html" target="_blank">Reference Library</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">SimpleText Sample</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/SimpleText.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/AboutBox.c</option>
<option value="listing2.html">/AboutBox.h</option>
<option value="listing3.html">/AboutBox.r</option>
<option value="listing4.html">/AGFile.h</option>
<option value="listing5.html">/Clipboard.c</option>
<option value="listing6.html">/Clipboard.h</option>
<option value="listing7.html">/Clipboard.r</option>
<option value="listing8.html">/GXFile.c</option>
<option value="listing9.html">/GXFile.h</option>
<option value="listing10.html">/GXFile.r</option>
<option value="listing11.html">/Localize.r</option>
<option value="listing12.html">/MacIncludes.h</option>
<option value="listing13.html">/MovieFile.c</option>
<option value="listing14.html">/MovieFile.h</option>
<option value="listing15.html">/MovieFile.r</option>
<option value="listing16.html">/PICTFile.c</option>
<option value="listing17.html">/PICTFile.h</option>
<option value="listing18.html">/PICTFile.r</option>
<option value="listing19.html">/SimpleText.c</option>
<option value="listing20.html">/SimpleText.h</option>
<option value="listing21.html">/SimpleText.r</option>
<option value="listing22.html">/TextDrag.c</option>
<option value="listing23.html">/TextFile.a</option>
<option value="listing24.html">/TextFile.c</option>
<option value="listing25.html">/TextFile.h</option>
<option value="listing26.html">/TextFile.r</option>
<option value="listing27.html">/ThreeDMetafile.c</option>
<option value="listing28.html">/ThreeDMetafile.h</option>
<option value="listing29.html">/ThreeDMetafile.r</option></select>
				</p>
				</form>
				<p><strong><a href="SimpleText_Sample.zip">Download Sample</a></strong> (&#147;SimpleText_Sample.zip&#148;, 602.8K)<BR>
<strong><a href="SimpleText_Sample.dmg">Download Sample</a></strong> (&#147;SimpleText_Sample.dmg&#148;, 959.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    SimpleText.c  Contains:  SimpleText - a simple document editing application for shipping               with system software.  Version:  SimpleText 1.4 or later** Copyright 1993-1996 Apple Computer. All rights reserved.****  You may incorporate this sample code into your applications without**  restriction, though the sample code has been provided &quot;AS IS&quot; and the**  responsibility for its operation is 100% yours.  However, what you are**  not permitted to do is to redistribute the source as &quot;DSC Sample Code&quot;**  after having made changes. If you're going to re-distribute the source,**  we require that you make it clear in the source that the code was**  descended from Apple Sample Code, but that you've made changes.*/#include &quot;MacIncludes.h&quot;#include &lt;ImageCompression.h&gt;  // for CustomGetFilePreview#include &lt;Threads.h&gt;#define CompilingMain=1#include &quot;SimpleText.h&quot;#include &quot;Clipboard.h&quot;// --------------------------------------------------------------------------------------------------------------// INTERNAL TYPES AND TYPEDEFS// --------------------------------------------------------------------------------------------------------------// refCon value between SimpleCatchShape and GXInstallQDTranslator  typedef struct  {  gxShape     thePage;  gxRectangle    thePageRectangle;  Boolean      doLayout;  gxJob      theJob;  } CatchRefCon;// --------------------------------------------------------------------------------------------------------------// FORWARD DECLARES// --------------------------------------------------------------------------------------------------------------OSErr   DoActivate(WindowRef pWindow, Boolean activating);OSErr  DoCommand(WindowRef pWindow, short commandID, long menuResult);OSErr  DoKeyEvent(WindowRef pWindow, EventRecord * pEvent, Boolean processPageControls);Boolean CommandToIDs(short commandID, short * menuID, short *itemID);void   AdjustMenus(WindowRef pWindow, Boolean editDialogs, Boolean forceTitlesOn);// --------------------------------------------------------------------------------------------------------------// GLOBAL VARIABLES// --------------------------------------------------------------------------------------------------------------EventRecord      gEvent;          // currently pending eventBoolean        gAllDone;        // true if the application is the in process of terminatingMachineInfoRec    gMachineInfo;      // info about abilities and options installed on this machineshort        gApplicationResFile;  // resource fork of applicationRgnHandle      gCursorRgn;        // region to control the cursor apearenceAGRefNum      gAGRefNum = -1;      // AppleGuide database which is openFSSpec        gAGSpec;        // where to find our databaseAGCoachRefNum    gAGCoachRefNum = -1;  // coach handler refNumFontMappingHandle  gFontMappingList = nil;  // list of font mappingsThreadID      gFontThread;      // thread that builds font menuThreadID      gAGThread;        // thread that looks for AppleGuide databaseThreadID      gStarterThread;      // starts our other threads for usBoolean        gDontYield;        // whether our threads should yieldvoid*        gThreadResults;      // scratch space for thread results// These variables are for the find/replace commandsStr255      gFindString = &quot;\p&quot;, gReplaceString = &quot;\p&quot;;Boolean      gWrapAround = false, gCaseSensitive = false;// Metrowerks MWCRuntime.lib defines qd for us on PPC, and their// __runtime module does under the 68K case. OTOH, neither SC nor// MrC give us qd for free, so we need it there. I'm still not// certain which way to go for the ThinkC or Symantec PPC case.#if !defined(__MWERKS__)// QuickDraw globalsQDGlobals    qd;#endif// --------------------------------------------------------------------------------------------------------------#pragma segment Utilitystatic pascal Boolean AlertFilter(DialogRef theDialog, EventRecord *theEvent, short *itemHit){  if (theEvent-&gt;what == activateEvt &amp;&amp; (DialogRef) theEvent-&gt;message == theDialog)    {    SetDialogDefaultItem(theDialog, 1);    }  if (StdFilterProc(theDialog, theEvent, itemHit))    return true;  // Pass updates through (Activates are tricky...was mucking with Apple menu &amp; thereby  // drastically changing how the system handles the menu bar during our alert)  if (theEvent-&gt;what == updateEvt /* || theEvent-&gt;what == activateEvt */ )    {    HandleEvent(theEvent);    }  return false;} // AlertFiltervoid ConductErrorDialog(OSErr error, short commandID, short alertType){  long    foundError;      // The error, converted to a number  short    stringIndex;    // Index into the strings  Str255    errorText;      // the error in a string format    // Start with no error so far  foundError = 0;    // Start with the first string  stringIndex = 1;    // Loop until we find an error string  errorText[0] = 0;  do    {    // Get the string, and convert it to a number    GetIndString(errorText, kErrorBaseID + commandID, stringIndex);    if (errorText[0] == 0)      break;    StringToNum(errorText, &amp;foundError);        // If we reach the last string, or we match the error code    if ((foundError == 0) ||      (foundError == error))      {      // Get the text string for this error      GetIndString(errorText, kErrorBaseID + commandID, stringIndex+1);      }    else      {      // Otherwise, make us continue until we get a string      errorText[0] = 0;      }          // Advance so we get the next string number    stringIndex += 2;        } while (errorText[0] == 0);        // errorText[0] == 0      if (errorText[0] != 0)    {    DialogRef  dPtr;    short    hit;        SetCursor(&amp;qd.arrow);    ParamText(errorText, &quot;\p&quot;, &quot;\p&quot;, &quot;\p&quot;);        #if !GENERATINGPOWERPC      if (gMachineInfo.theEnvirons.systemVersion &lt; 0x0700)        {        short ** hDialog;                hDialog = (short**) GetResource('DLOG', kErrorBaseID + alertType);        (*hDialog)[4] = dBoxProc;                dPtr = GetNewDialog(kErrorBaseID + alertType, nil, (WindowRef)-1);                do          {          ModalDialog(nil, &amp;hit);          } while (hit != ok);                DisposeDialog(dPtr);        }      else        {        dPtr = GetNewDialog(kErrorBaseID + alertType, nil, (WindowRef)-1);                SetDialogDefaultItem(dPtr, ok);                BeginMovableModal();                do          {          MovableModalDialog(nil, &amp;hit);          } while (hit != ok);                DisposeDialog(dPtr);        EndMovableModal();        }    #else      dPtr = GetNewDialog(kErrorBaseID + alertType, nil, (WindowRef)-1);            SetDialogDefaultItem(dPtr, ok);            BeginMovableModal();            do        {        MovableModalDialog(nil, &amp;hit);        } while (hit != ok);            DisposeDialog(dPtr);      EndMovableModal();    #endif    }    } // ConductErrorDialog// --------------------------------------------------------------------------------------------------------------#pragma segment Utilitystatic void MovableModalMenus(DialogRef dPtr, short *pItem, long menuResult){  short  iCut, iCopy, iClear, iPaste;  short  editMenu;  short  menuItem = menuResult &amp; 0xFFFF;    // find out where edit menus are  CommandToIDs(cCut, &amp;editMenu, &amp;iCut);  CommandToIDs(cCopy, &amp;editMenu, &amp;iCopy);  CommandToIDs(cClear, &amp;editMenu, &amp;iClear);  CommandToIDs(cPaste, &amp;editMenu, &amp;iPaste);    HiliteMenu(0);  switch (menuResult &gt;&gt; 16)    {    case mApple:      {      Str255  tempString;            GetMenuItemText(GetMenuHandle(menuResult&gt;&gt;16), menuItem, tempString);      OpenDeskAcc(tempString);      }      break;          case mEdit:      {      short  type;      Handle  item;      Rect  box;      short  editField = GetDialogKeyboardFocusItem(dPtr);            // return typed item, if it isn't disabled      GetDialogItem(dPtr, editField, &amp;type, &amp;item, &amp;box);      if ((type &amp; itemDisable) == 0)        *pItem = editField;              if (menuItem == iCut)        {        DialogCut(dPtr);        ZeroScrap();        TEToScrap();        }              if (menuItem == iCopy)        {        DialogCopy(dPtr);        ZeroScrap();        TEToScrap();        }              if (menuItem == iClear)        DialogDelete(dPtr);              if (menuItem == iPaste)        DialogPaste(dPtr);      }      break;    }    } // MovableModalMenus// --------------------------------------------------------------------------------------------------------------#pragma segment Utilityvoid MovableModalDialog(ModalFilterProcPtr filterProc, short *pItem)/*  Call this as you would ModalDialog, when the dialog is moveable  modal.    However, first call BeginMovableModal, and afterwards (after  disposing of dialog) call EndMovableModal.*/{  GrafPtr   curPort;  DialogRef  dPtr = FrontWindow();    *pItem = 0;    if (dPtr)    {    GetPort(&amp;curPort);    SetPort(dPtr);        do      {      WaitNextEvent(mDownMask + mUpMask + keyDownMask + keyUpMask + autoKeyMask + updateMask + activMask + osMask,              &amp;gEvent, 0, nil);            // call the filter proc      if ( (filterProc) &amp;&amp; ((*filterProc) (dPtr, &amp;gEvent, pItem)) )        break;                    // call the basic filtering      if (StdFilterProc(dPtr, &amp;gEvent, pItem))        break;              // handle keyboard      if ((gEvent.what == keyDown) &amp;&amp; (gEvent.modifiers &amp; cmdKey))        {        MovableModalMenus(dPtr, pItem, MenuKey(gEvent.message &amp; charCodeMask));        break;        }              // handle clicks and drags      if (gEvent.what == mouseDown)        {        WindowRef  whichWindow;        short    part = FindWindow(gEvent.where, &amp;whichWindow);                // menu bar events        if (part == inMenuBar)          {          MovableModalMenus(dPtr, pItem, MenuSelect(gEvent.where));          break;          }                  // check for outside of our window        if (!PtInRgn(gEvent.where, ((WindowPeek)dPtr)-&gt;strucRgn))          {          SysBeep(1);          gEvent.what = nullEvent;          }                  // drag the window around        if ( (part == inDrag) &amp;&amp; (whichWindow == dPtr) )          {          Rect  tempRect = (**GetGrayRgn()).rgnBBox;                    DragWindow(GetDialogWindow(dPtr), gEvent.where, &amp;tempRect);          gEvent.what = nullEvent;          }        }              // check with standard dialog stuff        {      DialogRef  tempDialog;            if ( IsDialogEvent(&amp;gEvent) &amp;&amp; DialogSelect(&amp;gEvent, &amp;tempDialog, pItem) )        break;      }            // handle updates      if (gEvent.what == updateEvt)        {        HandleEvent(&amp;gEvent);        break;        }      } while (true);        SetPort(curPort);    }    } // MovableModalDialog// --------------------------------------------------------------------------------------------------------------#pragma segment Utilityvoid BeginMovableModal(void){  DialogRef  dPtr = FrontWindow();  WindowRef  nextWindow = GetNextWindow(dPtr);    if (nextWindow)    DoActivate(nextWindow, false);  AdjustMenus(GetDialogWindow(dPtr), (GetDialogKeyboardFocusItem(dPtr) &gt; 0), false);} // BeginMovableModal// --------------------------------------------------------------------------------------------------------------#pragma segment Utilityvoid EndMovableModal(void){  WindowRef  nextWindow = FrontWindow();    AdjustMenus(nextWindow, true, false);  if (nextWindow)    DoActivate(nextWindow, true);  } // EndMovableModal// --------------------------------------------------------------------------------------------------------------#pragma segment Utilityshort ConductFindOrReplaceDialog(short dialogID){  DialogRef  dPtr;  short    hit;    dPtr = GetNewDialog(dialogID, nil, (WindowRef)-1);  if (dPtr)    {    short  kind;    Rect  box;    Handle  item;        // standard default behavior    SetDialogDefaultItem(dPtr, ok);    SetDialogCancelItem (dPtr, cancel);    SetDialogTracksCursor(dPtr, true);        // Find string    GetDialogItem(dPtr, iFindEdit, &amp;kind, &amp;item, &amp;box);    SetDialogItemText(item, gFindString);    // check boxes    GetDialogItem(dPtr, iCaseSensitive, &amp;kind, &amp;item, &amp;box);    SetControlValue((ControlRef)item, gCaseSensitive);    GetDialogItem(dPtr, iWrapAround, &amp;kind, &amp;item, &amp;box);    SetControlValue((ControlRef)item, gWrapAround);        if (dialogID == kReplaceWindowID)      {      // Replace string      GetDialogItem(dPtr, iReplaceEdit, &amp;kind, &amp;item, &amp;box);      SetDialogItemText(item, gReplaceString);      }        // select the search text by default    SelectDialogItemText(dPtr, iFindEdit, 0, 32767);        // and away we go!    ShowWindow(GetDialogWindow(dPtr));    BeginMovableModal();        do      {      MovableModalDialog(nil, &amp;hit);      switch (hit)        {        case iCaseSensitive:        case iWrapAround:          GetDialogItem(dPtr, hit, &amp;kind, &amp;item, &amp;box);          SetControlValue((ControlRef)item, 1-GetControlValue((ControlRef)item));          break;        }      } while ( (hit != ok) &amp;&amp; (hit != cancel) &amp;&amp; (hit != iReplaceAll) );        if (hit != cancel)      {      // Find string      GetDialogItem(dPtr, iFindEdit, &amp;kind, &amp;item, &amp;box);      GetDialogItemText(item, gFindString);        // check boxes      GetDialogItem(dPtr, iCaseSensitive, &amp;kind, &amp;item, &amp;box);      gCaseSensitive = GetControlValue((ControlRef)item);      GetDialogItem(dPtr, iWrapAround, &amp;kind, &amp;item, &amp;box);      gWrapAround = GetControlValue((ControlRef)item);            if (dialogID == kReplaceWindowID)        {        // Replace string        GetDialogItem(dPtr, iReplaceEdit, &amp;kind, &amp;item, &amp;box);        GetDialogItemText(item, gReplaceString);        }      }          DisposeDialog(dPtr);    EndMovableModal();    }      return(hit);  } // ConductFindOrReplaceDialog// --------------------------------------------------------------------------------------------------------------#pragma segment Utilityvoid SetWatchCursor(void){  CursHandle  theWatch;      theWatch = GetCursor(watchCursor);  if (theWatch)    {    char  oldState;        oldState = HGetState((Handle) theWatch);    HLock((Handle) theWatch);    SetCursor(*theWatch);    HSetState((Handle) theWatch, oldState);    }    } // SetWatchCursor// --------------------------------------------------------------------------------------------------------------#pragma segment Utilityvoid LongRectToRect(LongRect* longRect, Rect *rect){  rect-&gt;top     = longRect-&gt;top;  rect-&gt;left     = longRect-&gt;left;  rect-&gt;bottom   = longRect-&gt;bottom;  rect-&gt;right   = longRect-&gt;right;  } // LongRectToRect// --------------------------------------------------------------------------------------------------------------#pragma segment Utilityvoid RectToLongRect(Rect *rect, LongRect *longRect){  longRect-&gt;top     = rect-&gt;top;  longRect-&gt;left     = rect-&gt;left;  longRect-&gt;bottom   = rect-&gt;bottom;  longRect-&gt;right   = rect-&gt;right;  } // RectToLongRect// --------------------------------------------------------------------------------------------------------------#pragma segment Utilityvoid GetPICTRectangleAt72dpi(PicHandle hPicture, Rect *pictureRect){  typedef struct FixedRect {    Fixed left;    Fixed top;    Fixed right;    Fixed bottom;  } FixedRect;    typedef struct {    Picture        pictInfo;    unsigned short    versionOp;    // 0x1101    Byte        opCodes[1];  } PICTHeaderVer1;    typedef struct {    Picture      pictInfo;    unsigned short  versionOp;    // 0x0011    unsigned short  versionOp2;    // 0x02ff    unsigned short  headerOp;    // 0x0c00    unsigned short  version;    // 0xffff    unsigned short  version2;    // 0xffff    FixedRect    pictBounds;    unsigned long  reserved;    unsigned short  opCodes[1];  } PICTHeaderVer2;    typedef struct {    Picture      pictInfo;    unsigned short  versionOp;    // 0x0011    unsigned short  versionOp2;    // 0x02ff    unsigned short  headerOp;    // 0x0c00    unsigned short  version;    // 0xfffe    unsigned short  reserved;    // 0x0000    Fixed      hRes;    Fixed      vRes;    Rect      pictBounds;    unsigned long  reserved2;    unsigned short  opCodes[1];  } PICTHeaderVer2Ext;  Fixed      hRes, vRes;  PICTHeaderVer1* pPict = (PICTHeaderVer1*) *hPicture;  hRes = vRes = ff(72);    // assume 72 dpi  if (pPict-&gt;versionOp == 0x0011)     {      // Version 2 PICT      PICTHeaderVer2* pPict2 = (PICTHeaderVer2*) pPict;        if (pPict2-&gt;version == 0xfffe)       {        // Extended Version 2      PICTHeaderVer2Ext* pPict2ext = (PICTHeaderVer2Ext*) pPict;      hRes = pPict2ext-&gt;hRes;      vRes = pPict2ext-&gt;vRes;      }    }  hRes = FixDiv(hRes, ff(72));  vRes = FixDiv(vRes, ff(72));  pictureRect-&gt;left   = Fix2Long(FixDiv( ff((**hPicture).picFrame.left),     hRes ));  pictureRect-&gt;right   = Fix2Long(FixDiv( ff((**hPicture).picFrame.right),   hRes ));  pictureRect-&gt;top   = Fix2Long(FixDiv( ff((**hPicture).picFrame.top),     vRes ));  pictureRect-&gt;bottom = Fix2Long(FixDiv( ff((**hPicture).picFrame.bottom),   vRes ));  } // GetPICTRectangleAt72dpi// --------------------------------------------------------------------------------------------------------------#pragma segment Utilitystatic WindowDataPtr  GetWindowInfo(WindowRef pWindow){  WindowDataPtr result = nil;    if   (    (pWindow) &amp;&amp;    (GetWindowKind(pWindow) == userKind)    )    result = (WindowDataPtr) GetWRefCon(pWindow);  return result;  } // GetWindowInfo// --------------------------------------------------------------------------------------------------------------#pragma segment Utilitystatic short ZeroStringSub(Str255 destString, Str255 subStr)  // returns number of substitutions performed{  OSErr  anErr;  Handle  destHandle = nil;  Handle  subHandle = nil;  short  count = 0;  anErr = PtrToHand(&amp;destString[1], &amp;destHandle, destString[0]);  if (anErr == noErr)    {        anErr = PtrToHand(&amp;subStr[1], &amp;subHandle, subStr[0]);    if (anErr == noErr)      {      count = ReplaceText(destHandle, subHandle, &quot;\p^0&quot;);    // error or # of substitutions                  destString[0] = GetHandleSize(destHandle);      BlockMoveData(*destHandle, &amp;destString[1], destString[0]);      }    }  DisposeHandle(destHandle);  DisposeHandle(subHandle);  if (count &lt; 0)    count = 0;    // change error code into count = 0 substitutions  return count;} // ZeroStringSub// --------------------------------------------------------------------------------------------------------------// SEARCH/REPLACE UTILITY FUNCTIONS// --------------------------------------------------------------------------------------------------------------static Boolean IsThisTheString(      Ptr p,            // pointer to check      Str255 searchString,    // string to check for      Boolean isCaseSensitive)  // case sensitive check or not/*  Returns true if the supplied string is at the specified offset.  Otherwise returns false.*/{  Boolean  returnValue = false;    if (isCaseSensitive)    returnValue = ( IUMagString(p, &amp;searchString[1], searchString[0], searchString[0]) == 0 );  else    returnValue = ( IUMagIDString(p, &amp;searchString[1], searchString[0], searchString[0]) == 0 );      return(returnValue);  } // IsThisTheString// --------------------------------------------------------------------------------------------------------------Boolean PerformSearch(    Handle  h,          // handle to search    long start,          // offset to begin with    Str255 searchString,    // string to search for    Boolean isCaseSensitive,  // case sensitive search    Boolean isBackwards,    // search backwards from starting point    Boolean isWraparound,    // wrap search around from end-&gt;begining    long * pNewStart,      // returned new selection start    long * pNewEnd)        // returned new selection end/*  Performs a search on the supplied handle, starting at the provided  offset.  Returns the new selection start and end values, and true  if the search is successful.  Otherwise it returns false.*/{  char  flags;  Ptr    startPtr;  Ptr    endPtr;  Ptr    searchPtr;  Boolean  foundIt = false;    flags = HGetState(h);  HLock(h);        // back up one when searching backwards, or we'll hit every time on the current  // character  if (isBackwards)    {    if (start != 0)      {      --start;      }    else      {      if (isWraparound)        start = GetHandleSize(h);      else        return(false);      }    }      // determine the bounds of the searching  startPtr = (*h) + start;  if ( isWraparound )    {    if (isBackwards)      {      // go backwards until just after the start, or begining of      // document is start is the end      if (start == GetHandleSize(h))        endPtr = *h;      else        endPtr = startPtr + 1;      }    else      {      // go forwards until just before the start, or to the end      // of the document is the start is already the begining      if (start == 0)        endPtr = *h + GetHandleSize(h);      else        endPtr = startPtr - 1;      }    }  else    {    if (isBackwards)      {      // go back until hit begining of document      endPtr = *h-1;        }    else      {      // go forward until hit end of document      endPtr = *h + GetHandleSize(h);      }    }      searchPtr = startPtr;  while (searchPtr != endPtr)    {    if (IsThisTheString(searchPtr, searchString, isCaseSensitive))      {      foundIt = true;      *pNewStart = searchPtr - *h;      *pNewEnd = *pNewStart + searchString[0];      break;      }          if (isBackwards)      --searchPtr;    else      ++searchPtr;          if (isWraparound)      {      if (searchPtr &lt; *h)        searchPtr = *h + GetHandleSize(h);      if (searchPtr &gt; *h + GetHandleSize(h))        searchPtr = *h;      }    }      HSetState(h, flags);    return(foundIt);  } // PerformSearch// --------------------------------------------------------------------------------------------------------------// SELECTION UTILITY ROUTINES// --------------------------------------------------------------------------------------------------------------void DrawSelection(WindowDataPtr pData, Rect *pSelection, short * pPhase, Boolean bumpPhase){  if  (!EmptyRect(pSelection) )     {    RgnHandle  oldClip = NewRgn();    Pattern    aPattern;    Rect    newClip;        if   (       (bumpPhase) &amp;&amp;       (MOVESELECTION(TickCount()) )       )      {      if ((++(*pPhase)) &gt; 7 )        *pPhase = 1;      }          // setup for drawing in this window    SetPort((GrafPtr) pData);    GetClip(oldClip);    PenMode(notPatXor);        // offset the draw area (SetOrigin a must to preserve pattern appearence)    // and the clip area to avoid stepping on the scroll bars    SetOrigin(GetControlValue(pData-&gt;hScroll), GetControlValue(pData-&gt;vScroll));    newClip = pData-&gt;contentRect;    OffsetRect(&amp;newClip, GetControlValue(pData-&gt;hScroll), GetControlValue(pData-&gt;vScroll));    ClipRect(&amp;newClip);        // do the draw    GetIndPattern(&amp;aPattern, kPatternListID, (*pPhase)+1);    PenPat(&amp;aPattern);    FrameRect(pSelection);    SetOrigin(0, 0);        // restore the old port settings    SetClip(oldClip);    DisposeRgn(oldClip);    PenNormal();    }} // DrawSelection// --------------------------------------------------------------------------------------------------------------OSErr SelectContents(WindowRef pWindow, WindowDataPtr pData, EventRecord *pEvent, Rect *pSelection, Rect *pContent, short *pPhase){  OSErr      anErr = noErr;  Point      clickPoint = pEvent-&gt;where;  Point      currentPoint;  Boolean     didJustScroll;  ControlRef    theControl;    GlobalToLocal(&amp;clickPoint);  if (FindControl(clickPoint, pWindow, &amp;theControl) == 0)    {      // move the click point into the proper range    clickPoint.h += GetControlValue(pData-&gt;hScroll);    clickPoint.v += GetControlValue(pData-&gt;vScroll);        // if the shift key is held down then the selection starts from    // a preexisting point such that we are doing an expand/contract    // of the original selection    if (pEvent-&gt;modifiers &amp; shiftKey)      {      if (clickPoint.h &lt; pSelection-&gt;right)        clickPoint.h = pSelection-&gt;right;      else        clickPoint.h = pSelection-&gt;left;      if (clickPoint.v &lt; pSelection-&gt;bottom)        clickPoint.v = pSelection-&gt;bottom;      else        clickPoint.v = pSelection-&gt;top;      }                while (StillDown())      {                // get the current mouse       GetMouse(&amp;currentPoint);            didJustScroll = false;      // scroll contents if needed      {      short  deltaH = 0;      short  deltaV = 0;            if (currentPoint.h &lt; 0)        deltaH = pData-&gt;hScrollAmount;      if (currentPoint.h &gt; qd.thePort-&gt;portRect.right)        deltaH = -pData-&gt;hScrollAmount;      if (currentPoint.v &lt; 0)        deltaV = pData-&gt;vScrollAmount;      if (currentPoint.v &gt; qd.thePort-&gt;portRect.bottom)        deltaV = -pData-&gt;vScrollAmount;              if ( (deltaH != 0) || (deltaV != 0) )        {                if (deltaH)          SetControlAndClipAmount(pData-&gt;hScroll, &amp;deltaH);        if (deltaV)          SetControlAndClipAmount(pData-&gt;vScroll, &amp;deltaV);        DoScrollContent(pWindow, pData, deltaH, deltaV);                didJustScroll = true;        }      }            // map mouse into proper range      currentPoint.h += GetControlValue(pData-&gt;hScroll);      currentPoint.v += GetControlValue(pData-&gt;vScroll);        // clip to the document size      if (currentPoint.h &lt; 0)        currentPoint.h = 0;      if (currentPoint.v &lt; 0)        currentPoint.v = 0;      if (currentPoint.h &gt; pContent-&gt;right)        currentPoint.h = pContent-&gt;right;      if (currentPoint.v &gt; pContent-&gt;bottom)        currentPoint.v = pContent-&gt;bottom;              // draw the new selection if it is time or we are about to       // exit this loop      if ((MOVESELECTION(TickCount())) || (!Button()) || (didJustScroll) )        {        // first, erase any old selection we might have had        DrawSelection(pData, pSelection, pPhase, false);        // make a rectangle out of the two points        pSelection-&gt;left   = Min(currentPoint.h, clickPoint.h);        pSelection-&gt;right   = Max(currentPoint.h, clickPoint.h);        pSelection-&gt;top   = Min(currentPoint.v, clickPoint.v);        pSelection-&gt;bottom   = Max(currentPoint.v, clickPoint.v);          // draw the new selection        DrawSelection(pData, pSelection, pPhase, true);        }      }        // we handled the selection    anErr = eActionAlreadyHandled;    }      return(anErr);  } // SelectContents// --------------------------------------------------------------------------------------------------------------void DragAndDropArea(WindowRef pWindow, WindowDataPtr pData, EventRecord* event, Rect *pFrameRect){  RgnHandle    hilightRgn;  Rect      r;  DragReference  theDrag;  OSErr      anErr = noErr;    if (NewDrag(&amp;theDrag) == noErr)    {    if (pData-&gt;pDragAddFlavors)      anErr = (*(pData-&gt;pDragAddFlavors)) (pWindow, pData, theDrag);        if (anErr == noErr)      {      Rect  globalRect = *pFrameRect;            hilightRgn = NewRgn();        LocalToGlobal(&amp;TopLeft(globalRect));      LocalToGlobal(&amp;BotRight(globalRect));      RectRgn(hilightRgn, &amp;globalRect);      SetDragItemBounds(theDrag, 1, &amp;r);        // turn the region from a fill into a frame      {          RgnHandle tempRgn = NewRgn();          CopyRgn(hilightRgn, tempRgn);        InsetRgn(tempRgn, 1, 1);        DiffRgn(hilightRgn, tempRgn, hilightRgn);        DisposeRgn(tempRgn);      }            TrackDrag(theDrag, event, hilightRgn);      DisposeDrag(theDrag);      DisposeRgn(hilightRgn);      }    }} // DragAndDropArea// --------------------------------------------------------------------------------------------------------------// WINDOW UTILITY ROUTINES// --------------------------------------------------------------------------------------------------------------#pragma segment Mainstatic void CalculateGrowIcon(WindowDataPtr pData, Rect * location){  if (pData-&gt;vScroll)    location-&gt;top = (**pData-&gt;vScroll).contrlRect.bottom;  else    {    if (pData-&gt;hScroll)      location-&gt;top = (**pData-&gt;hScroll).contrlRect.top;    else      location-&gt;top = pData-&gt;theWindow.port.portRect.bottom - 15;    }      if (pData-&gt;hScroll)    location-&gt;left = (**pData-&gt;hScroll).contrlRect.right;  else    {    if (pData-&gt;vScroll)      location-&gt;left = (**pData-&gt;vScroll).contrlRect.left;    else      location-&gt;left = pData-&gt;theWindow.port.portRect.right - 15;    }      location-&gt;right = location-&gt;left + 16;  location-&gt;bottom = location-&gt;top + 16;  } // CalculateGrowIcon// --------------------------------------------------------------------------------------------------------------#pragma segment MainOSErr  AdjustScrollBars(WindowRef pWindow,  Boolean moveControls,         // might the controls have moved?  Boolean didResize,           // did we just resize the window?  Boolean *needInvalidate)      // does the caller need to invalidate contents as a result?{  OSErr      anErr = noErr;  LongRect    docRect;  WindowDataPtr   pData = GetWindowInfo(pWindow);  Rect      growIconRect;    if (needInvalidate)    *needInvalidate = false;  if (pData)    {    short  oldHMax, oldVMax;    short  oldHValue, oldVValue;        // cache current values, we'll force an update if we needed to change em!    if (pData-&gt;hScroll)      {      oldHMax = GetControlMaximum(pData-&gt;hScroll);      oldHValue = GetControlValue(pData-&gt;hScroll);      }    if (pData-&gt;vScroll)      {      oldVMax = GetControlMaximum(pData-&gt;vScroll);      oldVValue = GetControlValue(pData-&gt;vScroll);      }          // if we have a grow box but not all controls we have to invalidate the grow bar areas    // by caclulating them    if ( (didResize) &amp;&amp; (pData-&gt;hasGrow) )      {      // if we regrow without any scroll bars, we need to update the content area      if ( (needInvalidate) &amp;&amp; (pData-&gt;hScroll == nil) &amp;&amp; (pData-&gt;vScroll == nil) )        *needInvalidate = true;            // invalidate old grow bar areas      if (pData-&gt;vScroll == nil)        {        growIconRect = GetWindowPort(pWindow)-&gt;portRect;        growIconRect.left = pData-&gt;contentRect.right;        InvalRect(&amp;growIconRect);        }      if (pData-&gt;hScroll == nil)        {        growIconRect = GetWindowPort(pWindow)-&gt;portRect;        growIconRect.top = pData-&gt;contentRect.bottom;        InvalRect(&amp;growIconRect);        }            // invalidate new grow bar areas      if (pData-&gt;vScroll == nil)        {        growIconRect = GetWindowPort(pWindow)-&gt;portRect;        growIconRect.left = growIconRect.right - kScrollBarSize;        InvalRect(&amp;growIconRect);        }      if (pData-&gt;hScroll == nil)        {        growIconRect = GetWindowPort(pWindow)-&gt;portRect;        growIconRect.top = growIconRect.bottom - kScrollBarSize;        InvalRect(&amp;growIconRect);        }      }          // if the controls need moving, recalculate the visible area    if (moveControls)      {      pData-&gt;contentRect = GetWindowPort(pWindow)-&gt;portRect;      if ((pData-&gt;hScroll) || (pData-&gt;hasGrow) )        pData-&gt;contentRect.bottom -= kScrollBarSize;      if ((pData-&gt;vScroll) || (pData-&gt;hasGrow) )        pData-&gt;contentRect.right -= kScrollBarSize;      }          // before doing anything, make the controls invisible    if (pData-&gt;hScroll)      (**pData-&gt;hScroll).contrlVis = 0;      if (pData-&gt;vScroll)      (**pData-&gt;vScroll).contrlVis = 0;    // based on document and visiable area, adjust possible control values    if ( (pData-&gt;pGetDocumentRect) &amp;&amp; ((pData-&gt;hScroll) || (pData-&gt;vScroll)) )      {      // let the object calc the size and content if it wishes to      anErr = (*(pData-&gt;pGetDocumentRect)) (pWindow, pData, &amp;docRect, false);      if (anErr == noErr)        {        short  amountOver;        short  newMax;                amountOver = (docRect.right - docRect.left) - (pData-&gt;contentRect.right - pData-&gt;contentRect.left);        if   (          (pData-&gt;hScroll) &amp;&amp;          (amountOver &gt; 0)          )          newMax = amountOver;        else          newMax = 0;          if (pData-&gt;hScroll)          {          if (GetControlValue(pData-&gt;hScroll) &gt; newMax)            {            if (needInvalidate)              *needInvalidate = true;            }          SetControlMaximum(pData-&gt;hScroll, newMax);          }                amountOver = (docRect.bottom - docRect.top) - (pData-&gt;contentRect.bottom - pData-&gt;contentRect.top);        if   (          (pData-&gt;vScroll) &amp;&amp;          (amountOver &gt; 0)          )          newMax = amountOver;        else          newMax = 0;                  if (pData-&gt;vScroll)          {          if (GetControlValue(pData-&gt;vScroll) &gt; newMax)            {            if (needInvalidate)              *needInvalidate = true;            }          SetControlMaximum(pData-&gt;vScroll, newMax);          }        }      }          // then, if the controls need moving, we move them and inval the old    // and new locations    if (moveControls)      {      // if we have grow box we invalidate the old grow location      if ( pData-&gt;hasGrow)         {        CalculateGrowIcon(pData, &amp;growIconRect);        InvalRect(&amp;growIconRect);        }              if (pData-&gt;hScroll)        {        short  widthAdjust;                if ((pData-&gt;vScroll) || (pData-&gt;hasGrow))          widthAdjust = -kGrowScrollAdjust;        else          widthAdjust = -1;                  growIconRect = (**pData-&gt;hScroll).contrlRect;        InvalRect(&amp;growIconRect);                MoveControl(pData-&gt;hScroll, pData-&gt;hScrollOffset-1, GetWindowPort(pWindow)-&gt;portRect.bottom - kScrollBarSize);        SizeControl(pData-&gt;hScroll, (GetWindowPort(pWindow)-&gt;portRect.right -               GetWindowPort(pWindow)-&gt;portRect.left) + widthAdjust - pData-&gt;hScrollOffset,              16);        growIconRect = (**pData-&gt;hScroll).contrlRect;        InvalRect(&amp;growIconRect);        }      if (pData-&gt;vScroll)        {        short  heightAdjust;                if ((pData-&gt;hScroll) || (pData-&gt;hasGrow))          heightAdjust = -kGrowScrollAdjust;        else          heightAdjust = -1;                  growIconRect = (**pData-&gt;vScroll).contrlRect;        InvalRect(&amp;growIconRect);        MoveControl(pData-&gt;vScroll, GetWindowPort(pWindow)-&gt;portRect.right - kScrollBarSize, pData-&gt;vScrollOffset-1);        SizeControl(pData-&gt;vScroll, 16,              (GetWindowPort(pWindow)-&gt;portRect.bottom -               GetWindowPort(pWindow)-&gt;portRect.top) + heightAdjust - pData-&gt;vScrollOffset);        growIconRect = (**pData-&gt;vScroll).contrlRect;        InvalRect(&amp;growIconRect);        }              // if we have scroll bars, update the grow icon      if ( pData-&gt;hasGrow )        {        CalculateGrowIcon(pData, &amp;growIconRect);        InvalRect(&amp;growIconRect);        }            }    // let the document adjust anything it needs to    if (pData-&gt;pAdjustSize)      anErr = (*(pData-&gt;pAdjustSize)) (pWindow, pData, &amp;didResize);          if ((didResize) &amp;&amp; (needInvalidate))      *needInvalidate = true;    if ( ((WindowPeek) pWindow)-&gt;hilited )      {      // after doing something, make the controls visible      if (pData-&gt;hScroll)        {        if ((oldHMax != GetControlMaximum(pData-&gt;hScroll)) || (oldHValue != GetControlValue(pData-&gt;hScroll)) )          ShowControl(pData-&gt;hScroll);        else          (**pData-&gt;hScroll).contrlVis = 0xFF;          }      if (pData-&gt;vScroll)        {        if ((oldVMax != GetControlMaximum(pData-&gt;vScroll)) || (oldVValue != GetControlValue(pData-&gt;vScroll)) )          ShowControl(pData-&gt;vScroll);        else          (**pData-&gt;vScroll).contrlVis = 0xFF;        }      }    }      return anErr;  } // AdjustScrollBars// --------------------------------------------------------------------------------------------------------------// MENU UTILITY ROUTINES// --------------------------------------------------------------------------------------------------------------#pragma segment MainBoolean CommandToIDs(short commandID, short * menuID, short *itemID){  short  ** commandHandle;  short  whichMenu;  short  oldResFile = CurResFile();  Boolean  returnValue = false;    UseResFile(gApplicationResFile);  for (whichMenu = mApple; whichMenu &lt;= mLastMenu; whichMenu++)    {    commandHandle = (short**) Get1Resource('MCMD', whichMenu);    if (commandHandle)      {      short  * pCommands = *commandHandle;      short  commandIndex;      short  numCommands = pCommands[0];            for (commandIndex = 1; commandIndex &lt;= numCommands; ++commandIndex)        if (pCommands[commandIndex] == commandID)          {          *menuID = whichMenu;          *itemID = commandIndex;                    returnValue = (commandIndex == numCommands);          }      }      }      UseResFile(oldResFile);    return returnValue;  } // CommandToIDs// --------------------------------------------------------------------------------------------------------------#pragma segment MainBoolean IsCommandEnabled(short commandID)/*  returns true if a given command is currently enabled*/{  short    whichMenu, whichItem;  MenuHandle  menu;    CommandToIDs(commandID, &amp;whichMenu, &amp;whichItem);  menu = GetMenuHandle(whichMenu);    if ((**menu).enableFlags &amp; (1 &lt;&lt; whichItem))    return(true);    return(false);  } // IsCommandEnabled// --------------------------------------------------------------------------------------------------------------#pragma segment Mainvoid EnableCommand(short commandID)/*  Given a command ID, enables the first menu item with that command ID.    If the command table for a given menu is less than the number of items in the menu,  and the command being enabled is the last item in the command table, then all  items from there on down are also enabled.  This is useful for menus that get  appended to, such as the desk accessory list, font list, or speaking voices list.*/{  short  whichMenu;  short  whichItem;    if (CommandToIDs(commandID, &amp;whichMenu, &amp;whichItem))    {    short    i;    MenuHandle  menu = GetMenuHandle(whichMenu);        if (menu)      {      short    numItems = CountMItems(menu);            for (i = whichItem; i &lt;= numItems; ++i)        EnableItem(menu, i);      }    }  else    {    MenuHandle  menu = GetMenuHandle(whichMenu);    if (menu)      EnableItem(menu, whichItem);    }    } // EnableCommand// --------------------------------------------------------------------------------------------------------------#pragma segment Mainvoid ChangeCommandName(short commandID, short resourceID, short resourceIndex){  short    whichMenu;  short    whichItem;  MenuHandle  menu;    // figure out how this command maps into the menu bar  CommandToIDs(commandID, &amp;whichMenu, &amp;whichItem);  menu = GetMenuHandle(whichMenu);    // then make this item into the requested new string  {  Str255    theString;    GetIndString(theString, resourceID, resourceIndex);  SetMenuItemText(menu, whichItem, theString);  }  } // ChangeCommandName// --------------------------------------------------------------------------------------------------------------#pragma segment Mainvoid EnableCommandCheck(short commandID, Boolean check){  short  whichMenu;  short  whichItem;    if (CommandToIDs(commandID, &amp;whichMenu, &amp;whichItem))    {    short    i;    MenuHandle  menu = GetMenuHandle(whichMenu);    short    numItems = CountMItems(menu);        for (i = whichItem; i &lt;= numItems; ++i)      {      EnableItem(menu, i);      CheckItem(menu, i, check);      }    }  else    {    MenuHandle  menu = GetMenuHandle(whichMenu);    EnableItem(menu, whichItem);    CheckItem(menu, whichItem, check);    }    } // EnableCommandCheck// --------------------------------------------------------------------------------------------------------------#pragma segment Mainvoid EnableCommandCheckStyle(short commandID, Boolean check, short style){  short  whichMenu;  short  whichItem;    if (CommandToIDs(commandID, &amp;whichMenu, &amp;whichItem))    {    short    i;    MenuHandle  menu = GetMenuHandle(whichMenu);    short    numItems = CountMItems(menu);        for (i = whichItem; i &lt;= numItems; ++i)      {      EnableItem(menu, i);      CheckItem(menu, i, check);      SetItemStyle(menu, i, style);      }    }  else    {    MenuHandle  menu = GetMenuHandle(whichMenu);    EnableItem(menu, whichItem);    CheckItem(menu, whichItem, check);    SetItemStyle(menu, whichItem, style);    }    } // EnableCommandCheckStyle// --------------------------------------------------------------------------------------------------------------#pragma segment Mainvoid AdjustMenus(WindowRef pWindow, Boolean editDialogs, Boolean forceTitlesOn){  Boolean         wasEnabled[mNumberMenus];  // Old state of menus  short          whichMenu;          // for stepping through menus  MenuHandle        menu;            // for reading in menu IDs  WindowDataPtr       pData = GetWindowInfo(pWindow);    // Step through all of the menus   for (whichMenu = mApple; whichMenu &lt;= mLastMenu; whichMenu++)    {    // Save the old state of the menu title     menu = GetMenuHandle(whichMenu);    if (menu)                // because contents menu may not be around      {      if (forceTitlesOn)                wasEnabled[mLastMenu - whichMenu] = false;      else        wasEnabled[mLastMenu - whichMenu] = (((**menu).enableFlags &amp;&amp; 1) == 1);            // Disable the entire menu       (**menu).enableFlags = 0;          }    }    // select all, unless someone else changes it  ChangeCommandName(cSelectAll, kMiscStrings, iSelectAllCommand);  // if we have NO windows, or the current window is one we understand  if ((pWindow == nil) || (pData))    {    // enable the default commands    EnableCommand(cAbout);    EnableCommand(cDeskAccessory);        EnableCommand(cNew);    EnableCommand(cOpen);    EnableCommand(cQuit);      EnableCommand(cShowClipboard);    }  else    {    // it's printing or a dialog, so enable cut/copy/paste    if (editDialogs)      {      EnableCommand(cCut);      EnableCommand(cCopy);      EnableCommand(cPaste);      EnableCommand(cClear);      }        // and desk accs too!        EnableCommand(cDeskAccessory);    }      if ( (pWindow) &amp;&amp; (pData) )    {    // all windows can be closed    if (FrontWindow())      EnableCommand(cClose);    // changed documents can be saved, but only if the file is open for write    if (   (pData-&gt;changed) &amp;&amp;         ((pData-&gt;isWritable) || (pData-&gt;dataRefNum == -1)) )      EnableCommand(cSave);        // objects with a print method can be printed and page setup-ed    if (pData-&gt;pPrintPage)      {      EnableCommand(cPrint);      EnableCommand(cPageSetup);      EnableCommand(cPrintOneCopy);      }          // let object enable anything else that needs to be enabled    if (pData-&gt;pAdjustMenus)      (*(pData-&gt;pAdjustMenus)) (pWindow, pData);    }      // Now determine if any of the menus have changed state  {  Boolean gotToRedraw = false;    for (whichMenu = mApple; whichMenu &lt;= mLastMenu; ++whichMenu)    {    menu = GetMenuHandle(whichMenu);      if (menu)    // because contents menu may not be around      {      // If any of the menu is enabled       if ((**menu).enableFlags != 0)        {        // Make sure to turn on the menu title         (**menu).enableFlags |= 1;        }              /*   If this new state is different than the saved state, then the menu bar        will need to be redrawn */      if (wasEnabled[mLastMenu - whichMenu] != ((**menu).enableFlags &amp;&amp; 1))        {        gotToRedraw = true;        }      }    }      // And if any titles have changed state, redraw them   if (gotToRedraw)    DrawMenuBar();  }    } // AdjustMenus// --------------------------------------------------------------------------------------------------------------// PRINTING UTILITY ROUTINES// --------------------------------------------------------------------------------------------------------------#pragma segment PrintingBoolean IsSomewhereInRectangle(gxRectangle *pContainer, gxRectangle *pShape)/*  Calculates this by saying the rectangle doesn't intersect at ALL,  and then NOTs that expression.*/{  return    (!(    pShape-&gt;top &gt; pContainer-&gt;bottom ||    pShape-&gt;bottom &lt; pContainer-&gt;top ||    pShape-&gt;left &gt; pContainer-&gt;right ||    pShape-&gt;right &lt; pContainer-&gt;left    ));    } // IsSomewhereInRectangle// --------------------------------------------------------------------------------------------------------------#pragma segment Printing  static OSErr SimpleCatchShape(gxShape newShape, CatchRefCon * pRefCon){  Boolean        addShape = false;  gxGraphicsError    anErr;  // did the user abort printing?  anErr = GXGetJobError(pRefCon-&gt;theJob);  if (anErr != noErr)    return anErr;      switch (GXGetShapeType(newShape))    {        // if we have a layout, turn off justification so that we can get    // better looking morph effects, and also enable the default features    // of the layout.  However, we can only do this if the layout is    // in a script system where the translation wasn't done by a Print Action Hook.    // For now, this means only smRoman styles.    case gxLayoutType:      if (pRefCon-&gt;doLayout)        {        Boolean      enableLayout = pRefCon-&gt;doLayout;            gxStyle      * theStyles;        long      styleCount, index;                GXGetLayout(newShape, nil,              &amp;styleCount, nil, nil,  // style runs              nil, nil, nil,  // run levels              nil, nil);        theStyles = (gxStyle*) NewPtr(sizeof(gxStyle)*styleCount);        if (theStyles)          {          GXGetLayout(newShape, nil,                &amp;styleCount, nil, theStyles,  // style runs                nil, nil, nil,  // run levels                nil, nil);                    enableLayout = true;          for (index = 0; index &lt; styleCount; ++index)            {            gxFontScript theScript;            gxFontPlatform thePlatform = GXGetStyleEncoding(theStyles[index], &amp;theScript, nil);                        if ((thePlatform != gxMacintoshPlatform) || (theScript != gxRomanScript))              enableLayout = false;            }                        if (enableLayout)            for (index = 0; index &lt; styleCount; ++index)              {              gxRunControls theControls;                            // re-enable run control features              GXGetStyleRunControls(theStyles[index], &amp;theControls);              theControls.flags = 0;              theControls.track = 0;              theControls.hangingInhibitFactor = 0;              theControls.kerningInhibitFactor = 0;              GXSetStyleRunControls(theStyles[index], &amp;theControls);                            // and turn back on default features              GXSetStyleRunFeatures(theStyles[index], 0, nil);              }                      DisposePtr((Ptr) theStyles);          }            if ( (enableLayout) &amp;&amp; (GetSysDirection() == 0) )          {          // turn off justification          {          gxLayoutOptions  layoutOptions;                // get the current layout options          layoutOptions.baselineRec = nil;          GXGetLayout(newShape, nil,                nil, nil, nil,  // style runs                nil, nil, nil,  // run levels                &amp;layoutOptions, nil);                      // setting width to zero allows lines to float, but causes multi-styled          // lines (separate layouts from the translation process) to run into          // one another, so we can't do that          //layoutOptions.width = 0;          layoutOptions.just = gxNoJustification;          GXSetLayout(newShape,                 0, nil, nil,  // text runs                0, nil, nil,  // style runs                0, nil, nil, // run levels                &amp;layoutOptions, nil);          }                    // un-clip the shape left and right so we can see things like hanging puncs.            {            gxShape      newClip;            gxRectangle    bounds;                        newClip = GXGetShapeClip(newShape);            GXGetShapeLocalBounds(newClip, &amp;bounds);            GXDisposeShape(newClip);                        bounds.left   = gxNegativeInfinity;            bounds.right   = gxPositiveInfinity;            newClip = GXNewRectangle(&amp;bounds);            GXSetShapeClip(newShape, newClip);            GXDisposeShape(newClip);            }          }                }      // if we aren't forming layouts, we'll go ahead and check for this being on      // the shape.  But for pure text, we'll just always add the text.  TextEdit      // is pretty good about pre-clipping for us.      if (!pRefCon-&gt;doLayout)        {        gxRectangle  bounds;                GXGetShapeLocalBounds(newShape, &amp;bounds);        if (IsSomewhereInRectangle(&amp;pRefCon-&gt;thePageRectangle, &amp;bounds))          addShape = true;        }      else        addShape = true;      break;        // never add these for text case    case gxRectangleType:      if (!pRefCon-&gt;doLayout)        addShape = true;      break;          // always add these shapes if we see any because we don't know how to filter them    case gxEmptyType:    case gxFullType:    case gxPictureType:      addShape = true;      break;          default:      {      gxRectangle  bounds;            GXGetShapeLocalBounds(newShape, &amp;bounds);      if (IsSomewhereInRectangle(&amp;pRefCon-&gt;thePageRectangle, &amp;bounds))        addShape = true;      }      break;          } // switch      if (addShape)    GXSetPictureParts(pRefCon-&gt;thePage, 0, 0, 1, &amp;newShape, nil, nil, nil);  /* Add shape */    GXGetGraphicsError(&amp;anErr);    if (anErr == noErr)    {    GXIdleJob(pRefCon-&gt;theJob);    anErr = GXGetJobError(pRefCon-&gt;theJob);    }      return anErr;  } // SimpleCatchShape#if GENERATINGCFM  static RoutineDescriptor gSimpleCatchShapeRD = BUILD_ROUTINE_DESCRIPTOR(uppgxShapeSpoolProcInfo, SimpleCatchShape);  static gxShapeSpoolUPP gSimpleCatchShape = &amp;gSimpleCatchShapeRD;#else  static gxShapeSpoolUPP gSimpleCatchShape = NewgxShapeSpoolProc(SimpleCatchShape);#endif// --------------------------------------------------------------------------------------------------------------#pragma segment Printingstatic OSErr CompleteSpoolFileMessage( gxSpoolFile theSpoolFile ){  OSErr      anErr     = noErr;  Handle      hIcon;  short      sourceIcon   = 0;  short      docIcon   = 132;  WindowDataPtr  pData     = GXGetJobRefCon(GXGetJob());    // for some file types, we can supply a nicer icon for the Finder to display  // within the queue when this document is printing  switch (pData-&gt;originalFileType)    {    case 'TEXT':    case 'sEXT':      sourceIcon = kTextIcon;      break;                case 'ttro':      sourceIcon = kReadOnlyIcon;      break;    case 'PICT':      sourceIcon = kPICTIcon;      break;    }      if (sourceIcon != 0)    {    hIcon = GetResource('ICN#', sourceIcon);    if (hIcon != nil)       {      HNoPurge(hIcon);      DetachResource(hIcon);      anErr = Send_GXSpoolResource (theSpoolFile, hIcon, 'ICN#', docIcon);      }    nrequire(anErr, SpoolOneBit);        hIcon = GetResource('icl4', sourceIcon);    if (hIcon != nil)       {      HNoPurge(hIcon);      DetachResource(hIcon);      anErr = Send_GXSpoolResource (theSpoolFile, hIcon, 'icl4', docIcon);      }    nrequire(anErr, SpoolFourBit);      hIcon = GetResource('icl8', sourceIcon);    if (hIcon != nil)       {      HNoPurge(hIcon);      DetachResource(hIcon);      anErr = Send_GXSpoolResource (theSpoolFile, hIcon, 'icl8', docIcon);      }    nrequire(anErr, SpoolEightBit);    }    anErr = Forward_GXCompleteSpoolFile( theSpoolFile );  // FALL THROUGH EXCEPTION HANDLINGSpoolOneBit:SpoolFourBit:SpoolEightBit:  return anErr;  } // CompleteSpoolFileMessage#if GENERATINGCFM  static RoutineDescriptor gCompleteSpoolFileMessageRD = BUILD_ROUTINE_DESCRIPTOR(uppGXCompleteSpoolFileProcInfo, CompleteSpoolFileMessage);  static GXCompleteSpoolFileUPP gCompleteSpoolFileMessage = &amp;gCompleteSpoolFileMessageRD;#else  static GXCompleteSpoolFileUPP gCompleteSpoolFileMessage = NewGXCompleteSpoolFileProc(CompleteSpoolFileMessage);#endif// --------------------------------------------------------------------------------------------------------------#pragma segment Printingstatic OSErr PrintingEventMessage(EventRecord *event, Boolean filter){  OSErr   anErr = noErr;  GrafPtr  curPort;    GetPort(&amp;curPort);  if (filter == false)     {    switch ( event-&gt;what )       {      case mouseDown:      case keyDown:      case autoKey:        break;              case activateEvt:      case updateEvt:      default:        HandleEvent(event);        break;      }    }    anErr = Forward_GXPrintingEvent(event, filter);  SetPort(curPort);    return anErr;  } // PrintingEventMessage#if GENERATINGCFM  static RoutineDescriptor gPrintingEventMessageRD = BUILD_ROUTINE_DESCRIPTOR(uppGXPrintingEventProcInfo, PrintingEventMessage);  static GXPrintingEventUPP gPrintingEventMessage = &amp;gPrintingEventMessageRD;#else  static GXPrintingEventUPP gPrintingEventMessage = NewGXPrintingEventProc(PrintingEventMessage);#endif// --------------------------------------------------------------------------------------------------------------// FILE UTILITY ROUTINES// --------------------------------------------------------------------------------------------------------------#pragma segment Mainstatic Boolean BringToFrontIfOpen(FSSpecPtr pSpec){  WindowRef    pWindow;    pWindow = FrontWindow();  while (pWindow)    {    WindowDataPtr pData = GetWindowInfo(pWindow);        if (      (pData) &amp;&amp;      (pData-&gt;fileSpec.vRefNum == pSpec-&gt;vRefNum) &amp;&amp;      (pData-&gt;fileSpec.parID == pSpec-&gt;parID) &amp;&amp;      EqualString(pData-&gt;fileSpec.name, pSpec-&gt;name, false, false)      )      {      SelectWindow(pWindow);      return true;      }          pWindow = GetNextWindow(pWindow);    }      return false;  } // BringToFrontIfOpen// --------------------------------------------------------------------------------------------------------------#pragma segment Mainstatic Boolean BringToFrontIfExists(ResType windowKind){  WindowRef    pWindow;    pWindow = FrontWindow();  while (pWindow)    {    WindowDataPtr pData = GetWindowInfo(pWindow);        if ((pData) &amp;&amp; (pData-&gt;windowKind == windowKind))      {      SelectWindow(pWindow);      return true;      }          pWindow = GetNextWindow(pWindow);    }      return false;  } // BringToFrontIfExists// --------------------------------------------------------------------------------------------------------------// MAIN SIMPLETEXT ROUTINES// --------------------------------------------------------------------------------------------------------------#pragma segment Mainstatic OSErr MakeNewWindow(ResType windowKind, FSSpecPtr fileSpec, OSType fileType, Boolean *pWasAlreadyOpen){  OSErr        anErr = fnfErr;  PreflightRecord    thePreflight;  PreflightWindowProc  pPreflight = nil;  WindowRef      pWindow;  WindowDataPtr    pData;    // require a certain amount of RAM free before we allow the new window to be created  if (FreeMem() &lt; kRAMNeededForNew)    anErr = memFullErr;      // &lt;50&gt; if we already have a document open from this file, bring the window to the  // front and return with no error  if ( (fileSpec) &amp;&amp; (fileType != 'sEXT') &amp;&amp; (BringToFrontIfOpen(fileSpec)) )    {    if (pWasAlreadyOpen)      *pWasAlreadyOpen = true;    anErr = noErr;    return(anErr);    }  if (pWasAlreadyOpen)    *pWasAlreadyOpen = false;  if (anErr != fnfErr)    {    nrequire(anErr, SanityCheckFailed);    }      // initialize our behavior  thePreflight.continueWithOpen   = true;  thePreflight.resourceID     = kDefaultWindowID;  thePreflight.wantHScroll     = false;  thePreflight.wantVScroll     = false;  thePreflight.storageSize     = sizeof(WindowDataRecord);  thePreflight.makeProcPtr     = nil;  thePreflight.openKind      = fsRdPerm;  thePreflight.needResFork    = false;  thePreflight.doZoom        = false;  thePreflight.fileType      = fileType;    switch (windowKind)    {    case kAboutWindow:      pPreflight = AboutPreflightWindow;      break;    case kPICTWindow:      pPreflight = PICTPreflightWindow;      break;    case kMovieWindow:      pPreflight = MoviePreflightWindow;      break;    case kClipboardWindow:      pPreflight = ClipboardPreflightWindow;      break;    case kTextWindow:      pPreflight = TextPreflightWindow;      break;    case kGXWindow:      pPreflight = GXPreflightWindow;      break;    case kThreeDWindow:      pPreflight = ThreeDPreflightWindow;      break;    }    // preflight the window    if (pPreflight)    anErr = (*pPreflight) (&amp;thePreflight);  nrequire(anErr, PreflightFailed);    if (thePreflight.continueWithOpen)    {    // allocate a place for the window    pData = (WindowDataPtr)NewPtrClear(thePreflight.storageSize);    anErr = MemError();    nrequire(anErr, FailedToAllocateWindow);        // then actually create the window    if (gMachineInfo.theEnvirons.hasColorQD)      pWindow = (WindowRef)GetNewCWindow(thePreflight.resourceID, pData, (WindowPtr)-1);    else      pWindow = (WindowRef)GetNewWindow(thePreflight.resourceID, pData, (WindowPtr)-1);    if (!pWindow) anErr = memFullErr;    nrequire(anErr, NewWindowFailed);    SetWRefCon(pWindow, (long) pData);            // zoom the rectangle to big size on this monitor     // based upon which scroll bars they want    {    Rect  rect = GetWindowPort(pWindow)-&gt;portRect;    Rect  bigRect;        if (gMachineInfo.theEnvirons.hasColorQD)      bigRect = (**GetMainDevice()).gdRect;    else      bigRect = qd.screenBits.bounds;    bigRect.top += GetMBarHeight() * 2;    bigRect.left += 4;    bigRect.bottom -= 4;    bigRect.right -= 65;        SetPort((GrafPtr) GetWindowPort(pWindow));    LocalToGlobal(&amp;TopLeft(rect));    LocalToGlobal(&amp;BotRight(rect));        if ( (thePreflight.wantHScroll) || (thePreflight.doZoom) )      {      rect.left = bigRect.left;      rect.right = bigRect.right;      }          if ( (thePreflight.wantVScroll) || (thePreflight.doZoom) )      {      rect.top = bigRect.top;      rect.bottom = bigRect.bottom;      }        MoveWindow(pWindow, rect.left, rect.top, false);    SizeWindow(pWindow, rect.right - rect.left, rect.bottom - rect.top, false);    }        // fill in the default contents of the window    pData-&gt;windowKind     = windowKind;    pData-&gt;originalFileType  = fileType;    pData-&gt;pMakeWindow     = (MakeWindowProc)thePreflight.makeProcPtr;    pData-&gt;resRefNum    = -1;    pData-&gt;dataRefNum    = -1;    pData-&gt;contentRect     = GetWindowPort(pWindow)-&gt;portRect;        // make the scroll bars    {    Rect  controlRect;        if (thePreflight.wantHScroll)      {      pData-&gt;contentRect.bottom -= kScrollBarSize;      controlRect = GetWindowPort(pWindow)-&gt;portRect;      controlRect.top = controlRect.bottom - 16;      if (thePreflight.wantVScroll)        controlRect.right -= kGrowScrollAdjust;      OffsetRect(&amp;controlRect, -1, 1);      pData-&gt;hScroll = NewControl(pWindow, &amp;controlRect, &quot;\p&quot;, true, 0, 0, 0, scrollBarProc, 0);      }    if (thePreflight.wantVScroll)      {      pData-&gt;contentRect.right -= kScrollBarSize;      controlRect = GetWindowPort(pWindow)-&gt;portRect;      controlRect.left = controlRect.right - 16;      if (thePreflight.wantVScroll)        controlRect.bottom -= kGrowScrollAdjust;      OffsetRect(&amp;controlRect, 1, -1);      pData-&gt;vScroll = NewControl(pWindow, &amp;controlRect, &quot;\p&quot;, true, 0, 0, 0, scrollBarProc, 0);      }    }    // got a name?  Open the file        if (fileSpec)      {      anErr = FSpOpenDF(fileSpec, thePreflight.openKind, &amp;pData-&gt;dataRefNum);      if   (           ((anErr == afpAccessDenied) || (anErr == opWrErr) || (anErr == permErr) ) &amp;&amp;           (thePreflight.openKind != fsRdPerm)        )        {        thePreflight.openKind = fsRdPerm;        pData-&gt;isWritable = false;        anErr = FSpOpenDF(fileSpec, thePreflight.openKind, &amp;pData-&gt;dataRefNum);        }      else        pData-&gt;isWritable = true;      nrequire(anErr, FailedToOpenFile);      // okay not to find a resource fork, because some don't have them              pData-&gt;resRefNum = FSpOpenResFile(fileSpec, thePreflight.openKind);            // save the file spec in case someone is interested      pData-&gt;fileSpec = *fileSpec;      }          if (pData-&gt;pMakeWindow)      {      Rect oldContent = pData-&gt;contentRect;      anErr = (*(pData-&gt;pMakeWindow)) (pWindow, pData);      if (!EqualRect(&amp;oldContent, &amp;pData-&gt;contentRect))        {        SizeWindow(pWindow,             pData-&gt;contentRect.right  + (pData-&gt;vScroll != 0) * kScrollBarSize,            pData-&gt;contentRect.bottom + (pData-&gt;hScroll != 0) * kScrollBarSize,            false);        }      }    nrequire(anErr, FailedMakeWindow);    // got a name?  Use it as the window title    if ( (fileSpec) &amp;&amp; (!pData-&gt;openAsNew) )      SetWTitle(pWindow, fileSpec-&gt;name);    else      {      if ((gMachineInfo.documentCount == 1) &amp;&amp; (pData-&gt;windowKind == kTextWindow))        {        Str255 tempString;            GetIndString(tempString, kMiscStrings, iFirstNewDocumentTitle);  // get the &quot;untitled&quot; string (no number)        SetWTitle(pWindow, tempString);        }      else        {        Str255  tempString;        Str32  numString;          GetWTitle(pWindow, tempString);        NumToString(gMachineInfo.documentCount, numString);        (void) ZeroStringSub(tempString, numString);        SetWTitle(pWindow, tempString);        }      if (pData-&gt;bumpUntitledCount)        gMachineInfo.documentCount++;  // bump count if appropriate for this kind of document      }    // Make sure the scroll bars are reasonable in size, and move if they must    AdjustScrollBars(pWindow, true, true, nil);    // finally, if all goes well, we can see the window itself!    ShowWindow(pWindow);    }  return noErr;// EXCEPTION HANDLINGFailedMakeWindow:  if (pData-&gt;resRefNum != -1)    CloseResFile(pData-&gt;resRefNum);  if (pData-&gt;dataRefNum != -1)    FSClose(pData-&gt;dataRefNum);  FailedToOpenFile:  CloseWindow(pWindow);  NewWindowFailed:  DisposePtr((Ptr)pData);  FailedToAllocateWindow:PreflightFailed:SanityCheckFailed:  return anErr;  } // MakeNewWindow// --------------------------------------------------------------------------------------------------------------#pragma segment Main#define dontSaveChanges 3#define kVisualDelay 8static pascal Boolean SaveChangesFilter(DialogRef theDialog, EventRecord *theEvent, short *itemHit){  if (StdFilterProc(theDialog, theEvent, itemHit))    return true;  if (theEvent-&gt;what == updateEvt)    {    HandleEvent(theEvent);    }  if (theEvent-&gt;what == keyDown)    {    StringPtr keyEquivs = *GetString(kSaveChangesWindowID);    unsigned char theKey = theEvent-&gt;message &amp; charCodeMask;    if (keyEquivs &amp;&amp; (theKey == keyEquivs[1] || theKey == keyEquivs[2]))      {      short itemType;      Rect theRect;      ControlRef theControl;      long finalTicks;      GetDialogItem(theDialog, dontSaveChanges, &amp;itemType, (Handle *) &amp;theControl, &amp;theRect);      HiliteControl(theControl, kControlButtonPart);      Delay(kVisualDelay, &amp;finalTicks);      HiliteControl(theControl, 0);      *itemHit = dontSaveChanges;      return true;      }    }  return false;}static OSErr DoCloseWindow(WindowRef pWindow){  OSErr      anErr = noErr;  WindowDataPtr   pData = GetWindowInfo(pWindow);    if ( (pData) &amp;&amp; (pData-&gt;changed) )    {    short     hit;    Str255    wTitle;    DialogRef  dPtr;        GetWTitle(pWindow, wTitle);    SetCursor(&amp;qd.arrow);    ParamText(wTitle, &quot;\p&quot;, &quot;\p&quot;, &quot;\p&quot;);        hit = cancel;    dPtr = GetNewDialog(kSaveChangesWindowID, nil, (WindowRef)-1);    if (dPtr)      {      SetDialogDefaultItem(dPtr, ok);      SetDialogCancelItem (dPtr, cancel);      BeginMovableModal();      do        {        MovableModalDialog(SaveChangesFilter, &amp;hit);        } while ((hit != dontSaveChanges) &amp;&amp; (hit != ok) &amp;&amp; (hit != cancel));              DisposeDialog(dPtr);      EndMovableModal();      }    switch (hit)      {      case ok:        anErr = DoCommand(pWindow, cSave, 0);        if (anErr == eUserCanceled)    // redundant?          gAllDone = false;        break;              case cancel:        anErr = eUserCanceled;        gAllDone = false;        break;              case dontSaveChanges:        // don't save, so just close it        break;      }    }  if (anErr == noErr)    {    if ( (pData) &amp;&amp; (pData-&gt;pCloseWindow) )      {      // let the object close the window if it wishes to      anErr = (*(pData-&gt;pCloseWindow)) (pWindow, pData);      }    // otherwise we close it the default way    if (anErr == noErr)      {      if (pData)        {        CloseWindow(pWindow);          if (pData-&gt;hPrint)          {          if (gMachineInfo.haveGX)            GXDisposeJob( pData-&gt;hPrint);          else            DisposeHandle((Handle) pData-&gt;hPrint);          }                  if (pData-&gt;resRefNum != -1)          CloseResFile(pData-&gt;resRefNum);        if (pData-&gt;dataRefNum != -1)          FSClose(pData-&gt;dataRefNum);        DisposePtr((Ptr) pData);        }      }    }  // If we closed the last window, clean up  if (FrontWindow() == nil)    {    AdjustMenus(nil, true, false);    gMachineInfo.documentCount = 1;    // back to &quot;untitled&quot;    }    return anErr;  } // DoCloseWindow#undef dontSaveChanges// --------------------------------------------------------------------------------------------------------------#pragma segment Mainstatic OSErr  DetermineWindowTypeOrOpen(  FSSpecPtr theSpec, OSType theType,         // optional input params -- file to open  OSType *returnedTypeList, short * pNumTypes,  // optional input params -- returns list of files  Boolean *pWasAlreadyOpen)            // optional input params -- was file already open{  OSErr    anErr = noErr;  OSType    typeList[20];  OSType    docList[20];  short    numTypes;  // use local copies if the input params are nil    if (returnedTypeList == nil)    returnedTypeList = &amp;typeList[0];  if (pNumTypes == nil)    pNumTypes = &amp;numTypes;  *pNumTypes = 0;    // Load up all of the file types we know how to handle  AboutGetFileTypes(returnedTypeList, docList, pNumTypes);  PICTGetFileTypes(returnedTypeList, docList, pNumTypes);  MovieGetFileTypes(returnedTypeList, docList, pNumTypes);  ClipboardGetFileTypes(returnedTypeList, docList, pNumTypes);  TextGetFileTypes(returnedTypeList, docList, pNumTypes);  GXGetFileTypes(returnedTypeList, docList, pNumTypes);  ThreeDGetFileTypes(returnedTypeList, docList, pNumTypes);  if (theSpec != nil)    {    short     index;    OSType    windowType = '????';    for (index = 0; index &lt; (*pNumTypes); ++index)      if (theType == returnedTypeList[index])        windowType = docList[index];            if (windowType != '????')      {            if ( (theType == 'TEXT') || (theType == 'sEXT') )        {        FInfo  theInfo;                FSpGetFInfo(theSpec, &amp;theInfo);        if ((theInfo.fdFlags &amp; kIsStationary) != 0)          theType = 'sEXT';        else          theType = 'TEXT';        }              anErr = MakeNewWindow(windowType, theSpec, theType, pWasAlreadyOpen);      }    else      anErr = eDocumentWrongKind;    }          return anErr;  } // DetermineWindowTypeOrOpen// --------------------------------------------------------------------------------------------------------------#pragma segment Main// Handle update/activate events behind Standard Filestatic pascal Boolean OpenDialogFilter(DialogRef theDialog, EventRecord *theEvent,                    short *itemHit, void *myDataPtr){  #pragma unused(myDataPtr)  // Pass updates through (Activates are tricky...was mucking with Apple menu &amp; thereby  // drastically changing how the system handles the menu bar during our alert)  if ( (theEvent-&gt;what == updateEvt) &amp;&amp; (theEvent-&gt;message != (long)theDialog) )    HandleEvent(theEvent);  if (StdFilterProc(theDialog, theEvent, itemHit))    return(true);  return(false);} // OpenDialogFilter#if GENERATINGCFM  static RoutineDescriptor gOpenDialogFilterRD = BUILD_ROUTINE_DESCRIPTOR(uppModalFilterYDProcInfo, OpenDialogFilter);  static ModalFilterYDUPP gOpenDialogFilter = &amp;gOpenDialogFilterRD;#else  static ModalFilterYDUPP gOpenDialogFilter = NewModalFilterYDProc(OpenDialogFilter);#endifstatic OSErr DoOpenWindow(void){  OSErr        anErr = noErr;  short        numTypes;  OSType        typeList[20];  StandardFileReply  sfReply;  Point thePoint = { -1, -1 };  DetermineWindowTypeOrOpen(nil, '????', &amp;typeList[0], &amp;numTypes, nil);    if (gMachineInfo.haveQuickTime)    {    CustomGetFilePreview(nil, numTypes, typeList, &amp;sfReply, 0, thePoint, nil, gOpenDialogFilter, nil, nil, nil);    }  else    {    CustomGetFile(nil, numTypes, typeList, &amp;sfReply, 0, thePoint, nil, gOpenDialogFilter, nil, nil, nil);    }    if (sfReply.sfGood)    {    SetWatchCursor();        anErr = DetermineWindowTypeOrOpen(&amp;sfReply.sfFile, sfReply.sfType, &amp;typeList[0], &amp;numTypes, nil);    SetCursor(&amp;qd.arrow);    }      return anErr;  } // DoOpenWindow// --------------------------------------------------------------------------------------------------------------#pragma segment Mainstatic OSErr DoUpdateWindow(WindowRef pWindow){  OSErr      anErr = noErr;  WindowDataPtr  pData = GetWindowInfo(pWindow);  GrafPtr      curPort;    // only handle updates for windows we know about  if (pData)    {    GetPort(&amp;curPort);    SetPort((GrafPtr)GetWindowPort(pWindow));    BeginUpdate(pWindow);              if (pData-&gt;pUpdateWindow)      anErr = (*(pData-&gt;pUpdateWindow)) (pWindow, pData);      EndUpdate(pWindow);    SetPort(curPort);    }    return anErr;  } // DoUpdateWindow// --------------------------------------------------------------------------------------------------------------#pragma segment MainOSErr DoScrollContent(WindowRef pWindow, WindowDataPtr pData, short deltaH, short deltaV){  OSErr  anErr = noErr;    if ((deltaH) || (deltaV))    {    // if we have a balloon displayed, update before scrolling anything    if (HMIsBalloon())      DoUpdateWindow(pWindow);        if ((pData) &amp;&amp; (pData-&gt;pScrollContent))      anErr = (*(pData-&gt;pScrollContent)) (pWindow, pData, deltaH, deltaV);          if (anErr == noErr)      {      RgnHandle  invalidRgn = NewRgn();            ScrollRect(&amp;pData-&gt;contentRect, deltaH, deltaV, invalidRgn);      InvalRgn(invalidRgn);      DisposeRgn(invalidRgn);        DoUpdateWindow(pWindow);      }    }    return anErr;  } // DoScrollContent// --------------------------------------------------------------------------------------------------------------// BEGIN SCROLL ACTION PROCS// --------------------------------------------------------------------------------------------------------------#pragma segment Mainvoid SetControlAndClipAmount(ControlRef control, short * amount){  short    value, max;    value = GetControlValue(control);  /* get current value */  max = GetControlMaximum(control);    /* and maximum value */  *amount = value - *amount;  if ( *amount &lt; 0 )    *amount = 0;  else    {    if ( *amount &gt; max )      *amount = max;    }  SetControlValue(control, *amount);  *amount = value - *amount;    /* calculate the real change */  } // SetControlAndClipAmount// --------------------------------------------------------------------------------------------------------------static pascal void VActionProc(ControlRef control, short part){  if (part != 0)    {    WindowRef    pWindow = (**control).contrlOwner;    WindowDataPtr   pData = GetWindowInfo(pWindow);    short      amount = 0;        switch (part)      {      case kControlUpButtonPart:        amount = pData-&gt;vScrollAmount;        break;              case kControlDownButtonPart:        amount = -pData-&gt;vScrollAmount;        break;              // vertical page scrolling should be a multiple of the incremental scrolling -- so that      // we avoid half-lines of text at the bottom of pages.            // More generically, if there was a method for dealing with text scrolling by a non-constant      // amount, this would be better -- but SimpleText currently doesn't have a framework to allow      // the document object to override the scroll amount dynamically.  Maybe something to add in      // the future.      case kControlPageUpPart:        amount = (((pData-&gt;contentRect.bottom - pData-&gt;contentRect.top) / pData-&gt;vScrollAmount)-1) * pData-&gt;vScrollAmount;        if (amount == 0)          amount = pData-&gt;contentRect.bottom - pData-&gt;contentRect.top;        break;      case kControlPageDownPart:        amount = (((pData-&gt;contentRect.top - pData-&gt;contentRect.bottom) / pData-&gt;vScrollAmount)+1) * pData-&gt;vScrollAmount;        if (amount == 0)          amount = pData-&gt;contentRect.top - pData-&gt;contentRect.bottom;        break;      }        SetControlAndClipAmount(control, &amp;amount);    if (amount != 0)      DoScrollContent(pWindow, pData, 0, amount);    }    } // VActionProc#if GENERATINGCFM  static RoutineDescriptor gVActionProcRD = BUILD_ROUTINE_DESCRIPTOR(uppControlActionProcInfo, VActionProc);  static ControlActionUPP gVActionProc = &amp;gVActionProcRD;#else  static ControlActionUPP gVActionProc = VActionProc;#endif// --------------------------------------------------------------------------------------------------------------static pascal void HActionProc(ControlRef control, short part){  if (part != 0)    {    WindowRef    pWindow = (**control).contrlOwner;    WindowDataPtr   pData = GetWindowInfo(pWindow);    short      amount = 0;        switch (part)      {      case kControlUpButtonPart:        amount = pData-&gt;hScrollAmount;        break;              case kControlDownButtonPart:        amount = -pData-&gt;hScrollAmount;        break;              case kControlPageUpPart:        amount = pData-&gt;contentRect.right - pData-&gt;contentRect.left;        break;      case kControlPageDownPart:        amount = pData-&gt;contentRect.left - pData-&gt;contentRect.right;        break;      }        SetControlAndClipAmount(control, &amp;amount);    if (amount != 0)      DoScrollContent(pWindow, pData, amount, 0);    }    } // HActionProc#if GENERATINGCFM  static RoutineDescriptor gHActionProcRD = BUILD_ROUTINE_DESCRIPTOR(uppControlActionProcInfo, HActionProc);  static ControlActionUPP gHActionProc = &amp;gHActionProcRD;#else  static ControlActionUPP gHActionProc = HActionProc;#endif// --------------------------------------------------------------------------------------------------------------// END SCROLL ACTION PROCS// --------------------------------------------------------------------------------------------------------------#pragma segment Mainstatic OSErr DoContentClick(WindowRef pWindow){  OSErr      anErr = noErr;  WindowDataPtr   pData = GetWindowInfo(pWindow);      if ( pData )    {    SetPort((GrafPtr) GetWindowPort(pWindow));        if (pData-&gt;pContentClick)      {      // let the object handle the click if it wishes to      anErr = (*(pData-&gt;pContentClick)) (pWindow, pData, &amp;gEvent);      }        if (anErr == noErr)       {      ControlRef    theControl;      short      part;            GlobalToLocal(&amp;gEvent.where);      part = FindControl(gEvent.where, pWindow, &amp;theControl);      switch (part)        {        // do nothing for viewRect case        case 0:          break;        // track the thumb, and then update all at once        case kControlIndicatorPart:          {          short  value = GetControlValue(theControl);                    part = TrackControl(theControl, gEvent.where, nil);          if (part != 0)            {            // turn the value into a delta            value -= GetControlValue(theControl);                        // if we actually moved            if (value != 0)              {              if (theControl == pData-&gt;hScroll)                DoScrollContent(pWindow, pData, value, 0);              if (theControl == pData-&gt;vScroll)                DoScrollContent(pWindow, pData, 0, value);                              }            }          }          break;                  // track the control, and scroll as we go        default:          if (theControl)            {            if (theControl == pData-&gt;hScroll)              part = TrackControl(theControl, gEvent.where, gHActionProc);            if (theControl == pData-&gt;vScroll)              part = TrackControl(theControl, gEvent.where, gVActionProc);            }          break;        }      }    }      return anErr;  } // DoContentClick// --------------------------------------------------------------------------------------------------------------#pragma segment Mainstatic OSErr DoGrowWindow(WindowRef pWindow, EventRecord *pEvent){  OSErr      anErr = noErr;  WindowDataPtr   pData = GetWindowInfo(pWindow);  Rect      tempRect;  LongRect    docRect;  long      growResult;    if (pData)    {    GrafPtr  pPort = (GrafPtr)GetWindowPort(pWindow);        SetPort(pPort);        RectToLongRect(&amp;pData-&gt;contentRect, &amp;docRect);    if (pData-&gt;pGetDocumentRect)      (*(pData-&gt;pGetDocumentRect)) (pWindow, pData, &amp;docRect, true);    if (pData-&gt;vScroll)      docRect.right += 16;    if (pData-&gt;hScroll)      docRect.bottom += 16;        if ( (pData-&gt;hasGrow) &amp;&amp; (pData-&gt;hScroll == nil) &amp;&amp; (pData-&gt;vScroll == nil) )      {      docRect.right += 16;      docRect.bottom += 16;      }          // set up resize constraints    tempRect.left = pData-&gt;minHSize;    if (tempRect.left == 0)      tempRect.left = kMinDocSize;    tempRect.right = docRect.right - docRect.left;    if (tempRect.right &lt; tempRect.left)      tempRect.right = tempRect.left;    tempRect.top = pData-&gt;minVSize;    if (tempRect.top == 0)      tempRect.top = kMinDocSize;    tempRect.bottom = docRect.bottom - docRect.top;    if (tempRect.bottom &lt; tempRect.top)      tempRect.bottom = tempRect.top;          growResult = GrowWindow(pWindow, pEvent-&gt;where, &amp;tempRect);    if ( growResult != 0 )       {      Rect    oldRect;      RgnHandle  currentInval = NewRgn();      Boolean    needInvalidate;            // save old content area      oldRect = pData-&gt;contentRect;            // save old pending update      GetWindowUpdateRgn(pWindow, currentInval);      OffsetRgn(currentInval, pPort-&gt;portBits.bounds.left, pPort-&gt;portBits.bounds.top);            // grow window and recalc what is needed      SizeWindow(pWindow, growResult &amp; 0xFFFF, growResult &gt;&gt; 16, true);      AdjustScrollBars(pWindow, true, true, &amp;needInvalidate);            if (needInvalidate)        {        InvalRect(&amp;pData-&gt;contentRect);        }      else        {        // don't bother to redraw things that haven't changed        SectRect(&amp;oldRect, &amp;pData-&gt;contentRect, &amp;oldRect);        ValidRect(&amp;oldRect);                // but, if a pending update was there, be sure to deal with that!        InvalRgn(currentInval);        }      // if we have offset scrollbars, then force a redraw of them      if (pData-&gt;hScrollOffset)        {        oldRect = GetWindowPort(pWindow)-&gt;portRect;        oldRect.right = oldRect.left + pData-&gt;hScrollOffset;        oldRect.top = oldRect.bottom - kScrollBarSize;        InvalRect(&amp;oldRect);        }      if (pData-&gt;vScrollOffset)        {        oldRect = GetWindowPort(pWindow)-&gt;portRect;        oldRect.bottom = oldRect.top + pData-&gt;vScrollOffset;        oldRect.left = oldRect.right - kScrollBarSize;        InvalRect(&amp;oldRect);        }      DisposeRgn(currentInval);      }          }        return anErr;  } // DoGrowWindow// --------------------------------------------------------------------------------------------------------------#pragma segment Mainstatic OSErr DoZoomWindow(WindowRef pWindow, short zoomDir){  Rect        *windRect, *zoomRect;  Rect        globalPortRect, theSect, dGDRect;  GDHandle      nthDevice, dominantGDevice;  long        sectArea, greatestArea;  short         hMax, vMax;    // determine the max size of the window  {  WindowDataPtr    pData = GetWindowInfo(pWindow);  LongRect      docRect;    RectToLongRect(&amp;pData-&gt;contentRect, &amp;docRect);  if (pData-&gt;pGetDocumentRect)    (*(pData-&gt;pGetDocumentRect)) (pWindow, pData, &amp;docRect, true);  if (pData-&gt;vScroll)    docRect.right += kScrollBarSize;  if (pData-&gt;hScroll)    docRect.bottom += kScrollBarSize;    if ( (pData-&gt;hasGrow) &amp;&amp; (pData-&gt;hScroll == nil) &amp;&amp; (pData-&gt;vScroll == nil) )    {    docRect.right += kScrollBarSize;    docRect.bottom += kScrollBarSize;    }  hMax = docRect.right - docRect.left;  vMax = docRect.bottom - docRect.top;  }    SetPort((GrafPtr) GetWindowPort(pWindow));  EraseRect(&amp;GetWindowPort(pWindow)-&gt;portRect);  // recommended for cosmetic reasons  if (zoomDir == inZoomOut)     {    /*     *  ZoomWindow() is a good basic tool, but it doesn't do everything necessary to     *  implement a good human interface when zooming. In fact it's not even close for     *  more high-end hardware configurations. We must help it along by calculating an     *  appropriate window size and location any time a window zooms out.     */    {    RgnHandle  structRgn = NewRgn();        GetWindowStructureRgn(pWindow, structRgn);    windRect = &amp;(**structRgn).rgnBBox;    DisposeRgn(structRgn);    }    dominantGDevice = nil;    if (gMachineInfo.theEnvirons.hasColorQD)       {      /*       *  Color QuickDraw implies the possibility of multiple monitors. This is where       *  zooming becomes more interesting. One should zoom onto the monitor containing       *  the greatest portion of the window. This requires walking the gDevice list.       */      nthDevice = GetDeviceList();      greatestArea = 0;      while (nthDevice != nil)         {        if (TestDeviceAttribute(nthDevice, screenDevice))           {          if (TestDeviceAttribute(nthDevice, screenActive))             {            SectRect(windRect, &amp;(**nthDevice).gdRect, &amp;theSect);            sectArea = (long) RectWidth(theSect) * (long) RectHeight(theSect);            if (sectArea &gt; greatestArea)               {              greatestArea = sectArea;    // save the greatest intersection              dominantGDevice = nthDevice;  // and which device it belongs to              }            }          }        nthDevice = GetNextDevice(nthDevice);        }      }    /*     *  At this point, we know the dimensions of the window we're zooming, and we know     *  what screen we're going to put it on. To be more specific, however, we need a     *  rectangle which defines the maximum dimensions of the resized window's contents.     *  This rectangle accounts for the thickness of the window frame, the menu bar, and     *  one or two pixels around the edges for cosmetic compatibility with ZoomWindow().     */    if (dominantGDevice != nil)       {      dGDRect = (**dominantGDevice).gdRect;      if (dominantGDevice == GetMainDevice())    // account for menu bar on main device        dGDRect.top += GetMBarHeight();      }    else       {      dGDRect = qd.screenBits.bounds;        // if no gDevice, use default monitor      dGDRect.top += GetMBarHeight();      }    globalPortRect = GetWindowPort(pWindow)-&gt;portRect;    LocalToGlobal(&amp;TopLeft(globalPortRect));    // calculate the window's portRect    LocalToGlobal(&amp;BotRight(globalPortRect));    // in global coordinates    // account for the window frame and inset it a few pixels    dGDRect.left  += 2 + globalPortRect.left - windRect-&gt;left;    dGDRect.top    += 2 + globalPortRect.top - windRect-&gt;top;    dGDRect.right  -= 1 + windRect-&gt;right - globalPortRect.right;    dGDRect.bottom  -= 1 + windRect-&gt;bottom - globalPortRect.bottom;    /*     *  Now we know exactly what our limits are, and since there are input parameters     *  specifying the dimensions we'd like to see, we can move and resize the zoom     *  state rectangle for the best possible results. We have three goals in this:     *  1. Display the window entirely visible on a single device.     *  2. Resize the window to best represent the dimensions of the document itself.     *  3. Move the window as short a distance as possible to achieve #1 and #2.     */    zoomRect = &amp;(**(WStateDataHandle) ((WindowPeek) pWindow)-&gt;dataHandle).stdState;    /*     *  Initially set the zoom rectangle to the size requested by the input parameters,     *  although not smaller than a minimum size. We do this without moving the origin.     */    zoomRect-&gt;right = (zoomRect-&gt;left = globalPortRect.left) +                Max(hMax, kMinDocSize);    zoomRect-&gt;bottom = (zoomRect-&gt;top = globalPortRect.top) +                Max(vMax, kMinDocSize);    // Shift the entire rectangle if necessary to bring its origin inside dGDRect.    OffsetRect(zoomRect,          Max(dGDRect.left - zoomRect-&gt;left, 0),          Max(dGDRect.top - zoomRect-&gt;top, 0));    /*     *  Shift the rectangle up and/or to the left if necessary to accomodate the view,     *  and if it is possible to do so. The rectangle may not be moved such that its     *  origin would fall outside of dGDRect.     */    OffsetRect(zoomRect,          -Pin(zoomRect-&gt;right - dGDRect.right, 0, zoomRect-&gt;left - dGDRect.left),          -Pin(zoomRect-&gt;bottom - dGDRect.bottom, 0, zoomRect-&gt;top - dGDRect.top));    // Clip expansion to dGDRect, in case view is larger than dGDRect.    zoomRect-&gt;right = Min(zoomRect-&gt;right, dGDRect.right);    zoomRect-&gt;bottom = Min(zoomRect-&gt;bottom, dGDRect.bottom);    }  ZoomWindow(pWindow, zoomDir, pWindow == FrontWindow());    AdjustScrollBars(pWindow, true, true, nil);  InvalRect(&amp;GetWindowPort(pWindow)-&gt;portRect);    return noErr;  } // DoZoomWindow// --------------------------------------------------------------------------------------------------------------#pragma segment MainOSErr DoActivate(WindowRef pWindow, Boolean activating){  OSErr      anErr = noErr;  WindowDataPtr   pData = GetWindowInfo(pWindow);    SetPort((GrafPtr) GetWindowPort(pWindow));    if ( pData )    {    if (pData-&gt;pActivateEvent)      anErr = (*(pData-&gt;pActivateEvent)) (pWindow, pData, activating);          if (anErr == noErr)      {      if (activating)        {        // Reshow all controls on activation        if (pData-&gt;hScroll)          ShowControl(pData-&gt;hScroll);        if (pData-&gt;vScroll)          ShowControl(pData-&gt;vScroll);        }      else        {        // Hide all controls on deactivation        if (pData-&gt;hScroll)          HideControl(pData-&gt;hScroll);        if (pData-&gt;vScroll)          HideControl(pData-&gt;vScroll);        }              if (pData-&gt;hasGrow)         {        Rect  growIconRect;                CalculateGrowIcon(pData, &amp;growIconRect);        InvalRect(&amp;growIconRect);        }      }    }  AdjustMenus(pWindow, true, false);      return anErr;  } // DoActivate// --------------------------------------------------------------------------------------------------------------#pragma segment Mainstatic OSErr  DoStartupGX(void){  gxGraphicsError  anErr = noErr;    if (!gMachineInfo.haveStartedGX)    {    GXEnterGraphics();    GXGetGraphicsError(&amp;anErr);    if ( (anErr == noErr) &amp;&amp; (GXGetGraphicsClient() == nil) )      anErr = out_of_memory;    if (anErr == noErr)      {      anErr = GXInitPrinting();      if (anErr != noErr)        GXExitGraphics();      }          if (anErr != noErr)      GXSetGraphicsClient(nil);    }      if (GXGetGraphicsClient() == nil)    anErr = out_of_memory;  if (anErr == noErr)    gMachineInfo.haveStartedGX = true;  return anErr;  } // DoStartupGX// --------------------------------------------------------------------------------------------------------------#pragma segment MainOSErr  DoDefault(WindowDataPtr   pData){  OSErr  anErr = noErr;    if (gMachineInfo.haveGX)    {    // start up GX, if needed    anErr = DoStartupGX();    if (anErr == noErr)      {            // default the job if we don't have it      if (pData-&gt;hPrint == nil)        {        anErr = GXNewJob((gxJob*)&amp;pData-&gt;hPrint);        if (anErr == noErr)          {          GXInstallApplicationOverride(pData-&gt;hPrint, gxPrintingEventMsg,     gPrintingEventMessage);          GXInstallApplicationOverride(pData-&gt;hPrint, gxCompleteSpoolFileMsg,   gCompleteSpoolFileMessage);          }        }      }    }  else    {    PrOpen();    anErr = PrError();    if (anErr == noErr)      {      if (pData-&gt;hPrint == nil)        {        pData-&gt;hPrint = NewHandleClear(sizeof(TPrint));        anErr = MemError();        if (anErr == noErr)          PrintDefault(pData-&gt;hPrint);        }              }    PrClose();    }      return anErr;  } // DoDefault// --------------------------------------------------------------------------------------------------------------#pragma segment Mainstatic void SetupForPrintDialogs(gxEditMenuRecord * pEdit){  MenuHandle  menu;  short    menuID, itemID;  CommandToIDs(cCut,   &amp;pEdit-&gt;editMenuID, &amp;pEdit-&gt;cutItem);  CommandToIDs(cCopy,  &amp;pEdit-&gt;editMenuID, &amp;pEdit-&gt;copyItem);  CommandToIDs(cPaste, &amp;pEdit-&gt;editMenuID, &amp;pEdit-&gt;pasteItem);  CommandToIDs(cClear, &amp;pEdit-&gt;editMenuID, &amp;pEdit-&gt;clearItem);  CommandToIDs(cUndo,  &amp;pEdit-&gt;editMenuID, &amp;pEdit-&gt;undoItem);    // diable everything we don't want to deal with  for (menuID = mApple; menuID &lt;= mLastMenu; ++menuID)    {    menu = GetMenuHandle(menuID);        if (menu)      {      switch (menuID)        {        case mApple:          CommandToIDs(cAbout, &amp;menuID, &amp;itemID);          DisableItem(menu, itemID);          break;                  case mEdit:          CommandToIDs(cSelectAll, &amp;menuID, &amp;itemID);          DisableItem(menu, itemID);          CommandToIDs(cShowClipboard, &amp;menuID, &amp;itemID);          DisableItem(menu, itemID);          break;                  default:          DisableItem(menu, 0);          break;        }      }    }    // Disable the current indicator because the dialogs are moveable modal    HiliteMenu(0);    } // SetupForPrintDialogs// --------------------------------------------------------------------------------------------------------------#pragma segment MainOSErr  DoPageSetup(WindowRef pWindow){  OSErr      anErr = noErr;  WindowDataPtr   pData = GetWindowInfo(pWindow);      anErr = DoDefault(pData);  nrequire(anErr, DoDefault);    if (gMachineInfo.haveGX)    {    gxEditMenuRecord  theEdit;        SetupForPrintDialogs(&amp;theEdit);        GXJobDefaultFormatDialog(pData-&gt;hPrint, &amp;theEdit);    anErr = GXGetJobError(pData-&gt;hPrint);          AdjustMenus(pWindow, true, true);    }  else    {    PrOpen();    anErr = PrError();    if (anErr == noErr)      {      SetCursor(&amp;qd.arrow);      PrStlDialog(pData-&gt;hPrint);      }    PrClose();    }// FALL THROUGH EXCEPTION HANDLINGDoDefault:      return anErr;  } // DoPageSetup// --------------------------------------------------------------------------------------------------------------#pragma segment Mainstatic OSErr  DoPrintSetup(WindowRef pWindow, StringPtr pPrinterName){  OSErr      anErr = noErr;  WindowDataPtr   pData = GetWindowInfo(pWindow);      anErr = DoDefault(pData);  nrequire(anErr, DoDefault);    if (gMachineInfo.haveGX)    {    gxEditMenuRecord  theEdit;    gxDialogResult    result;        // toss any previous errors that might be around    (void)GXGetJobError(pData-&gt;hPrint);        if ( (pPrinterName) &amp;&amp; (pPrinterName[0] != 0) )      GXSelectJobOutputPrinter(pData-&gt;hPrint, pPrinterName);    else      {      SetupForPrintDialogs(&amp;theEdit);      result = GXJobPrintDialog(pData-&gt;hPrint, &amp;theEdit);      AdjustMenus(pWindow, true, true);      }    if (anErr == noErr)      {      anErr = GXGetJobError(pData-&gt;hPrint);      if ( (anErr == noErr) &amp;&amp; (result == gxCancelSelected) )        anErr = eUserCanceled;      }    }  else    {    PrOpen();    anErr = PrError();    if (anErr == noErr)      {      SetCursor(&amp;qd.arrow);      if (PrJobDialog(pData-&gt;hPrint) == false)        anErr = eUserCanceled;      }          PrClose();    }    // FALL THROUGH EXCEPTION HANDLINGDoDefault:      return anErr;  } // DoPrintSetup// --------------------------------------------------------------------------------------------------------------#pragma segment Mainstatic OSErr  DoPrint(WindowRef pWindow, void * hPrint, Boolean oneCopy){  gxGraphicsError    anErr = noErr;  WindowDataPtr     pData = GetWindowInfo(pWindow);  Boolean        didAllocate = false;    // use a watch cursor while printing  SetWatchCursor();    if (gMachineInfo.haveGX)    {    // startup GX, if needed    anErr = DoStartupGX();    if ( (anErr == noErr) &amp;&amp; (hPrint == nil) )      {      anErr = GXNewJob((gxJob*)&amp;hPrint);      if (anErr == noErr)              {        GXInstallApplicationOverride(hPrint, gxPrintingEventMsg,     gPrintingEventMessage);        GXInstallApplicationOverride(hPrint, gxCompleteSpoolFileMsg,   gCompleteSpoolFileMessage);        didAllocate = true;        }      }    if (anErr == noErr)      {            Str255  docName;            if (oneCopy)        {        gxCopiesInfo theCopies;                theCopies.copies = 1;        AddCollectionItem(GXGetJobCollection(hPrint), gxCopiesTag, gxPrintingTagID, sizeof(theCopies), &amp;theCopies);        }              GXSetJobRefCon(hPrint, pData);            GetWTitle(pWindow, docName);      GXStartJob(hPrint, docName, 0);      anErr = GXGetJobError(hPrint);      if (anErr == noErr)        {        long    first, last, pageIndex;        Rect    pageRect;        CGrafPort  thePort;                // determine size of page, and number of pages        {        gxRectangle  pageSize;        GXGetFormatDimensions(GXGetJobFormat(hPrint, 1), &amp;pageSize, nil);        pageRect.top  = pageSize.top &gt;&gt; 16;        pageRect.left  = pageSize.left &gt;&gt; 16;        pageRect.bottom  = pageSize.bottom &gt;&gt; 16;        pageRect.right  = pageSize.right &gt;&gt; 16;        }              GXGetJobPageRange(hPrint, &amp;first, &amp;last);        anErr = GXGetJobError(hPrint);        if (first &lt; 1)          first = 1;        if (last &lt; first)          last = first;                  if (anErr == noErr)          {          // make a port to perform translation in          OpenCPort(&amp;thePort);                    for (pageIndex = first; pageIndex &lt;= last; ++pageIndex)            {            SetPort((GrafPtr) &amp;thePort);                        if (pData-&gt;documentOutputsGX)              anErr = (*(pData-&gt;pPrintPage)) (pWindow, pData, &amp;pageRect, &amp;pageIndex);            else              {              Point          patStretch = {1,1};              gxTranslationOption   options = gxOptimizedTranslation;              CatchRefCon        theRefCon;                            if (GXGetPrinterDriverType(GXGetJobPrinter(hPrint)) == 'post')                options += gxPostScriptTargetTranslation;              else                options += gxRasterTargetTranslation;                            theRefCon.theJob          = hPrint;              theRefCon.doLayout          = (pData-&gt;originalFileType == 'TEXT');              theRefCon.thePage           = GXNewShape(gxPictureType);              theRefCon.thePageRectangle.top     = ff(pageRect.top);              theRefCon.thePageRectangle.left   = ff(pageRect.left);              theRefCon.thePageRectangle.bottom   = ff(pageRect.bottom);              theRefCon.thePageRectangle.right   = ff(pageRect.right);                GXInstallQDTranslator(                    qd.thePort,                    options,                    &amp;pageRect,                    &amp;pageRect,                    patStretch,                    gSimpleCatchShape,                    &amp;theRefCon);              GXGetGraphicsError(&amp;anErr);                            if (anErr == noErr)                {                long  whichPage = pageIndex;                                anErr = (*(pData-&gt;pPrintPage)) (pWindow, pData, &amp;pageRect, &amp;whichPage);                GXRemoveQDTranslator(qd.thePort, nil);                                GXPrintPage(hPrint, pageIndex, nil, theRefCon.thePage);                anErr = GXGetJobError(hPrint);                pageIndex = whichPage;                }                            GXDisposeShape(theRefCon.thePage);              }                        if (anErr == noErr)              GXGetGraphicsError(&amp;anErr);                        // bail when we are told to stop            if ( (pageIndex == -1) || (anErr != noErr) )              break;            }                    // all done with our temp port and job          CloseCPort(&amp;thePort);          }                  GXFinishJob(hPrint);        if (anErr == noErr) anErr = GXGetJobError(hPrint);        }              }            if (didAllocate)      GXDisposeJob(hPrint);    // restore those menus!    AdjustMenus(pWindow, true, true);    }  else    {    TPPrPort  printingPort;        PrOpen();    anErr = PrError();    if (anErr == noErr)      {      if (hPrint == nil)        {        hPrint = NewHandleClear(sizeof(TPrint));        anErr = MemError();        if (anErr == noErr)          {          PrintDefault(hPrint);          didAllocate = true;          }        }            if (anErr == noErr)        {        short  firstPage, lastPage;                // be sure to get the page range BEFORE calling PrValidate(),         // which blows it away for many drivers.        firstPage = (**(THPrint)hPrint).prJob.iFstPage;        lastPage = (**(THPrint)hPrint).prJob.iLstPage;                // make sure the print record is cool to use        PrValidate(hPrint);        // then clear out the job itself -- some drivers don't        // do this from within PrValidate().  We want the job        // clear in case the driver bases background behavior        // from this range (and many do).        (**(THPrint)hPrint).prJob.iFstPage = 1;        (**(THPrint)hPrint).prJob.iLstPage = 9999;                if (oneCopy)          (** ((THPrint)hPrint)).prJob.iCopies = 1;                  // start printing, and then loop over the pages        printingPort = PrOpenDoc(hPrint, nil, nil);        anErr = PrError();        if (anErr == noErr)          {          long  pageIndex;          Rect  pageRect;                    SetPort((GrafPtr) printingPort);                    pageRect = (**(THPrint)hPrint).prInfo.rPage;          if (firstPage &lt; 1)            firstPage = 1;          if (lastPage &lt; firstPage)            lastPage = firstPage;          for (pageIndex = firstPage; pageIndex &lt;= lastPage; ++pageIndex)            {            PrOpenPage(printingPort, nil);            anErr = PrError();            if (anErr == noErr)              anErr = (*(pData-&gt;pPrintPage)) (pWindow, pData, &amp;pageRect, &amp;pageIndex);                          PrClosePage(printingPort);            if (anErr == noErr)              anErr = PrError();            if ( (anErr != noErr) || (pageIndex == -1) )              break;            }          }                  // Finish up printing of the document        PrCloseDoc(printingPort);        if (anErr == noErr)          anErr = PrError();        if ( (anErr == noErr) &amp;&amp; ((**(THPrint)hPrint).prJob.bJDocLoop == bSpoolLoop) )          {          TPrStatus  theStatus;                    PrPicFile(hPrint, nil, nil, nil, &amp;theStatus);          anErr = PrError();          }        }              if (didAllocate)        DisposeHandle((Handle) hPrint);              }    PrClose();    }        // restore cursor  SetCursor(&amp;qd.arrow);  return anErr;  } // DoPrint// --------------------------------------------------------------------------------------------------------------#pragma segment MainOSErr  DoCommand(WindowRef pWindow, short commandID, long menuResult){  OSErr      anErr = noErr;  WindowDataPtr   pData = nil;    if (pWindow)    {    pData = (WindowDataPtr) GetWindowInfo(pWindow);        if ( (pData) &amp;&amp; (pData-&gt;pCommand) )      anErr = (*(pData-&gt;pCommand)) (pWindow, pData, commandID, menuResult);    }    if (anErr == noErr)    {    // default command handling    switch (commandID)      {      // About box command      case cAbout:        if (!BringToFrontIfExists(kAboutWindow))          anErr = MakeNewWindow(kAboutWindow, nil, '????', nil);        break;              case cDeskAccessory:        {        Str255  tempString;                GetMenuItemText(GetMenuHandle(menuResult&gt;&gt;16), menuResult &amp; 0xFFFF, tempString);        OpenDeskAcc(tempString);        }        break;              // New window command      case cNew:        anErr = MakeNewWindow(kTextWindow, nil, 'TEXT', nil);        break;              // Open window command      case cOpen:        anErr = DoOpenWindow();        break;              // Close window command      case cClose:        anErr = DoCloseWindow(pWindow);        break;              case cPageSetup:        anErr = DoPageSetup(pWindow);        break;              case cPrint:        anErr = DoPrintSetup(pWindow, nil);        if (anErr == noErr)          anErr = DoPrint(pWindow, pData-&gt;hPrint, false);        break;              case cPrintOneCopy:        anErr = DoPrint(pWindow, pData-&gt;hPrint, true);        break;              // get out of here command!      case cQuit:        gAllDone = true;        break;        // show/hide clipboard      case cShowClipboard:        if (!BringToFrontIfExists(kClipboardWindow))          {          anErr = MakeNewWindow(kClipboardWindow, nil, '????', nil);          }        else          {          pWindow = FrontWindow();          anErr = DoCloseWindow(pWindow);          }        break;              case cNextPage:        gEvent.what = keyDown;        gEvent.message = kPageDown &lt;&lt; 8;        gEvent.modifiers = 0;        DoKeyEvent(pWindow, &amp;gEvent, false);        break;              case cPreviousPage:        gEvent.what = keyDown;        gEvent.message = kPageUp &lt;&lt; 8;        gEvent.modifiers = 0;        DoKeyEvent(pWindow, &amp;gEvent, false);        break;              // Do nothing command      case cNull:        break;                    default:        break;      }    }      // don't report cancels  if ( (anErr == iPrAbort) || (anErr == gxPrUserAbortErr) )    anErr = noErr;    // some errors map to other errors because they are basically the same  // This way we can use the same string.  if (anErr == out_of_memory)    anErr = memFullErr;      if ( (anErr != noErr) &amp;&amp; (anErr != eActionAlreadyHandled) &amp;&amp; (anErr != eUserCanceled) )    {    // some commands are so similar to other commands that we map their IDs    // for the purposes of the error strings    if (commandID == cSaveAs)      commandID = cSave;    if (commandID == cPrintOneCopy)      commandID = cPrint;          ConductErrorDialog(anErr, commandID, cancel);    }      // in any case, unhilite the menu selected after command processing is done    HiliteMenu(0);    return anErr;  } // DoCommand// --------------------------------------------------------------------------------------------------------------#pragma segment Mainstatic OSErr  DoMenuCommand(WindowRef pWindow, long menuResult){  OSErr  anErr = noErr;  short  commandID = cNull;  short  ** commandHandle;  short  menuID = menuResult &gt;&gt; 16;    if (menuID == kHMHelpMenuID)    {    // close existing database (if any)    if ((gAGRefNum != -1) &amp;&amp; AGIsDatabaseOpen(gAGRefNum))      {      AGClose(&amp;gAGRefNum);      gAGRefNum = -1;      }          // and open the database we have found in the past    AGOpen(&amp;gAGSpec, 0, nil, &amp;gAGRefNum);    }  else    {    if (menuID &gt;= mFontSubMenusStart)      {      commandID = cSelectFontStyle;      }    else      {      // read in the resource that controls this menu        {        short  oldResFile = CurResFile();                UseResFile(gApplicationResFile);        commandHandle = (short**) Get1Resource('MCMD', menuID);        UseResFile(oldResFile);        anErr = ResError();        nrequire(anErr, FailedToLoadCommandTable);        }            if (commandHandle)        {        short  item = menuResult &amp; 0xFFFF;        short  * pCommands = *commandHandle;                if (item &lt;= pCommands[0])          commandID = pCommands[item];        else          commandID = pCommands[pCommands[0]];        }      }        anErr = DoCommand(pWindow, commandID, menuResult);    }  // FALL THROUGH EXCEPTION HANDLINGFailedToLoadCommandTable:  return anErr;  } // DoMenuCommand// --------------------------------------------------------------------------------------------------------------#pragma segment Mainstatic void DoKeyPageDown(WindowRef pWindow, WindowDataPtr pData, Boolean processPageControls){  if (GetControlValue(pData-&gt;vScroll) &lt; GetControlMaximum(pData-&gt;vScroll))    VActionProc(pData-&gt;vScroll, kControlPageDownPart);  else    {    if ( (processPageControls) &amp;&amp; (IsCommandEnabled(cNextPage)) )      {      short amount;      if (DoCommand(pWindow, cNextPage, 0) == eActionAlreadyHandled)        {        amount = GetControlValue(pData-&gt;vScroll);        SetControlAndClipAmount(pData-&gt;vScroll, &amp;amount);        if (amount != 0)          DoScrollContent(pWindow, pData, 0, amount);        }            AdjustMenus(pWindow, true, false);      }    }  } // DoKeyPageDown// --------------------------------------------------------------------------------------------------------------#pragma segment Mainstatic void DoKeyPageUp(WindowRef pWindow, WindowDataPtr pData, Boolean processPageControls){  if (GetControlValue(pData-&gt;vScroll) &gt; GetControlMinimum(pData-&gt;vScroll))    VActionProc(pData-&gt;vScroll, kControlPageUpPart);  else    {    if ( (processPageControls) &amp;&amp; (IsCommandEnabled(cPreviousPage)) )      {      short amount;            if (DoCommand(pWindow, cPreviousPage, 0) == eActionAlreadyHandled)        {        amount = -(GetControlMaximum(pData-&gt;vScroll)-GetControlValue(pData-&gt;vScroll));        SetControlAndClipAmount(pData-&gt;vScroll, &amp;amount);        if (amount != 0)          DoScrollContent(pWindow, pData, 0, amount);        }            AdjustMenus(pWindow, true, false);      }    }    } // DoKeyPageUp// --------------------------------------------------------------------------------------------------------------#pragma segment MainOSErr  DoKeyEvent(WindowRef pWindow, EventRecord * pEvent, Boolean processPageControls){  OSErr      anErr = noErr;  WindowDataPtr   pData = nil;  Boolean      passToObject = false;  Boolean     isMotionKey = false;  long      menuResult = 0;    char keyCode = (pEvent-&gt;message &gt;&gt; 8) &amp; charCodeMask;  if ( pEvent-&gt;modifiers &amp; cmdKey )      /* Command key down */    {    AdjustMenus(pWindow, true, false);    menuResult = MenuKey(pEvent-&gt;message &amp; charCodeMask);    DoMenuCommand(pWindow, menuResult);    pWindow = FrontWindow();    }  if (menuResult == 0)    {    if (pWindow)      {      pData = (WindowDataPtr)GetWindowInfo(pWindow);      if ( (pData) &amp;&amp; (pData-&gt;pKeyEvent) )        passToObject = true;      SetPort((GrafPtr) GetWindowPort(pWindow));      }          if (pData)      {      switch (keyCode)        {        case kHome: // top of file          isMotionKey = true;          if (pData-&gt;vScroll)            {            short amount;                        if ( (processPageControls) &amp;&amp; (IsCommandEnabled(cGotoPage)) )              DoCommand(pWindow, cGotoPage, cGotoFirst);            amount = GetControlValue(pData-&gt;vScroll);            SetControlAndClipAmount(pData-&gt;vScroll, &amp;amount);            if (amount != 0)              DoScrollContent(pWindow, pData, 0, amount);            passToObject = false;            }          break;                  case kEnd: // end of file          isMotionKey = true;          if (pData-&gt;vScroll)            {            short amount;            if ( (processPageControls) &amp;&amp; (IsCommandEnabled(cGotoPage)) )              DoCommand(pWindow, cGotoPage, cGotoLast);                          amount = -(GetControlMaximum(pData-&gt;vScroll)-GetControlValue(pData-&gt;vScroll));            SetControlAndClipAmount(pData-&gt;vScroll, &amp;amount);            if (amount != 0)              DoScrollContent(pWindow, pData, 0, amount);            passToObject = false;            }          break;                  case kPageUp: // scroll bar page up          isMotionKey = true;          if (pData-&gt;vScroll)            {            DoKeyPageUp(pWindow, pData, processPageControls);            passToObject = false;            }          break;                  case kPageDown: // scroll bar page down          isMotionKey = true;          if (pData-&gt;vScroll)            {            DoKeyPageDown(pWindow, pData, processPageControls);            passToObject = false;            }          break;                      case kUpArrow:    // scroll bar up arrow          isMotionKey = true;          if ( (pData-&gt;vScroll) &amp;&amp; (!pData-&gt;pKeyEvent) )            {            if ( pEvent-&gt;modifiers &amp; cmdKey )      /* Command key down */              DoKeyPageUp(pWindow, pData, processPageControls);            else              VActionProc(pData-&gt;vScroll, kControlUpButtonPart);            passToObject = false;            }          break;                  case kDownArrow:  // scroll bar down arrow          isMotionKey = true;          if ( (pData-&gt;vScroll) &amp;&amp; (!pData-&gt;pKeyEvent) )            {            if ( pEvent-&gt;modifiers &amp; cmdKey )      /* Command key down */              DoKeyPageDown(pWindow, pData, processPageControls);            else              VActionProc(pData-&gt;vScroll, kControlDownButtonPart);            passToObject = false;            }          break;            case kLeftArrow:  // scroll bar left arrow          isMotionKey = true;          if ( (pData-&gt;hScroll) &amp;&amp; (!pData-&gt;pKeyEvent) )            {            if ( pEvent-&gt;modifiers &amp; cmdKey )      /* Command key down */              HActionProc(pData-&gt;hScroll, kControlPageUpPart);            else              HActionProc(pData-&gt;hScroll, kControlUpButtonPart);            passToObject = false;            }          break;                  case kRightArrow:  // scroll bar right arrow          isMotionKey = true;          if ( (pData-&gt;hScroll) &amp;&amp; (!pData-&gt;pKeyEvent) )            {            if ( pEvent-&gt;modifiers &amp; cmdKey )      /* Command key down */              HActionProc(pData-&gt;hScroll, kControlPageDownPart);            else              HActionProc(pData-&gt;hScroll, kControlDownButtonPart);            passToObject = false;            }          break;          }          if (passToObject)        anErr = (*(pData-&gt;pKeyEvent)) (pWindow, pData, pEvent, isMotionKey);      else        {        if ( (pData-&gt;documentAcceptsText == false) &amp;&amp; !( pEvent-&gt;modifiers &amp; cmdKey ) &amp;&amp; !(isMotionKey) )          anErr = eDocumentNotModifiable;        }      }    if ( (anErr != noErr) &amp;&amp; (anErr != eActionAlreadyHandled) )      ConductErrorDialog(anErr, cTypingCommand, ok);          } // (menuResult == 0)        return anErr;  } // DoKeyEvent// --------------------------------------------------------------------------------------------------------------#pragma segment Mainstatic OSErr DoAdjustCursor(WindowRef pWindow){  OSErr    anErr = noErr;  Point    mouse;  Boolean    didAdjust = false;    if (pWindow)    {    // not one of our windows?  don't do anything    if (GetWindowKind(pWindow) != userKind)      didAdjust = true;          SetPort((GrafPtr) GetWindowPort(pWindow));        if ( (!didAdjust) &amp;&amp; (gMachineInfo.haveTSM) )      {      GetMouse(&amp;mouse);      LocalToGlobal(&amp;mouse);      if (SetTSMCursor(mouse))        didAdjust = true;      }          if (!didAdjust)      {      WindowDataPtr  pData = GetWindowInfo(pWindow);      RgnHandle    content = NewRgn();      Point      globalMouse;            GetMouse(&amp;mouse);      globalMouse = mouse;      LocalToGlobal(&amp;globalMouse);            GetWindowContentRgn(pWindow, content);      if ((pData) &amp;&amp; (PtInRgn(globalMouse, content)) &amp;&amp; (PtInRect(mouse, &amp;pData-&gt;contentRect)))        {        Rect      tempRect;                tempRect = pData-&gt;contentRect;        LocalToGlobal(&amp;TopLeft(tempRect));        LocalToGlobal(&amp;BotRight(tempRect));                if (pData-&gt;pAdjustCursor)          anErr = (*(pData-&gt;pAdjustCursor)) (pWindow, pData, &amp;mouse, &amp;tempRect);          RectRgn(gCursorRgn, &amp;tempRect);        }      DisposeRgn(content);      }    else      anErr = eActionAlreadyHandled;    }    // nobody set the cursor, we do it ourselves  if (anErr != eActionAlreadyHandled)    SetCursor(&amp;qd.arrow);      return anErr;  } // DoAdjustCursor // --------------------------------------------------------------------------------------------------------------#pragma segment Mainstatic long DetermineWaitTime(WindowRef pWindow){  long  waitTime = kMaxWaitTime;    while (pWindow)    {    long      newWaitTime;    WindowDataPtr  pData = GetWindowInfo(pWindow);        if ((pData) &amp;&amp; (pData-&gt;pCalculateIdleTime))      newWaitTime = (*(pData-&gt;pCalculateIdleTime)) (pWindow, pData);    else      newWaitTime = kMaxWaitTime;        if (newWaitTime &lt; waitTime)      waitTime = newWaitTime;          pWindow = GetNextWindow(pWindow);    }    return(waitTime);  } // DetermineWaitTime// --------------------------------------------------------------------------------------------------------------#pragma segment Mainvoid HandleEvent(EventRecord * pEvent){  WindowRef pWindow = FrontWindow();    switch (pEvent-&gt;what)    {    case kHighLevelEvent:      AEProcessAppleEvent(pEvent);      break;          case osEvt:      switch ((pEvent-&gt;message &gt;&gt; 24) &amp; 0xFF) /* high byte of message */        {            case mouseMovedMessage:          DoAdjustCursor(pWindow);          break;                  case suspendResumeMessage:    /* suspend/resume is also an activate/deactivate */          gMachineInfo.amInBackground = (pEvent-&gt;message &amp; 1) == 0;          if (pWindow)            DoActivate(pWindow, !gMachineInfo.amInBackground);                      // on resume, we must call GXUpdateJob for all active jobs in          // order to get instant activation of extensions and to properly          // handle potential shifting of driver names          if ( (gMachineInfo.haveGX) &amp;&amp; (!gMachineInfo.amInBackground) )            {            WindowRef  walkWindows = pWindow;                        while (walkWindows)              {              WindowDataPtr  pData = GetWindowInfo(walkWindows);              if (pData)                {                gxJob  theJob = pData-&gt;hPrint;                if (theJob)                  {                  GXUpdateJob(theJob);                  }                }              walkWindows = GetNextWindow(walkWindows);              }            }          break;        }      break;          case activateEvt:      pWindow = (WindowRef) pEvent-&gt;message;      DoActivate(pWindow, (pEvent-&gt;modifiers &amp; activeFlag) != 0);      break;                  // disk inserted events must be handled, or uninitialized floppies     // won't be recognized.    case diskEvt:      if ( HiWord(pEvent-&gt;message) != noErr )         {        Point  where;              SetPt(&amp;where, 70, 50);        ShowCursor();        (void) DIBadMount(where, pEvent-&gt;message);        }          break;            case mouseUp:      break;          case mouseDown:      {      short part = FindWindow(pEvent-&gt;where, &amp;pWindow);                      switch ( part )         {        case inContent:          if (pWindow != FrontWindow())            SelectWindow(pWindow);          else            DoContentClick(pWindow);          break;                  case inGoAway:          if (TrackGoAway(pWindow, pEvent-&gt;where) )            DoCommand(pWindow, cClose, 0);          break;                  case inGrow:          DoGrowWindow(pWindow, pEvent);          break;                  case inZoomIn:        case inZoomOut:          if ( TrackBox(pWindow, pEvent-&gt;where, part) )            DoZoomWindow(pWindow, part);          break;                  case inDrag:          {          WindowDataPtr  pData = GetWindowInfo(pWindow);                    if ( (pData) &amp;&amp; (pData-&gt;dragWindowAligned) )            DragAlignedWindow((WindowPtr) pWindow, pEvent-&gt;where, &amp;qd.screenBits.bounds, nil, nil);          else            DragWindow(pWindow, pEvent-&gt;where, &amp;qd.screenBits.bounds);          }          break;                  case inMenuBar:        /* process a mouse menu command (if any) */          {          long  menuResult;                    // force these threads to run to completion so the          // contents of the menus are fully initialized                    if (gFontThread != kNoThreadID)            {            gDontYield = true;            SetThreadState(gFontThread, kReadyThreadState, gFontThread);            YieldToThread(gFontThread);            gDontYield = false;            }          if (gAGThread != kNoThreadID)            {            gDontYield = true;            SetThreadState(gAGThread, kReadyThreadState, gAGThread);            YieldToThread(gAGThread);            gDontYield = false;            }                    pWindow = FrontWindow();          AdjustMenus(pWindow, true, false);          menuResult = MenuSelect(pEvent-&gt;where);          if ( (gMachineInfo.haveTSM) &amp;&amp; (TSMMenuSelect(menuResult)) )            HiliteMenu(0);          else            DoMenuCommand(pWindow, menuResult);          }          break;                  case inSysWindow:      /* let the system handle the mouseDown */          SystemClick(pEvent, pWindow);          break;                  } // switch(part)      }      break;          case keyDown:    case autoKey:            /* check for menukey equivalents */      DoKeyEvent(pWindow, pEvent, true);      break;          case updateEvt:      pWindow = (WindowRef) pEvent-&gt;message;      DoUpdateWindow(pWindow);      break;    } // switch (pEvent-&gt;what)  } // HandleEvent// --------------------------------------------------------------------------------------------------------------#pragma segment Mainstatic OSErr  DoEventLoop(void){  OSErr    anErr = noErr;  Boolean    gotEvent;  Boolean    trueGotEvent;  WindowRef  pWindow;    do   {    pWindow = LMGetFirstWindow();    // walk all of our windows, even invisible ones        DoAdjustCursor(pWindow);    gotEvent = WaitNextEvent(everyEvent, &amp;gEvent, DetermineWaitTime(pWindow), gCursorRgn);    trueGotEvent = gotEvent;    // WNE may close the window if it's owned by some silly extension.    pWindow = LMGetFirstWindow();            // let text services handle the event first if it wishes to do so    if ( gMachineInfo.haveTSM )      {      ScriptCode  keyboardScript;      WindowRef  theFront = FrontWindow();            if (theFront)        {        SetPort((GrafPtr) GetWindowPort(theFront));                keyboardScript = GetScriptManagerVariable(smKeyScript);        if (FontToScript(qd.thePort-&gt;txFont) != keyboardScript)          TextFont(GetScriptVariable(keyboardScript, smScriptAppFond));        }            if (TSMEvent(&amp;gEvent))        gotEvent = false;      }          // let all windows filter this event, and get time if they wish to    while (pWindow)      {      WindowDataPtr  pData = GetWindowInfo(pWindow);      Boolean      finishedEvent = false;            // help manager for the front window      if ( (pWindow == FrontWindow()) &amp;&amp; (pData) &amp;&amp; (!gMachineInfo.amInBackground) &amp;&amp; (HMGetBalloons()) )        {        Point  theMouse, tipLocation;        short  newBalloon = iNoBalloon;        Rect  tempRect;                // find out where the mouse is                SetPort((GrafPtr) GetWindowPort(pWindow));        GetMouse(&amp;theMouse);                // and only do something if we are within the window itself        if (PtInRect(theMouse, &amp;GetWindowPort(pWindow)-&gt;portRect))          {          // is it in the vertical scroll bar?          if (pData-&gt;vScroll)            {            tempRect = (**(pData-&gt;vScroll)).contrlRect;            if (PtInRect(theMouse, &amp;tempRect))              {              newBalloon = iHelpActiveScroll;              if (GetControlMinimum(pData-&gt;vScroll) == GetControlMaximum(pData-&gt;vScroll))                newBalloon = iHelpDimVertScroll;              tipLocation.h = tempRect.right - kFromBottomTipOffset;              tipLocation.v = tempRect.bottom - kFromBottomTipOffset;              }            }                      // is it in the horizontal scroll bar?          if (pData-&gt;hScroll)            {            tempRect = (**(pData-&gt;hScroll)).contrlRect;            if (PtInRect(theMouse, &amp;tempRect))              {              newBalloon = iHelpActiveScroll;              if (GetControlMinimum(pData-&gt;hScroll) == GetControlMaximum(pData-&gt;hScroll))                newBalloon = iHelpDimHorizScroll;              tipLocation.h = tempRect.right - kFromBottomTipOffset;              tipLocation.v = tempRect.bottom - kFromBottomTipOffset;              }            }                    // is it in the grow box?          if (pData-&gt;hasGrow)            {            CalculateGrowIcon(pData, &amp;tempRect);            if (PtInRect(theMouse, &amp;tempRect))              {              newBalloon = iHelpGrowBox;              tipLocation.h = tempRect.right - kFromBottomTipOffset;              tipLocation.v = tempRect.bottom - kFromBottomTipOffset;              }            }                    // none of the above, must be the content          if (newBalloon == iNoBalloon)            {            newBalloon = iHelpGenericContent;            tempRect = pData-&gt;contentRect;            if (pData-&gt;pGetBalloon)              (*(pData-&gt;pGetBalloon)) (pWindow, pData, &amp;theMouse, &amp;newBalloon, &amp;tempRect);                          tipLocation.h = tempRect.left + kFromTopTipOffset;            tipLocation.v = tempRect.top + kFromTopTipOffset;            }                      // show our new balloon, or remove the old one          if (newBalloon != iNoBalloon)            {            if ( (gMachineInfo.lastBalloonIndex != newBalloon) || (!HMIsBalloon()) )              {              HMMessageRecord  message;                            if (newBalloon != iDidTheBalloon)                {                message.hmmHelpType = khmmString;                GetIndString(message.u.hmmString, kWindowHelpID, newBalloon);                LocalToGlobal(&amp;tipLocation);                (void) HMShowBalloon(&amp;message, tipLocation, nil, nil, 0, kDefaultBalloonVariant, 0);                }              gMachineInfo.lastBalloonIndex = newBalloon;              }            }          else            HMRemoveBalloon();          }                            }              // if we hit a window we know about, then do filtering      if (pData)        {        if (pData-&gt;pFilterEvent)          finishedEvent = (*(pData-&gt;pFilterEvent)) (pWindow, pData, &amp;gEvent);        }      // if filtering indicates complete handling of event, then stop, and      // do no regular processing.      if (finishedEvent)        {        gotEvent = false;        pWindow = nil;        }      else        pWindow = GetNextWindow(pWindow);      }          if (gotEvent)      HandleEvent(&amp;gEvent);          // close request?    if (gAllDone)      {      pWindow = FrontWindow();      while ((gAllDone) &amp;&amp; (pWindow) )        {        WindowRef  nextWindow = GetNextWindow(pWindow);        OSErr    closeError = DoCloseWindow(pWindow);                // window didn't close?  then don't quit        if (pWindow == FrontWindow())          gAllDone = false;                  // something bad happened, then don't quit        if ( (closeError != noErr) /* &amp;&amp; (closeError != eUserCanceled) */ )          gAllDone = false;                  pWindow = nextWindow;        }      }        // our threads are low-priority, so we only give time to them on idle    if (gMachineInfo.haveThreads &amp;&amp; !trueGotEvent &amp;&amp; !gAllDone)      YieldToAnyThread();        } while (!gAllDone);      return anErr;  } // DoEventLoop// --------------------------------------------------------------------------------------------------------------// DRAG MANAGEMENT GLOBAL SUPPORT ROUTINES// --------------------------------------------------------------------------------------------------------------// Globals for our drag handlersBoolean        gCanAccept;        // if we can receive the item(s) being dragged// --------------------------------------------------------------------------------------------------------------#pragma segment Dragstatic pascal OSErr GlobalTrackingHandler(short message, WindowRef pWindow, void *handlerRefCon, DragReference theDragRef){  #pragma unused(handlerRefCon)  WindowDataPtr pData = GetWindowInfo(pWindow);  // Call the tracking handler associated with this type of window. Only allow messages referencing  // a specific window to be passed to the handler.  if (pData)    {      if (pData-&gt;pDragTracking)      return ((*(pData-&gt;pDragTracking)) (pWindow, pData, theDragRef, message));    }    return noErr;} // GlobalTrackingHandlerDragTrackingHandlerUPP gGlobalTrackingHandler;// --------------------------------------------------------------------------------------------------------------#pragma segment Dragstatic pascal OSErr GlobalReceiveHandler(WindowRef pWindow, void *handlerRefCon, DragReference theDragRef){  #pragma unused(handlerRefCon)  WindowDataPtr pData = GetWindowInfo(pWindow);    if (pData)    {    if (pData-&gt;pDragTracking)      return ((*(pData-&gt;pDragReceive)) (pWindow, pData, theDragRef));    }  return noErr;} // GlobalReceiveHandlerDragReceiveHandlerUPP gGlobalReceiveHandler;// --------------------------------------------------------------------------------------------------------------//// IsOnlyThisFlavor - Given a DragReference and a FlavorType, we iterate through the drag items to determine if//            all are of flavor theType. If this is so, we return true. If any of the items are not//            theType, we return false, indicating that we should not accept the drag.//#pragma segment DragBoolean IsOnlyThisFlavor(DragReference theDragRef, FlavorType theType){  unsigned short  items, index;  FlavorFlags    theFlags;  ItemReference  itemID;  OSErr      anErr = noErr;  CountDragItems(theDragRef, &amp;items);    for(index = 1; index &lt;= items; index++)    {    GetDragItemReferenceNumber(theDragRef, index, &amp;itemID);    anErr = GetFlavorFlags(theDragRef, itemID, theType, &amp;theFlags);        if(anErr == noErr)      continue;  // it's okay, this flavor is cool    return false;  // this item has at least one flavor we don't like    }  return true;    // all flavors in this item were cool} // IsOnlyThisFlavor// --------------------------------------------------------------------------------------------------------------//// IsDropInFinderTrash - Returns true if the given dropLocation AEDesc is a descriptor of the Finder's Trash.//#pragma segment DragBoolean IsDropInFinderTrash(AEDesc *dropLocation){  OSErr      result;  AEDesc      dropSpec;  FSSpec      *theSpec;  CInfoPBRec    thePB;  short      trashVRefNum;  long      trashDirID;  //  Coerce the dropLocation descriptor into an FSSpec. If there's no dropLocation or  //  it can't be coerced into an FSSpec, then it couldn't have been the Trash.  if ((dropLocation-&gt;descriptorType != typeNull) &amp;&amp;    (AECoerceDesc(dropLocation, typeFSS, &amp;dropSpec) == noErr))     {    unsigned char flags = HGetState(dropSpec.dataHandle);        HLock(dropSpec.dataHandle);    theSpec = (FSSpec *) *dropSpec.dataHandle;    //  Get the directory ID of the given dropLocation object.    thePB.dirInfo.ioCompletion = 0L;    thePB.dirInfo.ioNamePtr = (StringPtr) &amp;theSpec-&gt;name;    thePB.dirInfo.ioVRefNum = theSpec-&gt;vRefNum;    thePB.dirInfo.ioFDirIndex = 0;    thePB.dirInfo.ioDrDirID = theSpec-&gt;parID;    result = PBGetCatInfoSync(&amp;thePB);    HSetState(dropSpec.dataHandle, flags);    AEDisposeDesc(&amp;dropSpec);    if (result != noErr)      return false;    //  If the result is not a directory, it must not be the Trash.    if (!(thePB.dirInfo.ioFlAttrib &amp; (1 &lt;&lt; 4)))      return false;    //  Get information about the Trash folder.    FindFolder(theSpec-&gt;vRefNum, kTrashFolderType, kCreateFolder, &amp;trashVRefNum, &amp;trashDirID);    //  If the directory ID of the dropLocation object is the same as the directory ID    //  returned by FindFolder, then the drop must have occurred into the Trash.    if (thePB.dirInfo.ioDrDirID == trashDirID)      return true;    }  return false;} // IsDropInFinderTrash// --------------------------------------------------------------------------------------------------------------// APPLE EVENT SUPPORT ROUTINES// --------------------------------------------------------------------------------------------------------------#pragma segment Mainstatic OSErr  MissingParameterCheck(  AppleEvent   *inputEvent)/*  This routine checks an input AppleEvent for the missing keyword.  If the missing keyword is found, that means that some required  parameters were missing (ie, an error).     However, if the missing keyword isn't found, that means that we aren't missing   any required parameters (that is to say, all REQUIRED parameters were supplied  by the person who created the event).    SOME DAY, THE ABOVE COMMENT WILL MAKE SENSE TO YOU.  IT STILL DOESN'T  TO ME AND I WAS THE ONE WHO WROTE IT.*/{  OSErr    anErr;  AEKeyword  missingKeyword;  DescType  ignoredActualType;  Size    ignoredActualSize;    anErr = AEGetAttributePtr(    inputEvent,     keyMissedKeywordAttr,    typeWildCard,    &amp;ignoredActualType,    (Ptr) &amp;missingKeyword,    sizeof(AEKeyword),    &amp;ignoredActualSize);        if (anErr == noErr)    anErr = errAEParamMissed;  else    if (anErr == errAEDescNotFound)      anErr = noErr;      return anErr;  } // MissingParameterCheck// --------------------------------------------------------------------------------------------------------------// Globals for our handlersBoolean gQuitAfterPrint = true;// --------------------------------------------------------------------------------------------------------------#pragma segment Mainstatic pascal OSErr  DoOpenApp(  AppleEvent   *inputEvent,  AppleEvent   *outputEvent,  long    handlerRefCon){#pragma unused (outputEvent, handlerRefCon)  DoCommand(nil, cNew, 0);  gQuitAfterPrint = false;    // so that the initial document opens more quickly, we don't start  // the threads until we get an OpenApp or OpenDocument AppleEvent  if (gStarterThread != kNoThreadID)    SetThreadState(gStarterThread, kReadyThreadState, gStarterThread);    return(MissingParameterCheck(inputEvent));  } // DoAppOpen// --------------------------------------------------------------------------------------------------------------#pragma segment Mainstatic pascal OSErr  DoQuitApp(  AppleEvent   *inputEvent,  AppleEvent   *outputEvent,  long    handlerRefCon){#pragma unused (outputEvent, handlerRefCon)  DoCommand(nil, cQuit, 0);  return(MissingParameterCheck(inputEvent));  } // DoQuitApp// --------------------------------------------------------------------------------------------------------------#pragma segment Mainstatic pascal OSErr  DoOpenOrPrint(  AppleEvent   *inputEvent,  StringPtr  pPrinterName)  // nil == 0, zero length == print to default, other == printer name{  OSErr    anErr, anErr2;  AEDescList  docList;        // list of docs passed in  long    index, itemsInList;  void*    hPrint;  Boolean    wasAlreadyOpen;    anErr = AEGetParamDesc( inputEvent, keyDirectObject, typeAEList, &amp;docList);  nrequire(anErr, GetFileList);  anErr = AECountItems( &amp;docList, &amp;itemsInList);      // how many files passed in  nrequire(anErr, CountDocs);  for (index = 1; index &lt;= itemsInList; index++)      // handle each file passed in    {      AEKeyword  keywd;    DescType  returnedType;    Size    actualSize;    FSSpec    theFSS;      anErr = AEGetNthPtr( &amp;docList, index, typeFSS, &amp;keywd, &amp;returnedType,  // get file's info              (Ptr)(&amp;theFSS), sizeof(theFSS), &amp;actualSize);    nrequire(anErr, AEGetNthPtr);        {    FInfo  theFileInfo;        anErr = FSpGetFInfo(&amp;theFSS, &amp;theFileInfo);    if (anErr == noErr)      anErr = DetermineWindowTypeOrOpen(&amp;theFSS, theFileInfo.fdType, nil, nil, &amp;wasAlreadyOpen);          if (anErr == eDocumentWrongKind)      {      if (pPrinterName)        ConductErrorDialog(anErr, cPrint, cancel);      else        ConductErrorDialog(anErr, cOpen, cancel);      anErr = noErr;      break;      }          nrequire(anErr, DetermineWindowTypeOrOpen);    }        if (pPrinterName)      {      WindowRef    pWindow = FrontWindow();      WindowDataPtr  pData = GetWindowInfo(pWindow);            if (pData-&gt;pPrintPage)        {        if (index == 1)          {          anErr = DoPrintSetup(pWindow, pPrinterName);          if (anErr == noErr)            hPrint = pData-&gt;hPrint;          }                  if (anErr == noErr)          anErr = DoPrint(pWindow, hPrint, false);                  if (index != itemsInList)          pData-&gt;hPrint = nil;        }            if (!wasAlreadyOpen)        DoCloseWindow(pWindow);      if (anErr != noErr)        break;      }    }  // finally, make sure we didn't miss any parameters  anErr2 = MissingParameterCheck(inputEvent);  if (anErr == noErr)    anErr = anErr2;    // FALL THROUGH EXCEPTION HANDLINGDetermineWindowTypeOrOpen:AEGetNthPtr:CountDocs:  // done with doc list  (void) AEDisposeDesc( &amp;docList);              GetFileList:  // don't report cancels from prints  if (pPrinterName)    {    if ( (anErr == iPrAbort) || (anErr == gxPrUserAbortErr) )      anErr = noErr;    }    if ( (anErr != noErr) &amp;&amp; (anErr != eActionAlreadyHandled) &amp;&amp; (anErr != eUserCanceled) )    {    if (pPrinterName)      ConductErrorDialog(anErr, cPrint, cancel);    else      ConductErrorDialog(anErr, cOpen, cancel);    }      return anErr;  } // DoOpenOrPrint// --------------------------------------------------------------------------------------------------------------#pragma segment Mainstatic pascal OSErr  DoOpenDocument(  AppleEvent   *inputEvent,  AppleEvent   *outputEvent,  long    handlerRefCon){#pragma unused (outputEvent, handlerRefCon)  OSErr    anErr;    if (IsCommandEnabled(cOpen))    {    gQuitAfterPrint = false;    anErr = DoOpenOrPrint(inputEvent, nil);    }  else    {    anErr = errAEEventNotHandled;    ConductErrorDialog(anErr, cOpen, cancel);    }      // so that the initial document opens more quickly, we don't start  // the threads until we get an OpenApp or OpenDocument AppleEvent  if (gStarterThread != kNoThreadID)    SetThreadState(gStarterThread, kReadyThreadState, gStarterThread);    return anErr;  } // DoOpenDocument// --------------------------------------------------------------------------------------------------------------#pragma segment Mainstatic pascal OSErr  DoPrintDocument(  AppleEvent   *inputEvent,  AppleEvent   *outputEvent,  long    handlerRefCon){#pragma unused (outputEvent, handlerRefCon)  OSErr    anErr;  FSSpec    printerFSS;  AEDescList  dtpList;        // list of docs passed in    if (IsCommandEnabled(cOpen))    {    // try to find out if this doc was dropped onto a printer    anErr = AEGetAttributeDesc( inputEvent, keyOptionalKeywordAttr, typeAEList, &amp;dtpList);      if (anErr == noErr)                      // doc dragged to dtp?      {      AEKeyword  keywd;      DescType  returnedType;      Size    actualSize;        anErr = AEGetNthPtr( &amp;dtpList, 1, typeFSS, &amp;keywd, &amp;returnedType,  // get dtp info              (Ptr)(&amp;printerFSS), sizeof(printerFSS), &amp;actualSize);      }          // if it wasn't, that's not an error, just print normally    if (anErr != noErr)      {      printerFSS.name[0] = 0;      anErr = noErr;      }          anErr = DoOpenOrPrint(inputEvent, &amp;printerFSS.name[0]);        // if we are opened just for printing -- quit afterwards    if (gQuitAfterPrint)      DoCommand(nil, cQuit, 0);    }  else    {    anErr = errAEEventNotHandled;    ConductErrorDialog(anErr, cPrint, cancel);    }      return anErr;  } // DoPrintDocument#if GENERATINGCFM  static RoutineDescriptor  gDoOpenAppRD = BUILD_ROUTINE_DESCRIPTOR(uppAEEventHandlerProcInfo, DoOpenApp);  static AEEventHandlerUPP  gDoOpenApp = &amp;gDoOpenAppRD;  static RoutineDescriptor  gDoQuitAppRD = BUILD_ROUTINE_DESCRIPTOR(uppAEEventHandlerProcInfo, DoQuitApp);  static AEEventHandlerUPP  gDoQuitApp = &amp;gDoQuitAppRD;  static RoutineDescriptor  gDoOpenDocumentRD = BUILD_ROUTINE_DESCRIPTOR(uppAEEventHandlerProcInfo, DoOpenDocument);  static AEEventHandlerUPP  gDoOpenDocument = &amp;gDoOpenDocumentRD;  static RoutineDescriptor  gDoPrintDocumentRD = BUILD_ROUTINE_DESCRIPTOR(uppAEEventHandlerProcInfo, DoPrintDocument);  static AEEventHandlerUPP  gDoPrintDocument = &amp;gDoPrintDocumentRD;#else  static AEEventHandlerUPP  gDoOpenApp = (AEEventHandlerUPP) DoOpenApp;  static AEEventHandlerUPP  gDoQuitApp = (AEEventHandlerUPP) DoQuitApp;  static AEEventHandlerUPP  gDoOpenDocument = (AEEventHandlerUPP) DoOpenDocument;  static AEEventHandlerUPP  gDoPrintDocument = (AEEventHandlerUPP) DoPrintDocument;#endif// --------------------------------------------------------------------------------------------------------------#pragma segment Mainstatic pascal OSErr SimpleTextCoachHandler(Rect *pRect, Ptr name, long refCon){#pragma unused (refCon)  OSErr      anErr = noErr;  WindowRef    pWindow = FrontWindow();  WindowDataPtr   pData = GetWindowInfo(pWindow);    if ((pData) &amp;&amp; (pData-&gt;pGetCoachRectangle))    anErr = (*(pData-&gt;pGetCoachRectangle)) (pWindow, pData, pRect, name);      return(anErr);  } // SimpleTextCoachHandler// --------------------------------------------------------------------------------------------------------------// MAIN INITIALIZE/SHUTDOWN/LOOP ROUTINES// --------------------------------------------------------------------------------------------------------------#pragma segment Mainstatic pascal void* StarterThread(void* threadParam){  #pragma unused(threadParam)    /*    All threads, including the starter thread, are initially created    in a suspended state. The starter thread is made ready to run when    we get an open application or open document event. It runs until    there are no activate or update events pending, and then starts the    font menu and Apple Guide threads. This gives much better performance    for the initial creation and update of a document, because the threads    (especially the font thread) chew up a lot of time at first.        The starter thread isn't really necessary - we could get the same    effect by just checking in the event loop for activate/update events -    but hey, it's a lot easier to do it this way, doesn't cost much, and    isn't that what threads are for?  */    for (;;)    {    EventRecord    er;      YieldToAnyThread();        if (!EventAvail(activMask | updateMask, &amp;er))      {      if (gFontThread != kNoThreadID)        SetThreadState(gFontThread, kReadyThreadState, gFontThread);      if (gAGThread != kNoThreadID)        SetThreadState(gAGThread, kReadyThreadState, gAGThread);            break;      }    }    gStarterThread = kNoThreadID;  return NULL;  } // StarterThread// --------------------------------------------------------------------------------------------------------------#pragma segment Initializestatic OSErr CreateThread(ThreadEntryProcPtr pThread, void* threadParam, ThreadID* ptid){  OSErr  anErr;    anErr = NewThread(kCooperativeThread, pThread, threadParam, 0, kNewSuspend,    &amp;gThreadResults, ptid);      if (anErr == noErr &amp;&amp; gStarterThread == kNoThreadID)    {    anErr = NewThread(kCooperativeThread, StarterThread, NULL, 0, kNewSuspend,      &amp;gThreadResults, &amp;gStarterThread);    if (anErr != noErr)      DisposeThread(*ptid, &amp;gThreadResults, false);      // anErr remains != noErr    }      return anErr;}    // --------------------------------------------------------------------------------------------------------------// must be in Main because it runs in a thread and we don't want the segment unloaded// while some other thread is running#pragma segment Mainstatic OSErr FindSimpleTextGuideFile(FSSpec *pSpec){  OSErr  anErr = fnfErr;  short  numDBs, index;  short  folderIndex;    for (folderIndex = 0; folderIndex &lt; 3; ++folderIndex)    {    switch (folderIndex)      {      case 0:        FindFolder(-1, kPreferencesFolderType, false, &amp;pSpec-&gt;vRefNum, &amp;pSpec-&gt;parID);        break;      case 1:        FindFolder(-1, kExtensionFolderType, false, &amp;pSpec-&gt;vRefNum, &amp;pSpec-&gt;parID);        break;      case 2:        FindFolder(-1, kSystemFolderType, false, &amp;pSpec-&gt;vRefNum, &amp;pSpec-&gt;parID);        break;      }        numDBs = AGFileGetDBCount(pSpec-&gt;vRefNum, pSpec-&gt;parID, kAGFileDBTypeAny, false);        if (!gDontYield)      YieldToAnyThread();        for (index = 0; index &lt; numDBs; ++index)      {      if (!gDontYield)        YieldToAnyThread();            if (AGFileGetIndDB(pSpec-&gt;vRefNum, pSpec-&gt;parID, kAGFileDBTypeAny, false, index+1, pSpec) == noErr)        {        OSType  creator;                if ((AGFileGetHelpMenuAppCreator(pSpec, &amp;creator) == noErr) &amp;&amp; (creator == 'ttxt'))          return(noErr);        }      }    }    return(anErr);  } // FindSimpleTextGuideFile// --------------------------------------------------------------------------------------------------------------// must be in Main because it runs in a thread and we don't want the segment unloaded// while some other thread is running#pragma segment Mainstatic pascal void* AGThread(void *threadParam){  #pragma unused(threadParam)    if ( !(AGGetAvailableDBTypes() &amp; kAGDBTypeBitAny) )    {    // if we find one, add it to the help menu and add the right command    if (FindSimpleTextGuideFile(&amp;gAGSpec) == noErr)      {      MenuHandle  helpMenu;                  if (HMGetHelpMenuHandle(&amp;helpMenu) == noErr)        {        Str255  tempString;        short  rnSave;                AGFileGetDBMenuName(&amp;gAGSpec, tempString);        AppendMenu(helpMenu, tempString);                // since we're in a separate thread, so other resource file may        // be open in front of SimpleText's resource fork        rnSave = CurResFile();        UseResFile(gApplicationResFile);                GetIndString(tempString, kMiscStrings, iHelpMenuCommand);                UseResFile(rnSave);                if (tempString[0] != 0)          SetItemCmd(helpMenu, CountMItems(helpMenu), tempString[1]);        }      }    }    // if we have a database, then install a coach handler  if ( (AGGetAvailableDBTypes() &amp; kAGDBTypeBitAny) )    {    AGInstallCoachHandler(NewCoachReplyProc(SimpleTextCoachHandler), 0, &amp;gAGCoachRefNum);    }    gAGThread = kNoThreadID;  return NULL;  } // AGThread// --------------------------------------------------------------------------------------------------------------#pragma segment Initializestatic void FindAndInstallSimpleTextGuide(void){  OSErr  anErr = fnfErr;    if (gMachineInfo.haveThreads)    anErr = CreateThread(AGThread, NULL, &amp;gAGThread);    if (anErr != noErr)    AGThread(NULL);    } // FindAndinstallSimpleTextGuide// --------------------------------------------------------------------------------------------------------------// must be in Main because it runs in a thread and we don't want the segment unloaded// while some other thread is running#pragma segment Mainstatic long SortAndAddMenu(MenuHandle menu, Str255 newItem){  short  numInMenu = CountMItems(menu);  short  i;  Str255  oldItem;    for (i = 1; i &lt;= numInMenu; ++i)    {    GetMenuItemText(menu, i, oldItem);    switch(IUCompString(newItem, oldItem))      {      // already in?  Return index      case 0:        return(i);        break;              // less than, keep scanning      case 1:        break;              // greater than, add back one      case -1:        InsertMenuItem(menu, &quot;\pTom Dowdy&quot;, i-1);        SetMenuItemText(menu, i, newItem);        return(i);        break;      }    }      // fall off the end?  add at the end  InsertMenuItem(menu, &quot;\pTom Dowdy&quot;, numInMenu);  SetMenuItemText(menu, numInMenu+1, newItem);        return(numInMenu+1);  } // SortAndAddMenu// --------------------------------------------------------------------------------------------------------------// must be in Main because it runs in a thread and we don't want the segment unloaded// while some other thread is running#pragma segment Mainstatic void AddToGlobalList(gxFont fontID, short fond, Style styleBits){  if (!gFontMappingList)    gFontMappingList = (FontMappingHandle)NewHandle(0);      if (gFontMappingList)    {    Size      oldSize = GetHandleSize((Handle) gFontMappingList);    FontMappingPtr  pList;        SetHandleSize((Handle)gFontMappingList, oldSize + sizeof(FontMappingRecord));    pList = &amp;(*gFontMappingList)[oldSize/sizeof(FontMappingRecord)];    pList-&gt;fontID = fontID;    pList-&gt;qdFont = fond;    pList-&gt;qdStyle = styleBits;    }    } // AddToGlobalList// --------------------------------------------------------------------------------------------------------------// must be in Main because it runs in a thread and we don't want the segment unloaded// while some other thread is running#pragma segment Mainstatic void AddEachEntry(Handle fond, short* sp, short entries, gxStyle theStyle, MenuHandle menu, short* pStylesUsed){  gxFont      fontID;  long      length;  short       resID;    OSType       resType;    Str255       resName;  Style      styleBits;      GetResInfo(fond, &amp;resID, &amp;resType, resName);        for (; entries &gt;= 0; --entries)      {       if (*sp == 0)          {               styleBits = sp[1];      // map the font ID and the style bits for this style into GX space      (void)GXConvertQDFont(theStyle, resID, styleBits);            if (!gDontYield)        YieldToAnyThread();        fontID = GXGetStyleFont(theStyle);      if (fontID)        length = GXFindFontName(fontID, gxFamilyFontName, gxMacintoshPlatform, gxRomanScript, gxEnglishLanguage, nil, nil);      else        length = 0;              if (!gDontYield)        YieldToAnyThread();        if (length)        {        unsigned char   * name;        short      where;                name = (unsigned char*) NewPtr(length+1);        if (name)          {          MenuHandle  subMenu;          short    mark;          // add this font to the list we know about          AddToGlobalList(fontID, resID, styleBits);          // find the family name for this font          GXFindFontName(fontID, gxFamilyFontName, gxMacintoshPlatform, gxRomanScript, gxEnglishLanguage, &amp;name[1], nil);          name[0] = length;                    // add the name if new. Then add sub menus          where = SortAndAddMenu(menu, name);                    // do we already have a sub menu?  Or does this font have multiple styles?          GetItemMark(menu, where, &amp;mark);          if ( (mark != 0) || (GXFindFonts(fontID, 0, 0, 0, 0, 0, nil, 1, gxSelectToEnd, nil) &gt; 1) )            {            if (!gDontYield)              YieldToAnyThread();              // make a new menu or grab the old one            if (mark == 0)              subMenu = NewMenu(mFontSubMenusStart + *pStylesUsed, name);            else              subMenu = GetMenuHandle(mark);            DisposePtr((Ptr) name);                        length = GXFindFontName(fontID, gxStyleFontName, gxMacintoshPlatform, gxRomanScript, gxEnglishLanguage, nil, nil);            if (length)              {              name = (unsigned char*) NewPtr(length+1);              if (name)                {                GXFindFontName(fontID, gxStyleFontName, gxMacintoshPlatform, gxRomanScript, gxEnglishLanguage, &amp;name[1], nil);                name[0] = length;                (void) SortAndAddMenu(subMenu, name);                DisposePtr((Ptr) name);                }              }                        // if new menu, add to the master            if (mark == 0)              {              InsertMenu(subMenu, -1);              SetItemCmd(menu, where, hMenuCmd);              SetItemMark(menu, where, mFontSubMenusStart + *pStylesUsed);              (*pStylesUsed)++;              }            }          else            DisposePtr((Ptr) name);          }        }              } // if (*sp == 0)          sp += 3;        /* three elements in the FAT */        if (!gDontYield)      YieldToAnyThread();    } // for (# entries)} // AddEachEntry// --------------------------------------------------------------------------------------------------------------// must be in Main because it runs in a thread and we don't want the segment unloaded// while some other thread is running#pragma segment Mainstatic pascal void* FontsThread(void *threadParam){  MenuHandle  menu = (MenuHandle) threadParam;  long    numberFonts;  long    i;  short    stylesUsed = 0;  gxStyle    theStyle;  Boolean    menusAdjusted = false;    theStyle = GXNewStyle();    numberFonts = CountResources('FOND');  for (i = 1; i &lt;= numberFonts; ++i)    {    Handle   fond = GetIndResource('FOND', i);        if (!ResError() &amp;&amp; fond &amp;&amp; *fond)      do          {         short* sp = (short*)(*fond + sizeof(FamRec));            short entries = *sp++;                        AddEachEntry(fond, sp, entries, theStyle, menu, &amp;stylesUsed);                        // now that there are some fonts in the font menu, make sure the menu's enabled            if (!menusAdjusted &amp;&amp; CountMItems(menu) &gt; 0)              {        AdjustMenus(FrontWindow(), true, false);        menusAdjusted = true;              }              } while ((fond = GetNextFOND(fond)) != 0);          } // for (# fonts)  GXDisposeStyle(theStyle);    gFontThread = kNoThreadID;  return 0;} // FontsThread// --------------------------------------------------------------------------------------------------------------#pragma segment Initializestatic OSErr BuildFontMenu(MenuHandle menu){  OSErr  anErr = noErr;    if (gMachineInfo.haveGX)    {    (void) DoStartupGX();        // prime the font cache so we don't spend time doing this in the font thread    GXGetDefaultFont();        anErr = paramErr;    if (gMachineInfo.haveThreads)      anErr = CreateThread(FontsThread, menu, &amp;gFontThread);    if (anErr != noErr)      {      FontsThread(menu);      anErr = noErr;      }    }  else    AppendResMenu(menu, 'FONT');    return(anErr);  } // BuildFontMenu// --------------------------------------------------------------------------------------------------------------#pragma segment Initializestatic OSErr  DoInitialize(void){  short        count;      // loop counter  Handle        menuBar;    // for loading our menus in  gxGraphicsError    anErr = noErr;  // any errors we get, none so far  long        version;    // version for Gestalt calls    InitGraf((Ptr) &amp;qd.thePort);  InitFonts();  InitWindows();  InitMenus();  TEInit();  InitDialogs(nil);  InitCursor();    gAllDone = false;    // check that the system is correct to handle things  SysEnvirons(1, &amp;gMachineInfo.theEnvirons);  if (gMachineInfo.theEnvirons.systemVersion &lt; 0x0700)    {    // Wait for app to come to front    for (count = 1; count &lt;= 3; ++count)      EventAvail(everyEvent, &amp;gEvent);          anErr = eMachineToOld;    nrequire(anErr, SysEnvirons);    }  gMachineInfo.lastBalloonIndex = iNoBalloon;  gMachineInfo.amInBackground = false;  gMachineInfo.documentCount  = 1;  gMachineInfo.haveQuickTime   = (Gestalt(gestaltQuickTime, &amp;version) == noErr);  gMachineInfo.haveRecording   = (Gestalt(gestaltSoundAttr, &amp;version) == noErr) &amp;&amp; ((version &amp; (1&lt;&lt;gestaltHasSoundInputDevice)) != 0);  gMachineInfo.haveTTS     = (Gestalt(gestaltSpeechAttr, &amp;version) == noErr) &amp;&amp; ((version &amp; (1&lt;&lt;gestaltSpeechMgrPresent)) != 0);  gMachineInfo.haveGX      = (Gestalt(gestaltGXVersion, &amp;version) == noErr);  gMachineInfo.haveTSM     = (Gestalt(gestaltTSMgrVersion, &amp;version) == noErr) &amp;&amp; (version &gt;= 1);  gMachineInfo.haveTSMTE     = (Gestalt(gestaltTSMTEAttr, &amp;version) == noErr) &amp;&amp; ((version &amp; (1&lt;&lt;gestaltTSMTE)) != 0);  gMachineInfo.haveDragMgr  = (Gestalt(gestaltDragMgrAttr, &amp;version) == noErr) &amp;&amp; ((version &amp; (1&lt;&lt;gestaltDragMgrPresent)) != 0) &amp;&amp;                  (Gestalt(gestaltTEAttr, &amp;version) == noErr) &amp;&amp; ((version &amp; (1&lt;&lt;gestaltTEHasGetHiliteRgn)) != 0);  gMachineInfo.haveThreeD    = false;  gMachineInfo.haveAppleGuide  = (Gestalt(gestaltHelpMgrAttr, &amp;version) == noErr) &amp;&amp; ((version &amp; (1&lt;&lt;gestaltAppleGuidePresent)) != 0);  gMachineInfo.haveThreads  = (Gestalt(gestaltThreadMgrAttr, &amp;version) == noErr) &amp;&amp; ((version &amp; (1&lt;&lt;gestaltThreadMgrPresent)) != 0);    #if GENERATINGPOWERPC    {    CFragConnectionID  connID;    Ptr         mainAddr;    Str255        errName;        if ( (gMachineInfo.haveQuickTime)   &amp;&amp; (GetSharedLibrary(&quot;\pQuickTimeLib&quot;, kPowerPCCFragArch, kFindCFrag, &amp;connID, &amp;mainAddr, errName) != noErr) )      gMachineInfo.haveQuickTime = false;    if ( (gMachineInfo.haveTTS)     &amp;&amp; (GetSharedLibrary(&quot;\pSpeechLib&quot;, kPowerPCCFragArch, kFindCFrag, &amp;connID, &amp;mainAddr, errName) != noErr) )      gMachineInfo.haveTTS = false;    if ( (gMachineInfo.haveGX)       &amp;&amp; (GetSharedLibrary(&quot;\pQuickDrawGXLib&quot;, kPowerPCCFragArch, kFindCFrag, &amp;connID, &amp;mainAddr, errName) != noErr) )      gMachineInfo.haveGX = false;    if ( (gMachineInfo.haveDragMgr)    &amp;&amp; (GetSharedLibrary(&quot;\pDragLib&quot;, kPowerPCCFragArch, kFindCFrag, &amp;connID, &amp;mainAddr, errName) != noErr) )      gMachineInfo.haveDragMgr = false;    if ( (gMachineInfo.haveThreads)   &amp;&amp; (GetSharedLibrary(&quot;\pThreadsLib&quot;, kPowerPCCFragArch, kFindCFrag, &amp;connID, &amp;mainAddr, errName) != noErr) )      gMachineInfo.haveThreads = false;    }  #endif    // initialize text services if they exist  if (gMachineInfo.haveTSMTE)    {    if (InitTSMAwareApplication() != noErr)      {      gMachineInfo.haveTSM = false;      gMachineInfo.haveTSMTE = false;      }    }      // save away info we need from the get-go    gApplicationResFile = CurResFile();  gCursorRgn = NewRgn();  // load up the menus  menuBar = (Handle) GetNewMBar(rMenuBar);      /* read menus into menu bar */  anErr = ResError();  if ( (anErr == noErr) &amp;&amp; (menuBar == nil) )    anErr = resNotFound;  nrequire(anErr, GetNewMBar);    // install menus  SetMenuBar(menuBar);    DisposeHandle(menuBar);  // build the Apple menu  AppendResMenu(GetMenuHandle(mApple), 'DRVR');  /* add DA names to Apple menu */    // haven't yet done a startup of QuickDraw GX  if (gMachineInfo.haveGX)    gMachineInfo.haveStartedGX = false;  // Build the font menu  anErr = BuildFontMenu(GetMenuHandle(mFont));  nrequire(anErr, BuildFontMenu);    // insert our heirarchical menus  {  MenuHandle   menu = GetMenu( mVoices );  short    menuID, itemID;    InsertMenu( menu, hierMenu );    CommandToIDs(cSelectVoice, &amp;menuID, &amp;itemID);  menu = GetMenuHandle(menuID);  SetItemCmd( menu, itemID, hMenuCmd );  SetItemMark( menu, itemID, mVoices );  }  AdjustMenus(nil, true, false);  DrawMenuBar();    // start up QuickTime, but problems result in us pretending not to have it  if (gMachineInfo.haveQuickTime)    if (EnterMovies() != noErr)      gMachineInfo.haveQuickTime = false;      // Install AppleEvent handlers for the base classes  #define INSTALL(event, handler) \      AEInstallEventHandler(kCoreEventClass, event, handler, 0, false)  INSTALL (kAEOpenApplication, gDoOpenApp);  INSTALL (kAEQuitApplication, gDoQuitApp);  INSTALL (kAEOpenDocuments,   gDoOpenDocument);  INSTALL (kAEPrintDocuments,  gDoPrintDocument);  #undef INSTALL  // Install our global dragging procs, but only if we have Drag and Drop. An error results  // in us pretending that we don't have drag support. Notice that in the test above, we also  // require TextEdit to have TEGetHiliteRgn avalilable, which is always the case with the  // present Drag Manager.  if (gMachineInfo.haveDragMgr)    {    gGlobalTrackingHandler = NewDragTrackingHandlerProc(GlobalTrackingHandler);    gGlobalReceiveHandler = NewDragReceiveHandlerProc(GlobalReceiveHandler);        anErr = InstallTrackingHandler(gGlobalTrackingHandler, nil, nil);    if (anErr == noErr)      {      anErr = InstallReceiveHandler(gGlobalReceiveHandler, nil, nil);      if (anErr != noErr)        {        RemoveTrackingHandler(gGlobalTrackingHandler, nil);        gMachineInfo.haveDragMgr = false;        }      }    else      gMachineInfo.haveDragMgr = false;    }  // verify that the AppleGuide database is available, and if it isn't, try to find  // it from other places -- but don't bother on 2.1, because they made changes  // to break our location finding (sigh!)  if  (    (gMachineInfo.haveAppleGuide) &amp;&amp;     ( (Gestalt('ag_v', &amp;version) != noErr) || (version &lt; 0x00000210) )    )    FindAndInstallSimpleTextGuide();      return noErr;    // EXCEPTION HANDLINGBuildFontMenu:GetNewMBar:SysEnvirons:  ConductErrorDialog(anErr, cNull, cancel);    return anErr;} // DoInitialize// --------------------------------------------------------------------------------------------------------------#pragma segment Terminatestatic OSErr  DoTerminate(void){  OSErr  anErr = noErr;    if (gFontThread != kNoThreadID)    DisposeThread(gFontThread, &amp;gThreadResults, false);  if (gAGThread != kNoThreadID)    DisposeThread(gAGThread, &amp;gThreadResults, false);  if (gStarterThread != kNoThreadID)    DisposeThread(gStarterThread, &amp;gThreadResults, false);  if (gMachineInfo.haveQuickTime)    ExitMovies();  if ( (gMachineInfo.haveGX) &amp;&amp; (GXGetGraphicsClient() != nil) )    {    GXExitPrinting();    GXExitGraphics();    }      if (gMachineInfo.haveTSMTE)    CloseTSMAwareApplication();  if (gMachineInfo.haveDragMgr)    {    RemoveReceiveHandler(gGlobalReceiveHandler, nil);    RemoveTrackingHandler(gGlobalTrackingHandler, nil);    }      if (gMachineInfo.haveAppleGuide)    {    if ((gAGRefNum != -1) &amp;&amp; AGIsDatabaseOpen(gAGRefNum))      {      AGClose(&amp;gAGRefNum);      gAGRefNum = -1;      }    if (gAGCoachRefNum != -1)      AGRemoveCoachHandler(&amp;gAGCoachRefNum);    }  return anErr;  } // DoTerminate// --------------------------------------------------------------------------------------------------------------#pragma segment Mainmain(void){  OSErr  anErr;  #ifndef __MWERKS__  UnloadSeg((Ptr) _DataInit);            /* note that _DataInit must not be in Main! */#endif  MaxApplZone();                  /* expand the heap so code segments load at the top */  MoreMasters(); MoreMasters(); MoreMasters();   /* we love handles */  anErr = DoInitialize();  UnloadSeg((Ptr) DoInitialize);            if (anErr == noErr)    {    DoEventLoop();// REVIEW: don't want to unload the segment we're in!!//    UnloadSeg((Ptr) DoEventLoop);    DoTerminate();              }  return 0;} // main</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/SimpleText_Sample/listing19.html%3Fid%3DDTS10000736-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/SimpleText_Sample/listing19.html%3Fid%3DDTS10000736-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/SimpleText_Sample/listing19.html%3Fid%3DDTS10000736-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>