<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Carbon Event Manager Programming Guide: Carbon Event Manager Concepts</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Carbon Event Manager Concepts"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30000989-CH202" title="Carbon Event Manager Concepts"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000420" target="_top">Carbon</a> &gt; <a href="../../../EventsOtherInput-date.html#//apple_ref/doc/uid/TP30000440-TP30000420-TP30000447" target="_top">Events &amp; Other Input</a> &gt; <a href="../Intro/CarbonEventsIntro.html#//apple_ref/doc/uid/TP30000989-CH201-DontLinkElementID_33">Carbon Event Manager Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Intro/CarbonEventsIntro.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../Tasks/CarbonEventsTasks.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_3" title="Carbon Event Manager Concepts"></a><h1><a name="//apple_ref/doc/uid/TP30000989-CH202-BABDIGIF" title="Carbon Event Manager Concepts"></a>Carbon Event Manager Concepts</h1><p>This chapter gives an overview of the Carbon event model and how the Carbon Event Manager interacts with your application.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="CarbonEventsConcept.html#//apple_ref/doc/uid/TP30000989-CH202-TPXREF101">Carbon Event Handling Theory</a>
				
			<br/>
			
        
			
			
				<a href="CarbonEventsConcept.html#//apple_ref/doc/uid/TP30000989-CH202-TPXREF106">The Event Model</a>
				
			<br/>
			
        
			
			
				<a href="CarbonEventsConcept.html#//apple_ref/doc/uid/TP30000989-CH202-TPXREF107">Carbon Events Versus WaitNextEvent</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30000989-CH202-TPXREF101" title="Carbon Event Handling Theory"></a><h2>Carbon Event Handling Theory</h2><p>Carbon event processing is based on a callback mechanism. You define your program’s response to various types of event by writing <em>event handler</em> functions and installing them in the Carbon Event Manager. Then, each time an event occurs, the Carbon Event Manager will call back the handler routine you’ve installed for that type of event. By defining how your program responds to events, the event handlers determine everything about the program’s appearance and behavior on the screen.</p><a name="//apple_ref/doc/uid/TP30000989-CH202-TPXREF102" title="The Event Loop"></a><h3>The Event Loop</h3><p><a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_53"></a>The heart of an event-driven application is the <em>main event loop</em>. After any required initialization, the application enters the main event loop and does not leave it until required to quit. The basic loop operation is as follows:</p><ol class="ol"><li class="li"><p>The application sits in a suspended state, waiting for an event. While in this state it uses no processor time, which means that more time is available to other running applications. </p></li><li class="li"><p>When an event occurs that requires its attention, the application “wakes up” and processes the event. Typically the Carbon Event Manager calls back the event handler, if any, that the application has installed for that event. </p></li><li class="li"><p>After processing, the application returns to its suspended state, waiting for the next event. </p></li></ol><p>The main event loop continues in this manner until it receives a quit event (usually in response to the user’s choosing a Quit command from a menu). After leaving the event loop, the application calls any necessary termination routines and then quits. </p><a name="//apple_ref/doc/uid/TP30000989-CH202-BABDFHAH" title="Event Types"></a><h3>Event Types</h3><p><a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_54"></a><a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_55"></a><a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_56"></a>Every Carbon event is characterized by an <em>event type</em> consisting of two items of information: an <em>event class</em> and an <em>event kind</em>. The event class denotes a general category of events, such as mouse events or window events; the event kind identifies the specific type of event within that category, such as a mouse-down event (the user pressed the mouse button) or a window-activated event (a window has been brought to the front of the screen). </p><a name="//apple_ref/doc/uid/TP30000989-CH202-TPXREF103" title="Event Targets and Containment Hierarchies"></a><h3>Event Targets and Containment Hierarchies</h3><p><a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_57"></a><a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_58"></a>Every event handler you create must be associated with a particular object called an <em>event target</em>. For example, your handler could be associated with a control, a menu, a window, or even the entire application. The event class and kind do not have to be related to the event target. For example, a handler to process a control event (such as button click) does not have to be attached to a control. You could attach it to the window that contains the control, or even the application itself. How and when your handler gets called for an event is determined by a <em>containment hierarchy</em>, as shown in <span class="content_text">Figure 1-1</span>.</p><br/><div><a name="//apple_ref/doc/uid/TP30000989-CH202-SW1" title="Figure 1-1Event target containment hierarchy"></a><p><a name="//apple_ref/doc/uid/TP30000989-CH202-BABFBDIF" title="Figure 1-1Event target containment hierarchy"></a><strong>Figure 1-1&nbsp;&nbsp;</strong>Event target containment hierarchy</p><img src = "../Art/eventcontainmenthier.gif" alt = "Event target containment hierarchy" width="314" height="171"></div><br/><p>When an event occurs, it is initially reported to the innermost relevant target in the hierarchy. For example, if the user clicks a button, the event is initially sent to that button control. If the user resizes a window, the event is sent to that window. If that target has no handler for the given event type, the event propagates outward to the next containing target. This makes it possible for an event handler associated with an inner target to override the behavior defined for a given event type by an outer, enclosing target.</p><p>For example, you can use this hierarchy to enable or disable your program’s menu items according to circumstances. This behavior is controlled via events of type <code>kEventCommandUpdateStatus</code>, which ask whether a particular item should be enabled or disabled on the menu. On receiving such an event for, say, the Close command on your program’s File menu, you might have an event handler associated with the application event target (the outermost target in the hierarchy) disable the menu, while a handler associated with an individual window enables it. If your program has at least one window open on the screen, the event will be handled by the window’s event handler; if not, it will propagate outward to the application event handler. The Close command will thus be enabled if there are any windows present, but disabled if there aren’t.</p><a name="//apple_ref/doc/uid/TP30000989-CH202-BABCHCHA" title="The Handler Stack"></a><h3>The Handler Stack</h3><p><a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_59"></a><a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_60"></a>Within an event target, you can have multiple event handlers installed. These handlers are arranged in a stack, placed in reverse order of installation (last in is first called). For example, when an event is passed to an event target, it is sent to the top handler in the stack. If that handler doesn’t take the event, it is passed to the next handler in the stack, and so on. </p><p><a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_61"></a>Note that this stack design means that you can install more than one handler for a particular event. Plugins, for example, can use this feature to install additional event handlers for existing events. If the plug-in is installed after the application-defined handler, it is first in line to take the event. If it chooses not to handle it, the application-defined handler then has the opportunity to take the event.</p><p>If a standard handler is installed, it is placed at the bottom of the stack and will be the last to be called. </p><a name="//apple_ref/doc/uid/TP30000989-CH202-TPXREF104" title="Standard Handlers"></a><h3>Standard Handlers</h3><p><a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_62"></a><a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_63"></a>Carbon provides a standard event handler for the window and application event targets. These handlers define a standard response to each type of event that a window or application target may receive; the one for windows, for instance, implements all the standard behavior for manipulating a window with the mouse—dragging it by its title bar, closing it by clicking the close button, resizing it by dragging the resize control, and so on. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_4" title="Note"></a><p><strong>Note:</strong>&nbsp;<a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_64"></a><a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_65"></a>The standard window handler also includes standard responses for control events. The standard application handler includes support for menu events. </p></div><p>By installing the standard handler when you create a window, you automatically inherit all of this standard behavior with no additional effort on your part. You can then proceed to install additional handlers of your own for those aspects of the window’s behavior that are specific to your individual application, such as drawing its contents or responding to the user’s mouse actions inside it. Events of those specific types will be reported to your own installed handlers for processing; all others will instead be passed through to the standard handler to deal with in the standard way. This frees you from having to provide your own handler for each of the hundred-odd kinds of event that Carbon may throw at you: with the standard event handlers to back you up, you can just focus your attention on those events whose behavior you need to modify or customize in some way and leave the rest to the standard handlers, knowing that they will do something sensible with them. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_5" title="Note"></a><p><strong>Note:</strong>&nbsp;Some events have a default behavior rather than a standard handler associated with them. The default behavior always occurs if you don’t handle the event, whether or not you have a standard event handler installed. </p></div><p><a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_66"></a><a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_67"></a>Sometimes the standard event handler’s response to a single event can trigger an elaborate cascade of other events. Consider, for example, what happens when the user presses the mouse button in a window’s resize control. The mouse press generates an event of type <code>kEventMouseDown</code>, reporting such information as the time and location at which the button was pressed, what modifier keys were being held down at the time, and so forth. Responding to this event involves hit-testing the mouse location to determine that it lies in the window’s resize control, tracking the mouse’s movements for as long as the button is held down, providing appropriate visual feedback on the screen, and finally resizing the window when the button is released. Theoretically, you could provide a handler routine for mouse-down events to do all this yourself, but it’s generally more convenient to let the standard window event handler manage all these chores for you in the standard way. It does this by generating a sequence of further events representing various stages in the process of responding to the original mouse press: </p><ol class="ol"><li class="li"><p>A hit-test event (<code>kEventWindowHitTest</code>) to analyze the mouse location and determine what object on the screen received the mouse press</p></li><li class="li"><p>A click-resize-region event (<code>kEventWindowClickResizeRgn</code>) indicating that the mouse button was pressed in the resize control of one of your windows </p></li><li class="li"><p>A get-minimum-size (<code>kEventWindowGetMinimumSize</code>) and a get-maximum-size (<code>kEventWindowGetMaximumSize</code>) event requesting the smallest and largest dimensions to which the user should be allowed to resize the window </p><ol class="ol"><li class="ol ol"><p>A mouse-dragged event (<code>kEventMouseDragged</code>) reporting the mouse’s coordinates </p></li><li class="ol ol"><p>A window bounds-changing event (<code>kEventWindowBoundsChanging</code>) indicating that the window’s size is about to change </p></li><li class="ol ol"><p>A get-grow-image-region event (<code>kEventWindowGetGrowImageRegion</code>) requesting the size and shape of the window outline to be drawn for visual feedback on the screen</p></li></ol></li><li class="li"><p>A mouse-up event (<code>kEventMouseUp</code>) when the mouse button is released</p></li><li class="li"><p>A draw-frame event (<code>kEventWindowDrawFrame</code>) to redraw the window’s structural elements (frame, title bar, and so forth) in the new size </p></li><li class="li"><p>A window bounds-changed event (<code>kEventWindowBoundsChanged</code>) indicating that the window’s size has changed</p></li><li class="li"><p>A window update event (<code>kEventWindowUpdate</code>) indicating that the portion of the window’s contents visible on the screen has changed and must be redrawn</p></li><li class="li"><p>A draw-content event (<code>kEventDrawContent</code>) to redraw the window’s interior contents</p></li></ol><p>This proliferation of events may seem daunting, but most of them are really intended to be processed by the standard window event handler itself, with no active intervention on your part. The only reason for sending all these events is to give you the flexibility to step in at various points in the process and take control yourself if you choose to do so. Maybe you want to reimplement the draw-frame event to change the standard rectangular window frame to an octagonal viewing port for your starship simulation, or intercept mouse-dragged events to play a cool sound effect while the user is dragging the mouse around. Most of the time, you’ll just leave these events for the standard handler to manage in its own way.<a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_68"></a><a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_69"></a></p><a name="//apple_ref/doc/uid/TP30000989-CH202-BABIDCEE" title="An Event Propagation Example "></a><h3>An Event Propagation Example </h3><p><a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_70"></a><a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_71"></a>Here’s a simple example of how an event would propagate through the containment hierarchy when you have the standard handlers installed, as shown in <span class="content_text">Figure 1-2</span>.</p><br/><div><a name="//apple_ref/doc/uid/TP30000989-CH202-SW2" title="Figure 1-2Event propagation with standard handlers"></a><p><a name="//apple_ref/doc/uid/TP30000989-CH202-BCEDHHCJ" title="Figure 1-2Event propagation with standard handlers"></a><strong>Figure 1-2&nbsp;&nbsp;</strong>Event propagation with standard handlers</p><img src = "../Art/eventpropwstandardwindows.gif" alt = "Event propagation with standard handlers" width="454" height="426"></div><br/><p>Say the user clicks on a button. Doing so generates an event which is sent to the associated event target (the button control). If the event makes its way through the control’s handler stack without being processed, it is propagated to the window that contains it. (Currently there are no standard handlers that can be installed on controls.)</p><p><a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_72"></a>If the window event target contains no installed handlers that can take the control event, the standard window handler takes the event. (The standard window handler includes responses for control events.)</p><p>Note that if you installed a handler for a control event on the application event target, it would never get called, because the standard window handler will take the event before it can get propagated to the application. </p><a name="//apple_ref/doc/uid/TP30000989-CH202-TPXREF105" title="Event Timers"></a><h3>Event Timers</h3><p><a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_73"></a>In a<a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_74"></a>ddition to letting you install event handlers, the Carbon Event Manager also lets you create event timers, which you use to perform some action repeatedly at regular intervals. For example, you may want to use a timer to handle actions such as blinking a text-insertion caret, sounding a repeating beep, or updating a clock display on the screen. The timer fires at specified intervals, calling a timer routine you specified when installing the timer. You can also specify that a timer fire only once. For example, you can install a one-shot timer that dismisses a dialog after two minutes. </p><a name="//apple_ref/doc/uid/TP30000989-CH202-TPXREF106" title="The Event Model"></a><h2>The Event Model</h2><p>In most cases, you can simply write your event handlers and not worry about the details of how events are propagated to your application. However, if you have more sophisticated needs, understanding the event model will make it easier to write your code. </p><p><span class="content_text">Figure 1-3</span> diagrams the basic Carbon event model in Mac OS X. </p><br/><div><a name="//apple_ref/doc/uid/TP30000989-CH202-SW3" title="Figure 1-3The Carbon event model"></a><p><a name="//apple_ref/doc/uid/TP30000989-CH202-BABCDAEH" title="Figure 1-3The Carbon event model"></a><strong>Figure 1-3&nbsp;&nbsp;</strong>The Carbon event model</p><img src = "../Art/carboneventmodel.gif" alt = "The Carbon event model" width="435" height="323"></div><br/><p><a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_75"></a><a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_76"></a><a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_77"></a>User events of all kinds are propagated through the kernel to the Window Serve<a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_78"></a>r. From there, events are sent to your application in a two-step process:</p><ol class="ol"><li class="li"><p>A low-level event loop extracts the events that are relevant to your application and places them into the application’s event queue. This loop also fires timers as necessary. If neither of these tasks need attention, the loop is blocked. </p></li><li class="li"><p>The Carbon Event Manager removes events from the event queue and dispatches them to the appropriate event targets. If the target has registered for the event, the appropriate handler is called. If not, the event propagates up the containment hierarchy until someone handles the event. </p></li><li class="li"><p>If no registered handler takes the event, and no standard handlers are installed, the event is discarded (unless <code>WaitNextEvent</code> is also installed; see <span class="content_text"><a href="CarbonEventsConcept.html#//apple_ref/doc/uid/TP30000989-CH202-TPXREF107">“Carbon Events Versus WaitNextEvent”</a></span> for more details).</p></li></ol><div class="notebox"><a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_6" title="Note"></a><p><strong>Note:</strong>&nbsp;While the lower level details differ slightly, the Carbon event loop and dispatching mechanism are identical in older Mac OS systems using CarbonLib.</p></div><p>The standard Carbon Event Manager event loop function, <code>RunApplicationEventLoop<a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_79"></a></code>, automatically handles all of the above operations for you. However, if you want more control over the event-handling mechanism, you may choose to call lower-level functions to explicitly run the event loop and dispatch events. For more information about processing events yourself, see <span class="content_text"><a href="../Tasks/CarbonEventsTasks.html#//apple_ref/doc/uid/TP30000989-CH203-CIHFIHIF">“Processing Events Manually.”</a></span></p><p><a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_80"></a>If you create preemptive threads (using Multiprocessing Services), these will have their own low-level event loops and event queues, but they do not receive user events. Cooperatively-scheduled threads (such as you would create with the Thread Manager) share the main application event loop and queue. For more information about processing events in other threads, see <span class="content_text"><a href="../Tasks/CarbonEventsTasks.html#//apple_ref/doc/uid/TP30000989-CH203-CIHJICGJ">“Carbon Events in Multiple Threads.”</a></span></p><a name="//apple_ref/doc/uid/TP30000989-CH202-TPXREF107" title="Carbon Events Versus WaitNextEvent"></a><h2>Carbon Events Versus WaitNextEvent</h2><p><a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_81"></a><a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_82"></a>The <a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_83"></a>Carbon Event Manager was designed as a replacement for the Classic Event Manager, which is based around the <code>WaitNextEvent</code> loop. If you are writing a new Carbon application, you should use the Carbon Event Manager. If you are porting an existing application to Carbon, here are some reasons why you should adopt the Carbon Event Manager:</p><ul class="ul"><li class="li"><p>Standard event handlers mean that you don’t have to handle most common events.</p></li><li class="li"><p>No polling. A more efficient event model means that your application uses less processor time, improving overall system performance. </p></li><li class="li"><p>The Carbon Event Manager can handle any number of event types (not just the 16 available in the Classic Event Manager). </p></li><li class="li"><p>Defined event types include those that replace defproc messaging. </p></li></ul><p>The Carbon event model is flexible enough that you can make gradual changes to adopt the Carbon Event Manager. In fact, you can have Carbon event handlers installed and still call <code>WaitNextEvent</code> to run your event loop. <span class="content_text">Figure 1-4</span> shows the modified event handling mechanism used by <code>WaitNextEvent</code>. </p><br/><div><a name="//apple_ref/doc/uid/TP30000989-CH202-SW4" title="Figure 1-4WaitNextEvent execution in the Carbon environment"></a><p><a name="//apple_ref/doc/uid/TP30000989-CH202-BABEBHJI" title="Figure 1-4WaitNextEvent execution in the Carbon environment"></a><strong>Figure 1-4&nbsp;&nbsp;</strong>WaitNextEvent execution in the Carbon environment</p><img src = "../Art/waiteventmodel.gif" alt = "WaitNextEvent execution in the Carbon environment" width="354" height="414"></div><br/><ol class="ol"><li class="li"><p><code>WaitNextEvent</code> runs the event loop, placing events into the event queue as they appear. It also fires timers as necessary.</p></li><li class="li"><p>When an event appears in the event queue, <code>WaitNextEvent</code> dispatches it to the appropriate event target, but does not pull the event off the queue. </p></li><li class="li"><p>If a Carbon event handler processed the event, then the event is pulled off the queue and <code>WaitNextEvent</code> waits for the next event. </p></li><li class="li"><p>If the event wasn’t handled, <code>WaitNextEvent</code> checks to see if the event is in the event mask specified by the application. If not, it pulls the event off the queue and discards it. </p></li><li class="li"><p>It the event is in the event mask, <code>WaitNextEvent</code> pulls the event from the queue, packages it as an event specification, and returns. </p></li></ol><p><a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_84"></a>Note that if you specify that standard event handlers be used for your windows, these will override any <code>WaitNextEvent</code> handlers you had written to process window events. Also, the standard handlers for menu events and Apple events are installed only when you call <code>RunApplicationEventLoop</code>. Therefore, as long as you use <code>WaitNextEvent</code>, you will still have to handle menu tracking, menu selection, and Apple event dispatching yourself. </p><p>Here are some simple changes that can improve performance if you are not ready to fully adopt the Carbon Event Manager:</p><ul class="ul"><li class="li"><p>Maximize the wait time in <code>WaitNextEvent</code> to <code>7FFFFFFF</code>. Doing so effectively blocks your application so it won’t use unnecessary processor time. </p></li><li class="li"><p>Don’t reduce your wait time in order to get null events for idle processing. If you need to perform periodic actions (such as blinking the cursor), install Carbon event timers to do so. </p></li></ul><p>The Carbon Event Manager also provides some utility functions which can be useful for applications using both Carbon events and <code>WaitNextEvent</code>. To convert between event references and Classic Event Manager event specifications, use <code>ConvertEventRefToEventRecord<a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_85"></a></code>:</p><div class="codesample"><table><tr><td scope="row"><pre>EventRef     theRef;<span></span></pre></td></tr><tr><td scope="row"><pre>EventRecord  theRecord;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>ConvertEventRefToEventRecord (theRef, &amp;theRecord);<span></span></pre></td></tr></table></div><p>To determine whether a Carbon event corresponds to a bit in a Classic Event Manager event mask, use <code>IsEventInMask<a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_86"></a></code>:</p><div class="codesample"><table><tr><td scope="row"><pre>EventRef theRef;<span></span></pre></td></tr><tr><td scope="row"><pre>EventMask theMask;<span></span></pre></td></tr><tr><td scope="row"><pre>Boolean result;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>result = IsEventInMask (theRef, theMask);<span></span></pre></td></tr></table></div><p>A pair of convenience macros, <code>EventTimeToTicks<a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_87"></a></code> and <code>TicksToEventTime<a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_88"></a></code>, are available for converting between event times and the older ticks intervals: <a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_89"></a><a name="//apple_ref/doc/uid/TP30000989-CH202-DontLinkElementID_90"></a></p><div class="codesample"><table><tr><td scope="row"><pre>EventTime  timeInSeconds;<span></span></pre></td></tr><tr><td scope="row"><pre>UInt32     timeInTicks;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>timeInTicks   = EventTimeToTicks(timeInSeconds);<span></span></pre></td></tr><tr><td scope="row"><pre>timeInSeconds = TicksToEventTime(timeInTicks);<span></span></pre></td></tr></table></div>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Intro/CarbonEventsIntro.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../Tasks/CarbonEventsTasks.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2001, 2005 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2005-07-07<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Carbon/Conceptual/Carbon_Event_Manager/Concept/CarbonEventsConcept.html%3Fid%3DTP30000989-2.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Carbon/Conceptual/Carbon_Event_Manager/Concept/CarbonEventsConcept.html%3Fid%3DTP30000989-2.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Carbon/Conceptual/Carbon_Event_Manager/Concept/CarbonEventsConcept.html%3Fid%3DTP30000989-2.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>