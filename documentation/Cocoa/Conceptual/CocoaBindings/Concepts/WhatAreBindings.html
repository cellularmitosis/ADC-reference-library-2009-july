<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Cocoa Bindings Programming Topics: What Are Cocoa Bindings?</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="What Are Cocoa Bindings?"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/20002372" title="What Are Cocoa Bindings?"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../DesignGuidelines-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000556" target="_top">Design Guidelines</a> &gt; <a href="../index.html" target="_top">Cocoa Bindings Programming Topics</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../CocoaBindings.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="HowDoBindingsWork.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>
        
        
        <a name="//apple_ref/doc/uid/20002372-CJBEJBHH" title="What Are Cocoa Bindings?"></a><hr /><H1>What Are Cocoa Bindings?</H1><p>In the simplest functional sense, the Cocoa bindings technology provides a means of keeping model and view values synchronized without you having to write a lot of “glue code.” It allows you to establish a mediated connection between a view and a piece of data, “binding” them such that a change in one is reflected in the other.</p><p>This article describes what the technology offers and how it makes writing applications easier. It also introduces the idea that rather than completely reimplementing an existing application to make use of bindings, you can incorporate bindings in stages.</p><p>This article also describes on a conceptual level how Cocoa bindings work, and the design patterns you should adopt. It gives a brief overview of the Model-View-Controller design pattern, and why it is beneficial. It then gives a conceptual overview of how the main technologies that underpin Cocoa bindings—key-value coding, key-value observing, and key-value binding—work, and how they inter-relate. The article finally explains the role of the controller classes that Cocoa bindings provide and why you should use them.</p><p><span class="content_text"><a href="HowDoBindingsWork.html#//apple_ref/doc/uid/20002373-CJBEJBHH">“How Do Bindings Work?”</a></span> describes the supporting technologies in greater detail.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <!-- TopicBook.pm uses this template for its miniTOCs, but needs a different title. -->
    <h4>Contents:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="WhatAreBindings.html#//apple_ref/doc/uid/20002372-170032">The Advantages of Using Bindings</a>
				
			<br/>
			
        
			
			
				<a href="WhatAreBindings.html#//apple_ref/doc/uid/20002372-175802">The Model-View-Controller Design Pattern</a>
				
			<br/>
			
        
			
			
				<a href="WhatAreBindings.html#//apple_ref/doc/uid/20002372-180490">What Is a Binding?</a>
				
			<br/>
			
        
			
			
				<a href="WhatAreBindings.html#//apple_ref/doc/uid/20002372-176805">Supporting Technologies</a>
				
			<br/>
			
        
			
			
				<a href="WhatAreBindings.html#//apple_ref/doc/uid/20002372-177085">Why Are NSControllers Useful?</a>
				
			<br/>
			
        
			
			
				<a href="WhatAreBindings.html#//apple_ref/doc/uid/20002372-196320">What Can You Bind?</a>
				
			<br/>
			
        
			
			
				<a href="WhatAreBindings.html#//apple_ref/doc/uid/20002372-181136">Real-World Example</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/20002372-170032" title="The Advantages of Using Bindings"></a><h2>The Advantages of Using Bindings</h2><p>The Cocoa bindings technology offers a way to increase the functionality and consistency of your application while at the same time decreasing the amount of code you have to write and maintain. It takes care of most aspects of user interface management for you by allowing you to off load the work of custom glue code onto reusable pre-built controllers. It helps you build polished, easy-to-use applications that leverage object relationships, provide sortable tables, and include intelligent selection management.</p><p>Typically you do not need to completely rewrite your application in order to adopt Cocoa bindings. For example, it is likely that you can factor out User Preferences to be managed by Cocoa bindings without affecting the rest of an application. You will find it easier to make use of Cocoa bindings if your application adopts the recommended design patterns.</p><a name="//apple_ref/doc/uid/20002372-175802" title="The Model-View-Controller Design Pattern"></a><h2>The Model-View-Controller Design Pattern</h2><p>Cocoa applications generally adopt the Model-View-Controller (MVC) design pattern. When you develop a Cocoa application, you typically use model, view, and controller objects, each of which performs a different function. Model objects represent data and are typically saved to a file or some other permanent data store. View objects display model attributes. Controller objects act as go-betweens, to make sure that what a view displays is consistent with the corresponding model value and that any updates a user makes to a value in a view are propagated to the model. An understanding of the MVC design pattern is essential to fully understand and leverage Cocoa bindings. If you need to know more, read “<span class="content_text"><!--a target="_top" -->The Model-View-Controller Design Pattern<!--/a--></span>.”</p><p>If you adopt the MVC design pattern, much of your application code is easier to reuse and extend—you can reuse model and view classes in different applications. Much of the implementation of a controller object consists of what is commonly referred to as “glue code.” Glue code is the code that keeps the model values and views synchronized, and is unique to each application. It is typically tedious and cumbersome to write, contributes little to the fundamental function of the application, but you must do it well to provide a good user experience.</p><br/><div><a name="//apple_ref/doc/uid/20002372-180398" title="Figure 1Controllers provide glue code"></a><p><strong>Figure 1&nbsp;&nbsp;</strong>Controllers provide glue code</p><img src = "../art/glue.gif" alt = "" width="434" height="204"></div><br/><p>Cocoa bindings replace much of the glue code with reusable controllers and provide an infrastructure that allows you to connect the user interface with an application’s data.</p><p>Cocoa uses a number of terms that are commonly used in computer science. To avoid misunderstanding, they are defined in the “Terminology” section of <em><a href="../../KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i" target="_top">Key-Value Coding Programming Guide</a></em> with their particular meaning in the context of Cocoa bindings.</p><a name="//apple_ref/doc/uid/20002372-180490" title="What Is a Binding?"></a><h2>What Is a Binding?</h2><p>A binding is an attribute of one object that may be bound to a property in another such that a change in either one is reflected in the other. For example, the “value” binding of a text field might be bound to the temperature attribute of a particular model object. More typically, one binding might specify that a controller object “presents” a model object and another binding might specify that the value of a text field be tied to the temperature property of the object presented by the controller.</p><p>Although the following examples concentrate on simple cases, bindings are not restricted to the display of textual or numeric values. Among other things, a binding might specify the color in which text should be displayed, whether a view is hidden or not, or what message and arguments should be sent when a button is pressed.</p><a name="//apple_ref/doc/uid/20002372-169421" title="A Simple Example"></a><h3>A Simple Example</h3><p>Take as an example a very simple application in which the values in a text field and a slider are kept synchronized. Consider first an implementation that does <em>not</em> use bindings. The text field and slider are connected directly to each other using target-action, where each is the other’s target and the action is <code>takeFloatValueFrom:</code> as shown in <span class="content_text">Figure 2</span>. (If you do not understand this, you should read <span class="content_text"><a href="../../../../../referencelibrary/GettingStarted/GS_Cocoa/index.html#//apple_ref/doc/uid/TP30001088" target="_top">Getting Started With Cocoa</a></span>.)</p><br/><div><a name="//apple_ref/doc/uid/20002372-169708-BCICICGC" title="Figure 2A simple Cocoa application"></a><p><a name="//apple_ref/doc/uid/20002372-169708" title="Figure 2A simple Cocoa application"></a><strong>Figure 2&nbsp;&nbsp;</strong>A simple Cocoa application</p><img src = "../art/slider.gif" alt = "" width="294" height="220"></div><br/><p>This example illustrates the dynamism of the Cocoa environment—the values of two user interface objects are kept synchronized without writing any code, even without compiling. It also serves to illustrate the target-action design pattern (for more details, read <span class="content_text"><!--a target="_top" -->“The Target-Action Paradigm”<!--/a--></span>). </p><p>The major flaw from which this example suffers is that, as it is, it has almost no real-world application. In order to find out the value to which either the slider or the text field has been set, and update a model attribute accordingly, you need connections to the text field and slider, and have to write some code. You typically use a controller that is connected to both (using outlets) and to which both are connected (using target-action), as illustrated in <span class="content_text"><a href="WhatAreBindings.html#//apple_ref/doc/uid/20002372-172486-BAJCEHAD">Figure 3</a></span>.</p><br/><div><a name="//apple_ref/doc/uid/20002372-172486-BAJCEHAD" title="Figure 3Slider example using target-action"></a><p><a name="//apple_ref/doc/uid/20002372-172486" title="Figure 3Slider example using target-action"></a><strong>Figure 3&nbsp;&nbsp;</strong>Slider example using target-action</p><img src = "../art/slidertargetaction.gif" alt = "" width="438" height="220"></div><br/><p>When a user moves the slider, it sends an action message to its target (the controller). The controller in turn updates the value in the model, and synchronizes the user interface (the text field and the slider). Although this example is not particularly difficult, the situation becomes more complex if you use more complicated models and displays, especially if you use, for example, table views that allow multiple selections, or if a value may be displayed in a different window. And you have to write all the code to support this functionality. </p><p>Cocoa bindings uses prebuilt controller objects (subclasses of NSController) and supporting technologies to keep values synchronized automatically. The application design for an implementation of the slider example that uses bindings is shown in <span class="content_text">Figure 4</span>.</p><br/><div><a name="//apple_ref/doc/uid/20002372-181507-BCIHJDIB" title="Figure 4Slider demonstration using bindings"></a><p><a name="//apple_ref/doc/uid/20002372-181507" title="Figure 4Slider demonstration using bindings"></a><strong>Figure 4&nbsp;&nbsp;</strong>Slider demonstration using bindings</p><img src = "../art/sliderbindings.gif" alt = "" width="438" height="220"></div><br/><p>Note that this implementation does not use the target-action pattern. The slider does not send an action message to the controller. Instead, as the slider moves, it informs the controller directly that the value of its content’s number has changed and what the value is. The controller updates the model and in turn informs the text field and slider that the value they are displaying has changed. (In examples as simple as this controllers are not really necessary, however in most cases they are.) The mechanisms used to relay information are explained later in this article and in greater detail in <span class="content_text"><a href="HowDoBindingsWork.html#//apple_ref/doc/uid/20002373-CJBEJBHH">“How Do Bindings Work?,”</a></span> but it is important to appreciate that in most cases you will not have to write any glue code. </p><a name="//apple_ref/doc/uid/20002372-181534" title="Binding Options"></a><h3>Binding Options</h3><p>Many bindings allow you to specify options to customize their behavior. There are three types of option: value transformers, placeholders, and other parameters.</p><p>A value transformer, as its name implies, applies a transformation to a value. A value transformer may also allow reverse transformations. The Foundation framework provides the abstract NSValueTransformer class and several convenient transformers, including one that negates a value—that is, it turns a Boolean <code>YES</code> into <code>NO</code> (and vice versa). You can also implement your own transformers.</p><p>To see how transformers might be useful, suppose that in the previous example the number in the model represents temperature in degrees Fahrenheit, but that you want to display the value in Celsius. You could implement a reversible value transformer that converts values from one scale to the other. If you then specify it as the transformer option for the text field and slider, as shown in <span class="content_text"><a href="WhatAreBindings.html#//apple_ref/doc/uid/20002372-179879-BAJHFGAI">Figure 5</a></span>, the user interface displays the temperature in Celsius, and any new values entered using the slider or text field converted to Fahrenheit.</p><br/><div><a name="//apple_ref/doc/uid/20002372-179879-BAJHFGAI" title="Figure 5Displaying temperature using transformers"></a><p><a name="//apple_ref/doc/uid/20002372-179879" title="Figure 5Displaying temperature using transformers"></a><strong>Figure 5&nbsp;&nbsp;</strong>Displaying temperature using transformers</p><img src = "../art/temperaturetransformers.gif" alt = "" width="450" height="220"></div><br/><p>To learn more about transformers read <em><a href="../../ValueTransformers/index.html#//apple_ref/doc/uid/10000175i" target="_top">Value Transformer Programming Guide</a></em> (the article also shows an implementation of the Fahrenheit to Celsius transformer).</p><p>Placeholder options allow you to specify what a view should display: if the value of the property to which it is bound is null (nil); if there is no selection; if there is a multiple selection; or if for some other reason the value is not applicable.</p><p>In addition to value transformers and placeholders, some bindings offer a variety of other options, such as whether the value of the binding is updated as edits are made to the user interface item, or whether the editable state of a user interface item is automatically configured based on the controller’s selection. For a complete list of all the binding options available, see <em><a href="../../../Reference/CocoaBindingsRef/index.html#//apple_ref/doc/uid/10000189i" target="_top">Cocoa Bindings Reference</a></em>.</p><a name="//apple_ref/doc/uid/20002372-179967" title="Extending the MVC Design Pattern"></a><a name="//apple_ref/doc/uid/20002372-179967-BAJGAHGJ" title="Extending the MVC Design Pattern"></a><h3>Extending the MVC Design Pattern</h3><p>The Cocoa bindings architecture extends the traditional Cocoa MVC configuration, where there is a single custom-built controller that manages the user interface. It provides a set of reusable controller classes that inherit from an abstract superclass, NSController. In a bindings-based application there may be several controllers—your own (such as an NSWindowController subclass, managing a document’s user interface) and others that are subclasses of NSController and manage different parts of the user interface. You might also create your own subclasses of the standard Application Kit controller classes—in particular you might subclass NSArrayController to customize sorting and filtering behavior.</p><p>Other figures in this document present a convenient shorthand. Although the NSController instance is conceptually bound directly to its model object, in most situations the binding will be “indirect,” to a variable in your document object, as shown in <span class="content_text">Figure 6</span>.</p><br/><div><a name="//apple_ref/doc/uid/20002372-176110-BAJHDHDC" title="Figure 6Typical bindings configuration using existing controller"></a><p><a name="//apple_ref/doc/uid/20002372-176110" title="Figure 6Typical bindings configuration using existing controller"></a><strong>Figure 6&nbsp;&nbsp;</strong>Typical bindings configuration using existing controller</p><img src = "../art/bindings_controller.gif" alt = "" width="425" height="230"></div><br/><a name="//apple_ref/doc/uid/20002372-176805" title="Supporting Technologies"></a><h2>Supporting Technologies</h2><p>Cocoa bindings rely primarily on two other technologies, key-value coding (KVC) and key-value observing (KVO). Bindings themselves are established using key-value binding (KVB) as illustrated in <span class="content_text">Figure 7</span>. In practice you typically need to understand these technologies only if you want to create your own custom view with bindings. If you want to use bindings, the only requirement that is imposed on you is that your model classes must be compliant with key-value coding conventions for any properties to which you want to bind.</p><a name="//apple_ref/doc/uid/20002372-180761" title="Key-Value Binding"></a><h3>Key-Value Binding</h3><p>A binding is established with a <code>bind:toObject:withKeyPath:options:</code> message which tells the receiver to keep its specified attribute synchronized—modulo the options—with the value of the property identified by the key path of the specified object. The receiver must watch for relevant changes in the object to which it is bound and react to those changes. The receiver must also inform the object of changes to the bound attribute. After a binding is established there are therefore two aspects to keeping the model and views synchronized: responding to user interaction with views, and responding to changes in model values.</p><br/><div><a name="//apple_ref/doc/uid/20002372-180770-BAJBEHAB" title="Figure 7Bindings established using key-value binding"></a><p><a name="//apple_ref/doc/uid/20002372-180770" title="Figure 7Bindings established using key-value binding"></a><strong>Figure 7&nbsp;&nbsp;</strong>Bindings established using key-value binding</p><img src = "../art/key_value_bindings.gif" alt = "" width="426" height="220"></div><br/><p>In a view-initiated update a value changed in the user interface is passed to the controller, which in turn pushes the new value onto the model. To preserve the abstraction required to allow this to work with any controller or model object, the system uses a common access protocol—key-value coding.</p><p>In a model-initiated update models notify controllers, and controllers notify views, of changes to values in which interest has been registered using a common protocol—key-value observing. Note that a model-initiated update can be triggered by direct manipulation of the model—for example by a Scripted Apple event—or as the result of a view-initiated update—a change to the temperature made by editing the Celsius field must be propagated back to the slider.</p><a name="//apple_ref/doc/uid/20002372-180834" title="Key-Value Coding"></a><h3>Key-Value Coding</h3><p>Key-value coding is a mechanism whereby you can access a property in an object using the property’s name as a string—the “key.” You can also use key paths to follow relationships between objects. For example, given an Employee class with an attribute <code>firstName</code>, you could retrieve an employee’s first name using key-value coding with the key <code>firstName</code>. If Employee has a relationship called “manager” to another Employee, you could retrieve an employee’s manager’s first name using key-value coding with the key path <code>manager.firstName</code>. For more details, see <em><a href="../../KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i" target="_top">Key-Value Coding Programming Guide</a></em>.</p><p>Recall that a binding specifies the key path to a property to which a given attribute is bound. If the value in the slider or the text field is changed, it uses key-value coding—using the key path specified by the binding as the key—to communicate that change directly to the controller, as illustrated in <span class="content_text">Figure 8</span>. Note that the arrows in this figure represent the direction in which messages are sent and in which information flows. The new value is passed from the user interface widget to the controller, and from the controller to the model.</p><br/><div><a name="//apple_ref/doc/uid/20002372-177368-BCIJADFE" title="Figure 8Using key-value-coding to update values"></a><p><a name="//apple_ref/doc/uid/20002372-177368" title="Figure 8Using key-value-coding to update values"></a><strong>Figure 8&nbsp;&nbsp;</strong>Using key-value-coding to update values</p><img src = "../art/key_value_coding.gif" alt = "" width="426" height="220"></div><br/><a name="//apple_ref/doc/uid/20002372-177157" title="Key-Value Observing"></a><h3>Key-Value Observing</h3><p>Key-value observing is a mechanism whereby an object can register with another to be notified of changes to the value of a property. When one object is bound to another object, it registers itself as an observer of the relevant property of that object. In the current example, the text field and slider register as observers of the temperature property of the controller’s content, as illustrated in <span class="content_text">Figure 9</span>.</p><br/><div><a name="//apple_ref/doc/uid/20002372-177248-BCIEAFEA" title="Figure 9Key-value observing&acirc;&#128;&#148;registering observers"></a><p><a name="//apple_ref/doc/uid/20002372-177248" title="Figure 9Key-value observing&acirc;&#128;&#148;registering observers"></a><strong>Figure 9&nbsp;&nbsp;</strong>Key-value observing—registering observers</p><img src = "../art/key_value_observe_register.gif" alt = "" width="425" height="220"></div><br/><p>Note that the arrows shown in <span class="content_text">Figure 9</span> indicate direction of observation, not of data flow. Observation is a “passive” process (akin to registering to receive notifications from an NSNotificationCenter). When a value changes, the observed object sends a message to interested observers to notify them, as illustrated in <span class="content_text">Figure 10</span>. The arrows in <span class="content_text">Figure 10</span> show the direction in which messages are sent.</p><br/><div><a name="//apple_ref/doc/uid/20002372-177270-BCICEEHJ" title="Figure 10Key-value observing&acirc;&#128;&#148;notification of observers "></a><p><a name="//apple_ref/doc/uid/20002372-177270" title="Figure 10Key-value observing&acirc;&#128;&#148;notification of observers "></a><strong>Figure 10&nbsp;&nbsp;</strong>Key-value observing—notification of observers </p><img src = "../art/key_value_observing_notify.gif" alt = "" width="425" height="220"></div><br/><a name="//apple_ref/doc/uid/20002372-177085" title="Why Are NSControllers Useful?"></a><h2>Why Are NSControllers Useful?</h2><p>Bindings can, in principle, be made between almost any two objects, provided that they are KVC-compliant and KVO-compliant. A view could bind directly to a model object. Bindings-based applications, however, use controller objects to manage individual model objects and collections of model objects and to interface to the user preferences system. </p><p>It is possible to make bindings directly to your model objects or to controllers that do not inherit from NSController—however you lose (or must reimplement) functionality provided by the Application Kit’s controller objects.</p><ul class="ul"><li class="li"><p>NSController instances manage their current selection and placeholder values. This allows a view to display an appropriate value if the controller’s selection is null, or if there is a multiple selection.</p></li><li class="li"><p>NSController (and Application Kit user interface elements that support binding) implements the NSEditor and NSEditorRegistration protocols. The NSEditorRegistration protocol provides a means for an editor (a view) to inform a controller when it has uncommitted changes. The NSEditor protocol provides a means for requesting that the receiver commit or discard any pending edits.</p><p>For example, if a user is typing in a text field and then clicks a button, the controller ensures that the model object is updated with the complete contents of the text field before the button action takes place. </p><p>Although the methods are typically invoked on user interface elements by a controller they can also be sent to a controller, for example in response to a user’s attempt to save a document or quit an application.</p></li></ul><a name="//apple_ref/doc/uid/20002372-181113" title="NSController Classes"></a><h3>NSController Classes</h3><p>NSController is an abstract class. Its concrete subclasses are NSObjectController, NSUserDefaultsController, NSArrayController, and NSTreeController. NSObjectController manages a single object and provides the functionality discussed so far. NSUserDefaultsController provides a convenient interface to the preferences system.</p><p>NSArrayController and NSTreeController manage collections of model objects and track the current selection. The collection controllers also allow you to add objects to, and remove objects from, the content collection. The objects that the collection controllers manage don’t even have to be in an array—your container can implement suitable methods (“indexed accessor” methods, defined in the NSKeyValueCoding protocol) to present the values to the controller as if they were in an array. </p><a name="//apple_ref/doc/uid/20002372-196320" title="What Can You Bind?"></a><h2>What Can You Bind?</h2><p>You can make bindings for most of the Application Kit view classes, such as NSButton and NSTableView. Using an array controller, for example, you can bind the contents of a pop-up menu to objects in an array. The remainder of this article presents an example that is moderately complex. Although the details are intentionally left vague it nevertheless serves to illustrate a number of points, and provides examples of more complex bindings.</p><a name="//apple_ref/doc/uid/20002372-181136" title="Real-World Example"></a><h2>Real-World Example</h2><p>Consider a game application in which the user manages a number of combatants, from which they can select one as an attacker. A combatant can carry three weapons, one of which is selected at any time. In the application, the list of combatants is shown in a table view, the window’s title shows the attacker’s name, and a pop-up menu shows the currently selected weapon, as shown in <span class="content_text"><a href="WhatAreBindings.html#//apple_ref/doc/uid/20002372-181153-BAJIGIFE">Figure 11</a></span>.</p><br/><div><a name="//apple_ref/doc/uid/20002372-181153-BAJIGIFE" title="Figure 11User interface for Combatants application"></a><p><a name="//apple_ref/doc/uid/20002372-181153" title="Figure 11User interface for Combatants application"></a><strong>Figure 11&nbsp;&nbsp;</strong>User interface for Combatants application</p><img src = "../art/combatant_app.gif" alt = "" width="195" height="275"></div><br/><p>Combatants are represented by instances of the Combatant class. In the Combatant class, each weapon is referenced as a separate instance variable, as shown in <span class="content_text">Figure 12</span>. By implementing suitable “indexed” accessor methods (defined by the key-value coding protocol), however, the Combatant class can allow an array controller to access the weapons as if they were in an array.</p><br/><div><a name="//apple_ref/doc/uid/20002372-181175-BAJGACBI" title="Figure 12Combatant class"></a><p><a name="//apple_ref/doc/uid/20002372-181175" title="Figure 12Combatant class"></a><strong>Figure 12&nbsp;&nbsp;</strong>Combatant class</p><img src = "../art/combatant_class.gif" alt = "" width="150" height="112"></div><br/><p>When the user chooses an attacker from the table view, the window title is updated to reflect the attacker’s name, and the title of the pop-up menu is updated to reflect the attacker’s selected weapon. When the user activates the pop-up its contents are created dynamically from the set of weapons carried by the combatant. When the user selects a menu item, the combatant’s selected weapon is set to that corresponding to that menu item. If a different attacker is selected, the pop-up, selection and window title update accordingly.</p><p><span class="content_text"><a href="WhatAreBindings.html#//apple_ref/doc/uid/20002372-181202-BAJHIABJ">Figure 13</a></span> illustrates how the user interface of the Combatants application can be implemented using bindings. The table view is bound to an array controller that manages an array of combatants. The window title is bound to the name of the selected combatant. The pop-up menu retrieves its list of items from an array controller bound to the attacker’s weapons “array,” and its selection is bound to the attacker’s selected weapon. </p><br/><div><a name="//apple_ref/doc/uid/20002372-181202-BAJHIABJ" title="Figure 13Combatants application managed by bindings"></a><p><a name="//apple_ref/doc/uid/20002372-181202" title="Figure 13Combatants application managed by bindings"></a><strong>Figure 13&nbsp;&nbsp;</strong>Combatants application managed by bindings</p><img src = "../art/combatants_bindings.gif" alt = "" width="526" height="302"></div><br/><p>This example illustrates a number of points:</p><ul class="ul"><li class="li"><p>In an application you can use more than one controller object.</p></li><li class="li"><p>Different aspects of a user interface element may be bound to different controllers.</p></li><li class="li"><p>You can use your own custom model classes.</p></li></ul><p>Finally, it should be emphasized that the example requires no actual code to set up the user interface—the controllers and bindings can all be created in Interface Builder. This represents a considerable reduction in programming effort compared with the traditional target-action based approach.</p>

        <br/><br/> 

        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../CocoaBindings.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="HowDoBindingsWork.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2003, 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-03-08<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/CocoaBindings/Concepts/WhatAreBindings.html%3Fid%3D10000167i-5.7&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/CocoaBindings/Concepts/WhatAreBindings.html%3Fid%3D10000167i-5.7&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/CocoaBindings/Concepts/WhatAreBindings.html%3Fid%3D10000167i-5.7&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>
