/*//	GWorldUtils.c////	Created:	8/12/91 at 8:01:49 PM//	By:		Tony Myles//          Thanks Tony - grabbing this for the CIcon to GWorld stuff//	Description:	some utility routines to help create graphics worlds*/#include "ZAMProtos.h"#ifndef __MEMORY__#include <Memory.h>#endif#ifndef __TOOLUTILS__#include <ToolUtils.h>#endif#ifndef __RESOURCES__#include <Resources.h>#endif#include "GWorldUtils.h"/*//	create a new GWorld optimized for speed in copying//	to the graphics device that intersects the given rect.*/OSErr CreateOptimumGWorld(GWorldPtr *optGWorld, Rect *devRect){	OSErr err;	CGrafPtr saveCPort;	GDHandle saveGDevice;	GWorldPtr tempGWorld;	PixMapHandle pixMapH;	Rect tempRect = *devRect;	*optGWorld = NULL;	GetGWorld(&saveCPort, &saveGDevice);	LocalToGlobal((Point *)&tempRect.top);	LocalToGlobal((Point *)&tempRect.bottom);	err = NewGWorld(&tempGWorld, 0, &tempRect, NULL, NULL, 0);	if (err == noErr)	{		SetGWorld(tempGWorld, NULL);		EraseRect(&tempGWorld->portRect);		*optGWorld = tempGWorld;	}	SetGWorld(saveCPort, saveGDevice);	return err;}/*	BRS _ tweaked so I can add a CTable*/OSErr CreateGWorldWithCTable(GWorldPtr *optGWorld, Rect *devRect, CTabHandle ctable){	OSErr err;	CGrafPtr saveCPort;	GDHandle saveGDevice;	GWorldPtr tempGWorld;	PixMapHandle pixMapH;	Rect tempRect = *devRect;	*optGWorld = NULL;	GetGWorld(&saveCPort, &saveGDevice);	LocalToGlobal((Point *)&tempRect.top);	LocalToGlobal((Point *)&tempRect.bottom);	err = NewGWorld(&tempGWorld, 0, &tempRect, ctable, NULL, 0);	if (err == noErr)	{		SetGWorld(tempGWorld, NULL);		EraseRect(&tempGWorld->portRect);		*optGWorld = tempGWorld;	}	SetGWorld(saveCPort, saveGDevice);	return err;}/*//	creates a offScreen GWorld and draws the specified pict into it*/OSErr CreateGWorldFromPict(GWorldPtr *pictGWorld, PicHandle pictH){	OSErr err;	CGrafPtr saveCPort;	GDHandle saveGDevice;	GWorldPtr tempGWorld;	PixMapHandle tempPixHdl;	Rect pictRect;	*pictGWorld = NULL;	GetGWorld(&saveCPort, &saveGDevice);	pictRect.left = pictRect.top = 0;	pictRect.right = (**pictH).picFrame.right - (**pictH).picFrame.left;	pictRect.bottom = (**pictH).picFrame.bottom - (**pictH).picFrame.top;	err = CreateOptimumGWorld(&tempGWorld, &pictRect);	if (err == noErr)	{		*pictGWorld = tempGWorld;		SetGWorld(tempGWorld, NULL);		tempPixHdl = GetGWorldPixMap(tempGWorld);		if (LockPixels(tempPixHdl))		{			DrawPicture(pictH, &pictRect);			UnlockPixels(tempPixHdl);		}	}	SetGWorld(saveCPort, saveGDevice);	return err;}/*	BRS - Creates a GWORLD from the pict and attaches the color table to it.*/OSErr CreateGWorldFromPictWithCTable(GWorldPtr *pictGWorld, PicHandle pictH,CTabHandle ctable){	OSErr err;	CGrafPtr saveCPort;	GDHandle saveGDevice;	GWorldPtr tempGWorld;	PixMapHandle tempPixHdl;	Rect pictRect;	*pictGWorld = NULL;	GetGWorld(&saveCPort, &saveGDevice);	pictRect.left = pictRect.top = 0;	pictRect.right = (**pictH).picFrame.right - (**pictH).picFrame.left;	pictRect.bottom = (**pictH).picFrame.bottom - (**pictH).picFrame.top;	err = CreateGWorldWithCTable(&tempGWorld, &pictRect, ctable);	if (err == noErr)	{		*pictGWorld = tempGWorld;		SetGWorld(tempGWorld, NULL);		tempPixHdl = GetGWorldPixMap(tempGWorld);		if (LockPixels(tempPixHdl))		{			DrawPicture(pictH, &pictRect);			UnlockPixels(tempPixHdl);		}	}	SetGWorld(saveCPort, saveGDevice);	return err;}OSErr CreateGWorldFromPictResource(GWorldPtr *pictGWorldP, short pictResID){	OSErr err;	PicHandle newPictH;	newPictH = GetPicture(pictResID);	if (newPictH != NULL)	{		err = CreateGWorldFromPict(pictGWorldP, newPictH);		ReleaseResource((Handle)newPictH);	}	return err;}OSErr CreateGWorldFromCIconResource(GWorldPtr *iconGWorldP, short iconResID){	OSErr err;	CIconHandle cIconH;	cIconH = GetCIcon(iconResID);	if (cIconH != NULL)	{		HNoPurge((Handle)cIconH);		if (iconGWorldP != NULL)		{			err = CreateGWorldFromCIcon(iconGWorldP, cIconH);		}		DisposeCIcon(cIconH);	}	return err;}OSErr CreateGWorldFromCIcon(GWorldPtr *iconGWorldP, CIconHandle cIconH){	OSErr err;	CGrafPtr saveCPort;	GDHandle saveGDevice;	char saveState;	GWorldPtr tempGWorldP;	PixMapHandle iconPixMapH;	Rect iconRect;	*iconGWorldP = NULL;	GetGWorld(&saveCPort, &saveGDevice);	iconRect = (**cIconH).iconPMap.bounds;	err = CreateOptimumGWorld(&tempGWorldP, &iconRect);	if (err == noErr)	{		*iconGWorldP = tempGWorldP;		SetGWorld(tempGWorldP, NULL);		iconPixMapH = GetGWorldPixMap(tempGWorldP);		if (LockPixels(iconPixMapH))		{						PlotCIcon(&iconRect, cIconH);						UnlockPixels(iconPixMapH);		}	}	SetGWorld(saveCPort, saveGDevice);	return err;}OSErr CreateGWorldFromCIconMask(GWorldPtr *maskGWorldP, CIconHandle cIconH){	OSErr err;	CGrafPtr saveCPort;	GDHandle saveGDevice;	char saveState;	BitMap iconMask;	GWorldPtr tempGWorldP;	PixMapHandle maskPixMapH;	GetGWorld(&saveCPort, &saveGDevice);	saveState = HGetState((Handle)cIconH);	HLock((Handle)cIconH);	iconMask.rowBytes = (**cIconH).iconMask.rowBytes;	iconMask.bounds = (**cIconH).iconMask.bounds;	iconMask.baseAddr = (Ptr)(**cIconH).iconMaskData;	err = CreateOptimumGWorld(&tempGWorldP, &iconMask.bounds);	if (err == noErr)	{		*maskGWorldP = tempGWorldP;		SetGWorld(tempGWorldP, NULL);		maskPixMapH = GetGWorldPixMap(tempGWorldP);		if (LockPixels(maskPixMapH))		{			CopyBits(&iconMask, (BitMapPtr)*maskPixMapH,						&iconMask.bounds, &iconMask.bounds,						srcCopy, NULL);						UnlockPixels(maskPixMapH);		}	}	SetGWorld(saveCPort, saveGDevice);	HSetState((Handle)cIconH, saveState);	return err;}OSErr CreateRegionFromCIconMask(RgnHandle *maskRgn, CIconHandle cIconH){	OSErr err = noErr;	RgnHandle tempMaskRgn;	char saveState;	BitMap iconMask;	*maskRgn = NULL;	saveState = HGetState((Handle)cIconH);	HLock((Handle)cIconH);	iconMask.rowBytes = (**cIconH).iconMask.rowBytes;	iconMask.bounds = (**cIconH).iconMask.bounds;	iconMask.baseAddr = (Ptr)(**cIconH).iconMaskData;	tempMaskRgn = NewRgn();	if (tempMaskRgn != NULL)	{		err = BitMapToRegion(tempMaskRgn, &iconMask);		if (err == noErr)		{			*maskRgn = tempMaskRgn;		}		else		{			DisposeRgn(tempMaskRgn);		}	}	else	{		err = MemError();	}	HSetState((Handle)cIconH, saveState);	return err;}