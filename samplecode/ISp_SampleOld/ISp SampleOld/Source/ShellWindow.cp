/*	File:		ShellWindow.cp	Contains:	xxx put contents here xxx	Version:	xxx put version here xxx	Copyright:	© 1999 by Apple Computer, Inc., all rights reserved.	File Ownership:		DRI:				xxx put dri here xxx		Other Contact:		xxx put other contact here xxx		Technology:			xxx put technology here xxx	Writers:		(BWS)	Brent Schorsch	Change History (most recent first):	   <SP1>	  7/1/99	BWS		first checked in*///¥	ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	Includes#include <Controls.h>#include <MacWindows.h>#include <ToolUtils.h>#include "ShellWindow.h"#include "ToolboxUtils.h"//¥	ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	Private Definitions//¥	ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	Private Types//¥	ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	Private Variables//¥	ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	Private Functions//¥	ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	Public VariablesShellWindow::ShellWindow(){}ShellWindow::~ShellWindow(){}//¥	ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	ShellWindow::ShowvoidShellWindow::Show(void){	::ShowWindow(window);}//¥	ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	ShellWindow::HidevoidShellWindow::Hide(void){	::HideWindow(window);}//¥	ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	ShellWindow::MakeCurrentPortvoidShellWindow::MakeCurrentPort(void){	::SetPort(window);}//¥	ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	ShellWindow::SetTitlevoidShellWindow::SetTitle(const Str255 inTitle){	::SetWTitle(window, inTitle);}//¥	ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	ShellWindow::SetWidthvoidShellWindow::SetWidth(const UInt32 inWidth){Rect	r;	r = window->portRect;	r.right = r.left + inWidth;		::SizeWindow(window, r.right - r.left, r.bottom - r.top, true);}//¥	ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	ShellWindow::SetHeightvoidShellWindow::SetHeight(const UInt32 inHeight){Rect	r;	r = window->portRect;	r.bottom = r.top + inHeight;		::SizeWindow(window, r.right - r.left, r.bottom - r.top, true);}//¥	ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	ShellWindow::WidthshortShellWindow::Width(void){	return (window->portRect.right - window->portRect.left);}//¥	ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	ShellWindow::HeightshortShellWindow::Height(void){	return (window->portRect.bottom - window->portRect.top);}//¥	ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	ShellWindow::MoveTovoidShellWindow::MoveTo(const SInt32 inH, const SInt32 inY){Boolean	isFrontWindow;	if (window == ::FrontWindow())		isFrontWindow = true;	else		isFrontWindow = false;			::MoveWindow(window, inH, inY, isFrontWindow);}	//¥	ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	ShellWindow::MostOnWhichMonitorGDHandleShellWindow::MostOnWhichMonitor(void){GDHandle	mostMonitor = nil;GDHandle	monitor;UInt32		mostArea = 0U, area;Rect		r, windowRect;GrafPtr		oldPort;GDHandle	mainMonitor;			::GetPort(&oldPort);	MakeCurrentPort();		windowRect = window->portRect;	LocalToGlobalRect(&windowRect);		mainMonitor = ::GetMainDevice();	monitor = ::GetDeviceList();	while (nil != monitor)	{		::SectRect(&windowRect, & (**monitor).gdRect, &r);		::OffsetRect(&r, -r.left, -r.top);		area = r.right * r.bottom;				if (area > mostArea)		//¥	Favor the device that has the most area		{			mostArea = area;			mostMonitor = monitor;		}		else if (area == mostArea)	//¥	But if it's equal to the main monitor, favor main		{			if ((monitor == mainMonitor) || (mostMonitor == mainMonitor))				mostMonitor = mainMonitor;		}				monitor = ::GetNextDevice(monitor);	}		::SetPort(oldPort);	return (mostMonitor);}#pragma mark -//¥	ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	ShellWindow::ActivatevoidShellWindow::Activate(const Boolean inActivate){	::HiliteWindow(window, inActivate);	::DrawGrowIcon(window);}//¥	ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	ShellWindow::UpdatevoidShellWindow::Update(void){GrafPtr		oldPort;WindowPtr	theWindow = window;	::GetPort(&oldPort);	MakeCurrentPort();	::BeginUpdate(theWindow);	::ClipRect(&theWindow->portRect);	::EraseRect(&theWindow->portRect);	::DrawControls(theWindow);	::DrawGrowIcon(theWindow);	::EndUpdate(theWindow);		::SetPort(oldPort);}//¥	ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	ShellWindow::SelectvoidShellWindow::Select(void){	::SelectWindow(window);	MakeCurrentPort();}//¥	ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	ShellWindow::ClickOSErrShellWindow::Click(const Point inWhere, const short inModifiers){#pragma unused (inWhere, inModifiers)	if (FrontWindow() != window)		::SelectWindow(window);	return (noErr);}//¥	ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	ShellWindow::KeyOSErrShellWindow::Key(const UInt8 inChar, const UInt8 inKey, const short inModifiers){#pragma unused (inChar, inKey, inModifiers)	return (noErr);}//¥	ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	ShellWindow::GrowOSErrShellWindow::Grow(const Point inWhere){Rect		sizeRect;long		result;WindowPtr	theWindow = window;	sizeRect.top = 80;	sizeRect.left = 80;	sizeRect.bottom = 440;	sizeRect.right = 640;		result = ::GrowWindow(theWindow, inWhere, &sizeRect);	if (0 != result)	{	GrafPtr	oldPort;			::SizeWindow(theWindow, LoWord(result), HiWord(result), false);				::GetPort(&oldPort);		MakeCurrentPort();				::InvalRect(&theWindow->portRect);				::SetPort(oldPort);	}	return (noErr);}//¥	ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	ShellWindow::ZoomOSErrShellWindow::Zoom(const short inZoomDir){#pragma unused (inZoomDir)	return (noErr);}//¥	ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	ShellWindow::CloseOSErrShellWindow::Close(void){	return (noErr);}//¥	ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	ShellWindow::IdlevoidShellWindow::Idle(void){	::IdleControls(window);}//¥	ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	ShellWindow::MenuBooleanShellWindow::Menu(const UInt32 inMenuCommand, const short inModifiers){#pragma unused (inMenuCommand, inModifiers)	return (false);}//¥	ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	ShellWindow::HelpvoidShellWindow::Help(const Point inWhere){#pragma unused (inWhere)}//¥	ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	ShellWindow::DragBooleanShellWindow::Drag(const Point inWhere, const short inModifiers){#pragma unused (inModifiers)	::DragWindow(window, inWhere, &(**GetGrayRgn()).rgnBBox);	return (false);}//¥	ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	ShellWindow::SuspendvoidShellWindow::Suspend(void){}//¥	ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	ShellWindow::ResumevoidShellWindow::Resume(void){}