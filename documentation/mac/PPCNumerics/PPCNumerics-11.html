<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>About the IEEE Standard(IM:PN)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING11></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="PPCNumerics-10.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="PPCNumerics-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="PPCNumerics-192.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="PPCNumerics-12.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="PPCNumerics-2.html"><B>PowerPC Numerics </B></A> / <A HREF="PPCNumerics-9.html"><B>Part 1 - The PowerPC Numerics Environment</B></A><BR><DD><A HREF="PPCNumerics-10.html"><B>Chapter 1 - IEEE Standard Arithmetic</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING11-0></A>
<H1>About the IEEE Standard</H1>
 <B><A NAME=MARKER-2-5></A>PowerPC Numerics</B> is a floating-point environment that complies with IEEE Standard 754. There are two IEEE standards for floating-point arithmetic: <BR><B>IEEE Standard 754</B> for binary floating-point arithmetic and <B>IEEE Standard 854</B> for radix-independent floating-point arithmetic. When you see the term <B>IEEE standard</B> in this book without a number following, it means IEEE Standard 754. <A NAME=MARKER-2-28></A><P>
 <A NAME=MARKER-2-39></A>The IEEE standards ensure that computers represent real numbers as accurately as possible and that computers perform arithmetic on real numbers as accurately as possible. Although there are infinitely many real numbers, a computer can represent only a finite number of them. Computers represent real numbers as <B>binary floating-point numbers</B>. Binary floating-point numbers can represent real numbers exactly in relatively few cases; in all other cases the representation is approximate. For example, 1/2 (0.5 in decimal) can be represented exactly in binary as 0.1. Other real numbers that can be represented exactly in decimal have repeating digits in binary and hence cannot be represented exactly, as shown in <A HREF=#MARKER-9-1>Table 1-1</A>. For example, 1/10, or decimal 0.1 exactly, is 0.000110011 <EM>. . . </EM>in binary. Errors of this kind are unavoidable in any computer approximation of real numbers. Because of these errors, sums of fractions are often slightly incorrect. For example, 4/3 - 5/6 is not exactly equal to 1/2 on any computer, even on computers that use IEEE standard arithmetic.
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><A NAME=MARKER-9-1></A><B>Table 1-1 Approximation of real numbers</B></CAPTION>
<TH>Fraction<TH>Decimal approximation<TH>Binary approximation<TR>
<TD>1/10<TD>0.1000000000<A HREF="#FOOTNOTE-3">[3]</A><TD>0.000110011001100110011001101<TR>
<TD>1/2<TD>0.5000000000<A HREF="#FOOTNOTE-3">[3]</A><TD>0.100000000000000000000000<A HREF="#FOOTNOTE-3">[3]</A><TR>
<TD>4/3<TD>1.333333333<TD>1.01010101010101010101011<TR>
<TD>5/6<TD>0.8333333333<TD>0.110101010101010101010101<TR>
<TD>4/3 - 5/6<TD>0.4999999997<TD>0.100000000000000000000001</TABLE>
<A NAME=MARKER-2-33></A><P>
 <P>
 <P>
 <P>
 The IEEE standard defines data formats for floating-point numbers, shows how to interpret these formats, and specifies how to perform operations (known as <B>floating-point operations</B>) on numbers in these formats. It requires the following types of floating-point operations:<P>
<UL>
<LI>basic arithmetic operations (add, subtract, multiply, divide, square root, remainder, and round-to-integer)
<LI>conversion operations, which convert numbers to and from the floating-point data formats
<LI>comparison operations, such as less than, greater than, and equal to
<LI>environmental control operations, which manipulate the floating-point environment<P>
</UL>
 The IEEE standard requires that the basic arithmetic operations have the following attributes:<P>
<UL>
<LI>The result must be accurate in the precision in which the operation is performed. When a numerics environment is performing a floating-point operation, it calculates the result to a predetermined number of binary digits. This number of digits is called the <B>precision.</B> The result must be correct to the last binary digit.<A NAME=MARKER-9-10></A><A NAME=MARKER-2-62></A>
<LI>If the result cannot be represented exactly in the destination data format, it must be changed to the closest value that can be represented, using <B>rounding.</B> See the section <A HREF=#MARKER-9-13>"Careful Rounding" on page 1-5</A> for more information on why careful rounding is important.
<LI>If an invalid input is provided or if the result cannot be represented exactly, a floating-point <B>exception</B> must be raised. See the section <A HREF=#MARKER-9-19>"Exception Handling" on page 1-6</A> for a description of why exception handling is important in floating-point arithmetic.<P>
</UL>
<A NAME=HEADING11-15></A>
<H2>Starting to Use IEEE Arithmetic</H2>
 You can get the benefit of much of the IEEE standard without special programming techniques; you simply use the floating-point variable formats and operations available in the programming language in which you are working, and the computer takes care of the rest. Other features might require changes to your applications. If you are new to numerical programming, you should approach the IEEE standard features in three stages:<P>
<OL>
<LI>Recompile your old programs with no changes; you will get many of the benefits.
<LI>Make small changes to obtain more benefits. For example, at this stage you might remove all code that tests for division by zero.
<LI>Use the advanced features, such as environmental controls, for special applications.<P>
</OL>
 If you already use the IEEE standard features but your application is written for a non-Macintosh computer, see <A HREF=PPCNumerics-169.html#MARKER-9-1>Appendix B, "Porting Programs to PowerPC Numerics."</A><P>
<A NAME=HEADING11-21></A>
<H2><A NAME=MARKER-9-13></A>Careful Rounding </H2>
 <A NAME=MARKER-2-5></A>If the result of an IEEE arithmetic operation cannot be represented exactly in binary format, the number is rounded. IEEE arithmetic normally rounds results to the nearest value that can be represented in the chosen data format. The difference between the exact result and the represented result is the <B>roundoff error.</B><P>
 The IEEE standard requires that users be able to choose to round in directions other than to the nearest value. For example, sometimes you might want to know that rounding has not invalidated a computation. One way to do that would be to force the rounding direction so that you can be sure your results are higher (or lower) than the exact answer. Because it conforms to the IEEE standard, PowerPC Numerics gives you a means of doing that. Fully developed, this strategy is called <I>interval arithmetic</I> (Kahan 1980). For complete details on rounding directions, see <A HREF=PPCNumerics-55.html#MARKER-9-12>Chapter 4, "Environmental Controls."</A> <A NAME=MARKER-2-46></A><I><A NAME=MARKER-2-19></A></I><P>
 <A NAME=MARKER-2-60></A>The following example is a simple demonstration of the advantages of careful rounding. Suppose your application performs operations that are mutually inverse; that is, operations 
<MATH>
y = f(x)
</MATH>

,  
<MATH>
x = g(y)
</MATH>

,  such that 
<MATH>
g(f(x)) = x
</MATH>

. There are many such operations, such as<P>
 
<MATH>
y = x<SUP>2</SUP>
</MATH>

,  
<MATH>
x = SQRTy
</MATH>

<P>
 
<MATH>
y = 375x
</MATH>

,  
<MATH>
x = y/375
</MATH>

<P>
 Suppose 
<MATH>
F(x)
</MATH>

 is the computed value of 
<MATH>
f(x)
</MATH>

, and 
<MATH>
G(y)
</MATH>

 is the computed value of 
<MATH>
g(y)
</MATH>

. Because many numbers cannot be represented exactly in binary, the computed values 
<MATH>
F(x)
</MATH>

 and 
<MATH>
G(y)
</MATH>

 will often differ from 
<MATH>
f(x)
</MATH>

 and 
<MATH>
g(y)
</MATH>

. Even so, if both functions are continuous and well behaved, and if you always round 
<MATH>
F(x)
</MATH>

 and 
<MATH>
G(y)
</MATH>

 to the nearest value, you might expect your computer arithmetic to return <I>x</I> when it performs the cycle of inverse operations, 
<MATH>
G(F(x))
</MATH>

. It is difficult to predict when this relation will hold for computer numbers. Experience with other computers says it is too much to expect, but IEEE arithmetic very often returns the correct inverse value.<P>
 The reason for IEEE arithmetic's good behavior with respect to inverse operations is that it rounds so carefully. Even with all operations in, say, single precision, it evaluates the expression 3 <EM></EM> 1/3 to 1.0 exactly; some computers that do not follow the standard do not evaluate this expression exactly. If you find that surprising, you might enjoy running the code example in <A HREF=#MARKER-9-18>Listing 1-1</A> on a computer that does not use IEEE arithmetic and then on a PowerPC processor-based Macintosh computer. The default rounding provided by the numerics environment gives good results; the PowerPC processor-based Macintosh computer prints "No failures." The program will fail on a computer that doesn't have IEEE arithmetic--in particular, that doesn't round halfway cases in the same way that the IEEE standard's default rounding direction mode does.<P>
<B>Listing 1-1  <A NAME=MARKER-9-18></A>Inverse operations</B><P>
<PRE>
#include &lt;stdio.h&gt;
main()
{
   float x, y, a, b;
   int ix, iy, 
   int nofail = 1;      /* Boolean, initialized to true */

   for (ix = 1; ix &lt;= 12; ix++) {
      if ((ix != 7) &amp;&amp; (ix != 11)) {      /* x is a sum of powers of two */
         for (iy = 1; iy &lt;= 50; iy++) {
            x = ix;
            y = iy;
            a = y / x;
            b = x * a;        /* b == (x * y / x) == y */
            if (b != y) {
               nofail = 0;    /* false */
               printf(&quot;It failed for x = %d, y = %d\n&quot;, ix, iy);
            }
         }
      }
   }
   if (nofail) printf(&quot;No failures\n&quot;);
}
</PRE>
<A NAME=HEADING11-31></A>
<H2><A NAME=MARKER-9-19></A>Exception Handling</H2>
 <A NAME=MARKER-2-20></A>The IEEE standard defines five exceptions that indicate when an exceptional event has occurred. They are<P>
<UL>
<LI>invalid operation
<LI>underflow
<LI>overflow
<LI>division by zero
<LI>inexact result<P>
</UL>
 <A NAME=MARKER-2-18></A>There are three ways your application can deal with exceptions:<P>
<UL>
<LI>Continue operation.
<LI>Stop on exceptions if you think they will invalidate your results.
<LI>Include code to do something special when exceptions happen.<P>
</UL>
 The IEEE standard lets programs deal with the exceptions in reasonable ways. It defines the special values NaN (Not-a-Number) and Infinity, which allow a program to continue operation; see the section <A HREF=PPCNumerics-17.html#MARKER-9-36>"Interpreting Floating-Point Values"</A> in <A HREF=PPCNumerics-49.html#MARKER-9-18>Chapter 2, "Floating-Point Data Formats."</A> The IEEE standard also defines exception flags, which a program can test to detect exceptional events.<A NAME=MARKER-2-42></A><A NAME=MARKER-2-48></A><P>
 IEEE arithmetic allows the option to stop computation when exceptional events arise, but there are good reasons why you might prefer not to have to stop. The following examples illustrate some of those reasons.<P>
<A NAME=HEADING11-44></A>
<H3>Example: Finding Zero Return Values</H3>
 Suppose you want to find the first positive integer that causes a function to cross the x-axis. A simple version of the code might look like this:<P>
<PRE>
for (i = 0; i &lt; MAXVALUE; i++)
   if (func(i) == 0)
      printf(&quot;It crosses when x = %g\n&quot;, i);
</PRE>
 Further, suppose that <CODE>func</CODE> was defined like this:<P>
<PRE>
double func(double x)
{
   return(sqrt(x - 3));
}
</PRE>
 The intent of the <CODE>for</CODE> loop is to find out where the function crosses the x-axis and print out that information; it does not really care about the value returned from <CODE>func</CODE> unless the value is 0. However, this loop will fail when <CODE>i</CODE> is less than 3 because you cannot take the square root of a negative number. With a C compiler that supports PowerPC Numerics, performing the square root operation on a negative number returns a NaN, allowing the loop to produce the desired result. To obtain the desired result on all computers, something more cumbersome would have to be written. By allowing the square root of a negative number, PowerPC Numerics allows more straightforward code.<P>
 This program fragment demonstrates the principal service performed by NaNs: they permit deferred judgments about variables whose values might be unavailable (that is, uninitialized) or the result of invalid operations. Instead of having the computer stop a computation as soon as a NaN appears, you might prefer to have it continue if whatever caused the NaN is irrelevant to the solution.<P>
<A NAME=HEADING11-51></A>
<H3>Example: Searching Without Stopping </H3>
 <A NAME=MARKER-2-41></A>Suppose a program has to search through a database for a maximum value that has to be calculated. The search loop might call a subroutine to perform some calculation on the data in each record and return a value for the program to test or compare. The code might look like this:<P>
<PRE>
max = -INFINITY;
for (i = 0; i &lt; MAXRECORDS; i++)
   if((temp = computation(record[i].value)) &gt; max)
      max = temp;
</PRE>
 Suppose that the <CODE>value</CODE> field of the <CODE>record</CODE> structure is not a required field when the data is entered, so that for some records, data might be nonexistent or invalid. In many machines, that would cause the program to stop. To avoid having the program stop during the search, you would have to add tests for all the exceptional cases. With PowerPC Numerics, the subroutine <CODE>computation</CODE> does not stop for nonexistent or invalid data; it simply returns a NaN.<P>
 This is another example of the way arithmetic that includes NaNs allows the program to ignore irrelevancies, even when they cause invalid operations. Using arithmetic without NaNs, you would have to anticipate all exceptional cases and add code to the program to handle every one of them in advance. With NaNs, you can handle all exceptional cases after they have occurred, or you can simply ignore them, as in this example.<A NAME=MARKER-9-35></A><P>
<A NAME=HEADING11-56></A>
<H3>Example: Parallel Resistances </H3>
 <A NAME=MARKER-9-24></A>Like NaNs, Infinities enable the program to handle cases that otherwise would require special programming to keep from stopping. Here is an example where arithmetic with Infinities is entirely reasonable.<P>
 When three electrical resistances R1, R2, and R3 are connected in parallel, as shown in <A HREF=#MARKER-9-27>Figure 1-1</A>, their effective resistance is the same as a single resistance whose value R123 is given by this formula: <P>
 
<MATH>
R123 = 1 OVER 1 OVER R1+1 OVER R2+1 OVER R3
</MATH>

<P>
<B>Figure 1-1  <A NAME=MARKER-9-27></A>Parallel resistances</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/PPCN-L-01.jpg"><P>
 The formula gives correct results for positive resistance values between 0 (corresponding to a short circuit) and &#176; (corresponding to an open circuit) inclusive. On computers that do not allow division by zero, you would have to add tests designed to filter out the cases with resistance values of zero. (Negative values can cause trouble for this formula, regardless of the style of the arithmetic, but that reflects their troublesome nature in circuits, where they can cause instability.)<A NAME=MARKER-2-66></A><P>
 Arithmetic with Infinities usually gives reasonable results for expressions in which each independent variable appears only once.<A NAME=MARKER-2-48></A><A NAME=MARKER-9-13></A><A NAME=MARKER-2-61></A><A NAME=MARKER-2-11></A><P>
<HR>

<A NAME="FOOTNOTE-3">[3] Exact value

</BLOCKQUOTE>
<HR>
<center>
<A HREF="PPCNumerics-10.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="PPCNumerics-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="PPCNumerics-192.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="PPCNumerics-12.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="PPCNumerics-3.html">&copy; Apple Computer, Inc.</A><br>13 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
