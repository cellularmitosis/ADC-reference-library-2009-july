<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>PictMovier - /pictmovier.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxQuickTime-date.html">QuickTime</a> &gt; <A HREF="javascript:location.replace('index.html');">PictMovier</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/QuickTime/index.html" target="_blank">Reference Library > QuickTime</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">PictMovier</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/pictmovier.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/pictmovier.c</option>
<option value="listing2.html">/pictmovier.r</option></select>
				</p>
				</form>
				<p><strong><a href="PictMovier.zip">Download Sample</a></strong> (&#147;PictMovier.zip&#148;, 2.58M)<BR>
<strong><a href="PictMovier.dmg">Download Sample</a></strong> (&#147;PictMovier.dmg&#148;, 2.92M)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    PictMovier.c  Contains:  Application to make a movie from PICTs with various processes  Written by:  Mark Krueger  Copyright:  &copy; 1990-1994 by Apple Computer, Inc., all rights reserved.  Change History (most recent first):  12/06/94      khs    Fixes for MW  06/05/94      PM/MHK  New Today        This example shows how you can make movies by doing processing on pictures.  This allows a process that takes a long time to be shown at much faster rates  as a QuickTime movie. Any type of processing can be done, such as filtering,   transitions, 3-D transformations. This example shows two trivial examples.  The first simple does a linear cross fade between two images. The second creates  a random dot stereogram ( an image that if you stare at it long enough you can  see three dimensional depth in ( without special glasses ). This works from a single  image and shows how the effect can be varied from frame to frame.  Note that the code is not necessarily well commented, but should prove useful as   a jumping off point for making your own movie creation applications.*/// INCLUDES#include  &lt;Types.h&gt;#include  &lt;Files.h&gt;#include  &lt;Quickdraw.h&gt;#include  &lt;Packages.h&gt;#include  &lt;Memory.h&gt;#include  &lt;Fonts.h&gt;#include  &lt;Events.h&gt;#include  &lt;OSUtils.h&gt;#include  &lt;ToolUtils.h&gt;#include  &lt;Menus.h&gt;#include  &lt;Dialogs.h&gt;#include  &lt;stdio.h&gt;#include  &lt;Errors.h&gt;#include  &lt;Scrap.h&gt;#include  &lt;Desk.h&gt;#include  &lt;string.h&gt;#include  &lt;GestaltEqu.h&gt;#include  &lt;Resources.h&gt;#include  &lt;Finder.h&gt;#include  &lt;PictUtil.h&gt;#include  &lt;palettes.h&gt;#include  &lt;OSEvents.h&gt;#include  &lt;Math.h&gt;#include  &lt;SegLoad.h&gt;#include  &lt;Windows.h&gt;#ifndef  THINK_C#include  &lt;Strings.h&gt;#endif#include  &lt;ImageCompression.h&gt;#include   &lt;QuickTimeComponents.h&gt;#include  &lt;Components.h&gt;#include  &lt;Movies.h&gt;// DEFINES#define kNumberSteps  30#define kFrameRate 10      /* frames per second */#define  kCodecID  anyCodec#define  kCodecType  (CodecType) 'rpza'#define  kCodecDepth 32#define  kCodecQuality  codecNormalQuality// FUNCTION PROTOTYPESvoid FixMenus(void);void SetupMenus(void);void Error(char* msg, OSErr code);void ShowAboutBox(void);void Initialize(void);long DoClose(WindowPtr wind);void SetCompression(void);void SetStages(void);void DoHLock(Handle h);void DoHUnlock(Handle h);void DoDisposHandle(Handle h);void DoPreview(void);void DoMovie(void);void DoCopy(void);void DoCut(void);void DoPaste(void);void DoClear(void);void DoUndo(void);Boolean HandleEvents(EventRecord* myEvent);OSErr DoOpen(FSSpec* fsp);long BetterRand(long reseed);unsigned char DecodeDepth(unsigned char pix);void DoCrossFade(long stageNum,         long totalStages,         Boolean reverse);void DoRandomDotStereogram(long stageNum,               long totalStages,               Boolean reverse);void DoStage(long stageNum,       long totalStages,       Boolean reverse);void DoClear();void DoUpdate(CWindowPtr wind);short DoCommand(long mResult);OSErr AllocateBuffers(void);CWindowPtr MakeSWindow(Rect* frame,             StringPtr name,             GWorldPtr buffer);// GLOBALSCWindowPtr gSrcWindow = nil;CWindowPtr gAltWindow = nil;CWindowPtr gDstWindow = nil;Rect gOriginalPicFrame;Boolean gZoomed = false;Boolean gFitToWindow = true;Boolean gHasNewStdFile = false;PicHandle gOriginalPicture = nil;Boolean gCompressed = false;GWorldPtr gWorld = nil;GWorldPtr gAltWorld = nil;GWorldPtr gDstWorld = nil;GWorldPtr gBufferWorld = nil;long gFrameNumber = -1;MenuHandle gMenus[4];              // our menusBoolean gExitFlag = false;WindowPtr gActiveWindow = nil;Rect gRect;short gStripWidth = 128;short gDepthFactor = 16;Boolean gDepthDecodeTabInted = false;CodecType gCodecType = kCodecType;CodecQ gCodecQuality = kCodecQuality;CodecQ gCodecTemporalQuality = 0;short gCodecDepth = kCodecDepth;long gFrameRate = kFrameRate;long gKeyFrameRate = kFrameRate;CodecComponent gCodecID = kCodecID;long gNumberSteps = kNumberSteps;Boolean gOversample = false;Boolean gBackwards = false;#define    APPLE_MENU  0#define    APPLE_MENU_ID  128#define    FILE_MENU  1#define    FILE_MENU_ID  129#define    FILE_M_OPEN  1#define    FILE_M_CLOSE 2#define    FILE_M_SAVE  3#define    FILE_M_QUIT  5#define    EDIT_MENU  2#define    EDIT_MENU_ID  130#define    EDIT_M_UNDO    1#define    EDIT_M_CUT    3#define    EDIT_M_COPY    4#define    EDIT_M_PASTE  5#define    EDIT_M_CLEAR  6#define    MOVIE_MENU  3#define    MOVIE_MENU_ID  131#define    MOVIE_M_COMPRESS  1#define    MOVIE_M_STAGES    2#define    MOVIE_M_OVERSAMPLE  3#define    MOVIE_M_BACKWARDS  4#define    MOVIE_M_PREVIEW    6#define    MOVIE_M_MOVIE    8Boolean gDoCrossFade = true;          // type of processing to do ( set for crossfade, set to false to do random dot stereograms )Boolean gRequiresAlternate = true;        // if true means requires second picture for processingshort gDepth = 32;                // pixel depth of allocated image buffers/*********************************************  Funtion prototypes.*//*********************************************  Clean up menu hiliting*********************************************/void FixMenus(void){  Boolean gotAllWindows = gSrcWindow != nil &amp;&amp; (!gRequiresAlternate || gAltWindow != nil);  Boolean gotAnyWindows = gSrcWindow != nil || gAltWindow != nil;  DisableItem(gMenus[FILE_MENU], FILE_M_SAVE);  if (gotAnyWindows)    EnableItem(gMenus[FILE_MENU], FILE_M_CLOSE);  else    DisableItem(gMenus[FILE_MENU], FILE_M_CLOSE);  if (gotAllWindows)    DisableItem(gMenus[FILE_MENU], FILE_M_OPEN);  else    EnableItem(gMenus[FILE_MENU], FILE_M_OPEN);  if (!gotAllWindows)  {    DisableItem(gMenus[MOVIE_MENU], MOVIE_M_MOVIE);    DisableItem(gMenus[MOVIE_MENU], MOVIE_M_PREVIEW);    DisableItem(gMenus[MOVIE_MENU], MOVIE_M_OVERSAMPLE);  }  else  {    EnableItem(gMenus[MOVIE_MENU], MOVIE_M_MOVIE);    EnableItem(gMenus[MOVIE_MENU], MOVIE_M_PREVIEW);    EnableItem(gMenus[MOVIE_MENU], MOVIE_M_OVERSAMPLE);  }  DisableItem(gMenus[EDIT_MENU], EDIT_M_CUT);  DisableItem(gMenus[EDIT_MENU], EDIT_M_COPY);  DisableItem(gMenus[EDIT_MENU], EDIT_M_PASTE);  DisableItem(gMenus[EDIT_MENU], EDIT_M_CLEAR);  DisableItem(gMenus[EDIT_MENU], EDIT_M_UNDO);  CheckItem(gMenus[MOVIE_MENU], MOVIE_M_OVERSAMPLE, gOversample);  CheckItem(gMenus[MOVIE_MENU], MOVIE_M_BACKWARDS, gBackwards);}/*********************************************  Initialize menu bar.*********************************************/void SetupMenus(void){  gMenus[APPLE_MENU] = GetMenu(APPLE_MENU_ID);  AddResMenu(gMenus[APPLE_MENU], (ResType)'DRVR');  InsertMenu(gMenus[APPLE_MENU], 0);  gMenus[FILE_MENU] = GetMenu(FILE_MENU_ID);  InsertMenu(gMenus[FILE_MENU], 0);  gMenus[EDIT_MENU] = GetMenu(EDIT_MENU_ID);  InsertMenu(gMenus[EDIT_MENU], 0);  gMenus[MOVIE_MENU] = GetMenu(MOVIE_MENU_ID);  InsertMenu(gMenus[MOVIE_MENU], 0);  DrawMenuBar();  FixMenus();}/*********************************************  Prepare for work.*********************************************/void Initialize(void){  Ptr size;  long resp;  size = GetApplLimit();  SetApplLimit(size - 32 * 1024);        /* make room on stack so Quickdraw can do big pictures */  MaxApplZone();  /*  initialize managers */  InitGraf(&amp;qd.thePort);  InitFonts();  InitWindows();  InitMenus();  InitDialogs(nil);  InitCursor();  FlushEvents(everyEvent, 0);  SetupMenus();  CouldAlert(140);  if (NGetTrapAddress(0xab1d, ToolTrap) == NGetTrapAddress(0x9f, ToolTrap))  {    ExitToShell();  }  if (Gestalt(gestaltQuickTime, &amp;resp) != 0)  {    ExitToShell();  }}/*********************************************  If some kind of fatal error happened come here.*********************************************/void Error(char* msg,       OSErr code){  char buf[256];  GWorldPtr saveWorld;  GDHandle saveGD;  CGrafPtr wmgrPort;  GetGWorld(&amp;saveWorld, &amp;saveGD);  GetCWMgrPort(&amp;wmgrPort);  SetGWorld(wmgrPort, nil);  if (code)  {    sprintf(buf, &quot;%s %d&quot;, msg, code);    msg = buf;  }  c2pstr(msg);  ParamText((StringPtr)msg, &quot;\p&quot;, 0, 0);  if (code == 0)    Alert(140, nil);  else    StopAlert(140, nil);  SetGWorld(saveWorld, saveGD);}void ShowAboutBox(void){  ParamText(&quot;\pPictMovier&quot;, &quot;\pQuickTime!&quot;, 0, 0);  Alert(140, nil);}/*  Close a window*/long DoClose(WindowPtr wind){  if (wind == nil)    return (0);  if (gActiveWindow == wind)    gActiveWindow = nil;  if (wind == (WindowPtr)gSrcWindow)  {    DoClear();    gSrcWindow = nil;    DisposeGWorld(gWorld);    gWorld = nil;  }  else if (wind == (WindowPtr)gAltWindow)  {    DoClear();    gAltWindow = nil;    DisposeGWorld(gAltWorld);    gAltWorld = nil;  }  else if (wind == (WindowPtr)gDstWindow)  {    gDstWindow = nil;  }  CloseWindow(wind);  return (0);}/*********************************************  Allow the user to set the compression parameters with the standard compression dialog.*********************************************/void SetCompression(void){  ComponentInstance ci;  Point where;  SCParams p;  where.h = where.v = -2;  ci = OpenDefaultComponent('scdi', 0);  if (ci == nil)  {    Error(&quot;Couldn't open StdCompression&quot;, 0);    return;  }  p.flags = scShowMotionSettings;  p.theCodecType = gCodecType;  p.theCodec = gCodecID;  p.spatialQuality = gCodecQuality;  p.temporalQuality = gCodecTemporalQuality;  p.depth = gCodecDepth;  p.frameRate = gFrameRate &lt;&lt; 16;  p.keyFrameRate = gKeyFrameRate;  SCGetCompressionExtended(ci, &amp;p, where, 0,0,0,0);  gCodecType = p.theCodecType;  gCodecQuality = p.spatialQuality;  gCodecTemporalQuality = p.temporalQuality;  gCodecDepth = p.depth;  gFrameRate = p.frameRate &gt;&gt; 16;  gKeyFrameRate = p.keyFrameRate;  gCodecID = p.theCodec;}/*  Allow the user to set the number of stages she wants the processing to take.*/void SetStages(void){#define  STAGE_DLOG  128#define  IT_STAGES  3#define  IT_LINEAR  4#define  IT_OK  1#define  IT_CANCEL  2  CGrafPtr savePort;  DialogPtr theDialog;  short itemType;  Handle itemHdl;  Rect itemRect;  short itemHit,   lastItem = -1;  Boolean done = false;  Point tp;  GDHandle saveGD;  Str255 text;  long num;  long stageCount = gNumberSteps;  Boolean linear = true;  if ((theDialog = GetNewDialog(STAGE_DLOG, nil, (WindowPtr) - 1)) == nil)    return;  GetMouse(&amp;tp);  GetGWorld(&amp;savePort, &amp;saveGD);  SetPort(theDialog);  GetDItem(theDialog, IT_OK, &amp;itemType, &amp;itemHdl, &amp;itemRect);  PenSize(3, 3);  InsetRect(&amp;itemRect, -4, -4);  FrameRoundRect(&amp;itemRect, 16, 16);  GetDItem(theDialog, IT_STAGES, &amp;itemType, &amp;itemHdl, &amp;itemRect);  sprintf((char*)text, &quot;%ld&quot;, stageCount);  c2pstr((char*)text);  SetIText(itemHdl, text);  SelIText(theDialog, IT_STAGES, 0, 32767);  GetDItem(theDialog, IT_LINEAR, &amp;itemType, &amp;itemHdl, &amp;itemRect);  SetCtlValue((ControlHandle)itemHdl, linear);  HiliteControl((ControlHandle)itemHdl, 255);  while (!done)  {    ModalDialog(nil, &amp;itemHit);    if (itemHit != lastItem)    {      switch (lastItem)      {        case IT_STAGES:          GetDItem(theDialog, IT_STAGES, &amp;itemType, &amp;itemHdl, &amp;itemRect);          GetIText(itemHdl, text);          p2cstr(text);          if (sscanf((char*)text, &quot;%ld&quot;, &amp;num) == 1 &amp;&amp; num &gt; 0)            stageCount = num;          else            SysBeep(1);          sprintf((char*)text, &quot;%ld&quot;, stageCount);          c2pstr((char*)text);          SetIText(itemHdl, text);          break;      }      lastItem = itemHit;    }    switch (itemHit)    {      case IT_OK:        gNumberSteps = stageCount;        done = true;        break;      case IT_CANCEL:        done = true;        break;      case IT_LINEAR:        linear =!linear;        GetDItem(theDialog, IT_LINEAR, &amp;itemType, &amp;itemHdl, &amp;itemRect);        SetCtlValue((ControlHandle)itemHdl, linear);        break;      default:        break;    }  }  CloseDialog(theDialog);  SetGWorld(savePort, saveGD);}void DoStage(long stageNum,       long totalStages,       Boolean reverse){  if (gDoCrossFade)    DoCrossFade(stageNum, totalStages, reverse);  else    DoRandomDotStereogram(stageNum, totalStages, reverse);}/*********************************************  This processing routine creates a random dot stereogram of the input picture.  The second picture is not used.********************************************/void DoRandomDotStereogram(long stageNum,               long totalStages,               Boolean reverse){  /* StdFile stuff */  CGrafPtr savePort;  GDHandle saveGD;  char* ip,  * rp,  * pp,  * opp,  * qp;  char* sip,  * srp,  * spp;  short rowBytes;  short sRowBytes;  char mode = 1;  /* for sepecifying compression */  short i,   j,   x,   y,   height,   width;  unsigned char pix,   spix,   ppix,   qpix;  char* lineBuf = nil;  char* newLineBuf = nil;  char* tLineBuf = nil;#ifdef RDS_NEW_SEED_EACH_FRAME   unsigned long timeseed;#endif  //#define  RDS_DEPTH_FACTOR_VARIES      // set this to increase depth as movie progresses  //#define  RDS_STRIP_WIDTH_VARIES      // set this to increase repeat strip as movie progresses  //#define  RDS_NEW_SEED_EACH_FRAME      // set this to have a new random background for each frame #ifdef  RDS_NEW_SEED_EACH_FRAME  GetDateTime(&amp;timeseed);  BetterRand(time);#else  BetterRand(1);#endif#ifdef  RDS_DEPTH_FACTOR_VARIES  gDepthFactor = 1 + (stageNum * 64) / totalStages;  gDepthDecodeTabInted = false;#else  gDepthFactor = 16;#endif#ifdef  RDS_STRIP_WIDTH_VARIES  gStripWidth = 32 + (stageNum * 256) / totalStages;#else  gStripWidth = 128;#endif  GetGWorld(&amp;savePort, &amp;saveGD);  SetGWorld(gDstWorld, nil);  EraseRect(&amp;gDstWorld-&gt;portRect);  width = gWorld-&gt;portRect.right - gWorld-&gt;portRect.left;  height = gWorld-&gt;portRect.bottom - gWorld-&gt;portRect.top;  LockPixels(gWorld-&gt;portPixMap);  sRowBytes = (*gWorld-&gt;portPixMap)-&gt;rowBytes &amp; 0x7fff;  sip = GetPixBaseAddr(gWorld-&gt;portPixMap);  SetGWorld(gDstWorld, nil);  LockPixels(gDstWorld-&gt;portPixMap);  rowBytes = (*gDstWorld-&gt;portPixMap)-&gt;rowBytes &amp; 0x7fff;  ip = GetPixBaseAddr(gDstWorld-&gt;portPixMap);  lineBuf = NewPtr(sRowBytes);  if (lineBuf == nil)  {    Error(&quot;allocating line buffer&quot;, 0);    goto done;  }  newLineBuf = NewPtr(rowBytes);  if (newLineBuf == nil)  {    Error(&quot;allocating nline buffer&quot;, 0);    goto done;  }  tLineBuf = NewPtr(sRowBytes);  if (tLineBuf == nil)  {    Error(&quot;allocating tline buffer&quot;, 0);    goto done;  }  SwapMMUMode(&amp;mode);  if (gDepth == 1)  {    rp = ip;    for (y = 0; y &lt; height; y++)    {      pp = rp;      for (x = 0; x &lt; gStripWidth / 8; x++, pp++)      {        pix = 0;        for (i = 0; i &lt; 8; i++)        {          pix &lt;&lt;= 1;          if (BetterRand(0) % 5 == 0)            pix |= 1;        }        qp = pp;        for (j = 0; j &lt; width / gStripWidth; j++)        {          *qp = pix;          qp += gStripWidth / 8;        }      }      rp += rowBytes;    }    rp = ip;    srp = sip;    for (y = 0; y &lt; height; y++)    {      pp = rp;      spp = srp;      spp += gDepthFactor / 8;      qp = pp;      BlockMove(pp, tLineBuf, sRowBytes);      qp = tLineBuf;      pp = qp;      qp += gDepthFactor / 8;      opp = newLineBuf;      for (x = 0; x &lt; width / 8 - gStripWidth / 8; x++, pp++, qp++, opp++)      {        spix = *spp++;        qpix = *qp;        ppix = *pp;        pix = 0;        for (i = 0; i &lt; 8; i++)        {          pix &lt;&lt;= 1;          if ((spix &amp; 0x80))            pix |= (qpix &amp; 0x80) != 0 ? 1 : 0;          else            pix |= (ppix &amp; 0x80) != 0 ? 1 : 0;          spix &lt;&lt;= 1;          ppix &lt;&lt;= 1;          qpix &lt;&lt;= 1;        }        *opp = pix;        *(pp + gStripWidth / 8) = pix;      }      BlockMove(newLineBuf, rp + gStripWidth / 8, rowBytes - gStripWidth / 8);      rp += rowBytes;      srp += sRowBytes;    }  }  else if (gDepth == 8 || gDepth == 40)  {    rp = ip;    for (y = 0; y &lt; height; y++)    {      pp = rp;      for (x = 0; x &lt; gStripWidth; x++)      {        *pp++ = BetterRand(0);      }      rp += rowBytes;    }    rp = ip;    srp = sip;    for (y = 0; y &lt; height; y++)    {      pp = rp;      spp = srp;      spp += gStripWidth;      qp = pp;      BlockMove(pp, tLineBuf, sRowBytes);      qp = tLineBuf;      pp = qp;      opp = newLineBuf;      for (x = 0; x &lt; width - gStripWidth; x++, pp++, qp++, opp++)      {        spix = *spp++;        ppix = *pp;        pix = *(qp + DecodeDepth(spix));        *opp = pix;        *(pp + gStripWidth) = pix;      }      BlockMove(newLineBuf, rp + gStripWidth, rowBytes - gStripWidth);      rp += rowBytes;      srp += sRowBytes;    }  }  SwapMMUMode(&amp;mode);  UnlockPixels(gDstWorld-&gt;portPixMap);  SetGWorld(savePort, saveGD);done:if (newLineBuf)    DisposPtr(newLineBuf);  if (lineBuf)    DisposPtr(lineBuf);  if (tLineBuf)    DisposPtr(tLineBuf);}/*********************************************  a better random function than the one in the ROM *********************************************/long BetterRand(long reseed){#define  A  16807#define  M  2147483647#define  Q  127773#define  R  2836  static long seed = 1;  long lo,   hi,   test;  if (reseed != 0)    seed = reseed;  hi = seed / Q;  lo = seed % Q;  test = A * lo - R * hi;  if (test &gt; 0)    seed = test;  else    seed = test + M;  return (seed / (M &gt;&gt; 16));}unsigned char DecodeDepth(unsigned char pix){  static unsigned char table[256];  short i;  if (!gDepthDecodeTabInted)  {    gDepthDecodeTabInted = 1;    for (i = 0; i &lt; 255; i++)    {      table[i] = (i * gDepthFactor) / 255;    }  }  return (table[pix]);}/*********************************************  This processing routine does a linear cross dissolve between the two images,  using CopyBits with blend mode. It shows how to do a process which involves   both images. Any type of process could be done here, using the three parameters  to determine how much of the processing has progressed.  Note: See the Develop article by Konstantin Othmar ( sorry I forget the issue number )  about CopyBits to learn how to do other cool effects just using CopyBits.*********************************************/void DoCrossFade(long stageNum,         long totalStages,         Boolean reverse){  GWorldPtr saveWorld;  GDHandle saveGD;  RGBColor opColor;  if (reverse)    opColor.red = opColor.green = opColor.blue = (stageNum * 0xffff) / totalStages;  else    opColor.red = opColor.green = opColor.blue = ((totalStages - stageNum) * 0xffff) / totalStages;  GetGWorld(&amp;saveWorld, &amp;saveGD);  SetGWorld(gDstWorld, nil);  CopyBits((BitMap *) * gAltWorld-&gt;portPixMap, (BitMap *) * gDstWorld-&gt;portPixMap, &amp;gAltWorld-&gt;portRect, &amp;gDstWorld-&gt;portRect, ditherCopy, nil);  OpColor(&amp;opColor);  CopyBits((BitMap *) * gWorld-&gt;portPixMap, (BitMap *) * gDstWorld-&gt;portPixMap, &amp;gWorld-&gt;portRect, &amp;gDstWorld-&gt;portRect, blend, nil);  SetGWorld(saveWorld, saveGD);}/*   The following three routines are here because the MPW 3.2 c compiler   screw up compiling the DoMovie routine if you use the &quot;straight&quot; calls.  Try it and see and complain to DTS.*/void DoHLock(Handle h){  HLock(h);}void DoHUnlock(Handle h){  HUnlock(h);}void DoDisposHandle(Handle h){  DisposHandle(h);}/*********************************************  Show a preview of some stage in the process.********************************************/void DoPreview(void){#define  PV_DLOG  129#define  IT_STAGE  4#define  IT_OK  1#define  IT_CANCEL  2  CGrafPtr savePort;  DialogPtr theDialog;  short itemType;  Handle itemHdl;  Rect itemRect;  short itemHit,   lastItem = -1;  Boolean done = false;  Point tp;  GDHandle saveGD;  Str255 text;  long num;  long whichStage = gNumberSteps / 2;  if ((theDialog = GetNewDialog(PV_DLOG, nil, (WindowPtr) - 1)) == nil)    return;  GetMouse(&amp;tp);  GetGWorld(&amp;savePort, &amp;saveGD);  SetPort(theDialog);  GetDItem(theDialog, IT_OK, &amp;itemType, &amp;itemHdl, &amp;itemRect);  PenSize(3, 3);  InsetRect(&amp;itemRect, -4, -4);  FrameRoundRect(&amp;itemRect, 16, 16);  GetDItem(theDialog, IT_STAGE, &amp;itemType, &amp;itemHdl, &amp;itemRect);  sprintf((char*)text, &quot;%ld&quot;, whichStage);  c2pstr((char*)text);  SetIText(itemHdl, text);  SelIText(theDialog, IT_STAGE, 0, 32767);  while (!done)  {    ModalDialog(nil, &amp;itemHit);    if (itemHit != lastItem)    {      switch (lastItem)      {        case IT_STAGE:          GetDItem(theDialog, IT_STAGE, &amp;itemType, &amp;itemHdl, &amp;itemRect);          GetIText(itemHdl, text);          p2cstr(text);          if (sscanf((char*)text, &quot;%ld&quot;, &amp;num) == 1 &amp;&amp; num &gt; 0 &amp;&amp; num &lt;= gNumberSteps)            whichStage = num;          else            SysBeep(1);          sprintf((char*)text, &quot;%ld&quot;, whichStage);          c2pstr((char*)text);          SetIText(itemHdl, text);          break;      }      lastItem = itemHit;    }    switch (itemHit)    {      case IT_OK:        done = true;        break;      case IT_CANCEL:        whichStage = 0;        done = true;        break;      default:        break;    }  }  CloseDialog(theDialog);  if (whichStage)  {    Rect rect;    sprintf((char*)text, &quot;Preview %d of %d&quot;, whichStage, gNumberSteps);    c2pstr((char*)text);    rect = gSrcWindow-&gt;portRect;    SetGWorld(gSrcWindow, nil);    LocalToGlobal((Point *) &amp; rect.top);    LocalToGlobal((Point *) &amp; rect.bottom);    OffsetRect(&amp;rect, 20, 20);    if (gOversample)    {      rect.right = rect.left + (rect.right - rect.left) / 2;      rect.bottom = rect.top + (rect.bottom - rect.top) / 2;    }    SetGWorld(savePort, saveGD);    if (gDstWindow)    {      CloseWindow((WindowPtr)gDstWindow);      gDstWindow = nil;    }    if ((gDstWindow = (CWindowPtr)NewCWindow(nil, &amp;rect, text, true, zoomDocProc, (WindowPtr) - 1, true, 0)) == nil)    {      Error(&quot;NewCWindow Failed&quot;, 0);      goto done;    }    BringToFront((WindowPtr)gDstWindow);    HiliteWindow((WindowPtr)gDstWindow, true);    SetGWorld((CGrafPtr)gDstWorld, nil);    PaintRect(&amp;gDstWorld-&gt;portRect);    if (gDstWorld &amp;&amp; gWorld &amp;&amp; gAltWorld)      DoStage(whichStage, gNumberSteps, gBackwards);    SetGWorld((CGrafPtr)gDstWindow, nil);    CopyBits((BitMap *) * gDstWorld-&gt;portPixMap, (BitMap *) * gDstWindow-&gt;portPixMap, &amp;gDstWorld-&gt;portRect, &amp;gDstWindow-&gt;portRect, ditherCopy, nil);  }done:SetGWorld(savePort, saveGD);}/*********************************************  Create the movie by processing all the frames.********************************************/void DoMovie(void){  GWorldPtr saveWorld;  GDHandle saveGD;  short resRefNum;  OSErr result;  Rect rect;  /* Stuff for creating the file */  Point dlgPos =  {    100,  100  }  ;                      /* Position the dialog box */  SFReply sfr;                /* StdFile reply */  FSSpec mySpec;                /* Data structure with filename, etc. */  Movie gMovie = 0;              /* Our movie, track and media */  Track gTrack;  Media gMedia;  long maxCompressedFrameSize;        /* Max size of compressed frame    */  long compressedFrameSize;          /* Size of current compressed frame */  Handle compressedFrameBitsH = nil;      /* Buffer for the compressed data  */  ImageDescription * *imageDescriptionH = nil;/* Contains info about the sample  */  Ptr data;  EventRecord myEvent;  ImageSequence seq;  static Str255 name = &quot;\pMy Movie&quot;;  Rect dstRect;  short width,   height;  TimeValue timeVal;  if (gDstWindow)  {    CloseWindow((WindowPtr)gDstWindow);    gDstWindow = nil;  }  /* Prompt the user for a file name and create it */  SFPutFile(dlgPos, (StringPtr)&quot;\pMovie file to create:&quot;, (StringPtr)name, nil, &amp;sfr);  if (!sfr.good)    return;  BlockMove(sfr.fName, name, sfr.fName[0] + 1);  GetGWorld(&amp;saveWorld, &amp;saveGD);  width = gRect.right - gRect.left;  height = gRect.bottom - gRect.top;  if (gOversample)  {    width /= 2;    height /= 2;  }  SetRect(&amp;rect, 80, 80, width + 80, height + 80);  if ((gDstWindow = (CWindowPtr)NewCWindow(nil, &amp;rect, sfr.fName, true, zoomDocProc, (WindowPtr) - 1, true, 0)) == nil)  {    Error(&quot;NewCWindow Failed&quot;, 0);    goto done;  }  BringToFront((WindowPtr)gDstWindow);  HiliteWindow((WindowPtr)gDstWindow, true);  imageDescriptionH = (ImageDescription * *)NewHandle(sizeof(ImageDescription));/* handle for image descriptor */  if (imageDescriptionH == nil)  {    Error(&quot;Out of Memory&quot;, MemError());    goto done;  }  ClearMoviesStickyError();          /* Clear any old errors */  result = FSMakeFSSpec(sfr.vRefNum, 0, (unsigned char*)sfr.fName, &amp;mySpec);  if (result == fnfErr)    result = 0;  CreateMovieFile(&amp;mySpec, 'TVOD', 0, createMovieFileDeleteCurFile, &amp;resRefNum, &amp;gMovie);  gTrack = NewMovieTrack(gMovie, (long)width &lt;&lt; 16, (long)height &lt;&lt; 16, 0);  gMedia = NewTrackMedia(gTrack, VideoMediaType, gFrameRate, nil, (OSType)nil);  BeginMediaEdits(gMedia);          /* We do this since we are adding samples to the media */  GetMaxCompressionSize(gAltWorld-&gt;portPixMap, &amp;gAltWorld-&gt;portRect, gCodecDepth, gCodecQuality, gCodecType, gCodecID, &amp;maxCompressedFrameSize);  compressedFrameBitsH = NewHandle(maxCompressedFrameSize);  if (compressedFrameBitsH == nil)  {    EndMediaEdits(gMedia);    Error(&quot;Out of Memory&quot;, MemError());    goto bail;  }  GetGWorld(&amp;saveWorld, &amp;saveGD);  SetGWorld((CGrafPtr)gDstWorld, nil);  PaintRect(&amp;gDstWorld-&gt;portRect);  if ((result = CompressSequenceBegin(&amp;seq, gDstWorld-&gt;portPixMap, nil, &amp;gDstWorld-&gt;portRect, nil, gCodecDepth, gCodecType, gCodecID, gCodecQuality, gCodecTemporalQuality, gKeyFrameRate, nil, codecFlagUpdatePreviousComp, imageDescriptionH)) != 0)  {    Error(&quot;CompressSequenceBegin Failed&quot;, result);    goto bail2;  }  SetGWorld(saveWorld, saveGD);  while (WaitNextEvent(everyEvent, &amp;myEvent, 0, nil) != 0)  {    if (HandleEvents(&amp;myEvent))    {      CDSequenceEnd(seq);      EndMediaEdits(gMedia);      return;    }  }  SetRect(&amp;dstRect, 0, 0, gRect.right / 2, gRect.bottom / 2);  for (gFrameNumber = 0; gFrameNumber &lt;= gNumberSteps; gFrameNumber++)  {    SetGWorld(saveWorld, saveGD);    if (WaitNextEvent(everyEvent, &amp;myEvent, 0, nil) != 0)    {      if (HandleEvents(&amp;myEvent))      {        break;      }    }    SetGWorld((CGrafPtr)gDstWorld, nil);    PaintRect(&amp;gDstWorld-&gt;portRect);    if (gDstWorld &amp;&amp; gWorld &amp;&amp; gAltWorld)      DoStage(gFrameNumber, gNumberSteps, gBackwards);    SetGWorld((CGrafPtr)gDstWindow, nil);    InvalRect(&amp;gDstWindow-&gt;portRect);    DoHLock(compressedFrameBitsH);    data = StripAddress(*compressedFrameBitsH);    if (gOversample)    {      SetGWorld(gBufferWorld, nil);      CopyBits((BitMap *) * gDstWorld-&gt;portPixMap, (BitMap *) * gBufferWorld-&gt;portPixMap, &amp;gDstWorld-&gt;portRect, &amp;dstRect, ditherCopy, nil);      result = CompressSequenceFrame(seq, gBufferWorld-&gt;portPixMap, &amp;dstRect, codecFlagUpdatePreviousComp, data, &amp;compressedFrameSize, nil, nil);    }    else    {      SetGWorld((CGrafPtr)gDstWorld, nil);      result = CompressSequenceFrame(seq, gDstWorld-&gt;portPixMap, &amp;gDstWorld-&gt;portRect, codecFlagUpdatePreviousComp, data, &amp;compressedFrameSize, nil, nil);    }    if (result)    {      Error(&quot;Compress Sequence Frame Failed&quot;, result);      break;    }    DoHUnlock(compressedFrameBitsH);    result = AddMediaSample(gMedia, compressedFrameBitsH, 0L, compressedFrameSize, (TimeValue)1, (SampleDescriptionHandle)imageDescriptionH, 1L, 0, nil);    if (result)    {      Error(&quot;AddMediaSample Failed&quot;, result);      break;    }  }bail2:CDSequenceEnd(seq);bail:EndMediaEdits(gMedia);            /* We're done adding samples */  timeVal = GetMediaDuration(gMedia);  result = InsertMediaIntoTrack(gTrack, 0L, 0L, timeVal, 1L &lt;&lt; 16);  if (result)  {    Error(&quot;InsertMediaIntoTrack Failed&quot;, result);  }  result = AddMovieResource(gMovie, resRefNum, nil, nil);  if (result)  {    Error(&quot;AddMovieResource Failed&quot;, result);  }  CloseMovieFile(resRefNum);done:SetGWorld(saveWorld, saveGD);  if (imageDescriptionH)    DoDisposHandle((Handle)imageDescriptionH);  if (compressedFrameBitsH)    DoDisposHandle((Handle)compressedFrameBitsH);  if (gMovie)    DisposeMovie(gMovie);  if (gDstWindow)  {    CloseWindow((WindowPtr)gDstWindow);    gDstWindow = nil;  }  SetGWorld(saveWorld, saveGD);}/*********************************************  Stubs********************************************/void DoCopy(void){}void DoCut(void){}void DoPaste(void){}void DoClear(void){}void DoUndo(void){}/*********************************************  Process menu command.********************************************/short DoCommand(long mResult){  short theMenu,   theItem;  Str255 daName;  GDHandle saveGD;  CGrafPtr savePort;  OSErr res = 0;#define HIshort(aLong)    (((aLong) &gt;&gt; 16) &amp; 0xFFFF)#define LOshort(aLong)    ((aLong) &amp; 0xFFFF)  theItem = LOshort(mResult);  theMenu = HIshort(mResult);          /* This is the resource ID */  switch (theMenu)  {    case APPLE_MENU_ID:      if (theItem == 1)      {        ShowAboutBox();      }      else      {        GetItem(gMenus[0], theItem, daName);        GetGWorld(&amp;savePort, &amp;saveGD);        (void)OpenDeskAcc(daName);        SetGWorld(savePort, saveGD);      }      break;    case FILE_MENU_ID:      {        switch (theItem)        {          case FILE_M_OPEN:            DoOpen(nil);            FixMenus();            break;          case FILE_M_CLOSE:            DoClose(gActiveWindow);            FixMenus();            res = 1;            break;          case FILE_M_SAVE:            FixMenus();            break;          case FILE_M_QUIT:            {              Boolean abortion = false;              while (gActiveWindow)              {                if (DoClose(gActiveWindow) &lt; 0)                {                  abortion = true;                  break;                }              }              if (!abortion)                gExitFlag = true;/* Request exit */              res = 1;              break;            }        }      }      break;    case EDIT_MENU_ID:      if (!SystemEdit(theItem - 1))      {        switch (theItem)        {          case EDIT_M_UNDO:            DoUndo();            break;          case EDIT_M_CUT:            DoCut();            break;          case EDIT_M_COPY:            DoCopy();            break;          case EDIT_M_PASTE:            DoPaste();            break;          case EDIT_M_CLEAR:            DoClear();            break;        }      }      FixMenus();      break;    case MOVIE_MENU_ID:      switch (theItem)      {        case MOVIE_M_COMPRESS:          SetCompression();          break;        case MOVIE_M_STAGES:          DoClose((WindowPtr)gDstWindow);          SetStages();          break;        case MOVIE_M_OVERSAMPLE:          gOversample =!gOversample;          CheckItem(gMenus[MOVIE_MENU], theItem, gOversample);          break;        case MOVIE_M_BACKWARDS:          DoClose((WindowPtr)gDstWindow);          gBackwards =!gBackwards;          CheckItem(gMenus[MOVIE_MENU], theItem, gBackwards);          break;        case MOVIE_M_PREVIEW:          DoPreview();          break;        case MOVIE_M_MOVIE:          DoMovie();          break;      }      break;    default:      break;  }                      /*endsw theMenu*/  HiliteMenu(0);  return (res);}/********************************************  Process events.********************************************/Boolean HandleEvents(EventRecord* myEvent){  Rect dragRect;  WindowPtr whichWindow;  short res = 0;  GWorldPtr saveWorld;  GDHandle saveGD;  GetGWorld(&amp;saveWorld, &amp;saveGD);  switch (myEvent-&gt;what)  {    case mouseDown:      switch ((short)FindWindow(myEvent-&gt;where, &amp;whichWindow))      {        case inSysWindow:          SystemClick(myEvent, whichWindow);          break;        case inMenuBar:          res = DoCommand(MenuSelect(myEvent-&gt;where));          break;        case inDrag:          SetPort((GrafPtr)whichWindow);          SetRect(&amp;dragRect, 4, 20 + 4, qd.screenBits.bounds.right - 4, qd.screenBits.bounds.bottom - 4);          DragWindow(whichWindow, myEvent-&gt;where, &amp;dragRect);          break;        case inGrow:          break;        case inGoAway:          if (TrackGoAway(whichWindow, myEvent-&gt;where))          {            DoClose(whichWindow);            res = true;          }          break;        case inZoomIn:          break;        case inZoomOut:          break;        case inContent:          if (whichWindow != FrontWindow())          {            SelectWindow(whichWindow);            gActiveWindow = whichWindow;          }          FixMenus();          break;        default:          break;      }      break;    case keyDown:      if (((myEvent-&gt;modifiers &amp; cmdKey) != 0))      {        res = DoCommand(MenuKey(myEvent-&gt;message &amp; charCodeMask));      }      break;    case updateEvt:      DoUpdate((CWindowPtr)myEvent-&gt;message);      break;    case activateEvt:      whichWindow = (WindowPtr)myEvent-&gt;message;      if ((myEvent-&gt;modifiers &amp; activeFlag))      {        gActiveWindow = whichWindow;      }      break;    default:      break;  }  SetGWorld(saveWorld, saveGD);  return (res);}/********************************************  Allocate the image buffers for the processing********************************************/OSErr AllocateBuffers(void){  Rect rect = gRect;  OSErr result = 0;  short depth = gDepth &gt; 32 ? (gDepth - 32) : gDepth;  CTabHandle clut = nil;  OffsetRect(&amp;rect, -rect.left, -rect.top);  if (gDepth &gt; 32)    clut = GetCTable(gDepth);  if (gDstWorld)  {    DisposeGWorld(gDstWorld);    gDstWorld = nil;  }  if (gBufferWorld)  {    DisposeGWorld(gBufferWorld);    gBufferWorld = nil;  }  if ((result = NewGWorld(&amp;gWorld, depth, &amp;rect, clut, nil, 0)) != 0)  {    if ((result = NewGWorld(&amp;gWorld, depth, &amp;rect, clut, nil, useTempMem)) != 0)    {      Error(&quot;NewGWorld Failed&quot;, result);      goto done;    }  }  if ((result = NewGWorld(&amp;gAltWorld, depth, &amp;rect, clut, nil, 0)) != 0)  {    if ((result = NewGWorld(&amp;gAltWorld, depth, &amp;rect, clut, nil, useTempMem)) != 0)    {      Error(&quot;NewGWorld Failed&quot;, result);      goto done;    }  }  if ((result = NewGWorld(&amp;gBufferWorld, depth, &amp;rect, clut, nil, 0)) != 0)  {    if ((result = NewGWorld(&amp;gBufferWorld, depth, &amp;rect, clut, nil, useTempMem)) != 0)    {      Error(&quot;NewGWorld Failed&quot;, result);      goto done;    }  }  if ((result = NewGWorld(&amp;gDstWorld, depth, &amp;rect, clut, nil, 0)) != 0)  {    if ((result = NewGWorld(&amp;gDstWorld, depth, &amp;rect, clut, nil, useTempMem)) != 0)    {      Error(&quot;NewGWorld Failed&quot;, result);      goto done;    }  }done:if (result)  {    if (gWorld)      DisposeGWorld(gWorld);    gWorld = nil;    if (gAltWorld)      DisposeGWorld(gAltWorld);    gAltWorld = nil;    if (gDstWorld)      DisposeGWorld(gDstWorld);    gDstWorld = nil;    if (gBufferWorld)      DisposeGWorld(gBufferWorld);    gBufferWorld = nil;  }  if (clut)    DisposeCTable(clut);  return (result);}/********************************************  Make a source window ********************************************/CWindowPtr MakeSWindow(Rect* frame,             StringPtr name,             GWorldPtr buffer){  CWindowPtr wind;  if ((wind = (CWindowPtr)NewCWindow(nil, frame, name, false, zoomDocProc, (WindowPtr) - 1, true, 0)) == nil)  {    Error(&quot;NewCWindow Failed&quot;, 0);    return (nil);  }  ShowWindow((WindowPtr)wind);  BringToFront((WindowPtr)wind);  HiliteWindow((WindowPtr)wind, true);  SetWRefCon((WindowPtr)wind, (long)buffer);  return (wind);}/********************************************  Open a file.********************************************/OSErr DoOpen(FSSpec* fsp){  long result = noErr;  Rect zpFrame;  GWorldPtr saveWorld;  GDHandle saveGD;  short oFile = -1;  StandardFileReply theSFR;  GetGWorld(&amp;saveWorld, &amp;saveGD);  if (fsp == nil)  {    SFTypeList types =    {      'PICT',  0    }    ;    if (gHasNewStdFile)      StandardGetFile(nil, 1, types, &amp;theSFR);    else    {      SFReply osfr;      Point pt =      {        100,  100      }      ;      SFGetFile(pt, (ConstStr255Param)&quot;&quot;, nil, 1, types, nil, &amp;osfr);      theSFR.sfGood = osfr.good;      theSFR.sfReplacing = osfr.copy;      theSFR.sfType = osfr.fType;      if (osfr.good)        FSMakeFSSpec(osfr.vRefNum, 0L, osfr.fName, &amp;theSFR.sfFile);    }    if (!theSFR.sfGood)    {      return (1);    }  }  else  {    theSFR.sfFile = *fsp;  }  if (FSpOpenDF(&amp;theSFR.sfFile, fsRdPerm, &amp;oFile))  {    result = -1;    goto done;  }  /************************************************   *   *  Get the picture frame, to see how big of a window to make.   *  ************************************************/  if (GetPictureFileHeader(oFile, &amp;gOriginalPicFrame, nil))  {    result = -1;    goto done;  }  if (gSrcWindow == nil)  {    OffsetRect(&amp;gOriginalPicFrame, -gOriginalPicFrame.left, -gOriginalPicFrame.top);    if (gOversample)    {      gOriginalPicFrame.right *= 2;      gOriginalPicFrame.bottom *= 2;    }    gRect = gOriginalPicFrame;    zpFrame = gRect;    if ((result = AllocateBuffers()) != 0)      goto done;    OffsetRect(&amp;zpFrame, 50, 50);    gSrcWindow = MakeSWindow(&amp;zpFrame, theSFR.sfFile.name, gWorld);    SetGWorld((CGrafPtr)gWorld, nil);    if ((result = DrawPictureFile(oFile, &amp;gWorld-&gt;portRect, nil)) != 0)    {      Error(&quot;DrawPictureFile Failed&quot;, result);      goto done;    }  }  else  {    zpFrame = gRect;    OffsetRect(&amp;zpFrame, 70, 70);    gAltWindow = MakeSWindow(&amp;zpFrame, theSFR.sfFile.name, gAltWorld);    SetGWorld((CGrafPtr)gAltWorld, nil);    if ((result = DrawPictureFile(oFile, &amp;gAltWorld-&gt;portRect, nil)) != 0)    {      Error(&quot;DrawPictureFile Failed&quot;, result);      goto done;    }  }done:if (oFile != -1)    FSClose(oFile);  SetGWorld(saveWorld, saveGD);  return (result);}/********************************************  Update a window********************************************/void DoUpdate(CWindowPtr wind){  GWorldPtr saveWorld,  gw;  GDHandle saveGD;  RGBColor gray =  {    0xc000,  0xc000, 0xc000  }  ;  char c[32];  GetGWorld(&amp;saveWorld, &amp;saveGD);  if (wind == gDstWindow)  {    BeginUpdate((WindowPtr)wind);    SetGWorld((CGrafPtr)wind, nil);    CopyBits((BitMap *) * gDstWorld-&gt;portPixMap, (BitMap *) * wind-&gt;portPixMap, &amp;gDstWorld-&gt;portRect, &amp;wind-&gt;portRect, ditherCopy, nil);    if (gFrameNumber &gt;= 0)    {      MoveTo(20, 20);      TextSize(12);      TextFace(bold);      TextMode(patBic);      NumToString(gFrameNumber + 1, (StringPtr) &amp; c);      DrawString((StringPtr) &amp; c);      DrawString((StringPtr)&quot;\p/&quot;);      NumToString(gNumberSteps + 1, (StringPtr) &amp; c);      DrawString((StringPtr) &amp; c);      MoveTo(21, 21);      TextMode(srcOr);      NumToString(gFrameNumber + 1, (StringPtr) &amp; c);      DrawString((StringPtr) &amp; c);      DrawString((StringPtr)&quot;\p/&quot;);      NumToString(gNumberSteps + 1, (StringPtr) &amp; c);      DrawString((StringPtr) &amp; c);    }    EndUpdate((WindowPtr)wind);    SetGWorld(saveWorld, saveGD);    return;  }  SetGWorld(wind, nil);  gw = (GWorldPtr)GetWRefCon((WindowPtr)wind);  BeginUpdate((WindowPtr)wind);  CopyBits((BitMap *) * gw-&gt;portPixMap, (BitMap *) * wind-&gt;portPixMap, &amp;gw-&gt;portRect, &amp;wind-&gt;portRect, ditherCopy, nil);  EndUpdate((WindowPtr)wind);  SetGWorld(saveWorld, saveGD);}/********************************************  The main program********************************************/void main(void){  EventRecord myEvent;  Initialize();  EnterMovies();  if (!gDoCrossFade)  {    gDepth = 40;              // randomdotstereogram needs grayscale buffers    gCodecType = 'smc ';            // graphics compressor is good choice    gCodecDepth = gDepth;          // prime depth for std compression    gRequiresAlternate = false;        // only needs one pict to do processing  }  else  {    gDepth = 32;              // full resolution for best effect    gRequiresAlternate = true;        // needs two picts to do processing  }  while (!gExitFlag)  {    if (WaitNextEvent(everyEvent, &amp;myEvent, 1, nil) != 0)    {      HandleEvents(&amp;myEvent);    }  }done:ExitMovies();  ExitToShell();}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/PictMovier/listing1.html%3Fid%3DDTS10000332-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/PictMovier/listing1.html%3Fid%3DDTS10000332-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/PictMovier/listing1.html%3Fid%3DDTS10000332-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>