<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Make QTVR Panorama - /CApp.cp</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxQuickTime-date.html">QuickTime</a> &gt; <A HREF="javascript:location.replace('index.html');">Make QTVR Panorama</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/QuickTime/index.html" target="_blank">Reference Library > QuickTime</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Make QTVR Panorama</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/CApp.cp</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/CApp.cp</option>
<option value="listing2.html">/CApp.h</option>
<option value="listing3.html">/CBeachBall.cp</option>
<option value="listing4.html">/CBeachBall.h</option>
<option value="listing5.html">/CKeyFilters.cp</option>
<option value="listing6.html">/CKeyFilters.h</option>
<option value="listing7.html">/CLogConsole.cp</option>
<option value="listing8.html">/CMovieMaker.cp</option>
<option value="listing9.html">/CMovieMaker.h</option>
<option value="listing10.html">/CPict2VRWindow.cp</option>
<option value="listing11.html">/CPict2VRWindow.h</option>
<option value="listing12.html">/CPreferences.cp</option>
<option value="listing13.html">/CPreferences.h</option>
<option value="listing14.html">/CPrefsWindow.cp</option>
<option value="listing15.html">/CPrefsWindow.h</option>
<option value="listing16.html">/CUtils.cp</option>
<option value="listing17.html">/CUtils.h</option>
<option value="listing18.html">/QTVRPanoAuthoring.h</option>
<option value="listing19.html">/ToDoHistory.h</option></select>
				</p>
				</form>
				<p><strong><a href="Make_QTVR_Panorama.zip">Download Sample</a></strong> (&#147;Make_QTVR_Panorama.zip&#148;, 233.0K)<BR>
<strong><a href="Make_QTVR_Panorama.dmg">Download Sample</a></strong> (&#147;Make_QTVR_Panorama.dmg&#148;, 312.5K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  Make QTVR Panorama 1.0b1    A simple PowerPlant application for processing PICT files into QuickTime VR(tm) movies.    Created 29 Jan 1996 by EGH    Copyright &copy; 1996, Apple Computer, Inc. All rights reserved.*/#include &lt;StandardFile.h&gt;#include &lt;String_Utils.h&gt;#include &lt;LCaption.h&gt;#include &lt;UDesktop.h&gt;#include &lt;UDrawingState.h&gt;#include &lt;LEditField.h&gt;#include &lt;LGrowZone.h&gt;#include &lt;UMemoryMgr.h&gt;#include &lt;LPlaceHolder.h&gt;#include &lt;URegistrar.h&gt;#include &lt;LScroller.h&gt;#include &lt;LStdControl.h&gt;#include &lt;LTabGroup.h&gt;#include &lt;LTextEdit.h&gt;#include &lt;LUndoer.h&gt;#include &lt;LWindow.h&gt;#include &lt;PP_Resources.h&gt;#include &quot;CApp.h&quot;#include &quot;CBeachBall.h&quot;#include &quot;CMovieMaker.h&quot;#include &quot;CPict2VRWindow.h&quot;#include &quot;CPrefsWindow.h&quot;#include &quot;CUtils.h&quot;CPreferences *gAppPrefs = nil;CApp *gApp = nil;void main(void){  SetDebugThrow_(debugAction_Alert);  SetDebugSignal_(debugAction_Alert);  InitializeHeap(8);  UQDGlobals::InitializeToolbox(&amp;qd);      // check for the existence of QuickTime  Int32 result;  OSErr err = ::Gestalt(gestaltQuickTime, &amp;result);  if (err != noErr)  {    ::StopAlert(ALRT_NoQT, nil);    ExitToShell();  }    new LGrowZone(20000);      // fire up QuickTime and load the components necessary for    // creating pano media  ::EnterMovies();  ::RegisterComponentResourceFile(CurResFile(), 0);    CApp theApp;  gApp = &amp;theApp;  theApp.Run();    ::ExitMovies();}CApp::CApp(){  mDropMode = false;      // Register classes for objects created from 'PPob' resources  URegistrar::RegisterClass(CPict2VRWindow::class_ID,  CPict2VRWindow::CreatePict2VRWindowWindowStream);  URegistrar::RegisterClass(CPrefsWindow::class_ID,  CPrefsWindow::CreatePrefsWindowWindowStream);  URegistrar::RegisterClass(LCaption::class_ID,    LCaption::CreateCaptionStream);  URegistrar::RegisterClass(LDialogBox::class_ID,    LDialogBox::CreateDialogBoxStream);  URegistrar::RegisterClass(LEditField::class_ID,    LEditField::CreateEditFieldStream);  URegistrar::RegisterClass(LPicture::class_ID,    LPicture::CreatePictureStream);  URegistrar::RegisterClass(LPlaceHolder::class_ID,  LPlaceHolder::CreatePlaceHolderStream);  URegistrar::RegisterClass(LStdButton::class_ID,    LStdButton::CreateStdButtonStream);  URegistrar::RegisterClass(LStdCheckBox::class_ID,  LStdCheckBox::CreateStdCheckBoxStream);  URegistrar::RegisterClass(LStdControl::class_ID,  LStdControl::CreateStdControlStream);  URegistrar::RegisterClass(LStdPopupMenu::class_ID,  LStdPopupMenu::CreateStdPopupMenuStream);  URegistrar::RegisterClass(LStdRadioButton::class_ID,  LStdRadioButton::CreateStdRadioButtonStream);  URegistrar::RegisterClass(LTabGroup::class_ID,    LTabGroup::CreateTabGroupStream);  URegistrar::RegisterClass(LView::class_ID,      LView::CreateViewStream);  URegistrar::RegisterClass(LWindow::class_ID,    LWindow::CreateWindowStream);      // create application preferences  Str63 appName;  ::GetIndString(appName, STRx_Standards, str_ProgramName);  gAppPrefs = new CPreferences('p2vr', Creator_, appName);      // look for preferences and use them  mPrefsHdl = (P2VRPrefsHdl)gAppPrefs-&gt;GetPreferenceResource(ResType_Preferences, 128);  if (mPrefsHdl == nil)  {      // no prefs, so create default ones    mPrefsHdl = (P2VRPrefsHdl)::NewHandle(sizeof (P2VRPrefsRec));    if (mPrefsHdl != nil)    {      (*mPrefsHdl)-&gt;dropMode = mDropMode;            (*mPrefsHdl)-&gt;width = 400;      (*mPrefsHdl)-&gt;height = 300;      (*mPrefsHdl)-&gt;codec = 'cvid';      (*mPrefsHdl)-&gt;pan = 0;      (*mPrefsHdl)-&gt;tilt = 0;      (*mPrefsHdl)-&gt;zoom = 0;      (*mPrefsHdl)-&gt;spatialQuality = codecHighQuality;      (*mPrefsHdl)-&gt;depth = 32;      CopyPStr(&quot;\p.tile&quot;, (*mPrefsHdl)-&gt;tileSuffix);      CopyPStr(&quot;\p.snm&quot;, (*mPrefsHdl)-&gt;movieSuffix);            (*mPrefsHdl)-&gt;replaceFiles = false;    }  }  else  {    mDropMode = (*mPrefsHdl)-&gt;dropMode;  }      // initialize spinning cursor  CBeachBall::InitBeachBall();    if (!mDropMode)  {    try    {      LWindow *splash = LWindow::CreateWindow(WIND_Splash, this);            if (splash != nil)      {        splash-&gt;Show();        splash-&gt;UpdatePort();        UInt32 splashTime = ::TickCount() + 120; // this should be up for at least 180 ticks        CBeachBall::StartSpinningTask(5);        while (::TickCount() &lt; splashTime) ;        CBeachBall::StopSpinningTask();                delete splash;      }    }    catch (...)    {      // fall out    }  }}CApp::~CApp(){    // save the preferences  if (gAppPrefs != nil &amp;&amp; mPrefsHdl != nil)  {    (*mPrefsHdl)-&gt;dropMode = mDropMode;    gAppPrefs-&gt;SavePreferenceResource(ResType_Preferences, 128, (Handle)mPrefsHdl);  }}Boolean CApp::ObeyCommand(  CommandT inCommand,  void *ioParam){  Boolean  cmdHandled = true;    switch (inCommand)  {    case cmd_DropMode:    {      mDropMode = !mDropMode;      SetUpdateCommandStatus(true);      break;    }        case cmd_Preferences:    {      CPrefsWindow *pw = (CPrefsWindow *)LWindow::CreateWindow(WIND_Preferences, this);      pw-&gt;Show();      break;    }        default:      cmdHandled = LDocApplication::ObeyCommand(inCommand, ioParam);      break;  }    return cmdHandled;}void CApp::FindCommandStatus(  CommandT  inCommand,  Boolean    &amp;outEnabled,  Boolean    &amp;outUsesMark,  Char16    &amp;outMark,  Str255    outName){  outUsesMark = false;    if (sBusy)    outEnabled = false;  else    switch (inCommand)    {      case cmd_DropMode:        outEnabled = true;        outUsesMark = true;        outMark = mDropMode ? checkMark:noMark;        break;            case cmd_Preferences:        outEnabled = true;        break;            default:        LDocApplication::FindCommandStatus(inCommand, outEnabled, outUsesMark,            outMark, outName);        break;    }}/* CApp::DoAEOpenOrPrintDoc  Overridden from LDocApplication because we may want to quit afterwards.*/void CApp::DoAEOpenOrPrintDoc(  const AppleEvent &amp;inAppleEvent,  AppleEvent&amp; /* outAEReply */,  Int32 inAENumber){  AEDescList docList;  OSErr err = ::AEGetParamDesc(&amp;inAppleEvent, keyDirectObject,              typeAEList, &amp;docList);  ThrowIfOSErr_(err);    Int32 numDocs;  err = ::AECountItems(&amp;docList, &amp;numDocs);  ThrowIfOSErr_(err);    for (Int32 i = 1; i &lt;= numDocs; i++)  {    AEKeyword  theKey;    DescType  theType;    FSSpec    theFileSpec;    Size    theSize;    err = ::AEGetNthPtr(&amp;docList, i, typeFSS, &amp;theKey, &amp;theType,              (Ptr) &amp;theFileSpec, sizeof(FSSpec), &amp;theSize);    ThrowIfOSErr_(err);        if (inAENumber == ae_OpenDoc)    {      OpenDocument(&amp;theFileSpec);    }    else    {        // let the user know we don't do printing in this app      ::StopAlert(ALRT_WeDontPrint, nil);    }  }    ::AEDisposeDesc(&amp;docList);      // if we are in drop mode, get outta here  if (mDropMode)    DoQuit();}void CApp::OpenDocument(  FSSpec *inMacFSSpec){  Int16 errStrIndex;    try  {    errStrIndex = err_Window;        if (mDropMode &amp;&amp; mPrefsHdl != nil)    {        // just start making the movie      MovieMakinRec params;      params.width = (*mPrefsHdl)-&gt;width;      params.height = (*mPrefsHdl)-&gt;height;      params.srcSpec = *inMacFSSpec;            params.tileSpec = *inMacFSSpec;      unsigned char charspace = 31 - (*mPrefsHdl)-&gt;tileSuffix[0];      if (params.tileSpec.name[0] &gt; charspace)        params.tileSpec.name[0] = charspace;      ConcatPStr(params.tileSpec.name, (*mPrefsHdl)-&gt;tileSuffix);      params.destSpec = *inMacFSSpec;      charspace = 31 - (*mPrefsHdl)-&gt;movieSuffix[0];      if (params.destSpec.name[0] &gt; charspace)        params.destSpec.name[0] = charspace;      ConcatPStr(params.destSpec.name, (*mPrefsHdl)-&gt;movieSuffix);            params.codec = (*mPrefsHdl)-&gt;codec;      params.spatialQuality = (*mPrefsHdl)-&gt;spatialQuality;      params.depth = (*mPrefsHdl)-&gt;depth;            ListenToMessage(msg_MakeMovie, &amp;params);    }    else    {        // put up a window for editing movie making parameters      CPict2VRWindow *p2vr = (CPict2VRWindow *)LWindow::CreateWindow(WIND_Pict2VR, this);      p2vr-&gt;AddListener(this);      p2vr-&gt;SetPictFile(inMacFSSpec);    }  }  catch (ExceptionCode err)  {    ReportError(err, err_Window);  }      // drop mode leaves the menu bar inactive  if (mDropMode)    UpdateMenus();}void CApp::StartUp(){  ChooseDocument();}void CApp::ChooseDocument(){  StandardFileReply macFileReply;  SFTypeList typeList;    UDesktop::Deactivate();  typeList[0] = 'PICT';  ::StandardGetFile(nil, 1, typeList, &amp;macFileReply);  UDesktop::Activate();  if (macFileReply.sfGood)  {    OpenDocument(&amp;macFileReply.sfFile);  }}/* CApp::ProgressEvents  An event processing function necessary because the one implemented in  LApplication does things we dont want such as changing the cursor.  This one is useful for processing events during lengthy processes  (and there is a spinning cursor and a modal window in front).*/void CApp::ProgressEvents(){  EventRecord macEvent;  SetUpdateCommandStatus(false);  Boolean  gotEvent;  Int16 count = 0;    do  {    gotEvent = ::WaitNextEvent(everyEvent, &amp;macEvent, 0, mMouseRgnH);        if (LAttachable::ExecuteAttachments(msg_Event, &amp;macEvent))    {      if (gotEvent)        DispatchEvent(macEvent);      else        UseIdleTime(macEvent);    }      LPeriodical::DevoteTimeToRepeaters(macEvent);        if (GetUpdateCommandStatus())      UpdateMenus();  } while (gotEvent &amp;&amp; ++count &lt; 3); // do not hand over too much time}// ======================================// constants and statics for movie makingBoolean CApp::sCancelled;LWindow *CApp::sProgressWindow = nil;Boolean CApp::sBusy = false;const PaneIDT Button_Stop = 'stop';const PaneIDT Caption_Proc = 'proc';const PaneIDT Caption_Message = 'mess';const ResIDT WIND_Progress = 207;// ======================================void CApp::ListenToMessage(  MessageT inMessage,  void *ioParam){  switch (inMessage)  {      // note: one could conceivably tell the app to make a movie      // WHILE it is making one. this would work, except that the      // newly dropped one will be completed before the original is      // processed. this does not include numbers of PICTs dropped      // on the app at once in the Finder    case msg_MakeMovie:    {        // the make movie message includes parameters for making the movie      MovieMakinPtr mmp = (MovieMakinPtr)ioParam;            Str255 procStr;      ::GetIndString(procStr, STRx_Progress, str_Making);                // create a path name that fits into a Str255 minus the above string      Str255 moviePathStr;      GetFullPathName(&amp;mmp-&gt;destSpec, moviePathStr, sizeof (Str255) - procStr[0]);            try      {          // prepare progress stuff        sCancelled = false;        sBusy = true;        SetUpdateCommandStatus(true);        UpdateMenus();        sProgressWindow = LWindow::CreateWindow(WIND_Progress, this);        ThrowIfNil_(sProgressWindow);                  // set the main progress description string        ConcatPStr(procStr, moviePathStr);        SetSizedDescriptor(sProgressWindow, Caption_Proc, procStr);                  // listen to the stop button - provides both mouse and keyboard          // initiated user cancellation        LButton *button;        button = (LButton *)sProgressWindow-&gt;FindPaneByID(Button_Stop);        if (button != nil)          button-&gt;AddListener(this);                  // decide if we are replacing files        Boolean replaceFiles = false;        if (mPrefsHdl != nil)          replaceFiles = (*mPrefsHdl)-&gt;replaceFiles;                  // finally, make the movie!        CBeachBall::StartSpinningTask(5);        Boolean completed = CMovieMaker::MakeAMovie(          replaceFiles,          mmp-&gt;srcSpec, mmp-&gt;tileSpec, mmp-&gt;destSpec,          mmp-&gt;width, mmp-&gt;height,           mmp-&gt;pan, mmp-&gt;tilt, mmp-&gt;zoom,          mmp-&gt;codec, mmp-&gt;spatialQuality, mmp-&gt;depth, MovieProgressProc);        CBeachBall::StopSpinningTask();                delete sProgressWindow;        sProgressWindow = nil;                  // let the caller know how things went        mmp-&gt;completed = completed;      }      catch (ExceptionCode err)      {        mmp-&gt;completed = false;                  // the only exception that can make it here is to fail          // while creating the progress window          // all other exceptions are caught by CMovieMaker::MakeAMovie        if (err != Exception_UserCancelled)          ReportError(err, err_Window);      }            sBusy = false;      UpdateMenus();      break;    }        case Button_Stop:      sCancelled = true;      break;  }}/* CApp::MovieProgressProc  Called during processing. Gets events handled, messages displayed and  user cancellation reported.*/Boolean CApp::MovieProgressProc(  StringPtr inMessage){  if (inMessage != nil)  {    LPane *messageCaption = sProgressWindow-&gt;FindPaneByID(Caption_Message);    messageCaption-&gt;SetDescriptor(inMessage);    messageCaption-&gt;UpdatePort();  }    gApp-&gt;ProgressEvents();    return sCancelled;}/* CApp::BugUserTilSwitchedIn  Use the notification manager to let the user know they should switch in.  Returns once this has happened.    Useful for waiting to put up alerts during long processes where the possibility  of the user having switched out is an issue.*/void CApp::BugUserTilSwitchedIn(){  if (!IsOnDuty())  {    NMRec note;    OSErr nmErr;    Handle sicnH = ::GetResource('SICN', 12000);        if (sicnH)    {      ::HNoPurge(sicnH);      ::DetachResource(sicnH);    }        note.qType = nmType;    note.nmMark = 1;    note.nmIcon = sicnH;    note.nmSound = (Handle) -1;    note.nmStr = nil;    note.nmResp = nil;    note.nmRefCon = 0;        if ((nmErr = ::NMInstall(&amp;note)) == noErr)    {      while (!IsOnDuty())      {        ProgressEvents();      }      nmErr = ::NMRemove(&amp;note);    }        if (sicnH != nil)      ::DisposeHandle(sicnH);  }}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Make_QTVR_Panorama/listing1.html%3Fid%3DDTS10000339-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Make_QTVR_Panorama/listing1.html%3Fid%3DDTS10000339-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Make_QTVR_Panorama/listing1.html%3Fid%3DDTS10000339-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>