<HTML>		<HEAD>		<TITLE>			EOFaulting		</TITLE>		</HEAD>	<body bgcolor="#ffffff"><!--start of banner --><!--#include virtual="/includes/framesetheader" --><!-- end of banner --><!--start of path --><font face="Geneva,Helvetica,Arial" size="1"><b>PATH<spacer type="horizontal" size="5">&nbsp;</b> <a href="../../../../../../../index.html" target="_top">Documentation</a> <b>&gt;</b> <a href="../../../../../../webobjects.html" target="_top">WebObjects 4.5</a> <b>&gt;</b>EOControl Reference</font><br><br><!--end of path --><a href="../EOControlTOC.html"><img src="../../../../../../images/up.gif" border="0" alt="Table of Contents"></a><a name = "BEDCFBFB"></a><BR><h1><FONT COLOR="#000066"><a name="//apple_ref/java/intf/EOFaulting">EOFaulting</a></FONT></h1><br><blockquote><dl><b>Implemented by: </b><dd>EODeferredFaulting</dd><dd>EOEnterpriseObject</dd><dd>EOCustomObject</dd><dd>EOGenericRecord</dd></dl></blockquote><blockquote><dl><dt><b>Package: </b></dt><dd>com.apple.client.eocontrol</dd><dd>com.apple.yellow.eocontrol</dd></dl></blockquote><HR SIZE=4><h2>Interface Description</h2><hr><p>The EOFaulting interface together with the EOFaultHandlerclass forms a general mechanism for postponing an object's initializationuntil its actually needed. In it's pre-initialization state, an EOFaultingobject is known as a <em>fault.</em>  Whenthe object is sent a message to which it can't respond withoutinitializing, it uses a fault handler to <em>fire,</em> or to finish initializing. Faults are most commonly used by theaccess layer to represent an object not yet fetched from the database,but that must nonetheless exist as an instance in the application-typicallybecause it's the destination of a relationship. Consequently,a fault typically fires when an attempt is made to access any ofits data. In this case, firing a fault involves fetching the object'sdata.</p><p>The default implementations of EOFaulting in EOCustomObjectand EOGenericRecord are sufficient for most purposes. If you needcustom faulting behavior, you typically create a subclass of EOFaultHandlerto accommodate different means of converting faults into regularobjects; there's rarely a need to override the default implementationsof EOFaulting.</p><br><h2>Creating a Fault</h2><p>In Yellow Box, you create a fault with the  <a href="../Classes/EOFaultHandler.html#EOFaultHandler">EOFaultHandler</a> method  <a href="../Classes/EOFaultHandler.html#//apple_ref/java/clm/EOFaultHandler/makeObjectIntoFault">makeObjectIntoFault</a>. In Java Client, youcreate a fault by sending an newly created object a  <a href="#//apple_ref/java/intfm/EOFaulting/turnIntoFault">turnIntoFault</a> message,providing an EOFaultHandler that will later help the fault to fire.This fault handler should be considered completely the private propertyof the fault. You shouldn't send it any messages, instead dealingexclusively with the fault.</p><br><h2>Firing a Fault</h2><p>A fault is fired when it can't respond to a message withoutcompleting its initialization. Any of the object's methods thatrequires initialization trigger the firing, This is generally accomplishedby invoking the  <a href="#//apple_ref/java/intfm/EOFaulting/willRead">willRead</a> method.For example, in the typical case of an object that needs to fetchit's data from a database upon firing, <code>willRead</code> isinvoked from the object's "get" methods, such as the following:</p><blockquote><pre>public String roleName() {    willRead();    return roleName;}</pre></blockquote><br><p>The default implementations of <code>willRead</code> providedby EOCustomObject and EOGenericRecord take care of using the object'sfault handler to finish initialization. For more information ona fault handler's role, see the  <a href="../Classes/EOFaultHandler.html#EOFaultHandler">EOFaultHandler</a> class specification.</p><BR><BR><h2>Instance Methods</h2><hr><a name = "BEDEBCFF"></a><BR><h3><a name="//apple_ref/java/intfm/EOFaulting/clearFault">clearFault</a></h3><p><code>public abstract void <code>clearFault</code>()</code></p><p>(com.apple.client.eocontrol only) Restores the receiverto its status prior to the  <a href="#//apple_ref/java/intfm/EOFaulting/turnIntoFault">turnIntoFault</a> messagethat turned the object into a fault. Throws an exception if thereceiver isn't a fault.</p><p>You rarely use this method. Rather, it's invoked by an EOFaultHandlerduring the process of firing the fault. For more information, seethe  <a href="../Classes/EOFaultHandler.html#EOFaultHandler">EOFaultHandler</a> class specification.</p><hr WIDTH="25%" ALIGN="LEFT"><a name = "BEDFJAJB"></a><BR><h3><a name="//apple_ref/java/intfm/EOFaulting/faultHandler">faultHandler</a></h3><p><code>public abstract EOFaultHandler <code>faultHandler</code>()</code></p>(com.apple.client.eocontrol only)If the receiver is a fault, returns its fault handler; otherwisereturns <code>nil</code>.<hr WIDTH="25%" ALIGN="LEFT"><a name = "BEDBIAHF"></a><BR><h3><a name="//apple_ref/java/intfm/EOFaulting/isFault">isFault</a></h3><p><code>public abstract boolean <code>isFault</code>()</code></p>(com.apple.client.eocontrol only) Returns <code>true</code> ifthe receiver is a fault, <code>false</code> otherwise.<hr WIDTH="25%" ALIGN="LEFT"><a name = "BIADAFHB"></a><BR><h3><a name="//apple_ref/java/intfm/EOFaulting/turnIntoFault">turnIntoFault</a></h3><p><code>public abstract void <code>turnIntoFault</code>(EOFaultHandler <em>aFaultHandler</em>)</code></p><p>(com.apple.client.eocontrol only) Converts the receiverinto a fault, assigning <em>aFaultHandler</em>  asthe object that stores its original state and later converts thefault back into a normal object (typically by fetching data froman external repository). The receiver becomes the owner of <em>aFaultHandler;</em> you shouldn't assign it to another object.</p><hr WIDTH="25%" ALIGN="LEFT"><a name = "BIAEBFIE"></a><BR><h3><a name="//apple_ref/java/intfm/EOFaulting/willRead">willRead</a></h3><p><code>public abstract void <code>willRead</code>()</code></p>Fills the receiver with values fetched fromthe database. Before your application attempts to message an object,you must ensure that it has been filled with its data. To do this,enterprise objects invoke the method <code>willRead</code> priorto any attempt to access the object's state, most typically in"get" methods such as the following:<blockquote><pre>public String roleName() {    willRead();    return roleName;}</pre></blockquote><br><p></p><hr WIDTH="25%" ALIGN="LEFT"><BR><br><a href="../EOControlTOC.html"><img src="../../../../../../images/up.gif" border="0" alt="Table of Contents"></a></BODY></HTML>