<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>QTMusicToo - /&bull;Instrument Editor/Instrument Editor.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/QuickTime/index.html">QuickTime</a> &gt; <a href="../../samplecode/QuickTime/idxMusicAudio-date.html">Audio</a> &gt; <A HREF="javascript:location.replace('index.html');">QTMusicToo</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Not Recommended Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>The information in this document is <strong>Not Recommended</strong> and should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/QuickTime/idxMusicAudio-date.html" target="_blank">QuickTime > Audio</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">QTMusicToo</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/&bull;Instrument Editor/Instrument Editor.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/BigEasy/BigEasy2.c</option>
<option value="listing2.html">/BigEasy/BigEasy2.h</option>
<option value="listing3.html">/BigEasy/BigEasyControls.c</option>
<option value="listing4.html">/BigEasy/BigEasyControls.h</option>
<option value="listing5.html">/BigEasy/BigEasyDialogs.c</option>
<option value="listing6.html">/BigEasy/BigEasyDialogs.h</option>
<option value="listing7.html">/BigEasy/BigEasyGestalt.c</option>
<option value="listing8.html">/BigEasy/BigEasyGestalt.h</option>
<option value="listing9.html">/BigEasy/BigEasyGrafish.c</option>
<option value="listing10.html">/BigEasy/BigEasyGrafish.h</option>
<option value="listing11.html">/BigEasy/BigEasyPPC.c</option>
<option value="listing12.html">/BigEasy/BigEasyPPC.h</option>
<option value="listing13.html">/BigEasy/BigEasyStandardControls.c</option>
<option value="listing14.html">/BigEasy/BigEasyStandardControls.h</option>
<option value="listing15.html">/BigEasy/BigEasyTextish.c</option>
<option value="listing16.html">/BigEasy/BigEasyTextish.h</option>
<option value="listing17.html">/BigEasy/BigEasyUtils.c</option>
<option value="listing18.html">/BigEasy/BigEasyUtils.h</option>
<option value="listing19.html">/BigEasy/IconUtilsPriv.h</option>
<option value="listing20.html">/BigEasy/NWindows.c</option>
<option value="listing21.html">/BigEasy/OneWindow.c</option>
<option value="listing22.html">/•Instrument Editor/All The MIDI Components.h</option>
<option value="listing23.html">/•Instrument Editor/IE KeyboardDiagram.c</option>
<option value="listing24.html">/•Instrument Editor/IE KeyboardDiagram.h</option>
<option value="listing25.html">/•Instrument Editor/IE PrintUtilities.c</option>
<option value="listing26.html">/•Instrument Editor/IE PrintUtilities.h</option>
<option value="listing27.html">/•Instrument Editor/Instrument Editor Controls.c</option>
<option value="listing28.html">/•Instrument Editor/Instrument Editor Controls.h</option>
<option value="listing29.html">/•Instrument Editor/Instrument Editor Draw.c</option>
<option value="listing30.html">/•Instrument Editor/Instrument Editor Filing.c</option>
<option value="listing31.html">/•Instrument Editor/Instrument Editor Filing.h</option>
<option value="listing32.html">/•Instrument Editor/Instrument Editor Menus.c</option>
<option value="listing33.html">/•Instrument Editor/Instrument Editor Menus.h</option>
<option value="listing34.html">/•Instrument Editor/Instrument Editor.c</option>
<option value="listing35.html">/•Instrument Editor/Instrument Editor.h</option>
<option value="listing36.html">/•Instrument Editor/Instrument Editor.r</option>
<option value="listing37.html">/•Instrument Editor/Instrument Tests.c</option>
<option value="listing38.html">/•Instrument Editor/More IE Routines.c</option>
<option value="listing39.html">/•Instrument Editor/More IE Routines.h</option>
<option value="listing40.html">/•Instrument Picker Test/InstrumentPickerTest.c</option>
<option value="listing41.html">/•QTMusic Sample Keyboards/EasyKeyboardDiagram.c</option>
<option value="listing42.html">/•QTMusic Sample Keyboards/EasyKeyboardDiagram.h</option>
<option value="listing43.html">/•QTMusic Sample Keyboards/EasyKeyboardDiagram.r</option>
<option value="listing44.html">/•QTMusic Sample Keyboards/QTMusic Sample Keyboards.c</option>
<option value="listing45.html">/•QTMusic Sample Keyboards/QTMusic Sample Keyboards.r</option>
<option value="listing46.html">/•QTMusic Sample Sequencer/Event Priority Queue.c</option>
<option value="listing47.html">/•QTMusic Sample Sequencer/Event Priority Queue.h</option>
<option value="listing48.html">/•QTMusic Sample Sequencer/Sequencer Test Movies.c</option>
<option value="listing49.html">/•QTMusic Sample Sequencer/Sequencer Test Movies.h</option>
<option value="listing50.html">/•QTMusic Sample Sequencer/SequencerTest Filing.c</option>
<option value="listing51.html">/•QTMusic Sample Sequencer/SequencerTest Filing.h</option>
<option value="listing52.html">/•QTMusic Sample Sequencer/SequencerTest Movies.h</option>
<option value="listing53.html">/•QTMusic Sample Sequencer/SequencerTest Realtime.c</option>
<option value="listing54.html">/•QTMusic Sample Sequencer/SequencerTest Realtime.h</option>
<option value="listing55.html">/•QTMusic Sample Sequencer/SequencerTest.c</option>
<option value="listing56.html">/•QTMusic Sample Sequencer/SequencerTest.h</option></select>
				</p>
				</form>
				<p><strong><a href="QTMusicToo.zip">Download Sample</a></strong> (&#147;QTMusicToo.zip&#148;, 115.5K)<BR>
<strong><a href="QTMusicToo.dmg">Download Sample</a></strong> (&#147;QTMusicToo.dmg&#148;, 173.6K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/* * file: Instrument Editor.c * * started 22 March 1992 * david van brink * */  /*--------------------------  Inclusions--------------------------*/#include &lt;Memory.h&gt;#include &lt;QuickDraw.h&gt;#include &lt;Windows.h&gt;#include &lt;Dialogs.h&gt;#include &lt;OSUtils.h&gt;#include &lt;Errors.h&gt;#include &lt;Resources.h&gt;#include &lt;Timer.h&gt;//#include &lt;MIDI.h&gt;#include &quot;BigEasy2.h&quot;#include &quot;BigEasyGrafish.h&quot;#include &quot;BigEasyTextish.h&quot;#include &quot;BigEasyControls.h&quot;#include &quot;BigEasyDialogs.h&quot;#include &quot;BigEasyUtils.h&quot;#include &quot;Instrument Editor Controls.h&quot;#include &quot;IE PrintUtilities.h&quot;#define globals#include &quot;More IE Routines.h&quot;#include &quot;Instrument Editor.h&quot;#include &quot;Instrument Editor Filing.h&quot;#include &quot;Instrument Editor Menus.h&quot;/*--------------------------  Limits and Konstants--------------------------*/#define SignIt(x) ( (x)?1:-1)/*--------------------------  Prototypes--------------------------*/static void OpenAWindow(void);static void KeyDoc(short n,short key,short code,short mods);static short CloseDoc(short n);static void ActivateDoc(short n);static void DeactivateDoc(short n);static void IdleDoc(short n,Boolean front);static void LetsQuit(short n,short menuItem,short menuRef);static void NameInstrumentDoc(short n, short menuItem, short menuRef);static void RandomizeKnobsDoc(short n, short menuItem, short menuRef);static void ShowCPULoad(short n, short menuItem, short menuRef);static void GetInstrumentDoc(short n, short menuItem, short menuRef);static void GetROMInstrumentsDoc(short n, short menuItem, short menuRef);static void InitVars(void);static void InstrumentSliderValueDrawProc(EasyControl ec);static void MoveDoc(short n);static void AddToList(TDoc *d, InstrumentDataHandle iH);Boolean CheckBit(unsigned long *t, long bit);static void About(void);static void SliderValueProc(EasyControl ec);pascal ComponentResult EditorMusicReadHook(MusicMIDIPacket *mp, long refCon);static void OpenSomeSynth(short n, short item,short ref);static pascal void JunkTask(void);static long GetCPUTime(void);static unsigned long gUnloadedCPUTime;/*--------------------------  More bits--------------------------*/static tSliderStyle aSliderStyle =  {  longNum,  kSliderWidth,13,  kSliderWidth,13,  InstrumentSliderValueDrawProc  };static unsigned long gCPUUnloadedTime;/*--------------------------  Computer Programs--------------------------*/void SliderValueProc(EasyControl ec)  {  long value;  long id;  TDoc *d;  d = (void *)GetEasyControlRefcon(ec);  value = GetEasyControlValue(ec);  id = GetEasyControlID(ec);  if(d-&gt;whichList == mInstrumentKnobs)    NASetKnob(d-&gt;na,d-&gt;nc,id + 1,value);  else if(d-&gt;whichList == mControllers)    NASetController(d-&gt;na,d-&gt;nc,id,value);  else    MusicSetKnob(d-&gt;ci,id + 1,value);  }void KeyDoc(short n,short key,short code,short mods)  {  Boolean x;  Rect r;  TDoc *d;  ComponentResult result;  long xBump,yBump,scale;  controlClickResult ccr;  d = &amp;gDoc[n - kFirstDocWindow];  SetupSliderClipDoc(d);  KeyEasyControlList(d-&gt;ecl,key,mods,&amp;ccr);  DoneSliderClipDoc(d);  switch(key)    {    case 31: //down arrow      xBump = 0;      yBump = 1;fly:      if(mods &amp; optionKey)        {        if(mods &amp; cmdKey)          scale = 32000;        else          scale = 40;        xBump *= scale;        yBump *= scale;        SetCtlValue(d-&gt;horizontalScroller,GetCtlValue(d-&gt;horizontalScroller) + xBump);        SetCtlValue(d-&gt;verticalScroller,GetCtlValue(d-&gt;verticalScroller) + yBump);        NewScrollDoc(d,true,nil);        }      break;    case 30: //up arrow      xBump = 0;      yBump = -1;      goto fly;    case 29: //right arrow      xBump = 1;      yBump = 0;      goto fly;    case 28: //left arrow      xBump = -1;      yBump = 0;      goto fly;    case '[':      x = EasyDialogGetNumber(&quot;\pStore Instrument&quot;,          &quot;\pStore instrument in which instrument number:&quot;,          &amp;d-&gt;stashInstrument);      if(x)        {        GoWatch();        result = MusicStoreInstrument(d-&gt;ci,d-&gt;part,d-&gt;stashInstrument);        FlashResult(result);        GoArrow();        }      break;    case ']':        {        ToneDescription td;        ComponentResult result;        td.synthesizerType = d-&gt;sd.synthesizerType;        td.instrumentNumber = d-&gt;recallInstrument;        td.gmNumber = 0;        if(d-&gt;sd.flags &amp; (kSynthesizerGM | kSynthesizerGMSuperset))          if(td.instrumentNumber &lt;= 128)            td.gmNumber = td.instrumentNumber;        td.synthesizerName[0] = 0;        td.instrumentName[0] = 0;        result = NAPickInstrument(d-&gt;na,nil,&quot;\pPick An Instrument:&quot;,&amp;td,            3,0,0,0);        if(!result)          {          x = true;          MusicFindTone(d-&gt;ci,&amp;td,&amp;d-&gt;recallInstrument,nil);          result = MusicSetInstrumentNumber(d-&gt;ci,d-&gt;part,d-&gt;recallInstrument);          FlashResult(result);          result = MusicGetPartName(d-&gt;ci,d-&gt;part,d-&gt;instrumentName);          FlashResult(result);          UpdateSliderKnobs(d);          DrawStats(d);          }        }      break;    case '=':    case '+':      d-&gt;recallInstrument = d-&gt;recallInstrument % d-&gt;sd.modifiableInstrumentCount + 1;    getNewOne:      result = MusicSetInstrumentNumber(d-&gt;ci,d-&gt;part,d-&gt;recallInstrument);      FlashResult(result);      result = MusicGetPartName(d-&gt;ci,d-&gt;part,d-&gt;instrumentName);      FlashResult(result);      DrawStats(d);      UpdateSliderKnobs(d);      break;    case '-':    case '_':      d-&gt;recallInstrument = (d-&gt;recallInstrument + d-&gt;sd.modifiableInstrumentCount - 2)          % d-&gt;sd.modifiableInstrumentCount + 1;      goto getNewOne;    }  }short CloseDoc(short n)/* * Close that window... */  {  short x;  TDoc *d;  Boolean cancelClose;  d = &amp;gDoc[n - kFirstDocWindow];  if(d-&gt;used &amp;&amp; d-&gt;changed)    {    x = EasyDialogMessage(0,d-&gt;docSpec.name,&quot;\pSave changes before closing this document?&quot;,        kEasyDialogSaveDiscardCancel);    if(x == 2)      cancelClose = true;    else if(x == 0)      cancelClose = SaveDoc(n,0,0);    else      cancelClose = false;    }  else    cancelClose = false;  if(!cancelClose)    {    UninstallWindow(n);    CloseComponent(d-&gt;na);    DisposeEasyControlList(d-&gt;ecl);    d-&gt;ecl = 0;    d-&gt;used = false;    gDocCount--;    }  return cancelClose;  }void FixUpMenus(TDoc *d)  /*   * Make menus suitable for document d,   * where d=nil means deactivate   */  {  short moreDocs;  moreDocs = SignIt(gDocCount&lt;kDocMax);  SetMenuItem(mNew,moreDocs,0,0,nil);  SetMenuItem(mOpen,moreDocs,0,0,nil);  if(d)    {    Point c;    SetMenuItemRange(mFirstDocOnly,mLastDocOnly,1,0);    SetMenuItem(d-&gt;whichList,0,1,'*',0);    SetMenuItem(mSave,SignIt(d-&gt;changed || d-&gt;littleChanged),0,0,nil);    c.h = c.v = 0;    if(!LGetSelect(true,&amp;c,d-&gt;listH))      SetMenuItem(mSetInstrument,-1,0,0,0);    }  else    SetMenuItemRange(mFirstDocOnly,mLastDocOnly,-1,0);  }void ActivateDoc(short n)  {  TDoc *d;  ComponentResult thisError;  d = &amp;gDoc[n - kFirstDocWindow];  FixUpMenus(d);  if(d-&gt;listH)    LActivate(true,d-&gt;listH);  if(d-&gt;horizontalScroller)    {    HiliteControl(d-&gt;horizontalScroller,0);    HiliteControl(d-&gt;verticalScroller,0);    }  thisError = NAUseDefaultMIDIInput(d-&gt;na,EditorMusicReadHook,(long)d,0);  }void DeactivateDoc(short n)  {  TDoc *d;  ComponentResult thisError;  d = &amp;gDoc[n - kFirstDocWindow];  FixUpMenus(0);  if(d-&gt;listH)  LActivate(false,d-&gt;listH);  if(d-&gt;horizontalScroller)    {    HiliteControl(d-&gt;horizontalScroller,254);    HiliteControl(d-&gt;verticalScroller,254);    }  thisError = NALoseDefaultMIDIInput(d-&gt;na);  FlashResult(thisError);  thisError = NAResetNoteChannel(d-&gt;na,d-&gt;nc);  FlashResult(thisError);  d-&gt;controllersDirty = true;  }void IdleDoc(short n,Boolean front)  {  TDoc *d;  ComponentResult thisError;  d = &amp;gDoc[n - kFirstDocWindow];  PaintKeyboardVector(&amp;d-&gt;kd,d-&gt;keyVel);  if(d-&gt;whichList == mControllers      &amp;&amp; d-&gt;controllersDirty)    UpdateSliderKnobs(d);  SetupSliderClipDoc(d);  IdleEasyControlList(d-&gt;ecl);  DoneSliderClipDoc(d);    {    Point p;    short mods;    GetMouse(&amp;p);    mods = GetModKeys();    if(PtInRect(p,&amp;d-&gt;visibleSliderBounds) &amp;&amp; (mods &amp; optionKey))      GoCursor(128);    else      GoArrow();    }  }typedef struct  {  short number;  Str31 name;  } XX;XX dControllerNames[] =  {  kControllerModulationWheel,&quot;\pMod&quot;,  kControllerBreath,&quot;\pBreath&quot;,  kControllerFoot,&quot;\pFoot&quot;,  kControllerPortamentoTime,&quot;\pPortamento Time&quot;,  kControllerVolume,&quot;\pVolume&quot;,  kControllerBalance,&quot;\pBalance&quot;,  kControllerPan,&quot;\pPan&quot;,  kControllerExpression,&quot;\pExpression&quot;,  kControllerPitchBend,&quot;\pPitch Bend&quot;,  kControllerAfterTouch,&quot;\pAfter Touch&quot;,  kControllerSustain,&quot;\pSustain&quot;,  kControllerPortamento,&quot;\pPortamento&quot;,  kControllerSostenuto,&quot;\pSostenuto&quot;,  kControllerSoftPedal,&quot;\pSoft Pedal&quot;,  91,&quot;\pReverb&quot;,  kControllerTremolo,&quot;\pTremolo&quot;,  kControllerChorus,&quot;\pChorus&quot;,  kControllerCeleste,&quot;\pCeleste&quot;,  kControllerPhaser,&quot;\pPhaser&quot;,  -1,&quot;\p&quot;  };void InstrumentSliderValueDrawProc(EasyControl ec)  {  long x;  TDoc *d;  short i;  x = GetEasyControlValue(ec);  d = (void *)GetEasyControlRefcon(ec);  for(i = 0; i&lt;d-&gt;knobCount; i++)    {    if(ec == d-&gt;ec[i])      {      if(d-&gt;whichList == mInstrumentKnobs)        DrawString( (*(d-&gt;ikdList))[i].name);      else if(d-&gt;whichList == mGlobalKnobs)        DrawString( (*(d-&gt;gkdList))[i].name);      else        {        short j;        short id;        id = GetEasyControlID(ec);        j = 0;        while(1)          {          if(dControllerNames[j].number == id)            {            DrawString(dControllerNames[j].name);            goto gotIt;            }          else if(dControllerNames[j].number &lt; 0)            goto missedIt;          j++;          }        missedIt:          DrawString(&quot;\pController &quot;);          DrawNum(id);        gotIt:;        }      DrawString(&quot;\p: &quot;);      }    }  if(x == 0x7FFFffff)    DrawString(&quot;\p----&quot;);  else    DrawNum(x);  }static short dMyColors[6] =  {  0,  PackColor555(60000,60000,60000),  PackColor555(10000,10000,10000),  PackColor555(24000,0,0),  0,  0  };void LetsQuit(short n,short menuItem,short menuRef)  {  short i;  #pragma unused (n,menuItem,menuRef)  for(i = 0; i &lt; kDocMax; i++)    if(gDoc[i].used)      CloseDoc(i + kFirstDocWindow);  gQuitApp++;  }void NameInstrumentDoc(short n, short menuItem, short menuRef)  {  DialogPtr dp;  short hit;  short itemType;  Rect itemRect;  Handle itemHandle;  TDoc *d;  Boolean x;  ComponentResult result;  d = &amp;gDoc[n - kFirstDocWindow];  x = EasyDialogGetString(&quot;\pInstrument Name&quot;,&quot;\pNew Name:&quot;,d-&gt;instrumentName,31);  if(x)    {    DrawStats(d);    result = MusicSetPartName(d-&gt;ci,d-&gt;part,d-&gt;instrumentName);    FlashResult(result);    }  }void RandomizeKnobsDoc(short n, short menuItem, short menuRef)  {  TDoc *d;  ComponentResult result;  short i;  long x;  long dummy;  KnobDescription *kd;  d = &amp;gDoc[n - kFirstDocWindow];  for(i = 0; i &lt; d-&gt;knobCount; i++)    {    if(Random() % 6 == 0)      {  result = 0;  #if 1      kd = &amp;(*d-&gt;ikdList)[i];      x = kd-&gt;lowValue +          ((unsigned long)Random())%(kd-&gt;highValue          - kd-&gt;lowValue + 1);      result = MusicSetPartKnob(d-&gt;ci,d-&gt;part,i+1,x);  #endif      if(result)        {        FlashResult(result);        goto goHome;        }      Delay(5,&amp;dummy);      }    }goHome:  UpdateSliderKnobs(d);  }static void AddToList(TDoc *d, InstrumentDataHandle iH)/* * Adds an instrument to the list. Assume ownership of this handle. */  {  InstrumentData *id;  ComponentResult thisError;  if(!iH)    goto goHome;  HLock((Handle)iH);  id = *iH;  GoBW();  TextFont(3);  TextSize(9);  TextFace(0);    {    Point a;    long sizz;    a.h = 0;    a.v = LAddRow(1,-1,d-&gt;listH);    LSetCell(&amp;(id-&gt;tone.instrumentName[1]),id-&gt;tone.instrumentName[0],        a,d-&gt;listH);    if(d-&gt;instrument[d-&gt;instrumentCount])      DisposeHandle((Handle)d-&gt;instrument[d-&gt;instrumentCount]);    d-&gt;instrument[d-&gt;instrumentCount] = iH;    d-&gt;instrumentCount++;    }  d-&gt;changed = true;  FixUpMenus(d);goHome:;  }void SetInstrumentForDoc(TDoc *d,InstrumentDataHandle iH)  {  ComponentResult result;  GoWatch();  result = MusicSetInstrument(d-&gt;ci,d-&gt;part,iH);  GoArrow();  FlashResult(result);  result = MusicGetPartName(d-&gt;ci,d-&gt;part,d-&gt;instrumentName);  FlashResult(result);  DrawStats(d);  UpdateSliderKnobs(d);  }void SetInstrumentDoc(short n, short menuItem, short menuRef)  {  TDoc *d;  Cell c;  ComponentResult result;  d = &amp;gDoc[n - kFirstDocWindow];  c.h = c.v = 0;  if(!LGetSelect(true,&amp;c,d-&gt;listH))    goto goHome;  SetInstrumentForDoc(d,d-&gt;instrument[c.v]);goHome:;  }void GetInstrumentDoc(short n, short menuItem, short menuRef)  {  TDoc *d;  InstrumentDataHandle iH;  ComponentResult thisError;  d = &amp;gDoc[n - kFirstDocWindow];  GoWatch();  thisError = MusicGetInstrument(d-&gt;ci,d-&gt;part,&amp;iH);  GoArrow();  FlashResult(thisError);  if(thisError)    goto goHome;  AddToList(d,iH);goHome:;  }void ShowCPULoad(short n, short menuItem, short menuRef)  {  Str255 s;  Str63 nu;  long x;  CopyPString(s,&quot;\pOriginal time = &quot;);  AnyBaseToPString(gUnloadedCPUTime,10,0,nu);  ConcatenatePStrings(s,nu);  ConcatenatePStrings(s,&quot;\p, Loaded time = &quot;);  x = GetCPUTime();  AnyBaseToPString(x,10,0,nu);  ConcatenatePStrings(s,nu);  ConcatenatePStrings(s,&quot;\p. Percentage of CPU speed gone = &quot;);  x = 100 - gUnloadedCPUTime * 100L / x;  AnyBaseToPString(x,10,0,nu);  ConcatenatePStrings(s,nu);  ConcatenatePStrings(s,&quot;\p.&quot;);  EasyDialogMessage(1,&quot;\pCPU Loading&quot;,      s,kEasyDialogOkay);  }void UpdateSliderKnobs(TDoc *d)/* * Requery the music component for all * the knob/slider values */  {  long x;  short i;  EasyControl ec;  long id;  SetupSliderClipDoc(d);  for(i = 0; i &lt; d-&gt;knobCount; i++)    {    ec = d-&gt;ec[i];    id = GetEasyControlID(ec);    if(d-&gt;whichList == mInstrumentKnobs)      x = MusicGetPartKnob(d-&gt;ci,d-&gt;part,id+1);    else if(d-&gt;whichList == mControllers)      x = MusicGetController(d-&gt;ci,d-&gt;part,id);    else      x = MusicGetKnob(d-&gt;ci,id+1);    FlashResult(x);    if((x &amp; 0xFFFF0000) == 0x80000000)      goto goHome;    TextFont(3);    TextSize(9);    SetEasyControlValue(ec,x);    }goHome:  d-&gt;controllersDirty = false;  DoneSliderClipDoc(d);  }void MoveDoc(short n)  {  register TDoc *d;  d = &amp;gDoc[n - kFirstDocWindow];  d-&gt;littleChanged = true;  }void NewDocFromSaveRecord(short docNumber,TSaveRecord *sr,SynthMenuEntry *sme)  {  register TDoc *d;  Rect r,windowRect;  Rect allControls;  ComponentResult result;  short i,j;  EasyControl ec;  KnobDescription *kd;  SynthMenuEntry smell;  if(!sme)    {    if(sr)      {      smell.synthType = sr-&gt;sr.synthType;      BlockMove(sr-&gt;sr.synthName,smell.synthName,32);      }    else      {      smell.synthType = 0;      smell.synthName[0] = 0;      }    sme = &amp;smell;    }  d = &amp;gDoc[docNumber];#if 0    {    char *w;    short i;    /*     * Clear the document to zeros     */    i = sizeof(TDoc);    w = (void *)d;    while(i--)      *w++ = 0;    }#endif  d-&gt;changed = false;  for(i = 0; i &lt; kMaxInstruments; i++)    d-&gt;instrument[i] = 0;  d-&gt;na = OpenDefaultComponent('nota',0);  if(sr)    {    gStaggerWindows = false;    windowRect = sr-&gt;windowRect;    d-&gt;everSaved = true;    d-&gt;sr = sr-&gt;sr;    d-&gt;littleChanged = false;    }  else    {    gStaggerWindows = true;    gStagStepX = 3;    gStagStepY = 2;    SetRect(&amp;windowRect,10,30,625,460);    CopyPString(d-&gt;docSpec.name,&quot;\pUntitled&quot;);    d-&gt;everSaved = false;    d-&gt;littleChanged = true;    }  d-&gt;w = InstallWindow(-(docNumber + kFirstDocWindow),d-&gt;docSpec.name,&amp;windowRect,0,1,      DrawDoc,ClickDoc,KeyDoc,(void *)CloseDoc,      ActivateDoc,DeactivateDoc,IdleDoc);  SetWindowMoveProc(docNumber + kFirstDocWindow,MoveDoc);  SetWindowResizeProc(docNumber + kFirstDocWindow,ResizeDoc);    {    NoteRequest nr;    long index;    OSType synthType;      nr.polyphony = 2;    nr.typicalPolyphony = 0x00010000;    result = NAStuffToneDescription(d-&gt;na,1,&amp;nr.tone);    BlockMove(sme-&gt;synthName,nr.tone.synthesizerName,32);    nr.tone.synthesizerType = sme-&gt;synthType;    result = NANewNoteChannel(d-&gt;na,&amp;nr,&amp;d-&gt;nc);    FlashResult(result);    result = NAGetNoteChannelInfo(d-&gt;na,d-&gt;nc,&amp;index,&amp;d-&gt;part);    FlashResult(result);    result = NAGetRegisteredMusicDevice(d-&gt;na,index,&amp;synthType,nil,nil,&amp;d-&gt;ci);    FlashResult(result);    if(synthType != sme-&gt;synthType) //!!! note that this is in error, somehow      {      SysBeep(1);      SysBeep(1);      SysBeep(1);      }    d-&gt;sr.synthType = sme-&gt;synthType;    BlockMove(sme-&gt;synthName,d-&gt;sr.synthName,32);    }    /* * Since FlashResult will process the * update for the window, we have to * make harmless the update process. */  d-&gt;used = true;  d-&gt;ecl = NewEasyControlList(d-&gt;w,0);  result = MusicGetDescription(d-&gt;ci,&amp;d-&gt;sd);  FlashResult(result);  d-&gt;instrumentKnobCount = MusicGetInstrumentKnobDescription(d-&gt;ci,0,nil);    {    KnobDescription *kd;    short i;    d-&gt;ikdList = (KnobDescription **)NewHandle(sizeof(KnobDescription) * d-&gt;instrumentKnobCount);    HLock((Handle)d-&gt;ikdList);    kd = *d-&gt;ikdList;    for(i = 0; i &lt; d-&gt;instrumentKnobCount; i++)      result = MusicGetInstrumentKnobDescription(d-&gt;ci,i+1,kd+i);    }  d-&gt;globalKnobCount = MusicGetKnobDescription(d-&gt;ci,0,nil);    {    KnobDescription *kd;    short i;    d-&gt;gkdList = (KnobDescription **)NewHandle(sizeof(KnobDescription) * d-&gt;globalKnobCount);    HLock((Handle)d-&gt;gkdList);    kd = *d-&gt;gkdList;    for(i = 0; i &lt; d-&gt;globalKnobCount; i++)      result = MusicGetKnobDescription(d-&gt;ci,i+1,kd+i);    }  d-&gt;controllerCount = 0;    {    short i;    for(i = 1; i &lt;= 128; i++)      if(CheckBit(d-&gt;sd.controllers,i))        d-&gt;controllerCount++;    }  d-&gt;whichList = mInstrumentKnobs;  d-&gt;knobCount = d-&gt;instrumentKnobCount;    {    ToneDescription td;    long instrumentNumber;    td.synthesizerType = 0;    td.synthesizerName[0] = 0;    td.instrumentName[0] = 0;    td.instrumentNumber = 0;    td.gmNumber = 1;    result = MusicFindTone(d-&gt;ci, &amp;td, &amp;instrumentNumber, nil);    FlashResult(result);    result = MusicSetInstrumentNumber(d-&gt;ci,d-&gt;part,instrumentNumber);    FlashResult(result);    }  result = MusicGetPartName(d-&gt;ci,d-&gt;part,d-&gt;instrumentName);  FlashResult(result);/* end boguslike setup */    {    short knobses;    if(d-&gt;globalKnobCount &gt; d-&gt;instrumentKnobCount)      knobses = d-&gt;globalKnobCount;    else      knobses = d-&gt;instrumentKnobCount;    if(knobses &lt; 32)      knobses = 32;      /* for the controller list */    /*     * allocate space for enough controls     */    d-&gt;ec = (void *)NewPtr(sizeof(easyControl)        * knobses);    }  d-&gt;stashInstrument = 1;  d-&gt;recallInstrument = 1;  MakeControlsFromKnobList(d,&amp;allControls);  d-&gt;visibleSliderBounds.top = d-&gt;visibleSliderBounds.bottom      = d-&gt;visibleSliderBounds.left = d-&gt;visibleSliderBounds.right = 0;  d-&gt;virtualSliderBounds= allControls;  UpdateSliderKnobs(d);  /*   * Add the scroll bars   */  r.top = r.left = -10;  r.bottom = r.right = -5;  d-&gt;horizontalScroller = NewControl(d-&gt;w,&amp;r,&quot;\p&quot;,false,0,0,1,scrollBarProc,0);  d-&gt;verticalScroller = NewControl(d-&gt;w,&amp;r,&quot;\p&quot;,false,0,0,1,scrollBarProc,0);  d-&gt;lastH = d-&gt;lastV = 0;    {    Point a;    Rect cellBounds;    InstrumentDataHandle iH;      cellBounds.top = cellBounds.left = 0;    cellBounds.right = 1;    cellBounds.bottom = 0;    a.h = kInstrumentListWidth;    a.v = kInstrumentListCellHeight;    r.left = kInstrumentListLeft + 1;    r.right = kInstrumentListRight - 16;    r.top = kInstrumentListTop;    r.bottom = r.top + 10;    d-&gt;listH = LNew(&amp;r,&amp;cellBounds,a,0,d-&gt;w,false,false,false,true);    d-&gt;instrumentCount = 0;    if(sr)      {      i = 1;      do        {        iH = (InstrumentDataHandle)Get1Resource(kInstrumentListResType,i++);        DetachResource((Handle)iH);        if(iH)          AddToList(d,iH);        } while(iH);      }    }  d-&gt;statBounds.left = kStatLeft+1;  d-&gt;statBounds.right = kStatRight-1;  d-&gt;statBounds.top = kStatTop;  d-&gt;statBounds.bottom = kStatBottom;    {    Rect r;    r.left = kKeyboardLeft;    r.right = kKeyboardRight;    r.top = kKeyboardTop;    r.bottom = kKeyboardBottom;    InitializeKeyboard(&amp;d-&gt;kd,&amp;r,kKeyboardOctaveCount,48);    }  gDocCount++;    {    Point a,b;    a.h = b.h = windowRect.right - windowRect.left;    a.v = b.v = windowRect.bottom - windowRect.top;    ResizeDoc(docNumber + kFirstDocWindow,&amp;a,&amp;b,0);    ShowWindow(d-&gt;w);    }goHome:;  }void About(void)  {  EasyDialogMessage(0,(StringPtr)0x910,      &quot;\pby David Van Brink&quot;,      kEasyDialogOkay);  }void OpenSomeSynth(short n, short item,short ref)  {  short i;  for(i = 0; i&lt;kDocMax; i++)    {    if(!gDoc[i].used)      {      NewDocFromSaveRecord(i,nil,&amp;(**gSynthListH).entry[item-1]);      goto goHome;      }    }goHome:;  }#define kSliderVertBump 33Boolean CheckBit(unsigned long *t, long bit)  {  bit--;  t += (bit / 32);  bit &amp;= 31;  bit = 1L&lt;&lt;(31-bit);  return ((*t) &amp; bit) != 0;  }void MakeControlsFromKnobList(TDoc *d,Rect *outRect)  {  Rect allControls,r;  short i;  short j;  KnobDescription *kd;  EasyControl ec;  ComponentResult result;  short knobCount;  short columnCount;  short id;  if(d-&gt;whichList == mInstrumentKnobs)    d-&gt;knobCount = d-&gt;instrumentKnobCount;  else if(d-&gt;whichList == mControllers)    d-&gt;knobCount = d-&gt;controllerCount;  else    d-&gt;knobCount = d-&gt;globalKnobCount;  knobCount = d-&gt;knobCount;  SetRect(&amp;allControls,0,0,0,0);  ClipRect(&amp;allControls);      /* kill drawing for a while */  SetRect(&amp;r,kDocMargin,kDocMargin,kSliderWidth + kDocMargin,kDocMargin + 14);  kd = * (d-&gt;whichList == mInstrumentKnobs ? d-&gt;ikdList : d-&gt;gkdList);  columnCount = 1;  for(i = 0; i &lt; knobCount; i++)    {    if((!(d-&gt;whichList == mControllers)) &amp;&amp; ((kd-&gt;flags &amp; kKnobGroupStart) &amp;&amp; i))      {      OffsetRect(&amp;r,r.right - r.left + kDocMargin,0);      r.top = kDocMargin;      r.bottom = r.top + 14;      columnCount = 1;      }    else      {      columnCount++;      if(columnCount &gt; 20)        {        OffsetRect(&amp;r,r.right - r.left + kDocMargin,0);        r.top = kDocMargin + kSliderVertBump;        r.bottom = r.top + 14;        columnCount = 2;        }      }    UnionRect(&amp;allControls,&amp;r,&amp;allControls);    if(d-&gt;whichList == mControllers)      {      short jj;      jj = 0;      for(id = 1; id &lt;= 128; id++)        if(CheckBit(d-&gt;sd.controllers,id))          {          jj++;          if(jj == (i+1))            goto gotControl;          }      id = 1;      gotControl:      ec = NewEasyControl(&amp;sliderType,&amp;r,0,&amp;aSliderStyle,(long)d,id,0,d-&gt;ecl);      }    else      ec = NewEasyControl(&amp;sliderType,&amp;r,0,&amp;aSliderStyle,(long)d,i,0,d-&gt;ecl);    d-&gt;ec[i] = ec;    SetEasyControlValueProc(ec,(void *)SliderValueProc);    SetEasyControlColors(d-&gt;ec[i],dMyColors);//???    FlashResult(result);    if(d-&gt;whichList == mControllers)      {      if(id == kControllerPitchBend)        SetEasyControlRange(ec,0,3&lt;&lt;8);    /* 3 semitones */      else if(id == kControllerVolume)        SetEasyControlRange(ec,0,0x0001FFFF);  /* up to 4x max volume */      else        SetEasyControlRange(ec,0,(127&lt;&lt;8) + 255);      }    else      SetEasyControlRange(ec,kd-&gt;lowValue,kd-&gt;highValue);    OffsetRect(&amp;r,0,33);    kd++;    }  allControls.bottom += 20;  allControls.right += kDocMargin;  *outRect = allControls;  }void InitVars()/* * Called once at startup: yes, it * inits the vars. */  {  TDoc *d;  ComponentResult result;  gUnloadedCPUTime = GetCPUTime();#ifdef rolledIn  InstallFB01();//  InstallDumbSynth();#endif  }void FlashResult(ComponentResult result)  {  Str255 s,n;  short x;  GrafPort *oldPort;  GetPort(&amp;oldPort);  x = result &amp; 0x0000FFFF;  if((result &amp; 0xFFFF0000) == 0x80000000)    {    CopyPString(s,&quot;\pError number &quot;);    AnyBaseToPString(x,10,0,n);    ConcatenatePStrings(s,n);    ConcatenatePStrings(s,&quot;\p occurred.&quot;);        EasyDialogMessage(0,&quot;\pMusic Error&quot;,s,kEasyDialogOkay);    }  SetPort(oldPort);  }void Bootstrap()  {  short i;/*** File Menu ***/  InstallMenu(&quot;\pFile&quot;,nil,0);  InstallMenuItem(&quot;\pOpen\xC9/O&quot;,OpenDoc,mOpen);  InstallMenuItem(&quot;\pClose/W&quot;,(void *)CloseDoc,-mClose);  InstallMenuItem(&quot;\p(-&quot;,nil,0);  InstallMenuItem(&quot;\pSave/S&quot;,(void *)SaveDoc,-mSave);  InstallMenuItem(&quot;\pSave As&quot;,(void *)SaveAsDoc,-mSaveAs);  InstallQuitItem(LetsQuit,0);/*** Edit Menu ***/  InstallEditMenu(nil,nil,nil,nil,nil);/*** Synth Menu ***/  gSynthListH = GetSynthesizerList();  InstallMenu(&quot;\pSynthesizers&quot;,nil,0);  for(i = 0; i &lt; (**gSynthListH).synthCount; i++)    {    unsigned char s[40];    CopyPString(s,(**gSynthListH).entry[i].synthName);    if(!s[0])      {      s[0] = 1;      s[1] = 'x';      }    if(i &lt; 9)      {      s[s[0]+1] = '/';      s[s[0]+2] = '1' + i;      s[0] += 2;      }    InstallMenuItem( s,OpenSomeSynth,mNew);    }/* Instruments &amp; Knobs Menu */  InstallMenu(&quot;\pInstruments&quot;,nil,0);  InstallMenuItem(&quot;\pName Instrument\xC9/N&quot;,NameInstrumentDoc,-mNameInstrument);  InstallMenuItem(&quot;\pAdd Instrument To List/A&quot;,GetInstrumentDoc,-mGetInstrument);  InstallMenuItem(&quot;\pGet Instrument From List/G&quot;,SetInstrumentDoc,-mSetInstrument);  InstallMenuItem(&quot;\p(-&quot;,0,0);  InstallMenuItem(&quot;\pShow Instrument Knobs/&quot;,DoInstrumentKnobs,-mInstrumentKnobs);  InstallMenuItem(&quot;\pShow Global Knobs/(tm)&quot;,DoGlobalKnobs,-mGlobalKnobs);  InstallMenuItem(&quot;\pShow Controllers/&pound;&quot;,DoControllers,-mControllers);  InstallMenuItem(&quot;\p(-&quot;,nil,0);  InstallMenuItem(&quot;\pRandomize Instrument Knobs/K&quot;,RandomizeKnobsDoc,-mRandomizeKnobs);  InstallMenuItem(&quot;\pDefault Instrument Knobs/D&quot;,SetDefaultInstrumentDoc,-mTestDoc);/*** Tests Menu ***/  InstallMenu(&quot;\pTests&quot;,nil,0);  InstallMenuItem(&quot;\pPlay Pitchbend Scale&quot;,PitchBendDoc,-mPitchbendDoc);  InstallMenuItem(&quot;\pPlay &micro;Tonal Scale&quot;,MicrotoneDoc,-mMicrotoneDoc);  InstallMenuItem(&quot;\pNotes On&quot;,NotesOnDoc,-mTestDoc);  InstallMenuItem(&quot;\pNotes Off&quot;,NotesOffDoc,-mTestDoc);/*** Special Menu ***/  InstallMenu(&quot;\pSpecial&quot;,nil,0);  InstallMenuItem(&quot;\pCPU Load\xC9/L&quot;,ShowCPULoad,mCPULoad);  InstallMenuItem(&quot;\p(-&quot;,0,0);  InstallMenuItem(&quot;\pSet Master Tuning&quot;,SetMasterTuneDoc,-mTestDoc);  InstallMenuItem(&quot;\pSet Master Tuning&quot;,SetMasterTuneDoc,-mTestDoc);    {    Str63 s;    CopyPString(s,&quot;\pAbout &quot;);    ConcatenatePStrings(s,(StringPtr)0x910);    ConcatenatePStrings(s,&quot;\p&quot;);    SetAbout(s,0,About);    }  SetMasterOpenDocProc(OpenDocSpec);  SetMasterQuitAppProc((void *)LetsQuit);  InitVars();  }void Hatstrap()/*  * clean up  */  {  }pascal ComponentResult EditorMusicReadHook(MusicMIDIPacket *mp, long refCon)  {  ComponentInstance ci;  unsigned short x;  TDoc *d;  d = (TDoc *)refCon;  ci = d-&gt;ci;  x = mp-&gt;data[0] &amp; 0xF0;  if(x == 0x80)    {    NAPlayNote(d-&gt;na,d-&gt;nc,mp-&gt;data[1],0);    d-&gt;keyVel[mp-&gt;data[1]] = 0;    }  else if(x == 0x90)    {    NAPlayNote(d-&gt;na,d-&gt;nc,mp-&gt;data[1],mp-&gt;data[2]);    d-&gt;keyVel[mp-&gt;data[1]] = mp-&gt;data[2];    }  else if(x == 0xE0)    {    NASetController(d-&gt;na,d-&gt;nc,kControllerPitchBend,        (((mp-&gt;data[2]&lt;&lt;7) | mp-&gt;data[1]) - 0x2000) &gt;&gt; 4 );    d-&gt;controllersDirty = true;    }  return noErr;  }pascal void JunkTask(void)  {  }long GetCPUTime(void)/* * return the number of uSec for * some fixed little task here. */  {  TMTask tmTask;  register long tot,x;  short i;  tot = 0;  for(i = 0; i&lt; 4; i++)    {    tmTask.tmAddr = (TimerUPP)JunkTask;    tmTask.tmWakeUp = 0;    tmTask.tmReserved = 0;    InsXTime((void *)&amp;tmTask);    PrimeTime((void *)&amp;tmTask,-(0x7FFFffff));      x = 1000000;    while(x--);    RmvTime((void *)&amp;tmTask);    tot += tmTask.tmCount + (0x7FFFffff);    }  return tot;  }</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/QTMusicToo/listing34.html%3Fid%3DDTS10000915-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/QTMusicToo/listing34.html%3Fid%3DDTS10000915-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/QTMusicToo/listing34.html%3Fid%3DDTS10000915-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>