<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>CoreSample - /CoreSample.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">CoreSample</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxInterapplicationCommunication-date.html" target="_blank">Carbon > Interapplication Communication</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">CoreSample</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/CoreSample.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/CoreSample.c</option>
<option value="listing2.html">/CoreSample.h</option></select>
				</p>
				</form>
				<p><strong><a href="CoreSample.zip">Download Sample</a></strong> (&#147;CoreSample.zip&#148;, 43.4K)<BR>
<strong><a href="CoreSample.dmg">Download Sample</a></strong> (&#147;CoreSample.dmg&#148;, 110.2K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    CoreSample.c  Contains:  An application that is Apple Event-aware, Scripting Compatible,            and recordable. It supports the Required and Core Suite of               Apple Events, the Object Model, and the Open Scripting                Architecture.                                                          The main purpose of this sample code is to demonstrate how to develop an               application that is Apple event-aware, scripting compatible, uses the Object            Support Library, and supports Apple's Open Scripting Architecture.  In                 addition, it has its own 'aete' (Apple Event Terminology Extension) resource            (CoreSampleAETE.r). By  incorporating these technologies into your application,          your application will support Apple's Open Scripting Architecture.                                                              The functionality of CoreSample is basic window manipulation. The user may              create, drag, size, zoom, and close windows.  All these actions  may be                performed through Apple events.                                                                                  This application is also &quot;factored&quot;, which means that user interactions (such            as dragging or sizing a window, selecting a menuitem) are converted into Apple            events which the application sends off to itself, and then is handled by the            corresponding event handler.  Factoring makes it possible to access the appli-            cation's functionality through Apple events. It also makes it easier to record            the user's actions in the form of Apple events.                                                                          CoreSample supports the Required and Core suites of events, and the application            and window object classes. One additional property has been added to the window           class, and that is its position, the top left-hand coordinates of the window.            Some events only apply to the window class, such as Create, Move, Clone, and             Set Data (application properties are not modifiable, except for pClipboard,             which I do not support).  Currently, CoreSample supports the Simple Grammar,            as defined in the &quot;Object Support Library Developer Note&quot;.                                                                    The properties you may access with the Get Data Apple event are as follows:                Application - Best Type, Default Type, Class, Name, IsFrontProcess, Version              Window - Best Type, Default Type, Bounds, Class, Index, Name, Position,                 Closeable, Titled, Resizable, Zoomable, Floating, Modal, Zoomed,               and Visible.                                      The properties you may set with the Set Data Apple event are as follows:                Window - Bounds, Index, Zoomed, Name, Position, and Visible.                                                                When you create a new element, you may pass it initial data values. This              application will create the  new element accordingly if either or both of the            initial data parameters exist. In addition, with CoreSample, you may create or            move a window without passing it an insertion location record. By default, a            window will be created/moved to the frontmost position.                                                                      (NOTE: Some portions of this code are derived from TESample, a                    sample application provided by Apple Developer Technical Support.)            Written by:  Sue Dumont     Copyright:  Copyright &copy; 1992-1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        7/21/1999  Karl Groethe  Updated for Metrowerks Codewarror Pro 2.1        12/1/93    &lt;dan&gt;      added PowerPC support - will run native on PowerPC if                         compiled on PowerPC system.  These changes are denoted                          by [pwpc].        6/22/93    &lt;doo&gt;      converted files to run in the Think C 6.0 environment                        Fixed incorrect comparison of rects and windowlist problems                        associated with the Think compiler.          4/02.93    &lt;smd&gt;      added GetWindowBounds routine to calculate the correct                        bounds when the bounds accessed from the content region is                        invalid (such as when the application is hidden).                            -  cleaned up the aete.        10/01/92    &lt;smd&gt;       Added pVersion to application and now set the port before                        setting the pPosition property.            07/19/92    &lt;smd&gt;      Fixed bug where the Move event was not recording the                        correct window being moved when the data was being passed                        by index rather than by name.          04/30/92    &lt;smd&gt;      Check if replacing the same window in HandleMove                        (i.e., &quot;move window 2 to window 2&quot;). If so, do nothing.            06/25/92    &lt;smd&gt;      Changed FindRelativeWindow to return the windowPtr of the                          window being replaced rather than closing it. This caused                          an error when trying to replace the same window, in which                          case nothing should happen. (Ex. move window 2 to window 2).        04/27/92    &lt;smd&gt;      Fixed bug in DoSetData where data was set to a pointer, and                        then the pointer was diposed of.        04/20/92    &lt;smd&gt;       Fixed a bug with setting the visibility property of a window.        02/28/92    &lt;smd&gt;      Added coercion routines (thanks Kevin) to clean up code.                        These convert from descs to boolean, long, and pstrings.        02/25/92    &lt;smd&gt;      Modified GetWindowWithTitle, GetWidnowWithIndex, and                        GetWindowIndexNum routines to use WindowList so ALL windows                          will be accessed (even invisible ones).                                   -  Changed InitializeDescs to MyInitDescs and DisposeDescs to                        MyDisposeDescs.                                               -  Removed the FailIfErr calls from the AE Handlers so that                          they will return the error code rather than dying.        02/24/92    &lt;smd&gt;      Now sends a Move event when just making a window active.                        This is done in the DoEvent routine, drag region.        02/21/92    &lt;smd&gt;      Fixed bug where the same AEDesc was being passed as source                        and dest to AECoerceDesc().                                          Send myself a Move event when user clicks in content of a                          window.        02/17/92    &lt;smd&gt;      Added InitializeDescs() and DisposeDescs() routines.          02/05/92    &lt;smd&gt;      Handling optional parameters in Create Element event.        01/30/92    &lt;smd&gt;      Adding complete support for core suite and properties.        01/21/92    &lt;smd&gt;      Positive and negative offset when referencing by index.        01/10/92    &lt;smd&gt;      Made insertion location parameter optional in the Create                      and Move events, and provided my own default behavior.          01/09/92    &lt;kc&gt;      Quick clean up for Scripting QuickStart.            01/06/92    &lt;kc&gt;      Added code for Count Elements, Do Objects Exist, Move,                      and Get Data Size        11/91      &lt;smd&gt;      Initial code implementation.          */#include  &lt;Types.h&gt;#include   &lt;Quickdraw.h&gt;#include   &lt;Events.h&gt;#include   &lt;AppleEvents.h&gt;#include   &lt;AEObjects.h&gt;#include   &lt;AEPackObject.h&gt;#include  &lt;Resources.h&gt;          // for version resource#include   &lt;Windows.h&gt;#include   &lt;Menus.h&gt;#include   &lt;Dialogs.h&gt;#include   &lt;Desk.h&gt;#include   &lt;Scrap.h&gt;#include  &lt;limits.h&gt;#include   &lt;ToolUtils.h&gt;#include   &lt;Memory.h&gt;#include   &lt;SegLoad.h&gt;#include   &lt;OSUtils.h&gt;#include   &lt;OSEvents.h&gt;#include   &lt;DiskInit.h&gt;#include   &lt;Packages.h&gt;#include   &lt;Traps.h&gt;#include  &lt;string.h&gt;#include  &lt;Strings.h&gt;#include  &lt;stdarg.h&gt;#include  &quot;AERegistry.h&quot;        // Constants defined in the Registry.#include   &quot;CoreSample.h&quot;#include   &lt;LowMem.h&gt;#define HiWrd(aLong)  (((aLong) &gt;&gt; 16) &amp; 0xFFFF)#define LoWrd(aLong)  ((aLong) &amp; 0xFFFF)typedef  long*      LongPtr;typedef  WindowPeek*  PeekPtr;  //  Globals.SysEnvRec    gMac;          // Contains the system environmentBoolean      gHasWaitNextEvent;    // True if WaitNextEvent trap is availableBoolean      gInBackground;      // Determines if currently in the backgroundlong      gNumWindowsOpen;    // The number of windows openshort      gNewWindows;      // The number of new windows createdBoolean      gQuitApp;        // True to quit the applicationAEDesc      gNullDesc;        // A null descriptor recordAEAddressDesc  gSelfAddress;      // A self-addressed address descriptor recordProcessSerialNumber  gSelfPSN;      // This application's psnshort      gRefNum;        // reference number of rescource file//----------------------------------------------------------------------------------////      PROTOTYPES                                ////----------------------------------------------------------------------------------//void    AdjustMenuStates(void);void    AlertUser(short error);void    CloseTheWindow(WindowPtr window);WindowPtr  DoCreateNewWindow(WindowPtr behind);OSErr    CreateWindowObjectSpec(WindowPtr window,short formType,AEDesc *objectSpec);void    DoEvent(EventRecord *event);void    DoGrowWindow(WindowPtr window, EventRecord *event);void    DoMenuCommand(long menuResult);OSErr     DoSetData(AEDesc *token, AEDesc *data);void    DoUpdate(WindowPtr window);void    EventLoop(void);void    FailIfErr(OSErr error);OSErr    FindRelativeWindow(WindowPtr *window,AEDesc *object,DescType pos,WindowPtr *replaceWindow);OSErr    GetAppData(DescType theProperty, AEDesc *result);OSErr    GetMissingParams(AppleEvent *theAppleEvent);OSErr    GetWindowData(DescType property, WindowPtr window, AEDesc *result);long    GetWindowIndexNum(WindowPtr window);WindowPtr  GetWindowAtIndex(long index);WindowPtr  GetWindowWithTitle(ConstStr255Param title);void    InitAEHandlers(void);void    Initialize(void);Boolean   IsAppWindow(WindowPtr window);Boolean   IsDAWindow(WindowPtr window);Boolean   IsTrapAvailable(short tNumber, TrapType tType);void    ReportError(AppleEvent *reply, long err);WindowPtr  ResolveToWindow(AEDesc *objectSpecifier);void    SendClose(WindowPtr  window);void    SendCreateElement(void);void    SendMoveEvent(WindowPtr windowToMove, long index);void    SendQuitApp(void);void     SendSetData(AEDesc *pDesc, AEDesc *pData, AEDesc *object);void    SetUpPropertyData(WindowPtr window,DescType propType,DescType dataType,Size dataSize);void    SignalError(short error);void    Terminate(void);void    ZoomIt(WindowPtr window, short part);Rect    DoGetWindowBounds(WindowPtr window);void     MakeNewWindowTitle( short    num,        // Window number.             Str255    title);void     MyInitDescs(AEDesc*  desc1, ... );void     MyDisposeDescs(AEDesc*  desc1, ... );OSErr     DescToBoolean(const AEDesc* desc, Boolean* boolvalue);OSErr     DescToLong(const  AEDesc* desc, long* longvalue);OSErr     DescToPString(const AEDesc* desc, Str255 str, short maxLength);pascal OSErr HandleOpenApp(AppleEvent *theAppleEvent, AppleEvent* reply, long refCon);pascal OSErr HandleQuitApp(AppleEvent* theAppleEvent, AppleEvent* reply, long refCon);WindowPtr   DoCloneWindow(WindowPtr windowToClone, WindowPtr behindWindow);pascal  OSErr HandleClone(AppleEvent* theAppleEvent, AppleEvent* reply, long refCon);pascal  OSErr HandleClose(AppleEvent* theAppleEvent, AppleEvent* reply, long refCon);pascal  OSErr HandleCountElements(AppleEvent* theAppleEvent, AppleEvent* reply, long refCon);pascal  OSErr HandleCreateElement(AppleEvent* theAppleEvent, AppleEvent* reply, long refCon);pascal  OSErr HandleDoObjectsExist(AppleEvent* theAppleEvent, AppleEvent* reply, long refCon);pascal  OSErr HandleSetData(AppleEvent* theAppleEvent, AppleEvent* reply, long refCon);pascal  OSErr HandleGetData( AppleEvent*  theAppleEvent,           AppleEvent*  reply,           long      refCon  );pascal  OSErr HandleMove(AppleEvent* theAppleEvent, AppleEvent* reply, long refCon);pascal  OSErr DummyHandler( AppleEvent    *theAppleEvent,          AppleEvent    *reply,          long      refCon  );pascal  OSErr WindowAccessor( DescType    classWanted,    // window class            AEDesc*    container,      // the application (null container)            DescType    containerClass,             DescType    keyform,              AEDesc*    selectionData,            AEDesc*    resultToken,    // specified window is returned in result            long       theRefCon   );pascal  OSErr WindowPropertyAccessor( DescType    classWanted,    // Property class                  AEDesc*    container,      // Window object                DescType    containerClass,                 DescType    form,                AEDesc*    selectionData,                AEDesc*    resultToken,                long       theRefCon   );pascal  OSErr AppPropertyAccessor(  DescType    classWanted,      // Property class.                AEDesc*      container,        // Application.              DescType    containerClass,               DescType    form,              AEDesc*      selectionData,              AEDesc*      resultToken,              long       theRefCon   );extern pascal OSErr CreateObjSpecifier(DescType theClass, AEDesc *theContainer,            DescType keyForm, AEDesc *keyData, Boolean disposeInputs,             AEDesc *objSpecifier);extern void _DataInit();//----------------------------------------------------------------------------------//#pragma segment Mainvoid main(){#ifndef THINK_C  UnloadSeg((Ptr) _DataInit);    // Note that _DataInit must not be in Main!#endif  MaxApplZone();          // Expand the heap so code segments load at the top.  Initialize();          // Initialize the program  #ifndef THINK_C            // Initialize the program  UnloadSeg((Ptr)Initialize);    // Note that Initialize must not be in Main!#endif  EventLoop();          // Call the main event loop}//----------------------------------------------------------------------------------//// Continue retrieving events until the application terminates.            ////----------------------------------------------------------------------------------//#pragma segment Mainvoid EventLoop(){  RgnHandle    cursorRgn;  Boolean      gotEvent;  EventRecord    event;  cursorRgn = NewRgn();  gQuitApp = false;        // This is set to true in Terminate().        while (!gQuitApp)        // Loop until user quits or error.  {    if (gHasWaitNextEvent)      gotEvent = WaitNextEvent(everyEvent, &amp;event, LONG_MAX, cursorRgn);    else     {      SystemTask();      gotEvent = GetNextEvent(everyEvent, &amp;event);    }    if (gotEvent)      DoEvent(&amp;event);  }}//----------------------------------------------------------------------------------////  Find out which event this is and send it off to its appropriate handler.    ////  When the user clicks in the drag region, either one of two events may be    ////  triggered. The set position property (set data event) would occur if the widnow ////  is dragged to another location, or the move event would be sent if the window  ////  is just made active. In the latter case, the window's index before being    ////  moved to the front is passed to SendMoveEvent for recording purposes.      ////----------------------------------------------------------------------------------//#pragma segment Mainvoid DoEvent( EventRecord*  event ){  long    index=0;  short    part, err;  WindowPtr  window;  char    key;  Rect    bounds1, bounds2;  Point    aPoint;  switch (event-&gt;what)  {    case mouseDown:      part = FindWindow(event-&gt;where, &amp;window);      switch (part)       {        case inMenuBar:          AdjustMenuStates();                DoMenuCommand(MenuSelect(event-&gt;where));          break;                  case inSysWindow:          SystemClick(event, window);          break;                  case inContent:          if (window != FrontWindow())             SendMoveEvent(window, index);          break;                  case inDrag:          index = GetWindowIndexNum(window);          bounds1 = (*((WindowPeek)window)-&gt;contRgn)-&gt;rgnBBox;          DragWindow(window, event-&gt;where, &amp;qd.screenBits.bounds);          bounds2 = (*((WindowPeek)window)-&gt;contRgn)-&gt;rgnBBox;          if ((bounds1.left == bounds2.left) &amp;&amp;               (bounds1.top == bounds2.top))            SendMoveEvent(GetWindowAtIndex(index), index);          else            SetUpPropertyData(window,pPosition,typeQDPoint,sizeof(Point));          break;                  case inGoAway:          if (TrackGoAway(window, event-&gt;where))            SendClose(window);          break;                  case inGrow:          DoGrowWindow(window, event);          break;                  case inZoomIn:              // For recording purposes, we send an Apple        case inZoomOut:              // event to ourselves to set the bounds property.          if (TrackBox(window, event-&gt;where, part))          {            ZoomIt(window, part);            SetUpPropertyData(window, pIsZoomed, typeBoolean, sizeof(Boolean));          }          break;      }      break;          case keyDown:    case autoKey:                           // Only handle menu key equivalents      key = event-&gt;message &amp; charCodeMask;      if (event-&gt;modifiers &amp; cmdKey)    // Command key down      {        if (event-&gt;what == keyDown)         {          AdjustMenuStates();        // Enable/disable/check menu items properly          DoMenuCommand(MenuKey(key));        }      }       break;          case activateEvt:      DrawGrowIcon((WindowPtr)event-&gt;message);      break;          case updateEvt:      DoUpdate((WindowPtr) event-&gt;message);      break;          case diskEvt:      if (HiWord(event-&gt;message) != noErr)      {        SetPt(&amp;aPoint, kDILeft, kDITop);        err = DIBadMount(aPoint, event-&gt;message);      }      break;          case kOSEvent:      {        switch ((event-&gt;message &gt;&gt; 24) &amp; 0x0FF)      // High byte of message.        {          case kMouseMovedMessage:            break;            // Do nothing if mouse moved.                    case kSuspendResumeMessage:    // suspend/resume is also an activate/deactivate            SetCursor(&amp;qd.arrow);            if (IsAppWindow(window = FrontWindow()))              DrawGrowIcon(window);            break;        }      }      break;          case kHighLevelEvent:            // Let the Apple Event Manager handle high level event.      AEProcessAppleEvent(event);      break;    default:      break;  }}//----------------------------------------------------------------------------------////  Handle the mouseDown event in the grow box region of the window.  If the     ////  window has been resized, an Apple Event is sent to set the bounds property.    ////  This is done for recording purposes.                      ////----------------------------------------------------------------------------------//#pragma segment Mainvoid DoGrowWindow(  WindowPtr   window,          EventRecord* event  ){  long      result;  Rect      tempRect;  tempRect = qd.screenBits.bounds;    // Set up the limiting values.  tempRect.top = kMinWinDim;  tempRect.left = kMinWinDim;  result = GrowWindow(window, event-&gt;where, &amp;tempRect);  if (result)              // Did window actually change size?  {    SetPort(window);    InvalRect(&amp;window-&gt;portRect);    SizeWindow(window, LoWrd(result), HiWrd(result), true);    InvalRect(&amp;window-&gt;portRect);    // Send event for recording purposes.    SetUpPropertyData(window, pBounds, typeQDRectangle, sizeof(Rect));  }}//----------------------------------------------------------------------------------////  Zoom the window and set the refcon field to reflect its zoomed state.      ////----------------------------------------------------------------------------------//#pragma segment Mainvoid ZoomIt( WindowPtr  window,       short    part  ){  SetPort(window);  EraseRect(&amp;window-&gt;portRect);      // We just have a blank window.  ZoomWindow(window, part, window == FrontWindow());  SetWRefCon(window, (long)part == inZoomOut);  // Set to true if zoomed.  InvalRect(&amp;window-&gt;portRect);}//----------------------------------------------------------------------------------////  This is called when an update event is received for a window.          ////----------------------------------------------------------------------------------//#pragma segment Mainvoid DoUpdate( WindowPtr  window ){  if (IsAppWindow(window))   {    BeginUpdate(window);    SetPort(window);    EraseRect(&amp;window-&gt;portRect);      // We just have an empty window.    DrawGrowIcon(window);    EndUpdate(window);  }}//----------------------------------------------------------------------------------////  Set up the menus according to the current state.                ////----------------------------------------------------------------------------------//#pragma segment Mainvoid AdjustMenuStates(){  WindowPtr    window;  MenuHandle    menu;  window = FrontWindow();  menu = GetMenuHandle(mFile);  if (gNumWindowsOpen &lt; kMaxOpenWindows)    EnableItem(menu, iNew);      // Enable New if we can open more windows.  else    DisableItem(menu, iNew);  if (window)    EnableItem(menu, iClose);    // Enable Close if there is a window to close.  else    DisableItem(menu, iClose);}//----------------------------------------------------------------------------------////  This is called when an item is chosen from the menu bar.            ////----------------------------------------------------------------------------------//#pragma segment Mainvoid DoMenuCommand(long  menuResult){  short    menuID, menuItem;  short    itemHit, daRefNum;  Str255    daName;  WindowPtr  window;  window = FrontWindow();  menuID = HiWord(menuResult);  menuItem = LoWord(menuResult);  switch (menuID)  {    case mApple:      switch (menuItem)       {        case iAbout:          itemHit = Alert(rAboutAlert, nil);          break;        default:      // all other items in this menu are DA's.          GetMenuItemText(GetMenuHandle(mApple), menuItem, daName);          daRefNum = OpenDeskAcc(daName);          break;      }      break;          case mFile:      switch (menuItem)        // All these items send Apple events to      {                // handle the selection.        case iNew:          SendCreateElement();          break;        case iClose:          SendClose(FrontWindow());          break;        case iQuit:          SendQuitApp();          break;      }      break;        case mEdit:          // Call SystemEdit for DA editing &amp; MultiFinder.      SystemEdit(menuItem-1);      break;  }  HiliteMenu(0);          // Unhighlight what MenuSelect (or MenuKey) hilited.}//----------------------------------------------------------------------------------////  This routine appends the ascii representation of num to the title string.    ////----------------------------------------------------------------------------------//#pragma segment Mainvoid MakeNewWindowTitle( short    num,        // Window number.             Str255    title)        // Window title.{  short    i, count, index;  char    numStr[5];    i = 0;  do {      numStr[i++] = num % 10 + '0';    } while (num /= 10);      index = title[0] + 1;          // Get length of title string.    for (count = i-1; count &gt;= 0; count--)    title[index++] = numStr[count];  title[0] += i;}    //----------------------------------------------------------------------------------////  Create a new window behind the given window.  Use the window's refCon      ////  field to indicate whether the window is zoomed or not.              ////----------------------------------------------------------------------------------//#pragma segment MainWindowPtr DoCreateNewWindow(WindowPtr behindWindow){  Ptr      storage;  WindowPtr  newWindow, firstWindow;  Rect    bounds;  Str255    title;  if (gNumWindowsOpen &lt; kMaxOpenWindows)  {    storage = NewPtr(sizeof(WindowRecord));    if (storage != nil)     {      newWindow = GetNewWindow(rDocWindow, storage, behindWindow);      if (newWindow != nil)      {        gNumWindowsOpen++;      // Increment the number of windows currently open.        gNewWindows++;        // Increment the number of new windows created.        GetWTitle(newWindow, title);        MakeNewWindowTitle(gNewWindows, title);        SetWTitle(newWindow, title);        if (firstWindow = FrontWindow())        {      //***      bounds = (*((WindowPeek)firstWindow)-&gt;contRgn)-&gt;rgnBBox;          bounds = DoGetWindowBounds(firstWindow);          MoveWindow(newWindow, bounds.left+30, bounds.top+30, false);        }        SetWRefCon(newWindow, 0L);      // set zoom state to false.        SetPort(newWindow);        return(newWindow);      }    else      DisposePtr(storage);    // Dispose of the storage if it is not used.    }  }  return(nil);}//----------------------------------------------------------------------------------////  Close the given window or desk accessory.                    ////----------------------------------------------------------------------------------//#pragma segment Mainvoid CloseTheWindow(WindowPtr  window){  if (IsDAWindow(window))    CloseDeskAcc(((WindowPeek)window)-&gt;windowKind);  else     if (IsAppWindow(window))    {      CloseWindow(window);      DisposePtr((Ptr)window);      gNumWindowsOpen--;    }}//----------------------------------------------------------------------------------////  Returns true if the window belongs to this application, else false.        ////----------------------------------------------------------------------------------//#pragma segment MainBoolean IsAppWindow(WindowPtr  window){  if (!window)    return(false);  else     return(((WindowPeek)window)-&gt;windowKind == userKind);}//----------------------------------------------------------------------------------////  Returns true if the given window belongs to a DA, else false is returned.    ////----------------------------------------------------------------------------------//#pragma segment MainBoolean IsDAWindow(WindowPtr  window){  if (window == nil)    return(false);  else          // DA windows have negative windowKinds.    return(((WindowPeek)window)-&gt;windowKind &lt; 0);}//----------------------------------------------------------------------------------////  If an error has occurred, I check the user interaction level. If I can      ////  interact with the user, I put up a dialog and exit the application; otherwise,  ////  I just exit the application.                          ////                                          ////  ***NOTE: Real applications would not handle errors in this fashion!  If they  ////  cannot interact with the user, they should abort the Apple event handler and  //// return the error in the reply parameter.                      ////----------------------------------------------------------------------------------//#pragma segment  Mainvoid FailIfErr(OSErr  error){  if (error)  {    if (!(AEInteractWithUser(kNoTimeOut, nil, nil)))      // Can we interact?      AlertUser(eAEError);                  // Yes, so put up the dialog.    ExitToShell();  }}//----------------------------------------------------------------------------------////  Display an alert for the user to indicate that an error has occurred.      ////----------------------------------------------------------------------------------//#pragma segment Mainvoid AlertUser(short  error){  short    itemHit;  Str255    message;  GetIndString(message, kErrStrings, error);  ParamText(message, (ConstStr255Param)&quot;\p&quot;, (ConstStr255Param)&quot;\p&quot;, (ConstStr255Param)&quot;\p&quot;);  // [pwpc]  itemHit = Alert(rUserAlert, nil);}//----------------------------------------------------------------------------------////  Quit the application by closing all windows and setting the quit flag to true.  ////----------------------------------------------------------------------------------// #pragma segment Mainvoid Terminate(){  WindowPtr  aWindow;  while(aWindow = FrontWindow())    CloseTheWindow(aWindow);    AEDisposeDesc(&amp;gSelfAddress);      // Dispose of my self-addressed descriptor.  gQuitApp = true;}//----------------------------------------------------------------------------------////  Perform the initialization necessary at start-up time.  Note that we use    ////  kCurrentProcess in our psn rather than calling GetCurrentProcess.  Using    ////  kCurrentProcess will allow us to record those events we send to ourselves,    ////  otherwise, the recorder won't recognize the psn and won't record our event!    ////----------------------------------------------------------------------------------//#pragma segment Initializevoid Initialize(){  Handle          menuBar;  long          total, contig;  EventRecord       event;  short          count;  gInBackground = false;  InitGraf((Ptr)&amp;qd.thePort);  InitWindows();  InitMenus();  InitDialogs(nil);  InitCursor();  InitAEHandlers();  for (count = 1; count &lt;= 3; count++)    EventAvail(everyEvent, &amp;event);     SysEnvirons(kSysEnvironsVersion, &amp;gMac);    if (gMac.machineType &lt; 0)     SignalError(eWrongMachine);        // Less than 128K ROM's.  gHasWaitNextEvent = IsTrapAvailable(_WaitNextEvent, ToolTrap);     if ((long)GetApplLimit() - (long)ApplicationZone() &lt; kMinHeap)     SignalError(eSmallSize);    PurgeSpace(&amp;total, &amp;contig);  if (total &lt; kMinSpace)    if (UnloadScrap() != noErr)      SignalError(eNoMemory);    else    {      PurgeSpace(&amp;total, &amp;contig);      if (total &lt; kMinSpace)        SignalError(eNoMemory);    }  if (!(menuBar = GetNewMBar(rMenuBar)))    // Set up menu bar.    SignalError(eNoMemory);  SetMenuBar(menuBar);  DisposeHandle(menuBar);  AppendResMenu(GetMenuHandle(mApple), 'DRVR');      // Add DA's to menu.  DrawMenuBar();    // Set up the self-addressed descriptor record.    gSelfPSN.highLongOfPSN = 0;    gSelfPSN.lowLongOfPSN = kCurrentProcess;    //* Use this instead of GetCurrentProcess *//    FailIfErr(AECreateDesc(typeProcessSerialNumber,(Ptr)&amp;gSelfPSN,sizeof(ProcessSerialNumber),&amp;gSelfAddress));  gNullDesc.descriptorType = typeNull;    // Initialize the global null descriptor record.  gNullDesc.dataHandle = nil;  gRefNum = CurResFile();  gNumWindowsOpen = 0;  gNewWindows = 0;}//----------------------------------------------------------------------------------////  Returns true if the given trap number is implemented, else returns false.    ////----------------------------------------------------------------------------------//#pragma segment InitializeBoolean IsTrapAvailable(short trapNum, TrapType  tType){  if ((tType == (unsigned char)ToolTrap) &amp;&amp; (gMac.machineType &gt; envMachUnknown) &amp;&amp;     (gMac.machineType &lt; envMacII))  {                      // it's a 512K, Plus, or SE    trapNum = trapNum &amp; 0x03FF;    if (trapNum &gt; 0x01FF)          // which means the tool traps      trapNum = _Unimplemented;      // only go to 0x01FF  }  return(NGetTrapAddress(trapNum, tType) != GetToolTrapAddress(_Unimplemented));  // [pwpc]}//----------------------------------------------------------------------------------//#pragma segment Initializevoid SignalError(short error){  AlertUser(error);  ExitToShell();}//**********************************************************************************////          *  Apple Events and Object Model Support *            ////**********************************************************************************////----------------------------------------------------------------------------------////  Initializes all descriptor records passed in to this routine.  The variable    ////  argument list is null terminated.                        ////----------------------------------------------------------------------------------//#pragma segment Mainvoid MyInitDescs(AEDesc*  desc1, ... )      // Variable, null terminated argument list.{  va_list    argptr;              // pointer to each argument in list.  AEDesc*    nextDesc;            // next descriptor argument in list.  va_start(argptr, desc1);  desc1-&gt;descriptorType = typeNull;  desc1-&gt;dataHandle = nil;    while(nextDesc = va_arg(argptr, AEDesc *))  {    nextDesc-&gt;descriptorType = typeNull;    nextDesc-&gt;dataHandle = nil;  }  va_end(argptr);}  //----------------------------------------------------------------------------------////  Dispose all descriptor records passed into this routine. (Variable arg. list).  ////----------------------------------------------------------------------------------//#pragma segment Mainvoid MyDisposeDescs(AEDesc*  desc1, ... )    // Null terminated argument list.{  va_list    argptr;      // pointer to each argument in list.  AEDesc*    nextDesc;    // descriptor argument in list.  va_start(argptr, desc1);  if (desc1-&gt;dataHandle)    AEDisposeDesc(desc1);  while(nextDesc = va_arg(argptr, AEDesc *))  {    if (nextDesc-&gt;dataHandle)      AEDisposeDesc(nextDesc);  }  va_end(argptr);}//----------------------------------------------------------------------------------////  Converts a descriptor to a boolean.                        ////----------------------------------------------------------------------------------//#pragma segment AppleEventsOSErr DescToBoolean(const AEDesc* desc, Boolean* boolvalue){  AEDesc      tempDesc;  Handle      dataHandle;  tempDesc.dataHandle = nil;  if (desc-&gt;descriptorType == typeBoolean)    dataHandle = desc-&gt;dataHandle;  else    if (AECoerceDesc(desc, typeBoolean, &amp;tempDesc) == noErr)      dataHandle = tempDesc.dataHandle;    else      return(errAECoercionFail);    *boolvalue = **dataHandle;  MyDisposeDescs(&amp;tempDesc, kEndOfList);  return(noErr);}//----------------------------------------------------------------------------------////  Converts a descriptor to a long.                        ////----------------------------------------------------------------------------------//#pragma segment AppleEventsOSErr DescToLong(const  AEDesc* desc, long* longvalue){  AEDesc      tempDesc;  Handle      dataHandle;  tempDesc.dataHandle = nil;  if (desc-&gt;descriptorType == typeLongInteger)    dataHandle = desc-&gt;dataHandle;  else    if (AECoerceDesc(desc, typeLongInteger, &amp;tempDesc) == noErr)      dataHandle = tempDesc.dataHandle;    else      return(errAECoercionFail);    *longvalue = *(LongPtr)*dataHandle;  MyDisposeDescs(&amp;tempDesc, kEndOfList);  return(noErr);}//----------------------------------------------------------------------------------////  Converts a descriptor to a pascal string.                    ////----------------------------------------------------------------------------------//#pragma segment AppleEventsOSErr DescToPString(const AEDesc* desc, Str255 str, short maxLength){  AEDesc      tempDesc;  Handle      dataHandle;  long      charCount;  tempDesc.dataHandle = nil;  if (desc-&gt;descriptorType == typeChar)    dataHandle = desc-&gt;dataHandle;  else    if (AECoerceDesc(desc, typeChar, &amp;tempDesc) == noErr)      dataHandle = tempDesc.dataHandle;    else      return(errAECoercionFail);    charCount = GetHandleSize(dataHandle);  if (charCount &gt; maxLength)  {    MyDisposeDescs(&amp;tempDesc, kEndOfList);    return(errAECoercionFail);  }  str[0] = charCount;  HLock(dataHandle);  BlockMove(*dataHandle, &amp;str[1], charCount);  HUnlock(dataHandle);    // This may be from desc, so must unlock.  MyDisposeDescs(&amp;tempDesc, kEndOfList);  return(noErr);}//----------------------------------------------------------------------------------////  Create the first window in response to the Open Application Apple Event.    ////----------------------------------------------------------------------------------//#pragma segment MainpascalOSErr HandleOpenApp(AppleEvent *theAppleEvent, AppleEvent* reply, long refCon){  #pragma unused (reply,refCon)  WindowPtr  window;  OSErr    err;    if (!(err = GetMissingParams(theAppleEvent)))    // Error if any parameters.  {    if (window = DoCreateNewWindow((WindowPtr)-1))  // Create initial window      ShowWindow(window);    else      err = errAEEventNotHandled;  }  return(err);}//----------------------------------------------------------------------------------////  Send a Quit Application Apple Event to myself to terminate this app.      ////----------------------------------------------------------------------------------//#pragma segment Mainvoid SendQuitApp(){  AppleEvent  myAppleEvent, reply;      //  Create the Apple Event.  FailIfErr(AECreateAppleEvent(kCoreEventClass, kAEQuitApplication, &amp;gSelfAddress,                  kAutoGenerateReturnID, kAnyTransactionID, &amp;myAppleEvent));    //  Send the Apple Event.    FailIfErr(AESend(&amp;myAppleEvent, &amp;reply, kAENoReply+kAENeverInteract, kAENormalPriority,                kAEDefaultTimeout, nil, nil));    AEDisposeDesc(&amp;myAppleEvent);        // Dispose of the Apple Event.}//----------------------------------------------------------------------------------////  Quit the application.                              ////----------------------------------------------------------------------------------//#pragma segment MainpascalOSErr HandleQuitApp(AppleEvent* theAppleEvent, AppleEvent* reply, long refCon){  #pragma unused (reply,refCon)  OSErr  err;    if (!(err = GetMissingParams(theAppleEvent)))  // Error if there are any parameters.    Terminate();  return(err);}//----------------------------------------------------------------------------------////  This routine makes a clone of the given window by copying its bounds, zoom    ////  state, and title (with the addition of &quot;copy&quot;) properties.            ////----------------------------------------------------------------------------------//#pragma segment MainWindowPtr DoCloneWindow(WindowPtr windowToClone, WindowPtr behindWindow){  WindowPtr  clonedWindow;  Rect    bounds;  Str255    title;  if (clonedWindow = DoCreateNewWindow(behindWindow))  {    GetWTitle(windowToClone, title);    p2cstr(title);    strcat((char *)title, &quot; copy\0&quot;);    c2pstr((char *)title);    bounds = DoGetWindowBounds(windowToClone);    SetWTitle(clonedWindow, title);    MoveWindow(clonedWindow, bounds.left, bounds.top, false);    SizeWindow(clonedWindow, bounds.right-bounds.left, bounds.bottom-bounds.top, true);    SetWRefCon(clonedWindow, GetWRefCon(windowToClone));    return(clonedWindow);  }  return(nil);}//----------------------------------------------------------------------------------////  Handle the Clone Apple Event and create a clone of the given object. To clone  ////  a window, I clone its bounds, zoom state, and visible properties. In addition,  ////  I clone the window's title and append &quot; copy&quot; to it for the cloned window's    ////  title. If the insertion location parameter is not in the event record, I     ////  perform the default behavior, which is to position the clone behind the     ////  window being cloned.                              ////----------------------------------------------------------------------------------//#pragma segment MainpascalOSErr HandleClone(AppleEvent* theAppleEvent, AppleEvent* reply, long refCon){  #pragma unused (refCon)  AEDesc    cloneObject, windowObject, replyObject, insertionLoc;  AERecord  insertionRec;  DescType  theType, position;  WindowPtr  windowToClone, window, rplcWindow, behindWindow = nil;  Size    paramSize;  OSErr    err = noErr;  MyInitDescs(&amp;cloneObject,&amp;windowObject,&amp;replyObject,&amp;insertionLoc,&amp;insertionRec,kEndOfList);    //  Let's get the direct object, the object to clone.  if (err = AEGetParamDesc(theAppleEvent, keyDirectObject, typeObjectSpecifier, &amp;cloneObject))    goto myExit;  if (!(windowToClone = ResolveToWindow(&amp;cloneObject)))  {    err = errAENoSuchObject;    goto myExit;  }  else    // we have a window to clone.  {    if (!(err = AEGetParamDesc(theAppleEvent,keyAEInsertHere,typeInsertionLoc,&amp;insertionLoc)))      if (!(err = AECoerceDesc(&amp;insertionLoc, typeAERecord, &amp;insertionRec)))        // Get object as typeWildCard because it may be null or an object specifier.        if (!(err = AEGetKeyDesc(&amp;insertionRec, keyAEObject, typeWildCard, &amp;windowObject)))          if (!(err = AEGetKeyPtr(&amp;insertionRec,keyAEPosition,typeEnumeration,&amp;theType,                    (Ptr)&amp;position,sizeof(DescType),&amp;paramSize)))            err = FindRelativeWindow(&amp;behindWindow, &amp;windowObject, position, &amp;rplcWindow);    if (err)      if (err == errAEDescNotFound)        behindWindow = windowToClone;    // Registry's default behavior.      else        goto myExit;  }  if (window = DoCloneWindow(windowToClone, behindWindow))  {    if (((WindowPeek)windowToClone)-&gt;visible)      ShowWindow(window);    if (position == kAEReplace)      CloseTheWindow(rplcWindow);    if (reply-&gt;dataHandle != nil)    {      CreateWindowObjectSpec(window, kIndexKeyForm, &amp;replyObject);      err = AEPutParamDesc(reply, keyAEResult, &amp;replyObject);    }  }  else    err = errAEEventNotHandled;myExit:  MyDisposeDescs(&amp;cloneObject,&amp;windowObject,&amp;replyObject,&amp;insertionLoc,&amp;insertionRec,kEndOfList);  return(err);}  //----------------------------------------------------------------------------------////  Send a Close Apple Event to myself to close the specified window.        ////----------------------------------------------------------------------------------//#pragma segment Mainvoid SendClose(WindowPtr  window){  AppleEvent    myAppleEvent, reply;  AEDesc      windowObject;        // The window object specifier.        //  Create the Close Apple Event.  FailIfErr(AECreateAppleEvent(kAECoreSuite, kAEClose, &amp;gSelfAddress, kAutoGenerateReturnID,                  kAnyTransactionID, &amp;myAppleEvent));        //  Create the window object specifier and add this to myAppleEvent.  CreateWindowObjectSpec(window, kIndexKeyForm, &amp;windowObject);  FailIfErr(AEPutParamDesc(&amp;myAppleEvent, keyDirectObject, &amp;windowObject));        //  Send the Apple Event.    FailIfErr(AESend(&amp;myAppleEvent, &amp;reply, kAENoReply+kAECanInteract, kAENormalPriority,                kAEDefaultTimeout, nil, nil));        //  Now dispose of the AppleEvent and object specifier.                    AEDisposeDesc(&amp;myAppleEvent);  AEDisposeDesc(&amp;windowObject);}//----------------------------------------------------------------------------------////  Respond to the Close Apple Event by closing the specified window object.    ////----------------------------------------------------------------------------------//#pragma segment MainpascalOSErr HandleClose(AppleEvent* theAppleEvent, AppleEvent* reply, long refCon){  #pragma unused (reply,refCon)  AEDesc      windowObject;  WindowPtr    windowToClose;  OSErr      myErr;    MyInitDescs(&amp;windowObject,kEndOfList);    //  First, get the direct object which is the object to close.  myErr = AEGetParamDesc(theAppleEvent,keyDirectObject,typeObjectSpecifier,&amp;windowObject);  if (!myErr &amp;&amp; !(myErr = GetMissingParams(theAppleEvent)))  {    if (windowToClose = ResolveToWindow(&amp;windowObject))      CloseTheWindow(windowToClose);    else      myErr = errAENoSuchObject;  }  MyDisposeDescs(&amp;windowObject,kEndOfList);  return(myErr);}//----------------------------------------------------------------------------------////  Respond to the Count Elements Apple Event.                    ////----------------------------------------------------------------------------------//#pragma segment MainpascalOSErr HandleCountElements(AppleEvent* theAppleEvent, AppleEvent* reply, long refCon){  #pragma unused (refCon)  AEDesc      directObject;  DescType    theType, theClass;  Size      paramSize;  OSErr      err;    MyInitDescs(&amp;directObject, kEndOfList);    //  Get the direct object, should be null.  if (!(err = AEGetParamDesc(theAppleEvent, keyDirectObject, typeWildCard, &amp;directObject)))    if (!(err = AEGetParamPtr(theAppleEvent,keyAEObjectClass,typeType,&amp;theType,(Ptr)&amp;theClass,          sizeof(DescType),&amp;paramSize)))    // Get class of elements to count.      err = GetMissingParams(theAppleEvent);    // Error if more parameters.  if (err)    goto myExit;        //  If we had a deeper object hierarchy, we'd probably call AEResolve here, but...    //  we only handle the window class contained within the null object.  if (theClass == cWindow &amp;&amp; directObject.descriptorType == typeNull)    err = AEPutParamPtr(reply, keyAEResult, typeLongInteger, (Ptr)&amp;gNumWindowsOpen, sizeof(long));myExit:  MyDisposeDescs(&amp;directObject, kEndOfList);  return(err);}//----------------------------------------------------------------------------------////  Send a Create Element Apple Event to myself to create a new window. By default, ////  I am setting the position to the beginning of the null container (frontmost).  ////  In this case, as well as at the end of the container, the object parameter is  ////  the null container. If the position is before, after, or replace, the object  ////  parameter must be an object specifier to indicate the relative window.      ////----------------------------------------------------------------------------------//#pragma segment Mainvoid SendCreateElement(){  AppleEvent    myAppleEvent, reply;  AERecord    insertionRec;          // Insertion Loc record.  AEDesc      insertionLoc;          // The coerced insertionRec.  DescType    theType;          //  Create the Apple Event.  FailIfErr(AECreateAppleEvent(kAECoreSuite, kAECreateElement, &amp;gSelfAddress, kAutoGenerateReturnID,                  kAnyTransactionID, &amp;myAppleEvent));        //  Attach the class of the new element, which in this case is cWindow.  theType = cWindow;    FailIfErr(AEPutParamPtr(&amp;myAppleEvent, keyAEObjectClass, typeType, (Ptr)&amp;theType, sizeof(DescType)));        //  Create insertion loc, object is null container and position is beginning.  FailIfErr(AECreateList(nil, 0, true, &amp;insertionRec));      // Create an AE Record.  theType = kAEBeginning;  FailIfErr(AEPutKeyDesc(&amp;insertionRec, keyAEObject, &amp;gNullDesc));  FailIfErr(AEPutKeyPtr(&amp;insertionRec, keyAEPosition, typeEnumeration, (Ptr)&amp;theType, sizeof(DescType)));  FailIfErr(AECoerceDesc(&amp;insertionRec, typeInsertionLoc, &amp;insertionLoc));        // Now add the insertion location descriptor record to the Apple Event.  FailIfErr(AEPutParamDesc(&amp;myAppleEvent, keyAEInsertHere, &amp;insertionLoc));        //  Send the Apple Event.    FailIfErr(AESend(&amp;myAppleEvent, &amp;reply, kAENoReply+kAECanInteract, kAENormalPriority,                kAEDefaultTimeout, nil, nil));        //  Now dispose of the AppleEvent and other records.    MyDisposeDescs(&amp;myAppleEvent, &amp;insertionRec, &amp;insertionLoc, kEndOfList);}//----------------------------------------------------------------------------------////  Respond to the Create Element Apple event and create a new window. For this    ////  application, the keyAEInsertHere parameter is optional. If this parameter is   ////  not present, a new window is created in the frontmost position.          ////  This routine also handles the optional initial data parameters (keyAEData and  ////  keyAEPropData) if they are present. A window object specifier must be in the  ////  keyAEData parameter, which is essentially used to make a clone. If the      ////  property data exists, these properties will override those previously set.    ////----------------------------------------------------------------------------------//#pragma segment MainpascalOSErr HandleCreateElement(AppleEvent* theAppleEvent, AppleEvent* reply, long refCon){  #pragma unused (refCon)  AEDesc      windowObject, dataObject, propData, propObject, replyObject;  AEDesc      insLocParam;  AERecord    insLocRec;  AERecord    dataPropParam;          // Initial data parameters.  AEKeyword    keyWord;            // Property id code for PropData.  DescType    theType, theClass, position;  WindowPtr    window, relativeWindow, dataWindow, rplcWindow;  Rect      bounds;  Size      theSize;  Str255      buffer;  long      numItems;  short      i;  Boolean      isVisible;  OSErr      err;    if (err = AEGetParamPtr(theAppleEvent, keyAEObjectClass, typeType, &amp;theType, (Ptr)&amp;theClass,          sizeof(DescType), &amp;theSize))    return(err);  if (theClass != cWindow)      // We only handle elements of the class cWindow.    return(errAEEventNotHandled);  position = typeNull;  MyInitDescs(&amp;windowObject,&amp;dataObject,&amp;propData,&amp;propObject,&amp;insLocParam,&amp;dataPropParam,&amp;replyObject,&amp;insLocRec,kEndOfList);      // Now get the insertion location record as an AERecord, if it exists.  if (!(err = AEGetParamDesc(theAppleEvent, keyAEInsertHere, typeInsertionLoc, &amp;insLocParam)))  {    // coerce the insertion loc record to an AE record.    err = AECoerceDesc(&amp;insLocParam, typeAERecord, &amp;insLocRec);      //  Get the object as typeWildCard because it may be a null descriptor or an object.    if (!(err = AEGetKeyDesc(&amp;insLocRec, keyAEObject, typeWildCard, &amp;windowObject)))      if (!(err = AEGetKeyPtr(&amp;insLocRec, keyAEPosition, typeEnumeration, &amp;theType, (Ptr)&amp;position,            sizeof(DescType), &amp;theSize)))      {        relativeWindow = nil;        err = FindRelativeWindow(&amp;relativeWindow, &amp;windowObject, position, &amp;rplcWindow);      }  }  else    if (err == errAEDescNotFound)  // No insertion loc, make it frontmost by default.    {      relativeWindow = (WindowPtr)-1;      position = kAEBeginning;      err = noErr;    // Not an error for me because I make this param optional.    }  if (err)    goto myExit;            // Check if optional data parameter is present.  if (!(err = AEGetParamDesc(theAppleEvent,keyAEData,typeObjectSpecifier,&amp;dataObject)))  {    if (dataWindow = ResolveToWindow(&amp;dataObject))    {      window = DoCloneWindow(dataWindow, relativeWindow);      isVisible = ((WindowPeek)dataWindow)-&gt;visible;    }    else    {      err = errAENoSuchObject;      goto myExit;    }  }  else    if (err == errAEDescNotFound)  // The optional data parameter is not present.    {      if (window = DoCreateNewWindow(relativeWindow))      {      err = noErr;      isVisible = true;        if (position == kAEReplace)      // Replace the window in the right position.        {          bounds = DoGetWindowBounds(rplcWindow);          MoveWindow(window, bounds.left, bounds.top, false);        }      }      else      {        err = errAEEventNotHandled;    // couldn't create a new window.        goto myExit;      }    }    else      goto myExit;  if (isVisible)          // We set the visibility here because it may be changed    ShowWindow(window);      // by the following property data.      // Handle PropData parameter if it exists.      if (!(err = AEGetParamDesc(theAppleEvent,keyAEPropData,typeAERecord,&amp;dataPropParam)))  {    AECountItems(&amp;dataPropParam, &amp;numItems);    for (i = 1; i &lt;= numItems; i++)    {      if (!(err = AEGetNthPtr(&amp;dataPropParam,i,typeWildCard,&amp;keyWord,&amp;theType,&amp;buffer,sizeof(Str255),&amp;theSize)))      {        AECreateDesc(keyWord, (Ptr)&amp;window, sizeof(Ptr), &amp;propObject);        AECreateDesc(theType, (Ptr)&amp;buffer, theSize, &amp;propData);        err = DoSetData(&amp;propObject, &amp;propData);        AEDisposeDesc(&amp;propObject);        AEDisposeDesc(&amp;propData);        if (err)          break;      }    }  }    if (!err || err == errAEDescNotFound)  {    if (position == kAEReplace)      CloseTheWindow(rplcWindow);    err = noErr;    if (reply-&gt;dataHandle != nil)    {      CreateWindowObjectSpec(window, kIndexKeyForm, &amp;replyObject);      err = AEPutParamDesc(reply, keyAEResult, &amp;replyObject);    }  }    myExit:  MyDisposeDescs(&amp;windowObject,&amp;dataObject,&amp;propData,&amp;propObject,&amp;insLocParam,&amp;dataPropParam,&amp;replyObject,&amp;insLocRec,kEndOfList);  return(err);}//----------------------------------------------------------------------------------////  Respond to the Do Objects Exist AE by attempting to resolve the object specifier////----------------------------------------------------------------------------------//#pragma segment MainpascalOSErr HandleDoObjectsExist(AppleEvent* theAppleEvent, AppleEvent* reply, long refCon){  #pragma unused (reply,refCon)  AEDesc    target, token;  Boolean    exists;  OSErr    err;    MyInitDescs(&amp;target, &amp;token, kEndOfList);  if (!(err = AEGetParamDesc(theAppleEvent, keyDirectObject, typeWildCard, &amp;target)))    if (!(err = GetMissingParams(theAppleEvent)))      // Check for missing params.    {      exists = true;      token.descriptorType = typeNull;      if (target.descriptorType != typeNull)        exists = (AEResolve(&amp;target, kAEIDoMinimum, &amp;token) == noErr);        //  Add data to the reply Apple event record.        err = AEPutParamPtr(reply, keyDirectObject,typeBoolean,(Ptr)&amp;exists,sizeof(Boolean));    }myExit:  MyDisposeDescs(&amp;target, &amp;token, kEndOfList);  return(err);}//----------------------------------------------------------------------------------////  Send the Set Data Apple Event with the object, property, and property data.    ////  *NOTE*: I am sending myself the Set Data event in response to user interaction.  ////  These actions have already occurred by this time, so I am sending the event    ////  with the &quot;don't execute&quot; flag set for &quot;smart&quot; recorders.  A &quot;smart&quot; recorder  ////  would check this flag when it intercepts the Apple event, and if it was set,  ////  it wouldn't pass the event to the application.                  ////----------------------------------------------------------------------------------//#pragma segment Mainvoid SendSetData( AEDesc*  propDesc,      // the property to set          AEDesc*  propData,      // the property data          AEDesc*  target  )    // object to set property of{  AppleEvent  myAppleEvent, reply;  AEDesc    objectToSet;  FailIfErr(AECreateAppleEvent(kAECoreSuite, kAESetData, &amp;gSelfAddress, kAutoGenerateReturnID,                  kAnyTransactionID, &amp;myAppleEvent));        //  Create the object specifier for the property of the object.  FailIfErr(CreateObjSpecifier(cProperty, target, formPropertyID, propDesc,                     false, &amp;objectToSet));        //  Attach the property object specifier.  FailIfErr(AEPutParamDesc(&amp;myAppleEvent, keyDirectObject, &amp;objectToSet));        //  Add the property data.  FailIfErr(AEPutParamDesc(&amp;myAppleEvent, keyAEData, propData));    FailIfErr(AESend(&amp;myAppleEvent, &amp;reply, kAENoReply+kAECanInteract+kAEDontExecute, kAENormalPriority,                kAEDefaultTimeout, nil, nil));  AEDisposeDesc(&amp;objectToSet);          // Clean up.                  AEDisposeDesc(&amp;myAppleEvent);}//----------------------------------------------------------------------------------////  To set the data of an object, the expected data is passed in its raw form with  ////  the property type in the descriptorType field and the data in the dataHandle.  ////----------------------------------------------------------------------------------//#pragma segment MainpascalOSErr HandleSetData(AppleEvent* theAppleEvent, AppleEvent* reply, long refCon){  #pragma unused (reply,refCon)  AEDesc    target, data, token;  OSErr    err;    MyInitDescs(&amp;target, &amp;data,&amp;token, kEndOfList);    //  First, get the direct object. This is the object whose data is to be set.  if (!(err = AEGetParamDesc(theAppleEvent, keyDirectObject, typeObjectSpecifier, &amp;target)))    if (!(err = AEResolve(&amp;target, kAEIDoMinimum, &amp;token)))    // Resolve it.       if (!(err = AEGetParamDesc(theAppleEvent, keyAEData, typeWildCard, &amp;data)))        err = DoSetData(&amp;token, &amp;data);  MyDisposeDescs(&amp;target, &amp;data, &amp;token, kEndOfList);  return(err);}//----------------------------------------------------------------------------------////  Return a reply to the Get Data or Get Data Size Apple Event for the requested  ////  data. The refcon parameter is used to distinguish the two events. If typeBest  ////  is the requested return type, the data's descriptor type is the result type.  ////  **NOTE: Do not use the same descriptor as source and dest in AECoerceDesc().  ////  This routine creates a copy of the source, and then it is impossible to dispose  ////  of the memory originally contained in the source's dataHandle.          ////  2/25/92 - Removed FailIfErr calls. Now the error is returned as a result.    ////----------------------------------------------------------------------------------//#pragma segment MainpascalOSErr HandleGetData( AppleEvent*  theAppleEvent,           AppleEvent*  reply,           long      refCon  )    // kAEGetData or kAEGetDataSize.{  AEDesc      theObject, token;        // direct object and resolved token.  AEDesc      objectData, tempDesc;      // object data, and coerced data.  DescType    reqType;  WindowPtr    window;  Size      theSize;  OSErr      err;    MyInitDescs(&amp;theObject, &amp;objectData, &amp;token, kEndOfList);      //  First, get the direct objet.  if (err = AEGetParamDesc(theAppleEvent, keyDirectObject, typeObjectSpecifier, &amp;theObject))    goto myExit;      //  Next, get the requested return type, if it exists.  if (err = AEGetParamPtr(theAppleEvent, keyAERequestedType, typeType, &amp;reqType,                (Ptr)&amp;reqType, sizeof(DescType), &amp;theSize))  {    if (err == errAEDescNotFound)    // not an error if return type is not found    {      err = noErr;      reqType = typeWildCard;    }    else      goto myExit;  }  if (err = GetMissingParams(theAppleEvent))      // check for missing params    goto myExit;      //  Resolve the object specifier and get the token containing the property and container.  if (!(err = AEResolve(&amp;theObject, kAEIDoMinimum, &amp;token)))    if (window = (WindowPtr)*(LongPtr)*token.dataHandle)    // Nil for application; WindowPtr for window      err = GetWindowData(token.descriptorType, window, &amp;objectData);    else      err = GetAppData(token.descriptorType, &amp;objectData);  if (err == noErr &amp;&amp; reply-&gt;dataHandle != nil)  {    //  Add data to the reply Apple event record.    if (reqType != typeWildCard &amp;&amp; reqType != typeBest &amp;&amp;      reqType != objectData.descriptorType)    {      err = AECoerceDesc(&amp;objectData, reqType, &amp;tempDesc);      MyDisposeDescs(&amp;objectData, kEndOfList);      objectData.descriptorType = tempDesc.descriptorType;      objectData.dataHandle = tempDesc.dataHandle;    }    if (!err)    {      if (refCon == kAEGetData)        // return data        err = AEPutParamDesc(reply, keyAEResult, &amp;objectData);      else if (refCon == kAEGetDataSize)    // return data size      {        theSize = GetHandleSize(objectData.dataHandle);          err = AEPutParamPtr(reply, keyAEResult, typeLongInteger, (Ptr)&amp;theSize, sizeof(long));      }    }  }  myExit:  MyDisposeDescs(&amp;theObject, &amp;objectData, &amp;token, kEndOfList);  return(err);}//----------------------------------------------------------------------------------////  Send a Move Apple event to myself in response to a user selecting a window    ////  and making it frontmost. This event is sent with the insertion location record  ////  specifying the beginning of the null container. If the index is non-zero, this  ////  indicates that the move event has already been performed by DragWindow(). Thus,  ////  this event is passed with the don't execute flag set.              ////----------------------------------------------------------------------------------//#pragma segment Mainvoid SendMoveEvent(WindowPtr windowToMove, long index){  AppleEvent    myAppleEvent, reply, windowObject;  AERecord    insertionRec;          // Insertion Loc record.  AEDesc      insertionLoc;          // The coerced insertionRec.  DescType    theType;      //  Create the Apple Event.  FailIfErr(AECreateAppleEvent(kAECoreSuite, kAEMove, &amp;gSelfAddress, kAutoGenerateReturnID,                  kAnyTransactionID, &amp;myAppleEvent));    //  Create the object spec for the window to move.  FailIfErr(CreateWindowObjectSpec(windowToMove, kIndexKeyForm, &amp;windowObject));  FailIfErr(AEPutParamDesc(&amp;myAppleEvent, keyDirectObject, &amp;windowObject));    //  Create insertion loc record for beginning of null container.  FailIfErr(AECreateList(nil, 0, true, &amp;insertionRec));      // Create an AE Record.  theType = kAEBeginning;  FailIfErr(AEPutKeyDesc(&amp;insertionRec, keyAEObject, &amp;gNullDesc));  FailIfErr(AEPutKeyPtr(&amp;insertionRec,keyAEPosition,typeEnumeration,(Ptr)&amp;theType,sizeof(DescType)));  FailIfErr(AECoerceDesc(&amp;insertionRec, typeInsertionLoc, &amp;insertionLoc));    // Now add the insertion location descriptor record to the Apple Event.  FailIfErr(AEPutParamDesc(&amp;myAppleEvent, keyAEInsertHere, &amp;insertionLoc));    //  Send the Apple Event.  if (index)      FailIfErr(AESend(&amp;myAppleEvent, &amp;reply, kAENoReply+kAECanInteract+kAEDontExecute,              kAENormalPriority, kAEDefaultTimeout, nil, nil));  else      FailIfErr(AESend(&amp;myAppleEvent, &amp;reply, kAENoReply+kAECanInteract,              kAENormalPriority, kAEDefaultTimeout, nil, nil));    //  Now dispose of the AppleEvent and other records.  MyDisposeDescs(&amp;myAppleEvent,&amp;windowObject,&amp;insertionRec,&amp;insertionLoc,kEndOfList);}//----------------------------------------------------------------------------------////  Respond to the Move Apple Event by reordering the window list.  For CoreSample,  ////  the keyAEInsertHere parameter is optional. If this parameter does not exist,  ////  the specified window will move the  to the front.                ////----------------------------------------------------------------------------------//#pragma segment MainpascalOSErr HandleMove(AppleEvent* theAppleEvent, AppleEvent* reply, long refCon){  #pragma unused (refCon)  AEDesc      object, windowObj, replyObj, insertionLoc;  AERecord    insertionRec;  DescType    theType, position;  WindowPtr    windowToMove, relativeWindow, rplcWindow;  Rect      bounds;  Size      paramSize;  OSErr      err;    MyInitDescs(&amp;object,&amp;windowObj,&amp;insertionLoc,&amp;insertionRec,&amp;replyObj,kEndOfList);    //  First, get the direct parameter, the object to move.  if (err = AEGetParamDesc(theAppleEvent, keyDirectObject, typeObjectSpecifier, &amp;object))    goto myExit;  if (!(windowToMove = ResolveToWindow(&amp;object)))      // Check if valid window object.  {    err = errAENoSuchObject;    goto myExit;  }    // Retrieve the insertion location record, if it exists.  if ((err = AEGetParamDesc(theAppleEvent,keyAEInsertHere,typeInsertionLoc,&amp;insertionLoc)) == errAEDescNotFound)  {      // Execute *MY* default behavior since insertion loc param not present.    SelectWindow(windowToMove);    err = noErr;    goto myExit;  }  else    if (err)      goto myExit;    else      // get data from insertion loc and coerce it to typeAERecord.    {      if ((err = GetMissingParams(theAppleEvent))  ||          (err = AECoerceDesc(&amp;insertionLoc, typeAERecord, &amp;insertionRec)) ||         (err = AEGetKeyDesc(&amp;insertionRec,keyAEObject,typeWildCard,&amp;windowObj)) ||        (err = AEGetKeyPtr(&amp;insertionRec,keyAEPosition,typeEnumeration,&amp;theType,                  (Ptr)&amp;position,sizeof(DescType),&amp;paramSize)))          goto myExit;    }  if (!(err = FindRelativeWindow(&amp;relativeWindow,&amp;windowObj,position,&amp;rplcWindow)))  {    if (position == kAEReplace)      if (windowToMove == rplcWindow)        goto myExit;        // do nothing.      else      {        bounds = DoGetWindowBounds(rplcWindow);        CloseTheWindow(rplcWindow);        MoveWindow(windowToMove, bounds.left, bounds.top, false);      }    if (relativeWindow == (WindowPtr)-1)    // [pwpc]      SelectWindow(windowToMove);    else      if (windowToMove != relativeWindow)        SendBehind(windowToMove, relativeWindow);    // NOTE: may have to call PaintOne and                                // CalcVis if after; see IM I-286    if (position == kAEReplace &amp;&amp; windowToMove != rplcWindow)    {      bounds = DoGetWindowBounds(rplcWindow);      CloseTheWindow(rplcWindow);      MoveWindow(windowToMove, bounds.left, bounds.top, false);    }  }myExit:  if (!err)    if (reply-&gt;dataHandle != nil)    {      CreateWindowObjectSpec(windowToMove, kIndexKeyForm, &amp;replyObj);      err = AEPutParamDesc(reply, keyAEResult, &amp;replyObj);    }  MyDisposeDescs(&amp;object,&amp;windowObj,&amp;insertionLoc,&amp;insertionRec,&amp;replyObj,kEndOfList);  return(err);}//----------------------------------------------------------------------------------////  Set up the descriptor records needed to set the data for the bounds, position,  ////  and zoomed properties.  The bounds is set in response to sizing a window; the  ////  position is set after dragging a window; and the isZoomed property is set when  ////  zooming a window in or out.                            ////----------------------------------------------------------------------------------//#pragma segment Mainvoid SetUpPropertyData( WindowPtr    window,      // Window object.            DescType    propType,    // Property descriptor type.            DescType    dataType,    // Descriptor type for data.            Size      dataSize   )  // Size of data.{  AEDesc    windowObject, theData, theProperty;  Rect    bounds;  Boolean    isZoomed;    MyInitDescs(&amp;windowObject, &amp;theData, &amp;theProperty, kEndOfList);  if (propType == pIsZoomed)  {    isZoomed = (Boolean)GetWRefCon(window);    FailIfErr(AECreateDesc(dataType,(Ptr)&amp;isZoomed,dataSize,&amp;theData));  }  else    // it's either pBounds or pPosition.  {      bounds = DoGetWindowBounds(window);    FailIfErr(AECreateDesc(dataType, (Ptr)&amp;bounds, dataSize, &amp;theData));  }      CreateWindowObjectSpec(window, kIndexKeyForm, &amp;windowObject);  FailIfErr(AECreateDesc(typeType, (Ptr)&amp;propType, sizeof(DescType), &amp;theProperty));  SendSetData(&amp;theProperty, &amp;theData, &amp;windowObject);  MyDisposeDescs(&amp;windowObject, &amp;theData, &amp;theProperty, kEndOfList);}//----------------------------------------------------------------------------------////  Set the property data for the specified object.  For now, we only handle window  ////  objects, and you may only set the modifiable properties (defined in Registry).  ////  *NOTE*:  We do not allow the application's properties to be modified.      ////----------------------------------------------------------------------------------//#pragma segment MainOSErr DoSetData( AEDesc*  token,        // Contains the property and object.         AEDesc*  data  )      // Contains the data to set.{  AEDesc      propData;      // Property data.  Rect      bounds;  GrafPtr      oldPort;  WindowPtr    window, behindWindow;  Str255      name;  long      newIndex;  short      part;  Boolean      value;  Point      pt;  OSErr      err;  err = noErr;  if (window = (WindowPtr)*(LongPtr)*(token-&gt;dataHandle))  {    GetPort(&amp;oldPort);    switch (token-&gt;descriptorType)    {      case pBounds:        if (data-&gt;descriptorType != typeQDRectangle)        {          propData.dataHandle = nil;          err = AECoerceDesc(data, typeQDRectangle, &amp;propData);          bounds = *(Rect *)*propData.dataHandle;    // Get content region.          MyDisposeDescs(&amp;propData, kEndOfList);        }        else          bounds = *(Rect *)*data-&gt;dataHandle;    // Get content region.            if (!err)        {          SetPort(window);          InvalRect(&amp;window-&gt;portRect);                // Real applications may want to make a sanity check on the new bounds.              MoveWindow(window, bounds.left, bounds.top, false);           SizeWindow(window, bounds.right-bounds.left, bounds.bottom-bounds.top, true);          InvalRect(&amp;window-&gt;portRect);        }        break;            case pIndex:        if (DescToLong(data,&amp;newIndex) != noErr)          return(errAECoercionFail);    // Data cannot be coerced.        if (newIndex &gt; gNumWindowsOpen)          err = errAEIndexTooLarge;        else        {          if (newIndex == 1)            SelectWindow(window);          else            if (behindWindow = GetWindowAtIndex(newIndex))              SendBehind(window, behindWindow);            else              err = errAEEventFailed;        }        break;              case pIsZoomed:        if (DescToBoolean(data,&amp;value) != noErr)          return(errAECoercionFail);      // Data cannot be coerced.                  part = value ? inZoomOut : inZoomIn;        ZoomIt(window, part);        break;      case pName:        if (DescToPString(data,name,kMaxStrSize) != noErr)          return(errAECoercionFail);        SetWTitle(window, name);        break;            case pPosition:        if (data-&gt;descriptorType != typeQDPoint)        {          propData.dataHandle = nil;          err = AECoerceDesc(data, typeQDPoint, &amp;propData);          pt = *(Point *)*propData.dataHandle;          MyDisposeDescs(&amp;propData, kEndOfList);        }        else          pt = *(Point *)*data-&gt;dataHandle;        if (!err)        {            // Real applications may want to make a sanity check on the new loc.          SetPort(window);          MoveWindow(window, pt.h, pt.v, false);          InvalRect(&amp;window-&gt;portRect);        }        break;            case pVisible:        if (DescToBoolean(data,&amp;value) != noErr)          return(errAECoercionFail);    // Data cannot be coerced.        if (value)          ShowWindow(window);        else          HideWindow(window);        break;              default:            // No other properties are modifiable.        return(errAENotModifiable);    }    SetPort(oldPort);  }  else    return(errAEEventFailed);  return(err);}//----------------------------------------------------------------------------------////  This is a dummy handler that receives Apple events which I don't handle.  It   ////  is mainly provided as a stub in order to support all the events in the       ////  required suite, as well as the entire core suite.  This is the handler for the  ////  Open Document and Print Document events (required suite); and the Save, Get   ////  Class Info,  and Get Event Info events (core suite).  The Get Class Info and Get  ////  Event Info events &quot;MAY&quot; be supported internally in the future, so applications  ////  will not need to handle these events themselves.  This support may be provided  ////  since it would be consistent across all applications, and the information may  ////  be retrieved from the 'aeut'/'aete' resources.                  ////----------------------------------------------------------------------------------//#pragma segment MainpascalOSErr DummyHandler( AppleEvent    *theAppleEvent,          AppleEvent    *reply,          long      refCon  ){  #pragma unused (theAppleEvent,reply,refCon)  return(errAEEventNotHandled);}//----------------------------------------------------------------------------------////  Locate the window that is relative to the specified window object at the    ////  insertion position.  If the location is replace, the window to replace is     ////  closed, and its bounds are returned to the calling routine.            ////  **Note**: if windowObj is used within this routine, the object param will    ////  contain the same dataHandle. This will be disposed of by the calling routine.  ////----------------------------------------------------------------------------------//#pragma segment MainOSErr FindRelativeWindow( WindowPtr*  relativeWindow,  // window before insertion loc.              AEDesc*    object,      // object to be relative to.              DescType    position,      // insertion position.              WindowPtr*  replaceWindow )  // window to replace.{  AEDesc    windowObj;          // Coerced descriptor.  WindowPtr  windowToReplace;  long    index;  OSErr    err;    err = noErr;  *replaceWindow = nil;  switch(position)  {    case kAEBeginning:            // The object should be the container.      if (object-&gt;descriptorType == typeNull)        *relativeWindow = (WindowPtr)-1;      else        err = errAENoSuchObject;      break;        case kAEEnd:              // The object should be the container.      if (object-&gt;descriptorType == typeNull)        *relativeWindow = nil;      else        err = errAENoSuchObject;      break;          case kAEBefore:              // The object should be an object specifier.    case kAEReplace:      if (object-&gt;descriptorType != typeObjectSpecifier)      {        err = AECoerceDesc(object, typeObjectSpecifier, &amp;windowObj);        MyDisposeDescs(object, kEndOfList);        object-&gt;descriptorType = windowObj.descriptorType;        object-&gt;dataHandle = windowObj.dataHandle;      }            if (!err)        if (windowToReplace = ResolveToWindow(object))        {          index = GetWindowIndexNum(windowToReplace);          *relativeWindow = (index==1) ? (WindowPtr)-1 : GetWindowAtIndex(index-1);          if (position == kAEReplace)            *replaceWindow = windowToReplace;      }      else      // We weren't able to resolve the object specifier to a window.        err = errAENoSuchObject;      break;          case kAEAfter:            // The object should be an object specifier.      if (object-&gt;descriptorType != typeObjectSpecifier)      {        err = AECoerceDesc(object,typeObjectSpecifier,&amp;windowObj);        MyDisposeDescs(object, kEndOfList);        object-&gt;descriptorType = windowObj.descriptorType;        object-&gt;dataHandle = windowObj.dataHandle;      }      if (!err)        if (!(*relativeWindow = ResolveToWindow(object)))          err = errAENoSuchObject;      break;          default:      return(errAEEventNotHandled);  }  return(err);}//----------------------------------------------------------------------------------////  Retrieves the data for the specified property of the window.  The result token  ////  contains the type of the data in the descriptorType field, and the data itself  ////  in the dataHandle field.  I know my application's window properties       ////  (i.e., has title bar, has close box, is zoomable, etc.), so I set up the     ////  result token accordingly.  If your application handles various window types,  ////  you may need to look at the window defproc to determine which type of window it  ////  is.  If the property is pBestType or pDefaultType, I return an object specifier////  for the window which may be used to easily reference it.            ////----------------------------------------------------------------------------------//#pragma segment MainOSErr GetWindowData( DescType    theProperty,    // Window property.           WindowPtr    window,           AEDesc      *result  )      // Contains the result upon return.{  DescType    theType;  Str255      title;  Rect      bounds;  long      index;  Boolean      myAnswer;  switch (theProperty)  {    case pBestType:    case pDefaultType:      return(CreateWindowObjectSpec(window, kIndexKeyForm, result));    case pBounds:        bounds = DoGetWindowBounds(window);      return(AECreateDesc(typeQDRectangle, (Ptr)&amp;bounds, sizeof(Rect), result));          case pClass:      theType = cWindow;      return(AECreateDesc(typeType, (Ptr)&amp;theType, sizeof(DescType), result));    case pIndex:      index = GetWindowIndexNum(window);      return(AECreateDesc(typeLongInteger, (Ptr)&amp;index, sizeof(long), result));            case pName:      GetWTitle(window, title);      return(AECreateDesc(typeChar, (Ptr)&amp;title[1], title[0], result));    case pPosition:        bounds = DoGetWindowBounds(window);      return(AECreateDesc(typeQDPoint, (Ptr)&amp;bounds, sizeof(Point), result));    case pHasCloseBox:    case pHasTitleBar:    case pIsResizable:    case pIsZoomable:      myAnswer = true;      return(AECreateDesc(typeBoolean, (Ptr)&amp;myAnswer, sizeof(Boolean), result));    case pIsFloating:    case pIsModal:      myAnswer = false;      return(AECreateDesc(typeBoolean, (Ptr)&amp;myAnswer, sizeof(Boolean), result));          case pIsZoomed:      myAnswer = GetWRefCon(window);      return(AECreateDesc(typeBoolean, (Ptr)&amp;myAnswer, sizeof(Boolean), result));        case pVisible:          // Must check this because it is modifiable.      myAnswer = ((WindowPeek)window)-&gt;visible;      return(AECreateDesc(typeBoolean, (Ptr)&amp;myAnswer, sizeof(Boolean), result));    case pSelection:        // No selection in CoreSample.      return(errAENoSuchObject);    default:            // We don't handle requested property.      return(errAEEventNotHandled);  }}//----------------------------------------------------------------------------------////  Get the property data for the application and return it in the result parameter.////  The result token contains the property type in the descriptorType field, and    ////  a nil value in the dataHandle field to represent the null application.      ////----------------------------------------------------------------------------------//#pragma segment MainOSErr GetAppData(  DescType  theProperty,          AEDesc*    result  )    // Descriptor record to hold the property data.{  ProcessInfoRec      myProcessInfo;    // [pwpc]  DescType        theType;  short          refNum;  Str255          name;  Handle          myHandle;  ProcessSerialNumber    thePSN, currentProcess;  Boolean          isFront;  OSErr          err;  switch (theProperty)  {    case pBestType:          // Return the null descriptor representing    case pDefaultType:        // the application.      return(AEDuplicateDesc(&amp;gNullDesc, result));    case pClass:      theType = cApplication;      return(AECreateDesc(typeType,(Ptr)&amp;theType,sizeof(DescType),result));          case pName:      // [pwpc] Clear out the name, and then call the process manager to get      // the string for the name of our application.            name[0] = 0;      myProcessInfo.processInfoLength = sizeof(myProcessInfo);       myProcessInfo.processName = name;      myProcessInfo.processAppSpec = NULL;            GetCurrentProcess(&amp;currentProcess);      GetProcessInformation(&amp;currentProcess, &amp;myProcessInfo);          // Create an AEDesc returning the application name string      // returned by the process manager.      return(AECreateDesc(typeChar, (Ptr)&amp;name[1], name[0], result));    case pIsFrontProcess:      GetFrontProcess(&amp;thePSN);      SameProcess(&amp;gSelfPSN, &amp;thePSN, &amp;isFront);      return(AECreateDesc(typeBoolean,(Ptr)&amp;isFront,sizeof(Boolean),result));          case pVersion:      refNum = CurResFile();      // save current resource      UseResFile(gRefNum);      // set this resource to be current      myHandle = (Handle)Get1Resource((ResType)'vers', 1);        HLock(myHandle);       err = AECreateDesc(typeVersion, *myHandle, GetHandleSize(myHandle), result);        HUnlock(myHandle);      UseResFile(refNum);        // reset back to resource previously set      return(err);    default:        // We don't handle the requested property.      return(errAEEventNotHandled);  }}//----------------------------------------------------------------------------------////  Create an object specifier for the window with the indicated key form.      ////----------------------------------------------------------------------------------//#pragma segment MainOSErr CreateWindowObjectSpec( WindowPtr  window,                short    keyForm,    // index or name key form.                  AEDesc*  objectSpec )  // Resulting object specifier.{  AEDesc    data;  Str255    title;  long    index;  OSErr    err;  MyInitDescs(&amp;data, kEndOfList);  switch(keyForm)  {    case kNameKeyForm:          // Object specifier with name.      GetWTitle(window, title);      if (!(err = AECreateDesc(typeChar, (Ptr)&amp;title[1], title[0], &amp;data)))                err = CreateObjSpecifier(cWindow, &amp;gNullDesc, formName, &amp;data,                  false, objectSpec);      break;          case kIndexKeyForm:          // Object specifier with index.      index = GetWindowIndexNum(window);      if (!(err = CreateOffsetDescriptor(index, &amp;data)))        err = CreateObjSpecifier(cWindow, &amp;gNullDesc, formAbsolutePosition, &amp;data,                  false, objectSpec);      break;  }  MyDisposeDescs(&amp;data, kEndOfList);  return(err);}//----------------------------------------------------------------------------------////  Check to see if there exists any additional parameters in the Apple Event.    ////  If so, return an error to the calling routine.                  ////----------------------------------------------------------------------------------//#pragma segment MainOSErr GetMissingParams(AppleEvent*  theAppleEvent){  DescType  theType;  Size    actualSize;  OSErr    err;    err = AEGetAttributePtr(theAppleEvent, keyMissedKeywordAttr, typeWildCard,                &amp;theType, nil, 0, &amp;actualSize);  if (err == errAEDescNotFound)    return(noErr);  else    return(errAEEventNotHandled);}//----------------------------------------------------------------------------------////  If a reply is expected, the error number is returned in the reply parameter.  ////----------------------------------------------------------------------------------//#pragma segment Mainvoid ReportError( AppleEvent*  reply,          long      err  ){  if (reply-&gt;dataHandle != nil &amp;&amp; err != noErr)    FailIfErr(AEPutParamPtr(reply,keyErrorNumber,typeLongInteger,(Ptr)&amp;err,sizeof(long)));}//----------------------------------------------------------------------------------////  This routine returns the window object contained in the given object specifier.  ////  If the resolution does not return a descriptor record of type cWindow, nil is   ////  returned as a result.                              ////----------------------------------------------------------------------------------//#pragma segment MainWindowPtr ResolveToWindow(AEDesc*  objectSpecifier){  AEDesc    token;  WindowPtr  window;  MyInitDescs(&amp;token, kEndOfList);  window = nil;  if (objectSpecifier-&gt;descriptorType == typeObjectSpecifier)    if (!(AEResolve(objectSpecifier, kAEIDoMinimum, &amp;token)))      if (token.descriptorType == cWindow)        window = (WindowPtr)*((LongPtr)*(token.dataHandle));  MyDisposeDescs(&amp;token, kEndOfList);  return(window);}//----------------------------------------------------------------------------------////  Retrieve the window from the null container by the key form and return its    ////  pointer in the dataHandle field of resultToken.                  ////----------------------------------------------------------------------------------//#pragma segment MainpascalOSErr WindowAccessor( DescType    classWanted,    // window class            AEDesc*    container,      // the application (null container)            DescType    containerClass,             DescType    keyform,              AEDesc*    selectionData,            AEDesc*    resultToken,    // specified window is returned in result            long       theRefCon   ){  #pragma unused (classWanted,container,containerClass,theRefCon)  WindowPtr    window;  DescType    seldataType;  Str255      title;  long      index;  OSErr      err;  window = nil;  err = noErr;    if (!gNumWindowsOpen)    return(errAENoSuchObject);  else  {    seldataType = selectionData-&gt;descriptorType;      switch(keyform)    {      case formName:                  // Window title.        if (DescToPString(selectionData,title,kMaxStrSize) != noErr)          return(errAECoercionFail);        if (!(window = GetWindowWithTitle(title)))          return(errAENoSuchObject);    // Window was not found.        break;            case formAbsolutePosition:        if (DescToLong(selectionData,&amp;index) != noErr)          return(errAECoercionFail);    // Data cannot be coerced.        if (!(window = GetWindowAtIndex(index)))          return(errAENoSuchObject);      // Window was not found.        break;              default:                  // I don't handle any other key forms.        return(errAEEventNotHandled);    }  }  return(AECreateDesc(cWindow, (Ptr)&amp;window, sizeof(Ptr), resultToken));}//----------------------------------------------------------------------------------////  Return a token representing the property for the containing window.  The token  ////  is returned with the property and window pointer.                ////----------------------------------------------------------------------------------//#pragma segment MainpascalOSErr WindowPropertyAccessor( DescType    classWanted,    // Property class                  AEDesc*    container,      // Window object                DescType    containerClass,                 DescType    form,                AEDesc*    selectionData,                AEDesc*    resultToken,                long       theRefCon   ){  #pragma unused (containerClass, theRefCon)  Ptr        window;  DescType    propType;        //  Let's make sure we're accessing a valid descriptor type.  if ((classWanted != cProperty) || (form != formPropertyID))    return(errAEWrongDataType);  window = (Ptr)*(LongPtr)*(container-&gt;dataHandle);    // Get the window pointer.  propType = *(LongPtr)*selectionData-&gt;dataHandle;    // Get the property type.  return(AECreateDesc(propType, (Ptr)&amp;window, sizeof(Ptr), resultToken)); }//----------------------------------------------------------------------------------////  Return a token that contains the property type and nil to represent the null  ////  container (the application).                          ////----------------------------------------------------------------------------------//#pragma segment MainpascalOSErr AppPropertyAccessor(  DescType    classWanted,      // Property class.                AEDesc*      container,        // Application.              DescType    containerClass,               DescType    form,              AEDesc*      selectionData,              AEDesc*      resultToken,              long       theRefCon   ){    #pragma unused (container,containerClass,theRefCon)  DescType    propType;  long      nilValue;        //  Let's make sure we're accessing a valid descriptor type.  if ((classWanted != cProperty) || (form != formPropertyID))    return(errAEWrongDataType);  nilValue = nil;      propType = *(LongPtr)*selectionData-&gt;dataHandle;      // Get the property type.  return(AECreateDesc(propType, (Ptr)&amp;nilValue, sizeof(long), resultToken)); }//----------------------------------------------------------------------------------////  Returns the window with the given title if found.  Otherwise, nil is returned.  ////  Use WindowList in order to find windows that may be invisible.          ////----------------------------------------------------------------------------------//#pragma segment MainWindowPtr GetWindowWithTitle( ConstStr255Param  titleToFind ){  WindowPeek  window;  Str255    thisTitle;  #ifdef  THINK_C  window = (WindowPeek)LMGetWindowList();  // WindowList finds invisible windows as well.#else  window = *(PeekPtr)LMGetWindowList();    // WindowList finds invisible windows as well.#endif    while (window)  {    GetWTitle((WindowPtr)window, thisTitle);    if (EqualString(thisTitle, titleToFind, false, false))      return((WindowPtr)window);    window = window-&gt;nextWindow;  }  return(nil);}//----------------------------------------------------------------------------------////  Search all windows (including invisible), and return the window at the given   ////  index if found. Otherwise, nil is returned. This routine also handles negative  ////  indices which indicates that the offset  is from the end of the container.    //                  ////----------------------------------------------------------------------------------//#pragma segment MainWindowPtr GetWindowAtIndex(long  index){  WindowPeek  window;  short    count;    index = index &lt; 0 ? gNumWindowsOpen+index+1 : index;  count = 1;  #ifdef  THINK_C  window = (WindowPeek)LMGetWindowList();  // WindowList finds invisible windows as well.#else  window = *(PeekPtr)LMGetWindowList();    // WindowList finds invisible windows as well.#endif  while (window)  {    if (count == index)      return((WindowPtr)window);    window = window-&gt;nextWindow;    count++;  }  return(nil);}//----------------------------------------------------------------------------------////  Returns the index number of the given window, where 1 is the frontmost.      ////----------------------------------------------------------------------------------//#pragma segment Mainlong GetWindowIndexNum(WindowPtr myWindow){  WindowPeek  thisWindow;  long    index;  #ifdef  THINK_C  thisWindow = (WindowPeek)LMGetWindowList();    // Compilers are so much fun!!.#else  thisWindow = *(PeekPtr)LMGetWindowList();      // WindowList finds invisible windows as well.#endif  index = 1;    while (thisWindow)  {    if (thisWindow == (WindowPeek)myWindow)    // [pwpc]      return(index);    thisWindow = thisWindow-&gt;nextWindow;    index++;  }  return(nil);}//----------------------------------------------------------------------------------////  This routine returns the bounds of a given window. Special calculations are    ////  performed when the bounds is invalid (i.e., the window is hidden).        ////----------------------------------------------------------------------------------//#pragma segment MainRect DoGetWindowBounds(WindowPtr window){  Rect  portRect, bitMapRect, bounds;    bounds = (*((WindowPeek)window)-&gt;contRgn)-&gt;rgnBBox;    // check the content region.  if (bounds.top == 0 &amp;&amp; bounds.left == 0 &amp;&amp;    bounds.bottom == 0 &amp;&amp; bounds.right == 0)  {    portRect = window-&gt;portRect;    bitMapRect = window-&gt;portBits.bounds;        bounds.top =  portRect.top - bitMapRect.top;    bounds.left = portRect.left - bitMapRect.left;    bounds.bottom = portRect.bottom - bitMapRect.top;    bounds.right = portRect.right - bitMapRect.left;  }  return(bounds);}//----------------------------------------------------------------------------------//#pragma  segment Initializevoid InitAEHandlers(){  AEInstallEventHandler(kCoreEventClass,kAEOpenApplication,NewAEEventHandlerProc(HandleOpenApp), nil,false);  AEInstallEventHandler(kCoreEventClass,kAEOpenDocuments,NewAEEventHandlerProc(DummyHandler), nil,false);  AEInstallEventHandler(kCoreEventClass,kAEPrintDocuments,NewAEEventHandlerProc(DummyHandler), nil,false);  AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, NewAEEventHandlerProc(HandleQuitApp), nil, false);  AEInstallEventHandler(kAECoreSuite, kAEClone, NewAEEventHandlerProc(HandleClone), nil, false);  AEInstallEventHandler(kAECoreSuite, kAEClose, NewAEEventHandlerProc(HandleClose), nil, false);  AEInstallEventHandler(kAECoreSuite, kAECountElements, NewAEEventHandlerProc(HandleCountElements), nil, false);  AEInstallEventHandler(kAECoreSuite, kAECreateElement, NewAEEventHandlerProc(HandleCreateElement), nil, false);  AEInstallEventHandler(kAECoreSuite, kAEDelete, NewAEEventHandlerProc(HandleClose), nil, false);  AEInstallEventHandler(kAECoreSuite, kAEDoObjectsExist, NewAEEventHandlerProc(HandleDoObjectsExist), nil, false);  AEInstallEventHandler(kAECoreSuite, kAEGetData, NewAEEventHandlerProc(HandleGetData), kAEGetData, false);  AEInstallEventHandler(kAECoreSuite, kAEGetDataSize, NewAEEventHandlerProc(HandleGetData), kAEGetDataSize, false);  AEInstallEventHandler(kAECoreSuite, kAEGetClassInfo, NewAEEventHandlerProc(DummyHandler), nil, false);  AEInstallEventHandler(kAECoreSuite, kAEGetEventInfo, NewAEEventHandlerProc(DummyHandler), nil, false);  AEInstallEventHandler(kAECoreSuite, kAEMove, NewAEEventHandlerProc(HandleMove), nil, false);  AEInstallEventHandler(kAECoreSuite, kAESave, NewAEEventHandlerProc(DummyHandler), nil, false);  AEInstallEventHandler(kAECoreSuite, kAESetData, NewAEEventHandlerProc(HandleSetData), nil, false);  AEObjectInit();  AEInstallObjectAccessor(cWindow, typeNull, NewOSLAccessorProc(WindowAccessor), nil, false);  AEInstallObjectAccessor(cProperty, typeNull, NewOSLAccessorProc(AppPropertyAccessor), nil, false);  AEInstallObjectAccessor(cProperty, cWindow, NewOSLAccessorProc(WindowPropertyAccessor), nil, false);}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/CoreSample/listing1.html%3Fid%3DDTS10000663-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/CoreSample/listing1.html%3Fid%3DDTS10000663-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/CoreSample/listing1.html%3Fid%3DDTS10000663-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>