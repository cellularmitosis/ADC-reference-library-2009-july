/* * file: Instrument Editor.c * * started 22 March 1992 * david van brink * */  /*--------------------------	Inclusions--------------------------*/#include <Memory.h>#include <QuickDraw.h>#include <Windows.h>#include <Dialogs.h>#include <OSUtils.h>#include <Errors.h>#include <Resources.h>#include <Timer.h>//#include <MIDI.h>#include "BigEasy2.h"#include "BigEasyGrafish.h"#include "BigEasyTextish.h"#include "BigEasyControls.h"#include "BigEasyDialogs.h"#include "BigEasyUtils.h"#include "Instrument Editor Controls.h"#include "IE PrintUtilities.h"#define globals#include "More IE Routines.h"#include "Instrument Editor.h"#include "Instrument Editor Filing.h"#include "Instrument Editor Menus.h"/*--------------------------	Limits and Konstants--------------------------*/#define SignIt(x) ( (x)?1:-1)/*--------------------------	Prototypes--------------------------*/static void OpenAWindow(void);static void KeyDoc(short n,short key,short code,short mods);static short CloseDoc(short n);static void ActivateDoc(short n);static void DeactivateDoc(short n);static void IdleDoc(short n,Boolean front);static void LetsQuit(short n,short menuItem,short menuRef);static void NameInstrumentDoc(short n, short menuItem, short menuRef);static void RandomizeKnobsDoc(short n, short menuItem, short menuRef);static void ShowCPULoad(short n, short menuItem, short menuRef);static void GetInstrumentDoc(short n, short menuItem, short menuRef);static void GetROMInstrumentsDoc(short n, short menuItem, short menuRef);static void InitVars(void);static void InstrumentSliderValueDrawProc(EasyControl ec);static void MoveDoc(short n);static void AddToList(TDoc *d, InstrumentDataHandle iH);Boolean CheckBit(unsigned long *t, long bit);static void About(void);static void SliderValueProc(EasyControl ec);pascal ComponentResult EditorMusicReadHook(MusicMIDIPacket *mp, long refCon);static void OpenSomeSynth(short n, short item,short ref);static pascal void JunkTask(void);static long GetCPUTime(void);static unsigned long gUnloadedCPUTime;/*--------------------------	More bits--------------------------*/static tSliderStyle aSliderStyle =	{	longNum,	kSliderWidth,13,	kSliderWidth,13,	InstrumentSliderValueDrawProc	};static unsigned long gCPUUnloadedTime;/*--------------------------	Computer Programs--------------------------*/void SliderValueProc(EasyControl ec)	{	long value;	long id;	TDoc *d;	d = (void *)GetEasyControlRefcon(ec);	value = GetEasyControlValue(ec);	id = GetEasyControlID(ec);	if(d->whichList == mInstrumentKnobs)		NASetKnob(d->na,d->nc,id + 1,value);	else if(d->whichList == mControllers)		NASetController(d->na,d->nc,id,value);	else		MusicSetKnob(d->ci,id + 1,value);	}void KeyDoc(short n,short key,short code,short mods)	{	Boolean x;	Rect r;	TDoc *d;	ComponentResult result;	long xBump,yBump,scale;	controlClickResult ccr;	d = &gDoc[n - kFirstDocWindow];	SetupSliderClipDoc(d);	KeyEasyControlList(d->ecl,key,mods,&ccr);	DoneSliderClipDoc(d);	switch(key)		{		case 31: //down arrow			xBump = 0;			yBump = 1;fly:			if(mods & optionKey)				{				if(mods & cmdKey)					scale = 32000;				else					scale = 40;				xBump *= scale;				yBump *= scale;				SetCtlValue(d->horizontalScroller,GetCtlValue(d->horizontalScroller) + xBump);				SetCtlValue(d->verticalScroller,GetCtlValue(d->verticalScroller) + yBump);				NewScrollDoc(d,true,nil);				}			break;		case 30: //up arrow			xBump = 0;			yBump = -1;			goto fly;		case 29: //right arrow			xBump = 1;			yBump = 0;			goto fly;		case 28: //left arrow			xBump = -1;			yBump = 0;			goto fly;		case '[':			x = EasyDialogGetNumber("\pStore Instrument",					"\pStore instrument in which instrument number:",					&d->stashInstrument);			if(x)				{				GoWatch();				result = MusicStoreInstrument(d->ci,d->part,d->stashInstrument);				FlashResult(result);				GoArrow();				}			break;		case ']':				{				ToneDescription td;				ComponentResult result;				td.synthesizerType = d->sd.synthesizerType;				td.instrumentNumber = d->recallInstrument;				td.gmNumber = 0;				if(d->sd.flags & (kSynthesizerGM | kSynthesizerGMSuperset))					if(td.instrumentNumber <= 128)						td.gmNumber = td.instrumentNumber;				td.synthesizerName[0] = 0;				td.instrumentName[0] = 0;				result = NAPickInstrument(d->na,nil,"\pPick An Instrument:",&td,						3,0,0,0);				if(!result)					{					x = true;					MusicFindTone(d->ci,&td,&d->recallInstrument,nil);					result = MusicSetInstrumentNumber(d->ci,d->part,d->recallInstrument);					FlashResult(result);					result = MusicGetPartName(d->ci,d->part,d->instrumentName);					FlashResult(result);					UpdateSliderKnobs(d);					DrawStats(d);					}				}			break;		case '=':		case '+':			d->recallInstrument = d->recallInstrument % d->sd.modifiableInstrumentCount + 1;		getNewOne:			result = MusicSetInstrumentNumber(d->ci,d->part,d->recallInstrument);			FlashResult(result);			result = MusicGetPartName(d->ci,d->part,d->instrumentName);			FlashResult(result);			DrawStats(d);			UpdateSliderKnobs(d);			break;		case '-':		case '_':			d->recallInstrument = (d->recallInstrument + d->sd.modifiableInstrumentCount - 2)					% d->sd.modifiableInstrumentCount + 1;			goto getNewOne;		}	}short CloseDoc(short n)/* * Close that window... */	{	short x;	TDoc *d;	Boolean cancelClose;	d = &gDoc[n - kFirstDocWindow];	if(d->used && d->changed)		{		x = EasyDialogMessage(0,d->docSpec.name,"\pSave changes before closing this document?",				kEasyDialogSaveDiscardCancel);		if(x == 2)			cancelClose = true;		else if(x == 0)			cancelClose = SaveDoc(n,0,0);		else			cancelClose = false;		}	else		cancelClose = false;	if(!cancelClose)		{		UninstallWindow(n);		CloseComponent(d->na);		DisposeEasyControlList(d->ecl);		d->ecl = 0;		d->used = false;		gDocCount--;		}	return cancelClose;	}void FixUpMenus(TDoc *d)	/*	 * Make menus suitable for document d,	 * where d=nil means deactivate	 */	{	short moreDocs;	moreDocs = SignIt(gDocCount<kDocMax);	SetMenuItem(mNew,moreDocs,0,0,nil);	SetMenuItem(mOpen,moreDocs,0,0,nil);	if(d)		{		Point c;		SetMenuItemRange(mFirstDocOnly,mLastDocOnly,1,0);		SetMenuItem(d->whichList,0,1,'¥',0);		SetMenuItem(mSave,SignIt(d->changed || d->littleChanged),0,0,nil);		c.h = c.v = 0;		if(!LGetSelect(true,&c,d->listH))			SetMenuItem(mSetInstrument,-1,0,0,0);		}	else		SetMenuItemRange(mFirstDocOnly,mLastDocOnly,-1,0);	}void ActivateDoc(short n)	{	TDoc *d;	ComponentResult thisError;	d = &gDoc[n - kFirstDocWindow];	FixUpMenus(d);	if(d->listH)		LActivate(true,d->listH);	if(d->horizontalScroller)		{		HiliteControl(d->horizontalScroller,0);		HiliteControl(d->verticalScroller,0);		}	thisError = NAUseDefaultMIDIInput(d->na,EditorMusicReadHook,(long)d,0);	}void DeactivateDoc(short n)	{	TDoc *d;	ComponentResult thisError;	d = &gDoc[n - kFirstDocWindow];	FixUpMenus(0);	if(d->listH)	LActivate(false,d->listH);	if(d->horizontalScroller)		{		HiliteControl(d->horizontalScroller,254);		HiliteControl(d->verticalScroller,254);		}	thisError = NALoseDefaultMIDIInput(d->na);	FlashResult(thisError);	thisError = NAResetNoteChannel(d->na,d->nc);	FlashResult(thisError);	d->controllersDirty = true;	}void IdleDoc(short n,Boolean front)	{	TDoc *d;	ComponentResult thisError;	d = &gDoc[n - kFirstDocWindow];	PaintKeyboardVector(&d->kd,d->keyVel);	if(d->whichList == mControllers			&& d->controllersDirty)		UpdateSliderKnobs(d);	SetupSliderClipDoc(d);	IdleEasyControlList(d->ecl);	DoneSliderClipDoc(d);		{		Point p;		short mods;		GetMouse(&p);		mods = GetModKeys();		if(PtInRect(p,&d->visibleSliderBounds) && (mods & optionKey))			GoCursor(128);		else			GoArrow();		}	}typedef struct	{	short number;	Str31 name;	} XX;XX dControllerNames[] =	{	kControllerModulationWheel,"\pMod",	kControllerBreath,"\pBreath",	kControllerFoot,"\pFoot",	kControllerPortamentoTime,"\pPortamento Time",	kControllerVolume,"\pVolume",	kControllerBalance,"\pBalance",	kControllerPan,"\pPan",	kControllerExpression,"\pExpression",	kControllerPitchBend,"\pPitch Bend",	kControllerAfterTouch,"\pAfter Touch",	kControllerSustain,"\pSustain",	kControllerPortamento,"\pPortamento",	kControllerSostenuto,"\pSostenuto",	kControllerSoftPedal,"\pSoft Pedal",	91,"\pReverb",	kControllerTremolo,"\pTremolo",	kControllerChorus,"\pChorus",	kControllerCeleste,"\pCeleste",	kControllerPhaser,"\pPhaser",	-1,"\p"	};void InstrumentSliderValueDrawProc(EasyControl ec)	{	long x;	TDoc *d;	short i;	x = GetEasyControlValue(ec);	d = (void *)GetEasyControlRefcon(ec);	for(i = 0; i<d->knobCount; i++)		{		if(ec == d->ec[i])			{			if(d->whichList == mInstrumentKnobs)				DrawString( (*(d->ikdList))[i].name);			else if(d->whichList == mGlobalKnobs)				DrawString( (*(d->gkdList))[i].name);			else				{				short j;				short id;				id = GetEasyControlID(ec);				j = 0;				while(1)					{					if(dControllerNames[j].number == id)						{						DrawString(dControllerNames[j].name);						goto gotIt;						}					else if(dControllerNames[j].number < 0)						goto missedIt;					j++;					}				missedIt:					DrawString("\pController ");					DrawNum(id);				gotIt:;				}			DrawString("\p: ");			}		}	if(x == 0x7FFFffff)		DrawString("\p----");	else		DrawNum(x);	}static short dMyColors[6] =	{	0,	PackColor555(60000,60000,60000),	PackColor555(10000,10000,10000),	PackColor555(24000,0,0),	0,	0	};void LetsQuit(short n,short menuItem,short menuRef)	{	short i;	#pragma unused (n,menuItem,menuRef)	for(i = 0; i < kDocMax; i++)		if(gDoc[i].used)			CloseDoc(i + kFirstDocWindow);	gQuitApp++;	}void NameInstrumentDoc(short n, short menuItem, short menuRef)	{	DialogPtr dp;	short hit;	short itemType;	Rect itemRect;	Handle itemHandle;	TDoc *d;	Boolean x;	ComponentResult result;	d = &gDoc[n - kFirstDocWindow];	x = EasyDialogGetString("\pInstrument Name","\pNew Name:",d->instrumentName,31);	if(x)		{		DrawStats(d);		result = MusicSetPartName(d->ci,d->part,d->instrumentName);		FlashResult(result);		}	}void RandomizeKnobsDoc(short n, short menuItem, short menuRef)	{	TDoc *d;	ComponentResult result;	short i;	long x;	long dummy;	KnobDescription *kd;	d = &gDoc[n - kFirstDocWindow];	for(i = 0; i < d->knobCount; i++)		{		if(Random() % 6 == 0)			{	result = 0;	#if 1			kd = &(*d->ikdList)[i];			x = kd->lowValue +					((unsigned long)Random())%(kd->highValue					- kd->lowValue + 1);			result = MusicSetPartKnob(d->ci,d->part,i+1,x);	#endif			if(result)				{				FlashResult(result);				goto goHome;				}			Delay(5,&dummy);			}		}goHome:	UpdateSliderKnobs(d);	}static void AddToList(TDoc *d, InstrumentDataHandle iH)/* * Adds an instrument to the list. Assume ownership of this handle. */	{	InstrumentData *id;	ComponentResult thisError;	if(!iH)		goto goHome;	HLock((Handle)iH);	id = *iH;	GoBW();	TextFont(3);	TextSize(9);	TextFace(0);		{		Point a;		long sizz;		a.h = 0;		a.v = LAddRow(1,-1,d->listH);		LSetCell(&(id->tone.instrumentName[1]),id->tone.instrumentName[0],				a,d->listH);		if(d->instrument[d->instrumentCount])			DisposeHandle((Handle)d->instrument[d->instrumentCount]);		d->instrument[d->instrumentCount] = iH;		d->instrumentCount++;		}	d->changed = true;	FixUpMenus(d);goHome:;	}void SetInstrumentForDoc(TDoc *d,InstrumentDataHandle iH)	{	ComponentResult result;	GoWatch();	result = MusicSetInstrument(d->ci,d->part,iH);	GoArrow();	FlashResult(result);	result = MusicGetPartName(d->ci,d->part,d->instrumentName);	FlashResult(result);	DrawStats(d);	UpdateSliderKnobs(d);	}void SetInstrumentDoc(short n, short menuItem, short menuRef)	{	TDoc *d;	Cell c;	ComponentResult result;	d = &gDoc[n - kFirstDocWindow];	c.h = c.v = 0;	if(!LGetSelect(true,&c,d->listH))		goto goHome;	SetInstrumentForDoc(d,d->instrument[c.v]);goHome:;	}void GetInstrumentDoc(short n, short menuItem, short menuRef)	{	TDoc *d;	InstrumentDataHandle iH;	ComponentResult thisError;	d = &gDoc[n - kFirstDocWindow];	GoWatch();	thisError = MusicGetInstrument(d->ci,d->part,&iH);	GoArrow();	FlashResult(thisError);	if(thisError)		goto goHome;	AddToList(d,iH);goHome:;	}void ShowCPULoad(short n, short menuItem, short menuRef)	{	Str255 s;	Str63 nu;	long x;	CopyPString(s,"\pOriginal time = ");	AnyBaseToPString(gUnloadedCPUTime,10,0,nu);	ConcatenatePStrings(s,nu);	ConcatenatePStrings(s,"\p, Loaded time = ");	x = GetCPUTime();	AnyBaseToPString(x,10,0,nu);	ConcatenatePStrings(s,nu);	ConcatenatePStrings(s,"\p. Percentage of CPU speed gone = ");	x = 100 - gUnloadedCPUTime * 100L / x;	AnyBaseToPString(x,10,0,nu);	ConcatenatePStrings(s,nu);	ConcatenatePStrings(s,"\p.");	EasyDialogMessage(1,"\pCPU Loading",			s,kEasyDialogOkay);	}void UpdateSliderKnobs(TDoc *d)/* * Requery the music component for all * the knob/slider values */	{	long x;	short i;	EasyControl ec;	long id;	SetupSliderClipDoc(d);	for(i = 0; i < d->knobCount; i++)		{		ec = d->ec[i];		id = GetEasyControlID(ec);		if(d->whichList == mInstrumentKnobs)			x = MusicGetPartKnob(d->ci,d->part,id+1);		else if(d->whichList == mControllers)			x = MusicGetController(d->ci,d->part,id);		else			x = MusicGetKnob(d->ci,id+1);		FlashResult(x);		if((x & 0xFFFF0000) == 0x80000000)			goto goHome;		TextFont(3);		TextSize(9);		SetEasyControlValue(ec,x);		}goHome:	d->controllersDirty = false;	DoneSliderClipDoc(d);	}void MoveDoc(short n)	{	register TDoc *d;	d = &gDoc[n - kFirstDocWindow];	d->littleChanged = true;	}void NewDocFromSaveRecord(short docNumber,TSaveRecord *sr,SynthMenuEntry *sme)	{	register TDoc *d;	Rect r,windowRect;	Rect allControls;	ComponentResult result;	short i,j;	EasyControl ec;	KnobDescription *kd;	SynthMenuEntry smell;	if(!sme)		{		if(sr)			{			smell.synthType = sr->sr.synthType;			BlockMove(sr->sr.synthName,smell.synthName,32);			}		else			{			smell.synthType = 0;			smell.synthName[0] = 0;			}		sme = &smell;		}	d = &gDoc[docNumber];#if 0		{		char *w;		short i;		/*		 * Clear the document to zeros		 */		i = sizeof(TDoc);		w = (void *)d;		while(i--)			*w++ = 0;		}#endif	d->changed = false;	for(i = 0; i < kMaxInstruments; i++)		d->instrument[i] = 0;	d->na = OpenDefaultComponent('nota',0);	if(sr)		{		gStaggerWindows = false;		windowRect = sr->windowRect;		d->everSaved = true;		d->sr = sr->sr;		d->littleChanged = false;		}	else		{		gStaggerWindows = true;		gStagStepX = 3;		gStagStepY = 2;		SetRect(&windowRect,10,30,625,460);		CopyPString(d->docSpec.name,"\pUntitled");		d->everSaved = false;		d->littleChanged = true;		}	d->w = InstallWindow(-(docNumber + kFirstDocWindow),d->docSpec.name,&windowRect,0,1,			DrawDoc,ClickDoc,KeyDoc,(void *)CloseDoc,			ActivateDoc,DeactivateDoc,IdleDoc);	SetWindowMoveProc(docNumber + kFirstDocWindow,MoveDoc);	SetWindowResizeProc(docNumber + kFirstDocWindow,ResizeDoc);		{		NoteRequest nr;		long index;		OSType synthType;			nr.polyphony = 2;		nr.typicalPolyphony = 0x00010000;		result = NAStuffToneDescription(d->na,1,&nr.tone);		BlockMove(sme->synthName,nr.tone.synthesizerName,32);		nr.tone.synthesizerType = sme->synthType;		result = NANewNoteChannel(d->na,&nr,&d->nc);		FlashResult(result);		result = NAGetNoteChannelInfo(d->na,d->nc,&index,&d->part);		FlashResult(result);		result = NAGetRegisteredMusicDevice(d->na,index,&synthType,nil,nil,&d->ci);		FlashResult(result);		if(synthType != sme->synthType) //!!! note that this is in error, somehow			{			SysBeep(1);			SysBeep(1);			SysBeep(1);			}		d->sr.synthType = sme->synthType;		BlockMove(sme->synthName,d->sr.synthName,32);		}		/* * Since FlashResult will process the * update for the window, we have to * make harmless the update process. */	d->used = true;	d->ecl = NewEasyControlList(d->w,0);	result = MusicGetDescription(d->ci,&d->sd);	FlashResult(result);	d->instrumentKnobCount = MusicGetInstrumentKnobDescription(d->ci,0,nil);		{		KnobDescription *kd;		short i;		d->ikdList = (KnobDescription **)NewHandle(sizeof(KnobDescription) * d->instrumentKnobCount);		HLock((Handle)d->ikdList);		kd = *d->ikdList;		for(i = 0; i < d->instrumentKnobCount; i++)			result = MusicGetInstrumentKnobDescription(d->ci,i+1,kd+i);		}	d->globalKnobCount = MusicGetKnobDescription(d->ci,0,nil);		{		KnobDescription *kd;		short i;		d->gkdList = (KnobDescription **)NewHandle(sizeof(KnobDescription) * d->globalKnobCount);		HLock((Handle)d->gkdList);		kd = *d->gkdList;		for(i = 0; i < d->globalKnobCount; i++)			result = MusicGetKnobDescription(d->ci,i+1,kd+i);		}	d->controllerCount = 0;		{		short i;		for(i = 1; i <= 128; i++)			if(CheckBit(d->sd.controllers,i))				d->controllerCount++;		}	d->whichList = mInstrumentKnobs;	d->knobCount = d->instrumentKnobCount;		{		ToneDescription td;		long instrumentNumber;		td.synthesizerType = 0;		td.synthesizerName[0] = 0;		td.instrumentName[0] = 0;		td.instrumentNumber = 0;		td.gmNumber = 1;		result = MusicFindTone(d->ci, &td, &instrumentNumber, nil);		FlashResult(result);		result = MusicSetInstrumentNumber(d->ci,d->part,instrumentNumber);		FlashResult(result);		}	result = MusicGetPartName(d->ci,d->part,d->instrumentName);	FlashResult(result);/* end boguslike setup */		{		short knobses;		if(d->globalKnobCount > d->instrumentKnobCount)			knobses = d->globalKnobCount;		else			knobses = d->instrumentKnobCount;		if(knobses < 32)			knobses = 32;			/* for the controller list */		/*		 * allocate space for enough controls		 */		d->ec = (void *)NewPtr(sizeof(easyControl)				* knobses);		}	d->stashInstrument = 1;	d->recallInstrument = 1;	MakeControlsFromKnobList(d,&allControls);	d->visibleSliderBounds.top = d->visibleSliderBounds.bottom			= d->visibleSliderBounds.left = d->visibleSliderBounds.right = 0;	d->virtualSliderBounds= allControls;	UpdateSliderKnobs(d);	/*	 * Add the scroll bars	 */	r.top = r.left = -10;	r.bottom = r.right = -5;	d->horizontalScroller = NewControl(d->w,&r,"\p",false,0,0,1,scrollBarProc,0);	d->verticalScroller = NewControl(d->w,&r,"\p",false,0,0,1,scrollBarProc,0);	d->lastH = d->lastV = 0;		{		Point a;		Rect cellBounds;		InstrumentDataHandle iH;			cellBounds.top = cellBounds.left = 0;		cellBounds.right = 1;		cellBounds.bottom = 0;		a.h = kInstrumentListWidth;		a.v = kInstrumentListCellHeight;		r.left = kInstrumentListLeft + 1;		r.right = kInstrumentListRight - 16;		r.top = kInstrumentListTop;		r.bottom = r.top + 10;		d->listH = LNew(&r,&cellBounds,a,0,d->w,false,false,false,true);		d->instrumentCount = 0;		if(sr)			{			i = 1;			do				{				iH = (InstrumentDataHandle)Get1Resource(kInstrumentListResType,i++);				DetachResource((Handle)iH);				if(iH)					AddToList(d,iH);				} while(iH);			}		}	d->statBounds.left = kStatLeft+1;	d->statBounds.right = kStatRight-1;	d->statBounds.top = kStatTop;	d->statBounds.bottom = kStatBottom;		{		Rect r;		r.left = kKeyboardLeft;		r.right = kKeyboardRight;		r.top = kKeyboardTop;		r.bottom = kKeyboardBottom;		InitializeKeyboard(&d->kd,&r,kKeyboardOctaveCount,48);		}	gDocCount++;		{		Point a,b;		a.h = b.h = windowRect.right - windowRect.left;		a.v = b.v = windowRect.bottom - windowRect.top;		ResizeDoc(docNumber + kFirstDocWindow,&a,&b,0);		ShowWindow(d->w);		}goHome:;	}void About(void)	{	EasyDialogMessage(0,(StringPtr)0x910,			"\pby David Van Brink",			kEasyDialogOkay);	}void OpenSomeSynth(short n, short item,short ref)	{	short i;	for(i = 0; i<kDocMax; i++)		{		if(!gDoc[i].used)			{			NewDocFromSaveRecord(i,nil,&(**gSynthListH).entry[item-1]);			goto goHome;			}		}goHome:;	}#define kSliderVertBump 33Boolean CheckBit(unsigned long *t, long bit)	{	bit--;	t += (bit / 32);	bit &= 31;	bit = 1L<<(31-bit);	return ((*t) & bit) != 0;	}void MakeControlsFromKnobList(TDoc *d,Rect *outRect)	{	Rect allControls,r;	short i;	short j;	KnobDescription *kd;	EasyControl ec;	ComponentResult result;	short knobCount;	short columnCount;	short id;	if(d->whichList == mInstrumentKnobs)		d->knobCount = d->instrumentKnobCount;	else if(d->whichList == mControllers)		d->knobCount = d->controllerCount;	else		d->knobCount = d->globalKnobCount;	knobCount = d->knobCount;	SetRect(&allControls,0,0,0,0);	ClipRect(&allControls);			/* kill drawing for a while */	SetRect(&r,kDocMargin,kDocMargin,kSliderWidth + kDocMargin,kDocMargin + 14);	kd = * (d->whichList == mInstrumentKnobs ? d->ikdList : d->gkdList);	columnCount = 1;	for(i = 0; i < knobCount; i++)		{		if((!(d->whichList == mControllers)) && ((kd->flags & kKnobGroupStart) && i))			{			OffsetRect(&r,r.right - r.left + kDocMargin,0);			r.top = kDocMargin;			r.bottom = r.top + 14;			columnCount = 1;			}		else			{			columnCount++;			if(columnCount > 20)				{				OffsetRect(&r,r.right - r.left + kDocMargin,0);				r.top = kDocMargin + kSliderVertBump;				r.bottom = r.top + 14;				columnCount = 2;				}			}		UnionRect(&allControls,&r,&allControls);		if(d->whichList == mControllers)			{			short jj;			jj = 0;			for(id = 1; id <= 128; id++)				if(CheckBit(d->sd.controllers,id))					{					jj++;					if(jj == (i+1))						goto gotControl;					}			id = 1;			gotControl:			ec = NewEasyControl(&sliderType,&r,0,&aSliderStyle,(long)d,id,0,d->ecl);			}		else			ec = NewEasyControl(&sliderType,&r,0,&aSliderStyle,(long)d,i,0,d->ecl);		d->ec[i] = ec;		SetEasyControlValueProc(ec,(void *)SliderValueProc);		SetEasyControlColors(d->ec[i],dMyColors);//???		FlashResult(result);		if(d->whichList == mControllers)			{			if(id == kControllerPitchBend)				SetEasyControlRange(ec,0,3<<8);		/* 3 semitones */			else if(id == kControllerVolume)				SetEasyControlRange(ec,0,0x0001FFFF);	/* up to 4x max volume */			else				SetEasyControlRange(ec,0,(127<<8) + 255);			}		else			SetEasyControlRange(ec,kd->lowValue,kd->highValue);		OffsetRect(&r,0,33);		kd++;		}	allControls.bottom += 20;	allControls.right += kDocMargin;	*outRect = allControls;	}void InitVars()/* * Called once at startup: yes, it * inits the vars. */	{	TDoc *d;	ComponentResult result;	gUnloadedCPUTime = GetCPUTime();#ifdef rolledIn	InstallFB01();//	InstallDumbSynth();#endif	}void FlashResult(ComponentResult result)	{	Str255 s,n;	short x;	GrafPort *oldPort;	GetPort(&oldPort);	x = result & 0x0000FFFF;	if((result & 0xFFFF0000) == 0x80000000)		{		CopyPString(s,"\pError number ");		AnyBaseToPString(x,10,0,n);		ConcatenatePStrings(s,n);		ConcatenatePStrings(s,"\p occurred.");				EasyDialogMessage(0,"\pMusic Error",s,kEasyDialogOkay);		}	SetPort(oldPort);	}void Bootstrap()	{	short i;/*** File Menu ***/	InstallMenu("\pFile",nil,0);	InstallMenuItem("\pOpenÉ/O",OpenDoc,mOpen);	InstallMenuItem("\pClose/W",(void *)CloseDoc,-mClose);	InstallMenuItem("\p(-",nil,0);	InstallMenuItem("\pSave/S",(void *)SaveDoc,-mSave);	InstallMenuItem("\pSave AsÉ",(void *)SaveAsDoc,-mSaveAs);	InstallQuitItem(LetsQuit,0);/*** Edit Menu ***/	InstallEditMenu(nil,nil,nil,nil,nil);/*** Synth Menu ***/	gSynthListH = GetSynthesizerList();	InstallMenu("\pSynthesizers",nil,0);	for(i = 0; i < (**gSynthListH).synthCount; i++)		{		unsigned char s[40];		CopyPString(s,(**gSynthListH).entry[i].synthName);		if(!s[0])			{			s[0] = 1;			s[1] = 'x';			}		if(i < 9)			{			s[s[0]+1] = '/';			s[s[0]+2] = '1' + i;			s[0] += 2;			}		InstallMenuItem( s,OpenSomeSynth,mNew);		}/* Instruments & Knobs Menu */	InstallMenu("\pInstruments",nil,0);	InstallMenuItem("\pName InstrumentÉ/N",NameInstrumentDoc,-mNameInstrument);	InstallMenuItem("\pAdd Instrument To List/A",GetInstrumentDoc,-mGetInstrument);	InstallMenuItem("\pGet Instrument From List/G",SetInstrumentDoc,-mSetInstrument);	InstallMenuItem("\p(-",0,0);	InstallMenuItem("\pShow Instrument Knobs/Á",DoInstrumentKnobs,-mInstrumentKnobs);	InstallMenuItem("\pShow Global Knobs/ª",DoGlobalKnobs,-mGlobalKnobs);	InstallMenuItem("\pShow Controllers/£",DoControllers,-mControllers);	InstallMenuItem("\p(-",nil,0);	InstallMenuItem("\pRandomize Instrument Knobs/K",RandomizeKnobsDoc,-mRandomizeKnobs);	InstallMenuItem("\pDefault Instrument Knobs/D",SetDefaultInstrumentDoc,-mTestDoc);/*** Tests Menu ***/	InstallMenu("\pTests",nil,0);	InstallMenuItem("\pPlay Pitchbend Scale",PitchBendDoc,-mPitchbendDoc);	InstallMenuItem("\pPlay µTonal Scale",MicrotoneDoc,-mMicrotoneDoc);	InstallMenuItem("\pNotes On",NotesOnDoc,-mTestDoc);	InstallMenuItem("\pNotes Off",NotesOffDoc,-mTestDoc);/*** Special Menu ***/	InstallMenu("\pSpecial",nil,0);	InstallMenuItem("\pCPU LoadÉ/L",ShowCPULoad,mCPULoad);	InstallMenuItem("\p(-",0,0);	InstallMenuItem("\pSet Master Tuning",SetMasterTuneDoc,-mTestDoc);	InstallMenuItem("\pSet Master Tuning",SetMasterTuneDoc,-mTestDoc);		{		Str63 s;		CopyPString(s,"\pAbout ");		ConcatenatePStrings(s,(StringPtr)0x910);		ConcatenatePStrings(s,"\pÉ");		SetAbout(s,0,About);		}	SetMasterOpenDocProc(OpenDocSpec);	SetMasterQuitAppProc((void *)LetsQuit);	InitVars();	}void Hatstrap()/*  * clean up  */	{	}pascal ComponentResult EditorMusicReadHook(MusicMIDIPacket *mp, long refCon)	{	ComponentInstance ci;	unsigned short x;	TDoc *d;	d = (TDoc *)refCon;	ci = d->ci;	x = mp->data[0] & 0xF0;	if(x == 0x80)		{		NAPlayNote(d->na,d->nc,mp->data[1],0);		d->keyVel[mp->data[1]] = 0;		}	else if(x == 0x90)		{		NAPlayNote(d->na,d->nc,mp->data[1],mp->data[2]);		d->keyVel[mp->data[1]] = mp->data[2];		}	else if(x == 0xE0)		{		NASetController(d->na,d->nc,kControllerPitchBend,				(((mp->data[2]<<7) | mp->data[1]) - 0x2000) >> 4 );		d->controllersDirty = true;		}	return noErr;	}pascal void JunkTask(void)	{	}long GetCPUTime(void)/* * return the number of uSec for * some fixed little task here. */	{	TMTask tmTask;	register long tot,x;	short i;	tot = 0;	for(i = 0; i< 4; i++)		{		tmTask.tmAddr = (TimerUPP)JunkTask;		tmTask.tmWakeUp = 0;		tmTask.tmReserved = 0;		InsXTime((void *)&tmTask);		PrimeTime((void *)&tmTask,-(0x7FFFffff));			x = 1000000;		while(x--);		RmvTime((void *)&tmTask);		tot += tmTask.tmCount + (0x7FFFffff);		}	return tot;	}