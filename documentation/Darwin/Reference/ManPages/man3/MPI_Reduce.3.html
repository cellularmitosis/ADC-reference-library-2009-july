<html><head><title>Mac OS X
 Manual Page For MPI_Reduce(3)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3/MPI_Reduce" title="Mac OS X
 Manual Page for MPI_Reduce(3)"><!-- headerDoc=man; indexgroup=Section 3; uid="//apple_ref/doc/man/3/MPI_Reduce"; name=MPI_Reduce(3) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
MPI_Reduce(3OpenMPI)                                                                    MPI_Reduce(3OpenMPI)



<b>NAME</b>
       <b>MPI_Reduce</b> - Reduces values on all processes within a group.


<b>SYNTAX</b>
<b>C</b> <b>Syntax</b>
       #include &lt;mpi.h&gt;
       int MPI_Reduce(void *<u>sendbuf</u>, void *<u>recvbuf</u>, int <u>count</u>,
            MPI_Datatype <u>datatype</u>, MPI_Op <u>op</u>, int <u>root</u>, MPI_Comm <u>comm</u>)


<b>Fortran</b> <b>Syntax</b>
       INCLUDE 'mpif.h'
       MPI_REDUCE(<u>SENDBUF,</u> <u>RECVBUF,</u> <u>COUNT,</u> <u>DATATYPE,</u> <u>OP,</u> <u>ROOT,</u> <u>COMM,</u>
                 <u>IERROR</u>)
            &lt;type&gt;    <u>SENDBUF(*),</u> <u>RECVBUF(*)</u>
            INTEGER   <u>COUNT,</u> <u>DATATYPE,</u> <u>OP,</u> <u>ROOT,</u> <u>COMM,</u> <u>IERROR</u>


<b>C++</b> <b>Syntax</b>
       #include &lt;mpi.h&gt;
       void MPI::Intracomm::Reduce(const void* <u>sendbuf</u>, void* <u>recvbuf</u>,
            int <u>count</u>, const MPI::Datatype&amp; <u>datatype</u>, const MPI::Op&amp; <u>op</u>,
            int <u>root</u>) const


<b>INPUT</b> <b>PARAMETERS</b>
       sendbuf   Address of send buffer (choice).

       count     Number of elements in send buffer (integer).

       datatype  Data type of elements of send buffer (handle).

       op        Reduce operation (handle).

       root      Rank of root process (integer).

       comm      Communicator (handle).


<b>OUTPUT</b> <b>PARAMETERS</b>
       recvbuf   Address of receive buffer (choice, significant only at root).

       IERROR    Fortran only: Error status (integer).


<b>DESCRIPTION</b>
       The  global reduce functions (MPI_Reduce, MPI_Op_create, MPI_Op_free, MPI_Allreduce, MPI_Reduce_scat-<font color="#ffffff" class="whiteout">ter,&nbsp;MPI_Reduce_scatter,</font>
       ter, MPI_Scan) perform a global reduce operation (such as sum, max, logical AND, etc.) across all the
       members  of a group. The reduction operation can be either one of a predefined list of operations, or
       a user-defined operation. The global reduction functions come  in  several  flavors:  a  reduce  that
       returns the result of the reduction at one node, an all-reduce that returns this result at all nodes,
       and a scan (parallel prefix) operation. In addition, a reduce-scatter operation  combines  the  func-<font color="#ffffff" class="whiteout">tionality&nbsp;functionality</font>
       tionality of a reduce and a scatter operation.

       MPI_Reduce combines the elements provided in the input buffer of each process in the group, using the
       operation op, and returns the combined value in the output buffer of the process with rank root.  The
       input  buffer  is defined by the arguments sendbuf, count, and datatype; the output buffer is defined
       by the arguments recvbuf, count, and datatype; both have the same number of elements, with  the  same
       type.  The  routine  is called by all group members using the same arguments for count, datatype, op,
       root, and comm. Thus, all processes provide input buffers and output buffers of the same length, with
       elements  of the same type. Each process can provide one element, or a sequence of elements, in which
       case the combine operation is executed element-wise on each entry of the sequence.  For  example,  if
       the  operation  is  MPI_MAX and the send buffer contains two elements that are floating-point numbers
       (count = 2 and datatype = MPI_FLOAT), then <!-- a -->recvbuf(1)<!-- /a --> = global  max  <!-- a -->(sendbuf(1)<!-- /a -->)  and  <!-- a -->recvbuf(2)<!-- /a -->  =
       global max(sendbuf(2)).


<b>USE</b> <b>OF</b> <b>IN-PLACE</b> <b>OPTION</b>
       When  the communicator is an intracommunicator, you can perform a reduce operation in-place (the out-<font color="#ffffff" class="whiteout">put&nbsp;output</font>
       put buffer is used as the input buffer).  Use the variable MPI_IN_PLACE as  the  value  of  the  root
       process <u>sendbuf</u>.  In this case, the input data is taken at the root from the receive buffer, where it
       will be replaced by the output data.

       Note that MPI_IN_PLACE is a special kind of value; it  has  the  same  restrictions  on  its  use  as
       MPI_BOTTOM.

       Because  the  in-place  option  converts the receive buffer into a send-and-receive buffer, a Fortran
       binding that includes INTENT must mark these as INOUT, not OUT.


<b>WHEN</b> <b>COMMUNICATOR</b> <b>IS</b> <b>AN</b> <b>INTER-COMMUNICATOR</b>
       When the communicator is an inter-communicator, the root process in the  first  group  combines  data
       from  all  the  processes  in  the  second group and then performs the <u>op</u> operation.  The first group
       defines the root process.  That process uses MPI_ROOT as the value of its <u>root</u> argument.  The remain-<font color="#ffffff" class="whiteout">ing&nbsp;remaining</font>
       ing  processes  use  MPI_PROC_NULL  as the value of their <u>root</u> argument.  All processes in the second
       group use the rank of that root process in the first group as the value of their <u>root</u> argument.  Only
       the  send buffer arguments are significant in the second group, and only the receive buffer arguments
       are significant in the root process of the first group.


<b>PREDEFINED</b> <b>REDUCE</b> <b>OPERATIONS</b>
       The set of predefined operations provided by MPI is listed below (Predefined Reduce Operations). That
       section also enumerates the datatypes each operation can be applied to. In addition, users may define
       their own operations that can be overloaded to operate on several datatypes, either basic or derived.
       This  is  further  explained in the description of the user-defined operations (see the man pages for
       MPI_Op_create and MPI_Op_free).

       The operation op is always assumed to be associative. All predefined operations are also  assumed  to
       be  commutative. Users may define operations that are assumed to be associative, but not commutative.
       The ``canonical'' evaluation order of a reduction is determined by the ranks of the processes in  the
       group. However, the implementation can take advantage of associativity, or associativity and commuta-<font color="#ffffff" class="whiteout">tivity,&nbsp;commutativity,</font>
       tivity, in order to change the order of evaluation. This may change the result of the  reduction  for
       operations that are not strictly associative and commutative, such as floating point addition.

       Predefined operators work only with the MPI types listed below (Predefined Reduce Operations, and the
       section MINLOC and MAXLOC, below).  User-defined operators may operate on general, derived datatypes.
       In  this case, each argument that the reduce operation is applied to is one element described by such
       a datatype, which may contain several basic values. This is further explained in Section 4.9.4 of the
       MPI Standard, "User-Defined Operations."

       The  following predefined operations are supplied for MPI_Reduce and related functions MPI_Allreduce,
       MPI_Reduce_scatter, and MPI_Scan. These operations are invoked by placing the following in op:

            Name                Meaning
            ---------           --------------------<font color="#ffffff" class="whiteout">MPI_MAX&nbsp;-------------------MPI_MAX</font>
            MPI_MAX             maximum
            MPI_MIN             minimum
            MPI_SUM             sum
            MPI_PROD            product
            MPI_LAND            logical and
            MPI_BAND            bit-wise and
            MPI_LOR             logical or
            MPI_BOR             bit-wise or
            MPI_LXOR            logical xor
            MPI_BXOR            bit-wise xor
            MPI_MAXLOC          max value and location
            MPI_MINLOC          min value and location

       The two operations MPI_MINLOC and MPI_MAXLOC are discussed separately below (MINLOC and MAXLOC).  For
       the other predefined operations, we enumerate below the allowed combinations of op and datatype argu-<font color="#ffffff" class="whiteout">ments.&nbsp;arguments.</font>
       ments. First, define groups of MPI basic datatypes in the following way:

            C integer:            MPI_INT, MPI_LONG, MPI_SHORT,
                                  MPI_UNSIGNED_SHORT, MPI_UNSIGNED,
                                  MPI_UNSIGNED_LONG
            Fortran integer:      MPI_INTEGER
            Floating-point:       MPI_FLOAT, MPI_DOUBLE, MPI_REAL,
                                  MPI_DOUBLE_PRECISION, MPI_LONG_DOUBLE
            Logical:              MPI_LOGICAL
            Complex:              MPI_COMPLEX
            Byte:                 MPI_BYTE

       Now, the valid datatypes for each option is specified below.

            Op                       Allowed Types
            ----------------         ---------------------------<font color="#ffffff" class="whiteout">MPI_MAX,&nbsp;--------------------------MPI_MAX,</font>
            MPI_MAX, MPI_MIN         C integer, Fortran integer,
                                     floating-point

            MPI_SUM, MPI_PROD        C integer, Fortran integer,
                                     floating-point, complex

            MPI_LAND, MPI_LOR,       C integer, logical
            MPI_LXOR

            MPI_BAND, MPI_BOR,       C integer, Fortran integer, byte
            MPI_BXOR

       <b>Example</b> <b>1:</b> A routine that computes the dot product of two  vectors  that  are  distributed  across  a
       group of processes and returns the answer at process zero.

           SUBROUTINE PAR_BLAS1(m, a, b, c, comm)
           REAL <!-- a -->a(m)<!-- /a -->, <!-- a -->b(m)<!-- /a -->       ! local slice of array
           REAL c                ! result (at process zero)
           REAL sum
           INTEGER m, comm, i, ierr

           ! local sum
           sum = 0.0
           DO i = 1, m
              sum = sum + <!-- a -->a(i)<!-- /a -->*b(i)
           END DO

           ! global sum
           CALL MPI_REDUCE(sum, c, 1, MPI_REAL, MPI_SUM, 0, comm, ierr)
           RETURN

       <b>Example</b> <b>2:</b> A routine that computes the product of a vector and an array that are distributed across a
       group of processes and returns the answer at process zero.

           SUBROUTINE PAR_BLAS2(m, n, a, b, c, comm)
           REAL <!-- a -->a(m)<!-- /a -->, b(m,n)    ! local slice of array
           REAL <!-- a -->c(n)<!-- /a -->            ! result
           REAL <!-- a -->sum(n)<!-- /a -->
           INTEGER n, comm, i, j, ierr

           ! local sum
           DO j= 1, n
             <!-- a -->sum(j)<!-- /a --> = 0.0
             DO i = 1, m
               <!-- a -->sum(j)<!-- /a --> = <!-- a -->sum(j)<!-- /a --> + <!-- a -->a(i)<!-- /a -->*b(i,j)
             END DO
           END DO

           ! global sum
           CALL MPI_REDUCE(sum, c, n, MPI_REAL, MPI_SUM, 0, comm, ierr)

           ! return result at process zero (and garbage at the other nodes)
           RETURN


<b>MINLOC</b> <b>AND</b> <b>MAXLOC</b>
       The operator MPI_MINLOC is used to compute a global minimum and also an index attached to the minimum
       value.  MPI_MAXLOC similarly computes a global maximum and index. One application of these is to com-<font color="#ffffff" class="whiteout">pute&nbsp;compute</font>
       pute a global minimum (maximum) and the rank of the process containing this value.


       The operation that defines MPI_MAXLOC is

                ( u )    (  v )      ( w )
                (   )  o (    )   =  (   )
                ( i )    (  j )      ( k )

       where

           w = max(u, v)

       and

                ( i            if u &gt; v
                (
          k   = ( min(i, j)    if u = v
                (
                (  j           if u &lt; v)


       MPI_MINLOC is defined similarly:

                ( u )    (  v )      ( w )
                (   )  o (    )   =  (   )
                ( i )    (  j )      ( k )

       where

           w = max(u, v)

       and

                ( i            if u &lt; v
                (
          k   = ( min(i, j)    if u = v
                (
                (  j           if u &gt; v)




       Both operations are associative and commutative. Note that if  MPI_MAXLOC  is  applied  to  reduce  a
       sequence of pairs (u(0), 0), <!-- a -->(u(1)<!-- /a -->, 1), ..., (u(n-1), n-1), then the value returned is (u , r), where
       u= <!-- a -->max(i)<!-- /a --> <!-- a -->u(i)<!-- /a --> and r is the index of the first global maximum in the sequence. Thus, if each  process
       supplies  a  value  and  its rank within the group, then a reduce operation with op = MPI_MAXLOC will
       return the maximum value and the rank of the first process with that value. Similarly, MPI_MINLOC can
       be  used to return a minimum and its index. More generally, MPI_MINLOC computes a lexicographic mini-<font color="#ffffff" class="whiteout">mum,&nbsp;minimum,</font>
       mum, where elements are ordered according to the first component of each pair, and ties are  resolved
       according to the second component.

       The  reduce operation is defined to operate on arguments that consist of a pair: value and index. For
       both Fortran and C, types are provided to describe the pair. The  potentially  mixed-type  nature  of
       such  arguments is a problem in Fortran. The problem is circumvented, for Fortran, by having the MPI-<font color="#ffffff" class="whiteout">provided&nbsp;MPIprovided</font>
       provided type consist of a pair of the same type as value, and coercing the index to this type  also.
       In C, the MPI-provided pair type has distinct types and the index is an int.

       In order to use MPI_MINLOC and MPI_MAXLOC in a reduce operation, one must provide a datatype argument
       that represents a pair (value and index). MPI provides nine such predefined datatypes. The operations
       MPI_MAXLOC and MPI_MINLOC can be used with each of the following datatypes:

           Fortran:
           Name                     Description
           MPI_2REAL                pair of REALs
           MPI_2DOUBLE_PRECISION    pair of DOUBLE-PRECISION variables
           MPI_2INTEGER             pair of INTEGERs

           C:
           Name                 Description
           MPI_FLOAT_INT            float and int
           MPI_DOUBLE_INT           double and int
           MPI_LONG_INT             long and int
           MPI_2INT                 pair of ints
           MPI_SHORT_INT            short and int
           MPI_LONG_DOUBLE_INT      long double and int

       The data type MPI_2REAL is equivalent to:
           MPI_TYPE_CONTIGUOUS(2, MPI_REAL, MPI_2REAL)

       Similar statements apply for MPI_2INTEGER, MPI_2DOUBLE_PRECISION, and MPI_2INT.

       The datatype MPI_FLOAT_INT is as if defined by the following sequence of instructions.

           type[0] = MPI_FLOAT
           type[1] = MPI_INT
           disp[0] = 0
           disp[1] = sizeof(float)
           block[0] = 1
           block[1] = 1
           MPI_TYPE_STRUCT(2, block, disp, type, MPI_FLOAT_INT)

       Similar statements apply for MPI_LONG_INT and MPI_DOUBLE_INT.

       <b>Example</b>  <b>3:</b>  Each process has an array of 30 doubles, in C. For each of the 30 locations, compute the
       value and rank of the process containing the largest value.

               ...
               /* each process has an array of 30 double: ain[30]
                */
               double ain[30], aout[30];
               int  ind[30];
               struct {
                   double val;
                   int   rank;
               } in[30], out[30];
               int i, myrank, root;

               MPI_Comm_rank(MPI_COMM_WORLD, &amp;myrank);
               for (i=0; i&lt;30; ++i) {
                   in[i].val = ain[i];
                   in[i].rank = myrank;
               }
               MPI_Reduce( in, out, 30, MPI_DOUBLE_INT, MPI_MAXLOC, root, comm );
               /* At this point, the answer resides on process root
                */
               if (myrank == root) {
                   /* read ranks out
                    */
                   for (i=0; i&lt;30; ++i) {
                       aout[i] = out[i].val;
                       ind[i] = out[i].rank;
                   }
               }

       <b>Example</b> <b>4:</b>  Same example, in Fortran.

           ...
           ! each process has an array of 30 double: <!-- a -->ain(30)<!-- /a -->

           DOUBLE PRECISION <!-- a -->ain(30)<!-- /a -->, <!-- a -->aout(30)<!-- /a -->
           INTEGER <!-- a -->ind(30)<!-- /a -->;
           DOUBLE PRECISION in(2,30), out(2,30)
           INTEGER i, myrank, root, ierr;

           MPI_COMM_RANK(MPI_COMM_WORLD, myrank);
               DO I=1, 30
                   in(1,i) = <!-- a -->ain(i)<!-- /a -->
                   in(2,i) = myrank    ! myrank is coerced to a double
               END DO

           MPI_REDUCE( in, out, 30, MPI_2DOUBLE_PRECISION, MPI_MAXLOC, root,
                                                                     comm, ierr );
           ! At this point, the answer resides on process root

           IF (myrank .EQ. root) THEN
                   ! read ranks out
                   DO I= 1, 30
                       <!-- a -->aout(i)<!-- /a --> = out(1,i)
                       <!-- a -->ind(i)<!-- /a --> = out(2,i)  ! rank is coerced back to an integer
                   END DO
               END IF

       <b>Example</b> <b>5:</b> Each process has a nonempty array of values.  Find the minimum global value, the  rank  of
       the process that holds it, and its index on this process.

           #define  LEN   1000

           float val[LEN];        /* local array of values */
           int count;             /* local number of values */
           int myrank, minrank, minindex;
           float minval;

           struct {
               float value;
               int   index;
           } in, out;

           /* local minloc */
           in.value = val[0];
           in.index = 0;
           for (i=1; i &lt; count; i++)
               if (in.value &gt; val[i]) {
                   in.value = val[i];
                   in.index = i;
               }

           /* global minloc */
           MPI_Comm_rank(MPI_COMM_WORLD, &amp;myrank);
           in.index = myrank*LEN + in.index;
           MPI_Reduce( in, out, 1, MPI_FLOAT_INT, MPI_MINLOC, root, comm );
               /* At this point, the answer resides on process root
                */
           if (myrank == root) {
               /* read answer out
                */
               minval = out.value;
               minrank = out.index / LEN;
               minindex = out.index % LEN;

       All MPI objects (e.g., MPI_Datatype, MPI_Comm) are of type INTEGER in Fortran.

<b>NOTES</b> <b>ON</b> <b>COLLECTIVE</b> <b>OPERATIONS</b>
       The  reduction  functions  (  <u>MPI</u><b>_</b><u>Op</u>  )  do not return an error value.  As a result, if the functions
       detect an error, all they can do is either call <u>MPI</u><b>_</b><u>Abort</u> or silently skip the problem.  Thus, if you
       change  the error handler from <u>MPI</u><b>_</b><u>ERRORS</u><b>_</b><u>ARE</u><b>_</b><u>FATAL</u> to something else, for example, <u>MPI</u><b>_</b><u>ERRORS</u><b>_</b><u>RETURN</u>
       , then no error may be indicated.

       The reason for this is the performance problems in ensuring that all collective routines  return  the
       same error value.


<b>ERRORS</b>
       Almost  all  MPI  routines return an error value; C routines as the value of the function and Fortran
       routines in the last argument. C++ functions do not return errors. If the default  error  handler  is
       set  to MPI::ERRORS_THROW_EXCEPTIONS, then on error the C++ exception mechanism will be used to throw
       an MPI:Exception object.

       Before the error value is returned, the current MPI error handler is called. By default,  this  error
       handler  aborts  the  MPI  job, except for I/O function errors. The error handler may be changed with
       MPI_Comm_set_errhandler; the predefined error handler MPI_ERRORS_RETURN may be used  to  cause  error
       values  to  be  returned.  Note  that MPI does not guarantee that an MPI program can continue past an
       error.


<b>SEE</b> <b>ALSO</b>
       MPI_Allreduce
       MPI_Reduce_scatter
       MPI_Scan
       MPI_Op_create
       MPI_Op_free






Open MPI 1.2                                   September 2006                           MPI_Reduce(3OpenMPI)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/MPI_Reduce.3.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/MPI_Reduce.3.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/MPI_Reduce.3.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
