<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Using the Device Manager(IM: D)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING13></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->




<!-- Main Body -->

<CENTER>
<P>
<A HREF="Devices-12.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Devices-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Devices-328.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Devices-14.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Devices-2.html"><B>Devices</B></A> / <BR><DD><A HREF="Devices-10.html"><B>Chapter 1 - Device Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING13-0></A>
<H1><A NAME=MARKER-9-121></A>Using the Device Manager</H1>
 Your application can use Device Manager functions to communicate with devices through their device drivers. This section describes the Device Manager functions that allow you to open, close, and control device drivers, exchange information with them, and monitor their status. The Device Manager also provides support functions useful for writing and installing device drivers. The section <A HREF=Devices-14.html#MARKER-9-113>"Writing a Device Driver," beginning on page 1-24</A>, describes these support functions. <P>
 The Device Manager includes high-level and low-level versions of most of its functions. The high-level versions are somewhat easier to use, but they allow less control of how the Device Manager processes the I/O request (for example, they are always handled synchronously) and they return less information to your application. Conversely, the low-level functions require some additional setup, but they allow you greater control and return more information.<P>
 The high-level Device Manager functions call the low-level functions, which in turn call the appropriate driver routine. For example, the Device Manager converts the high-level <CODE>FSRead</CODE> function to a low-level <CODE>PBRead</CODE> function before calling the driver's prime routine. <A HREF=#MARKER-9-75>Figure 1-7</A> depicts this hierarchy.<P>
<B>Figure 1-7  <A NAME=MARKER-9-75></A>Hierarchy of Device Manager functions</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/DEV-L-11.jpg"><p>
 The high-level functions differ in form, but the low-level functions all have the form:<P>
<PRE>
pascal OSErr PBRoutineName (ParmBlkPtr paramBlock, Boolean async); 
</PRE>
 The <CODE>paramBlock</CODE> parameter is a pointer to a structure of type <CODE>ParamBlockRec</CODE>. You use the fields of this structure to pass more complete information to the driver than you can with high-level functions, and the driver uses the same structure to pass information back. The <CODE>ParamBlockRec</CODE> is defined in C as a union of six structures, but only the <CODE>IOParam</CODE> and <CODE>CntrlParam</CODE> types are used by the Device Manager. <A HREF=#MARKER-9-86>Figure 1-8</A> shows the fields of the <CODE>ParamBlockRec</CODE> structure used by the Device Manager. These fields are described in detail later in this section and in <A HREF=Devices-18.html#MARKER-9-218>"Data Structures" on page 1-53</A>.<P>
 <A NAME=MARKER-2-190></A><A NAME=MARKER-2-163></A>The <CODE>async</CODE> parameter specifies whether the Device Manager should process the function asynchronously. For synchronous requests you set this parameter to <CODE>false</CODE>; the Device Manager adds the parameter block to the driver I/O queue and waits until the driver completes the request (which means it has completed all previously queued requests) before returning control to your application. <P>
<DL>
<DT><B>WARNING</B>
<DD><A NAME=MARKER-9-78></A>Never call any Device Manager function synchronously at interrupt time. <A NAME=MARKER-2-162></A>A synchronous request at interrupt time may block other pending I/O requests. Because the device driver cannot begin processing the synchronous request until it completes the other requests in its queue, this situation can cause the Device Manager to loop indefinitely while it waits for the device driver to complete the synchronous request.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 If you set the <CODE>async</CODE> parameter to <CODE>true</CODE>, the Device Manager adds the parameter block to the driver I/O queue and returns control to your application immediately. In this case, a <CODE>noErr</CODE> result code signifies that the request was successfully queued, not that the request was successfully completed. The Device Manager sets the <CODE>ioResult</CODE> field of the parameter block to 1 when the request is queued, and stores the actual result code there when the driver indicates the request is complete. <P>
 When you make an asynchronous request you can also provide a pointer to a completion routine in the <CODE>ioCompletion</CODE> field of the parameter block. The Device Manager executes this routine when the driver completes the asynchronous request. Your completion routine could, for example, set a flag to signal your application that the I/O operation is complete. See <A HREF=Devices-14.html#MARKER-9-173>"Handling Asynchronous I/O," beginning on page 1-37</A>, for more information about completion routines and asynchronous operation.<P>
<DL>
<DT><B>Assembly-Language Note</B>
<DD><A NAME=MARKER-2-302></A><A NAME=MARKER-2-51></A>You can call a Device Manager function immediately, bypassing the I/O queue, by setting bit 9 of the trap word. You can set or test this bit using the global constant <CODE>noQueueBit</CODE>. However, remember that the device driver might be processing another request, especially if you make an immediate request during interrupt time. The driver must be reentrant to handle this situation properly. You should always check a driver's documentation to make sure the driver is reentrant before making immediate requests.<A NAME=MARKER-2-83></A><A NAME=MARKER-9-163></A><A NAME=MARKER-2-164></A><EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<B>Figure 1-8  <A NAME=MARKER-9-86></A>Device Manager parameter blocks</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/DEV-L-10.jpg"><p>
 When you use a low-level Device Manager function, the Device Manager places the parameter block at the end of the driver I/O queue and then either waits for the driver to complete the request or returns control to your application, depending on the value of the <CODE>async</CODE> parameter. For the high-level functions, the Device Manager creates a parameter block for you, filling the required fields with the values you supplied. The Device Manager then inserts the parameter block at the end of the <A NAME=MARKER-2-87></A>I/O queue as a synchronous request. As previously-queued requests are processed, the parameter block moves forward in the I/O queue. When the parameter block is at the beginning of the queue, the Device Manager calls the appropriate driver routine and passes it a pointer to the parameter block and a pointer to the driver's device control entry.<P>
 <A NAME=MARKER-8-79></A>For read and write requests, the Device Manager calls the driver's prime routine. This routine can execute synchronously, completing the requested read or write transaction before returning control to the Device Manager, or asynchronously, beginning the requested transaction but returning control to the Device Manager before completing it. For information about reading and writing data to devices, see <A HREF=#MARKER-9-103>"Communicating With Device Drivers" on page 1-20</A>.<P>
 <A NAME=MARKER-2-57></A>If you are writing a device driver and your driver's prime routine can execute asynchronously, your driver must use some mechanism to regain control of the processor to complete asynchronous requests. Your driver would typically use an interrupt handler for this purpose, and notify the Device Manager when the transaction is complete. See <A HREF=Devices-14.html#MARKER-9-153>"Writing a Prime Routine" on page 1-33</A> and <A HREF=Devices-14.html#MARKER-9-173>"Handling Asynchronous I/O" on page 1-37</A> for more information about writing asynchronous routines.<P>
 The Device Manager handles control and status requests in the same way as read and write requests, except that for control requests it calls the control routine and for status requests it calls the status routine. See <A HREF=#MARKER-9-109>"Controlling and Monitoring Device Drivers" on page 1-22</A> for information about making these requests. For information about providing status and control routines for your own driver, see <A HREF=Devices-14.html#MARKER-9-160>"Writing Control and Status Routines" on page 1-34</A>.<P>
 <A NAME=MARKER-2-59></A>The Device Manager responds to <CODE>KillIO</CODE> requests by calling the device driver's control routine with a value of <CODE>killCode</CODE> for the <CODE>csCode</CODE> parameter. If the driver returns <CODE>noErr</CODE>, the Device Manager removes all parameter blocks from the queue, calling their completion routines with the result code <CODE>abortErr</CODE>. For more information about canceling I/O requests, see the description of the <CODE>KillIO</CODE> function on <A HREF=Devices-40.html#MARKER-9-368>page 1-80</A>. For information on how your driver can handle <CODE>KillIO</CODE> requests, see <A HREF=Devices-14.html#MARKER-9-160>"Writing Control and Status Routines" on page 1-34</A>.<P>
 <A NAME=MARKER-2-375></A><A NAME=MARKER-2-28></A>In response to a close request, the Device Manager waits until the driver is inactive, then calls the driver's close routine. When the driver indicates it has processed the close request, the Device Manager unlocks the driver resource if the <CODE>dRAMBased</CODE> flag is set, and unlocks the device control entry if the <CODE>dNeedLock</CODE> flag is not set. The Device Manager does not release the driver resource or dispose of the device control entry unless you call the <CODE>DriverRemove</CODE> function. The next section describes how to open and close a device driver. See <A HREF=Devices-14.html#MARKER-9-144>"Writing Open and Close Routines" on page 1-31</A> for information about how your driver should respond to open and close requests.<P>
<A NAME=HEADING13-23></A>
<H2><A NAME=MARKER-2-94></A>Opening and Closing Device Drivers</H2>
 <CODE><A NAME=MARKER-2-61></A><A NAME=MARKER-2-116></A><A NAME=MARKER-2-68></A></CODE>You must open a driver before your application can communicate with it. The Device Manager provides three functions for opening device drivers: <CODE>OpenDriver</CODE>, <CODE>OpenSlot</CODE>, and <CODE>PBOpen</CODE>. Each of these functions requires a driver name and returns a driver reference number.<P>
 <A NAME=MARKER-2-66></A><A NAME=MARKER-2-117></A>A driver name consists of a period (.) followed by any sequence of 1 to 254 printing characters; for example, .ATP is the name of one of the high-level AppleTalk drivers. The initial period in a driver name allows the Device Manager and the File Manager, which share the <CODE>_Open</CODE> trap, to distinguish between driver names and filenames. Refer to a device driver's documentation to determine the driver name.<P>
 The <CODE>OpenDriver</CODE> function, which is the high-level function for opening a device driver, takes the driver name as its first parameter and returns the driver reference number in its second parameter. When an application or another manager calls the <CODE>OpenDriver</CODE> function, the Device Manager first searches the unit table to see if a driver with the specified name is already installed. If the name does not match any installed driver, the Device Manager searches the current Resource Manager search path for a driver resource with the specified name.<P>
 To open a device driver from a resource, the Device Manager<P>
<UL>
<LI>creates a device control entry for the driver, filling in the DCE with values from the header of the driver resource
<LI>installs a handle to the device control entry in the unit table at a location determined by the driver resource ID
<LI>calls the driver's open routine<P>
</UL>
 <A HREF=#MARKER-9-100>Listing 1-1</A> shows an application-defined function that uses the <CODE>OpenDriver</CODE> function to open a driver.<P>
<B>Listing 1-1  <A NAME=MARKER-9-100></A>Opening a device driver</B><P>
<PRE>
short    gDrvrRefNum; /* global variable for storing
                         my driver reference number */

OSErr MyOpenDriver(void)
{
   Handle   drvrHdl;
   short    drvrID;
   short    tempDrvrID;
   ResType  drvrType;
   Str255   drvrName;
   OSErr    myErr;

   tempDrvrID = MyFindSpaceInUnitTable(); /* see Listing 1-14 */
   if (tempDrvrID &gt; 0)
   {
      drvrHdl = GetNamedResource((ResType)'DRVR', &quot;\p.MYDRIVER&quot;);
      GetResInfo(drvrHdl, &amp;drvrID, &amp;drvrType, drvrName);
      SetResInfo(drvrHdl, tempDrvrID, drvrName);

      myErr = OpenDriver(&quot;\p.MYDRIVER&quot;, &amp;gDrvrRefNum);

      if (myErr == noErr)
         DetachResource(drvrHdl);
      
      drvrHdl = GetNamedResource((ResType)'DRVR', drvrName);
      SetResInfo(drvrHdl, drvrID, drvrName);

      return(myErr);
   }
   else
      return(openErr); /* no space in the unit table */
}
</PRE>
 The <CODE>OpenDriver</CODE> function uses the resource ID of the driver resource as the unit number for the device driver, which determines where the device control entry will be stored in the unit table. Because the <CODE>OpenDriver</CODE> function does not check to see if another device control entry is already located at that position in the unit table, the <CODE>MyOpenDriver</CODE> function begins by searching for an available space in the unit table. <A HREF=Devices-14.html#MARKER-9-183>Listing 1-14 on page 1-39</A> shows the <CODE>MyFindSpaceInUnitTable</CODE> function.<P>
 If there is room in the unit table, the <CODE>MyOpenDriver</CODE> function calls <CODE>GetNamedResource</CODE> to load the resource into memory, then changes the ID of the driver resource in the resource map before calling the <CODE>OpenDriver</CODE> function. <P>
 After the driver is open, <CODE>MyOpenDriver</CODE> calls the <CODE>DetachResource</CODE> function to prevent the driver resource from being released. Finally, <CODE>MyOpenDriver</CODE> restores the original resource ID so that the driver's resource file remains unchanged.<P>
 You can use the <CODE>PBOpen</CODE> or <CODE>OpenSlot</CODE> functions instead of the <CODE>OpenDriver</CODE> function when you want more control over how the Device Manager opens the device driver. For example, you can set read and write permissions for the device with the <CODE>ioPermssn</CODE> field of the parameter block. Use the <CODE>OpenSlot</CODE> function to open drivers that serve slot devices, and the <CODE>PBOpen</CODE> function for all other drivers.<P>
 Because the Device Manager always opens device drivers synchronously, you must set the <CODE>async</CODE> parameter to <CODE>false</CODE> when using the <CODE>PBOpen</CODE> or <CODE>OpenSlot</CODE> functions. If a device driver is already open, the Device Manager simply returns the driver reference number.<P>
 The remaining Device Manager functions require your application to use the driver reference number, instead of the driver name, when referring to a device driver.<P>
 When you finish using a driver, you may want to close it. However, you do not normally close drivers that might be needed by the system or by other applications. Whether you should close a particular driver depends on the type of driver and how it is being used. Refer to the driver's documentation to determine if it should be closed. See the appropriate chapters in<I> </I>this book and other books in the <I>Inside Macintosh</I> series for information about standard Macintosh drivers.<P>
 If you do want to close a driver, you can use the high-level <CODE>CloseDriver</CODE> function or the low-level <CODE>PBClose</CODE> function. <A HREF=#MARKER-9-101>Listing 1-2</A> shows how to use the <CODE>PBClose</CODE> function to close the driver opened in <A HREF=#MARKER-9-100>Listing 1-1</A>.<P>
<B>Listing 1-2  <A NAME=MARKER-9-101></A>Closing a device driver</B><P>
<PRE>
OSErr MyCloseDriver(short refNum)
{
   IOParam  paramBlock;

   paramBlock.ioRefNum = refNum;

   return(PBClose((ParmBlkPtr)&amp;paramBlock, false));
}
</PRE>
 The <CODE>MyCloseDriver</CODE> function specifies the driver to close by placing the driver reference number in the <CODE>ioRefNum</CODE> field of the parameter block and then calls the Device Manager <CODE>PBClose</CODE> function. <P>
<A NAME=HEADING13-45></A>
<H2><A NAME=MARKER-2-174></A><A NAME=MARKER-9-103></A>Communicating With Device Drivers</H2>
 Once a device driver is open and you have its reference number, you can use Device Manager functions to exchange information with it. When you want to receive information from a device driver, you first allocate a data buffer to hold the information and then call the <CODE>FSRead</CODE> or <CODE>PBRead</CODE> function. To send information to a device driver, you first store the information in a data buffer and then call the <CODE>FSWrite</CODE> or <CODE>PBWrite</CODE> function. You must specify the number of bytes you want transferred when calling any of these functions.<P>
 <A NAME=MARKER-2-71></A><A NAME=MARKER-2-63></A>The <CODE>PBRead</CODE> and <CODE>PBWrite</CODE> functions support asynchronous requests, and allow you to specify a completion routine. For block devices you specify the drive number, positioning mode, and positioning offset in the <CODE>ioVRefNum</CODE>, <CODE>ioPosMode</CODE>, and <CODE>ioPosOffset</CODE> fields of the parameter block. The Device Manager does not interpret these fields--they are used by the device driver to locate the desired data block.<P>
 The Macintosh Operating System defines three positioning modes for block devices:<P>
<UL>
<LI>At the current position. Transfer begins at the current position on the <BR>medium--typically where the last transfer ended.
<LI>Offset from the start. Transfer begins at the specified offset from the beginning of the medium. 
<LI>Offset from the mark. Transfer begins at the specified offset from the current position. <P>
</UL>
 You specify the positioning mode by setting the <CODE>ioPosMode</CODE> field to one of the defined constants, <CODE>fsAtMark</CODE>, <CODE>fsFromStart</CODE>, or <CODE>fsFromMark</CODE>. Be sure you specify a mode that is compatible with the device.<P>
 On completion, the <CODE>PBRead</CODE> and <CODE>PBWrite</CODE> functions return in the <CODE>ioActCount</CODE> field of the parameter block the total number of bytes actually transferred. For block devices, these functions also return a new positioning offset in the <CODE>ioPosOffset</CODE> field.<P>
 Certain device drivers provide additional abilities with the read and write functions. For example, the Disk Driver allows you to use the <CODE>PBRead</CODE> function to verify that data written to a block device matches the data in memory. To do this, you add the <BR>read-verify constant <CODE>rdVerify</CODE> to the value in the <CODE>ioPosMode</CODE> field of the parameter block, as explained in the description of the <CODE>PBRead</CODE> function on <A HREF=Devices-32.html#MARKER-9-343>page 1-70</A>.<P>
 <A HREF=#MARKER-9-106>Listing 1-3</A> shows an example of how to read from a device driver. <P>
<B>Listing 1-3  Reading from a device driver<A NAME=MARKER-9-106></A></B><P>
<PRE>
OSErr MyReadFromDriver(short refNum)
{
   IOParam  paramBlock;
   char     buffer[256];

   paramBlock.ioRefNum = refNum;
   paramBlock.ioReqCount = 256;
   paramBlock.ioBuffer = (Ptr)buffer;

   return(PBRead((ParmBlkPtr)&amp;paramBlock, false));
}
</PRE>
 The <CODE>MyReadFromDriver</CODE> function uses a parameter block to specify the device driver (by its driver reference number), the number of bytes to read, and a pointer to a buffer to receive the data. When <CODE>MyReadFromDriver</CODE> calls the <CODE>PBRead</CODE> function, the Device Manager appends the parameter block to the end of the driver I/O queue. Because the <CODE>async</CODE> parameter is set to <CODE>false</CODE>, the Device Manager does not return control to <CODE>MyReadFromDriver</CODE> until the driver has completed every request in its queue.<P>
 <A HREF=#MARKER-9-107>Listing 1-4</A> shows an example of how to write to a device driver. <P>
<B>Listing 1-4  <A NAME=MARKER-9-107></A>Writing to a device driver</B><P>
<PRE>
OSErr MyWriteToDriver(short refNum)
{
   IOParam  paramBlock;
   char*    buffer;

   buffer = &quot;Data to Write&quot;;

   paramBlock.ioCompletion = nil;
   paramBlock.ioRefNum = refNum;
   paramBlock.ioBuffer = (Ptr)buffer;
   paramBlock.ioReqCount = strlen(buffer);
   
   return(PBWrite((ParmBlkPtr)&amp;paramBlock, false));
}
</PRE>
 The <CODE>MyWriteToDriver</CODE> function also uses a parameter block to transfer information to the driver. After filling in the necessary fields, <CODE>MyWriteToDriver</CODE> sends the parameter block to the <CODE>PBWrite</CODE> function. Because the <CODE>async</CODE> parameter is <CODE>false</CODE>, the Device Manager appends the parameter block to the end of the I/O queue and does not return control to the <CODE>MyWriteToDriver</CODE> function until the driver has completed the request.<P>
<A NAME=HEADING13-63></A>
<H2><A NAME=MARKER-2-191></A><A NAME=MARKER-9-109></A>Controlling and Monitoring Device Drivers</H2>
 In addition to the read and write functions, the Device Manager provides functions that allow your application to control and monitor device drivers in other ways. <P>
 <A NAME=MARKER-2-58></A>The <CODE>Control</CODE> and <CODE>PBControl</CODE> functions send commands to a driver. Because the types of commands to which drivers respond varies, you need to consult a driver's documentation to determine what commands it accepts. As an example, you can send a command to the Disk Driver requesting that it eject a disk.<P>
 <A NAME=MARKER-2-118></A>The <CODE>Status</CODE> and <CODE>PBStatus</CODE> functions return status<B> </B>information from a driver. Again, the type of information drivers provide varies widely. The Serial Driver, for example, can return a breakdown of the types of errors that have occurred recently.<P>
 The control and status functions use the <CODE>CntrlParam</CODE> structure of the <CODE>ParamBlockRec</CODE> union. This structure is defined in <A HREF=Devices-19.html#MARKER-9-219>"Device Manager Parameter Block,"</A> beginning on <A HREF=Devices-19.html#MARKER-9-219>page 1-53</A>.<P>
 Because of the diversity of device drivers, the control and status functions have two general-purpose parameters: <CODE>csCode</CODE> and <CODE>csParamPtr</CODE> (or <CODE>csParam</CODE> for the low-level <CODE>PBControl</CODE> and <CODE>PBStatus</CODE> functions). You indicate the type of control or status information you are requesting by placing a driver-specific code in the <CODE>csCode</CODE> parameter. You send or receive information using the <CODE>csParamPtr</CODE> parameter.<P>
 <A HREF=#MARKER-9-112>Listing 1-5</A> shows an example of how to send control and status requests to a device driver using the <CODE>PBControl</CODE> and <CODE>PBStatus</CODE> functions.<P>
<B>Listing 1-5  Controlling and monitoring a device driver<A NAME=MARKER-9-112></A></B><P>
<PRE>
OSErr MyIssueDriverControl(short refNum)
{
   CntrlParam  paramBlock;

   paramBlock.ioCRefNum = refNum;
   paramBlock.csCode = kClearAll;   /* driver-specific control request */

   return(PBControl((ParmBlkPtr)paramBlock, false));
}

OSErr MyGetDriverStatus(short refNum)
{
   CntrlParam  paramBlock;
   OSErr       myErr;
   short       count;

   paramBlock.ioCRefNum = refNum;
   paramBlock.csCode = kByteCount; /* driver-specific status request */

   myErr = PBStatus((ParmBlkPtr)&amp;paramBlock, false);

   count = paramBlock.csParam[0]; /* value returned in csParam array */
   if (myErr == noErr)
      return(count);
   else
      return(myErr);
}
</PRE>
 The <CODE>MyIssueDriverControl</CODE> and <CODE>MyGetDriverStatus</CODE> functions call the example device driver control and status routines shown in <A HREF=Devices-14.html#MARKER-9-166>Listing 1-12 on page 1-35</A> and <A HREF=Devices-14.html#MARKER-9-169>Listing 1-13 on page 1-36</A>.<P>
 The MyIssueDriverControl function begins by setting up the fields of a parameter block. The <CODE>ioCRefNum</CODE> field specifies the driver reference number, and the <CODE>csCode</CODE> field specifies the type of control information being sent. The <CODE>MyDriverControl</CODE> function shown in <A HREF=Devices-14.html#MARKER-9-166>Listing 1-12</A> interprets the driver-specific value <CODE>kClearAll</CODE> as a request for the device driver to clear the information in its private storage.<P>
 The MyGetDriverStatus function also begins by setting up the fields of a parameter block. The <CODE>ioCRefNum</CODE> field specifies the device driver reference number, and the <CODE>csCode</CODE> field specifies the type of status information being requested. The <CODE>MyDriverStatus</CODE> function shown in <A HREF=Devices-14.html#MARKER-9-169>Listing 1-13</A> interprets a value of <CODE>kByteCount</CODE> as a request to return the number of bytes transferred by the last I/O operation. This information is returned in the <CODE>csParam</CODE> field of the parameter block.<P>
<HR>
<B>Subtopics</B>
<B><!-- TOC --><DL>
<DT><A HREF="Devices-13.html#HEADING13-23">Opening and Closing Device Drivers</A>
<DD>
<DT><A HREF="Devices-13.html#HEADING13-45">Communicating With Device Drivers</A>
<DD>
<DT><A HREF="Devices-13.html#HEADING13-63">Controlling and Monitoring Device Drivers</A>
<DD>
</DL>
</B>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Devices-12.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Devices-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Devices-328.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Devices-14.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Devices-3.html">&copy; Apple Computer, Inc.</A><br>3 JUL 1996</center></font><P>
<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->
</BODY>
</HTML>  
