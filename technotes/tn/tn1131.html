<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 01-05-01 --><head><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note TN1131: Creating Desktop Printers on the Fly</title>    <meta name="keywords" content="Mac OS 8 LaserWriter creating desktop printers fly drivers">    <meta name="Description" content="Technical Note TN1131: This Technical Note documents themethod that Apple uses  to create desktop printers on thefly, without having the user go through Chooser. Includedis a discussion on Desktop Printing and sample code illustratinghow a DTP can be created for both a non-LaserWriter typeof printer driver, e.g.,  the StyleWriter printer drivers,and LaserWriter printer drivers. "><meta name="categories" content="Printing"><meta name="week-posted" content="Jun 1, 1998 - Jun 5, 1998"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002970" title="Creating Desktop Printers on the Fly"></a><A NAME="top"></A><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxPrinting-date.html">Printing</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Printing/idxCarbon-date.html" target="_blank">Printing > Carbon</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1131</div>
<div id="pageheadsub">Creating Desktop Printers on the Fly</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><center><table width="600" cellpadding="0" cellspacing="0" border="0">     <tr>         <td width=300 valign="top" align=left scope="row">             <table border="0" width="300" cellpadding="0" cellspacing="0">                 <tr>             <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                 </tr>                 <tr bgcolor="#e6e6e6">                     <td background="images/tnmenubody.gif" width=300 align=left>                         <span id="menutitle">                             CONTENTS                             <br>                             <br>                         </span>                     </td>                 </tr>                 <tr bgcolor="#e6e6e6">                     <td background="images/tnmenubody.gif" width=300 align=left>                         <!-- begin_toc -->                         <p id="menutext"><A HREF = "#Overview">Overview</A><BR><BR><A HREF = "#Desktop">What is Desktop Printing?</A><BR><BR><A HREF = "#Environment">Checking Your Environment</A><BR><BR><A HREF = "#Creating">Creating Desktop Printers for Apple Printers</A><BR><BR><A HREF = "#StyleWriters">StyleWriters</A><BR><BR><A HREF = "#LaserWriters">LaserWriters</A><BR><BR><A HREF = "#LaserWriter8.4.3">LaserWriter 8.4.3 and before (PAP only)</A><BR><BR><A HREF = "#LaserWriter8.5">LaserWriter 8.5.1 and above <BR>(PAP, LPR, IR, Hold, Translator, Custom)</A><BR><BR><A HREF = "#Summary">Summary</A><BR><BR><A HREF = "#References">References</A><BR><BR><A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                 </tr>                 <tr>                     <td width=300 align=left scope="row">                         <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                     </td>                 </tr>             </table>         </td>         <td width=300 valign="top" align=left>             <!-- begin_intro_text --><P id = "introtext">This Technote documents the method that Apple uses to create desktop printers on the fly, without having the user go through Chooser.  </p><TABLE BORDER=0 WIDTH=300><TR><td bgcolor="#E6E6E6" align=left><P id="introtext"><B>Note:</B><BR>Apple does not recommend that your application do this behind the user's back; however, to prevent hacks and future incompatibilities we are documenting our "supported" method.<br>We also recommend that if you do create a DTP for your user, you switch the DTP back to your user's original selection so as not to interfere with their printing selection for other applications.</p></TD></TR></TABLE><P id = "introtext">The Settings Library (<CODE>SettingsLib</CODE>), introduced in LaserWriter 8.5.1, allows applications to access and change the information created by LaserWriter 8 when a desktop printer is created. <CODE>SettingsLib</CODE> prevents contention over the printer database between different parts of a printer driver, different printer drivers, and other printer database clients such as the Desktop Print Monitor. The printer database is stored in the LaserWriter 8 preferences file. The Settings Library is especially useful for applications that previously relied on the format of the <code>PAPA</code> resource in the LaserWriter 8 driver. With the introduction of LaserWriter 8.5.1, the size of the <code>PAPA</code> resource changed, and applications that depended upon its size broke. Since the resource size may change again in the future, Apple has introduced this library to prevent such problems. This Technote overviews the Settings Library APIs.</P><!-- end_intro_text --><!-- begin_date --><h3>&nbsp;Updated: [Jun 01 1998]</h3><!-- end_date -->                </TD>             </TR>          </TABLE></center> <!-- end_header_box --><BR><BR><hr width=500 align=center><BR><BR>          <!-- begin_content --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=550><TR><td align="left"><A NAME="Overview"></A> <h2>Overview</h2><P>In 1994, Apple introduced the desktop printing architecture with the StyleWriter 1200 driver and LaserWriter 8.3. Since this introduction, many developers have asked Worldwide Developer Technical Support how to create desktop printers on the fly, without having the user go through Chooser. With the release of LaserWriter 8.5.1, Apple introduced one application, Desktop Printer Utility, that creates desktop printers for the user without the Chooser.</P>     <BR><P><A HREF="#top">Back to top</A></P>     <A Name="Desktop"></A><h2>What is Desktop Printing?</h2><P>Desktop printing is the mechanism that allows drag-and-drop document printing via a 'desktop printer' icon on the user's desktop. It is supported by Mac OS 8.x  (built-in) and System 7.x (with the  "Desktop Printer Extension" installed). Whenever the user selects a new printer using the Chooser, a Desktop Printer (DTP) is created to represent the newly selected default printer.  Once this is done, a printing job can be initiated by simply dragging a document and dropping it on the DTP.</p><P>You can write a program (much like Apple's Chooser or Desktop Printer Utility) to create different types of desktop printers.  Once a desktop printer is created by your program, the operating system--specifically the Desktop Printer Extension--treats it equally to those created by Chooser.</P><P>Each desktop printer is associated with a particular printer driver.  Desktop printers can currently be created for StyleWriters and LaserWriters. A future release of the Mac OS will enable third-party printer driver developers to take advantage of desktop printing.</P><H3>Background</H3><P>Once the user selects a printer with the Chooser control panel, this printer becomes the system-wide default printer driver.  The file specification and the file name of the selected printer driver are recorded in the "System" file.  Specifically, the <CODE>AliasRecord</CODE> of the selected printer driver is stored as resource type 'alis' with an ID of -8192.  The name of the printer driver is stored as resource type 'STR ' with an ID of -8192. </p><P>If the selected printer driver is of the LaserWriter type, then one more piece of information is also needed to uniquely identify the destination printer.  This piece of information is stored in the printer driver as a resource of type 'PAPA' and ID -8192.  Whenever a different physical printer on the AppleTalk network is chosen in the Chooser, the 'PAPA' resource is updated to reflect the change. </p><P>One of the many things the "Desktop Printer Extension" does is to monitor the change of the resources mentioned above.  When the resources change to reflect a newly selected default printer that does not yet have a desktop printer, Desktop Printer Extension will automatically make a new desktop printer to represent it.</p><P>To create a desktop printer, you need only change the three resources mentioned above.  </p><P><B>Warning</B>: While changing the content of resources 'STR '  -8192 in the System file and 'PAPA' in the LaserWriter driver, be sure not to change their length... it will cause problems if you do (see <A HREF = "tn1114.html">Technote 1114: "The Extended PAPA Resource").</A></p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Some Metrowerks PowerPlant classes are used in the following sample code.  Please refer to Metrowerks PowerPlant documentation for these classes.  C and C++ coding styles are both used in the sample code.  The code is listed for demonstration purposes only.</P></TD></TR></TABLE></CENTER><BR><BR>     <BR><P><A HREF="#top">Back to top</A></P><A NAME="Environment"></A><h2>Checking Your Environment</h2><P>In addition to your regular environment checking, you need to perform the following checks before attempting to create a desktop printer on the fly:</p><h3>Desktop Printer Extension</h3><P>The "Desktop Printer Extension" is required for any desktop printing.  For System 8.0 and later, the functionality is built-into the OS.  However, for 7.x systems, it is an add-on extension that can be found in the Extensions folder.</p>  <P>The code to check for the Desktop Printer Extension follows:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>// ------------------------------------------------------// checking for Desktop Printer Extension// ------------------------------------------------------enum { kGestaltPFEFeatures = 'dtpf' };Boolean HasDesktopExtension(){ OSErr err; Boolean hasIt = false; long gestaltResponse = NULL; err = Gestalt(kGestaltPFEFeatures, &amp;gestaltResponse); if(err == noErr)  hasIt = true; return hasIt;}</pre></TD></TR></TABLE></CENTER><BR><BR><h3>Finder Scripting extension</h3><P>Apple events are used to communicate between the printer driver and the Desktop Printer Extension. Therefore, you need to verify that the Finder Scripting Extension is installed.</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>// ------------------------------------------------------// checking for Finder Scripting// ------------------------------------------------------Boolean HasFinderScripting(){ long gestaltResponse = NULL; return ( (Gestalt(gestaltFinderAttr, &amp;gestaltResponse ) == noErr)  &amp;&amp; ((response &amp; (1L &lt;&lt; gestaltOSLCompliantFinder)) != 0) );}</pre></TD></TR></TABLE></CENTER><BR><BR><h3>Valid Printer Driver</h3><P>Each desktop printer must have a valid printer driver installed. You need to make sure that the printer driver for which you wish to create a desktop printer is installed in the system.  Here is some code for this given the file type and creator of a printer driver:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><TH align="left">File</TH><TH align="left">Type</TH><TH align="left">Creator </TH></TR><TR>    <td align="left">LaserWriter 8</TD>    <td align="left">'PRER'</TD>    <td align="left">'vgrd'</TD></TR><TR>    <td align="left">StyleWriter 1200</TD>    <td align="left">'PRER'</TD>    <td align="left">'dblo'</TD></TR><TR>    <td align="left">StyleWriter 2500</TD>    <td align="left">'PRER'</TD>    <td align="left">'auro'</TD></TR></TABLE></center><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>// --------------------------------------------------------------// Find the printer driver in the system extensions folder w/ the// specified minimum version, type and creator// Note: This routine does not return an error code. If any error// should happen, it'll be thrown to the caller w/ C++ exception// handling.// The caller should be prepared to handle errors including eofErr// which indicates that the printer driver is not found.// Parameters:// inMinVersion- specify printer driver's minimum version// inFileType - specify printer driver's file type// inCreator - specify printer driver's creator// outPrinterDrvrFsSpec - return the printer driver's FSSpec if// found// --------------------------------------------------------------void FindPrinterDriver(unsigned short inMinVersion, OSType inFileType, OSType inCreatorvoid FSSpec&amp; outPrinterDrvrFsSpec ){OSErr err;const long kSearchBufSize = 16 * 1024;short savedResFile = CurResFile();short startupVRefNum;long extDirID; // of extensions folderCInfoPBRec targetPb;CInfoPBRec maskPb;CSParam catSearchPb;FSSpec foundFsSpec;StPointerBlock searchBuf(kSearchBufSize); // buffer for PBCatSearchBoolean foundOne = false; err = FindFolder(-1, kExtensionFolderType, FALSE, &amp;startupVRefNum, &amp;extDirID); ThrowIfOSErr_(err); targetPb.hFileInfo.ioFlFndrInfo.fdType = inFileType; targetPb.hFileInfo.ioFlFndrInfo.fdCreator = inCreator; targetPb.hFileInfo.ioNamePtr = 0; targetPb.hFileInfo.ioFlAttrib = 0x00; // search for file only targetPb.hFileInfo.ioFlParID = extDirID; // in extensions folder only maskPb.hFileInfo.ioFlFndrInfo.fdType = 0xFFFFFFFF; maskPb.hFileInfo.ioFlFndrInfo.fdCreator = 0xFFFFFFFF; maskPb.hFileInfo.ioFlFndrInfo.fdFlags = 0; maskPb.hFileInfo.ioFlFndrInfo.fdLocation.h = 0; maskPb.hFileInfo.ioFlFndrInfo.fdLocation.v = 0; maskPb.hFileInfo.ioFlFndrInfo.fdFldr = 0; maskPb.hFileInfo.ioNamePtr = 0; maskPb.hFileInfo.ioFlAttrib = 0x10;  // directory bit maskPb.hFileInfo.ioFlParID = extDirID; // in extensions folder only Try_{  catSearchPb.ioCatPosition.initialize = 0;  while(!foundOne ){   catSearchPb.ioCompletion = 0;   catSearchPb.ioNamePtr = 0;   catSearchPb.ioVRefNum = startupVRefNum;   catSearchPb.ioMatchPtr = &amp;foundFsSpec;   catSearchPb.ioReqMatchCount = 1;   catSearchPb.ioSearchBits = fsSBFlAttrib +      fsSBFlFndrInfo + fsSBFlParID;   catSearchPb.ioSearchInfo1 = &amp;targetPb;   catSearchPb.ioSearchInfo2 = &amp;maskPb;   catSearchPb.ioSearchTime = 0;   catSearchPb.ioOptBuffer = (Ptr)searchBuf;   catSearchPb.ioOptBufSize = kSearchBufSize;   err = PBCatSearchSync(&amp;catSearchPb);   ThrowIfOSErr_(err);    // found one w/ the specified type and creator   LFile thePrDrFile(foundFsSpec);   Try_{    thePrDrFile.OpenResourceFork(fsRdPerm);    // version of printer driver    StResource versRsrc('vers', 1, true, true);    // compare against minimum version    if(**(unsigned short **)(Handle)versRsrc &gt;= inMinVersion){     // found one meeting the version requirement     outPrinterDrvrFsSpec = foundFsSpec;     foundOne = true; // get out of the loop    }    thePrDrFile.CloseResourceFork();   }Catch_(inErr){    thePrDrFile.CloseResourceFork();    // don't throw   }EndCatch_  } // while }Catch_(inErr){  // restore default resource file  UseResFile(savedResFile);  Throw_(inErr); }EndCatch_}</pre></TD></TR></TABLE></CENTER><BR><BR>     <BR><P><A HREF="#top">Back to top</A></P>           <A NAME="Creating"></A><h2>Creating Desktop Printers for       Apple Printers</h2><A NAME="StyleWriters"></A><h2>StyleWriters</h2><P>This section demonstrates how a DTP can be created for a non-LaserWritertype of printer driver, e.g., the StyleWriter printer drivers.  First, we need some utility routines to change the resources in System file and printer driver's file:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>// ---------------------------------------------------------------------------// SetResource// This routine change the content of an existing resource to the new content// pointed to by inNewContentH.  The resource file containing the target resource// must be open and set to the current resource file before this routine is// called.// ---------------------------------------------------------------------------voidSetResource(ResType inResType, ResID inResID, Handle inNewContentH){ // get the resource to be changed oldResH = Get1Resource(inResType, inResID); // be sure to handle error when the resource doesn't exist (oldResH == 0) char savedInHdlState = HGetState(inNewContentH);  char savedRsrcHdlState = HGetState(oldResH ); Size sz = GetHandleSize(inNewContentH); HUnlock(oldResH ); SetHandleSize(oldResH, sz); // match sizes ThrowIfMemError_(); HLock(oldResH ); HLock(inNewContentH); BlockMove(*inNewContentH, *oldResH, sz); // copy content HSetState(inNewContentH, savedInHdlState); HSetState(oldResH , savedRsrcHdlState); ChangedResource(oldResH); // mark dirty WriteResource(oldResH); ThrowIfResError_(); UpdateResFile(CurResFile());}// ---------------------------------------------------------------------------// SetStrResource// This routine changes the content of an existing 'STR ' resource to the new// content pointed to by inStrP.  The resource file containing the target// resource must be open and set to the current resource file before this routine// is called.  Pay special attention to how we avoid to shrink existing resource.// ---------------------------------------------------------------------------voidSetStrResource(ResType inResType, ResID inResID, ConstStringPtr inStrP ){ // get the resource to be changed oldResH = Get1Resource(inResType, inResID); // be sure to handle error when the resource doesn't exist (oldResH == 0) Size sz = *inStrP + 1; /* If the string is longer than the handle, then  grow the handle. */ if(sz &gt; GetHandleSize(oldResH )){  char savedRsrcHdlState = HGetState(oldResH );  HUnlock(oldResH );  SetHandleSize(oldResH , sz);  ThrowIfMemError_();  HSetState(oldResH , savedRsrcHdlState); } BlockMoveData(inStrP, *oldResH , sz); ChangedResource(oldResH ); WriteResource(oldResH); ThrowIfResError_(); UpdateResFile(CurResFile());}</pre></TD></TR></TABLE></CENTER><BR><BR><P>Because Desktop Printer Extension is implemented as a Finder extension, we need to talk to Finder in order to communicate with it. The following routines are needed for this purpose:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>// ---------------------------------------------------------------------------// Create the Finder address we wish to send our Apple Event to;// Note that we mean here &quot;Finder&quot; in the most generic sense;// In reality, this can be the Finder or AtEase.// ---------------------------------------------------------------------------OSStatus getFinderAddress(AEAddressDesc *theDesc){   OSErr               result = noErr;   ProcessInfoRec      processInfo;   ProcessSerialNumber serialNumber;   serialNumber.highLongOfPSN = 0;   serialNumber.lowLongOfPSN = kNoProcess;   while ((result = GetNextProcess(&amp;serialNumber)) == noErr)   {       processInfo.processInfoLength = sizeof(ProcessInfoRec);       processInfo.processName     = nil;       processInfo.processAppSpec  = nil;       result = GetProcessInformation(&amp;serialNumber, &amp;processInfo);       if (result == noErr){           if ( processInfo.processType == 'FNDR' ){               result = AECreateDesc(typeProcessSerialNumber, (Ptr)&amp;serialNumber,sizeof(ProcessSerialNumber), theDesc);               return(result);           }       }   }   return(result);}// ---------------------------------------------------------------------------// Send an Apple event to the Finder. The data for the event is pointed to// by 'dataPtr' and is 'dataSize' bytes long.// Note that the data is sub-typed so the Finder can decipher the contents.// ---------------------------------------------------------------------------#define kFinderExtension       'fext'static OSStatus sendAEToFinder( Ptr dataPtr, Size dataSize){ OSStatus  err = noErr; // the address of the Finder as an Apple event Descriptor AEAddressDesc  finderAddr; AppleEvent      theEvent; AppleEvent      replyEvent;   err = getFinderAddress(&amp;finderAddr); if (err == noErr) {       err = AECreateAppleEvent(           kCoreEventClass,        // this is a core event           kFinderExtension,       // for a Finder extension           &amp;finderAddr,            // and we send it to the Finder           kAutoGenerateReturnID,  // we aren't getting a return           kAnyTransactionID,      // and we don't care about the transaction #           &amp;theEvent);             // and we create it right here       if (err == noErr)       {           err = AEPutParamPtr(               &amp;theEvent,          // the event to shove into               keyDirectObject,    // direct object keyword               kFinderExtension,   // for the Finder extension               dataPtr,            // here's the data!               dataSize);          // here's how long it is!           if (err == noErr)           {               err = AESend(                   &amp;theEvent,          // send the status event                   &amp;replyEvent,        // no reply event because -                   kAENoReply +        // we don't want a reply                    kAECanInteract +   // the receiver can interact with user                    kAEDontReconnect,  // and don't bother to reconnect on error                   kAENormalPriority,  // just a normal event                   kAEDefaultTimeout,  // we'll wait some reasonable amount of time                   nil, nil);          // and don't care what happens during that.           }                                       // now get rid of the Apple event           (void) AEDisposeDesc(&amp;theEvent);       }                                       // and get rid of the Finder address       (void) AEDisposeDesc(&amp;finderAddr);   }                                       // Fall through and return error, if any   return(err);}</pre></TD></TR></TABLE></CENTER><BR><BR><P>Although the Desktop Printer Extension can detect newly selected current printer automatically,  it does this by checking the related resources in its idle time.  This can take a while to happen; therefore, to get better performance, the following routine sends an Apple event to notify Desktop Printer Extension of the new printer:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>// ---------------------------------------------------------------------------// nessieCreateDTP// Send an Apple event to Desktop Printer Extension asking it to create a new// DTP for the current printer.// ---------------------------------------------------------------------------#define kPrintingExtension     'dtpx'#define aePFECreateDTP         'pfcr'typedef struct{   OSType      pfeCreator;   OSType      extensionType;} CreateDTPEvent;// ---------------------------------------------------------------------------// Notify Desktop Printer Extension/Finder the current printer has changed// ---------------------------------------------------------------------------OSStatus nessieCreateDTP(){ OSStatus err; CreateDTPEvent  myEvent; myEvent.pfeCreator = kPrintingExtension; myEvent.extensionType = aePFECreateDTP; // because Desktop Printer Extension is a Finder extension err = sendAEToFinder((Ptr) &amp;myEvent, sizeof(myEvent));    return err;}</pre></TD></TR></TABLE></CENTER><BR><BR><P>After the resources specifying the current printer have been properly set up and the notification to Desktop Printer Extension is sent, you still have to verify that the DTP is actually created.  The data structure <CODE>DTPInfo</CODE> is used just for this:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef struct DTPInfo{   short    vRefNum;    // vRefNum of the DTP folder   long  dirID;         // directory ID of the DTP folder   Str31    DTPName;    // name of the DTP folder   OSType   driverType; // creator type of the print driver for this DTP   Boolean  current;    // is this DTP currently the default printer   Str32 printerName;   // name of the acutal printer on the net (only for LW8.4)   Str32 zoneName;      // zone where this printer resides (only for LW8.4 DTPs)} DTPInfo, *DTPInfoPtr, **DTPInfoHdl;</pre></TD></TR></TABLE></CENTER><BR><BR><P>The way to get information about DTPs is to make a <CODE>Gestalt</CODE> call to the Desktop Printer Extension.  A list of <CODE>DTPInfo</CODE> is returned by the <CODE>Gestalt</CODE> call.  Each <CODE>DTPInfo</CODE> record in the list describes a single DTP.  You can walk down the list and examine the content of the <CODE>DTPInfo</CODE> to decide if the DTP of interest is created.  The following routines demonstrate how to do this:</p></TD></TR></TABLE></CENTER><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>#define errDTPNotFound -1#define kGestaltPFEInfo  'dtpx'enum{     kOldPFEGestaltStructVersion     = 0x02008000,     // version 2.0f0 (for Mac OS 8.0, 8.1 and 7.x)     kPFEGestaltStructVersion        = 0x03000000     // version 3.0 (for Allegro)};// GestaltDTPInfotypedef struct{        short   vRefNum;       // vRefNum of the DTP folder        long    dirID;         // directory ID of the DTP folder        Str31   dtpName;       // name of the DTP folder        OSType  driverType;    // creator type of the print driver for this DTP        Boolean current;       // is this DTP currently the default printer?        Str32   printerName;   // name of the acutal printer on the                               // net (only for LaserWriter 8 dtps)        Str32   zoneName;      // zone where this printer resides                               // (only for LaserWriter 8 dtps)} GestaltDTPInfo, *GestaltDTPInfoPtr;// data associated with the pfe gestalttypedef struct{        long    version;             // kPFEGestaltStructVersion        short   numDTPs;             // number of the active dtps        Handle  theDTPList;          // handle to a list of                                     // GestaltDTPInfo for the active dtps        Handle  theDTPDriverList;    // handle to a list of drivers' files specs        Handle  theDTPMoreInfoList;  // Apple's Internal use only.} GestaltPFEInfo, **GestaltPFEInfoHdl;// ---------------------------------------------------------------------------// Look through the list of DTP's looking for a DTP// that describes the printer with the network address// 'papaH' and associated with a printer driver whose file spec is// *printerDrvrFsSpecP.// papaH is ignored if it's NULL.// printerDrvrFsSpecP is ignored if it's NULL.//// If a match is found, then noErr is returned.// If a match can not be found then an error is returned.// If the caller wants information about the matched// printer, then on entry, *'DTPInfoP' should be non-NULL// and point to an allocated DTPInfo structure.// ---------------------------------------------------------------------------OSStatusnessieFindDTP(Handle papaH, FSSpec *printerDrvrFsSpecP, DTPInfo *DTPInfoP){ DTPInfoPtr found = NULL; GestaltPFEInfoHdl gestaltResponse; char papaHState; OSStatus err; if(papaH){  papaHState = HGetState(papaH);  HLock(papaH); } err = Gestalt(kGestaltPFEInfo, (long *)&amp;gestaltResponse); if(!err &amp;&amp; gestaltResponse != NULL){  int numDTPs = (*gestaltResponse)-&gt;numDTPs;  DTPInfoHdl DTPH = (*gestaltResponse)-&gt;theDTPList;  FSSpec** driverH = (*gestaltResponse)-&gt;theDTPDriverList;  err = errDTPNotFound;  if((numDTPs &gt; 0) &amp;&amp; (DTPH != NULL) &amp;&amp; (driverH != NULL)){   DTPInfoPtr DTP;   FSSpec *driverP;   char DTPState = HGetState((Handle)DTPH);   char driverListState = HGetState((Handle)driverH);   HLock((Handle)DTPH);   HLock((Handle)driverH);   DTP = *DTPH;   driverP = *driverH;   if((DTP != NULL) &amp;&amp; (driverP != NULL)){    StringPtr printerStr;      // Points to printer's name    StringPtr zoneStr;         // Will point to zone name (first we                               // skip object type).    int i;    if(papaH){     printerStr = (StringPtr)*papaH;          // Points to printer's name     zoneStr = printerStr + *printerStr + 1;  // Will point to zone name                                              // (first we skip object type).     zoneStr += *zoneStr + 1;                 // Now points to zone name.    }    for(i = 0; i &lt; numDTPs &amp;&amp; found == NULL;    ++i, ++DTP, ++driverP){     // This DTP matches the one we want if it's     // created with the specified printer driver and     // the zone and printer names match.     if(papaH){      if(((printerDrvrFsSpecP == NULL) ||       ((printerDrvrFsSpecP-&gt;vRefNum == driverP-&gt;vRefNum) &amp;&amp;(printerDrvrFsSpecP-&gt;parID == driverP-&gt;parID) &amp;&amp;(EqualString(printerDrvrFsSpecP-&gt;name, driverP-&gt;name, false, false)))) &amp;&amp;      EqualString(printerStr, DTP-&gt;printerName, false, false) &amp;&amp;EqualString(zoneStr, DTP-&gt;zoneName, false, false)){       found = DTP;      }     }else{      if((printerDrvrFsSpecP != NULL) &amp;&amp;       ((printerDrvrFsSpecP-&gt;vRefNum == driverP-&gt;vRefNum) &amp;&amp;       (printerDrvrFsSpecP-&gt;parID == driverP-&gt;parID) &amp;&amp;      (EqualString(printerDrvrFsSpecP-&gt;name, driverP-&gt;name, false, false)))){       found = DTP;      }     }    }    if(found != NULL){     if(DTPInfoP) *DTPInfoP = *found;    }   }   HSetState((Handle)driverH, driverListState);   HSetState((Handle)DTPH, DTPState);  } } if(papaH)  HSetState(papaH, papaHState); return found == NULL ? errDTPNotFound : noErr;}// ---------------------------------------------------------------------------// Given a FSSpec of a printer driver, this routine can decide if its DTP exists// ---------------------------------------------------------------------------Boolean HasDTP(DTPInfo *DTPInfoP, FSSpec *prDriverFsSpecP){ OSStatus err; err = nessieFindDTP(NULL, prDriverFsSpecP, DTPInfoP); return(!err);}</pre></TD></TR></TABLE></CENTER><BR><BR><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left">      <P>With the help of the routines above, we are now ready to create our first DTP.  This example demonstrates how to create a DTP for a non-LaserWriter type of printer driver.  For LaserWriter (LW) DTP, you need to call the routine named <CODE>LaserWriterExtra()</CODE> which is commented out here.  (See the LaserWriter sections for more detail.)</p><P>After verifying the environment, we try to locate the printer driver.  In the System file, we then change the two resources specifying the current printer driver, notify Desktop Printer Extension of the change, and wait for the new DTP to be made.  Note how we stay in the wait loop.  Within this loop, make sure you yield control to Finder by <CODE>EventAvail</CODE> or <CODE>WaitNextEvent</CODE>. Without this, Desktop Printer Extension/Finder would NOT have an opportunity to create the DTP for you:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>#define kWaitForDTPTime   (60 * 20)// ---------------------------------------------------------------------------// CreateDTP// This routine demonstrates how to create a DTP for StyleWriter1200// ---------------------------------------------------------------------------voidCreateDTP(){ OSErr err; short savedResFile = CurResFile(); FSSpec printerDriverFSSpec; AliasHandle theAlias; EventRecord eventRec; unsigned long endTime = TickCount() + kWaitForDTPTime; DTPInfo DTPInfo;                    // checking the environment                    // make sure we have Desktop Printer Extension                    // and Finder Scripting Extension if(HasDesktopExtension() &amp;&amp; HasFinderScripting()){  Try_{   FindPrinterDriver(0x0120,    'PRER', 'dblo', FSSpec&amp; // StyleWriter1200    printerDriverFSSpec);   /* if you are creating DTP for LaserWriter type of      printer driver, you'll need to write some more      code here.      Let's call LaserWriterExtra();   */   UseResFile(0);   // system file                    // make alias for printer driver   err = NewAlias(nil, &amp;printerDriverFSSpec, &amp;theAlias);   ThrowIfOSErr_(err);                    // set current printer to our printer driver   SetResource('alis', -8192, theAlias);   SetStrResource('STR ', -8192, printerDriverFSSpec.name);   DisposeHandle(theAlias);                    // we should notify Desktop Printer Extension                    // that we have changed the default printer   err = nessieCreateDTP();                    // verify that the DTP is created   do{                    // give Desktop Printer Extension a chance                    // to handle the request to create DTP    EventAvail(everyEvent, &amp;eventRec);    newDTPMade = HasDTP(&amp;DTPInfo,  &amp;printerDriverFSSpec);   }while((TickCount() &lt; endTime) &amp;&amp; (newDTPMade == FALSE));                    // until either the DTP is made or time-out  }Catch_(inErr){                    // handle error...  }EndCatch_ } UseResFile(savedResFile);}</pre></TD></TR></TABLE></CENTER><BR><BR>     <BR><P><A HREF="#top">Back to top</A></P><A NAME="LaserWriters"></A><h2>Creating A Desktop Printer for the LaserWriter</h2><P>If you are writing code to create a DTP for the LaserWriter, you simply need to make some minor modifications to the routine <CODE>CreateDTP()</CODE>.</p><P>Instead of passing the creator for StyleWriter, use LaserWriter's creator where <CODE>FindPrinterDriver</CODE> is called.  You should also call the routine <CODE>LaserWriterExtra()</CODE>, which is commented out in the example above. <CODE>LaserWriterExtra()</CODE> should change the 'PAPA'  -8192 resource in the LaserWriter printer driver to point to your new printer.</p><P>The routine LaserWriterExtra() varies between LaserWriter 8.5.1 and the earlier versions.  For 8.5.1, this routine can change further depending on the type of the DTP.</p>     <BR><P><A HREF="#top">Back to top</A></P><A NAME="LaserWriter8.4.3"></A><h2>LaserWriter 8.4.3 and before (PAP only)</h2><P>Only an AppleTalk (PAP) DTP can be created for pre-8.5.1 LW.  These drivers support only the original 103-byte long 'PAPA' resource. The <CODE>LaserWriterExtra()</CODE> might look something like this:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>// ---------------------------------------------------------------------------// LaserWriterExtra for pre-8.5.1 LW// point current printer to target// ---------------------------------------------------------------------------LaserWriterExtra(FSSpec *printerDrvrFsSpecP,   ConstStr32Param inZone,   ConstStr32Param inPrinterName){ OSErr err; char papaState; short refNum; Handle papaH; short savedResFile = CurResFile(); // open printer driver resource fork err = FSpOpenResFile(printerDrvrFsSpecP, fsWrPerm); // handle error... // get PAPA resource from printer driver papaH= Get1Resource('PAPA' , -8192); // handle error...    papaState = HGetState(papaH); HLock(papaH); // change PAPA resource content NBPSetEntity(*papaH, (ConstStr32Param)StringPtr(inPrinterName),   (ConstStr32Param)(&quot;\pLaserWriter&quot;),   (ConstStr32Param)inZone); HSetState(papaH, papaState ); ChangedResource(papaH); // mark dirty WriteResource(papaH);   // update resource err = FSClose(refNum); UseResFile(savedResFile);}</pre></TD></TR></TABLE></CENTER><BR><BR>     <BR><P><A HREF="#top">Back to top</A></P><A NAME="LaserWriter8.5"></A><h2>For LaserWriter 8.5.1 and Greater</h2><P>LaserWriter 8.5.1 supports extended PAPA (1024 bytes in length).  Using the extended PAPA,  different types of desktop printers can be created to represent different types of virtual or physical printers, in addition to the original AppleTalk "PAP" printer.   Printing to these different types of DTPs will have different effects.  A "Hold" DTP is one that can only accept spool files.  "PostScript Translator" DTP is one that can translate the printed document into a PostScript document.  "Custom" DTP can launch a pre-specified application and instruct it to open the converted PostScript document.  "LPR" DTP allows printing to a printer/spooler understanding LPR protocol.  "Infrared" DTP allows printing to a LaserWriter with infrared communication port.  For extended PAPA details, see <A HREF = "tn1115.html">Technote 1115: "The Extended 'PAPA' Resource"</A>.</p><P><CODE>PrintingLib</CODE> provides some routines for fabricating extended PAPA so programmers don't have to understand its internal structure  See <A HREF = "tn1129.html">Technote 1129: "The Settings Library"</A> for details.</p><P>Before changing the PAPA resource in LaserWriter driver to create a DTP, you must also set additional parameters to fully specify a DTP.  Examples of these parameters for currently defined DTPs are PPD files for all types of DTP, domain name address for LPR DTPs, destination folder for Translator DTPs and target application for Custom DTPs.</p><P>The parameters are listed below:</p>     <TABLE border="1" cellpadding="1"><TR><TH>Collection Tag</TH><TH>Tag ID</TH><TH>DTP Type</TH><TH>parameter</TH></TR><TR>    <TD align=center align="left">'pppd'</TD>        <TD align=center align="left">1</TD>        <TD align=center align="left">all</TD>        <TD align=center align="left">parsed PPD FSSpec</TD></TR><TR>    <TD align=center align="left">'ppd '</TD>    <TD align=center align="left">1</TD>    <TD align=center align="left">all</TD>    <TD align=center align="left">additional PPD specification</TD></TR><TR>    <TD align=center align="left">'LpIa'</TD>    <TD align=center align="left">1</TD>    <TD align=center align="left">LPR</TD>    <TD align=center align="left">domain address of printer</TD></TR><TR>    <TD align=center align="left">'Svap'</TD>    <TD align=center align="left">1</TD>    <TD align=center align="left">Translator</TD>    <TD align=center align="left">save to file preference</TD></TR><TR>    <TD align=center align="left">'Pdka'</TD>    <TD align=center align="left">1</TD>    <TD align=center align="left">Translator</TD>    <TD align=center align="left">destination folder alias</TD></TR><TR>    <TD align=center align="left">'TGap'</TD>    <TD align=center align="left">1</TD>    <TD align=center align="left">Custom</TD>    <TD align=center align="left">post-process application alias</TD></TR><TR>    <TD align=center align="left">'pslv'</TD>    <TD align=center align="left">1</TD>    <TD align=center align="left">Custom</TD>    <TD align=center align="left">postscript level</TD></TR><TR>    <TD align=center align="left">'bnok'</TD>    <TD align=center align="left">1</TD>    <TD align=center align="left">Custom</TD>    <TD align=center align="left">use of binary data</TD></TR><TR>    <TD align=center align="left">'jobt'</TD>    <TD align=center align="left">1</TD>    <TD align=center align="left">Custom</TD>    <TD align=center align="left">type of postscript </TD></TR><TR>    <TD align=center align="left">'font'</TD>    <TD align=center align="left">1</TD>    <TD align=center align="left">Custom</TD>    <TD align=center align="left">font handling</TD></TR><TR>    <TD align=center align="left">'CsDs'</TD>    <TD align=center align="left">1</TD>    <TD align=center align="left">Custom</TD>    <TD align=center align="left">post-process application description</TD></TR></TABLE><P>These parameters are stored as hints within collections, which are then saved in LaserWriter's preference file.  These hints are identified by collection tags and IDs.  The meaning and data structure associated with each parameter are explained below with more details in the sections where they are used.</p><P><CODE>PrintingLib</CODE> provides some routines for accessing these collections.  See <I>The Settings Library</I> documentation for details.  These routines should be used to access the collections, and some of the routines might require the name of the printer driver's preference file.  For LaserWriter, the name of the preference file is stored as 'STR ' resource, ID -8185 within the LaserWriter file.</p><P>A routine to add a hint to a DTP's collection might look like this:</p>           <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>#define kNoCollection -2OSErr psStorePrinterName(Collection prInfo, Handle papa);/* store a normalized EntityName into collection prInfo *//* add a hint to a DTP's collection The memory block pointed by 'bufP' of length 'size' is added as a hint of 'tag' and   'id' to the DTPwhose PAPA is specified by 'papaH'. Note: the resource fork of LaserWriter must be open before this routine    is called.*/OSErr addHint(Handle papaH, CollectionTag tag, long id, long size, void *bufP){ Handle lwPrefFileNameH; char savedHandleState; Collection DTPCollection; // we need the name of LW's pref. file lwPrefFileNameH= GetString(-8185 ); // don't forget to handle error savedHandleState = HGetState(inHandle); HLock(lwPrefFileNameH); // use routine in SettingsLib to get the collection and add item DTPCollection= psGetPrefsPrinterInfo((StringPtr)(*lwPrefFileNameH), papaH); if(DTPCollection== nil)  // don't forget to handle error  err = kNoCollection; err = psStorePrinterName(DTPCollection, papaH); // handle error err = AddCollectionItem(DTPCollection, tag, id, size, bufP); // handle error err = psUpdatePrefsPrinterInfo(*lwPrefFileNameH, papaH, DTPCollection); DisposeCollection(DTPCollection); // clean up HSetState(lwPrefFileNameH, savedHandleState ); ReleaseResource(lwPrefFileNameH); return (err);}</pre></TD></TR></TABLE></CENTER><BR><BR><P>PPD files can be specified for all different types of DTP.  The following routine shows how this can be done:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus psGetPPDInfo(FSSpecPtr driver, Handle papaH,long structVersion, PrinterPPDInfo *ppdInfo);/* Return the PPD information for the printer specified by 'papaH' for the printer specified by 'driver'. The PPD information is returned in *'ppdInfo'. The caller must pass in the version of the PrinterPPDInfo structure being used, this should be the constant 'kPPDInfoStructVersion'. If the caller's structure is not compatable with the routine, then the routine returns ' errWrongStructVersion'.*/OSStatus psSetPPDInfo(FSSpecPtr driver, Handle papaH,long structVersion, PrinterPPDInfo *ppdInfo);/* Set the ppd file and the parsed ppd file for the printer driver specified by 'driver' and the printer specified by 'papaH'. The FSSpec's of the PPD file and the parsed PPD file are passed in the structure pointed to by' ppdInfo' along with a flag indicating whether the generic PPD should be used. If the generic PPD flag is set, then only the parsed PPD FSSpec need be valid. 'structVersion' indicates the version of the PrinterPPDInfo structure the caller is using. The caller should pass in the constant*/OSErr ppdGetParseFolder(FSSpecPtr parseFolder);/* Fill in the FSSpec pointed to by 'parseFolder' with the 'vRefNum' and 'parID' of the parsed PPD folder. The client can place a parsed PPD file name into the FSSpec's 'name' field and then use the File Manager's Open call's to open a parsed PPD. Note that *parseFolder' is not the FSSpec of the parsed PPD folder.*/OSErr ppdParseFile (const FSSpec *ppdFileSpec, short compiledRef, short compiledResFRef,  PPDParseErr *errInfoP);/* Parse a PPD file, and all its includes. FSSpecPtr will be closed upon exit. The PPD is parsed into the open file with the file reference 'compiledRef'. If compiledResFRef is not -1, the resource fork of the ppd file is copied into it. If 'errInfoP' is not NULL, then any error information is returned in *'errInfoP'.*/enum PPDPresetSource { kPPDSourceUnknown = -1, kPPDSourceRSRC = 0, kPPDSourceGeneric = 1, kPPDSourceCustom = 2};typedef enum{ kTriFalse = 0, kTriTrue, kTriUnknown} TriState;struct CustPPDInfo { Boolean   usePPD; FSSpec   fileSpec;};typedef struct CustPPDInfo CustPPDInfo, **CustPPDHandle;typedef struct { short presetSource;  /* enum PPDPresetSource */ TriState isSetup; CustPPDInfo customPPD;} WhatPPD;typedef struct PrinterPPDInfo{ long  structVersion;     // Identifies the version of the rest of this structure. Boolean  useGenericPPD;  // True if the generic PPD should be used. FSSpec  ppdFile;         // FSSpec of the current PPD file. FSSpec  parsedPPDFile;   // FSSpec of the parsed PPD file for the printer.}PrinterPPDInfo;/*This routine parse a ppd file specified ppdFsSpecand add the corresponding hints to a DTP specifiedby papaH*/OSErr SetPPD(FSSpec* ppdFsSpecP, Handle papaH, FSSpec* laserWriterFsSpecP){ OSErr err = noErr; FSSpec parsedPPD; WhatPPD whatPPD; short savedResFile = ::CurResFile(); Boolean isGeneric = false; short dataForkRefNum, resourceForkRefNum; PrinterPPDInfo ppdInfo; // default whatPPD.presetSource = kPPDSourceCustom; whatPPD.isSetup = kTriTrue; whatPPD.customPPD.usePPD = TRUE; whatPPD.customPPD.fileSpec = *ppdFsSpecP; // prepare parsed PPD FSSpec err = ppdGetParseFolder(&amp;parsedPPD); ThrowIfOSErr_(err); CopyPStr(ppdFsSpecP-&gt;name, parsedPPD.name, sizeof(parsedPPD.name)); // create parsed file and open its resource/data fork FSpCreateResFile(&amp;parsedPPD, 'vgrd', 'Pref', smSystemScript); err = SpOpenDF(&amp;parsedPPD, fsRdWrPerm, &amp;dataForkRefNum); resourceForkRefNum = ::FSpOpenResFile(&amp;parsedPPD, fsRdWrPerm); // parse ppd err = ppdParseFile (ppdFsSpecP, dataForkRefNum, resourceForkRefNum, NULL); // close resource/data fork CloseResFile(resourceForkRefNum); err = FSClose(dataForkRefNum); UseResFile(savedResFile); // associate the ppd with the printer err = addHint(papaH, 'pppd', 1, sizeof(parsedPPD), &amp;parsedPPD); err = addHint(papaH, 'ppd ', 1, sizeof(whatPPD), &amp;whatPPD); // set default hints err = psGetPPDInfo(laserWriterFsSpecP, papaH, 2, &amp;ppdInfo); if(!err) err = psSetPPDInfo(laserWriterFsSpecP, papaH, 2, &amp;ppdInfo); return (err);}</pre></TD></TR></TABLE></CENTER><BR><BR><h3>Creating A PAP Desktop Printer for the LaserWriter</h3><P>The <CODE>LaserWriterExtra</CODE> for PAP DTP might look like this:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>// ---------------------------------------------------------------------------// LaserWriterExtra for 8.5.1 LW// point current printer to target// ---------------------------------------------------------------------------LaserWriterExtra(FSSpec *printerDrvrFsSpecP,   ConstStr32Param inZone,   ConstStr32Param inPrinterName){ OSErr err; short refNum; Handle papaH; short savedResFile = CurResFile(); SSpec ppdFsSpec; // open printer driver resource fork err = FSpOpenResFile(printerDrvrFsSpecP, fsWrPerm, &amp;refNum); // handle error... // get PAPA resource from printer driver papaH= Get1Resource('PAPA' , -8192); // handle error... // change PAPA resource content // See SettingsLib Spec  for psSetPapPapa err = psSetPapPapa(papaH, inPrinterName,  (const Byte *)(&quot;\pLaserWriter&quot;), inZone, 0); // handle error... // specify PPD file w/ ppdFsSpec err = FSMakeFSSpec(vRefNum,dirID,fileName,&amp;ppdFsSpec); err = SetPPD(&amp;ppdFsSpec, papaH, printerDrvrFsSpecP); ChangedResource(papaH); // mark dirty WriteResource(papaH);   // update resource err = FSClose(refNum); UseResFile(savedResFile);}</pre></TD></TR></TABLE></CENTER><BR><BR><h3>Creating An LPR Desktop Printer for the LaserWriter</h3><P>The domain address and queue have to be specified for LPR DTP.  They are specified as 'LpIa' hint.  The format of the 'LpIa' is formed by appending the queue name (a Pascal String) to the end of the domain address (another Pascal String) of the printer.</p><P>The <CODE>LaserWriterExtra</CODE> for an LPR DTP might look like this:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>// ---------------------------------------------------------------------------// LaserWriterExtra for 8.5.1 LW// point current printer to target// where inTcpAddr is the network address of the lpr printer.// This address can be in either name or dot format, i.e either &quot;\plaser.rbi.com&quot;// or &quot;\p204.188.109.155&quot;.// inQNameis the name of the print queue associated with// a spooler at inTcpAddr. If inQName is NULL then the default queue for the// printer/spooler is used.// ---------------------------------------------------------------------------LaserWriterExtra(FSSpec *printerDrvrFsSpecP,   ConstStr32Param inTcpAddr,   ConstStr32Param inPrinterName,   ConstStr32Param inQName){ OSErr err; short refNum; Handle papaH; Handle ipAddrQueueH; short savedResFile = CurResFile(); // open printer driver resource fork err = FSpOpenResFile(printerDrvrFsSpecP, fsWrPerm, &amp;refNum); // handle error... // get PAPA resource from printer driver papaH= Get1Resource('PAPA' , -8192); // handle error... // change PAPA resource content // See SettingsLib Spec  for psSetLprPapa err = psSetLprPapa(papaH, inPrinterName, (const Byte *)(&quot;\p=LPR&quot;),  (const Byte *)(*inTcpAddr), (const Byte *)inQName); // handle error... // specify PPD file w/ ppdFsSpec err = FSMakeFSSpec(vRefNum,dirID,fileName,&amp;ppdFsSpec); err = SetPPD(&amp;ppdFsSpec, papaH, printerDrvrFsSpecP); // specify domain address and queue of the printer err = PtrToHand(inTcpAddr, &amp;ipAddrQueueH, inTcpAddr[0] + 1); err = PtrAndHand(inQName, ipAddrQueueH, inQName[0] + 1); HLock(ipAddrQueueH); err = addHint(papaH, 'LpIa', 1, GetHandleSize(ipAddrQueueH), *ipAddrQueueH); HUnlock(ipAddrQueueH); DisposHandle(ipAddrQueueH); ChangedResource(papaH); // mark dirty WriteResource(papaH); // update resource err = FSClose(refNum); UseResFile(savedResFile);}</pre></TD></TR></TABLE></CENTER><BR><BR><h3>Creating An Infrared Desktop Printer for the LaserWriter</h3><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>// ---------------------------------------------------------------------------// LaserWriterExtra for 8.5.1 LW// point current printer to target// ---------------------------------------------------------------------------LaserWriterExtra(FSSpec *printerDrvrFsSpecP,   ConstStr32Param inPrinterName){ OSErr err; short refNum; Handle papaH; short savedResFile = CurResFile(); // open printer driver resource fork err = FSpOpenResFile(printerDrvrFsSpecP, fsWrPerm, &amp;refNum); // handle error... // get PAPA resource from printer driver papaH= Get1Resource('PAPA' , -8192); // handle error... // change PAPA resource content // See SettingsLib Spec  for psSetInfraredPapa err = psSetInfraredPapa(papaH, inPrinterName, (&quot;\p=Ird&quot;)); // handle error... // specify PPD file w/ ppdFsSpec err = FSMakeFSSpec(vRefNum,dirID,fileName,&amp;pgsSpec); err = SetPPD(&amp;ppdFsSpec, papaH, printerDrvrFsSpecP); ChangedResource(papaH); // mark dirty WriteResource(papaH); // update resource err = FSClose(refNum); UseResFile(savedResFile);}</pre></TD></TR></TABLE></CENTER><BR><BR><h3>Creating A Hold Desktop Printer for the LaserWriter</h3><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>//---------------------------------------------------------------------------// LaserWriterExtra for 8.5.1 LW// point current printer to target// ---------------------------------------------------------------------------LaserWriterExtra(FSSpec *printerDrvrFsSpecP,   ConstStr32Param inPrinterName){ OSErr err; short refNum; Handle papaH; short savedResFile = CurResFile(); // open printer driver resource fork err = FSpOpenResFile(printerDrvrFsSpecP, fsWrPerm, &amp;refNum); // handle error... // get PAPA resource from printer driver papaH= Get1Resource('PAPA' , -8192); // handle error... // change PAPA resource content // See SettingsLib Spec  for psSetHoldPapa err = psSetHoldPapa(papaH, inPrinterName, (&quot;\p=Hld&quot;)); // handle error... // specify PPD file w/ ppdFsSpec err = FSMakeFSSpec(vRefNum,dirID,fileName,&amp;ppdFsSpec); err = SetPPD(&amp;ppdFsSpec, papaH, printerDrvrFsSpecP); ChangedResource(papaH); // mark dirty WriteResource(papaH); // update resource err = FSClose(refNum); UseResFile(savedResFile);}</pre></TD></TR></TABLE></CENTER><BR><BR><h3>Creating A PostScript Translator Desktop Printer for the LaserWriter</h3><P>For PostScript Translator DTP, the default destination folder to hold the translated file must be specified as 'Pdka' hint.  A 'Svap' must also be specified to indicate this DTP is for "print to file":</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre> struct SaveAsFilePrefs{ Boolean  saveToFile; // true for printing to file Boolean  restricted; // true for printing to file};// ---------------------------------------------------------------------------// LaserWriterExtra for 8.5.1 LW// point current printer to target// ---------------------------------------------------------------------------LaserWriterExtra(FSSpec *printerDrvrFsSpecP,   ConstStr32Param inPrinterName,   FSSpec* destinationFolderP){ OSErr err; short refNum; Handle papaH; SaveAsFilePrefs saveToFilePref; AliasHandle printToDiskAliasH; short savedResFile = CurResFile(); // open printer driver resource fork err = FSpOpenResFile(printerDrvrFsSpecP, fsWrPerm, &amp;refNum); // handle error... // get PAPA resource from printer driver papaH= Get1Resource('PAPA' , -8192); // handle error... // change PAPA resource content // See SettingsLib Spec  for psSetFilePapa err = psSetFilePapa(papaH, inPrinterName, &quot;\p=Fil&quot;); // handle error... // specify PPD file w/ ppdFsSpec err = FSMakeFSSpec(vRefNum,dirID,fileName,&amp;ppdFsSpec); err = SetPPD(&amp;ppdFsSpec, papaH, printerDrvrFsSpecP); // print to disk hint saveToFilePref.saveToFile = TRUE; saveToFilePref.restricted = TRUE; prefCollection.AddItem('Svap', 1, sizeof(saveToFilePref), &amp;saveToFilePref); // set print to disk default folder err = NewAliasMinimal(destinationFolderP, &amp;printToDiskAliasH); HLock((Handle)printToDiskAliasH); err = addHint(papaH, 'Pdka', 1,  GetHandleSize((Handle)printToDiskAliasH), *printToDiskAliasH); HUnlock((Handle)printToDiskAliasH); DisposeHandle((Handle)printToDiskAliasH); // change PAPA resource content ChangedResource(papaH); // mark dirty WriteResource(papaH); // update resource err = FSClose(refNum); UseResFile(savedResFile);}</pre></TD></TR></TABLE></CENTER><BR><BR>            <h3>Creating Custom Desktop Printer for LaserWriter</h3><P>For an in-depth description of how a custom DTP can be used by developers and how to modify Apple's Desktop Printer Utility to support a specific post-processing application, please read <A HREF = "tn1113.html">Technote 1113: "Customizing the Desktop Printer Utility."</A></p><P>With each Custom DTP, we need to specify a post-processing application for LaserWriter to launch.  The post-processing application is specified as an <CODE>AliasHandle</CODE> and stored as a 'TGap' hint. </p><P>Currently supported hints for custom DTP include 'pslv', 'bnok', 'jobt' and 'font'.  The meaning of these hints and their data structures are described in <I>Customizing the Desktop Printer Utility.</I></p><P>The following routine shows how these parameters can be added to a custom DTP's collection. For more information on the <CODE>FOntHint</CODE> and <CODE>CustomAppeDesc</CODE> structures, please see <A HREF = "tn1113.html">Technote 1113: "Customizing the Desktop Printer Utility."</A></p>      <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre> typedef struct{           // see &quot;Custom DTPs&quot;. long flag;                // kIncludeAllFontsBut or kIncludeAllFontsBut unsigned char name[1];    // font name }FOntHint;struct CustomAppDesc{ OSType appSignature;      // target application's signature Str255 docType;           // appears in the list of doc. types                           // when &quot;New&quot; menu is selected Str255 helpText;          // lin43, appears when the type of                           // this DTP is selected Str255 usage;             // appears as the DTP usage in the window Str255 appFileName;       // default application file name, used in                           // error message and etc. short numOfHintsFollow;   // 1 based HintRsrcSpec hintRsrc[1]; // variable length};typedef struct CustomAppDesc CustomAppDesc;typedef struct CustomAppDesc* CustomAppDescPtr;typedef struct CustomAppDesc** CustomAppDescHdl;/* This routine adds custom DTP hints to the DTP specified papaH. The FSSpec of the post-processing application is pointed to by ppApp. Note how AliasHandle for the post-processing application is generated and added as a 'TGap' hint.*/OSErr addCustomDtpParameters(FSSpec* ppApp, Handle papaH){ OSErr err; long psLevel = 1;       // postscript level 1 Byte binaryOK = 0;      // false char job = 0;           // psJobPostScript FOntHint fontHint; AliasHandle targetAppAliasH; CustomAppDesc customAppDesc; // postscript level 1 err = addHint(papaH, 'pslv', 1, siezof(psLevel ), &amp;psLevel ){ // no Binary err = addHint(papaH, 'bnok', 1, siezof(binaryOK ), &amp;binaryOK ){ // PostScript job err = addHint(papaH, 'jobt', 1, siezof(job ), &amp;job ){ // includeAllFonts fontHint.flag = 1; fontHint.name [0] = 0;  err = addHint(papaH, 'font', 1, siezof(fontHint), &amp;fontHint){ // save target application's location err = ::NewAliasMinimal(ppApp, &amp;targetAppAliasH); // handle error ::HLock((Handle)targetAppAliasH); err = addHint('TGap', 1,  GetHandleSize((Handle)targetAppAliasH),    *targetAppAliasH); ::HUnlock((Handle)targetAppAliasH); ::DisposeHandle((Handle)targetAppAliasH); // if you want Apple's Desktop Printer Utility to recognize and being able to // open your DTP, you must add the 'CsDs' hint // fill out fields in customAppDesc for post-processing application customAppDesc.appSignature = 'xxxx'; // of post-processing application /* and all other fields... */ // save custom app's description err = addHint(('CsDs', 1, sizeof(customAppDesc), &amp;customAppDesc); return err;}// ---------------------------------------------------------------------------// LaserWriterExtra for 8.5.1 LW// point current printer to target// ---------------------------------------------------------------------------LaserWriterExtra(FSSpec *printerDrvrFsSpecP,   ConstStr32Param inPrinterName){ OSErr err; FSSpec postProcessAppFsSpec; short refNum; Handle papaH; short savedResFile = CurResFile(); // open printer driver resource fork err = FSpOpenResFile(printerDrvrFsSpecP, fsWrPerm, &amp;refNum); // handle error... // get PAPA resource from printer driver papaH= Get1Resource('PAPA' , -8192); // handle error... // See SettingsLib Spec  for psSetCustomPapa err = psSetCustomPapa(papaH, inPrinterName, &quot;\p=Cst&quot;); // handle error... // specify PPD file w/ ppdFsSpec err = FSMakeFSSpec(vRefNum,dirID,fileName,&amp;ppdFsSpec); err = SetPPD(&amp;ppdFsSpec, papaH, printerDrvrFsSpecP); // specify post-processing app. and other parameters err = FSMakeFSSpec(vRefNum, dirID, &quot;\pYourPostProcessAppName&quot;,  &amp;postProcessAppFsSpec); err = addCustomDtpParameters(&amp;postProcessAppFsSpec, papaH); // change PAPA resource content ChangedResource(papaH); // mark dirty WriteResource(papaH);   // update resource err = FSClose(refNum); UseResFile(savedResFile);}</pre></TD></TR></TABLE></CENTER><BR><BR>     <BR><P><A HREF="#top">Back to top</A></P><A NAME="Summary"></A> <h2>Summary</h2><P>As outlined here, there is some work to creating a desktop printer on the fly; however, the end result is worth it for many applications as long as you heed the warnings. Good luck!</p><A NAME="References"></A><H2>References</H2><P><A HREF = "tn1129.html">Technote 1129: "The Settings Library"</A></p><P><A HREF = "tn1113.html">Technote 1113: "Customizing Desktop Printer Utility"</A></P><P><A HREF = "tn1115.html">Technote 1115: "The Extended PAPA"</A></P><P>Metrowerks PowerPlant documentation</P><P>Inside Macintosh: Macintosh Toolbox Essentials, Chapter 7.</P>     <BR><P><A HREF="#top">Back to top</A></P>        <A NAME="Downloads"></A>         <h2>Downloadables</h2>        <center><TABLE BORDER=0 CELLPADDING=3 WIDTH="600">          <TR>             <td width=50 align=left>               <P ALIGN=center><img src="images/acrobatsmall.gif" align=middle alt="Acrobat" width=22 height=23></P>            </TD>            <td align="left">               <p>Acrobat version of this Note (108K).</P>            </TD>            <td width=60 align=left>               <p><A HREF="pdf/tn1131.pdf">Download</A></P>            </TD>          </TR>        </TABLE></center><BR><BR>         <BR><P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1131.html%3Fid%3DDTS10002970-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1131.html%3Fid%3DDTS10002970-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1131.html%3Fid%3DDTS10002970-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>