<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>MoreFinderEvents - /MoreFinderEvents.cp</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxCarbon-date.html">Carbon</a> &gt; <A HREF="javascript:location.replace('index.html');">MoreFinderEvents</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxFileManagement-date.html" target="_blank">Carbon > File Management</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">MoreFinderEvents</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/MoreFinderEvents.cp</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/MoreFinderEvents.cp</option>
<option value="listing2.html">/MoreFinderEvents.h</option>
<option value="listing3.html">/TestFinderEvents.c</option></select>
				</p>
				</form>
				<p><strong><a href="MoreFinderEvents.zip">Download Sample</a></strong> (&#147;MoreFinderEvents.zip&#148;, 10.9K)<BR>
<strong><a href="MoreFinderEvents.dmg">Download Sample</a></strong> (&#147;MoreFinderEvents.dmg&#148;, 69.6K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">  //  //  MoreFinderEvents 1.0  //  ====================  //  //  an AppleEvents package for non-scriptable versions of Finder  //  //  by Pete Gontier, Apple Macintosh Developer Technical Support  //  //  Copyright (c) 1996 Apple Computer, Inc., All Rights Reserved.  //  //  Complaints and kudos to: &lt;gurgle@apple.com&gt;  //  //  Thanks to Jon Pugh for 'FinderEvents.p' XCMD and code review  //  of this package.  //  //  INTRODUCTION  //  ============  //  //  The AppleEvents API is icky and you probably don't relish the  //  idea of developing an intimate relationship with it. And you  //  don't feel your application should yet require the scriptable  //  Finder, which first shipped in System 7.5. Yet you still want  //  to make Finder do backflips and cartwheels.  //  //  Enter MoreFinderEvents.  //  //  This package provides you with a painless API for sending some  //  of the more simple forms of the FinderEvents, which have been  //  with us since System 7.0.0. With this API you can copy a  //  file or open a control panel or empty the trash or any of  //  several other things usually done by Finder at the user's  //  request.  //  //  THEORY OF OPERATION  //  ===================  //  //  There's nothing terribly tricky here. We're just using the  //  AppleEvents API along with some simple C++ code to make it  //  a little more palatable. The only thing worth noting is that  //  Finder doesn't use the AppleEvents API on its end. Apparently  //  the Finder which shipped with System 7.0.0 needed to feature-  //  freeze before the AppleEvent Manager, so it has its own code  //  for examining AppleEvents. Since the Finder code is tailored  //  specifically to support FinderEvents, it tends to get cranky  //  when fed data which is not absotively posilutely correct.  //  If you modify this library and Finder starts crashing, that's  //  probably why.  //  //  BUILDING  //  ========  //  //  I wrote this library intermittently over a period of months with  //  with Metrowerks CodeWarrior CW7, CW8, and CW9. Consequently,  //  I don't know for certain whether it compiles with any other  //  compilers, although it's Universal Headers 2.0-savvy and should  //  work just fine.  //  //  Note that despite the fact that this is C++ code, all entry  //  points (the function prototypes in &quot;MoreFinderEvents.h&quot;) are  //  declared 'pascal', meaning you can call this code from C and  //  Pascal. There's no Pascal interface file for this library  //  at the moment primarily because to me an interface file would  //  imply that the author had ported &quot;TestFinderEvents.c&quot; to Pascal  //  to make sure the interface file worked. If someone wants to do  //  that and send me the results, I'll be more than happy to include  //  them in future versions of this package.  //  //  KNOWN PROBLEMS  //  ==============  //  //  [1] One of the following two things is true:  //  //    [a] The handling of 'iconPosition' in  //    'MFE_DragLow' is buggy.  //  //    [b] Finder doesn't handle this parameter properly.  //  //  The practical effect is that the icon lands in an unpredictable  //  position in the destination folder window.  //  //  [2] Some FinderEvents result in Finder behavior which doesn't  //  work well unless Finder is the front application. For example,  //  you can submit a request to open the Page Setup dialog for a  //  given folder window and Finder will happily open the Printing  //  Manager and the appropriate dialog from the background. When  //  the user brings Finder forward, the dialog won't (always) update  //  properly. Bad. It's not clear what to do about this; some  //  developers would probably rather decide for themselves when to  //  bring Finder forward. I'd love to hear your feedback.  //  //  [3] It's been suggested you're better off using the scriptable  //  Finder. It's said these older FinderEvents will go away  //  eventually. These things are true, so you should use the  //  scriptable Finder if it's available. See 'd e v e l o p'  //  magazine, issue 20, pages 65 to 78 for details. Does this  //  mean you'll have two chunks of code in your application?  //  Well... er... yes. Maybe someday I'll update this library so  //  that a single call will work regardless of the presence of  //  a scriptable Finder. Wouldn't that be cool?  //  //  TO DO  //  =====  //  //  There are a few events defined in Chapter 8 of the AppleEvents  //  Registry for which I have not yet implemented glue. If you're  //  a squeaky wheel, I'll try to make sure you get some grease.  //  //    move window  //    size window  //    zoom window  //    set view  //  //  LEGAL NOTICE  //  ============  //  //   You may incorporate this sample code into your applications  //   without restriction. This sample code has been provided &quot;AS  //   IS&quot; and the responsibility for its operation is 100% yours.  //   You are not permitted to redistribute the source as &quot;Apple  //   sample code&quot; after having made changes. If you're going to  //   re-distribute the source, we require that you make it clear  //   in the source that the code was descended from Apple sample  //   code, but that you've made changes.  //#define SystemSevenOrLater    1#define OLDROUTINELOCATIONS    0#define OLDROUTINENAMES      0#include &quot;MoreFinderEvents.h&quot;#ifndef __AEREGISTRY__#  include &lt;AERegistry.h&gt;#endif#ifndef __APPLEEVENTS__#  include &lt;AppleEvents.h&gt;#endif#if PRAGMA_ALIGN_SUPPORTED#  pragma push#  pragma options align=mac68k#endifstruct MFE_Window{  long      fWindowType;  DescType    fAliasType;  long      fAliasLen;  AliasRecord    fAliasRecord;};typedef MFE_Window *MFE_WindowP, **MFE_WindowH;struct FinderEvent : public AppleEvent{  OSErr    fErr;  AppleEvent  fReply;  AESendMode  fSendMode;  FinderEvent (AEEventClass,AEEventID);  ~FinderEvent (void);  OSErr Send (void);};#if PRAGMA_ALIGN_SUPPORTED#  pragma pop#endifenum{  kCreatorCode_Finder = 'MACS',  kCreatorCode_AtEase = 'mfdr'};static pascal OSErr GetCreatorOfFinderLikeProcess (OSType *processSignature){  OSErr err = noErr;  ProcessSerialNumber    psn    = { kNoProcess, kNoProcess };  ProcessInfoRec      pir    = { sizeof (pir), nil };  *processSignature = 0;  pir.processAppSpec = nil;  for (;;)  {    err = GetNextProcess (&amp;psn);    if (err)    {      if (err == procNotFound) err = noErr;      break;    }    err = GetProcessInformation (&amp;psn,&amp;pir);    if (err) break;    if (pir.processSignature == kCreatorCode_Finder ||      pir.processSignature == kCreatorCode_AtEase)    {      *processSignature = pir.processSignature;      break;    }  }  return err;}/////////////////////////////////////////////////////////////////////////////////#pragma mark -/*// cheap 68K-only debugging toolstatic pascal asm void DisassembleAppleEvent (AEDesc *){  MOVE.L  (A7)+,A0  MOVE.L  (A7)+,A1  PEA    @1  DC.W  0xABFF  JMP    (A0)@1:  DC.B &quot;\p ; aevt rA1&quot;}*/OSErr FinderEvent::Send (void){  return fErr = AESend (this,&amp;fReply,fSendMode,kAENormalPriority,-1,nil,nil);}FinderEvent::FinderEvent (AEEventClass eventClass, AEEventID eventID){  OSType finderLikeProcess;  descriptorType      = typeNull;  dataHandle        = nil;  fReply.descriptorType  = typeNull;  fReply.dataHandle    = nil;  if (!(fErr = GetCreatorOfFinderLikeProcess (&amp;finderLikeProcess)))  {    AEAddressDesc address;    if (!(fErr = AECreateDesc (typeApplSignature, &amp;finderLikeProcess,      sizeof (finderLikeProcess), &amp;address)))    {      OSErr err2 = noErr;      fErr = AECreateAppleEvent (eventClass,eventID,&amp;address,        kAutoGenerateReturnID,kAnyTransactionID,this);      err2 = AEDisposeDesc (&amp;address);      if (!fErr &amp;&amp; !(fErr = err2))      {        fSendMode = kAENoReply | kAEAlwaysInteract | kAECanSwitchLayer;      }    }  }}FinderEvent::~FinderEvent (void){  if (dataHandle)    fErr = AEDisposeDesc (this);  if (fReply.dataHandle)    fErr = AEDisposeDesc (&amp;fReply);}/////////////////////////////////////////////////////////////////////////////////#pragma mark -static pascal OSErr MFE_Simple (AEEventID eventID){  OSErr err = noErr;  FinderEvent finderEvent (kAEFinderEvents,eventID);  if (!(err = finderEvent.fErr))    err = finderEvent.Send ( );  return err;}static pascal OSErr MFE_HideSpecialWindow (OSType aliasUserType){  OSErr err = noErr;  FinderEvent finderEvent (kAEFinderEvents,kAEClose);  if (!(err = finderEvent.fErr))  {    MFE_Window finderWindow;    finderWindow.fWindowType        = 0;    finderWindow.fAliasType          = 'find';    finderWindow.fAliasLen          = 4;    finderWindow.fAliasRecord.userType    = aliasUserType;    finderWindow.fAliasRecord.aliasSize    = 0;    if (!(err = AEPutParamPtr (&amp;finderEvent, keyDirectObject,      typeFinderWindow, &amp;finderWindow, sizeof (finderWindow))))        err = finderEvent.Send ( );  }  return err;}static pascal OSErr MFE_ShowSpecialWindow  (AEEventClass eventClass, AEEventID eventID){  FinderEvent finderEvent (eventClass,eventID);  if (finderEvent.fErr)    return finderEvent.fErr;  else    return finderEvent.Send ( );}static pascal OSErr MFE_AddParentAlias  (FinderEvent &amp;finderEvent, const AliasRecord **aliasH){  //  //  The goal here is to add a parent alias to 'finderEvent' as the direct  //  object as specified by the Apple Event Registry. If 'aliasH' is not a  //  volume, we add an alias of the parent of 'aliasH'. If 'aliasH' is a  //  volume, we want to add 'aliasH' itself as the container because lots  //  of events expect that bizarre behavior. We make a new alias to it  //  because we have no way of telling whether the incoming alias is a full  //  alias or not, and Finder demands one (and it tends to throw nasty  //  tantrums if it's not).  //  OSErr err = noErr;  FSSpecPtr fssP = FSSpecPtr (NewPtr (sizeof (FSSpec)));  if (!(err = MemError ( )))  {    if (!(err = ::HandToHand ((Handle *) &amp;aliasH)))    {      Boolean wasChanged;      if (!(err = ResolveAlias (nil, AliasHandle (aliasH), fssP,        &amp;wasChanged))) // aliasH is a copy      {        if (fssP-&gt;parID == fsRtParID ||          !(err = FSMakeFSSpec (fssP-&gt;vRefNum, fssP-&gt;parID, nil, fssP)))        {          AliasHandle parentAlias;          if (!(err = NewAlias (nil,fssP,&amp;parentAlias)))          {            HLock (Handle (parentAlias));            if (!(err = MemError ( )))            {              Size parentAliasSize =                GetHandleSize (Handle (parentAlias));              if (!(err = MemError ( )))                err = AEPutParamPtr (&amp;finderEvent, keyDirectObject,                  typeAlias, *parentAlias, parentAliasSize);            }            DisposeHandle (Handle (parentAlias));          }        }      }      ::DisposeHandle (Handle (aliasH));      if (!err) err = MemError ( );    }    DisposePtr (Ptr (fssP));    if (!err) err = MemError ( );  }  return err;}static pascal OSErr MFE_AddChildAlias  (AEDescList &amp;selection, const AliasRecord **aliasH){  OSErr err = noErr;  SInt8 hState = HGetState (Handle (aliasH));  if (!(err = MemError ( )))  {    HLock (Handle (aliasH));    if (!(err = MemError ( )))    {      Size aliasSize = GetHandleSize (Handle (aliasH));      if (!(err = MemError ( )))      {        err = AEPutPtr (&amp;selection,0,typeAlias,*aliasH,aliasSize);      }      HSetState (Handle (aliasH), hState);    }  }  return err;}static pascal OSErr MFE_SendSingleSelectionEvent  (const AliasRecord **aliasH, AEEventID eventID){  OSErr err = noErr;  FinderEvent finderEvent (kAEFinderEvents,eventID);  if (!(err = finderEvent.fErr))  {    if (!(err = MFE_AddParentAlias (finderEvent,aliasH)))    {      AEDescList selection = { typeNull, nil };      if (!(err = AECreateList (nil,0,false,&amp;selection)))      {        if (!(err = MFE_AddChildAlias (selection,aliasH)))          if (!(err = AEPutParamDesc (&amp;finderEvent,keySelection,            &amp;selection)))              err = finderEvent.Send ( );        AEDisposeDesc (&amp;selection);      }    }  }  return err;}static pascal OSErr MFE_SendSingleFileEventViaHandle  (Handle h, AEEventID eventID, DescType descType){  OSErr err = noErr;  FinderEvent finderEvent (kAEFinderEvents,eventID);  if (!(err = finderEvent.fErr))  {    SInt8 hState = HGetState (h);    if (!(err = MemError ( )))    {      HLock (h);      if (!(err = MemError ( )))      {        Size size = GetHandleSize (h);        if (!(err = MemError ( )))          if (!(err = AEPutParamPtr (&amp;finderEvent, keyDirectObject,            descType, *h, size)))              err = finderEvent.Send ( );        HSetState (h, hState);        if (!err) err = MemError ( );      }    }  }  return err;}static pascal OSErr MFE_CreateFinderWindowHandle  (const AliasRecord **aliasH, MFE_WindowH *fwhp, long windowType = 0){  OSErr err = noErr;  Size size = ::GetHandleSize (Handle (aliasH));  if (!(err = MemError ( )))  {    *fwhp = MFE_WindowH (NewHandle (size + sizeof (MFE_Window) -      sizeof (AliasRecord)));    if (!(err = MemError ( )))    {      MFE_Window finderWindow;      finderWindow.fWindowType  = windowType;      finderWindow.fAliasRecord  = **aliasH;      finderWindow.fAliasType    = typeAlias;      finderWindow.fAliasLen    = size;      MFE_Window *finderWindowP = **fwhp;      BlockMoveData (*aliasH,&amp;(finderWindowP-&gt;fAliasRecord),size);      *finderWindowP = finderWindow;    }  }  return err;}static pascal OSErr MFE_SendSimpleFinderWindowEvent  (const AliasRecord **aliasH, AEEventID eventID, long windowType = 0){  OSErr err = noErr;  MFE_WindowH finderWindowH = nil;  if (!(err = MFE_CreateFinderWindowHandle (aliasH,&amp;finderWindowH,windowType)))  {    err = MFE_SendSingleFileEventViaHandle (Handle (finderWindowH),      eventID, typeFinderWindow);    DisposeHandle (Handle (finderWindowH));    if (!err) err = MemError ( );  }  return err;}static pascal OSErr MFE_AddDestinationAlias  (const AliasRecord **destAlias, FinderEvent &amp;finderEvent){  OSErr err = noErr;  SInt8 destAliasState = HGetState (Handle (destAlias));  if (!(err = MemError ( )))  {    HLock (Handle (destAlias));    if (!(err = MemError ( )))    {      Size destAliasSize = GetHandleSize (Handle (destAlias));      if (!(err = MemError ( )))        err = AEPutParamPtr (&amp;finderEvent, keyDirectObject, typeAlias,          *destAlias, destAliasSize);      HSetState (Handle (destAlias), destAliasState);      if (!err) err = MemError ( );    }  }  return err;}static pascal OSErr MFE_ResolveAlias (const AliasRecord **aliasH, FSSpecPtr fssP){  Boolean dontCare;  short aliasCount = 1;  const unsigned long rulesMask = kARMNoUI | kARMSearch;  return MatchAlias (nil,rulesMask,AliasHandle(aliasH),&amp;aliasCount,    fssP,&amp;dontCare,nil,nil);}typedef pascal OSErr (*vParamValidator)  (const FSSpec &amp;fssToDrag, const FSSpec &amp;fssTarget);static pascal OSErr MFE_DragLow  (AEEventID eventID, vParamValidator validateParams,    const AliasRecord **aliasToDrag, const AliasRecord **destAlias){  OSErr err = noErr;  //  //  If we need to validate our inputs, allocate two FSSpec records  //  on the heap and resolve the parameter aliases.  //  if (validateParams)  {    FSSpecPtr specToDragP  = nil;    FSSpecPtr specDestP    = nil;    do    {      specToDragP = FSSpecPtr (NewPtr (sizeof (FSSpec)));      err = MemError ( ); if (err) break;      specDestP = FSSpecPtr (NewPtr (sizeof (FSSpec)));      err = MemError ( ); if (err) break;      err = MFE_ResolveAlias (aliasToDrag,specToDragP);      if (err) break;      err = MFE_ResolveAlias (destAlias,specDestP);      if (err) break;      err = validateParams (*specToDragP,*specDestP);    }    while (false);    if (specToDragP)      DisposePtr (Ptr (specToDragP));    if (specDestP)      DisposePtr (Ptr (specDestP));  }  //  //  If there were no errors validating our inputs,  //  build and send the event.  //  if (!err)  {    AEDescList selection = { typeNull, nil };    do    {      FinderEvent finderEvent (kAEFinderEvents,eventID);      err = finderEvent.fErr;      if (err) break;      err = AECreateList (nil,0,false,&amp;selection);      if (err) break;      err = MFE_AddChildAlias (selection,aliasToDrag);      if (err) break;      err = AEPutParamDesc (&amp;finderEvent,keySelection,&amp;selection);      if (err) break;      Point iconPosition = { 0,0 }; // no offset, thank you      err = AEPutParamPtr (&amp;finderEvent, keyMiscellaneous, typeLongInteger,        &amp;iconPosition, sizeof (iconPosition));      if (err) break;      err = MFE_AddDestinationAlias (destAlias,finderEvent);      if (err) break;      err = finderEvent.Send ( );    }    while (false);    if (selection.dataHandle)      AEDisposeDesc (&amp;selection);  }  return err;}/////////////////////////////////////////////////////////////////////////////////#pragma mark -pascal OSErr MFE_PrintWindow (const AliasRecord **aliasH){  return MFE_SendSimpleFinderWindowEvent (aliasH,kAEPrintWindow);}pascal OSErr MFE_PageSetup (const AliasRecord **aliasH){  return MFE_SendSimpleFinderWindowEvent (aliasH,kAEPageSetup);}pascal OSErr MFE_CloseWindow (const AliasRecord **aliasH){  return MFE_SendSimpleFinderWindowEvent (aliasH,kAEClose);}pascal OSErr MFE_CloseGetInfo (const AliasRecord **aliasH){  return MFE_SendSimpleFinderWindowEvent (aliasH,kAEClose,kAEInfo);}pascal OSErr MFE_CloseSharing (const AliasRecord **aliasH){  return MFE_SendSimpleFinderWindowEvent (aliasH,kAEClose,kAESharing);}pascal OSErr MFE_MakeAlias (const AliasRecord **aliasH){  return MFE_SendSingleSelectionEvent (aliasH,kAEAliasSelection);}pascal OSErr MFE_Duplicate (const AliasRecord **aliasH){  return MFE_SendSingleSelectionEvent (aliasH,kAEDuplicateSelection);}pascal OSErr MFE_OpenSelection (const AliasRecord **aliasH){  return MFE_SendSingleSelectionEvent (aliasH,kAEOpenSelection);}pascal OSErr MFE_PrintSelection (const AliasRecord **aliasH){  return MFE_SendSingleSelectionEvent (aliasH,kAEPrintSelection);}pascal OSErr MFE_OpenGetInfo (const AliasRecord **aliasH){  return MFE_SendSingleSelectionEvent (aliasH,kAEGetInfoSelection);}pascal OSErr MFE_OpenSharing (const AliasRecord **aliasH){  return MFE_SendSingleSelectionEvent (aliasH,kAEGetPrivilegeSelection);}pascal OSErr MFE_Reveal (const AliasRecord **aliasH){  return MFE_SendSingleSelectionEvent (aliasH,kAERevealSelection);}pascal OSErr MFE_PutAway (const AliasRecord **aliasH){  return MFE_SendSingleSelectionEvent (aliasH,kAEPutAwaySelection);}pascal OSErr MFE_UnmountVolume (short vRefNum){  FSSpecPtr fssP = (FSSpecPtr) ::NewPtr (sizeof (*fssP));  OSErr err = ::MemError ( );  if (!err)  {    if (!(err = FSMakeFSSpec (vRefNum, fsRtDirID, &quot;\p&quot;, fssP)))    {      AliasHandle aliasH = nil;      OSErr err = NewAliasMinimal (fssP, &amp;aliasH);      if (!err)      {        err = MFE_PutAway (aliasH);        DisposeHandle (Handle (aliasH));        if (!err) err = MemError ( );      }    }    DisposePtr (Ptr (fssP));    if (!err) err = MemError ( );  }  return err;}pascal OSErr MFE_ShowAbout (void){  return MFE_ShowSpecialWindow (kCoreEventClass,kAEAbout);}pascal OSErr MFE_ShowClipboard (void){  return MFE_ShowSpecialWindow (kAEFinderEvents,kAEShowClipboard);}pascal OSErr MFE_HideAbout (void){  return MFE_HideSpecialWindow ('abot');}pascal OSErr MFE_HideClipboard (void){  return MFE_HideSpecialWindow ('clip');}#pragma mark -pascal OSErr MFE_Sleep (void){  return MFE_Simple (kAESleep);}pascal OSErr MFE_Restart (void){  return MFE_Simple (kAERestart);}pascal OSErr MFE_ShutDown (void){  return MFE_Simple (kAEShutDown);}pascal OSErr MFE_EmptyTrash (void){  return MFE_Simple (kAEEmptyTrash);}#pragma mark -static pascal OSErr MFE_CopyParamValidator  (const FSSpec &amp;fssToDrag, const FSSpec &amp;fssTarget){  //  //  Finder does an infinite recursion when you attempt to  //  copy a file over itself. Here we test a file to be moved  //  against a potential destination directory. If they match,  //  we claim we were passed bogus parameters, which isn't a lie.  //  OSErr err = noErr;  CInfoPBPtr cipbp = CInfoPBPtr (NewPtrClear (sizeof (*cipbp)));  if (!(err = MemError ( )))  {    cipbp-&gt;dirInfo.ioDrDirID  = fssTarget.parID;    cipbp-&gt;dirInfo.ioVRefNum  = fssTarget.vRefNum;    cipbp-&gt;dirInfo.ioNamePtr  = StringPtr (fssTarget.name);    if (!(err = PBGetCatInfoSync (cipbp)))      if (fssToDrag.parID == cipbp-&gt;dirInfo.ioDrDirID)        err = paramErr;    DisposePtr (Ptr (cipbp));    if (!err) err = MemError ( );  }  return err;}static pascal OSErr MFE_MoveParamValidator  (const FSSpec &amp;fssToDrag, const FSSpec &amp;fssTarget){  //  //  Finder will happily attempt (and fail) to move something  //  to a different volume. The item gets moved to the directory  //  with the same ID on the source volume -- if it exists.  //  If it doesn't exist, we never hear about the problem and  //  nothing happens.  //  //  Also: moving a file onto itself is dumb, so we call the copy  //  validator, which checks this for us.  //  OSErr err = noErr;  if (fssToDrag.vRefNum != fssTarget.vRefNum)    err = paramErr;  else    err = MFE_CopyParamValidator (fssToDrag,fssTarget);  return err;}pascal OSErr MFE_Copy  (const AliasRecord **aliasToDrag, const AliasRecord **destAlias){  return MFE_DragLow (kAEDrag,MFE_CopyParamValidator,aliasToDrag,destAlias);}pascal OSErr MFE_Move  (const AliasRecord **aliasToDrag, const AliasRecord **destAlias){  return MFE_DragLow (kAEMove,MFE_MoveParamValidator,aliasToDrag,destAlias);}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/MoreFinderEvents/listing1.html%3Fid%3DDTS10000206-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/MoreFinderEvents/listing1.html%3Fid%3DDTS10000206-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/MoreFinderEvents/listing1.html%3Fid%3DDTS10000206-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>