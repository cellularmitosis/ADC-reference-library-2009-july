<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><html><head><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note PR505: PostScript Q&amp;As</title>                                       <meta name="categories" content="Printing"><meta name="week-posted" content="Oct 1, 1990 - Oct 5, 1990"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002645" title="PostScript Q&As"></a><a name="top"></A><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxPrinting-date.html">Printing</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/Printing/idxHardwareDrivers-date.html" target="_blank">Printing > Hardware & Drivers</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note PR505</div>
<div id="pageheadsub">PostScript Q&amp;As</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->										<p id="menutext"> <A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><p id="introtext">This Technical Note contains a collection of archived Q&amp;As relating to a specifictopic--questions sent the Developer Support Center (DSC) along withanswers from the DSC engineers. Current Q&amp;A's can be found on the <A HREF = "../../qa/index.html">Macintosh Technical Q&amp;A's web site</a>.</p> <!-- end_intro_text --><!-- begin_date --><h3 align=center>[Oct 01 1990]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR>          <!-- begin_content --><a name=Section1></A> <h2>PostScript documentation</h2><P>Date Written:  7/13/90</p><P>Last reviewed:  8/1/92</p><p>Adobe Systems publishes three great manuals that can help you with PostScriptcommands: <i>PostScript Language Reference Manual, PostScript LanguageTutorial,</i> and <i>PostScript Language Cookbook.</i> You can find thesemanuals at just about any bookstore, or you can order them through APDA bycalling (800) 282-2732 or writing them at:</p><p>Apple Computer, Inc.<br>20525 Mariani Avenue, Mail Stop 33-G<br>Cupertino, CA 95014</p><P><A HREF="#top">Back to top</A></P><h2>AppleTalk packets and PostScriptHandle PicComment</h2><P>Date Written:  8/7/90</p><P>Last reviewed:  8/1/92</p><p>What's the optimal amount of PostScript to pass in <code>PicComment</code> 192 for AppleTalkpacket throughput?</p> <P>There is no one optimal size that your <code>PostScriptHandle PicComment </code>should befor AppleTalk packets. The LaserWriter driver sends different amounts ofPostScript, depending on the amount of memory that is available. It could sendas little as 1K or as much as 4K bytes of PostScript at one time. The driver isusing four 4096-byte buffers to send the data, and the amount of data that itsends from a particular buffer is completely memory dependent. In the generalcase, it does not send any data until a particular buffer is full. The driverdoes not control the number of packets that are sent over AppleTalk. When PAPreceives the PostScript, it packages up the PostScript and sends it down to theLaserWriter.  In general, DTS recommends that applications send a PostScripthandle that contains 4096 bytes of data.</p><P><A HREF="#top">Back to top</A></P><h2>Using PostScript to control LaserWriter serial I/O</h2><P>Date Written:  12/6/90</p><P>Last reviewed:  3/28/93</p><p>Where can I find information on using PostScript to control a multi-tray sheetfeeder by communicating through the LaserWriter serial port?</p> <P>You need to talk with Adobe on how they control the serial chip withPostScript. They use some undocumented PostScript calls to control the serialchip on the controller board of the LaserWriter. They can be reached at:</p><p>     Adobe Systems, Inc.<br>     1585 Charleston Road<br>     Mountain View, CA   94039</p><P>or</p>     <P>AppleLink Address:  ADOBE.SUPT (Tech Support)</p><P>Details about installing feeder resources for Macintosh into the LaserWriterdriver 7.0 dialogs are available in the Macintosh Technical Note <A HREF = "pr_15.html">"FeederFodder</a>."</p><P><A HREF="#top">Back to top</A></P><h2>How to inhibit LaserWriter test page</h2><P>Date Written:  12/24/90</p><P>Last reviewed:  8/1/92</p><p>How do I inhibit the test page on a LaserWriter?</p> <ol type="1">	<li>Use the LaserWriter Utility to turn the startup page off (best), or</li>	<li>Download the following PostScript commands:</li></ol><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>serverdict begin 0 exitserverstatusdict beginfalse setdostartpage</pre>	</TD></TR></TABLE></CENTER><p>The above commands can be downloaded from your Macintosh to the printer severalways:</p><ol type="1">	<li>Use the menu command in the LaserWriter Utility that comes with System 7 (easiest).</li>	<li>You can use a PostScript utility like LaserTalk from Emerald City Software.</li>	<li>The PostScript Language facility in Microsoft Word.</li>	<li>PSDump or PSsend</li>	<li>Use the PostScript utilities in the Developer CD's PostScript Utilities folder.</li>	<li>Use the methods described in the <A HREF = "../qd/qd_10.html">Macintosh Technical Note #91</a>.</li></ol><p>When you issue the commands, your LaserWriter will probably crank and grind fora few seconds (it has to re-program the EPROM inside) then after the lightsstop flashing, your LaserWriter will no longer spit out the startup page untilyou enable the setdostartpage flag again (in other words, this isn't apermanent change).</p><p>For more information on the above subject we recommend the <i>PostScriptLanguage Reference Manual</i> by Adobe Systems.</p><P><A HREF="#top">Back to top</A></P><h2>Where to find Encapsulated PostScript file (EPSF) documentation</h2><P>Date Written:  4/5/91</p><P>Last reviewed:  8/1/92</p><p>I'm developing an application that creates pictures containing both QuickDrawand PostScript (as picComments). How do I create an encapsulated PostScriptfile (EPSF)? Is the format explained anywhere, and is it possible to convertthe QuickDraw into PostScript directly in the application?</p> <P>Adobe's EPSF format is documented in the new (2nd) edition of Adobe's<i>PostScript Language Reference Manual</i> (Addison-Wesley) and in "AdobeDocument Structuring Conventions," available from Adobe Systems. Adobe'sreferences explain how to structure your comments in your PostScript file sothat other applications know how to read it.</p><p>You probably don't want to try to convert QuickDraw to PostScript directly inyour application, although it is possible. Basically, it involves translatingeach QuickDraw command into PostScript, which is what the LaserWriter Driverdoes. It's a lot of work and makes you dependent on the QuickDraw featuresbeing used, which can be a problem when new features are added.</p><P><A HREF="#top">Back to top</A></P><h2>PostScript setprintername doesn't accept colons in string</h2><P>Date Written:  4/16/91</p><P>Last reviewed:  8/1/92</p><p>Why can't I use a colon with the PostScript command <code>setprintername</code> to changethe Personal LaserWriter NT network name and type, but it works with theLaserWriter II?</p> <P>The reason that the Personal LaserWriter NT is not accepting the PostScriptyou're sending is not because of a bug, but rather a bug fix. Colons have neverbeen acceptable in the string passed to <code>setprintername</code>. (See page 296 ofAdobe's <i>PostScript Language Reference Manual.)</i> The reason the call worksin older LaserWriters but not the Personal LaserWriter NT is that the NT has anewer version of PostScript in it. Older versions of PostScript didn't enforceAdobe's printer naming conventions. The <code>setprintername</code> restrictions have beenenforced in more recent versions, however. Therefore, colons are not allowed.</p><p>If you need to change the LaserWriter network type, it can be done with theAppleTalk-type parameter described on page 105 of Apple's <i>LaserWriterReference</i> manual. This method will work on the new printers as well as theold.</p><P><A HREF="#top">Back to top</A></P><h2>PostScript code for renaming LaserWriter</h2><P>Date Written:  6/5/91</p><P>Last reviewed:  8/1/92</p><p>In checking a printer name to ensure an even number of characters, does theLaserWriter Namer append a space to the end if the total is odd?</p> <P>In a nutshell, yes. The Namer does indeed append an extra space to odd-lengthprinter names. The reasoning behind this is to be compatible with some of theold 68000 processors. The addressing scheme of these old processors requiresthat memory be accessed by even-numbered addresses. To get at a piece of memorylocated after an odd-length LaserWriter name, you would need to get anodd-numbered address (which is not directly possible). This obviously can beworked around, but the authors of the Namer felt it best to avoid thisaltogether by padding the name when necessary. It's worth noting that theversion 7.0 Namer does this too.</p><p>If you'd like to work around this, here's an alternate method for renaming theprinter:</p><p>The printer name is stored as a string in the persistent parameters of allLaserWriters. This string can be changed by the following PostScript program:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    serverdict begin 0 exitserver</pre>	</TD></TR></TABLE></CENTER><p>Replace <code>NEWNAME</code> with the name you want for the printer. The name can be up to31 characters and should consist entirely of printing characters - the "@" and":" cannot be used. Note that parentheses are required.</p><p>This program can be downloaded to the LaserWriter in batch or interactive mode.In interactive mode you should type both command strings on the same linebefore pressing Enter, because exitserver disconnects you from the printer.When you reestablish your connection to the printer, the name will bechanged.</p><p>Make sure you have selected the correct LaserWriter using the Chooser beforedownloading this program, so you don't rename the wrong LaserWriter.</p><P><A HREF="#top">Back to top</A></P><h2>Printing 2-byte bitmap fonts on PostScript LaserWriters</h2><P>Date Written:  9/29/91</p><P>Last reviewed:  8/1/92</p><p>The <A HREF = "../qd/qd_10.html">Macintosh Technical Note #91</a> refers to using QuickDraw picComments to printrotated text, but this doesn't work for 2-byte Japanese text. Is there arecommended workaround for this problem?</p> <P>Two-byte characters don't print when using the <code>TextBegin</code>, <code>TextCenter</code>, and<code>TextEnd PicComments</code> because of the structure of the data that is being sent inthe comments. The LaserWriter driver uses these <code>PicComments</code> to rotate text, andit is not expecting the data to be in the 2-byte format. The 2-byte format isconverted to bitmap data by the driver, so the data is ignored and nothing isprinted. The driver is expecting the comments to contain "normal" text.</p><p>Since the data is in bitmap format, you can use the <code>RotateBegin</code> and <code>RotateEnd</code>PicComments to perform the rotation, as follows:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>RotateBegin    DrawString (...);  &lt;&lt; To rotate your 2 byte Japanese characters</pre>	</TD></TR></TABLE></CENTER><p>The tricky part of the solution is that you only need to use this approach whenyou're printing 2-byte Japanese bitmap fonts. Therefore, you'll need to checkthe type of data that is to be printed, and send the appropriate <code>PicComments</code>.</p><p>You can also use the following <code>PicComments</code> to hide the QuickDraw representationof the rotated text, as shown below:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>PostScriptBegin    CopyBits (...);   &lt;&lt; For the QuickDraw printers</pre>	</TD></TR></TABLE></CENTER><p>The <code>PostScriptBegin</code> and <code>PostScriptEnd PicComments</code> are used to hide the CopyBitscalls from the LaserWriter driver in a device-independent manner. When you use<code>PostScriptBegin</code>, the LaserWriter driver doesn't interpret any QuickDraw callsuntil it finds the <code>PostScriptEnd PicComment</code>. Since QuickDraw printer drivers do<i>not</i> understand the <code>PostScriptBegin</code> and <code>PostScriptEnd PicComments</code>, theyignore the <code>PicComments</code>, and the <code>CopyBits</code> call is used to perform the rotationof your text.</p><p>There is one problem with the previously mentioned solution: If you record theprevious <code>PicComments</code> into a picture and print it, everything will print exactlyas expected, but if you display the picture into a window, you'll see the<i>unrotated</i> version of the text. This is definitely a bug, which has beenreported, but it won't be fixed in the very near future. So, what do you do inthe meantime? You have the following two options:</p><ol type="1">	<li>Do not export pictures that contain this type of rotated data.  Export the picture with this problem, and explain the problem to your users.</li></ol><p>Neither solution is ideal. Quite a few applications out in the market todayhave decided to use idea #2.</p><P><A HREF="#top">Back to top</A></P><h2>Macintosh spooling should be device independent</h2><P>Date Written:  1/1/90</p><P>Last reviewed:  8/1/92</p><p>How can I tell whether the chosen printer supports PostScript or not?</p> <P>There is no supported method for determining whether or not a device speaksPostScript. Apple engineering would like all Macintosh applications to spoolboth PostScript and QuickDraw regardless of the chosen printer, so that thespool file is device-independent and can be redirected after spooling. Sinceengineering is strongly encouraging developers to spool both models, it isdoubtful that Apple will be providing a query mechanism in the future. The bestmethod is to assume PostScript is available, and format your document based oninformation returned by <code>PrGeneral</code> and the print record.</p><P><A HREF="#top">Back to top</A></P><h2>LaserWriter driver and PostScript showpage</h2><P>Date Written:  1/1/90</p><P>Last reviewed:  6/14/93</p><p>When I print a PostScript file, why do I get one blank page for every pageprinted?</p> <P>Your PostScript file probably contains calls to the PostScript <code>showpage</code>operator. This operator is also called by the Macintosh LaserWriter driver whenit receives the <code>PrClosePage</code> call. The solution to this problem is to strip<code>showpage</code> calls from the file before sending the file to the LaserWriter. If yousend one QuickDraw graphic at the beginning of each page:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    MoveTo(-32000, -32000);</pre>	</TD></TR></TABLE></CENTER><p>the LaserWriter driver will handle calling <code>showpage</code> for you. Versions of theLaserWriter driver before 5.2 do not send the <code>showpage</code> operator unless aQuickDraw drawing routine (that is, something other than PicComment) is sent.This is why you need to do the <code>MoveTo/LineTo</code>. Versions 5.2 and later will sendthe <code>showpage</code> operator whether any QuickDraw has been sent or not. Since youcan't be sure whether <code>showpage</code> will be sent for you or not, the best solutionis to let the LaserWriter driver send it.</p><P><A HREF="#top">Back to top</A></P><h2>PicComment TextIsPostScript versus PostScriptHandle</h2><P>Date Written:  1/1/90</p><P>Last reviewed:  6/14/93</p><p>When using the Macintosh TextIsPostScript picture comment, my PostScript codeis also "printed" on the ImageWriter. Why isn't it ignored?</p> <P>One of the comments, <code>TextIsPostScript</code>, allows the application to use theQuickDraw <code>DrawString</code> procedure to send the PostScript code. This method is nolonger recommended, as it is not device independent. If you use the<code>TextIsPostScript</code> comment when printing to a non-PostScript device, thePostScript code will be printed as text. On an ImageWriter, the entirePostScript program will be printed as one line on the page, because the<code>TextIsPostScript</code> PicComment is ignored by the ImageWriter drivers, and theDrawString calls are executed normally.</p><p>To avoid this problem, developers should use the <code>PostScriptHandle</code> comment. Thiscomment accepts a handle as a parameter. The handle points to the PostScriptcode that you want to download. This comment is better for two reasons:</p><p>First, there is no QuickDraw/PostScript interaction. For example, earlyversions of the LaserWriter driver sent the strings passed to <code>DrawString</code> as-is.The latest version of the driver appends carriage returns onto those strings.If your application is expecting the <code>DrawString</code> calls to work one way oranother, you might get a surprise.</p><p>The other reason for using the <code>PostScriptHandle</code> comment involves deviceindependence. When a non-PostScript driver sees the <code>PostScriptHandle</code>PicComment, it not only ignores the comment, but also ignores the PostScriptdata that was passed to the comment, so nothing prints if you use the<code>PostScriptHandle</code> comment on a non-PostScript driver.</p><p>X-Ref:</p><P>Macintosh Technical Note  <A HREF = "../tb/tb_03.html">"How To Produce Continuous Sound Without Clicking"</a></p><P><A HREF="#top">Back to top</A></P><h2>How to send PostScript from the Macintosh to the LaserWriter</h2><P>Date Written:  5/3/89</p><P>Last reviewed:  6/14/93</p><p>How do I send PostScript from the Macintosh to the LaserWriter?</p> <P>The best method for sending PostScript to the LaserWriter is to use the<code>PostScriptHandle</code> (kind = 192) <code>PicComment</code> documented in the Macintosh TechnicalNotes "Optimizing for the LaserWriter" and "Picture Comments--the Real Deal."There are a few <code>PicComment</code>s for sending PostScript to the LaserWriter, but theeasiest to use and most problem free is the <code>PostScriptHandle</code> comment. One modelis:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre> PrOpenPage(...) { Send some QuickDraw so that the Printing Manager gets a  } { chance to define the clip region.             } MoveTo(-32000, -32000); Line(0, 0); PicComment(PostScriptBegin, 0, NIL); { QuickDraw representation of graphic. } MoveTo(100, 100); LineTo(200, 200); { PostScript representation of graphic. } thePSHandle^^ := '100 100 moveto 200 200 lineto stroke'; PicComment(PostScriptHandle,GetHandleSize(thePSHandle),thePSHandle); PicComment(PostScriptEnd, 0, NIL);</pre>	</TD></TR></TABLE></CENTER><p>The described fragment prints a line on any type of printer, PostScript or not.The first <code>MoveTo/Line</code> combination is required to give the LaserWriter driver achance to define a clipping region. The LaserWriter driver replaces the<code>grafProcs</code> record in the <code>GrafPort</code> returned from <code>PrOpenDoc</code>. In order for theLaserWriter driver to get execution time, you must execute a QuickDraw drawingroutine that calls one of the <code>grafProcs</code>. In this case, the <code>MoveTo/Line</code>combination is sent firing the <code>StdLine</code> <code>grafProc</code>. When <code>StdLine</code> executes, itnotices that the GrafPort has been reinitialized, and therefore initializes theclipping region for the port. Until the MoveTo/Line combination is executed,the clipping region for the port is set to (0,0,0,0). If PostScript code issent via the <code>PostScriptHandle</code> <code>PicComment</code> before executing any QuickDrawroutines, all PostScript operations will be clipped to (0,0,0,0). The nextthing to do is send the PostScriptBegin <code>PicComment</code>. This comment is recognizedonly by PostScript printer drivers. When the driver receives this comment, itsaves the current state of the PostScript device (by executing the PostScriptgsave operator), then disables all QuickDraw drawing operations. This way, theQuickDraw representation of the Graphic will be ignored by PostScript devices.In the previous example, the <code>MoveTo/LineTo</code> combination is only executed onnon-PostScript devices. The next comment is the <code>PostScriptHandle</code> <code>PicComment</code>.This tells the driver that the data in <code>thePSHandle</code> is to be sent to the deviceas PostScript code. The driver then passes this code unchanged to thePostScript device for execution. The <code>PostScriptHandle</code> <code>PicComment</code> is onlyrecognized by PostScript printer drivers. The last <code>PicComment</code>, PostScriptEnd,tells the driver to restore the previous state of the device (via a PostScriptgrestore call), and to enable QuickDraw drawing operations. Since all<code>PicComment</code>s are ignored by QuickDraw devices, only the QuickDraw representationis printed. Since PostScriptBegin tells PostScript drivers to ignore QuickDrawoperations, only the PostScript representation is printed on PostScriptdevices. This is a truly device-independent method for providing bothPostScript and QuickDraw representations of a document.</p><P><A HREF="#top">Back to top</A></P><h2>Converting PostScript file to Encapsulated PostScript</h2><P>Date Written:  5/19/92</p><P>Last reviewed:  6/14/93</p><p>What needs to be added to an ordinary PostScript file to convert it to anEncapsulated PostScript (EPS) file?</p> <P>The latest Adobe "red book," PostScript Language Reference Manual (2ndEdition), has the information you need. Appendix H: Encapsulated PostScriptFile Format Version 3.0 describes the contents of an EPS file. Appendix G:Document Structuring Conventions specifies the single-page document PS file,which must include at least these two comments:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    %!PS-Adobe-3.0 EPSF-3.0</pre>	</TD></TR></TABLE></CENTER><p>You might find the following references from Adobe useful as well:</p><p>    Adobe Illustrator Document Format Specification v2.0 (Adobe Technical Note#LPS5007)</p>    <P>Encapsulated PostScript Files v1.2 (Adobe Technical Note #LPS5002)</p><P>You can reach Adobe at:</p><p>    Corporate Headquarters<br>    1585 Charleston Road, PO Box 7900<br>    Mountain View, CA 94039-7900<br>    (415) 961-4111 Developer Support</p><P>Macintosh Technical Note <A HREF = "../qd/qd_10.html">"Picture Comments--The Real Deal"</a> (formerly #91)contains sample code for using all of the supported Picture Comments.</p><P><A HREF="#top">Back to top</A></P><h2>Printing halftone images on the LaserWriter</h2><P>Date Written:  5/3/89</p><P>Last reviewed:  8/1/92</p><p>How can I print halftone images on the LaserWriter? How do I use the PostScript"image" operator for printing halftones?</p> <P>The PostScript "image" operator is similar to the Macintosh QuickDraw <code>CopyBits</code>routine. It can be used by converting a QuickDraw bitmap/pixmap into an imagecall. This is only necessary if you are printing color information with aPostScript printer driver that doesn't support Color QuickDraw. LaserWriterdrivers up to 5.2 do NOT support Color QuickDraw. If you want to send colorinformation to a LaserWriter with version 5.2 of the driver, you will have toconvert your color images into image commands. Before doing this it isimportant to check the <code>GrafPort</code> returned by <code>PrOpenDoc</code>. If this port is a ColorQuickDraw port (for example, <code>portBits.rowBytes &lt; 0</code>) then you should useColor QuickDraw commands and let the driver handle the conversion toPostScript.</p><p>About image: The PostScript image operator is used to send bitmaps or pixmapsto the LaserWriter. The image operator can handle depths from one to eight bitsper pixel. Our current LaserWriters can image only about 16 shades of gray, butthe printed page will look like there's more. Because the image operator isstill a PostScript operator, it expects its data in the form of hexadecimalbytes. The bytes are represented by two ASCII characters("0"-"9," "A"-"F") perbyte. The image operator takes these parameters: width height depth matriximage-data.</p><P>The first three are the width, height, and depth of the image, and the matrixis the transformation matrix to be applied to the current matrix. See thePostScript Language Reference Manual for more information. The image data iswhere the actual hex data should go. Instead of inserting the data between thefirst parameters and the image operator itself, it is better to use a smallPostScript procedure to read the data starting right after the image operator.For example:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>640 480 8 [640 0 0 480 0 0] {currentfile picstr readhexstring pop} image FF 00</pre>	</TD></TR></TABLE></CENTER><p>In the preceding example, the width of the image is 640, the height is 480, andthe depth is 8. The matrix (enclosed in brackets) is set up to draw the imagestarting at QuickDraw's 0,0(top left of page), and with no scaling. ThePostScript code (enclosed in braces) is not executed. Instead, it is passed tothe image operator, and the image operator calls it repeatedly until it hasenough data to draw the image. In this case, it is expecting 640*480 bytes.When the image operator calls the procedure, it does the following:</p><ol type="1">	<li>Pushes the current file which in this case is the stream of data coming to the LaserWriter over AppleTalk. This is the first parameter to the readhexstring operator.</li>	<li>Pushes <code>picstr. picstr</code> is a string variable defined to hold one row of hex data. The PostScript to create <code>the picstr</code> is:</li>	<li><code>readhexstring</code> is called to fill <code>picstr</code> with data from the current file. It begins reading bytes which are the characters following the image operator.</li>	<li><code>readhexstring</code> leaves the string we want, and a boolean that we don't want, on the stack, so we do one pop to kill off the boolean. Now the string is left behind for the image operator to use.</li></ol><p>Using the above PostScript code you can easily print an image. Just fill in thewidth height and depth, and send the hex data immediately following thePostScript code.</p><p>Setting up for image: Most of the users of this technique are going to want toprint a Color QuickDraw pixmap. Although the image command does a lot of thework for you, there are still a couple of tricks for performance:</p><p>Assume the maximum depth: Since the current version of the image operator has amaximum depth of eight bits/pixel, it is wise to convert the source image tothe same depth before imaging. You can do this very simply by using anoffscreen <code>GrafPort</code> that is set to eight bits/pixel, and then using CopyBits todo the depth conversion for you. This does a nice job of converting lowerresolution images to 8 bits/pixel.</p><p>Build a color table: An eight bit deep image can use only 256 colors. Since theimage that you are starting with is probably color, and the image you get willbe grayscale, you need to convert the colors in the source color table intoPostScript grayscale values. This is actually easy to do using the ColorManager. First create a table that can hold 512 bytes. This is two bytes foreach color value from 0 to 255. Since PostScript wants the values in ASCII, youneed two characters for each pixel. Now loop through the colors in the colortable. Call <code>Index2Color</code> to get the real RGB color for that index, and then call<code>RGB2HSL</code> to convert the RGB color into a luminance value. This value isexpressed as a <code>SmallFract</code> which can then be scaled into a value from 0 to 255.This value should then be converted to ASCII, and stored at the appropriatelocation in the table. When you are done, you should be able to use a pixelvalue as an index into your table of PostScript color values. For each pixel inthe image, send two characters to the LaserWriter.</p><p>Sending the data: Once you have set up the color table, all that's left to dois loop through all of the pixels, and send their PostScript representation tothe LaserWriter. There are a couple of ways to do this. One is to use thelow-level Print Manager interface and stream the PostScript using the <code>stdBufPrCtlCall</code>. Although this seems like it would be the fastest way, the latestversion of the LaserWriter driver (5.0) converts all low-level calls to theirhigh level equivalent before executing them, so the low-level interface is nolonger faster than the high level. Another way is to use the high-level PrintManager interface, and send the data via the <code>PostScriptHandle</code> <code>PicComment</code>. Thisenables you to buffer a large amount of data before actually sending it. Usingthis second technique, you should be able to image a Macintosh II screen inabout 5 minutes on a LaserWriter Plus, and about 1.5 minutes on a LaserWriterII NTX.</p><p>X-Ref:</p><P><i>PostScript Language Reference Manual,</i> Adobe Systems.</p>         <P><A HREF="#top">Back to top</A></P>         <a name=Downloads></A>                  <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (56K).</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/pr_505.pdf">Download</A></P>               </TD>            </TR>                    </TABLE>         <BR></TD></TR></table></center><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/pr/pr_505.html%3Fid%3DDTS10002645-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/pr/pr_505.html%3Fid%3DDTS10002645-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/pr/pr_505.html%3Fid%3DDTS10002645-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>