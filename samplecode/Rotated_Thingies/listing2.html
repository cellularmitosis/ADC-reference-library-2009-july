<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Rotated Thingies - /&hellip;using Text PicComments/Rotn Text.p</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxPrinting-date.html">Printing</a> &gt; <A HREF="javascript:location.replace('index.html');">Rotated Thingies</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Printing/index.html" target="_blank">Reference Library > Printing</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Rotated Thingies</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/&hellip;using Text PicComments/Rotn Text.p</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/…using Rotate PicComments/Rotn Objs.p</option>
<option value="listing2.html">/…using Text PicComments/Rotn Text.p</option></select>
				</p>
				</form>
				<p><strong><a href="Rotated_Thingies.zip">Download Sample</a></strong> (&#147;Rotated_Thingies.zip&#148;, 33.0K)<BR>
<strong><a href="Rotated_Thingies.dmg">Download Sample</a></strong> (&#147;Rotated_Thingies.dmg&#148;, 94.5K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">{  File:    Rotn Text.p  Contains:  Rotn Text demonstrates how to rotate text on PostScript printers        using the TextBegin/End PicComments.  PrGeneral is used to change        the resolution, which throws another wrench in the works; you have        to scale everything.  Written by: Dave Hersey    Copyright:  Copyright &copy; 1991-1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        7/26/1999  Karl Groethe  Updated for Metrowerks Codewarror Pro 2.1        }PROGRAM RotnText;USES  Memory, QuickDraw, ToolUtils, Traps, Printing, Packages,Devices,Fonts;CONST  {The following constants are used to identify menus and their items. The menu IDs   have an &quot;m&quot; prefix and the item numbers within each menu have an &quot;i&quot; prefix.}  rMenuBar  = 128;          {menubar}  mApple    = 128;          {Apple menu}  iAbout    = 1;  mFile    = 129;          {File menu}  iPrint    = 1;  iQuit    = 3;  mEdit    = 130;          {Edit menu}VAR  gQuitting  : Boolean;        {&quot;Are we all done?&quot; flag}{*------ RotateText -----------------------------------------------------------------*}{** **    RotateText draws the passed text rotated 45&iexcl; using the TextBegin/End **    comments.  The center of rotation and start of text drawing is done **    at the &quot;where&quot; point passed. **}{$S Main}PROCEDURE RotateText(theText : Str255; where : Point);  CONST    TextBegin  = 150;    TextEnd    = 151;    TextCenter  = 154;  TYPE    TTxtCenterHdl  = ^TTxtCenterPtr;    TTxtCenterPtr  = ^TTxtCenterRec;    TTxtCenterRec  = RECORD              y, x: Fixed;  {offset from current pen location to center of rotation.}              END;   { TTxtCenterRec }    TTxtPicHdl    = ^TTxtPicPtr;    TTxtPicPtr    = ^TTxtPicRec;    TTxtPicRec    = PACKED RECORD              tJus: Byte;    {0,1,2,3,4 -&gt; none, left, center, right, full justification.}              tFlip: Byte;  {0,1,2 -&gt; none, horizontal, vertical coordinate flip.}              tRot: integer;  {0..360 -&gt; clockwise rotation in degrees.}              tLine: Byte;  {1,2,3.. -&gt; single, 1 1/2, double.. spacing}              tCmnt: Byte;  {Reserved.}              END;   { TTxtPicRec }  VAR    txtHdl    : TTxtPicHdl;    txtCtr    : TTxtCenterHdl;  BEGIN  {Do a dummy draw to set the clipping region.}    PenSize(0, 0);    MoveTo(0, 0);    LineTo(0, 0);    PenSize(1, 1);    txtCtr := TTxtCenterHdl(NewHandle(SizeOf(TTxtCenterRec)));    txtCtr^^.y := 0; {no y offset to center of rotation}    txtCtr^^.x := 0; {no x offset to center of rotation}    txtHdl := TTxtPicHdl(NewHandle(SizeOf(TTxtPicRec)));    txtHdl^^.tJus := 0;   {no justification}    txtHdl^^.tFlip := 0; {no flip}    txtHdl^^.tRot := 45; {45&iexcl; rotation}    txtHdl^^.tLine := 1; {single spacing}  {Begin text rotation.}    PicComment(TextBegin,GetHandleSize(handle(txtHdl)),handle(txtHdl));  {Set the center of rotation and draw.}    MoveTo(where.h, where.v);    PicComment(TextCenter,GetHandleSize(handle(txtCtr)),handle(txtCtr));    DrawString(theText);  {Text rotation ends here.}    PicComment(TextEnd,0,NIL);    DisposeHandle(handle(txtHdl)); {Clean up}    DisposeHandle(handle(txtCtr));  END;  {**  RotateText  **}{*------ DrawStuff -----------------------------------------------------------------*}{** **    DrawStuff draws the objects.  prRsl is the resolution of the printer's **    GrafPort and is used to determine the amount to scale everything. **}{$S Main} PROCEDURE DrawStuff(theGPort : GrafPtr; prRsl : Integer); VAR  oldPort    : GrafPtr;  fNum    : Integer;  scalar    : Real;  where    : Point; BEGIN{Get the current port and save it.}    GetPort(oldPort);  SetPort(theGPort);    scalar := prRsl;    scalar := scalar / 72;  GetFNum('Times', fNum);  TextFont(fNum);  TextSize(Round(24 * scalar));  where.h := Round(50 * scalar);  where.v := Round(50 * scalar);  RotateText('This is a line of rotated text.', where);  SetPort(oldPort); END;  {**  DrawStuff  **}{*------ GetBestRsl -----------------------------------------------------------------*}{** **    GetBestRsl determines the best &quot;square&quot; resolution supported by the printer. **    For example, 300 dpi horizontal by 300 dpi vertical.  It isn't necessary to **    use square resolutions, but it generally proves easier.  We use PrGeneral and **    the getRslDataOp opCode to get a list of the supported resolutions for our **    printer.  Then we just go through the rgRslRec and find the maximum square **    resolution for discrete or non-discrete data, whichever we have.  Finally, we **    make sure it's divisible by 72 for cleaner scaling. **}{$S Main}FUNCTION GetBestRsl :Integer;VAR    err      : OSErr;    theRes, num  : Integer;    getRslData  : TGetRslBlk;BEGIN{Start off with our maximum resolution at 0, then call PrGeneral and parse our list of returned values.}    theRes := 0;    getRslData.iOpCode := getRslDataOp;    PrGeneral(@getRslData);    err := getRslData.iError;{If our printer only supports discrete resolutions, find the largest square one and use that.  If our printer supports a range of resolutions, choose the smaller of the maximum X and Y resolutions, then make it divisible by 72 for cleaner scaling.}    IF (err = noErr) THEN      IF (getRslData.XRslRg.iMax = 0) AND (getRslData.YRslRg.iMax = 0) THEN        BEGIN                                {Discrete resolutions.}          FOR num := 1 TO getRslData.iRslRecCnt DO            IF (getRslData.rgRslRec[num].iXRsl = getRslData.rgRslRec[num].iYRsl)              AND (theRes &lt; getRslData.rgRslRec[num].iXRsl) THEN                theRes := getRslData.rgRslRec[num].iXRsl;        END      ELSE        BEGIN                                {Variable resolutions.}          IF (getRslData.XRslRg.iMax &lt; getRslData.YRslRg.iMax) THEN            theRes := (getRslData.XRslRg.iMax DIV 72) * 72      {Use multiple of 72 closest to max. X resolution.}          ELSE            theRes := (getRslData.YRslRg.iMax DIV 72) * 72      {Use multiple of 72 closest to max. Y resolution.}        END;      {In the unlikely event that PrGeneral fails and theRes is still 0, set it to 72. This most likely is a supported resolution.  Finally return the best resolution we could find.}    IF theRes = 0 THEN theRes := 72;    GetBestRsl := theRes;END;  {**  GetBestRsl  **}{*------ PrintStuff ----------------------------------------------------------------*}{** **    PrintStuff will call all of the necessary Print Manager calls to print  **    a document. It checks PrError after each Print Manager call. If an error  **     is found, all of the Print Manager open calls (i.e. PrOpen, PrOpenDoc...)  **    will have a corresponding close call before the error is posted to the user.  **    You want to use this approach to make sure the Print Manager closes properly  **    and all temporary memory is released. **}{$S Main}PROCEDURE PrintStuff;VAR  oldPort      : GrafPtr;  thePrRecHdl    : THPrint;  thePrPort    : TPPrPort;  theStatus    : TPrStatus;  rslData      : TSetRslBlk;  err        : OSErr;  prRsl      : Integer;  bestRsl      : Integer;BEGIN{Get our current port and create a print handle.  If no errors, do our PrOpen call and, if no errors again, get the default settings for the current driver.}  GetPort(oldPort);  thePrRecHdl := THPrint(NewHandle(sizeof(TPrint)));    IF (MemError = noErr) THEN  BEGIN    PrOpen;    IF (PrError = noErr) THEN    BEGIN      PrintDefault(thePrRecHdl);      bestRsl := GetBestRsl;      rslData.iOpCode := SetRslOp;      rslData.hPrint := thePrRecHdl;      rslData.iXRsl := bestRsl;      rslData.iYRsl := bestRsl;      PrGeneral(@rslData);      err := rslData.iError;        prRsl := bestRsl;{If we still have no errors, give style and print job dialogs, then open a document and its page.  Keep checking for those dang printer errors.}      IF (PrError = noErr) THEN      BEGIN        IF (PrStlDialog(thePrRecHdl)) THEN          BEGIN          IF (PrJobDialog(thePrRecHdl)) THEN           BEGIN            thePrPort := PrOpenDoc(thePrRecHdl, NIL, NIL);                                 IF (PrError = noErr) THEN            BEGIN              PrOpenPage(thePrPort, NIL);{If we're still running error-free, draw our test page.  prRsl is the resolution of our printer port.}               IF (PrError = noErr) THEN                DrawStuff(GrafPtr(thePrPort), prRsl);{When done, close our page and document and spool the document if necessary.  When finshed, call PrClose to end the whole shabang.}               PrClosePage(thePrPort);            END;                           PrCloseDoc(thePrPort);                           IF (thePrRecHdl^^.prJob.bJDocLoop = bSpoolLoop) and (PrError = noErr) THEN              PrPicFile(thePrRecHdl, NIL, NIL, NIL, @theStatus);          END;        END;      END;    END;        PrClose;  END;END;  {**  PrintStuff  **}{*------ Initialize ----------------------------------------------------------------*}{** **    Initialize just handles necessary Toolbox initializing, setting our quitting  **    flag to FALSE and installing our menus. **}{$S Initialize}PROCEDURE Initialize;VAR  menuBar  : Handle;  BEGIN  InitGraf(@qd.thePort);  InitFonts;  InitWindows;  InitMenus;  TEInit;  InitDialogs(NIL);  InitCursor;  FlushEvents(everyEvent, 0);    gQuitting := FALSE;  menuBar := GetNewMBar(rMenuBar);    {read menus into menu bar}  IF (menuBar = NIL) THEN ExitToShell;  {should do real error stuff here.}  SetMenuBar(menuBar);          {install menus}  DisposeHandle(menuBar);  AppendResMenu(GetMenuHandle(mApple), 'DRVR');  {add DA names to Apple menu}  DrawMenuBar;END;  {**  Initialize  **}{$S _DataInit}PROCEDURE _DataInit; EXTERNAL;{This routine is automatically linked in by the MPW Linker. This external reference to it is done so that we can unload its segment, %A5Init.}{*------ DoMenuCommand ----------------------------------------------------------------*}{** **    DoMenuCommand is called when an item is chosen from the menu bar (after calling  **    MenuSelect or MenuKey).  It does the right thing for each command. **}{$S Main}PROCEDURE DoMenuCommand(menuResult: LONGINT);VAR  menuID, menuItem  : INTEGER;  daRefNum      : INTEGER;  daName        : Str255;BEGIN{Get the menu ID and item ID.}  menuID := HiWrd(menuResult);  menuItem := LoWrd(menuResult);  CASE menuID OF    mApple:      CASE menuItem OF        iAbout:        {bring up alert for About}          (* We do nothing here... *);        OTHERWISE        BEGIN    {all non-About items in this menu are DAs}          GetMenuItemText(GetMenuHandle(mApple), menuItem, daName);          daRefNum := OpenDeskAcc(daName);        END;      END;    mFile:              {File Menu}      CASE menuItem OF        iPrint:            {-&gt; Print Test Page.}          PrintStuff;        iQuit:          gQuitting := TRUE;    {-&gt; Quit}      END;  END;      HiliteMenu(0);END;  {**  DoMenuCommand  **}{*------ DoEvent ----------------------------------------------------------------*}{** **    DoEvent handles incoming events for our app.  In this skimpy sample, we **    only handle menu events and system clicks. **}{$S Main}PROCEDURE DoEvent;VAR  part    : INTEGER;  key      : Char;  event    : EventRecord;  window    : WindowPtr;BEGIN{Repeatedly handle menu selecting events until our quit flag is set.}  REPEAT    BEGIN      SystemTask;                  {This must be called if using GetNextEvent}      IF (GetNextEvent(everyEvent, event)) THEN        CASE event.what OF          mouseDown:            BEGIN              part := FindWindow(event.where, window);              CASE part OF                inMenuBar:                  DoMenuCommand(MenuSelect(event.where));                        inSysWindow:                  SystemClick(event, window);              END;            END;            keyDown, autoKey:            BEGIN              key := CHR(BAnd(event.message, charCodeMask));              IF (BAnd(event.modifiers, cmdKey) &lt;&gt; 0) AND (event.what = keyDown) THEN                DoMenuCommand(MenuKey(key));            END;        END;    END;  UNTIL gQuitting;END;  {**  DoEvent  **}{*------ Main ----------------------------------------------------------------*}{** **    Main kickstarts our app. **}{$S Main}BEGIN  //UnloadSeg(@_DataInit);  {note that _DataInit must not be in Main!}  MaxApplZone;      {expand the heap so code segments load at the top}  Initialize;        {initialize the program}  //UnloadSeg(@Initialize);  {note that Initialize must not be in Main!}  DoEvent;        {handle menu events until quitting.}END.  {**  Rotn Text.  **}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Rotated_Thingies/listing2.html%3Fid%3DDTS10000302-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Rotated_Thingies/listing2.html%3Fid%3DDTS10000302-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Rotated_Thingies/listing2.html%3Fid%3DDTS10000302-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>