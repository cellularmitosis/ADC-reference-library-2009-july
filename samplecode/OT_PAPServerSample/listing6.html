<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>OT PAPServerSample - /PAPPostScriptStuff.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxNetworking-date.html">Networking</a> &gt; <A HREF="javascript:location.replace('index.html');">OT PAPServerSample</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Networking/idxPrinting-date.html" target="_blank">Networking > Printing</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">OT PAPServerSample</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/PAPPostScriptStuff.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/ATalkSampleUtils.c</option>
<option value="listing2.html">/ATalkSampleUtils.h</option>
<option value="listing3.html">/CompEnv.h</option>
<option value="listing4.html">/EnableEOMSample.c</option>
<option value="listing5.html">/EnableSelfSendSample.c</option>
<option value="listing6.html">/PAPPostScriptStuff.c</option>
<option value="listing7.html">/PAPPostScriptStuff.h</option>
<option value="listing8.html">/PAPServerSample.c</option>
<option value="listing9.html">/PAPServerSample.h</option>
<option value="listing10.html">/PAPServerUtilities.c</option>
<option value="listing11.html">/PAPServerUtilities.h</option>
<option value="listing12.html">/SetServerStatusOption.c</option>
<option value="listing13.html">/StringUtils.c</option>
<option value="listing14.html">/StringUtils.h</option></select>
				</p>
				</form>
				<p><strong><a href="OT_PAPServerSample.zip">Download Sample</a></strong> (&#147;OT_PAPServerSample.zip&#148;, 93.6K)<BR>
<strong><a href="OT_PAPServerSample.dmg">Download Sample</a></strong> (&#147;OT_PAPServerSample.dmg&#148;, 157.6K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    PAPPostScriptStuff.c  Contains:  The following are routines used to support the handling of Postscript query         processing.  These are my own routines implemented to provide support for        the postscript queries from a laserwriter client.  All of the postscript        parsing related functions are included in this file.  I'd like to warn the        reader that this code is written to handle some basic postscript queries as        sent by Apple LaserWriter Client prior to v8.5.          The design of the routine presented here are to        1. recognize postscript queries as opposed to postscript data        2. parse postscript commands and return the default response.          This code does not support other Postscript clients or handling of other        than the default responses.  This may not be sufficient to support your        printer and client.          For more information on processing Postscript queries, contact Adobe for their        technote on this subject *** Get web address ***          A RIP or printer spooler would have to handle queries in a different manner.        In order to respond to the queris the spooler code might already have the        desired response, or may have to delay response until it can query the          printer to obtain the correct response.      My thanks to Mark Fleming for his help with debugging this code.  Written by: Rich Kubota    Copyright:  Copyright &copy; 1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        7/22/1999  Karl Groethe  Updated for Metrowerks Codewarror Pro 2.1                */#include &lt;ctype.h&gt;#include &quot;StringUtils.h&quot;#include &quot;PAPServerSample.h&quot;#include &quot;PAPPostScriptStuff.h&quot;extern PacketPtr  gTempPackPtr;char        gEOFStr[8] = kEOFStr;char        gBeginPSStr[8] = &quot;\045\041PS&quot;;    // = &quot;%!PS&quot;char        qBeginQueryStr[8] = kBeginQueryStr;char        gEndStr[8] = kEndStr;char        gQueryStr[8] = kQueryStr;extern OTLIFO*    gFreeQ;  extern Boolean    gDone;// prototypesBoolean FindString(const char *buffer, char *str, SInt16 lenStr, SInt16 *lenMatched,            SInt16 *pos, UInt16 numCharsInBuffer, Boolean matchAll);/*  The TestDataIsPSQuery is used to determine whether an incoming packet is the initial packet  for a postscript query, or is a continuing packet of a prelvious query started with some   previous packet.*/Boolean TestDataIsPSQuery(PacketPtr packetPtr){  MyEndpointRef   *theEp;  Boolean      result;  theEp = packetPtr-&gt;theEp;  if (TstInPSQueryFlag(theEp-&gt;flags))  // check if the endpoint is already processing a postscript    result = true;          // query for which we have not reached the EndQuery  else  {    result = IsPacketAPSQuery(packetPtr);    if (result == true)    {#if SHOW_DEBUG_FLOW          DebugStr(&quot;\p processing a postscript query;g&quot;);#endif      theEp-&gt;prevPtr = nil;  // initialize the prevPtr field to nil      SetInPSQueryFlag(theEp-&gt;flags);      theEp-&gt;psState = kLookingForEndStr;  // indicate that we have identified query beginning                    // and that the next step is to look for the EndQuery string        // set the time Data In timestamp field      BlockMove((Ptr)&amp;packetPtr-&gt;timeStamp, (Ptr)&amp;theEp-&gt;timeDataIn, sizeof(OTTimeStamp));        // reset the numBytesIn field to zero      theEp-&gt;numBytesIn = 0;          }  }    return result;}/*  ProcessPSQuery as used in this sample looks for the ps end...query string, then  gets the response and and sends it  The routine is designed to be called at deferred task time and uses OTAllocMem  instead of NewPtr or NewHandle    Note that this routine is responsible for enqueueing the processed packet ptr  to the freeQ, unless it appears that there is a partial match to a string that  we are looking for at the end of the buffer.  If so, then the packetPtr is  save with the endpoint ref to be used when the next incoming packet is processed    In this routine, the first while loop is where the contents of the ps query are  analyzed until the end of the packet is read.  As each default response is read,  an individual OTSnd call is made to send the default response.  Each response will   be made with the T_MORE flag bit set to keep the EOF bit from being sent in the  PAP responses. This routine does not queue multiple responses to send in a single  response.    When the end of the packet has been reached, the routine exits the while loop   and checks for the EOF indicator signaling the end of the query.  If the   EOF is read, then the call is made to SendEmptyPacket, which will result in  an empty packet with the EOF bit set.  The Apple LaserWriter client requires  receiving a last packet that has the eof bit set to know that the query has been  completely processed by the printer/server (even if the printer/server has responded  to all of the query items).*/OSStatus ProcessPSQuery(PacketPtr packetPtr){  OSStatus    err;  MyEndpointRef  *theEp;  PacketPtr    packPtr;  UInt16      offset;  UInt16      matchResult;  Boolean      done = false;  Boolean      testflag = false;  theEp = packetPtr-&gt;theEp;    // add the number of bytes in the packet to the numBytesIn field  theEp-&gt;numBytesIn += packetPtr-&gt;numBytes;    // set the time Data End timestamp field  BlockMove((Ptr)&amp;packetPtr-&gt;timeStamp, (Ptr)&amp;theEp-&gt;timeDataEnd, sizeof(OTTimeStamp));    err = kOTNoError;    // check whether we need to concatenate the current and previous packet ptrs  if ((packetPtr == theEp-&gt;prevPtr) || (theEp-&gt;prevPtr == nil))  {    DebugStr(&quot;\p no packet to append&quot;);    testflag = false;    packPtr = packetPtr;  }  else  {    DebugStr(&quot;\p checking how we append packets&quot;);    packPtr = gTempPackPtr;      // copy contents of the previous packet buffer to the new buffer    BlockMove((Ptr)theEp-&gt;prevPtr, (Ptr)packPtr, sizeof(PacketBuffer));    offset = sizeof(PacketBuffer) - kPAPDataSize + (theEp-&gt;prevPtr)-&gt;numBytes;    BlockMove((Ptr)&amp;(packetPtr-&gt;data), (Ptr)&amp;(packPtr-&gt;data[offset]), packetPtr-&gt;numBytes);      // adjust the numbytes field    packPtr-&gt;numBytes += packetPtr-&gt;numBytes;          // enqueue the previous packet ptr back to the gFreeQ since I not expecting a       // ps default response that overlaps 3 packets.      // fixed bug here where I release the current packetPtr instead of the previous      // packetPtr      OTLIFOEnqueue(gFreeQ, &amp;((theEp-&gt;prevPtr)-&gt;fLink));  // first field is fLink field  }    while (done == false)  {    switch (theEp-&gt;psState)    {      case kLookingForEndStr:        matchResult = FindQueryString(packPtr, kLookingForEndStr);        break;      case kLookingForQueryStr:        matchResult = FindQueryString(packPtr, kLookingForQueryStr);        break;      case kLookingForDefaultResponse:        if (testflag)          DebugStr(&quot;\p about to call ProcessDefaultResponse&quot;);                matchResult = ProcessDefaultResponse(packPtr);        break;    }                    switch (matchResult)    {      case kMatch:        if (theEp-&gt;psState == kLookingForDefaultResponse)          theEp-&gt;psState = kLookingForEndStr;        else          theEp-&gt;psState += 1;  // increment the state        break;            case kPartialMatch:        done = true;    // have to come around with the next packet        break;      case kNoMatch:        DebugStr(&quot;\p no match&quot;);                  // wasn't able to find a match, not even a                   // partial match, so set the pos to the end of the                  // packet        packPtr-&gt;lastPos = packPtr-&gt;numBytes;        done = true;    // have to come around with the next packet        break;    }  }    // check to see if we see the EOF flag        // this is the last packet of this query.    // check to see if the lastPos field is set to the end of the buffer    // this tels us the we are not awaiting a pending match for a partial    // string  if (packPtr-&gt;lastPos == packPtr-&gt;numBytes)  {      // reset the lastPos field so that we can search for the EOF string as the      // last few characters    packPtr-&gt;lastPos -= clen(gEOFStr);      // search for the EOF string at the end of the packet    matchResult = FindQueryString(packPtr, kLookingForEOFStr);      // since we reset lastPos, we need to restore it    packPtr-&gt;lastPos = packPtr-&gt;numBytes;          if (matchResult == kMatch)    {#if SHOW_DEBUG_FLOW        DebugStr(&quot;\p Sending a null packet;g&quot;);#endif        // send an empty response with EOF flag set since this is what the Laserwriter         // client wants to see.      SendEmptyPacket(packPtr);        // clear bit that indicates we are processing a postscript query      ClrInPSQueryFlag(theEp-&gt;flags);#if SHOW_DEBUG_FLOW        DebugStr(&quot;\p Have finished ps query;g&quot;);#endif    }      }          // check to see whether we processed all of the bytes in the packet.  if (packPtr-&gt;lastPos == packPtr-&gt;numBytes)  {    theEp-&gt;prevPtr = nil;  // if so, then don't save this packet in the prevPtr field.        // queue the buffer to the freeQ    OTLIFOEnqueue(gFreeQ, &amp;(packetPtr-&gt;fLink));  // first field is fLink field  }  else  {    theEp-&gt;prevPtr = packetPtr;  // we still have bytes to process.      //adjust the lastPos field    packetPtr-&gt;lastPos = packetPtr-&gt;numBytes - (packPtr-&gt;numBytes - packPtr-&gt;lastPos);      }        return err;  }/*  DoProcessPSQuery is used as the entry point to processing a postscript query.*/Boolean DoProcessPSQuery(PacketPtr  packetPtr){  OSStatus  err = kOTNoError;  Boolean    result = false;      if (TestDataIsPSQuery(packetPtr))  // is the packet a PS query  {    result = true;    // packet is a PostScript query and is being processed    err = ProcessPSQuery(packetPtr);          if (err &lt; kOTNoError)    {      DoValueBreak(err, &quot;error occured calling ProcessPSQuery #&quot;);        // show the error and quit the main event loop      gDone = true;    }      }  else  {      // we aren't processing PS query packets, so exit this routine      // the IsPacketQuery routine potentially sets the lastPos field      // so reset it back to 0;    packetPtr-&gt;lastPos = 0;  }    return result;}/*  FindString is used to find the iterate through the characters passed in the buffer  to find the string passed in str.  The length of the search string is passed in   lenStr.  pos is a pointer to the index where to start searching.  stopChar is the  last position of the buffer to search  input     buffer - pointer to buffer to search    str - string to match    lenStr - length of the str to match in buffer    pos - index where to begin search    numCharsInBuffer - index of last valid char in buffer    matchAll - match both upper and lower cases of the input string.    output -    lenMatched - number of character which were matched.  If no match, then            returns 0.    pos - index of the next char to look at for the next search.      If the str is not found in the buffer between the pos index and the stopChar,  *pos returns -1,  If a partial match is made at the end of the buffer, return the  negative offset*/Boolean FindString(const char *buffer, char *str, SInt16 lenStr, SInt16 *lenMatched,            SInt16 *pos, UInt16 numCharsInBuffer, Boolean matchAll){  SInt16    i;  SInt16    numToCompare;  Boolean    done = false;  Boolean    ok;    numToCompare = lenStr;  // set the number of chars to compare as the string len.  while (done == false)  // search until the flag is set to true.  {      // check whether the first character matches the character at the      // current index position    if ((buffer[*pos] == str[0]) || ((matchAll == true) &amp;&amp; (toupper(buffer[*pos]) ==             toupper(str[0]))))    {      if (numCharsInBuffer &lt; (*pos + lenStr))      {          // the has too few remaining characters to compare all of the current          // string.        numToCompare = numCharsInBuffer - *pos;              }        //init OK boolean      ok = true;      for (i = 1; (i &lt; numToCompare) &amp;&amp; ok; i++)      {        if ((buffer[*pos+i] == str[i]) || ((matchAll == true) &amp;&amp;             (toupper(buffer[*pos+1]) == toupper(str[i]))))          continue;         else          ok = false;              }        // we've done our testing, now see if we found a match      if (ok == true)    // was match found      {        *lenMatched = numToCompare;    // return the number of chars matched        *pos += numToCompare;      // return the next position in the buffer to start next search        done = true;          // search finished.      }    }        if (done == false)    {      *pos += 1;    // no match found so increment the place to start the next search iteration      if ((*pos+1) == numCharsInBuffer)      {          // no more characters in the buffer to search        *lenMatched = 0;    // set len matched to nothing          done = true;      // search finished.      }    }      }    return (*lenMatched != 0);}/*  IsPacketAPSQuery is used to check whether the contents of a packet are the beginning of  a PostScript query.  This can be found since there will be the signature stuff  at the beginning of the query.*/Boolean IsPacketAPSQuery(PacketPtr packetPtr){  SInt16    lenMatched, pos;  Boolean   result;    pos = 0;    // start search from the beginning of the buffer  result = FindString((char*)&amp;(packetPtr-&gt;data), gBeginPSStr, clen(gBeginPSStr),        &amp;lenMatched, &amp;pos, 4, kCaseMatchAll);  // must find the &quot;%!PS&quot; string in position 3 &amp; 4 of the buffer  if (result == true)  {      // the search found something in the first 4 characters of the buffer    if (lenMatched &lt; clen(gBeginPSStr))    {      result = false;    // didn't match 2 characters    }    else    {      result = FindString((char*)&amp;(packetPtr-&gt;data), qBeginQueryStr,               clen(qBeginQueryStr), &amp;lenMatched,               &amp;pos, 24, kCaseMatchAll);    // must find &quot;Query\015&quot; in pos 15 - 20 of the buffer      if (result == true)      {        if (lenMatched &lt; clen(qBeginQueryStr))          result = false;        else        {            // we're going to return a true result, to set the packetPtr.lastPos            // field to the current pos field.  When we start our next search, we             // do so at this position.          packetPtr-&gt;lastPos = pos;        }      }    }  }    return result;}UInt16  FindQueryString(PacketPtr packetPtr, SInt16 whichStr){  SInt16    lenMatched, pos;  UInt16    result1, len;  Boolean    result;  char    *str;    result1 = kNoMatch;        // initialize to no Match  pos = packetPtr-&gt;lastPos;    // start search from where we last stopped looking in buffer                  // first find the query prefix    switch (whichStr)  {    case kLookingForEndStr:      str = gEndStr;      len = clen(gEndStr);      break;        case kLookingForQueryStr:      str = gQueryStr;      len = clen(gQueryStr);      break;          case kLookingForEOFStr:      str = gEOFStr;      len = clen(gEOFStr);      break;  }  result = FindString((char*)&amp;(packetPtr-&gt;data), str, len,        &amp;lenMatched, &amp;pos, packetPtr-&gt;numBytes, kCaseMustMatch);      if (result == true)  {      // check that the proper string len was returned    if (lenMatched &lt; len)    {        // we have reached the end of the buffer and have found a partial match.      result1 = kPartialMatch;        // set the lastPos field to where the partial match begins      packetPtr-&gt;lastPos = pos - lenMatched;    }    else    {        // all parts found      result1 = kMatch;        // complete match found, so advance the lastPos field      packetPtr-&gt;lastPos = pos;    }  }    return result1;  }UInt16 ProcessDefaultResponse(PacketPtr packetPtr){  OTResult  otErr;  UInt32    pos, begin;  UInt16    result;  char    response[255];    // since we've found the end of the query chars, then there is at least a     // partial match  result = kPartialMatch;    // set pos to the lastPos position since this is the beginning of     // the query  begin = pos = packetPtr-&gt;lastPos;      // remove the leading space character which may precede the default response  while (packetPtr-&gt;data[pos] == kSpaceChar)  {    pos++;    begin++;  }        // gather the default response characters    while ((packetPtr-&gt;data[pos] != kReturnChar) &amp;&amp; (pos &lt; packetPtr-&gt;numBytes))  {      // gather default response characters    response[pos - begin] = packetPtr-&gt;data[pos];      // increment the counter    pos++;  }      // go ahead and set the terminating null character for the &quot;c&quot; string  if ((pos - begin) &lt; 255)    response[pos - begin] = 0;  else  {      // this should never happen, but if it does, I want to know about it.#if SHOW_DEBUG_FLOW//    DebugStr((const unsigned char *)&quot;\p response greater than 255 chars&quot;);#endif    response[255] = 0;  }        if (packetPtr-&gt;data[pos] == kReturnChar)  {      // we have found the end of the default response       // catenate a line feed character to the  response       ccatchr(response, kLineFeedChar, 1);    otErr = OTSnd((packetPtr-&gt;theEp)-&gt;ep, response, clen(response), T_MORE);    if (otErr &lt; 0)    {#if SHOW_DEBUG_FLOW      DoValueBreak((long)otErr, &quot;error occured sending PS response #&quot;);#endif    }    packetPtr-&gt;lastPos = pos;    result = kMatch;  }#if SHOW_DEBUG_FLOW  ccatchr(response, ';', 1);  ccatchr(response, 'g', 1);  c2p(response);//  DebugStr((const unsigned char*)response);#endif    return result;}/*  SendEmptyPacket is implemented to send an empty packet with the T_MORE flag not set.  The Apple LaserWriter client requires that the last response to a Postscript query  have the EOF flag set.  By having the EOM option enabled and sending a packet with   the T_MORE flag not set, OT/PAP will send an empty packet that has the EOF bit set.*/void SendEmptyPacket(PacketPtr packetPtr){  OTResult  err;  char    response[16];  err = OTSnd((packetPtr-&gt;theEp)-&gt;ep, &amp;response, 0, 0);  if (err != kOTNoError)  {#if SHOW_DEBUG_FLOW    DoValueBreak((long)err, &quot;error occured sending empty packet #&quot;);#endif  }  }</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/OT_PAPServerSample/listing6.html%3Fid%3DDTS10000243-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/OT_PAPServerSample/listing6.html%3Fid%3DDTS10000243-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/OT_PAPServerSample/listing6.html%3Fid%3DDTS10000243-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>