<html><head><title>Mac OS X
 Manual Page For tcpdump(1)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/1/tcpdump" title="Mac OS X
 Manual Page for tcpdump(1)"><!-- headerDoc=man; indexgroup=Section 1; uid="//apple_ref/doc/man/1/tcpdump"; name=tcpdump(1) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
TCPDUMP(1)                                                                                        TCPDUMP(1)



<b>NAME</b>
       tcpdump - dump traffic on a network

<b>SYNOPSIS</b>
       <b>tcpdump</b> [ <b>-AdDefKlLnNOpqRStuUvxX</b> ] [ <b>-c</b> <u>count</u> ]
               [ <b>-C</b> <u>file</u><b>_</b><u>size</u> ] [ <b>-F</b> <u>file</u> ]
               [ <b>-i</b> <u>interface</u> ] [ <b>-m</b> <u>module</u> ] [ <b>-M</b> <u>secret</u> ]
               [ <b>-r</b> <u>file</u> ] [ <b>-s</b> <u>snaplen</u> ] [ <b>-T</b> <u>type</u> ] [ <b>-w</b> <u>file</u> ]
               [ <b>-W</b> <u>filecount</u> ]
               [ <b>-E</b> <u>spi@ipaddr</u> <u>algo:secret,...</u>  ]
               [ <b>-y</b> <u>datalinktype</u> ] [ <b>-Z</b> <u>user</u> ]
               [ <u>expression</u> ]

<b>DESCRIPTION</b>
       <u>Tcpdump</u>  prints  out  a  description of the contents of packets on a network interface that match the
       boolean <u>expression</u>.  It can also be run with the <b>-w</b> flag, which causes it to save the packet data  to
       a  file for later analysis, and/or with the <b>-r</b> flag, which causes it to read from a saved packet file
       rather than to read packets from a network interface.  In all cases, only packets that match  <u>expres</u>-<font color="#ffffff" class="whiteout">sion&nbsp;expression</font>
       <u>sion</u> will be processed by <u>tcpdump</u>.

       <u>Tcpdump</u>  will,  if  not run with the <b>-c</b> flag, continue capturing packets until it is interrupted by a
       SIGINT signal (generated, for example, by typing your interrupt character, typically control-C) or  a
       SIGTERM  signal (typically generated with the <a href="kill.1.html#//apple_ref/doc/man/1/kill"><b>kill</b>(1)</a> command); if run with the <b>-c</b> flag, it will cap-<font color="#ffffff" class="whiteout">ture&nbsp;capture</font>
       ture packets until it is interrupted by a SIGINT or SIGTERM signal or the specified number of packets
       have been processed.

       When <u>tcpdump</u> finishes capturing packets, it will report counts of:

              packets ``captured'' (this is the number of packets that <u>tcpdump</u> has received and processed);

              packets  ``received by filter'' (the meaning of this depends on the OS on which you're running
              <u>tcpdump</u>, and possibly on the way the OS was configured - if a filter was specified on the com-<font color="#ffffff" class="whiteout">mand&nbsp;command</font>
              mand  line, on some OSes it counts packets regardless of whether they were matched by the fil-<font color="#ffffff" class="whiteout">ter&nbsp;filter</font>
              ter expression and, even if they were matched by the filter expression, regardless of  whether
              <u>tcpdump</u>  has  read  and  processed  them  yet,  on other OSes it counts only packets that were
              matched by the filter expression regardless of whether <u>tcpdump</u> has  read  and  processed  them
              yet,  and  on other OSes it counts only packets that were matched by the filter expression and
              were processed by <u>tcpdump</u>);

              packets ``dropped by kernel'' (this is the number of packets that were dropped, due to a  lack
              of buffer space, by the packet capture mechanism in the OS on which <u>tcpdump</u> is running, if the
              OS reports that information to applications; if not, it will be reported as 0).

       On platforms that support the SIGINFO signal, such as most  BSDs  (including  Mac  OS  X)  and  Digi-<font color="#ffffff" class="whiteout">tal/Tru64&nbsp;Digital/Tru64</font>
       tal/Tru64  UNIX,  it will report those counts when it receives a SIGINFO signal (generated, for exam-<font color="#ffffff" class="whiteout">ple,&nbsp;example,</font>
       ple, by typing your ``status'' character, typically control-T, although on some  platforms,  such  as
       Mac OS X, the ``status'' character is not set by default, so you must set it with <a href="stty.1.html#//apple_ref/doc/man/1/stty"><b>stty</b>(1)</a> in order to
       use it) and will continue capturing packets.

       Reading packets from a network interface may require that you have special privileges:

       <b>Under</b> <b>SunOS</b> <b>3.x</b> <b>or</b> <b>4.x</b> <b>with</b> <b>NIT</b> <b>or</b> <b>BPF:</b>
              You must have read access to <u>/dev/nit</u> or <u>/dev/bpf*</u>.

       <b>Under</b> <b>Solaris</b> <b>with</b> <b>DLPI:</b>
              You must have read/write access to the network pseudo device, e.g.  <u>/dev/le</u>.  On at least some
              versions  of Solaris, however, this is not sufficient to allow <u>tcpdump</u> to capture in promiscu-<font color="#ffffff" class="whiteout">ous&nbsp;promiscuous</font>
              ous mode; on those versions of Solaris, you must be root, or <u>tcpdump</u> must be installed  setuid
              to  root,  in  order  to capture in promiscuous mode.  Note that, on many (perhaps all) inter-<font color="#ffffff" class="whiteout">faces,&nbsp;interfaces,</font>
              faces, if you don't capture in promiscuous mode, you will not see any outgoing packets,  so  a
              capture not done in promiscuous mode may not be very useful.

       <b>Under</b> <b>HP-UX</b> <b>with</b> <b>DLPI:</b>
              You must be root or <u>tcpdump</u> must be installed setuid to root.

       <b>Under</b> <b>IRIX</b> <b>with</b> <b>snoop:</b>
              You must be root or <u>tcpdump</u> must be installed setuid to root.

       <b>Under</b> <b>Linux:</b>
              You  must  be root or <u>tcpdump</u> must be installed setuid to root (unless your distribution has a
              kernel that supports capability bits such as CAP_NET_RAW and code to  allow  those  capability
              bits  to be given to particular accounts and to cause those bits to be set on a user's initial
              processes when they log in, in which case you  must have CAP_NET_RAW in order to  capture  and
              CAP_NET_ADMIN to enumerate network devices with, for example, the <b>-D</b> flag).

       <b>Under</b> <b>ULTRIX</b> <b>and</b> <b>Digital</b> <b>UNIX/Tru64</b> <b>UNIX:</b>
              Any user may capture network traffic with <u>tcpdump</u>.  However, no user (not even the super-user)
              can capture in promiscuous mode on an interface unless the super-user has enabled promiscuous-<font color="#ffffff" class="whiteout">mode&nbsp;promiscuousmode</font>
              mode  operation on that interface using <!-- a --><u>pfconfig</u>(8)<!-- /a -->, and no user (not even the super-user) can
              capture unicast traffic received by or sent by the machine on an interface unless  the  super-<font color="#ffffff" class="whiteout">user&nbsp;superuser</font>
              user  has  enabled  copy-all-mode operation on that interface using <u>pfconfig</u>, so <u>useful</u> packet
              capture on an interface probably requires that either promiscuous-mode or copy-all-mode opera-<font color="#ffffff" class="whiteout">tion,&nbsp;operation,</font>
              tion, or both modes of operation, be enabled on that interface.

       <b>Under</b> <b>BSD</b> <b>(this</b> <b>includes</b> <b>Mac</b> <b>OS</b> <b>X):</b>
              You  must have read access to <u>/dev/bpf*</u> on systems that don't have a cloning BPF device, or to
              <u>/dev/bpf</u> on systems that do.  On BSDs with a devfs  (this  includes  Mac  OS  X),  this  might
              involve more than just having somebody with super-user access setting the ownership or permis-<font color="#ffffff" class="whiteout">sions&nbsp;permissions</font>
              sions on the BPF devices - it might involve configuring devfs to set the ownership or  permis-<font color="#ffffff" class="whiteout">sions&nbsp;permissions</font>
              sions every time the system is booted, if the system even supports that; if it doesn't support
              that, you might have to find some other way to make that happen at boot time.

       Reading a saved packet file doesn't require special privileges.

<b>OPTIONS</b>
       <b>-A</b>     Print each packet (minus its link level header) in ASCII.  Handy for capturing web pages.

       <b>-c</b>     Exit after receiving <u>count</u> packets.

       <b>-C</b>     Before writing a raw packet to a savefile, check whether the file  is  currently  larger  than
              <u>file</u><b>_</b><u>size</u>  and,  if  so,  close  the current savefile and open a new one.  Savefiles after the
              first savefile will have the name specified with the <b>-w</b> flag, with a number after it, starting
              at  1  and  continuing upward.  The units of <u>file</u><b>_</b><u>size</u> are millions of bytes (1,000,000 bytes,
              not 1,048,576 bytes).

       <b>-d</b>     Dump the compiled packet-matching code in a human readable form to standard output and stop.

       <b>-dd</b>    Dump packet-matching code as a <b>C</b> program fragment.

       <b>-ddd</b>   Dump packet-matching code as decimal numbers (preceded with a count).

       <b>-D</b>     Print the list of the network interfaces available on the system and on which <u>tcpdump</u> can cap-<font color="#ffffff" class="whiteout">ture&nbsp;capture</font>
              ture  packets.   For each network interface, a number and an interface name, possibly followed
              by a text description of the interface, is printed.  The interface name or the number  can  be
              supplied to the <b>-i</b> flag to specify an interface on which to capture.

              This  can  be useful on systems that don't have a command to list them (e.g., Windows systems,
              or UNIX systems lacking <b>ifconfig</b> <b>-a</b>); the number can be useful on Windows 2000 and later  sys-<font color="#ffffff" class="whiteout">tems,&nbsp;systems,</font>
              tems, where the interface name is a somewhat complex string.

              The  <b>-D</b>  flag will not be supported if <u>tcpdump</u> was built with an older version of <u>libpcap</u> that
              lacks the <b>pcap_findalldevs()</b> function.

       <b>-e</b>     Print the link-level header on each dump line.

       <b>-E</b>     Use <u>spi@ipaddr</u> <u>algo:secret</u> for decrypting IPsec ESP packets that are  addressed  to  <u>addr</u>  and
              contain  Security  Parameter  Index  value <u>spi</u>. This combination may be repeated with comma or
              newline seperation.

              Note that setting the secret for IPv4 ESP packets is supported at this time.

              Algorithms may be <b>des-cbc</b>, <b>3des-cbc</b>, <b>blowfish-cbc</b>, <b>rc3-cbc</b>, <b>cast128-cbc</b>, or <b>none</b>.  The default
              is <b>des-cbc</b>.  The ability to decrypt packets is only present if <u>tcpdump</u> was compiled with cryp-<font color="#ffffff" class="whiteout">tography&nbsp;cryptography</font>
              tography enabled.

              <u>secret</u> is the ASCII text for ESP secret key.  If preceeded by 0x, then a  hex  value  will  be
              read.

              The  option  assumes RFC2406 ESP, not RFC1827 ESP.  The option is only for debugging purposes,
              and the use of this option with a true `secret'  key  is  discouraged.   By  presenting  IPsec
              secret key onto command line you make it visible to others, via <a href="ps.1.html#//apple_ref/doc/man/1/ps"><u>ps</u>(1)</a> and other occasions.

              In  addition  to  the  above syntax, the syntax <u>file</u> <u>name</u> may be used to have tcpdump read the
              provided file in. The file is opened upon receiving the first ESP packet, so any special  per-<font color="#ffffff" class="whiteout">missions&nbsp;permissions</font>
              missions that tcpdump may have been given should already have been given up.

       <b>-f</b>     Print  `foreign'  IPv4 addresses numerically rather than symbolically (this option is intended
              to get around serious brain damage in Sun's NIS server -- usually it hangs forever translating
              non-local internet numbers).

              The test for `foreign' IPv4 addresses is done using the IPv4 address and netmask of the inter-<font color="#ffffff" class="whiteout">face&nbsp;interface</font>
              face on which capture is being done.  If that address or netmask are not available, available,
              either  because  the  interface  on  which  capture is being done has no address or netmask or
              because the capture is being done on the Linux "any" interface, which can capture on more than
              one interface, this option will not work correctly.

       <b>-F</b>     Use  <u>file</u>  as  input for the filter expression.  An additional expression given on the command
              line is ignored.

       <b>-i</b>     Listen on <u>interface</u>.  If unspecified, <u>tcpdump</u> searches the system interface list for the  low-<font color="#ffffff" class="whiteout">est&nbsp;lowest</font>
              est  numbered,  configured up interface (excluding loopback).  Ties are broken by choosing the
              earliest match.

              On Linux systems with 2.2 or later kernels, an <u>interface</u> argument of ``any'' can  be  used  to
              capture  packets  from  all  interfaces.  Note that captures on the ``any'' device will not be
              done in promiscuous mode.

              If the <b>-D</b> flag is supported, an interface number as printed by that flag can be  used  as  the
              <u>interface</u> argument.

       <b>-K</b>     Don't  attempt  to  verify  TCP checksums.  This is useful for interfaces that perform the TCP
              checksum calculation in hardware; otherwise, all outgoing TCP checksums  will  be  flagged  as
              bad.

       <b>-l</b>     Make stdout line buffered.  Useful if you want to see the data while capturing it.  E.g.,
              ``tcpdump  -l  |  tee dat'' or ``tcpdump  -l   &gt; dat  &amp;  tail  -f  dat''.

       <b>-L</b>     List the known data link types for the interface and exit.

       <b>-m</b>     Load  SMI  MIB  module definitions from file <u>module</u>.  This option can be used several times to
              load several MIB modules into <u>tcpdump</u>.

       <b>-M</b>     Use <u>secret</u> as a shared secret for validating the digests found in TCP segments with  the  TCP-<font color="#ffffff" class="whiteout">MD5&nbsp;TCPMD5</font>
              MD5 option (RFC 2385), if present.

       <b>-n</b>     Don't convert addresses (i.e., host addresses, port numbers, etc.) to names.

       <b>-N</b>     Don't print domain name qualification of host names.  E.g., if you give this flag then <u>tcpdump</u>
              will print ``nic'' instead of ``nic.ddn.mil''.

       <b>-O</b>     Do not run the packet-matching code optimizer.  This is useful only if you suspect  a  bug  in
              the optimizer.

       <b>-p</b>     <u>Don't</u>  put the interface into promiscuous mode.  Note that the interface might be in promiscu-<font color="#ffffff" class="whiteout">ous&nbsp;promiscuous</font>
              ous mode for some other reason; hence, `-p' cannot be used as an abbreviation for `ether  host
              {local-hw-addr} or ether broadcast'.

       <b>-q</b>     Quick (quiet?) output.  Print less protocol information so output lines are shorter.

       <b>-R</b>     Assume  ESP/AH  packets  to be based on old specification (RFC1825 to RFC1829).  If specified,
              <u>tcpdump</u> will not print replay prevention field.  Since there is no protocol version  field  in
              ESP/AH specification, <u>tcpdump</u> cannot deduce the version of ESP/AH protocol.

       <b>-r</b>     Read packets from <u>file</u> (which was created with the <b>-w</b> option).  Standard input is used if <u>file</u>
              is ``-''.

       <b>-S</b>     Print absolute, rather than relative, TCP sequence numbers.

       <b>-s</b>     Snarf <u>snaplen</u> bytes of data from each packet rather than the default of 68 (with SunOS's  NIT,
              the  minimum is actually 96).  68 bytes is adequate for IP, ICMP, TCP and UDP but may truncate
              protocol information from name server and NFS packets (see below).  Packets truncated  because
              of  a  limited snapshot are indicated in the output with ``[|<u>proto</u>]'', where <u>proto</u> is the name
              of the protocol level at which the truncation has occurred.  Note that taking larger snapshots
              both  increases the amount of time it takes to process packets and, effectively, decreases the
              amount of packet buffering.  This may cause packets to be lost.  You should limit  <u>snaplen</u>  to
              the  smallest number that will capture the protocol information you're interested in.  Setting
              <u>snaplen</u> to 0 means use the required length to catch whole packets.

       <b>-T</b>     Force packets selected by "<u>expression</u>" to be interpreted the specified <u>type</u>.  Currently  known
              types are <b>aodv</b> (Ad-hoc On-demand Distance Vector protocol), <b>cnfp</b> (Cisco NetFlow protocol), <b>rpc</b>
              (Remote Procedure Call), <b>rtp</b> (Real-Time Applications protocol), <b>rtcp</b>  (Real-Time  Applications
              control protocol), <b>snmp</b> (Simple Network Management Protocol), <b>tftp</b> (Trivial File Transfer Pro-<font color="#ffffff" class="whiteout">tocol),&nbsp;Protocol),</font>
              tocol), <b>vat</b> (Visual Audio Tool), and <b>wb</b> (distributed White Board).

       <b>-t</b>     <u>Don't</u> print a timestamp on each dump line.

       <b>-tt</b>    Print an unformatted timestamp on each dump line.

       <b>-ttt</b>   Print a delta (in micro-seconds) between current and previous line on each dump line.

       <b>-tttt</b>  Print a timestamp in default format proceeded by date on each dump line.

       <b>-u</b>     Print undecoded NFS handles.

       <b>-U</b>     Make output saved via the <b>-w</b> option ``packet-buffered''; i.e., as each  packet  is  saved,  it
              will  be  written  to  the  output file, rather than being written only when the output buffer
              fills.

              The <b>-U</b> flag will not be supported if <u>tcpdump</u> was built with an older version of  <u>libpcap</u>  that
              lacks the <b>pcap_dump_flush()</b> function.

       <b>-v</b>     When  parsing  and printing, produce (slightly more) verbose output.  For example, the time to
              live, identification, total length and options in an IP  packet  are  printed.   Also  enables
              additional packet integrity checks such as verifying the IP and ICMP header checksum.

              When  writing  to  a  file with the <b>-w</b> option, report, every 10 seconds, the number of packets
              captured.

       <b>-vv</b>    Even more verbose output.  For example, additional fields are printed from NFS reply  packets,
              and SMB packets are fully decoded.

       <b>-vvv</b>   Even more verbose output.  For example, telnet <b>SB</b> ... <b>SE</b> options are printed in full.  With <b>-X</b>
              Telnet options are printed in hex as well.

       <b>-w</b>     Write the raw packets to <u>file</u> rather than parsing and printing them out.  They  can  later  be
              printed with the -r option.  Standard output is used if <u>file</u> is ``-''.

       <b>-W</b>     Used  in  conjunction  with  the <b>-C</b> option, this will limit the number of files created to the
              specified number, and begin overwriting files from the beginning, thus creating  a  'rotating'
              buffer.   In  addition,  it  will name the files with enough leading 0s to support the maximum
              number of files, allowing them to sort correctly.

       <b>-x</b>     When parsing and printing, in addition to printing the headers of each packet, print the  data
              of  each  packet  (minus  its  link level header) in hex.  The smaller of the entire packet or
              <u>snaplen</u> bytes will be printed.  Note that this is the entire link-layer packet,  so  for  link
              layers  that pad (e.g. Ethernet), the padding bytes will also be printed when the higher layer
              packet is shorter than the required padding.

       <b>-xx</b>    When parsing and printing, in addition to printing the headers of each packet, print the  data
              of each packet, <u>including</u> its link level header, in hex.

       <b>-X</b>     When  parsing and printing, in addition to printing the headers of each packet, print the data
              of each packet (minus its link level header) in  hex  and  ASCII.   This  is  very  handy  for
              analysing new protocols.

       <b>-XX</b>    When  parsing and printing, in addition to printing the headers of each packet, print the data
              of each packet, <u>including</u> its link level header, in hex and ASCII.

       <b>-y</b>     Set the data link type to use while capturing packets to <u>datalinktype</u>.

       <b>-Z</b>     Drops privileges (if root) and changes user ID to <u>user</u> and the group ID to the  primary  group
              of <u>user</u>.

              This behavior can also be enabled by default at compile time.

        <u>expression</u>
              selects  which packets will be dumped.  If no <u>expression</u> is given, all packets on the net will
              be dumped.  Otherwise, only packets for which <u>expression</u> is `true' will be dumped.

              The <u>expression</u> consists of one or more <u>primitives.</u>  Primitives usually consist of an <u>id</u>  (name
              or number) preceded by one or more qualifiers.  There are three different kinds of qualifier:

              <u>type</u>   qualifiers  say what kind of thing the id name or number refers to.  Possible types are
                     <b>host</b>, <b>net</b> <b>,</b> <b>port</b> and <b>portrange</b>.  E.g., `host foo', `net 128.3', `port  20',  `portrange
                     6000-6008'.  If there is no type qualifier, <b>host</b> is assumed.

              <u>dir</u>    qualifiers  specify a particular transfer direction to and/or from <u>id</u>.  Possible direc-<font color="#ffffff" class="whiteout">tions&nbsp;directions</font>
                     tions are <b>src</b>, <b>dst</b>, <b>src</b> <b>or</b> <b>dst</b> and <b>src</b> <b>and</b> <b>dst</b>.  E.g., `src foo', `dst net 128.3', `src
                     or  dst port ftp-data'.  If there is no dir qualifier, <b>src</b> <b>or</b> <b>dst</b> is assumed.  For some
                     link layers, such as SLIP and the ``cooked'' Linux capture mode used  for  the  ``any''
                     device and for some other device types, the <b>inbound</b> and <b>outbound</b> qualifiers can be used
                     to specify a desired direction.

              <u>proto</u>  qualifiers restrict the match to a particular protocol.  Possible  protos  are:  <b>ether</b>,
                     <b>fddi</b>,  <b>tr</b>,  <b>wlan</b>, <b>ip</b>, <b>ip6</b>, <b>arp</b>, <b>rarp</b>, <b>decnet</b>, <b>tcp</b> and <b>udp</b>.  E.g., `ether src foo', `arp
                     net 128.3', `tcp port 21', `udp portrange 7000-7009'.  If there is no proto  qualifier,
                     all  protocols consistent with the type are assumed.  E.g., `src foo' means `(ip or arp
                     or rarp) src foo' (except the latter is not legal syntax), `net bar' means `(ip or  arp
                     or rarp) net bar' and `port 53' means `(tcp or udp) port 53'.

              [`fddi'  is actually an alias for `ether'; the parser treats them identically as meaning ``the
              data link level used on the specified network interface.''  FDDI headers contain Ethernet-like
              source  and  destination  addresses,  and often contain Ethernet-like packet types, so you can
              filter on these FDDI fields just as with the analogous Ethernet  fields.   FDDI  headers  also
              contain other fields, but you cannot name them explicitly in a filter expression.

              Similarly,  `tr' and `wlan' are aliases for `ether'; the previous paragraph's statements about
              FDDI headers also apply to Token Ring and 802.11 wireless LAN headers.   For  802.11  headers,
              the destination address is the DA field and the source address is the SA field; the BSSID, RA,
              and TA fields aren't tested.]

              In addition to the above, there are some special `primitive' keywords that  don't  follow  the
              pattern:  <b>gateway</b>,  <b>broadcast</b>,  <b>less</b>,  <b>greater</b>  and  arithmetic expressions.  All of these are
              described below.

              More complex filter expressions are built up by using the words <b>and</b>, <b>or</b>  and  <b>not</b>  to  combine
              primitives.  E.g., `host foo and not port ftp and not port ftp-data'.  To save typing, identi-<font color="#ffffff" class="whiteout">cal&nbsp;identical</font>
              cal qualifier lists can be omitted.  E.g., `tcp dst port ftp or ftp-data or domain' is exactly
              the same as `tcp dst port ftp or tcp dst port ftp-data or tcp dst port domain'.

              Allowable primitives are:

              <b>dst</b> <b>host</b> <u>host</u>
                     True  if  the  IPv4/v6  destination field of the packet is <u>host</u>, which may be either an
                     address or a name.

              <b>src</b> <b>host</b> <u>host</u>
                     True if the IPv4/v6 source field of the packet is <u>host</u>.

              <b>host</b> <u>host</u>
                     True if either the IPv4/v6 source or destination of the packet is <u>host</u>.

                     Any of the above host expressions can be prepended with the keywords, <b>ip</b>, <b>arp</b>, <b>rarp</b>, or
                     <b>ip6</b> as in:
                          <b>ip</b> <b>host</b> <u>host</u>
                     which is equivalent to:
                          <b>ether</b> <b>proto</b> <u>\ip</u> <b>and</b> <b>host</b> <u>host</u>
                     If <u>host</u> is a name with multiple IP addresses, each address will be checked for a match.

              <b>ether</b> <b>dst</b> <u>ehost</u>
                     True if the Ethernet destination address is <u>ehost</u>.  <u>Ehost</u> may be  either  a  name  from
                     /etc/ethers or a number (see <a href="../man3/ethers.3.html#//apple_ref/doc/man/3/ethers"><u>ethers</u>(3N)</a> for numeric format).

              <b>ether</b> <b>src</b> <u>ehost</u>
                     True if the Ethernet source address is <u>ehost</u>.

              <b>ether</b> <b>host</b> <u>ehost</u>
                     True if either the Ethernet source or destination address is <u>ehost</u>.

              <b>gateway</b> <u>host</u>
                     True  if  the  packet used <u>host</u> as a gateway.  I.e., the Ethernet source or destination
                     address was <u>host</u> but neither the IP source nor the IP destination was <u>host</u>.  <u>Host</u>  must
                     be  a  name  and must be found both by the machine's host-name-to-IP-address resolution
                     mechanisms (host name file, DNS, NIS, etc.) and by the machine's host-name-to-Ethernet-<font color="#ffffff" class="whiteout">address&nbsp;host-name-to-Ethernetaddress</font>
                     address resolution mechanism (/etc/ethers, etc.).  (An equivalent expression is
                          <b>ether</b> <b>host</b> <u>ehost</u> <b>and</b> <b>not</b> <b>host</b> <u>host</u>
                     which can be used with either names or numbers for <u>host</u> <u>/</u> <u>ehost</u>.)  This syntax does not
                     work in IPv6-enabled configuration at this moment.

              <b>dst</b> <b>net</b> <u>net</u>
                     True if the IPv4/v6 destination address of the packet has a network number of <u>net</u>.  <u>Net</u>
                     may be either a name from the networks database (/etc/networks, etc.) or a network num-<font color="#ffffff" class="whiteout">ber.&nbsp;number.</font>
                     ber.  An IPv4 network number can be written as a dotted quad (e.g., 192.168.1.0),  dot-<font color="#ffffff" class="whiteout">ted&nbsp;dotted</font>
                     ted  triple  (e.g., 192.168.1), dotted pair (e.g, 172.16), or single number (e.g., 10);
                     the netmask is 255.255.255.255 for a dotted quad (which means that it's really  a  host
                     match),  255.255.255.0 for a dotted triple, 255.255.0.0 for a dotted pair, or 255.0.0.0
                     for a single number.  An IPv6 network number must be written out fully; the netmask  is
                     ff:ff:ff:ff:ff:ff:ff:ff,  so IPv6 "network" matches are really always host matches, and
                     a network match requires a netmask length.

              <b>src</b> <b>net</b> <u>net</u>
                     True if the IPv4/v6 source address of the packet has a network number of <u>net</u>.

              <b>net</b> <u>net</u>
                     True if either the IPv4/v6 source or destination address of the packet  has  a  network
                     number of <u>net</u>.

              <b>net</b> <u>net</u> <b>mask</b> <u>netmask</u>
                     True  if the IPv4 address matches <u>net</u> with the specific <u>netmask</u>.  May be qualified with
                     <b>src</b> or <b>dst</b>.  Note that this syntax is not valid for IPv6 <u>net</u>.

              <b>net</b> <u>net</u>/<u>len</u>
                     True if the IPv4/v6 address matches <u>net</u> with a netmask <u>len</u> bits wide.  May be qualified
                     with <b>src</b> or <b>dst</b>.

              <b>dst</b> <b>port</b> <u>port</u>
                     True  if  the  packet  is ip/tcp, ip/udp, ip6/tcp or ip6/udp and has a destination port
                     value of <u>port</u>.  The <u>port</u> can be a number or a name used in /etc/services  (see  <a href="../man4/tcp.4.html#//apple_ref/doc/man/4/tcp"><u>tcp</u>(4P)</a>
                     and  <a href="../man4/udp.4.html#//apple_ref/doc/man/4/udp"><u>udp</u>(4P)</a>).  If a name is used, both the port number and protocol are checked.  If a
                     number or ambiguous name is used, only the port number is checked (e.g., <b>dst</b>  <b>port</b>  <b>513</b>
                     will  print both tcp/login traffic and udp/who traffic, and <b>port</b> <b>domain</b> will print both
                     tcp/domain and udp/domain traffic).

              <b>src</b> <b>port</b> <u>port</u>
                     True if the packet has a source port value of <u>port</u>.

              <b>port</b> <u>port</u>
                     True if either the source or destination port of the packet is <u>port</u>.

              <b>dst</b> <b>portrange</b> <u>port1</u><b>-</b><u>port2</u>
                     True if the packet is ip/tcp, ip/udp, ip6/tcp or ip6/udp and  has  a  destination  port
                     value  between <u>port1</u> and <u>port2</u>.  <u>port1</u> and <u>port2</u> are interpreted in the same fashion as
                     the <u>port</u> parameter for <b>port</b>.

              <b>src</b> <b>portrange</b> <u>port1</u><b>-</b><u>port2</u>
                     True if the packet has a source port value between <u>port1</u> and <u>port2</u>.

              <b>portrange</b> <u>port1</u><b>-</b><u>port2</u>
                     True if either the source or destination port of the packet is between <u>port1</u> and <u>port2</u>.

                     Any of the above port or port range expressions can be prepended with the keywords, <b>tcp</b>
                     or <b>udp</b>, as in:
                          <b>tcp</b> <b>src</b> <b>port</b> <u>port</u>
                     which matches only tcp packets whose source port is <u>port</u>.

              <b>less</b> <u>length</u>
                     True if the packet has a length less than or equal to <u>length</u>.  This is equivalent to:
                          <b>len</b> <b>&lt;=</b> <u>length</u><b>.</b>

              <b>greater</b> <u>length</u>
                     True if the packet has a length greater than or equal to <u>length</u>.   This  is  equivalent
                     to:
                          <b>len</b> <b>&gt;=</b> <u>length</u><b>.</b>

              <b>ip</b> <b>proto</b> <u>protocol</u>
                     True  if the packet is an IPv4 packet (see <a href="../man4/ip.4.html#//apple_ref/doc/man/4/ip"><u>ip</u>(4P)</a>) of protocol type <u>protocol</u>.  <u>Protocol</u>
                     can be a number or one of the names <b>icmp</b>, <b>icmp6</b>, <b>igmp</b>, <b>igrp</b>, <b>pim</b>, <b>ah</b>, <b>esp</b>,  <b>vrrp</b>,  <b>udp</b>,
                     or  <b>tcp</b>.   Note  that  the identifiers <b>tcp</b>, <b>udp</b>, and <b>icmp</b> are also keywords and must be
                     escaped via backslash (\), which is \\ in the C-shell.  Note that this  primitive  does
                     not chase the protocol header chain.

              <b>ip6</b> <b>proto</b> <u>protocol</u>
                     True  if the packet is an IPv6 packet of protocol type <u>protocol</u>.  Note that this primi-<font color="#ffffff" class="whiteout">tive&nbsp;primitive</font>
                     tive does not chase the protocol header chain.

              <b>ip6</b> <b>protochain</b> <u>protocol</u>
                     True if the packet is IPv6 packet, and contains protocol header with type  <u>protocol</u>  in
                     its protocol header chain.  For example,
                          <b>ip6</b> <b>protochain</b> <b>6</b>
                     matches  any  IPv6  packet  with TCP protocol header in the protocol header chain.  The
                     packet may contain, for example, authentication header, routing header,  or  hop-by-hop
                     option header, between IPv6 header and TCP header.  The BPF code emitted by this primi-<font color="#ffffff" class="whiteout">tive&nbsp;primitive</font>
                     tive is complex and cannot be optimized by BPF optimizer code in <u>tcpdump</u>, so  this  can
                     be somewhat slow.

              <b>ip</b> <b>protochain</b> <u>protocol</u>
                     Equivalent to <b>ip6</b> <b>protochain</b> <u>protocol</u>, but this is for IPv4.

              <b>ether</b> <b>broadcast</b>
                     True if the packet is an Ethernet broadcast packet.  The <u>ether</u> keyword is optional.

              <b>ip</b> <b>broadcast</b>
                     True  if the packet is an IPv4 broadcast packet.  It checks for both the all-zeroes and
                     all-ones broadcast conventions, and looks up the subnet mask on the interface on  which
                     the capture is being done.

                     If  the  subnet  mask of the interface on which the capture is being done is not avail-<font color="#ffffff" class="whiteout">able,&nbsp;available,</font>
                     able, either because the interface on which capture is being done  has  no  netmask  or
                     because  the  capture  is being done on the Linux "any" interface, which can capture on
                     more than one interface, this check will not work correctly.

              <b>ether</b> <b>multicast</b>
                     True if the packet is an Ethernet multicast packet.  The  <b>ether</b>  keyword  is  optional.
                     This is shorthand for `<b>ether[0]</b> <b>&amp;</b> <b>1</b> <b>!=</b> <b>0</b>'.

              <b>ip</b> <b>multicast</b>
                     True if the packet is an IPv4 multicast packet.

              <b>ip6</b> <b>multicast</b>
                     True if the packet is an IPv6 multicast packet.

              <b>ether</b> <b>proto</b> <u>protocol</u>
                     True  if  the packet is of ether type <u>protocol</u>.  <u>Protocol</u> can be a number or one of the
                     names <b>ip</b>, <b>ip6</b>, <b>arp</b>, <b>rarp</b>, <b>atalk</b>, <b>aarp</b>, <b>decnet</b>, <b>sca</b>, <b>lat</b>, <b>mopdl</b>, <b>moprc</b>, <b>iso</b>,  <b>stp</b>,  <b>ipx</b>,
                     or <b>netbeui</b>.  Note these identifiers are also keywords and must be escaped via backslash
                     (\).

                     [In the case of FDDI (e.g., `<b>fddi</b> <b>protocol</b> <b>arp</b>'), Token Ring (e.g., `<b>tr</b> <b>protocol</b> <b>arp</b>'),
                     and IEEE 802.11 wireless LANS (e.g., `<b>wlan</b> <b>protocol</b> <b>arp</b>'), for most of those protocols,
                     the protocol identification comes from the 802.2 Logical  Link  Control  (LLC)  header,
                     which is usually layered on top of the FDDI, Token Ring, or 802.11 header.

                     When  filtering  for  most protocol identifiers on FDDI, Token Ring, or 802.11, <u>tcpdump</u>
                     checks only the protocol ID field of an LLC header in so-called  SNAP  format  with  an
                     Organizational Unit Identifier (OUI) of 0x000000, for encapsulated Ethernet; it doesn't
                     check whether the packet is in SNAP format with an OUI  of  0x000000.   The  exceptions
                     are:

                     <b>iso</b>    <u>tcpdump</u> checks the DSAP (Destination Service Access Point) and SSAP (Source Ser-<font color="#ffffff" class="whiteout">vice&nbsp;Service</font>
                            vice Access Point) fields of the LLC header;

                     <b>stp</b> and <b>netbeui</b>
                            <u>tcpdump</u> checks the DSAP of the LLC header;

                     <b>atalk</b>  <u>tcpdump</u> checks for a  SNAP-format  packet  with  an  OUI  of  0x080007  and  the
                            AppleTalk etype.

                     In  the case of Ethernet, <u>tcpdump</u> checks the Ethernet type field for most of those pro-<font color="#ffffff" class="whiteout">tocols.&nbsp;protocols.</font>
                     tocols.  The exceptions are:

                     <b>iso</b>, <b>stp</b>, and <b>netbeui</b>
                            <u>tcpdump</u> checks for an 802.3 frame and then checks the LLC header as it does  for
                            FDDI, Token Ring, and 802.11;

                     <b>atalk</b>  <u>tcpdump</u> checks both for the AppleTalk etype in an Ethernet frame and for a SNAP-<font color="#ffffff" class="whiteout">format&nbsp;SNAPformat</font>
                            format packet as it does for FDDI, Token Ring, and 802.11;

                     <b>aarp</b>   <u>tcpdump</u> checks for the AppleTalk ARP etype in either an  Ethernet  frame  or  an
                            802.2 SNAP frame with an OUI of 0x000000;

                     <b>ipx</b>    <u>tcpdump</u>  checks  for the IPX etype in an Ethernet frame, the IPX DSAP in the LLC
                            header, the 802.3-with-no-LLC-header encapsulation of IPX, and the IPX etype  in
                            a SNAP frame.

              <b>decnet</b> <b>src</b> <u>host</u>
                     True  if  the  DECNET  source  address  is  <u>host</u>,  which  may be an address of the form
                     ``10.123'', or a DECNET host name.  [DECNET host name  support  is  only  available  on
                     ULTRIX systems that are configured to run DECNET.]

              <b>decnet</b> <b>dst</b> <u>host</u>
                     True if the DECNET destination address is <u>host</u>.

              <b>decnet</b> <b>host</b> <u>host</u>
                     True if either the DECNET source or destination address is <u>host</u>.

              <b>ifname</b> <u>interface</u>
                     True  if  the packet was logged as coming from the specified interface (applies only to
                     packets logged by OpenBSD's <!-- a --><b>pf</b>(4)<!-- /a -->).

              <b>on</b> <u>interface</u>
                     Synonymous with the <b>ifname</b> modifier.

              <b>rnr</b> <u>num</u>
                     True if the packet was logged as matching the specified PF rule number (applies only to
                     packets logged by OpenBSD's <!-- a --><b>pf</b>(4)<!-- /a -->).

              <b>rulenum</b> <u>num</u>
                     Synonomous with the <b>rnr</b> modifier.

              <b>reason</b> <u>code</u>
                     True  if the packet was logged with the specified PF reason code.  The known codes are:
                     <b>match</b>, <b>bad-offset</b>, <b>fragment</b>, <b>short</b>, <b>normalize</b>, and  <b>memory</b>  (applies  only  to  packets
                     logged by OpenBSD's <!-- a --><b>pf</b>(4)<!-- /a -->).

              <b>rset</b> <u>name</u>
                     True  if the packet was logged as matching the specified PF ruleset name of an anchored
                     ruleset (applies only to packets logged by <!-- a --><b>pf</b>(4)<!-- /a -->).

              <b>ruleset</b> <u>name</u>
                     Synonomous with the <b>rset</b> modifier.

              <b>srnr</b> <u>num</u>
                     True if the packet was logged as matching the specified PF rule number of  an  anchored
                     ruleset (applies only to packets logged by <!-- a --><b>pf</b>(4)<!-- /a -->).

              <b>subrulenum</b> <u>num</u>
                     Synonomous with the <b>srnr</b> modifier.

              <b>action</b> <u>act</u>
                     True  if  PF  took the specified action when the packet was logged.  Known actions are:
                     <b>pass</b> and <b>block</b> (applies only to packets logged by OpenBSD's <!-- a --><b>pf</b>(4)<!-- /a -->).

              <b>ip</b>, <b>ip6</b>, <b>arp</b>, <b>rarp</b>, <b>atalk</b>, <b>aarp</b>, <b>decnet</b>, <b>iso</b>, <b>stp</b>, <b>ipx</b>, <u>netbeui</u>
                     Abbreviations for:
                          <b>ether</b> <b>proto</b> <u>p</u>
                     where <u>p</u> is one of the above protocols.

              <b>lat</b>, <b>moprc</b>, <b>mopdl</b>
                     Abbreviations for:
                          <b>ether</b> <b>proto</b> <u>p</u>
                     where <u>p</u> is one of the above protocols.  Note that <u>tcpdump</u> does not currently  know  how
                     to parse these protocols.

              <b>vlan</b> <u>[vlan</u><b>_</b><u>id]</u>
                     True if the packet is an IEEE 802.1Q VLAN packet.  If <u>[vlan</u><b>_</b><u>id]</u> is specified, only true
                     if the packet has the specified <u>vlan</u><b>_</b><u>id</u>.  Note that the first <b>vlan</b> keyword  encountered
                     in  <u>expression</u>  changes  the  decoding  offsets  for the remainder of <u>expression</u> on the
                     assumption that the packet is a VLAN packet.  The <b>vlan</b> <u>[vlan</u><b>_</b><u>id]</u> expression may be used
                     more  than once, to filter on VLAN hierarchies.  Each use of that expression increments
                     the filter offsets by 4.

                     For example:
                          <b>vlan</b> <b>100</b> <b>&amp;&amp;</b> <b>vlan</b> <b>200</b>
                     filters on VLAN 200 encapsulated within VLAN 100, and
                          <b>vlan</b> <b>&amp;&amp;</b> <b>vlan</b> <b>300</b> <b>&amp;&amp;</b> <b>ip</b>
                     filters IPv4 protocols encapsulated in VLAN 300 encapsulated within  any  higher  order
                     VLAN.

              <b>mpls</b> <u>[label</u><b>_</b><u>num]</u>
                     True  if  the  packet is an MPLS packet.  If <u>[label</u><b>_</b><u>num]</u> is specified, only true is the
                     packet has the specified <u>label</u><b>_</b><u>num</u>.  Note that the first <b>mpls</b>  keyword  encountered  in
                     <u>expression</u>  changes the decoding offsets for the remainder of <u>expression</u> on the assump-<font color="#ffffff" class="whiteout">tion&nbsp;assumption</font>
                     tion that the packet is a MPLS-encapsulated IP packet.  The <b>mpls</b> <u>[label</u><b>_</b><u>num]</u> expression
                     may be used more than once, to filter on MPLS hierarchies.  Each use of that expression
                     increments the filter offsets by 4.

                     For example:
                          <b>mpls</b> <b>100000</b> <b>&amp;&amp;</b> <b>mpls</b> <b>1024</b>
                     filters packets with an outer label of 100000 and an inner label of 1024, and
                          <b>mpls</b> <b>&amp;&amp;</b> <b>mpls</b> <b>1024</b> <b>&amp;&amp;</b> <b>host</b> <b>192.9.200.1</b>
                     filters packets to or from 192.9.200.1 with an inner label of 1024 and any outer label.

              <b>pppoed</b> True if the packet is a PPP-over-Ethernet Discovery packet (Ethernet type 0x8863).

              <b>pppoes</b> True  if the packet is a PPP-over-Ethernet Session packet (Ethernet type 0x8864).  Note
                     that the first <b>pppoes</b> keyword encountered in <u>expression</u> changes  the  decoding  offsets
                     for  the  remainder  of <u>expression</u> on the assumption that the packet is a PPPoE session
                     packet.

                     For example:
                          <b>pppoes</b> <b>&amp;&amp;</b> <b>ip</b>
                     filters IPv4 protocols encapsulated in PPPoE.

              <b>tcp</b>, <b>udp</b>, <b>icmp</b>
                     Abbreviations for:
                          <b>ip</b> <b>proto</b> <u>p</u> <b>or</b> <b>ip6</b> <b>proto</b> <u>p</u>
                     where <u>p</u> is one of the above protocols.

              <b>iso</b> <b>proto</b> <u>protocol</u>
                     True if the packet is an OSI packet of protocol type <u>protocol</u>.  <u>Protocol</u> can be a  num-<font color="#ffffff" class="whiteout">ber&nbsp;number</font>
                     ber or one of the names <b>clnp</b>, <b>esis</b>, or <b>isis</b>.

              <b>clnp</b>, <b>esis</b>, <b>isis</b>
                     Abbreviations for:
                          <b>iso</b> <b>proto</b> <u>p</u>
                     where <u>p</u> is one of the above protocols.

              <b>l1</b>, <b>l2</b>, <b>iih</b>, <b>lsp</b>, <b>snp</b>, <b>csnp</b>, <b>psnp</b>
                     Abbreviations for IS-IS PDU types.

              <b>vpi</b> <u>n</u>  True if the packet is an ATM packet, for SunATM on Solaris, with a virtual path identi-<font color="#ffffff" class="whiteout">fier&nbsp;identifier</font>
                     fier of <u>n</u>.

              <b>vci</b> <u>n</u>  True if the packet is an ATM packet, for SunATM on  Solaris,  with  a  virtual  channel
                     identifier of <u>n</u>.

              <b>lane</b>   True  if the packet is an ATM packet, for SunATM on Solaris, and is an ATM LANE packet.
                     Note that the first <b>lane</b> keyword encountered in <u>expression</u> changes the  tests  done  in
                     the remainder of <u>expression</u> on the assumption that the packet is either a LANE emulated
                     Ethernet packet or a LANE LE Control packet.  If <b>lane</b> isn't specified,  the  tests  are
                     done under the assumption that the packet is an LLC-encapsulated packet.

              <b>llc</b>    True  if the packet is an ATM packet, for SunATM on Solaris, and is an LLC-encapsulated
                     packet.

              <b>oamf4s</b> True if the packet is an ATM packet, for SunATM on Solaris, and is  a  segment  OAM  F4
                     flow cell (VPI=0 &amp; VCI=3).

              <b>oamf4e</b> True if the packet is an ATM packet, for SunATM on Solaris, and is an end-to-end OAM F4
                     flow cell (VPI=0 &amp; VCI=4).

              <b>oamf4</b>  True if the packet is an ATM packet, for SunATM on Solaris, and is a segment or end-to-<font color="#ffffff" class="whiteout">end&nbsp;end-toend</font>
                     end OAM F4 flow cell (VPI=0 &amp; (VCI=3 | VCI=4)).

              <b>oam</b>    True if the packet is an ATM packet, for SunATM on Solaris, and is a segment or end-to-<font color="#ffffff" class="whiteout">end&nbsp;end-toend</font>
                     end OAM F4 flow cell (VPI=0 &amp; (VCI=3 | VCI=4)).

              <b>metac</b>  True if the packet is an ATM packet, for SunATM on Solaris, and is on a meta  signaling
                     circuit (VPI=0 &amp; VCI=1).

              <b>bcc</b>    True  if the packet is an ATM packet, for SunATM on Solaris, and is on a broadcast sig-<font color="#ffffff" class="whiteout">naling&nbsp;signaling</font>
                     naling circuit (VPI=0 &amp; VCI=2).

              <b>sc</b>     True if the packet is an ATM packet, for SunATM on Solaris, and is on a signaling  cir-<font color="#ffffff" class="whiteout">cuit&nbsp;circuit</font>
                     cuit (VPI=0 &amp; VCI=5).

              <b>ilmic</b>  True  if  the packet is an ATM packet, for SunATM on Solaris, and is on an ILMI circuit
                     (VPI=0 &amp; VCI=16).

              <b>connectmsg</b>
                     True if the packet is an ATM packet, for SunATM on Solaris, and is on a signaling  cir-<font color="#ffffff" class="whiteout">cuit&nbsp;circuit</font>
                     cuit  and is a Q.2931 Setup, Call Proceeding, Connect, Connect Ack, Release, or Release
                     Done message.

              <b>metaconnect</b>
                     True if the packet is an ATM packet, for SunATM on Solaris, and is on a meta  signaling
                     circuit  and is a Q.2931 Setup, Call Proceeding, Connect, Release, or Release Done mes-<font color="#ffffff" class="whiteout">sage.&nbsp;message.</font>
                     sage.

              <u>expr</u> <u>relop</u> <u>expr</u>
                     True if the relation holds, where <u>relop</u> is one of &gt;, &lt;, &gt;=, &lt;=, =, !=, and <u>expr</u>  is  an
                     arithmetic  expression  composed of integer constants (expressed in standard C syntax),
                     the normal binary operators [+, -, *, /, &amp;, |, &lt;&lt;, &gt;&gt;], a length operator, and  special
                     packet  data  accessors.  Note that all comparisons are unsigned, so that, for example,
                     0x80000000 and 0xffffffff are &gt; 0.  To access data inside the packet, use the following
                     syntax:
                          <u>proto</u> <b>[</b> <u>expr</u> <b>:</b> <u>size</u> <b>]</b>
                     <u>Proto</u>  is one of <b>ether,</b> <b>fddi,</b> <b>tr,</b> <b>wlan,</b> <b>ppp,</b> <b>slip,</b> <b>link,</b> <b>ip,</b> <b>arp,</b> <b>rarp,</b> <b>tcp,</b> <b>udp,</b> <b>icmp,</b>
                     <b>ip6</b> or <b>radio</b>, and indicates the protocol layer for the index operation.  (<b>ether,</b>  <b>fddi,</b>
                     <b>wlan,</b>  <b>tr,</b>  <b>ppp,</b>  <b>slip</b> and <b>link</b> all refer to the link layer. <b>radio</b> refers to the "radio
                     header" added to some 802.11 captures.)  Note that <u>tcp,</u> <u>udp</u> and other upper-layer  pro-<font color="#ffffff" class="whiteout">tocol&nbsp;protocol</font>
                     tocol  types only apply to IPv4, not IPv6 (this will be fixed in the future).  The byte
                     offset, relative to the indicated protocol layer, is given by <u>expr</u>.  <u>Size</u>  is  optional
                     and  indicates the number of bytes in the field of interest; it can be either one, two,
                     or four, and defaults to one.  The length operator, indicated by the keyword <b>len</b>, gives
                     the length of the packet.

                     For  example, `<b>ether[0]</b> <b>&amp;</b> <b>1</b> <b>!=</b> <b>0</b>' catches all multicast traffic.  The expression `<b>ip[0]</b>
                     <b>&amp;</b> <b>0xf</b> <b>!=</b> <b>5</b>' catches all IPv4 packets with options.  The expression `<b>ip[6:2]</b> <b>&amp;</b> <b>0x1fff</b>  <b>=</b>
                     <b>0</b>' catches only unfragmented IPv4 datagrams and frag zero of fragmented IPv4 datagrams.
                     This check is implicitly applied to the <b>tcp</b> and <b>udp</b> index  operations.   For  instance,
                     <b>tcp[0]</b> always means the first byte of the TCP <u>header</u>, and never means the first byte of
                     an intervening fragment.

                     Some offsets and field values may be expressed as names rather than as numeric  values.
                     The  following protocol header field offsets are available: <b>icmptype</b> (ICMP type field),
                     <b>icmpcode</b> (ICMP code field), and <b>tcpflags</b> (TCP flags field).

                     The following ICMP type field values are available: <b>icmp-echoreply</b>, <b>icmp-unreach</b>, <b>icmp</b>-<font color="#ffffff" class="whiteout">sourcequench,&nbsp;icmpsourcequench,</font>
                     <b>sourcequench</b>,  <b>icmp-redirect</b>,  <b>icmp-echo</b>,  <b>icmp-routeradvert</b>, <b>icmp-routersolicit</b>, <b>icmp</b>-<font color="#ffffff" class="whiteout">timxceed,&nbsp;icmptimxceed,</font>
                     <b>timxceed</b>, <b>icmp-paramprob</b>,  <b>icmp-tstamp</b>,  <b>icmp-tstampreply</b>,  <b>icmp-ireq</b>,  <b>icmp-ireqreply</b>,
                     <b>icmp-maskreq</b>, <b>icmp-maskreply</b>.

                     The  following  TCP  flags  field values are available: <b>tcp-fin</b>, <b>tcp-syn</b>, <b>tcp-rst</b>, <b>tcp</b>-<font color="#ffffff" class="whiteout">push,&nbsp;tcppush,</font>
                     <b>push</b>, <b>tcp-ack</b>, <b>tcp-urg</b>.

              Primitives may be combined using:

                     A parenthesized group of primitives and operators (parentheses are special to the Shell
                     and must be escaped).

                     Negation (`<b>!</b>' or `<b>not</b>').

                     Concatenation (`<b>&amp;&amp;</b>' or `<b>and</b>').

                     Alternation (`<b>||</b>' or `<b>or</b>').

              Negation  has highest precedence.  Alternation and concatenation have equal precedence and as-<font color="#ffffff" class="whiteout">sociate&nbsp;associate</font>
              sociate left to right.  Note that explicit <b>and</b> tokens, not juxtaposition, are now required for
              concatenation.

              If an identifier is given without a keyword, the most recent keyword is assumed.  For example,
                   <b>not</b> <b>host</b> <b>vs</b> <b>and</b> <b>ace</b>
              is short for
                   <b>not</b> <b>host</b> <b>vs</b> <b>and</b> <b>host</b> <b>ace</b>
              which should not be confused with
                   <b>not</b> <b>(</b> <b>host</b> <b>vs</b> <b>or</b> <b>ace</b> <b>)</b>

              Expression arguments can be passed to <u>tcpdump</u> as either a single argument or as multiple argu-<font color="#ffffff" class="whiteout">ments,&nbsp;arguments,</font>
              ments,  whichever is more convenient.  Generally, if the expression contains Shell metacharac-<font color="#ffffff" class="whiteout">ters,&nbsp;metacharacters,</font>
              ters, it is easier to pass it as a single, quoted argument.  Multiple arguments  are  concate-<font color="#ffffff" class="whiteout">nated&nbsp;concatenated</font>
              nated with spaces before being parsed.

<b>EXAMPLES</b>
       To print all packets arriving at or departing from <u>sundown</u>:
              <b>tcpdump</b> <b>host</b> <b>sundown</b>

       To print traffic between <u>helios</u> and either <u>hot</u> or <u>ace</u>:
              <b>tcpdump</b> <b>host</b> <b>helios</b> <b>and</b> <b>\(</b> <b>hot</b> <b>or</b> <b>ace</b> <b>\)</b>

       To print all IP packets between <u>ace</u> and any host except <u>helios</u>:
              <b>tcpdump</b> <b>ip</b> <b>host</b> <b>ace</b> <b>and</b> <b>not</b> <b>helios</b>

       To print all traffic between local hosts and hosts at Berkeley:
              <b>tcpdump</b> <b>net</b> <b>ucb-ether</b>

       To  print  all ftp traffic through internet gateway <u>snup</u>: (note that the expression is quoted to pre-<font color="#ffffff" class="whiteout">vent&nbsp;prevent</font>
       vent the shell from (mis-)interpreting the parentheses):
              <b>tcpdump</b> <b>'gateway</b> <b>snup</b> <b>and</b> <b>(port</b> <b>ftp</b> <b>or</b> <b>ftp-data)'</b>

       To print traffic neither sourced from nor destined for local hosts (if you gateway to one other  net,
       this stuff should never make it onto your local net).
              <b>tcpdump</b> <b>ip</b> <b>and</b> <b>not</b> <b>net</b> <u>localnet</u>

       To print the start and end packets (the SYN and FIN packets) of each TCP conversation that involves a
       non-local host.
              <b>tcpdump</b> <b>'tcp[tcpflags]</b> <b>&amp;</b> <b>(tcp-syn|tcp-fin)</b> <b>!=</b> <b>0</b> <b>and</b> <b>not</b> <b>src</b> <b>and</b> <b>dst</b> <b>net</b> <u>localnet</u><b>'</b>

       To print all IPv4 HTTP packets to and from port 80, i.e. print only packets that contain  data,  not,
       for example, SYN and FIN packets and ACK-only packets.  (IPv6 is left as an exercise for the reader.)
              <b>tcpdump</b> <b>'tcp</b> <b>port</b> <b>80</b> <b>and</b> <b>(((ip[2:2]</b> <b>-</b> <b>((ip[0]&amp;0xf)&lt;&lt;2))</b> <b>-</b> <b>((tcp[12]&amp;0xf0)&gt;&gt;2))</b> <b>!=</b> <b>0)'</b>

       To print IP packets longer than 576 bytes sent through gateway <u>snup</u>:
              <b>tcpdump</b> <b>'gateway</b> <b>snup</b> <b>and</b> <b>ip[2:2]</b> <b>&gt;</b> <b>576'</b>

       To print IP broadcast or multicast packets that were <u>not</u> sent via Ethernet broadcast or multicast:
              <b>tcpdump</b> <b>'ether[0]</b> <b>&amp;</b> <b>1</b> <b>=</b> <b>0</b> <b>and</b> <b>ip[16]</b> <b>&gt;=</b> <b>224'</b>

       To print all ICMP packets that are not echo requests/replies (i.e., not ping packets):
              <b>tcpdump</b> <b>'icmp[icmptype]</b> <b>!=</b> <b>icmp-echo</b> <b>and</b> <b>icmp[icmptype]</b> <b>!=</b> <b>icmp-echoreply'</b>

<b>OUTPUT</b> <b>FORMAT</b>
       The output of <u>tcpdump</u> is protocol dependent.  The following gives a brief description and examples of
       most of the formats.

       <b>Link</b> <b>Level</b> <b>Headers</b>

       If the '-e' option is given, the link level header is printed out.  On Ethernets, the source and des-<font color="#ffffff" class="whiteout">tination&nbsp;destination</font>
       tination addresses, protocol, and packet length are printed.

       On FDDI networks, the  '-e' option causes <u>tcpdump</u> to print the `frame control' field,  the source and
       destination  addresses, and the packet length.  (The `frame control' field governs the interpretation
       of the rest of the packet.  Normal packets (such as those containing IP datagrams) are `async'  pack-<font color="#ffffff" class="whiteout">ets,&nbsp;packets,</font>
       ets,  with a priority value between 0 and 7; for example, `<b>async4</b>'.  Such packets are assumed to con-<font color="#ffffff" class="whiteout">tain&nbsp;contain</font>
       tain an 802.2 Logical Link Control (LLC) packet; the LLC header is printed if it is <u>not</u> an ISO  data-<font color="#ffffff" class="whiteout">gram&nbsp;datagram</font>
       gram or a so-called SNAP packet.

       On  Token Ring networks, the '-e' option causes <u>tcpdump</u> to print the `access control' and `frame con-<font color="#ffffff" class="whiteout">trol'&nbsp;control'</font>
       trol' fields, the source and destination addresses, and the packet  length.   As  on  FDDI  networks,
       packets  are assumed to contain an LLC packet.  Regardless of whether the '-e' option is specified or
       not, the source routing information is printed for source-routed packets.

       On 802.11 networks, the '-e' option causes <u>tcpdump</u> to print the `frame control' fields,  all  of  the
       addresses  in  the 802.11 header, and the packet length.  As on FDDI networks, packets are assumed to
       contain an LLC packet.

       <u>(N.B.:</u> <u>The</u> <u>following</u> <u>description</u> <u>assumes</u> <u>familiarity</u> <u>with</u> <u>the</u> <u>SLIP</u> <u>compression</u> <u>algorithm</u> <u>described</u> <u>in</u>
       <u>RFC-1144.)</u>

       On  SLIP  links, a direction indicator (``I'' for inbound, ``O'' for outbound), packet type, and com-<font color="#ffffff" class="whiteout">pression&nbsp;compression</font>
       pression information are printed out.  The packet type is printed first.  The  three  types  are  <u>ip</u>,
       <u>utcp</u>, and <u>ctcp</u>.  No further link information is printed for <u>ip</u> packets.  For TCP packets, the connec-<font color="#ffffff" class="whiteout">tion&nbsp;connection</font>
       tion identifier is printed following the type.  If the packet is compressed, its  encoded  header  is
       printed out.  The special cases are printed out as <b>*S+</b><u>n</u> and <b>*SA+</b><u>n</u>, where <u>n</u> is the amount by which the
       sequence number (or sequence number and ack) has changed.  If it is not a special case, zero or  more
       changes  are  printed.  A change is indicated by U (urgent pointer), W (window), A (ack), S (sequence
       number), and I (packet ID), followed by a delta (+n or -n), or a new value (=n).  Finally, the amount
       of data in the packet and compressed header length are printed.

       For  example, the following line shows an outbound compressed TCP packet, with an implicit connection
       identifier; the ack has changed by 6, the sequence number by 49, and the packet ID by 6; there are  3
       bytes of data and 6 bytes of compressed header:
              <b>O</b> <b>ctcp</b> <b>*</b> <b>A+6</b> <b>S+49</b> <b>I+6</b> <b>3</b> <b>(6)</b>

       <b>ARP/RARP</b> <b>Packets</b>

       Arp/rarp  output  shows  the  type  of  request and its arguments.  The format is intended to be self
       explanatory.  Here is a short sample taken from the start of an `rlogin' from host <u>rtsg</u> to host <u>csam</u>:
              arp who-has csam tell rtsg
              arp reply csam is-at CSAM
       The  first  line  says  that rtsg sent an arp packet asking for the Ethernet address of internet host
       csam.  Csam replies with its Ethernet address (in this example, Ethernet addresses are  in  caps  and
       internet addresses in lower case).

       This would look less redundant if we had done <u>tcpdump</u> <u>-n</u>:
              arp who-has 128.3.254.6 tell 128.3.254.68
              arp reply 128.3.254.6 is-at 02:07:01:00:01:c4

       If  we  had  done <u>tcpdump</u> <u>-e</u>, the fact that the first packet is broadcast and the second is point-to-<font color="#ffffff" class="whiteout">point&nbsp;point-topoint</font>
       point would be visible:
              RTSG Broadcast 0806  64: arp who-has csam tell rtsg
              CSAM RTSG 0806  64: arp reply csam is-at CSAM
       For the first packet this says the Ethernet source address is RTSG, the destination is  the  Ethernet
       broadcast  address,  the  type  field contained hex 0806 (type ETHER_ARP) and the total length was 64
       bytes.

       <b>TCP</b> <b>Packets</b>

       <u>(N.B.:The</u> <u>following</u> <u>description</u> <u>assumes</u> <u>familiarity</u> <u>with</u> <u>the</u> <u>TCP</u> <u>protocol</u> <u>described</u> <u>in</u>  <u>RFC-793.</u>   <u>If</u>
       <u>you</u>  <u>are</u>  <u>not</u> <u>familiar</u> <u>with</u> <u>the</u> <u>protocol,</u> <u>neither</u> <u>this</u> <u>description</u> <u>nor</u> <u>tcpdump</u> <u>will</u> <u>be</u> <u>of</u> <u>much</u> <u>use</u> <u>to</u>
       <u>you.)</u>

       The general format of a tcp protocol line is:
              <u>src</u> <u>&gt;</u> <u>dst:</u> <u>flags</u> <u>data-seqno</u> <u>ack</u> <u>window</u> <u>urgent</u> <u>options</u>
       <u>Src</u> and <u>dst</u> are the source and destination IP addresses and ports.  <u>Flags</u> are some combination  of  S
       (SYN),  F  (FIN),  P (PUSH), R (RST), W (ECN CWR) or E (ECN-Echo), or a single `.' (no flags).  <u>Data</u>-<font color="#ffffff" class="whiteout">seqno&nbsp;Dataseqno</font>
       <u>seqno</u> describes the portion of sequence space covered by the data in this packet (see example below).
       <u>Ack</u>  is  sequence number of the next data expected the other direction on this connection.  <u>Window</u> is
       the number of bytes of receive buffer space available the other direction on  this  connection.   <u>Urg</u>
       indicates  there  is `urgent' data in the packet.  <u>Options</u> are tcp options enclosed in angle brackets
       (e.g., &lt;mss 1024&gt;).

       <u>Src,</u> <u>dst</u> and <u>flags</u> are always present.  The other fields depend on the contents of the  packet's  tcp
       protocol header and are output only if appropriate.

       Here is the opening portion of an rlogin from host <u>rtsg</u> to host <u>csam</u>.
              rtsg.1023 &gt; csam.login: S 768512:768512(0) win 4096 &lt;mss 1024&gt;
              csam.login &gt; rtsg.1023: S 947648:947648(0) ack 768513 win 4096 &lt;mss 1024&gt;
              rtsg.1023 &gt; csam.login: . ack 1 win 4096
              rtsg.1023 &gt; csam.login: P 1:2(1) ack 1 win 4096
              csam.login &gt; rtsg.1023: . ack 2 win 4096
              rtsg.1023 &gt; csam.login: P 2:21(19) ack 1 win 4096
              csam.login &gt; rtsg.1023: P 1:2(1) ack 21 win 4077
              csam.login &gt; rtsg.1023: P 2:3(1) ack 21 win 4077 urg 1
              csam.login &gt; rtsg.1023: P 3:4(1) ack 21 win 4077 urg 1
       The  first line says that tcp port 1023 on rtsg sent a packet to port <u>login</u> on csam.  The <b>S</b> indicates
       that the <u>SYN</u> flag was set.  The packet sequence number was 768512 and it  contained  no  data.   (The
       notation  is  `first:last(nbytes)'  which  means `sequence numbers <u>first</u> up to but not including <u>last</u>
       which is <u>nbytes</u> bytes of user data'.)  There was no piggy-backed ack, the  available  receive  window
       was 4096 bytes and there was a max-segment-size option requesting an mss of 1024 bytes.

       Csam  replies  with a similar packet except it includes a piggy-backed ack for rtsg's SYN.  Rtsg then
       acks csam's SYN.  The `.' means no flags were set.  The packet contained no data so there is no  data
       sequence  number.   Note that the ack sequence number is a small integer (1).  The first time <u>tcpdump</u>
       sees a tcp `conversation', it prints the sequence number from the packet.  On subsequent  packets  of
       the  conversation,  the  difference  between  the  current  packet's sequence number and this initial
       sequence number is printed.  This means that sequence numbers after the first can be  interpreted  as
       relative  byte  positions  in the conversation's data stream (with the first data byte each direction
       being `1').  `-S' will override this feature, causing the original sequence numbers to be output.

       On the 6th line, rtsg sends csam 19 bytes of data (bytes 2 through 20 in the rtsg -&gt; csam side of the
       conversation).   The  PUSH  flag is set in the packet.  On the 7th line, csam says it's received data
       sent by rtsg up to but not including byte 21.  Most of this data is apparently sitting in the  socket
       buffer  since csam's receive window has gotten 19 bytes smaller.  Csam also sends one byte of data to
       rtsg in this packet.  On the 8th and 9th lines, csam sends two bytes of urgent, pushed data to  rtsg.

       If  the  snapshot  was small enough that <u>tcpdump</u> didn't capture the full TCP header, it interprets as
       much of the header as it can and then reports ``[|<u>tcp</u>]'' to  indicate  the  remainder  could  not  be
       interpreted.   If  the  header  contains a bogus option (one with a length that's either too small or
       beyond the end of the header), <u>tcpdump</u> reports it as ``[<u>bad</u> <u>opt</u>]'' and does not interpret any further
       options (since it's impossible to tell where they start).  If the header length indicates options are
       present but the IP datagram length is not long enough for the options to actually be  there,  <u>tcpdump</u>
       reports it as ``[<u>bad</u> <u>hdr</u> <u>length</u>]''.

       <b>Capturing</b> <b>TCP</b> <b>packets</b> <b>with</b> <b>particular</b> <b>flag</b> <b>combinations</b> <b>(SYN-ACK,</b> <b>URG-ACK,</b> <b>etc.)</b>

       There are 8 bits in the control bits section of the TCP header:

              <u>CWR</u> <u>|</u> <u>ECE</u> <u>|</u> <u>URG</u> <u>|</u> <u>ACK</u> <u>|</u> <u>PSH</u> <u>|</u> <u>RST</u> <u>|</u> <u>SYN</u> <u>|</u> <u>FIN</u>

       Let's  assume  that  we want to watch packets used in establishing a TCP connection.  Recall that TCP
       uses a 3-way handshake protocol when it initializes a new connection; the  connection  sequence  with
       regard to the TCP control bits is

              1) Caller sends SYN
              2) Recipient responds with SYN, ACK
              3) Caller sends ACK

       Now  we're  interested  in  capturing  packets that have only the SYN bit set (Step 1).  Note that we
       don't want packets from step 2 (SYN-ACK), just a plain initial SYN.  What we need is a correct filter
       expression for <u>tcpdump</u>.

       Recall the structure of a TCP header without options:

        0                            15                              31
       -----------------------------------------------------------------<font color="#ffffff" class="whiteout">|&nbsp;----------------------------------------------------------------|</font>
       |          source port          |       destination port        |
       -----------------------------------------------------------------<font color="#ffffff" class="whiteout">|&nbsp;----------------------------------------------------------------|</font>
       |                        sequence number                        |
       -----------------------------------------------------------------<font color="#ffffff" class="whiteout">|&nbsp;----------------------------------------------------------------|</font>
       |                     acknowledgment number                     |
       -----------------------------------------------------------------<font color="#ffffff" class="whiteout">|&nbsp;----------------------------------------------------------------|</font>
       |  HL   | rsvd  |C|E|U|A|P|R|S|F|        window size            |
       -----------------------------------------------------------------<font color="#ffffff" class="whiteout">|&nbsp;----------------------------------------------------------------|</font>
       |         TCP checksum          |       urgent pointer          |
       -----------------------------------------------------------------<font color="#ffffff" class="whiteout">A&nbsp;----------------------------------------------------------------A</font>

       A  TCP  header  usually  holds  20 octets of data, unless options are present.  The first line of the
       graph contains octets 0 - 3, the second line shows octets 4 - 7 etc.

       Starting to count with 0, the relevant TCP control bits are contained in octet 13:

        0             7|             15|             23|             31
       ----------------|---------------|---------------|----------------<font color="#ffffff" class="whiteout">|&nbsp;----------------|---------------|---------------|---------------|</font>
       |  HL   | rsvd  |C|E|U|A|P|R|S|F|        window size            |
       ----------------|---------------|---------------|----------------<font color="#ffffff" class="whiteout">|&nbsp;----------------|---------------|---------------|---------------|</font>
       |               |  13th octet   |               |               |

       Let's have a closer look at octet no. 13:

                       |               |
                       |---------------|
                       |C|E|U|A|P|R|S|F|
                       |---------------|
                       |7   5   3     0|

       These are the TCP control bits we are interested in.  We have numbered the bits in this octet from  0
       to 7, right to left, so the PSH bit is bit number 3, while the URG bit is number 5.

       Recall  that  we  want to capture packets with only SYN set.  Let's see what happens to octet 13 if a
       TCP datagram arrives with the SYN bit set in its header:

                       |C|E|U|A|P|R|S|F|
                       |---------------|
                       |0 0 0 0 0 0 1 0|
                       |---------------|
                       |7 6 5 4 3 2 1 0|

       Looking at the control bits section we see that only bit number 1 (SYN) is set.

       Assuming that octet number 13 is an 8-bit unsigned integer in network byte order, the binary value of
       this octet is

              00000010

       and its decimal representation is

          7     6     5     4     3     2     1     0
       0*2 + 0*2 + 0*2 + 0*2 + 0*2 + 0*2 + 1*2 + 0*2  =  2

       We're  almost  done,  because now we know that if only SYN is set, the value of the 13th octet in the
       TCP header, when interpreted as a 8-bit unsigned integer in network byte order, must be exactly 2.

       This relationship can be expressed as
              <b>tcp[13]</b> <b>==</b> <b>2</b>

       We can use this expression as the filter for <u>tcpdump</u> in order to watch packets which  have  only  SYN
       set:
              <b>tcpdump</b> <b>-i</b> <b>xl0</b> <b>tcp[13]</b> <b>==</b> <b>2</b>

       The expression says "let the 13th octet of a TCP datagram have the decimal value 2", which is exactly
       what we want.

       Now, let's assume that we need to capture SYN packets, but we don't care if ACK or any other TCP con-<font color="#ffffff" class="whiteout">trol&nbsp;control</font>
       trol  bit  is set at the same time.  Let's see what happens to octet 13 when a TCP datagram with SYN-<font color="#ffffff" class="whiteout">ACK&nbsp;SYNACK</font>
       ACK set arrives:

            |C|E|U|A|P|R|S|F|
            |---------------|
            |0 0 0 1 0 0 1 0|
            |---------------|
            |7 6 5 4 3 2 1 0|

       Now bits 1 and 4 are set in the 13th octet.  The binary value of octet 13 is

                   00010010

       which translates to decimal

          7     6     5     4     3     2     1     0
       0*2 + 0*2 + 0*2 + 1*2 + 0*2 + 0*2 + 1*2 + 0*2   = 18

       Now we can't just use 'tcp[13] == 18' in the <u>tcpdump</u> filter expression,  because  that  would  select
       only  those  packets  that have SYN-ACK set, but not those with only SYN set.  Remember that we don't
       care if ACK or any other control bit is set as long as SYN is set.

       In order to achieve our goal, we need to logically AND the binary value of octet 13 with  some  other
       value  to  preserve  the SYN bit.  We know that we want SYN to be set in any case, so we'll logically
       AND the value in the 13th octet with the binary value of a SYN:


                 00010010 SYN-ACK              00000010 SYN
            AND  00000010 (we want SYN)   AND  00000010 (we want SYN)
                 --------                      --------<font color="#ffffff" class="whiteout">=&nbsp;-------=</font>
            =    00000010                 =    00000010

       We see that this AND operation delivers the same result regardless whether ACK or another TCP control
       bit is set.  The decimal representation of the AND value as well as the result of this operation is 2
       (binary 00000010), so we know that for packets with SYN set the following relation must hold true:

              ( ( value of octet 13 ) AND ( 2 ) ) == ( 2 )

       This points us to the <u>tcpdump</u> filter expression
                   <b>tcpdump</b> <b>-i</b> <b>xl0</b> <b>'tcp[13]</b> <b>&amp;</b> <b>2</b> <b>==</b> <b>2'</b>

       Note that you should use single quotes or a backslash in the expression to hide the AND ('&amp;') special
       character from the shell.

       <b>UDP</b> <b>Packets</b>

       UDP format is illustrated by this rwho packet:
              actinide.who &gt; broadcast.who: udp 84
       This  says  that  port  <u>who</u>  on  host <u>actinide</u> sent a udp datagram to port <u>who</u> on host <u>broadcast</u>, the
       Internet broadcast address.  The packet contained 84 bytes of user data.

       Some UDP services are recognized (from the source or destination port number) and  the  higher  level
       protocol  information  printed.   In particular, Domain Name service requests (RFC-1034/1035) and Sun
       RPC calls (RFC-1050) to NFS.

       <b>UDP</b> <b>Name</b> <b>Server</b> <b>Requests</b>

       <u>(N.B.:The</u> <u>following</u> <u>description</u> <u>assumes</u> <u>familiarity</u> <u>with</u> <u>the</u> <u>Domain</u>  <u>Service</u>  <u>protocol</u>  <u>described</u>  <u>in</u>
       <u>RFC-1035.</u>   <u>If</u>  <u>you</u>  <u>are</u>  <u>not</u> <u>familiar</u> <u>with</u> <u>the</u> <u>protocol,</u> <u>the</u> <u>following</u> <u>description</u> <u>will</u> <u>appear</u> <u>to</u> <u>be</u>
       <u>written</u> <u>in</u> <u>greek.)</u>

       Name server requests are formatted as
              <u>src</u> <u>&gt;</u> <u>dst:</u> <u>id</u> <u>op?</u> <u>flags</u> <u>qtype</u> <u>qclass</u> <u>name</u> <u>(len)</u>
              h2opolo.1538 &gt; helios.domain: 3+ A? ucbvax.berkeley.edu. (37)
       Host <u>h2opolo</u> asked the domain server on <u>helios</u> for an address record (qtype=A)  associated  with  the
       name  <u>ucbvax.berkeley.edu.</u>   The  query id was `3'.  The `+' indicates the <u>recursion</u> <u>desired</u> flag was
       set.  The query length was 37 bytes, not including the UDP and IP protocol headers.  The query opera-<font color="#ffffff" class="whiteout">tion&nbsp;operation</font>
       tion  was  the  normal one, <u>Query</u>, so the op field was omitted.  If the op had been anything else, it
       would have been printed between the `3' and the `+'.  Similarly, the qclass was the normal one, <u>C</u><b>_</b><u>IN</u>,
       and omitted.  Any other qclass would have been printed immediately after the `A'.

       A  few  anomalies are checked and may result in extra fields enclosed in square brackets:  If a query
       contains an answer, authority records or additional records section, <u>ancount</u>, <u>nscount</u>, or <u>arcount</u> are
       printed  as `[<u>n</u>a]', `[<u>n</u>n]' or  `[<u>n</u>au]' where <u>n</u> is the appropriate count.  If any of the response bits
       are set (AA, RA or rcode) or any of the `must  be  zero'  bits  are  set  in  bytes  two  and  three,
       `[b2&amp;3=<u>x</u>]' is printed, where <u>x</u> is the hex value of header bytes two and three.

       <b>UDP</b> <b>Name</b> <b>Server</b> <b>Responses</b>

       Name server responses are formatted as
              <u>src</u> <u>&gt;</u> <u>dst:</u>  <u>id</u> <u>op</u> <u>rcode</u> <u>flags</u> <u>a/n/au</u> <u>type</u> <u>class</u> <u>data</u> <u>(len)</u>
              helios.domain &gt; h2opolo.1538: 3 3/3/7 A 128.32.137.3 (273)
              helios.domain &gt; h2opolo.1537: 2 NXDomain* 0/1/0 (97)
       In the first example, <u>helios</u> responds to query id 3 from <u>h2opolo</u> with 3 answer records, 3 name server
       records and 7 additional records.  The first answer record is type A (address) and its data is inter-<font color="#ffffff" class="whiteout">net&nbsp;internet</font>
       net  address  128.32.137.3.  The total size of the response was 273 bytes, excluding UDP and IP head-<font color="#ffffff" class="whiteout">ers.&nbsp;headers.</font>
       ers.  The op (Query) and response code (NoError) were omitted, as was  the  class  (C_IN)  of  the  A
       record.

       In  the second example, <u>helios</u> responds to query 2 with a response code of non-existent domain (NXDo-<font color="#ffffff" class="whiteout">main)&nbsp;(NXDomain)</font>
       main) with no answers, one name server and no authority records.  The `*' indicates that the <u>authori</u>-<font color="#ffffff" class="whiteout">tative&nbsp;authoritative</font>
       <u>tative</u> <u>answer</u> bit was set.  Since there were no answers, no type, class or data were printed.

       Other flag characters that might appear are `-' (recursion available, RA, <u>not</u> set) and `|' (truncated
       message, TC, set).  If the `question' section doesn't contain exactly one entry, `[<u>n</u>q]' is printed.

       Note that name server requests and responses tend to be large and the default <u>snaplen</u> of 68 bytes may
       not  capture  enough  of the packet to print.  Use the <b>-s</b> flag to increase the snaplen if you need to
       seriously investigate name server traffic.  `<b>-s</b> <b>128</b>' has worked well for me.


       <b>SMB/CIFS</b> <b>decoding</b>

       <u>tcpdump</u> now includes fairly extensive SMB/CIFS/NBT decoding for data on UDP/137, UDP/138 and TCP/139.
       Some primitive decoding of IPX and NetBEUI SMB data is also done.

       By  default a fairly minimal decode is done, with a much more detailed decode done if -v is used.  Be
       warned that with -v a single SMB packet may take up a page or more, so only use -v if you really want
       all the gory details.

       For  information  on  SMB  packet  formats  and  what  all  te  fields  mean  see www.cifs.org or the
       pub/samba/specs/ directory on your favorite samba.org mirror site.  The SMB patches were  written  by
       Andrew Tridgell (tridge@samba.org).


       <b>NFS</b> <b>Requests</b> <b>and</b> <b>Replies</b>

       Sun NFS (Network File System) requests and replies are printed as:
              <u>src.xid</u> <u>&gt;</u> <u>dst.nfs:</u> <u>len</u> <u>op</u> <u>args</u>
              <u>src.nfs</u> <u>&gt;</u> <u>dst.xid:</u> <u>reply</u> <u>stat</u> <u>len</u> <u>op</u> <u>results</u>
              sushi.6709 &gt; wrl.nfs: 112 readlink fh 21,24/10.73165
              wrl.nfs &gt; sushi.6709: reply ok 40 readlink "../var"
              sushi.201b &gt; wrl.nfs:
                   144 lookup fh 9,74/4096.6878 "xcolors"
              wrl.nfs &gt; sushi.201b:
                   reply ok 128 lookup fh 9,74/4134.3150
       In the first line, host <u>sushi</u> sends a transaction with id <u>6709</u> to <u>wrl</u> (note that the number following
       the src host is a transaction id, <u>not</u> the source port).  The request was 112 bytes, excluding the UDP
       and   IP  headers.   The  operation  was  a  <u>readlink</u>  (read  symbolic  link)  on  file  handle  (<u>fh</u>)
       21,24/10.731657119.  (If one is lucky, as in this case, the file  handle  can  be  interpreted  as  a
       major,minor  device  number  pair,  followed by the inode number and generation number.)  <u>Wrl</u> replies
       `ok' with the contents of the link.

       In the third line, <u>sushi</u> asks <u>wrl</u> to lookup the name  `<u>xcolors</u>'  in  directory  file  9,74/4096.6878.
       Note that the data printed depends on the operation type.  The format is intended to be self explana-<font color="#ffffff" class="whiteout">tory&nbsp;explanatory</font>
       tory if read in conjunction with an NFS protocol spec.

       If the -v (verbose) flag is given, additional information is printed.  For example:
              sushi.1372a &gt; wrl.nfs:
                   148 read fh 21,11/12.195 8192 bytes @ 24576
              wrl.nfs &gt; sushi.1372a:
                   reply ok 1472 read REG 100664 ids 417/0 sz 29388
       (-v also prints the IP header TTL, ID, length, and fragmentation fields, which have been omitted from
       this  example.)  In the first line, <u>sushi</u> asks <u>wrl</u> to read 8192 bytes from file 21,11/12.195, at byte
       offset 24576.  <u>Wrl</u> replies `ok'; the packet shown on the second line is the  first  fragment  of  the
       reply,  and  hence  is only 1472 bytes long (the other bytes will follow in subsequent fragments, but
       these fragments do not have NFS or even UDP headers and so might not be  printed,  depending  on  the
       filter  expression  used).   Because  the  -v  flag  is given, some of the file attributes (which are
       returned in addition to the file data) are printed: the file type (``REG'', for  regular  file),  the
       file mode (in octal), the uid and gid, and the file size.

       If the -v flag is given more than once, even more details are printed.

       Note  that  NFS  requests  are  very  large and much of the detail won't be printed unless <u>snaplen</u> is
       increased.  Try using `<b>-s</b> <b>192</b>' to watch NFS traffic.

       NFS reply packets do not explicitly identify the RPC operation.   Instead,  <u>tcpdump</u>  keeps  track  of
       ``recent''  requests,  and matches them to the replies using the transaction ID.  If a reply does not
       closely follow the corresponding request, it might not be parsable.

       <b>AFS</b> <b>Requests</b> <b>and</b> <b>Replies</b>

       Transarc AFS (Andrew File System) requests and replies are printed as:

              <u>src.sport</u> <u>&gt;</u> <u>dst.dport:</u> <u>rx</u> <u>packet-type</u>
              <u>src.sport</u> <u>&gt;</u> <u>dst.dport:</u> <u>rx</u> <u>packet-type</u> <u>service</u> <u>call</u> <u>call-name</u> <u>args</u>
              <u>src.sport</u> <u>&gt;</u> <u>dst.dport:</u> <u>rx</u> <u>packet-type</u> <u>service</u> <u>reply</u> <u>call-name</u> <u>args</u>
              elvis.7001 &gt; pike.afsfs:
                   rx data fs call rename old fid 536876964/1/1 ".newsrc.new"
                   new fid 536876964/1/1 ".newsrc"
              pike.afsfs &gt; elvis.7001: rx data fs reply rename
       In the first line, host elvis sends a RX packet to pike.  This was a RX data packet to the fs  (file-<font color="#ffffff" class="whiteout">server)&nbsp;(fileserver)</font>
       server)  service, and is the start of an RPC call.  The RPC call was a rename, with the old directory
       file id of 536876964/1/1 and an old filename of  `.newsrc.new',  and  a  new  directory  file  id  of
       536876964/1/1 and a new filename of `.newsrc'.  The host pike responds with a RPC reply to the rename
       call (which was successful, because it was a data packet and not an abort packet).

       In general, all AFS RPCs are decoded at least by RPC call name.  Most AFS RPCs have at least some  of
       the  arguments  decoded (generally only the `interesting' arguments, for some definition of interest-<font color="#ffffff" class="whiteout">ing).&nbsp;interesting).</font>
       ing).

       The format is intended to be self-describing, but it will probably not be useful to  people  who  are
       not familiar with the workings of AFS and RX.

       If the -v (verbose) flag is given twice, acknowledgement packets and additional header information is
       printed, such as the the RX call ID, call number, sequence number, serial number, and the  RX  packet
       flags.

       If  the -v flag is given twice, additional information is printed, such as the the RX call ID, serial
       number, and the RX packet flags.  The MTU negotiation information is also printed from RX  ack  pack-<font color="#ffffff" class="whiteout">ets.&nbsp;packets.</font>
       ets.

       If the -v flag is given three times, the security index and service id are printed.

       Error  codes  are printed for abort packets, with the exception of Ubik beacon packets (because abort
       packets are used to signify a yes vote for the Ubik protocol).

       Note that AFS requests are very large and many of the arguments won't be printed  unless  <u>snaplen</u>  is
       increased.  Try using `<b>-s</b> <b>256</b>' to watch AFS traffic.

       AFS  reply  packets  do  not  explicitly identify the RPC operation.  Instead, <u>tcpdump</u> keeps track of
       ``recent'' requests, and matches them to the replies using the call number  and  service  ID.   If  a
       reply does not closely follow the corresponding request, it might not be parsable.


       <b>KIP</b> <b>AppleTalk</b> <b>(DDP</b> <b>in</b> <b>UDP)</b>

       AppleTalk  DDP  packets  encapsulated  in UDP datagrams are de-encapsulated and dumped as DDP packets
       (i.e., all the UDP header information is discarded).  The file <u>/etc/atalk.names</u> is used to  translate
       AppleTalk net and node numbers to names.  Lines in this file have the form
              <u>number</u>    <u>name</u>

              1.254          ether
              16.1      icsd-net
              1.254.110 ace
       The first two lines give the names of AppleTalk networks.  The third line gives the name of a partic-<font color="#ffffff" class="whiteout">ular&nbsp;particular</font>
       ular host (a host is distinguished from a net by the 3rd octet in the number - a net number <u>must</u> have
       two  octets  and  a  host number <u>must</u> have three octets.)  The number and name should be separated by
       whitespace (blanks or tabs).  The <u>/etc/atalk.names</u> file may contain  blank  lines  or  comment  lines
       (lines starting with a `#').

       AppleTalk addresses are printed in the form
              <u>net.host.port</u>

              144.1.209.2 &gt; icsd-net.112.220
              office.2 &gt; icsd-net.112.220
              jssmag.149.235 &gt; icsd-net.2
       (If  the  <u>/etc/atalk.names</u> doesn't exist or doesn't contain an entry for some AppleTalk host/net num-<font color="#ffffff" class="whiteout">ber,&nbsp;number,</font>
       ber, addresses are printed in numeric form.)  In the first example, NBP (DDP port  2)  on  net  144.1
       node  209  is  sending to whatever is listening on port 220 of net icsd node 112.  The second line is
       the same except the full name of the source node is known (`office').  The third line is a send  from
       port  235  on  net  jssmag  node  149  to broadcast on the icsd-net NBP port (note that the broadcast
       address (255) is indicated by a net name with no host number - for this reason it's a  good  idea  to
       keep node names and net names distinct in /etc/atalk.names).

       NBP  (name  binding  protocol)  and  ATP (AppleTalk transaction protocol) packets have their contents
       interpreted.  Other protocols just dump the protocol name (or number if no name is registered for the
       protocol) and packet size.

       <b>NBP</b> <b>packets</b> are formatted like the following examples:
              icsd-net.112.220 &gt; jssmag.2: nbp-lkup 190: "=:LaserWriter@*"
              jssmag.209.2 &gt; icsd-net.112.220: nbp-reply 190: "RM1140:LaserWriter@*" 250
              techpit.2 &gt; icsd-net.112.220: nbp-reply 190: "techpit:LaserWriter@*" 186
       The  first  line is a name lookup request for laserwriters sent by net icsd host 112 and broadcast on
       net jssmag.  The nbp id for the lookup is 190.  The second line shows a reply for this request  (note
       that  it  has  the  same  id)  from  host  jssmag.209 saying that it has a laserwriter resource named
       "RM1140" registered on port 250.  The third line is another reply to the  same  request  saying  host
       techpit has laserwriter "techpit" registered on port 186.

       <b>ATP</b> <b>packet</b> formatting is demonstrated by the following example:
              jssmag.209.165 &gt; helios.132: atp-req  12266&lt;0-7&gt; 0xae030001
              helios.132 &gt; jssmag.209.165: atp-resp 12266:0 (512) 0xae040000
              helios.132 &gt; jssmag.209.165: atp-resp 12266:1 (512) 0xae040000
              helios.132 &gt; jssmag.209.165: atp-resp 12266:2 (512) 0xae040000
              helios.132 &gt; jssmag.209.165: atp-resp 12266:3 (512) 0xae040000
              helios.132 &gt; jssmag.209.165: atp-resp 12266:4 (512) 0xae040000
              helios.132 &gt; jssmag.209.165: atp-resp 12266:5 (512) 0xae040000
              helios.132 &gt; jssmag.209.165: atp-resp 12266:6 (512) 0xae040000
              helios.132 &gt; jssmag.209.165: atp-resp*12266:7 (512) 0xae040000
              jssmag.209.165 &gt; helios.132: atp-req  12266&lt;3,5&gt; 0xae030001
              helios.132 &gt; jssmag.209.165: atp-resp 12266:3 (512) 0xae040000
              helios.132 &gt; jssmag.209.165: atp-resp 12266:5 (512) 0xae040000
              jssmag.209.165 &gt; helios.132: atp-rel  12266&lt;0-7&gt; 0xae030001
              jssmag.209.133 &gt; helios.132: atp-req* 12267&lt;0-7&gt; 0xae030002
       Jssmag.209  initiates  transaction  id  12266  with  host  helios  by requesting up to 8 packets (the
       `&lt;0-7&gt;').  The hex number at the end of the line is the value of the `userdata' field in the request.

       Helios  responds with 8 512-byte packets.  The `:digit' following the transaction id gives the packet
       sequence number in the transaction and the number in parens is the amount  of  data  in  the  packet,
       excluding the atp header.  The `*' on packet 7 indicates that the EOM bit was set.

       Jssmag.209  then  requests  that packets 3 &amp; 5 be retransmitted.  Helios resends them then jssmag.209
       releases the transaction.  Finally, jssmag.209 initiates the next request.  The `*'  on  the  request
       indicates that XO (`exactly once') was <u>not</u> set.


       <b>IP</b> <b>Fragmentation</b>

       Fragmented Internet datagrams are printed as
              <b>(frag</b> <u>id</u><b>:</b><u>size</u><b>@</b><u>offset</u><b>+)</b>
              <b>(frag</b> <u>id</u><b>:</b><u>size</u><b>@</b><u>offset</u><b>)</b>
       (The first form indicates there are more fragments.  The second indicates this is the last fragment.)

       <u>Id</u> is the fragment id.  <u>Size</u> is the fragment size (in bytes) excluding the IP header.  <u>Offset</u> is this
       fragment's offset (in bytes) in the original datagram.

       The  fragment  information is output for each fragment.  The first fragment contains the higher level
       protocol header and the frag info is printed after the protocol info.  Fragments after the first con-<font color="#ffffff" class="whiteout">tain&nbsp;contain</font>
       tain  no  higher  level protocol header and the frag info is printed after the source and destination
       addresses.  For example, here is part of an ftp from arizona.edu to lbl-rtsg.arpa over a  CSNET  con-<font color="#ffffff" class="whiteout">nection&nbsp;connection</font>
       nection that doesn't appear to handle 576 byte datagrams:
              arizona.ftp-data &gt; rtsg.1170: . 1024:1332(308) ack 1 win 4096 (frag 595a:328@0+)
              arizona &gt; rtsg: (frag 595a:204@328)
              rtsg.1170 &gt; arizona.ftp-data: . ack 1536 win 2560
       There  are a couple of things to note here:  First, addresses in the 2nd line don't include port num-<font color="#ffffff" class="whiteout">bers.&nbsp;numbers.</font>
       bers.  This is because the TCP protocol information is all in the first fragment and we have no  idea
       what  the  port  or sequence numbers are when we print the later fragments.  Second, the tcp sequence
       information in the first line is printed as if there were 308 bytes of user data when, in fact, there
       are  512  bytes  (308  in the first frag and 204 in the second).  If you are looking for holes in the
       sequence space or trying to match up acks with packets, this can fool you.

       A packet with the IP <u>don't</u> <u>fragment</u> flag is marked with a trailing <b>(DF)</b>.

       <b>Timestamps</b>

       By default, all output lines are preceded by a timestamp.  The timestamp is the current clock time in
       the form
              <u>hh:mm:ss.frac</u>
       and  is  as accurate as the kernel's clock.  The timestamp reflects the time the kernel first saw the
       packet.  No attempt is made to account for the time lag between when the Ethernet  interface  removed
       the packet from the wire and when the kernel serviced the `new packet' interrupt.

<b>SEE</b> <b>ALSO</b>
       <a href="stty.1.html#//apple_ref/doc/man/1/stty">stty(1)</a>, <a href="../man3/pcap.3.html#//apple_ref/doc/man/3/pcap">pcap(3)</a>, <a href="../man4/bpf.4.html#//apple_ref/doc/man/4/bpf">bpf(4)</a>, <!-- a -->nit(4P)<!-- /a -->, <!-- a -->pfconfig(8)<!-- /a -->

<b>AUTHORS</b>
       The original authors are:

       Van  Jacobson, Craig Leres and Steven McCanne, all of the Lawrence Berkeley National Laboratory, Uni-<font color="#ffffff" class="whiteout">versity&nbsp;University</font>
       versity of California, Berkeley, CA.

       It is currently being maintained by tcpdump.org.

       The current version is available via http:

              <a href="http://www.tcpdump.org/"><u>http://www.tcpdump.org/</u></a>

       The original distribution is available via anonymous ftp:

              <a href="ftp://ftp.ee.lbl.gov/tcpdump.tar.Z"><u>ftp://ftp.ee.lbl.gov/tcpdump.tar.Z</u></a>

       IPv6/IPsec support is added by WIDE/KAME project.  This program uses  Eric  Young's  SSLeay  library,
       under specific configuration.

<b>BUGS</b>
       Please send problems, bugs, questions, desirable enhancements, etc. to:

              tcpdump-workers@tcpdump.org

       Please send source code contributions, etc. to:

              patches@tcpdump.org

       NIT doesn't let you watch your own outbound traffic, BPF will.  We recommend that you use the latter.

       On Linux systems with 2.0[.x] kernels:

              packets on the loopback device will be seen twice;

              packet filtering cannot be done in the kernel, so that all packets must  be  copied  from  the
              kernel in order to be filtered in user mode;

              all  of a packet, not just the part that's within the snapshot length, will be copied from the
              kernel (the 2.0[.x] packet capture mechanism, if asked to copy only part of a packet to  user-
              land,  will  not report the true length of the packet; this would cause most IP packets to get
              an error from <b>tcpdump</b>);

              capturing on some PPP devices won't work correctly.

       We recommend that you upgrade to a 2.2 or later kernel.

       Some attempt should be made to reassemble IP fragments or, at least to compute the right  length  for
       the higher level protocol.

       Name  server inverse queries are not dumped correctly: the (empty) question section is printed rather
       than real query in the answer section.  Some believe that inverse queries are themselves  a  bug  and
       prefer to fix the program generating them rather than <u>tcpdump</u>.

       A  packet  trace  that  crosses a daylight savings time change will give skewed time stamps (the time
       change is ignored).

       Filter expressions on fields other than those in Token Ring headers will not correctly handle source-
       routed Token Ring packets.

       Filter expressions on fields other than those in 802.11 headers will not correctly handle 802.11 data
       packets with both To DS and From DS set.

       <b>ip6</b> <b>proto</b> should chase header chain, but at this moment it does not.  <b>ip6</b> <b>protochain</b> is supplied  for
       this behavior.

       Arithmetic  expression against transport layer headers, like <b>tcp[0]</b>, does not work against IPv6 pack-
       ets.  It only looks at IPv4 packets.



                                                18 April 2005                                     TCPDUMP(1)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man1/tcpdump.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man1/tcpdump.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man1/tcpdump.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
