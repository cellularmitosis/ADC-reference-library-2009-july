<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>About QuickDraw Drawing (IM: Im)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING59></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!--end of header -->

<center>
<A HREF="QuickDraw-58.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="QuickDraw-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="QuickDraw-476.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="QuickDraw-60.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="QuickDraw-2.html"><B>Imaging With QuickDraw</B></A> / <BR><DD><A HREF="QuickDraw-58.html"><B>Chapter 3 - QuickDraw Drawing</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING59-0></A>
<H1>About QuickDraw Drawing</H1>
 QuickDraw provides your application with routines for rapidly creating, manipulating, and drawing graphic objects such as lines, arcs, rectangles, ovals, regions, and bitmaps. <P>
 These routines extract information from and affect the fields of the current graphics port, without specifically naming it as a parameter. For example, the <CODE>Move</CODE> procedure moves the graphics pen of the current graphics port, changing the value of its <CODE>pnLoc</CODE> field, <BR>and the <CODE>PaintOval</CODE> procedure paints an oval using the pattern and pattern mode of the graphics pen for the current graphics port. <P>
 The previous chapter, "Basic QuickDraw," describes the basic graphics port. The next chapter, "Color QuickDraw," describes the color graphics port. The routines described in this chapter operate in both types of graphics ports.<P>
 Whenever you use QuickDraw, all drawing is performed with the graphics pen, which is described next.<P>
<A NAME=HEADING59-5></A>
<H2><A NAME=MARKER-9-14></A><A NAME=MARKER-2-454></A>The Graphics Pen</H2>
 Every graphics port contains one, and only one, graphics pen with which to perform drawing operations. You use this metaphorical pen to draw lines, shapes, and text. Using QuickDraw routines, you can set these five characteristics of the graphics pen for the current graphics port:<P>
<UL>
<LI>visibility, as stored in the <CODE>pnVis</CODE> fields of the <CODE>GrafPort</CODE> and <CODE>CGrafPort</CODE> records
<LI>size, as stored in the <CODE>pnSize</CODE> fields of the <CODE>GrafPort</CODE> and <CODE>CGrafPort</CODE> records
<LI>location, as stored in the <CODE>pnLoc</CODE> fields of the <CODE>GrafPort</CODE> and <CODE>CGrafPort</CODE> records
<LI>pattern, as stored in the <CODE>pnPat</CODE> field of the <CODE>GrafPort</CODE> and <CODE>CGrafPort</CODE> records
<LI>pattern mode, as stored in the <CODE>pnMode</CODE> fields of <CODE>GrafPort</CODE> and <CODE>CGrafPort</CODE> records<P>
</UL>
 The visibility of the graphics pen simply determines whether the pen draws on the screen. You can use the <CODE>HidePen</CODE> and <CODE>ShowPen</CODE> procedures to change the pen's visibility.<P>
 The graphics pen is rectangular in shape, and its size (that is, its height and width) are measured in pixels. The default size is a 1-by-1 pixel square, but you can use the <CODE>PenSize</CODE> procedure to change its shape from a 0-by-0 pixel square to a 32,767-by-32,767 pixel square. If you set either the width or the height to 0, however, the graphics pen does not draw. (Heights or widths of less than 0 are undefined.) <A HREF=#MARKER-9-16>Figure 3-1</A> illustrates a graphics pen of 8 pixels by 8 pixels.<P>
<B>Figure 3-1  <A NAME=MARKER-9-16></A>A graphics pen</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/DRAW-L-30.jpg"><BR>
 The graphics pen can be located anywhere on the local coordinate plane of the graphics port, and there are no restrictions on the movement or placement of the pen. You can use the <CODE>MoveTo</CODE> and <CODE>Move</CODE> procedures to change the pen's location, which is defined by the point that positions the upper-left corner of the pen. You can use the <CODE>GetPen</CODE> procedure to determine the pen's current location. As shown in <A HREF=#MARKER-9-16>Figure 3-1</A>, the pen draws below and to the right of the point specifying its location.<P>
 The pattern and pattern mode determine how the bits under the pen are affected when your application draws lines or shapes. A bit pattern is a repeating 8-by-8 bit image, such as that shown in <A HREF=#MARKER-9-16>Figure 3-1</A>. You can use the <CODE>PenPat</CODE> procedure to change the bit pattern for the graphics pen. Bit patterns are described in more detail in the next section. The pattern mode for the graphics pen determines how the bit pattern interacts with the existing bit image according to one of eight Boolean operations, as described in detail in <A HREF=#MARKER-9-37>"Boolean Transfer Modes With 1-Bit Pixels" beginning on page 3-7</A>. You can use the <CODE>PenMode</CODE> procedure to change the pattern mode of the graphics pen.<P>
 To determine the size, location, pattern, and pattern mode of the graphics pen, you can use the <CODE>GetPenState</CODE> procedure, which returns a <CODE>PenState</CODE> record that contains fields for each of these characteristics. If you need to temporarily change these characteristics, you can use the <CODE>SetPenState</CODE> procedure to restore the graphics pen to the state saved in the record returned by <CODE>GetPenState</CODE>.<P>
 Upon the creation of a graphics port, QuickDraw assigns these initial values to the graphics pen: a size of (1,1), a pattern of all-black pixels, and a pattern mode of <CODE>patCopy</CODE>. After changing any of these values, you can use the <CODE>PenNormal</CODE> procedure to return these initial values to the graphics pen.<A NAME=MARKER-2-287></A><P>
 <A HREF=#MARKER-9-53>"Lines and Shapes" beginning on page 3-9</A> describes how to use the graphics pen to draw lines and shapes.<P>
<A NAME=HEADING59-21></A>
<H2><A NAME=MARKER-9-18></A>Bit Patterns</H2>
 A <B>bit pattern</B> is a 64-pixel image, organized as an 8-by-8 pixel square, that defines a repeating design (such as stripes) or a tone (such as gray). The patterns defined in bit patterns are usually black and white, although any two colors can be used on a color screen. Pixel patterns (which are supported only in color graphics ports) define color patterns at any pixel depth. (Pixel patterns are described in the chapter "Color QuickDraw" in this book.) <A HREF=#MARKER-9-19>Figure 3-2</A> shows a typical bit pattern--the one used for the standard gray desktop pattern on most Macintosh computers with black-and-white screens. <P>
<B>Figure 3-2  <A NAME=MARKER-9-19></A>A bit pattern</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/DRAW-S-29.jpg"><BR>
 <A NAME=MARKER-2-322></A>You can use bit patterns to draw lines and shapes on the screen. In a basic graphics port, the graphics pen has a pattern specified in the <CODE>pnPat</CODE> field of its <CODE>GrafPort</CODE> record. This bit pattern acts like the ink in the pen; the bits in the pattern interact with the pixels in the bitmap according to the pattern mode of the graphics pen. When you use the <CODE>FrameRect</CODE>, <CODE>FrameRoundRect</CODE>, <CODE>FrameArc</CODE>, <CODE>FramePoly</CODE>, <CODE>FrameRgn</CODE>, <CODE>PaintRect</CODE>, <CODE>PaintRoundRect</CODE>, <CODE>PaintArc</CODE>, <CODE>PaintPoly</CODE>, and <CODE>PaintRgn</CODE> procedures to draw shapes, these procedures draw the shape with the bit pattern specified in the <CODE>pnPat</CODE> field.<P>
 You can use the <CODE>FillRect</CODE>, <CODE>FillRoundRect</CODE>, <CODE>FillArc</CODE>, <CODE>FillPoly</CODE>, and <CODE>FillRgn</CODE> procedures to draw shapes with a bit pattern other than that specified in the <CODE>pnPat</CODE> field of the graphics port. When your application uses one of these procedures, the procedure stores the pattern your application specifies in the <CODE>fillPat</CODE> field of the <CODE>GrafPort</CODE> record (or its handle in the <CODE>fillPixPat</CODE> field of a <CODE>CGrafPort</CODE> record) and then calls a low-level drawing routine that gets the pattern from that field.<A NAME=MARKER-2-330></A><P>
 Each graphics port also has a background pattern that's used when an area is erased (such as by using the <CODE>EraseRect</CODE>, <CODE>EraseRoundRect</CODE>, <CODE>EraseArc</CODE>, <CODE>ErasePoly</CODE>, and <CODE>EraseRgn</CODE> procedures) and when pixels are scrolled out of an area (such as by using the <CODE>ScrollRect</CODE> procedure as described in the chapter "Basic QuickDraw"). Every basic graphics port stores a background bit pattern in the <CODE>bkPat</CODE> field of its <CODE>GrafPort</CODE> record.<A NAME=MARKER-2-22></A> (Color graphics ports store a handle to the background pattern in their <CODE>bkPixPat</CODE> field.)<P>
 So that adjacent areas of the same pattern form a continuous, coordinated pattern, all patterns are always drawn relative to the origin of the graphics port.<P>
 <A NAME=MARKER-2-308></A>A basic graphics port supports only bit patterns. Bit patterns are defined in data structures of type <CODE>Pattern</CODE>, in which each pixel is represented by a single bit. Five such bit patterns are predefined as global variables for your use. These patterns are illustrated in <A HREF=#MARKER-9-24>Figure 3-3</A>. <P>
<B>Figure 3-3  <A NAME=MARKER-9-24></A>Windows filled with the predefined bit patterns</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/DRAW-L-24.jpg"><BR>
 <A NAME=MARKER-2-25></A>The upper-left window in this figure is filled with the predefined pattern <CODE>white</CODE>, in which every pixel is white. By default, this is the<B> background pattern</B> for a graphics port; that is, this is the pattern displayed when an area is erased or when bits are scrolled out of it. The <CODE>white</CODE> pattern can also produce useful effects when transferred with an appropriate pattern mode to an existing bit image. (Pattern modes are explained in <A HREF=#MARKER-9-37>"Boolean Transfer Modes With 1-Bit Pixels" beginning on page 3-7</A>.)<A NAME=MARKER-2-121></A><A NAME=MARKER-2-172></A><P>
 <A NAME=MARKER-2-214></A>The middle window in the top row of <A HREF=#MARKER-9-24>Figure 3-3</A> is filled with the predefined bit pattern <CODE>black</CODE>, in which every pixel is black. This is the initial pattern that QuickDraw assigns to the graphics pen.<A NAME=MARKER-2-376></A><P>
 <A NAME=MARKER-2-288></A><A NAME=MARKER-2-212></A><A HREF=#MARKER-9-24>Figure 3-3</A> illustrates a window filled with the predefined pattern <CODE>gray</CODE>, which uses a combination of black and white pixels. As illustrated in this figure, fewer black pixels in the combination produce the predefined pattern <CODE>ltGray</CODE>, and more black pixels produce the predefined pattern <CODE>dkGray</CODE>. <A NAME=MARKER-2-302></A><A NAME=MARKER-2-213></A><A NAME=MARKER-2-278></A><P>
 <A NAME=MARKER-2-432></A>These predefined patterns use colored pixels to produce similar effects in color graphics ports, as described in the chapter "Color QuickDraw."<P>
 You can create your own bit patterns in your program code, but it's usually simpler and more convenient to store them in resources of type <CODE>'PAT '</CODE> or <CODE>'PAT#'</CODE> and to read them in when you need them. The five predefined patterns are available not only through the global variables provided by QuickDraw but also as system resources stored in the system resource file. You can use the <CODE>GetPattern</CODE> function and the <CODE>GetIndPattern</CODE> procedure to get patterns stored as resources. <P>
 The result of the transfer of a pattern to a bitmap depends on the pattern mode, which is described next.<A NAME=MARKER-2-591></A><P>
<A NAME=HEADING59-38></A>
<H2><A NAME=MARKER-9-37></A>Boolean Transfer Modes With 1-Bit Pixels</H2>
 <A NAME=MARKER-2-431></A>A <B>Boolean transfer mode</B> describes an interaction between the pixels that your application draws and the pixels that are already in the destination bitmap--for example, when you draw a patterned line into a graphics port. Black-and-white drawing uses two types of Boolean transfer modes:<P>
<UL>
<LI><B>source modes</B> for copying bit images or drawing text<A NAME=MARKER-2-39></A>
<LI><B>pattern modes</B> for drawing lines and shapes<A NAME=MARKER-2-40></A><P>
</UL>
 Color QuickDraw uses Boolean transfer mode differently than basic QuickDraw. Color QuickDraw also has transfer modes that perform arithmetic operations on the red, green, and blue values of color pixels. Using transfer modes with Color QuickDraw is described in the chapter "Color QuickDraw" in this book.<P>
 Your application uses source modes when using <CODE>CopyBits</CODE> procedure (described in <A HREF=QuickDraw-60.html#MARKER-9-129>"Copying Bits Between Graphics Ports" beginning on page 3-28</A>) and the <CODE>CopyDeepMask</CODE> procedure (described in the chapter "Color QuickDraw"). <P>
 Your application uses pattern modes to transfer patterns to lines and shapes. The <CODE>penMode</CODE> field of a graphics port stores the pattern mode for the graphics pen. You use the pattern mode to draw lines, rectangles, rounded rectangles, ovals, arcs, wedges, polygons, and regions, as follows: <P>
<UL>
<LI>When you use a procedure like <CODE>LineTo</CODE>, <CODE>FrameRect</CODE>, or <CODE>FrameOval</CODE>, the procedure draws the lines of your shape with the pattern specified in the <CODE>pnPat</CODE> field of the graphics port, but the procedure transfers that pattern into the graphics port by using the pattern mode specified in the <CODE>pnMode</CODE> field of the current graphics port. 
<LI>When you use a procedure like <CODE>PaintRect</CODE> or <CODE>PaintOval</CODE>, the procedure draws your shape with the pattern specified in the <CODE>pnPat</CODE> field by transferring the pattern with the pattern mode specified in the <CODE>pnMode</CODE> field. 
<LI>When you use a procedure like <CODE>FillRect</CODE> or <CODE>FillOval</CODE>, the procedure draws your shape with the pattern you request and uses the <CODE>patCopy</CODE> pattern mode (which copies your requested pattern directly into the shape).<P>
</UL>
 You use the source mode when using the <CODE>CopyBits</CODE> procedure to copy a bit image from one graphics port to another and when drawing text using the QuickDraw routines described in the chapter "QuickDraw Text" in <I><A HREF="../Text/Text-2.html">Inside Macintosh: Text</A></I>. (The source mode for text is stored in the <CODE>textMode</CODE> field of a graphics port.)<P>
 For both pattern and source modes there are four Boolean operations: COPY, OR, XOR (for exclusive-or), and BIC (for bit clear). Each of these operations has an inverse variant in which the pattern or source is inverted before the transfer, so in fact there are eight operations in all.<P>
 The eight operations in the pattern and source modes have names defined as constants. Their effects on 1-bit destination pixels are summarized in <A HREF=#MARKER-9-7>Table 3-1</A>. (See the chapter "Color QuickDraw" for information about the effects of these operations on colored pixels--that is, those with a pixel depth of more than 1 pixel.)
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><A NAME=MARKER-9-7></A><B>Table 3-1 Effect of Boolean transfer modes on 1-bit pixels</B></CAPTION>
<TH>Pattern mode<TH>Source mode<TH colspan=2>Action on destination pixel<TR>
<TD>&nbsp;<TD>&nbsp;<TD>If pattern or source pixel is black<TD>If pattern or source pixel is white<TR>
<TD>patCopy<TD>srcCopy<TD>Force black<TD>Force white<A NAME=MARKER-2-2></A><TR>
<TD>notPatCopy<TD>notSrcCopy<TD>Force white<TD>Force black<A NAME=MARKER-2-3></A><TR>
<TD>patOr<TD>srcOr<TD>Force black<TD>Leave alone<A NAME=MARKER-2-4></A><TR>
<TD>notPatOr<TD>notSrcOr<TD>Leave alone<TD>Force black<A NAME=MARKER-2-5></A><TR>
<TD>patXor<TD>srcXor<TD>Invert<TD>Leave alone<A NAME=MARKER-2-152></A><TR>
<TD>notPatXor<TD>notSrcXor<TD>Leave alone<TD>Invert<A NAME=MARKER-2-118></A><TR>
<TD>patBic<TD>srcBic<TD>Force white<TD>Leave alone<A NAME=MARKER-2-8></A><TR>
<TD>notPatBic<TD>notSrcBic<TD>Leave alone<TD>Force white<A NAME=MARKER-2-9></A></TABLE>
<P>
 The COPY operations completely replace the pixels in the destination bitmap with either the pixels in the pattern (for the <CODE>patCopy</CODE> mode) or the pixels in the source bitmap (for the <CODE>srcCopy</CODE> mode). The inverse COPY operations completely replace the pixels in the destination bitmap with a "photographic negative" of the pattern (for the <CODE>notPatCopy</CODE> mode) or the source bitmap (for the <CODE>notSrcCopy</CODE> mode).<P>
 The OR operations add the black pixels from either the pattern (for the <CODE>patOr</CODE> mode) or the source bitmap (for the <CODE>srcOr</CODE> mode) to the destination bitmap. The inverse OR operations (<CODE>notPatOr</CODE> and <CODE>notSrcOr</CODE> modes) take a "photographic negative" of the pattern or the source bitmap, and then add the black pixels from this negative to the destination bitmap.<P>
 The XOR operations (<CODE>patXor</CODE> and <CODE>srcXor</CODE> modes) invert the pixels in the destination bitmap that correspond to black pixels in the pattern or source bitmap. The inverse XOR operations (<CODE>notPatXor</CODE> and <CODE>notSrcXor</CODE> modes) invert the pixels in the destination bitmap that correspond to white pixels in the pattern or source bitmap.<P>
 The BIC operations (<CODE>patBic</CODE> and <CODE>srcBic</CODE> modes) turn pixels in the destination bitmap white when they correspond to black pixels in the pattern or source bitmap. The inverse BIC operations (<CODE>notPatBic</CODE> and <CODE>notSrcBic</CODE> modes) turn pixels in the destination bitmap white when they correspond to white pixels in the pattern or source bitmap.<P>
 These actions are illustrated in <A HREF=#MARKER-9-41>Figure 3-4</A>, where a black X is transferred to a destination bitmap consisting of a black O.<P>
<B>Figure 3-4  <A NAME=MARKER-9-41></A>Examples of Boolean transfer modes<A NAME=MARKER-2-143></A><A NAME=MARKER-2-43></A><A NAME=MARKER-2-44></A><A NAME=MARKER-11-77></A><A NAME=MARKER-2-113></A><A NAME=MARKER-2-47></A><A NAME=MARKER-2-142></A><A NAME=MARKER-2-49></A></B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/DRAW-L-03.jpg"><BR>
 On computers running System 7, you can add dithering to any source mode by adding the following constant or the value it represents to the source mode:<P>
<PRE>
CONST ditherCopy  = 64;
</PRE>
 <B>Dithering</B> mixes existing colors to create the effect of additional colors on indexed devices. It also improves images that you shrink or that you copy from a direct pixel device to an indexed device. Using dithering even when shrinking 1-bit images between basic graphics ports can produce much better representations of the original images. The <CODE>CopyBits</CODE> procedure always dithers images when shrinking them between pixel maps on direct devices. Dithering is explained in the chapter "Color QuickDraw."<P>
 The next section describes how your application uses pattern modes to transfer patterns to lines and shapes.<A NAME=MARKER-2-50></A><A NAME=MARKER-2-51></A><A NAME=MARKER-2-52></A><P>
<A NAME=HEADING59-62></A>
<H2><A NAME=MARKER-9-53></A>Lines and Shapes</H2>
 As explained in the chapter "Basic QuickDraw," rectangles and regions are mathematical models that QuickDraw defines as data types. However, they also can be graphic elements that appear on the screen. A rectangle, for example, can mathematically define a visible area, but it can also be an object to draw.<P>
<A NAME=HEADING59-64></A>
<H3>Defining Lines and Shapes</H3>
 <A NAME=MARKER-2-54></A>You use two points to define a line. Using the <CODE>LineTo</CODE> and <CODE>Line</CODE> procedures, you can draw lines onscreen using the size, pattern, and pattern mode of the graphics pen for the current graphics port. You can also define a rectangle with two points (the upper-left and lower-right corners of the rectangle) or with four boundary coordinates (one for each side of the rectangle). Using the <CODE>FrameRect</CODE> procedure, you can draw rectangles that are framed by lines rendered with the size, pattern, and pattern mode of the graphics pen.<P>
 <A NAME=MARKER-2-55></A>You use rectangles to define ovals and rounded rectangles. Rectangles used to define other shapes are called <B>bounding rectangles.</B> The lines of bounding rectangles completely enclose the shapes they bound; in other words, no pixels from these shapes lie outside the infinitely thin lines of the bounding rectangles.<A NAME=MARKER-2-56></A><P>
 Ovals are circular or elliptical shapes defined by the height and width of their bounding rectangles, and rounded rectangles are rectangles with rounded corners defined by the width and height of the ovals forming their corners. Using the <CODE>FrameOval</CODE> and <CODE>FrameRoundRect</CODE> procedures, you can draw, respectively, framed ovals and framed rounded rectangles.<P>
 You can use rectangles to define ovals that, in turn, you can use to define arcs and wedges. An arc is a portion of an oval's circumference bounded by a pair of radii. A wedge is a pie-shaped segment of an oval. The wedge starts at the center of the oval, is bounded by a pair of radii, and extends to the oval's circumference. You use the <CODE>FrameArc</CODE> procedure to draw a framed arc, and you use the <CODE>PaintArc</CODE> or <CODE>FillArc</CODE> procedure to draw a wedge.<A NAME=MARKER-2-57></A><P>
 You use lines to define a polygon. First, however, you must call the <CODE>OpenPoly</CODE> function and then some number of <CODE>LineTo</CODE> procedures to create lines from the first vertex of the polygon to the second, from the second to the third, and so on, until you've created a line to the last vertex. You then use the <CODE>ClosePoly</CODE> procedure, which completes the figure by drawing a connecting line from the last vertex back to the first. After defining a polygon in this way, you can draw a framed outline of it using the <CODE>FramePoly</CODE> procedure.<P>
 To define a region, you can use any set of lines or shapes, including other regions, so long as the region's outline consists of one or more closed loops. First, however, you must call the <CODE>NewRgn</CODE> function and <CODE>OpenRgn</CODE> procedure. You then use line-, shape-, or region-drawing commands to define the region, which can be concave or convex, can consist of one connected area or many separate ones, and can even have holes in the middle. When you are finished collecting commands to define the outline of the region, you use the <CODE>CloseRgn</CODE> procedure. You can then draw a framed outline of the region using the <CODE>FrameRgn</CODE> procedure. <A NAME=MARKER-2-58></A><P>
<A NAME=HEADING59-71></A>
<H3>Framing Shapes</H3>
 <A NAME=MARKER-11-89></A><A NAME=MARKER-2-60></A>Using the <CODE>FrameRect</CODE>, <CODE>FrameOval</CODE>, <CODE>FrameRoundRect</CODE>, <CODE>FrameArc</CODE>, <CODE>FramePoly</CODE>, or <CODE>FrameRgn</CODE> procedure to <B>frame</B> a shape draws just its outline, using the size, pattern, and pattern mode of the graphics pen for the current graphics port. The interior of the shape is unaffected, allowing previously existing pixels in the bit image to show through. <P>
<A NAME=HEADING59-73></A>
<H3>Painting and Filling Shapes</H3>
 <A NAME=MARKER-2-150></A>Using the <CODE>PaintRect</CODE>, <CODE>PaintOval</CODE>, <CODE>PaintRoundRect</CODE>, <CODE>PaintArc</CODE>, <CODE>PaintPoly</CODE>, or <CODE>PaintRgn</CODE> procedure to <B>paint</B> a shape draws both its outline and its interior with the pattern of the graphics pen, using the pattern mode of the graphics pen. <P>
 Using the <CODE>FillRect</CODE>, <CODE>FillOval</CODE>, <CODE>FillRoundRect</CODE>, <CODE>FillArc</CODE>, <CODE>FillPoly</CODE>, or <CODE>FillRgn</CODE> procedure to <B>fill</B> a shape draws both its outline and its interior with any pattern you specify. The procedure transfers the pattern with the <CODE>patCopy</CODE> pattern mode, which directly copies your requested pattern into the shape.<P>
<A NAME=HEADING59-76></A>
<H3>Erasing Shapes</H3>
 <A NAME=MARKER-2-129></A>Using the <CODE>EraseRect</CODE>, <CODE>EraseOval</CODE>, <CODE>EraseRoundRect</CODE>, <CODE>EraseArc</CODE>, <CODE>ErasePoly</CODE>, or <CODE>EraseRgn</CODE> procedure to <B>erase</B> a shape draws both its outline and its interior with the background pattern for the current graphics port. The background pattern is typically solid white on a black-and-white monitor or a solid background color on a color monitor. Making the shape blend into the background pattern of the graphics port effectively erases the shape.<P>
<A NAME=HEADING59-78></A>
<H3>Inverting Shapes</H3>
 <A NAME=MARKER-2-402></A>Using the <CODE>InvertRect</CODE>, <CODE>InvertOval</CODE>, <CODE>InvertRoundRect</CODE>, <CODE>InvertArc</CODE>, <CODE>InvertPoly</CODE>, or <CODE>InvertRgn</CODE> procedure to <B>invert</B> a shape reverses the colors of all pixels within its boundary. On a black-and-white monitor, this changes all the black pixels in the shape to white and changes all the white pixels to black. <P>
 The inversion procedures were designed for 1-bit images in basic graphics ports. These procedures operate on color pixels in color graphics ports, but the results are predictable only with direct devices or 1-bit pixel maps. <P>
 For indexed pixels, Color QuickDraw performs the inversion on the pixel indexes. The results depend entirely on the contents of the video device's color lookup table (CLUT). (The CLUT is described in the chapter "Color QuickDraw.") <P>
 The eight colors used in basic QuickDraw are stored in a color table represented by the global variable <CODE>QDColors</CODE>. To display those eight basic QuickDraw colors on an indexed device, Color QuickDraw uses the Color Manager to obtain indexes to the colors in the CLUT that best map to the colors in the <CODE>QDColors</CODE> color table. Because the index, not the color value, is inverted, the results are again unpredictable. (The eight-color system is described in <A HREF=#MARKER-9-65>"The Eight Basic QuickDraw Colors" beginning on page 3-12</A>.)<P>
 Inversion works better for direct devices. Inverting a pure green, for example, that has red, green, and blue component values of $0000, $FFFF, and $0000 results in magenta, which has component values of $FFFF, $0000, and $FFFF.<A NAME=MARKER-2-145></A><P>
<A NAME=HEADING59-84></A>
<H3>Other Graphic Entities</H3>
 <A HREF=QuickDraw-60.html#MARKER-9-72>"Drawing With QuickDraw" beginning on page 3-14</A> provides an introduction to creating and drawing lines, rectangles, rounded rectangles, ovals, arcs, wedges, polygons, and regions. You can also use QuickDraw routines to draw pictures, cursors, icons, and text.<P>
 A QuickDraw picture is the recorded transcription of a sequence of drawing operations that can be played back with the <CODE>DrawPicture</CODE> procedure. See the chapter "Pictures" for information about creating and displaying QuickDraw pictures.<P>
 A cursor is a 16-by-16 pixel image that maps the user's movement of the mouse to relative locations on the screen. An icon is an image (usually 32 by 32 or 16 by 16 pixels) that represents an object, a concept, or a message. For example, the Finder uses icons to represent files and disks. Cursors and icons are stored as resources. See the chapter "Cursor Utilities" for information about drawing cursors. See the chapter "Icon Utilities" in <I><A HREF="../MoreToolbox/MoreToolbox-2.html">Inside Macintosh: More Macintosh Toolbox</A></I> for information about drawing icons.<P>
 See the chapter "QuickDraw Text" in <I><A HREF="../Text/Text-2.html">Inside Macintosh: Text</A></I> for information about using QuickDraw routines to draw text.<P>
<A NAME=HEADING59-89></A>
<H2><A NAME=MARKER-9-65></A>The Eight Basic QuickDraw Colors</H2>
 <A NAME=MARKER-2-405></A><A NAME=MARKER-2-68></A>On a color screen, you can draw with colors, even when you are using a basic graphics port. Although basic QuickDraw graphics routines were designed for black-and-white drawing, they also support the <B>eight-color system</B> that basic QuickDraw predefines for display on color screens and color printers. Because Color QuickDraw also supports this system, it is compatible across all Macintosh platforms. (This section describes the rudimentary color capabilities included in basic QuickDraw. See the next chapter, "Color QuickDraw," for information about more sophisticated color use in your application.)<P>
 A pair of fields in a graphics port, <CODE>fgColor</CODE> and <CODE>bkColor</CODE>, specify a foreground and background color. The <B>foreground color</B> is the color used for bit patterns and for the graphics pen when drawing. By default, the foreground color is black. The <B>background color</B> is the color of the pixels in the bitmap wherever no drawing has taken place. By default, the background color is white. However, you can use the <CODE>ForeColor</CODE> and <CODE>BackColor</CODE> procedures to change these fields. (When printing, however, use the <CODE>ColorBit</CODE> procedure to set the foreground color.) For example, on a color screen the following lines of code draw a red rectangle against a blue background.<P>
<PRE>
BackColor(blueColor);   {make a blue background}
ForeColor(redColor);    {draw with red ink}
PenMode(patCopy);       {when drawing, replace background color }
                        { with ink's color}
PaintRect(20,20,80,80); {create and paint the red rectangle}
</PRE>
 If you use the <CODE>OpenCPicture</CODE> or <CODE>OpenPicture</CODE> function to include this code in a picture definition, these colors are stored in the picture. However, basic QuickDraw cannot store these colors in a bitmap. See the chapter "Pictures" in this book for more information about defining and drawing pictures.<P>
 The basic QuickDraw color values consist of 1 bit for normal black-and-white drawing (black on white), 1 bit for inverted black-and-white drawing (white on black), 3 bits for the additive primary colors (red, green, blue) used in video display, and 4 bits for the subtractive primary colors (cyan, magenta, yellow, black) used in printing. QuickDraw includes a set of predefined constants for those standard colors: <P>
<PRE>
CONST
 \xDDwhiteColor   =\xDD30;
 \xDDblackColor   = 33
 \xDDyellowColor  = 69;
  magentaColor =\xDD137;
 \xDDredColor     =\xDD205;
 \xDDcyanColor    =\xDD273;
 \xDDgreenColor   =\xDD341;
 \xDDblueColor    =\xDD409;
</PRE>
 These are the only colors available in basic QuickDraw (or with Color QuickDraw drawing into a basic graphics port). When you specify these colors on a Macintosh computer with Color QuickDraw, Color QuickDraw draws these colors if the user has set the screen to a color mode. <P>
 These eight color values are based on a planar model: each bit position corresponds to a different color plane, and the value of each bit indicates whether a particular color plane should be activated. (The term <I>color plane</I> refers to a logical plane, rather than a physical plane.) The individual color planes combine to produce the full-color image. <P>
 There are three advantages to using basic QuickDraw's color system:<P>
<UL>
<LI>It is available across all platforms, so you don't have to check for the presence of Color QuickDraw.
<LI>It is much simpler to use than Color QuickDraw.
<LI>It works well on an ImageWriter printer with a color ribbon.<P>
</UL>
 The main disadvantage is that basic QuickDraw is limited to eight predefined colors. Another problem is that, if the graphics port in which you are working happens to be a color graphics port, then the two color systems may clash. For example, saving the current foreground color (from the <CODE>fgColor</CODE> field of the color graphics port) and then later restoring it with the <CODE>ForeColor</CODE> procedure doesn't work: the original content of the <CODE>fgColor</CODE> field is an index value for a color graphics port using indexed colors. This index value is not what basic QuickDraw's <CODE>ForeColor</CODE> procedure expects as a parameter.<P>
 In System 7, these Color QuickDraw routines are available to basic QuickDraw: <CODE>RGBForeColor</CODE>, <CODE>RGBBackColor</CODE>, <CODE>GetForeColor</CODE>, and <CODE>GetBackColor</CODE>. Described in the next chapter, "Color QuickDraw," these routines can also assist you in manipulating the eight-color system of basic QuickDraw. When running on a System 7 computer, your application should use <CODE>GetForeColor</CODE> and <CODE>GetBackColor</CODE> to determine the foreground color and background color instead of checking the <CODE>fgColor</CODE> and <CODE>bkColor</CODE> fields of the <CODE>GrafPort</CODE> record.<P>
 The next section provides an introduction to creating and drawing lines and shapes. Without using a color graphics port, you can use the <CODE>ForeColor</CODE> or <CODE>RGBForeColor</CODE> procedure on a color screen to draw these lines and shapes in color, against the background color you set with the <CODE>BackColor</CODE> or <CODE>RGBBackColor</CODE> procedure.<A NAME=MARKER-2-69></A><A NAME=MARKER-2-70></A><A NAME=MARKER-11-169></A><P>

</BLOCKQUOTE>
<HR>
<center>
<A HREF="QuickDraw-58.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="QuickDraw-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="QuickDraw-476.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="QuickDraw-60.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="QuickDraw-3.html">&copy; Apple Computer, Inc.</A><br>7 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
