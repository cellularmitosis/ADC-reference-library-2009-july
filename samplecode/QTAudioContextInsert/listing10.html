<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>QTAudioContextInsert - /AudioPropertiesInspectorController.mm</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/QuickTime/index.html">QuickTime</a> &gt; <a href="../../samplecode/QuickTime/idxMusicAudio-date.html">Audio</a> &gt; <A HREF="javascript:location.replace('index.html');">QTAudioContextInsert</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->


	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">QTAudioContextInsert</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/AudioPropertiesInspectorController.mm</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/ACInsertManager.h</option>
<option value="listing2.html">/ACInsertManager.mm</option>
<option value="listing3.html">/ACInsertProcessor.h</option>
<option value="listing4.html">/ACInsertProcessor.mm</option>
<option value="listing5.html">/ACInsertWindowController.h</option>
<option value="listing6.html">/ACInsertWindowController.mm</option>
<option value="listing7.html">/AudioExtractionWindowController.h</option>
<option value="listing8.html">/AudioExtractionWindowController.mm</option>
<option value="listing9.html">/AudioPropertiesInspectorController.h</option>
<option value="listing10.html">/AudioPropertiesInspectorController.mm</option>
<option value="listing11.html">/CoreAudioPlayback.c</option>
<option value="listing12.html">/CoreAudioPlayback.h</option>
<option value="listing13.html">/CustomDataTypes.h</option>
<option value="listing14.html">/CustomDataTypes.mm</option>
<option value="listing15.html">/CustomTableColumns.h</option>
<option value="listing16.html">/CustomTableColumns.mm</option>
<option value="listing17.html">/English.lproj/ACInsertWindow.nib/_ACInsertWindow_EOArchive_English.java</option>
<option value="listing18.html">/English.lproj/AudioExtractionWindow.nib/_AudioExtractionWindow_EOArchive_English.java</option>
<option value="listing19.html">/English.lproj/AudioPropertiesWindow.nib/_AudioProperties_EOArchive_English.java</option>
<option value="listing20.html">/English.lproj/MainMenu.nib/_MainMenu_EOArchive_English.java</option>
<option value="listing21.html">/MovieDocument.h</option>
<option value="listing22.html">/MovieDocument.mm</option>
<option value="listing23.html">/MovieWindowController.h</option>
<option value="listing24.html">/MovieWindowController.mm</option>
<option value="listing25.html">/QTACInsertApp_main.mm</option>
<option value="listing26.html">/QTACInsertAppDelegate.h</option>
<option value="listing27.html">/QTACInsertAppDelegate.mm</option>
<option value="listing28.html">/QuickTimeAudioUtils.c</option>
<option value="listing29.html">/QuickTimeAudioUtils.h</option>
<option value="listing30.html">/README.txt</option></select>
				</p>
				</form>
				<p><strong><a href="QTAudioContextInsert.zip">Download Sample</a></strong> (&#147;QTAudioContextInsert.zip&#148;, 305.7K)<BR>
<strong><a href="QTAudioContextInsert.dmg">Download Sample</a></strong> (&#147;QTAudioContextInsert.dmg&#148;, 344.2K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*

    File:        AudioPropertiesInspectorController.mm

    Abstract:    Implements the Audio Properties Inspector panel.
                This panel is used to inspect and change movie
                and audio track audio settings such as gain, track 
                enabled/disabled state and track channel assignments.
                
    Version:    1.0

    Disclaimer: IMPORTANT:  This Apple software is supplied to you by Apple
    Computer, Inc. (&quot;Apple&quot;) in consideration of your agreement to the
    following terms, and your use, installation, modification or
    redistribution of this Apple software constitutes acceptance of these
    terms.  If you do not agree with these terms, please do not use,
    install, modify or redistribute this Apple software.

    In consideration of your agreement to abide by the following terms, and
    subject to these terms, Apple grants you a personal, non-exclusive
    license, under Apple's copyrights in this original Apple software (the
    &quot;Apple Software&quot;), to use, reproduce, modify and redistribute the Apple
    Software, with or without modifications, in source and/or binary forms;
    provided that if you redistribute the Apple Software in its entirety and
    without modifications, you must retain this notice and the following
    text and disclaimers in all such redistributions of the Apple Software. 
    Neither the name, trademarks, service marks or logos of Apple Computer,
    Inc. may be used to endorse or promote products derived from the Apple
    Software without specific prior written permission from Apple.  Except
    as expressly stated in this notice, no other rights or licenses, express
    or implied, are granted by Apple herein, including but not limited to
    any patent rights that may be infringed by your derivative works or by
    other works in which the Apple Software may be incorporated.

    The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE
    MAKES NO WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION
    THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS
    FOR A PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND
    OPERATION ALONE OR IN COMBINATION WITH YOUR PRODUCTS.

    IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
    INTERRUPTION) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION,
    MODIFICATION AND/OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED
    AND WHETHER UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE),
    STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE
    POSSIBILITY OF SUCH DAMAGE.

    Copyright &copy; 2006-2008 Apple Inc. All Rights Reserved.
*/

#import &quot;AudioPropertiesInspectorController.h&quot;

// Movie gain change property listener callback
// Used to update the movie gain slider in the movie settings view
static void movieGainChangeCallback(Movie m, QTPropertyClass propClass, QTPropertyID propID, id observer);

@implementation AudioPropertiesInspectorController

#pragma mark
#pragma mark ---- Init, Dealloc, Post-Nib Loading ---

- (id) init
{
    self = [self initWithWindowNibName:@&quot;AudioPropertiesWindow&quot;];
    if (self) 
    {
        mMovieDocument = [[NSDocumentController sharedDocumentController] currentDocument];
        mChannelLabelOptionsMenu = nil;
        mAudioTracks = [[NSMutableArray alloc] init];
        mCommonChannelLabelOptions = [[NSMutableArray alloc] init];
    }
    return self;
}

- (void) dealloc
{
    [[NSNotificationCenter defaultCenter] removeObserver:self];
    [self removeMovieGainPropertyListener:[self movie]];
    [self setChannelLabelOptionsMenu:nil];
    [mAudioTracks release];
    [mCommonChannelLabelOptions release];
    [super dealloc];
}

- (void)awakeFromNib
{
    // Populate the channel options menu with channel label names 
    // that make sense for the current movie
    [self synchronizeChannelLabelOptionsMenu];
}

- (void)windowDidLoad 
{    
    [super windowDidLoad];

    [[self window] setTitle:[NSString stringWithFormat:@&quot;Audio Properties : %@&quot;, (NSString*)[[self movie] attributeForKey:QTMovieDisplayNameAttribute]]];
    
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(windowWillClose:) name:NSWindowWillCloseNotification object:nil];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(tableViewSelectionChanged:) name:NSTableViewSelectionDidChangeNotification object:nil];
    // Add an observor for movie gain changes
    [self addMovieGainPropertyListener:[self movie]];
    
    // Dispatched set-up
    [uiTrackTableView reloadData];

}

#pragma mark
#pragma mark --- Setter ----
- (void)setChannelLabelOptionsMenu:(NSMenu*)menu
{
    [menu retain];
    [mChannelLabelOptionsMenu release];
    mChannelLabelOptionsMenu = menu;
}

#pragma mark
#pragma mark --- Getter ----
-(QTMovie*)movie
{
    return [mMovieDocument movie];
}

#pragma mark
#pragma mark ---- IB Actions ----
- (IBAction)iaMovieGainSliderChanged:(id)sender
{
    float gain = [sender floatValue];
    (void)QTSetMovieProperty([[self movie] quickTimeMovie], 
                                    kQTPropertyClass_Audio,
                                    kQTAudioPropertyID_Gain, 
                                    sizeof(gain),  
                                    &amp;gain);
}

- (IBAction)iaTrackGainSliderChanged:(id)sender
{
    float gain = [sender floatValue];
    int indexIntoTrackArray = [uiTrackTableView selectedRow] - 1;
    QTTrack *selectedTrack = [mAudioTracks objectAtIndex:indexIntoTrackArray];
    
    (void)QTSetTrackProperty([selectedTrack quickTimeTrack], 
                                            kQTPropertyClass_Audio, 
                                            kQTAudioPropertyID_Gain, 
                                            sizeof(gain),  
                                            &amp;gain);
}


#pragma mark
#pragma mark ---- Panel UI Functions ----
// Depending on whether the movie or a track is selected
// in the upper 'track table', select which view -
// movie settings view or track settings view - to display
- (void)synchronizeSettingsView
{
    int trackTableSelectedRow = [uiTrackTableView selectedRow];
    float gain = 0.;
    
    if (trackTableSelectedRow == 0) 
    {
        // Switch to the Movie Settings Tab
        [uiSettingsTabView selectTabViewItemAtIndex:0];
        
        // Get the movie gain and update the gain slider
        [self synchronizeMovieGainSlider];                                        
    } 
    else 
    {
        int indexIntoTrackArray = trackTableSelectedRow - 1;
        if (indexIntoTrackArray &gt;= 0 &amp;&amp; indexIntoTrackArray &lt; (int)[mAudioTracks count]) 
        {
            QTTrack *selectedTrack = [mAudioTracks objectAtIndex:indexIntoTrackArray];
            // Select the Track Settings Tab
            [uiSettingsTabView selectTabViewItemAtIndex:1];
            // Get the track's gain
            (void) QTGetTrackProperty([selectedTrack quickTimeTrack], 
                                        kQTPropertyClass_Audio, 
                                        kQTAudioPropertyID_Gain, 
                                        sizeof (gain), &amp;gain, NULL);
            [uiTrackGainSlider setFloatValue:(float)gain];
                            
            // Reload the channel assignment table
            [uiTrackChannelLayoutTableView reloadData];

        }
    }

}

// Get the current value for the movie gain and 
// set the movie gain slider to this value
- (void)synchronizeMovieGainSlider
{
    float gain = 0.;
    if ( [uiSettingsTabView indexOfTabViewItem:[uiSettingsTabView selectedTabViewItem]] == 0)
    {
        
        // If the current tab view is the movie settings view, 
        // get the movie gain and update the gain slider
        (void) QTGetMovieProperty([[self movie] quickTimeMovie], 
                                        kQTPropertyClass_Audio, 
                                        kQTAudioPropertyID_Gain, 
                                        sizeof(gain), &amp;gain, NULL);
        [uiMovieGainSlider setFloatValue:(float)gain];    
    }
}

- (void)synchronizeChannelLabelOptionsMenu
{
    // Populates the channel label options array
    // with options that make sense for the selected track
    NSMenu *menu = [[NSMenu alloc] init];
    [self getNewChannelLabelOptions:menu];
    [self setChannelLabelOptionsMenu:menu];    //update our cached copy
    [menu release];    
}

- (void)getNewChannelLabelOptions:(NSMenu*)menu
{

    NSMenuItem *menuItem;    

    // This tag gets us most of the labels that we are interested in
    AudioChannelLayoutTag    tag = kAudioChannelLayoutTag_MPEG_7_1_A;
    UInt32                    layoutSize = 0;
    AudioChannelLayout        *layout = NULL;
    UInt32                    channel = 0;
    UInt32                    numDiscreteChannels = 0;
    UInt32                    numMovieAudioChannels = 0;
    UInt32                    numDeviceChannels = 0;
    UInt32                    index;
    
    // This array doesn't exist yet, so let's make it
    // it will contain some commonly used channel labels
    if ([mCommonChannelLabelOptions count] == 0) 
    {
        if (noErr != AudioFormatGetPropertyInfo (kAudioFormatProperty_ChannelLayoutForTag, sizeof(AudioChannelLayoutTag), 
                                                &amp;tag, &amp;layoutSize))
        {
            goto bail;                                    
        }
        layout = (AudioChannelLayout*)malloc(layoutSize);
        if (noErr != AudioFormatGetProperty(kAudioFormatProperty_ChannelLayoutForTag, sizeof(AudioChannelLayoutTag), 
                                                &amp;tag, &amp;layoutSize, layout))
        {
            goto bail;
        }                                        
        if (noErr != expandChannelLayout(&amp;layout, &amp;layoutSize))
        {
            goto bail;
        }    
        // Commonly used labels 
        for (channel = 0 ; channel &lt; layout-&gt;mNumberChannelDescriptions; channel++)
        {
            AudioChannelLabel thisLabel = (AudioChannelLabel)(layout-&gt;mChannelDescriptions[channel]).mChannelLabel;
            [mCommonChannelLabelOptions addObject:[NSNumber numberWithInt:thisLabel]];
        }
        
        // Center Surround, Mono, Unused
        [mCommonChannelLabelOptions addObject:[NSNumber numberWithInt:kAudioChannelLabel_CenterSurround]];
        [mCommonChannelLabelOptions addObject:[NSNumber numberWithInt:kAudioChannelLabel_Mono]];
        [mCommonChannelLabelOptions addObject:[NSNumber numberWithInt:kAudioChannelLabel_Unused]];
    }
    
    // Add the commonly used labels to our menu
    for (index = 0; index &lt; [mCommonChannelLabelOptions count]; index++)
    {
        menuItem = [[NSMenuItem alloc] init];
        [self fillInMenuItem:menuItem forChannelLabel:(AudioChannelLabel)[[mCommonChannelLabelOptions objectAtIndex:index] intValue]];
        [menu addItem:menuItem];
        [menuItem release];

    }
     
    // Now add discrete channel labels to our menu
    // The number of discrete channels is the the greater number between 
    // the total number of device channels and the total number of discrete
    // movie channels    
    getDeviceNumberOfChannels([[self movie] quickTimeMovie], &amp;numDeviceChannels);
    getNumMovieAudioChannels([[self movie] quickTimeMovie], &amp;numMovieAudioChannels);
    numDiscreteChannels = (numMovieAudioChannels &gt; numDeviceChannels) ? numMovieAudioChannels : numDeviceChannels;
    
    for (index = 0; index &lt; numDiscreteChannels; index++)
    {
        menuItem = [[NSMenuItem alloc] init];
        [self fillInMenuItem:menuItem forChannelLabel:(AudioChannelLabel)((1L&lt;&lt;16) | index)];
        [menu addItem:menuItem];
        [menuItem release];
    }
    
bail:
    if (layout)
    {
        free(layout);
    }    
}

// Fills in a menu item with the channel name correspoding to the AudioChannelLabel
// specified. Also sets the menu item's tag to the AudioChannelLabel
- (void) fillInMenuItem:(NSMenuItem*)theMenuItem forChannelLabel:(AudioChannelLabel)theLabel
{
    AudioChannelDescription acd = {0};
    NSString* channelLabelStr;    
    UInt32 channelLabelStringSize = sizeof(NSString*);

    acd.mChannelLabel = theLabel;
    // Get the name for this channel
    if (noErr == AudioFormatGetProperty(kAudioFormatProperty_ChannelName, 
                                sizeof(AudioChannelDescription),
                                &amp;acd,
                                &amp;channelLabelStringSize,
                                &amp;channelLabelStr))
    {                        
        [theMenuItem setTitle:channelLabelStr];            // title = The channel name string
        [theMenuItem setTag:(int)acd.mChannelLabel];    // tag = AudioChannelLabel            
    }
    [channelLabelStr release];
}    

#pragma mark
#pragma mark ---- Wrappers to C Routines ----

// The movie gain property listener callback is called
// whenever the movie gain changes
- (void)addMovieGainPropertyListener:(QTMovie*)movie
{
    (void)QTAddMoviePropertyListener([movie quickTimeMovie],
                                    kQTPropertyClass_Audio, 
                                    kQTAudioPropertyID_Gain,
                                    (QTMoviePropertyListenerUPP)&amp;movieGainChangeCallback, 
                                    self);

}

- (void)removeMovieGainPropertyListener:(QTMovie*)movie
{
    QTRemoveMoviePropertyListener([movie quickTimeMovie],
                                    kQTPropertyClass_Audio, 
                                    kQTAudioPropertyID_Gain,
                                    (QTMoviePropertyListenerUPP)&amp;movieGainChangeCallback, 
                                    self);
}

#pragma mark
#pragma mark ---- NSTableView DataSource Methods ----------

-(int) numberOfRowsInTableView:(NSTableView*)tableView
{
    UInt32 numberOfRows = 0;
    
    if ( [mMovieDocument movie] ) 
    {
        if ( [tableView isEqual:uiTrackTableView] ) 
        {
            // Track Table
            UInt32    index;
            NSArray    *arrayOfMovieTracks = [(QTMovie*)[self movie] tracks];    
                    
            [mAudioTracks removeAllObjects];
            for (index = 0; index &lt; [arrayOfMovieTracks count]; index++) 
            {
                // Look for audio tracks that mix into the audio context 
                // (no streaming or MPEG tracks)
                if (trackMixesToAudioContext([[arrayOfMovieTracks objectAtIndex:index] quickTimeTrack])) 
                {
                    [mAudioTracks addObject:[arrayOfMovieTracks objectAtIndex:index]];
                }
            }        
            // No. of rows = no. of tracks that mix into audio context + 1 (for the movie info) 
            numberOfRows = [mAudioTracks count] + 1;
            
        } else if ([tableView isEqual:uiTrackChannelLayoutTableView]) 
        {
            // Track Channel Layout table    
            QTTrack *selectedTrack = nil;
            AudioChannelLayout *trackLayout = NULL; 
            UInt32 trackLayoutSize = 0;
            int indexIntoTrackArray = [uiTrackTableView selectedRow] - 1;    //offset by one, since first row contains movie info
            
            if (indexIntoTrackArray &gt;= 0 &amp;&amp; indexIntoTrackArray &lt; (int)[mAudioTracks count]) 
            {
                selectedTrack = [mAudioTracks objectAtIndex:indexIntoTrackArray];
                if (noErr == getTrackLayoutAndSize([selectedTrack quickTimeTrack], &amp;trackLayoutSize, &amp;trackLayout))
                {
                    // No. of rows = no. of channels that the currently selected track has
                    UInt32 numberOfRowsSize = sizeof(numberOfRows);
                    (void) AudioFormatGetProperty(kAudioFormatProperty_NumberOfChannelsForLayout, 
                                                  trackLayoutSize, 
                                                  trackLayout, 
                                                  &amp;numberOfRowsSize, 
                                                  &amp;numberOfRows);    
                }
                if (trackLayout) 
                {
                    free(trackLayout);
                }    
            }
        }
    }
    return numberOfRows;
}

- (id)tableView:(NSTableView *)tableView objectValueForTableColumn:(NSTableColumn *)tableColumn row:(int)row
{
    id objectValue = nil; 
    NSString *column_id = [tableColumn identifier];

    if ( [tableView isEqual:uiTrackTableView] ) 
    {
        // Track table 
        if ( [column_id isEqualToString:@&quot;enabled&quot;]) 
        {
            if (row == 0) 
            {
                objectValue = [NSString stringWithFormat:@&quot;&quot;];
            } 
            else 
            {
                int indexIntoTrackArray = row-1;    //account for the fact that the first row in table corresponds to movie info
                if (indexIntoTrackArray &gt;= 0 &amp;&amp; indexIntoTrackArray &lt; (int)[mAudioTracks count]) 
                {
                    objectValue = (NSNumber*)[[mAudioTracks objectAtIndex:indexIntoTrackArray] attributeForKey:QTTrackEnabledAttribute];
                }
            }
        } 
        else if ( [column_id isEqualToString:@&quot;name&quot;]) 
        {
            if (row == 0) 
            {
                objectValue = (NSString*)[[self movie] attributeForKey:QTMovieDisplayNameAttribute];
            } 
            else 
            {
                int indexIntoTrackArray = row-1;    //account for the fact that the first row in table corresponds to movie info
                if (indexIntoTrackArray &gt;= 0 &amp;&amp; indexIntoTrackArray &lt; (int)[mAudioTracks count]) 
                {
                    objectValue = (NSString*)[[mAudioTracks objectAtIndex:indexIntoTrackArray] attributeForKey:QTTrackDisplayNameAttribute];
                }
            }
        } 
    }
    else if ([tableView isEqual:uiTrackChannelLayoutTableView]) 
    {
        // Track Channel Layout table
        QTTrack     *selectedTrack = NULL;
        UInt32 trackLayoutSize = 0;
        AudioChannelLayout *trackLayout = NULL;
        int indexIntoTrackArray;    
        
        if ([column_id isEqualToString:@&quot;channel&quot;]) 
        {
            objectValue = [NSNumber numberWithInt:row+1];    // channel numbers are 1-based
        } 
        else if ([column_id isEqualToString:@&quot;assignment&quot;]) 
        {
            indexIntoTrackArray = [uiTrackTableView selectedRow] - 1;    // offset by one since the track table first row contains movie info
            if (indexIntoTrackArray &gt;= 0 &amp;&amp; indexIntoTrackArray &lt; (int)[mAudioTracks count])
            {
                selectedTrack = [mAudioTracks objectAtIndex:indexIntoTrackArray];
                if (noErr == getTrackLayoutAndSize([selectedTrack quickTimeTrack], &amp;trackLayoutSize, &amp;trackLayout))     
                {
                    int indexIntoMenu;
                    AudioChannelLabel theChannelLabel = trackLayout-&gt;mChannelDescriptions[row].mChannelLabel;
                    for (indexIntoMenu = 0; indexIntoMenu &lt; [mChannelLabelOptionsMenu numberOfItems]; indexIntoMenu++)
                    {
                        if (theChannelLabel == (AudioChannelLabel)[[mChannelLabelOptionsMenu itemAtIndex:indexIntoMenu] tag]) 
                        {
                            objectValue = [NSNumber numberWithInt:indexIntoMenu];
                        }
                    }
                }
                if (trackLayout) 
                {
                    free(trackLayout);
                }    
            }             
        }
    }
    return objectValue;
}

-(void) tableView:(NSTableView*)tableView setObjectValue:(id)value forTableColumn:(NSTableColumn*)tableColumn row:(int)row
{
    NSString *column_id = [tableColumn identifier];

    if ( [tableView isEqual:uiTrackTableView] ) 
    {
        // Track table
        if ([column_id isEqualToString:@&quot;enabled&quot;]) 
        {
            int indexIntoTrackArray = row-1;
            if (indexIntoTrackArray &gt;= 0 &amp;&amp; indexIntoTrackArray &lt; (int)[mAudioTracks count]) 
            {
                [[mAudioTracks objectAtIndex:indexIntoTrackArray] setAttribute:value forKey:QTTrackEnabledAttribute];
                [[NSNotificationCenter defaultCenter] postNotificationName:QTAudioContextInsertMovieTracksChangedNotification object:[mMovieDocument movie]];
                // Enabling/disabling a track changes the discrete channel label
                // options, so update these options, and reload the channel layout table
                [self synchronizeChannelLabelOptionsMenu];
                [uiTrackChannelLayoutTableView reloadData];
            }
        }
        
    }
    else if ([tableView isEqual:uiTrackChannelLayoutTableView]) 
    {
        // Track Channel Layout table
        if ([column_id isEqualToString:@&quot;assignment&quot;]) 
        {
            int indexIntoMenu;
            AudioChannelLabel newLabel;            
            QTTrack     *selectedTrack = NULL;
            UInt32 trackLayoutSize = 0;
            AudioChannelLayout *trackLayout = NULL;
            int indexIntoTrackArray;    
            
            indexIntoMenu = [(NSNumber*)value intValue];
            newLabel = (AudioChannelLabel)[[mChannelLabelOptionsMenu itemAtIndex:indexIntoMenu] tag];    
            
            indexIntoTrackArray = [uiTrackTableView selectedRow] - 1;    // offset by one since the track table first row contains movie info
            if (indexIntoTrackArray &gt;= 0 &amp;&amp; indexIntoTrackArray &lt; (int)[mAudioTracks count])
            {
                selectedTrack = [mAudioTracks objectAtIndex:indexIntoTrackArray];
                if (noErr == getTrackLayoutAndSize([selectedTrack quickTimeTrack], &amp;trackLayoutSize, &amp;trackLayout)) 
                {
                    trackLayout-&gt;mChannelDescriptions[row].mChannelLabel = newLabel;
                    if (noErr == setTrackLayout([selectedTrack quickTimeTrack],  trackLayoutSize, trackLayout))
                    {
                        [[NSNotificationCenter defaultCenter] postNotificationName:QTAudioContextInsertMovieTracksChangedNotification object:[mMovieDocument movie]];    
                    }
                }
                if (trackLayout) 
                {
                    free(trackLayout);
                }    
            }
        }
    }
}

#pragma mark
#pragma mark ---- NSTableColumn Delegate Method ----

    // Delegate method for custom NSTableColumn 
- (id)dataCellForRow:(int)row forTable:(NSTableView*)tableView
{
    id dataCell = nil;
    
    if ( [tableView isEqual:uiTrackTableView] ) 
    {
        // Track Table: Col 1 is a custom column. Its data cells are check-boxes.
        // However, the first row in the table shouldn't have a check-box cell.
        if (row == 0) 
        {
            dataCell = [[NSCell alloc] initTextCell:@&quot;&quot;];
        } 
        else 
        {
            dataCell = [[NSButtonCell alloc] init];
            [dataCell setButtonType:NSSwitchButton];
            [dataCell setTitle:@&quot;&quot;];
        }        
        [dataCell setControlSize:NSMiniControlSize];
        [dataCell setAlignment:NSCenterTextAlignment];

    } 
    else if ([tableView isEqual:uiTrackChannelLayoutTableView]) 
    {
        // Track Channel Layout Table: Col 2 is a custom column. 
        // Its cells are pop-up buttons, containing a menu of channel
        // label options
        dataCell = [[NSPopUpButtonCell alloc] initTextCell:@&quot;&quot; pullsDown:NO];
        [dataCell setControlSize:NSMiniControlSize];
        [dataCell setFont:[NSFont menuFontOfSize:10]];
        [dataCell setMenu:mChannelLabelOptionsMenu];

    }
    return dataCell;
}


#pragma mark
#pragma mark ---- Notifications ----

- (void) windowWillClose:(NSNotification*)notification
{
    NSWindowController *controller = [[notification object] windowController];
    if ([controller isKindOfClass:[MovieWindowController class]]) 
    {
        // A movie window is being closed
        if ([controller window] == [[mMovieDocument movieWindowController] window])
        {
            // If that window belongs to the movie we're inspecting,
            // then close our own window
            [[self window] close];
        }
    }
}

-(void)tableViewSelectionChanged:(NSNotification*)notification
{
    NSTableView *changedTableView = [notification object];
    if ( [changedTableView isEqual:uiTrackTableView]) 
    {
        // A new row was selected in the Track Table
        // We must update the settings view 
        [self synchronizeSettingsView];
    }
}

        
@end

static void movieGainChangeCallback(Movie m, QTPropertyClass propClass, QTPropertyID propID, id observer)
{
    if ([observer isKindOfClass:[AudioPropertiesInspectorController class]]) 
    {
        AudioPropertiesInspectorController *trackInspector = (AudioPropertiesInspectorController*)observer;
        if ([[trackInspector movie] quickTimeMovie] == m &amp;&amp;
                propClass == kQTPropertyClass_Audio &amp;&amp;
                propID == kQTAudioPropertyID_Gain) 
        {
            [trackInspector synchronizeMovieGainSlider];
        }
    }
}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/QTAudioContextInsert/listing10.html%3Fid%3DDTS10003981-1.3&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/QTAudioContextInsert/listing10.html%3Fid%3DDTS10003981-1.3&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/QTAudioContextInsert/listing10.html%3Fid%3DDTS10003981-1.3&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>