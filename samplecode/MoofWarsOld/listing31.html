<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>MoofWarsOld - /MoofWars/TTileCollection.cp</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGames-date.html">Games</a> &gt; <A HREF="javascript:location.replace('index.html');">MoofWarsOld</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Games/index.html" target="_blank">Reference Library > Games</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">MoofWarsOld</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/MoofWars/TTileCollection.cp</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/MoofEncoder/AppConditionals.h</option>
<option value="listing2.html">/MoofEncoder/Color Search Procs.cp</option>
<option value="listing3.html">/MoofEncoder/Color Search Procs.h</option>
<option value="listing4.html">/MoofEncoder/GridEncode.cp</option>
<option value="listing5.html">/MoofEncoder/GridEncode.h</option>
<option value="listing6.html">/MoofEncoder/GridTilesFormat.h</option>
<option value="listing7.html">/MoofEncoder/ICL8Encode.cp</option>
<option value="listing8.html">/MoofEncoder/ICL8Encode.h</option>
<option value="listing9.html">/MoofEncoder/main.cp</option>
<option value="listing10.html">/MoofEncoder/main.h</option>
<option value="listing11.html">/MoofEncoder/PICTEncode.cp</option>
<option value="listing12.html">/MoofEncoder/PICTEncode.h</option>
<option value="listing13.html">/MoofEncoder/PICTMask.cp</option>
<option value="listing14.html">/MoofEncoder/PICTMask.h</option>
<option value="listing15.html">/MoofWars/AppConditionals.h</option>
<option value="listing16.html">/MoofWars/GridTilesFormat.h</option>
<option value="listing17.html">/MoofWars/MoofWars.cp</option>
<option value="listing18.html">/MoofWars/MoofWars.h</option>
<option value="listing19.html">/MoofWars/TCommandTimer.cp</option>
<option value="listing20.html">/MoofWars/TCommandTimer.h</option>
<option value="listing21.html">/MoofWars/TEnemySprite.cp</option>
<option value="listing22.html">/MoofWars/TEnemySprite.h</option>
<option value="listing23.html">/MoofWars/TShipSprite.cp</option>
<option value="listing24.html">/MoofWars/TShipSprite.h</option>
<option value="listing25.html">/MoofWars/TShotSprite.cp</option>
<option value="listing26.html">/MoofWars/TShotSprite.h</option>
<option value="listing27.html">/MoofWars/TSprite.cp</option>
<option value="listing28.html">/MoofWars/TSprite.h</option>
<option value="listing29.html">/MoofWars/TSpriteCollection.cp</option>
<option value="listing30.html">/MoofWars/TSpriteCollection.h</option>
<option value="listing31.html">/MoofWars/TTileCollection.cp</option>
<option value="listing32.html">/MoofWars/TTileCollection.h</option>
<option value="listing33.html">/MoofWars/TTileGrid.cp</option>
<option value="listing34.html">/MoofWars/TTileGrid.h</option>
<option value="listing35.html">/Tim's Libraries/Common Stuff.h</option>
<option value="listing36.html">/Tim's Libraries/Error Macros.h</option>
<option value="listing37.html">/Tim's Libraries/Scaling.cp</option>
<option value="listing38.html">/Tim's Libraries/Scaling.h</option>
<option value="listing39.html">/Tim's Libraries/TGraphic.cp</option>
<option value="listing40.html">/Tim's Libraries/TGraphic.h</option>
<option value="listing41.html">/Tim's Libraries/TGraphicCollection.cp</option>
<option value="listing42.html">/Tim's Libraries/TGraphicCollection.h</option></select>
				</p>
				</form>
				<p><strong><a href="MoofWarsOld.zip">Download Sample</a></strong> (&#147;MoofWarsOld.zip&#148;, 222.9K)<BR>
<strong><a href="MoofWarsOld.dmg">Download Sample</a></strong> (&#147;MoofWarsOld.dmg&#148;, 287.5K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    TTileCollection.cp  Contains:  A TileCollection is a set of tiles that can be used to draw a grid.          Essentially, this class performs the same function that the TGraphicCollection        class does, but it is designed just to draw 32x32x8 tiles.  By making this        code as specific as possible, this code is more than twice as fast as using        TGraphics to draw the tiles.  Written by: Timothy Carroll    Copyright:  Copyright &copy; 1996-1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        7/2/1999  Karl Groethe  Updated for Metrowerks Codewarror Pro 2.1                1/23/97     Timothy Carroll  Added include for Moofwars.h so that MrC will              compile                      8/15/96    Timothy Carroll  Initial Release        */#include &lt;Memory.h&gt;#include &lt;Resources.h&gt;#include &quot;Moofwars.h&quot;#include &quot;TTileCollection.h&quot;#include &quot;Scaling.h&quot;#include &quot;GridTilesFormat.h&quot;const int kTileSize = 1024;const int kTileGroupSize = (kTileSize+1)*8;/*************************************************************************************Internal DeclarationsWe will hold the list of created TTileCollection objects in a handle.  This handle is automatically created the first time we load a TTileCollection and is deallocated whenthe list is empty.All of the allocation and deallocation is handled by the static NewCollection call.NewCollection has a few utility routines it calls on to manage the handle.  Mainly they dothe searching, insertion and deletion from the list.*************************************************************************************/static Handle gTileCollectionList = NULL;static unsigned long gNumberItemsInList = 0;static OSErr InsertCollectionIntoList (TTileCollection *theCollection, UInt32 index);static OSErr DeleteCollectionFromList (UInt32 index);static OSErr SearchCollectionList (SInt16 resID, Boolean *found, UInt32 *index);/*************************************************************************************  InsertCollectionIntoList    This routine creates the handle if necessary, and otherwise inserts the TTileCollection  into the list at the index location given.    Assumptions:    theCollection must be a legitimate TTileCollection -- no NULL parameters.    index must be no more than 1 larger than gNumberItemsInList. ?????*************************************************************************************/OSErr InsertCollectionIntoList (TTileCollection *theCollection, UInt32 index){  OSErr theErr = noErr;#if qDebugging  if (index &gt; gNumberItemsInList)    SIGNAL_ERROR (&quot;\pAttempting to insert collection at invalid index&quot;)  if (theCollection == NULL)    SIGNAL_ERROR (&quot;\pAttempting to insert a null collection into the list&quot;)    #endif    if (gTileCollectionList == NULL)  {    gNumberItemsInList = 1;        gTileCollectionList = NewHandleClear (sizeof (TTileCollection *));    theErr = MemError();        FAIL_OSERR (theErr, &quot;\pCouldn't allocate a new handle of information&quot;)    FAIL_NIL (gTileCollectionList, &quot;\pCouldn't allocate a new handle of information&quot;)      }  else  {    gNumberItemsInList++;    SetHandleSize(gTileCollectionList,gNumberItemsInList*sizeof(TTileCollection *));        theErr = MemError();    FAIL_OSERR (theErr, &quot;\pCouldn't resize the list handle&quot;)    FAIL_NIL (gTileCollectionList, &quot;\pCouldn't resize the list handle&quot;)        // Shift the data to make room    BlockMoveData(  (*(TTileCollection ***)gTileCollectionList)+index,            (*(TTileCollection ***)gTileCollectionList)+index+1,            (gNumberItemsInList - index-1) * sizeof(TTileCollection *));  }    // finally, set the new object in place      *((*(TTileCollection ***) gTileCollectionList)+index) = theCollection;  return noErr;    error:      if (theErr == noErr)    theErr = paramErr;  return theErr;}/*************************************************************************************  DeleteCollectionFromList    This routine removes the collection from the list and destroys it.  If there are no more items  in the list then we dispose of the handle.    Assumptions:  index must be within the list.*************************************************************************************/OSErr DeleteCollectionFromList (UInt32 index){  OSErr theErr;    gNumberItemsInList--;    //  slide remaining elements up    BlockMoveData(  (*(TTileCollection ***)gTileCollectionList)+index+1,          (*(TTileCollection ***)gTileCollectionList)+index,          (gNumberItemsInList - index) * sizeof(TTileCollection *));  //  cut back the storage and dispose of the handle if we have no items left      if (gNumberItemsInList&gt; 0)  {    SetHandleSize((Handle) gTileCollectionList,gNumberItemsInList*sizeof(TTileCollection *));    theErr = MemError();    FAIL_OSERR (theErr, &quot;\pCouldn't resize the list handle&quot;)    FAIL_NIL (gTileCollectionList, &quot;\pCouldn't resize the list handle&quot;)  }    else  {    DisposeHandle (gTileCollectionList);    gTileCollectionList = NULL;  }      return noErr;  error:      if (theErr == noErr)    theErr = paramErr;  return theErr;}/*************************************************************************************  SearchCollectionList    This routine searches through the list and attempts to find an existing TTileCollection with  that resID.  If it finds one with that resID, then it returns the index to that collection and  sets found to true.  If it doesn't find that resource, then it sets found to false AND sets the  index to where it should be inserted into the list.*************************************************************************************/OSErr SearchCollectionList (SInt16 resID, Boolean *found, UInt32 *index){    UInt32 low = 0;  UInt32 high = gNumberItemsInList;  UInt32 tempIndex;  TTileCollection *theItem;    OSErr theErr = noErr;    *found = false;    while (low &lt; high)    {    tempIndex = (low+high) &gt;&gt; 1;        theItem = (*(TTileCollection ***)gTileCollectionList)[tempIndex];        FAIL_NIL (theItem, &quot;\pBad TTile object&quot;)        if (resID &lt; theItem-&gt;GetResID())      high = tempIndex;          //  element is below &quot;high&quot;    else if (resID == theItem-&gt;GetResID())      {      *found = true;      *index = tempIndex;      return noErr;      }    else      low = tempIndex+1;          //  element is above &quot;low&quot;    }    // use final calculations to put insert in the right place in the list  *index = (low+high) &gt;&gt; 1;  return noErr;    error:    if (theErr == noErr)    theErr = paramErr;  return theErr;}/*************************************************************************************  TTileCollection::NewCollection    This routine merely uses the routines we created above to properly create and load  the TTileCollections.*************************************************************************************/TTileCollection*TTileCollection::NewCollection (SInt16 resID){  unsigned long    listIndex;  Boolean       tableAlreadyExists;  TTileCollection  *newCollection = NULL;  OSErr        theErr;    theErr = SearchCollectionList (resID, &amp;tableAlreadyExists, &amp;listIndex);  FAIL_OSERR(theErr,&quot;\pCouldn't search the collection list in TTileCollection::NewCollection&quot;)    if (tableAlreadyExists)  {    // find the existing collection and add 1 to the ref count.    newCollection = (*(TTileCollection ***)gTileCollectionList)[listIndex];    newCollection-&gt;AddReference();  }  else  {    // create a new collection    newCollection = new TTileCollection(resID);    theErr = newCollection-&gt;CreateCollection ();    FAIL_OSERR(theErr,&quot;\pCouldn't create new TTileCollection&quot;)    theErr = InsertCollectionIntoList(newCollection, listIndex);    FAIL_OSERR(theErr, &quot;\pCouldn't add new TTileCollection to list&quot;)    newCollection-&gt;AddReference();  }    return newCollection;  error:    if (newCollection != NULL)      delete newCollection;    return NULL;}/*************************************************************************************  TTileCollection::AddReference*************************************************************************************/voidTTileCollection::AddReference (void)   {     fReferenceCount++;   }      /*************************************************************************************  TTileCollection::DisposeReference*************************************************************************************/void TTileCollection::DisposeReference (void){     fReferenceCount--;     if (fReferenceCount == 0)     {       UInt32        listIndex;    Boolean       tableEntry;    OSErr        theErr;    theErr = SearchCollectionList (fResID, &amp;tableEntry, &amp;listIndex);            FAIL_OSERR (theErr, &quot;\pFailed to search the CollectionList&quot;)    FAIL_FALSE (tableEntry, &quot;\pFailed to find an existing TTileCollection in list&quot;)            theErr = DeleteCollectionFromList(listIndex);    FAIL_OSERR (theErr, &quot;\pFailed to delete Collection from the list&quot;)               delete this;     }         error:     return;}   /*************************************************************************************  TTileCollection::TTileCollection    All of the actual work is done in CreateCollection*************************************************************************************/TTileCollection::TTileCollection (SInt16 resID){  fResID = resID;  fReferenceCount = 0;  fNumberOfTiles = 0;  fTiles = NULL;}/*************************************************************************************  TTileCollection::~TTileCollection    All of the actual work is done in DeleteCollection*************************************************************************************/TTileCollection::~TTileCollection (void){  if (fTiles != NULL)    {    OSErr theErr = DestroyCollection();    FAIL_OSERR (theErr, &quot;\pFailed to destroy the TTileCollection data&quot;)    }      error:  return;}/*************************************************************************************  TTileCollection::CreateCollection    This routine uses the resource number we passed into the contructor to load the TTileCollection  from the 'SptA' resource we created for it.  Note that we don't make any assumptions about  the resource file being used, so the correct resource file already needs to be opened for this  call to work.*************************************************************************************/OSErr TTileCollection::CreateCollection(void){  OSErr   theErr = noErr;  TileCollectionResHeader **tiles;  int    loop;  Ptr    srcPtr, destPtr;    // Load the 'TILE' resource and check to make sure we can read the header information.    tiles = (TileCollectionResHeader **) Get1Resource (TileCollectionResType, fResID);  theErr = ResError();    FAIL_OSERR (theErr, &quot;\pFailed to load the TILE resource.&quot;)  FAIL_NIL (tiles, &quot;\pFailed to load the TILE resource.&quot;)  if ( (**tiles).version != 0) SIGNAL_ERROR (&quot;\pInvalid version number in TILE resource&quot;)  if ( (**tiles).depth != 8) SIGNAL_ERROR (&quot;\pInvalid Pixel Depth in TILE resource&quot;)  fNumberOfTiles = (**tiles).numTiles;    fTiles = NewHandle (fNumberOfTiles * kTileGroupSize);  theErr = MemError();    FAIL_OSERR (theErr, &quot;\pFailed to allocate memory for the tiles&quot;)  FAIL_NIL (fTiles, &quot;\pFailed to allocate memory for the tiles&quot;)    srcPtr = (Ptr)(*tiles) + sizeof (TileCollectionResHeader);  destPtr = (*fTiles);    fTileOffset = (fNumberOfTiles * kTileSize) +1;  for (loop = 0; loop &lt; 8; loop++)  {    BlockMoveData (srcPtr, destPtr, kTileSize*fNumberOfTiles);    destPtr += fTileOffset;  }    // Completed successfully, cleanup and exit with no error;  goto cleanup;    error:  if (theErr == noErr)    theErr = paramErr;    if (fTiles != NULL)    DisposeHandle (fTiles);  fTiles = NULL;    cleanup:    if (tiles != NULL)    ReleaseResource ((Handle) tiles);      return theErr;}/*************************************************************************************  TTileCollection::DestroyCollection    Throw away all of the objects that we're created.  We do check for null TTile objects here,  and properly skip null objects that might not have been finished from the create calls.*************************************************************************************/OSErrTTileCollection::DestroyCollection (void){  if (fTiles != NULL)    DisposeHandle (fTiles);  fTiles = NULL;    return noErr;}/*************************************************************************************  TTileCollection::LockCollection*************************************************************************************/OSErrTTileCollection::LockCollection (void){  OSErr theErr = noErr;    MoveHHi (fTiles);  theErr = MemError();  FAIL_OSERR (theErr, &quot;\pCouldn't move fTiles handle high&quot;)  HLock (fTiles);  theErr = MemError();  FAIL_OSERR (theErr, &quot;\pCouldn't lock fTiles handle&quot;)      error:  return theErr;}/*************************************************************************************  TTileCollection::UnlockCollection*************************************************************************************/OSErrTTileCollection::UnlockCollection (void){  OSErr theErr = noErr;    HUnlock (fTiles);  theErr = MemError();  FAIL_OSERR (theErr, &quot;\pCouldn't unlock fTiles handle&quot;)    error:  return theErr;}           /*************************************************************************************  TTileCollection::CopyImageUnclipped    This is a set of optimized image copying routines that take advantage of alignment for some serious  speed improvements.  These routines take the destination pointer and assume that the image being  copied is completely on the screen.  If your routine can't determine which of these routines to  call, call CopyImageClip instead.    Now for a more detailed discussion of these routines and why we actually go about this.  The main  advantage to these routines is that their specialization allows them to be much faster than the  generic copying loop in the TGraphic class.    The fastest way to move memory on PPC is usually to load and store float doubles, which are 64 bits  wide.  The problem is that if you decide to move doubles, you need to guarantee alignment to an  8 byte boundary, or your code will run slow on a 603 and 604 processor.  For the generic sprite  blitter, it was faster to just move longs and let the hardware deal with address misalignment.  But  for tiles, we can make copies of the same data at different alignments and use the correct data  when drawing to the screen.  In fact, we could do this for sprites too.  The main advantage is that  because we know the width of the tile, we can write a blitter loop that has no logic in it other  than loads and stores.  At one point, I did attempt to write a variable length blitter that did the  same thing, but for small sprites, the overhead of checking for the correct sprite was always more  than just drawing with longs.    In any case, each of these blitters performs every load and every store on an exact boundary, with  no misalignments.  This results in much faster code in general, and also lets us load data into  the floats and stores.    Future possibilities:    * The cache touch instructions might be useful to make sure that the source data is loaded well ahead    of each time through the loop.  This can help performance, and is also possible to do for the    destination if the destination is cacheable.  I haven't experimented with this yet, but probably    will in the future.      * Currently the largest number of loads for a single line is 7 (CopyImageUnclipped1).  Because the    next line starts immediately after the previous line in memory, we can probably replace 3 of the    loads (load char, load char, load short) with a single load long, and use shifts to get the correct    data.  This won't do much to reduce the number of stores, but might improve performance slightly.  *************************************************************************************//***************************************TTileCollection::CopyImageUnclipped0****************************************/voidTTileCollection::CopyImageUnclipped0 (UInt32 index, unsigned char *destPtr){  register double double1, double2, double3, double4;  unsigned char  *srcPtr;    // the current position in the sprite data  int        loop;  int        rowBytesLocal;  // used to hold the rowbytes value to eliminate a load.#if qDebugging  if (gDestPixMap == NULL)    SIGNAL_ERROR (&quot;\pAttempting to draw to a NULL destination pixmap&quot;)          if  (index &gt;= fNumberOfTiles)    // We're outside of the bounds of the Tiles table here.  Debugger time! :-)      SIGNAL_ERROR(&quot;\ptried to index a TTile that was out of bounds&quot;);#endif  srcPtr =  (unsigned char *)  ((*fTiles)  + kTileSize*index);  rowBytesLocal = gRowBytes;  for (loop = 0; loop &lt; 32; loop++)  {    // load all the data into the registers    double1 = *((double *) srcPtr);    double2 = *((double *) srcPtr+1);    double3 = *((double *) srcPtr+2);    double4 = *((double *) srcPtr+3);    // dump all the data out to the destination.    *((double *) destPtr)   = double1;    *((double *) destPtr+1) = double2;    *((double *) destPtr+2) = double3;    *((double *) destPtr+3) = double4;    srcPtr += 32;    destPtr += rowBytesLocal;  }    error:  return;}/***************************************TTileCollection::CopyImageUnclipped1****************************************/voidTTileCollection::CopyImageUnclipped1 (UInt32 index, unsigned char *destPtr){  register double double1, double2, double3;  register unsigned char  char1,char2;  register unsigned short short1;  register unsigned long  long1;  unsigned char  *srcPtr;    // the current position in the sprite data  int        loop;  int        rowBytesLocal;  // used to hold the rowbytes value to eliminate a load.#if qDebugging  if (gDestPixMap == NULL)    SIGNAL_ERROR (&quot;\pAttempting to draw to a NULL destination pixmap&quot;)          if  (index &gt;= fNumberOfTiles)    // We're outside of the bounds of the Tiles table here.  Debugger time! :-)      SIGNAL_ERROR(&quot;\ptried to index a TTile that was out of bounds&quot;);#endif  srcPtr =  (unsigned char *)  ((*fTiles)  + kTileSize*index + fTileOffset);  rowBytesLocal = gRowBytes;  for (loop = 0; loop &lt; 32; loop++)  {    // load all the data into the registers.  We're one byte misaligned, so we need to load 7 bytes before    // we hit the next 8-byte boundary.        char1   = *((unsigned char *)                     srcPtr);    short1  = *((unsigned short *) ((unsigned char *) srcPtr+1));    long1   = *((unsigned long *)  ((unsigned char *) srcPtr+3));    double1 = *((double *)         ((unsigned char *) srcPtr+7));    double2 = *((double *)         ((unsigned char *) srcPtr+15));    double3 = *((double *)         ((unsigned char *) srcPtr+23));    char2   = *((unsigned char *)  ((unsigned char *) srcPtr+31));        srcPtr += 32;        // dump all the data out to the destination.        *((unsigned char *)  ((unsigned char *) destPtr))    = char1;    *((unsigned short *) ((unsigned char *) destPtr+1))  = short1;    *((unsigned long *)  ((unsigned char *) destPtr+3))  = long1;    *((double *)      ((unsigned char *) destPtr+7))  = double1;    *((double *)         ((unsigned char *) destPtr+15)) = double2;    *((double *)         ((unsigned char *) destPtr+23)) = double3;    *((unsigned char *)  ((unsigned char *) destPtr+31)) = char2;        destPtr += rowBytesLocal;  }  error:  return;}/***************************************TTileCollection::CopyImageUnclipped2****************************************/voidTTileCollection::CopyImageUnclipped2 (UInt32 index, unsigned char *destPtr){  register double double1, double2, double3;  register unsigned short short1, short2;  register unsigned long  long1;  unsigned char  *srcPtr;    // the current position in the sprite data  int        loop;  int        rowBytesLocal;  // used to hold the rowbytes value to eliminate a load.#if qDebugging  if (gDestPixMap == NULL)    SIGNAL_ERROR (&quot;\pAttempting to draw to a NULL destination pixmap&quot;)          if  (index &gt;= fNumberOfTiles)    // We're outside of the bounds of the Tiles table here.  Debugger time! :-)    SIGNAL_ERROR(&quot;\ptried to index a TTile that was out of bounds&quot;);#endif  srcPtr =  (unsigned char *)  ((*fTiles)  + kTileSize*index + fTileOffset*2);  rowBytesLocal = gRowBytes;  for (loop = 0; loop &lt; 32; loop++)  {  // load all the data into the registers    short1  = *((unsigned short *)                    srcPtr);    long1   = *((unsigned long *)  ((unsigned char *) srcPtr+2));    double1 = *((double *)         ((unsigned char *) srcPtr+6));    double2 = *((double *)         ((unsigned char *) srcPtr+14));    double3 = *((double *)         ((unsigned char *) srcPtr+22));    short2  = *((unsigned short *) ((unsigned char *) srcPtr+30));        // dump all the data out to the destination.    *((unsigned short *)  ((unsigned char *) destPtr))    = short1;    *((unsigned long *)   ((unsigned char *) destPtr+2))  = long1;    *((double *)          ((unsigned char *) destPtr+6))  = double1;    *((double *)          ((unsigned char *) destPtr+14)) = double2;    *((double *)          ((unsigned char *) destPtr+22)) = double3;    *((unsigned short *)  ((unsigned char *) destPtr+30)) = short2;        srcPtr += 32;    destPtr += rowBytesLocal;  }    error:  return;}/***************************************TTileCollection::CopyImageUnclipped3****************************************/void TTileCollection::CopyImageUnclipped3 (UInt32 index, unsigned char *destPtr){  register double double1, double2, double3;  register unsigned char  char1,char2;  register unsigned short short1;  register unsigned long  long1;  unsigned char  *srcPtr;    // the current position in the sprite data  int        loop;  int        rowBytesLocal;  // used to hold the rowbytes value to eliminate a load.#if qDebugging  if (gDestPixMap == NULL)    SIGNAL_ERROR (&quot;\pAttempting to draw to a NULL destination pixmap&quot;)          if  (index &gt;= fNumberOfTiles)    // We're outside of the bounds of the Tiles table here.  Debugger time! :-)      SIGNAL_ERROR(&quot;\ptried to index a TTile that was out of bounds&quot;);#endif  srcPtr =  (unsigned char *)  ((*fTiles)  + kTileSize*index + fTileOffset*3);  rowBytesLocal = gRowBytes;  for (loop = 0; loop &lt; 32; loop++)  {    // load all the data into the registers        char1   = *((unsigned char *)                    srcPtr);    long1   = *((unsigned long *)  ((unsigned char *)srcPtr+1));    double1 = *((double *)         ((unsigned char *)srcPtr+5));    double2 = *((double *)         ((unsigned char *)srcPtr+13));    double3 = *((double *)         ((unsigned char *)srcPtr+21));    char2   = *((unsigned char *)  ((unsigned char *)srcPtr+29));    short1  = *((unsigned short *) ((unsigned char *)srcPtr+30));        // dump all the data out to the destination.    *((unsigned char *) ((unsigned char *) destPtr))    = char1;    *((unsigned long *) ((unsigned char *) destPtr+1))  = long1;    *((double *)        ((unsigned char *) destPtr+5))  = double1;    *((double *)        ((unsigned char *) destPtr+13)) = double2;    *((double *)        ((unsigned char *) destPtr+21)) = double3;    *((unsigned char *) ((unsigned char *) destPtr+29)) = char2;    *((unsigned short *)((unsigned char *) destPtr+30)) = short1;        srcPtr += 32;    destPtr += rowBytesLocal;  }    error:  return;}/***************************************TTileCollection::CopyImageUnclipped4****************************************/voidTTileCollection::CopyImageUnclipped4 (UInt32 index, unsigned char *destPtr){  register double double1, double2, double3;  register unsigned long  long1, long2;  unsigned char  *srcPtr;    // the current position in the sprite data  int        loop;  int        rowBytesLocal;  // used to hold the rowbytes value to eliminate a load.#if qDebugging  if (gDestPixMap == NULL)    SIGNAL_ERROR (&quot;\pAttempting to draw to a NULL destination pixmap&quot;)          if  (index &gt;= fNumberOfTiles)    // We're outside of the bounds of the Tiles table here.  Debugger time! :-)      SIGNAL_ERROR(&quot;\ptried to index a TTile that was out of bounds&quot;);#endif  //srcPtr =  (unsigned char *)  ((*fTiles) + alignment * fTileOffset + kTileSize*index);  srcPtr =  (unsigned char *)  ((*fTiles)  + kTileSize*index + 4*fTileOffset);  rowBytesLocal = gRowBytes;  for (loop = 0; loop &lt; 32; loop++)  {    long1   = *((unsigned long *) ((unsigned char *)srcPtr));    double1 = *((double *)        ((unsigned char *)srcPtr+4));    double2 = *((double *)        ((unsigned char *)srcPtr+12));    double3 = *((double *)        ((unsigned char *)srcPtr+20));    long2   = *((unsigned long *) ((unsigned char *)srcPtr+28));        // dump all the data out to the destination.    *((unsigned long *) ((unsigned char *) destPtr))    = long1;    *((double *)        ((unsigned char *) destPtr+4))  = double1;    *((double *)        ((unsigned char *) destPtr+12)) = double2;    *((double *)        ((unsigned char *) destPtr+20)) = double3;    *((unsigned long *) ((unsigned char *) destPtr+28)) = long2;        srcPtr += 32;    destPtr += rowBytesLocal;  }  error:  return;}/***************************************TTileCollection::CopyImageUnclipped5****************************************/voidTTileCollection::CopyImageUnclipped5 (UInt32 index, unsigned char *destPtr){  register double double1, double2, double3;  register unsigned char  char1,char2;  register unsigned short short1;  register unsigned long  long1;  unsigned char  *srcPtr;    // the current position in the sprite data  int        loop;  int        rowBytesLocal;  // used to hold the rowbytes value to eliminate a load.#if qDebugging  if (gDestPixMap == NULL)    SIGNAL_ERROR (&quot;\pAttempting to draw to a NULL destination pixmap&quot;)          if  (index &gt;= fNumberOfTiles)    // We're outside of the bounds of the Tiles table here.  Debugger time! :-)      SIGNAL_ERROR(&quot;\ptried to index a TTile that was out of bounds&quot;);#endif  srcPtr =  (unsigned char *)  ((*fTiles)  + kTileSize*index + 5*fTileOffset);  rowBytesLocal = gRowBytes;  for (loop = 0; loop &lt; 32; loop++)  {        // load all the data into the registers    char1   = *((unsigned char *)  ((unsigned char *) srcPtr+0));    short1  = *((unsigned short *) ((unsigned char *) srcPtr+1));    double1 = *((double *)         ((unsigned char *) srcPtr+3));    double2 = *((double *)         ((unsigned char *) srcPtr+11));    double3 = *((double *)         ((unsigned char *) srcPtr+19));    long1   = *((unsigned long *)  ((unsigned char *) srcPtr+27));    char2   = *((unsigned char *)  ((unsigned char *) srcPtr+31));    *((unsigned char *) ((unsigned char *) destPtr+0))  = char1;    *((unsigned short *)((unsigned char *) destPtr+1))  = short1;    *((double *)        ((unsigned char *) destPtr+3))  = double1;    *((double *)        ((unsigned char *) destPtr+11)) = double2;    *((double *)        ((unsigned char *) destPtr+19)) = double3;    *((unsigned long *) ((unsigned char *) destPtr+27)) = long1;    *((unsigned char *) ((unsigned char *) destPtr+31)) = char2;      srcPtr += 32;    destPtr += rowBytesLocal;  }  error:  return;}/***************************************TTileCollection::CopyImageUnclipped6****************************************/voidTTileCollection::CopyImageUnclipped6 (UInt32 index, unsigned char *destPtr){  register double double1, double2, double3;  register unsigned short short1, short2;  register unsigned long  long1;  unsigned char  *srcPtr;    // the current position in the sprite data  int        loop;  int        rowBytesLocal;  // used to hold the rowbytes value to eliminate a load.#if qDebugging  if (gDestPixMap == NULL)    SIGNAL_ERROR (&quot;\pAttempting to draw to a NULL destination pixmap&quot;)          if  (index &gt;= fNumberOfTiles)    // We're outside of the bounds of the Tiles table here.  Debugger time! :-)      SIGNAL_ERROR(&quot;\ptried to index a TTile that was out of bounds&quot;);#endif  //srcPtr =  (unsigned char *)  ((*fTiles) + alignment * fTileOffset + kTileSize*index);  srcPtr =  (unsigned char *)  ((*fTiles)  + kTileSize*index + 6*fTileOffset);  rowBytesLocal = gRowBytes;  for (loop = 0; loop &lt; 32; loop++)  {    short1  = *((unsigned short *) ((unsigned char *) srcPtr+0));    double1 = *((double *)         ((unsigned char *) srcPtr+2));    double2 = *((double *)         ((unsigned char *) srcPtr+10));    double3 = *((double *)         ((unsigned char *) srcPtr+18));    long1   = *((unsigned long *)  ((unsigned char *) srcPtr+26));    short2  = *((unsigned short *) ((unsigned char *) srcPtr+30));        *((unsigned short *)((unsigned char *) destPtr+0))  = short1;    *((double *)        ((unsigned char *) destPtr+2))  = double1;    *((double *)        ((unsigned char *) destPtr+10)) = double2;    *((double *)        ((unsigned char *) destPtr+18)) = double3;    *((unsigned long *) ((unsigned char *) destPtr+26)) = long1;    *((unsigned short *)((unsigned char *) destPtr+30))  = short2;        srcPtr += 32;    destPtr += rowBytesLocal;  }  error:  return;}/***************************************TTileCollection::CopyImageUnclipped7****************************************/voidTTileCollection::CopyImageUnclipped7 (UInt32 index, unsigned char *destPtr){  register double double1, double2, double3;  register unsigned char  char1,char2;  register unsigned short short1;  register unsigned long  long1;  unsigned char  *srcPtr;    // the current position in the sprite data  int        loop;  int        rowBytesLocal;  // used to hold the rowbytes value to eliminate a load.#if qDebugging  if (gDestPixMap == NULL)    SIGNAL_ERROR (&quot;\pAttempting to draw to a NULL destination pixmap&quot;)          if  (index &gt;= fNumberOfTiles)    // We're outside of the bounds of the Tiles table here.  Debugger time! :-)      SIGNAL_ERROR(&quot;\ptried to index a TTile that was out of bounds&quot;);#endif  //srcPtr =  (unsigned char *)  ((*fTiles) + alignment * fTileOffset + kTileSize*index);  srcPtr =  (unsigned char *)  ((*fTiles)  + kTileSize*index+ 7*fTileOffset);  rowBytesLocal = gRowBytes;  for (loop = 0; loop &lt; 32; loop++)  {    char1   = *((unsigned char *)  ((unsigned char *) srcPtr+0));    double1 = *((double *)         ((unsigned char *) srcPtr+1));    double2 = *((double *)         ((unsigned char *) srcPtr+9));    double3 = *((double *)         ((unsigned char *) srcPtr+17));    long1   = *((unsigned long *)  ((unsigned char *) srcPtr+25));    short1  = *((unsigned short *) ((unsigned char *) srcPtr+29));    char2   = *((unsigned char *)  ((unsigned char *) srcPtr+31));          *((unsigned char *) ((unsigned char *) destPtr+0))  = char1;    *((double *)        ((unsigned char *) destPtr+1))  = double1;    *((double *)        ((unsigned char *) destPtr+9))  = double2;    *((double *)        ((unsigned char *) destPtr+17)) = double3;    *((unsigned long *) ((unsigned char *) destPtr+25)) = long1;    *((unsigned short *)((unsigned char *) destPtr+29)) = short1;    *((unsigned char *) ((unsigned char *) destPtr+31)) = char2;    srcPtr += 32;    destPtr += rowBytesLocal;  }  error:  return;}/*************************************************************************************  TTileCollection::CopyImageClipped    CopyImageClipped also draws the image, but always checks to make sure that it is inside the  designated drawing area set in the clipping rectangle for our drawing code.  For the moment, this  version of the code always does the drawing using simple long moves without regard to alignment.    *************************************************************************************/void TTileCollection::CopyImageClipped (UInt32 index, SInt32 top, SInt32 left){#if qDebugging  if (gDestPixMap == NULL)    SIGNAL_ERROR (&quot;\pAttempting to draw to a NULL destination pixmap&quot;)          if (EmptyRect (&amp;gClipRect))    SIGNAL_ERROR (&quot;\pEmpty Clipping Region&quot;)      if  (index &gt;= fNumberOfTiles)    // We're outside of the bounds of the Tiles table here.  Debugger time! :-)      SIGNAL_ERROR(&quot;\ptried to index a TTile that was out of bounds&quot;);#endif  // We'll do all our calculations in variables rather than use a structure.  // hopefully this should speed things up  SInt32 destTop, destBottom, destLeft, destRight;    destTop    = top;  destBottom = top+32;  destLeft   = left;  destRight  = left+32;    // determine if the spite needs to be drawn at all  if  (destTop &gt;= gClipRect.bottom || destBottom &lt;= gClipRect.top ||     destLeft &gt;= gClipRect.right || destRight &lt;= gClipRect.left )    // no need to draw, goodbye    return;    // determine if the sprite will be clipped  if   (destTop &lt; gClipRect.top || destBottom &gt; gClipRect.bottom ||     destLeft &lt; gClipRect.left || destRight &gt; gClipRect.right)  {    UInt32 clipTop, clipBottom, clipLeft, clipRight;    unsigned char  *srcPtr;            // the current position in the tile data    unsigned char  *destPtr;              // the current position in the destination pixmap    unsigned long   blitwidth, blitheight;    unsigned long  yLoop;    unsigned long  sourceOffset, destOffset;        // Calculate clipping rectangle.    clipTop    = destTop &lt; gClipRect.top       ? gClipRect.top - destTop  : 0;    clipBottom = destBottom &gt; gClipRect.bottom ? gClipRect.bottom-destTop : destBottom-destTop;    clipLeft   = destLeft &lt; gClipRect.left     ? gClipRect.left-destLeft  : 0;    clipRight  = destRight &gt; gClipRect.right   ? gClipRect.right-destLeft : destRight-destLeft;    // calculate source and destination pointers    srcPtr =  ( unsigned char * )( *fTiles ) + kTileSize*index;    srcPtr += 32*clipTop+clipLeft;        destPtr = gDestBaseAddr + (top + clipTop) * gRowBytes + left + clipLeft;        // how much do we actually need to draw?    blitwidth = clipRight - clipLeft;    blitheight = clipBottom - clipTop;    sourceOffset = 32-blitwidth;    destOffset = gRowBytes-blitwidth;        for (yLoop = 0; yLoop &lt; blitheight; yLoop++)    {      register unsigned long sixteenblits, blitloop;      sixteenblits = blitwidth &gt;&gt; 4;      for ( blitloop = 0; blitloop &lt; sixteenblits; blitloop++)      {        register unsigned long temp1, temp2, temp3, temp4;        temp1 = ((unsigned long *) srcPtr)[0];        temp2 = ((unsigned long *) srcPtr)[1];        temp3 = ((unsigned long *) srcPtr)[2];        temp4 = ((unsigned long *) srcPtr)[3];        ((unsigned long *) destPtr)[0] = temp1;        ((unsigned long *) destPtr)[1] = temp2;        ((unsigned long *) destPtr)[2] = temp3;        ((unsigned long *) destPtr)[3] = temp4;        srcPtr += 16;        destPtr += 16;      }      // move any remaining data, up to 15 bytes total      if (blitwidth &amp; 0x8)      {        register unsigned long temp1, temp2;        temp1 = ((unsigned long *) srcPtr)[0];        temp2 = ((unsigned long *) srcPtr)[1];        ((unsigned long *) destPtr)[0] = temp1;        ((unsigned long *) destPtr)[1] = temp2;        srcPtr += 8;        destPtr += 8;      }      if (blitwidth &amp; 0x4)      {        register unsigned long temp1;        temp1 = *((unsigned long *) srcPtr);        srcPtr +=4;        *((unsigned long *) destPtr)  = temp1;        destPtr +=4;      }      if (blitwidth &amp; 0x2)      {        register unsigned short temp1;        temp1 = *((unsigned short *) srcPtr);        srcPtr +=2;        *((unsigned short *) destPtr)  = temp1;        destPtr +=2;      }      if (blitwidth &amp; 0x1)        *destPtr++ = *srcPtr++;    srcPtr += sourceOffset;    destPtr += destOffset;      }  }  else  {    // Unclipped, so calculate the destination pointer and alignment and call the appropriate unclipped case.    unsigned char  *destPtr;              // the current position in the destination pixmap    long      alignment;            destPtr = gDestBaseAddr + top * gRowBytes + left;    alignment = ((long) destPtr) &amp; 0x07;    switch (alignment)    {      case 0: CopyImageUnclipped0 (index, destPtr); break;      case 1: CopyImageUnclipped1 (index, destPtr); break;      case 2: CopyImageUnclipped2 (index, destPtr); break;      case 3: CopyImageUnclipped3 (index, destPtr); break;      case 4: CopyImageUnclipped4 (index, destPtr); break;      case 5: CopyImageUnclipped5 (index, destPtr); break;      case 6: CopyImageUnclipped6 (index, destPtr); break;      case 7: CopyImageUnclipped7 (index, destPtr); break;    }  }error:  return;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/MoofWarsOld/listing31.html%3Fid%3DDTS10000057-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/MoofWarsOld/listing31.html%3Fid%3DDTS10000057-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/MoofWarsOld/listing31.html%3Fid%3DDTS10000057-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>