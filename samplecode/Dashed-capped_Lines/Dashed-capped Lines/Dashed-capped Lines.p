{	File:		Dashed-capped Lines.p	Contains:	Dashed-capped Lines demonstrates how to draw dashed line objects on PostScript				printers.  It also demonstrates how to use PostScript line caps with dashed				lines.				This simple example does not deal with QuickDraw printers, on which it draws				solid black lines.		 				(This is my Dashed Lines sample modified to use setlinecap to make round-ended lines.)	Written by: Dave Hersey		Copyright:	Copyright © 1991-1999 by Apple Computer, Inc., All Rights Reserved.				You may incorporate this Apple sample source code into your program(s) without				restriction. This Apple sample source code has been provided "AS IS" and the				responsibility for its operation is yours. You are not permitted to redistribute				this Apple sample source code as "Apple sample source code" after having made				changes. If you're going to re-distribute the source, we require that you make				it clear in the source that the code was descended from Apple sample source				code, but that you've made changes.	Change History (most recent first):				7/23/1999	Karl Groethe	Updated for Metrowerks Codewarror Pro 2.1				} PROGRAM Dashed_Lines;USES	Fonts, QuickDraw, Printing;CONST	DashedLine			= 180;	(*	Begin PostScript line dashing			*)	DashedStop			= 181;	(*	End PostScript line dashing				*)	SetLineWidth		= 182;	(*	Set high resolution line width. 		*)		PostScriptHandle	= 192;	(*	Transfer a block of PostScript			*)	TYPE	TDashedLineHdl = ^TDashedLinePtr;	TDashedLinePtr = ^TDashedLine;	TDashedLine = PACKED RECORD		offset:		SignedByte;		centered:	SignedByte;		dashed:		ARRAY [0..1] OF SignedByte;	END;{*------ SendPostScript ------------------------------------------------------------*}PROCEDURE SendPostScript(theComment: Str255);VAR    PSCommand	: Str255;    CommandHdl	: Handle;    CRString	: Str255;    theError	: OSErr;BEGIN    CRString := ' ';    CRString[1] := CHR(13);    PSCommand := theComment;    PSCommand := CONCAT(PSCommand, CRString);    theError := PtrToHand(POINTER(ORD(@PSCommand) + 1), CommandHdl, LENGTH(PSCommand));    PicComment(PostScriptHandle, LENGTH(PSCommand), CommandHdl);    DisposeHandle(CommandHdl);END;  {*------ DrawStuff -----------------------------------------------------------------*}{** **  	DrawStuff draws QuickDraw objects with dashed lines in Postscript. **} PROCEDURE DrawStuff (theWorld : Rect; theGPort : GrafPtr);TYPE	widhdl = ^widptr;	widptr = ^widpt;	widpt = Point; VAR   oldPort  	: 	GrafPtr;   arect    	:	Rect;   Width    	:	Widhdl;   dashedln 	:	TDashedLineHdl;   myPic		:	PicHandle;BEGIN    GetPort (oldPort);	SetPort (theGPort);	Dashedln := TDashedLineHdl(NewHandle(sizeof(tdashedline)));	Dashedln^^.offset := 0;       {No offset}	Dashedln^^.centered := 0;     {don’t center}	Dashedln^^.dashed[0] := 1;    {this is the length }	Dashedln^^.dashed[1] := 4;    {this means 4 points on, 4 points off }		Width := widhdl(NewHandle(sizeof(widpt)));	Width^^.h := 1;          	  {denominator is 4}	Width^^.v := 2;               {numerator is 1}		myPic := OpenPicture(theWorld);    PenSize(1,1);                {Set the pen size to 1 wide x 1 high }    ClipRect(theWorld);	SendPostScript('1 setlinecap');	PicComment(DashedLine,GetHandleSize(Handle(dashedln)),Handle(dashedln)); 	PicComment(SetLineWidth,4,Handle(width));   {SetLineWidth to 8 pixels wide.}	SetRect(arect,100,100,500,500);	{Draw some stuff in dash mode.}    FrameRect(aRect);    MoveTo(500,500);    Lineto(100,100);    MoveTo(100,500);    Lineto(500,100);    InsetRect(arect,10,10);    FrameOval(aRect);    InsetRect(arect,10,10);    FrameOval(aRect);    InsetRect(arect,10,10);    FrameOval(aRect);    InsetRect(arect,10,10);    FrameOval(aRect);    InsetRect(arect,10,10);    FrameOval(aRect);    InsetRect(arect,10,10);    FrameOval(aRect);    InsetRect(arect,10,10);    FrameOval(aRect);    InsetRect(arect,10,10);    FrameOval(aRect);    InsetRect(arect,10,10);    FrameOval(aRect);	PicComment(DashedStop,0,nil);    {DashedStop}  ClosePicture;  DisposeHandle(handle(width));           {Clean up}  DisposeHandle(handle(dashedln));  DrawPicture(MyPic, theWorld);          {print it}  KillPicture(MyPic);    SetPort(oldPort); END;  {**  DrawStuff  **}{*------ PrintStuff ----------------------------------------------------------------*}{** **		PrintStuff will call all of the nescessary Print Manager calls to print  **		a document. It checks PrError() after each Print Manager call. If an error  **     is found, all of the Print Manager open calls (i.e. PrOpen, PrOpenDoc...)  **		will have a corresponding close call before the error is posted to the user.  **		You want to use this approach to make sure the Print Manager closes properly  **		and all temporary memory is released. **}PROCEDURE PrintStuff;VAR  oldPort  			: GrafPtr;  thePrRecHdl		: THPrint;  thePrPort			: TPPrPort;  theStatus			: TPrStatus;	BEGIN   GetPort(oldPort);	   thePrRecHdl := THPrint(NewHandle(SIZEOF(TPrint)));	   IF (MemError = noErr) AND (thePrRecHdl <> NIL) THEN	BEGIN	   PrOpen;	   IF (PrError = noErr) THEN		BEGIN		   PrintDefault(thePrRecHdl);           IF (PrError = noErr) THEN		    BEGIN			   IF (PrStlDialog(thePrRecHdl)) THEN			    BEGIN				   IF (PrJobDialog(thePrRecHdl)) THEN 					BEGIN     			   	  thePrPort := PrOpenDoc(thePrRecHdl, NIL, NIL);        		   								  IF (PrError = noErr) THEN						BEGIN           		          PrOpenPage(thePrPort, NIL);													      IF (PrError = noErr) THEN							BEGIN        					  {**        					 	 rPage (IM II-150) is the printable area for the          					 	 currently selected printer. By passing the current          					 	 port to the draw routine, enables your app        					 	 to use the same routine to draw to the screen        					 	 and the printer's GrafPort.        					   **}									        			           DrawStuff (thePrRecHdl^^.prInfo.rPage,         			         			  GrafPtr (thePrPort));								 							 END;							PrClosePage(thePrPort);						  END;							 						  PrCloseDoc(thePrPort);							 						  IF (thePrRecHdl^^.prJob.bJDocLoop = bSpoolLoop) and (PrError = noErr) THEN           					PrPicFile(thePrRecHdl, NIL, NIL, NIL, @theStatus);					  END;				  END;			  END;		  END;				PrClose;	 END;END;  {**  PrintStuff  **}{*------ main ----------------------------------------------------------------------*}BEGIN	    InitGraf(@qd.thePort);	InitFonts;	FlushEvents(everyEvent, 0);		InitWindows;	InitMenus;	TEInit;	InitDialogs(NIL);	InitCursor;	PrintStuff;END. {**  main  **}