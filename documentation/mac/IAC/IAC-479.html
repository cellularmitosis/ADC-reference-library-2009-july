<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Using the Low-Level Interface(IM:IC)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING479></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="IAC-478.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="IAC-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="IAC-529.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="IAC-480.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="IAC-2.html"><B>Interapplication Communication</B></A> / <BR><DD><A HREF="IAC-469.html"><B>Chapter 12 - Data Access Manager</B></A> / <A HREF="IAC-474.html"><B>Using the Data Access Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING479-0></A>
<H2><A NAME=MARKER-9-141></A><A NAME=MARKER-2-142></A><A NAME=MARKER-2-143></A><A NAME=MARKER-2-144></A><A NAME=MARKER-21-145></A>Using the Low-Level Interface</H2>
 <A NAME=MARKER-2-146></A>You can use the low-level interface to establish communication (initiate a session) with a data server, send a query to the data server, execute the query, and retrieve any data requested by the query. You call one or more low-level routines to accomplish each of these tasks. <P>
 Applications that implement this type of data access must provide user control and feedback, as described in <A HREF=IAC-476.html#MARKER-9-98>"General Guidelines for the User Interface" on page 12-13</A>. When the data source is ready to return data, you can retrieve it all and then display it to the user, or you can display the data as it arrives. If the data arrives slowly, it's best to display it one record at a time as it arrives. This way the user can preview the data, decide if it's the desired information, and cancel the query if not. <P>
 <A HREF=#MARKER-9-149>Figure 12-5</A> is a flowchart of a typical session using the low-level interface. As <A HREF=#MARKER-9-149>Figure 12-5</A> illustrates, you must follow this procedure to use the low-level interface:<P>
<OL>
<LI>Call the <CODE>InitDBPack</CODE> function to initialize the Data Access Manager.
<LI><A NAME=MARKER-2-147></A>Call the <CODE>DBInit</CODE> function to establish communication with the data server. The <CODE>DBInit</CODE> function returns an identification number, called a <I>session ID.</I> This session ID is unique; no other current session, for any database extension, has the same session ID. <A NAME=MARKER-2-148></A><P>
</OL>
<B>Figure 12-5  <A NAME=MARKER-9-149></A><A NAME=MARKER-21-150></A>A flowchart of a session using the low-level interface<A NAME=MARKER-2-151></A></B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/DA-L-08.jpg"><P>
You must specify the session ID any time you want to send data to or retrieve data from this session.<P>
The <CODE>DBInit</CODE> function requires as input parameters the name of the database extension and character strings for the host system, user name, password, and connection string. All of these parameters depend on the user and the user's computer system, including the specific database extension, host computer, data server, and database management software in use. You will not know the user name and password when you are writing an application, and you might not know the values of any of these parameters. Therefore, you must display a dialog box that prompts the user for the necessary information. <P>
Depending on the database extension you are using, the <CODE>DBInit</CODE> function might return a session ID of zero if it fails to initiate a session, or it might return a nonzero session ID and a result code other than <CODE>noErr</CODE>. In the latter case, you can pass the session ID to the <CODE>DBGetErr</CODE> function to determine the cause of the error. If the <CODE>DBInit</CODE> function returns a nonzero session ID and a result code other than <CODE>noErr</CODE>, you must call the <CODE>DBEnd</CODE> function before making another attempt to open the session.<P>
<OL>
<LI><A NAME=MARKER-2-118></A><A NAME=MARKER-2-151></A>Prepare a query, and send it to the data server by calling the <CODE>DBSend</CODE> and <CODE>DBSendItem</CODE> functions one or more times. <P>
An application that uses the low-level interface must be capable of creating a query for the data server in the language and format required by that data server.<P>
The <CODE>DBSend</CODE> function sends a query or a portion of a query to the data server. The data server appends this portion of the query to any portion you sent previously. Because the Data Access Manager and data server do not modify the string you send in any way, they do not insert any delimiter between fragments of queries that you send to the data server. If you want a blank or a semicolon to be included between query fragments, or if you want to use return characters to divide the query into lines of text, you must include them in the character string that you send with the <CODE>DBSend</CODE> function. The data string that you send with the <CODE>DBSend</CODE> function can be any length up to 64 KB. <P>
The <CODE>DBSendItem</CODE> function sends a single data item to the data server. Use the <CODE>DBSendItem</CODE> function to send data items to the data source in the same format as they are retrieved from the data source by the <CODE>DBGetItem</CODE> function. You must specify the data type as an input parameter and, for any data type that does not have an implied length, you must specify the length as well. The database extension or the data server (depending on how the system is implemented) converts the data item to a character string and appends it to the query, just as a query program fragment is appended to the query by the <CODE>DBSend</CODE> function. <P>
You can call the <CODE>DBSend</CODE> and <CODE>DBSendItem</CODE> functions as many times as you wish to send your query to the data server.<P>
<A HREF=#MARKER-9-154>Listing 12-4</A> sends the Data Access Language query fragment "<CODE>print 451+222</CODE>;" to the Data Access Language server.<P>
</OL>
<B>Listing 12-4  <A NAME=MARKER-9-154></A>Sending a query fragment</B><P>
<PRE>
FUNCTION MySendFragment(sessID: LongInt): OSErr;
VAR
   value1:                       LongInt;
   value2:                       LongInt;
   text1, text2, text3:          Str15;
   text1Ptr, text2Ptr, text3Ptr: Ptr;
   rc:      OSErr;
BEGIN
   text1 := 'print ';
   value1 := 451;
   text2 := '+';
   value2 := 222;
   text3 := ';';
   MySetTextPtrs(text1, text1Ptr, text2, text2Ptr, 
                  text3, text3Ptr);
   rc := DBSend (sessID, text1Ptr, LENGTH(text1), NIL);
   IF rc = noErr THEN
      rc := DBSendItem (sessID, typeInteger, 0, 0, 0, 
                        Ptr(ORD(@value1)), NIL);
   IF rc = noErr THEN
      rc := DBSend (sessID, text2Ptr, LENGTH(text2), NIL);
   IF rc = noErr THEN
      rc := DBSendItem (sessID, typeInteger, 0, 0, 0, 
                        Ptr(ORD(@value2)), NIL);
   IF rc = noErr THEN
      rc := DBSend (sessID, text3Ptr, LENGTH(text3), NIL);
   MySendFragment := rc;
END;
</PRE>
<OL>
<LI><A NAME=MARKER-2-155></A>Use the <CODE>DBExec</CODE> function to initiate execution of the query. <P>
Depending on the way the system you are using is implemented, the <CODE>DBExec</CODE> function might return control to your application as soon as the query has begun execution. 
<LI>Use the <CODE>DBState</CODE> function to determine the status of the data source. <P>
The <CODE>DBState</CODE> function tells you when the data server has finished executing the query you just sent. If you have requested data, the data server stores the data you requested but does not send it to your application until you request it explicitly. The <CODE>DBState</CODE> function tells you when the data is available; if data is available, go to step 6. If you wish to send another query, return to step 3. If you are finished using the data source, skip to step 7.
<LI>Call the <CODE>DBGetItem</CODE> function repeatedly to retrieve the data. <P>
The <CODE>DBGetItem</CODE> function retrieves the next data item from the data server. You can also use this function to obtain information about the next data item without retrieving the data. When you use the <CODE>DBGetItem</CODE> function to retrieve a data item, you must specify the location and size of the buffer into which the function is to place that item. If you know beforehand what kind of data to expect, you can allocate a buffer of the exact size you need. If you do not know what type of data to expect, you can first call the <CODE>DBGetItem</CODE> function with a <CODE>NIL</CODE> pointer to the data buffer. The <CODE>DBGetItem</CODE> function then returns information about the next data item without actually retrieving it. You can then allocate the appropriate buffer and call <CODE>DBGetItem</CODE> again. <P>
Alternatively, to avoid calling <CODE>DBGetItem</CODE> twice for each data item, you can allocate a buffer that you expect to be of sufficient size for any data item and call the <CODE>DBGetItem</CODE> function. If the buffer is not large enough for the data item, the <CODE>DBGetItem</CODE> function returns the <CODE>rcDBError</CODE> result code, but still returns information about the data item. You can then allocate the necessary buffer, call the <CODE>DBUnGetItem</CODE> function to go back one data item, and call the <CODE>DBGetItem</CODE> function again to retrieve the data item a second time.<P>
The <CODE>DBGetItem</CODE> function includes a <CODE>timeout</CODE> parameter that you can use to specify the maximum amount of time that the database extension should wait to receive results from the data server before canceling the command. If the database extension you are using does not support asynchronous execution of routines, you can use the <CODE>timeout</CODE> parameter to return control to your application while a query is executing. To use the <CODE>timeout</CODE> parameter in this way, call the <CODE>DBGetItem</CODE> function periodically, specifying a brief period of time for the <CODE>timeout</CODE> parameter. Your application can then retrieve the next data item as soon as execution of the query is complete without having to call the <CODE>DBState</CODE> function to determine when data is available. The <CODE>DBGetItem</CODE> function ignores the <CODE>timeout</CODE> parameter if you make an asynchronous call to this function.
<LI>When you are finished using the data source, you must use the <CODE>DBEnd</CODE> function to terminate the session. You must call the <CODE>DBEnd</CODE> function after the <CODE>DBInit</CODE> function has returned a nonzero session ID, even if it also returned an error.<A NAME=MARKER-2-156></A><P>
</OL>
 The procedure in <A HREF=#MARKER-9-157>Listing 12-5</A> uses the low-level interface to send a Data Access Language routine to the Data Access Language server on a remote computer and then retrieves the results. The procedure initiates a session with a remote database and calls the <CODE>MySendFragment</CODE> routine (<A HREF=#MARKER-9-154>Listing 12-4</A>) to send a query. Next, it executes the query, checks the status of the remote database server, and retrieves the data when it's available. This example retrieves only one data item. To retrieve more than one data item, put the data-retrieval code in a loop.<P>
 <A HREF=#MARKER-9-157>Listing 12-5</A> assumes that the database extension does not support asynchronous execution of Data Access Manager routines. For an example of asynchronous execution of routines, see <A HREF=IAC-477.html#MARKER-9-125>Listing 12-1</A> beginning on <A HREF=IAC-477.html#MARKER-9-125>page 12-18</A>.<P>
<B>Listing 12-5  <A NAME=MARKER-9-157></A><A NAME=MARKER-21-158></A>Using the low-level interface</B><P>
<PRE>
PROCEDURE MyLoLevel(VAR thisSession: LongInt; VAR sessErr: OSErr);
VAR
   theDDevName:                        Str63;
   theHost, theUser:                   Str255;
   thePasswd, theConnStr:              Str255;
   packErr, initErr, sendErr, execErr: OSErr;
   stateErr, getErr, endErr:           OSErr;
   myTimeout:                          LongInt;
   myType:                             DBType;
   len, places, flags:                 Integer;
   myBuffer:                           Ptr;
   myDataInfo:                         Boolean;
   myDataReturned:                     Boolean;
BEGIN
   sessErr := noErr;       {assume everything went fine}
   packErr := InitDBPack;  {init the Data Access Mgr}
   {Set up values for theDDevName, theHost, theUser, thePasswd, }
   { and theConnStr. You can display a dialog box prompting }
   { the user to supply some of these parameters.}
   theDDevName := 'DAL';
   theHost := 'The Host System Name';
   theUser := 'Joe User';
   thePasswd := 'secret';
   theConnStr := 'extra stuff as needed';
   initErr := DBInit(thisSession, theDDevName, theHost, theUser,
                     thePasswd, theConnStr, NIL);
   IF initErr &lt;&gt; noErr THEN
   BEGIN
      sessErr := initErr;
      IF thisSession &lt;&gt; 0 THEN endErr := DBEnd(thisSession, NIL);
      EXIT(MyLoLevel);
   END;
   {send a query or query fragment to the remote data server}
   sendErr := MySendFragment(thisSession);
   {If there's an error, then probably something went wrong with }
   { DBSend or DBSendItem.  Don't forget to end the session.}
   IF sendErr &lt;&gt; noErr THEN
   BEGIN
      sessErr := sendErr;
      endErr := DBEnd(thisSession, NIL);
      EXIT(MyLoLevel);
   END;
   {The query has been sent.  This example assumes that }
   { the query will return data.} 
   execErr := DBExec(thisSession, NIL);
   IF execErr = noErr THEN
   BEGIN
      stateErr := rcDBExec;
      WHILE (stateErr = rcDBExec) DO
      BEGIN             {while waiting for stateErr &lt;&gt; rcDBExec, }
         MyGoDoSomething; { let other apps run}
         stateErr := DBState(thisSession, NIL);
      END;
      {DBState returned a result code other than rcDBExec. }
      { If it's rcDBValue, there are results to retrieve. }
      { Otherwise, it's probably an error.}
      IF stateErr = rcDBValue THEN
      BEGIN
         {call DBGetItem once to get info on the data item and }
         { call DBGetItem a second time to get the data item}
         myTimeout := 2*60;   {2*60 ticks = 2 seconds}
         myType := DBType(typeAnyType);
         myDataInfo := FALSE;
         WHILE NOT myDataInfo DO
         BEGIN
            getErr := DBGetItem(thisSession, myTimeout, myType,
                                 len, places, flags, NIL, NIL);
            {If you timed out, then give up control.  When }
            { control returns, continue getting the info.}
            IF getErr = rcDBBreak THEN MyGoDoSomething
            ELSE IF (getErr = noErr) OR (getErr = rcDBValue) THEN 
               myDataInfo := TRUE
            ELSE
            BEGIN
               sessErr := getErr;
               endErr := DBEnd(thisSession, NIL);
               EXIT(MyLoLevel);
            END;
         END; {while}
         {At this point, you may want to examine the info }
         { about the data item before calling DBGetItem a }
         { second time to actually retrieve it.}
         {MyGimmeSpace returns a pointer to where you want }
         { the data item to go.}
         myBuffer := MyGimmeSpace(len);
         myDataReturned := FALSE;
         WHILE NOT myDataReturned DO
         BEGIN
            getErr := DBGetItem(thisSession, myTimeout, myType,
                                 len, places, flags, myBuffer,
                                 NIL);
            {If you timed out, then give up control.  When }
            { control returns, continue getting the data.}
            IF getErr = rcDBBreak THEN MyGoDoSomething
            ELSE IF (getErr = noErr) OR
                  (getErr = rcDBValue) THEN myDataReturned := TRUE
            ELSE
            BEGIN
               sessErr := getErr;
               endErr := DBEnd(thisSession, NIL);
               EXIT(MyLoLevel);
            END;
         END; {while}
      END
      ELSE sessErr := stateErr;
   END
   ELSE sessErr := execErr;
   endErr := DBEnd(thisSession, NIL);
END;
</PRE>
 Note that, even if you are using the low-level interface to send queries to the data server, you might want to use the high-level functions to retrieve data and convert it to text.<A NAME=MARKER-2-159></A><A NAME=MARKER-2-160></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="IAC-478.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="IAC-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="IAC-529.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="IAC-480.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="IAC-3.html">&copy; Apple Computer, Inc.</A><br>7 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
