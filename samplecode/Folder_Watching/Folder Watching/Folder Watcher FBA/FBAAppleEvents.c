/*	File:		FBAAppleEvents.c	Contains:		Written by: Greg Sutton		Copyright:	Copyright © 1996-1999 by Apple Computer, Inc., All Rights Reserved.				You may incorporate this Apple sample source code into your program(s) without				restriction. This Apple sample source code has been provided "AS IS" and the				responsibility for its operation is yours. You are not permitted to redistribute				this Apple sample source code as "Apple sample source code" after having made				changes. If you're going to re-distribute the source, we require that you make				it clear in the source that the code was descended from Apple sample source				code, but that you've made changes.	Change History (most recent first):				7/21/1999	Karl Groethe	Updated for Metrowerks Codewarror Pro 2.1				*/#include "FBAAppleEvents.h"#include "FBA.h"#include "FBALists.h"#include <Events.h>#include <Errors.h>#include <AERegistry.h>#include <Gestalt.h>#include <Resources.h>// prototypesstatic pascal OSErr HandleOpenApplication( AppleEvent *theAppleEvent, AppleEvent *theReply, long theRefcon );static pascal OSErr HandleQuitApplication( AppleEvent *theAppleEvent, AppleEvent *theReply, long theRefcon );static pascal OSErr HandleOpenDocuments( AppleEvent *theAppleEvent, AppleEvent *theReply, long theRefcon );static pascal OSErr HandlePrintDocuments( AppleEvent *theAppleEvent, AppleEvent *theReply, long theRefcon );static OSErr		HandleOpenDesc( AEDesc* theDesc );static OSErr		GetDescriptorData( const AEDesc* theDesc, Ptr destPtr, Size maxSize );static OSErr		GetTargetAppDesc( OSType theAppCreator, AEDesc* theTarget );// Globalsextern	short		gQuit;OSErr InitAppleEvents ( void ){	short err;	long response;		err = Gestalt( gestaltAppleEventsAttr, &response );    if (noErr != err)    	response = 0L;	if ( ! ( response & (1 << gestaltAppleEventsPresent)) )		return gestaltUndefSelectorErr;		err = AEInstallEventHandler ( kCoreEventClass, kAEOpenApplication,						NewAEEventHandlerProc(HandleOpenApplication), 0L, false );	if (noErr != err) goto done;	err = AEInstallEventHandler ( kCoreEventClass, kAEQuitApplication,						NewAEEventHandlerProc(HandleQuitApplication), 0L, false );	if (noErr != err) goto done;	err = AEInstallEventHandler ( kCoreEventClass, kAEOpenDocuments,						NewAEEventHandlerProc(HandleOpenDocuments), 0L, false );	if (noErr != err) goto done;	err = AEInstallEventHandler ( kCoreEventClass, kAEPrintDocuments,						NewAEEventHandlerProc(HandlePrintDocuments), 0L, false );done:			return err;}OSErr DoAppleEvent( EventRecord *event ){	short err = noErr;		err = AEProcessAppleEvent ( event );	return err;}static pascal OSErr HandleOpenApplication( AppleEvent *theAppleEvent, AppleEvent *theReply, long theRefcon ){#ifdef __MWERKS__	#pragma unused (theAppleEvent, theReply, theRefcon )#endif	// don't do anything here	return noErr;}static pascal OSErr HandleQuitApplication( AppleEvent *theAppleEvent, AppleEvent *theReply, long theRefcon ){#ifdef __MWERKS__	#pragma unused (theAppleEvent, theReply, theRefcon )#endif	gQuit = true;	return noErr;}// If we get a folder dropped onto the application then we'll add it to our// list of folders to watch.static pascal OSErr HandleOpenDocuments( AppleEvent *theAppleEvent, AppleEvent *theReply, long theRefcon ){#ifdef __MWERKS__	#pragma unused( theReply, theRefcon )#endif	AEDesc	directObj = { typeNull, NULL };	OSErr	err;	err = AEGetParamDesc( theAppleEvent, keyDirectObject, typeWildCard, &directObj );	if ( noErr != err ) goto done;	err = HandleOpenDesc( &directObj );done:	AEDisposeDesc( &directObj );	return err;}static OSErr	HandleOpenDesc( AEDesc* theDesc ){	AEDesc		aDesc = { typeNull, NULL };	FSSpec		anFSSpec;	long		aCount;	DescType	anAEKeyword;	OSErr		err;	switch ( theDesc->descriptorType )	{		case typeAEList:			err = AECountItems( theDesc, &aCount );			if ( noErr != err ) goto done;						for ( ; aCount > 0; aCount-- )			{				err = AEGetNthDesc( theDesc, aCount, typeWildCard, &anAEKeyword, &aDesc );				if ( noErr != err ) goto done;								err = HandleOpenDesc( &aDesc );				if ( noErr != err ) goto done;								AEDisposeDesc( &aDesc );			}			break;				default:			err = AECoerceDesc( theDesc, typeFSS, &aDesc );			if ( noErr != err ) goto done;						err = GetDescriptorData( &aDesc, (Ptr)&anFSSpec, sizeof( anFSSpec ) );			if ( noErr != err ) goto done;						if ( ! FolderInList( &anFSSpec ) )				if ( AddFolder( &anFSSpec ) )			// If this is a new folder to watch					AddFolderPathResource( &anFSSpec );	// then add it to our resources.	}done:	AEDisposeDesc( &aDesc );		return err;}static OSErr	GetDescriptorData( const AEDesc* theDesc, Ptr destPtr, Size maxSize ){	Size	copySize;	OSErr	err;		if ( typeNull == theDesc->descriptorType || ! theDesc->dataHandle )		return( errAENotAEDesc );	copySize = GetHandleSize( (Handle)theDesc->dataHandle );	if ( copySize <= maxSize )	{		HLock( (Handle)theDesc->dataHandle );		BlockMoveData( *theDesc->dataHandle, destPtr, copySize );		HUnlock( (Handle)theDesc->dataHandle );	}	else		err = errAECorruptData;		return noErr;} // GetDescriptorDatastatic pascal OSErr HandlePrintDocuments( AppleEvent *theAppleEvent, AppleEvent *theReply, long theRefcon ){#ifdef __MWERKS__	#pragma unused(theAppleEvent, theReply, theRefcon )#endif	// Faceless Background Applications can't print documents	return errAEEventNotHandled;}OSErr	SendChangeEvent( ProcessSerialNumber* thePSN, FSSpec* theSpec, DescType theChangeType ){	AppleEvent 		anAppleEvent = {typeNull,NULL},					aReply = {typeNull,NULL};	AEDesc   		targetDesc = {typeNull,NULL},					specDesc = {typeNull,NULL};	OSErr   		err;		err = AECreateDesc( typeProcessSerialNumber, (Ptr)thePSN,                      				sizeof( ProcessSerialNumber ), &targetDesc );	if ( noErr != err ) goto done;		// Create the AppleEvent	err = AECreateAppleEvent( kFolderWatcherSuite, theChangeType, &targetDesc,								kAutoGenerateReturnID, kAnyTransactionID, &anAppleEvent );	if ( noErr != err ) goto done;		err = AECreateDesc( typeFSS, (Ptr)theSpec, sizeof( FSSpec ), &specDesc );	if ( noErr != err ) goto done;   	err = AEPutParamDesc(&anAppleEvent, keyDirectObject, &specDesc );	if ( noErr != err ) goto done; 	    	err = AESend( &anAppleEvent, &aReply, kAENoReply, kAENormalPriority,												kAEDefaultTimeout, NULL, NULL );done:	AEDisposeDesc( &anAppleEvent );	AEDisposeDesc( &aReply );	AEDisposeDesc( &targetDesc );	AEDisposeDesc( &specDesc );	    	return err;}