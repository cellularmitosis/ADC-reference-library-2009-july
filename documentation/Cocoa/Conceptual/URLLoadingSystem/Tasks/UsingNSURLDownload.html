<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>URL Loading System: Using NSURLDownload</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Using NSURLDownload"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/20001839" title="Using NSURLDownload"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../Networking-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000453" target="_top">Networking</a> &gt; <a href="../index.html" target="_top">URL Loading System</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="UsingNSURLConnection.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../Concepts/CachePolicies.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>
        
        
        <a name="//apple_ref/doc/uid/20001839-BAJEAIEE" title="Using NSURLDownload"></a><hr /><H1>Using NSURLDownload</H1><p>NSURLDownload provides an application the ability to download the contents of a URL directly to disk. It provides an interface similar to NSURLConnection, adding an additional method for specifying the destination of the file. NSURLDownload can also decode commonly used encoding schemes such as MacBinary, BinHex and gzip. Unlike NSURLConnection, data downloaded using NSURLDownload is not stored in the cache system.</p><div class="notebox"><a name="//apple_ref/doc/uid/20001839-DontLinkElementID_10" title="Note"></a><p><strong>Note:</strong>&nbsp;If your application is not restricted to using Foundation classes, the Web Kit framework includes WebDownload, a subclass of NSURLDownload that provides a user interface for authentication.</p></div>
<!-- This template is being used for both PDF and HTML. -->

    
    <!-- TopicBook.pm uses this template for its miniTOCs, but needs a different title. -->
    <h4>Contents:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="UsingNSURLDownload.html#//apple_ref/doc/uid/20001839-165459">Downloading to a Predetermined Destination</a>
				
			<br/>
			
        
			
			
				<a href="UsingNSURLDownload.html#//apple_ref/doc/uid/20001839-163723">Downloading a File Using the Suggested Filename</a>
				
			<br/>
			
        
			
			
				<a href="UsingNSURLDownload.html#//apple_ref/doc/uid/20001839-165094">Displaying the Download Progress</a>
				
			<br/>
			
        
			
			
				<a href="UsingNSURLDownload.html#//apple_ref/doc/uid/20001839-155583">Handling Request Changes</a>
				
			<br/>
			
        
			
			
				<a href="UsingNSURLDownload.html#//apple_ref/doc/uid/20001839-155724">Handling Authentication Challenges</a>
				
			<br/>
			
        
			
			
				<a href="UsingNSURLDownload.html#//apple_ref/doc/uid/20001839-165205">Decoding Encoded Files</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/20001839-165459" title="Downloading to a Predetermined Destination"></a><h2>Downloading to a Predetermined Destination</h2><p>One usage pattern for NSURLDownload is downloading a file to a predetermined filename on the disk. If the application knows the destination of the download, it can explicitly set it using <code>setDestination:allowOverwrite:</code>. Multiple <code>setDestination:allowOverwrite:</code> messages to an NSURLDownload instance are ignored.</p><p>The download starts immediately upon receiving the <code>initWithRequest:delegate:</code> message. It can be canceled any time before the delegate receives a <code>downloadDidFinish:</code> or <code>download:didFailWithError:</code> message by sending the download a <code>cancel</code> message.</p><p>The example in <span class="content_text">Listing 1</span> sets the destination, and thus requires the delegate only implement the <code>download:didFailWithError:</code> and <code>downloadDidFinish:</code> methods.</p><a name="//apple_ref/doc/uid/20001839-163401-CJBFJHHG" title="Listing 1Using NSURLDownload with a predetermined destination file location"></a><p class="codesample"><a name="//apple_ref/doc/uid/20001839-163401" title="Listing 1Using NSURLDownload with a predetermined destination file location"></a><strong>Listing 1&nbsp;&nbsp;</strong>Using NSURLDownload with a predetermined destination file location</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)startDownloadingURL:sender<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // create the request<span></span></pre></td></tr><tr><td scope="row"><pre>    NSURLRequest *theRequest=[NSURLRequest requestWithURL:[NSURL URLWithString:CONFIG_SOURCE_URL_STRING]<span></span></pre></td></tr><tr><td scope="row"><pre>                                              cachePolicy:NSURLRequestUseProtocolCachePolicy<span></span></pre></td></tr><tr><td scope="row"><pre>                                          timeoutInterval:60.0];<span></span></pre></td></tr><tr><td scope="row"><pre>    // create the connection with the request<span></span></pre></td></tr><tr><td scope="row"><pre>    // and start loading the data<span></span></pre></td></tr><tr><td scope="row"><pre>NSURLDownload  *theDownload=[[NSURLDownload alloc] initWithRequest:theRequest<span></span></pre></td></tr><tr><td scope="row"><pre>                                             delegate:self];<span></span></pre></td></tr><tr><td scope="row"><pre>    if (theDownload) {<span></span></pre></td></tr><tr><td scope="row"><pre>        // set the destination file now<span></span></pre></td></tr><tr><td scope="row"><pre>        [theDownload setDestination:CONFIG_SOURCE_PATH allowOverwrite:YES];<span></span></pre></td></tr><tr><td scope="row"><pre>    } else {<span></span></pre></td></tr><tr><td scope="row"><pre>        // inform the user that the download could not be made<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)download:(NSURLDownload *)download didFailWithError:(NSError *)error<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // release the connection<span></span></pre></td></tr><tr><td scope="row"><pre>    [download release];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // inform the user<span></span></pre></td></tr><tr><td scope="row"><pre>    NSLog(@"Download failed! Error - %@ %@",<span></span></pre></td></tr><tr><td scope="row"><pre>          [error localizedDescription],<span></span></pre></td></tr><tr><td scope="row"><pre>          [[error userInfo] objectForKey:NSErrorFailingURLStringKey]);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)downloadDidFinish:(NSURLDownload *)download<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // release the connection<span></span></pre></td></tr><tr><td scope="row"><pre>    [download release];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // do something with the data<span></span></pre></td></tr><tr><td scope="row"><pre>    NSLog(@"%@",@"downloadDidFinish");<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Additional methods can be implemented by the delegate to customize the handling of authentication, server redirects and file decoding.</p><a name="//apple_ref/doc/uid/20001839-163723" title="Downloading a File Using the Suggested Filename"></a><h2>Downloading a File Using the Suggested Filename</h2><p>Another common situation is that the application must derive the destination filename from the downloaded data itself. This requires you to implement the delegate method <code>download:decideDestinationWithSuggestedFilename:</code> and call <code>setDestination:allowOverwrite:</code> with the suggested filename. The example in <span class="content_text">Listing 2</span> saves the downloaded file to a users desktop using the suggested filename.</p><a name="//apple_ref/doc/uid/20001839-163755-CJBJJCBB" title="Listing 2Using NSURLDownload with a filename derived from the download"></a><p class="codesample"><a name="//apple_ref/doc/uid/20001839-163755" title="Listing 2Using NSURLDownload with a filename derived from the download"></a><strong>Listing 2&nbsp;&nbsp;</strong>Using NSURLDownload with a filename derived from the download</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)startDownloadingURL:sender<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // create the request<span></span></pre></td></tr><tr><td scope="row"><pre>    NSURLRequest *theRequest=[NSURLRequest requestWithURL:[NSURL URLWithString:@"http://www.apple.com/index.html"]<span></span></pre></td></tr><tr><td scope="row"><pre>                                              cachePolicy:NSURLRequestUseProtocolCachePolicy<span></span></pre></td></tr><tr><td scope="row"><pre>                                          timeoutInterval:60.0];<span></span></pre></td></tr><tr><td scope="row"><pre>    // create the connection with the request<span></span></pre></td></tr><tr><td scope="row"><pre>    // and start loading the data<span></span></pre></td></tr><tr><td scope="row"><pre>NSURLDownload  *theDownload=[[NSURLDownload alloc] initWithRequest:theRequest delegate:self];<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!theDownload) {<span></span></pre></td></tr><tr><td scope="row"><pre>        // inform the user that the download could not be made<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)download:(NSURLDownload *)download decideDestinationWithSuggestedFilename:(NSString *)filename<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSString *destinationFilename;<span></span></pre></td></tr><tr><td scope="row"><pre>    NSString *homeDirectory=NSHomeDirectory();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    destinationFilename=[[homeDirectory stringByAppendingPathComponent:@"Desktop"]<span></span></pre></td></tr><tr><td scope="row"><pre>        stringByAppendingPathComponent:filename];<span></span></pre></td></tr><tr><td scope="row"><pre>    [download setDestination:destinationFilename allowOverwrite:NO];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)download:(NSURLDownload *)download didFailWithError:(NSError *)error<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // release the connection<span></span></pre></td></tr><tr><td scope="row"><pre>    [download release];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // inform the user<span></span></pre></td></tr><tr><td scope="row"><pre>    NSLog(@"Download failed! Error - %@ %@",<span></span></pre></td></tr><tr><td scope="row"><pre>          [error localizedDescription],<span></span></pre></td></tr><tr><td scope="row"><pre>          [[error userInfo] objectForKey:NSErrorFailingURLStringKey]);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)downloadDidFinish:(NSURLDownload *)download<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // release the connection<span></span></pre></td></tr><tr><td scope="row"><pre>    [download release];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // do something with the data<span></span></pre></td></tr><tr><td scope="row"><pre>    NSLog(@"%@",@"downloadDidFinish");<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The downloaded file is stored on the user's desktop with the name <code>index.html</code>, which was derived from the downloaded content. Passing <code>NO </code>to <code>setDestination:allowOverwrite:</code> prevents an existing file from being overwritten by the download. Instead a unique filename is created by inserting a sequential number after the filename, for example, <code>index-1.html</code>.</p><p>The delegate is informed when a file is created on disk if it implements the <code>download:didCreateDestination:</code> method. This method also gives the application the opportunity to determine the finalized filename with which the download is saved.</p><p>The example in <span class="content_text">Listing 3</span> logs the finalized filename.</p><a name="//apple_ref/doc/uid/20001839-169655-CJBBDBCG" title="Listing 3Logging the finalized filename using download:didCreateDestination:"></a><p class="codesample"><a name="//apple_ref/doc/uid/20001839-169655" title="Listing 3Logging the finalized filename using download:didCreateDestination:"></a><strong>Listing 3&nbsp;&nbsp;</strong>Logging the finalized filename using download:didCreateDestination:</p><div class="codesample"><table><tr><td scope="row"><pre>-(void)download:(NSURLDownload *)download didCreateDestination:(NSString *)path<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // path now contains the destination path<span></span></pre></td></tr><tr><td scope="row"><pre>    // of the download, taking into account any<span></span></pre></td></tr><tr><td scope="row"><pre>    // unique naming caused by -setDestination:allowOverwrite:<span></span></pre></td></tr><tr><td scope="row"><pre>    NSLog(@"Final file destination: %@",path);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>This message is sent to the delegate after it has been given an opportunity to respond to the <code>download:shouldDecodeSourceDataOfMIMEType:</code> and <code>download:decideDestinationWithSuggestedFilename:</code> messages.</p><a name="//apple_ref/doc/uid/20001839-165094" title="Displaying the Download Progress"></a><h2>Displaying the Download Progress</h2><p>The progress of the download can be determined by implementing the delegate methods <code>download:didReceiveResponse:</code> and <code>download:didReceiveDataOfLength:</code>.</p><p>The <code>download:didReceiveResponse:</code> method provides the delegate an opportunity to determine the expected content length from the NSURLResponse. The delegate should reset the progress each time this message is received. </p><p>The example implementation in <span class="content_text">Listing 4</span> demonstrates using these methods to provide progress feedback to the user.</p><a name="//apple_ref/doc/uid/20001839-164292-CJBJGDHA" title="Listing 4Displaying the download progress"></a><p class="codesample"><a name="//apple_ref/doc/uid/20001839-164292" title="Listing 4Displaying the download progress"></a><strong>Listing 4&nbsp;&nbsp;</strong>Displaying the download progress</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)setDownloadResponse:(NSURLResponse *)aDownloadResponse<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [aDownloadResponse retain];<span></span></pre></td></tr><tr><td scope="row"><pre>    [downloadResponse release];<span></span></pre></td></tr><tr><td scope="row"><pre>    downloadResponse = aDownloadResponse;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)download:(NSURLDownload *)download didReceiveResponse:(NSURLResponse *)response<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // reset the progress, this might be called multiple times<span></span></pre></td></tr><tr><td scope="row"><pre>    bytesReceived=0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // retain the response to use later<span></span></pre></td></tr><tr><td scope="row"><pre>    [self setDownloadResponse:response];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)download:(NSURLDownload *)download didReceiveDataOfLength:(unsigned)length<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    long long expectedLength=[[self downloadResponse] expectedContentLength];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    bytesReceived=bytesReceived+length;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (expectedLength != NSURLResponseUnknownLength) {<span></span></pre></td></tr><tr><td scope="row"><pre>        // if the expected content length is<span></span></pre></td></tr><tr><td scope="row"><pre>        // available, display percent complete<span></span></pre></td></tr><tr><td scope="row"><pre>        float percentComplete=(bytesReceived/(float)expectedLength)*100.0;<span></span></pre></td></tr><tr><td scope="row"><pre>        NSLog(@"Percent complete - %f",percentComplete);<span></span></pre></td></tr><tr><td scope="row"><pre>    } else {<span></span></pre></td></tr><tr><td scope="row"><pre>        // if the expected content length is<span></span></pre></td></tr><tr><td scope="row"><pre>        // unknown just log the progress<span></span></pre></td></tr><tr><td scope="row"><pre>        NSLog(@"Bytes received - %d",bytesReceived);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The delegate receives a <code>download:didReceiveResponse:</code> message before it begins receiving <code>download:didReceiveDataOfLength:</code> messages.</p><a name="//apple_ref/doc/uid/20001839-155583" title="Handling Request Changes"></a><h2>Handling Request Changes</h2><p>It’s not uncommon for a server to redirect a request for one URL to another URL. The NSURLDownload delegate receives a <code>download:willSendRequest:redirectResponse:</code> when this occurs. </p><p>If the delegate implements this method, it can examine the new NSURLRequest and the NSURLResponse that caused the redirect and allow the redirected NSURLRequest to be used for the download, create a new NSURLRequest for the download, reject the redirect and return any data received from the NSURLResponse that caused the redirect, or cancel the download entirely.</p><p>To allow the redirect to occur, the delegate implementation should return the NSURLRequest passed to the delegate method. The delegate could also create a new NSURLRequest, pointing to a new URL, and return that request.</p><p>If the delegate wishes to reject the redirect, but receive any existing data for the connection, it should return <code>nil</code>. </p><p>Finally, the delegate can cancel the redirect and the connection by calling <code>[connection cancel]</code>.</p><p>The delegate also receives this message if the NSURLProtocol subclass that handles the request has changed the NSURLRequest in order to standardize its format. For example, changing a request for “<code>http://www.apple.com</code>” to “<code>http://www.apple.com/</code>“. This is required because the standardized, or canonical, version of the request is used for cache management. In this special case the response passed to the delegate is <code>nil</code> and the delegate should simply return the provided NSURLRequest.</p><p>The example in <span class="content_text">Listing 5</span> allows canonical changes and denies all server redirects.</p><a name="//apple_ref/doc/uid/20001839-156071-CJBIHFAG" title="Listing 5Example download:willSendRequest:redirectResponse: implementation."></a><p class="codesample"><a name="//apple_ref/doc/uid/20001839-156071" title="Listing 5Example download:willSendRequest:redirectResponse: implementation."></a><strong>Listing 5&nbsp;&nbsp;</strong>Example download:willSendRequest:redirectResponse: implementation.</p><div class="codesample"><table><tr><td scope="row"><pre>-(NSURLRequest *)download:(NSURLDownload *)download<span></span></pre></td></tr><tr><td scope="row"><pre>            willSendRequest:(NSURLRequest *)request<span></span></pre></td></tr><tr><td scope="row"><pre>           redirectResponse:(NSURLResponse *)redirectResponse<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSURLRequest *newRequest=request;<span></span></pre></td></tr><tr><td scope="row"><pre>    if (redirectResponse) {<span></span></pre></td></tr><tr><td scope="row"><pre>        newRequest=nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return newRequest;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>If the delegate doesn’t implement <code>download:willSendRequest:redirectResponse:</code>, the default behavior is to allow all canonical changes and server redirects.</p><a name="//apple_ref/doc/uid/20001839-155724" title="Handling Authentication Challenges"></a><h2>Handling Authentication Challenges</h2><p>If a request requires authentication and there are no valid credentials available, either as part of the requested URL or in the shared NSURLCredentialStorage, the NSURLDownload delegate receives a <code>download:didReceiveAuthenticationChallenge:</code> message. In order for the download to continue, the delegate must provide credentials, attempt to continue without credentials, or cancel the authentication request.</p><p>The NSURLAuthenticationChallenge (the challenge) passed to the delegate contains information about what triggered the authentication challenge, the number of attempts that have been made for the challenge, any attempted credentials, the NSURLProtocolSpace that requires the credentials, and the sender of the challenge.</p><p>If the authentication challenge has tried to authenticate and failed, the attempted credentials are returned by calling <code>[challenge proposedCredential]</code>. The delegate can then use the previously attempted credential to populate a dialog and prompt the user.</p><p>The number of attempts at authentication for the challenge is returned by calling <code>[challenge previousFailureCount]</code>. The delegate can pass this information along to the end user, to determine if the credentials supplied previously are failing, or to limit the maximum number of authentication attempts.</p><p>To attempt to authenticate, the application should create an NSURLCredential object with the user name, password and the type of persistence to use for the credentials, and then send the <code>[challenge sender]</code> a <code>useCredential:forAuthenticationChallenge:</code> message. </p><p>If the delegate chooses not to provide a credential for the authentication challenge it can attempt to continue without one by sending <code>[challenge sender]</code> a <code>continueWithoutCredentialsForAuthenticationChallenge:</code> message. Depending on the protocol implementation, this may return alternate URL contents that don’t require authentication or cause the connection to fail, receiving a <code>connectionDidFailWithError:</code> message. </p><p>The delegate may choose to cancel the authentication challenge by sending <code>cancelAuthenticationChallenge:</code> to <code>[challenge sender]</code>. The delegate then receives a <code>connection:didCancelAuthenticationChallenge:</code> message, providing the opportunity to give the end user feedback.</p><p>The example in <span class="content_text">Listing 6</span> attempts to authenticate the challenge by creating an NSURLCredential instance using a user name and password supplied by the application’s preferences. If the authentication has failed previously, it cancels the authentication challenge and informs the user. </p><a name="//apple_ref/doc/uid/20001839-156094-CJBBCDEI" title="Listing 6Example download:didReceiveAuthenticationChallenge: implementation."></a><p class="codesample"><a name="//apple_ref/doc/uid/20001839-156094" title="Listing 6Example download:didReceiveAuthenticationChallenge: implementation."></a><strong>Listing 6&nbsp;&nbsp;</strong>Example download:didReceiveAuthenticationChallenge: implementation.</p><div class="codesample"><table><tr><td scope="row"><pre>-(void)download:(NSURLDownload *)download<span></span></pre></td></tr><tr><td scope="row"><pre>        didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if ([challenge previousFailureCount] == 0) {<span></span></pre></td></tr><tr><td scope="row"><pre>        NSURLCredential *newCredential;<span></span></pre></td></tr><tr><td scope="row"><pre>        newCredential=[NSURLCredential credentialWithUser:[self preferencesName]<span></span></pre></td></tr><tr><td scope="row"><pre>                                                 password:[self preferencesPassword]<span></span></pre></td></tr><tr><td scope="row"><pre>                                              persistence:NSURLCredentialPersistenceNone];<span></span></pre></td></tr><tr><td scope="row"><pre>        [[challenge sender] useCredential:newCredential<span></span></pre></td></tr><tr><td scope="row"><pre>               forAuthenticationChallenge:challenge];<span></span></pre></td></tr><tr><td scope="row"><pre>    } else {<span></span></pre></td></tr><tr><td scope="row"><pre>        [[challenge sender] cancelAuthenticationChallenge:challenge];<span></span></pre></td></tr><tr><td scope="row"><pre>        // inform the user that the user name and password<span></span></pre></td></tr><tr><td scope="row"><pre>        // in the preferences are incorrect<span></span></pre></td></tr><tr><td scope="row"><pre>        [self showPreferencesCredentialsAreIncorrectPanel:self];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	<a name="//apple_ref/doc/uid/20001839-165205" title="Decoding Encoded Files"></a><h2>Decoding Encoded Files</h2><p>NSURLDownload provides support for decoding selected file formats: MacBinary, BinHex and gzip. If NSURLDownload determines that a file is encoded in a supported format, it attempts to send the delegate a <code>download:shouldDecodeSourceDataOfMIMEType:</code> message. If the delegate implements this method, it should examine the passed MIME type and return <code>YES </code>if the file should be decoded.</p><p>The example in <span class="content_text">Listing 7</span> compares the MIME type of the file and allows decoding of MacBinary and BinHex encoded content.</p><a name="//apple_ref/doc/uid/20001839-165276-CJBFHAII" title="Listing 7Example implementation of download:shouldDecodeSourceDataOfMIMEType: method."></a><p class="codesample"><a name="//apple_ref/doc/uid/20001839-165276" title="Listing 7Example implementation of download:shouldDecodeSourceDataOfMIMEType: method."></a><strong>Listing 7&nbsp;&nbsp;</strong>Example implementation of download:shouldDecodeSourceDataOfMIMEType: method.</p><div class="codesample"><table><tr><td scope="row"><pre>- (BOOL)download:(NSURLDownload *)download<span></span></pre></td></tr><tr><td scope="row"><pre>     shouldDecodeSourceDataOfMIMEType:(NSString *)encodingType;<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    BOOL shouldDecode=NO;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if ([encodingType isEqual:@"application/macbinary"]) {<span></span></pre></td></tr><tr><td scope="row"><pre>        shouldDecode=YES;<span></span></pre></td></tr><tr><td scope="row"><pre>    } else if ([encodingType isEqual:@"application/binhex"]) {<span></span></pre></td></tr><tr><td scope="row"><pre>        shouldDecode=YES;<span></span></pre></td></tr><tr><td scope="row"><pre>    } else if ([encodingType isEqual:@"application/gzip"]) {<span></span></pre></td></tr><tr><td scope="row"><pre>        shouldDecode=NO;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return shouldDecode;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>

        <br/><br/> 

        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="UsingNSURLConnection.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../Concepts/CachePolicies.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2003, 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-05-06<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/URLLoadingSystem/Tasks/UsingNSURLDownload.html%3Fid%3D10000165i-2.7&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/URLLoadingSystem/Tasks/UsingNSURLDownload.html%3Fid%3D10000165i-2.7&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/URLLoadingSystem/Tasks/UsingNSURLDownload.html%3Fid%3D10000165i-2.7&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>
