<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>PCCardNetworkSample - /MyRegisterPort.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxHardwareDrivers-date.html">Hardware & Drivers</a> &gt; <A HREF="javascript:location.replace('index.html');">PCCardNetworkSample</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/HardwareDrivers/idxPCIandPCCard-date.html" target="_blank">Hardware & Drivers > PCI and PC Card</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">PCCardNetworkSample</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/MyRegisterPort.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/dlpiether.h</option>
<option value="listing2.html">/dlpiuser.h</option>
<option value="listing3.html">/EnablerSample.h</option>
<option value="listing4.html">/EnablerSmpl.c</option>
<option value="listing5.html">/EnablerSmpl.r</option>
<option value="listing6.html">/EnetDrvrSmpl.r</option>
<option value="listing7.html">/EnetDrvrSrc.c</option>
<option value="listing8.html">/MyPortCalls.c</option>
<option value="listing9.html">/MyPortCalls.h</option>
<option value="listing10.html">/MyPortModule.c</option>
<option value="listing11.html">/MyRegisterPort.c</option>
<option value="listing12.html">/MyRegisterPort.h</option>
<option value="listing13.html">/PortScanner.c</option>
<option value="listing14.html">/PortScanner.r</option>
<option value="listing15.html">/ProjectDefines.h</option></select>
				</p>
				</form>
				<p><strong><a href="PCCardNetworkSample.zip">Download Sample</a></strong> (&#147;PCCardNetworkSample.zip&#148;, 49.2K)<BR>
<strong><a href="PCCardNetworkSample.dmg">Download Sample</a></strong> (&#147;PCCardNetworkSample.dmg&#148;, 109.0K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    MyRegisterPort.c  Contains:  Contains the custom routines for registering an offlineing an OT Port        See the PortScanner.c file for an explanation of the call  Written by:     Copyright:  Copyright &copy; 1998-1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        8/16/1999  Karl Groethe  Updated for Metrowerks Codewarror Pro 2.1        */#pragma export on//----------------------------------------------------------------------#define  DEBUG          1//----------------------------------------------------------------------#include  &lt;OpenTptModule.h&gt;#include  &lt;OpenTptLinks.h&gt;#include &lt;PCCardEnablerPlugin.h&gt;#include &lt;PCCardTuples.h&gt;#include &lt;Gestalt.h&gt;#include &lt;DriverFamilyMatching.h&gt;#include &quot;EnablerSample.h&quot;#include &quot;MyRegisterPort.h&quot;static Boolean OfflinePortExists(RegEntryID *deviceRef, DriverDescription *dd, UInt32 socketNum);static OSStatus SetPortConfiguredProperty (RegEntryID *deviceRef);/*  The OfflinePortExists call is used to offline a port  where the assumption is that the deviceRef for the device  in the NameRegistry is stored in the fContext field of the  portRecord.  This routine searches the ports for an entry which  has a matching deviceRef value and unregisters the port.    Assumes that there is an existing port that has as it's fContext  value, the same as *deviceRef, so that the value can be matched.*/static Boolean OfflinePortExists(RegEntryID *deviceRef, DriverDescription *dd, UInt32 socketNum){  DriverServiceInfo  *dsi;  TPortRecord      *portRecord;  UInt32        index;  UInt32        busType;  size_t        idx;  OSStatus      err;  Boolean        foundOne;  #if DEBUG  DebugStr(&quot;\p about to check for offlined ports&quot;);#endif  index = 0;  while (portRecord = OTGetIndexedPort(index))  {    index++;          busType = OTGetBusTypeFromPortRef(portRecord-&gt;fRef);    if (busType == kOTPCCardBus)    {#if DEBUG      DebugStr(&quot;\p PCCard port found&quot;);          #endif            // check if the socket numbers match      if (((UInt8)portRecord-&gt;fSlotID[0] - '0') != socketNum)      {#if DEBUG        DebugStr(&quot;\p socketNum - no match&quot;);          #endif        continue;      }#if DEBUG      DebugStr(&quot;\p socketNum - matches&quot;);          #endif                // check if the port is offlined      if (portRecord-&gt;fPortFlags &amp;&amp; kOTPortIsOffline)      {        // we've found an offline port.          // check if the driver descriptor info matches the info in the port        dsi = dd-&gt;driverServices.service;        foundOne = false;        for (idx = 0; idx &lt; dd-&gt;driverServices.nServices; ++idx)        {          if ( dsi-&gt;serviceCategory == kServiceCategoryOpenTransport )          {            foundOne = true;            break;          }          dsi += 1;        }                if (foundOne == true)        {            // check if the driver name matches          if (OTMemcmp(&amp;(dd-&gt;driverOSRuntimeInfo.driverName[1]), portRecord-&gt;fModuleName,                  dd-&gt;driverOSRuntimeInfo.driverName[0]) == true)          {#if DEBUG            DebugStr(&quot;\p matching offline port found&quot;);          #endif              // restore the fPortFlags            portRecord-&gt;fPortFlags &amp;= ~(kOTPortIsOffline + kOTPortIsUnavailable );                          // set the fContext field to the current deviceRef            *(RegEntryID *)portRecord-&gt;fContext = *deviceRef;            err = SetPortConfiguredProperty(deviceRef);            if (err)            {#if DEBUG              DebugStr(&quot;\p RegistryPropertySet for port-configured property failed&quot;);#endif            }              return true;          }        }      }    }  }#if DEBUG  DebugStr(&quot;\p matching offliner port not found&quot;);#endif    return false;}/*  The OfflineThePort call is used to offline a port  where the assumption is that the deviceRef for the device  in the NameRegistry is stored in the fContext field of the  portRecord.  This routine searches the ports for an entry which  has a matching deviceRef value and unregisters the port.    Assumes that there is an existing port that has as it's fContext  value, the same as *deviceRef, so that the value can be matched.*/extern void OfflineThePort(RegEntryID *deviceRef){  RegEntryID    *portContext;  TPortRecord    *portRecord;  UInt32      index;  UInt32      busType;  #if DEBUG  DebugStr(&quot;\p about to check bus&quot;);#endif  index = 0;  while (portRecord = OTGetIndexedPort(index))  {    index++;    busType = OTGetBusTypeFromPortRef(portRecord-&gt;fRef);    if (busType == kOTPCCardBus)    {        // check if the deviceRef matches      portContext = portRecord-&gt;fContext;      if (*((long*)deviceRef) == *((long*)portContext))      {          // set the offline bit in the fPortFlags field        portRecord-&gt;fPortFlags |= kOTPortIsOffline;        portRecord-&gt;fPortFlags |= kOTPortIsUnavailable;#if DEBUG        DebugStr(&quot;\p port offlined&quot;);#endif        return;      }    }  }#if DEBUG  DebugStr(&quot;\p port not found to offline&quot;);#endif}/*  The RegisterThePort call is used to register a network port for a   PC Card 3.0 device with Open Transport.  The call   is designed for alternate networking cards like TokenRing, and ATM  which are not handled by the default PC Card Port Scanner.    This function checks for the presence of a   &quot;driver-descriptor&quot; and the &quot;SocketNumber&quot; property associated with  the device node. It uses the these properties to fill in the port information.    The call looks at the &quot;driver-descriptor&quot; property to know how to fill out the   TPortRecord structure.  */void RegisterThePort( RegEntryID *deviceRef){  char        buffer[sizeof(DriverDescription) +                  kMaxServices*sizeof(DriverServiceInfo)];  DriverDescription  *dd = (DriverDescription*)buffer;  DriverServiceInfo  *dsi;  OTPortRecord    *portRecord;  RegEntryID      *portContext;  OSStatus      err;  UInt32        size;  UInt32        framing;  UInt32        socket;  size_t        idx;  size_t        sIndex = 0;  UInt16         other;  UInt16        otType;  UInt16         iface;  Boolean        foundOne;    #if  DEBUG    DebugStr(&quot;\p port scanner:  RegisterThePort&quot;);    #endif  //  // If the driver has no driver-descriptor property, or the size  // is too small, or it is too large to fit our buffer - forget   // this one.  //  err = RegistryPropertyGetSize(deviceRef, kDescriptorProperty, &amp;size);  if ( err != noErr || size &lt; sizeof(DriverDescription) ||     size &gt; sizeof(buffer) )  {#if DEBUG    DebugStr(&quot;\p kPropertyDriverDesc not found&quot;);#endif    return;  }    //  // Read the driver-descriptor property into our buffer.  //  err = RegistryPropertyGet(deviceRef, kDescriptorProperty, buffer, &amp;size);    if ( err != noErr )  {#if DEBUG    DebugStr(&quot;\p kPropertyDriverDesc not found&quot;);#endif    return;  }    //  // Read the SocketNumber property into our buffer.  //  size = sizeof(socket);  err = RegistryPropertyGet(deviceRef, kSocketNumber, &amp;socket, &amp;size);    if ( err != noErr )  {#if DEBUG    DebugStr(&quot;\p socket property not found&quot;);#endif    return;  }  //  // Check whether an offline port exists for this module  //    if (OfflinePortExists(deviceRef, dd, socket) == true)  {    return;  }    dsi = dd-&gt;driverServices.service;  foundOne = false;    for (idx = 0; idx &lt; dd-&gt;driverServices.nServices; ++idx)  {    if ( dsi-&gt;serviceCategory == kServiceCategoryOpenTransport )    {      foundOne = true;      break;    }    dsi += 1;  }    if (foundOne == false)    return;        // check if there is a driver name  if (dd-&gt;driverOSRuntimeInfo.driverName[0] == 0 )    return;        // lets register this port - first get some memory  portRecord = (OTPortRecord*)OTAllocPortMem(sizeof(OTPortRecord));  if (portRecord == nil)    return;      OTMemzero(portRecord, sizeof(OTPortRecord));      OTMemcpy(&amp;portRecord-&gt;fModuleName, &amp;dd-&gt;driverOSRuntimeInfo.driverName[1],         dd-&gt;driverOSRuntimeInfo.driverName[0]);    otType = (UInt16)((dsi-&gt;serviceType &gt;&gt; 16) &amp; 0x7ff);  iface = (UInt16)(dsi-&gt;serviceType &amp; 3);  framing = (UInt32)((dsi-&gt;serviceType &gt;&gt; 8) &amp; 0xff);      // find a unique &quot;other&quot; value for this device  other = 0;  do  {    portRecord-&gt;fRef = OTCreatePortRef(kOTPCCardBus, otType, socket, other++);  } while ( OTFindPortByRef(portRecord-&gt;fRef) != 0 );      // now set the associated slot //  portRecord-&gt;fSlotID[0] = 0;  OTMemcpy(&amp;portRecord-&gt;fSlotID, &quot; \0&quot;, 2);  portRecord-&gt;fSlotID[0] = (char)('0'+ socket);      // for the fInfoFlag the 0x1 indicates the module is DLPI    // for a TPI interface, set the value to 0x2  portRecord-&gt;fInfoFlags    = iface;  portRecord-&gt;fCapabilities  = framing;  portRecord-&gt;fNumChildPorts  = 0;  portRecord-&gt;fPortName[0]  = 0;      // allocate port context memory  portContext = (RegEntryID*)OTAllocPortMem(sizeof(RegEntryID));  if (portContext != nil)  {      // store the deviceRef in the portContext field so that      // we can discriminate this port entry later when we for a matching       // port to offline.    *portContext = *deviceRef;    #if DEBUG    DebugStr(&quot;\p about to register port&quot;);#endif    err = OTRegisterPort(portRecord, (void*)portContext);      if (err == noErr)    {      err = SetPortConfiguredProperty(deviceRef);      if (err)      {#if DEBUG        DebugStr(&quot;\p RegistryPropertySet for port-configured property failed&quot;);#endif      }      }    else    {#if DEBUG      DebugStr(&quot;\p OTRegisterPort failed&quot;);#endif    }  }  else  {#if DEBUG      DebugStr(&quot;\p OTAllocPortMem failed&quot;);#endif      OTFreePortMem(portRecord);  }}static OSStatus SetPortConfiguredProperty (RegEntryID *deviceRef){  OSStatus  err;  UInt16    portConfigProperty = 1;  // modify the port-configured property to indicate that we have registered the  // port.  Note that the presence of this property tells the default PC Card  // Port scanner that the port has been previously registered, whatever the  // value.  This scanner checks the value and if zero, registers the port.  // then we set the value to 1 to indicate that we've registered it.  Later  // we might find this port and have a way to know that we've already configured  // this device.  err = RegistryPropertySet(deviceRef, kPortConfigured,               &amp;portConfigProperty, sizeof(portConfigProperty));  return err;}#pragma export off</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/PCCardNetworkSample/listing11.html%3Fid%3DDTS10000258-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/PCCardNetworkSample/listing11.html%3Fid%3DDTS10000258-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/PCCardNetworkSample/listing11.html%3Fid%3DDTS10000258-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>