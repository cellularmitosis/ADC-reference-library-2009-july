<html lang="en">
<head>
<title>Optimize Options - Using the GNU Compiler Collection (GCC)</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Using the GNU Compiler Collection (GCC)">
<meta name="generator" content="makeinfo 4.7">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Invoking-GCC.html#Invoking-GCC" title="Invoking GCC">
<link rel="prev" href="Debugging-Options.html#Debugging-Options" title="Debugging Options">
<link rel="next" href="Preprocessor-Options.html#Preprocessor-Options" title="Preprocessor Options">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``GNU General Public License'' and ``Funding
Free Software'', the Front-Cover texts being (a) (see below), and with
the Back-Cover Texts being (b) (see below).  A copy of the license is
included in the section entitled ``GNU Free Documentation License''.

(a) The FSF's Front-Cover Text is:

     A GNU Manual

(b) The FSF's Back-Cover Text is:

     You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc { font-variant:small-caps }
  span.roman { font-family: serif; font-weight: normal; } 
--></style>
</head>
<body>
<div class="node">
<p>
<a name="Optimize-Options"></a>Next:&nbsp;<a rel="next" accesskey="n" href="Preprocessor-Options.html#Preprocessor-Options">Preprocessor Options</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Debugging-Options.html#Debugging-Options">Debugging Options</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Invoking-GCC.html#Invoking-GCC">Invoking GCC</a>
<hr><br>
</div>

<h3 class="section">3.10 Options That Control Optimization</h3>

<p><a name="index-optimize-options-367"></a><a name="index-options_002c-optimization-368"></a>
These options control various sorts of optimizations.

   <p>Without any optimization option, the compiler's goal is to reduce the
cost of compilation and to make debugging produce the expected
results.  Statements are independent: if you stop the program with a
breakpoint between statements, you can then assign a new value to any
variable or change the program counter to any other statement in the
function and get exactly the results you would expect from the source
code.

   <p>Turning on optimization flags makes the compiler attempt to improve
the performance and/or code size at the expense of compilation time
and possibly the ability to debug the program.

   <p>Not all optimizations are controlled directly by a flag.  Only
optimizations that have a flag are listed.

     <dl>
<dt><code>-O</code><dt><code>-O1</code><dd><a name="index-O-369"></a><a name="index-O1-370"></a>Optimize.  Optimizing compilation takes somewhat more time, and a lot
more memory for a large function.

     <p>With <span class="option">-O</span>, the compiler tries to reduce code size and execution
time, without performing any optimizations that take a great deal of
compilation time.

     <!-- APPLE LOCAL begin optimization -->
<p>In Apple's version of GCC, <span class="option">-fstrict-aliasing</span>,
<span class="option">-freorder-blocks</span>, and <span class="option">-fsched-interblock</span>
are disabled by default when optimizing. 
<!-- APPLE LOCAL end optimization -->

     <br><dt><code>-O2</code><dd><a name="index-O2-371"></a>Optimize even more.  GCC performs nearly all supported optimizations
that do not involve a space-speed tradeoff.  The compiler does not
perform loop unrolling or function inlining when you specify <span class="option">-O2</span>. 
As compared to <span class="option">-O</span>, this option increases both compilation time
and the performance of the generated code.

     <p><span class="option">-O2</span> turns on all optimization flags specified by <span class="option">-O</span>.  It
also turns on the following optimization flags:
     <pre class="smallexample">          -fforce-mem
          -foptimize-sibling-calls
          -fstrength-reduce
          -fcse-follow-jumps  -fcse-skip-blocks
          -frerun-cse-after-loop  -frerun-loop-opt
          -fgcse   -fgcse-lm   -fgcse-sm
          -fdelete-null-pointer-checks
          -fexpensive-optimizations
          -fregmove
          -fschedule-insns  -fschedule-insns2
          -fsched-interblock -fsched-spec
          -fcaller-saves
          -fpeephole2
          -freorder-blocks  -freorder-functions
          -fstrict-aliasing
          -falign-functions  -falign-jumps
          -falign-loops  -falign-labels
     </pre>
     <p>Please note the warning under <span class="option">-fgcse</span> about
invoking <span class="option">-O2</span> on programs that use computed gotos.

     <br><dt><code>-O3</code><dd><a name="index-O3-372"></a>Optimize yet more.  <span class="option">-O3</span> turns on all optimizations specified by
<span class="option">-O2</span> and also turns on the <span class="option">-finline-functions</span> and
<span class="option">-frename-registers</span> options.

     <br><dt><code>-O0</code><dd><a name="index-O0-373"></a>Do not optimize.  This is the default.

     <!-- APPLE LOCAL begin -fast -->
<br><dt><code>-fast</code><dd><a name="index-fast-374"></a>Optimize for maximum performance. <span class="option">-fast</span> changes the overall optimization
strategy of GCC in order to produce the fastest possible running code for PPC7450
and G5 architectures. By default, <span class="option">-fast</span> optimizes for G5. Programs
optimized for G5 will not run on PPC7450. To optimize for PPC7450, add
<span class="option">-mcpu=7450</span> on command line.

     <p><span class="option">-fast</span> currently enables the following optimization flags (for G5 and PPC7450). 
These flags may change in the future. You cannot override any of these options if you use
<span class="option">-fast</span> except by setting <span class="option">-mcpu=7450</span>. Note that <span class="option">-ffast-math</span>,
<span class="option">-fstrict-aliasing</span> and <span class="option">-malign-natural</span> are unsafe in some situations. 
To build shared libraries with <span class="option">-fast</span>, specify <span class="option">-fPIC</span> on command line.

     <pre class="smallexample">          -O3
          -funroll-loops
          -fstrict-aliasing
          -fsched-interblock
          -falign-loops=16
          -falign-jumps=16
          -falign-functions=16
          -falign-jumps-max-skip=15
          -falign-loops-max-skip=15
          -malign-natural
          -ffast-math
          -mdynamic-no-pic
          -mpowerpc-gpopt
          -force_cpusubtype_ALL
          -fstrict-aliasing
          -mtune=G5
          -mcpu=G5
          -mpowerpc64
     </pre>
     <!-- APPLE LOCAL end -fast -->
<br><dt><code>-Os</code><dd><a name="index-Os-375"></a>Optimize for size.  <span class="option">-Os</span> enables all <span class="option">-O2</span> optimizations that
do not typically increase code size.  It also performs further
optimizations designed to reduce code size.

     <p><span class="option">-Os</span> disables the following optimization flags:
     <pre class="smallexample">          -falign-functions  -falign-jumps  -falign-loops
          -falign-labels  -freorder-blocks -fprefetch-loop-arrays
     </pre>
     <p>If you use multiple <span class="option">-O</span> options, with or without level numbers,
the last such option is the one that is effective. 
</dl>

   <p>Options of the form <span class="option">-f</span><var>flag</var> specify machine-independent
flags.  Most flags have both positive and negative forms; the negative
form of <span class="option">-ffoo</span> would be <span class="option">-fno-foo</span>.  In the table
below, only one of the forms is listed&mdash;the one you typically will
use.  You can figure out the other form by either removing <span class="samp">no-</span>
or adding it.

   <p>The following options control specific optimizations.  They are either
activated by <span class="option">-O</span> options or are related to ones that are.  You
can use the following flags in the rare cases when &ldquo;fine-tuning&rdquo; of
optimizations to be performed is desired.

     <dl>
<dt><code>-fno-default-inline</code><dd><a name="index-fno_002ddefault_002dinline-376"></a>Do not make member functions inline by default merely because they are
defined inside the class scope (C++ only).  Otherwise, when you specify
<span class="option">-O</span><!-- /@w -->, member functions defined inside class scope are compiled
inline by default; i.e., you don't need to add <span class="samp">inline</span> in front of
the member function name.

     <br><dt><code>-fno-defer-pop</code><dd><a name="index-fno_002ddefer_002dpop-377"></a>Always pop the arguments to each function call as soon as that function
returns.  For machines which must pop arguments after a function call,
the compiler normally lets arguments accumulate on the stack for several
function calls and pops them all at once.

     <p>Disabled at levels <span class="option">-O</span>, <span class="option">-O2</span>, <span class="option">-O3</span>, <span class="option">-Os</span>.

     <br><dt><code>-fforce-mem</code><dd><a name="index-fforce_002dmem-378"></a>Force memory operands to be copied into registers before doing
arithmetic on them.  This produces better code by making all memory
references potential common subexpressions.  When they are not common
subexpressions, instruction combination should eliminate the separate
register-load.

     <p>Enabled at levels <span class="option">-O2</span>, <span class="option">-O3</span>, <span class="option">-Os</span>.

     <br><dt><code>-fforce-addr</code><dd><a name="index-fforce_002daddr-379"></a>Force memory address constants to be copied into registers before
doing arithmetic on them.  This may produce better code just as
<span class="option">-fforce-mem</span> may.

     <br><dt><code>-fomit-frame-pointer</code><dd><a name="index-fomit_002dframe_002dpointer-380"></a>Don't keep the frame pointer in a register for functions that
don't need one.  This avoids the instructions to save, set up and
restore frame pointers; it also makes an extra register available
in many functions.  <strong>It also makes debugging impossible on
some machines.</strong>

     <p>On some machines, such as the VAX, this flag has no effect, because
the standard calling sequence automatically handles the frame pointer
and nothing is saved by pretending it doesn't exist.  The
machine-description macro <code>FRAME_POINTER_REQUIRED</code> controls
whether a target machine supports this flag.  See <a href="../gccint/Registers.html#Registers">Register Usage (GNU Compiler Collection (GCC) Internals)</a>.

     <p>Enabled at levels <span class="option">-O</span>, <span class="option">-O2</span>, <span class="option">-O3</span>, <span class="option">-Os</span>.

     <br><dt><code>-foptimize-sibling-calls</code><dd><a name="index-foptimize_002dsibling_002dcalls-381"></a>Optimize sibling and tail recursive calls.

     <p>Enabled at levels <span class="option">-O2</span>, <span class="option">-O3</span>, <span class="option">-Os</span>.

     <br><dt><code>-fno-inline</code><dd><a name="index-fno_002dinline-382"></a>Don't pay attention to the <code>inline</code> keyword.  Normally this option
is used to keep the compiler from expanding any functions inline. 
Note that if you are not optimizing, no functions can be expanded inline.

     <br><dt><code>-finline-functions</code><dd><a name="index-finline_002dfunctions-383"></a>Integrate all simple functions into their callers.  The compiler
heuristically decides which functions are simple enough to be worth
integrating in this way.

     <p>If all calls to a given function are integrated, and the function is
declared <code>static</code>, then the function is normally not output as
assembler code in its own right.

     <p>Enabled at level <span class="option">-O3</span>.

     <br><dt><code>-finline-limit=</code><var>n</var><dd><a name="index-finline_002dlimit-384"></a>By default, gcc limits the size of functions that can be inlined.  This flag
allows the control of this limit for functions that are explicitly marked as
inline (i.e., marked with the inline keyword or defined within the class
definition in c++).  <var>n</var> is the size of functions that can be inlined in
number of pseudo instructions (not counting parameter handling).  The default
value of <var>n</var> is 600. 
Increasing this value can result in more inlined code at
the cost of compilation time and memory consumption.  Decreasing usually makes
the compilation faster and less code will be inlined (which presumably
means slower programs).  This option is particularly useful for programs that
use inlining heavily such as those based on recursive templates with C++.

     <p>Inlining is actually controlled by a number of parameters, which may be
specified individually by using <span class="option">--param </span><var>name</var><span class="option">=</span><var>value</var>. 
The <span class="option">-finline-limit=</span><var>n</var> option sets some of these parameters
as follows:

          <dl>
 <dt><code>max-inline-insns</code><dd>  is set to <var>n</var>. 
 <br><dt><code>max-inline-insns-single</code><dd>  is set to <var>n</var>/2. 
 <br><dt><code>max-inline-insns-single-auto</code><dd>  is set to <var>n</var>/2. 
 <br><dt><code>min-inline-insns</code><dd>  is set to 130 or <var>n</var>/4, whichever is smaller. 
 <br><dt><code>max-inline-insns-rtl</code><dd>  is set to <var>n</var>. 
</dl>

     <p>Using <span class="option">-finline-limit=600</span> thus results in the default settings
for these parameters.  See below for a documentation of the individual
parameters controlling inlining.

     <p><em>Note:</em> pseudo instruction represents, in this particular context, an
abstract measurement of function's size.  In no way, it represents a count
of assembly instructions and as such its exact meaning might change from one
release to an another.

     <br><dt><code>-fkeep-inline-functions</code><dd><a name="index-fkeep_002dinline_002dfunctions-385"></a>Even if all calls to a given function are integrated, and the function
is declared <code>static</code>, nevertheless output a separate run-time
callable version of the function.  This switch does not affect
<code>extern inline</code> functions.

     <br><dt><code>-fkeep-static-consts</code><dd><a name="index-fkeep_002dstatic_002dconsts-386"></a>Emit variables declared <code>static const</code> when optimization isn't turned
on, even if the variables aren't referenced.

     <p>GCC enables this option by default.  If you want to force the compiler to
check if the variable was referenced, regardless of whether or not
optimization is turned on, use the <span class="option">-fno-keep-static-consts</span> option.

     <br><dt><code>-fmerge-constants</code><dd>Attempt to merge identical constants (string constants and floating point
constants) across compilation units.

     <p>This option is the default for optimized compilation if the assembler and
linker support it.  Use <span class="option">-fno-merge-constants</span> to inhibit this
behavior.

     <p>Enabled at levels <span class="option">-O</span>, <span class="option">-O2</span>, <span class="option">-O3</span>, <span class="option">-Os</span>.

     <br><dt><code>-fmerge-all-constants</code><dd>Attempt to merge identical constants and identical variables.

     <p>This option implies <span class="option">-fmerge-constants</span>.  In addition to
<span class="option">-fmerge-constants</span> this considers e.g. even constant initialized
arrays or initialized constant variables with integral or floating point
types.  Languages like C or C++ require each non-automatic variable to
have distinct location, so using this option will result in non-conforming
behavior.

     <br><dt><code>-fno-branch-count-reg</code><dd><a name="index-fno_002dbranch_002dcount_002dreg-387"></a>Do not use &ldquo;decrement and branch&rdquo; instructions on a count register,
but instead generate a sequence of instructions that decrement a
register, compare it against zero, then branch based upon the result. 
This option is only meaningful on architectures that support such
instructions, which include x86, PowerPC, IA-64 and S/390.

     <p>The default is <span class="option">-fbranch-count-reg</span>, enabled when
<span class="option">-fstrength-reduce</span> is enabled.

     <br><dt><code>-fno-function-cse</code><dd><a name="index-fno_002dfunction_002dcse-388"></a>Do not put function addresses in registers; make each instruction that
calls a constant function contain the function's address explicitly.

     <p>This option results in less efficient code, but some strange hacks
that alter the assembler output may be confused by the optimizations
performed when this option is not used.

     <p>The default is <span class="option">-ffunction-cse</span>

     <br><dt><code>-fno-zero-initialized-in-bss</code><dd><a name="index-fno_002dzero_002dinitialized_002din_002dbss-389"></a>If the target supports a BSS section, GCC by default puts variables that
are initialized to zero into BSS.  This can save space in the resulting
code.

     <p>This option turns off this behavior because some programs explicitly
rely on variables going to the data section.  E.g., so that the
resulting executable can find the beginning of that section and/or make
assumptions based on that.

     <p>The default is <span class="option">-fzero-initialized-in-bss</span>.

     <br><dt><code>-fstrength-reduce</code><dd><a name="index-fstrength_002dreduce-390"></a>Perform the optimizations of loop strength reduction and
elimination of iteration variables.

     <p>Enabled at levels <span class="option">-O2</span>, <span class="option">-O3</span>, <span class="option">-Os</span>.

     <br><dt><code>-fthread-jumps</code><dd><a name="index-fthread_002djumps-391"></a>Perform optimizations where we check to see if a jump branches to a
location where another comparison subsumed by the first is found.  If
so, the first branch is redirected to either the destination of the
second branch or a point immediately following it, depending on whether
the condition is known to be true or false.

     <p>Enabled at levels <span class="option">-O</span>, <span class="option">-O2</span>, <span class="option">-O3</span>, <span class="option">-Os</span>.

     <br><dt><code>-fcse-follow-jumps</code><dd><a name="index-fcse_002dfollow_002djumps-392"></a>In common subexpression elimination, scan through jump instructions
when the target of the jump is not reached by any other path.  For
example, when CSE encounters an <code>if</code> statement with an
<code>else</code> clause, CSE will follow the jump when the condition
tested is false.

     <p>Enabled at levels <span class="option">-O2</span>, <span class="option">-O3</span>, <span class="option">-Os</span>.

     <br><dt><code>-fcse-skip-blocks</code><dd><a name="index-fcse_002dskip_002dblocks-393"></a>This is similar to <span class="option">-fcse-follow-jumps</span>, but causes CSE to
follow jumps which conditionally skip over blocks.  When CSE
encounters a simple <code>if</code> statement with no else clause,
<span class="option">-fcse-skip-blocks</span> causes CSE to follow the jump around the
body of the <code>if</code>.

     <p>Enabled at levels <span class="option">-O2</span>, <span class="option">-O3</span>, <span class="option">-Os</span>.

     <br><dt><code>-frerun-cse-after-loop</code><dd><a name="index-frerun_002dcse_002dafter_002dloop-394"></a>Re-run common subexpression elimination after loop optimizations has been
performed.

     <p>Enabled at levels <span class="option">-O2</span>, <span class="option">-O3</span>, <span class="option">-Os</span>.

     <br><dt><code>-frerun-loop-opt</code><dd><a name="index-frerun_002dloop_002dopt-395"></a>Run the loop optimizer twice.

     <p>Enabled at levels <span class="option">-O2</span>, <span class="option">-O3</span>, <span class="option">-Os</span>.

     <br><dt><code>-fgcse</code><dd><a name="index-fgcse-396"></a>Perform a global common subexpression elimination pass. 
This pass also performs global constant and copy propagation.

     <p><em>Note:</em> When compiling a program using computed gotos, a GCC
extension, you may get better runtime performance if you disable
the global common subexpression elimination pass by adding
<span class="option">-fno-gcse</span> to the command line.

     <p>Enabled at levels <span class="option">-O2</span>, <span class="option">-O3</span>, <span class="option">-Os</span>.

     <br><dt><code>-fgcse-lm</code><dd><a name="index-fgcse_002dlm-397"></a>When <span class="option">-fgcse-lm</span> is enabled, global common subexpression elimination will
attempt to move loads which are only killed by stores into themselves.  This
allows a loop containing a load/store sequence to be changed to a load outside
the loop, and a copy/store within the loop.

     <p>Enabled by default when gcse is enabled.

     <br><dt><code>-fgcse-sm</code><dd><a name="index-fgcse_002dsm-398"></a>When <span class="option">-fgcse-sm</span> is enabled, A store motion pass is run after global common
subexpression elimination.  This pass will attempt to move stores out of loops. 
When used in conjunction with <span class="option">-fgcse-lm</span>, loops containing a load/store sequence
can be changed to a load before the loop and a store after the loop.

     <p>Enabled by default when gcse is enabled.

     <br><dt><code>-floop-optimize</code><dd><a name="index-floop_002doptimize-399"></a>Perform loop optimizations: move constant expressions out of loops, simplify
exit test conditions and optionally do strength-reduction and loop unrolling as
well.

     <p>Enabled at levels <span class="option">-O</span>, <span class="option">-O2</span>, <span class="option">-O3</span>, <span class="option">-Os</span>.

     <br><dt><code>-fcrossjumping</code><dd><a name="index-crossjumping-400"></a>Perform cross-jumping transformation. This transformation unifies equivalent code and save code size. The
resulting code may or may not perform better than without cross-jumping.

     <p>Enabled at levels <span class="option">-O</span>, <span class="option">-O2</span>, <span class="option">-O3</span>, <span class="option">-Os</span>.

     <br><dt><code>-fif-conversion</code><dd><a name="index-if_002dconversion-401"></a>Attempt to transform conditional jumps into branch-less equivalents.  This
include use of conditional moves, min, max, set flags and abs instructions, and
some tricks doable by standard arithmetics.  The use of conditional execution
on chips where it is available is controlled by <code>if-conversion2</code>.

     <p>Enabled at levels <span class="option">-O</span>, <span class="option">-O2</span>, <span class="option">-O3</span>, <span class="option">-Os</span>.

     <br><dt><code>-fif-conversion2</code><dd><a name="index-if_002dconversion2-402"></a>Use conditional execution (where available) to transform conditional jumps into
branch-less equivalents.

     <p>Enabled at levels <span class="option">-O</span>, <span class="option">-O2</span>, <span class="option">-O3</span>, <span class="option">-Os</span>.

     <br><dt><code>-fdelete-null-pointer-checks</code><dd><a name="index-fdelete_002dnull_002dpointer_002dchecks-403"></a>Use global dataflow analysis to identify and eliminate useless checks
for null pointers.  The compiler assumes that dereferencing a null
pointer would have halted the program.  If a pointer is checked after
it has already been dereferenced, it cannot be null.

     <p>In some environments, this assumption is not true, and programs can
safely dereference null pointers.  Use
<span class="option">-fno-delete-null-pointer-checks</span> to disable this optimization
for programs which depend on that behavior.

     <p>Enabled at levels <span class="option">-O2</span>, <span class="option">-O3</span>, <span class="option">-Os</span>.

     <br><dt><code>-fexpensive-optimizations</code><dd><a name="index-fexpensive_002doptimizations-404"></a>Perform a number of minor optimizations that are relatively expensive.

     <p>Enabled at levels <span class="option">-O2</span>, <span class="option">-O3</span>, <span class="option">-Os</span>.

     <br><dt><code>-foptimize-register-move</code><dt><code>-fregmove</code><dd><a name="index-foptimize_002dregister_002dmove-405"></a><a name="index-fregmove-406"></a>Attempt to reassign register numbers in move instructions and as
operands of other simple instructions in order to maximize the amount of
register tying.  This is especially helpful on machines with two-operand
instructions.

     <p>Note <span class="option">-fregmove</span> and <span class="option">-foptimize-register-move</span> are the same
optimization.

     <p>Enabled at levels <span class="option">-O2</span>, <span class="option">-O3</span>, <span class="option">-Os</span>.

     <br><dt><code>-fdelayed-branch</code><dd><a name="index-fdelayed_002dbranch-407"></a>If supported for the target machine, attempt to reorder instructions
to exploit instruction slots available after delayed branch
instructions.

     <p>Enabled at levels <span class="option">-O</span>, <span class="option">-O2</span>, <span class="option">-O3</span>, <span class="option">-Os</span>.

     <br><dt><code>-fschedule-insns</code><dd><a name="index-fschedule_002dinsns-408"></a>If supported for the target machine, attempt to reorder instructions to
eliminate execution stalls due to required data being unavailable.  This
helps machines that have slow floating point or memory load instructions
by allowing other instructions to be issued until the result of the load
or floating point instruction is required.

     <p>Enabled at levels <span class="option">-O2</span>, <span class="option">-O3</span>, <span class="option">-Os</span>.

     <br><dt><code>-fschedule-insns2</code><dd><a name="index-fschedule_002dinsns2-409"></a>Similar to <span class="option">-fschedule-insns</span>, but requests an additional pass of
instruction scheduling after register allocation has been done.  This is
especially useful on machines with a relatively small number of
registers and where memory load instructions take more than one cycle.

     <p>Enabled at levels <span class="option">-O2</span>, <span class="option">-O3</span>, <span class="option">-Os</span>.

     <br><dt><code>-fno-sched-interblock</code><dd><a name="index-fno_002dsched_002dinterblock-410"></a>Don't schedule instructions across basic blocks.  This is normally
enabled by default when scheduling before register allocation, i.e. 
with <span class="option">-fschedule-insns</span> or at <span class="option">-O2</span> or higher.

     <br><dt><code>-fno-sched-spec</code><dd><a name="index-fno_002dsched_002dspec-411"></a>Don't allow speculative motion of non-load instructions.  This is normally
enabled by default when scheduling before register allocation, i.e. 
with <span class="option">-fschedule-insns</span> or at <span class="option">-O2</span> or higher.

     <br><dt><code>-fsched-spec-load</code><dd><a name="index-fsched_002dspec_002dload-412"></a>Allow speculative motion of some load instructions.  This only makes
sense when scheduling before register allocation, i.e. with
<span class="option">-fschedule-insns</span> or at <span class="option">-O2</span> or higher.

     <br><dt><code>-fsched-spec-load-dangerous</code><dd><a name="index-fsched_002dspec_002dload_002ddangerous-413"></a>Allow speculative motion of more load instructions.  This only makes
sense when scheduling before register allocation, i.e. with
<span class="option">-fschedule-insns</span> or at <span class="option">-O2</span> or higher.

     <br><dt><code>-fcaller-saves</code><dd><a name="index-fcaller_002dsaves-414"></a>Enable values to be allocated in registers that will be clobbered by
function calls, by emitting extra instructions to save and restore the
registers around such calls.  Such allocation is done only when it
seems to result in better code than would otherwise be produced.

     <p>This option is always enabled by default on certain machines, usually
those which have no call-preserved registers to use instead.

     <p>Enabled at levels <span class="option">-O2</span>, <span class="option">-O3</span>, <span class="option">-Os</span>.

     <br><dt><code>-fmove-all-movables</code><dd><a name="index-fmove_002dall_002dmovables-415"></a>Forces all invariant computations in loops to be moved
outside the loop.

     <br><dt><code>-freduce-all-givs</code><dd><a name="index-freduce_002dall_002dgivs-416"></a>Forces all general-induction variables in loops to be
strength-reduced.

     <p><em>Note:</em> When compiling programs written in Fortran,
<span class="option">-fmove-all-movables</span> and <span class="option">-freduce-all-givs</span> are enabled
by default when you use the optimizer.

     <p>These options may generate better or worse code; results are highly
dependent on the structure of loops within the source code.

     <p>These two options are intended to be removed someday, once
they have helped determine the efficacy of various
approaches to improving loop optimizations.

     <p>Please let us (<a href="mailto:gcc@gcc.gnu.org">gcc@gcc.gnu.org</a><!-- /@w --> and <a href="mailto:fortran@gnu.org">fortran@gnu.org</a><!-- /@w -->)
know how use of these options affects
the performance of your production code. 
We're very interested in code that runs <em>slower</em>
when these options are <em>enabled</em>.

     <br><dt><code>-fno-peephole</code><dt><code>-fno-peephole2</code><dd><a name="index-fno_002dpeephole-417"></a><a name="index-fno_002dpeephole2-418"></a>Disable any machine-specific peephole optimizations.  The difference
between <span class="option">-fno-peephole</span> and <span class="option">-fno-peephole2</span> is in how they
are implemented in the compiler; some targets use one, some use the
other, a few use both.

     <p><span class="option">-fpeephole</span> is enabled by default. 
<span class="option">-fpeephole2</span> enabled at levels <span class="option">-O2</span>, <span class="option">-O3</span>, <span class="option">-Os</span>.

     <br><dt><code>-fbranch-probabilities</code><br><dt><code>-fno-guess-branch-probability</code><dd><a name="index-fno_002dguess_002dbranch_002dprobability-419"></a>Do not guess branch probabilities using a randomized model.

     <p>Sometimes gcc will opt to use a randomized model to guess branch
probabilities, when none are available from either profiling feedback
(<span class="option">-fprofile-arcs</span>) or <span class="samp">__builtin_expect</span>.  This means that
different runs of the compiler on the same program may produce different
object code.

     <p>In a hard real-time system, people don't want different runs of the
compiler to produce code that has different behavior; minimizing
non-determinism is of paramount import.  This switch allows users to
reduce non-determinism, possibly at the expense of inferior
optimization.

     <p>The default is <span class="option">-fguess-branch-probability</span> at levels
<span class="option">-O</span>, <span class="option">-O2</span>, <span class="option">-O3</span>, <span class="option">-Os</span>.

     <br><dt><code>-freorder-blocks</code><dd><a name="index-freorder_002dblocks-420"></a>Reorder basic blocks in the compiled function in order to reduce number of
taken branches and improve code locality.

     <p>Enabled at levels <span class="option">-O2</span>, <span class="option">-O3</span>, <span class="option">-Os</span>.

     <br><dt><code>-freorder-functions</code><dd><a name="index-freorder_002dfunctions-421"></a>Reorder basic blocks in the compiled function in order to reduce number of
taken branches and improve code locality. This is implemented by using special
subsections <code>text.hot</code> for most frequently executed functions and
<code>text.unlikely</code> for unlikely executed functions.  Reordering is done by
the linker so object file format must support named sections and linker must
place them in a reasonable way.

     <p>Also profile feedback must be available in to make this option effective.  See
<span class="option">-fprofile-arcs</span> for details.

     <p>Enabled at levels <span class="option">-O2</span>, <span class="option">-O3</span>, <span class="option">-Os</span>.

     <br><dt><code>-fstrict-aliasing</code><dd><a name="index-fstrict_002daliasing-422"></a>Allows the compiler to assume the strictest aliasing rules applicable to
the language being compiled.  For C (and C++), this activates
optimizations based on the type of expressions.  In particular, an
object of one type is assumed never to reside at the same address as an
object of a different type, unless the types are almost the same.  For
example, an <code>unsigned int</code> can alias an <code>int</code>, but not a
<code>void*</code> or a <code>double</code>.  A character type may alias any other
type.

     <p>Pay special attention to code like this:
     <pre class="example">          union a_union {
            int i;
            double d;
          };
          
          int f() {
            a_union t;
            t.d = 3.0;
            return t.i;
          }
     </pre>
     <p>The practice of reading from a different union member than the one most
recently written to (called &ldquo;type-punning&rdquo;) is common.  Even with
<span class="option">-fstrict-aliasing</span>, type-punning is allowed, provided the memory
is accessed through the union type.  So, the code above will work as
expected.  However, this code might not:
     <pre class="example">          int f() {
            a_union t;
            int* ip;
            t.d = 3.0;
            ip = &amp;t.i;
            return *ip;
          }
     </pre>
     <p>Every language that wishes to perform language-specific alias analysis
should define a function that computes, given an <code>tree</code>
node, an alias set for the node.  Nodes in different alias sets are not
allowed to alias.  For an example, see the C front-end function
<code>c_get_alias_set</code>.

     <p>Enabled at levels <span class="option">-O2</span>, <span class="option">-O3</span>, <span class="option">-Os</span>.

     <br><dt><code>-falign-functions</code><dt><code>-falign-functions=</code><var>n</var><dd><a name="index-falign_002dfunctions-423"></a>Align the start of functions to the next power-of-two greater than
<var>n</var>, skipping up to <var>n</var> bytes.  For instance,
<span class="option">-falign-functions=32</span> aligns functions to the next 32-byte
boundary, but <span class="option">-falign-functions=24</span> would align to the next
32-byte boundary only if this can be done by skipping 23 bytes or less.

     <p><span class="option">-fno-align-functions</span> and <span class="option">-falign-functions=1</span> are
equivalent and mean that functions will not be aligned.

     <p>Some assemblers only support this flag when <var>n</var> is a power of two;
in that case, it is rounded up.

     <p>If <var>n</var> is not specified, use a machine-dependent default.

     <p>Enabled at levels <span class="option">-O2</span>, <span class="option">-O3</span>.

     <br><dt><code>-falign-labels</code><dt><code>-falign-labels=</code><var>n</var><dd><a name="index-falign_002dlabels-424"></a>Align all branch targets to a power-of-two boundary, skipping up to
<var>n</var> bytes like <span class="option">-falign-functions</span>.  This option can easily
make code slower, because it must insert dummy operations for when the
branch target is reached in the usual flow of the code.

     <p>If <span class="option">-falign-loops</span> or <span class="option">-falign-jumps</span> are applicable and
are greater than this value, then their values are used instead.

     <p>If <var>n</var> is not specified, use a machine-dependent default which is
very likely to be <span class="samp">1</span>, meaning no alignment.

     <p>Enabled at levels <span class="option">-O2</span>, <span class="option">-O3</span>.

     <br><dt><code>-falign-loops</code><dt><code>-falign-loops=</code><var>n</var><dd><a name="index-falign_002dloops-425"></a>Align loops to a power-of-two boundary, skipping up to <var>n</var> bytes
like <span class="option">-falign-functions</span>.  The hope is that the loop will be
executed many times, which will make up for any execution of the dummy
operations.

     <br><dt><code>-falign-loops-max-skip</code><br><dt><code>-falign-loops-max-skip=</code><var>n</var><dd><a name="index-falign_002dloops_002dmax_002dskip-426"></a>When aligning loops to a power-of-two boundary, only do so if can skip by up
to <var>n</var> bytes.

     <p>If <var>n</var> is not specified, use a machine-dependent default.

     <p>Enabled at levels <span class="option">-O2</span>, <span class="option">-O3</span>.

     <br><dt><code>-falign-jumps</code><dt><code>-falign-jumps=</code><var>n</var><dd><a name="index-falign_002djumps-427"></a>Align branch targets to a power-of-two boundary, for branch targets
where the targets can only be reached by jumping, skipping up to <var>n</var>
bytes like <span class="option">-falign-functions</span>.  In this case, no dummy operations
need be executed.

     <br><dt><code>-falign-jumps-max-skip</code><dt><code>-falign-jumps-max-skip=</code><var>n</var><dd><a name="index-falign_002djump_002dmax_002dskips-428"></a>When aligning branch targets to a power-of-two boundary, only do so if can skip
by up to <var>n</var> bytes.

     <p>If <var>n</var> is not specified, use a machine-dependent default.

     <p>Enabled at levels <span class="option">-O2</span>, <span class="option">-O3</span>.

     <br><dt><code>-frename-registers</code><dd><a name="index-frename_002dregisters-429"></a>Attempt to avoid false dependencies in scheduled code by making use
of registers left over after register allocation.  This optimization
will most benefit processors with lots of registers.  It can, however,
make debugging impossible, since variables will no longer stay in
a &ldquo;home register&rdquo;.

     <p>Enabled at levels <span class="option">-O3</span>.

     <br><dt><code>-fno-cprop-registers</code><dd><a name="index-fno_002dcprop_002dregisters-430"></a>After register allocation and post-register allocation instruction splitting,
we perform a copy-propagation pass to try to reduce scheduling dependencies
and occasionally eliminate the copy.

     <p>Disabled at levels <span class="option">-O</span>, <span class="option">-O2</span>, <span class="option">-O3</span>, <span class="option">-Os</span>.

   </dl>

   <p>The following options control compiler behavior regarding floating
point arithmetic.  These options trade off between speed and
correctness.  All must be specifically enabled.

     <dl>
<dt><code>-ffloat-store</code><dd><a name="index-ffloat_002dstore-431"></a>Do not store floating point variables in registers, and inhibit other
options that might change whether a floating point value is taken from a
register or memory.

     <p><a name="index-floating-point-precision-432"></a>This option prevents undesirable excess precision on machines such as
the 68000 where the floating registers (of the 68881) keep more
precision than a <code>double</code> is supposed to have.  Similarly for the
x86 architecture.  For most programs, the excess precision does only
good, but a few programs rely on the precise definition of IEEE floating
point.  Use <span class="option">-ffloat-store</span> for such programs, after modifying
them to store all pertinent intermediate computations into variables.

     <br><dt><code>-ffast-math</code><dd><a name="index-ffast_002dmath-433"></a>Sets <span class="option">-fno-math-errno</span>, <span class="option">-funsafe-math-optimizations</span>, <br>
<span class="option">-fno-trapping-math</span>, <span class="option">-ffinite-math-only</span> and <br>
<span class="option">-fno-signaling-nans</span>.

     <p>This option causes the preprocessor macro <code>__FAST_MATH__</code> to be defined.

     <p>This option should never be turned on by any <span class="option">-O</span> option since
it can result in incorrect output for programs which depend on
an exact implementation of IEEE or ISO rules/specifications for
math functions.

     <br><dt><code>-fno-math-errno</code><dd><a name="index-fno_002dmath_002derrno-434"></a>Do not set ERRNO after calling math functions that are executed
with a single instruction, e.g., sqrt.  A program that relies on
IEEE exceptions for math error handling may want to use this flag
for speed while maintaining IEEE arithmetic compatibility.

     <p>This option should never be turned on by any <span class="option">-O</span> option since
it can result in incorrect output for programs which depend on
an exact implementation of IEEE or ISO rules/specifications for
math functions.

     <p>The default is <span class="option">-fmath-errno</span>.

     <br><dt><code>-funsafe-math-optimizations</code><dd><a name="index-funsafe_002dmath_002doptimizations-435"></a>Allow optimizations for floating-point arithmetic that (a) assume
that arguments and results are valid and (b) may violate IEEE or
ANSI standards.  When used at link-time, it may include libraries
or startup files that change the default FPU control word or other
similar optimizations.

     <p>This option should never be turned on by any <span class="option">-O</span> option since
it can result in incorrect output for programs which depend on
an exact implementation of IEEE or ISO rules/specifications for
math functions.

     <p>The default is <span class="option">-fno-unsafe-math-optimizations</span>.

     <br><dt><code>-ffinite-math-only</code><dd><a name="index-ffinite_002dmath_002donly-436"></a>Allow optimizations for floating-point arithmetic that assume
that arguments and results are not NaNs or +-Infs.

     <p>This option should never be turned on by any <span class="option">-O</span> option since
it can result in incorrect output for programs which depend on
an exact implementation of IEEE or ISO rules/specifications.

     <p>The default is <span class="option">-fno-finite-math-only</span>.

     <br><dt><code>-fno-trapping-math</code><dd><a name="index-fno_002dtrapping_002dmath-437"></a>Compile code assuming that floating-point operations cannot generate
user-visible traps.  These traps include division by zero, overflow,
underflow, inexact result and invalid operation.  This option implies
<span class="option">-fno-signaling-nans</span>.  Setting this option may allow faster
code if one relies on &ldquo;non-stop&rdquo; IEEE arithmetic, for example.

     <p>This option should never be turned on by any <span class="option">-O</span> option since
it can result in incorrect output for programs which depend on
an exact implementation of IEEE or ISO rules/specifications for
math functions.

     <p>The default is <span class="option">-ftrapping-math</span>.

     <br><dt><code>-fsignaling-nans</code><dd><a name="index-fsignaling_002dnans-438"></a>Compile code assuming that IEEE signaling NaNs may generate user-visible
traps during floating-point operations.  Setting this option disables
optimizations that may change the number of exceptions visible with
signaling NaNs.  This option implies <span class="option">-ftrapping-math</span>.

     <p>This option causes the preprocessor macro <code>__SUPPORT_SNAN__</code> to
be defined.

     <p>The default is <span class="option">-fno-signaling-nans</span>.

     <p>This option is experimental and does not currently guarantee to
disable all GCC optimizations that affect signaling NaN behavior.

     <br><dt><code>-fsingle-precision-constant</code><dd><a name="index-fsingle_002dprecision_002dconstant-439"></a>Treat floating point constant as single precision constant instead of
implicitly converting it to double precision constant.

   </dl>

   <p>The following options control optimizations that may improve
performance, but are not enabled by any <span class="option">-O</span> options.  This
section includes experimental options that may produce broken code.

     <dl>
<dt><code>-fbranch-probabilities</code><dd><a name="index-fbranch_002dprobabilities-440"></a>After running a program compiled with <span class="option">-fprofile-arcs</span>
(see <a href="Debugging-Options.html#Debugging-Options">Options for Debugging Your Program or <span class="command">gcc</span></a>), you can compile it a second time using
<span class="option">-fbranch-probabilities</span>, to improve optimizations based on
the number of times each branch was taken.  When the program
compiled with <span class="option">-fprofile-arcs</span> exits it saves arc execution
counts to a file called <var>sourcename</var><span class="file">.da</span> for each source
file  The information in this data file is very dependent on the
structure of the generated code, so you must use the same source code
and the same optimization options for both compilations.

     <p>With <span class="option">-fbranch-probabilities</span>, GCC puts a
<span class="samp">REG_BR_PROB</span> note on each <span class="samp">JUMP_INSN</span> and <span class="samp">CALL_INSN</span>. 
These can be used to improve optimization.  Currently, they are only
used in one place: in <span class="file">reorg.c</span>, instead of guessing which path a
branch is mostly to take, the <span class="samp">REG_BR_PROB</span> values are used to
exactly determine which path is taken more often.

     <br><dt><code>-fnew-ra</code><dd><a name="index-fnew_002dra-441"></a>Use a graph coloring register allocator.  Currently this option is meant
for testing, so we are interested to hear about miscompilations with
<span class="option">-fnew-ra</span>.

     <br><dt><code>-ftracer</code><dd><a name="index-ftracer-442"></a>Perform tail duplication to enlarge superblock size. This transformation
simplifies the control flow of the function allowing other optimizations to do
better job.

     <br><dt><code>-funroll-loops</code><dd><a name="index-funroll_002dloops-443"></a>Unroll loops whose number of iterations can be determined at compile
time or upon entry to the loop.  <span class="option">-funroll-loops</span> implies both
<span class="option">-fstrength-reduce</span> and <span class="option">-frerun-cse-after-loop</span>.  This
option makes code larger, and may or may not make it run faster.

     <br><dt><code>-funroll-all-loops</code><dd><a name="index-funroll_002dall_002dloops-444"></a>Unroll all loops, even if their number of iterations is uncertain when
the loop is entered.  This usually makes programs run more slowly. 
<span class="option">-funroll-all-loops</span> implies the same options as
<span class="option">-funroll-loops</span>,

     <br><dt><code>-fprefetch-loop-arrays</code><dd><a name="index-fprefetch_002dloop_002darrays-445"></a>If supported by the target machine, generate instructions to prefetch
memory to improve the performance of loops that access large arrays.

     <p>Disabled at level <span class="option">-Os</span>.

     <br><dt><code>-ffunction-sections</code><dt><code>-fdata-sections</code><dd><a name="index-ffunction_002dsections-446"></a><a name="index-fdata_002dsections-447"></a>Place each function or data item into its own section in the output
file if the target supports arbitrary sections.  The name of the
function or the name of the data item determines the section's name
in the output file.

     <p>Use these options on systems where the linker can perform optimizations
to improve locality of reference in the instruction space.  HPPA
processors running HP-UX and SPARC processors running Solaris 2 have
linkers with such optimizations.  Other systems using the ELF object format
as well as AIX may have these optimizations in the future.

     <p>Only use these options when there are significant benefits from doing
so.  When you specify these options, the assembler and linker will
create larger object and executable files and will also be slower. 
You will not be able to use <code>gprof</code> on all systems if you
specify this option and you may have problems with debugging if
you specify both this option and <span class="option">-g</span>.

     <br><dt><code>-fssa</code><dd><a name="index-fssa-448"></a>Perform optimizations in static single assignment form.  Each function's
flow graph is translated into SSA form, optimizations are performed, and
the flow graph is translated back from SSA form.  Users should not
specify this option, since it is not yet ready for production use.

     <br><dt><code>-fssa-ccp</code><dd><a name="index-fssa_002dccp-449"></a>Perform Sparse Conditional Constant Propagation in SSA form.  Requires
<span class="option">-fssa</span>.  Like <span class="option">-fssa</span>, this is an experimental feature.

     <br><dt><code>-fssa-dce</code><dd><a name="index-fssa_002ddce-450"></a>Perform aggressive dead-code elimination in SSA form.  Requires <span class="option">-fssa</span>. 
Like <span class="option">-fssa</span>, this is an experimental feature.

     <br><dt><code>--param </code><var>name</var><code>=</code><var>value</var><dd><a name="index-param-451"></a>In some places, GCC uses various constants to control the amount of
optimization that is done.  For example, GCC will not inline functions
that contain more that a certain number of instructions.  You can
control some of these constants on the command-line using the
<span class="option">--param</span> option.

     <p>In each case, the <var>value</var> is an integer.  The allowable choices for
<var>name</var> are given in the following table:

          <dl>
<dt><code>max-delay-slot-insn-search</code><dd>The maximum number of instructions to consider when looking for an
instruction to fill a delay slot.  If more than this arbitrary number of
instructions is searched, the time savings from filling the delay slot
will be minimal so stop searching.  Increasing values mean more
aggressive optimization, making the compile time increase with probably
small improvement in executable run time.

          <br><dt><code>max-delay-slot-live-search</code><dd>When trying to fill delay slots, the maximum number of instructions to
consider when searching for a block with valid live register
information.  Increasing this arbitrarily chosen value means more
aggressive optimization, increasing the compile time.  This parameter
should be removed when the delay slot code is rewritten to maintain the
control-flow graph.

          <br><dt><code>max-gcse-memory</code><dd>The approximate maximum amount of memory that will be allocated in
order to perform the global common subexpression elimination
optimization.  If more memory than specified is required, the
optimization will not be done.

          <br><dt><code>max-gcse-passes</code><dd>The maximum number of passes of GCSE to run.

          <br><dt><code>max-pending-list-length</code><dd>The maximum number of pending dependencies scheduling will allow
before flushing the current state and starting over.  Large functions
with few branches or calls can create excessively large lists which
needlessly consume memory and resources.

          <br><dt><code>max-inline-insns-single</code><dd>Several parameters control the tree inliner used in gcc. 
This number sets the maximum number of instructions (counted in gcc's
internal representation) in a single function that the tree inliner
will consider for inlining.  This only affects functions declared
inline and methods implemented in a class declaration (C++). 
The default value is 300.

          <br><dt><code>max-inline-insns-auto</code><dd>When you use <span class="option">-finline-functions</span> (included in <span class="option">-O3</span>),
a lot of functions that would otherwise not be considered for inlining
by the compiler will be investigated.  To those functions, a different
(more restrictive) limit compared to functions declared inline can
be applied. 
The default value is 300.

          <br><dt><code>max-inline-insns</code><dd>The tree inliner does decrease the allowable size for single functions
to be inlined after we already inlined the number of instructions
given here by repeated inlining.  This number should be a factor of
two or more larger than the single function limit. 
Higher numbers result in better runtime performance, but incur higher
compile-time resource (CPU time, memory) requirements and result in
larger binaries.  Very high values are not advisable, as too large
binaries may adversely affect runtime performance. 
The default value is 600.

          <br><dt><code>max-inline-slope</code><dd>After exceeding the maximum number of inlined instructions by repeated
inlining, a linear function is used to decrease the allowable size
for single functions.  The slope of that function is the negative
reciprocal of the number specified here. 
The default value is 32.

          <br><dt><code>min-inline-insns</code><dd>The repeated inlining is throttled more and more by the linear function
after exceeding the limit.  To avoid too much throttling, a minimum for
this function is specified here to allow repeated inlining for very small
functions even when a lot of repeated inlining already has been done. 
The default value is 130.

          <br><dt><code>max-inline-insns-rtl</code><dd>For languages that use the RTL inliner (this happens at a later stage
than tree inlining), you can set the maximum allowable size (counted
in RTL instructions) for the RTL inliner with this parameter. 
The default value is 600.

          <br><dt><code>max-unrolled-insns</code><dd>The maximum number of instructions that a loop should have if that loop
is unrolled, and if the loop is unrolled, it determines how many times
the loop code is unrolled.

          <br><dt><code>hot-bb-count-fraction</code><dd>Select fraction of the maximal count of repetitions of basic block in program
given basic block needs to have to be considered hot.

          <br><dt><code>hot-bb-frequency-fraction</code><dd>Select fraction of the maximal frequency of executions of basic block in
function given basic block needs to have to be considered hot

          <br><dt><code>tracer-dynamic-coverage</code><dt><code>tracer-dynamic-coverage-feedback</code><dd>
This value is used to limit superblock formation once the given percentage of
executed instructions is covered.  This limits unnecessary code size
expansion.

          <p>The <span class="option">tracer-dynamic-coverage-feedback</span> is used only when profile
feedback is available.  The real profiles (as opposed to statically estimated
ones) are much less balanced allowing the threshold to be larger value.

          <br><dt><code>tracer-max-code-growth</code><dd>Stop tail duplication once code growth has reached given percentage.  This is
rather hokey argument, as most of the duplicates will be eliminated later in
cross jumping, so it may be set to much higher values than is the desired code
growth.

          <br><dt><code>tracer-min-branch-ratio</code><dd>
Stop reverse growth when the reverse probability of best edge is less than this
threshold (in percent).

          <br><dt><code>tracer-min-branch-ratio</code><dt><code>tracer-min-branch-ratio-feedback</code><dd>
Stop forward growth if the best edge do have probability lower than this
threshold.

          <p>Similarly to <span class="option">tracer-dynamic-coverage</span> two values are present, one for
compilation for profile feedback and one for compilation without.  The value
for compilation with profile feedback needs to be more conservative (higher) in
order to make tracer effective.

          <br><dt><code>ggc-min-expand</code><dd>
GCC uses a garbage collector to manage its own memory allocation.  This
parameter specifies the minimum percentage by which the garbage
collector's heap should be allowed to expand between collections. 
Tuning this may improve compilation speed; it has no effect on code
generation.

          <p>The default is 30% + 70% * (RAM/1GB) with an upper bound of 100% when
RAM &gt;= 1GB.  If <code>getrlimit</code> is available, the notion of "RAM" is
the smallest of actual RAM, RLIMIT_RSS, RLIMIT_DATA and RLIMIT_AS.  If
GCC is not able to calculate RAM on a particular platform, the lower
bound of 30% is used.  Setting this parameter and
<span class="option">ggc-min-heapsize</span> to zero causes a full collection to occur at
every opportunity.  This is extremely slow, but can be useful for
debugging.

          <br><dt><code>ggc-min-heapsize</code><dd>
Minimum size of the garbage collector's heap before it begins bothering
to collect garbage.  The first collection occurs after the heap expands
by <span class="option">ggc-min-expand</span>% beyond <span class="option">ggc-min-heapsize</span>.  Again,
tuning this may improve compilation speed, and has no effect on code
generation.

          <p>The default is RAM/8, with a lower bound of 4096 (four megabytes) and an
upper bound of 131072 (128 megabytes).  If <code>getrlimit</code> is
available, the notion of "RAM" is the smallest of actual RAM,
RLIMIT_RSS, RLIMIT_DATA and RLIMIT_AS.  If GCC is not able to calculate
RAM on a particular platform, the lower bound is used.  Setting this
parameter very large effectively disables garbage collection.  Setting
this parameter and <span class="option">ggc-min-expand</span> to zero causes a full
collection to occur at every opportunity.

     </dl>
     </dl>

   </body></html>

