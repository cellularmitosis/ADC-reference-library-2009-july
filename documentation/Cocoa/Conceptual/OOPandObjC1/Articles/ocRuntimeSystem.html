<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Object Oriented Programming and the Objective-C Programming Language 1.0 (Not Recommended): The Runtime System</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="The Runtime System"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	<meta name="ROBOTS" content="NOINDEX"/>
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40005191-CH9" title="The Runtime System"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../LegacyTechnologies/index.html#//apple_ref/doc/uid/TP30000440-TP30000470" target="_top">Legacy Documents</a> &gt; <a href="../../../../LegacyTechnologies/Cocoa-date.html#//apple_ref/doc/uid/TP30000440-TP30000470-TP30000495" target="_top">Cocoa</a> &gt; <a href="../Introduction/introObjectiveC.html#//apple_ref/doc/uid/TP40005191-CH1-SW2">Object Oriented Programming and the Objective-C Programming Language 1.0 (Not Recommended)</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="ocLanguage.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="ocLanguageSummary.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        <script type="text/javascript" language="JavaScript">placeWatermark()</script>
<div id="legacyOuterWrapper"><div align="center" id="watermark">
<div class="legacybox">
<h1>Legacy Document<span class="closebutton"><a href="javascript:closeWatermark()"><img src="../../../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
You should read <em><a href="../../OOP_ObjC/index.html#//apple_ref/doc/uid/TP40005149" target="_top">Object-Oriented Programming with Objective-C</a></em>
                
                 and <em><a href="../../ObjectiveC/index.html#//apple_ref/doc/uid/TP30001163" target="_top">The Objective-C 2.0 Programming Language</a></em>
                
                 instead.</p></div></div></div>
        <a name="//apple_ref/doc/uid/TP40005191-CH9-CJBBBCHG" title="The Runtime System"></a><h1>The Runtime System</h1><p>The Objective-C language defers as many decisions as it can from compile time and link time to runtime. Whenever possible, it does things dynamically. This means that the language requires not just a compiler, but also a runtime system to execute the compiled code. The runtime system<a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_478"></a> acts as a kind of operating system for the Objective-C language; it’s what makes the language work.</p><p>The following sections look in particular at three areas where the <code>NSObject</code> class provides a framework and defines conventions:</p><ul class="ul"><li class="li"><p>Allocating and initializing new instances of a class, and deallocating instances when they’re no longer needed</p></li><li class="li"><p>Forwarding messages to another object</p></li><li class="li"><p>Dynamically loading new modules into a running program</p></li></ul><p>Additional conventions of the <code>NSObject</code> class are described in the <code>NSObject</code> class specification in the Foundation framework reference.</p><p>Other sections look at how you interact with the runtime at an abstract level; how you can use the Distributed Objects system for sending messages between objects in different address spaces; and how the compiler encodes the return and argument types for each method. </p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="ocRuntimeSystem.html#//apple_ref/doc/uid/TP40005191-CH9-SW7">Interacting with the Runtime System</a>
				
			<br/>
			
        
			
			
				<a href="ocRuntimeSystem.html#//apple_ref/doc/uid/TP40005191-CH9-SW6">Allocating, Initializing, and Deallocating Objects</a>
				
			<br/>
			
        
			
			
				<a href="ocRuntimeSystem.html#//apple_ref/doc/uid/TP40005191-CH9-SW5">Forwarding</a>
				
			<br/>
			
        
			
			
				<a href="ocRuntimeSystem.html#//apple_ref/doc/uid/TP40005191-CH9-SW20">Dynamic Loading</a>
				
			<br/>
			
        
			
			
				<a href="ocRuntimeSystem.html#//apple_ref/doc/uid/TP40005191-CH9-BAJIGHAF">Remote Messaging</a>
				
			<br/>
			
        
			
			
				<a href="ocRuntimeSystem.html#//apple_ref/doc/uid/TP40005191-CH9-TPXREF165">Type Encodings</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40005191-CH9-SW7" title="Interacting with the Runtime System"></a><h2>Interacting with the Runtime System</h2><p>Objective-C programs interact with the runtime system at three distinct levels: </p><ol class="ol"><li class="li"><p>Through Objective-C source code.</p><p>For the most part, the runtime system works automatically and behind the scenes. You use it just by writing and compiling Objective-C source code.</p><p>When you compile code containing Objective-C classes and methods, the compiler creates the data structures and function calls that implement the dynamic characteristics of the language. The data structures capture information found in class and category definitions and in protocol declarations; they include the class and protocol objects discussed in <span class="content_text"><a href="ocLanguage.html#//apple_ref/doc/uid/TP40005191-CH7-95276">“Extending Classes,”</a></span> as well as method selectors, instance variable templates, and other information distilled from source code. The principal runtime function is the one that sends messages, as described in <span class="content_text"><a href="ocLanguage.html#//apple_ref/doc/uid/TP40005191-CH7-88846">“How Messaging Works.”</a></span> It’s invoked by source-code message expressions.</p></li><li class="li"><p>Through the methods defined in the <code>NSObject</code> class of the Foundation framework.</p><p>Most objects in Cocoa are subclasses of the <code>NSObject</code> class, so most objects inherit the methods it defines. (The notable exception is the <code>NSProxy</code> class; see <span class="content_text"><a href="ocRuntimeSystem.html#//apple_ref/doc/uid/TP40005191-CH9-87022">“Forwarding”</a></span> for more information.)</p><p>Some of the <code>NSObject</code> methods simply query the runtime system for information. These methods allow objects to perform introspection. Examples of such methods are the <code>class</code><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_479"></a> method, which asks an object to identify its class; <code>isKindOfClass:</code><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_480"></a> and <code>isMemberOfClass:</code><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_481"></a>, which test an object’s position in the inheritance hierarchy; <code>respondsToSelector:</code><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_482"></a>, which indicates whether an object can accept a particular message; <code>conformsToProtocol:</code><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_483"></a>, which indicates whether an object claims to implement the methods defined in a specific protocol; and <code>methodForSelector:</code><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_484"></a>, which provides the address of a method’s implementation. Methods like these give an object the ability to introspect about itself.</p><p>All these methods were mentioned in previous chapters and are described in detail in the <code>NSObject</code> class specification in the Foundation framework reference.</p></li><li class="li"><p>Through direct calls to runtime<a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_485"></a> functions.</p><p>The runtime system is a dynamic shared library with a public interface consisting of a set of functions and data structures in the header files located within the directory <code>/usr/include/objc</code>. Many of these functions allow you to use plain C to replicate what the compiler does when you write Objective-C code. Others form the basis for functionality exported through the methods of the <code>NSObject</code> class. These functions make it possible to develop other interfaces to the runtime system and produce tools that augment the development environment; they’re not needed when programming in Objective-C. However, a few of the runtime functions might on occasion be useful when writing an Objective-C program. All of these functions are documented in <em><a href="../../../Reference/ObjCRuntimeRef/index.html#//apple_ref/doc/uid/TP40001418" target="_top">Objective-C 2.0 Runtime Reference</a></em>.</p></li></ol><p>Because the <code>NSObject</code><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_486"></a> class is at the root of the inheritance hierarchy of the Foundation framework, the methods it defines are usually inherited by all classes. Its methods therefore establish behaviors<a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_487"></a> that are inherent to every instance and every class object. However, in a few cases, the <code>NSObject</code> class merely defines a template for how something should be done; it doesn’t provide all the necessary code itself.</p><p>For example, the <code>NSObject</code> class defines a <code>description</code> instance method that returns a string describing the contents of the class. This is primarily used for debugging—the GDB <code>print-object</code> command prints the string returned from this method. <code>NSObject</code>’s implementation of this method doesn’t know what the class contains, so it returns a string with the name and address of the object. Subclasses of <code>NSObject</code> can implement this method to return more details. For example, the Foundation class <code>NSArray</code> returns a list of descriptions of the objects it contains.</p><a name="//apple_ref/doc/uid/TP40005191-CH9-105377" title="Allocating, Initializing, and Deallocating Objects"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-SW6" title="Allocating, Initializing, and Deallocating Objects"></a><h2>Allocating, Initializing, and Deallocating Objects</h2><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_488"></a><p>This section describes how to allocate, initialize, and deallocate objects, and the fundamentals of the methods you use for memory management in Cocoa. This section does not provide a complete description of memory management—or more accurately, object ownership—in Cocoa; this subject is discussed in <em><a href="../../MemoryMgmt/index.html#//apple_ref/doc/uid/10000011i" target="_top">Memory Management Programming Guide for Cocoa</a></em> which you should consider as required reading. </p><a name="//apple_ref/doc/uid/TP40005191-CH9-105701" title="Allocating and Initializing Objects"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-SW8" title="Allocating and Initializing Objects"></a><h3>Allocating and Initializing Objects</h3><p><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_489"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_490"></a>It takes two steps to create an object using Objective-C. You must:</p><ul class="spaceabove"><li class="li"><p>Dynamically allocate memory for the new object</p></li><li class="li"><p>Initialize<a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_491"></a> the newly allocated memory<a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_492"></a> to appropriate values</p></li></ul><p>An object isn’t fully functional until both steps have been completed. Each step is accomplished by a separate method but typically in a single line of code:</p><div class="codesample"><table><tr><td scope="row"><pre>id anObject = [[Rectangle alloc] init];<span></span></pre></td></tr></table></div><p>Separating allocation from initialization gives you individual control over each step so that each can be modified independently of the other. The following sections look first at allocation and then at initialization, and discuss how they are controlled and modified.</p><p>In Objective-C, memory for new objects<a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_493"></a> is allocated using class methods defined in the <code>NSObject</code> class. <code>NSObject</code> defines two principal methods for this purpose, <code>alloc</code> and <code>allocWithZone:</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>+ (id)alloc;<span></span></pre></td></tr><tr><td scope="row"><pre>+ (id)allocWithZone:(NSZone *)zone;<span></span></pre></td></tr></table></div><p>These methods allocate enough memory to hold all the instance variables for an object belonging to the receiving class. They don’t need to be overridden and modified in subclasses.</p><p>The <code>alloc</code><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_494"></a> and <code>allocWithZone:</code><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_495"></a> methods initialize a newly allocated object’s <code>isa</code> instance variable so that it points to the object’s class (the class object). All other instance variables are set to <code>0</code>. Usually, an object needs to be more specifically initialized before it can be safely used.</p><p>This initialization<a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_496"></a> is the responsibility of class-specific instance methods that, by convention, begin with the abbreviation “init”. If the method takes no arguments, the method name is just those four letters, <code>init</code><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_497"></a>. If it takes arguments, labels for the arguments follow the “init” prefix. For example, an <code>NSView</code> object can be initialized with an <code>initWithFrame:</code> method.</p><p>Every class that declares instance variables must provide an <code>init...</code> method to initialize them. The <code>NSObject</code> class declares the <code>isa</code> variable and defines an <code>init</code> method. However, since <code>isa</code> is initialized when memory for an object is allocated, all <code>NSObject</code>’s <code>init</code> method does is return <code>self</code>. <code>NSObject</code> declares the method mainly to establish the naming convention described earlier.<a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_498"></a></p><a name="//apple_ref/doc/uid/TP40005191-CH9-105952" title="The Returned Object"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-CJBBEEFH" title="The Returned Object"></a><h4>The Returned Object</h4><p>An <code>init...</code> method normally initializes the instance variables of the receiver, then returns it. It’s the responsibility of the method to return an object that can be used without error.</p><p>However, in some cases, this responsibility can mean returning a different object than the receiver. For example, if a class keeps a list of named objects, it might provide an <code>initWithName:</code> method to initialize new instances. If there can be no more than one object per name, <code>initWithName:</code> might refuse to assign the same name to two objects. When asked to assign a new instance a name that’s already being used by another object, it might free the newly allocated instance and return the other object—thus ensuring the uniqueness of the name while at the same time providing what was asked for, an instance with the requested name.</p><p>In a few cases, it might be impossible for an <code>init...</code> method to do what it’s asked to do. For example, an <code>initFromFile:</code> method might get the data it needs from a file passed as an argument. If the file name it’s passed doesn’t correspond to an actual file, it won’t be able to complete the initialization. In such a case, the <code><!--a  -->init...<!--/a--></code> method could free the receiver and return <code>nil</code>, indicating that the requested object can’t be created.</p><p>Because an <code>init...</code> method might return an object other than the newly allocated receiver, or even return <code>nil</code>, it’s important that programs use the value returned by the initialization method, not just that returned by <code>alloc</code> or <code>allocWithZone:</code>. The following code is very dangerous, since it ignores the return of <code>init</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>id anObject = [SomeClass alloc];<span></span></pre></td></tr><tr><td scope="row"><pre>[anObject init];<span></span></pre></td></tr><tr><td scope="row"><pre>[anObject someOtherMessage];<span></span></pre></td></tr></table></div><p>Instead, to safely initialize an object, you should combine allocation and initialization messages in one line of code.</p><div class="codesample"><table><tr><td scope="row"><pre>id anObject = [[SomeClass alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>[anObject someOtherMessage];<span></span></pre></td></tr></table></div><p>If there’s a chance that the <code>init...</code> method might return <code>nil</code>, then you should check the return value before proceeding:</p><div class="codesample"><table><tr><td scope="row"><pre>id anObject = [[SomeClass alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>if ( anObject )<span></span></pre></td></tr><tr><td scope="row"><pre>    [anObject someOtherMessage];<span></span></pre></td></tr><tr><td scope="row"><pre>else<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40005191-CH9-143322" title="Arguments"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-SW9" title="Arguments"></a><h4>Arguments</h4><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_499"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_500"></a><p>An <code>init...</code> method must ensure that all of an object’s instance variables have reasonable values. This doesn’t mean that it needs to provide an argument for each variable. It can set some to default values or depend on the fact that (except for <code>isa</code>) all bits of memory allocated for a new object are set to <code>0</code>. For example, if a class requires its instances to have a name and a data source, it might provide an <code>initWithName:fromFile:</code> method, but set nonessential instance variables to arbitrary values or allow them to have the null values set by default. It could then rely on methods like <code>setEnabled:</code>, <code>setFriend:</code>, and <code>setDimensions:</code> to modify default values after the initialization phase had been completed.</p><p>Any <code>init...</code> method that takes arguments must be prepared to handle cases where an inappropriate value is passed.</p><a name="//apple_ref/doc/uid/TP40005191-CH9-106169" title="Coordinating Classes"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-SW10" title="Coordinating Classes"></a><h4>Coordinating Classes</h4><p>Every class that declares instance variables<a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_501"></a> must provide an <code>init...</code> method to initialize them (unless the variables require no initialization). The <code>init...</code> methods the class defines initialize only those variables declared in the class. Inherited instance variables<a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_502"></a> are initialized by sending a message to <code>super</code><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_503"></a> to perform an initialization method defined somewhere farther up the inheritance hierarchy:</p><div class="codesample"><table><tr><td scope="row"><pre>- initWithName:(char *)string<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( self = [super init] ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        name = (char *)NSZoneMalloc([self zone],<span></span></pre></td></tr><tr><td scope="row"><pre>            strlen(string) + 1);<span></span></pre></td></tr><tr><td scope="row"><pre>        strcpy(name, string);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return self;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The message to <code>super</code> chains together initialization methods in all inherited classes. Because it comes first, it ensures that superclass variables are initialized before those declared in subclasses. For example, a Rectangle object must be initialized as an <code>NSObject</code>, a Graphic, and a Shape before it’s initialized as a Rectangle.</p><p>The connection between the <code>initWithName:</code> method illustrated above and the inherited <code>init</code> method it incorporates is illustrated in <span class="content_text">Figure 2-1</span>:</p><br/><div><a name="//apple_ref/doc/uid/TP40005191-CH9-106278" title="Figure 2-1Incorporating an Inherited Initialization Method"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-BABBBEAE" title="Figure 2-1Incorporating an Inherited Initialization Method"></a><p><strong>Figure 2-1&nbsp;&nbsp;</strong>Incorporating an Inherited Initialization Method</p><img src = "../Art/initsimple.gif" alt = "" width="278" height="302"></div><br/><p>A class must also make sure that all inherited initialization methods work. For example, if class A defines an <code>init</code> method and its subclass B defines an <code>initWithName:</code> method, as shown in <span class="content_text">Figure 2-1</span>, B must also make sure that an <code>init</code> message successfully initializes B instances. The easiest way to do that is to replace the inherited <code>init</code> method with a version that invokes <code>initWithName:</code>:</p><div class="codesample"><table><tr><td scope="row"><pre>- init<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return [self initWithName:"default"];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The <code>initWithName:</code> method would, in turn, invoke the inherited method, as shown earlier. <span class="content_text">Figure 2-2</span> includes B’s version of <code>init</code>:</p><br/><div><a name="//apple_ref/doc/uid/TP40005191-CH9-106357" title="Figure 2-2Covering an Inherited Initialization Model"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-BCIBCHGD" title="Figure 2-2Covering an Inherited Initialization Model"></a><p><strong>Figure 2-2&nbsp;&nbsp;</strong>Covering an Inherited Initialization Model</p><img src = "../Art/inita_b.gif" alt = "" width="278" height="302"></div><br/><p>Covering inherited initialization methods makes the class you define more portable to other applications. If you leave an inherited method uncovered, someone else may use it to produce incorrectly initialized instances of your class.</p><a name="//apple_ref/doc/uid/TP40005191-CH9-106376" title="The Designated Initializer"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-SW11" title="The Designated Initializer"></a><h4>The Designated Initializer</h4><p><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_504"></a>In the example above, <code>initWithName:</code> would be the <strong>designated initializer</strong><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_505"></a> for its class (class B). The designated initializer is the method in each class<a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_506"></a> that guarantees inherited instance variables are initialized (by sending a message to <code>super</code> to perform an inherited method). It’s also the method that does most of the work, and the one that other initialization methods in the same class invoke. It’s a Cocoa convention that the designated initializer is always the method that allows the most freedom to determine the character of a new instance (usually this is the one with the most arguments, but not always).</p><p>It’s important to know the designated initializer when defining a subclass. For example, suppose we define class C, a subclass of B, and implement an <code>initWithName:fromFile:</code> method. In addition to this method, we have to make sure that the inherited <code>init</code> and <code>initWithName:</code> methods also work for instances of C. This can be done just by covering B’s <code>initWithName:</code> with a version that invokes <code>initWithName:fromFile:</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>- initWithName:(char *)string<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return [self initWithName:string fromFile:NULL];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>For an instance of the C class, the inherited <code>init</code> method invokes this new version of <code>initWithName:</code> which invokes <code>initWithName:fromFile:</code>. The relationship between these methods is shown in <span class="content_text">Figure 2-3</span>:</p><br/><div><a name="//apple_ref/doc/uid/TP40005191-CH9-106471" title="Figure 2-3Covering the Designated Initializer"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-BCIGDDCC" title="Figure 2-3Covering the Designated Initializer"></a><p><strong>Figure 2-3&nbsp;&nbsp;</strong>Covering the Designated Initializer</p><img src = "../Art/initb_c.gif" alt = "" width="223" height="253"></div><br/><p>This figure omits an important detail. The <code>initWithName:fromFile:</code> method, being the designated initializer for the C class, sends a message to <code>super</code> to invoke an inherited initialization method. But which of B’s methods should it invoke, <code>init</code> or <code>initWithName:</code>? It can’t invoke <code>init</code>, for two reasons:</p><ul class="spaceabove"><li class="li"><p>Circularity would result (<code>init</code> invokes C’s <code>initWithName:</code>, which invokes <code>initWithName:fromFile:</code>, which invokes <code>init</code> again).</p></li><li class="li"><p>It won’t be able to take advantage of the initialization code in B’s version of <code>initWithName:</code>.</p></li></ul><p>Therefore, <code>initWithName:fromFile:</code> must invoke <code>initWithName:</code>:</p><div class="codesample"><table><tr><td scope="row"><pre>- initWithName:(char *)string fromFile:(char *)pathname<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( self = [super initWithName:string] )<span></span></pre></td></tr><tr><td scope="row"><pre>        ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40005191-CH9-SW12" title="General Principle"></a><p><strong>General Principle:</strong>&nbsp;The designated initializer in a class must, through a message to <code>super</code>, invoke the designated initializer in a superclass.</p></div><p>Designated initializers are chained to each other through messages to <code>super</code>, while other initialization methods are chained to designated initializers through messages to <code>self</code>.</p><p><span class="content_text">Figure 2-4</span> shows how all the initialization methods in classes A, B, and C are linked. Messages to <code>self</code> are shown on the left and messages to <code>super</code> are shown on the right.</p><br/><div><a name="//apple_ref/doc/uid/TP40005191-CH9-106638" title="Figure 2-4Initialization Chain"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-BCIHGIFI" title="Figure 2-4Initialization Chain"></a><p><strong>Figure 2-4&nbsp;&nbsp;</strong>Initialization Chain</p><img src = "../Art/initall.gif" alt = "" width="222" height="367"></div><br/><p>Note that B’s version of <code>init</code> sends a message to <code>self</code> to invoke the <code>initWithName:</code> method. Therefore, when the receiver is an instance of the B class, it invokes B’s version of <code>initWithName:</code>, and when the receiver is an instance of the C class, it invokes C’s version.<a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_507"></a></p><a name="//apple_ref/doc/uid/TP40005191-CH9-86749" title="Combining Allocation and Initialization"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-SW13" title="Combining Allocation and Initialization"></a><h4>Combining Allocation and Initialization</h4><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_508"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_509"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_510"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_511"></a><p>In Cocoa, some classes define creation methods that combine the two steps of allocating and initializing to return new, initialized instances of the class. These methods typically take the form <code>+ </code><em>className...</em> where <em>className</em> is the name of the class. For instance, <code>NSString</code> has the following methods (among others):</p><div class="codesample"><table><tr><td scope="row"><pre>+ (NSString *)stringWithCString:(const char *)bytes;<span></span></pre></td></tr><tr><td scope="row"><pre>+ (NSString *)stringWithFormat:(NSString *)format, ...;<span></span></pre></td></tr></table></div><p>Similarly, <code>NSArray</code> defines the following class methods that combine allocation and initialization:</p><div class="codesample"><table><tr><td scope="row"><pre>+ (id)array;<span></span></pre></td></tr><tr><td scope="row"><pre>+ (id)arrayWithObject:(id)anObject;<span></span></pre></td></tr><tr><td scope="row"><pre>+ (id)arrayWithObjects:(id)firstObj, ...;<span></span></pre></td></tr></table></div><p>Instances created with any of these methods are deallocated automatically (as described in <span class="content_text"><a href="ocRuntimeSystem.html#//apple_ref/doc/uid/TP40005191-CH9-107334">“Marking Objects for Later Release”</a></span>), so you don’t have to release them unless you have retained them (as described in <span class="content_text"><a href="ocRuntimeSystem.html#//apple_ref/doc/uid/TP40005191-CH9-107640">“Retaining Objects”</a></span>). Usually there are equivalent <code>-init...</code> methods provided along with these conveniences.</p><p>Methods that combine allocation and initialization are particularly valuable if the allocation must somehow be informed by the initialization. For example, if the data for the initialization is taken from a file, and the file might contain enough data to initialize more than one object, it would be impossible to know how many objects to allocate until the file is opened. In this case, you might implement a <code>listFromFile:</code> method that takes the name of the file as an argument. It would open the file, see how many objects to allocate, and create a List object large enough to hold all the new objects. It would then allocate and initialize the objects from data in the file, put them in the List, and finally return the List.</p><p>It also makes sense to combine allocation and initialization in a single method if you want to avoid the step of blindly allocating memory for a new object that you might not use. As mentioned in <span class="content_text"><a href="ocRuntimeSystem.html#//apple_ref/doc/uid/TP40005191-CH9-105952">“The Returned Object,”</a></span> an <code>init...</code> method might sometimes substitute another object for the receiver. For example, when <code>initWithName:</code> is passed a name that’s already taken, it might free the receiver and in its place return the object that was previously assigned the name. This means, of course, that an object is allocated and freed immediately without ever being used.</p><p>If the code that determines whether the receiver should be initialized is placed inside the method that does the allocation instead of inside <code>init...</code>, you can avoid the step of allocating a new instance when one isn’t needed.</p><p>In the following example, the <code>soloist</code> method ensures that there’s no more than one instance of the Soloist class. It allocates and initializes an instance only once:<a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_512"></a></p><div class="codesample"><table><tr><td scope="row"><pre>+ soloist<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    static Soloist *instance = nil;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if ( instance == nil )<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        instance = [[self alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return instance;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40005191-CH9-142945" title="Object Ownership"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-SW1" title="Object Ownership"></a><h3>Object Ownership</h3><p>In an Objective-C program, objects<a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_513"></a> are constantly creating and disposing of other objects. Much of the time an object creates things for private use and can dispose of them as it needs. However, when an object passes something to another object through a method invocation, the lines of ownership—and responsibility for disposal—blur. Object ownership and memory management are discussed in greater detail in <em><a href="../../MemoryMgmt/index.html#//apple_ref/doc/uid/10000011i" target="_top">Memory Management Programming Guide for Cocoa</a></em>; the following three sections describe the mechanism of memory management in Cocoa, but not the policy. <em>You must read</em> <em><a href="../../MemoryMgmt/index.html#//apple_ref/doc/uid/10000011i" target="_top">Memory Management Programming Guide for Cocoa</a></em> <em>to fully understand the issues.</em></p><a name="//apple_ref/doc/uid/TP40005191-CH9-SW14" title="Basic Ownership"></a><h4>Basic Ownership</h4><p>Cocoa uses a memory-management technique called <strong>reference counting</strong> (also known as <em>refcounting</em>), in which each entity that claims ownership of an object increments the object’s reference count and decrements the reference count<a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_514"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_515"></a> when finished with the object. When the reference count reaches zero, the object is deallocated (as will be explained in <span class="content_text"><a href="ocRuntimeSystem.html#//apple_ref/doc/uid/TP40005191-CH9-106980">“Deallocation”</a></span>). This technique allows one instance of an object to be safely shared among several other objects. </p><p>If you <em>create</em> a <em>new</em> object, you own it (note that there are precise definitions for what create means here—again see <em><a href="../../MemoryMgmt/index.html#//apple_ref/doc/uid/10000011i" target="_top">Memory Management Programming Guide for Cocoa</a></em>). The new object has a refcount of 1. It is your responsibility to relinquish ownership of the object when you have finished with it. You can do this by sending it a <code>release</code> message, which decrements the refcount by 1.</p><div class="codesample"><table><tr><td scope="row"><pre>[anObject release];<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40005191-CH9-107334" title="Marking Objects for Later Release"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-SW3" title="Marking Objects for Later Release"></a><h4>Marking Objects for Later Release</h4><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_516"></a><p>When you write a method that creates and returns a new object, that method is responsible for releasing the object. However, it’s clearly not fruitful to dispose of an object before the recipient of the object gets it. What is needed is a way to mark an object for release at a later time, so that it’s properly disposed of after the recipient has had a chance to use it. Cocoa provides just such a mechanism.</p><div class="codesample"><table><tr><td scope="row"><pre>[anObject autorelease];<span></span></pre></td></tr></table></div><p>The <code>autorelease</code><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_517"></a> method, defined by <code>NSObject</code>, marks the receiver for later release. By autoreleasing <a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_518"></a>an object—that is, by sending it an <code>autorelease</code> message—you cause the autoreleased object to be sent a <code>release</code> message at some stage in the future by the current <strong>autorelease pool</strong> The mechanism by which the release message is sent and the timing of the release message are discussed in greater detail in <span class="content_text"><a href="../../MemoryMgmt/Articles/mmAutoreleasePools.html#//apple_ref/doc/uid/20000047" target="_top">Autorelease Pools</a></span>. </p><a name="//apple_ref/doc/uid/TP40005191-CH9-107640" title="Retaining Objects"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-SW2" title="Retaining Objects"></a><h4>Retaining Objects</h4><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_519"></a><p><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_520"></a>There are times when you don’t want a received object to be disposed of; for example, you may need to cache the object in an instance variable. In this case, only you know when the object is no longer needed, so you need the power to ensure that the object is not disposed of while you are still using it.</p><div class="codesample"><table><tr><td scope="row"><pre>[anObject retain];<span></span></pre></td></tr></table></div><p>You do this with the <code>retain</code><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_521"></a> method, which stays the effect of a pending <code>autorelease</code> (or preempts a later <code>release</code><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_522"></a> or <code>autorelease</code><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_523"></a> message; see <span class="content_text"><a href="ocRuntimeSystem.html#//apple_ref/doc/uid/TP40005191-CH9-106980">“Deallocation”</a></span> for details on the <code>autorelease</code> message). By retaining an object you ensure that it isn’t deallocated until you’re done with it:</p><a name="//apple_ref/doc/uid/TP40005191-CH9-106980" title="Deallocation"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-SW4" title="Deallocation"></a><h3>Deallocation</h3><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_524"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_525"></a><p>The <code>NSObject</code> class defines a <code>dealloc</code><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_526"></a> method that relinquishes the memory originally allocated for an object. You must never invoke <code>dealloc</code> directly; you should instead invoke either the <code>release</code><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_527"></a> method or the <code>autorelease</code><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_528"></a> method to decrement the method’s refcount. When the object’s refcount reaches zero, the <code>release</code> method invokes <code>dealloc</code>. In some situations, you don’t release an object at all.</p><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_529"></a><p>The purpose of a <code>dealloc</code> message is to deallocate all the memory occupied by the receiver. <code>NSObject</code>’s version of the method deallocates the receiver’s instance variables, but doesn’t follow any variable that points to other memory. If the receiver allocated any additional memory—to store a character string or an array of structures, for example—that memory must also be deallocated (unless it’s shared by other objects). If the receiver had claimed ownership of any other objects, it must also relinquish ownership.</p><p>Every class that has its objects allocate additional memory or claim ownership of other objects (typically using object instance variables) must have its own <code>dealloc</code> method. Each version of <code>dealloc</code> ends with a message to <code>super</code> to perform an inherited version of the method, as illustrated in the following example:</p><div class="codesample"><table><tr><td scope="row"><pre>- dealloc {<span></span></pre></td></tr><tr><td scope="row"><pre>    [ownedObject release];<span></span></pre></td></tr><tr><td scope="row"><pre>    free(privateMemory);<span></span></pre></td></tr><tr><td scope="row"><pre>    vm_deallocate(task_self(), sharedMemory, memorySize);<span></span></pre></td></tr><tr><td scope="row"><pre>    [super dealloc];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>By working its way up the inheritance hierarchy, every <code>dealloc</code> message eventually invokes <code>NSObject</code>’s version of the method.</p><a name="//apple_ref/doc/uid/TP40005191-CH9-87022" title="Forwarding"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-SW5" title="Forwarding"></a><h2>Forwarding</h2><p><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_530"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_531"></a>Sending a message to an object that does not handle that message is an error. However, before announcing the error, the runtime system gives the receiving object a second chance to handle the message. It sends the object a <code>forwardInvocation:</code> message with an <code>NSInvocation</code><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_532"></a> object as its sole argument—the <code>NSInvocation</code> object encapsulates the original message and the arguments that were passed with it.</p><p>You can implement a <code>forwardInvocation:</code><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_533"></a> method to give a default response to the message, or to avoid the error in some other way. As its name implies, <code>forwardInvocation:</code> is commonly used to forward the message to another object.</p><p>To see the scope and intent of forwarding, imagine the following scenarios: Suppose, first, that you’re designing an object that can respond to a message called <code>negotiate</code>, and you want its response to include the response of another kind of object. You could accomplish this easily by passing a <code>negotiate</code> message to the other object somewhere in the body of the <code>negotiate</code> method you implement.</p><p>Take this a step further, and suppose that you want your object’s response to a <code>negotiate</code> message to be exactly the response implemented in another class. One way to accomplish this would be to make your class inherit the method from the other class. However, it might not be possible to arrange things this way. There may be good reasons why your class and the class that implements <code>negotiate</code> are in different branches of the inheritance hierarchy.</p><p>Even if your class can’t inherit the <code>negotiate</code> method, you can still “borrow” it by implementing a version of the method that simply passes the message on to an instance of the other class:</p><div class="codesample"><table><tr><td scope="row"><pre>- negotiate<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( [someOtherObject respondsTo:@selector(negotiate)] )<span></span></pre></td></tr><tr><td scope="row"><pre>        return [someOtherObject negotiate];<span></span></pre></td></tr><tr><td scope="row"><pre>    return self;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>This way of doing things could get a little cumbersome, especially if there were a number of messages you wanted your object to pass on to the other object. You’d have to implement one method to cover each method you wanted to borrow from the other class. Moreover, it would be impossible to handle cases where you didn’t know, at the time you wrote the code, the full set of messages you might want to forward. That set might depend on events at runtime, and it might change as new methods and classes are implemented in the future.</p><p>The second chance offered by a <code>forwardInvocation:</code> message provides a less ad hoc solution to this problem, and one that’s dynamic rather than static. It works like this: When an object can’t respond to a message because it doesn’t have a method matching the selector in the message, the runtime system informs the object by sending it a <code>forwardInvocation:</code> message. Every object inherits a <code>forwardInvocation:</code> method from the <code>NSObject</code> class. However, <code>NSObject</code>’s version of the method simply invokes <code>doesNotRecognizeSelector:</code><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_534"></a>. By overriding <code>NSObject</code>’s version and implementing your own, you can take advantage of the opportunity that the <code>forwardInvocation:</code> message provides to forward messages to other objects.</p><p>To forward a message, all a <code>forwardInvocation:</code> method needs to do is:</p><ul class="ul"><li class="li"><p> Determine where the message should go, and</p></li><li class="li"><p> Send it there with its original arguments.</p></li></ul><p>The message can be sent with the <code>invokeWithTarget:</code> method:</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)forwardInvocation:(NSInvocation *)anInvocation<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if ([someOtherObject respondsToSelector:<span></span></pre></td></tr><tr><td scope="row"><pre>            [anInvocation selector]])<span></span></pre></td></tr><tr><td scope="row"><pre>        [anInvocation invokeWithTarget:someOtherObject];<span></span></pre></td></tr><tr><td scope="row"><pre>    else<span></span></pre></td></tr><tr><td scope="row"><pre>        [super forwardInvocation:anInvocation];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The return value of the message that’s forwarded is returned to the original sender. All types of return values can be delivered to the sender, including <code>id</code>s, structures, and double-precision floating-point numbers.</p><p>A <code>forwardInvocation:</code> method can act as a distribution center for unrecognized messages, parceling them out to different receivers. Or it can be a transfer station, sending all messages to the same destination. It can translate one message into another, or simply “swallow” some messages so there’s no response and no error. A <code>forwardInvocation:</code> method can also consolidate several messages into a single response. What <code>forwardInvocation:</code> does is up to the implementor. However, the opportunity it provides for linking objects in a forwarding chain opens up possibilities for program design.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40005191-CH9-SW15" title="Note"></a><p><strong>Note:</strong>&nbsp;The <code>forwardInvocation:</code> method gets to handle messages only if they don’t invoke an existing method in the nominal receiver. If, for example, you want your object to forward <code>negotiate</code> messages to another object, it can’t have a <code>negotiate</code> method of its own. If it does, the message will never reach <code>forwardInvocation:</code>.</p></div><p>For more information on forwarding and invocations, see the <code>NSInvocation</code> class specification in the Foundation framework reference.</p><a name="//apple_ref/doc/uid/TP40005191-CH9-87300" title="Forwarding and Multiple Inheritance"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-SW16" title="Forwarding and Multiple Inheritance"></a><h3>Forwarding and Multiple Inheritance</h3><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_535"></a><p>Forwarding mimics inheritance, and can be used to lend some of the effects of multiple inheritance to Objective-C programs. As shown in <span class="content_text"><a href="ocRuntimeSystem.html#//apple_ref/doc/uid/TP40005191-CH9-87317">Figure 2-5</a></span>, an object that responds to a message by forwarding it appears to borrow or “inherit” a method implementation defined in another class.</p><br/><div><a name="//apple_ref/doc/uid/TP40005191-CH9-87317" title="Figure 2-5Forwarding"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-BCIEECCB" title="Figure 2-5Forwarding"></a><p><strong>Figure 2-5&nbsp;&nbsp;</strong>Forwarding</p><img src = "../Art/forwarding.gif" alt = "" width="376" height="241"></div><br/><p>In this illustration, an instance of the Warrior class forwards a <code>negotiate</code> message to an instance of the Diplomat class. The Warrior will appear to negotiate like a Diplomat. It will seem to respond to the <code>negotiate</code> message, and for all practical purposes it does respond (although it’s really a Diplomat that’s doing the work).</p><p>The object that forwards a message thus “inherits” methods from two branches of the inheritance hierarchy—its own branch and that of the object that responds to the message. In the example above, it appears as if the Warrior class inherits from Diplomat as well as its own superclass.</p><p>Forwarding addresses most needs that lead programmers to value multiple inheritance. However, there’s an important difference between the two: Multiple inheritance combines different capabilities in a single object. It tends toward large, multifaceted objects. Forwarding, on the other hand, assigns separate responsibilities to disparate objects. It decomposes problems into smaller objects, but associates those objects in a way that’s transparent to the message sender.</p><a name="//apple_ref/doc/uid/TP40005191-CH9-87354" title="Surrogate Objects"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-SW17" title="Surrogate Objects"></a><h3>Surrogate Objects</h3><p><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_536"></a>Forwarding not only mimics multiple inheritance, it also makes it possible to develop lightweight objects that represent or “cover” more substantial objects. The surrogate stands in for the other object and funnels messages to it.</p><p>The proxy<a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_537"></a> discussed in <span class="content_text"><a href="ocRuntimeSystem.html#//apple_ref/doc/uid/TP40005191-CH9-103647">“Remote Messaging”</a></span> is such a surrogate<a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_538"></a>. A proxy takes care of the administrative details of forwarding messages to a remote receiver, making sure argument values are copied and retrieved across the connection, and so on. But it doesn’t attempt to do much else; it doesn’t duplicate the functionality of the remote object but simply gives the remote object a local address, a place where it can receive messages in another application.</p><p>Other kinds of surrogate objects are also possible. Suppose, for example, that you have an object that manipulates a lot of data—perhaps it creates a complicated image or reads the contents of a file on disk. Setting this object up could be time-consuming, so you prefer to do it lazily—when it’s really needed or when system resources are temporarily idle. At the same time, you need at least a placeholder for this object in order for the other objects in the application to function properly.</p><p>In this circumstance, you could initially create, not the full-fledged object, but a lightweight surrogate for it. This object could do some things on its own, such as answer questions about the data, but mostly it would just hold a place for the larger object and, when the time came, forward messages to it. When the surrogate’s <code>forwardInvocation:</code> method first receives a message destined for the other object, it would ensure that the object existed and would create it if it didn’t. All messages for the larger object go through the surrogate, so, as far as the rest of the program is concerned, the surrogate and the larger object would be the same.<a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_539"></a></p><a name="//apple_ref/doc/uid/TP40005191-CH9-87395" title="Forwarding and Inheritance"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-SW18" title="Forwarding and Inheritance"></a><h3>Forwarding and Inheritance</h3><p>Although forwarding<a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_540"></a> mimics inheritance, the <code>NSObject</code> class never confuses the two. Methods like <code>respondsToSelector:</code> and <code>isKindOfClass:</code> look only at the inheritance hierarchy, never at the forwarding chain. If, for example, a Warrior object is asked whether it responds to a <code>negotiate</code> message,</p><div class="codesample"><table><tr><td scope="row"><pre>if ( [aWarrior respondsToSelector:@selector(negotiate)] )<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr></table></div><p>the answer is <code>NO</code>, even though it can receive <code>negotiate</code> messages without error and respond to them, in a sense, by forwarding them to a Diplomat. (See <span class="content_text"><a href="ocRuntimeSystem.html#//apple_ref/doc/uid/TP40005191-CH9-87317">Figure 2-5</a></span>.)</p><p>In many cases, <code>NO</code> is the right answer. But it may not be. If you use forwarding to set up a surrogate object or to extend the capabilities of a class, the forwarding mechanism should probably be as transparent as inheritance. If you want your objects to act as if they truly inherited the behavior<a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_541"></a> of the objects they forward messages to, you’ll need to re-implement the <code>respondsToSelector:</code> and <code>isKindOfClass:</code> methods to include your forwarding algorithm:</p><div class="codesample"><table><tr><td scope="row"><pre>- (BOOL)respondsToSelector:(SEL)aSelector<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( [super respondsToSelector:aSelector] )<span></span></pre></td></tr><tr><td scope="row"><pre>        return YES;<span></span></pre></td></tr><tr><td scope="row"><pre>    else {<span></span></pre></td></tr><tr><td scope="row"><pre>        /* Here, test whether the aSelector message can     *<span></span></pre></td></tr><tr><td scope="row"><pre>         * be forwarded to another object and whether that  *<span></span></pre></td></tr><tr><td scope="row"><pre>         * object can respond to it. Return YES if it can.  */<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return NO;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>In addition to <code>respondsToSelector:</code> and <code>isKindOfClass:</code>, the <code>instancesRespondToSelector:</code> method should also mirror the forwarding algorithm. If protocols are used, the <code>conformsToProtocol:</code> method should likewise be added to the list. Similarly, if an object forwards any remote messages it receives, it should have a version of <code>methodSignatureForSelector:</code> that can return accurate descriptions of the methods that ultimately respond to the forwarded messages.</p><p>You might consider putting the forwarding algorithm somewhere in private code and have all these methods, <code>forwardInvocation:</code> included, call it.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40005191-CH9-SW19" title="Note"></a><p><strong>Note:</strong>&nbsp; This is an advanced technique, suitable only for situations where no other solution is possible. It is not intended as a replacement for inheritance. If you must make use of this technique, make sure you fully understand the behavior of the class doing the forwarding and the class you’re forwarding to.</p></div><p>The methods mentioned in this section are described in the <code>NSObject</code> class specification in the Foundation framework reference. For information on <code>invokeWithTarget:</code>, see the <code><a href="../../../Reference/Foundation/Classes/NSInvocation_Class/Reference/Reference.html#//apple_ref/occ/cl/NSInvocation" target="_top">NSInvocation</a></code> class specification in the Foundation framework reference.<a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_542"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_543"></a></p><a name="//apple_ref/doc/uid/TP40005191-CH9-87594" title="Dynamic Loading"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-SW20" title="Dynamic Loading"></a><h2>Dynamic Loading</h2><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_544"></a><p>An Objective-C program can load and link new classes<a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_545"></a> and categories<a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_546"></a> while it’s running. The new code is incorporated into the program and treated identically to classes and categories loaded at the start.</p><p>Dynamic loading can be used to do a lot of different things. For example, the various modules in the System Preferences application are dynamically loaded.</p><p>In the Cocoa environment, dynamic loading is commonly used to allow applications to be customized. Others can write modules that your program loads at runtime—much as Interface Builder loads custom palettes and the Mac OS X System Preferences application loads custom preference modules. The loadable modules extend what your application can do. They contribute to it in ways that you permit but could not have anticipated or defined yourself. You provide the framework, but others provide the code.</p><p>Although there is a runtime function that performs dynamic loading of Objective-C modules in Mach-O files (<code>objc_loadModules</code><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_547"></a>, defined in <code>objc/objc-load.h</code>), Cocoa’s <code>NSBundle</code><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_548"></a> class provides a significantly more convenient interface for dynamic loading—one that’s object-oriented and integrated with related services. See the <code><a href="../../../Reference/Foundation/Classes/NSBundle_Class/Reference/Reference.html#//apple_ref/occ/cl/NSBundle" target="_top">NSBundle</a></code> class specification in the Foundation framework reference for information on the <code>NSBundle</code> class and its use. See <em><a href="../../../../DeveloperTools/Conceptual/MachORuntime/index.html#//apple_ref/doc/uid/TP40000895" target="_top">Mac OS X ABI Mach-O File Format Reference</a></em><em></em> for information on Mach-O files.</p><a name="//apple_ref/doc/uid/TP40005191-CH9-103647" title="Remote Messaging"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-BAJIGHAF" title="Remote Messaging"></a><h2>Remote Messaging</h2><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_549"></a><p><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_550"></a>Like most other programming languages, Objective-C was initially designed for programs that are executed as a single process in a single address space.</p><p>Nevertheless, the object-oriented model, where communication takes place between relatively self-contained units through messages<a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_551"></a> that are resolved at runtime, would seem well suited for interprocess communication as well. It’s not hard to imagine Objective-C messages between objects that reside in different address spaces (that is, in different tasks) or in different threads of execution of the same task.</p><p>For example, in a typical server-client interaction, the client task might send its requests to a designated object in the server, and the server might target specific client objects for the notifications and other information it sends.</p><p>Or imagine an interactive application that needs to do a good deal of computation to carry out a user command. It could simply display a dialog telling the user to wait while it was busy, or it could isolate the processing work in a subordinate task, leaving the main part of the application free to accept user input. Objects in the two tasks would communicate through Objective-C messages.</p><p>Similarly, several separate processes could cooperate on the editing of a single document. There could be a different editing tool for each type of data in the document. One task might be in charge of presenting a unified onscreen user interface and of sorting out which user instructions are the responsibility of the various editing tools. Each cooperating task could be written in Objective-C, with Objective-C messages being the vehicle of communication between the user interface and the tools and between one tool and another.</p><a name="//apple_ref/doc/uid/TP40005191-CH9-103681" title="Distributed Objects"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-TPXREF154" title="Distributed Objects"></a><h3>Distributed Objects</h3><p>Remote messaging in Objective-C requires a runtime system that can establish connections between objects in different address spaces, recognize when a message is intended for an object in a remote address space, and transfer data from one address space to another. It must also mediate between the separate schedules of the two tasks; it has to hold messages until their remote receivers are free to respond to them.</p><p>Cocoa includes a <strong>distributed objects</strong><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_552"></a> architecture that is essentially this kind of extension to the runtime system. Using distributed objects, you can send Objective-C messages to objects in other tasks or have messages executed in other threads of the same task. (When remote messages are sent between two threads of the same task, the threads are treated exactly like threads in different tasks.) Note that Cocoa’s distributed objects system is built on top of the runtime system; it doesn’t alter the fundamental behavior<a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_553"></a> of your Cocoa objects.</p><p>To send a remote message, an application must first establish a connection with the remote receiver. Establishing the connection gives the application a proxy<a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_554"></a> for the remote object in its own address space. It then communicates with the remote object through the proxy. The proxy assumes the identity of the remote object; it has no identity of its own. The application is able to regard the proxy as if it were the remote object; for most purposes, it is the remote object.</p><p>Remote messaging is illustrated in <span class="content_text"><a href="ocRuntimeSystem.html#//apple_ref/doc/uid/TP40005191-CH9-103717">Figure 2-6</a></span>, where object A communicates with object B through a proxy, and messages for B wait in a queue until B is ready to respond to them:</p><br/><div><a name="//apple_ref/doc/uid/TP40005191-CH9-103717" title="Figure 2-6Remote Messages"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-BCIEGADD" title="Figure 2-6Remote Messages"></a><p><strong>Figure 2-6&nbsp;&nbsp;</strong>Remote Messages</p><img src = "../Art/messageproxy.gif" alt = "" width="438" height="108"></div><br/><p>The sender and receiver are in different tasks and are scheduled independently of each other. So there’s no guarantee that the receiver is free to accept a message when the sender is ready to send it. Therefore, arriving messages are placed in a queue and retrieved at the convenience of the receiving application.</p><p>A proxy doesn’t act on behalf of the remote object or need access to its class. It isn’t a copy of the object, but a lightweight substitute for it. In a sense, it’s transparent; it simply passes the messages it receives on to the remote receiver and manages the interprocess communication. Its main function is to provide a local address for an object that wouldn’t otherwise have one. A proxy isn’t fully transparent, however. For instance, a proxy doesn’t allow you to directly set and get an object’s instance variables.</p><p>A remote receiver is typically anonymous. Its class is hidden inside the remote application. The sending application doesn’t need to know how that application is designed or what classes it uses. It doesn’t need to use the same classes itself. All it needs to know is what messages the remote object responds to.</p><p>Because of this, an object that’s designated to receive remote messages advertises its interface in a formal protocol. Both the sending and the receiving application declare the protocol—they both import the same protocol declaration. The receiving application declares it because the remote object must conform to the protocol. The sending application declares it to inform the compiler about the messages it sends and because it may use the <code>conformsToProtocol:</code><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_555"></a> method and the <code>@protocol()</code><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_556"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_557"></a> directive to test the remote receiver. The sending application doesn’t have to implement any of the methods in the protocol; it declares the protocol only because it initiates messages to the remote receiver.</p><p>The distributed objects architecture, including the <code><a href="../../../Reference/Foundation/Classes/NSProxy_Class/Reference/Reference.html#//apple_ref/occ/cl/NSProxy" target="_top">NSProxy</a></code> and <code><a href="../../../Reference/Foundation/Classes/NSConnection_Class/Reference/Reference.html#//apple_ref/occ/cl/NSConnection" target="_top">NSConnection</a></code> classes, is documented in the Foundation framework reference and <em><a href="../../DistrObjects/index.html#//apple_ref/doc/uid/10000102i" target="_top">Distributed Objects Programming Topics</a></em>.</p><a name="//apple_ref/doc/uid/TP40005191-CH9-103764" title="Language Support"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-TPXREF155" title="Language Support"></a><h3>Language Support</h3><p>Remote messaging raises not only a number of intriguing possibilities for program design, it also raises some interesting issues for the Objective-C language. Most of the issues are related to the efficiency of remote messaging and the degree of separation that the two tasks should maintain while they’re communicating with each other.</p><p>So that programmers can give explicit instructions about the intent of a remote message, Objective-C defines six type qualifiers that can be used when declaring methods inside a formal protocol:</p><ul class="simple"><li><p><code>oneway</code></p></li><li><p><code>in</code></p></li><li><p><code>out</code></p></li><li><p><code>inout</code></p></li><li><p><code>bycopy</code></p></li><li><p><code>byref</code></p></li></ul><p>These modifiers are restricted to formal protocols; they can’t be used inside class and category declarations. However, if a class or category adopts a protocol, its implementation of the protocol methods can use the same modifiers that are used to declare the methods.</p><p>The following sections explain how these modifiers are used.</p><a name="//apple_ref/doc/uid/TP40005191-CH9-103850" title="Synchronous and Asynchronous Messages"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-TPXREF156" title="Synchronous and Asynchronous Messages"></a><h4>Synchronous and Asynchronous Messages</h4><p>Consider first a method with just a simple return value:</p><div class="codesample"><table><tr><td scope="row"><pre>- (BOOL)canDance;<span></span></pre></td></tr></table></div><p>When a <code>canDance</code> message is sent to a receiver in the same application, the method is invoked and the return value provided directly to the sender. But when the receiver is in a remote application, two underlying messages are required—one message to get the remote object to invoke the method, and the other message to send back the result of the remote calculation. This is illustrated in the figure below:</p><br/><div><a name="//apple_ref/doc/uid/TP40005191-CH9-103885" title="Figure 2-7Round-Trip Message"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-BCIDEFID" title="Figure 2-7Round-Trip Message"></a><p><strong>Figure 2-7&nbsp;&nbsp;</strong>Round-Trip Message</p><img src = "../Art/messagingproxyreturn.gif" alt = "" width="434" height="97"></div><br/><p>Most remote messages are, at bottom, two-way (or “round trip”) remote procedure calls<a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_558"></a> (RPCs) like this one. The sending application waits for the receiving application to invoke the method, complete its processing, and send back an indication that it has finished, along with any return information requested. Waiting for the receiver to finish, even if no information is returned, has the advantage of coordinating the two communicating applications, of keeping them both “in sync.” For this reason, round-trip messages are often called <strong>synchronous</strong><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_559"></a>. Synchronous messages are the default.</p><p>However, it’s not always necessary or a good idea to wait for a reply. Sometimes it’s sufficient simply to dispatch the remote message and return, allowing the receiver to get to the task when it can. In the meantime, the sender can go on to other things. Objective-C provides a return type modifier, <code>oneway</code>, to indicate that a method is used only for <strong>asynchronous</strong><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_560"></a> messages:</p><div class="codesample"><table><tr><td scope="row"><pre>- (oneway void)waltzAtWill;<span></span></pre></td></tr></table></div><p>Although <code>oneway</code> is a type qualifier (like <code>const</code>) and can be used in combination with a specific type name, such as <code>oneway float</code> or <code>oneway id</code>, the only such combination that makes any sense is <code>oneway void</code>. An asynchronous message can’t have a valid return value.</p><a name="//apple_ref/doc/uid/TP40005191-CH9-103959" title="Pointer Arguments"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-TPXREF157" title="Pointer Arguments"></a><h4>Pointer Arguments</h4><p>Next, consider methods that take pointer arguments<a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_561"></a>. A pointer can be used to pass information to the receiver by reference. When invoked, the method looks at what’s stored in the address it’s passed.</p><div class="codesample"><table><tr><td scope="row"><pre>- setTune:(struct tune *)aSong<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    tune = *aSong;<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The same sort of argument can also be used to return information by reference. The method uses the pointer to find where it should place information requested in the message.</p><div class="codesample"><table><tr><td scope="row"><pre>- getTune:(struct tune *)theSong<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>    *theSong = tune;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The way the pointer is used makes a difference in how the remote message is carried out. In neither case can the pointer simply be passed to the remote object unchanged; it points to a memory location in the sender’s address space and would not be meaningful in the address space of the remote receiver. The runtime system for remote messaging must make some adjustments behind the scenes.</p><p>If the argument is used to pass information by reference, the runtime system must dereference the pointer, ship the value it points to over to the remote application, store the value in an address local to that application, and pass that address to the remote receiver.</p><p>If, on the other hand, the pointer is used to return information by reference, the value it points to doesn’t have to be sent to the other application. Instead, a value from the other application must be sent back and written into the location indicated by the pointer.</p><p>In the first case, information is passed on the first leg of the round trip. In the second case, information is returned on the second leg of the round trip. Because these cases result in very different actions on the part of the runtime system for remote messaging, Objective-C provides type modifiers that can clarify the programmer’s intention:</p><ul class="spaceabove"><li class="li"><p>The type modifier<a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_562"></a><code>in</code> indicates that information is being passed in a message:</p><div class="codesample"><table><tr><td scope="row"><pre>- setTune:(in struct tune *)aSong;<span></span></pre></td></tr></table></div></li><li class="li"><p>The modifier <code>out</code> indicates that an argument is being used to return information by reference:</p><div class="codesample"><table><tr><td scope="row"><pre>- getTune:(out struct tune *)theSong;<span></span></pre></td></tr></table></div></li><li class="li"><p>A third modifier, <code>inout</code>, indicates that an argument is used both to provide information and to get information back:</p><div class="codesample"><table><tr><td scope="row"><pre>- adjustTune:(inout struct tune *)aSong;<span></span></pre></td></tr></table></div></li></ul><p>The Cocoa distributed objects system takes <code>inout</code> to be the default modifier for all pointer arguments except those declared <code>const</code>, for which <code>in</code> is the default. <code>inout</code> is the safest assumption but also the most time-consuming since it requires passing information in both directions. The only modifier that makes sense for arguments passed by value (non-pointers) is <code>in</code>. While <code>in</code> can be used with any kind of argument, <code>out</code> and <code>inout</code> make sense only for pointers.</p><p>In C, pointers are sometimes used to represent composite values. For example, a string is represented as a character pointer (<code>char *</code>). Although in notation and implementation there’s a level of indirection here, in concept there’s not. Conceptually, a string is an entity in and of itself, not a pointer to something else.</p><p>In cases like this, the distributed objects system automatically dereferences the pointer and passes whatever it points to as if by value. Therefore, the <code>out</code> and <code>inout</code> modifiers make no sense with simple character pointers. It takes an additional level of indirection in a remote message to pass or return a string by reference:</p><div class="codesample"><table><tr><td scope="row"><pre>- getTuneTitle:(out char **)theTitle;<span></span></pre></td></tr></table></div><p>The same is true of objects:</p><div class="codesample"><table><tr><td scope="row"><pre>- adjustRectangle:(inout Rectangle **)theRect;<span></span></pre></td></tr></table></div><p>These conventions are enforced at runtime, not by the compiler.</p><a name="//apple_ref/doc/uid/TP40005191-CH9-104225" title="Proxies and Copies"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-TPXREF158" title="Proxies and Copies"></a><h4>Proxies and Copies</h4><p>Finally, consider a method that takes an object as an argument:</p><div class="codesample"><table><tr><td scope="row"><pre>- danceWith:(id)aPartner;<span></span></pre></td></tr></table></div><p>A <code>danceWith:</code> message passes an object <code>id</code> to the receiver. If the sender and the receiver are in the same application, they would both be able to refer to the same <em>aPartner</em> object.</p><p>This is true even if the receiver is in a remote application, except that the receiver needs to refer to the object through a proxy (since the object isn’t in its address space). The pointer that <code>danceWith:</code> delivers to a remote receiver is actually a pointer to the proxy. Messages sent to the proxy would be passed across the connection to the real object and any return information would be passed back to the remote application.</p><p>There are times when proxies may be unnecessarily inefficient, when it’s better to send a copy of the object to the remote process so that it can interact with it directly in its own address space. To give programmers a way to indicate that this is intended, Objective-C provides a <code>bycopy</code> type modifier:</p><div class="codesample"><table><tr><td scope="row"><pre>- danceWith:(bycopy id)aClone;<span></span></pre></td></tr></table></div><p><code>bycopy</code> can also be used for return values:</p><div class="codesample"><table><tr><td scope="row"><pre>- (bycopy)dancer;<span></span></pre></td></tr></table></div><p>It can similarly be used with <code>out</code> to indicate that an object returned by reference should be copied rather than delivered in the form of a proxy:</p><div class="codesample"><table><tr><td scope="row"><pre>- getDancer:(bycopy out id *)theDancer;<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40005191-CH9-SW21" title="Note"></a><p><strong>Note:</strong>&nbsp;When a copy of an object is passed to another application, it cannot be anonymous. The application that receives the object must have the class of the object loaded in its address space.</p></div><p><code>bycopy</code> makes so much sense for certain classes—classes that are intended to contain a collection of other objects, for instance—that often these classes are written so that a copy is sent to a remote receiver, instead of the usual reference. You can override this behavior<a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_563"></a> with <code>byref</code>, however, thereby specifying that objects passed to a method or objects returned from a method should be passed or returned by reference. Since passing by reference is the default behavior for the vast majority of Objective-C objects, you will rarely, if ever, make use of the <code>byref</code> keyword.</p><p>The only type that it makes sense for <code>bycopy</code> or <code>byref</code> to modify is an object, whether dynamically typed <code>id</code> or statically typed by a class name.</p><p>Although <code>bycopy</code> and <code>byref</code> can’t be used inside class and category declarations, they can be used within formal protocols. For instance, you could write a formal protocol <code>foo</code> as follows:</p><div class="codesample"><table><tr><td scope="row"><pre>@Protocol foo<span></span></pre></td></tr><tr><td scope="row"><pre>- (bycopy)array;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>A class or category can then adopt your protocol <code>foo</code>. This allows you to construct protocols so that they provide “hints” as to how objects should be passed and returned by the methods described by the protocol.<a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_564"></a></p><a name="//apple_ref/doc/uid/TP40005191-CH9-113054" title="Type Encodings"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-TPXREF165" title="Type Encodings"></a><h2>Type Encodings</h2><p><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_565"></a>To assist the runtime system, the compiler encodes<a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_566"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_567"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_568"></a> the return<a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_569"></a> and argument types<a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_570"></a> for each method in a character string and associates the string with the method selector. The coding scheme it uses is also useful in other contexts and so is made publicly available with the <code>@encode()</code> compiler directive. When given a type specification, <code>@encode()</code> returns a string encoding that type. The type can be a basic type such as an <code>int</code>, a pointer, a tagged structure or union, or a class name—anything, in fact, that can be used as an argument to the C <code>sizeof()</code> operator.</p><div class="codesample"><table><tr><td scope="row"><pre>char *buf1 = @encode(int **);<span></span></pre></td></tr><tr><td scope="row"><pre>char *buf2 = @encode(struct key);<span></span></pre></td></tr><tr><td scope="row"><pre>char *buf3 = @encode(Rectangle);<span></span></pre></td></tr></table></div><p>The table below lists the type codes. Note that many of them overlap with the codes you use when encoding an object for purposes of archiving or distribution. However, there are codes listed here that you can’t use when writing a coder, and there are codes that you may want to use when writing a coder that aren’t generated by <code>@encode()</code><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_571"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_572"></a>. (See the <code><a href="../../../Reference/Foundation/Classes/NSCoder_Class/Reference/NSCoder.html#//apple_ref/occ/cl/NSCoder" target="_top">NSCoder</a></code> class specification in the Foundation Framework reference for more information on encoding objects for archiving or distribution.)</p><a name="//apple_ref/doc/uid/TP40005191-CH9-105283" title="Table 2-1Objective-C type encodings"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-BABGGCCF" title="Table 2-1Objective-C type encodings"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 2-1&nbsp;&nbsp;</strong>Objective-C type encodings</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Code</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Meaning</p></th></tr><tr><td  scope="row"><p><code>c</code></p></td><td ><p>A <code>char</code></p></td></tr><tr><td  scope="row"><p><code>i</code></p></td><td ><p>An <code>int</code></p></td></tr><tr><td  scope="row"><p><code>s</code></p></td><td ><p>A <code>short</code></p></td></tr><tr><td  scope="row"><p><code>l</code></p></td><td ><p>A <code>long</code></p></td></tr><tr><td  scope="row"><p><code>q</code></p></td><td ><p>A <code>long long</code></p></td></tr><tr><td  scope="row"><p><code>C</code></p></td><td ><p>An <code>unsigned char</code></p></td></tr><tr><td  scope="row"><p><code>I</code></p></td><td ><p>An <code>unsigned int</code></p></td></tr><tr><td  scope="row"><p><code>S</code></p></td><td ><p>An <code>unsigned short</code></p></td></tr><tr><td  scope="row"><p><code>L</code></p></td><td ><p>An <code>unsigned long</code></p></td></tr><tr><td  scope="row"><p><code>Q</code></p></td><td ><p>An <code>unsigned long long</code></p></td></tr><tr><td  scope="row"><p><code>f</code></p></td><td ><p>A <code>float</code></p></td></tr><tr><td  scope="row"><p><code>d</code></p></td><td ><p>A <code>double</code></p></td></tr><tr><td  scope="row"><p><code>B</code></p></td><td ><p>A C++ <code>bool</code> or a C99 <code>_Bool</code></p></td></tr><tr><td  scope="row"><p><code>v</code></p></td><td ><p>A <code>void</code></p></td></tr><tr><td  scope="row"><p><code>*</code></p></td><td ><p>A character string (<code>char *</code>)</p></td></tr><tr><td  scope="row"><p><code>@</code></p></td><td ><p>An object (whether statically typed or typed <code>id</code>)</p></td></tr><tr><td  scope="row"><p><code>#</code></p></td><td ><p>A class object (<code>Class</code>)</p></td></tr><tr><td  scope="row"><p><code>:</code></p></td><td ><p>A method selector (<code>SEL</code>)</p></td></tr><tr><td  scope="row"><p>[<em>array type</em>] </p></td><td ><p>An array</p></td></tr><tr><td  scope="row"><p>{<em>name=type...</em>}</p></td><td ><p>A structure</p></td></tr><tr><td  scope="row"><p>(<em>name</em>=<em>type...</em>)</p></td><td ><p>A union</p></td></tr><tr><td  scope="row"><p><code>b</code>num</p></td><td ><p>A bit field of <em>num</em> bits</p></td></tr><tr><td  scope="row"><p><code>^</code>type</p></td><td ><p>A pointer to <em>type</em></p></td></tr><tr><td  scope="row"><p><code>?</code></p></td><td ><p>An unknown type (among other things, this code is used for function pointers)</p></td></tr></table></div><p>The type code for an array is enclosed within square brackets; the number of elements in the array is specified immediately after the open bracket, before the array type. For example, an array of 12 pointers to <code>float</code>s would be encoded as:</p><div class="codesample"><table><tr><td scope="row"><pre>[12^f]<span></span></pre></td></tr></table></div><p>Structures are specified within braces, and unions within parentheses. The structure tag is listed first, followed by an equal sign and the codes for the fields of the structure listed in sequence. For example, the structure</p><div class="codesample"><table><tr><td scope="row"><pre>typedef struct example {<span></span></pre></td></tr><tr><td scope="row"><pre>    id   anObject;<span></span></pre></td></tr><tr><td scope="row"><pre>    char *aString;<span></span></pre></td></tr><tr><td scope="row"><pre>    int  anInt;<span></span></pre></td></tr><tr><td scope="row"><pre>} Example;<span></span></pre></td></tr></table></div><p>would be encoded like this:</p><div class="codesample"><table><tr><td scope="row"><pre>{example=@*i}<span></span></pre></td></tr></table></div><p>The same encoding results whether the defined type name (<code>Example</code>) or the structure tag (<code>example</code>) is passed to <code>@encode()</code>. The encoding for a structure pointer carries the same amount of information about the structure’s fields:</p><div class="codesample"><table><tr><td scope="row"><pre>^{example=@*i}<span></span></pre></td></tr></table></div><p>However, another level of indirection removes the internal type specification:</p><div class="codesample"><table><tr><td scope="row"><pre>^^{example}<span></span></pre></td></tr></table></div><p>Objects are treated like structures. For example, passing the <code>NSObject</code> class name to <code>@encode()</code> yields this encoding:</p><div class="codesample"><table><tr><td scope="row"><pre>{NSObject=#}<span></span></pre></td></tr></table></div><p>The <code>NSObject</code> class declares just one instance variable, <code>isa</code>, of type Class.</p><p>Note that although the <code>@encode()</code> directive doesn’t return them, the runtime system uses the additional encodings listed in <span class="content_text">Table 2-2</span> for type qualifiers when they’re used to declare methods in a protocol<a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_573"></a>.</p><a name="//apple_ref/doc/uid/TP40005191-CH9-105288" title="Table 2-2Objective-C method encodings"></a><a name="//apple_ref/doc/uid/TP40005191-CH9-BABHAIFA" title="Table 2-2Objective-C method encodings"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 2-2&nbsp;&nbsp;</strong>Objective-C method encodings</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Code</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Meaning</p></th></tr><tr><td  scope="row"><p><code>r</code></p></td><td ><p><code>const</code><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_574"></a></p></td></tr><tr><td  scope="row"><p><code>n</code></p></td><td ><p><code>in</code><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_575"></a></p></td></tr><tr><td  scope="row"><p><code>N</code></p></td><td ><p><code>inout</code><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_576"></a></p></td></tr><tr><td  scope="row"><p><code>o</code></p></td><td ><p><code>out</code><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_577"></a></p></td></tr><tr><td  scope="row"><p><code>O</code></p></td><td ><p><code>bycopy</code><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_578"></a></p></td></tr><tr><td  scope="row"><p><code>R</code></p></td><td ><p><code>byref</code><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_579"></a></p></td></tr><tr><td  scope="row"><p><code>V</code></p></td><td ><p><code>oneway</code><a name="//apple_ref/doc/uid/TP40005191-CH9-DontLinkElementID_580"></a></p></td></tr></table></div>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="ocLanguage.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="ocLanguageSummary.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-06-09<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/OOPandObjC1/Articles/ocRuntimeSystem.html%3Fid%3DTP40005191-1.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/OOPandObjC1/Articles/ocRuntimeSystem.html%3Fid%3DTP40005191-1.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/OOPandObjC1/Articles/ocRuntimeSystem.html%3Fid%3DTP40005191-1.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>