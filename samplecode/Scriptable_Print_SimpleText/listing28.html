<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Scriptable Print SimpleText - /TextFile.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxPrinting-date.html">Printing</a> &gt; <A HREF="javascript:location.replace('index.html');">Scriptable Print SimpleText</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Printing/index.html" target="_blank">Reference Library > Printing</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Scriptable Print SimpleText</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/TextFile.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/AboutBox.c</option>
<option value="listing2.html">/AboutBox.h</option>
<option value="listing3.html">/AboutBox.r</option>
<option value="listing4.html">/aete.r</option>
<option value="listing5.html">/AGFile.h</option>
<option value="listing6.html">/Clipboard.c</option>
<option value="listing7.html">/Clipboard.h</option>
<option value="listing8.html">/Clipboard.r</option>
<option value="listing9.html">/CoercePrGeneral.h</option>
<option value="listing10.html">/ExtendPrintRecord.c</option>
<option value="listing11.html">/ExtendPrintRecord.h</option>
<option value="listing12.html">/Localize.r</option>
<option value="listing13.html">/MacIncludes.h</option>
<option value="listing14.html">/MovieFile.c</option>
<option value="listing15.html">/MovieFile.h</option>
<option value="listing16.html">/MovieFile.r</option>
<option value="listing17.html">/PICTFile.c</option>
<option value="listing18.html">/PICTFile.h</option>
<option value="listing19.html">/PICTFile.r</option>
<option value="listing20.html">/PrintAETypes.h</option>
<option value="listing21.html">/ScriptablePrinting.c</option>
<option value="listing22.html">/ScriptablePrinting.h</option>
<option value="listing23.html">/SimpleText.c</option>
<option value="listing24.html">/SimpleText.h</option>
<option value="listing25.html">/SimpleText.r</option>
<option value="listing26.html">/TextDrag.c</option>
<option value="listing27.html">/TextFile.a</option>
<option value="listing28.html">/TextFile.c</option>
<option value="listing29.html">/TextFile.h</option>
<option value="listing30.html">/TextFile.r</option>
<option value="listing31.html">/ThreeDMetafile.c</option>
<option value="listing32.html">/ThreeDMetafile.h</option>
<option value="listing33.html">/ThreeDMetafile.r</option></select>
				</p>
				</form>
				<p><strong><a href="Scriptable_Print_SimpleText.zip">Download Sample</a></strong> (&#147;Scriptable_Print_SimpleText.zip&#148;, 212.5K)<BR>
<strong><a href="Scriptable_Print_SimpleText.dmg">Download Sample</a></strong> (&#147;Scriptable_Print_SimpleText.dmg&#148;, 290.1K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/***  File:    TextFile.c****  Contains:  Text file support for simple text application.****  Version:  SimpleText 1.4 or later**** Copyright 1993-1999 Apple Computer. All rights reserved.****  You may incorporate this sample code into your applications without**  restriction, though the sample code has been provided &quot;AS IS&quot; and the**  responsibility for its operation is 100% yours.  However, what you are**  not permitted to do is to redistribute the source as &quot;DSC Sample Code&quot;**  after having made changes. If you're going to re-distribute the source,**  we require that you make it clear in the source that the code was**  descended from Apple Sample Code, but that you've made changes.*/#include &quot;MacIncludes.h&quot;#include &quot;TextFile.h&quot;#pragma segment Text// --------------------------------------------------------------------------------------------------------------// INTERNAL DEFINES// --------------------------------------------------------------------------------------------------------------#define kOnePageWidth     600      // preferred width of a window#define kMargins      4      // margins in window#define kPrintMargins    8      // margins in printing window#define kGXPrintMargins    10      // margins in printing a GX window#define kPictureBase    1000    // resource base ID for PICTs in documents#define kSoundBase      10000    // resource base ID for 'snd 's in documents// resources for controling printing#define kFormResource    'form'  #define kFormFeed      0x00000001  // form feed after this line#define  kContentsListID    10000    // resource ID for STR# contents menu     // some memory requirements#define kPrefBufferSize    90*1024#define kMinBufferSize    5*1024#define kDeleteKey      8#define kForwardDeleteKey  0x75extern pascal void AsmClikLoop();#define ABS(n)        (((n) &lt; 0) ? -(n) : (n))// --------------------------------------------------------------------------------------------------------------// GLOBALS USED ONLY BY THESE ROUTINES// --------------------------------------------------------------------------------------------------------------// These variables are used for speech, notice that on purpose we only// support a single channel at a time.static SpeechChannel  gSpeechChannel = nil;    static VoiceSpec    gCurrentVoice;static Ptr        gSpeakPtr = nil;static Boolean      gAddedVoices = false;static Str31      gPictMarker1, gPictMarker2;// --------------------------------------------------------------------------------------------------------------// EXTERNAL FUNCTIONS// --------------------------------------------------------------------------------------------------------------extern OSErr  TextDragTracking(WindowRef pWindow, void *pData, DragReference theDragRef, short message);extern OSErr  TextDragReceive(WindowRef pWindow, void *refCon, DragReference theDragRef);extern Boolean  DragText(WindowRef pWindow, void *pData, EventRecord *pEvent, RgnHandle hilightRgn);// --------------------------------------------------------------------------------------------------------------// INTERNAL ROUTINES// --------------------------------------------------------------------------------------------------------------static void TextAddContentsMenu(WindowDataPtr pData);static void TextRemoveContentsMenu(WindowDataPtr pData);static OSErr TextGetContentsListItem(WindowDataPtr pData, short itemNum, StringPtr menuStr, StringPtr searchStr, short *totalItems);static OSErr TextAdjustContentsMenu(WindowDataPtr pData);// --------------------------------------------------------------------------------------------------------------// UNDO UTILITY FUNCTIONS// --------------------------------------------------------------------------------------------------------------OSErr SaveCurrentUndoState(WindowDataPtr pData, short newCommandID){  OSErr    anErr = noErr;  TEHandle  hTE = ((TextDataPtr) pData)-&gt;hTE;    // this is only a new command if:  //  the command ID is different  // OR  //  the selection is a range, and not equal to the old one  if   (      ( ((TextDataPtr) pData)-&gt;prevCommandID != newCommandID )    ||      (        ( (**hTE).selStart != (**hTE).selEnd )      ||        ( ABS((**hTE).selStart - ((TextDataPtr) pData)-&gt;prevSelStart) &gt; 1 )      )    )    {    Handle    tempHandle;    Size    tempSize;        // if we don't have save handles, make em!    if (!((TextDataPtr) pData)-&gt;prevText)      {      ((TextDataPtr) pData)-&gt;prevText = NewHandle(0);      anErr = MemError();      nrequire(anErr, MakeTextSave);      }    if  (!((TextDataPtr) pData)-&gt;prevStyle)       {      ((TextDataPtr) pData)-&gt;prevStyle = NewHandle(0);      anErr = MemError();      nrequire(anErr, MakeStyleSave);      }          // grow the save handles and block move into them    tempHandle = (**hTE).hText;    tempSize = GetHandleSize(tempHandle);    SetHandleSize( ((TextDataPtr) pData)-&gt;prevText, tempSize);    anErr = MemError();    nrequire(anErr, GrowTextSave);    BlockMoveData(*tempHandle, * ((TextDataPtr) pData)-&gt;prevText, tempSize );    tempHandle = (Handle) TEGetStyleHandle(hTE);    tempSize = GetHandleSize(tempHandle);    SetHandleSize( ((TextDataPtr) pData)-&gt;prevStyle, tempSize);    anErr = MemError();    nrequire(anErr, GrowTextSave);    BlockMoveData(*tempHandle, * ((TextDataPtr) pData)-&gt;prevStyle, tempSize );    // save length    ((TextDataPtr) pData)-&gt;prevLength = (**hTE).teLength;    ((TextDataPtr) pData)-&gt;beforeSelStart = (**hTE).selStart;    ((TextDataPtr) pData)-&gt;beforeSelEnd = (**hTE).selEnd;    }    // save start and end of the selection  ((TextDataPtr) pData)-&gt;prevSelStart = (**hTE).selStart;  // if we didn't have any problems, then we can undo this operation  ((TextDataPtr) pData)-&gt;prevCommandID = newCommandID;  return(noErr);  // EXCEPTION HANDLINGGrowStyleSave:GrowTextSave:MakeStyleSave:MakeTextSave:  // can't undo because of an error   // (at some point might warn the user, but that's probably more annoying)  ((TextDataPtr) pData)-&gt;prevCommandID = cNull;    return(anErr);  } // SaveCurrentUndoState// --------------------------------------------------------------------------------------------------------------static void PerformUndo(WindowDataPtr pData){  if (((TextDataPtr) pData)-&gt;prevCommandID != cNull)    {    TEHandle  hTE = ((TextDataPtr) pData)-&gt;hTE;    long    tempLong;        // undo text    tempLong = (long) (**hTE).hText;    (**hTE).hText = ((TextDataPtr) pData)-&gt;prevText;    ((TextDataPtr) pData)-&gt;prevText = (Handle)tempLong;    // undo length    tempLong = (long) (**hTE).teLength;    (**hTE).teLength = ((TextDataPtr) pData)-&gt;prevLength;    ((TextDataPtr) pData)-&gt;prevLength = tempLong;    // undo style    tempLong = (long) TEGetStyleHandle(hTE);    if (HandToHand((Handle*) &amp;tempLong) == noErr)      {      TESetStyleHandle( (TEStyleHandle) ((TextDataPtr) pData)-&gt;prevStyle, hTE );      ((TextDataPtr) pData)-&gt;prevStyle = (Handle)tempLong;      }          // undo selection      {      short  start, end;            start = ((TextDataPtr) pData)-&gt;beforeSelStart;      end = ((TextDataPtr) pData)-&gt;beforeSelEnd;      ((TextDataPtr) pData)-&gt;prevSelStart = (**hTE).selStart;      TESetSelect(start, end, hTE);      }        }    } // PerformUndo// --------------------------------------------------------------------------------------------------------------// TEXT EDIT UTILITY FUNCTIONS// --------------------------------------------------------------------------------------------------------------static long CalculateTextEditHeight(TEHandle hTE){  long  result;  short  length;    result = TEGetHeight(32767, 0, hTE);  length = (**hTE).teLength;    // Text Edit doesn't return the height of the last character, if that  // character is a &lt;cr&gt;.  So if we see that, we go grab the height of  // that last character and add it into the total height.  if ( (length) &amp;&amp; ( (*(**hTE).hText)[length-1] == '\n') )    {    TextStyle  theStyle;    short    theHeight;    short    theAscent;    TEGetStyle(length, &amp;theStyle, &amp;theHeight, &amp;theAscent, hTE);    result += theHeight;    }  return result;} // CalculateTextEditHeight// --------------------------------------------------------------------------------------------------------------void AdjustTE(WindowDataPtr pData, Boolean doScroll){  TEPtr    te;  short    value;  short    prevValue;    te = *((TextDataPtr) pData)-&gt;hTE;  prevValue = GetControlValue(pData-&gt;vScroll);  value = te-&gt;viewRect.top - te-&gt;destRect.top;  SetControlValue(pData-&gt;vScroll, value);  te = *((TextDataPtr) pData)-&gt;hTE;  if (doScroll)    {    short  hScroll = te-&gt;viewRect.left - te-&gt;destRect.left;    short  vScroll = value - prevValue;    if ((hScroll != 0) || (vScroll != 0))      TEScroll(hScroll, vScroll, ((TextDataPtr) pData)-&gt;hTE);    }        } // AdjustTE// --------------------------------------------------------------------------------------------------------------static void RecalcTE(WindowDataPtr pData, Boolean doInval){  Rect  viewRect, destRect;  short  oldOffset;    destRect = (**((TextDataPtr) pData)-&gt;hTE).destRect;  viewRect = (**((TextDataPtr) pData)-&gt;hTE).viewRect;  oldOffset = destRect.top - viewRect.top;    viewRect = pData-&gt;contentRect;        InsetRect(&amp;viewRect, kMargins, kMargins);  destRect = viewRect;    OffsetRect(&amp;destRect, 0, oldOffset);    (**((TextDataPtr) pData)-&gt;hTE).viewRect = viewRect;  (**((TextDataPtr) pData)-&gt;hTE).destRect = destRect;    TECalText(((TextDataPtr) pData)-&gt;hTE);  if (doInval)    InvalRect(&amp;qd.thePort-&gt;portRect);  } // RecalcTE// --------------------------------------------------------------------------------------------------------------pascal TEClickLoopUPP GetOldClickLoop(void){  return ((TextDataPtr) FrontWindow())-&gt;docClick;  } // GetOldClikLooppascal void TextClickLoop(void){    WindowRef  window;  RgnHandle  region;    window = FrontWindow();  region = NewRgn();  GetClip(region);          /* save clip */  ClipRect(&amp;GetWindowPort(window)-&gt;portRect);  ((TextDataPtr) window)-&gt;insideClickLoop = true;    AdjustScrollBars(window, false, false, nil);  ((TextDataPtr) window)-&gt;insideClickLoop = false;  SetClip(region);          /* restore clip */  DisposeRgn(region);} // TextClickLoop#if GENERATINGPOWERPCstatic pascal Boolean CClikLoop(TEPtr pTE){  CallTEClickLoopProc(GetOldClickLoop(), pTE);    TextClickLoop();    return(true);  } // CClikLoop  static RoutineDescriptor gMyClickLoopRD = BUILD_ROUTINE_DESCRIPTOR(uppTEClickLoopProcInfo, CClikLoop);  static TEClickLoopUPP gMyClickLoop = &amp;gMyClickLoopRD;#else  static TEClickLoopUPP gMyClickLoop = NewDrawHookProc(AsmClikLoop);#endif// --------------------------------------------------------------------------------------------------------------#if GENERATINGPOWERPCpascal void MyDrawHook ( unsigned short offset, unsigned short textLen,   Ptr textPtr, TEPtr tePtr, TEHandle teHdl )#elsepascal void MyDrawGlue();pascal void MyDrawHook ( TEHandle teHdl, TEPtr tePtr, Ptr textPtr, short textLen, short offset )#endif{#pragma unused  ( teHdl, tePtr)  register short      drawLen = 0;  register Ptr      drawPtr;    drawPtr = textPtr + (long)offset;    while ( textLen--)    {    if ( *drawPtr == 0xCA &amp;&amp;       ( *(drawPtr - 1) == 0x0D || *tePtr-&gt;hText == textPtr) )      {      DrawText( textPtr, offset, drawLen);      DrawChar( '\040');      offset += drawLen + 1;      drawLen = 0;      }    else      {      ++drawLen;      }    ++drawPtr;    }    DrawText( textPtr, offset, drawLen);  } // MyDrawHook#if GENERATINGCFM  static RoutineDescriptor gMyDrawGlueRD = BUILD_ROUTINE_DESCRIPTOR(uppDrawHookProcInfo, MyDrawHook);  static DrawHookUPP gMyDrawGlue = &amp;gMyDrawGlueRD;#else  static DrawHookUPP gMyDrawGlue = NewDrawHookProc(MyDrawGlue);#endif// --------------------------------------------------------------------------------------------------------------static void DisposeOfSpeech(Boolean throwAway){  if (gSpeechChannel)    {    (void) StopSpeech( gSpeechChannel );    if (throwAway)      {      (void) DisposeSpeechChannel( gSpeechChannel );      gSpeechChannel = nil;      }    }  if (gSpeakPtr)    {    DisposePtr(gSpeakPtr);    gSpeakPtr = nil;    }    } // DisposeOfSpeech// --------------------------------------------------------------------------------------------------------------static Boolean FindNextPicture(Handle textHandle, short *offset, short *delta){  long result;    // marker at begining of document means a picture there  if ( (*offset == 0) &amp;&amp; ( (*(unsigned char*)(*textHandle + (*offset))) == 0xCA) )    {    *delta = 1;    return true;    }  if (gPictMarker1[0] != 0)    {    result = Munger(textHandle, *offset, &amp;gPictMarker1[1], gPictMarker1[0], nil, 0);    if (result &gt;= 0)      {      *offset = result;      *delta = gPictMarker1[0];      return true;      }    }  if (gPictMarker2[0] != 0)    {    result = Munger(textHandle, *offset, &amp;gPictMarker2[1], gPictMarker2[0], nil, 0);    if (result &gt;= 0)      {      *offset = result;      *delta = gPictMarker2[0];      return true;      }    }      *delta = 1;  return false;  } // FindNextPicture// --------------------------------------------------------------------------------------------------------------static Boolean LineHasPageBreak(short lineNum, TEHandle hTE){  Boolean    result = false;  short    offset, delta, lineStartOffset;  short    textLength;  Handle    textHandle;  short    pictIndex = 0;    textHandle = (** hTE).hText;  lineStartOffset = (**hTE).lineStarts[lineNum];  textLength = (**hTE).lineStarts[lineNum+1];    offset = 0;  while (offset &lt; textLength)    {    if (FindNextPicture(textHandle, &amp;offset, &amp;delta))      {      Handle  formHandle;            formHandle = Get1Resource(kFormResource, kFormResource + pictIndex);      if (formHandle)        {        long  options = **(long**)formHandle;                ReleaseResource(formHandle);        if ( (options &amp; kFormFeed) &amp;&amp; (offset &gt;= lineStartOffset) &amp;&amp; (offset &lt; textLength) )          {          result = true;          break;          }        }      ++pictIndex;      }        offset += delta;    }      return(result);  } // LineHasPageBreak// --------------------------------------------------------------------------------------------------------------#define USE_PICT_SPOOL_CACHE 1enum {kSpoolCacheBlockSize = 1024};    // 1K is arbitrary, perhaps could be tunedstatic Handle  gSpoolPicture;static long    gSpoolOffset;static Handle  gSpoolCacheBlock;static long    gSpoolCacheOffset;static long    gSpoolCacheSize;// --------------------------------------------------------------------------------------------------------------/*  ReadPartialResource is very painful over slow links such as ARA or ISDN. This code implements a simple  cache that vastly improves the performance of displaying embedded pictures over a slow network link.  The cache also improves scrolling performance in documents with many embedded pictures, even on local  volumes.*/static short ReadPartialData(Ptr dataPtr, short byteCount){#if USE_PICT_SPOOL_CACHE  if (gSpoolCacheBlock == NULL)    {    gSpoolCacheBlock = NewHandle(kSpoolCacheBlockSize);    if (gSpoolCacheBlock != NULL)      {      long  cacheBytes  = GetResourceSizeOnDisk(gSpoolPicture) - gSpoolOffset;            if (cacheBytes &gt; kSpoolCacheBlockSize)        cacheBytes = kSpoolCacheBlockSize;            HLock(gSpoolCacheBlock);      ReadPartialResource(gSpoolPicture, gSpoolOffset, *gSpoolCacheBlock, cacheBytes);      HUnlock(gSpoolCacheBlock);            gSpoolCacheOffset = gSpoolOffset;      gSpoolCacheSize = cacheBytes;      }    }    // if the requested data is entirely present in the cache block, get it from there\xC9  if (gSpoolCacheBlock != NULL &amp;&amp;    gSpoolOffset &gt;= gSpoolCacheOffset &amp;&amp; gSpoolOffset + byteCount &lt;= gSpoolCacheOffset + gSpoolCacheSize)    {    BlockMoveData(*gSpoolCacheBlock + (gSpoolOffset - gSpoolCacheOffset), dataPtr, byteCount);    return byteCount;    }  // \xC9else read it directly from disk, and force the cache block to be filled with new data  else    {    ReadPartialResource(gSpoolPicture, gSpoolOffset, dataPtr, byteCount);    if (gSpoolCacheBlock != NULL)      {      DisposeHandle(gSpoolCacheBlock);      gSpoolCacheBlock = NULL;      }    return byteCount;    }#else  ReadPartialResource(gSpoolPicture, gSpoolOffset, dataPtr, byteCount);  return byteCount;  #endif  } // ReadPartialData// --------------------------------------------------------------------------------------------------------------static pascal void GetPartialPICTData(Ptr dataPtr,short byteCount){  while (byteCount &gt; 0)  {    short  readBytes  = ReadPartialData(dataPtr, byteCount);        byteCount -= readBytes;    dataPtr += readBytes;        gSpoolOffset += readBytes;  }  } // GetPartialPICTData#if GENERATINGCFM  static RoutineDescriptor gGetPartialPICTDataRD = BUILD_ROUTINE_DESCRIPTOR(uppQDGetPicProcInfo, GetPartialPICTData);  static QDGetPicUPP gGetPartialPICTData = &amp;gGetPartialPICTDataRD;#else  static QDGetPicUPP gGetPartialPICTData = NewQDGetPicProc(GetPartialPICTData);#endif// --------------------------------------------------------------------------------------------------------------static void SpoolDrawPicture(Handle spoolPicture, PicHandle pictureHeader, Rect *pRect){  CQDProcs  spoolProcs;  QDProcs    *oldProcs;  gSpoolPicture = spoolPicture;  gSpoolOffset = sizeof(Picture);    if (gMachineInfo.theEnvirons.hasColorQD)    SetStdCProcs(&amp;spoolProcs);  else    SetStdProcs((QDProcs*) &amp;spoolProcs);      spoolProcs.getPicProc = gGetPartialPICTData;  oldProcs = qd.thePort-&gt;grafProcs;  qd.thePort-&gt;grafProcs = (QDProcs*) &amp;spoolProcs;    DrawPicture(pictureHeader, pRect);  qd.thePort-&gt;grafProcs = oldProcs;    if (gSpoolCacheBlock != NULL)    {    DisposeHandle(gSpoolCacheBlock);    gSpoolCacheBlock = NULL;    }  } // SpoolDrawPicture// --------------------------------------------------------------------------------------------------------------static void DrawPictures( WindowDataPtr pData, TEHandle hTE){  Handle  textHandle;  long  textLength;  short  oldResFile;  short  pictIndex;  short  numPicts;    oldResFile = CurResFile();  UseResFile(pData-&gt;resRefNum);    numPicts = Count1Resources('PICT');  pictIndex = 0;    if (numPicts != 0)    {    short        offset, delta;    RgnHandle      oldClip;    Rect        theRect;    Rect        viewRect;        viewRect = theRect = (** hTE).viewRect;    // intersect our viewing area with the actual clip to avoid    // drawing over the scroll bars      {      RgnHandle  newClip = NewRgn();            oldClip = NewRgn();      GetClip(oldClip);      RectRgn(newClip, &amp;theRect);      SectRgn(oldClip, newClip, newClip);      SetClip(newClip);      }    textHandle = (** hTE).hText;    textLength = (** hTE).teLength;        offset = 0;    while (offset &lt; textLength)      {      if (FindNextPicture(textHandle, &amp;offset, &amp;delta))        {        Handle    pictHandle;        Point    picturePoint = TEGetPoint(offset, hTE);                SetResLoad(false);        pictHandle = Get1Resource('PICT', kPictureBase + pictIndex);        SetResLoad(true);        if (pictHandle)          {          PicHandle  pictHeader = (PicHandle)NewHandle(sizeof(Picture) + sizeof(long)*8);                    if (pictHeader)            {            HLock((Handle) pictHeader);            ReadPartialResource(pictHandle, 0, (Ptr)*pictHeader, GetHandleSize((Handle)pictHeader));            HUnlock((Handle) pictHeader);                        // calculate where to draw the picture, this location is            // computed by:            //  1) the frame of the original picture, normalized to 0,0            //  2) the location of the non-breaking space character            //  3) centering the picture on the content frame horizontally            //  4) subtracting off the line-height of the character                        GetPICTRectangleAt72dpi(pictHeader, &amp;theRect);            OffsetRect(&amp;theRect, -theRect.left, -theRect.top);            OffsetRect(&amp;theRect,                       theRect.left +                      ((viewRect.right - viewRect.left) &gt;&gt; 1) -                      ((theRect.right - theRect.left) &gt;&gt; 1),                    picturePoint.v-theRect.top - pData-&gt;vScrollAmount);              // only draw the picture if it will be visible (vastly improves scrolling            // performance in documents with many embedded pictures)                        if (RectInRgn(&amp;theRect, qd.thePort-&gt;clipRgn))              SpoolDrawPicture(pictHandle, pictHeader, &amp;theRect);            }          ReleaseResource((Handle) pictHandle);          }        ++pictIndex;        offset += delta;        }      else        break;      }            SetClip(oldClip);    DisposeRgn(oldClip);    }      UseResFile(oldResFile);  } // DrawPictures// --------------------------------------------------------------------------------------------------------------static void UpdateFileInfo(FSSpec *pSpec, Boolean documentIsText){  FInfo  theInfo;  FSpGetFInfo(pSpec, &amp;theInfo);  theInfo.fdCreator = 'ttxt';  // set the stationary bit, if we must  if (!documentIsText)    {    theInfo.fdFlags |= kIsStationery;    theInfo.fdType = 'sEXT';    }  else    {    theInfo.fdFlags &amp;= ~kIsStationery;    theInfo.fdType = 'TEXT';    }  FSpSetFInfo(pSpec, &amp;theInfo);} // UpdateFileInfo// --------------------------------------------------------------------------------------------------------------static OSErr  TextSave(WindowDataPtr pData){  OSErr  anErr = noErr;  long  amountToWrite;    // write out the text  SetFPos(pData-&gt;dataRefNum, fsFromStart, 0);  amountToWrite = (** ((TextDataPtr) pData)-&gt;hTE).teLength;  anErr = FSWrite(pData-&gt;dataRefNum, &amp;amountToWrite, * (** ((TextDataPtr) pData)-&gt;hTE).hText);  nrequire(anErr, FailedWrite);  SetEOF(pData-&gt;dataRefNum, amountToWrite);    if (pData-&gt;resRefNum == -1)    {    FSpCreateResFile(&amp;pData-&gt;fileSpec, 'ttxt', pData-&gt;originalFileType, 0);    pData-&gt;resRefNum = FSpOpenResFile(&amp;pData-&gt;fileSpec, fsRdWrPerm);          }  else    {    // a save always makes it into file of type 'TEXT', for Save As\xC9 we     // afterwards set it again if the user is saving as stationary.    UpdateFileInfo(&amp;pData-&gt;fileSpec, true);    }  if (pData-&gt;resRefNum != -1)    {    short  oldResFile = CurResFile();    Handle  resourceHandle;        UseResFile(pData-&gt;resRefNum);        // remove any old sounds    resourceHandle = Get1Resource('snd ', kSoundBase);    if (resourceHandle)      {      RemoveResource(resourceHandle);      DisposeHandle(resourceHandle);      }          // save the new sound    resourceHandle = ((TextDataPtr) pData)-&gt;soundHandle;    if (resourceHandle)      {      anErr = HandToHand(&amp;resourceHandle);      if (anErr == noErr)        {        AddResource(resourceHandle, 'snd ', kSoundBase, &quot;\p&quot;);        anErr = ResError();        }      nrequire(anErr, AddSoundResourceFailed);      }          // remove any old styles    resourceHandle = Get1Resource('styl', 128);    if (resourceHandle)      {      RemoveResource(resourceHandle);      DisposeHandle(resourceHandle);      }        // save the new style -- get the scrap handle from the TE record    // To do this, we must select the text -- BUT doing so through the    // TextEdit API results in lots of flashing and annoying behavior.    // So we just change the offsets by hand    {    short        oldStart, oldEnd;          oldStart = (** ((TextDataPtr) pData)-&gt;hTE).selStart;    oldEnd   = (** ((TextDataPtr) pData)-&gt;hTE).selEnd;        (** ((TextDataPtr) pData)-&gt;hTE).selStart = 0;    (** ((TextDataPtr) pData)-&gt;hTE).selEnd = 32767;      resourceHandle = (Handle) TEGetStyleScrapHandle( ((TextDataPtr) pData)-&gt;hTE );      (** ((TextDataPtr) pData)-&gt;hTE).selStart = oldStart;    (** ((TextDataPtr) pData)-&gt;hTE).selEnd = oldEnd;    }      if (resourceHandle)      {      AddResource(resourceHandle, 'styl', 128, &quot;\p&quot;);      anErr = ResError();      nrequire(anErr, AddStyleResourceFailed);      }          AddSoundResourceFailed:    AddStyleResourceFailed:            UpdateResFile(pData-&gt;resRefNum);      UseResFile(oldResFile);    }    // FALL THROUGH EXCEPTION HANDLINGFailedWrite:  // if everything went okay, then clear the changed bit  if (anErr == noErr)    {    pData-&gt;changed = false;    (void) FlushVol(&quot;\p&quot;, pData-&gt;fileSpec.vRefNum);    }      return anErr;  } // TextSave// --------------------------------------------------------------------------------------------------------------static pascal void DrawTextUserItem(DialogPtr dPtr, short theItem)/*  Draw text icon in the location*/{  short    kind;  Handle    itemHandle;  Rect    box;    GetDialogItem(dPtr, theItem, &amp;kind, &amp;itemHandle, &amp;box);  PlotIconID(&amp;box, ttNone, ttNone, kTextIcon);      } // DrawTextUserItem#if GENERATINGCFM  static RoutineDescriptor gDrawTextUserItemRD = BUILD_ROUTINE_DESCRIPTOR(uppUserItemProcInfo, DrawTextUserItem);  static UserItemUPP gDrawTextUserItem = &amp;gDrawTextUserItemRD;#else  static UserItemUPP gDrawTextUserItem = NewUserItemProc(DrawTextUserItem);#endif// --------------------------------------------------------------------------------------------------------------static pascal void DrawStationeryUserItem(DialogPtr dPtr, short theItem)/*  Draw stationery icon in the location*/{  short    kind;  Handle    itemHandle;  Rect    box;    GetDialogItem(dPtr, theItem, &amp;kind, &amp;itemHandle, &amp;box);  PlotIconID(&amp;box, ttNone, ttNone, kStationeryIcon);      } // DrawStationeryUserItem#if GENERATINGCFM  static RoutineDescriptor gDrawStationeryUserItemRD = BUILD_ROUTINE_DESCRIPTOR(uppUserItemProcInfo, DrawStationeryUserItem);  static UserItemUPP gDrawStationeryUserItem = &amp;gDrawStationeryUserItemRD;#else  static UserItemUPP gDrawStationeryUserItem = NewUserItemProc(DrawStationeryUserItem);#endif// --------------------------------------------------------------------------------------------------------------// pre and post update procs for inline input static pascal void TSMPreUpdateProc(TEHandle textH, long refCon){#pragma unused (refCon)  ScriptCode   keyboardScript;  short    mode;  TextStyle  theStyle;  keyboardScript = GetScriptManagerVariable(smKeyScript);  mode = doFont;  if   (!      (      (TEContinuousStyle(&amp;mode, &amp;theStyle, textH) )&amp;&amp;       (FontToScript(theStyle.tsFont) == keyboardScript)       )    )    {    theStyle.tsFont = GetScriptVariable(keyboardScript, smScriptAppFond);    TESetStyle(doFont, &amp;theStyle, false, textH);    }    } // TSMPreUpdateProc#if GENERATINGCFM  static RoutineDescriptor gTSMPreUpdateProcRD = BUILD_ROUTINE_DESCRIPTOR(uppTSMTEPreUpdateProcInfo, TSMPreUpdateProc);  static TSMTEPreUpdateUPP gTSMPreUpdateProc = &amp;gTSMPreUpdateProcRD;#else  static TSMTEPreUpdateUPP gTSMPreUpdateProc = NewTSMTEPreUpdateProc(TSMPreUpdateProc);#endifstatic pascal void TSMPostUpdateProc(        TEHandle textH,        long fixLen,        long inputAreaStart,        long inputAreaEnd,        long pinStart,        long pinEnd,        long refCon){#pragma unused (textH, fixLen, inputAreaStart, inputAreaEnd, pinStart, pinEnd)  AdjustScrollBars((WindowRef)refCon, false, false, nil);  AdjustTE((WindowDataPtr)refCon, true);    ((WindowDataPtr)refCon)-&gt;changed = true;  } // TSMPostUpdateProc#if GENERATINGCFM  static RoutineDescriptor gTSMPostUpdateProcRD = BUILD_ROUTINE_DESCRIPTOR(uppTSMTEPostUpdateProcInfo, TSMPostUpdateProc);  static TSMTEPostUpdateUPP gTSMPostUpdateProc = &amp;gTSMPostUpdateProcRD;#else  static TSMTEPostUpdateUPP gTSMPostUpdateProc = NewTSMTEPostUpdateProc(TSMPostUpdateProc);#endif// --------------------------------------------------------------------------------------------------------------static pascal short SaveDialogHook(short item, DialogPtr dPtr, Boolean *isText){  short  theType;  Handle  theHandle;  Rect  theRect;  short  returnValue = item;    switch (item)    {    case sfHookFirstCall:      if (GetWRefCon(GetDialogWindow(dPtr)) == sfMainDialogRefCon)        {        GetDialogItem(dPtr, iTextUserItem, &amp;theType, &amp;theHandle, &amp;theRect);        theHandle = (Handle) gDrawTextUserItem;        SetDialogItem(dPtr, iTextUserItem, theType, theHandle, &amp;theRect);                GetDialogItem(dPtr, iStationeryUserItem, &amp;theType, &amp;theHandle, &amp;theRect);        theHandle = (Handle) gDrawStationeryUserItem;        SetDialogItem(dPtr, iStationeryUserItem, theType, theHandle, &amp;theRect);          GetDialogItem(dPtr, iTextDocumentItem, &amp;theType, &amp;theHandle, &amp;theRect);        SetControlValue((ControlHandle) theHandle, 1);                GetDialogItem(dPtr, iStationeryDocumentItem, &amp;theType, &amp;theHandle, &amp;theRect);        SetControlValue((ControlHandle) theHandle, 0);        *isText = true;        }      break;          case iTextDocumentItem:    case iTextUserItem:      GetDialogItem(dPtr, iTextDocumentItem, &amp;theType, &amp;theHandle, &amp;theRect);      SetControlValue((ControlHandle) theHandle, 1);            GetDialogItem(dPtr, iStationeryDocumentItem, &amp;theType, &amp;theHandle, &amp;theRect);      SetControlValue((ControlHandle) theHandle, 0);            *isText = true;      returnValue = sfHookNullEvent;      break;          case iStationeryDocumentItem:    case iStationeryUserItem:      GetDialogItem(dPtr, iTextDocumentItem, &amp;theType, &amp;theHandle, &amp;theRect);      SetControlValue((ControlHandle) theHandle, 0);            GetDialogItem(dPtr, iStationeryDocumentItem, &amp;theType, &amp;theHandle, &amp;theRect);      SetControlValue((ControlHandle) theHandle, 1);            *isText = false;      returnValue = sfHookNullEvent;      break;        }      return returnValue;  } // SaveDialogHook#if GENERATINGCFM  static RoutineDescriptor gSaveDialogHookRD = BUILD_ROUTINE_DESCRIPTOR(uppDlgHookYDProcInfo, SaveDialogHook);  static DlgHookYDUPP gSaveDialogHook = &amp;gSaveDialogHookRD;#else  static DlgHookYDUPP gSaveDialogHook = NewDlgHookYDProc(SaveDialogHook);#endif// --------------------------------------------------------------------------------------------------------------// Handle update/activate events behind Standard Filestatic pascal Boolean SaveDialogFilter(DialogPtr theDialog, EventRecord *theEvent,                    short *itemHit, void *myDataPtr){  #pragma unused(myDataPtr)  if (StdFilterProc(theDialog, theEvent, itemHit))    return true;  // Pass updates through (Activates are tricky...was mucking with Apple menu &amp; thereby  // drastically changing how the system handles the menu bar during our alert)  if (theEvent-&gt;what == updateEvt /* || theEvent-&gt;what == activateEvt */ )    {    HandleEvent(theEvent);    }  return false;} // SaveDialogFilter#if GENERATINGCFM  static RoutineDescriptor gSaveDialogFilterRD = BUILD_ROUTINE_DESCRIPTOR(uppModalFilterYDProcInfo, SaveDialogFilter);  static ModalFilterYDUPP gSaveDialogFilter = &amp;gSaveDialogFilterRD;#else  static ModalFilterYDUPP gSaveDialogFilter = NewModalFilterYDProc(SaveDialogFilter);#endif// --------------------------------------------------------------------------------------------------------------static OSErr  TextSaveAs(WindowRef pWindow, WindowDataPtr pData){  OSErr        anErr = noErr;  short        oldRes, oldData;  StandardFileReply  sfReply;  Boolean        documentIsText;    // save the old references -- if there is an error, we restore them  oldRes = pData-&gt;resRefNum;  oldData = pData-&gt;dataRefNum;    // ask where and how to save this document  {  Str255  defaultName;  Point  where = {-1, -1};    // setup for the call  GetWTitle(pWindow, defaultName);  SetCursor(&amp;qd.arrow);    // find out where the user wants the file  CustomPutFile(&quot;\p&quot;, defaultName, &amp;sfReply,         kTextSaveAsDialogID, where,        gSaveDialogHook, gSaveDialogFilter, nil, nil, &amp;documentIsText);    // map the cancel button into a cancelling error  if (!sfReply.sfGood)    anErr = eUserCanceled;  }      // can't replace over other types    if (sfReply.sfReplacing)    {    FInfo  theInfo;        FSpGetFInfo(&amp;sfReply.sfFile, &amp;theInfo);        if ( (theInfo.fdType != 'TEXT') &amp;&amp; (theInfo.fdType != 'sEXT') )      anErr = eDocumentWrongKind;    }  nrequire(anErr, StandardPutFile);      if   (    (sfReply.sfReplacing) &amp;&amp;     (oldData != -1) &amp;&amp;     (pData-&gt;fileSpec.vRefNum == sfReply.sfFile.vRefNum) &amp;&amp;    (pData-&gt;fileSpec.parID == sfReply.sfFile.parID) &amp;&amp;    EqualString(pData-&gt;fileSpec.name, sfReply.sfFile.name, false, false)    )    {    anErr = TextSave(pData);        if (anErr == noErr)      UpdateFileInfo(&amp;sfReply.sfFile, documentIsText);    }  else    {    // create the data file and resource fork    (void) FSpDelete(&amp;sfReply.sfFile);    anErr = FSpCreate(&amp;sfReply.sfFile, 'ttxt', documentIsText ? 'TEXT' : 'sEXT', 0);    FSpCreateResFile(&amp;sfReply.sfFile, 'ttxt', documentIsText ? 'TEXT' : 'sEXT', 0);    nrequire(anErr, FailedCreate);    // set the stationary bit, if we must    if (!documentIsText)      {      FInfo  theInfo;            FSpGetFInfo(&amp;sfReply.sfFile, &amp;theInfo);      theInfo.fdFlags |= kIsStationery;      FSpSetFInfo(&amp;sfReply.sfFile, &amp;theInfo);      }    // open both of forks    anErr = FSpOpenDF(&amp;sfReply.sfFile, fsRdWrPerm, &amp;pData-&gt;dataRefNum);    if (anErr == noErr)      {      pData-&gt;resRefNum = FSpOpenResFile(&amp;sfReply.sfFile, fsRdWrPerm);      anErr = ResError();      }    nrequire(anErr, FailedOpen);    // call the standard save function to do the save    anErr = TextSave(pData);    // FALL THROUGH EXCEPTION HANDLING  FailedOpen:    FSpDelete(&amp;sfReply.sfFile);    FailedCreate:  StandardPutFile:    // finally, close the old files if everything went okay    if (anErr == noErr)      {      if (oldRes != -1)        CloseResFile(oldRes);      if (oldData != -1)        FSClose(oldData);      pData-&gt;isWritable = true;      SetWTitle(pWindow, sfReply.sfFile.name);      }    else      {      pData-&gt;resRefNum = oldRes;      pData-&gt;dataRefNum = oldData;      }    }    // save new location  if (anErr == noErr)    BlockMoveData(&amp;sfReply.sfFile, &amp;pData-&gt;fileSpec, sizeof(FSSpec));    // Return eUserCanceled so we can avoid closing/quitting if they cancel the SF dialog//  // don't propagate this error//  if (anErr == eUserCanceled)//    anErr = noErr;  return anErr;  } // TextSaveAs// --------------------------------------------------------------------------------------------------------------static void ApplyFace(short requestedFace, WindowRef pWindow, WindowDataPtr pData, short commandID){  TextStyle  style;  short    oldNumLines = (**(((TextDataPtr) pData)-&gt;hTE)).nLines;    SaveCurrentUndoState(pData, commandID);    style.tsFace = requestedFace;  TESetStyle(doFace + ((requestedFace != normal) ? doToggle : 0), &amp;style, true, ((TextDataPtr) pData)-&gt;hTE);  TECalText(((TextDataPtr) pData)-&gt;hTE);    oldNumLines -= (**(((TextDataPtr) pData)-&gt;hTE)).nLines;  AdjustTE(pData, false);  AdjustScrollBars(pWindow, (oldNumLines &gt; 0), (oldNumLines &gt; 0), nil);  pData-&gt;changed = true;  } // ApplyFace// --------------------------------------------------------------------------------------------------------------static OSErr ApplySize(short requestedSize, WindowRef pWindow, WindowDataPtr pData, short commandID){  OSErr    anErr = noErr;  TextStyle  style;  short    oldNumLines = (**(((TextDataPtr) pData)-&gt;hTE)).nLines;    SaveCurrentUndoState(pData, commandID);  style.tsSize = requestedSize;  TESetStyle(doSize, &amp;style, true, ((TextDataPtr) pData)-&gt;hTE);  TECalText(((TextDataPtr) pData)-&gt;hTE);  if (CalculateTextEditHeight(((TextDataPtr) pData)-&gt;hTE) &gt; 32767)    {        style.tsSize = 0;    TESetStyle(doSize, &amp;style, true, ((TextDataPtr) pData)-&gt;hTE);    anErr = eDocumentTooLarge;    }  oldNumLines -= (**(((TextDataPtr) pData)-&gt;hTE)).nLines;  AdjustTE(pData, false);  AdjustScrollBars(pWindow, (oldNumLines &gt; 0), (oldNumLines &gt; 0), nil);  pData-&gt;changed = true;    return anErr;} // ApplySize// --------------------------------------------------------------------------------------------------------------// OOP INTERFACE ROUTINES// --------------------------------------------------------------------------------------------------------------static OSErr  TextUpdateWindow(WindowRef pWindow, WindowDataPtr pData){  Rect  updateArea = pData-&gt;contentRect;    // be sure to also erase the area where the horizontal scroll bar  // is missing.  updateArea.bottom = GetWindowPort(pWindow)-&gt;portRect.bottom;  EraseRect(&amp;updateArea);    TEUpdate(&amp;pData-&gt;contentRect, ((TextDataPtr) pData)-&gt;hTE);    DrawPictures(pData, ((TextDataPtr) pData)-&gt;hTE);    DrawControls(pWindow);  DrawGrowIcon(pWindow);    return noErr;  } // TextUpdateWindow// --------------------------------------------------------------------------------------------------------------static OSErr  TextCloseWindow(WindowRef pWindow, WindowDataPtr pData){#pragma unused (pWindow)  // shut down text services  if (pData-&gt;docTSMDoc)    {    FixTSMDocument(pData-&gt;docTSMDoc);    DeactivateTSMDocument(pData-&gt;docTSMDoc);    DeleteTSMDocument(pData-&gt;docTSMDoc);    }    DisposeOfSpeech(true);  DisposeHandle(((TextDataPtr) pData)-&gt;soundHandle);  TEDispose(((TextDataPtr) pData)-&gt;hTE);  DisposeHandle(((TextDataPtr) pData)-&gt;prevText);  DisposeHandle(((TextDataPtr) pData)-&gt;prevStyle);    TextRemoveContentsMenu(pData);  return noErr;} // TextCloseWindow// --------------------------------------------------------------------------------------------------------------static OSErr  TextActivateEvent(WindowRef pWindow, WindowDataPtr pData, Boolean activating){#pragma unused (pWindow)  // only modifyable docs can be active  if (pData-&gt;originalFileType == 'TEXT')    {    if (activating)      {      TEActivate(((TextDataPtr) pData)-&gt;hTE);      if (pData-&gt;docTSMDoc != nil)        ActivateTSMDocument(pData-&gt;docTSMDoc);      }    else      {      TEDeactivate(((TextDataPtr) pData)-&gt;hTE);      if (pData-&gt;docTSMDoc != nil)        DeactivateTSMDocument(pData-&gt;docTSMDoc);      }    }      // add contents menu, if appropriate      if (activating)    {    TextAddContentsMenu(pData);    }  else    {    TextRemoveContentsMenu(pData);    }    return noErr;  } // TextActivateEvent// --------------------------------------------------------------------------------------------------------------static Boolean  TextFilterEvent(WindowRef pWindow, WindowDataPtr pData, EventRecord *pEvent){    switch (pEvent-&gt;what)    {    case nullEvent:      if (pData-&gt;originalFileType == 'TEXT')        {        if ( pWindow == FrontWindow() )          TEIdle(((TextDataPtr) pData)-&gt;hTE);        }              // if we stop speaking, ditch the channel      if (gSpeechChannel)         {        SpeechStatusInfo  status;        // Status of our speech channel.                if (           (GetSpeechInfo( gSpeechChannel, soStatus, (void*) &amp;status ) == noErr)          &amp;&amp;  (!status.outputBusy )          )          DisposeOfSpeech(true);        }      break;    }      return false;  } // TextFilterEvent// --------------------------------------------------------------------------------------------------------------static OSErr  TextScrollContent(WindowRef pWindow, WindowDataPtr pData, short deltaH, short deltaV){  GrafPtr    port = (GrafPtr) GetWindowPort(pWindow);  RgnHandle  srcRgn, dstRgn;  Rect    viewRect;    // scroll the text area  TEScroll(deltaH, deltaV, ((TextDataPtr) pData)-&gt;hTE);  // calculate the region that is uncovered by the scroll  srcRgn = NewRgn();  dstRgn = NewRgn();  viewRect = (**((TextDataPtr) pData)-&gt;hTE).viewRect;  RectRgn( srcRgn, &amp;viewRect );  SectRgn( srcRgn, port-&gt;visRgn,  srcRgn );  SectRgn( srcRgn, port-&gt;clipRgn, srcRgn );  CopyRgn( srcRgn, dstRgn );  OffsetRgn( dstRgn, deltaH, deltaV );  SectRgn( srcRgn, dstRgn, dstRgn );  DiffRgn( srcRgn, dstRgn, srcRgn );  // clip to this new area  GetClip(dstRgn);  SetClip(srcRgn);    DrawPictures(pData, ((TextDataPtr) pData)-&gt;hTE);  SetClip(dstRgn);    // all done with these calculation regions  DisposeRgn( srcRgn );  DisposeRgn( dstRgn );    return eActionAlreadyHandled;  } // TextScrollContent// --------------------------------------------------------------------------------------------------------------static OSErr  TextKeyEvent(WindowRef pWindow, WindowDataPtr pData, EventRecord *pEvent, Boolean isMotionKey){    OSErr  anErr = noErr;    if (!(pEvent-&gt;modifiers &amp; cmdKey))     {    char  theKey = pEvent-&gt;message &amp; charCodeMask;    char  theKeyCode = (pEvent-&gt;message &gt;&gt; 8) &amp; charCodeMask;        if ( ((theKey != kDeleteKey) || (theKeyCode != kForwardDeleteKey)) &amp;&amp;       ((** ((TextDataPtr) pData)-&gt;hTE).teLength+1 &gt; kMaxLength) )      anErr = eDocumentTooLarge;    else      {      long    oldHeight = CalculateTextEditHeight(((TextDataPtr) pData)-&gt;hTE);      long    end = (**(((TextDataPtr) pData)-&gt;hTE)).selEnd;      long    start = (**(((TextDataPtr) pData)-&gt;hTE)).selStart;      ObscureCursor();      SaveCurrentUndoState(pData, cTypingCommand);      if (theKeyCode != kForwardDeleteKey)        {        if (pEvent-&gt;modifiers &amp; shiftKey)          {          switch (theKeyCode)            {            case kUpArrow:              TEKey(theKey, ((TextDataPtr) pData)-&gt;hTE);              TESetSelect((**(((TextDataPtr) pData)-&gt;hTE)).selStart, end, ((TextDataPtr) pData)-&gt;hTE);              break;                          case kDownArrow:              TESetSelect(end, end, ((TextDataPtr) pData)-&gt;hTE);              TEKey(theKey, ((TextDataPtr) pData)-&gt;hTE);              TESetSelect(start, (**(((TextDataPtr) pData)-&gt;hTE)).selEnd, ((TextDataPtr) pData)-&gt;hTE);              break;                          case kRightArrow:              {              Handle textHandle = (**(((TextDataPtr) pData)-&gt;hTE)).hText;              Ptr textBuf;              char state;                            state = HGetState(textHandle);              HLock(textHandle);              textBuf = *(**(((TextDataPtr) pData)-&gt;hTE)).hText;              if (CharacterByteType(textBuf, start, smCurrentScript) != smSingleByte)                ++end;              HSetState(textHandle, state);              TESetSelect(start, ++end, ((TextDataPtr) pData)-&gt;hTE);              }              break;                          case kLeftArrow:              if (start &gt; 0)                {                if (start &gt; 1)                  {                  Handle textHandle = (**(((TextDataPtr) pData)-&gt;hTE)).hText;                  Ptr textBuf;                  char state;                                    state = HGetState(textHandle);                  HLock(textHandle);                  textBuf = *(**(((TextDataPtr) pData)-&gt;hTE)).hText;                  if (CharacterByteType(textBuf, start-1, smCurrentScript) != smSingleByte)                    --start;                  HSetState(textHandle, state);                  }                TESetSelect(--start, end, ((TextDataPtr) pData)-&gt;hTE);                }              break;                          default:              TEKey(theKey, ((TextDataPtr) pData)-&gt;hTE);            }          }        else          TEKey(theKey, ((TextDataPtr) pData)-&gt;hTE);        }      else        {        if   (end &lt; (**(((TextDataPtr) pData)-&gt;hTE)).teLength)          {          if (start == end)            TEKey(kRightArrowCharCode, ((TextDataPtr) pData)-&gt;hTE);          TEKey(kBackspaceCharCode, ((TextDataPtr) pData)-&gt;hTE);          }        }      oldHeight -= CalculateTextEditHeight(((TextDataPtr) pData)-&gt;hTE);                    ((TextDataPtr) pWindow)-&gt;insideClickLoop = true;        AdjustTE(pData, false);        AdjustScrollBars(pWindow, (oldHeight &gt; 0), (oldHeight &gt; 0), nil);      ((TextDataPtr) pWindow)-&gt;insideClickLoop = false;      if (!isMotionKey)        pData-&gt;changed = true;      }    }  return anErr;} // TextKeyEvent// --------------------------------------------------------------------------------------------------------------static OSErr  TextContentClick(WindowRef pWindow, WindowDataPtr pData, EventRecord *pEvent){  OSErr      anErr = noErr;  Point      clickPoint = pEvent-&gt;where;  ControlHandle  theControl;  RgnHandle    hilightRgn;  GlobalToLocal(&amp;clickPoint);  if (FindControl(clickPoint, pWindow, &amp;theControl) == 0)    {    if (gMachineInfo.haveDragMgr)      {      hilightRgn = NewRgn();      TEGetHiliteRgn(hilightRgn, ((TextDataPtr) pData)-&gt;hTE);        if (PtInRgn(clickPoint, hilightRgn))        {        SaveCurrentUndoState(pData, cTypingCommand);        if (!DragText(pWindow, pData, pEvent, hilightRgn))          anErr = eActionAlreadyHandled;        }      else            {        anErr = eActionAlreadyHandled;        }        DisposeRgn(hilightRgn);      }    else      {      anErr = eActionAlreadyHandled;      }    }  if ( (anErr == eActionAlreadyHandled) &amp;&amp; (PtInRect(clickPoint, &amp;pData-&gt;contentRect)) )    {    TEClick(clickPoint, (pEvent-&gt;modifiers &amp; shiftKey) != 0, ((TextDataPtr) pData)-&gt;hTE);    }      return anErr;  } // TextContentClick// --------------------------------------------------------------------------------------------------------------static OSErr  TextAdjustSize(WindowRef pWindow, WindowDataPtr pData,       Boolean *didReSize) // input: was window resized, output: t-&gt;we resized something{#pragma unused (pWindow)    if (*didReSize)    {    RecalcTE(pData, true);    AdjustTE(pData, true);    }  else    {    AdjustTE(pData, false);    }      return noErr;  } // TextAdjustSize// --------------------------------------------------------------------------------------------------------------static OSErr  TextCommand(WindowRef pWindow, WindowDataPtr pData, short commandID, long menuResult){  OSErr  anErr = noErr;    SetPort((GrafPtr) GetWindowPort(pWindow));    if ( (pData-&gt;docTSMDoc) &amp;&amp; (menuResult != 0) )    FixTSMDocument(pData-&gt;docTSMDoc);      switch (commandID)    {          case cUndo:      {      short    oldNumLines = (**(((TextDataPtr) pData)-&gt;hTE)).nLines;      PerformUndo(pData);      oldNumLines -= (**(((TextDataPtr) pData)-&gt;hTE)).nLines;      AdjustTE(pData, false);      AdjustScrollBars(pWindow, (oldNumLines &gt; 0), (oldNumLines &gt; 0), nil);      RecalcTE(pData, true);      pData-&gt;changed = true;      }      break;          case cCut:      SaveCurrentUndoState(pData, cCut);      {      short    oldNumLines = (**(((TextDataPtr) pData)-&gt;hTE)).nLines;      TECut(((TextDataPtr) pData)-&gt;hTE);  // no need for TEToScrap with styled TE record      oldNumLines -= (**(((TextDataPtr) pData)-&gt;hTE)).nLines;      AdjustTE(pData, false);      AdjustScrollBars(pWindow, (oldNumLines &gt; 0), (oldNumLines &gt; 0), nil);      pData-&gt;changed = true;      }      break;          case cCopy:      TECopy(((TextDataPtr) pData)-&gt;hTE);  // no need for TEToScrap with styled TE record      AdjustTE(pData, false);      break;          case cClear:      SaveCurrentUndoState(pData, cClear);      {      short    oldNumLines = (**(((TextDataPtr) pData)-&gt;hTE)).nLines;      TEDelete(((TextDataPtr) pData)-&gt;hTE);      oldNumLines -= (**(((TextDataPtr) pData)-&gt;hTE)).nLines;      AdjustTE(pData, false);      AdjustScrollBars(pWindow, (oldNumLines &gt; 0), (oldNumLines &gt; 0), nil);      pData-&gt;changed = true;      }      break;          case cPaste:      SaveCurrentUndoState(pData, cPaste);      {      short    oldNumLines = (**(((TextDataPtr) pData)-&gt;hTE)).nLines;      anErr = TEFromScrap();            if (anErr == noErr)        {                // if the current length, plus the paste data, minus the data in the selection        // would make the document too large, say so        if   (             ((** ((TextDataPtr) pData)-&gt;hTE).teLength +            TEGetScrapLength() -            ((** ((TextDataPtr) pData)-&gt;hTE).selEnd-(** ((TextDataPtr) pData)-&gt;hTE).selStart)            )          &gt; kMaxLength)          {          anErr = eDocumentTooLarge;          }        else          {          Handle  aHandle = (Handle) TEGetText(((TextDataPtr) pData)-&gt;hTE);          Size  oldSize = GetHandleSize(aHandle);          Size  newSize = oldSize + TEGetScrapLength();          OSErr  saveErr;                    SetHandleSize(aHandle, newSize);          saveErr = MemError();          SetHandleSize(aHandle, oldSize);          if (saveErr != noErr)            anErr = eDocumentTooLarge;          else            TEStylePaste(((TextDataPtr) pData)-&gt;hTE);          }                  UnloadScrap();        }      oldNumLines -= (**(((TextDataPtr) pData)-&gt;hTE)).nLines;      AdjustTE(pData, false);      AdjustScrollBars(pWindow, (oldNumLines &gt; 0), (oldNumLines &gt; 0), nil);      pData-&gt;changed = true;      }      break;          case cReplace:      SaveCurrentUndoState(pData, cReplace);      {      short result = ConductFindOrReplaceDialog(kReplaceWindowID);            if (result == cancel)        break;              if (result == iReplaceAll)        {        long     newStart, newEnd;        short    oldNumLines = (**(((TextDataPtr) pData)-&gt;hTE)).nLines;                TESetSelect(0, 0, ((TextDataPtr) pData)-&gt;hTE);        while (PerformSearch((**((TextDataPtr) pData)-&gt;hTE).hText,                  (**((TextDataPtr) pData)-&gt;hTE).selStart,                  gFindString, gCaseSensitive, false, false,                  &amp;newStart, &amp;newEnd))          {          TESetSelect(newStart, newEnd, ((TextDataPtr) pData)-&gt;hTE);          TEDelete(((TextDataPtr) pData)-&gt;hTE);          TEInsert(&amp;gReplaceString[1], gReplaceString[0], ((TextDataPtr) pData)-&gt;hTE);          TESetSelect(newStart, newStart+gReplaceString[0], ((TextDataPtr) pData)-&gt;hTE);                  pData-&gt;changed = true;          }        oldNumLines -= (**(((TextDataPtr) pData)-&gt;hTE)).nLines;                AdjustTE(pData, false);        AdjustScrollBars(pWindow, (oldNumLines &gt; 0), (oldNumLines &gt; 0), nil);          anErr = eActionAlreadyHandled;        break;        }      }        // fall through from replace    case cReplaceAgain:      SaveCurrentUndoState(pData, cReplaceAgain);      {      long   newStart, newEnd;      Boolean  isBackwards = ((gEvent.modifiers &amp; shiftKey) != 0);            if (PerformSearch((**((TextDataPtr) pData)-&gt;hTE).hText,                isBackwards ? (**((TextDataPtr) pData)-&gt;hTE).selEnd : (**((TextDataPtr) pData)-&gt;hTE).selStart,                gFindString, gCaseSensitive, isBackwards, gWrapAround,                &amp;newStart, &amp;newEnd))        {        short    oldNumLines = (**(((TextDataPtr) pData)-&gt;hTE)).nLines;                TESetSelect(newStart, newEnd, ((TextDataPtr) pData)-&gt;hTE);        TEDelete(((TextDataPtr) pData)-&gt;hTE);        TEInsert(&amp;gReplaceString[1], gReplaceString[0], ((TextDataPtr) pData)-&gt;hTE);        TESetSelect(newStart, newStart+gReplaceString[0], ((TextDataPtr) pData)-&gt;hTE);                oldNumLines -= (**(((TextDataPtr) pData)-&gt;hTE)).nLines;                AdjustTE(pData, false);        AdjustScrollBars(pWindow, (oldNumLines &gt; 0), (oldNumLines &gt; 0), nil);        pData-&gt;changed = true;        }      else        SysBeep(1);      anErr = eActionAlreadyHandled;      }      break;          case cFind:    case cFindSelection:      if (commandID == cFind)        {        if (ConductFindOrReplaceDialog(kFindWindowID) == cancel)            break;        }      else        {        gFindString[0] = (**((TextDataPtr) pData)-&gt;hTE).selEnd - (**((TextDataPtr) pData)-&gt;hTE).selStart;        BlockMoveData( (*(**((TextDataPtr) pData)-&gt;hTE).hText) + (**((TextDataPtr) pData)-&gt;hTE).selStart, &amp;gFindString[1], gFindString[0]);        }          // fall through from find or find selection    case cFindAgain:      {      long   newStart, newEnd;      Boolean  isBackwards = ((gEvent.modifiers &amp; shiftKey) != 0);            if (PerformSearch((**((TextDataPtr) pData)-&gt;hTE).hText,                isBackwards ? (**((TextDataPtr) pData)-&gt;hTE).selStart : (**((TextDataPtr) pData)-&gt;hTE).selEnd,                gFindString, gCaseSensitive, isBackwards, gWrapAround,                &amp;newStart, &amp;newEnd))        {        TESetSelect(newStart, newEnd, ((TextDataPtr) pData)-&gt;hTE);        AdjustTE(pData, false);        AdjustScrollBars(pWindow, false, false, nil);        }      else        SysBeep(1);      anErr = eActionAlreadyHandled;      }      break;          case cSelectAll:      TESetSelect(0, (**((TextDataPtr) pData)-&gt;hTE).teLength,             ((TextDataPtr) pData)-&gt;hTE);      AdjustTE(pData, false);      AdjustScrollBars(pWindow, false, false, nil);      anErr = eActionAlreadyHandled;      break;        // save turns into save as if this is a new document or if the original wasn't    // available for writing    case cSave:      if   (        (!pData-&gt;isWritable) ||         ( (pData-&gt;dataRefNum == -1) &amp;&amp; (pData-&gt;resRefNum == -1) )        )        anErr = TextSaveAs(pWindow, pData);      else        anErr = TextSave(pData);      break;          case cSaveAs:      anErr = TextSaveAs(pWindow, pData);      break;          // SUPPORTED FONTS//    case cSelectFontStyle:          case cSelectFont:      SaveCurrentUndoState(pData, cSelectFont);      {      Str255    itemName;      Str255    menuName;      TextStyle  theStyle;      short    oldNumLines = (**(((TextDataPtr) pData)-&gt;hTE)).nLines;            GetMenuItemText( GetMenuHandle( menuResult&gt;&gt;16 ), menuResult &amp; 0xFFFF, itemName );      GetFNum( itemName, &amp;theStyle.tsFont );                TESetStyle( doFont, &amp;theStyle, true, ((TextDataPtr) pData)-&gt;hTE );              TECalText(((TextDataPtr) pData)-&gt;hTE);      oldNumLines -= (**(((TextDataPtr) pData)-&gt;hTE)).nLines;      AdjustTE(pData, false);      AdjustScrollBars(pWindow, (oldNumLines &gt; 0), (oldNumLines &gt; 0), nil);      pData-&gt;changed = true;      }      break;                // SUPPORTED STYLES    case cPlain:      ApplyFace(normal, pWindow, pData, cPlain);      break;          case cBold:      ApplyFace(bold, pWindow, pData, cBold);      break;    case cItalic:      ApplyFace(italic, pWindow, pData, cItalic);      break;          case cUnderline:      ApplyFace(underline, pWindow, pData, cUnderline);      break;          case cOutline:      ApplyFace(outline, pWindow, pData, cOutline);      break;          case cShadow:      ApplyFace(shadow, pWindow, pData, cShadow);      break;    case cCondensed:      ApplyFace(condense, pWindow, pData, cCondensed);      break;          case cExtended:      ApplyFace(extend, pWindow, pData, cExtended);      break;            // SUPPORTED SIZES    case cSize9:      anErr = ApplySize(9, pWindow, pData, cSize9);      break;          case cSize10:      anErr = ApplySize(10, pWindow, pData, cSize10);      break;          case cSize12:      anErr = ApplySize(12, pWindow, pData, cSize12);      break;          case cSize14:      anErr = ApplySize(14, pWindow, pData, cSize14);      break;          case cSize18:      anErr = ApplySize(18, pWindow, pData, cSize18);      break;          case cSize24:      anErr = ApplySize(24, pWindow, pData, cSize24);      break;          case cSize36:      anErr = ApplySize(36, pWindow, pData, cSize36);      break;                // SUPPORTED SOUND COMMANDS    case cRecord:      {      Handle  tempHandle;      // allocate our prefered buffer if we can, but if we can't      // make sure that at least a minimum amount of RAM is around      // before recording.      tempHandle = NewHandle(kPrefBufferSize);      anErr = MemError();      if (anErr != noErr)        {        tempHandle = NewHandle(kMinBufferSize);        anErr = MemError();        DisposeHandle(tempHandle);        tempHandle = nil;        }            // if the preflight goes okay, do the record      if (anErr == noErr)        {        Point  where = {50, 100};                anErr = SndRecord(nil, where, siGoodQuality, (SndListHandle*) &amp;tempHandle);        if (anErr == noErr)          {          DisposeHandle(((TextDataPtr) pData)-&gt;soundHandle);          ((TextDataPtr) pData)-&gt;soundHandle = tempHandle;          pData-&gt;changed = true;          }        else          DisposeHandle(tempHandle);                  if (anErr == userCanceledErr)          anErr = noErr;        }      }      break;          case cPlay:      if (((TextDataPtr) pData)-&gt;soundHandle)        (void) SndPlay(nil, (SndListHandle) ((TextDataPtr) pData)-&gt;soundHandle, false);      break;    case cErase:      DisposeHandle(((TextDataPtr) pData)-&gt;soundHandle);      ((TextDataPtr) pData)-&gt;soundHandle = nil;      pData-&gt;changed = true;      break;          case cSpeak:      DisposeOfSpeech(false);      if (gSpeechChannel == nil)        anErr = NewSpeechChannel( &amp;gCurrentVoice, &amp;gSpeechChannel );              if ( anErr == noErr )        {        short  textLength, textStart;                          // determine which text to speak        if ( (**((TextDataPtr) pData)-&gt;hTE).selEnd &gt; (**((TextDataPtr) pData)-&gt;hTE).selStart )  // If there is a selection.          {          textLength = (**((TextDataPtr) pData)-&gt;hTE).selEnd - (**((TextDataPtr) pData)-&gt;hTE).selStart;          textStart = (**((TextDataPtr) pData)-&gt;hTE).selStart;          }        else                      // No text selected.          {          textLength = (**((TextDataPtr) pData)-&gt;hTE).teLength;          textStart = 0;          }                            gSpeakPtr = NewPtr(textLength);        anErr = MemError();        if (anErr == noErr)          {          BlockMoveData( *((**((TextDataPtr) pData)-&gt;hTE).hText) + textStart, gSpeakPtr, (Size) textLength );          anErr = SpeakText( gSpeechChannel, gSpeakPtr, textLength );          }        }      break;    case cStopSpeaking:      DisposeOfSpeech(true);      break;          case cSelectVoiceSubMenu:        {        VoiceSpec  newSpec;        short    i, menuIndex;        Str255    itemText;        short    theVoiceCount;        MenuHandle   menu = GetMenuHandle(mVoices);                // in order to change voices, we need to ditch the speaking        DisposeOfSpeech(true);        // get the name of the selected voice                menuIndex = menuResult &amp; 0xFFFF;        GetMenuItemText(menu, menuIndex, itemText);                if (CountVoices( &amp;theVoiceCount ) == noErr)          {          VoiceDescription  description;    // Info about a voice.              for (i = 1; i &lt;= theVoiceCount; ++i)            {            if ( (GetIndVoice( i, &amp;newSpec ) == noErr)  &amp;&amp;               (GetVoiceDescription( &amp;newSpec, &amp;description, sizeof(description) ) == noErr ) )              {              if (IUCompString( itemText, description.name ) == 0)                break;              }            }          }                  gCurrentVoice = newSpec;        for (i = CountMItems(menu); i &gt;= 1; --i)          CheckItem(menu, i, (menuIndex == i));        }      break;            case cSelectContents:        {        Str255  searchStr;        short  menuIndex;        long   newStart, newEnd;                menuIndex = menuResult &amp; 0xFFFF;        // get the search string for this menu item        anErr = TextGetContentsListItem(pData, menuIndex, nil, searchStr, nil);                if (anErr == noErr)          {          if (PerformSearch(            (**((TextDataPtr) pData)-&gt;hTE).hText,            0,      // start at beginning of text            searchStr,            false,    // not case sensitive            false,    // forwards            false,    // wrap            &amp;newStart,             &amp;newEnd))            {                        // &lt;7&gt;                        short   amount;            Point  newSelectionPt;                        // get QuickDraw offset of found text,              // scroll that amount plus a line height,            // and add a fifth of the window for aesthetics (and              // for slop to avoid fraction-of-line problems)            newSelectionPt = TEGetPoint(newEnd, ((TextDataPtr) pData)-&gt;hTE);                        amount = - newSelectionPt.v + pData-&gt;vScrollAmount;            amount += (pData-&gt;contentRect.bottom - pData-&gt;contentRect.top) / 5;                        SetControlAndClipAmount(pData-&gt;vScroll, &amp;amount);            if (amount != 0)              {              DoScrollContent(pWindow, pData, 0, amount);              }            // move selection to beginning of found text             // (are the Adjust calls necessary?)                        TESetSelect(newStart, newStart, ((TextDataPtr) pData)-&gt;hTE);              AdjustTE(pData, false);            AdjustScrollBars(pWindow, false, false, nil);            }          else            {              // search failed              SysBeep(10);            }          }        }      break;    }      return anErr;  } // TextCommand// --------------------------------------------------------------------------------------------------------------static OSErr  TextAdjustMenus(WindowRef pWindow, WindowDataPtr pData){#pragma unused (pWindow)  // enable the commands that we support for editable text document  if (pData-&gt;originalFileType == 'TEXT')    {        if (((TextDataPtr) pData)-&gt;prevCommandID != cNull)      EnableCommand(cUndo);          if ( (**((TextDataPtr) pData)-&gt;hTE).selEnd &gt; (**((TextDataPtr) pData)-&gt;hTE).selStart )  // If there is a selection.      {      EnableCommand(cCut);      EnableCommand(cCopy);      EnableCommand(cClear);            EnableCommand(cFindSelection);      }        TEFromScrap();    if (TEGetScrapLength() &gt; 0)      EnableCommand(cPaste);          EnableCommand(cSaveAs);    EnableCommand(cSelectAll);        EnableCommand(cFind);    EnableCommand(cReplace);    if (gFindString[0] != 0)      {      EnableCommand(cFindAgain);      EnableCommand(cReplaceAgain);      }          // enable all fonts, select the font current, if that's what's best    EnableCommand(cSelectFont);    {    short    mode = doFont;    Str255    fontName, itemName;    Str255    styleName;    TextStyle  theStyle;    Boolean    isCont;        isCont = TEContinuousStyle(&amp;mode, &amp;theStyle, ((TextDataPtr) pData)-&gt;hTE);    if (isCont)      {      GetFontName(theStyle.tsFont, fontName);      }      {      MenuHandle  menu = GetMenuHandle( mFont );      short    count = CountMItems(menu);      short    index;            for (index = 1; index &lt;= count; ++index)        {        short  mark;                GetItemMark(menu, index, &amp;mark);        if (isCont)          {          GetMenuItemText( menu, index, itemName );                    // don't change the checkmark if it's a heirarchichal menu, because          // the mark actually holds the ID of sub-menu          if ((mark == noMark) || (mark == checkMark))            {            CheckItem(menu, index, EqualString(itemName, fontName, true, true) );            }          else            {            // if it is a sub menu, we check there too            MenuHandle  subMenu = GetMenuHandle(mark);            short    subCount = CountMItems(subMenu);            short    subIndex;                        if (EqualString(itemName, fontName, true, true))              {              SetItemStyle(menu, index, underline);              for (subIndex = 1; subIndex &lt;= subCount; ++subIndex)                {                GetMenuItemText(subMenu, subIndex, itemName);                CheckItem(subMenu, subIndex, EqualString(itemName, styleName, true, true) );                }              }            else              {              SetItemStyle(menu, index, normal);              for (subIndex = 1; subIndex &lt;= subCount; ++subIndex)                CheckItem(subMenu, subIndex, false );              }            }          }        else          {          if ((mark == noMark) || (mark == checkMark))            CheckItem(menu, index, false);          else            SetItemStyle(menu, index, normal);          }        }      }    }    // enable the sizes, and outline what's currently valid    {    short    mode;    TextStyle  theStyle;    Boolean    isCont;    short    whichToCheck;        // find out the continuous run of sizes    whichToCheck = 0;    mode = doSize;    if (TEContinuousStyle(&amp;mode, &amp;theStyle, ((TextDataPtr) pData)-&gt;hTE))      {            whichToCheck = theStyle.tsSize;            // default font size -&gt; proper size      if (whichToCheck == 0)        whichToCheck = GetDefFontSize();      }          // find out the font runs    mode = doFont;    isCont = TEContinuousStyle(&amp;mode, &amp;theStyle, ((TextDataPtr) pData)-&gt;hTE);        EnableCommandCheckStyle(cSize9,  whichToCheck == 9, (isCont &amp; RealFont(theStyle.tsFont, 9)) ? outline : normal);    EnableCommandCheckStyle(cSize10, whichToCheck == 10, (isCont &amp; RealFont(theStyle.tsFont, 10)) ? outline : normal);    EnableCommandCheckStyle(cSize12, whichToCheck == 12, (isCont &amp; RealFont(theStyle.tsFont, 12)) ? outline : normal);    EnableCommandCheckStyle(cSize14, whichToCheck == 14, (isCont &amp; RealFont(theStyle.tsFont, 14)) ? outline : normal);    EnableCommandCheckStyle(cSize18, whichToCheck == 18, (isCont &amp; RealFont(theStyle.tsFont, 18)) ? outline : normal);    EnableCommandCheckStyle(cSize24, whichToCheck == 24, (isCont &amp; RealFont(theStyle.tsFont, 24)) ? outline : normal);    EnableCommandCheckStyle(cSize36, whichToCheck == 36, (isCont &amp; RealFont(theStyle.tsFont, 36)) ? outline : normal);          }        {    short    mode = doFace;    TextStyle  theStyle;    Style    legalStyles;        if (!TEContinuousStyle(&amp;mode, &amp;theStyle, ((TextDataPtr) pData)-&gt;hTE))      {      theStyle.tsFace = normal;      EnableCommandCheck(cPlain, false);      }    else      EnableCommandCheck(cPlain, theStyle.tsFace == normal);          // &lt;39&gt; use the script manager to determine legal styles for this    // run of text.  If the legal styles are zero (trap unimplemented),    // then we assume all styles.    legalStyles = GetScriptVariable(GetScriptManagerVariable(smKeyScript), smScriptValidStyles);    if (legalStyles == 0)      legalStyles = 0xFFFF;          if (legalStyles &amp; bold)      EnableCommandCheck(cBold,       theStyle.tsFace &amp; bold);    if (legalStyles &amp; italic)      EnableCommandCheck(cItalic,     theStyle.tsFace &amp; italic);    if (legalStyles &amp; underline)      EnableCommandCheck(cUnderline,     theStyle.tsFace &amp; underline);    if (legalStyles &amp; outline)      EnableCommandCheck(cOutline,     theStyle.tsFace &amp; outline);    if (legalStyles &amp; shadow)      EnableCommandCheck(cShadow,     theStyle.tsFace &amp; shadow);    if (legalStyles &amp; condense)      EnableCommandCheck(cCondensed,     theStyle.tsFace &amp; condense);    if (legalStyles &amp; extend)      EnableCommandCheck(cExtended,     theStyle.tsFace &amp; extend);    }        }  // enable commands related to speaking the content if we have support for that  if (gMachineInfo.haveTTS)    {    // if we are speaking, we can stop    if (gSpeechChannel)       EnableCommand(cStopSpeaking);    // even while speaking, you can re-speak or select a new voice    EnableCommand(cSpeak);    EnableCommand(cSelectVoice);    EnableCommand(cSelectVoiceSubMenu);        if ( (**((TextDataPtr) pData)-&gt;hTE).selEnd &gt; (**((TextDataPtr) pData)-&gt;hTE).selStart )  // If there is a selection.      ChangeCommandName(cSpeak, kTextStrings, iSpeakSelection);    else      ChangeCommandName(cSpeak, kTextStrings, iSpeakAll);          }      // enable the correct controls to go with sound input/output  if (((TextDataPtr) pData)-&gt;soundHandle)    EnableCommand(cPlay);  if (pData-&gt;originalFileType == 'TEXT')    {    if (((TextDataPtr) pData)-&gt;soundHandle)      EnableCommand(cErase);    else      {      if (gMachineInfo.haveRecording)        EnableCommand(cRecord);      }    }    // enable the contents menu, if any       (void) TextAdjustContentsMenu(pData);    // enable commands that we support at all times  if (GetControlMaximum(pData-&gt;vScroll) != 0)    {    EnableCommand(cNextPage);    EnableCommand(cPreviousPage);    }    return noErr;  } // TextAdjustMenus// --------------------------------------------------------------------------------------------------------------static OSErr  TextGetDocumentRect(WindowRef pWindow, WindowDataPtr pData,       LongRect * documentRectangle, Boolean forGrow){#pragma unused (pWindow)    Rect  theRect = pData-&gt;contentRect;  Rect  maxRect = (**GetGrayRgn()).rgnBBox;    if ( (!forGrow) &amp;&amp; (!(((TextDataPtr) pData)-&gt;insideClickLoop) ) )    RecalcTE(pData, false);    theRect.bottom = CalculateTextEditHeight(((TextDataPtr) pData)-&gt;hTE);  theRect.bottom += kMargins*2;  theRect.right = maxRect.right;      if (theRect.bottom &lt; pData-&gt;contentRect.bottom)    theRect.bottom = pData-&gt;contentRect.bottom;      if (forGrow)    theRect.bottom = maxRect.bottom-kScrollBarSize;      RectToLongRect(&amp;theRect, documentRectangle);    return noErr;  } // TextGetDocumentRect// --------------------------------------------------------------------------------------------------------------static OSErr  TextGetBalloon(WindowRef pWindow, WindowDataPtr pData,     Point *localMouse, short * returnedBalloonIndex, Rect *returnedRectangle){#pragma unused (pWindow, pData, localMouse, returnedRectangle)  *returnedBalloonIndex = iHelpTextContent;    return noErr;  } // TextGetBalloon// --------------------------------------------------------------------------------------------------------------static long TextCalculateIdleTime(WindowRef pWindow, WindowDataPtr pData){#pragma unused (pWindow, pData)  if ( (gMachineInfo.amInBackground) || (! (**(((TextDataPtr) pData)-&gt;hTE)).active) )    return(0x7FFFFFF);  else    return(1);    } // TextCalculateIdleTime// --------------------------------------------------------------------------------------------------------------static OSErr  TextAdjustCursor(WindowRef pWindow, WindowDataPtr pData,             Point * localMouse, Rect * globalRect){#pragma unused (pWindow, globalRect)  OSErr      anErr = noErr;  CursHandle    theCross;  RgnHandle    hilightRgn;    if (gMachineInfo.haveDragMgr)    {    hilightRgn = NewRgn();    TEGetHiliteRgn(hilightRgn, ((TextDataPtr) pData)-&gt;hTE);    if (PtInRgn(*localMouse, hilightRgn))      {      SetCursor(&amp;qd.arrow);      DisposeRgn(hilightRgn);      return eActionAlreadyHandled;        }      DisposeRgn(hilightRgn);    }      theCross = GetCursor(iBeamCursor);  if (theCross)    {    char  oldState;        oldState = HGetState((Handle) theCross);    HLock((Handle) theCross);    SetCursor(*theCross);    HSetState((Handle) theCross, oldState);    anErr = eActionAlreadyHandled;    }      return anErr;  } // TextAdjustCursor// --------------------------------------------------------------------------------------------------------------short gNilCaretProc[] = {             0x584F,     // ADDQ.W  #$4, A7            0x4E75};    // RTS// --------------------------------------------------------------------------------------------------------------static OSErr  TextPrintPage(WindowRef pWindow, WindowDataPtr pData,          Rect * pageRect, long *pageNum){#pragma unused (pWindow)  OSErr    anErr = noErr;  short    footerHeight;  TEHandle  hTE;  Rect    areaForThisPage;  short    ourPage = 1;  Boolean    documentHasFormControl = Count1Resources(kFormResource) != 0;    // calculate area for the footer (page number)  {  FontInfo  theInfo;    TextFont(0);  TextSize(0);  TextFace(normal);  GetFontInfo(&amp;theInfo);  footerHeight = (theInfo.ascent + theInfo.descent + theInfo.leading) &lt;&lt; 1;  }    // duplicate the text edit record, disable the selection before swapping the new port in  hTE = ((TextDataPtr) pData)-&gt;hTE;  TEDeactivate(hTE);    anErr = HandToHand((Handle*) &amp;hTE);  nrequire(anErr, DuplicateTE);  // turn off outline hilighting -- because the window is disabled while  // printing is going on, but we don't want that disabled hilight to draw  TEFeatureFlag(teFOutlineHilite, teBitClear, ((TextDataPtr) pData)-&gt;hTE);      // now HERE'S a real hack!  Under certain conditions, Text Edit will draw the  // cursor, even if you said the edit record is inactive!  This happens when  // the internal state sez that the cursor hasn't been drawn yet.  Lucky  // for us, the caret is drawn through a hook, which we replace with a NOP.  (**hTE).caretHook = (CaretHookUPP) gNilCaretProc;    // point the rectangles to be the page rect minus the footer  areaForThisPage = *pageRect;  areaForThisPage.bottom -= footerHeight;  InsetRect(&amp;areaForThisPage, kPrintMargins, kPrintMargins);  (**hTE).viewRect = (**hTE).destRect = areaForThisPage;  // recalculate the line breaks  TECalText(hTE);  // point it at the printing port.  (**hTE).inPort = qd.thePort;  // now loop over all pages doing page breaking until we find our current  // page, which we print, and then return.  {  Rect  oldPageHeight = (**hTE).viewRect;  short  currentLine = 0;  long  prevPageHeight = 0;  while (ourPage &lt;= *pageNum)    {    long  currentPageHeight = 0;              // calculate the height including the current page, breaks    // when one of three things happen:    // 1) adding another line to this page would go beyond the length of the page    // 2) a picture needs to be broken to the next page (NOT YET IMPLEMENTED)    // 3) we run out of lines for the document     // 4) if the line has a page break (defined as a non breaking space w/o a PICT)    // POTENTIAL BUG CASES:    // If a single line &gt; the page height.  Can that happen?  If so, we need to     // add something to handle it.    do      {      long currentLineHeight;            // zero based count -- but one based calls to TEGetHeight       currentLineHeight = TEGetHeight(currentLine+1, currentLine+1, hTE);              // if adding this line would just be too much, break out of here      if ((currentLineHeight + currentPageHeight) &gt; (areaForThisPage.bottom - areaForThisPage.top))        break;              ++ currentLine;      currentPageHeight += currentLineHeight;            // if this line had a page break on it, break out of pagination      if (documentHasFormControl &amp;&amp; LineHasPageBreak(currentLine-1, hTE))        break;              } while (currentLine &lt; (**hTE).nLines);        // if this the page we are trying to print    if (ourPage == *pageNum)      {      Str255    pageString;      RgnHandle  oldRgn = NewRgn();            // move onto the next page via offset by the previous pages -- but      // clip to the current page height because we wouldn't want to see      // half of a line from the next page at the bottom of a page.      OffsetRect(&amp;oldPageHeight, 0, -(prevPageHeight));      oldPageHeight.bottom = oldPageHeight.top + currentPageHeight;      (**hTE).destRect = oldPageHeight;            // clip to this area as well      areaForThisPage.bottom = areaForThisPage.top + currentPageHeight;      GetClip(oldRgn);      ClipRect(&amp;areaForThisPage);            // draw the edit record, plus our cool pictures        TEUpdate(&amp;areaForThisPage, hTE);       DrawPictures(pData, hTE);            // restore the clip      SetClip(oldRgn);      DisposeRgn(oldRgn);            // Draw the page string at the bottom of the page, centered      pageString[0] = 2;      pageString[1] = '-';      NumToString(*pageNum, &amp;pageString[2]);      pageString[0] += pageString[2];      pageString[2] = ' ';      pageString[++pageString[0]] = ' ';      pageString[++pageString[0]] = '-';            MoveTo(        pageRect-&gt;left +           ((pageRect-&gt;right - pageRect-&gt;left) &gt;&gt; 1) -           (StringWidth(pageString)&gt;&gt;1),        pageRect-&gt;bottom - kPrintMargins);              DrawString(pageString);            // if we have completed all pages      if (currentLine &gt;= (**hTE).nLines)        {        // tell it to stop printing        *pageNum = -1;        }              // get out of here!      break;      }      // move onto the next page via count    ++ourPage;        // and the list of pages before now includes this page we just finished    prevPageHeight += currentPageHeight;        }    }      // restore text for visible page if done  if (*pageNum == -1)    {    TEFeatureFlag(teFOutlineHilite, teBitSet, ((TextDataPtr) pData)-&gt;hTE);    TECalText(((TextDataPtr) pData)-&gt;hTE);    if (pData-&gt;originalFileType != 'ttro')      TEActivate(((TextDataPtr) pData)-&gt;hTE);    }    // FALL THROUGH EXCEPTION HANDLING  // Dispose this way to avoid disposing of any owned objects  DisposeHandle((Handle) hTE);DuplicateTE:  return anErr;  } // TextPrintPage// --------------------------------------------------------------------------------------------------------------static OSErr  TextMakeWindow(WindowRef pWindow, WindowDataPtr pData){  #pragma unused(pWindow)  OSErr        anErr = noErr;  pData-&gt;bumpUntitledCount  = true;    pData-&gt;pScrollContent     = (ScrollContentProc)  TextScrollContent;  pData-&gt;pAdjustSize       = (AdjustSizeProc)    TextAdjustSize;  pData-&gt;pGetDocumentRect   = (GetDocumentRectProc)  TextGetDocumentRect;  pData-&gt;pAdjustMenus       = (AdjustMenusProc)    TextAdjustMenus;  pData-&gt;pCommand         = (CommandProc)      TextCommand;  pData-&gt;pCloseWindow     = (CloseWindowProc)    TextCloseWindow;  pData-&gt;pFilterEvent     = (FilterEventProc)    TextFilterEvent;  pData-&gt;pActivateEvent     = (ActivateEventProc)  TextActivateEvent;  pData-&gt;pUpdateWindow     = (UpdateWindowProc)  TextUpdateWindow;  pData-&gt;pPrintPage       = (PrintPageProc)    TextPrintPage;  // we only support keydowns and editing for modifable docs  if (pData-&gt;originalFileType != 'ttro')    {    pData-&gt;pKeyEvent       = (KeyEventProc)      TextKeyEvent;    pData-&gt;pContentClick    = (ContentClickProc)    TextContentClick;    pData-&gt;pAdjustCursor    = (AdjustCursorProc)    TextAdjustCursor;    pData-&gt;pGetBalloon      = (GetBalloonProc)      TextGetBalloon;    pData-&gt;pCalculateIdleTime  = (CalculateIdleTimeProc)  TextCalculateIdleTime;        // We can always reference our Drag handlers, because they will not be called if we    // don't have the Drag Manager available. We needn't check here (it would be redundant).    pData-&gt;pDragTracking    = (DragTrackingProc)  TextDragTracking;    pData-&gt;pDragReceive      = (DragReceiveProc)    TextDragReceive;    pData-&gt;documentAcceptsText  = true;    }      // leave room for the grow area at bottom  pData-&gt;hasGrow        = true;  pData-&gt;contentRect.bottom  -= kScrollBarSize;    if ((pData-&gt;contentRect.right - pData-&gt;contentRect.left) &gt; kOnePageWidth)    pData-&gt;contentRect.right = pData-&gt;contentRect.left + kOnePageWidth;      ((TextDataPtr) pData)-&gt;hTE  = TEStyleNew(&amp;pData-&gt;contentRect, &amp;pData-&gt;contentRect);  anErr = MemError();  nrequire(anErr, TENewFailed);      pData-&gt;hScrollAmount    = 0;  pData-&gt;vScrollAmount    = TEGetHeight(0, 0, ((TextDataPtr) pData)-&gt;hTE);  TEAutoView(true, ((TextDataPtr) pData)-&gt;hTE);  // Setup our click loop to handle autoscrolling  ((TextDataPtr) pData)-&gt;docClick = (**(((TextDataPtr) pData)-&gt;hTE)).clickLoop;  TESetClickLoop(gMyClickLoop, ((TextDataPtr) pData)-&gt;hTE);    // if we have a data fork, read the contents into the record    if (pData-&gt;dataRefNum != -1)    {    long  dataSize;        GetEOF(pData-&gt;dataRefNum, &amp;dataSize);    if (dataSize &gt; kMaxLength)      anErr = eDocumentTooLarge;    else      {      Handle  tempHandle = NewHandle(dataSize);      anErr = MemError();      if (anErr == noErr)        {        // read the text in        SetFPos(pData-&gt;dataRefNum, fsFromStart, 0);        anErr = FSRead(pData-&gt;dataRefNum, &amp;dataSize, * tempHandle);                // then insert it.        if (anErr == noErr)          {          HLock(tempHandle);          TEStyleInsert(*tempHandle, dataSize, nil, ((TextDataPtr) pData)-&gt;hTE);          anErr = MemError();          }        DisposeHandle(tempHandle);        }            }        }  nrequire(anErr, ReadData);    // if we have a resource fork, read the contents  if (pData-&gt;resRefNum != -1)    {    short  oldResFile = CurResFile();    Handle  theStyle;        // read the style information    UseResFile(pData-&gt;resRefNum);    theStyle = Get1Resource('styl', 128);    if (theStyle)      {      HNoPurge(theStyle);      TEUseStyleScrap(0, 32767, (StScrpHandle) theStyle, true, ((TextDataPtr) pData)-&gt;hTE);      ReleaseResource(theStyle);      }    // if we have sound, load it in and detach it    {    Handle  soundHandle = Get1Resource('snd ', kSoundBase);    if (soundHandle)      {      HNoPurge(soundHandle);      DetachResource(soundHandle);      ((TextDataPtr) pData)-&gt;soundHandle = soundHandle;      }    }    UseResFile(oldResFile);    }        // hook out drawing of the non-breaking space for read only documents,  // for modifiable documents, enable outline hiliting (ie, when TE window  // isn't in front, show the gray outline)  if (pData-&gt;originalFileType == 'ttro')    {    UniversalProcPtr  hookRoutine = (UniversalProcPtr)gMyDrawGlue;        TECustomHook(intDrawHook, &amp;hookRoutine, ((TextDataPtr) pData)-&gt;hTE);    }  else    {    TEFeatureFlag(teFOutlineHilite, teBitSet, ((TextDataPtr) pData)-&gt;hTE);    }  // make a TSM document if this is editable  if   (    (pData-&gt;originalFileType != 'ttro') &amp;&amp;    (gMachineInfo.haveTSMTE)    )    {    OSType  supportedInterfaces[1];    supportedInterfaces[0] = kTSMTEInterfaceType;        if (NewTSMDocument(1, supportedInterfaces,       &amp;pData-&gt;docTSMDoc, (long)&amp;pData-&gt;docTSMRecHandle) == noErr)      {      long response;      (**(pData-&gt;docTSMRecHandle)).textH         = ((TextDataPtr) pData)-&gt;hTE;      if ((Gestalt(gestaltTSMTEVersion, &amp;response) == noErr) &amp;&amp; (response == gestaltTSMTE1))        (**(pData-&gt;docTSMRecHandle)).preUpdateProc   = gTSMPreUpdateProc;      (**(pData-&gt;docTSMRecHandle)).postUpdateProc   = gTSMPostUpdateProc;      (**(pData-&gt;docTSMRecHandle)).updateFlag     = kTSMTEAutoScroll;      (**(pData-&gt;docTSMRecHandle)).refCon       = (long)pData;      }    }  // now we have added text, so adjust views and such as needed  TESetSelect(0, 0, ((TextDataPtr) pData)-&gt;hTE);  RecalcTE(pData, true);  AdjustTE(pData, true);  // ???? Hack to get around a 7.0 TextEdit bug.  If you are pasting a multiple  // line clipboard into TE, *and* the TextEdit record is new, *and* the selection  // is at the begining of the doc (0,0 as above), *and* you haven't moved the  // cursor around at all, then TE pastes thinking it's at the end of the line,  // when it really should be at the begining.  Then if you &lt;cr&gt; with the cursor  // visible, it'll leave a copy behind.      // I'm not happy with this, but I don't know another way around the problem.  if (pData-&gt;originalFileType != 'ttro')     {    TEKey(0x1F, ((TextDataPtr) pData)-&gt;hTE);    TEKey(0x1E, ((TextDataPtr) pData)-&gt;hTE);    }    // &lt;39&gt; if this is a new document, convert the &quot;system size&quot;, &quot;system font&quot;, and  // &quot;application font&quot; into real font IDs and sizes.  This is so that  // if someone saves this document and opens it with another script  // system, they don't get all huffy that the font changed on them.  // It also solves problems with cut and paste to applications too stupid  // to know that &quot;zero&quot; means system size.  if (pData-&gt;dataRefNum == -1)    {    TEHandle  hTE = ((TextDataPtr) pData)-&gt;hTE;    short    mode = doAll;    TextStyle  theStyle;      TEContinuousStyle(&amp;mode, &amp;theStyle, hTE);    if (theStyle.tsSize == 0)      theStyle.tsSize = GetDefFontSize();    if (theStyle.tsFont == systemFont)      theStyle.tsFont = GetSysFont();    if (theStyle.tsFont == applFont)      theStyle.tsFont = GetAppFont();          mode = doAll;    TESetStyle(mode, &amp;theStyle, false, hTE);    }  // if stationary, use untitled and close down the files  if (pData-&gt;originalFileType == 'sEXT')    {    pData-&gt;originalFileType = 'TEXT';    pData-&gt;openAsNew = true;    if (pData-&gt;resRefNum != -1)      CloseResFile(pData-&gt;resRefNum);    if (pData-&gt;dataRefNum != -1)      FSClose(pData-&gt;dataRefNum);    pData-&gt;resRefNum = pData-&gt;dataRefNum = -1;    }      // initalize undo information  ((TextDataPtr) pData)-&gt;prevCommandID = cNull;    // if we have voices, add them to the menu  if ( (gMachineInfo.haveTTS) &amp;&amp; (!gAddedVoices) )    {    short  theVoiceCount;    short  i, item;        if (CountVoices( &amp;theVoiceCount ) == noErr)      {      VoiceSpec      spec;        // A voice to add to the menu.      VoiceDescription  description;    // Info about a voice.      MenuHandle      voicesMenu = GetMenuHandle(mVoices);      anErr = GetVoiceDescription( nil, &amp;description, sizeof(description) );      if (anErr == noErr)        {        gCurrentVoice = description.voice;        for (i = 1; i &lt;= theVoiceCount; ++i)          {          if ( (GetIndVoice( i, &amp;spec ) == noErr)  &amp;&amp;             (GetVoiceDescription( &amp;spec, &amp;description, sizeof(description) ) == noErr ) )            {            short  menuCount = CountMItems( voicesMenu );                        // first one we are adding == get rid of item already there            if ( (i == 1)  &amp;&amp; (menuCount &gt; 0) )              {              DeleteMenuItem( voicesMenu, 1 );              --menuCount;              }                          for ( item = 1; item &lt;= menuCount; ++item )              {              Str255  itemText;                            GetMenuItemText( voicesMenu, item, itemText );              /*1st &gt; 2nd*/              if ( IUCompString( itemText, description.name ) == 1 )                break;            // Found where name goes in list.              }                InsertMenuItem( voicesMenu, &quot;\p &quot;, item - 1 );            SetMenuItemText( voicesMenu, item, description.name );                        CheckItem(voicesMenu, item,               ((gCurrentVoice.creator == spec.creator) &amp;&amp; (gCurrentVoice.id == spec.id)) );            }          }          }            gAddedVoices = true;      }          } // end of adding voices      return noErr;  // EXCEPTION HANDLINGReadData:  TEDispose(((TextDataPtr) pData)-&gt;hTE);  TENewFailed:  return anErr;  } // TextMakeWindow// --------------------------------------------------------------------------------------------------------------OSErr  TextPreflightWindow(PreflightPtr pPreflightData){    pPreflightData-&gt;continueWithOpen   = true;  pPreflightData-&gt;wantVScroll      = true;  pPreflightData-&gt;doZoom        = true;  pPreflightData-&gt;makeProcPtr     = TextMakeWindow;  if (pPreflightData-&gt;fileType != 'ttro')    pPreflightData-&gt;openKind      = fsRdWrPerm;    pPreflightData-&gt;storageSize     = sizeof(TextDataRecord);  // get strings that mark the picture  GetIndString(gPictMarker1, kTextStrings, iPictureMarker1);  GetIndString(gPictMarker2, kTextStrings, iPictureMarker2);    return noErr;  } // TextPreflightWindow// --------------------------------------------------------------------------------------------------------------void TextGetFileTypes(OSType * pFileTypes, OSType * pDocumentTypes, short * numTypes){  pFileTypes[*numTypes]     = 'TEXT';  pDocumentTypes[*numTypes]   = kTextWindow;  (*numTypes)++;      pFileTypes[*numTypes]     = 'ttro';  pDocumentTypes[*numTypes]   = kTextWindow;  (*numTypes)++;      pFileTypes[*numTypes]     = 'sEXT';  pDocumentTypes[*numTypes]   = kTextWindow;  (*numTypes)++;    } // TextGetFileTypes// --------------------------------------------------------------------------------------------------------------// TextAddContentsMenu checks if there is a contents list and, if there// is, creates a new menu handle for the contents list and fills it with // the appropriate visible itemsvoid TextAddContentsMenu(WindowDataPtr pData){  MenuHandle  contentsMenu;  Str255    menuStr;  short    totalItems;  short    index;  OSErr    err;    contentsMenu = GetMenuHandle(mContents);  require(contentsMenu == nil, ContentsMenuAlreadyInstalled);    // Is there a contents list?  If so, get the menu name   // and the number of items in the list    if (TextGetContentsListItem(pData, 0, menuStr, nil, &amp;totalItems) == noErr)    {        // create the menu and fill it with all the items    // listed in the string list resource        contentsMenu = NewMenu(mContents, menuStr);    require(contentsMenu != nil, CantCreateContentsMenu);        for (index = 1; index &lt; totalItems; index++)      {      err = TextGetContentsListItem(pData, index, menuStr, nil, nil);      require(err == noErr, CantGetItem);            AppendMenu(contentsMenu, menuStr);      }    // add the menu to the menu bar, and redraw the menu bar    InsertMenu(contentsMenu, 0);    DrawMenuBar();    }  else    {    // no contents, do nothing    }    return;  // error handlingCantGetItem:CantCreateContentsMenu:    if (contentsMenu)   DisposeMenu(contentsMenu);ContentsMenuAlreadyInstalled:  return;    } // TextAddContentsMenu// TextRemoveContentsMenu removes the contents menu, if any,// and redraws the menu barstatic void TextRemoveContentsMenu(WindowDataPtr pData){#pragma unused (pData)  MenuHandle  contentsMenu;    contentsMenu = GetMenuHandle(mContents);  if (contentsMenu)    {    DeleteMenu(mContents);    DisposeMenu(contentsMenu);    DrawMenuBar();    }} // TextRemoveContentsMenu// TextGetContentsListItem is a general utility routine for examining the// contents menu list, returning the menu and search strings, and returning// the total number of entries in the contents list.//// Pass 0 as itemNum to retrieve the strings for the contents menu title.//// Pass nil for menuStr, searchStr, or totalItems if you don't want that// info returned.//// Returns eDocumentHasNoContentsEntries if there is no contents string list// resource for the specified windowstatic OSErr TextGetContentsListItem(WindowDataPtr pData, short itemNum,                 StringPtr menuStr, StringPtr searchStr,                 short *totalItems){  OSErr  err;  short  oldResFile;  short  menuItemNum;  short  searchItemNum;  Handle  contentsStrListHandle;    // if no original resource file, don't bother  if (pData-&gt;resRefNum == -1)      {    return eDocumentHasNoContentsEntries;    }      err = noErr;    oldResFile = CurResFile();  UseResFile(pData-&gt;resRefNum);    // two entries per item  //  // first (itemNum zero) is content menu title  // (second -- itemNum one, search string for menu title -- is unused)    menuItemNum = itemNum * 2 + 1;  searchItemNum = menuItemNum + 1;    contentsStrListHandle = Get1Resource('STR#', kContentsListID);  if (contentsStrListHandle)    {    if (totalItems)  *totalItems = (*(short *)*contentsStrListHandle) / 2;    if (menuStr)  GetIndString(menuStr, kContentsListID, menuItemNum);    if (searchStr)        {      GetIndString(searchStr, kContentsListID, searchItemNum);          if (searchStr[0] == 0)        {        // search string was empty, so use the        // menu string as the search string                GetIndString(searchStr, kContentsListID, menuItemNum);        }      }    }  else    {    err = eDocumentHasNoContentsEntries;    if (totalItems)  *totalItems = 0;    }    UseResFile(oldResFile);    return err;} // TextGetContentsListItem// TextAdjustContentsMenu enables the items in the contents menu//// This routine is essentially a placeholder in case the contents// menu really were to be dynamically enabled.static OSErr TextAdjustContentsMenu(WindowDataPtr pData){#pragma unused (pData)    EnableCommand(cSelectContents);  return(noErr);  } // TextAdjustContentsMenu</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Scriptable_Print_SimpleText/listing28.html%3Fid%3DDTS10000305-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Scriptable_Print_SimpleText/listing28.html%3Fid%3DDTS10000305-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Scriptable_Print_SimpleText/listing28.html%3Fid%3DDTS10000305-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>