<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Implementing Your Cyberdog Item Class</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING4></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->




<!-- Main Body -->

<CENTER>
<P>
<A HREF="ServiceExample-3.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="ServiceExample-1.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="ServiceExample-7.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="ServiceExample-5.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../../macos8/mac8.html"><B>Inside Macintosh:</B></A>  / <BR><DD><A HREF="ServiceExample-1.html"><B> Creating a Cyberdog Service</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING4-0></A>
<H1>Implementing Your Cyberdog Item Class</H1>
 <A NAME=MARKER-2-17></A>To implement your own kind of Cyberdog item, you must define a subclass of <CODE><A NAME=MARKER-2-18></A>CyberItem</CODE> and override most of its methods. These methods are called by the service while opening the Cyberdog item. <A HREF=#MARKER-9-19>Listing 2</A> shows the SOM class definition for the Cyberdog item associated with the Finger service.<P>
<B>Listing 2  <A NAME=MARKER-9-19></A>The SOM class definition of the Finger service item</B><P>
<PRE>
module AppleCyberdog
{
   interface FingerItem : CyberItem
   {
      #ifdef __SOMIDL__
         implementation
         {
            functionprefix = FingerItem__;
            override:
               somInit,
               somUninit,
               Open,
               SetUpFromURL,
               GetFlatSize,
               Flatten,
               Unflatten,
               ExternalizeContent,
               Clone,
               Compare,
               GetStringProperty,
               SetDefaultName,
               GetURL,
               GetIconSuite,
               CreateCyberStream,
               IsDownloadable,
               GetContentKind,
               GetFileInfo;
                     
            #ifdef __PRIVATE__
               FingerItemDatafData;
            #endif
         }; 
      #endif
   };
};
</PRE>
 The following sections describe how to implement these methods.<P>
<A NAME=HEADING4-5></A>
<H2>Initializing a Cyberdog Item</H2>
 Your Cyberdog item must contain enough information to identify the location to which the item refers. It should also contain, or be able to derive, the information that needs to be flattened when the item is saved in a storage unit. <A HREF=#MARKER-9-20>Listing 3</A> shows the data maintained in a Finger service's item, which is referenced by the fData field.<P>
<B>Listing 3  <A NAME=MARKER-9-20></A>The data structure of the Finger service item</B><P>
<PRE>
struct CFingerItemData
{
            CFingerItemData();
   virtual  ~CFingerItemData();
   
   char*          fURL;
   StringPtr      fDefaultName;
   ScriptCode     fDefaultNameScript;
   static Handle  gIconSuite;
};
</PRE>
 The item holds a URL, a display name for the URL, the script system with which to display the name, and a handle to the icon suite associated with the item. A structure for this data is created when the item is initialized, as shown in <A HREF=#MARKER-9-21>Listing 4</A>.<P>
<B>Listing 4  <A NAME=MARKER-9-21></A>The <CODE>somInit</CODE> method of the Finger service item</B><P>
<PRE>
SOM_Scope void  SOMLINK FingerItem__somInit
                           (AppleCyberdog_FingerItem *somSelf)
{
   ...
   AppleCyberdog_FingerItem_parent_CyberItem_somInit(somSelf);
    
    CFingerItemData* data = new CFingerItemData;
    somThis-&gt;fData = data;
}
</PRE>
 The item's data is deleted when the item is destroyed, as shown in <A HREF=#MARKER-9-22>Listing 5</A>.<P>
<B>Listing 5  <A NAME=MARKER-9-22></A>The <CODE>somUninit</CODE> method of the Finger service item </B><P>
<PRE>
SOM_Scope void  SOMLINK FingerItem__somUninit
                           (AppleCyberdog_FingerItem *somSelf)
{
   ...
   AppleCyberdog_FingerItem_parent_CyberItem_somUninit(somSelf);
    
    CFingerItemData* data = (CFingerItemData*) somThis-&gt;fData;
    
    if(data)
    {
      delete data;
      somThis-&gt;fData = nil;
    }
}
</PRE>
<A NAME=HEADING4-15></A>
<H2><A NAME=MARKER-9-23></A>Setting Up a Cyberdog Item</H2>
 Your Cyberdog item must provide a <CODE>SetUpFromURL</CODE> method. Your service calls this <A NAME=MARKER-2-24></A><CODE>SetUpFromURL</CODE> method when it creates the item. The <CODE>SetUpFromURL</CODE> method is called with the URL, the URL's name, and the name's script as input parameters. If the name is not specified, your <CODE>SetUpFromURL</CODE> method must create a name. <A HREF=#MARKER-9-25>Listing 6</A> shows the <CODE>SetUpFromURL</CODE> method of the Finger service item, which stores the URL and sets the name.<P>
<B>Listing 6  <A NAME=MARKER-9-25></A>The <CODE>SetUpFromURL</CODE> method of the Finger service item</B><P>
<PRE>
SOM_Scope void  SOMLINK FingerItem__SetUpFromURL
                           (AppleCyberdog_FingerItem *somSelf, 
                            Environment *ev,
                            char* url,
                            StringPtr defaultName,
                            ScriptCode defaultNameScript)
{
   ...
   CFingerItemData* data = (CFingerItemData*) somThis-&gt;fData;
   
   if(url)
   {
      data-&gt;fURL = (char*) ODNewPtr(strlen(url)+1);
      strcpy(data-&gt;fURL, url);
      
      if(defaultName)
         somSelf-&gt;SetDefaultName(ev, defaultName, defaultNameScript);
      else
      {
         short port;
         char host[256];
         char user[256];
         char manufacturedName[256];
         manufacturedName[0] = 0;
         
         ParseFingerURL(url, host, user, &amp;port);
         
         if(user[0] != 0)
         {
            strcat(manufacturedName, user);
            strcat(manufacturedName, &quot; at &quot;);
         }
         strcat(manufacturedName, host);
         ctopstr(manufacturedName);
         
         somSelf-&gt;SetDefaultName(ev, 
                        (StringPtr) manufacturedName, smRoman);
      }
   }
}
</PRE>
 The <CODE>ParseFingerURL</CODE> function decomposes the URL in the <CODE>url</CODE> field into its host, user, and port components.<P>
<A NAME=HEADING4-20></A>
<H2>Opening a Cyberdog Item</H2>
 <A NAME=MARKER-2-26></A>You must override your Cyberdog item's <A NAME=MARKER-2-27></A><CODE>Open</CODE> method to specify how to open the Cyberdog item. Your implementation can either open the item synchronously or asynchronously. <A HREF=#MARKER-9-28>Listing 7</A> shows the <CODE>Open</CODE> method of the Finger service item. A preference in the Internet Config file controls how to open the item. See <A HREF=ServiceExample-6.html#MARKER-9-98>"Creating the Preferences Panel" (page 37)</A>.<P>
<DL>
<DT><B>Note</B>
<DD>It is not necessary to open a Finger service item asynchronously. The data type being accessed is known to be text and only a small amount of data is transferred. The asynchronous option is provided to show the differences between asynchronous and synchronous opening of Cyberdog items.   <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<B>Listing 7  <A NAME=MARKER-9-28></A>The <CODE>Open</CODE> method of the Finger service item</B><P>
<PRE>
SOM_Scope void  SOMLINK FingerItem__Open
                           (AppleCyberdog_FingerItem *somSelf,
                            Environment *ev,
                            ParameterSet* theParams)
{
   ...
   // Try to find a window that already shows the Cyberdog item
   long search4ExistingWindow = true;
   if(theParams)
   {
      if( ! theParams-&gt;GetParameter(ev, kCDSearch4ExistingWindowKey,
                            (void**) &amp;search4ExistingWindow) )
         search4ExistingWindow = true;
   }
   if(search4ExistingWindow)
      // Existing window found and selected; do not create a new part.
      if(GetCyberSession(ev)-&gt;SelectCyberItemWindow(ev, somSelf))
         return; 
   
   // Extract the opener part (if any) from the parameter set.
   ODPart* openerPart = kODNULL;
   if(theParams)
      if(!theParams-&gt;GetParameter(ev, kCDInitialOpenerPartKey,
                           &amp;openerPart))
         theParams-&gt;GetParameter(ev, kCDObtainedOpenerPartKey,
                           &amp;openerPart);

// Read the opening mode preference from Internet config.
   OSErr err;
   long  size;
   
   ODBoolean openAsync;
   size = sizeof(ODBoolean);
   err = GetPrefsValue(ev, kFingerOpenAsyncPref, (Ptr) &amp;openAsync, 
                  &amp;size);
   if(err != noErr)
      openAsync = kODFalse;
   if(openAsync)
   // Open asynchronously.
   {
      // Provide a parameter set object for the call to ObtainOpener.
      theParams = AcquireCreateParameterSet(ev, theParams);
      
      // Obtain an opener part for opening asyncronously.
      openerPart = GetCyberSession(ev)-&gt;ObtainOpener(ev, 
                        openerPart, kODNULL, somSelf, theParams);
      
      // Create a thread that simulates deferred opening
       const Size kThreadStackSize = 0;
       ThreadID threadID;
       AsyncOpenData* openData 
               = new AsyncOpenData(somSelf, theParams, openerPart);    
       OSErr err = NewThread(kCooperativeThread,
                      gFingerItemAsyncOpenThread, openData,
                      kThreadStackSize, kCreateIfNeeded, 
                      nil, &amp; threadID);
    }
    else
   // Open synchronously.
{
      // Create the right kind of part in the right document.
      CyberSession* cyberSession = ::GetCyberSession(ev);
      TempODPart cyberPart = cyberSession-&gt;CreateCyberPart(ev,
                           openerPart, kTextPlainKind, kODNULL);
      
      // If the display part handles the kTextPlain kind of data,
      // create a download part instead.
      if(cyberPart == kODNULL)
         cyberPart = cyberSession-&gt;CreatePartInCyberDocument(ev,
                                 kDownloadPartKind, kODNULL);
      
      // Open the Cyberdog item.
      if(cyberPart)
      {
         TempCyberPartExtension cyberPartExt(cyberPart,
                                    kCyberPartExtension); 
         cyberPartExt-&gt;OpenCyberItem(ev,  fingerItem, openerPart,
                              params);
      }
    }
}
</PRE>
 The <CODE>Open</CODE> method attempts to find a window that already displays the item. If it cannot find the window, it opens the window asynchronously or synchronously. If the mode is asynchronous, the <CODE>Open</CODE> method initiates a cooperative Thread Manager thread to open the window, as shown in <A HREF=#MARKER-9-29>Listing 8</A>.<P>
<B>Listing 8  <A NAME=MARKER-9-29></A>The thread that opens an item asynchronously for the Finger service</B><P>
<PRE>
pascal void* FingerItemAsyncOpenThread(AsyncOpenData* openData)
{
   Environment localEv;
   SOM_InitEnvironment(&amp;localEv);
   Environment* ev = &amp;localEv;
   CyberItem* fingerItem = openData-&gt;fFingerItem;
   ParameterSet* params = openData-&gt;fParams;
   ODPart*     openerPart = openData-&gt;fOpenerPart;
   Boolean     aborted = false;
   {
      // Set up a progress broadcaster object.
      CyberProgressBroadcaster* broadcaster 
                              = new CyberProgressBroadcaster;
      broadcaster-&gt;ICyberProgressBroadcaster(ev, 
                           gMyCyberAbortUPP, (Ptr) &amp;aborted);
      
      broadcaster-&gt;SetProgressMode(ev, kUnmeteredProgress);

      // Attach the broadcaster object to the opener part.
      TempOpenerPartExtension openerPartExt(openerPart,
                                 kCyberOpenerPartExtension);
      openerPartExt-&gt;AttachProgressBroadcaster(ev, broadcaster);
   
      // Set the status string to something informative.
      broadcaster-&gt;SetStatusString(ev, &quot;\pUm...thinking...&quot;);
      
      // Simulate a need for asynchronous operation by waiting.
      unsigned long tickOut = TickCount() + 4*60;  // 4 seconds
      while(TickCount() &lt; tickOut &amp;&amp; !aborted)
         YieldToAnyThread();
      
      // Detach the broadcaster object and delete it.
      openerPartExt-&gt;DetachProgressBroadcaster(ev, broadcaster);
      delete broadcaster;
   }
   
   // If the user didn't press the Stop button, create and open a
   // Cyberdog display part.
   if(!aborted)
   {
      // Create the right kind of part in the right document.
      CyberSession* cyberSession = ::GetCyberSession(ev);
      TempODPart cyberPart = cyberSession-&gt;CreateCyberPart(ev,
                           openerPart, kTextPlainKind, kODNULL);
      
      // If the display part handles the kTextPlain kind of data,
      // create a download part instead.
      if(cyberPart == kODNULL)
         cyberPart = cyberSession-&gt;CreatePartInCyberDocument(ev,
                                 kDownloadPartKind, kODNULL);
      
      // Open the Cyberdog item.
      if(cyberPart)
      {
         TempCyberPartExtension cyberPartExt(cyberPart,
                                    kCyberPartExtension); 
         cyberPartExt-&gt;OpenCyberItem(ev,  fingerItem, openerPart,
                              params);
      }
   }
   // Release the parameter set.
   params-&gt;Release(ev);
   delete openData;
   SOM_UninitEnvironment(&amp;localEv);
   
   return nil;
}
</PRE>
<A NAME=HEADING4-28></A>
<H2>Resolving a Cyberdog Item</H2>
 <A NAME=MARKER-2-30></A>When a Cyberdog item is opened, the item determines the kind of data to which it refers. This process is called resolving the item. You must specify how to resolve your Cyberdog item and provide information about the item's state as it is being resolved. To resolve a Cyberdog item, you must override the following methods:<P>
<UL>
<LI>Override the item's <A NAME=MARKER-2-31></A><CODE>IsResolved</CODE> method to specify whether or not the item has been resolved. If you do not override the <CODE>IsResolved</CODE> method, it returns <CODE>kODTrue</CODE>, meaning that it is not necessary to resolve the item. The Finger service's item class does not override this method because the URL points to data whose type is known before the item is opened.
<LI>Override the item's <A NAME=MARKER-2-32></A><CODE>Resolve</CODE> method to identify the kind of data to which the item refers. The Finger service's item class does not override this method because the <CODE>IsResolved</CODE> method always returns <CODE>kODTrue</CODE>. Thus, the <CODE>Resolve</CODE> method is never called.
<LI>Override the item's <A NAME=MARKER-2-33></A><CODE>IsDownloadable</CODE> method to specify whether or not the data associated with the item is downloadable. The superclass implementation returns <CODE>kODFalse</CODE>, meaning that the data cannot be downloaded. The Finger service's item class overrides this method to return <CODE>kODTrue</CODE>, because the Finger service downloads data.
<LI>Override the item's <A NAME=MARKER-2-34></A><CODE>IsSecure</CODE> method to specify whether or not the item points to a secure site. The superclass implementation returns <CODE>kODFalse</CODE>, meaning that the data does not require a protocol that provides security. The Finger service's item class does not override this method.
<LI>If the data can be downloaded, override the item's <A NAME=MARKER-2-35></A><CODE>GetContentKind</CODE> method to specify the kind of data that is returned by the Cyberdog stream. The kind is specified as an OpenDoc token. The Finger service's item specifies text data, thus the item's <CODE>GetContentKind</CODE> method returns the token representing <CODE>kTextPlain</CODE> data, as follows:<P>
</UL>
<PRE>
   ODSession* session = GetCyberSession(ev)-&gt;GetODSession(ev);
   return session-&gt;Tokenize(ev, kTextPlainKind);
</PRE>
<UL>
<LI>Override the item's <A NAME=MARKER-2-36></A><CODE>GetFileInfo</CODE> method to return the file creator and file type of the item. This information is used when the item or its associated data is represented as a file in the Finder. The Finger service item's <CODE>GetFileInfo</CODE> method specifies a creator of <CODE>'????'</CODE> and a type of <CODE>'TEXT'</CODE> for data created by downloading with this item and a creator of <CODE>'odtm'</CODE> and a type of <CODE>'FNGR'</CODE> for references to the data, as shown in <A HREF=#MARKER-9-37>Listing 9</A>.<P>
</UL>
<B>Listing 9  <A NAME=MARKER-9-37></A>The <CODE>GetFileInfo</CODE> method of the Finger service item</B><P>
<PRE>
SOM_Scope void  SOMLINK FingerItem__GetFileInfo
               (AppleCyberdog_FingerItem *somSelf, Environment *ev,
                CDItemInfoType infoType,
                ODOSType* flCreator,
                ODOSType* flType)
{
   ...
   if(infoType == kCDInfoDownload)
   {
      *flCreator = '????';
      *flType = 'TEXT';
   }
   else
   {
      *flCreator = 'odtm';
      *flType = 'FNGR';
   }
}
</PRE>
 The <A NAME=MARKER-2-38></A>kCDInfoDownload constant indicates that the data is in its native form, which is text in the Finger sample.<P>
<A NAME=HEADING4-40></A>
<H2>Creating a Cyberdog Stream</H2>
 <A NAME=MARKER-2-39></A>If your item's content is accessible via a stream, you must override your item's <A NAME=MARKER-2-40></A><CODE>CreateCyberStream</CODE> method to create a Cyberdog stream that uses the service's protocol to download data. <A HREF=#MARKER-9-41>Listing 10</A> shows the <CODE>CreateCyberStream</CODE> method of the Finger service item.<P>
<B>Listing 10  <A NAME=MARKER-9-41></A>The <CODE>CreateCyberStream</CODE> method of the Finger item</B><P>
<PRE>
SOM_Scope CyberStream*  SOMLINK FingerItem__CreateCyberStream
               (AppleCyberdog_FingerItem *somSelf, Environment *ev)
{
   ...
   CFingerItemData* data = (CFingerItemData*) somThis-&gt;fData;
   
   AppleCyberdog_FingerStream* stream = new AppleCyberdog_FingerStream;
   stream-&gt;IFingerStream(ev, data-&gt;fURL);
   
    return stream;
}
</PRE>
<A NAME=HEADING4-44></A>
<H2>Flattening and Unflattening a Cyberdog Item</H2>
 <A NAME=MARKER-2-42></A>You must override your Cyberdog item's <A NAME=MARKER-2-43></A><CODE>Flatten</CODE> and <A NAME=MARKER-2-44></A><CODE>Unflatten</CODE> methods so that the item can be written to and read from a storage unit. These methods create a flat representation of a Cyberdog item and recreate an item from its flat representation, respectively. You must override its <A NAME=MARKER-2-45></A><CODE>GetFlatSize</CODE> method to return the size of the flattened item. <P>
 You must use Cyberdog's format for your flattened items. You can place your item's unique values (called private data) after the required data. See the description of the <CODE>CyberItem</CODE> class in the Classes and Methods chapter of the <I>Cyberdog Programmer's Kit</I> for the structure of a flattened Cyberdog item.<P>
 <A HREF=#MARKER-9-46>Listing 11</A> shows the <CODE>Flatten</CODE> method of the Finger service item. The Finger service item does not contain any private data.<P>
<B>Listing 11  <A NAME=MARKER-9-46></A>The <CODE>Flatten</CODE> method of the Finger service item</B><P>
<PRE>
SOM_Scope long  SOMLINK FingerItem__Flatten
               (AppleCyberdog_FingerItem *somSelf, Environment *ev,
                Ptr buffer,
                long length)
{
   ...
   CFingerItemData* data = (CFingerItemData*) somThis-&gt;fData;

   long flatSize = somSelf-&gt;GetFlatSize(ev);
   
   if(flatSize &lt;= length)
   {
      long classNameLen = strlen(kFingerItemClassName);
      char* url = nil;
      StringPtr defaultName = nil;
      ScriptCode defaultNameScript = smRoman;
      
      if(data)
      {
         url = data-&gt;fURL;
         defaultName = data-&gt;fDefaultName;
         defaultNameScript = data-&gt;fDefaultNameScript;
      }
   
      Ptr p = buffer;
      
      *((long*)p) = flatSize;
      p += sizeof(long);
      
      *((short*)p) = kCyberItemSignature;
      p += sizeof(short);
      
      *((short*)p) = kCyberItemVersionNum;
      p += sizeof(short);
      
      *((long*)p) = classNameLen;
      p += sizeof(long);
      
      memcpy(p, kFingerItemClassName, classNameLen);
      p += classNameLen;
      
      *((short*)p) = defaultNameScript;
      p += sizeof(short);
      
      if(defaultName)
      {
         memcpy(p, defaultName, defaultName[0] + 1);
         p += defaultName[0] + 1;
      }
      else
      {
         *p = 0;
         p += 1;
      }
      
      if(url)
      {
         long urlLen = strlen(url);
         *((long*)p) = urlLen;
         p += sizeof(long);
         memcpy(p, url, urlLen);
         p += urlLen;
      }
      else
      {
         *((long*)p) = 0;
         p += sizeof(long);
      }

      *((long*)p) = 0;
      p += sizeof(long);
   }
   else
      // Error--the buffer is not large enough to flatten into
      flatSize = 0;
      
   return flatSize;
}
</PRE>
 <A HREF=#MARKER-9-47>Listing 12</A> shows the <CODE>Unflatten</CODE> method of the Finger service item, which unflattens the item. The method shows the minimum amount of effort required to unflatten any Cyberdog item.<P>
<B>Listing 12  <A NAME=MARKER-9-47></A>The <CODE>Unflatten</CODE> method Finger service item</B><P>
<PRE>
SOM_Scope long  SOMLINK FingerItem__Unflatten
               (AppleCyberdog_FingerItem *somSelf, Environment *ev,
                Ptr buffer)
{
   ...
   CFingerItemData* data = (CFingerItemData*) somThis-&gt;fData;
   
   Ptr p = buffer;
   
   long flatSize = *((long*)p);
   p += sizeof(long);
   
   if(data)
   {
      short cyberItemSignature = *((short*)p);
      p += sizeof(short);

      short cyberItemVersion = *((short*)p);
      p += sizeof(short);
      
      long classNameLen = *((long*)p);
      p += sizeof(long);
      p += classNameLen;
      
      short defaultNameScript = *((short*)p);
      p += sizeof(short);
      
      StringPtr defaultName = (StringPtr) p;
      somSelf-&gt;SetDefaultName(ev, defaultName, defaultNameScript);
      p += defaultName[0] + 1;
      
      long urlLen = *((long*)p);
      p += sizeof(long);
      
      if(data-&gt;fURL)
         ODDisposePtr(data-&gt;fURL);
      data-&gt;fURL = (char*) ODNewPtr(urlLen + 1);
      memcpy(data-&gt;fURL, p, urlLen);
      data-&gt;fURL[urlLen] = 0;
      p += urlLen;
   }
   
   return flatSize;
}
</PRE>
 <A HREF=#MARKER-9-48>Listing 13</A> shows the <CODE>GetFlatSize</CODE> method of the Finger service item, which returns the size of the flattened item. Because the item does not contain any private data, it returns the minimum size of any flattened item.<P>
<B>Listing 13  <A NAME=MARKER-9-48></A>The <CODE>GetFlatSize</CODE> method of the Finger service item</B><P>
<PRE>
SOM_Scope long  SOMLINK FingerItem__GetFlatSize
               (AppleCyberdog_FingerItem *somSelf, Environment *ev)
{
   ...
   CFingerItemData* data = (CFingerItemData*) somThis-&gt;fData;

   long flatSize;
   long classNameLen = strlen(&quot;AppleCyberdog_FingerItem&quot;);
   long urlLen = 0;
   long defaultNameLen = 0;
   
   if(data)
   {
      if(data-&gt;fURL)
         urlLen = strlen(data-&gt;fURL);
      if(data-&gt;fDefaultName)
         defaultNameLen = data-&gt;fDefaultName[0];
   }
   flatSize =  sizeof(long) + // Overall length
            sizeof(short) +   // CyberItem Signature
            sizeof(short) +   // Version
            sizeof(long) +    // Class length
            classNameLen +    // Class name (no null
                              // termination)
            sizeof(ScriptCode) +// Display name script code
            defaultNameLen + 1 +// Display name (plus 1 byte
                              // for the length byte)
            sizeof(long) +    // URL length
            urlLen +          // URL
            sizeof(long);     // Private data length

   return flatSize;
}
</PRE>
<A NAME=HEADING4-56></A>
<H2>Writing a Cyberdog Item to a Storage Unit</H2>
 <A NAME=MARKER-2-49></A>You must override your Cyberdog item's<A NAME=MARKER-2-50></A> <CODE>ExternalizeContent</CODE> method to write its content to storage. <A HREF=#MARKER-9-51>Listing 14</A> shows the <CODE>ExternalizeContent</CODE> method of the Finger service item. The method writes a Finger service item to storage in its internal format (<CODE>kCyberItemKind</CODE>) and also writes the URL as text.<P>
<B>Listing 14  <A NAME=MARKER-9-51></A>The <CODE>ExternalizeContent</CODE> method of the Finger service item</B><P>
<PRE>
SOM_Scope void  SOMLINK FingerItem__ExternalizeContent
               (AppleCyberdog_FingerItem *somSelf, Environment *ev,
                ODStorageUnit* su)
{
   ...
   CFingerItemData* data = (CFingerItemData*) somThis-&gt;fData;

   // Add a kCyberItemKind key with the flattened 
   // Cyberdog item as its value.
   
   su-&gt;AddValue(ev, kCyberItemKind);
   somSelf-&gt;StreamToStorageUnit(ev, su);
   
   // Add a kODPlatformDataType key (scrapbook text) with the URL 
   // as its value.
   if(data &amp;&amp; data-&gt;fURL)
   {
      ODTranslation* translation
       = ::GetCyberSession(ev)-&gt;GetODSession(ev)-&gt;GetTranslation(ev);
      TempODValueType textType 
       = translation-&gt;GetISOTypeFromPlatformType
                           (ev, 'TEXT', kODPlatformDataType);
      
      if(textType != nil)
      {
         su-&gt;AddValue(ev, textType);
         StorageUnitSetValue
               (su, ev, strlen(data-&gt;fURL), (ODValue)data-&gt;fURL);
      }
   }
}
</PRE>
<A NAME=HEADING4-60></A>
<H2>Cloning and Comparing a Cyberdog Item</H2>
 You must override your Cyberdog item's <A NAME=MARKER-2-52></A><CODE>Clone</CODE> method to allow the item to be copied. You must override your Cyberdog item's <A NAME=MARKER-2-53></A><CODE>Compare</CODE> method to allow an item to be compared with other items. An item that is created as a clone of another item should be equivalent when they are compared.<P>
 <A HREF=#MARKER-9-54>Listing 15</A> shows the <CODE>Clone</CODE> method of the Finger service item. After the method creates and initializes a new Finger service item, the method calls the item's SetUpFromURL method to set initial values for the item's fields. See <A HREF=#MARKER-9-23>"Setting Up a Cyberdog Item" (page 10)</A> for information about the SetUpFromURL method.<P>
<B>Listing 15  <A NAME=MARKER-9-54></A>The <CODE>Clone</CODE> method of the Finger service item</B><P>
<PRE>
SOM_Scope CyberItem*  SOMLINK FingerItem__Clone
               (AppleCyberdog_FingerItem *somSelf, Environment *ev)
{
   ...
   CFingerItemData* data = (CFingerItemData*) somThis-&gt;fData;
   
   AppleCyberdog_FingerItem* clone = new AppleCyberdog_FingerItem;
   clone-&gt;ICyberItem(ev);
   clone-&gt;SetUpFromURL(ev, 
          data-&gt;fURL, data-&gt;fDefaultName, data-&gt;fDefaultNameScript);
   
   return clone;
}
</PRE>
 <A HREF=#MARKER-9-55>Listing 16</A> shows the <CODE>Compare</CODE> method of the Finger service item. The method calls its inherited <CODE>Compare</CODE> method to determine whether the items being compared are derived from the same SOM class. If so, the URL text is compared for equality. If the URLs match, the items are equivalent.<P>
<B>Listing 16  <A NAME=MARKER-9-55></A>The <CODE>Compare</CODE> method of the Finger service item</B><P>
<PRE>
SOM_Scope CDCompareType  SOMLINK FingerItem__Compare
               (AppleCyberdog_FingerItem *somSelf, Environment *ev,
                CyberItem* compare)
{
   ...
   // Call the inherited method first to determine whether the
   // Cyberdog items are of the same SOM class or not.
   CDCompareType val = AppleCyberdog_FingerItem_parent_CyberItem_Compare
                                       (somSelf,ev,compare);
   
   if(val == kCDCompareEqual)
   {
      // The item is a Finger service item.
      // Base the comparison on the URL.
      
      char* ourURL = somSelf-&gt;GetURL(ev);
      char* itsURL = compare-&gt;GetURL(ev);
      
      int stringCompare = strcmp(ourURL, itsURL);
      
      if(stringCompare &lt; 0)
         val = kCDCompareLessThan;
      else if(stringCompare &gt; 0)
         val = kCDCompareGreaterThan;
      else
         val = kCDCompareEqual;
   }
   return val;
}
</PRE>
<A NAME=HEADING4-68></A>
<H2>Retrieving a Cyberdog Item's Icons</H2>
 <A NAME=MARKER-2-56></A>You must override your Cyberdog item's <A NAME=MARKER-2-57></A><CODE>GetIconSuite</CODE> method to retrieve the item's icon suite. <A HREF=#MARKER-9-58>Listing 17</A> shows the <CODE>GetIconSuite</CODE> method of the Finger service item.<P>
<B>Listing 17  <A NAME=MARKER-9-58></A>The <CODE>GetIconSuite</CODE> method of the Finger service item</B><P>
<PRE>
SOM_Scope Handle  SOMLINK FingerItem__GetIconSuite
               (AppleCyberdog_FingerItem *somSelf, Environment *ev,
                CDItemInfoType infoType)
{
   ...
   CFingerItemData* data = (CFingerItemData*) somThis-&gt;fData;

   if(data-&gt;gIconSuite == nil)
   {
      CUsingLibraryResources rsrcAccess;
      ::GetDetachedIconSuite(&amp;data-&gt;gIconSuite, 128);
   }
return data-&gt;gIconSuite;
}
</PRE>
 The <CODE>GetIconSuite</CODE> method calls the <CODE>GetDetachedIconSuite</CODE> function, shown in <A HREF=#MARKER-9-59>Listing 18</A>, to retrieve the icon suite and detach its handles.<P>
<B>Listing 18  <A NAME=MARKER-9-59></A>The <CODE>GetDetachedIconSuite</CODE> function</B><P>
<PRE>
OSErr GetDetachedIconSuite (Handle *theIconSuite, short resID,
                     IconSelectorValue selector)
{
   OSErr err;
   THz zone = GetZone();
   
   SetZone(SystemZone());
   
   *theIconSuite = nil;
   err = GetIconSuite(theIconSuite, resID, selector);
   
   // Detach the resource handles.
   if (err == noErr)
   {
      RoutineDescriptor detachProc =
         BUILD_ROUTINE_DESCRIPTOR(uppIconActionProcInfo, DetachProc);
      err = ForEachIconDo(*theIconSuite, selector, &amp;detachProc, nil);
   }
   SetZone(zone);
   return err;
}
</PRE>
 The <CODE>GetDetachedIconSuite</CODE> function calls a the DetachProc function for each icon in the suite. The DetachProc function, shown in <A HREF=#MARKER-9-60>Listing 19</A>, detaches the icon's handle.<P>
<B>Listing 19  <A NAME=MARKER-9-60></A>The <CODE>DetachProc</CODE> function</B><P>
<PRE>
static pascal OSErr DetachProc
      (ResType /* theType */, Handle* theIcon, void* /* yourDataPtr */)
{
   if (theIcon &amp;&amp; (*theIcon))
      DetachResource(*theIcon);
   return noErr;
}
</PRE>
<A NAME=HEADING4-78></A>
<H2>Getting and Setting a Cyberdog Item's Characteristics</H2>
 Your service's item class may need to override additional methods that get or set the data associated with the Cyberdog item, as follows:<P>
<UL>
<LI>Override the <A NAME=MARKER-2-61></A><CODE>GetFlags</CODE> method if you do not want to log your Cyberdog item or if you do not want to allow the item to be embedded. The Finger service's item class does not override this method.
<LI>Override the <A NAME=MARKER-2-62></A><CODE>GetStringProperty</CODE> method to return the value of each string associated with your Cyberdog item. The Finger service's item class overrides this method to return the default name property and the name's script system.
<LI>Override the <A NAME=MARKER-2-63></A><CODE>GetURL</CODE> method to return the URL for the item in a null-terminated string. The Finger service item class overrides this method.
<LI>Override the <A NAME=MARKER-2-64></A><CODE>SetDefaultName</CODE> method to set the default display name for the Cyberdog item. The Finger service item class overrides this method.
<LI>Override the <A NAME=MARKER-2-65></A><CODE>ShowInfoPart</CODE> method to change the display in the Item Info window for your Cyberdog item. The superclass implementation of this method displays the Cyberdog item's default display name and URL. The Finger service's item class does not override this method. 
<LI>If your Cyberdog item refers to a secure location, override the <CODE><A NAME=MARKER-2-66></A>ShowSecurityInfo</CODE> method to display the Security Info window for your Cyberdog item. The Finger service's item class does not override this method because its items do not refer to secure locations. <P>
</UL>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="ServiceExample-3.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="ServiceExample-1.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="ServiceExample-7.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="ServiceExample-5.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<P>
<FONT SIZE="-1">
<center><font size=-1><A HREF="ServiceExample-1A.html">&copy; Apple Computer, Inc.</A><br>1 JUNE 1996</center></font><P>
<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->
</BODY>
</HTML> 
