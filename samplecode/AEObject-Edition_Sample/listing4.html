<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>AEObject-Edition Sample - /AppleEventCore.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxCarbon-date.html">Carbon</a> &gt; <A HREF="javascript:location.replace('index.html');">AEObject-Edition Sample</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxInterapplicationCommunication-date.html" target="_blank">Carbon > Interapplication Communication</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">AEObject-Edition Sample</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/AppleEventCore.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/AEObject-Edition Sample.r</option>
<option value="listing2.html">/AEObject.c</option>
<option value="listing3.html">/AEUtilities.c</option>
<option value="listing4.html">/AppleEventCore.c</option>
<option value="listing5.html">/BuildHeaders.c</option>
<option value="listing6.html">/Files.c</option>
<option value="listing7.html">/globals.c</option>
<option value="listing8.html">/Initialize.c</option>
<option value="listing9.html">/Macros.h</option>
<option value="listing10.html">/main.c</option>
<option value="listing11.html">/Menu.c</option>
<option value="listing12.html">/Print.c</option>
<option value="listing13.html">/prototypes.h</option>
<option value="listing14.html">/Publish.c</option>
<option value="listing15.html">/SampConstants.h</option>
<option value="listing16.html">/Sampdefines.h</option>
<option value="listing17.html">/Structs.h</option>
<option value="listing18.html">/Subscribe.c</option>
<option value="listing19.html">/TextSections.c</option>
<option value="listing20.html">/Utilities.c</option>
<option value="listing21.html">/Windows.c</option></select>
				</p>
				</form>
				<p><strong><a href="AEObject-Edition_Sample.zip">Download Sample</a></strong> (&#147;AEObject-Edition_Sample.zip&#148;, 895.6K)<BR>
<strong><a href="AEObject-Edition_Sample.dmg">Download Sample</a></strong> (&#147;AEObject-Edition_Sample.dmg&#148;, 1.22M)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*------------------------------------------------------------------------------**  Apple Developer Technical Support**  AppleEvent specific routines**  Program:    AEObject-Edition Sample*  File:       AppleEventCore.c - C Source**  by:         C.K. Haun &lt;TR&gt;**  Copyright &copy; 1990-1992 Apple Computer, Inc.*  All rights reserved.**------------------------------------------------------------------------------* This file handles the generic AppleEvent handlers, as well as intialization* and installing the handlers I'll need for this application.* Also installs my coercion handlers and has the interaction Idle proc.* Other, more specific AE handling (like edition functions) are in the functional * area files.* Functions that deal specifically with AppleEvent(tm) Objects are in the * file AEObject.c.*----------------------------------------------------------------------------*//* AESample v1: Removed all ShowMe error notifications, replaced with macro to display *//* errors non-intrusively in AESatus window */#define __AEM__#pragma segment Main/* DoHighLevel will be in main, just because */#include &quot;Sampdefines.h&quot;/* DoHighLevel processes our high level events *//* All the HLEs that come into my application get dispatched to here. *//* All I do is call AEProcessAppleEvent, because I do not support any *//* other types of High Level Events, justs AEs. */void DoHighLevel(EventRecord AERecord){    OSErr fred2;    /* Process the event. */    /* Here's what happens;     1) If this is an AppleEvent, and we have a handler installed for this event,     AEProcessAppleEvent jumps to that handler     else    2) If there is a system handler for this event, AEProcessAppleEvent jumps to that    else    3) return errEventNotHandled.    */    /* **** NOTE: If you are sending AppleEvents to yourself (using a PSN of kCurrentProcess */    /* in the address AEDesc to AECreateAppleEvent) then events sent to yourself that */    /* way will NOT come here!  They will be dispatched directly to the  */    /* correct handler by the AppleEvent manager!  Try it in this sample. */    fred2 = AEProcessAppleEvent(&amp;AERecord);    if ((fred2 != userCanceledErr) &amp;&amp; (fred2 != noErr) &amp;&amp; (fred2 != errAEEventNotHandled))        mAEErrorDisplay(&quot;\pAppleEvent Proccessing.&quot;, fred2)        /* if it was a userCanceledErr (from the quit routine) and the reply has been */        /* sent from there already */        /* if it's a errAEEventNotHandled, then someone sent us  an event we're not prepared for, */        /* that is not a reason to put up a dialog.  Since anyone can send us events, then */        /* we could get all kinds of stray stuff, so just ignore it. */    /* you may want to check for debugging reasons */        }/* end DoHighLevel */#pragma segment AppleEvents/***************************************************************************************MissedAnyParametersUsed to check for any unread required parameters. Returns true if we missed atleast one.*****************************************************************************************/Boolean MissedAnyParameters(AppleEvent *message){    OSErr err;    DescType ignoredActualType;    AEKeyword missedKeyword;    Size ignoredActualSize;    EventRecord event;        err = AEGetAttributePtr(message, keyMissedKeywordAttr, typeKeyword, &amp;ignoredActualType, (Ptr)&amp;missedKeyword,                            sizeof(missedKeyword), &amp;ignoredActualSize);        /* no error means that we found some more.*/        if (!err) {        event.message = *(long *)&amp;ignoredActualType;        event.where = *(Point *)&amp;missedKeyword;        mAEErrorDisplay(&quot;\pMissedAnyParameters: got parameters I don't know what to do with.&quot;, err)        err = errAEEventNotHandled;    }        /* errAEDescNotFound means that there are no more parameters. If we get */    /* an error code other than that, flag it. */        else if (err != errAEDescNotFound) {        mAEErrorDisplay(&quot;\pMissedAnyParameters: after AEGetAttributeDesc.&quot;, err)            }    return(err != errAEDescNotFound);}/* This is the standard Open Application event.  You'll get this as one of the (if not the ) *//* first events in your application.  So, we open up a blank document *//* You will _NOT_ get this if you were launched with an event (like an 'odoc' or 'pdoc' ) *//* so do _not_ do application initialiaztion things here!  This routine may never *//* get called! */pascal OSErr AEOpenHandler(AppleEvent *messagein, AppleEvent *reply, long refIn){    OSErr myErr = noErr;#pragma unused (messagein,refIn)  gCurrentReply = reply;    ChangePlane(AddNewWindow(true));                        /* open our initial, blank window */    /* and make sure it's the front window */        mAEErrorDisplay(&quot;\pOpen App Handler&quot;, myErr)  gCurrentReply = nil;    return(myErr);}/* end AEOpenHandler *//* Open Doc, opens our documents.  Remember, this can happen at application start AND *//* anytime else.  If your app is up and running and the user goes to the desktop, hilites one *//* of your files, and double-clicks or selects Open from the finder File menu this event *//* handler will get called. Which means you don't do any initialization of globals here, or *//* anything else except open then doc.  *//* SO -- Do NOT assume that you are at app start time in this *//* routine, or bad things will surely happen to you. */pascal OSErr AEOpenDocHandler(AppleEvent *messagein, AppleEvent *reply, long refIn){    OSErr myErr = noErr;#pragma unused ( refIn)  gCurrentReply = reply;    /* In previous versions I was coming to the front on this message.  This is _not_ */    /* the proper thing to do.  I have changed things to call AEInteractWithUser.  */    /*  The user (or the AEm will bring us forward if appropriate).  But we may _not_ be  */    /*required to come forward, it may be perfectly reasonable to stay in the background */  /* so don't do anything unless you really need to, like to put up a dialog */  /* which we don't have to, so just press on */    myErr = processOpenPrint(messagein, false);  gCurrentReply = nil;    return(myErr);}/* Same logic as OpenDoc */pascal OSErr AEPrintHandler(AppleEvent *messagein, AppleEvent *reply, long refIn){                                                           /* no printing handler in yet, so we'll ignore this */    /* the operation is functionally identical to the ODOC event, with the additon */    /* of calling your print routine.  */#pragma unused (refIn)  gCurrentReply = reply;    processOpenPrint(messagein, true);  gCurrentReply = nil;    return(noErr);}/* Standard Quit event handler, to handle a Quit event from the Finder, for example.  *//* ***** DO NOT CALL EXITTOSHELL HERE ***** or you will never have a happy life.  *//* OK, it's a few months after I wrote that comment, and I've seen a lot of code *//* come through DTS that calls ExitToShell from quit handlers.  Let me explain... *//* When an AppleEvent Handler is called (like this quit handler) you are ALMOST *//* 100% in your application world.  A5 is right, you can call any toolbox function, *//* you can call your own routines, everything _seems_ like you are in complete  *//* control.  Well, almost but not quite.  The routine has been dispatch to from the *//* AppleEvent Manager's space, so you _must_ return to that at some point! *//* Which is why you can't call ETS from here.  When you call ExitToShell from an *//* AE Handler, the most likely thing that happens is the FInder quits, and your  *//* application keeps running.  Which ain't what you want, y'know? *//* so, DON'T CALL EXITTOSHELL FROM AN APPLEEVENT HANDLER!!!!!!!!!!!!!! */pascal OSErr AEQuitHandler(AppleEvent *messagein, AppleEvent *reply, long refIn){#pragma unused (messagein,refIn)    OSErr theErr;    Str32 userCanx;  gCurrentReply = reply;    theErr = PrepQuit();                                    /* prepQuit sets the Stop flag for us.  It does _NOT_ quit, you */    /* should NEVER quit from an AppleEvent handler.  Calling */    /* ExitToShell here would blow things up */        if (!theErr){  gCurrentReply = nil;        return(noErr);}    if (theErr == (userCanceledErr)) {        /* reply to the application that told us to quit */        GetIndString(userCanx,kGeneralStrings,kUCanxString);    AEPutParamPtr(reply, keyErrorNumber, typeLongInteger, (Ptr)&amp;theErr, sizeof(OSErr));        AEPutParamPtr(reply, keyErrorString, typeChar, (Ptr)&amp;userCanx, userCanx[0]);    }  gCurrentReply = nil;        return(theErr);    }/* This is the 'ansr', or answer, handler.  You need this if you ever want to *//* use QueueReply as an option to AESend (which you will) since the reply  *//* is going to be coming in through your event loop like any other  *//* AppleEvent.   So here it is */pascal OSErr AEAnswerHandler(AppleEvent *messagein, AppleEvent *reply, long refIn){#pragma unused (refIn)     OSErr myErr = noErr;      gCurrentReply = reply;    mVerboseOutput(&quot;\p\nGot an answer from an event&quot;)    DisplayReturnedData((AEDesc *)messagein);  gCurrentReply = nil;    return(myErr);    /* **** NOTE:  One thing you may want to consider, and it's a side-effect of */    /* the AppleEvent manager's direct dispatching of events if you send them to yourself */    /* using the kCurrentProcess Process Serial Number constant. */    /* If you use kCurrentProcess, then the AppleEvent manager will directly dispatch */    /* to the AppleEvent handler, the event will _not_ go through WaitNextEvent. */    /* Normally, that's a very good thing.  But there is one potential problem.... */    /* It means that kQueueReply doesn't quite work the way you think it will when sending to */    /* yourself.  The reply will _not_ be put in the event queue, instead this Answer hander */    /* will be called directly.  And if you reply from the answer handler, that will dispatch right  */    /* back to itself.  And so on.  So be aware that Queued replies are _not_ really  */    /* queued when you are using kCurrentProcess! */}/* my routine to snatch a section handle out of an AppleEvent */OSErr GetSectionHandleFromEvent(AppleEvent *AEin, SectionHandle *theSection){    DescType thisType;    Size returnedSize;    return(AEGetParamPtr(AEin, keyDirectObject, typeSectionH, &amp;thisType, (Ptr)theSection, sizeof(theSection), &amp;returnedSize));}/* processOpenPrint handles ODOC and PDOC events.  Both events open a document, one prints it */OSErr processOpenPrint(AppleEvent *messagein, Boolean printIt){    OSErr err;    OSErr err2;    AEDesc theDesc;    FSSpec theFSS;    register qq;    long numFilesToOpen;    AEKeyword ignoredKeyWord;    DescType ignoredType;    Size ignoredSize;    WindowPtr tWind;    err = AEGetParamDesc(messagein, keyDirectObject, typeAEList, &amp;theDesc);    if (err) {        mAEErrorDisplay(&quot;\pGetParamDesc error in Open/Print&quot;, err)    }    if (!MissedAnyParameters(messagein)) {                /* Got all the parameters we need. Now, go through the direct object, */        /* see what type it is, and parse it up. */                if (err = AECountItems(&amp;theDesc, &amp;numFilesToOpen)) {            mAEErrorDisplay(&quot;\pAECountItems error in Open/Print&quot;, err)        } else {            for (qq = 1; ((qq &lt;= numFilesToOpen) &amp;&amp; (!err)); ++qq) {                if (err = AEGetNthPtr(&amp;theDesc, qq, typeFSS, &amp;ignoredKeyWord, &amp;ignoredType, (Ptr)&amp;theFSS, sizeof(theFSS),                                      &amp;ignoredSize)) {                    mAEErrorDisplay(&quot;\pAEGetNthPtr in Open/Print&quot;, err)                                    } else {                    FInfo fileInfo;                    FSpGetFInfo(&amp;theFSS, &amp;fileInfo);        /* make sure it's a data file */                    if (fileInfo.fdCreator == kMySignature &amp;&amp; fileInfo.fdType == kMyDocumentFileType)                        tWind = OpenFile(&amp;theFSS);                    else                        tWind = nil;                        /* they may have double clicked on the prefs file */                }                if (printIt &amp;&amp; tWind != nil) {                                        PrintIt(tWind, false);                  /* in Print.c.  Does not yet print, but the idea is there */                    CloseMyWindow(tWind);                }            }                                               /* for qq = ... */        }                                                   /* AECountItems OK */    }                                                       /* Got all necessary parameters */        if (err2 = AEDisposeDesc(&amp;theDesc)) {        mAEErrorDisplay(&quot;\pAEDisposeDesc in Open/Print&quot;, err2)    }    return(err ? err : err2);}/* This is an AppleEvent Idle function.  It can be passed to AEInteractWithUser *//* or AESend. *//* What it does is this; *//* If some AppleEvent thing is taking a really long time, the AppleEvent manager *//* will call WaitNextEvent FOR you (yeah, yeah, only one event loop per app, oh well) *//* and give you a result (limited) if you need to do something.  That something *//* will only be an update,activate,OSevent, or null event */pascal Boolean CommonIdleFunction(EventRecord *whatEvent, long *sleeping, RgnHandle *mouseRgn){    extern Boolean gInBackground;        extern RgnHandle mousergn;    switch (whatEvent-&gt;what) {        case updateEvt:            DrawIt((WindowPtr)whatEvent-&gt;message);          /* draw whatever window needs an update */                        break;        case activateEvt:            if (whatEvent-&gt;modifiers &amp; activeFlag)                DrawIt((WindowPtr)whatEvent-&gt;message);            break;        case app4Evt:                                       /* or kOSEvent, I'm old fashioned */            switch ((whatEvent-&gt;message &gt;&gt; 24) &amp; 0x0FF) {       /* high byte of message */                case suspendResumeMessage:                  /* suspend/resume is also an activate/deactivate */                    gInBackground = (whatEvent-&gt;message &amp; kResumeMask) == 0;                    if (gInBackground) {                        SpitClip();                         /* export the clipboard please */                        /* deactivate the current TextEdit record as necessary */                        if (FrontWindow() != nil) {                            windowCHandle tempCH = (windowCHandle)GetWRefCon(FrontWindow());                            if ((*tempCH)-&gt;boxHandle != nil)                                TEDeactivate((*tempCH)-&gt;boxHandle);                        }                    } else {                        if (FrontWindow() != nil) {                            windowCHandle tempCH = (windowCHandle)GetWRefCon(FrontWindow());                            if ((*tempCH)-&gt;boxHandle != nil)                                TEActivate((*tempCH)-&gt;boxHandle);                        }                    }                    break;            }            break;        case nullEvent:            AdjustCursor(whatEvent-&gt;where, mousergn);            *sleeping = 20;                                  /* may as well sleep a while */            *mouseRgn = mousergn;            break;         }    return(false);                                          /* If it takes for-ever I will wait, for you...  Sorry. */}AEIdleUPP gCommonIdleFunctionUPP = NewAEIdleProc(CommonIdleFunction);/* This function sends a GetData AppleEvent to someone, and displays the *//* results in the AEStatus window */void SendGetData(short which){    AEDesc thisAddress;    AppleEvent theEvent;    AEDesc reply;    OSErr myErr = noErr;    /* first make an address */    MakeAddress(&amp;thisAddress);    myErr = AECreateAppleEvent(kAECoreSuite, kAEGetData, &amp;thisAddress, kAutoGenerateReturnID, kAnyTransactionID, &amp;theEvent);    myErr = BuildGetDataEvent(&amp;theEvent, which);            /* in AEObjects.c */    if (!myErr) {        /* reply may or may not be used, depending on the reply mode you have set */        myErr = DoSend(&amp;theEvent, &amp;reply);        if (!myErr) {            /* display the results, if we were in WaitReply */            if (gReplyMode == 1)                DisplayReturnedData(&amp;reply);        }    }}/* This function sends a SetData AppleEvent to someone, and displays the *//* results in the AEStatus window */void SendSetData(short which){    AEDesc thisAddress;    AppleEvent theEvent;    AEDesc reply;    OSErr myErr = noErr;    /* first make an address */    MakeAddress(&amp;thisAddress);    myErr = AECreateAppleEvent(kAECoreSuite, kAESetData, &amp;thisAddress, kAutoGenerateReturnID, kAnyTransactionID, &amp;theEvent);    myErr = BuildSetDataEvent(&amp;theEvent, which);            /* in AEObjects.c */    if (!myErr) {         DoSend(&amp;theEvent, &amp;reply);    }}/* Dialog box handler for the Interaction Settings you want to use for this sample */void SetInteractionLevels(void){    /* call my common start routine and preset some buttons */    DialogPtr tdial = CommonDStart(kInteractionDialog, gLocalInteraction + 6, gAESendInteraction + 9);    short hitItem = 0;    /* save some stuff in case the user cancels */    short saveMode1 = gLocalInteraction;    short saveMode2 = gAESendInteraction;    short saveMode3 = gAESwitchLayer;        /* one additial item to set */    SetControlValue(SnatchHandle(tdial, kSwitchLItem), gAESwitchLayer);      /* run the dialog */  {    ModalFilterUPP upp = NewModalFilterProc(standardDialogFilter);      while (hitItem != ok &amp;&amp; hitItem != cancel) {      ModalDialog(upp, &amp;hitItem);      switch (hitItem) {        case kSelfIItem:        case kLocalIItem:        case kAllIItem:          /* check boxes, just toggle them */          SetControlValue(SnatchHandle(tdial, gLocalInteraction + kSelfIItem), false);          gLocalInteraction = hitItem - kSelfIItem;          SetControlValue(SnatchHandle(tdial, gLocalInteraction + kSelfIItem), true);          break;                  case kNeverIItem:        case kCanIItem:        case kAlwaysIItem:          /* more toggleable checkboxes */          SetControlValue(SnatchHandle(tdial, gAESendInteraction + kNeverIItem), false);          gAESendInteraction = hitItem - kNeverIItem;          SetControlValue(SnatchHandle(tdial, gAESendInteraction + kNeverIItem), true);                    break;        case kSwitchLItem:          gAESwitchLayer = (gAESwitchLayer ? false : kAECanSwitchLayer);          SetControlValue(SnatchHandle(tdial, kSwitchLItem), gAESwitchLayer);          break;        default:          break;      }    }    DisposeDialog(tdial);    DisposeRoutineDescriptor(upp);  }      if (hitItem == cancel) {        /* if they canceled, restore the old values */        gLocalInteraction = saveMode1;        gAESendInteraction = saveMode2;        gAESwitchLayer = saveMode3;            } else {  /* set interaction levels to what the user picked  */  AESetInteractionAllowed(gLocalInteraction);  }}/* Dialog box handler for the addressing mode you want to use for this sample */void SetTargetAddress(void){    /* bring up dialog and preset some stuff */    DialogPtr tdial = CommonDStart(kAddressingDialog, gAddressMode + kSelfAddressCurrItem, 0);    short hitItem = 0;    short saveMode = gAddressMode;    /* if an address is already specified, draw it in the box */    ParamText(&amp;targetName, &quot;&quot;, &quot;&quot;, &quot;&quot;);    /* dim out the 'Select Target' button if the right check box is not set */    if (gAddressMode + kSelfAddressCurrItem != kOtherAppItem)        HiliteControl(SnatchHandle(tdial, kSelectProcItem), 255);       /* can't find the constant for dimmed, somebody tell me where it is,please */  {    ModalFilterUPP upp = NewModalFilterProc(standardDialogFilter);    /* run the dialog */    while (hitItem != ok &amp;&amp; hitItem != cancel) {      ModalDialog(upp, &amp;hitItem);      switch (hitItem) {        case kSelfAddressCurrItem:        case kSelfAddressPSNItem:        case kOtherAppItem:          /* checkbox toggling, and also setting the hilite state of the 'Set Target' */          /* button as necessary */          SetControlValue(SnatchHandle(tdial, gAddressMode + kSelfAddressCurrItem), false);          gAddressMode = hitItem - kSelfAddressCurrItem;          SetControlValue(SnatchHandle(tdial, gAddressMode + kSelfAddressCurrItem), true);          if (gAddressMode + kSelfAddressCurrItem != kOtherAppItem)            HiliteControl(SnatchHandle(tdial, kSelectProcItem), 255);          else            HiliteControl(SnatchHandle(tdial, kSelectProcItem), 0);          break;        case kSelectProcItem:          /* Call the PPC browser to select a target */          BrowseForTarget(&amp;gTargetAddress);          break;        default:          break;      }    }    DisposeRoutineDescriptor(upp);  }    DisposeDialog(tdial);    /* restore old mode if they canceled */    if (hitItem == cancel)        gAddressMode = saveMode;    }/* Dialog box handler for the Reply Settings you want to use for this sample */void SetReplyMode(void){    DialogPtr tdial = CommonDStart(kReplyModeDialog, gReplyMode + kNoReplyItem, 0);    short hitItem = 0;    short saveMode = gReplyMode;        /* set up to gray out the 'no reply' button */    HiliteControl(SnatchHandle(tdial, kNoReplyItem), 255);    {    ModalFilterUPP upp = NewModalFilterProc(standardDialogFilter);    while (hitItem != ok &amp;&amp; hitItem != cancel) {      ModalDialog(upp, &amp;hitItem);      switch (hitItem) {        case kNoReplyItem:        case kWaitReplyItem:        case kQueueReplyItem:          SetControlValue(SnatchHandle(tdial, gReplyMode + kNoReplyItem), false);          gReplyMode = hitItem - kNoReplyItem;          SetControlValue(SnatchHandle(tdial, gReplyMode + kNoReplyItem), true);          break;        default:          break;      }    }    DisposeRoutineDescriptor(upp);  }      DisposeDialog(tdial);    if (hitItem == cancel)        gReplyMode = saveMode;}/*  CoerceBooleanToChar creates a desc that says True or False.  It's not a very *//* interesting coercion, but it's a nice sample.  I use it for my output window */pascal OSErr CoerceBooleanToChar(DescType origData, Ptr inPtr, Size theSize, DescType toType, long refCon, AEDesc *result){#pragma unused (refCon)    OSErr myErr = noErr;    /* make sure everything is fine first */    if (origData != typeBoolean || toType != typeChar) {        /* something is goofy here */        myErr = errAECoercionFail;    } else {        /* a boolean should be two bytes. if it isn't, I'm confused */        if (theSize == sizeof(short)) {            short theBool = *((short *)inPtr);            short index;            Str32 theText;            index = theBool ? kTrueWord : kFalseWord;            GetIndString(theText, kGeneralStrings, index);            myErr = AECreateDesc(typeChar, (Ptr)&amp;theText[1], theText[0], result);        } else {            myErr = errAECoercionFail;        }    }    return(myErr);}/*  CoerceQDRectToChar is the same kinda thing */pascal OSErr CoerceQDRectToChar(DescType origData, Ptr inPtr, Size theSize, DescType toType, long refCon, AEDesc *result){#pragma unused (theSize,refCon)    OSErr myErr = noErr;    /* make sure everything is fine first */    if (origData != typeQDRectangle || toType != typeChar) {        myErr = errAECoercionFail;    } else {        short *myRect = (short *)inPtr;        register qq;        Str255 theString;        Str32 tempString;        Str32 spaceString = &quot;\p &quot;;                theString[0] = 0;        GetIndString(theString, kGeneralStrings, kSayRectangle);        for (qq = 0; qq &lt; kFour; qq++) {            NumToString(*myRect, tempString);            AppendString(theString, tempString);            AppendString(theString, spaceString);            myRect = myRect + 1;                            /* I have had trouble with MPW C doing a += on a pointer, so I'll do it this way */        }        myErr = AECreateDesc(typeChar, (Ptr)&amp;theString[1], theString[0], result);    }    return(myErr);}/* these next two I really do find useful, dealing with Toolbox strings */pascal OSErr CoerceCharToPString(DescType origData, Ptr inPtr, Size theSize, DescType toType, long refCon, AEDesc *result){#pragma unused (origData,toType,refCon)    OSErr myErr = noErr;    Str255 theString;    theString[0] = theSize;    BlockMove(inPtr, (Ptr)&amp;theString[1], theSize);    myErr = AECreateDesc(typeMyPString, (Ptr)&amp;theString[0], theString[0] + 1, result);        return(myErr);}pascal OSErr CoercePStringToChar(DescType origData, Ptr inPtr, Size theSize, DescType toType, long refCon, AEDesc *result){#pragma unused (origData,toType,refCon)    OSErr myErr = noErr;    myErr = AECreateDesc(typeChar, (Ptr)(inPtr + 1), theSize - 1, result);            return(myErr);}/* CoerceAliasToTargetID takes an applicaiton alias and coerces it to a process target ID *//* Of course, to do this is needs to find and launch the application *//* This handler uses pointers to the data, since the AppleEvent managr can handle this type *//* of manipulation more efficiently than passing descs.  You can install a desc handler *//* instead, if you'd like. *//* I actually don't use this in this sample, but I left it in as an example *//* of a coercion handler */pascal OSErr CoerceAliasToTargetID(DescType origData, Ptr inPtr, Size theSize, DescType toType, long refCon, AEDesc *returnID){#pragma unused (origData,toType,refCon)    OSErr myErr;    LaunchParamBlockRec launchThis;    FSSpec theSpec;    Boolean changed;    Handle theAlias = NewHandle(theSize);    HLock(theAlias);    BlockMove(inPtr, (Ptr)*theAlias, theSize);    HUnlock(theAlias);    launchThis.launchAppSpec = &amp;theSpec;    /* the caller may have already done this, but it doesn't hurt to do it again */    myErr = ResolveAlias(nil, (AliasHandle)theAlias, launchThis.launchAppSpec, &amp;changed);    if (myErr)        return(myErr);    /* launch the thing */    launchThis.launchBlockID = extendedBlock;    launchThis.launchEPBLength = extendedBlockLen;    launchThis.launchFileFlags = nil;    /* launchdontswitch because we just want to use the service.  Also, it may be a */    /* background only application, so like you don't want it to come up, y'know? */    launchThis.launchControlFlags = launchContinue + launchNoFileFlags + launchDontSwitch;    launchThis.launchAppParameters = nil;    myErr = LaunchApplication(&amp;launchThis);    if (myErr) {        mAEErrorDisplay(&quot;\pLaunchApplication error&quot;, myErr)        return(myErr);    }    /* it launched.  the PSN has been stored in the launchProcessSN field, now we have to make */    /* that a target */    /* fill in all the details for the target */    /* we'll just use the PSN to communicate */    myErr = AECreateDesc(typeProcessSerialNumber, (Ptr)&amp;launchThis.launchProcessSN, sizeof(ProcessSerialNumber), returnID);    mAEErrorDisplay(&quot;\pCreateDesc error after launch&quot;, myErr)    return(myErr);}#undef __AEM__</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/AEObject-Edition_Sample/listing4.html%3Fid%3DDTS10000204-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/AEObject-Edition_Sample/listing4.html%3Fid%3DDTS10000204-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/AEObject-Edition_Sample/listing4.html%3Fid%3DDTS10000204-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>