<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>DefProcs - /rdocproc.a</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">DefProcs</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxHumanInterfaceToolbox-date.html" target="_blank">Carbon > Human Interface Toolbox</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">DefProcs</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/rdocproc.a</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/butcdef.a</option>
<option value="listing2.html">/LDefProc0.A</option>
<option value="listing3.html">/mdefproc.a</option>
<option value="listing4.html">/rdocproc.a</option>
<option value="listing5.html">/Read Me â€¢ DefProcs.txt</option>
<option value="listing6.html">/sbarcdef.a</option>
<option value="listing7.html">/wprocasm.a</option></select>
				</p>
				</form>
				<p><strong><a href="DefProcs.zip">Download Sample</a></strong> (&#147;DefProcs.zip&#148;, 78.9K)<BR>
<strong><a href="DefProcs.dmg">Download Sample</a></strong> (&#147;DefProcs.dmg&#148;, 151.3K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">;EASE$$$ READ ONLY COPY of file &quot;rdocproc.a&quot;; 1.0  CCH 11/16/1988 Added to EASE.; END EASE MODIFICATION HISTORY ;;File RDocProc.A;-------------------------------------------------------;;  Rounded Corner Window Definition Routine &quot;RDocProc&quot;;;  written by Andy Hertzfeld  Aug 4, 1982;;  (c) 1982-1986 by Apple Computer, Inc.  All rights reserved.;;   This file contains the window definition procedure;  &quot;RDocProc&quot;, a standard Mac window type similar to the;  &quot;DocumentProc&quot; included in the ROM.  It is indentical if;  the refCon is zero, otherwise the roundness of the corners;  is specified using the high 2 bytes of the window;  refCon.  It is intended to be linked with applications or;  desk ornaments.;;  Modification History:;;  16-OCt-82  AJH  Converted to QuickDraw Trap Interface;  15-Nov-82  AJH  Added GoAway button, made content rectangular;  02-Jan-83  AJH  Made it a &quot;WDEF&quot; resource;  07-Mar-83  AJH  Made it dispose the title region (bug fix);  17-Mar-83  AJH  Fixed D4 trash bug;  27-Apr-83  AJH  only plot, hit-test goAway if window is active;  20-Aug-83  AJH  made it get roundness from selector instead of refCon;  18-Oct-83  AJH  made it ignore unwanted messages; new hiliting;  11-Jan-85  JTC  convert to MDS;  31-Jan-85  EHB  made hit-testing of GoAway box accurate;  14-Feb-85  JTC  named rsrc.;  29-Jul-85  EHB  converted back to porkshop;v4  7-Aug-85  EHB  did variable system font height version;   23 Jul 86  DLD  Converted source to MPW.;   22 Aug 86  DLD  Recoded draw goaway before DoHilite to fix Mac Plus system.;;----Reno World!----------------------------------------;;  &lt;C59/30Jun86&gt; DAF added color support for nuMac;   &lt;C60/22Aug86&gt; DLD Recoded draw goaway before DoHilite to fix Mac Plus system.;  &lt;Cxxx/06Oct86&gt; DAF updated color support to use RGB calls on Beck's.  Fixed;            goaway mask to center mask for everyone.;  &lt;C407/13Oct86&gt; DAF changed textmode from srcBIC to srcCopy;   &lt;C424/18Nov86&gt; DAF  Added portToMap to correct problems in cWindows.;  &lt;C491/08Dec86&gt; DAF  Locked title string before drawing it (OLD BUG!);  &lt;C700/26Jan87&gt; DAF  Universal defproc (version 10);      BLANKS    ON      STRING    ASIS      PRINT    OFF      LOAD    'inc.sum.d'      LOAD    'nEqu.d'      INCLUDE    'colorequ.a'      PRINT    ONWDEF1    FUNC    EXPORT; Stack Frame DefinitionsWindowID  EQU    14      ;                message    EQU    12      ;                WFrameSize  EQU    -30      ;  IsColor    EQU    -30      ; do we have colorQD and toolbox?  [boolean]Align    EQU    -29      ; a dead byte for IsColor      SavFgCol  EQU    -28SavBkCol  EQU    -22WCTabHndl  EQU    -16      ;                WCTabPtr  EQU    -12      ;                WInfoRec  EQU   -8      ;                &lt;7Aug85&gt;WAscent   EQU   -8      ;                &lt;7Aug85&gt;WDescent  EQU   -6      ;                &lt;7Aug85&gt;WHeight   EQU   -4      ;                &lt;7Aug85&gt;WBoxDelta  EQU   -2      ;                &lt;7Aug85&gt;;;  FUNCTION   RDocProc(    selector: INTEGER;         window: WindowPtr,;         message: INTEGER;;         parameter: LongInt): LongInt;      BRA.S  @0; standard header      DC.W  0          ; flags word      DC.B  'WDEF'        ; type      DC.W  1          ; ID      DC.W  10          ; version@0      LINK  A6,#WFrameSize    ; set up a stack frame to address parameters        MOVEM.L D3-D5/A3-A4,-(SP)  ; save work registers; test if the message is in range      CMP.W  #wCalcRgnMsg,message(A6) ; compare to highest value  (this is highest for rdocs)&lt;C700/26Jan87&gt; DAF      BGT   OORange          ; skip it, it's too high      &lt;C700/26Jan87&gt; DAF      CMP.W  #wDrawMsg,message(A6)  ;  compare to lowest value, too    &lt;C700/26Jan87&gt; DAF      BMI   OORange          ;                  &lt;C700/26Jan87&gt; DAF            MOVE.L  grafGlobals(A5),A0   ; get pointer to quickDraw globals      &lt;7Aug85&gt;      MOVE.L  thePort(A0),-(SP)  ; save current port on stack        &lt;7Aug85&gt;; Determine type of system.  We need to know if we have color QuickDraw and a color;  window manager port.        CMP.W  #$3FFF,ROM85    ; do we have color QD?       SLS    IsColor(A6)      ; set boolean depending on color or B&amp;W system      BHI.S  @BWSys        ; no, this system has B&amp;W QD; when using the wmgrCPort, it is the defproc's responsibility to reconcile;   the wmgrPort and the wmgrCPort.        BSR   UpdateCPort      ; compare and update wmgrPorts, also set WMgrCPort; save off the current port fore- &amp; backcolors on color systems.             PEA    SavFgCol(A6)    ; push a pointer to save area      _GetForeColor        ; get the current color      PEA    SavBkCol(A6)    ;       _GetBackColor        ;; also, find the auxWinRec and lock it down            CLR.L  -(SP)        ; here's a space for the var handle      CLR.W  -(SP)        ; function return here      MOVE.L  14(A6),-(SP)    ; push window ptr       PEA    6(SP)        ; a pointer to the space above      _GetAuxWin          ; find the auxrec      ADDQ  #2,SP        ; pitch the boolean (it doesn't matter)      MOVE.L  (SP)+,A0      ; get the auxRecHandle      MOVE.L  (A0),A0        ; handle -&gt; ptr      MOVE.L  winCTable(A0),A0  ; get the colortable handle      MOVE.L  A0,WCTabHndl(A6)  ; save this handle      _HLock            ; lock the table down in memory      MOVE.L  (A0),WCTabPtr(A6)  ; and get a pointer too!      BRA.S  @CommonSys      ; @BWSys                  ; END OF A COLOR-ONLY SECTION      MOVE.L  WMgrPort,-(SP)    ; and set port to window manager port      _SetPort          ; @CommonSys                ; rdocprocs have asymmetric titles that are 19 high.  Figure it so that fonts smaller; or equal to chicago get mapped to 19, and all others are made odd for good centering.      LEA   WInfoRec(A6),A3   ; point to our info rec           &lt;7Aug85&gt;@1      MOVE.L  A3,-(SP)      ; push a pointer              &lt;7Aug85&gt;      _GetFontInfo        ; and get the font's info                   &lt;7Aug85&gt;      MOVE.W  (A3)+,D0      ; get ascent+2                &lt;5Aug85&gt;      ADD.W  (A3)+,D0      ; add descent                &lt;5Aug85&gt;      ADDQ.W  #4,D0        ; get the height              &lt;5Aug85&gt;      BSET  #0,D0        ; make height odd for symmetry        &lt;7Aug85&gt;      MOVEQ  #19,D1        ; get 19                  &lt;26Aug85&gt;      CMP.W  D1,D0        ; force height to 19 min          &lt;26Aug85&gt;      BGE.S  @3          ; =&gt; not a tiny font            &lt;5Aug85&gt;      SUB.W  D0,D1        ; how much less than 19 is it?        &lt;26Aug85&gt;      LSR.W  #1,D1        ; used for centering tiny fonts       &lt;26Aug85&gt;      ADD.W  D1,WAscent(A6)    ; make the ascent &quot;bigger&quot;          &lt;26Aug85&gt;      MOVEQ  #19,D0        ;                      &lt;7Aug85&gt;@3      MOVE.W  D0,(A3)+      ; WHeight = ascent+descent+4        &lt;7Aug85&gt;      SUB.W  #13,D0        ; subtract height of box          &lt;7Aug85&gt;      LSR.W  #1,D0        ; divide by 2                &lt;7Aug85&gt;      MOVE.W  D0,(A3)       ; save delta to goAway box        &lt;7Aug85&gt;; fetch the parameters into registers      LEA   8(A6),A0      ; get ptr to first parameter      MOVE.L  (A0)+,D3      ; get param in D3      MOVE.W  (A0)+,D0      ; get message      MOVE.L  (A0)+,A3      ; get the window pointer      MOVE.W  (A0)+,D5      ; get the selector      LSR   #1,D5        ; only use 8 alternatives      ASL   #2,D5        ; quadruple for long index      CLR.L  (A0)        ; clear out function result;; case out on the message number;      CMP   #3,D0        ; is it one we deal with?      BGE.S  @4          ; if not, skip      ASL   #2,D0        ; quadruple for long index      JSR   GODOCPROC(D0)    ; dispatch to appropriate routine;; we're done -- restore port and registers and return to caller;@4            TST.B  IsColor(A6)      ; are we on a color system?            BEQ.S  @NoColor2      ; if on B&amp;W, then skip            PEA    SavFgCol(A6)    ;      _RGBForeColor        ;      PEA    SavBkCol(A6)    ;      _RGBBackColor        ;      MOVE.L  WCTabHndl(A6),A0  ; unlock the colortable      _HUnlock          ;@NoColor2                ; END OF A COLOR-ONLY SECTION      _SetPort          ; restore the port            &lt;7Aug85&gt;OORange                  ; 'Out Of Range, of course'      &lt;C700/26Jan87&gt; DAF      MOVEM.L (SP)+,D3-D5/A3-A4  ; restore work registers      UNLK  A6          ; unlink stack frame      MOVE.L  (SP)+,A0      ADD   #12,SP        ; strip parameters      JMP   (A0)        ; return to caller;; DocumentProc dispatch table -- entries must be long branches!;GODOCPROC      BRA   DRAWDOC       ; draw is message 0      BRA   HITDOC        ; hit test is message 1      BRA   CALCDOC       ; calc test is message 2DoneDoc   RTS             ; nor does it need dispose call; utility UpdateCPort ;  This utility compares the pertinent fields of the wmgrPort and the wmgrCPort,;  updating the wmgrCPort as necessary to match the wmgrPort.UpdateCPort                ; &lt;C700/26Jan87&gt; DAF        MOVE.L  WmgrCPort,-(SP)    ; make the wmgrCPort the current port      _SetPort          ; set it      MOVE.L  WmgrPort,A0      ; get the wmgrPort addr      MOVE.L  WmgrCPort,A1    ; and the wmgrCPort too            PEA    bkPat(A0)      ; push pointers to pattern for later      PEA    pnPat(A0)      ;; copy all fields from pnLoc to end of grafPort, excluding pnPixPat and fillPixPat      LEA    pnLoc(A0),A0          ; point at source      LEA    pnLoc(A1),A1          ; point at dest      MOVE.L  (A0)+,(A1)+            ; copy pnLoc      MOVE.L  (A0)+,(A1)+            ; copy pnSize      MOVE.W  (A0)+,(A1)+            ; copy pnMode      ADDQ  #8,A0              ; skip pnPat (aka, pnPixPat,fillPixPat)      ADDQ  #8,A1              ;       MOVE.W  #((portRec-pnVis)/2)-1,D0    ; set up a counter (long sized)@1      MOVE.W  (A0)+,(A1)+            ; copy it      DBRA  D0,@1              ; loop      ; now set up the patterns in the wmgrCPort (which is thePort);  the parameters were pushed before the copying loop above      _PenPat      _BackPat      RTS              ; &lt;C700/26Jan87&gt; DAF; SetUpColor takes a window part identifier in D0, finds the corresponding;  part in the AuxWinTable (the part code is in the .value field) and returns;  a pointer to its RGB on the stack.  If the requested part is not found,;  the first color table element is used (I'd use frameColor, but that might;  not be there!).  Trashes A0/D0.SetUpColor      MOVE.L  D1,-(SP)      ; save a register      MOVE.L  WCTabPtr(A6),A0    ; get the color table pointer      MOVE.W  CTSize(A0),D1    ; get the color table size      MULU  #8,D1        ; convert to color table indexLegalIndex        CMP.W  CTTable+value(A0,D1),D0  ; is this the one?      BEQ.S  FoundIt        ; if equal, then done      SUB.W  #8,D1        ; try the previous one      BGE.S  LegalIndex      ; loop while index positive      MOVEQ  #0,D1        ; OK, use the first oneFoundIt          LEA    CTTable+rgb(A0,D1),A0 ; get the address of the color to use      MOVE.L  A0,D0        ; we'll need A0 in a second      MOVE.L  (SP)+,D1      ; restore the register      MOVE.L  (SP)+,A0      ; get the return address      MOVE.L  D0,-(SP)      ; push the rgb addr on the stack      JMP    (A0)        ; return to caller      PORTTOMAP                    ; &lt;C424/18Nov86&gt; DAF;----------------------------------------------------------;; Given a window pointer in A0, return the bitmap/pixmap pointer in A0      ADDQ  #PORTBITS,A0        ;POINT TO BITMAP/PIXMAP HANDLE      TST    ROWBYTES(A0)        ;BITMAP OR PIXMAP HANDLE?      BPL.S  GOTBITMAP          ;=&gt;JUST A BITMAP      MOVE.L  BASEADDR(A0),A0        ;ELSE GET PORT'S PIXMAP HANDLE      MOVE.L  (A0),A0            ;GET PIXMAP POINTERGOTBITMAP  RTS                        ;;  DrawDoc -- draw the document window.   The windowPtr is in A3;DrawDoc      TST.B  WVISIBLE(A3)    ; is it visible?      BEQ.S  DoneDoc       ; if not, don't do anything;; see if its a EORGoAway call and special case it;      CMP   #wInGoAway,D3    ; is it a goAway call?      BEQ   EorGoAway      ; if so, go handle it;; derive the titleBar rectangle from the structRgn and keep it in TempRect;      LEA   TEMPRECT,A0     ; get pointer to tempRect      MOVE.L  STRUCTRGN(A3),A1  ; get structure region handle      MOVE.L  (A1),A1       ; get strucRgn pointer      ADDQ  #RGNBBOX,A1     ; point A1 at the bounding box      MOVE.L  (A1)+,(A0)+     ; copy bounding box into tempRect      MOVE.L  (A1),(A0);;  make bottom := top + height;      MOVE  -4(A0),D0      ; get top      ADD.W  WHeight(A6),D0    ; compute top + height          &lt;EHB 7Aug85&gt;      MOVE  D0,(A0)       ; update bottom;; handle the case of non-rectangular titleBar -- we must allocate a region;      CLR.L  -(SP)        ; make space for function result      _NewRgn           ; allocate a region      MOVE.L  (SP),A4       ; keep it in A4 -- and don't pop it off      PEA   TEMPRECT      ; tempRect defines the bounding rect      BSR   GetRadPoint     ; get the radius point in D0      MOVE.L  D0,-(SP)      ; push the radius factor      ST    -(SP)        ; topRound is true      CLR   -(SP)        ; botRound is false      BSR   MakeRoundRegion   ; make the region; set the frame color first                TST.B  IsColor(A6)      ; is it color?      BEQ.S  @NoColor3      ; no, so skip this            MOVE.W  #wframeColor,D0    ; get element index      BSR.S  SetUpColor      ; get it on the stack      _RGBForeColor        ; and set it; and do a PenNormal so that pattern and mode are OK (mostly for PaintRgn coming up) &lt;C254/22Oct86&gt; DAF            _PenNormal          ;         &lt;C254/22Oct86&gt; DAF@NoColor3                ; END OF A COLOR-ONLY SECTION      ; draw the titlebar outline      MOVE.L  A4,-(SP)      ; push the region      _FrameRgn          ; frame it      ; determine the highlight state and set colors accordingly        &lt;26Apr86&gt;            TST.B  IsColor(A6)      ; is it color?      BEQ.S  @NoColor4      ; no, so skip this            TST.B  WHILITED(A3)    ; is it hilited?      BNE.S  @8          ; &shy; is highlighted, = is not highlighted      MOVEQ  #wTitleBarColor,D0  ; not hilited, so paint the titlebar in this color      BSR.S  SetUpColor      ;      _RGBForeColor      MOVEQ  #wFrameColor,D0    ; in this state, text is in frame color      BSR.S  SetUpColor      ;      BRA.S  @9@8      MOVEQ  #wTitleBarColor,D0  ; hilited, so paint the text in this color      BSR.S  SetUpColor      ;  (foreColor is already frameColor!)@9      _RGBBackColor  @NoColor4                ; END OF A COLOR-ONLY SECTION      ; now, go on and draw the rest of the titlebar      MOVE.L  A4,-(SP)      ; push it again      MOVE.L  OneOne,-(SP)    ; inset by 1      _InsetRgn          ; inset it      MOVE.L  A4,-(SP)      ; push for erase (now paint)      TST.B  IsColor(A6)      ; is it color?      BEQ.S  @NoColor5      ; no, so erase            _PaintRgn          ; paint it      BRA.S  @Common5      ; and continue@NoColor5  _EraseRgn          ; erase it@Common5;; hilite the title bar by filling it with specified pattern;DrawTheTitle      BSR   DoTitleString    ; draw the centered Title;; plot the goAway button, if necessary;      TST.B  WHilited(A3)    ; if hilited window      &lt;08/22/86 DLD&gt;      BEQ.S  DisposIt      ; if not, don't plot goAway  &lt;08/22/86 DLD&gt;      TST.B  WGoAway(A3)     ; is there a goaway button?  &lt;08/22/86 DLD&gt;      BEQ.S  DoHilite      ; if not, skip        &lt;08/22/86 DLD&gt;      TST.B  IsColor(A6)      ; is it color?      BEQ.S  @NoColor6      ;      MOVEQ  #notSrcCopy,D1    ; plot in notsrcCopy mode  &lt;08/22/86 DLD&gt;      BRA.S  @Common6      ; continue@NoColor6  MOVEQ  #srcCopy,D1      ; default to srcCopy mode  &lt;08/22/86 DLD&gt;@Common6                ;  since we will invert  &lt;08/22/86 DLD&gt;      LEA   GoAwaySymbol,A1   ; get the goAway symbol    &lt;08/22/86 DLD&gt;      BSR.S   PlotGoAway      ; draw goAway        &lt;08/22/86 DLD&gt;DoHilite      TST.B  IsColor(A6)      ; is it B&amp;W?      BNE.S  @BW1        ;            SUBQ  #1,TempRect+Bottom  ; adjust bottom      PEA   TEMPRECT      ; push the title rect      _InverRect@BW1                  ; END OF A B&amp;W-ONLY SECTION  DisposIt      MOVE.L  A4,-(SP)      ; push the region handle      _DisposRgn          ; deallocate it;; frame the body of the window;DrawFrame      TST.B  IsColor(A6)      ; is it color?      BEQ.S  @NoColor8      ;      MOVEQ  #wFrameColor,D0    ; get the framecolor in Fore      BSR    SetUpColor      ;      _RGBForeColor@NoColor8                ; END OF A COLOR-ONLY SECTION        MOVE.L  STRUCTRGN(A3),-(SP) ; push the structure      _FrameRgn          ; frame the body      RTS;; BuildTBarRect builds a rectangle enclosing the titleBar in TempRect;BuildTBarRect      LEA   TEMPRECT,A0     ; get pointer to tempRect      MOVE.L  STRUCTRGN(A3),A1  ; get structure region handle      MOVE.L  (A1),A1       ; get strucRgn pointer      ADDQ  #RGNBBOX,A1     ; point A1 at the bounding box      MOVE.L  (A1)+,(A0)      ; copy bounding box into tempRect      MOVE.L  (A1),4(A0);;  make bottom := top + height;      MOVE  Top(A0),D0      ; get top      ADD.W  WHeight(A6),D0    ; add in height             &lt;EHB 7Aug85&gt;      MOVE  D0,Bottom(A0)    ; update bottom      SUBQ  #1,Right(A0)    ; inset right      RTS             ; return to caller;; EORGoAway hilites/unhilites the goAway button.  It falls through into PlotGoAway;EorGoAway      BSR.S  BuildTBarRect    ; build the bounding rect      LEA   GoAwaySymbol,A1   ; get the bitMap      ADD.W  #32,A1        ; bump to the EOR Mask      MOVEQ  #SrcXOR,D1      ; set EOR as the plot mode;; PlotGoAway plots the goAway button.  A1 holds the symbol, D1 the plotting mode;PlotGoAway      LEA   TempRect,A0     ; point to temprect           &lt;7Aug85&gt;      MOVE.W  WBoxDelta(A6),D0  ; get offset from top to GABox      &lt;7Aug85&gt;      ADD.W  D0,(A0)       ; add offset to top           &lt;7Aug85&gt;      SUBQ.W  #1,(A0)       ; align bitmap              &lt;7Aug85&gt;      ADDQ.W  #8,2(A0)      ; add margin to left          &lt;7Aug85&gt;      MOVE.L  (A0)+,(A0)      ; bottom/right = top/left        &lt;7Aug85&gt;      MOVEQ  #16,D0        ; get a constant            &lt;7Aug85&gt;      ADD.W  D0,(A0)+      ; Bottom = top + 16           &lt;7Aug85&gt;      ADD.W  D0,(A0)       ; Right = Left + 16           &lt;7Aug85&gt;      MOVE  D1,D0        ; set plotting mode      MOVE.L  #$00100010,D1      BSR.S   PlotSymbol      ; plot it in tempRect      BSR.S  BuildTBarRect    ; rebuild tempRect      RTS;;  PlotSymbol -- plot the little 16 by 16 symbol bitmap pointed to by A1 into the rectangle;  pointed held in TempRect. D0 holds the mode.;PlotSymbol      LEA   IconBitMap,A0    ; get pointer to source bitmap      MOVE.L  A1,(A0)       ; update base address of bitMap      MOVE  #2,4(A0)      ; update rowBytes      MOVE.L  #$00100010,10(A0)  ; adjust boundsRect;; push parameters for CopyBits call to transfer arrow bitMap;      MOVE.L  A0,-(SP)      ; push pointer source bitmap      MOVE.L  GrafGlobals(A5),A1    ; get lisaGraf global baseaddress      MOVE.L  THEPORT(A1),A1    ; get thePort      PEA   PORTBITS(A1)    ; that's the destination bitmap;      PEA   BOUNDS(A0)      ; boundsRect of bitmap is source      PEA   TempRect      ; tempRect is the destination      MOVE.W  D0,-(SP)      ; theMode is in D0      CLR.L  -(SP)        ; no mask region;; transfer the bitMap (stretching as necessary...);      _CopyBits          ; let Bill stretch those bits      RTS             ; return to caller;; DoTitleString is the common code that draws the title centered in tempRect;DoTitleString  ; on entry, temprect is title rect inset by one      BSR   BuildTBarRect    ; calculate title bar rect; compute indent factor based on GoAwayButton state@1      MOVE.W  TempRect+Right,D3  ; get right      SUB.W  TempRect+Left,D3  ; compute width      SUB.W  WTITLEWIDTH(A3),D3  ; compute extra x      ASR.W  #1,D3        ; divide by 2;; if there's a goAway button, make sure the margin is at least 28 pixels;      TST.B  WGoAway(A3)     ; is there a go away button      BEQ.S  @2          ; skip if there's not      TST   D3          ; is it negative?      BMI.S  @3          ; if so, pin at 28      CMP.W  #28,D3        ; if goAway button, must have some margin      BGT.S  @2@3      MOVEQ  #28,D3@2      ADD   TempRect+Left,D3  ; compute x position      MOVE.W  D3,-(SP)      ; and push for MoveTo      MOVE.W  TempRect+Top,D0   ; get top            &lt;7Aug85&gt;      ADD.W  WAscent(A6),D0    ; move down to baseline     &lt;7Aug85&gt;      ADDQ.W  #2,D0        ; add a little white space    &lt;7Aug85&gt;      MOVE.W  D0,-(SP)      ; push baseline         &lt;7Aug85&gt;      _MoveTo      TST.B  IsColor(A6)      ; is it color?      BEQ.S  @NoColor9      ; no, so skip      MOVE.W  txMode(A3),-(SP)  ; save the xfer mode      MOVE.W  #notsrcCopy,-(SP)  ; set the text mode        &lt;C407/13Nov86&gt; DAF      _TextMode@NoColor9                ; END OF A COLOR-ONLY SECTION; draw the string      MOVE.L  WTITLEHANDLE(A3),A0 ; get titleHandle      _HLock            ; lock that puppy      &lt;C491/08Dec86&gt; DAF      MOVE.L  (A0),-(SP)      ; push title pointer      _DrawString         ; draw it      MOVE.L  WTITLEHANDLE(A3),A0 ; get titleHandle again    &lt;C491/08Dec86&gt; DAF      _HUnlock          ; unlock it          &lt;C491/08Dec86&gt; DAF      TST.B  IsColor(A6)      ; is it color?      BEQ.S  @NoColor10      ; no, so skip      _TextMode          ; and restore textMode    &lt;26Apr86&gt;@NoColor10                ; END OF A COLOR-ONLY SECTIONDoneDString      RTS             ; all done drawing title...;;  GetRadPoint returns the radius in D0 of the round rect parameter defined; by the selector parameter;GetRadPoint      MOVE.L  RadiusTable(D5),D0      RTSRadiusTable      DC.L  $00100010      ; (16,16)      DC.L  $00040004      ; (4,4)      DC.L  $00060006      ; (6,6)      DC.L  $00080008      ; (8,8)      DC.L  $000A000A      ; (10,10)      DC.L  $000C000C      ; (12,12)      DC.L  $00140014      ; (20,20)      DC.L  $00180018      ; (24,24);;  MakeRoundRegion -- makes a round region given a bounding rectangle and a radius;  value.  Also, half round regions (top round, bottom square) are supported;  by the topRound,botRound booleans;;    MakeRoundRegion( theRgn:RegionHandle;       theRect:     Rect;       xRad,yRad:  INTEGER;       topRound,botRound: BOOLEAN);MakeRoundRegion             ; ???? was ...Rgn      LINK  A6,#0        ; set up stack frame      MOVE.L  A3,-(SP)      ; save work registers      TST.L  8(A6)        ; are flags both  false?      BEQ.S  PlainRect      ; if so, its just a rectangle      TST.L  12(A6)        ; is radius factor 0?      BNE.S  ComplexRect     ; if not, its a round one;; optimize for the rectangular case;PlainRect      MOVE.L  20(A6),-(SP)    ; push region handle      MOVE.L  16(A6),-(SP)    ; push  rectangle pointer      _RectRgn          ; make a  rectangular region      BRA.S  MMRDone       ; all done!;; make a region with top and bottom corners rounded;ComplexRect      _HidePen          ; hide the pen      _OpenRgn          ; start recording the region;      MOVE.L  16(A6),-(SP)    ; push the rectangle pointer      MOVE.L  12(A6),-(SP)    ; push the radius point      _FrameRoundRect       ; define the region      MOVE.L  20(A6),-(SP)    ; push region handle      _CloseRgn          ; assign roundRect region;      _ShowPen          ; enable drawing again;; now square up either the top or bottom of the region (or neither);      MOVE.L  16(A6),A0      ; get rectangle pointer      TST.W  8(A6)        ; examine 'botRound' flag      BNE.S  CheckTRound     ; if true, see if top needs squaring      MOVE  BOTTOM(A0),D1    ; get bottom y coordinate      MOVE  D1,D0      SUBQ  #8,D0        ; compute top      BRA.S  SquareIt;CheckTRound      TST.W  10(A6)        ; examine 'topRound' flag      BNE.S  MMRDone       ; if that true, we're done      MOVE  Top(A0),D0      ; get top y coordinate      MOVE  D0,D1      ADDQ  #8,D1        ; get bottom;; here we build a rect in ToolScratch that has the same X as tempRect, but centered; around the top or bottom;SquareIt      LEA   ToolScratch,A1    ; get pointer to dest Rect      MOVE  D0,(A1)+      ; update top      MOVE  Left(A0),(A1)+    ; copy left      MOVE  D1,(A1)+      ; update bottom      MOVE  Right(A0),(A1)    ; copy  right;; now make a region out of that rectangle;      CLR.L  -(SP)        ; make space for result      _NewRgn           ; allocate a new region      MOVE.L  (SP),A3       ; keep a copy in  A3      PEA   ToolScratch     ; push the rectangle pointer      _RectRgn          ; make the rectangular region;; now union with the parameter region to square up the edges;      MOVE.L  20(A6),-(SP)    ; push destination region      MOVE.L  A3,-(SP)      ; push square region      MOVE.L  20(A6),-(SP)    ; dest gets the result      _UnionRgn;; all done -- deallocate the temporary region;      MOVE.L  A3,-(SP)      _DisposRgn;MMRDone      MOVE.L  (SP)+,A3      ; restore work reg      UNLK  A6          ; unlink stack frame      MOVE.L  (SP)+,A0      ; get return address      ADD   #16,SP        ; strip parameters      JMP   (A0)        ; all done!; HitDoc -- perform a hit test on the document.  On entry, D3 contains the mousePoint; in global coordinates while A3 holds the window pointer;HitDoc      MOVEQ  #16,D4        ; keep 16 in a register to save code      CLR.W  -(SP)        ; make room for function  result      MOVE.L  D3,-(SP)      ; push the mouse  point      MOVE.L  CONTRGN(A3),-(SP)  ; push content region handle      _PtInRgn          ; is the point in the content region?      TST.B  (SP)+        ; well, is it?      BEQ.S  NotInContent    ; if not, go check out drag region; the point is in the content region so return a '1'justContent      MOVEQ  #wInContent,D0    ; return in content      BRA.S  DoneHitDoc      ; go store function result and return; its not in the content -- see if its in the dragRgn (content extended by titleBar)NotInContent      CLR.W  -(SP)      MOVE.L  D3,-(SP)      MOVE.L  StructRgn(A3),-(SP)      _PtInRgn      TST.B  (SP)+      BEQ.S  DoneHit1      CLR.W  -(SP)        ; make room for function result      MOVE.L  D3,-(SP)      ; push the mouse point      MOVE.L  ContRgn(A3),A4    ; get content region handle      MOVE.L  (A4),A4       ; get region ptr      ADDQ  #RgnBBox,A4     ; get bounding box ptr      MOVE.W  WHeight(A6),D0    ; get height of title bar        &lt;7Aug85&gt;      SUB.W  D0,Top(A4)      ; decrease by height of title bar    &lt;7Aug85&gt;      MOVE.L  A4,-(SP)      ; push the rect      _PtInRect          ; is the point in the title bar?      MOVE.W  WHeight(A6),D0    ; get height of title bar        &lt;7Aug85&gt;      ADD.W  D0,Top(A4)      ; and fix the bounding box up      &lt;7Aug85&gt;      TST.B  (SP)+        ; examine result      BEQ.S  DoneHit1      ; if not, return 0 (do nothing); see if its in leftmost 16 of drag, which is the goAway button      TST.B  WGoAway(A3)     ; is there a goAway button?      BEQ.S  ItsInDrag      ; if not, skip      TST.B  WHilited(A3)    ; only draw it for the active one      BEQ.S  ItsInDrag      MOVE  D3,D0        ; get mousePt      MOVE.L  A3,A0        ; copy the windowPtr for PortToMap  &lt;C424/18Nov86&gt; DAF      BSR    PortToMap      ; convert it            &lt;C424/18Nov86&gt; DAF        ADD   Bounds+Left(A0),D0  ; convert to local          &lt;C424/18Nov86&gt; DAF      SUB   PortRect+Left(A3),D0  ; compensate for origin      CMP   #18,D0        ; is it too far right?      BGT.S  ItsInDrag      ; if so, its in drag      SUBQ  #8,D0        ; it must be at least 8      BMI.S  ItsInDrag      MOVE.L  D3,D0        ;; now check vertical      SWAP  D0          ;; which is high word of D3      ADD.W  Bounds+Top(A0),D0  ;; convert to local  (A0 is still valid)  &lt;C424/18Nov86&gt; DAF      SUB.W  PortRect+Top(A3),D0   ;; compensate for origin; D0 is aligned with 0 as the bottom of the title bar.      ADD.W  WBoxDelta(A6),D0    ; below box?        &lt;7Aug85&gt;      BPL.S  ItsInDrag        ; =&gt; yes          &lt;7Aug85&gt;      ADD.W  #11,D0          ; in box?          &lt;7Aug85&gt;      BMI.S  ItsInDrag        ; =&gt; no           &lt;7Aug85&gt;; its in the goAway button so signal it      MOVEQ  #wInGoAway,D0      BRA.S  DoneHitDocItsInDrag      MOVEQ  #wInDrag,D0     ; flag in drag regionDoneHitDoc      MOVE.L  D0,20(A6)      ; update function resultDoneHit1  RTS; CalcDoc  -- calculate the structure and content regions for the window pointed; to by A3.CalcDoc      LEA   TEMPRECT,A0     ; get a pointer to the work rectangle      MOVE.L  A0,-(SP)      ; push for later offset      MOVE.L  PORTRECT(A3),(A0)+  ; copy topLeft of portRect      MOVE.L  PORTRECT+4(A3),(A0) ; copy botLeft of portRect; offset it to global coordinates      MOVE.L  A3,A0        ; copy window pointer        &lt;C424/18Nov86&gt; DAF      BSR    PortToMap      ; convert pointer, if necessary    &lt;C424/18Nov86&gt; DAF      MOVE.L  BOUNDS(A0),-(SP)  ; push topLeft of port.portBits.bounds &lt;C424/18Nov86&gt; DAF      NEG   2(SP)        ; negate  offset      NEG   (SP)      _OffsetRect         ; offset  tempRect to global coordinates; make the content region square for fast updating      MOVE.L  CONTRGN(A3),A0    ; A0 holds the content region      CLR   D1          ; topround is false      BSR.S  GOMAKERGN      ; go make the region into content region; now do the structure region.  First correct the bounding rectangle (tempRect) for; structure instead of content      PEA   TEMPRECT      ; push a  pointer to the rect      MOVE.L  MinusOne,-(SP)    ; make 1  pixel bigger, all around      _InsetRect          ; make it bigger      MOVE.W  WHeight(A6),D0    ; move up to top of window        &lt;7Aug85&gt;      SUBQ.W  #1,D0        ; tweak it                &lt;7Aug85&gt;      SUB.W  D0,TempRect+Top   ; and set top of struct region      &lt;7Aug85&gt;      MOVEQ  #1,D1        ; topRound is true      MOVE.L  STRUCTRGN(A3),A0  ; A0 holds the structRgn  pointerGoMakeRgn      MOVE.L  A0,-(SP)      ; push the region handle      PEA   TEMPRECT      ; push bounding rectangle pointer      BSR   GETRADPOINT     ; get the radius  factor      MOVE.L  D0,-(SP)      ; push it      MOVE.W  D1,-(SP)      ; topRound is in  D1      ST    -(SP)        ; so is botRound      BSR   MakeRoundRegion   ; go make the region; all done with CalcDocRgns      RTS;; BitMap for default GoAway buttonGoAwaySymbol      DC.W  $0000,$0000,$7FF0,$4010      DC.W  $4010,$4010,$4010,$4010      DC.W  $4010,$4010,$4010,$4010      DC.W  $7FF0,$0000,$0000,$0000; brand-new, centered mask            &lt;Cxxx/06Oct86&gt; DAF      DC.W  $0000,$0000,$7FF0,$4210      DC.W  $5250,$4A90,$4010,$5DD0      DC.W  $4010,$4A90,$5250,$4210      DC.W  $7FF0,$0000,$0000,$0000      END ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           </pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/DefProcs/listing4.html%3Fid%3DDTS10000184-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/DefProcs/listing4.html%3Fid%3DDTS10000184-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/DefProcs/listing4.html%3Fid%3DDTS10000184-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>