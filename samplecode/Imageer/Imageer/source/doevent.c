/****************************************************//*													*//*	File:		doevent.c							*//*													*//*	Program:	Imageer								*//*													*//*	By:			Jason Hodges-Harris					*//*													*//*	Created:	26/10/95  00:00:00 AM				*//*													*//*	Version:	1.0.0d3								*//*													*//*	Copyright:	© 1995-96 Apple Computer, Inc.,		*/ /*					all rights reserved.			*/		/*													*//****************************************************//**** Macintosh Toolbox Headers *****/#ifndef __CURSORCTL__#include <CursorCtl.h>#endif#ifndef __DESK__#include <Desk.h>#endif#ifndef __DISKINIT__#include <DiskInit.h>#endif#ifndef __EVENTS__#include <Events.h>#endif#ifndef __MENUS__#include <Menus.h>#endif#ifndef __QDOFFSCREEN__#include <QDOffscreen.h>#endif#ifndef __TOOLUTILS__#include <ToolUtils.h>#endif#ifndef __WINDOWS__#include <Windows.h>#endif/****   Application headers and prototypes   ****/#ifndef __IMAGEERAPPHEADER__#include "Imageer.app.h"#endif#ifndef __IMAGEERPROTOSHEADER__#include "Imageer.protos.h"#endif// DoEvent function processess the events posted by the application.// This includes the handling of mouse, key,// disk and operating system events.#pragma segment Mainvoid DoEvent (EventRecord *eventPtr){	char			theChar;		switch (eventPtr->what)	{		case nullEvent:		break;		case mouseDown:			HandleMouseDown(eventPtr);		break;		case mouseUp:		break;		case keyDown:		case autoKey:			theChar=eventPtr->message & charCodeMask;			 if ((eventPtr->modifiers &cmdKey) != 0)				 DoMenuCommand(MenuKey (theChar));		break;		case keyUp:		break;		case updateEvt:			DoWindowUpdate((WindowPtr)(eventPtr->message));		break;		case diskEvt:			DoDiskEvt(eventPtr);	// disk inserted event		break;		case activateEvt:			DoWindowUpdate((WindowPtr)(eventPtr->message));		break;		case osEvt:			if (eventPtr->message>>24==resumeFlag)				SetCursor(&qd.arrow);		break;	}}// HandleMouseDown controls the further processing of mouse button down events.// This includes testing the location of the mouse pointer at the time of the event// and performing the appropriate action. e.g. if the mouse button was pressed// whilst the pointer was in the menubar, the value returned by MenuSelect()// (used to determine which menubar and item selected) is passed into DoMenuCommand()// which in turn handles the processing of the selected menu items.#pragma segment Mainvoid HandleMouseDown(EventRecord *eventPtr){	ImageDocHndl		theWindDocHndl;	MenuHandle			theMenu;	WindowPtr			theWindow,						oldPort;	long				menuChoice;	Str255				theResString;	short				thePart,						maxXsize,						maxYsize;		theMenu = GetMHandle(mModel);	thePart=FindWindow (eventPtr->where,&theWindow);	switch (thePart)	{		case inMenuBar:			menuChoice = MenuSelect (eventPtr->where);			DoMenuCommand(menuChoice);		break;		case inSysWindow:			SystemClick(eventPtr,theWindow);		break;		case inDrag:			SetCurrentWindowMark(theWindow);			if (FrontWindow() != theWindow)			{				theWindDocHndl = (ImageDocHndl)GetWRefCon(theWindow);				if (!(**theWindDocHndl).isColorsWindow)				{					SetUndoItemText((*theWindDocHndl)->theUndoState);					if (ColorWindowVisible())						UpdateColorsWindPalette(theWindDocHndl, theWindow);					if ((**theWindDocHndl).isUsingQDGX)					{						GetIndString (theResString,rImageModel,iUseColorQD);						SetMenuItemText (theMenu,iUseQDGX,theResString);						SetMenuItemAvailable(true);					}					else					{						GetIndString (theResString,rImageModel,iUseQuickDrawGX);						SetMenuItemText (theMenu,iUseQDGX,theResString);						SetMenuItemAvailable(false);					}				}				else 					SetUndoItemText(kCannotUndo);				SetCurrentWindowMark(theWindow);				SelectWindow(theWindow);			}			DragSelWind(theWindow,eventPtr->where);		break;		case inGrow:			HandleWindowReSize(theWindow, eventPtr->where);		break;		case inGoAway:			DoGoAwayWind(theWindow,eventPtr->where);		break;		case inContent:			if (FrontWindow() != theWindow)			{				theWindDocHndl = (ImageDocHndl)GetWRefCon(theWindow);				if (!(**theWindDocHndl).isColorsWindow)				{					SetUndoItemText((*theWindDocHndl)->theUndoState);					if (ColorWindowVisible())						UpdateColorsWindPalette(theWindDocHndl, theWindow);					if ((**theWindDocHndl).isUsingQDGX)					{						GetIndString (theResString,rImageModel,iUseColorQD);						SetMenuItemText (theMenu,iUseQDGX,theResString);						SetMenuItemAvailable(true);					}					else					{						GetIndString (theResString,rImageModel,iUseQuickDrawGX);						SetMenuItemText (theMenu,iUseQDGX,theResString);						SetMenuItemAvailable(false);					}				}				else 					SetUndoItemText(kCannotUndo);				SetCurrentWindowMark(theWindow);				SelectWindow(theWindow);			}			else				ScrollBarHandler(eventPtr->where, theWindow);	// find if current window control selected		break;		case inZoomIn:		case inZoomOut:			theWindDocHndl = (ImageDocHndl)GetWRefCon((WindowPtr)theWindow);			MoveWindow((WindowPtr)theWindow,0,18+GetMBarHeight(),true);			SizeWindow((WindowPtr)theWindow,			(**theWindDocHndl).theMaxWindowSize.right - (**theWindDocHndl).theMaxWindowSize.left,			(**theWindDocHndl).theMaxWindowSize.bottom - (**theWindDocHndl).theMaxWindowSize.top,true);			MoveControl((**theWindDocHndl).theVScrollBar,						theWindow->portRect.right - kScrollBarWidth,theWindow->portRect.top - 1);			MoveControl((**theWindDocHndl).theHScrollBar,						theWindow->portRect.left - 1,theWindow->portRect.bottom - kScrollBarWidth);			SizeControl((**theWindDocHndl).theVScrollBar,16,						(theWindow->portRect.bottom - theWindow->portRect.top)-13);			SizeControl((**theWindDocHndl).theHScrollBar,						(theWindow->portRect.right - theWindow->portRect.left)-13,16);			SetControlMinimum((**theWindDocHndl).theVScrollBar,0);			SetControlMinimum((**theWindDocHndl).theHScrollBar,0);			maxXsize = (**theWindDocHndl).theImageXSize - 						((theWindow->portRect.right - kScrollBarWidth) - theWindow->portRect.left);			maxYsize = (**theWindDocHndl).theImageYSize - 						((theWindow->portRect.bottom - kScrollBarWidth) - theWindow->portRect.top);			SetControlMaximum((**theWindDocHndl).theVScrollBar,maxYsize);			SetControlMaximum((**theWindDocHndl).theHScrollBar,maxXsize);			SetControlValue((**theWindDocHndl).theVScrollBar,0);			SetControlValue((**theWindDocHndl).theHScrollBar,0);			GetPort(&oldPort);			SetPort(theWindow);			InvalRect(&theWindow->portRect);			SetPort(oldPort);		break;	}	DrawMenuBar();}// DoDiskEvt handles the event post by the OS when a disk is insert// and displays an error is the media cannot be mounted.#pragma segment Mainvoid DoDiskEvt(EventRecord *eventPtr){	short	ErrResult;	Point	ErrPoint;	if((HiWord(eventPtr->message)!=noErr))	{		SetPt(&ErrPoint,100,100);		ErrResult=DIBadMount(ErrPoint,eventPtr->message);	}}/****	Handle image window scroll bars		****/// Handle the actions of the scroll bars in the image windows,// using control actions to track controls when the mouse button is held down.#pragma segment MainOSErr	ScrollBarHandler(Point	Position, WindowPtr theWindow){	ImageDocHndl 		theDocHndl;	ControlHandle		theScrollBar;	ControlActionUPP	theVertActionScrollUPP,						theHorizActionScrollUPP;	WindowPtr			oldPort;	short				theControlPart;	OSErr				error = noErr;		GetPort(&oldPort);	SetPort(theWindow);	GlobalToLocal(&Position);	theDocHndl = (ImageDocHndl)GetWRefCon(theWindow);	theControlPart = FindControl(Position, theWindow, &theScrollBar);	theVertActionScrollUPP = NewControlActionProc(ImageWindVertAction);	theHorizActionScrollUPP = NewControlActionProc(ImageWindHorizAction);	switch (theControlPart)	{		case inUpButton:			if (theScrollBar == (**theDocHndl).theVScrollBar)				TrackControl(theScrollBar,Position,theVertActionScrollUPP);			else if (theScrollBar == (**theDocHndl).theHScrollBar)				TrackControl(theScrollBar,Position,theHorizActionScrollUPP);		break;		case inDownButton:			if (theScrollBar == (**theDocHndl).theVScrollBar)				TrackControl(theScrollBar,Position,theVertActionScrollUPP);			else if (theScrollBar == (**theDocHndl).theHScrollBar)				TrackControl(theScrollBar,Position,theHorizActionScrollUPP);		break;		case inPageUp:			if (theScrollBar == (**theDocHndl).theVScrollBar)				TrackControl(theScrollBar,Position,theVertActionScrollUPP);			else if (theScrollBar == (**theDocHndl).theHScrollBar)				TrackControl(theScrollBar,Position,theHorizActionScrollUPP);		break;		case inPageDown:			if (theScrollBar == (**theDocHndl).theVScrollBar)				TrackControl(theScrollBar,Position,theVertActionScrollUPP);			else if (theScrollBar == (**theDocHndl).theHScrollBar)				TrackControl(theScrollBar,Position,theHorizActionScrollUPP);		break;		case inThumb:			if (theScrollBar == (**theDocHndl).theVScrollBar)			{				theControlPart = TrackControl(theScrollBar,Position,nil);				if (theControlPart)				{					InvalRect(&theWindow->portRect);				}			}			else if (theScrollBar == (**theDocHndl).theHScrollBar)			{				theControlPart = TrackControl(theScrollBar,Position,nil);				if (theControlPart)				{					InvalRect(&theWindow->portRect);				}			}		break;	}	DisposeRoutineDescriptor((UniversalProcPtr)theVertActionScrollUPP);	DisposeRoutineDescriptor((UniversalProcPtr)theHorizActionScrollUPP);	SetPort(oldPort);	return error;}/****		Update image window scroll bar controls	****/#pragma segment Mainvoid	UpdateImageWindCntrl(ControlHandle theControlHndl, WindowPtr theWindow, short stepSize){	short			theControlValue,					theControlBounds;	theControlValue = GetControlValue(theControlHndl);	theControlBounds = GetControlMaximum(theControlHndl);	theControlValue = (theControlValue + stepSize > theControlBounds) ?		theControlBounds : theControlValue + stepSize;	SetControlValue(theControlHndl,theControlValue);	InvalRect(&theWindow->portRect);}/****	Vertical scrolling action function	****/#pragma segment Mainpascal void ImageWindVertAction(ControlHandle theControl, short theControlPart){	WindowPtr		theWindow;		theWindow = (*theControl)->contrlOwner;	switch (theControlPart)	{		case inUpButton:			UpdateImageWindCntrl(theControl, theWindow, -kSmallScroller);		break;		case inDownButton:			UpdateImageWindCntrl(theControl, theWindow, kSmallScroller);		break;				case inPageUp:			UpdateImageWindCntrl(theControl, theWindow, -kLargeScroller);		break;		case inPageDown:			UpdateImageWindCntrl(theControl, theWindow, kLargeScroller);		break;	}}/****	Horizontal scrolling action function	****/#pragma segment Mainpascal void ImageWindHorizAction(ControlHandle theControl, short theControlPart){	WindowPtr		theWindow;		theWindow = (*theControl)->contrlOwner;	switch (theControlPart)	{		case inUpButton:			UpdateImageWindCntrl(theControl, theWindow, -kSmallScroller);		break;		case inDownButton:			UpdateImageWindCntrl(theControl, theWindow, kSmallScroller);		break;				case inPageUp:			UpdateImageWindCntrl(theControl, theWindow, -kLargeScroller);		break;		case inPageDown:			UpdateImageWindCntrl(theControl, theWindow, kLargeScroller);		break;	}}