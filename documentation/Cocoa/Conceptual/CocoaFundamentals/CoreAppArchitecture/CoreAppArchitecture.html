<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Cocoa Fundamentals Guide: The Core Application Architecture on Mac OS X</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="The Core Application Architecture on Mac OS X"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40002974-CH8" title="The Core Application Architecture on Mac OS X"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../DesignGuidelines-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000556" target="_top">Design Guidelines</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP40002974-CH1-SW1">Cocoa Fundamentals Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../CommunicatingWithObjects/CommunicateWithObjects.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../OtherArchitectures/OtherArchitectures.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40002974-CH8-SW45" title="The Core Application Architecture on Mac OS X"></a><h1>The Core Application Architecture on Mac OS X</h1><p>When a user launches a Cocoa application, a network of objects is put into place. This runtime network consists of Application Kit objects of different types, each performing a specific role. These objects are related to each other in various ways defined by ownership, dependency, and cooperation. This chapter looks at this application architecture and examines the roles played by the core objects, their primary attributes, and the relationships they have with each other.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW54">The Event-Drawing Cycle, Revisited</a>
				
			<br/>
			
        
			
			
				<a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW48">The Global Application Object</a>
				
			<br/>
			
        
			
			
				<a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW14">Windows</a>
				
			<br/>
			
        
			
			
				<a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW10">Views</a>
				
			<br/>
			
        
			
			
				<a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW17">Responders and the Responder Chain</a>
				
			<br/>
			
        
			
			
				<a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW13">Controls and Menus</a>
				
			<br/>
			
        
			
			
				<a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW49">Nib Files and Other Application Resources</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40002974-CH8-SW54" title="The Event-Drawing Cycle, Revisited"></a><h2>The Event-Drawing Cycle, Revisited</h2><p>The overall purpose of the network of objects is to expedite the work of the event and drawing <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_660"></a>cycle.  <span class="content_text">Figure A-1</span> (which you may recall from <span class="content_text"><a href="../AddingBehaviortoaCocoaProgram/AddingBehaviorCocoa.html#//apple_ref/doc/uid/TP40002974-CH5-SW1">“Adding Behavior to a Cocoa Program”</a></span>) illustrates this cycle.</p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH8-SW1" title="Figure A-1The event and drawing cycle"></a><p><strong>Figure A-1&nbsp;&nbsp;</strong>The event and drawing cycle</p><img src = "../Art/main_event_loop.gif" alt = "The event and drawing cycle" width="387" height="183"></div><br/><p>The application presents a graphical user interface; users interact with that interface by using the mouse and keyboard to enter data or indicate a choice; and this input is transformed into an event that is routed to the application and placed in its event queue. For each event in its queue, the application locates the object or objects best suited to handle the event, and after the event is handled the application may appropriately modify what it displays to users. Then the application gets the next event in its queue and the cycle begins again.</p><p>The <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_661"></a>core objects that participate in this architecture are direct or indirect descendants of the <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/cl/NSApplication" target="_top">NSApplication</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/cl/NSWindow" target="_top">NSWindow</a></code>, and <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/cl/NSView" target="_top">NSView</a></code> classes. </p><a name="//apple_ref/doc/uid/TP40002974-CH8-SW48" title="The Global Application Object"></a><h2>The Global Application Object</h2><p><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_662"></a><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_663"></a>Every Cocoa application is managed by a single <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/cl/NSApplication" target="_top">NSApplication</a></code><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_664"></a><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_665"></a> object known by the name of the global variable, <code>NSApp</code>. This singleton instance of <code>NSApplication</code> (or of a custom subclass thereof) has a major responsibility: obtaining user and system events targeted at the application and dispatching them to the appropriate objects. It is also responsible for managing the application's windows, including tracking their current status as key or main window (see <span class="content_text"><a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW16">“Window Status”</a></span>). </p><a name="//apple_ref/doc/uid/TP40002974-CH8-SW6" title="The Main Event Loop"></a><h3>The Main Event Loop</h3><p>Most of the work that <code>NSApp</code> does takes place in the application's <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_666"></a>main event loop, which is the basis of the event and drawing cycle. To understand how the main event loop operates, it helps to consider what takes place in a Cocoa application's <code><!--a-->main<!--/a--></code> entry point. In a standard Xcode Cocoa project, <code><!--a-->main<!--/a--></code> has a single function call, <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_667"></a><code><a href="../../../Reference/ApplicationKit/Miscellaneous/AppKit_Functions/Reference/reference.html#//apple_ref/c/func/NSApplicationMain" target="_top">NSApplicationMain</a></code> This function does three important things, in the following order:</p><ol class="ol"><li class="li"><p>It obtains the shared application object (<code>NSApp</code>) by invoking the class <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_668"></a>method <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/clm/NSApplication/sharedApplication" target="_top">sharedApplication</a></code>.</p></li><li class="li"><p>It loads the application's <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_669"></a>main nib file into memory.</p></li><li class="li"><p>It runs the application (<code>[NSApp</code>    <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/instm/NSApplication/run" target="_top">run</a></code><code>]).</code></p></li></ol><p>Let's examine these steps in a little more detail, starting with some background information. A running application is essentially a process, and each process has a main thread and possibly one or more secondary threads. Each thread always has a<a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_670"></a> run loop created for it; a run loop is a mechanism that monitors <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_671"></a>sources of input to the process and dispatches control to it when sources become ready for processing. </p><p>The main thing that the <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/clm/NSApplication/sharedApplication" target="_top">sharedApplication</a></code> method does—outside of ensuring a singleton instance—is to set up the programmatic infrastructure for receiving and processing events from the window server. In initializing the global application object, <code>NSApplication</code> establishes a connection to the <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_672"></a>window server by creating an <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_673"></a>event source for receiving events (implemented as a Mach port). It also sets up the application's <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_674"></a>event queue, a FIFO mechanism that enqueues events fetched from the event source as they arrive. Finally, <code>NSApplication</code> initializes the <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_675"></a>main run loop—the run loop on the main thread—with the event source as an input source (see <span class="content_text">Figure A-2</span>). </p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH8-SW5" title="Figure A-2Main event loop, with event source"></a><p><strong>Figure A-2&nbsp;&nbsp;</strong>Main event loop, with event source</p><img src = "../Art/main_event_loop1.gif" alt = "Main event loop, with event source" width="384" height="208"></div><br/><p>The window server receives events from I/O Kit device drivers and dispatches them to the appropriate processes. The process receives the event from the event source in the run loop and places it on a queue. </p><p>When the application loads the <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_676"></a>main nib file, the objects in the file are unarchived along with the connections between these objects. The main nib file always contains the application menu and may contain one or more window objects (with their constituent views). Other nib files may be unarchived at launch time as well; document-based applications, for instance, may unarchive the nib files of documents when a user double-clicks a file in the Finder. This initial graphical user interface is needed so users can begin making requests—by, for instance, choosing a menu item— and consequently generating events for the application to handle. </p><p>The <code>NSApplication</code> <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/instm/NSApplication/run" target="_top">run</a></code> <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_677"></a>method is the workhorse of the main event loop. It first registers Apple <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_678"></a>event handlers for the application (see <span class="content_text"><a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW2">“Handling Apple Events”</a></span>). Then in a closed <code>while</code> loop, <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/instm/NSApplication/run" target="_top">run</a></code> does the following until the application terminates:</p><ol class="ol"><li class="li"><p>It services pending <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_679"></a><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_680"></a>window-display observers on the run loop (see <span class="content_text">Figure A-3</span>, which results in the redrawing of regions in windows that are marked as "dirty." </p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40002974-CH8-SW4" title="Figure A-3Main event loop, with run-loop observer"></a><p><strong>Figure A-3&nbsp;&nbsp;</strong>Main event loop, with run-loop observer</p><img src = "../Art/main_event_loop2.gif" alt = "Main event loop, with run-loop observer" width="384" height="208"></div></li><li class="li"><p>It gets the next event in the event queue (<code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/instm/NSApplication/nextEventMatchingMask:untilDate:inMode:dequeue:" target="_top">nextEventMatchingMask:untilDate:inMode:dequeue:</a></code>).</p></li><li class="li"><p>It dispatches the <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_681"></a><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_682"></a>event to the object that should next handle it, which in most cases is an <code>NSWindow</code> object (<code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/instm/NSApplication/sendEvent:" target="_top">sendEvent:</a></code>). See <span class="content_text"><a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW3">“More About Event Dispatch”</a></span> for clarification.</p><p>Ultimately, numerous objects may become involved in handling the event, and the call stack may grow significantly. After the event is handled, control returns to <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/instm/NSApplication/run" target="_top">run</a></code>. </p></li></ol><p>The funnel point of the main event loop is the <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/instm/NSApplication/nextEventMatchingMask:untilDate:inMode:dequeue:" target="_top">nextEventMatchingMask:untilDate:inMode:dequeue:</a></code> <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_683"></a> method. If there are events in the event queue, this method fetches the topmost event in the queue and converts the structure to an <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/cl/NSEvent" target="_top">NSEvent</a></code> <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_684"></a>object. If there are no events in the queue, the method blocks. During the period the method blocks, new events from the window server are processed and placed in the queue. The presence of new events  "wakes" <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/instm/NSApplication/nextEventMatchingMask:untilDate:inMode:dequeue:" target="_top">nextEventMatchingMask:untilDate:inMode:dequeue:</a></code> and it returns the first matching event in the queue.</p><p>If a window has its <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_685"></a><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_686"></a>auto-display feature enabled and it has views marked for display, it also installs an observer (an input source) on the run loop. Just before <code>NSApp</code> processes the next event in the queue, this observer fires, leading to the redrawing of those views. For more on this automatic displaying of window content, see <span class="content_text"><a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW22">“Windows and Drawing.”</a></span> </p><a name="//apple_ref/doc/uid/TP40002974-CH8-SW3" title="More About Event Dispatch"></a><h3>More About Event Dispatch</h3><p><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_687"></a>In its <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/instm/NSApplication/sendEvent:" target="_top">sendEvent:</a></code> <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_688"></a>implementation, <code>NSApp</code> looks at the type of event passed in and dispatches it accordingly. Usually the target of the dispatch is one of the application's windows, and the application forwards the event by invoking the <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/instm/NSWindow/sendEvent:" target="_top">sendEvent:</a></code> method of that NSWindow object. For the two major types of input events, key events and mouse events, <code>NSApp</code> uses a different approach to find the appropriate window.</p><p>When users press keys on the keyboard, <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_689"></a>key events are generated. <code>NSApp</code> forwards these events on to the key window—the window of the application that is currently accepting key presses. (In some cases, such as <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_690"></a>key equivalents, the application handles <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/econst/NSKeyDown" target="_top">NSKeyDown</a></code> events specially instead of dispatching them.)</p><p>When users click an object on a window with a mouse, such as a graphical shape in a drawing program, <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_691"></a>mouse events are generated. <code>NSApp</code> dispatches mouse events to the window in which the mouse event occurred. </p><p>If the object that is clicked or otherwise manipulated is a control object, such as a button or a slider, that object sends an additional sort of message to the application—an <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_692"></a>action message. That message invokes the <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/instm/NSApplication/sendAction:to:from:" target="_top">sendAction:to:from:</a></code> <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_693"></a>method of <code>NSApplication</code>. If a target of the message is not specified, this method searches the <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_694"></a>responder chains of the application's key and (if necessary) main windows, to find a suitable target. Then it sends the message to the target of the action message.</p><p><code>NSApp</code> deals with other types of events in <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/instm/NSApplication/sendEvent:" target="_top">sendEvent:</a></code>. Some events are specific to the application itself (such as activation and deactivation), and <code>NSApp</code> handles these itself. Other events are related to one or more windows—for example, a window is exposed or a change is made in screen resolution. For these, <code>NSApp</code> invokes the appropriate method in the affected windows. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH8-SW73" title="Further Reading"></a><p><strong>Further Reading:</strong>&nbsp;The responder chain is described in <span class="content_text"><a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW17">“Responders and the Responder Chain.”</a></span> To learn more about key windows, see <span class="content_text"><a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW16">“Window Status.”</a></span> For a discussion of NSControl objects and how they work together with NSCell objects, read <span class="content_text"><a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW13">“Controls and Menus.”</a></span> </p></div><a name="//apple_ref/doc/uid/TP40002974-CH8-SW55" title="Window Management"></a><h3>Window Management</h3><p>Part of the job of the global <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_695"></a><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_696"></a>application object is to manage the windows of the application. <code>NSApp</code> performs the following window-management tasks:</p><ul class="spaceabove"><li class="li"><p>It keeps track of the current <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_697"></a><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_698"></a>key and main windows.</p></li><li class="li"><p>It hides and unhides windows.</p></li><li class="li"><p>It deallocates windows at application termination.</p></li><li class="li"><p>It manages window activation and deactivation during application switching.</p></li></ul><p>And, as noted in <span class="content_text"><a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW3">“More About Event Dispatch,”</a></span> <code>NSApp</code> dispatches window-specific event and action messages to the affected windows. It also maintains the application's Window menu and manages modal windows and panels. (See <span class="content_text"><a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW9">“Modal Windows”</a></span> for a description.)</p><p>To help it locate windows, the application object keeps a reference to them called its <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_699"></a>window list (see <span class="content_text">Figure A-4</span>). For some window-management tasks (such as deallocation) it iterates through this list. (You can obtain the window list at any time by sending <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/instm/NSApplication/windows" target="_top">windows</a></code> to <code>NSApp</code>.) The application object also finds windows by using the window number obtained from the current <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/cl/NSEvent" target="_top">NSEvent</a></code> object in a call to  <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/instm/NSApplication/windowWithWindowNumber:" target="_top">windowWithWindowNumber:</a></code>. </p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH8-SW7" title="Figure A-4The application&#39;s window list"></a><p><strong>Figure A-4&nbsp;&nbsp;</strong>The application's window list</p><img src = "../Art/window_list.gif" alt = "The application's window list" width="299" height="96"></div><br/><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH8-SW74" title="Note"></a><p><strong>Note:</strong>&nbsp;<code>NSApp</code> doesn't have anything to do with the layering of windows on the screen (Z -order). That is managed by the window server. For a discussion of window Z-order, see <span class="content_text"><a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW8">“Window Z-Order and Levels.”</a></span></p></div><a name="//apple_ref/doc/uid/TP40002974-CH8-SW2" title="Handling Apple Events"></a><h3>Handling Apple Events</h3><p>Not all events that an application must deal with come from the event queue. Other processes on a Mac OS X system, such as the Finder and Launch Services, use <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_700"></a>Apple events to communicate with other processes. They occasionally send an application Apple events to notify it (for example) when users double-click a document in a Finder window or choose Shut Down from the Apple menu, requiring the application to terminate.  </p><p>When a Cocoa application starts up, one of the first things it does is to register a number of Apple <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_701"></a>event handlers. When an Apple event is sent to the application, the appropriate handler is invoked. A Cocoa application registers handlers for the following Apple events:</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Apple event ID</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code><a href="../../../../Carbon/Reference/Apple_Event_Manager/Reference/reference.html#//apple_ref/c/econst/kAEOpenApplication" target="_top">kAEOpenApplication</a></code></p></td><td ><p>Launches an application.</p></td></tr><tr><td  scope="row"><p><code><a href="../../../../Carbon/Reference/Apple_Event_Manager/Reference/reference.html#//apple_ref/c/econst/kAEReopenApplication" target="_top">kAEReopenApplication</a></code></p></td><td ><p>Reopens an application. It is sent, for example, when an application is running and a user clicks the application icon in the Dock.</p></td></tr><tr><td  scope="row"><p><code><a href="../../../../Carbon/Reference/Apple_Event_Manager/Reference/reference.html#//apple_ref/c/econst/kAEOpenDocuments" target="_top">kAEOpenDocuments</a></code></p></td><td ><p>Provides an application with a list of documents to open. This event is commonly sent when the user selects one or more documents in the Finder and double-clicks them.</p></td></tr><tr><td  scope="row"><p><code><a href="../../../../Carbon/Reference/Apple_Event_Manager/Reference/reference.html#//apple_ref/c/econst/kAEPrintDocuments" target="_top">kAEPrintDocuments</a></code></p></td><td ><p>Provides an application with a list of documents to print. This event is commonly sent when a user selects one or more documents in the Finder and chooses Print from the File menu.</p></td></tr><tr><td  scope="row"><p><code><a href="../../../../Carbon/Reference/Apple_Event_Manager/Reference/reference.html#//apple_ref/c/econst/kAEOpenContents" target="_top">kAEOpenContents</a></code></p></td><td ><p>Provides an application with dragged content, such as text or an image. This event is often sent when a user drags a file onto an application’s icon in the Dock.</p></td></tr><tr><td  scope="row"><p><code><a href="../../../../Carbon/Reference/Apple_Event_Manager/Reference/reference.html#//apple_ref/c/econst/kAEQuitApplication" target="_top">kAEQuitApplication</a></code></p></td><td ><p>Requests the application to terminate.</p></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH8-SW75" title="Note"></a><p><strong>Note:</strong>&nbsp;For more information on this subject, see "<span class="content_text"><a href="../../ScriptableCocoaApplications/SApps_handle_AEs/SAppsHandleAEs.html#//apple_ref/doc/uid/20001239" target="_top">How Cocoa Applications Handle Apple Events</a></span>"<a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_702"></a>. </p></div><a name="//apple_ref/doc/uid/TP40002974-CH8-SW14" title="Windows"></a><h2>Windows</h2><p><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_703"></a>An application uses windows to claim an area of the screen in which to display content and respond to user actions. Windows are essential to both drawing and event handling.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH8-SW76" title="Further Reading"></a><p><strong>Further Reading:</strong>&nbsp;<em><a href="../../WinPanel/index.html#//apple_ref/doc/uid/10000031i" target="_top">Window Programming Guide for Cocoa</a></em> discusses many of the topics covered in this section in greater detail.</p></div><a name="//apple_ref/doc/uid/TP40002974-CH8-SW56" title="The Windows of an Application"></a><h3>The Windows of an Application</h3><p>Although it's possible to have an application with no visible windows (for example, a background application) such applications are rare. Generally, there are two types of applications based on the number of windows they can potentially display:</p><ul class="spaceabove"><li class="li"><p><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_704"></a>Document-based—An application capable of creating multiple documents, each in its own window. Examples are word-processing and drawing applications. In a document-based application, users choose a menu option (typically File > New) to create a new document. Most document-based applications in Cocoa are based on its document architecture. (You can find an overview of this architecture in <span class="content_text"><a href="../OtherArchitectures/OtherArchitectures.html#//apple_ref/doc/uid/TP40002974-CH10-SW1">“Other Cocoa Architectures on Mac OS X.”</a></span>) </p></li><li class="li"><p>Single-window—An application that displays no more than one window at any time. Examples in Mac OS X are iSync and Font Book. When a <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_705"></a>single-window application launches, it displays its window. Often closing the window causes the application to terminate.</p></li></ul><p>Any application can also have <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_706"></a>secondary windows, also known as <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_707"></a>dialogs and <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_708"></a>panels. These windows are subordinate to the current document window or, in the case of single-window applications, to the main window. They support the document or main window in various ways—for example, allowing selection of fonts and color, allowing the selection of tools from a palette, or displaying a warning‚ A secondary window is often modal. See <span class="content_text"><a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW11">“Panels”</a></span> for more information</p><a name="//apple_ref/doc/uid/TP40002974-CH8-SW57" title="NSWindow and the Window Server"></a><h3>NSWindow and the Window Server</h3><p>In Cocoa an <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/cl/NSWindow" target="_top">NSWindow</a></code> <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_709"></a>object represents a physical window. The <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_710"></a>window server creates physical windows and ultimately manages them on the screen. It assigns each window a unique number as an identifier. The connection between an <code>NSWindow</code> object and its physical window is established through this <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_711"></a>window number. </p><p>When the window server creates a window, it obtains a <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_712"></a>window graphics context and initializes the <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_713"></a>graphics-state stack. It also creates the window's <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_714"></a>backing store, a memory region holding the pixel values of the window to be placed into the display device's frame buffer. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH8-SW77" title="Note"></a><p><strong>Note:</strong>&nbsp;It's possible to create a window without a backing store. This is called a deferred window. The backing store of a deferred window is created when the window is ordered on-screen.</p></div><a name="//apple_ref/doc/uid/TP40002974-CH8-SW58" title="Window Buffering"></a><h3>Window Buffering</h3><p><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_715"></a>Windows often overlap when there's more than one on the screen. When a group of windows are stacked one over another, a mouse click on a partially obscured window usually brings it to the front. In the process, its obscured contents become visible. If the window has a <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_716"></a>display buffer, the window server can automatically make those contents visible. Otherwise, the application has to redraw them. </p><p>There are two types of window buffering.  A window's display buffer stores pixel values either for the entire window or for those portions of the window that are currently obscured.  When an obscured window with a display buffer is made frontmost, the window server copies the exposed area from the display buffer to the screen.  When you create an <code>NSWindow</code> object you can specify one of three buffering schemes, which are depicted in <span class="content_text">Figure A-5</span>.</p><ul class="spaceabove"><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_717"></a>Buffered</strong>. The buffer contains an exact duplicate of what's in backing store. In fact, drawing is done to the display buffer, and then its contents are flushed to the screen, composited with overlapping windows if there are shadows or transparency involved. If a window is obscured and then later brought frontmost, the entire display buffer is copied to the screen.</p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_718"></a>Retained</strong>. Although a retained window has a display buffer, drawing is done directly on-screen when the window is unobscured and no alpha component is to be drawn. When any part of the window is obscured, the displayed contents are copied to the buffer, and drawing is done to the buffer. Modified parts of the buffer are copied to the display.  When the obscured areas of the window on the display are later revealed, the contents of the display buffer are copied to the screen.</p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_719"></a>Nonretained</strong>. No display buffer is provided. All drawing occurs directly onscreen—that is, the pixel values are written directly to the frame buffer. If part of the window is covered by another window, the bits for that part of the window's content area are lost. When the obscured window is exposed, the application must redraw the obscured portion; if it doesn't draw, that portion is displayed in the window's background color. </p></li></ul><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH8-SW31" title="Figure A-5Window buffering schemes"></a><p><strong>Figure A-5&nbsp;&nbsp;</strong>Window buffering schemes</p><img src = "../Art/win_buffering.gif" alt = "Window buffering schemes" width="482" height="467"></div><br/><p>Only buffered windows support transparency effects, including the use of an alpha channel in drawing. Because the Quartz drawing system relies extensively on the use of alpha in drawing, windows to be used with Quartz should be buffered windows, and components that rely on Quartz, such as the Application Kit, should always use buffered windows. Nonretained windows might be used for transitory images or simple connection lines, such as are used in Interface Builder for target-action connections. However, the use of nonretained and retained windows is in general discouraged, because the presence of such windows interacts poorly with the modern user interface and may cause performance degradation.</p><a name="//apple_ref/doc/uid/TP40002974-CH8-SW8" title="Window Z-Order and Levels"></a><h3>Window Z-Order and Levels</h3><p>The <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_720"></a>window server maintains the windows it displays on a screen in a front-to-back order known as the <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_721"></a>screen list or the <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_722"></a>Z-order. Each window has a unique position in the list. A window can be at the top of the list—that is, the frontmost window. Or it can be at the bottom of the list—that is, the window potentially overlapped by every other window. Or it can be in any other position where it is above and below other windows. The Z-order is changed every time a user clicks a window, which makes that window frontmost and puts the previously frontmost window behind it. </p><p>The concept of window layering is complicated by <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_723"></a>window levels. A level is a layering subset of windows of a particular functional type. Window levels are in a hierarchical order, with those windows in higher levels displayed above windows in lower levels. This scheme guarantees that a window of one particular type always appears above or below a window in another level. For example, a modal system dialog always appears above all application windows. Thus Z-order is really maintained within windows levels (see <span class="content_text">Figure A-6</span>). </p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH8-SW26" title="Figure A-6Window levels and Z-order"></a><p><strong>Figure A-6&nbsp;&nbsp;</strong>Window levels and Z-order</p><img src = "../Art/window_layer_image.jpg" alt = "Window levels and Z-order" ></div><br/><p>The window server supports several levels of windows, in the following order:</p><ol class="ol"><li class="li"><p>Screen savers. (Screen savers use a window the size of the screen but without a title bar to display their content.) Screen-saver windows are displayed above all other windows.</p></li><li class="li"><p>The menu bar (which includes application menus).</p></li><li class="li"><p>The Dock.</p></li><li class="li"><p>Modal windows and panels (see <span class="content_text"><a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW9">“Modal Windows.”</a></span></p></li><li class="li"><p>Contextual menus.</p></li><li class="li"><p>Floating windows (for example, palette windows for a drawing application).</p></li><li class="li"><p>Any other types of windows, including application windows.</p></li></ol><p>A window can be explicitly taken off the screen list, in which case it's known as an <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_724"></a>offscreen window. A window disappears when it's removed from the list, and it's restored to the screen when it's put back on the list. Events are not dispatched to offscreen windows. Moving windows off the screen list is the basis for an application's <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_725"></a>window-hiding capability. An offscreen window must be buffered or retained in order for it to be drawn into.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH8-SW78" title="Note"></a><p><strong>Note:</strong>&nbsp;You can also remove a borderless window from the screen by setting its frame coordinates outside of the visible coordinates of the screen. You cannot do this with other windows, however; the Application Kit constrains these windows to remain at least partially visible within the screen bounds. </p></div><p><code>NSWindow</code> defines methods for manipulating the Z-order of application windows, for taking windows off and on the screen list, and for setting the level of windows. See the <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/cl/NSWindow" target="_top">NSWindow</a></code> class reference for details.</p><a name="//apple_ref/doc/uid/TP40002974-CH8-SW59" title="Parts of a Window"></a><h3>Parts of a Window</h3><p>A window has two major <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_726"></a>parts: a <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_727"></a>frame area and a <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_728"></a>content area, as shown in <span class="content_text">Figure A-7</span>. These areas are views—specifically, instances of a subclass of <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/cl/NSView" target="_top">NSView</a></code> (see <span class="content_text"><a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW10">“Views.”</a></span> The frame view surrounds the entire window area, and draws the window's border and title bar. The frame view is a private object created by <code>NSWindow</code>; it is not open to alteration through subclassing. However, when you create a window, you can specify which <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_729"></a>controls and other features—close button, miniaturize button, resizing triangle, title—you want the frame view to have. </p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH8-SW27" title="Figure A-7A window&#39;s frame view and content view"></a><p><strong>Figure A-7&nbsp;&nbsp;</strong>A window's frame view and content view</p><img src = "../Art/frame_content_views.jpg" alt = "A window's frame view and content view" ></div><br/><p>The content view is inset into the frame view, usually occupying the entire area except for the title bar and the window border. <span class="content_text">Figure A-7</span> shows the content view relative to the frame view. (One can create windows that don't have a title bar or visible border, but they still have a frame view.) The content view is the sole public subview of the frame view. It is not a private view so you can replace it with your own custom view, if you wish. Although the content view has a superview (that is, a view that owns and encloses it in the hierarchy of views), that superview is a private object. The content view is thus the root of the <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_730"></a>hierarchy of views for the window. For more on the view hierarchy, see <span class="content_text"><a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW10">“Views.”</a></span></p><p>As do all view objects, the content view keeps a reference to its window, accessible through the <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/window" target="_top">window</a></code> method. <span class="content_text">Figure A-8</span> depicts <code>NSApp</code> and its window list, the content view of each of the windows in the list, and the relationships between those objects. </p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH8-SW28" title="Figure A-8Relationships among NSApp, windows, and content views"></a><p><strong>Figure A-8&nbsp;&nbsp;</strong>Relationships among <code>NSApp</code>, windows, and content views</p><img src = "../Art/win_content_view.gif" alt = "Relationships among NSApp, windows, and content views" width="452" height="255"></div><br/><a name="//apple_ref/doc/uid/TP40002974-CH8-SW60" title="Window Coordinates"></a><h3>Window Coordinates</h3><p>The <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_731"></a>coordinates of a window are related to the coordinates of the <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_732"></a>screen. The entire screen can be thought of as the upper-right quadrant of a two-dimensional coordinate grid, with the origin in the lower-left corner and the positive x-axis extending horizontally to the right and the positive y-axis extending vertically upward (see <span class="content_text">Figure A-9</span>). You can locate a point in the screen by reference to this grid.</p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH8-SW29" title="Figure A-9Screen coordinates"></a><p><strong>Figure A-9&nbsp;&nbsp;</strong>Screen coordinates</p><img src = "../Art/screen_coord_system.jpg" alt = "Screen coordinates" ></div><br/><p>The primary function of the screen coordinate system is to position windows on the screen. When your application creates a new window and puts it on the screen, it must specify the window's initial size and location in screen coordinates. However, for <em>drawing</em> in a window, it uses a different coordinate system, one that's specific to the window: its <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_733"></a><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_734"></a>base coordinate system (see <span class="content_text">Figure A-10</span>). This coordinate system differs from the screen coordinate system in two respects:</p><ul class="spaceabove"><li class="li"><p>It applies only to a particular window; each window has its own base coordinate system.</p></li><li class="li"><p>The origin is at the lower-left corner of the window rather than at the lower-left corner of the screen. If the window moves, the origin and the entire coordinate system move with it. An image retains its position within a base coordinate system no matter where the window is located.</p></li></ul><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH8-SW30" title="Figure A-10Base coordinate system"></a><p><strong>Figure A-10&nbsp;&nbsp;</strong>Base coordinate system</p><img src = "../Art/base_coord_system.jpg" alt = "Base coordinate system" ></div><br/><p>The base coordinate system is the reference point for defining the individual coordinate systems of the window's views. The frame view draws the window's border and title bar directly in the base coordinate system. The content view and its subviews draw in coordinate systems that are transformations of the base coordinate system.</p><a name="//apple_ref/doc/uid/TP40002974-CH8-SW22" title="Windows and Drawing"></a><h3>Windows and Drawing</h3><p><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_735"></a><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_736"></a>Windows do not draw themselves. That job is left to the views they contain. However, an <code>NSWindow</code> object plays an important role in coordinating the drawing of its views. </p><p>Normally, during a pass of the event loop objects in an application may mark views (or regions of views) as needing to be redrawn. An <code>NSWindow</code> object collects references to these <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_737"></a><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_738"></a>"dirty" views in a list, the order of which is determined by position in the <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_739"></a>view hierarchy. Shortly afterward—which is usually at the end of an event cycle—the Application Kit iterates through this list starting with the topmost view (that is, the view closest to the content view) and requests each view to draw itself.  In this manner, views that are a background to other views are drawn first.</p><p>This automatic drawing of a window's views takes place only if the window's <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_740"></a>auto-display feature is turned on, which it is by default (see the  <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/instm/NSWindow/setAutodisplay:" target="_top">setAutodisplay:</a></code> <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_741"></a>method). If you turn off this feature, the application is responsible for updating window content when necessary. In addition, you can bypass the auto-display mechanism by sending an  <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/display" target="_top">display</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/displayRect:" target="_top">displayRect:</a></code>, or <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/displayRectIgnoringOpacity:" target="_top">displayRectIgnoringOpacity:</a></code> message to any <code>NSView</code> object; as a result that view and its subviews are immediately redrawn. See <span class="content_text"><a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW24">“Displaying a View”</a></span> for further information.</p><p>You can redraw an entire window with the <code>NSWindow</code> <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/instm/NSWindow/display" target="_top">display</a></code> and <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/instm/NSWindow/displayIfNeeded" target="_top">displayIfNeeded</a></code> methods. These methods force an immediate display of the window's views, although the latter method iterates only through the list of invalidated views. The <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/instm/NSWindow/display" target="_top">display</a></code> method causes each view in the window's view hierarchy to redraw itself, starting with the content view. This method is invoked on a one-shot window (that is, a window whose backing store is released when the window is offscreen) before the window is shown onscreen. In addition, you can call <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/instm/NSWindow/setFrame:display:" target="_top">setFrame:display:</a></code> with a second argument of <code>YES</code> to cause the window to resize and to redraw all of its views.</p><p>A mechanism related to window display is <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_742"></a>window updating. At every pass through the event loop, <code>NSApp</code> sends an <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/instm/NSWindow/update" target="_top">update</a></code> message to each window in its window list. The default implementation of <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/instm/NSWindow/update" target="_top">update</a></code> does nothing, but subclasses of <code>NSWindow</code> can override this method to examine the state of the application and modify the behavior or appearance of the window as needed.</p><a name="//apple_ref/doc/uid/TP40002974-CH8-SW16" title="Window Status"></a><h3>Window Status</h3><p>Each <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_743"></a>window of an application has a status related to the user's interaction with it. The appearance of a window is an indication of this status. Inactive windows are open and may be visible, but they are not in the foreground. The controls and title in the title bars of inactive windows are grayed out. Users cannot interact with these windows unless they click on them to bring them forward. </p><p><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_744"></a>Active windows are windows that are currently the focus of user input or attention. They are in the foreground, their controls have color, and their titles are in a black font. Active windows can have two statuses: main and key. The active window that is currently the focus of user attention is the main window. It is also the <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_745"></a>key window much of the time; a window is key if it currently accepts keyboard events. </p><p>However, sometimes the <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_746"></a>main window and the key window are separate windows. While the main window is still the focus of user attention, another window is the input focus for key events. The key window must have an object such as a text field in which the user can enter characters by typing at the keyboard. In this case, the key window is typically a dialog or panel (for example, the Find dialog) in which the user specifies data relevant to the main window.</p><p>The application object (<code>NSApp</code>) maintains the main and key status of the application's windows. A window's status often determines the events it receives and dispatches (see <span class="content_text"><a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW3">“More About Event Dispatch.”</a></span></p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH8-SW79" title="Further Reading"></a><p><strong>Further Reading:</strong>&nbsp;For more on main and key windows, see the section on window behavior in <em><a href="../../../../UserExperience/Conceptual/AppleHIGuidelines/index.html#//apple_ref/doc/uid/20000957" target="_top">Apple Human Interface Guidelines</a></em>.</p></div><a name="//apple_ref/doc/uid/TP40002974-CH8-SW12" title="Windows and Event Handling"></a><h3>Windows and Event Handling</h3><p><code>NSWindow</code> is involved with events and event handling in two principal ways. In one activity— event dispatch—it is actively involved. In the other, it is the passive recipient of a constrained stream of events.</p><a name="//apple_ref/doc/uid/TP40002974-CH8-SW61" title="Event Dispatch"></a><h4>Event Dispatch</h4><p><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_747"></a>As described in <span class="content_text"><a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW3">“More About Event Dispatch,”</a></span> the application dispatches most events it receives by sending <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/instm/NSWindow/sendEvent:" target="_top">sendEvent:</a></code> to the <code>NSWindow</code> objects to which the event "belongs." The window object, in turn, locates the <code>NSView</code> object that should receive the event and sends the appropriate <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/cl/NSResponder" target="_top">NSResponder</a></code> message to that view, passing in the <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/cl/NSEvent" target="_top">NSEvent</a></code> object. For example, if the event is a key-down event, it sends <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/keyDown:" target="_top">keyDown:</a></code> to the view; if it's a mouse-dragged event (left button), it sends <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/mouseDragged:" target="_top">mouseDragged:</a></code>. How the window object locates the target view generally differs between key and mouse events:</p><ul class="spaceabove"><li class="li"><p>The window sends <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_748"></a>key events to the <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_749"></a>first responder of the view hierarchy.</p></li><li class="li"><p>The window sends <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_750"></a>mouse events to the view in which the mouse event occurred.</p></li></ul><p>The key-down (<code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSKeyDown" target="_top">NSKeyDown</a></code>) and left-mouse-down (<code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSLeftMouseDown" target="_top">NSLeftMouseDown</a></code>) events require the most handling. Before <code>NSWindow</code> attempts to send the <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/keyDown:" target="_top">keyDown:</a></code>  message to the first-responder view, it feeds the key character (or characters) to the system <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_751"></a>input manager, which interprets the input as text to insert or commands to perform. Before it sends a  <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/mouseDown:" target="_top">mouseDown:</a></code> message, <code>NSWindow</code> attempts to make the target view the first responder. If the appropriate modifier keys are pressed, it doesn't send the message at all, instead handling it by displaying contextual help or a <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_752"></a>contextual menu.</p><a name="//apple_ref/doc/uid/TP40002974-CH8-SW9" title="Modal Windows"></a><h4>Modal Windows</h4><p>Normally an application distributes events to all of its windows, guided primarily by where user actions occur. But sometimes an application may run a <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_753"></a>window modally, thus requiring users to complete a task—for example, selecting a file, entering a name, or even clicking an OK button—before they can dismiss the window. Modal windows are common in Mac OS X; they include error-message dialogs and panels for opening and printing documents.</p><p><code>NSWindow</code> objects are passive participants in the modal-window mechanism; it's the <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_754"></a>application that programmatically initiates and manages modal behavior. To run a window modally, <code>NSApp</code> uses its normal event loop machinery but restricts input to a specific window or panel. In the loop, it fetches events but if the events do not meet certain criteria—most importantly their association with the modal window—it tosses them.</p><p><code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/cl/NSApplication" target="_top">NSApplication</a></code> offers a couple of ways to run a window modally: </p><ul class="spaceabove"><li class="li"><p>Blocking—The application blocks until the user dismisses the modal window.</p></li><li class="li"><p>Nonblocking (modal session)—An application initiates the modal session and runs the window modally for one pass through the event loop. The modal-session code can continue to run the window modally in a loop until some condition is satisfied.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_8" title="Important:"></a><p><strong>Important:</strong>&nbsp;In a non-blocking loop, your code should do some work in between the invocations that run the window modally. Otherwise, it puts the application in a tight polling loop rather than a blocking loop.</p><p></p></div></li></ul><p>Other Application Kit classes also provide methods to run windows and panels modally.</p><a name="//apple_ref/doc/uid/TP40002974-CH8-SW11" title="Panels"></a><h3>Panels</h3><p><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_755"></a>Panels are secondary windows that act in a supporting role to an application or document window. They are frequently referred to as dialogs. In Cocoa, panels are <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_756"></a>instances of <code><a href="../../../Reference/ApplicationKit/Classes/NSPanel_Class/Reference/Reference.html#//apple_ref/occ/cl/NSPanel" target="_top">NSPanel</a></code> or of a subclass of <code>NSPanel</code>. Panels have some special behaviors suitable to their auxiliary function. They can become the <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_757"></a>key window, but never the main window. By default, they are removed from the screen when the application becomes inactive, and are redisplayed when the application becomes active again. (Alert dialogs are an exception to this behavior.) And, because a panel is intended for repeated use, it isn't released when it's closed. You can also configure panels to become floating windows—such as <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_758"></a>utility windows—which are in a level above the other windows of an application. <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_759"></a><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_760"></a> </p><a name="//apple_ref/doc/uid/TP40002974-CH8-SW10" title="Views"></a><h2>Views</h2><p><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_761"></a><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_762"></a>An <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/cl/NSView" target="_top">NSView</a></code> object (or simply, a view) occupies a rectangular area in a window. In Cocoa, views are instances of a subclass of <code>NSView</code>. They are the most pervasive type of object in the Application Kit; nearly every object you see in a Cocoa application is a view. Views are in the front line of both drawing and event handling, and hence are one of the more important types of objects to understand.</p><p>You can think of the drawing a view performs on the screen as a visual representation of the object itself. In a very real sense, a view draws itself. It also provides a surface that can be responsive to input from a mouse, keyboard, or other input device.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH8-SW80" title="Further Reading"></a><p><strong>Further Reading:</strong>&nbsp;See <em><a href="../../CocoaDrawingGuide/index.html#//apple_ref/doc/uid/TP40003290" target="_top">Cocoa Drawing Guide</a></em> for a comprehensive description of concepts and tasks related to drawing with <code>NSView</code> objects. Also, <em><a href="../../CocoaViewsGuide/index.html#//apple_ref/doc/uid/TP40002978" target="_top">View Programming Guide for Cocoa</a></em> describes various tasks related to the manipulation of views.</p></div><a name="//apple_ref/doc/uid/TP40002974-CH8-SW62" title="Varieties of Views"></a><h3>Varieties of Views</h3><p><code>NSView</code> is a <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_763"></a>class that defines the basic drawing, event-handling, and printing architecture of an application. <code>NSView</code> itself does not draw content or respond to user events, so you typically don’t interact with a direct instance of <code>NSView</code>. Instead you use an instance of a custom <code>NSView</code> subclass. A <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_764"></a>custom view class inherits from <code>NSView</code> and overrides many of its methods, which are invoked automatically by the Application Kit.</p><p>If you look at the class hierarchy of the Application Kit (<span class="content_text"><a href="../WhatIsCocoa/WhatIsCocoa.html#//apple_ref/doc/uid/TP40002974-CH3-SW1">Figure 1-10</a></span>), you'll notice a proliferation of classes inheriting, directly or indirectly, from NSView. These classes fall into several categories: </p><ul class="spaceabove"><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_765"></a>Controls</strong>. Controls are views that users manipulate (for example, by clicking or dragging) to indicate a choice to an application. Buttons, sliders, text fields, and steppers are examples of controls. Controls usually (but not always) work in concert with cell objects, which do not inherit from <code>NSView</code>. <span class="content_text"><a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW13">“Controls and Menus”</a></span> discusses controls at more length. </p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_766"></a>Container views</strong>. Some views are used to enclose and present other views or more primitive data. They may allow the editing of data or a more efficient presentation of a user interface. Among these kinds of views are <code><a href="../../../Reference/ApplicationKit/Classes/NSTextView_Class/Reference/Reference.html#//apple_ref/occ/cl/NSTextView" target="_top">NSTextView</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSImageView_Class/Reference/Reference.html#//apple_ref/occ/cl/NSImageView" target="_top">NSImageView</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSBox_Class/Reference/Reference.html#//apple_ref/occ/cl/NSBox" target="_top">NSBox</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSSplitView_Class/Reference/Reference.html#//apple_ref/occ/cl/NSSplitView" target="_top">NSSplitView</a></code>, and <code><a href="../../../Reference/ApplicationKit/Classes/NSTabView_Class/Reference/Reference.html#//apple_ref/occ/cl/NSTabView" target="_top">NSTabView</a></code> objects.  </p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_767"></a>Compound views</strong>. Some views are composed of other views. When you see a text view in a Cocoa application, it includes not just an <code>NSTextView</code> object but also an <code><a href="../../../Reference/ApplicationKit/Classes/NSClipView_Class/Reference/Reference.html#//apple_ref/occ/cl/NSClipView" target="_top">NSClipView</a></code> object and an <code><a href="../../../Reference/ApplicationKit/Classes/NSScrollView_Class/Reference/Reference.html#//apple_ref/occ/cl/NSScrollView" target="_top">NSScrollView</a></code> object (which itself includes <code><a href="../../../Reference/ApplicationKit/Classes/NSScroller_Class/Reference/Reference.html#//apple_ref/occ/cl/NSScroller" target="_top">NSScroller</a></code> objects).  Another example are table views (instances of <code><a href="../../../Reference/ApplicationKit/Classes/NSTableView_Class/Reference/Reference.html#//apple_ref/occ/cl/NSTableView" target="_top">NSTableView</a></code>), which have constituent objects for table headers and table columns (the latter of which is not a view).  </p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_768"></a>Wrapper views</strong>. A few views act as a Cocoa "host" for a Mac OS X technology. Examples of these objects are instances of <code><a href="../../../Reference/ApplicationKit/Classes/NSOpenGLView_Class/Reference/Reference.html#//apple_ref/occ/cl/NSOpenGLView" target="_top">NSOpenGLView</a></code> and <code><a href="../../../Reference/ApplicationKit/Classes/NSMovieView_Class/Reference/Reference.html#//apple_ref/occ/cl/NSMovieView" target="_top">NSMovieView</a></code>. </p></li></ul><p>There is some overlap between some objects in these categories. For example, an <code>NSTableView</code> object is a compound object, but it is also a control.</p><a name="//apple_ref/doc/uid/TP40002974-CH8-SW51" title="The View Hierarchy"></a><h3>The View Hierarchy</h3><p><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_769"></a>As you may recall from the earlier discussion of windows (<span class="content_text"><a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW14">“Windows”</a></span>), each view object is associated with the window in which it is displayed. All of the views in a window are linked together in a <strong>view hierarchy</strong>. Each view has another view as its <strong><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_770"></a>superview</strong> and may be the superview for any number of <strong><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_771"></a>subviews</strong>. At the top of the hierarchy of views is the window's content view, which has no public superview (it does have a private one). The key visual characteristic of the view hierarchy is enclosure: a superview encloses its subviews, which are positioned relative to it. <span class="content_text">Figure A-11</span> illustrates this enclosure.</p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH8-SW32" title="Figure A-11View hierarchy"></a><p><strong>Figure A-11&nbsp;&nbsp;</strong>View hierarchy</p><img src = "../Art/view_hierarchy_enclose.jpg" alt = "View hierarchy" ></div><br/><p>Arranging views in a hierarchy is <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_772"></a>beneficial for both drawing and event handling. It benefits drawing in three ways:</p><ul class="spaceabove"><li class="li"><p>It permits a complex view to be constructed out of other views. For example, a graphical keypad might be a container view with a separate subview for each key. </p></li><li class="li"><p>It also permits each view to have its own coordinate system for convenient drawing. Views are positioned within the coordinates of their superviews, so when a view object is moved or its coordinate system is transformed, all of its subviews are moved or transformed with it. Because a view draws within its own coordinate system, its drawing instructions can remain constant no matter where it is or where its superview moves to on the screen.</p></li><li class="li"><p>It is used to set the layering order of views rendered in a drawing pass (see <span class="content_text"><a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW24">“Displaying a View”</a></span>).</p></li></ul><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH8-SW81" title="Note"></a><p><strong>Note:</strong>&nbsp;Don't confuse the view <em>instance</em> hierarchy with the view <em>class</em> inheritance hierarchy. The view inheritance hierarchy is the arrangement of classes based on shared attributes, interface, and behavior. A view instance hierarchy is an arrangement of particular view instances based on enclosure.</p></div><p>The view hierarchy (referring now to the view instance hierarchy) plays an important role in event handling because it is a major part of the responder chain. See <span class="content_text"><a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW17">“Responders and the Responder Chain”</a></span> for more about the responder chain.</p><p>The view hierarchy is dynamic: As an application runs, you can rearrange views, add them, and remove them. You can move a view from one window to another, and you can move a view around a particular hierarchy.</p><p><code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/cl/NSView" target="_top">NSView</a></code> has three <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_773"></a>relationship properties that help to locate a view in the view hierarchy:</p><ul class="spaceabove"><li class="li"><p><code>window</code>—the window (<code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/cl/NSWindow" target="_top">NSWindow</a></code> object) in which the view appears</p></li><li class="li"><p><code>superview</code>—the view that's immediately above the view in the hierarchy</p></li><li class="li"><p><code>subviews</code>—the list of views that contained by the view (the list could have zero or more views)</p></li></ul><p>Reflecting these properties, Figure <span class="content_text">Figure A-12</span> diagrams the relationships of a window object and its view hierarchy.</p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH8-SW38" title="Figure A-12Relationships among objects in a view hierarchy"></a><p><strong>Figure A-12&nbsp;&nbsp;</strong>Relationships among objects in a view hierarchy</p><img src = "../Art/contents_sub_super_views.gif" alt = "Relationships among objects in a view hierarchy" width="285" height="362"></div><br/><a name="//apple_ref/doc/uid/TP40002974-CH8-SW63" title="View Geometry and Coordinates"></a><h3>View Geometry and Coordinates</h3><p><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_774"></a>View geometry is largely defined by two rectangles associated with each view: its frame and its bounds. Although these rectangles circumscribe the same area, they have different purposes. Together they help to define a view's position and size, and the coordinate system in which it draws and responds to events.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH8-SW82" title="Note"></a><p><strong>Note:</strong>&nbsp;Dimensions and locations described with these rectangles are expressed in floating-point values. </p></div><a name="//apple_ref/doc/uid/TP40002974-CH8-SW64" title="The Frame"></a><h4>The Frame</h4><p>The <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_775"></a>frame rectangle defines the area of a view, the tablet on which it can draw. If you think of a view as a rectangular area on a window, the frame specifies the dimensions of this rectangle and its location in the window. A view can draw only within its frame; by default, the Application Kit enforces clipping of the content the view draws to the view's frame. </p><p>As shown in <span class="content_text">Figure A-13</span>, the frame rectangle of a view usually lies within the frame rectangle of its superview. But it doesn't have to. A view's frame rectangle can extend outside its superview's frame, but its drawing is clipped to its chain of containing ancestor views. The only part of the view that's visible on the screen is that part within the view's frame rectangle and within the frame rectangles of all its ancestor views.</p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH8-SW34" title="Figure A-13Hierarchical views"></a><p><strong>Figure A-13&nbsp;&nbsp;</strong>Hierarchical views</p><img src = "../Art/view_frames.gif" alt = "Hierarchical views" width="382" height="247"></div><br/><p><span class="content_text">Figure A-14</span> also shows three hierarchically related views. In this case, however, the middle view lies partially outside it superview's frame rectangle. Although the lowest view lies entirely inside its superview, it also lies partially outside an ancestor view, so only the colored portion of it is visible.</p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH8-SW35" title="Figure A-14Views clipped by the superview"></a><p><strong>Figure A-14&nbsp;&nbsp;</strong>Views clipped by the superview</p><img src = "../Art/displaced_frames.gif" alt = "Views clipped by the superview" width="373" height="247"></div><br/><p>Some views may contain more material than a window has room enough to display—a view containing the contents of a long document, for example. Such a view may be made the subview of another, smaller view that exposes only part of it. This smaller view is known as a <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_776"></a>clip view (an instance of <code>NSClipView</code>). With the aid of enclosing <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_777"></a>scroll view (<code>NSScrollView</code>) and the <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_778"></a>scrollers (<code>NSScroller</code>) that it manages, users can control the visible portion of the document within its clip view. As the subview moves, different portions of it are scrolled into view. </p><p>You move the location of a <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_779"></a><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_780"></a>view within its subview by resetting its frame's origin. You change the size of a view by altering the size of the frame rectangle. Because these values are interpreted according to the superview's coordinate system, the size and location of a view on a screen can also change if the superview's coordinates change. </p><p>You can <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_781"></a><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_782"></a>rotate a view around its frame origin. Rotation doesn't affect the shape or size of the view; it remains a rectangle even though it has been turned at an angle and the sides of its frame are no longer parallel to its superview's x-axis and y-axis. The frame's origin stays at the same point regardless of the angle of the frame's rotation. Subviews of a rotated view remain aligned with it and hence are also turned in relation to the superview of the rotated view. <span class="content_text">Figure A-15</span> illustrates the same three views shown in <span class="content_text"><a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW34">Figure A-13</a></span>, but here the view in the center of the hierarchy has been rotated.</p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH8-SW33" title="Figure A-15Rotated view and its subview"></a><p><strong>Figure A-15&nbsp;&nbsp;</strong>Rotated view and its subview</p><img src = "../Art/frame_rotation.gif" alt = "Rotated view and its subview" width="382" height="247"></div><br/><a name="//apple_ref/doc/uid/TP40002974-CH8-SW65" title="The Bounds"></a><h4>The Bounds</h4><p>While a view's frame provides the means to size and position the view within its containing superview, it is of little use to the view for drawing. A view performs all drawing and event handling in its own local coordinate system, which is defined by its <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_783"></a>bounds rectangle.</p><p>A view's bounds rectangle defines the way that its local <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_784"></a>coordinate system is mapped onto the view's area. It describes exactly the same physical area as the frame rectangle, though this area is stated in the view's local coordinate system. By default, a view's bounds rectangle is identical in size to its frame, and has an origin of (0.0, 0.0). Under this arrangement, the view positions and draws its content using positive-valued coordinates. </p><p>However, If the view is <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_785"></a><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_786"></a>flipped, this situation changes. A view can flip its coordinate system so that the drawing origin is in the upper-left corner of the view and the positive y-axis extends downward. <span class="content_text">Figure A-16</span> shows what a flipped coordinate system looks like. Flipped views are especially useful for applications that draw text in languages such as English, where text starts in the upper-left corner of a document and flows right and then down.</p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH8-SW25" title="Figure A-16Flipping a view"></a><p><strong>Figure A-16&nbsp;&nbsp;</strong>Flipping a view</p><img src = "../Art/flipped_view.gif" alt = "Flipping a view" width="264" height="445"></div><br/><p>Views typically use the bounds rectangle to ensure that they don't fruitlessly attempt to draw something that will never be rendered on the screen. Because drawing is clipped if it falls outside of any ancestor view, the bounds rectangle by itself is a reliable guide only for views that aren't scrolled and stay entirely within the frame rectangles of all their ancestors. The <code>NSView</code> class provides other programmatic ways to determine where to draw, but the bounds rectangle remains part of any drawing calculation.</p><a name="//apple_ref/doc/uid/TP40002974-CH8-SW66" title="Drawing Coordinates"></a><h4>Drawing Coordinates</h4><p>The <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_787"></a>bounds rectangle provides a view with its <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_788"></a>drawing coordinates. Before a view draws itself, its <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_789"></a>coordinate system is made the current coordinate system for the application (see <span class="content_text"><a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW18">“How Views Get Drawn”</a></span> for details). Recall that the default coordinate system for a view is the same as its superview's, except for these differences:</p><ul class="spaceabove"><li class="li"><p>The point that locates the view's frame in its superview is made the origin (0.0, 0.0) of the bounds rectangle, and hence is the origin of the drawing coordinates.</p></li><li class="li"><p>If a view's frame is rotated, its drawing coordinate system is rotated with it; the bound's x-axis and y-axis remain parallel with the frame's axes.</p></li></ul><p>If a transformation is performed on the bounds, however, these details can change.</p><p><span class="content_text">Figure A-17</span> illustrates the relationship between a view's default coordinate system and the coordinate system of its superview. The <code>innerView</code> object in this diagram is located at (400.0, 200.0) in its superview coordinate system. For any drawing that <code>innerView</code> does, this same point is treated as the coordinate origin (0.0, 0.0). When <code>innerView</code> draws text beginning at (100.0, 200.0), as it does in this example, the point is measured from its own origin, not its superview's. Even if <code>innerView</code> is rotated, as shown in the diagram, the bound's axes rotate with the frame; the origin of the view's drawing coordinates remain unchanged.</p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH8-SW36" title="Figure A-17Relation between coordinate systems of view and superview"></a><p><strong>Figure A-17&nbsp;&nbsp;</strong>Relation between coordinate systems of view and superview</p><img src = "../Art/drawing_coordinates.gif" alt = "Relation between coordinate systems of view and superview" width="398" height="247"></div><br/><p>A view can modify its default <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_790"></a>local coordinate system in several ways:</p><ul class="spaceabove"><li class="li"><p>It can translate its origin to a point other than that defined by the frame's origin.</p></li><li class="li"><p>It can scale the size of units along its bounds axes to a value different than its superview's.</p></li><li class="li"><p>It can rotate the axes of its bounds rectangle around the bounds origin so that they're no longer aligned with the frame's axes.</p></li></ul><p>These modifications alter the coordinate system that the view draws in, and may affect the appearance of what's drawn, but they don't change the area where the drawing appears. In other words, they don't affect the view's frame rectangle.</p><a name="//apple_ref/doc/uid/TP40002974-CH8-SW18" title="How Views Get Drawn"></a><h3>How Views Get Drawn</h3><p>Views are the primary objects responsible for <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_791"></a><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_792"></a>drawing window content in a Cocoa application. Other Application Kit objects can draw (such as <code><a href="../../../Reference/ApplicationKit/Classes/NSCell_Class/Reference/NSCell.html#//apple_ref/occ/cl/NSCell" target="_top">NSCell</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/cl/NSBezierPath" target="_top">NSBezierPath</a></code>, and <code><a href="../../../Reference/Foundation/Classes/NSAttributedString_Class/Reference/Reference.html#//apple_ref/occ/cl/NSAttributedString" target="_top">NSAttributedString</a></code> objects), but they require an <code>NSView</code> "host" object to provide the drawing surface and coordinate the drawing. The following sections give a high-level overview of how the Application Kit coordinates the drawing of a view.</p><a name="//apple_ref/doc/uid/TP40002974-CH8-SW24" title="Displaying a View"></a><h4>Displaying a View</h4><p>A <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_793"></a><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_794"></a>view typically doesn't draw itself whenever it wishes. It must be explicitly marked as <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_795"></a><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_796"></a>invalid (or "dirty") and thus in need of display. Redrawing of the view can then either take place immediately or, if the <code>NSWindow</code> auto-display feature is turned on, it can be deferred until the conclusion of the current cycle of the main event loop. Windows have auto-display enabled by default. (Auto-display is described in <span class="content_text"><a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW6">“The Main Event Loop”</a></span> and in <span class="content_text"><a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW22">“Windows and Drawing.”</a></span>)</p><p>You can initiate immediate redrawing of a view or a portion of a view with one of the <code>NSView</code> <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_797"></a>display methods (so-called because each of these methods has "display" embedded in its name). These methods differ in various respects but they all result in the Application Kit doing the following things:  </p><ol class="ol"><li class="li"><p>Locking focus on the invalidated view (described in <span class="content_text"><a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW20">“Locking Focus”</a></span>)</p></li><li class="li"><p>Invoking the view's <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/drawRect:" target="_top">drawRect:</a></code> method (described in <span class="content_text"><a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW21">“What Happens in drawRect:”</a></span>)</p></li><li class="li"><p>At the conclusion of a drawing pass, flushing the window associated with the view (if the window's backing store is double-buffered) </p></li></ol><p>Rather than displaying views immediately, the recommended course for most situations is to use the <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_798"></a>auto-display mechanism and during an event cycle mark views (or parts of views) as needing display. The <code>NSWindow</code> associated with the views collects the marked views in a list ordered by position in the view hierarchy, topmost view first. At the end of the event cycle, it recursively processes this list in one drawing pass, locking focus on each view in turn and asking the view to draw itself entirely or the portion of the view that was marked as needing display. When all views have been drawn, the window (if buffered) is flushed. </p><p>The Application Kit may request drawing of additional views and view areas beyond those that your application explicitly marks as needing redisplay. It may determine that additional view drawing is needed to fully update the corresponding window area. That's because an important aspect of the drawing of views is <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_799"></a><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_800"></a>view opacity. A view does not have to draw every bit of its surface, but if it does it should declare itself to be opaque (by implementing <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/isOpaque" target="_top">isOpaque</a></code> to return <code>YES</code>). When you mark a view for display, the Application Kit checks the opacity of the view, and if it is not opaque (that is, partially transparent) the Application Kit goes up the view hierarchy until it finds a <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_801"></a>superview that is opaque. It calculates the portion of the opaque ancestor covered by the original view. Then it draws forward through the hierarchy from this view to the view originally marked as dirty. If you want the Application Kit to not look for the first opaque ancestor before drawing a view, there are several "display ignoring opacity" methods you can use (which are listed in <span class="content_text">Table A-1</span> and <span class="content_text">Table A-3</span>).</p><p>You can also mark portions of views and their subviews as needing display and then have them redrawn at once, instead of waiting for the auto-display mechanism to trigger. The <code>NSView</code> display methods that offer this feature all begin with <code><!--a-->displayIfNeeded...<!--/a--></code>. Even though display is immediate, these methods are more efficient than sending <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/display" target="_top">display</a></code> or <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/displayRect:" target="_top">displayRect:</a></code> messages to isolated views.</p><p><span class="content_text">Table A-1</span> shows the <code>NSView</code> display methods for displaying individual views or regions of views immediately. </p><a name="//apple_ref/doc/uid/TP40002974-CH8-SW19" title="Table A-1NSView display methods&acirc;&#128;&#148;immediate display"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table A-1&nbsp;&nbsp;</strong><code>NSView</code> display methods—immediate display</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Display area and opacity</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Display method</p></th></tr><tr><td  scope="row"><p>Entire view</p></td><td ><p><code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/display" target="_top">display</a></code></p></td></tr><tr><td  scope="row"><p>Partial view</p></td><td ><p><code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/displayRect:" target="_top">displayRect:</a></code></p></td></tr><tr><td  scope="row"><p>Entire view, ignoring opacity</p></td><td ><p>None</p></td></tr><tr><td  scope="row"><p>Partial view, ignoring opacity</p></td><td ><p><code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/displayRectIgnoringOpacity:" target="_top">displayRectIgnoringOpacity:</a></code></p></td></tr></table></div><p><span class="content_text">Table A-2</span> lists the methods that mark views or regions of views for redrawing using the auto-display feature.</p><a name="//apple_ref/doc/uid/TP40002974-CH8-SW42" title="Table A-2NSView display methods&acirc;&#128;&#148;deferred display"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table A-2&nbsp;&nbsp;</strong><code>NSView</code> display methods—deferred display</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Display area</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Display method</p></th></tr><tr><td  scope="row"><p>Entire view</p></td><td ><p><code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/setNeedsDisplay:" target="_top">setNeedsDisplay:</a></code></p></td></tr><tr><td  scope="row"><p>Partial view</p></td><td ><p><code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/setNeedsDisplayInRect:" target="_top">setNeedsDisplayInRect:</a></code></p></td></tr></table></div><p><span class="content_text">Table A-3</span> lists the methods that force an immediate display of views (or portions of views) invalidated with the methods in <span class="content_text">Table A-2</span>. </p><a name="//apple_ref/doc/uid/TP40002974-CH8-SW41" title="Table A-3NSView display methods&acirc;&#128;&#148;Immediate display of marked views"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table A-3&nbsp;&nbsp;</strong><code>NSView</code> display methods—Immediate display of marked views</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Display area and opacity</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Display method</p></th></tr><tr><td  scope="row"><p>Entire view</p></td><td ><p><code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/displayIfNeeded" target="_top">displayIfNeeded</a></code></p></td></tr><tr><td  scope="row"><p>Partial view</p></td><td ><p><code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/displayIfNeededInRect:" target="_top">displayIfNeededInRect:</a></code></p></td></tr><tr><td  scope="row"><p>Entire view, ignoring opacity</p></td><td ><p><code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/displayIfNeededIgnoringOpacity" target="_top">displayIfNeededIgnoringOpacity</a></code></p></td></tr><tr><td  scope="row"><p>Partial view, ignoring opacity</p></td><td ><p><code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/displayIfNeededInRectIgnoringOpacity:" target="_top">displayIfNeededInRectIgnoringOpacity:</a></code></p></td></tr></table></div><p>To reiterate, displaying views immediately is less efficient than using the auto-display feature, and immediately displaying only the marked parts of views falls somewhere in between. In addition, it is generally more efficient to mark areas of views as dirty rather than entire views. The display methods are a convenience for application development. A view can lock focus, draw itself, and unlock focus. But this is recommended only in certain circumstances, such as when animating content on a timer callback. In general, you should not try to circumvent the Application Kit's display mechanism.</p><a name="//apple_ref/doc/uid/TP40002974-CH8-SW20" title="Locking Focus"></a><h4>Locking Focus</h4><p>When the Application Kit—or your code—locks <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_802"></a><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_803"></a>focus on a view, <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/cl/NSView" target="_top">NSView</a></code> completes the following set-up steps:</p><ul class="spaceabove"><li class="li"><p>It transforms the view's coordinate system from its superview's coordinate system and makes it the application's current coordinate system.</p></li><li class="li"><p>It constructs a clipping path to define the rectangular area outside of which the view cannot draw. </p></li><li class="li"><p>It activates other parameters of the current graphics state to establish the view's drawing environment.</p></li></ul><p>You lock focus on a view by sending it a <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/lockFocus" target="_top">lockFocus</a></code> (or related <code>lockFocus...</code>) message. After drawing is completed in a focused view, you unlock focus by sending it <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/unlockFocus" target="_top">unlockFocus</a></code>. The Application Kit automatically locks and unlocks focus when sending a view a <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/drawRect:" target="_top">drawRect:</a></code> message.</p><p>A focused view is one that is currently drawing. Every window has a <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_804"></a>window graphics context, which defines a window server destination for drawing. This graphics context contains one or more graphics states, each of which isolates drawing operations for a particular view. The current graphics state contains the effective coordinate system and other drawing parameters for the most recently focused view. </p><p>A <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_805"></a>graphics state includes the <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_806"></a>current transformation matrix, which is a mathematical construct used to map points from one coordinate space to another through rotation, scaling, and translation operations. A graphics state also defines the current clipping area and other parameters that drawing operations may consult when they render an image. These parameters include the following:</p><ul class="spaceabove"><li class="li"><p>The current color for fill and stroke operations</p></li><li class="li"><p>Alpha value (transparency)</p></li><li class="li"><p>Line attributes, including width, join, cap, dash, and miter limit</p></li><li class="li"><p>Anti-aliasing value</p></li><li class="li"><p>Current color space</p></li><li class="li"><p>Text attributes: font, font size, character spacing</p></li><li class="li"><p>Blend mode</p></li></ul><p>It's possible to lock focus on a view when another view already has focus. In fact, this is what the Application Kit does during a drawing pass. Because each view keeps track of its own coordinate system as a modification of its superview's, a view is generally brought into focus after its superview. In a group of invalidated views, the Application Kit locks focus on the topmost view and works its way down the view hierarchy, making a nested series of  <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/lockFocus" target="_top">lockFocus</a></code> calls. As focus is locked on each successive view, the current graphics state is saved on a stack maintained by the graphics context (see <span class="content_text">Figure A-18</span>). As focus is unlocked on a view, the graphics state at the top of the stack is "popped" and restored as the current graphics state. </p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH8-SW23" title="Figure A-18Nested focused views and graphics state stack"></a><p><strong>Figure A-18&nbsp;&nbsp;</strong>Nested focused views and graphics state stack</p><img src = "../Art/graphics_state_stack.gif" alt = "Nested focused views and graphics state stack" width="372" height="196"></div><br/><a name="//apple_ref/doc/uid/TP40002974-CH8-SW21" title="What Happens in drawRect:"></a><h4>What Happens in drawRect:</h4><p>After the Application Kit locks focus on a view, it sends it a <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_807"></a><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_808"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/drawRect:" target="_top">drawRect:</a></code> message. A view's class implements this method to <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_809"></a><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_810"></a>draw the view. A rectangle is passed in to <code>drawRect:</code>  that defines the area to be drawn in the view's coordinate system. This rectangle might or might not correspond to the bounds of the view. It could be the union of all rectangular regions of the view that have been marked as invalid, or it could be a superset of that. </p><p>The sending of drawing instructions and data to the window server has a cost that should be avoided when possible, especially for drawing that will not end up being visible. A major Application Kit optimization is restricting the area to draw in, especially when the drawing is complex. The view can choose to draw itself entirely—the least efficient of alternatives—or it can draw the area defined by the passed-in rectangle. A potentially even more efficient procedure for a view would be to obtain the list of invalidated regions (through the <code>NSView</code> method <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/getRectsBeingDrawn:count:" target="_top">getRectsBeingDrawn:count:</a></code>) and selectively draw each of these regions in turn.</p><p>In its implementation of <code>drawRect:</code> the view class invokes various functions and methods to specify the drawing instructions and data to be passed to the window server. The Application Kit provides the following high-level drawing functions and methods: </p><ul class="spaceabove"><li class="li"><p>Drawing functions (declared in <code>NSGraphics.h</code>) to draw, fill, erase, and perform other operations with rectangles  </p></li><li class="li"><p>Methods to construct lines and shapes with bezier paths (<code>NSBezierPath</code> class)</p></li><li class="li"><p>Methods to create and apply affine transforms, involving translation, scaling, and rotation operations (<code><a href="../../../Reference/Foundation/Classes/NSAffineTransform_Class/Reference/Reference.html#//apple_ref/occ/cl/NSAffineTransform" target="_top">NSAffineTransform</a></code> class)</p></li><li class="li"><p>Color and color-space methods (<code><a href="../../../Reference/ApplicationKit/Classes/NSColor_Class/Reference/Reference.html#//apple_ref/occ/cl/NSColor" target="_top">NSColor</a></code> and <code><a href="../../../Reference/ApplicationKit/Classes/NSColorSpace_Class/Reference/Reference.html#//apple_ref/occ/cl/NSColorSpace" target="_top">NSColorSpace</a></code>)</p></li><li class="li"><p>Methods for creating and compositing images (<code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/cl/NSImage" target="_top">NSImage</a></code> and various image-representation classes)</p></li><li class="li"><p>Methods for drawing text (<code><a href="../../../Reference/Foundation/Classes/NSString_Class/Reference/NSString.html#//apple_ref/occ/cl/NSString" target="_top">NSString</a></code> and <code>NSAttributedString</code>)</p></li></ul><p>The Application Kit implements these methods and functions using <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_811"></a>Core Graphics (<a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_812"></a>Quartz) functions and types. A view can also use these Core Graphics functions natively when it draws itself. These Quartz client library functions map directly to rendering operators of the window server, resulting in a raster (bitmap) image that, for in-window drawing, becomes part of the window's backing store. </p><a name="//apple_ref/doc/uid/TP40002974-CH8-SW67" title="Threads and Drawing"></a><h4>Threads and Drawing</h4><p>The <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_813"></a>drawing of views does not have to occur on the main thread; each thread of an application has the ability to lock focus on a view and draw. However, there are the following qualifications:  </p><ul class="spaceabove"><li class="li"><p>Mutations of the properties of an <code>NSView</code> object (for example, its frame rectangle) should happen only on the main thread.</p></li><li class="li"><p>When an <code>NSView</code> display method is invoked, the Application Kit grabs a lock for drawing in the receiving view's window; you cannot perform any custom drawing until the display method returns. This means that only one thread can draw into a given window at a time.</p></li></ul><a name="//apple_ref/doc/uid/TP40002974-CH8-SW68" title="Views and Printing"></a><h3>Views and Printing</h3><p><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_814"></a>Views are the foundation of the Cocoa printing architecture. They provide the content to be printed, just as they provide content to be displayed on a screen. The general procedure is the same: The Application Kit locks focus on the view, its <code>drawRect:</code> method is invoked, the view draws the printable content, and focus is unlocked. You can tell a view to print itself by invoking its <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/print:" target="_top">print:</a></code> method.</p><a name="//apple_ref/doc/uid/TP40002974-CH8-SW69" title="Views and Events"></a><h3>Views and Events</h3><p><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_815"></a><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_816"></a>Views are the objects in an application that respond directly to most user events such as mouse clicks or key presses. They are almost always the object providing the surface on which a user event occurs. Consequently, these front-line objects are given the first shot at handling <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_817"></a>event messages. </p><p>As discussed in <span class="content_text"><a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW12">“Windows and Event Handling,”</a></span> a window forwards a user event (as an event message) to the view in its view hierarchy that should receive the event. For mouse events, it sends the message to the view under which the event occurred. If the event is a key event, the window sends the message to its <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_818"></a>first responder, which is usually the view with key focus. In order to receive the key event, the view must declare that it accepts first-responder status (that is, it overrides the <code>NSResponder</code> method <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/acceptsFirstResponder" target="_top">acceptsFirstResponder</a></code> to return <code>YES</code>). </p><p>Views are responder objects, which means they inherit the programmatic interface of the <code>NSResponder</code> class. Event messages invoke methods declared by this class; examples of such messages are <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/mouseDown:" target="_top">mouseDown:</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/mouseMoved:" target="_top">mouseMoved:</a></code>, and <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/keyUp:" target="_top">keyUp:</a></code>. To handle an event, a view's class must implement the appropriate <code>NSResponder</code> method; in its implementation it can inspect the passed-in <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/cl/NSEvent" target="_top">NSEvent</a></code> <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_819"></a>objects (which encapsulates information about the event) and proceed from there. If a view does not handle an event, the next responder up the <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_820"></a>responder chain—which is usually a superview—is given an opportunity to handle the event. <span class="content_text"><a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW17">“Responders and the Responder Chain”</a></span> describes responders and how events travel up the responder chain.</p><p>Views also play a major role with <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_821"></a>action messages. These messages often originate as event messages sent to <code><a href="../../../Reference/ApplicationKit/Classes/NSControl_Class/Reference/Reference.html#//apple_ref/occ/cl/NSControl" target="_top">NSControl</a></code> objects; in handling them, a control object sends an action message to a target object. If no target is specified, the application searches up the responder chain for an object that can respond to the action message. For more on <code>NSControl</code> objects and the <code>NSCell</code> objects they use, see <span class="content_text"><a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW13">“Controls and Menus.”</a></span><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_822"></a><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_823"></a></p><a name="//apple_ref/doc/uid/TP40002974-CH8-SW17" title="Responders and the Responder Chain"></a><h2>Responders and the Responder Chain</h2><p>Objects of the core application classes—<code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/cl/NSApplication" target="_top">NSApplication</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/cl/NSWindow" target="_top">NSWindow</a></code>, and <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/cl/NSView" target="_top">NSView</a></code>—are <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_824"></a>responders. They are instances of classes that inherit, directly or indirectly, from <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/cl/NSResponder" target="_top">NSResponder</a></code> (see <span class="content_text">Figure A-19</span>). This abstract class defines the interface and expected behavior of objects that can respond to events. The subclasses of <code>NSResponder</code> implement this behavior in whole or in part.</p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH8-SW37" title="Figure A-19NSResponder and its direct subclasses"></a><p><strong>Figure A-19&nbsp;&nbsp;</strong>NSResponder and its direct subclasses</p><img src = "../Art/responder_classes.gif" alt = "NSResponder and its direct subclasses" width="386" height="177"></div><br/><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH8-SW83" title="Note"></a><p><strong>Note:</strong>&nbsp;Two other Application Kit classes directly inherit from <code>NSResponder</code>: <code><a href="../../../Reference/ApplicationKit/Classes/NSWindowController_Class/Reference/Reference.html#//apple_ref/occ/cl/NSWindowController" target="_top">NSWindowController</a></code> and <code><a href="../../../Reference/ApplicationKit/Classes/NSDrawer_Class/Reference/Reference.html#//apple_ref/occ/cl/NSDrawer" target="_top">NSDrawer</a></code>. Although <code>NSWindowController</code> is part of the Cocoa document architecture (described in  <span class="content_text"><a href="../OtherArchitectures/OtherArchitectures.html#//apple_ref/doc/uid/TP40002974-CH10-SW1">“Other Cocoa Architectures on Mac OS X”</a></span>), neither of these classes is central to the core Cocoa application architecture.</p></div><p>The <code>NSResponder</code> class defines an interface for three major patterns or mechanisms of the core application architecture:</p><ul class="ul"><li class="li"><p>It declares a number of methods for handling <strong><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_825"></a>event messages</strong> (that is, messages originating in user events such as mouse clicks and key presses).</p></li><li class="li"><p>It declares dozens of methods for handling <strong><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_826"></a>action messages</strong> that are tied to the standard key bindings (for example, those that move the insertion point within text). An action message is dispatched to a target object; if no target is specified, the application searches for a suitable responder.</p></li><li class="li"><p>It defines a set of methods for designating and managing the responders in an application. These responders form what as known as a <strong><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_827"></a>responder chain</strong>—a series of responders along which an event or action message is passed until it finds an object capable of handling it. </p> </li></ul><p>The responder chain is a central mechanism in the Application Kit's architecture for <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_828"></a>event handling. It is a linked series of responder objects along which an event or action message is passed. As depicted in <span class="content_text">Figure A-20</span>, if a responder object cannot handle an event or action—that is, it either does not respond to the message or the event is one it doesn't recognize—it resends the message to the next responder in the chain. The message travels up the chain, toward higher-level objects, until it is handled. (If it isn't handled, it is discarded.)</p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH8-SW15" title="Figure A-20The responder chain"></a><p><strong>Figure A-20&nbsp;&nbsp;</strong>The responder chain</p><img src = "../Art/responder_chain.gif" alt = "The responder chain" width="312" height="373"></div><br/><p>When the Application Kit constructs the objects in a application, it sets up the responder chain for each window. The essential objects in a responder chain are the <code>NSWindow</code> object and its <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_829"></a>view hierarchy. Lower views in the hierarchy are given the chance to handle an event or action message before higher level objects. The <code>NSWindow</code> keeps a reference to the <strong><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_830"></a>first responder</strong>, which is usually the currently selected view in the window, and gives it first shot at responding to the message. For event messages, the responder chain usually ends at the <code>NSWindow</code> object managing the window in which the event occurred, although other next-responders can be added after the <code>NSWindow</code> object. </p><p>For action messages, the responder chain is more complex. Two factors determine the chain of responders for action messages:</p><ul class="ul"><li class="li"><p>If the application currently has both a <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_831"></a>main window and a <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_832"></a>key window, the responders chains of both windows are involved, with the key window's responder chain first given the chance at handling the action. At the end of each window's chain, the <code>NSWindow</code> delegate is given a chance to respond; at the end of the combined responder chains are <code>NSApp</code> and its delegate. </p></li><li class="li"><p>The type of application—simple, document-based, or an application that uses a window controller—determines the type and location of responder objects in the chain. </p></li></ul><p>The <code>NSResponder</code> class also includes declarations of methods for error presentation and recovery, message dispatch, application help, and other features. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH8-SW84" title="Further Reading"></a><p><strong>Further Reading:</strong>&nbsp;To learn more about responders and the responder chain, see <em><a href="../../EventOverview/index.html#//apple_ref/doc/uid/10000060i" target="_top">Cocoa Event-Handling Guide</a></em></p></div><a name="//apple_ref/doc/uid/TP40002974-CH8-SW13" title="Controls and Menus"></a><h2>Controls and Menus</h2><p>Many of the objects you see in an application let you manipulate them to signal intent. These objects include buttons, checkboxes, sliders, table views, file-system browsers, and menus (including the application and pop-up menus).  In Cocoa, similar architectures underlie the implementations of the two general kinds of choice-enabling objects: controls and menus. In these architectures, various types of objects, including <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/cl/NSView" target="_top">NSView</a></code> objects, work together to allow the indication of user choice or intent.  </p><a name="//apple_ref/doc/uid/TP40002974-CH8-SW47" title="Control and Cell Architecture"></a><h3>Control and Cell Architecture</h3><p>A <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_833"></a><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_834"></a>control is a user-interface object that responds to a user event such as a mouse click by sending a message to another object in an application. Common types of controls are buttons, sliders, and text fields (which typically send a message when users press the Return key). Other, less obvious controls are table views, data browsers, and color wells.</p><p>A control is an instance of a subclass of the abstract <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_835"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSControl_Class/Reference/Reference.html#//apple_ref/occ/cl/NSControl" target="_top">NSControl</a></code>. It generally manages one or more <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_836"></a>cells—instances of a subclass of <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_837"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSCell_Class/Reference/NSCell.html#//apple_ref/occ/cl/NSCell" target="_top">NSCell</a></code>, another abstract class. If you look at the Application Kit class hierarchy (<span class="content_text"><a href="../WhatIsCocoa/WhatIsCocoa.html#//apple_ref/doc/uid/TP40002974-CH3-SW1">Figure 1-10</a></span>), you notice that <code>NSControl</code>, a subclass of <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/cl/NSView" target="_top">NSView</a></code>, is the root of a fairly large branch of control classes: <code><a href="../../../Reference/ApplicationKit/Classes/NSButton_Class/Reference/Reference.html#//apple_ref/occ/cl/NSButton" target="_top">NSButton</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSStepper_Class/Reference/Reference.html#//apple_ref/occ/cl/NSStepper" target="_top">NSStepper</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSTextField_Class/Reference/Reference.html#//apple_ref/occ/cl/NSTextField" target="_top">NSTextField</a></code>, and so on. At an entirely different location in the hierarchy (under <code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/cl/NSObject" target="_top">NSObject</a></code>), <code>NSCell</code> is the start of a branch of cell classes, most of which correspond to a control class: <code><a href="../../../Reference/ApplicationKit/Classes/NSButtonCell_Class/Reference/Reference.html#//apple_ref/occ/cl/NSButtonCell" target="_top">NSButtonCell</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSStepperCell_Class/Reference/Reference.html#//apple_ref/occ/cl/NSStepperCell" target="_top">NSStepperCell</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSTextFieldCell_Class/Reference/Reference.html#//apple_ref/occ/cl/NSTextFieldCell" target="_top">NSTextFieldCell</a></code>, and so on.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH8-SW85" title="Note"></a><p><strong>Note:</strong>&nbsp;Two control classes dispense with cells entirely: <code><a href="../../../Reference/ApplicationKit/Classes/NSScroller_Class/Reference/Reference.html#//apple_ref/occ/cl/NSScroller" target="_top">NSScroller</a></code> and <code><a href="../../../Reference/ApplicationKit/Classes/NSColorWell_Class/Reference/Reference.html#//apple_ref/occ/cl/NSColorWell" target="_top">NSColorWell</a></code>. Instances of these classes, like any control, enable the user to indicate a choice, but they behave like any non-control view in that they draw themselves and respond to user events without using cells. </p></div><a name="//apple_ref/doc/uid/TP40002974-CH8-SW70" title="Controls That Manage Multiple Cells"></a><h4>Controls That Manage Multiple Cells</h4><p>Most <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_838"></a><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_839"></a>controls in the Application Kit manage a <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_840"></a>single cell. In these cases, the control has its cell do almost all of the actual work; it forwards many of the messages sent to it to its cell. But some controls manage multiple cells. The Application Kit takes two general approaches to managing multiple cells within controls: </p><ul class="spaceabove"><li class="li"><p>A single cell instance is used as a <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_841"></a>template for drawing. Whenever a control must draw a cell, it uses this instance to replicate each cell representation, varying only the content. The <code><a href="../../../Reference/ApplicationKit/Classes/NSTableView_Class/Reference/Reference.html#//apple_ref/occ/cl/NSTableView" target="_top">NSTableView</a></code> and <code><a href="../../../Reference/ApplicationKit/Classes/NSOutlineView_Class/Reference/Reference.html#//apple_ref/occ/cl/NSOutlineView" target="_top">NSOutlineView</a></code> classes take this approach when drawing the cells of table-view and outline-view columns.</p></li><li class="li"><p>An individual cell instance represents each cell region drawn on a control. The <code><a href="../../../Reference/ApplicationKit/Classes/NSMatrix_Class/Reference/Reference.html#//apple_ref/occ/cl/NSMatrix" target="_top">NSMatrix</a></code> class takes this approach when it requests its cell instances to draw themselves. <code><a href="../../../Reference/ApplicationKit/Classes/NSBrowser_Class/Reference/Reference.html#//apple_ref/occ/cl/NSBrowser" target="_top">NSBrowser</a></code> and <code><a href="../../../Reference/ApplicationKit/Classes/NSForm_Class/Reference/Reference.html#//apple_ref/occ/cl/NSForm" target="_top">NSForm</a></code> objects function in a similar way: their cells are also individual instances. </p><p>An <code>NSMatrix</code> object (or matrix) can manage most cell types. It arranges them in grids of arbitrary dimensions. When you construct a matrix of cells in <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_842"></a>Interface Builder, the cells are all copies of a given cell prototype. However, you can programmatically set the cells to be instances of different <code>NSCell</code> subclasses. <code>NSBrowser</code> and <code>NSForm</code> controls are more limited in the types of cells they can manage. </p></li></ul><p>A single-cell control may seem to be a redundant design, but the value here is with the cell, not the control. See <span class="content_text"><a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW43">“Rationale for the Control-Cell Architecture”</a></span> for an explanation.</p><a name="//apple_ref/doc/uid/TP40002974-CH8-SW71" title="How Controls Manage Cells"></a><h4>How Controls Manage Cells</h4><p>Controls are full-fledged <code>NSView</code> objects. They can be marked as needing display, they are responsible for drawing themselves, they can respond to user events, and they are in the <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_843"></a>responder chain. At runtime, a control initially behaves like any view. The Application Kit asks it to redraw itself by invoking the control's <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/drawRect:" target="_top">drawRect:</a></code> method. If an event message is dispatched to the responder chain and the control implements the appropriate <code>NSResponder</code> method, the control may have an opportunity to handle the event. However, instead of drawing and handling events themselves, controls pass on these responsibilities to their cells. If the control has multiple cells, it also coordinates the behavior of its cells.</p><p>As illustrated in <span class="content_text">Figure A-21</span>, a control within its  <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/drawRect:" target="_top">drawRect:</a></code> method typically sends <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_844"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSCell_Class/Reference/NSCell.html#//apple_ref/occ/instm/NSCell/drawWithFrame:inView:" target="_top">drawWithFrame:inView:</a></code> to a cell, asking it to <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_845"></a>draw itself within the passed-in rectangle. Because focus is already locked on the control, the cell can draw itself using the surface of its "host" view. A control in an implementation of a <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/mouseDown:" target="_top">mouseDown:</a></code> event method sends a <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_846"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSCell_Class/Reference/NSCell.html#//apple_ref/occ/instm/NSCell/trackMouse:inRect:ofView:untilMouseUp:" target="_top">trackMouse:inRect:ofView:untilMouseUp:</a></code> to the cell in which the event occurred. Typically, the cell tracks the mouse events within its border until either the mouse exits or the cell receives a <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/mouseUp:" target="_top">mouseUp:</a></code> event; then it responds appropriately. (Other event types are handled in a similar manner.)</p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH8-SW44" title="Figure A-21A control coordinating the drawing of a cell"></a><p><strong>Figure A-21&nbsp;&nbsp;</strong>A control coordinating the drawing of a cell</p><img src = "../Art/control_cell_drawing.gif" alt = "A control coordinating the drawing of a cell" width="505" height="159"></div><br/><p>When a cell draws itself, it must represent two aspects. The first is the general appearance of the cell, which is consistent among cells of the same class. These characteristics include cell shape, background color, style, and visual indications of cell state (for example, a checkbox for cell selection or gray text if the cell isn't enabled). The second aspect is the cell's <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_847"></a>content, which individuates the cell. For content, a cell usually has a title (a string), an image, or in some cases both title and image. The title can be in a specified font. (Some cells, like <code><a href="../../../Reference/ApplicationKit/Classes/NSSliderCell_Class/Reference/Reference.html#//apple_ref/occ/cl/NSSliderCell" target="_top">NSSliderCell</a></code>, have custom content instead of image or title.) </p><p>As content (or part of its content) a cell has an <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_848"></a>object value and possibly a <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_849"></a>represented object. The object value must be an object that can be formatted as a string and thus displayed as the cell title—for example, an <code><a href="../../../Reference/Foundation/Classes/NSNumber_Class/Reference/Reference.html#//apple_ref/occ/cl/NSNumber" target="_top">NSNumber</a></code> object encapsulating a <code>float</code> value. A represented object, although not displayed, is associated with the cell; for example, a button with a title of "Red" could have an <code><a href="../../../Reference/ApplicationKit/Classes/NSColor_Class/Reference/Reference.html#//apple_ref/occ/cl/NSColor" target="_top">NSColor</a></code> represented object. For more on object values and represented objects, see <span class="content_text"><a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW53">“Represented Objects.”</a></span> </p><p>What also individuates most cells is the information they encapsulate for <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_850"></a>action messages. The <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_851"></a><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_852"></a>target-action mechanism (discussed in <span class="content_text"><a href="../CommunicatingWithObjects/CommunicateWithObjects.html#//apple_ref/doc/uid/TP40002974-CH7-SW14">“The Target-Action Mechanism”</a></span> allows a control to send a message to a designated object when the user activates the control (by clicking a button or pressing Return in a text field, for example). The action is a selector that identifies the method to invoke; the target is the designated object. (The target can be <code>nil</code>, which tells the application to search the <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_853"></a>responder chain for an object that can handle the message; see <span class="content_text"><a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW17">“Responders and the Responder Chain.”</a></span>) The abstract NSActionCell class defines the interface for storing and retrieving action selectors and references to target objects. Most NSCell subclasses inherit from NSActionCell. </p><a name="//apple_ref/doc/uid/TP40002974-CH8-SW43" title="Rationale for the Control-Cell Architecture"></a><h4>Rationale for the Control-Cell Architecture</h4><p>The <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_854"></a>control-cell architecture in the Application Kit has deep historical roots, going back to the early days of NeXTSTEP. But the necessity for it might seem puzzling at first glance. Why have controls manage cells at all? Why can't controls do the required work themselves?</p><p>There's no reason why a control couldn't, and if you are designing a custom control, a cell-less control is certainly a valid approach. But the control-cell architecture brings some advantages with it:</p><ul class="spaceabove"><li class="li"><p>The architecture extends the usefulness of controls. A control such as a table view or a matrix can efficiently manage many different types of cells without having to have specific knowledge of each type. A cell such as an <code>NSButtonCell</code> object might be designed to work with <code>NSButton</code> controls, but it can also work with matrix and table-view objects. </p><p>A cell is an abstraction that simplifies the management of different kinds of graphical objects on a view. It allows for a kind of plug-in design where a control can host different kinds of graphical objects, each with its own identity, including target and action information.</p></li><li class="li"><p>The control-cell architecture permits a tighter coupling between a control and its cells than between, say, a view and a collection of subviews. Subviews are largely autonomous within their superview; a control can better act as a coordinator of its cells. For example, in a matrix of radio buttons, the control ensures that only one of the buttons is on at any time.</p></li><li class="li"><p>The <code>NSTableView</code> model for drawing cell regions—reusing a handful of cell instances as  "rubber stamps" for drawing—is efficient, especially for controls that must manage a potentially unbounded number of subregions. </p></li><li class="li"><p>Even in cases where it's not feasible to use a few cell instances as templates for drawing, <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_855"></a>cells often offer a performance advantage over subviews. Views are relatively heavyweight objects both in terms of memory and computation. For example, tracking and propagating invalid view regions through the view hierarchy can exact a significant cost.</p></li></ul><p>There are also tradeoffs between the use of cells versus subviews for drawing subregions. In the absence of the view invalidation mechanism, the control must take responsibility for figuring out what each cell need to draw on itself. But because views are general purpose objects, a specialized control can often do the required calculations more efficiently.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH8-SW86" title="Note"></a><p><strong>Note:</strong>&nbsp;See <em><a href="../../ControlCell/index.html#//apple_ref/doc/uid/10000015i" target="_top">Control and Cell Programming Topics for Cocoa</a></em> for more information about controls, cells, and the architecture enabling them to work together.</p></div><a name="//apple_ref/doc/uid/TP40002974-CH8-SW72" title="Menu Characteristics and Architecture"></a><h3>Menu Characteristics and Architecture</h3><p><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_856"></a><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_857"></a>In addition to controls and cells, users can signal their intentions to an application (as well as to the operating system itself) using menus. A menu is a list of tersely worded choices—or menu items—with potentially nested menus (called submenus). Users typically choose a menu item by clicking it (although other methods are supported); as a result, a command is issued that the active application or operating system acts upon. </p><p>Cocoa supports various kinds of <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_858"></a>menus. Primary among these are the <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_859"></a>application-specific menus, which in Cocoa are collectively known as the <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_860"></a>main menu. At runtime, the application-specific menus include <em>the</em>application menu (the one bearing the application name) and all the menus to the right of it up through the Help menu. The application-specific menus share the menu bar with the Apple menu and menu extras—the service-specific menus to the right of the application-specific menus. The Application Kit automatically creates and manages <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_861"></a>certain application-specific menus, such as the Services menu, the Font menu, the Windows menu, and the Help menu. Other types of menus that Cocoa applications can manage include pop-up menus, contextual menus, and dock menus. </p><p>Menus and especially <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_862"></a>menu items have a number of interesting characteristics. Both menus and menu items have a title; the titles of menus are the strings that appear in the menu bar. Menu items can additionally have an image that appears to the left of the title, or they can have an image instead of a title. The title can be an attributed string, allowing different fonts and even text attachments (which permits an image to appear anywhere in the content area of a menu item). Menu items can also have an assigned key called the key equivalent which, when pressed together with modifier keys (except for Shift), causes the same response as a mouse click. Menu items are enabled or disabled, or they can indicate an on or off state; a check-mark appears to the left of the title if the item is in an on state.</p><p>Menus and menu items in Cocoa are instances of the classes <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_863"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSMenu_Class/Reference/Reference.html#//apple_ref/occ/cl/NSMenu" target="_top">NSMenu</a></code> and <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_864"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSMenuItem_Class/Reference/Reference.html#//apple_ref/occ/cl/NSMenuItem" target="_top">NSMenuItem</a></code>, respectively. In a Cocoa application, menus (in a generic sense) are based on a simple design that gives <code>NSMenu</code> and <code>NSMenuItem</code> objects complementary roles. An <code>NSMenu</code> object manages and draws a collection of menu items one below another. It contains an array of <code>NSMenuItem</code> objects representing this collection. An <code>NSMenuItem</code> object encapsulates all the data that characterizes a menu item but does no drawing or event handling itself. An <code>NSMenu</code> object uses the data in each <code>NSMenuItem</code> to draw the menu item within the boundaries of the menu, to track the location of the menu item within the menu, and to send an <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_865"></a>action message to a <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_866"></a>target object when users choose the menu item. When drawing, an <code>NSMenu</code> object uses an <code>NSMenuItem</code> object's title and image; for tracking, it uses the item's index; for sending action messages, it uses the action selector and target object stored in an <code>NSMenuItem</code> object. </p><p><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_867"></a><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_868"></a>Pop-up menus make use of this basic menu architecture. However, since they appear within an application's user interface, they have an additional design. Before a user clicks it, a pop-up menu appears as a button-like object. This object is an instance of <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_869"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSPopUpButton_Class/Reference/Reference.html#//apple_ref/occ/cl/NSPopUpButton" target="_top">NSPopUpButton</a></code>, which manages an <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_870"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSPopUpButtonCell_Class/Reference/Reference.html#//apple_ref/occ/cl/NSPopUpButtonCell" target="_top">NSPopUpButtonCell</a></code> instance—in other words, the control-cell architecture is used for this initial presentation. The <code>NSPopUpButtonCell</code> object contains an <code>NSMenu</code> object along with its encapsulated <code>NSMenuItem</code> objects. When a user clicks a pop-up button, this embedded menu is asked to display itself.  </p><p>The menu items in a menu can be <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_871"></a>validated for the current context and, if an item is not relevant to that context, it can be disabled. <code>NSMenu</code> includes an auto-enabling feature that performs this validation automatically. Before a menu is displayed, it searches the responder chain for an object that can respond to a menu item's action message; if it cannot find any such object, it disables the item. Applications can further refine menu validation by implementing the <code>NSMenuValidation</code> informal protocol.</p><p><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_872"></a>Contextual menus are implemented in way that's similar to pop-up menus. You can attach an <code>NSMenu</code> object (along with its menu items) to a view using the <code>NSResponder</code> method <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/setMenu:" target="_top">setMenu:</a></code>. This menu lists commands specific to the view (which can be validated according to context). When users Control-click or right-click in the view, the menu is displayed.<a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_873"></a> </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH8-SW87" title="Further Reading"></a><p><strong>Further Reading:</strong>&nbsp;<em><a href="../../MenuList/index.html#//apple_ref/doc/uid/10000032i" target="_top">Application Menu and Pop-up List Programming Topics for Cocoa</a></em> discusses Cocoa menus and menu items in more detail.</p></div><a name="//apple_ref/doc/uid/TP40002974-CH8-SW53" title="Represented Objects"></a><h3>Represented Objects</h3><p>A cell and menu item can have a <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_874"></a><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_875"></a>represented object, an object that is arbitrarily associated with it. The target of an action message can ask a clicked menu item or cell (<code>sender</code>) for its represented object; the target can then display the represented object, load it, or perform whatever operation is required with the fetched object. A cell or menu item allows clients to access a represented object, and it archives and restores it, but otherwise does not use it.</p><p>To understand how you might use represented objects, consider a couple of examples. A matrix contains cells for setting the background color of a text view. These cells have names such as "Light Blue", "Light Gray", "Pink," and so on; the represented object for each menu item is an <code>NSColor</code> object encapsulating the RGB components for that color. Your application might use that represented object as in <span class="content_text">Listing A-1</span>.</p><a name="//apple_ref/doc/uid/TP40002974-CH8-SW52" title="Listing A-1Using a represented object"></a><p class="codesample"><strong>Listing A-1&nbsp;&nbsp;</strong>Using a represented object</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)changeColor:(id)sender {<span></span></pre></td></tr><tr><td scope="row"><pre>    NSColor *repObj = [sender representedObject];<span></span></pre></td></tr><tr><td scope="row"><pre>    [textView setBackgroundColor:repObj];  // textView is an outlet<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Another example would be a pop-up menu in an Info window that allows you to change the displayed pane of settings. Assigned as a represented object to each menu item is an <code>NSView</code> object containing the required set of text fields, controls, and so on.</p><p>A represented object is not the same thing as the <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_876"></a>object value of a control or cell. A represented object is arbitrarily associated while an object value <em>is</em> the value behind what the cell or control displays. For example, an object value for a text field that displays "05/23/2006" would be an <code>NSDate</code> or <code>NSCalendarDate</code> object representing that displayed value. A cell or control's formatter must be able to "understand" an object value. (A formatter is an <code>NSFormatter</code> object).</p><p>Represented objects are not strictly limited to cells and menu items. For example, <code>NSRulerMarker</code> objects can have represented objects. And you can design your own custom views to have represented objects.</p> <a name="//apple_ref/doc/uid/TP40002974-CH8-SW49" title="Nib Files and Other Application Resources"></a><h2>Nib Files and Other Application Resources</h2><p>So far the discussion in this chapter has focused on the fundamental application architecture of Cocoa, describing how at runtime the core objects of an application work together to facilitate event handling and drawing. But now the focus shifts somewhat to take in the full picture of a running Cocoa application. Rarely does an application create all of its constituent objects "from scratch" when it launches. Many, if not most, of these objects are stored in the application bundle as archives of object graphs. These object graphs can represent the model objects that encapsulate the application's data as it existed just before the user quit the application. Or they can be encoded representations of the windows, views, and other objects that make up the application's user interface. An application loads and unarchives object archives at runtime to re-create the original objects. </p><p>An application includes not just objects and code but the other resources in its bundle, such as images and localized strings. This section also summarizes the role that instances of the <code><a href="../../../Reference/Foundation/Classes/NSBundle_Class/Reference/Reference.html#//apple_ref/occ/cl/NSBundle" target="_top">NSBundle</a></code> <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_877"></a>class plays in locating and loading all types of  application resources, both localized and non-localized.</p><a name="//apple_ref/doc/uid/TP40002974-CH8-SW50" title="Object Archives"></a><h3>Object Archives</h3><p><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_878"></a>Objects in a program exist in a network of relationships with other objects. An object can own particular objects or collections of objects, it can be dependent on other objects, and it can hold references to objects in the program in order to send messages to those objects. This web of interrelated objects is known as an <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_879"></a>object graph. Object graphs can become quite complex.</p><p>An <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_880"></a>archive is a means for storing an object graph. It usually takes the form of a file but can be a stream transmitted between processes. An archive preserves the identity of each object in the graph and all the relationships that object has with all other objects in the graph. It encodes the type of each object along with the object's data. When an object graph is unarchived, each decoded object is typically of the same class as the object that was originally encoded into the stream. An object's instance data is also decoded and is used to reconstitute the object. The relationships among objects in the graph are also restored. As a result, an unarchived graph should almost always duplicate the original object graph.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH8-SW88" title="Note"></a><p><strong>Note:</strong>&nbsp;Many Cocoa applications use archives as a persistent store for their model objects. However, the <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_881"></a>Core Data framework (a Cocoa framework) uses a more sophisticated mechanism for object persistence. See <span class="content_text"><a href="../OtherArchitectures/OtherArchitectures.html#//apple_ref/doc/uid/TP40002974-CH10-SW1">“Other Cocoa Architectures on Mac OS X”</a></span> (in this document) and <em><a href="../../CoreData/index.html#//apple_ref/doc/uid/TP40001075" target="_top">Core Data Programming Guide</a></em> for more information.</p></div><p><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_882"></a><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_883"></a>Archiving is an operation that requests each object in an object graph to encode itself into a stream; unarchiving does the reverse, requesting that each object decode itself. Both operations are initiated with a message sent to the root object of the graph. An object that wants to be saved to an archive must encode itself when asked to; to be restorable, it must be able to decode itself. The two types of archiving in Cocoa, sequential and keyed, reflect different styles for encoding and decoding objects. <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_884"></a>Sequential archiving requires objects to encode and decode their instance data in the same order. <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_885"></a>Keyed archiving (a more modern approach) permits each piece of stored instance data to be stored and retrieved using a key (that is, an identifying string). A class that wants to archive its instances must conform to the <code><a href="../../../Reference/Foundation/Protocols/NSCoding_Protocol/Reference/Reference.html#//apple_ref/occ/intf/NSCoding" target="_top">NSCoding</a></code> <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_886"></a>protocol. An object that does sequential archiving uses the encoding and decoding methods of the <code><a href="../../../Reference/Foundation/Classes/NSCoder_Class/Reference/NSCoder.html#//apple_ref/occ/cl/NSCoder" target="_top">NSCoder</a></code> <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_887"></a>class. For keyed archiving (and unarchiving), it must use the methods of the <code><a href="../../../Reference/Foundation/Classes/NSKeyedArchiver_Class/Reference/Reference.html#//apple_ref/occ/cl/NSKeyedArchiver" target="_top">NSKeyedArchiver</a></code> and <code><a href="../../../Reference/Foundation/Classes/NSKeyedUnarchiver_Class/Reference/Reference.html#//apple_ref/occ/cl/NSKeyedUnarchiver" target="_top">NSKeyedUnarchiver</a></code> classes. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH8-SW89" title="Further Reading"></a><p><strong>Further Reading:</strong>&nbsp;To learn more about archiving and unarchiving objects, see <em><a href="../../Archiving/index.html#//apple_ref/doc/uid/10000047i" target="_top">Archives and Serializations Programming Guide for Cocoa</a></em>. </p></div><a name="//apple_ref/doc/uid/TP40002974-CH8-SW46" title="Nib Files"></a><h3>Nib Files</h3><p><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_888"></a>Nearly all Cocoa developers use the <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_889"></a>Interface Builder application to construct the user interface of their applications. (There's no requirement to use Interface Builder, but it makes the job of a developer so much easier.) <span class="content_text">Figure A-22</span>, which you might recall from an earlier chapter, shows a typical arrangement of Interface Builder windows. To create a user interface, you drag objects such as text views, buttons, and table views from palettes and drop them on windows; you then position and size the objects and set their other attributes. You can also make various kinds of <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_890"></a>connections—outlets, target-action, and bindings—between these objects. Interface Builder also lets you make the initial definitions of custom model and controller classes for the purpose of making connections to and from proxy instances of those classes. And, using Interface Builder, you can specify a placeholder object assigned to a custom <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/cl/NSView" target="_top">NSView</a></code> subclass. When you finish work on a user interface in Interface Builder, you can save it as a <strong>nib file</strong> in the project as a localized resource. When the project is built, the nib file is copied to the same <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_891"></a><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_892"></a>localization (<code>.lproj</code>) folder in the application bundle. </p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH8-SW39" title="Figure A-22Interface Builder"></a><p><strong>Figure A-22&nbsp;&nbsp;</strong>Interface Builder</p><img src = "../Art/ib3_2.jpg" alt = "Interface Builder" ></div><br/><p>Nib files are archives whose <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_893"></a>object graphs describe an entire or partial user interface. These graphs represent the complex relationships within a user interface, including a window's view hierarchy and the various connections between objects. The descriptions of these object graphs use XML as a representation language. (You should never attempt to directly edit the XML in a nib file.) </p><p>The root object of a graph appears in the Instances pane of the nib file window (the lower-left window in <span class="content_text"><a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW39">Figure A-22</a></span>). In this example, the Panel instance is a root object (since it contains a view hierarchy). A nib file could have other root objects as well as <code><a href="../../../Reference/ApplicationKit/Classes/NSController_Class/Reference/Reference.html#//apple_ref/occ/cl/NSController" target="_top">NSController</a></code> objects (used for bindings) and proxy instances of custom classes. In addition, each nib file window of a Cocoa application has two special kinds of instances: </p><ul class="spaceabove"><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_894"></a>File's Owner.</strong> An object that owns the nib file and manages the objects within it. The File's Owner must be external to the nib file. You use the File's Owner object as the conduit for connections between objects in the nib file and objects outside of it.</p></li><li class="li"><p><strong><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_895"></a>First Responder</strong>. An object representing the first responder in the responder chain (see <span class="content_text"><a href="CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW17">“Responders and the Responder Chain”</a></span>). In <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_896"></a>target-action connections you can specify the First Responder object as target; when a control or menu sends an action message, the application searches the responder chain (starting with the first responder) until it finds an object that can handle the message.</p></li></ul><p>The standard objects on Interface Builder <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_897"></a>palettes are allocated and initialized when a user interface is built and later are archived when the objects are saved to a nib file. When the nib file is unarchived, these objects are restored. If you create a custom subclass based on the class for a standard palette object, Interface Builder encodes the superclass when it archives the object but has the custom class swapped in when the object is unarchived. In either case, the initializer for the unarchived object is not called. However, if you have a custom class of <code>NSView</code> (represented by the Custom View palette object), the initializer of the class is called when the <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_898"></a>Custom View object is unarchived. In any case, the application sends each custom class associated with a nib file an <code><a href="../../../Reference/ApplicationKit/Protocols/NSNibAwaking_Protocol/Reference/Reference.html#//apple_ref/occ/instm/NSObject/awakeFromNib" target="_top">awakeFromNib</a></code> <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_899"></a>message when all objects in a nib file have been unarchived; this message gives the class an opportunity to establish connections or perform any other set-up tasks.</p><p>Each Cocoa application has a <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_900"></a>main nib file that contains the application-specific menus and possibly one or more windows. <code>NSApp</code> is File's Owner of the main nib file. When an application launches, <code>NSApp</code> loads the main nib file, unarchiving it, and displays the menus and initial windows. Many applications have auxiliary nib files for such things as documents and panels; these nib files are loaded on demand (that is, when the user requests behavior provided by objects in the nib file). </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH8-SW90" title="Further Reading"></a><p><strong>Further Reading:</strong>&nbsp;You can find out more about nib files (including how to dynamically load them) by reading <em><a href="../../LoadingResources/index.html#//apple_ref/doc/uid/10000051i" target="_top">Resource Programming Guide</a></em>.</p></div><a name="//apple_ref/doc/uid/TP40002974-CH8-SW40" title="Loading Application Resources"></a><h3>Loading Application Resources</h3><p>Nib files are an <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_901"></a>application resource, as are image files, sound files, help files, and other kinds of data. Application resources can be localized—that is, they can be adapted to multiple languages and locales. For nib files, localization primarily means translating the <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_902"></a>strings that appear in a user interface, but other modifications might also be required. Text fields, buttons, and other user-interface objects might have to be resized to accommodate the new strings. The formats of dates and numbers might also have to change.</p><p><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_903"></a>Internationalization denotes the developmental infrastructure that supports localization. When internationalizing a software product, you must put <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_904"></a><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_905"></a>resources for a language or locale in a particular location inside a bundle's <code><a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_906"></a>Resources</code> directory. This location is a folder whose name identifies a language and perhaps a locale, either as a well-known language string or an abbreviation conforming to the<a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_907"></a> ISO 639-1, <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_908"></a>ISO 639-2, and (for locales) <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_909"></a>ISO 3166-1 specifications. The extension of <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_910"></a>localization folders is <code>.lproj</code>. Users compose their list of preferred localizations in the International pane of System Preferences, and an application selects resources from the <code>.lproj</code> folder that corresponds to the first matching localization. Xcode offers support for internationalizing application resources; it creates the bundle structure, including the <code>.lproj</code> folders, and automatically populates them. </p><p>Application resources can also be nonlocalized. <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_911"></a>Nonlocalized resources go just under the application bundle's <code>Resources</code> directory, outside of any <code>.lproj</code> directory.</p><p>At runtime, an application can locate an application resource within a bundle and load it into memory. It uses an instance of the <code><a href="../../../Reference/Foundation/Classes/NSBundle_Class/Reference/Reference.html#//apple_ref/occ/cl/NSBundle" target="_top">NSBundle</a></code> <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_912"></a>class for this purpose. Methods of this class, when given the name and extension of a resource, return the file-system path to that resource. Application Kit categories on <code>NSBundle</code> allow an application to locate and load nib files, help files, and sound and image files. For example, the <code>NSBundle</code> class <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_913"></a>method <code><a href="../../../Reference/ApplicationKit/Classes/NSBundle_AppKitAdditions/Reference/Reference.html#//apple_ref/occ/clm/NSBundle/loadNibNamed:owner:" target="_top">loadNibNamed:owner:</a></code> finds and loads a nib file that has the specified name and is owned by the referenced object. Loading <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_914"></a>resources dynamically this way is a programming practice that contributes to the overall efficiency of the application. An application should load resources into memory only when users request those resources. </p><p>An application can dynamically load more than file-based resources. It can programmatically load <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_915"></a>localized strings in certain contexts (for example, dialogs where the displayed message might vary). The localized string is fetched from a "<a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_916"></a>strings" file (that is a file with an extension of <code>.strings</code>) stored in one of a bundle's <code>.lproj</code> directories. An application's main bundle can also contain subsidiary bundles, called <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_917"></a>loadable bundles. Loadable bundles can contain their own code (and resources), and an application, using <code>NSBundle</code> objects, can dynamically load this <a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_918"></a>code into memory. Loadable bundles make it possible to extend application behavior flexibly through a kind of plug-in architecture. (The Automator application is an example of this architecture; it dynamically loads actions, which are loadable bundles.)<a name="//apple_ref/doc/uid/TP40002974-CH8-DontLinkElementID_919"></a></p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH8-SW91" title="Further Reading"></a><p><strong>Further Reading:</strong>&nbsp;For more information about localization and internationalization, see <em><a href="../../../../MacOSX/Conceptual/BPInternational/index.html#//apple_ref/doc/uid/10000171i" target="_top">Internationalization Programming Topics</a></em>. To learn more about <code>NSBundle</code> and bundles, see <em><a href="../../LoadingResources/index.html#//apple_ref/doc/uid/10000051i" target="_top">Resource Programming Guide</a></em> and <em><a href="../../LoadingCode/index.html#//apple_ref/doc/uid/10000052i" target="_top">Code Loading Programming Topics for Cocoa</a></em>.</p></div>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../CommunicatingWithObjects/CommunicateWithObjects.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../OtherArchitectures/OtherArchitectures.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-11-19<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/CocoaFundamentals/CoreAppArchitecture/CoreAppArchitecture.html%3Fid%3DTP40002974-3.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/CocoaFundamentals/CoreAppArchitecture/CoreAppArchitecture.html%3Fid%3DTP40002974-3.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/CocoaFundamentals/CoreAppArchitecture/CoreAppArchitecture.html%3Fid%3DTP40002974-3.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>