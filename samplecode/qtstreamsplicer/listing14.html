<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>qtstreamsplicer - /QTStreamSplicer.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/QuickTime/index.html">QuickTime</a> &gt; <a href="../../samplecode/QuickTime/idxStreaming-date.html">Streaming</a> &gt; <A HREF="javascript:location.replace('index.html');">qtstreamsplicer</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">qtstreamsplicer</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/QTStreamSplicer.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Application Files/ComApplication.c</option>
<option value="listing2.html">/Application Files/ComApplication.h</option>
<option value="listing3.html">/Application Files/ComResource.h</option>
<option value="listing4.html">/Common Files/ComFramework.c</option>
<option value="listing5.html">/Common Files/ComFramework.h</option>
<option value="listing6.html">/Common Files/MacFramework.c</option>
<option value="listing7.html">/Common Files/MacFramework.h</option>
<option value="listing8.html">/Common Files/MacPrefix.h</option>
<option value="listing9.html">/Common Files/QTUtilities.c</option>
<option value="listing10.html">/Common Files/QTUtilities.h</option>
<option value="listing11.html">/Common Files/WinFramework.c</option>
<option value="listing12.html">/Common Files/WinFramework.h</option>
<option value="listing13.html">/Common Files/WinPrefix.h</option>
<option value="listing14.html">/QTStreamSplicer.c</option>
<option value="listing15.html">/QTStreamSplicer.h</option></select>
				</p>
				</form>
				<p><strong><a href="qtstreamsplicer.zip">Download Sample</a></strong> (&#147;qtstreamsplicer.zip&#148;, 138.1K)<BR>
<strong><a href="qtstreamsplicer.dmg">Download Sample</a></strong> (&#147;qtstreamsplicer.dmg&#148;, 211.6K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">//////////////  File:    QTStreamSplicer.c////  Contains:  Code to splice a still frame onto a streamed movie.////  Written by:  Dan Crow//  Revised by: Tim Monroe////  Copyright:  &copy; 1999 by Apple Computer, Inc., all rights reserved.////  Change History (most recent first):////     &lt;6&gt;     07/18/00  rtm    fixed bug in QTSplicer_SpliceImageOverStream//     &lt;5&gt;     03/20/00  rtm    made changes to get things running under CarbonLib//     &lt;4&gt;     06/02/99  rtm    further work on QTSplicer_SpliceImageOverStream//     &lt;3&gt;     05/28/99  rtm    added QTSplicer_SpliceImageOverStream, for sound-only streams//     &lt;2&gt;     05/19/99  rtm    minor tweaking for Windows version; added some comments; added ability//                  to save spliced file as self-contained//     &lt;1&gt;     05/18/99  rtm    first file from Dan Crow; modified to better cohere with QT SDK//                  standards (did some renaming of variables and functions, but otherwise//                  this is pretty much Dan's code)////  This file defines two principal functions, QTSplicer_SpliceImageOntoStream and QTSplicer_SpliceImageOverStream.//  QTSplicer_SpliceImageOntoStream prompts the user for a picture and a streamed movie, which is assumed to have//  a video track. QTSplicer_SpliceImageOntoStream is designed to splice the selected picture onto the beginning of//  the streamed movie, so that that picture appears in place of the standard QuickTime pre-preroll sequence, for a//  user-specified duration.////  QTSplicer_SpliceImageOverStream has a slightly different purpose. It prompts the user for a picture and a streamed//  movie, which is assumed to have no video track. QTSplicer_SpliceImageOverStream is designed to splice the picture//  over the streamed track for the entire duration of the streamed movie. You might want to do this to add a graphic//  to a streamed radio broadcast or to a streamed music selection.////////////#include &quot;QTStreamSplicer.h&quot;////////////// QTSplicer_SpliceImageOntoStream//// Prompt the user for an image file and a streamed movie; then splice the image// onto the front of the stream, for a specific duration; save the new spliced movie.//// This function contains the user interface for getting the input image and movie,// the output spliced movie location, and the desired splicing settings. The function// QTSplicer_CreateSplicedOntoMovie does all the nitty-gritty movie creation stuff.////////////OSErr QTSplicer_SpliceImageOntoStream (void){  FSSpec          myImageSpec;  FSSpec          myStreamSpec;  FSSpec          myMovieSpec;  Movie          myMovie = NULL;  Boolean          isScaleImage = false;  Boolean          isSelfContained = false;  Boolean          gotImage = false;  Boolean          gotStream = false;  short          myResID = movieInDataForkResID;  short          myRefNum = 0;  DialogPtr        myDialog = NULL;  DialogItemIndex      myItem = 0;  DialogItemType      myItemType;  Handle          myItemHandle = NULL;  Rect          myItemRect;  long          myImageDuration;  Str255          myDurationString;  FSSpec          myFSSpec;  OSType           myTypeList[] = {kQTFileTypeMovie};  short          myNumTypes = 1;  QTFrameFileFilterUPP  myFileFilterUPP = NULL;  OSErr          myErr = noErr;#if TARGET_OS_MAC  myNumTypes = 0;#endif  myFileFilterUPP = QTFrame_GetFileFilterUPP((ProcPtr)QTFrame_FilterFiles);    // prompt the user for the image file to splice onto the stream  do {    myErr = QTFrame_GetOneFileWithPreview(myNumTypes, (QTFrameTypeListPtr)myTypeList, &amp;myFSSpec, myFileFilterUPP);    if (myErr == noErr) {      if (QTUtils_IsImageFile(&amp;myFSSpec)) {        myImageSpec = myFSSpec;        gotImage = true;      }    } else {      break;    // if the user cancelled    }            } while (!gotImage);    // prompt the user for the live stream file to splice onto the end of the created movie  do {    myErr = QTFrame_GetOneFileWithPreview(myNumTypes, (QTFrameTypeListPtr)myTypeList, &amp;myFSSpec, myFileFilterUPP);    if (myErr == noErr) {      if (QTSplicer_FileContainsStream(myFSSpec)) {        myStreamSpec = myFSSpec;        gotStream = true;      }    } else {      break;    // if the user cancelled    }  } while (!gotStream);    if (myFileFilterUPP != NULL)    DisposeNavObjectFilterUPP(myFileFilterUPP);  // make sure we have both an image and a stream  if (!gotStream || !gotImage)    goto bail;  // get the desired splicing settings; open up the Splicer dialog box  myDialog = GetNewDialog(kSpliceOntoDialogID, NULL, (WindowPtr)-1L);  if (myDialog == NULL)    goto bail;      SetDialogDefaultItem(myDialog, kSpliceButtonDone);  MacShowWindow(GetDialogWindow(myDialog));      do {    ModalDialog(NULL, &amp;myItem);    if ((myItem == kSpliceScaleCheckbox) || (myItem == kSelfContainedCheckbox)) {      Boolean      myValue;            GetDialogItem(myDialog, myItem, &amp;myItemType, &amp;myItemHandle, &amp;myItemRect);      myValue = (Boolean)GetControlValue((ControlHandle)myItemHandle);      SetControlValue((ControlHandle)myItemHandle, !myValue);    }  } while (myItem != kSpliceButtonDone);    // set the isScaleImage variable depending on the state of the kSpliceScaleCheckbox item  GetDialogItem(myDialog, kSpliceScaleCheckbox, &amp;myItemType, &amp;myItemHandle, &amp;myItemRect);  isScaleImage = (Boolean)GetControlValue((ControlHandle)myItemHandle);    // set the isSelfContained variable depending on the state of the kSelfContainedCheckbox item  GetDialogItem(myDialog, kSelfContainedCheckbox, &amp;myItemType, &amp;myItemHandle, &amp;myItemRect);  isSelfContained = (Boolean)GetControlValue((ControlHandle)myItemHandle);    // get the desired image duration from the kSpliceDuration item  GetDialogItem(myDialog, kSpliceDuration, &amp;myItemType, &amp;myItemHandle, &amp;myItemRect);  GetDialogItemText(myItemHandle, myDurationString);  StringToNum(myDurationString, &amp;myImageDuration);    DisposeDialog(myDialog);  // prompt the user for the location of the output spliced movie  {    FSSpec        myFile;    Boolean        myIsSelected = false;    Boolean        myIsReplacing = false;      StringPtr       myMoviePrompt = QTUtils_ConvertCToPascalString(kSaveSplicePrompt);    StringPtr       myMovieFileName = QTUtils_ConvertCToPascalString(kSaveSpliceFileName);    QTFrame_PutFile(myMoviePrompt, myMovieFileName, &amp;myFile, &amp;myIsSelected, &amp;myIsReplacing);    if (!myIsSelected)      goto bail;        // deal with user cancelling    if (myIsReplacing)      DeleteMovieFile(&amp;myFile);    myMovieSpec = myFile;    free(myMoviePrompt);    free(myMovieFileName);    // create a movie file for the destination (&quot;spliced&quot;) movie    myErr = CreateMovieFile(&amp;myMovieSpec, FOUR_CHAR_CODE('TVOD'), smCurrentScript, createMovieFileDeleteCurFile | createMovieFileDontCreateResFile, &amp;myRefNum, &amp;myMovie);    if (myErr != noErr)      goto bail;  }    // now create a movie that contains the image file and the stream spliced together  myErr = QTSplicer_CreateSplicedOntoMovie(myImageSpec, myStreamSpec, myMovie, isScaleImage, isSelfContained, myImageDuration * kOneSecond);  if (myErr != noErr)    goto bail;      // put the movie resource into the file  myErr = AddMovieResource(myMovie, myRefNum, &amp;myResID, NULL);    bail:  if (myRefNum != 0)    CloseMovieFile(myRefNum);    if (myMovie != NULL)    DisposeMovie(myMovie);    return(myErr);}////////////// QTSplicer_SpliceImageOverStream//// Prompt the user for an image file and a streamed movie, which is a sound-only stream;// then splice the image over the stream, for the duration of the stream; save the new spliced movie.//// This function contains the user interface for getting the input image and movie,// the output spliced movie location, and the desired splicing settings. The function// QTSplicer_CreateSplicedOverMovie does all the nitty-gritty movie creation stuff.////////////OSErr QTSplicer_SpliceImageOverStream (void){  FSSpec          myImageSpec;  FSSpec          myStreamSpec;  FSSpec          myMovieSpec;  Movie          myMovie = NULL;  Boolean          isScaleImage = false;  Boolean          isSelfContained = false;  Boolean          gotImage = false;  Boolean          gotStream = false;  short          myResID = movieInDataForkResID;  short          myRefNum = 0;  DialogPtr        myDialog = NULL;  DialogItemIndex      myItem = 0;  DialogItemType      myItemType;  Handle          myItemHandle = NULL;  Rect          myItemRect;  long          myImageHeight;  long          myImageWidth;  Str255          myHeightString;  Str255          myWidthString;  FSSpec          myFSSpec;  OSType           myTypeList[] = {kQTFileTypeMovie};  short          myNumTypes = 1;  QTFrameFileFilterUPP  myFileFilterUPP = NULL;  OSErr          myErr = noErr;#if TARGET_OS_MAC  myNumTypes = 0;#endif  myFileFilterUPP = QTFrame_GetFileFilterUPP((ProcPtr)QTFrame_FilterFiles);    // prompt the user for the image file to splice onto the stream  do {    myErr = QTFrame_GetOneFileWithPreview(myNumTypes, (QTFrameTypeListPtr)myTypeList, &amp;myFSSpec, myFileFilterUPP);    if (myErr == noErr) {      if (QTUtils_IsImageFile(&amp;myFSSpec)) {        myImageSpec = myFSSpec;        gotImage = true;      }    } else {      break;    // if the user cancelled    }            } while (!gotImage);    // prompt the user for the live stream file to splice under the image file  do {    myErr = QTFrame_GetOneFileWithPreview(myNumTypes, (QTFrameTypeListPtr)myTypeList, &amp;myFSSpec, myFileFilterUPP);    if (myErr == noErr) {      if (QTSplicer_FileContainsStream(myFSSpec)) {        myStreamSpec = myFSSpec;        gotStream = true;      }    } else {      break;    // if the user cancelled    }            } while (!gotStream);      // make sure we have both an image and a stream  if (!gotStream || !gotImage)    goto bail;  // get the desired splicing settings; open up the Splicer dialog box  myDialog = GetNewDialog(kSpliceOverDialogID, NULL, (WindowPtr)-1L);  if (myDialog == NULL)    goto bail;      SetDialogDefaultItem(myDialog, kSpliceButtonDone);  MacShowWindow(GetDialogWindow(myDialog));      do {    ModalDialog(NULL, &amp;myItem);    if ((myItem == kSpliceScaleCheckbox) || (myItem == kSelfContainedCheckbox)) {      Boolean      myValue;            GetDialogItem(myDialog, myItem, &amp;myItemType, &amp;myItemHandle, &amp;myItemRect);      myValue = (Boolean)GetControlValue((ControlHandle)myItemHandle);      SetControlValue((ControlHandle)myItemHandle, !myValue);    }  } while (myItem != kSpliceButtonDone);    // set the isScaleImage variable depending on the state of the kSpliceScaleCheckbox item  GetDialogItem(myDialog, kSpliceScaleCheckbox, &amp;myItemType, &amp;myItemHandle, &amp;myItemRect);  isScaleImage = (Boolean)GetControlValue((ControlHandle)myItemHandle);    // set the isSelfContained variable depending on the state of the kSelfContainedCheckbox item  GetDialogItem(myDialog, kSelfContainedCheckbox, &amp;myItemType, &amp;myItemHandle, &amp;myItemRect);  isSelfContained = (Boolean)GetControlValue((ControlHandle)myItemHandle);    if (isScaleImage) {    // get the desired image width from the kSpliceWidth item    GetDialogItem(myDialog, kSpliceWidth, &amp;myItemType, &amp;myItemHandle, &amp;myItemRect);    GetDialogItemText(myItemHandle, myWidthString);    StringToNum(myWidthString, &amp;myImageWidth);        // get the desired image height from the kSpliceHeight item    GetDialogItem(myDialog, kSpliceHeight, &amp;myItemType, &amp;myItemHandle, &amp;myItemRect);    GetDialogItemText(myItemHandle, myHeightString);    StringToNum(myHeightString, &amp;myImageHeight);  }    DisposeDialog(myDialog);  // prompt the user for the location of the output spliced movie  {    FSSpec        myFile;    Boolean        myIsSelected = false;    Boolean        myIsReplacing = false;      StringPtr       myMoviePrompt = QTUtils_ConvertCToPascalString(kSaveSplicePrompt);    StringPtr       myMovieFileName = QTUtils_ConvertCToPascalString(kSaveSpliceFileName);    QTFrame_PutFile(myMoviePrompt, myMovieFileName, &amp;myFile, &amp;myIsSelected, &amp;myIsReplacing);    if (!myIsSelected)      goto bail;        // deal with user cancelling    if (myIsReplacing)      DeleteMovieFile(&amp;myFile);    myMovieSpec = myFile;    free(myMoviePrompt);    free(myMovieFileName);    // create a movie file for the destination (&quot;spliced&quot;) movie    myErr = CreateMovieFile(&amp;myMovieSpec, FOUR_CHAR_CODE('TVOD'), smCurrentScript, createMovieFileDeleteCurFile | createMovieFileDontCreateResFile, &amp;myRefNum, &amp;myMovie);    if (myErr != noErr)      goto bail;  }    // now create a movie that contains the image file and the stream spliced together  myErr = QTSplicer_CreateSplicedOverMovie(myImageSpec, myStreamSpec, myMovie, isScaleImage, isSelfContained, myImageHeight, myImageWidth);  if (myErr != noErr)    goto bail;      // put the movie resource into the file  myErr = AddMovieResource(myMovie, myRefNum, &amp;myResID, NULL);    bail:  if (myRefNum != 0)    CloseMovieFile(myRefNum);    if (myMovie != NULL)    DisposeMovie(myMovie);    return(myErr);}////////////// QTSplicer_CreateSplicedOntoMovie//// Create a movie file that contains the specified movie, with the specified image// spliced onto the front for the specified duration.////////////OSErr QTSplicer_CreateSplicedOntoMovie (FSSpec theImageSpec, FSSpec theMovieSpec, Movie theSplicedMovie, Boolean isScaleImage, Boolean isSelfContained, long theImageDuration){  short            myRefNum = kInvalidFileRefNum;  short            myResID = 0;  Movie            myMovie = NULL;  MovieController        mySplicedController = NULL;  Rect            myStreamBox, myImageRect;  GraphicsImportComponent    myImporter = NULL;  GWorldPtr          myImageGWorld = NULL;  ComponentResult        myErr = noErr;          // open the streamed movie file  myErr = OpenMovieFile(&amp;theMovieSpec, &amp;myRefNum, fsRdPerm);  if (myErr != noErr)    goto bail;  myErr = NewMovieFromFile(&amp;myMovie, myRefNum, &amp;myResID, NULL, newMovieActive, NULL);  if (myErr != noErr)    goto bail;    // find out the size of the streamed movie  GetMovieBox(myMovie, &amp;myStreamBox);    // get a graphics importer for the image file  myErr = GetGraphicsImporterForFile(&amp;theImageSpec, &amp;myImporter);  if (myErr != noErr)    goto bail;          // get the size of the image  if (isScaleImage) {    myImageRect = myStreamBox;    MacOffsetRect(&amp;myImageRect, -myStreamBox.left, -myStreamBox.top);  } else {    GraphicsImportGetBoundsRect(myImporter, &amp;myImageRect);  }  // allocate a new GWorld to draw the image into  myErr = QTNewGWorld(&amp;myImageGWorld, 32, &amp;myImageRect, NULL, NULL, kICMTempThenAppMemory);  if (myErr != noErr) {    if (myImporter != NULL)      CloseComponent(myImporter);    goto bail;  }    // draw the picture into the GWorld  GraphicsImportSetGWorld(myImporter, myImageGWorld, NULL);  GraphicsImportSetBoundsRect(myImporter, &amp;myImageRect);  GraphicsImportDraw(myImporter);    // close the graphics importer component  if (myImporter != NULL)    CloseComponent(myImporter);    // create a controller for the spliced movie  mySplicedController = NewMovieController(theSplicedMovie, &amp;myStreamBox, 0);    // make sure we can edit this movie  MCEnableEditing(mySplicedController, true);      // paste the still image into the spliced movie as a new video track  myErr = QTSplicer_AddVideoTrackFromGWorld(&amp;theSplicedMovie, myImageGWorld, myImageRect.right - myImageRect.left, myImageRect.bottom - myImageRect.top, theImageDuration);  if (myErr != noErr)    goto bail;  // go to the end of the spliced movie; this jumps past the first track,  // which we have just pasted into the spliced movie.  QTSplicer_SetCurrentTime(mySplicedController, GetMovieDuration(theSplicedMovie));  if (isSelfContained) {    Track      mySrcTrack = NULL;    Track      myDstTrack = NULL;    Media      myDstMedia = NULL;    Fixed      myWidth, myHeight;        mySrcTrack = GetMovieIndTrackType(myMovie, 1, kQTSStreamMediaType, movieTrackMediaType);    if (mySrcTrack == NULL)      goto bail;        GetTrackDimensions(mySrcTrack, &amp;myWidth, &amp;myHeight);        myDstTrack = NewMovieTrack(theSplicedMovie, myWidth, myHeight, kNoVolume);    if (myDstTrack == NULL)      goto bail;        myDstMedia = NewTrackMedia(myDstTrack, kQTSStreamMediaType, GetMovieTimeScale(theSplicedMovie), NULL, 0);    if (myDstTrack == NULL)      goto bail;        myErr = BeginMediaEdits(myDstMedia);    if (myErr != noErr)      goto bail;        myErr = CopyTrackSettings(mySrcTrack, myDstTrack);    if (myErr != noErr)      goto bail;        myErr = InsertTrackSegment(mySrcTrack, myDstTrack, 0, (0x7FFFFFFF - GetMovieDuration(theSplicedMovie)), GetMovieDuration(theSplicedMovie));    if (myErr != noErr)      goto bail;        myErr = EndMediaEdits(myDstMedia);    if (myErr != noErr)      goto bail;  } else {    // insert the streamed movie after the image track    myErr = InsertMovieSegment(myMovie, theSplicedMovie, 0, (0x7FFFFFFF - GetMovieDuration(theSplicedMovie)), GetMovieDuration(theSplicedMovie));    if (myErr != noErr)      goto bail;  }    // select none on the resulting movie  QTSplicer_SetSelectionTimes(mySplicedController, 0, 0);    // go to the start of the spliced movie  QTSplicer_SetCurrentTime(mySplicedController, 0);  bail:  if (myRefNum != 0)    CloseMovieFile(myRefNum);  if (myImageGWorld != NULL) {    DisposeGWorld(myImageGWorld);    myImageGWorld = NULL;  }    if (mySplicedController != NULL) {    DisposeMovieController(mySplicedController);  }    return(myErr);}////////////// QTSplicer_CreateSplicedOverMovie//// Create a movie file that contains the specified movie, with the specified image as the video track.////////////OSErr QTSplicer_CreateSplicedOverMovie (FSSpec theImageSpec, FSSpec theMovieSpec, Movie theSplicedMovie, Boolean isScaleImage, Boolean isSelfContained, long theImageHeight, long theImageWidth){  short            myRefNum = kInvalidFileRefNum;  short            myResID = 0;  Movie            myMovie = NULL;  MovieController        mySplicedController = NULL;  Rect            myImageRect;  GraphicsImportComponent    myImporter = NULL;  GWorldPtr          myImageGWorld = NULL;  Track            mySrcTrack = NULL;  Track            myDstTrack = NULL;  Media            myDstMedia = NULL;  Fixed            myWidth, myHeight;  ComponentResult        myErr = noErr;          // open the streamed movie file  myErr = OpenMovieFile(&amp;theMovieSpec, &amp;myRefNum, fsRdPerm);  if (myErr != noErr)    goto bail;  myErr = NewMovieFromFile(&amp;myMovie, myRefNum, &amp;myResID, NULL, newMovieActive, NULL);  if (myErr != noErr)    goto bail;    // get a graphics importer for the image file  myErr = GetGraphicsImporterForFile(&amp;theImageSpec, &amp;myImporter);  if (myErr != noErr)    goto bail;          // get the size of the image  if (isScaleImage) {    myImageRect.top = 0;    myImageRect.left = 0;    myImageRect.bottom = (short)theImageHeight;    myImageRect.right = (short)theImageWidth;  } else {    GraphicsImportGetBoundsRect(myImporter, &amp;myImageRect);  }  // allocate a new GWorld to draw the image into  myErr = QTNewGWorld(&amp;myImageGWorld, 32, &amp;myImageRect, NULL, NULL, kICMTempThenAppMemory);  if (myErr != noErr) {    if (myImporter != NULL)      CloseComponent(myImporter);    goto bail;  }    // draw the picture into the GWorld  GraphicsImportSetGWorld(myImporter, myImageGWorld, NULL);  GraphicsImportSetBoundsRect(myImporter, &amp;myImageRect);  GraphicsImportDraw(myImporter);    // close the graphics importer component  if (myImporter != NULL)    CloseComponent(myImporter);    // create a controller for the spliced movie  mySplicedController = NewMovieController(theSplicedMovie, &amp;myImageRect, 0);    // make sure we can edit this movie  MCEnableEditing(mySplicedController, true);      // paste the still image into the spliced movie as a new video track  myErr = QTSplicer_AddVideoTrackFromGWorld(&amp;theSplicedMovie, myImageGWorld, myImageRect.right - myImageRect.left, myImageRect.bottom - myImageRect.top, GetMovieDuration(myMovie));  if (myErr != noErr)    goto bail;        //////////  //  // copy over the streamed track  //  //////////    mySrcTrack = GetMovieIndTrackType(myMovie, 1, kQTSStreamMediaType, movieTrackMediaType);  if (mySrcTrack == NULL)    goto bail;    GetTrackDimensions(mySrcTrack, &amp;myWidth, &amp;myHeight);    myDstTrack = NewMovieTrack(theSplicedMovie, myWidth, myHeight, kNoVolume);  if (myDstTrack == NULL)    goto bail;    myDstMedia = NewTrackMedia(myDstTrack, kQTSStreamMediaType, GetMovieTimeScale(theSplicedMovie), NULL, 0);  if (myDstTrack == NULL)    goto bail;    if (isSelfContained)    BeginMediaEdits(myDstMedia);    myErr = CopyTrackSettings(mySrcTrack, myDstTrack);  if (myErr != noErr)    goto bail;    myErr = InsertTrackSegment(mySrcTrack, myDstTrack, 0, GetMovieDuration(myMovie), 0);  if (myErr != noErr)    goto bail;    if (isSelfContained)    EndMediaEdits(myDstMedia);    // select none on the resulting movie  QTSplicer_SetSelectionTimes(mySplicedController, 0, 0);    // go to the start of the spliced movie  QTSplicer_SetCurrentTime(mySplicedController, 0);  bail:  if (myRefNum != 0)    CloseMovieFile(myRefNum);  if (myImageGWorld != NULL) {    DisposeGWorld(myImageGWorld);    myImageGWorld = NULL;  }    if (mySplicedController != NULL) {    DisposeMovieController(mySplicedController);  }    return(myErr);}////////////// QTSplicer_FileContainsStream//// Determine whether the specified movie file contains a streaming track.//// Returns true iff the file is a movie file that has at least one streaming// track in it, false otherwise.////////////Boolean QTSplicer_FileContainsStream (FSSpec theMovieFile){  short    myRefNum = 0;  short    myResID = 0;  Movie    myMovie = NULL;  Boolean    myResult = false;  OSErr    myErr = noErr;  myErr = OpenMovieFile(&amp;theMovieFile, &amp;myRefNum, fsRdPerm);  if (myErr != noErr)    goto bail;      myErr = NewMovieFromFile(&amp;myMovie, myRefNum, &amp;myResID, NULL, newMovieActive, NULL);  if (myErr != noErr)    goto bail;    if (GetMovieIndTrackType(myMovie, 1, kQTSStreamMediaType, movieTrackMediaType) != NULL)    myResult = true;  bail:  if (myRefNum != 0)    CloseMovieFile(myRefNum);  return(myResult);}////////////// QTSplicer_SetSelectionTimes//// Set the movie selection to the specified times.////////////OSErr QTSplicer_SetSelectionTimes (MovieController theController, TimeValue theTime1, TimeValue theTime2){  TimeRecord       myTimeRecord;  Movie        myMovie = MCGetMovie(theController);  ComponentResult    myErr = noErr;    myTimeRecord.value.hi = 0;  myTimeRecord.value.lo = theTime1;  myTimeRecord.base = 0;  myTimeRecord.scale = GetMovieTimeScale(myMovie);  myErr = MCDoAction(theController, mcActionSetSelectionBegin, &amp;myTimeRecord);  if (myErr != noErr)    goto done;    myTimeRecord.value.lo = theTime2 - theTime1;  myErr = MCDoAction(theController, mcActionSetSelectionDuration, &amp;myTimeRecord);  done:  return((OSErr)myErr);}////////////// QTSplicer_SetCurrentTime//// Set the movie current time to the specified time.////////////OSErr QTSplicer_SetCurrentTime (MovieController theController, TimeValue theTime){  TimeRecord       myTimeRecord;  Movie        myMovie = MCGetMovie(theController);  ComponentResult    myErr = noErr;    myTimeRecord.value.hi = 0;  myTimeRecord.value.lo = theTime;  myTimeRecord.base = GetMovieTimeBase(myMovie);  myTimeRecord.scale = GetMovieTimeScale(myMovie);  myErr = MCDoAction(theController, mcActionGoToTime, &amp;myTimeRecord);  return((OSErr)myErr);}////////////// QTSplicer_AddVideoTrackFromGWorld//// Add to the specified movie a video track, using the image in the specified GWorld.////////////OSErr QTSplicer_AddVideoTrackFromGWorld (Movie *theMovie, GWorldPtr theGW, short theWidth, short theHeight, long theImageDuration){  Track            myTrack = NULL;  Media            myMedia = NULL;  ImageDescriptionHandle    myDesc = NULL;  Rect            myRect;  long            mySize;  Handle            myData = NULL;  Ptr              myDataPtr = NULL;  PixMapHandle        myDstPixMap = NULL;  OSErr            myErr = noErr;    // create a video track in the movie  myTrack = NewMovieTrack(*theMovie, FixRatio(theWidth, 1), FixRatio(theHeight, 1), kNoVolume);  myMedia = NewTrackMedia(myTrack, VideoMediaType, kOneSecond, NULL, 0);    myRect.top = 0;  myRect.left = 0;  myRect.right = theWidth;  myRect.bottom = theHeight;    // begin editing the new track  BeginMediaEdits(myMedia);  // create a new image description; CompressImage will fill in the fields of this structure  myDesc = (ImageDescriptionHandle)NewHandle(4);    myDstPixMap = GetGWorldPixMap(theGW);  LockPixels(myDstPixMap);    myErr = GetMaxCompressionSize(myDstPixMap, &amp;myRect, 0, codecNormalQuality, kAnimationCodecType, anyCodec, &amp;mySize);  if (myErr != noErr)    goto bail;      myData = NewHandle(mySize);  if (myData == NULL)    goto bail;      HLockHi(myData);#if TARGET_CPU_68K  myDataPtr = StripAddress(*myData);#else  myDataPtr = *myData;#endif    myErr = CompressImage(myDstPixMap, &amp;myRect, codecNormalQuality, kAnimationCodecType, myDesc, myDataPtr);  if (myErr != noErr)    goto bail;      myErr = AddMediaSample(myMedia, myData, 0, (**myDesc).dataSize, theImageDuration, (SampleDescriptionHandle)myDesc, 1, 0, NULL);  if (myErr != noErr)    goto bail;  myErr = EndMediaEdits(myMedia);  if (myErr != noErr)    goto bail;  myErr = InsertMediaIntoTrack(myTrack, 0, 0, GetMediaDuration(myMedia), fixed1);  bail:  if (myData != NULL) {    HUnlock(myData);    DisposeHandle(myData);  }  if (myDesc != NULL)    DisposeHandle((Handle)myDesc);      if (myDstPixMap != NULL)    UnlockPixels(myDstPixMap);    return(myErr);}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/qtstreamsplicer/listing14.html%3Fid%3DDTS10001055-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/qtstreamsplicer/listing14.html%3Fid%3DDTS10001055-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/qtstreamsplicer/listing14.html%3Fid%3DDTS10001055-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>