<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>GLUT - /macx_gamemode.m</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/GraphicsImaging/index.html">Graphics & Imaging</a> &gt; <a href="../../samplecode/GraphicsImaging/idxOpenGL-date.html">OpenGL</a> &gt; <A HREF="javascript:location.replace('index.html');">GLUT</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->


	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">GLUT</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/macx_gamemode.m</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/gle/copy.h</option>
<option value="listing2.html">/gle/ex_angle.c</option>
<option value="listing3.html">/gle/ex_cut_round.c</option>
<option value="listing4.html">/gle/ex_raw.c</option>
<option value="listing5.html">/gle/extrude.c</option>
<option value="listing6.html">/gle/extrude.h</option>
<option value="listing7.html">/gle/gle_osx.h</option>
<option value="listing8.html">/gle/gutil.h</option>
<option value="listing9.html">/gle/intersect.c</option>
<option value="listing10.html">/gle/intersect.h</option>
<option value="listing11.html">/gle/port.h</option>
<option value="listing12.html">/gle/rot.h</option>
<option value="listing13.html">/gle/rot_prince.c</option>
<option value="listing14.html">/gle/rotate.c</option>
<option value="listing15.html">/gle/round_cap.c</option>
<option value="listing16.html">/gle/segment.c</option>
<option value="listing17.html">/gle/segment.h</option>
<option value="listing18.html">/gle/texgen.c</option>
<option value="listing19.html">/gle/tube.h</option>
<option value="listing20.html">/gle/tube_gc.h</option>
<option value="listing21.html">/gle/urotate.c</option>
<option value="listing22.html">/gle/view.c</option>
<option value="listing23.html">/gle/vvector.h</option>
<option value="listing24.html">/glsmap/glsmap.h</option>
<option value="listing25.html">/glsmap/glsmapint.h</option>
<option value="listing26.html">/glsmap/smap_buildsmap.c</option>
<option value="listing27.html">/glsmap/smap_context.c</option>
<option value="listing28.html">/glsmap/smap_create.c</option>
<option value="listing29.html">/glsmap/smap_destroy.c</option>
<option value="listing30.html">/glsmap/smap_drawmesh.c</option>
<option value="listing31.html">/glsmap/smap_flag.c</option>
<option value="listing32.html">/glsmap/smap_get.c</option>
<option value="listing33.html">/glsmap/smap_getfunc.c</option>
<option value="listing34.html">/glsmap/smap_gettexdim.c</option>
<option value="listing35.html">/glsmap/smap_gettexobj.c</option>
<option value="listing36.html">/glsmap/smap_getvec.c</option>
<option value="listing37.html">/glsmap/smap_makemesh.c</option>
<option value="listing38.html">/glsmap/smap_nearfar.c</option>
<option value="listing39.html">/glsmap/smap_origin.c</option>
<option value="listing40.html">/glsmap/smap_render.c</option>
<option value="listing41.html">/glsmap/smap_rvec2st.c</option>
<option value="listing42.html">/glsmap/smap_set.c</option>
<option value="listing43.html">/glsmap/smap_setfunc.c</option>
<option value="listing44.html">/glsmap/smap_setvec.c</option>
<option value="listing45.html">/glsmap/smap_texdim.c</option>
<option value="listing46.html">/glsmap/smap_texobj.c</option>
<option value="listing47.html">/glut.h</option>
<option value="listing48.html">/glut_8x13.c</option>
<option value="listing49.html">/glut_9x15.c</option>
<option value="listing50.html">/glut_bitmap.c</option>
<option value="listing51.html">/glut_bwidth.c</option>
<option value="listing52.html">/glut_cindex.c</option>
<option value="listing53.html">/glut_ext.c</option>
<option value="listing54.html">/glut_hel10.c</option>
<option value="listing55.html">/glut_hel12.c</option>
<option value="listing56.html">/glut_hel18.c</option>
<option value="listing57.html">/glut_mroman.c</option>
<option value="listing58.html">/glut_roman.c</option>
<option value="listing59.html">/glut_shapes.c</option>
<option value="listing60.html">/glut_stroke.c</option>
<option value="listing61.html">/glut_swidth.c</option>
<option value="listing62.html">/glut_teapot.c</option>
<option value="listing63.html">/glut_tr10.c</option>
<option value="listing64.html">/glut_tr24.c</option>
<option value="listing65.html">/glut_vidresize.c</option>
<option value="listing66.html">/GLUTApplication.h</option>
<option value="listing67.html">/GLUTApplication.m</option>
<option value="listing68.html">/glutbitmap.h</option>
<option value="listing69.html">/GLUTClipboardController.h</option>
<option value="listing70.html">/GLUTClipboardController.m</option>
<option value="listing71.html">/glutf90.h</option>
<option value="listing72.html">/GLUTMenu.h</option>
<option value="listing73.html">/GLUTMenu.m</option>
<option value="listing74.html">/GLUTMenuItem.h</option>
<option value="listing75.html">/GLUTMenuItem.m</option>
<option value="listing76.html">/GLUTPreferencesController.h</option>
<option value="listing77.html">/GLUTPreferencesController.m</option>
<option value="listing78.html">/glutstroke.h</option>
<option value="listing79.html">/GLUTView.h</option>
<option value="listing80.html">/GLUTView.m</option>
<option value="listing81.html">/GLUTWindow.h</option>
<option value="listing82.html">/GLUTWindow.m</option>
<option value="listing83.html">/HID_Config_Utilities.c</option>
<option value="listing84.html">/HID_Config_Utilities.h</option>
<option value="listing85.html">/HID_Error_Handler.c</option>
<option value="listing86.html">/HID_Error_Handler.h</option>
<option value="listing87.html">/HID_Name_Lookup.c</option>
<option value="listing88.html">/HID_Name_Lookup.h</option>
<option value="listing89.html">/HID_Queue_Utilities.c</option>
<option value="listing90.html">/HID_Queue_Utilities.h</option>
<option value="listing91.html">/HID_Utilities.c</option>
<option value="listing92.html">/HID_Utilities.h</option>
<option value="listing93.html">/HID_Utilities_External.h</option>
<option value="listing94.html">/HID_Utilities_Internal.h</option>
<option value="listing95.html">/libForeground.a</option>
<option value="listing96.html">/macx_cursor.m</option>
<option value="listing97.html">/macx_dials.m</option>
<option value="listing98.html">/macx_dstr.m</option>
<option value="listing99.html">/macx_event.m</option>
<option value="listing100.html">/macx_fortran.m</option>
<option value="listing101.html">/macx_gamemode.m</option>
<option value="listing102.html">/macx_get.m</option>
<option value="listing103.html">/macx_glut.h</option>
<option value="listing104.html">/macx_init.m</option>
<option value="listing105.html">/macx_input.m</option>
<option value="listing106.html">/macx_joy.m</option>
<option value="listing107.html">/macx_key.m</option>
<option value="listing108.html">/macx_menu.m</option>
<option value="listing109.html">/macx_modifier.m</option>
<option value="listing110.html">/macx_overlay.m</option>
<option value="listing111.html">/macx_space.m</option>
<option value="listing112.html">/macx_swap.m</option>
<option value="listing113.html">/macx_tablet.m</option>
<option value="listing114.html">/macx_util.m</option>
<option value="listing115.html">/macx_utilities.h</option>
<option value="listing116.html">/macx_warp.m</option>
<option value="listing117.html">/macx_win.m</option>
<option value="listing118.html">/ReadMe.txt</option></select>
				</p>
				</form>
				<p><strong><a href="glut.zip">Download Sample</a></strong> (&#147;glut.zip&#148;, 374.3K)<BR>
<strong><a href="glut.dmg">Download Sample</a></strong> (&#147;glut.dmg&#148;, 680.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">
/* Copyright (c) Mark J. Kilgard, 1994. */
/* Copyright (c) Dietmar Planitzer, 1998, 2002 */

/* This program is freely distributable without licensing fees 
   and is provided without guarantee or warrantee expressed or 
   implied. This program is -not- in the public domain. */

#import &quot;macx_glut.h&quot;
#import &quot;GLUTView.h&quot;

BOOL                        __glutCaptureAllDisplays = kCaptureAllDisplays;

/* The following code is based on similiar code in glut_gamemode.c */
GLUTView *                    __glutGameModeWindow = nil;
BOOL                        __glutDestoryingGameMode = false;
CGDisplayFadeInterval        __glutGameModeFadeInterval = GLUT_DEFAULT_FADE_INTERVAL;
static int                    __glutDisplaySettingsChanged = 0;
static DisplayMode *        dmodes, *currentDm = NULL;
static int                    ndmodes = -1;
static CFDictionaryRef        gOriginalMode = NULL;
static BOOL                    gIsLimitedMode = NO;
static int                    gSavedDefaultColorSize;



#ifdef TEST
static char *compstr[] =
{
  &quot;none&quot;, &quot;=&quot;, &quot;!=&quot;, &quot;&lt;=&quot;, &quot;&gt;=&quot;, &quot;&gt;&quot;, &quot;&lt;&quot;, &quot;~&quot;
};
static char *capstr[] =
{
  &quot;width&quot;, &quot;height&quot;, &quot;bpp&quot;, &quot;hertz&quot;, &quot;num&quot;
};
#endif

short __glutGetCurrentDMDepth (void)
{
    if (currentDm)
        return currentDm-&gt;cap[DM_PIXEL_DEPTH];
    else
        return __glutDefaultColorSize;
}

void __glutCloseDownGameMode(void)
{
   if(__glutGameModeWindow == nil &amp;&amp; !__glutDisplaySettingsChanged)
      return;
   
    CGDisplayFadeReservationToken fadeToken;

   if(__glutGameModeFadeInterval &gt; 0.0) {
      CGAcquireDisplayFadeReservation(kCGMaxDisplayReservationInterval, &amp;fadeToken);
      /* Fade all displays to black */
      CGDisplayFade(fadeToken,
            __glutGameModeFadeInterval,            // 2 seconds
            kCGDisplayBlendNormal,    // Starting state
            kCGDisplayBlendSolidColor, // Ending state
            0.0, 0.0, 0.0,        // black
            true);            // Wait for completion
   }
   
   if(__glutGameModeWindow) {
      GLUTView * tempView = __glutGameModeWindow;
      __glutGameModeWindow = nil; // ensure close is not called recursively
      __glutDestroyWindow(tempView);
   }
   
   if(__glutDisplaySettingsChanged) {
       CGDisplaySwitchToMode(kCGDirectMainDisplay, gOriginalMode);
      gOriginalMode = NULL;
        if (NO == __glutCaptureAllDisplays)
            CGDisplayRelease (kCGDirectMainDisplay);
        else
            CGReleaseAllDisplays();
      __glutDisplaySettingsChanged = 0;
      __glutDefaultColorSize = gSavedDefaultColorSize;
   }
   
   if(__glutGameModeFadeInterval &gt; 0.0) {
      /* Fade all displays back in */
      CGDisplayFade(fadeToken,
                __glutGameModeFadeInterval,            // 2 seconds
                kCGDisplayBlendSolidColor, // Starting state
                kCGDisplayBlendNormal,    // Ending state
                0.0, 0.0, 0.0,        // black
                false);            // Don't wait for completion
      CGReleaseDisplayFadeReservation(fadeToken);
   }
}

static int _getDictInt (CFDictionaryRef refDict, CFStringRef key)
{
    int int_value;
    CFNumberRef number_value = (CFNumberRef) CFDictionaryGetValue(refDict, key);
    if (!number_value) // if can't get a number for the dictionary
        return -1;  // fail
    if (!CFNumberGetValue(number_value, kCFNumberIntType, &amp;int_value)) // or if cant convert it
        return -1; // fail
    return int_value; // otherwise return the int value
}

static double _getDictDouble (CFDictionaryRef refDict, CFStringRef key)
{
    double double_value;
    CFNumberRef number_value = (CFNumberRef) CFDictionaryGetValue(refDict, key);
    if (!number_value) // if can't get a number for the dictionary
        return -1;  // fail
    if (!CFNumberGetValue(number_value, kCFNumberDoubleType, &amp;double_value)) // or if cant convert it
        return -1; // fail
    return double_value; // otherwise return the int value
}

#define MIN_WIDTH 640
#define MIN_HEIGHT 480
#define MIN_FREQUENCY 0 /* account for flat panels */
#define MIN_PIXEL_DEPTH    16

static void initGameModeSupport(void)
{
   CFArrayRef    displayModes = NULL;
   CFIndex        i, j, count;

   if(ndmodes &gt;= 0) {
      /* ndmodes is initially -1 to indicate no dmodes allocated yet. */
      if(!gIsLimitedMode) {
         return;
      } else {
         /* let's promote to all modes */
         free(dmodes);
         dmodes = NULL;
         ndmodes = -1;
         currentDm = NULL;
      }
   }
   
   /* Determine how many display modes there are. */
   displayModes = CGDisplayAvailableModes(kCGDirectMainDisplay);
   count = CFArrayGetCount(displayModes);
   ndmodes = 0; // must set to zero otherwise allocate too little storage
   for(i = 0; i &lt; count; i++) {
      CFDictionaryRef    modeDict = CFArrayGetValueAtIndex(displayModes, i);      
      long width = _getDictInt (modeDict, kCGDisplayWidth);
      long height = _getDictInt (modeDict, kCGDisplayHeight);
      long freq = (int)(_getDictDouble (modeDict, kCGDisplayRefreshRate) + 0.5);
      long depth = _getDictInt (modeDict, kCGDisplayBitsPerPixel);
      
      if ((width &gt;= MIN_WIDTH) &amp;&amp; (height &gt;= MIN_HEIGHT) &amp;&amp; (freq &gt;= MIN_FREQUENCY) &amp;&amp; (depth &gt;= MIN_PIXEL_DEPTH))
         ndmodes++;
   }
   
   /* Allocate memory for a list of all the display modes. */
   dmodes = (DisplayMode *) malloc(ndmodes * sizeof(DisplayMode));
   
   /* Now that we know how many display modes to expect,
      enumerate them again and save the information in
      the list we allocated above. */
   for(i = 0, j = 0; i &lt; count; i++) {
      CFDictionaryRef    modeDict = CFArrayGetValueAtIndex(displayModes, i);
      int displayWidth = _getDictInt (modeDict, kCGDisplayWidth);
      int displayHeight = _getDictInt (modeDict, kCGDisplayHeight);
      int displayFreq = (int)(_getDictDouble (modeDict, kCGDisplayRefreshRate) + 0.5);
      int bitsPerPixel = _getDictInt (modeDict, kCGDisplayBitsPerPixel);
      
      /* Try to reject any display settings that seem unplausible. */
      if(displayWidth &gt;= MIN_WIDTH &amp;&amp;
         displayHeight &gt;= MIN_HEIGHT &amp;&amp;
         displayFreq &gt;= MIN_FREQUENCY &amp;&amp;
         bitsPerPixel &gt;= MIN_PIXEL_DEPTH) {
         dmodes[j].cgModeDict = modeDict;
         dmodes[j].valid = 1;  /* XXX Not used for now. */
         dmodes[j].cap[DM_WIDTH] = displayWidth;
         dmodes[j].cap[DM_HEIGHT] = displayHeight;
         dmodes[j].cap[DM_PIXEL_DEPTH] = bitsPerPixel;
         dmodes[j].cap[DM_HERTZ] = displayFreq;
         j++;
      }
   }
   gIsLimitedMode = NO;
}

/* Same as above but creates only a single DisplayMode for the current
   CG display mode */
static void initLimitedGameModeSupport(void)
{
   CFDictionaryRef    modeDict = CGDisplayCurrentMode(kCGDirectMainDisplay);
   
   if(ndmodes &gt;= 0) {
      /* ndmodes is initially -1 to indicate no dmodes allocated yet. */
      return;
   }
   
   /* Allocate memory for a single display mode. */
   dmodes = (DisplayMode *) malloc(sizeof(DisplayMode));
   
   dmodes[0].cgModeDict = modeDict;
    dmodes[0].valid = 1;  /* XXX Not used for now. */
   dmodes[0].cap[DM_WIDTH] = _getDictInt(modeDict, kCGDisplayWidth);
   dmodes[0].cap[DM_HEIGHT] = _getDictInt(modeDict, kCGDisplayHeight);
   dmodes[0].cap[DM_PIXEL_DEPTH] = (int)(_getDictDouble (modeDict, kCGDisplayRefreshRate) + 0.5);
   dmodes[0].cap[DM_HERTZ] = _getDictInt(modeDict, kCGDisplayRefreshRate);
   gIsLimitedMode = YES;
}

/* This routine is based on similiar code in glut_dstr.c */
static DisplayMode *findMatch(DisplayMode *localdmodes, int localndmodes, Criterion *criteria, int ncriteria)
{
#if USE_GLUT_DSPY_MATCH_SCHEME
   DisplayMode *found;
   int *bestScore, *thisScore;
   int i, j, numok, result, worse, better;
   
   found = NULL;
   numok = 1;        /* &quot;num&quot; capability is indexed from 1, not 0. */
   
   /* XXX alloca canidate. */
   bestScore = (int *) malloc(ncriteria * sizeof(int));
   if(!bestScore) {
      __glutFatalError(&quot;out of memory.&quot;);
   }
   for (j = 0; j &lt; ncriteria; j++) {
      /* Very negative number. */
      bestScore[j] = -32768;
   }
   
   /* XXX alloca canidate. */
   thisScore = (int *) malloc(ncriteria * sizeof(int));
   if (!thisScore) {
      __glutFatalError(&quot;out of memory.&quot;);
   }
   
   for(i = 0; i &lt; localndmodes; i++) {
      if(localdmodes[i].valid) {
         worse = 0;
         better = 0;
         
         for(j = 0; j &lt; ncriteria; j++) {
            int cap, cvalue, dvalue;
            
            cap = criteria[j].capability;
            cvalue = criteria[j].value;
            if(cap == NUM) {
               dvalue = numok;
            } else {
               dvalue = localdmodes[i].cap[cap];
            }
#ifdef TEST
            if(verbose)
               NSLog(@&quot;  %s %s %d to %d\n&quot;, capstr[cap], compstr[criteria[j].comparison], cvalue, dvalue);
#endif
            switch(criteria[j].comparison) {
               case CMP_EQ:
                  result = cvalue == dvalue;
                  thisScore[j] = 1;
                  break;
               case CMP_NEQ:
                  result = cvalue != dvalue;
                  thisScore[j] = 1;
                  break;
               case CMP_LT:
                  result = dvalue &lt; cvalue;
                  thisScore[j] = dvalue - cvalue;
                  break;
               case CMP_GT:
                  result = dvalue &gt; cvalue;
                  thisScore[j] = dvalue - cvalue;
                  break;
               case CMP_LTE:
                  result = dvalue &lt;= cvalue;
                  thisScore[j] = dvalue - cvalue;
                  break;
               case CMP_GTE:
                  result = (dvalue &gt;= cvalue);
                  thisScore[j] = dvalue - cvalue;
                  break;
               case CMP_MIN:
                  result = dvalue &gt;= cvalue;
                  thisScore[j] = cvalue - dvalue;
                  break;
            }

#ifdef TEST
            if(verbose)
               NSLog(@&quot;       result=%d   score=%d   bestScore=%d\n&quot;, result, thisScore[j], bestScore[j]);
#endif

            if(result) {
               if(better || thisScore[j] &gt; bestScore[j]) {
                  better = 1;
               } else if(thisScore[j] == bestScore[j]) {
                  /* Keep looking. */
               } else {
                  goto nextDM;
               }
            } else {
               if(cap == NUM) {
                  worse = 1;
            } else {
                  goto nextDM;
            }
         }
      }

      if(better &amp;&amp; !worse) {
         found = &amp;localdmodes[i];
         for(j = 0; j &lt; ncriteria; j++) {
            bestScore[j] = thisScore[j];
         }
      }
      numok++;

nextDM:;

      }
   }
   free(bestScore);
   free(thisScore);
   return found;
#else
    DisplayMode *found;
    CFDictionaryRef bestMode = NULL;
    boolean_t bExactMatch;
    int width = MIN_WIDTH, height = MIN_HEIGHT, bpp = MIN_PIXEL_DEPTH, freq = MIN_FREQUENCY;
    int i;
    
    for (i = 0; i &lt; ncriteria; i++) {
    switch (criteria[i].capability) {
    case DM_WIDTH:        width = criteria[i].value; break;
    case DM_HEIGHT:       height = criteria[i].value; break;
    case DM_PIXEL_DEPTH:  bpp = criteria[i].value; break;
    case DM_HERTZ:        freq = criteria[i].value; break;
    }
    }

    bestMode = CGDisplayBestModeForParametersAndRefreshRate(
        kCGDirectMainDisplay, bpp, width, height, freq,  &amp;bExactMatch);

    found = NULL;
    for(i = 0; i &lt; localndmodes; i++) {
        if (localdmodes[i].cgModeDict == bestMode) {
            found = &amp;(localdmodes[i]);
            break;
        }
    }
    if (NULL == found) { /* could not find mode, try with 0 freq for flat panels */
        bestMode = CGDisplayBestModeForParametersAndRefreshRate(
            kCGDirectMainDisplay, bpp, width, height, 0,  &amp;bExactMatch);
    
        found = NULL;
        for(i = 0; i &lt; localndmodes; i++) {
            if (localdmodes[i].cgModeDict == bestMode) {
                found = &amp;(localdmodes[i]);
                break;
            }
        }
    }
    return found;
#endif
}

/**
 * Parses strings in the form of:
 *  800x600
 *  800x600:16
 *  800x600@60
 *  800x600:16@60
 *  @60
 *  :16
 *  :16@60
 * NOTE that @ before : is not parsed.
 */
static int specialCaseParse(char *word, Criterion *criterion, int mask)
{
   char *xstr, *response;
   int got;
   int width, height, bpp, hertz;
   
   switch(word[0]) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
         /* The WWWxHHH case. */
         if(mask &amp; (1 &lt;&lt; DM_WIDTH)) {
            return -1;
         }
         xstr = strpbrk(&amp;word[1], &quot;x&quot;);
         if(xstr) {
            width = (int) strtol(word, &amp;response, 0);
            if(response == word || response[0] != 'x') {
               /* Not a valid number OR needs to be followed by 'x'. */
               return -1;
            }
            height = (int) strtol(&amp;xstr[1], &amp;response, 0);
            if(response == &amp;xstr[1]) {
               /* Not a valid number. */
               return -1;
            }
            criterion[0].capability = DM_WIDTH;
            criterion[0].comparison = CMP_EQ;
            criterion[0].value = width;
            criterion[1].capability = DM_HEIGHT;
            criterion[1].comparison = CMP_EQ;
            criterion[1].value = height;
            got = specialCaseParse(response, &amp;criterion[2], 1 &lt;&lt; DM_WIDTH);
            if(got &gt;= 0) {
               return got + 2;
            } else {
               return -1;
            }
         }    
         return -1;
         
      case ':':
         /* The :BPP case. */
         if(mask &amp; (1 &lt;&lt; DM_PIXEL_DEPTH)) {
            return -1;
         }
         bpp = (int) strtol(&amp;word[1], &amp;response, 0);
         if(response == &amp;word[1]) {
            /* Not a valid number. */
            return -1;
         }
         criterion[0].capability = DM_PIXEL_DEPTH;
         criterion[0].comparison = CMP_EQ;
         criterion[0].value = bpp;
         got = specialCaseParse(response, &amp;criterion[1], 1 &lt;&lt; DM_WIDTH | 1 &lt;&lt; DM_PIXEL_DEPTH);
         if(got &gt;= 0) {
            return got + 1;
         } else {
            return -1;
         }
         
      case '@':
         /* The @HZ case. */
         if(mask &amp; (1 &lt;&lt; DM_HERTZ)) {
            return -1;
         }
         hertz = (int) strtol(&amp;word[1], &amp;response, 0);
         if(response == &amp;word[1]) {
            /* Not a valid number. */
            return -1;
         }
         criterion[0].capability = DM_HERTZ;
         criterion[0].comparison = CMP_EQ;
         criterion[0].value = hertz;
         got = specialCaseParse(response, &amp;criterion[1], ~DM_HERTZ);
         if(got &gt;= 0) {
            return got + 1;
         } else {
            return -1;
         }
         
      case '\0':
         return 0;
   }
   return -1;
}

/* This routine is based on similiar code in glut_dstr.c */
static int parseCriteria(char *word, Criterion *criterion)
{
   char *cstr, *vstr, *response;
   int comparator, value = 0;
   
   cstr = strpbrk(word, &quot;=&gt;&lt;!~&quot;);
   if(cstr) {
      switch(cstr[0]) {
         case '=':
            comparator = CMP_EQ;
            vstr = &amp;cstr[1];
            break;
            
         case '~':
            comparator = CMP_MIN;
            vstr = &amp;cstr[1];
            break;
            
         case '&gt;':
            if(cstr[1] == '=') {
               comparator = CMP_GTE;
               vstr = &amp;cstr[2];
            } else {
               comparator = CMP_GT;
               vstr = &amp;cstr[1];
            }
            break;
            
         case '&lt;':
            if(cstr[1] == '=') {
               comparator = CMP_LTE;
               vstr = &amp;cstr[2];
            } else {
               comparator = CMP_LT;
               vstr = &amp;cstr[1];
            }
            break;
            
         case '!':
            if(cstr[1] == '=') {
               comparator = CMP_NEQ;
               vstr = &amp;cstr[2];
            } else {
               return -1;
            }
            break;
            
         default:
            return -1;
      }
      value = (int) strtol(vstr, &amp;response, 0);
      if(response == vstr) {
         /* Not a valid number. */
         return -1;
      }
      *cstr = '\0';
   } else {
      comparator = CMP_NONE;
   }
   
   switch (word[0]) {
      case 'b':
         if(!strcmp(word, &quot;bpp&quot;)) {
            criterion[0].capability = DM_PIXEL_DEPTH;
            if(comparator == CMP_NONE) {
               return -1;
            } else {
               criterion[0].comparison = comparator;
               criterion[0].value = value;
               return 1;
            }
         }
         return -1;
         
      case 'h':
         if(!strcmp(word, &quot;height&quot;)) {
            criterion[0].capability = DM_HEIGHT;
            if(comparator == CMP_NONE) {
               return -1;
            } else {
               criterion[0].comparison = comparator;
               criterion[0].value = value;
               return 1;
            }
         }
         if(!strcmp(word, &quot;hertz&quot;)) {
            criterion[0].capability = DM_HERTZ;
            if(comparator == CMP_NONE) {
               return -1;
            } else {
               criterion[0].comparison = comparator;
               criterion[0].value = value;
               return 1;
            }
         }
         return -1;
         
      case 'n':
         if(!strcmp(word, &quot;num&quot;)) {
            criterion[0].capability = DM_NUM;
            if(comparator == CMP_NONE) {
               return -1;
            } else {
               criterion[0].comparison = comparator;
               criterion[0].value = value;
               return 1;
            }
         }
         return -1;
         
      case 'w':
         if(!strcmp(word, &quot;width&quot;)) {
            criterion[0].capability = DM_WIDTH;
            if(comparator == CMP_NONE) {
               return -1;
            } else {
               criterion[0].comparison = comparator;
               criterion[0].value = value;
               return 1;
            }
         }
         return -1;
         
   }
   if(comparator == CMP_NONE) {
      return specialCaseParse(word, criterion, 0);
   }
   return -1;
}

/* This routine is based on similiar code in glut_dstr.c */
static Criterion *parseDisplayString(const char *display, int *ncriteria)
{
   Criterion *criteria = NULL;
   int n, parsed;
   char *copy, *word;
   
   copy = __glutStrdup(display);
   /* Attempt to estimate how many criteria entries should be needed. */
   n = 0;
   word = strtok(copy, &quot; \t&quot;);
   while(word) {
      n++;
      word = strtok(NULL, &quot; \t&quot;);
   }
   /* Allocate number of words of criteria.  A word
      could contain as many as four criteria in the
      worst case.  Example: 800x600:16@60 */
   criteria = (Criterion *) malloc(4 * n * sizeof(Criterion));
   if(!criteria) {
      __glutFatalError(&quot;out of memory.&quot;);
   }
   
   /* Re-copy the copy of the display string. */
   strcpy(copy, display);
   
   n = 0;
   word = strtok(copy, &quot; \t&quot;);
   while(word) {
      parsed = parseCriteria(word, &amp;criteria[n]);
      if(parsed &gt;= 0) {
         n += parsed;
      } else {
         __glutWarning(&quot;Unrecognized game mode string word: %s (ignoring)\n&quot;, word);
      }
      word = strtok(NULL, &quot; \t&quot;);
   }
   
   free(copy);
   *ncriteria = n;
   return criteria;
}

/* CENTRY */
void APIENTRY glutGameModeString(const char *string)
{
   Criterion *    criteria;
   int            ncriteria;
   
   initGameModeSupport();
   criteria = parseDisplayString(string, &amp;ncriteria);
   currentDm = findMatch(dmodes, ndmodes, criteria, ncriteria);
   free(criteria);
}

int APIENTRY glutEnterGameMode(void)
{
   int            width, height;
   CGDisplayErr    status = kCGErrorSuccess;
   CGDisplayFadeReservationToken fadeToken;
   int            winID = -1;

   GLUTAPI_DECLARATIONS
   GLUTAPI_BEGIN   
   
    if(__glutMappedMenu) {
            __glutFatalUsage(&quot;Entering game mode not allowed while menus in use&quot;);
    }

   if(__glutGameModeFadeInterval &gt; 0.0) {
      CGAcquireDisplayFadeReservation(kCGMaxDisplayReservationInterval, &amp;fadeToken);
      /* Fade all displays to black */
      CGDisplayFade(fadeToken,
         __glutGameModeFadeInterval,            // 2 seconds
         kCGDisplayBlendNormal,    // Starting state
         kCGDisplayBlendSolidColor, // Ending state
         0.0, 0.0, 0.0,        // black
         true);            // Wait for completion
   }

   if(__glutGameModeWindow) {
      /* Already in game mode, so blow away game mode
         window so apps can change resolutions. */
      GLUTView *    window = __glutGameModeWindow;
      /* Setting the game mode window to NULL tricks
         the window destroy code into not undoing the
         screen display change since we plan on immediately
         doing another mode change. */
      __glutGameModeWindow = nil;
      __glutDestroyWindow(window);
   }

   /* Assume default screen size until we find out if we
      can actually change the display settings. */
   width = __glutScreenWidth;
   height = __glutScreenHeight;
   gSavedDefaultColorSize = __glutDefaultColorSize;
   
   if(currentDm == NULL) {
      /* No game mode string specified. We simply capture the current
         display mode */
      initLimitedGameModeSupport();
      currentDm = &amp;dmodes[0];
   }

    if(!CGDisplayIsCaptured(kCGDirectMainDisplay)) {
        if (NO == __glutCaptureAllDisplays)
            status = CGDisplayCapture (kCGDirectMainDisplay);
        else
            status = CGCaptureAllDisplays ();
    }

    if(status == kCGErrorSuccess) {
        if(gOriginalMode == NULL) {
            gOriginalMode = CGDisplayCurrentMode(kCGDirectMainDisplay);
        }
      
        status = CGDisplaySwitchToMode(kCGDirectMainDisplay, currentDm-&gt;cgModeDict);
        if(status == kCGErrorSuccess) {
            __glutDisplaySettingsChanged = 1;
            width = currentDm-&gt;cap[DM_WIDTH];
            height = currentDm-&gt;cap[DM_HEIGHT];
        } else {
            /* Switch back to default resolution. */
            __glutWarning(&quot;Could not enter game mode (%d)&quot;, status);
            CGDisplaySwitchToMode(kCGDirectMainDisplay, gOriginalMode);
            gOriginalMode = NULL;
            if (NO == __glutCaptureAllDisplays)
                CGDisplayRelease (kCGDirectMainDisplay);
            else
                CGReleaseAllDisplays();
        }
    }
    else
        __glutWarning (&quot;glutEnterGameMode: Could not capture display&quot;);

   __glutDefaultColorSize = currentDm-&gt;cap[DM_PIXEL_DEPTH];
    /* Create a new window */
    __glutGameModeWindow = __glutCreateWindow(nil, 0, 0, width, height, /* game mode */ YES);
   if(__glutGameModeFadeInterval &gt; 0.0) {
      /* Fade all displays back in */
      CGDisplayFade(fadeToken,
                __glutGameModeFadeInterval,            // 2 seconds
                kCGDisplayBlendSolidColor, // Starting state
                kCGDisplayBlendNormal,    // Ending state
                0.0, 0.0, 0.0,        // black
                false);            // Don't wait for completion
      CGReleaseDisplayFadeReservation(fadeToken);
   }
   winID = [__glutGameModeWindow windowID];
   GLUTAPI_END
   return winID;
}

void APIENTRY glutLeaveGameMode(void)
{
   GLUTAPI_DECLARATIONS
    GLUTAPI_BEGIN
    if(__glutGameModeWindow) {
        __glutDestoryingGameMode = true;
        __glutDestroyWindow(__glutGameModeWindow);
        // do not set game mode window to NULL here as the view dealloc is not called until this function exits
        // it is set to null in view dealloc
    } else
      __glutWarning(&quot;not in game mode so cannot leave game mode&quot;);
    GLUTAPI_END
}

int APIENTRY glutGameModeGet(GLenum mode)
{
   switch(mode) {
      case GLUT_GAME_MODE_ACTIVE:
            return __glutGameModeWindow != nil;
      case GLUT_GAME_MODE_POSSIBLE:
            return currentDm != NULL;
      case GLUT_GAME_MODE_WIDTH:
            return currentDm ? currentDm-&gt;cap[DM_WIDTH] : -1;
      case GLUT_GAME_MODE_HEIGHT:
            return currentDm ? currentDm-&gt;cap[DM_HEIGHT] : -1;
      case GLUT_GAME_MODE_PIXEL_DEPTH:
            return currentDm ? currentDm-&gt;cap[DM_PIXEL_DEPTH] : -1;
      case GLUT_GAME_MODE_REFRESH_RATE:
            return currentDm ? currentDm-&gt;cap[DM_HERTZ] : -1;
      case GLUT_GAME_MODE_DISPLAY_CHANGED:
            return __glutDisplaySettingsChanged;
      default:
            __glutWarning(&quot;invalid glutGameModeGet parameter: %d&quot;, mode);
         return -1;
   }
}
/* ENDCENTRY */
</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/glut/listing101.html%3Fid%3DDTS10000528-2.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/glut/listing101.html%3Fid%3DDTS10000528-2.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/glut/listing101.html%3Fid%3DDTS10000528-2.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>