<html>	<head>		<title>NSMultiReaderLock (Java) </title>	</head>	<body bgcolor="#ffffff">		<!-- start of header -->		<!--#include virtual="/includes/framesetheader" -->		<!-- end of header --><!-- start of path --><table cellspacing=0 border=0 width=600 valign="left"><tr><td scope="row"><font face="Geneva,Helvetica,Arial" size="1"><b>PATH<spacer type="horizontal" size="5">&nbsp;</b><a href="../../../../index.html" target="_top">Documentation</a> <b>></b> <a href="../../../webobjects.html" target="_top">WebObjects</a></font></td></tr></table><br><!-- end of path -->		<a href="../FoundationTOC.html"><img src="../Art/up.gif" border="0" alt="Table of Contents"></a> <a name="CEBCJFJJ"></a><br>		<h1><font color="#000066"><a name="//apple_ref/java/cl/NSMultiReaderLock">NSMultiReaderLock</a></font></h1>		<br>		<blockquote>			<dl>				<dt><b>Inherits from: </b>				<dd>Object 			</dl>		</blockquote>		<blockquote>			<dl>				<dt><b>Implements: </b>				<dd>NSLocking 			</dl>		</blockquote>		<blockquote>			<dl>				<dt><b>Package: </b>				<dd>com.webobjects.foundation 			</dl>		</blockquote>		<hr size="4">		<br>		<h2>Class Description</h2>		<hr alt="">		<p>The NSMultiReaderLock class provides <b>reader</b> and <b>writer locks</b>. The locks are recursive; a single thread can request a lock many times, but a lock is actually taken only on the first request. Likewise, when a thread indicates it's finished with a lock, it takes an equal number of <b>unlock...</b> invocations to return the lock.</p>		<p>There's no limit on the number of reader locks that a process can take. However, there can only be one writer lock at a time, and a writer lock is not issued until all reader locks are returned. Reader locks aren't issued to new threads when there is a thread waiting for a writer lock, but threads that already have a reader lock can increment their lock count.</p>		<p>NSMultiReaderLock correctly handles promotion of a reader lock to a writer lock, and the extension of a reader lock to the current writer. This prevents a thread from deadlocking on itself when requesting a combination of lock types.</p>		<p>NSMultiReaderLocks are slightly more time-expensive than <a href="NSRecursiveLock.html#CBEEJIJF">NSRecursiveLock</a>s because the recursion count has to be stored per-thread, causing each request for a reader lock to incur at least one hash lookup. Writer locks are even more expensive because NSMultiReaderLock must poll the hashtable until all reader locks have been returned before the writer lock can be taken.</p>		<br>		<br>		<br>		<h2>Method Types</h2>		<hr alt="">		<blockquote>			<dl>				<dt>Constructors 				<dl>					<dd><a href="#//apple_ref/java/instm/NSMultiReaderLock/NSMultiReaderLock">NSMultiReaderLock</a> 				</dl>			</dl>			<dl>				<dt>Managing reader locks 				<dl>					<dd><a href="#//apple_ref/java/instm/NSMultiReaderLock/lockForReading">lockForReading</a> 					<dd><a href="#//apple_ref/java/instm/NSMultiReaderLock/retrieveReaderLocks">retrieveReaderLocks</a> 					<dd><a href="#//apple_ref/java/instm/NSMultiReaderLock/suspendReaderLocks">suspendReaderLocks</a> 					<dd><a href="#//apple_ref/java/instm/NSMultiReaderLock/tryLockForReading">tryLockForReading</a> 					<dd><a href="#//apple_ref/java/instm/NSMultiReaderLock/unlockForReading">unlockForReading</a> 				</dl>			</dl>			<dl>				<dt>Managing writer locks 				<dl>					<dd><a href="#//apple_ref/java/instm/NSMultiReaderLock/lock">lock</a> 					<dd><a href="#//apple_ref/java/instm/NSMultiReaderLock/lockForWriting">lockForWriting</a> 					<dd><a href="#//apple_ref/java/instm/NSMultiReaderLock/tryLockForWriting">tryLockForWriting</a> 					<dd><a href="#//apple_ref/java/instm/NSMultiReaderLock/unlock">unlock</a> 					<dd><a href="#//apple_ref/java/instm/NSMultiReaderLock/unlockForWriting">unlockForWriting</a> 				</dl>			</dl>			<dl>				<dt>Methods inherited from Object 				<dl>					<dd><a href="#//apple_ref/java/instm/NSMultiReaderLock/toString">toString</a> 				</dl>			</dl>		</blockquote>		<br>		<br>		<h2>Constructors</h2>		<hr alt="">		<a name="CJFFDBGH"></a><br>		<h3><a name="//apple_ref/java/instm/NSMultiReaderLock/NSMultiReaderLock">NSMultiReaderLock</a></h3>		<p><code>public <b>NSMultiReaderLock</b>()</code></p>		Creates an NSMultiReaderLock object. 		<hr width="25%" align="LEFT">		<br>		<br>		<h2>Instance Methods</h2>		<hr alt="">		<a name="lock_NSMultiReaderLock"></a><br>		<h3><a name="//apple_ref/java/instm/NSMultiReaderLock/lock">lock</a></h3>		<p><code>public void <b>lock</b>()</code></p>		Conformance to <a href="../Interfaces/NSLocking.html#CHCJAGIE">NSLocking</a>. See the method description of <a href="../Interfaces/NSLocking.html#//apple_ref/java/intfm/NSLocking/lock">lock</a> in the interface description for NSLocking. This method is equivalent to <a href="#//apple_ref/java/instm/NSMultiReaderLock/lockForWriting">lockForWriting</a>. 		<hr width="25%" align="LEFT">		<a name="lockForReading_NSMultiReaderLock"></a><br>		<h3><a name="//apple_ref/java/instm/NSMultiReaderLock/lockForReading">lockForReading</a></h3>		<p><code>public void <b>lockForReading</b>()</code></p>		Acquires a reader lock for the current thread. If the current thread doesn't already have a lock, the method blocks if there are any waiting or active writer locks. If the current thread already has a lock (reader or writer), the lock request count is incremented. 		<hr width="25%" align="LEFT">		<a name="lockForWriting_NSMultiReaderLock"></a><br>		<h3><a name="//apple_ref/java/instm/NSMultiReaderLock/lockForWriting">lockForWriting</a></h3>		<p><code>public void <b>lockForWriting</b>()</code></p>		Gets a writer lock for the current thread. If the current thread already has one, the lock request count is incremented, but a new lock is not taken. If the requesting thread has outstanding reader locks, they are temporarily dropped until the writer lock is returned. If other threads have outstanding reader locks, this method blocks until all reader locks have been freed. 		<hr width="25%" align="LEFT">		<a name="retrieveReaderLocks_NSMultiReaderLock"></a><br>		<h3><a name="//apple_ref/java/instm/NSMultiReaderLock/retrieveReaderLocks">retrieveReaderLocks</a></h3>		<p><code>public void <b>retrieveReaderLocks</b>()</code></p>		Reinstates the current thread's reader locks that have been suspended using <a href="#//apple_ref/java/instm/NSMultiReaderLock/suspendReaderLocks">suspendReaderLocks</a>. 		<hr width="25%" align="LEFT">		<a name="suspendReaderLocks_NSMultiReaderLock"></a><br>		<h3><a name="//apple_ref/java/instm/NSMultiReaderLock/suspendReaderLocks">suspendReaderLocks</a></h3>		<p><code>public void <b>suspendReaderLocks</b>()</code></p>		Temporarily relinquishes all of the current thread's reader locks, releasing the lock if all reader locks are unlocked. To reinstate the current thread's suspended reader locks, use the <a href="#//apple_ref/java/instm/NSMultiReaderLock/retrieveReaderLocks">retrieveReaderLocks</a> method. 		<hr width="25%" align="LEFT">		<a name="toString_NSMultiReaderLock"></a><br>		<h3><a name="//apple_ref/java/instm/NSMultiReaderLock/toString">toString</a></h3>		<p><code>public String <b>toString</b>()</code></p>		Returns a string representation of the receiver containing the current thread name and a table with the names and reader lock counts of all the receiver's threads. 		<hr width="25%" align="LEFT">		<a name="tryLockForReading_NSMultiReaderLock"></a><br>		<h3><a name="//apple_ref/java/instm/NSMultiReaderLock/tryLockForReading">tryLockForReading</a></h3>		<p><code>public boolean <b>tryLockForReading</b>()</code></p>		Returns <code>true</code> if the current thread is able to immediately obtain a reader lock. There are three ways this can happen: 		<ol>			<li>There are no outstanding writer locks. 			<li>The writer lock is held by the current thread. 			<li>The current thread already has a reader lock. 		</ol>		<p>This method implicitly calls <b>lockForReading</b>, so you must call <b>unlockForReading</b> if <b>tryLockForReading</b> returns <code>true</code>.</p>		<hr width="25%" align="LEFT">		<a name="tryLockForWriting_NSMultiReaderLock"></a><br>		<h3><a name="//apple_ref/java/instm/NSMultiReaderLock/tryLockForWriting">tryLockForWriting</a></h3>		<p><code>public boolean <b>tryLockForWriting</b>()</code></p>		Returns <code>true</code> if the current thread is able to immediately obtain a writer lock. Returns <code>false</code> if another thread already has the lock or is queued to receive it. This method implicitly calls <b>lockForWriting</b>, so you must call <b>unlockForWriting</b> if <b>tryLockForWriting</b> returns <code>true</code>. 		<hr width="25%" align="LEFT">		<a name="unlock_NSMultiReaderLock"></a><br>		<h3><a name="//apple_ref/java/instm/NSMultiReaderLock/unlock">unlock</a></h3>		<p><code>public void <b>unlock</b>()</code></p>		Conformance to <a href="../Interfaces/NSLocking.html#CHCJAGIE">NSLocking</a>. See the method description of <a href="../Interfaces/NSLocking.html#//apple_ref/java/intfm/NSLocking/unlock">unlock</a> in the interface description for NSLocking. This method is equivalent to <a href="#//apple_ref/java/instm/NSMultiReaderLock/unlockForWriting">unlockForWriting</a>. 		<hr width="25%" align="LEFT">		<a name="unlockForReading_NSMultiReaderLock"></a><br>		<h3><a name="//apple_ref/java/instm/NSMultiReaderLock/unlockForReading">unlockForReading</a></h3>		<p><code>public void <b>unlockForReading</b>()</code></p>		Releases a reader lock for the current thread. Each <b>lockForReading</b> message must be paired with an <b>unlockForReading</b> message before the lock is actually released. Invoking this method when the lock count is zero does nothing. 		<hr width="25%" align="LEFT">		<a name="unlockForWriting_NSMultiReaderLock"></a><br>		<h3><a name="//apple_ref/java/instm/NSMultiReaderLock/unlockForWriting">unlockForWriting</a></h3>		<p><code>public void <b>unlockForWriting</b>()</code></p>		Releases a writer lock for the current thread. Each <b>lockForWriting</b> message must be paired with an <b>unlockForWriting</b> message before the lock is actually released. When the writer lock is released, it checks to see if the thread previously had any reader locks. If so, the reader lock count is restored. Invoking this method when the lock count is zero does nothing. 		<hr width="25%" align="LEFT">		<br>		<p>&copy; 2001 Apple Computer, Inc. (Last Published April 17, 2001)</p>		<br>		<a href="../FoundationTOC.html"><img src="../Art/up.gif" border="0" alt="Table of Contents"></a> <!-- start of footer -->		<!--#include virtual="/includes/framesetfooter" -->		<!-- end of footer -->	</body></html>