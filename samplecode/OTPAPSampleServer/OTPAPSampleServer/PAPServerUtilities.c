/*	file: PAPServerUtilities.c		by:		Rich Kubota			Developer Technical Support			*/#include <Errors.h>#include <Files.h>#include <Traps.h>#include <Devices.h>#include "PAPServerUtilities.h"/* the following code is from IM VI 3-8 which demonstrates how to check for the  * availability of traps */ short NumToolboxTraps(void){	if (NGetTrapAddress(_InitGraf, ToolTrap) == NGetTrapAddress(0xAA6E, ToolTrap))		return(0x200);	else		return(0x400);} /* NumToolboxTraps */TrapType GetTrapType(short theTrap){	short	trapMask = 0x0800;		if (theTrap & trapMask)		return(ToolTrap);	else		return(OSTrap);} /* GetTrapType */Boolean TrapAvailable(short theTrap){	TrapType	theType;		theType = GetTrapType(theTrap);	if (theType == ToolTrap) {		theTrap &= 0x07FF;		if (theTrap >= NumToolboxTraps())			theTrap = _Unimplemented;	}	return(NGetTrapAddress(theTrap, theType) != NGetTrapAddress(_Unimplemented, ToolTrap));}/***************************************************************************The following function was taken from the MoreFiles.c DTS Sample code.**/pascal	OSErr	HCreateMinimum(short vRefNum,							   long dirID,							   ConstStr255Param fileName){	HParamBlockRec pb;	pb.fileParam.ioNamePtr = (StringPtr)fileName;	pb.fileParam.ioVRefNum = vRefNum;	pb.ioParam.ioVersNum = 0;	pb.fileParam.ioDirID = dirID;	return ( PBHCreateSync(&pb) );}/*  * OpenTempFile opens a temporary file on the root volume of the boot drive * returns the file ref num to write to, or -1 if a problem occurred * * This code is not meant to demonstrate how one goes about creating a temporary * file, it's more a matter of expediency for me. */OSErr	OpenTempFile(short	*fRefNum){	HParamBlockRec	pb;	short			index = 0;	OSErr			err;		Str255			fname = "\pSavedPAPFile";						//	   123456789012		temp file name is 12 characters long			// initialize err as dupFNErr since that and noErr are the only errors		// which we can deal with here	err = dupFNErr;	while (err == dupFNErr)	{		if (index < 10)		{			fname[0] = 14;	// specify that the file name is 14 character pascal string			fname[14] = '0' + index;		}		else if (index < 100)	// temp files 'SavedPAPFile 0' - 'SavedPAPFile 9' already exist		{			fname[0] = 15;			fname[14] = '0' + (index / 10);		// set the tens placeholder			fname[15] = '0' + (index % 10);		// set the units placeholder		}		else // this part of the code will likely not be tested, but it's implemented just in case.		{			fname[0] = 16;			fname[14] = '0' + (index / 100);		// set the hundreds placeholder			fname[15] = '0' + ((index % 100) / 10);	// set the tens placeholder			fname[16] = '0' + (index % 10);			// set the units placeholder		}				index++;  	// increment index for the next go around;				err = HCreateMinimum(kBootVolVRefNum, kRootFolderDirID, fname);	}			// was the file created successfully			if (err == noErr)	{		pb.fileParam.ioNamePtr = (StringPtr) fname;		pb.ioParam.ioPermssn = fsWrPerm;		pb.ioParam.ioMisc = 0;		pb.fileParam.ioDirID = kRootFolderDirID;		pb.fileParam.ioVRefNum = kBootVolVRefNum;		err = PBHOpenSync(&pb);	}		if (err != noErr)		*fRefNum = 0;	else		*fRefNum = pb.ioParam.ioRefNum;			return err;}OSErr WriteDataToTempFile(short fRefNum, UInt8 *buffer, UInt32 len){	HParamBlockRec	pb;	pb.ioParam.ioRefNum = fRefNum;	pb.ioParam.ioBuffer = (Ptr)buffer;	pb.ioParam.ioReqCount = len;	pb.ioParam.ioPosMode = fsAtMark + 0x0020;  /* fsAtMarK + noCacheBit */	pb.ioParam.ioPosOffset = 0;	return (PBWriteSync((ParmBlkPtr)&pb));	}OSErr CloseTempFile(short fRefNum){	HParamBlockRec	pb;	pb.ioParam.ioRefNum = fRefNum;	return (PBCloseSync((ParmBlkPtr)&pb));	}