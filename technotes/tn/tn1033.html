<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 03-24-01 --><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note TN1033: Interrupts in Need of (a Good) Time</title>    <meta name="keywords" content="Mac OS 8 interrupts calling task level code DRVR QQueuesNewRequest ">    <meta name="Description" content="Technical Note TN1033: This Technical Note presents a numberof techniques you can use for communicating between interrupttime code and task level code, along with an analysis ofeach method. Included are techniques to obtain periodic timeso as to process events.">                                       <meta name="categories" content="Processes"><meta name="week-posted" content="Jan 29, 1996 - Feb 2, 1996"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002875" title="Interrupts in Need of (a Good) Time"></a><A NAME="top"></A><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxCarbon-date.html">Carbon</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxProcessManagement-date.html" target="_blank">Carbon > Process Management</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1033</div>
<div id="pageheadsub">Interrupts in Need of (a Good) Time</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"> <!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr><td width=300 valign="top" align=left scope="row">    <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td></tr><tr bgcolor="#e6e6e6">    <td background="images/tnmenubody.gif" width=300 align=left><span id="menutitle">    CONTENTS     <BR>    <BR></span>    </td></tr><tr bgcolor="#e6e6e6">    <td background="images/tnmenubody.gif" width=300 align=left><!-- begin_toc --><P id = "menutext"><A HREF = "#RTFToC1">Defining the Problem</a><br><br><A HREF = "#RTFToC2">Techniques for Solving the Problem</a><br><br><A HREF = "#RTFToC3">Summary</a><br><br><A HREF = "#References">References</a><br><br><A HREF="#Downloads">Downloadables</A></P>   <!-- end_toc -->  </td></tr><tr>    <td width=300 align=left scope="row"><img src="images/tnmenubottom.gif" alt="" width=300 height=16>    </td></tr>    </table></td><td width=300 valign="top" align=left><!-- begin_intro_text -->  <p id = "introtext">    One of the classic problems of Macintosh programming is that your code is executing at interrupt time and you wish to execute a Mac OS routine that cannot be called at interrupt time. This Technote presents a number of techniques you can use for communicating between interrupt time code and task level code, along with an analysis of each method. It concludes with a recommendation for the best general-purpose method for solving the problem.</p><P id = "introtext">This Note is intended for Macintosh application developers who are writing interrupt time code that needs to execute code at task level. The Note focuses on traditional Macintosh Operating System techniques but it also analyzes the likelihood of future compatibilty for each approach. The Note may also be useful for traditional Mac OS device driver writers, i.e., those who are writing drivers of type <code>'DRVR'</code>.</p><!-- end_intro_text --><!-- begin_date --><h3>&nbsp;Updated: [Feb 1 1996]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR> <!-- begin_content --><a name="RTFToC1"></a><h2>Defining the Problem</h2><P>Before discussing some of the techniques you can use for communicating between interrupt time code and task level code, it's important to note that the Mac OS supports three execution levels: </p><ul><li>hardware interrupt time</li><li>deferred task time</li><li>task level, also known as system task time</li></ul><P>In common parlance, hardware interrupt and deferred task time are collectively referred to as "interrupt time." Application developers usually encounter interrupt time when writing ioCompletion routines, which typically run at deferred task time.</p><P>The most important consequence of these different execution levels is that you can only call a limited set of Mac OS routines from interrupt time. For example, you might have an application that issues an asynchronous call to read some data off the network. The call completes and executes your <code>ioCompletion</code> at deferred task time. Inside your <code>ioCompletion</code> routine you want to call a Mac OS routine that can't be called at interrupt time, such as <code>NewHandle</code>. What do you do?</P><P><A HREF="#top">Back to top</A></P><a name="RTFToC2"></a><h2>Techniques for Solving the Problem</h2><P>Over time, a number of techniques have been used to solve the problem of calling task level code from interrupt time. Some, but not all, of them are described here, along with an analysis of the pros and cons of each approach.</p><h3>Solution Framework</h3><P>All of the solutions that follow, essentially, take the same approach. The program contains two threads of execution, one that runs at interrupt time and the other that runs at task level time. When it executes, the interrupt time code queues a request (using the queue management routines described in <CITE>Inside Macintosh: Operating System Utilities</CITE>) on to some global queue. The task level code then polls this queue and processes any requests it finds.</p><P>The following snippets demonstrate this technique.  First, we declare two queues, one that contains a pool of free queue elements (<code>free_queue</code>) and the other which contains a list of pending requests (<code>request_queue</code>). These are declared as simple extensions to the QElem record declared in OSUtils.h.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>typedef struct qQElem qQElem;typedef qQElem *qQElemPtr;struct qQElem {    qQElemPtr qLink;    short qType;    requestProc request;    long refcon;};static QHdr free_queue;        /* List of queue elements that are                    currently unused. */static QHdr request_queue;    /* List of queue elements that                    hold pending requests. */</pre>	</TD></TR></TABLE></CENTER><P>Populating the free queue is left as an exercise for the reader.</p><P>The <code>QQueuesNewRequest</code> routine is called at interrupt time to indicate the request procedure to be called at the next available task level time.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal OSStatus QQueuesNewRequest(requestProc request, long refcon)    /* Add a request to the &quot;to do&quot; queue.  Request must be a    native procedure, there is no MixedMode magic in here!*/{    OSStatus err;    qQElemPtr free_element;    err = noErr;    /* Get an element from the free queue. */    free_element = (qQElemPtr) QQueuesGetQueueElement(&amp;free_queue);    if (free_element == nil) {        err = noFreeQueueElementsErr;    }    /* Now fill out the fields of the element and add it to the    list of queued requests. */    if (err == noErr) {        free_element-&gt;request = request;        free_element-&gt;refcon = refcon;        Enqueue((QElemPtr) free_element, &amp;request_queue);    }    return (err);}</pre>	</TD></TR></TABLE></CENTER><P>The <code>QQueuesProcessRequests</code> routine is called at task level time to execute all of the pending requests.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal OSStatus QQueuesProcessRequests(void)    /* Process each of the queued requests.*/{    qQElemPtr request;    do {        /* Get an element off the &quot;to do&quot; queue. */        request = (qQElemPtr) QQueuesGetQueueElement(&amp;request_queue);        if (request != nil) {            request-&gt;request(request-&gt;refcon);                /* Do the request... */            Enqueue((QElemPtr) request, &amp;free_queue);                /* ... and put it back on the free                queue. */        }    } while (request != nil);    return (noErr);}</pre>	</TD></TR></TABLE></CENTER><P>Oh, and just for the sake of completeness, the <code>QQueuesGetQueueElement</code> routine is a utility routine called by the previous two routines.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>static QElemPtr QQueuesGetQueueElement(QHdrPtr queue)    /* An interrupt safe mechanism to remove and return the    first element of queue. */{    OSStatus err;    QElemPtr first_element;    /* Pull the first element off the queue, spinning if it    disappears while we're looking at it.*/    do {        first_element = queue-&gt;qHead;        if (first_element != nil) {            err = Dequeue(first_element, queue);        }    } while ((first_element != nil) &amp;&amp; (err != noErr));    /* Return it. */    return first_element;}</pre>	</TD></TR></TABLE></CENTER><P>So the original problem can now be restated as "How do I get periodic time in order to process requests?"</P><h3>Approach #1: Patching SystemTask, Installing a jGNEFilter, et al</h3><P>One obvious approach is to patch some commonly called trap (for example, <code>SystemTask</code>) or low memory global and use it to periodically check for the queued requests. Historically, this is a very common technique, largely inherited from the original Mac OS which could only run one application at a time.</p><P>The drawback to this approach is that it involves either patching or changing low memory globals, both of which are considered bad. Still, if you have already written an extension that installs a <code>SystemTask</code> patch or a <code>jGNEFilter</code>, this technique might be useful.</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>If you're installing a <code>jGNEFilter</code> you should check out Pete Gontier's jGNE Helper [soon to be] on the developer CD series.</P></TD></TR></TABLE></CENTER><BR><h3>Approach #2: Installing a Device Driver in the Device Manager's Unit Table</h3><P>Another commonly used technique is to install a device driver in the Device Manager's unit table and set the <code>dNeedTime</code> bit in the <code>DCtlEntry</code>. The Mac OS will then periodically call the device with the accRun control code.</p><P>This technique has a number of drawbacks. First, it requires you to install a driver into the unit table, something that is tricky and may involve walking on low memory globals another compatibility liability.</p><P>The second drawback is a bit more obscure. If another device driver (or desk accessory) brings up a modal dialog in its <code>accRun</code> handler, your device driver won't get time, even though the other driver is calling <code>SystemTask</code>. This is because the system explicitly guards against dispatching <code>accRun</code> events reentrantly.  This is in direct contradiction to the statements in the old Technical Note <A HREF = "../dv/dv_19.html">DV 19 - "Drivers &amp; DAs in Need of (a Good) Time."</a></P><P>Incidentally, the other main point of Technote DV 19 -- that traditional Mac OS device drivers should be careful about which heap they're allocating their storage in -- is still very relevant.</p><P>The third drawback is that device drivers of type <code>'DRVR'</code> as we know them under System 7 are rapidly becoming a thing of the past.  The new guidelines for writing native device drivers on PCI machines have explicitly outlawed the practice of making Toolbox calls from a device driver.</p><P>In summary, this approach is only appropriate if you're working on a traditional Mac OS device driver of type <code>'DRVR'</code>, not <code>'ndrv'</code>.</p><h3>Approach #3: Posting a Notification Request</h3><P>This technique is hinted at in <CITE>Inside Macintosh: Devices</CITE> and further described in <A HREF = "../../qa/nw/nw13.html">Macintosh Technical Q &amp;A NW 13</a>. The gist of the idea is to use NMInstall to post a notification request with a response procedure but no sound, icon, string or mark. The Notification Manager polls its internal queue of notification requests at task level and calls your response procedure.</p><P>The technique works well. Contrary to popular belief, the Notification Manager does not serialize all requests and so your response procedure will be called even if there is another notification dialog up.</p><P>One caveat is that your notification response procedure is called in the context of some other application. You should tread lightly!  Be careful about allocating too much memory and don't make assumptions about the current resource chain.</p><P>About the only problem with this approach is that it works against the spirit of the Notification Manager, which is meant as a simple method for notifying users about asynchronous tasks, not as a Poor Droid's Scheduling System.  Before using this technique, make sure you read Technical Note <A HREF = "../tb/tb_39.html">TB 39  "Toolbox Karma."</a></P><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>This is an excellent opportunity to reiterate the advice that you should not leave a notification dialog posted indefinitely. If the user doesn't respond to your notification within a minute or so, you should use <code>NMRemove</code> to cancel it and repost it at some later time. A notification dialog on the screen will prevent the foreground process from executing, which will seriously annoy a user who has left a ray tracer running overnight only to find that "The file server Womble has unexpectedly shut down" and that the ray tracer has unexpectedly not finished. </P></TD></TR></TABLE></CENTER><BR><h3>Approach #4: Application Processing Requests </h3><P>This technique uses an application to process the queued requests in its main event loop. Your interrupt routine puts the request onto a queue in the application's globals and wakes up the application using WakeUpProcess. When the application runs, it looks at the global queue and processes any requests on it.</p><P>If you don't have a suitable application handy,  you can just create a background-only application (BOA) dedicated to this function. You can even put an INIT resource in BOA, as described in <A HREF = "../ps/ps_02.html">Technical Note PS 2 - "Background-Only Applications."</a></P><P>This technique is the best general-purpose method for solving the problem. It involves no trap patches and it doesn't touch low memory.</p><P>The only drawback to this approach is the memory requirements (approximately 50K) if you need a dedicated BOA to process requests. However, if you already have an application running, this technique is definitely the way to go.</p><h3>Approach #5: Open Transport</h3><P>Open Transport provides a good technique for scheduling task level time from interrupt time, namely <code>OTScheduleSystemTask</code>. OpenTransport will run on most modern Macintoshes and provides this service as an adjunct to its networking facilities.</p><P>However, using OpenTransport restricts the systems your code will operate on. The decision as to whether to use this technique, and hence make your software dependent on OpenTransport, is for you to make based on both technical and marketing considerations.</p><h3>Approach #6: Software Interrupts</h3><P>Another approach that will be available in the future is the software interrupt routines, currently provided as part of the PCI driver services library. See <A HREF = "tn1001.html">Technote 1001, "On Power Macintosh Interrupt Management,"</a> for details.</p><P><A HREF="#top">Back to top</A></P><a name="RTFToC3"></a><h2>Summary</h2><P>There are a variety of techniques you can use to process requests received at interrupt time.  The technique you choose depends on a number of factors outlined in this Technote. An application processing the requests on behalf of your interrupt code is the best general-purpose method for solving the problem because it represents the least compatibility liability.</p><P><A HREF="#top">Back to top</A></P><a name="References"></a><h2>References</h2><p><CITE>Inside Macintosh: Operating System Utilities</CITE></p><p><CITE>Inside Macintosh: Devices</CITE></p><p><CITE>Inside Macintosh: Processes</CITE></p><p>Designing PCI Cards and Drivers for Power Macintosh Computers </p><p><A HREF = "../ps/ps_02.html">Technical Note PS 2 - Background-Only Applications</a></p><p>"Be Our Guest: Background-Only Applications in System 7" in <CITE>develop</CITE>  Issue 9.</p><p><A HREF = "../dv/dv_19.html">Technical Note DV 19 - Drivers &amp; DAs in Need of (a Good) Time</a></p><p><A HREF = "../tb/tb_39.html">Technical Note TB 39 - Toolbox Karma</a></p><p><A HREF = "../../qa/nw/nw13.html">Macintosh Technical Q &amp;A NW 13</a></p><p>PCI Device Driver article in <CITE>develop</CITE> (May 1995)</p><BR><P><A HREF="#top">Back to top</A></P>          <A NAME=Downloads></A>                  <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (52K).</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/tn1033.pdf">Download</A></P>               </TD>            </TR>         </TABLE>         <BR><BR><P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER>		<!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1033.html%3Fid%3DDTS10002875-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1033.html%3Fid%3DDTS10002875-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1033.html%3Fid%3DDTS10002875-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>