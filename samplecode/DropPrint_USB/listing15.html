<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>DropPrint USB - /SafeNameRegistry.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxHardwareDrivers-date.html">Hardware & Drivers</a> &gt; <A HREF="javascript:location.replace('index.html');">DropPrint USB</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/HardwareDrivers/idxUSB-date.html" target="_blank">Hardware & Drivers > USB</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">DropPrint USB</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/SafeNameRegistry.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/DropShell.c</option>
<option value="listing2.html">/DropShell.h</option>
<option value="listing3.html">/dropshell.r</option>
<option value="listing4.html">/DSAppleEvents.c</option>
<option value="listing5.html">/DSAppleEvents.h</option>
<option value="listing6.html">/DSGlobals.h</option>
<option value="listing7.html">/DSUserProcs.c</option>
<option value="listing8.html">/DSUserProcs.h</option>
<option value="listing9.html">/DSUtils.c</option>
<option value="listing10.html">/DSUtils.h</option>
<option value="listing11.html">/ListInDialog.c</option>
<option value="listing12.html">/ListInDialog.h</option>
<option value="listing13.html">/ListInDialog.r</option>
<option value="listing14.html">/Prefix.h</option>
<option value="listing15.html">/SafeNameRegistry.c</option>
<option value="listing16.html">/SafeNameRegistry.h</option>
<option value="listing17.html">/TestPrinterClass.c</option>
<option value="listing18.html">/TestPrinterClass.h</option></select>
				</p>
				</form>
				<p><strong><a href="DropPrint_USB.zip">Download Sample</a></strong> (&#147;DropPrint_USB.zip&#148;, 72.5K)<BR>
<strong><a href="DropPrint_USB.dmg">Download Sample</a></strong> (&#147;DropPrint_USB.dmg&#148;, 133.2K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    SafeNameRegistry.c  Contains:  Stub routines for name registry calls  Written by:  G. Poon  Copyright:  &copy; 1998 by Apple Computer, Inc., all rights reserved.  Change History:    25 Mar 98   gp    Added calls to create and remove name registry proc ptrs    18 Mar 98   gp    Created  To Do:*/#ifndef __CODEFRAGMENTS__#include &lt;CodeFragments.h&gt;#endif#ifndef __MIXEDMODE__#include &lt;MixedMode.h&gt;#endif#ifndef __GESTALT__#include &lt;Gestalt.h&gt;#endif#ifndef __ERRORS__#include &lt;Errors.h&gt;#endif#ifndef __DIALOGS__#include &lt;Dialogs.h&gt;#endif#ifndef __SafeNameRegistry__#include &quot;SafeNameRegistry.h&quot;#endif/******************************************************************************  Prototypes ******************************************************************************/// prototypes used to find address of routine in name registry libraryOSErr Find_Symbol(Ptr* pSymAddr, Str255 pSymName, ProcInfoType pProcInfo);pascal OSErr GetSystemArchitecture(OSType *archType);/******************************************************************************  Typedefs ******************************************************************************/// proc typedefs for calling routines in the name registry librarytypedef pascal OSStatus (*RegistryEntryIDInitProcPtr) ( RegEntryID* id );typedef pascal OSStatus (*RegistryCStrEntryLookupProcPtr) ( RegEntryID* searchPointID,       RegCStrPathName* pathName, RegEntryID*foundEntry );typedef pascal OSStatus (*RegistryEntryIterateCreateProcPtr) ( RegEntryIter* cookie );typedef pascal OSStatus (*RegistryEntryIterateDisposeProcPtr) ( RegEntryIter* cookie );typedef pascal OSStatus (*RegistryEntryIterateSetProcPtr) ( RegEntryIter* cookie, RegEntryID *startEntryID );typedef pascal OSStatus (*RegistryEntryIterateProcPtr) ( RegEntryIter *cookie,       RegEntryIterationOp relationship, RegEntryID *foundEntry, Boolean *done );typedef pascal OSStatus (*RegistryEntryIDDisposeProcPtr) ( RegEntryID* id );typedef pascal OSStatus (*RegistryPropertyGetProcPtr) ( RegEntryID *entryID,       RegPropertyName *propertyName, void *propertyValue, RegPropertyValueSize *propertySize );/******************************************************************************  Constants ******************************************************************************/#define  kNoNameRegistryAlert    3000// stack descriptors used in the name registry stub calls to pass params// to the proper routine in the name registry shared libraryenum {  kRegistryEntryIDInitProcInfo = kPascalStackBased  | RESULT_SIZE( SIZE_CODE(sizeof(OSStatus)))  | STACK_ROUTINE_PARAMETER( 1, SIZE_CODE(sizeof( RegEntryID*)))};enum {  kRegistryCStrEntryLookupProcInfo = kPascalStackBased  | RESULT_SIZE( SIZE_CODE(sizeof(OSStatus)))  | STACK_ROUTINE_PARAMETER( 1, SIZE_CODE(sizeof( RegEntryID*)))  | STACK_ROUTINE_PARAMETER( 2, SIZE_CODE(sizeof( RegCStrPathName*)))  | STACK_ROUTINE_PARAMETER( 3, SIZE_CODE(sizeof( RegEntryID*)))};enum {  kRegistryEntryIterateCreateProcInfo = kPascalStackBased  | RESULT_SIZE( SIZE_CODE(sizeof(OSStatus)))  | STACK_ROUTINE_PARAMETER( 1, SIZE_CODE(sizeof( RegEntryIter*)))};enum {  kRegistryEntryIterateDisposeProcInfo = kPascalStackBased  | RESULT_SIZE( SIZE_CODE(sizeof(OSStatus)))  | STACK_ROUTINE_PARAMETER( 1, SIZE_CODE(sizeof( RegEntryIter*)))};enum {  kRegistryEntryIterateSetProcInfo = kPascalStackBased  | RESULT_SIZE( SIZE_CODE(sizeof(OSStatus)))  | STACK_ROUTINE_PARAMETER( 1, SIZE_CODE(sizeof( RegEntryIter*)))  | STACK_ROUTINE_PARAMETER( 2, SIZE_CODE(sizeof( RegEntryID*)))};enum {  kRegistryEntryIterateProcInfo = kPascalStackBased  | RESULT_SIZE( SIZE_CODE(sizeof(OSStatus)))  | STACK_ROUTINE_PARAMETER( 1, SIZE_CODE(sizeof( RegEntryIter*)))  | STACK_ROUTINE_PARAMETER( 2, SIZE_CODE(sizeof( RegEntryIterationOp)))  | STACK_ROUTINE_PARAMETER( 3, SIZE_CODE(sizeof( RegEntryID*)))  | STACK_ROUTINE_PARAMETER( 4, SIZE_CODE(sizeof( Boolean*)))};enum {  kRegistryEntryIDDisposeProcInfo = kPascalStackBased  | RESULT_SIZE( SIZE_CODE(sizeof(OSStatus)))  | STACK_ROUTINE_PARAMETER( 1, SIZE_CODE(sizeof( RegEntryID*)))};enum {  kRegistryPropertyGetProcInfo = kPascalStackBased  | RESULT_SIZE( SIZE_CODE(sizeof(OSStatus)))  | STACK_ROUTINE_PARAMETER( 1, SIZE_CODE(sizeof( RegEntryID*)))  | STACK_ROUTINE_PARAMETER( 2, SIZE_CODE(sizeof( RegPropertyName*)))  | STACK_ROUTINE_PARAMETER( 3, SIZE_CODE(sizeof( void*)))  | STACK_ROUTINE_PARAMETER( 4, SIZE_CODE(sizeof( RegPropertyValueSize*)))};typedef struct{// address of name registry routines  ProcPtr    RegistryEntryIDInitAddr;  ProcPtr    RegistryCStrEntryLookupAddr;  ProcPtr    RegistryEntryIterateCreateAddr;  ProcPtr    RegistryEntryIterateDisposeAddr;  ProcPtr    RegistryEntryIterateSetAddr;  ProcPtr    RegistryEntryIterateAddr;    ProcPtr    RegistryEntryIDDisposeAddr;    ProcPtr    RegistryPropertyGetAddr;  Boolean    hasNameRegistry;      // does this cpu have a name registry  Boolean    checkedForNameRegistry;    // did we check for the name registry already  short    numberOfPrinters;      // total number of printers listed  short    numberOfUSBPrinters;    // total number of USB printers  short    numberOfPorts;        // total number of serial ports on this cpu  Boolean    supportsSerial;        // do we support serial  Boolean    supportsUSB;        // do we support USB// holds index into our STR# rsrc (name registry model path) for each entry in the printer list  short*    modelIndex;} USBGlobals;USBGlobals  gGlobals;/*-----------------------------------------------------------------------------*  NameRegistryInstalled    Desc:    Test to see if the name registry exists on this machine  In:      None  Out:    True if name registry exists else false    History:  18 Mar 98  gp    Added.  *-----------------------------------------------------------------------------*/Boolean  NameRegistryInstalled( void ){  OSErr  err=noErr;    // result from gestalt call  long  result;  // if not our first time then return previous result  if( gGlobals.checkedForNameRegistry == true )    return gGlobals.hasNameRegistry;  else {  // check to see if name registry exists    err = Gestalt(gestaltNameRegistryVersion, &amp;result);    if( err == noErr )      gGlobals.hasNameRegistry = true;    else {      gGlobals.hasNameRegistry = false;  // put up alert if it isn't installed      StopAlert(kNoNameRegistryAlert, nil);    }    gGlobals.checkedForNameRegistry=true;  }  return gGlobals.hasNameRegistry;}/*-----------------------------------------------------------------------------*  SafeRegistryEntryIDInit    Desc:    Stub code for name registry routine 'RegistryEntryIDInit'  In:      id - pointer to a RegEntryID to initialize  Out:    returns any errors which may have occur    History:  18 Mar 98  gp    Added.  *-----------------------------------------------------------------------------*/OSStatus SafeRegistryEntryIDInit(RegEntryID *id){  OSStatus  anErr=-1;        // return value  if( (Ptr) gGlobals.RegistryEntryIDInitAddr != (Ptr) nil )    anErr = ((RegistryEntryIDInitProcPtr) gGlobals.RegistryEntryIDInitAddr) (id);  return anErr;}/*-----------------------------------------------------------------------------*  SafeRegistryCStrEntryLookup    Desc:    Stub code for name registry routine 'RegistryCStrEntryLookup'  In:      searchPointID - the RegEntryID to start searching from        pathName - the cstring path of the entry to find        foundEntry - where to store the found entry  Out:    foundEntry - the RegEntryID of any found entry        returns any errors which may have occur    History:  18 Mar 98  gp    Added.  *-----------------------------------------------------------------------------*/OSStatus SafeRegistryCStrEntryLookup( RegEntryID *searchPointID, RegCStrPathName *pathName, RegEntryID *foundEntry){  OSStatus  anErr=-1;        // return value  // now call it  if( (Ptr) gGlobals.RegistryCStrEntryLookupAddr != (Ptr) nil )    anErr = ((RegistryCStrEntryLookupProcPtr) gGlobals.RegistryCStrEntryLookupAddr) (searchPointID, pathName, foundEntry);  return anErr;}/*-----------------------------------------------------------------------------*  SafeRegistryEntryIterateCreate    Desc:    Stub code for name registry routine 'RegistryEntryIterateCreate'  In:      id - pointer to a RegEntryIter to initialize  Out:    returns any errors which may have occur    History:  18 Mar 98  gp    Added.  *-----------------------------------------------------------------------------*/OSStatus SafeRegistryEntryIterateCreate(RegEntryIter *cookie){  OSStatus  anErr=-1;        // return value  if( (Ptr) gGlobals.RegistryEntryIterateCreateAddr != (Ptr) nil )    anErr = ((RegistryEntryIterateCreateProcPtr) gGlobals.RegistryEntryIterateCreateAddr) (cookie);  return anErr;}/*-----------------------------------------------------------------------------*  SafeRegistryEntryIterateDispose    Desc:    Stub code for name registry routine 'RegistryEntryIterateDispose'  In:      cookie - iterator to dispose  Out:    returns any errors which may have occur    History:  18 Mar 98  gp    Added.  *-----------------------------------------------------------------------------*/OSStatus SafeRegistryEntryIterateDispose(RegEntryIter *cookie){  OSStatus  anErr=-1;        // return value  if( (Ptr) gGlobals.RegistryEntryIterateDisposeAddr != (Ptr) nil )    anErr = ((RegistryEntryIterateDisposeProcPtr) gGlobals.RegistryEntryIterateDisposeAddr) (cookie);  return anErr;}/*-----------------------------------------------------------------------------*  SafeRegistryEntryIterateSet    Desc:    Stub code for name registry routine 'RegistryEntryIterateSet'  In:      cookie - pointer to iterator to set        startEntryID - name registry entry to start iterating from  Out:    returns any errors which may have occur    History:  18 Mar 98  gp    Added.  *-----------------------------------------------------------------------------*/OSStatus SafeRegistryEntryIterateSet(RegEntryIter *cookie, RegEntryID *startEntryID){  OSStatus  anErr=-1;        // return value  if( (Ptr) gGlobals.RegistryEntryIterateSetAddr != (Ptr) nil )    anErr = ((RegistryEntryIterateSetProcPtr) gGlobals.RegistryEntryIterateSetAddr) (cookie, startEntryID);  return anErr;}/*-----------------------------------------------------------------------------*  SafeRegistryEntryIterate    Desc:    Stub code for name registry routine 'RegistryEntryIterate'  In:      cookie - iterator to use        relationship - direction to iterate        foundEntry - where to store next name entry found        done - tells if we're done with iteration  Out:    foundEntry - RegEntryID of name entry found        done - true if no more entries found        returns any errors which may have occur    History:  18 Mar 98  gp    Added.  *-----------------------------------------------------------------------------*/OSStatus SafeRegistryEntryIterate(RegEntryIter *cookie, RegEntryIterationOp relationship,     RegEntryID *foundEntry, Boolean *done){  OSStatus  anErr=-1;        // return value  if( (Ptr) gGlobals.RegistryEntryIterateAddr != (Ptr) nil )    anErr = ((RegistryEntryIterateProcPtr) gGlobals.RegistryEntryIterateAddr) (cookie, relationship, foundEntry, done);  return anErr;}/*-----------------------------------------------------------------------------*  SafeRegistryEntryIDDispose    Desc:    Stub code for name registry routine 'RegistryEntryIDDispose'  In:      id - RegEntryID to dispose  Out:    returns any errors which may have occur    History:  18 Mar 98  gp    Added.  *-----------------------------------------------------------------------------*/OSStatus SafeRegistryEntryIDDispose(RegEntryID *id){  OSStatus  anErr=-1;        // return value  if( (Ptr) gGlobals.RegistryEntryIDDisposeAddr != (Ptr) nil )    anErr = ((RegistryEntryIDDisposeProcPtr) gGlobals.RegistryEntryIDDisposeAddr) (id);  return anErr;}/*-----------------------------------------------------------------------------*  SafeRegistryPropertyGet    Desc:    Stub code for name registry routine 'RegistryPropertyGet'  In:      entryID - RegEntryID value that identifies a name entry        propertyName - name of the property        propertyValue - buffer to hold the property        propertySize - size of the property buffer  Out:    propertySize - size of the property retrieved        returns any errors which may have occur    History:  18 Mar 98  gp    Added.  *-----------------------------------------------------------------------------*/OSStatus SafeRegistryPropertyGet( RegEntryID *entryID, RegPropertyName *propertyName,     void *propertyValue, RegPropertyValueSize *propertySize){  OSStatus  anErr=-1;        // return value  if( (Ptr) gGlobals.RegistryPropertyGetAddr != (Ptr) nil )    anErr = ((RegistryPropertyGetProcPtr) gGlobals.RegistryPropertyGetAddr) (entryID, propertyName, propertyValue, propertySize);  return anErr;}/*-----------------------------------------------------------------------------*  GetSystemArchitecture    Desc:    Taken from         DTS Technote 1077 &quot;Calling CFM Code from Classic 68K Code&quot;.        Returns architect of current cpu during runtime.  In:      archType - address of variable to hold architect type  Out:    archType - returns architect of current cpu pointed by this variable        Also returns any errors    History:  18 Mar 98  gp    Added.  *-----------------------------------------------------------------------------*/pascal OSErr GetSystemArchitecture(OSType *archType){  long sSysArchitecture = 0; // static so we only Gestalt once.  OSErr tOSErr = noErr;    *archType = kAnyCFragArch;   // assume wild architecture    // If we don't know the system architecture yet...  if (sSysArchitecture == 0)    // ...Ask Gestalt what kind of machine we are running on.    tOSErr = Gestalt(gestaltSysArchitecture, &amp;sSysArchitecture);    if (tOSErr == noErr) // if no errors  {    if (sSysArchitecture == gestalt68k)   // 68k?       *archType = kMotorola68KCFragArch;       else if (sSysArchitecture == gestaltPowerPC) // PPC?       *archType = kPowerPCCFragArch;           else       tOSErr = gestaltUnknownErr;  // who knows what might be next?  }  return tOSErr;}/*-----------------------------------------------------------------------------*  Find_Symbol    Desc:    Taken from         DTS Technote 1077 &quot;Calling CFM Code from Classic 68K Code&quot;.        Returns the address of a routine in a shared library  In:      pSymAddr - address of variable to hold returned address        pSymName - a pstring of the name of the routine        pProcInfo - stack descriptor for the routine  Out:    pSymAddr - the address of the routine pointed by this variable        Also returns any errors    History:  18 Mar 98  gp    Added.  *-----------------------------------------------------------------------------*/OSErr Find_Symbol(Ptr* pSymAddr, Str255 pSymName, ProcInfoType pProcInfo){  CFragConnectionID sCID = 0;  OSType sArchType = kAnyCFragArch;  OSErr sOSErr = noErr;  Str255 errMessage;  Ptr mainAddr;  CFragSymbolClass symClass;      ISAType tISAType;        ProcInfoType used = pProcInfo;  // compiler warning    if( NameRegistryInstalled() == false )    return -1;      // return general error - gp    if (sArchType == kAnyCFragArch)  // if architecture is undefined...  {    sCID = 0;     // ...force (re)connect to library    sOSErr = GetSystemArchitecture(&amp;sArchType); // determine architecture    if (sOSErr != noErr)       return sOSErr; // OOPS!  }    if (sArchType == kMotorola68KCFragArch) // ...for CFM68K      tISAType = kM68kISA | kCFM68kRTA;  else if (sArchType == kPowerPCCFragArch)  // ...for PPC CFM      tISAType = kPowerPCISA | kPowerPCRTA;  else    sOSErr = gestaltUnknownErr; // who knows what might be next?    if (sCID == 0) // If we haven't connected to the library yet...  {    // NOTE: The library name is hard coded here.    // I try to isolate the glue code, one file per library.    // I have had developers pass in the Library name to allow    // plug-in type support. Additional code has to be added to    // each entry points glue routine to support multiple or    // switching connection IDs.    sOSErr = GetSharedLibrary(&quot;\pNameRegistryLib&quot;, sArchType, kLoadCFrag,           &amp;sCID, &amp;mainAddr, errMessage);    if (sOSErr != noErr)       return sOSErr; // OOPS!  }    // If we haven't looked up this symbol yet...  if ((Ptr) *pSymAddr == (Ptr) kUnresolvedCFragSymbolAddress)      {    // ...look it up now    sOSErr = FindSymbol(sCID,pSymName,pSymAddr,&amp;symClass);    if (sOSErr != noErr) {// in case of error...     // ...clear the procedure pointer       *(Ptr*) &amp;pSymAddr = (Ptr) kUnresolvedCFragSymbolAddress;    }    #if !GENERATINGCFM // if this is classic 68k code...     *pSymAddr = (Ptr)NewRoutineDescriptorTrap((ProcPtr) *pSymAddr,            pProcInfo, tISAType);  // ...create a routine descriptor...    #endif  }  return sOSErr;}/*-----------------------------------------------------------------------------*  InitNameRegistryPtrs    Desc:    Create all the proc ptrs to Name Registry calls we will        need  In:      None  Out:    None    History:  25 Mar 98  gp    Created  *-----------------------------------------------------------------------------*/void  InitNameRegistryPtrs( void ){  OSStatus  anErr=noErr;        // error code for Find_Symbol and name registry call  if( NameRegistryInstalled() == true) {    anErr = Find_Symbol( (Ptr*) &amp;gGlobals.RegistryEntryIDInitAddr,         &quot;\pRegistryEntryIDInit&quot;, kRegistryEntryIDInitProcInfo );    anErr = Find_Symbol( (Ptr*) &amp;gGlobals.RegistryCStrEntryLookupAddr,         &quot;\pRegistryCStrEntryLookup&quot;, kRegistryCStrEntryLookupProcInfo );    anErr = Find_Symbol( (Ptr*) &amp;gGlobals.RegistryEntryIterateCreateAddr,         &quot;\pRegistryEntryIterateCreate&quot;, kRegistryEntryIterateCreateProcInfo );    anErr = Find_Symbol( (Ptr*) &amp;gGlobals.RegistryEntryIterateDisposeAddr,         &quot;\pRegistryEntryIterateDispose&quot;, kRegistryEntryIterateDisposeProcInfo );    anErr = Find_Symbol( (Ptr*) &amp;gGlobals.RegistryEntryIterateSetAddr,         &quot;\pRegistryEntryIterateSet&quot;, kRegistryEntryIterateSetProcInfo );    anErr = Find_Symbol( (Ptr*) &amp;gGlobals.RegistryEntryIterateAddr,         &quot;\pRegistryEntryIterate&quot;, kRegistryEntryIterateProcInfo );    anErr = Find_Symbol( (Ptr*) &amp;gGlobals.RegistryEntryIDDisposeAddr,         &quot;\pRegistryEntryIDDispose&quot;, kRegistryEntryIDDisposeProcInfo );    anErr = Find_Symbol( (Ptr*) &amp;gGlobals.RegistryPropertyGetAddr,         &quot;\pRegistryPropertyGet&quot;, kRegistryPropertyGetProcInfo );  }}/*-----------------------------------------------------------------------------*  RemoveNameRegistryPtrs    Desc:    Remove all the proc ptrs we created for Name Registry calls  In:      None  Out:    None    History:  25 Mar 98  gp    Created  *-----------------------------------------------------------------------------*/void  RemoveNameRegistryPtrs(void){    // dispose of proc ptrs      if( gGlobals.RegistryEntryIDInitAddr != nil )    DisposeRoutineDescriptor( (struct RoutineDescriptor *) gGlobals.RegistryEntryIDInitAddr);    if( gGlobals.RegistryCStrEntryLookupAddr != nil )    DisposeRoutineDescriptor( (struct RoutineDescriptor *) gGlobals.RegistryCStrEntryLookupAddr);    if( gGlobals.RegistryEntryIterateCreateAddr != nil )    DisposeRoutineDescriptor( (struct RoutineDescriptor *) gGlobals.RegistryEntryIterateCreateAddr);    if( gGlobals.RegistryEntryIterateDisposeAddr != nil )    DisposeRoutineDescriptor( (struct RoutineDescriptor *) gGlobals.RegistryEntryIterateDisposeAddr);    if( gGlobals.RegistryEntryIterateSetAddr != nil )    DisposeRoutineDescriptor( (struct RoutineDescriptor *) gGlobals.RegistryEntryIterateSetAddr);    if( gGlobals.RegistryEntryIterateAddr != nil )    DisposeRoutineDescriptor( (struct RoutineDescriptor *) gGlobals.RegistryEntryIterateAddr);    if( gGlobals.RegistryEntryIDDisposeAddr != nil )    DisposeRoutineDescriptor( (struct RoutineDescriptor *) gGlobals.RegistryEntryIDDisposeAddr);    if( gGlobals.RegistryPropertyGetAddr != nil )    DisposeRoutineDescriptor( (struct RoutineDescriptor *) gGlobals.RegistryPropertyGetAddr);}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/DropPrint_USB/listing15.html%3Fid%3DDTS10000288-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/DropPrint_USB/listing15.html%3Fid%3DDTS10000288-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/DropPrint_USB/listing15.html%3Fid%3DDTS10000288-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>