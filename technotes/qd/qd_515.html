<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><html><head><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note QD515: Color QuickDraw Q&amp;As</title><meta name="keywords" content="Mac OS 8 Color QuickDraw questions dithering PICTs CopyBits OpenCPicture"><meta name="Description" content="Technical Note QD515: This Technical Note contains a collectionof archived Q&amp;As relating to Color Quickdraw--questions sentthe Developer Support Center (DSC) along with answers fromthe DSC engineers. Archived Q&amp;As include: Color QuickDrawnot available to 68000 Macintosh models; Check 'cicn' IDif menu icons are tiny; Color QuickDraw and large pixmaps;Getting a single scan line from a PICT file; Determiningpixel depth from PICT files; Gestalt 'qdrw' selector bugand workaround; BitsToRgn and MPW BitMapToRegionGlue; andMacintosh Color QuickDraw CalcCMask and SeedCFill clarified."><meta name="categories" content="QuickDraw"><meta name="week-posted" content="Oct 1, 1990 - Oct 5, 1990"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002737" title="Color QuickDraw Q&As"></a><a name="top"></A><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note QD515</div>
<div id="pageheadsub">Color QuickDraw Q&amp;As</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->										<p id="menutext"><A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><p id="introtext">This Technical Note contains a collection of archived Q&amp;As relating to a specific topic - questions sent the Developer Support Center (DSC) along withanswers from the DSC engineers. Current Q&amp;As can be found on the <a href="../../qa/index.html">Macintosh Technical Q&amp;As web site</a>.</p><!-- end_intro_text --><!-- begin_date --><h3 align=center>[Oct 01 1990]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR>          <!-- begin_content --><a name=Section1></A><H2>Color QuickDraw not available to 68000 Macintosh models</h2><p>Date Written:   2/4/93</p><p>Last reviewed: 3/17/93</p><p>Inside Macintosh Volume VI says Color QuickDraw is built into System 7, butwhen I use <code>Gestalt</code> to check for Color QuickDraw on a Macintosh PowerBook 100running System 7, the call returns 0 in <code>QDversion</code>. What's wrong?</p><p>The Color QuickDraw routines were written in 68020 assembly, meaning that onlyMacintosh models with 68020 and later CPUs have access to Color QuickDraw.Models such as the Macintosh SE, Macintosh Classic, and PowerBook 100 can useonly Classic QuickDraw. However, this isn't such a bad thing because theprocessing power required to run Color QuickDraw would be an enormous burden onthe 68000 machines.</p><p>The bulk of Color QuickDraw routines reside in the larger ROMs of models usingthe 68020 and greater CPUs, thus taking the burden away from system software.However, if changes have to be made to Color QuickDraw (usually in the form ofpatches) they reside in system software.</p><P><A HREF="#top">Back to top</A></p><H2>Check 'cicn' ID if menu icons are tiny</h2><p>Date Written:   2/16/93</p><p>Last reviewed: 7/2/93</p><p>The icons that appear in our application's menu lists are very, very small. Itlooks like they're 8 x 8 (scaled) instead of the standard 16 x 16. Can you tellfrom our test code why this is happening?</p><p>This was a wild one! What's causing the weird behavior is that you have a<code>'cicn'</code> resource with ID&nbsp;=&nbsp;256 that's smaller than 32 x 32. When theMDEF finds such an icon, it uses it to size the area to use for the menu icons.So, for your application the solution is either to change the 'cicn' to belarger (32 x 32) or to give it a different ID.</p><P><A HREF="#top">Back to top</A></p><H2>Color QuickDraw and large pixmaps</h2><p>Date Written:   3/11/93</p><p>Last reviewed: 6/24/93</p><p>Somewhere in QuickDraw, a routine is using the 14th bit of the <code><code>rowBytes</code></code> field(the 15th is used to differentiate a pixmap from a bitmap) and it reallyshouldn't. This is a problem now that it's so easy to create large pixmaps of4096 32-bit pixels or more. What's causing the problem and what's therecommended solution for handling large pixmaps?</p><p>This is a long story. It's described in <cite>Inside Macintosh</cite> Volumes V and VI butwe'll summarize it here.</p><p>Color QuickDraw allows you to pass one of three addresses to <code>CopyBits</code>: theaddress of a bitmap, the address of a pixmap, or the address of the pixmaphandle of a port. The first two conditions (bit and pixmap) are determined bybit 15 of <code>rowBytes</code>: if the bit isn't set, the address points to a bitmap;otherwise, it points to a pixmap. The third case is the problem here. A colorport's <code>portVersion</code> field is expected to be set to 0xC000, so after decidingit's dealing with a possible pixmap <code>CopyBits</code> checks bit 14 and if it's set itassumes it got the address of the pixmap handle in a <code>CGrafPort</code> and proceeds todereference it in order to get the real address of the pixmap.</p><p>Today's applications have trouble with this because they must either refuse tocreate pixmaps as big as users want or cause crashes by confusing <code>CopyBits</code> intodereferencing the base address of the pixmap if <code>rowBytes</code> exceeds theestablished limit of less than 0x4000.</p><p>Engineering is studying future solutions. It's possible that a future QuickDrawrelease will support pixmap with a <code>rowBytes</code> constant value indicating that thereal <code>rowBytes</code> is contained in the planeBytes field instead. You might think ofcases where this is also going to cause problems but the problems probably areless important than the limitation being overcome.</p><p>For the present, the solution depends on the conditions under which the problemaffects you. If you're writing an application, the solution could be to patch<code>CopyBits</code> and call <code>DrawPicture</code>. When <code>CopyBits</code> is called while a picture is beingdrawn the source is a pixmap; if <code>rowBytes</code> is too big, your application couldsplit the job banding the image vertically until the resulting <code>rowBytes</code> valuesfall within range. With a little debugging it would be possible to find where<code>CopyBits</code> calls the bit/pixmap/port checking routine and bypass that, given thatthe actual routine doing the blitting doesn't have problems dealing withpixmaps of less than 0x8000 <code>rowBytes</code>.</p><p>Another possibility is to call <code>StdBits</code> directly since it doesn't mind dealingwith larger than legal <code>rowBytes</code>. The problem here is that the destination isimplied and the application has to make sure that everything is all right. Alsoif the destination spans multiple devices the application must divide the task,targeting each device at the time. See the <code>DeviceLoop</code> procedure in InsideMacintosh Volume VI for ideas on this.</p><p>To recap: The limitation of <code>rowBytes</code> is becoming increasingly painful, now thatapplications can easily create pixmaps (and PICTs) that exceed the limit of0x4000. It's possible for an application to patch <code>CopyBits</code> in order to workaround this limitation but you have to decide what is appropriate for each setof conditions.</p><P><A HREF="#top">Back to top</A></p><H2>Animation speed on the Macintosh</h2><p>Date written:  1/18/93</p><p>Last reviewed:  4/1/93</p><p>How can I get reasonably fast animation on Macintosh models? So far, I'vecreated off-screen pixmaps with the image and mask, and an extra off-screenpixmap for use in restoring the original picture. However, <code>CopyPix</code> is still tooslow. I had to write my own <code>CopyPix</code> routine in assembly, which works great. ButI can't help wondering how Apple expected fast animation to be accomplished.</p><p>You're certainly right that the way to increase performance is by off-screendrawing and QuickDraw's <code>CopyBits</code> procedure. The key information that's usefulto you is in the Macintosh Technical Note "Of Time and Space and -CopyBits."This tech note covers some of the factors affecting <code>CopyBits</code> and what can bedone to improve the speed of calling <code>CopyBits</code>.</p><p>Just to mention some of the factors that might improve the speed of calling<code>CopyBits</code>: Avoid color mapping, or even try faking out color mapping by settingyour <code>ctSeed</code> to be the same. Alignment of pixels in the source map relative totheir alignment to the destination pixel map can be important. If the sourceand destination rectangles are different sizes, <code>CopyBits</code> has to scale thecopied image, which slows it down a lot. Also dithering and bit depth haseffect on the speed of <code>CopyBits</code>.</p><p>Whereas QuickDraw often trades performance for flexibility, there are timeswe'd just as soon trade flexibility for performance. In these cases, we can achieve tremendous gains in speed by writing custom routines to draw to off-screen worlds. I recommend the article "Drawing in GWorlds for speed and versatility" (<i>develop,</i> issue 10) which shows you exactly how to do that.</p><p>Many developers want to go beyond the speed of QuickDraw. Writing directly tothe screen can allow you to create faster animation and graphics than possiblewith QuickDraw. However, Apple has always maintained that writing to videomemory is unsupported, since it may cause your application to break on futuresystems. If you write directly to the screen, your application will forfeit theuse of many Toolbox managers and will put future compatibility at risk. Sincemost applications require the Window Manager and other basic Macintoshmanagers, writing to the screen is for only a few specialized applications,such as video games and some animation packages that compete on the quality andspeed of graphics. The most important thing to remember is <i>don't writedirectly to the screen if you don't have to.</i> But if you do need to, anarticle that provides some guidelines is "Graphical Truffles: Writing Directlyto the Screen," <i>develop,</i> Issue 11.</p><p>Following are some additional articles that animation and game developers find useful:</p><ol type="1" start="1">	<li>"Palette Manager Animation," <i>develop,</i> Issue 5.</li>	<li>"Using the Palette Manager Off-Screen," <i>develop,</i> Issue 10.</li>	<li>"QuickDraw's <code>CopyBits</code> Procedure: Better Than Ever in System 7.0," <i>develop,</i> Issue 6.</li>	<li>"Graphical Truffles: Animation at a Glance," <i>develop,</i> Issue 12.</li></ol><p>Also, some sample code that can speed your development is given as<A HREF = "downloads/SC.015.Offscreen.sea.hqx">SC.015.Offscreen</a> and <A HREF = "downloads/SC.016.OffSample.sea.hqx">SC.016.OffSample</a> (Dev CD Jan 93:Technical Documentation:Sample Code: Macintosh Sample Code).</p><p>Animation on the Macintosh does take some work. Nevertheless, we've seen somepretty amazing animations developed on the Macintosh.</p><P><A HREF="#top">Back to top</A></p><H2>Inside Macintosh Volume V PnPixPat &amp; BkPixPat doc fix</h2><p>Date written:  12/4/92</p><p>Last reviewed:  3/1/93</p><p><i>Inside Macintosh</i> Volume V (page 103) says that when a PICT patternopcode (for instance, 0x0012) comes along, and the pattern isn't a ditherpattern, the full <code>pixMap</code> data follows the old-style 8-byte pattern. The fullpixMap data structure described on page 104 indicates that a <code>pixMap</code> starts withan unused long (<code>baseAddr</code> placeholder), followed by the <code>rowBytes</code>, bounds, and soon. However, looking at the Pict.r file on the October 1992 Developer CD, atthe same opcode (<code>BkPixPat</code> == 0x0012), the first data field after the old-stylepattern (hex <code>string[8]</code>) is the <code>rowBytes</code> field (broken down into threebitstrings). The <code>baseAddr</code> placeholder field isn't there. Which is correct?</p><p>The <i>Inside Macintosh</i> documentation on pages V-103 and V-104 is wrong.The Pict.r file correctly describes the format of the <code>PnPixPat</code> and <code>BkPixPat</code> opcodes. So there shouldn't be a <code>baseAddr</code> field in the <code>pixMap</code> record of a pattern as stored in the <code>PnPixPat</code> of a PICT. However, the <code>baseAddr</code> does occur in a <code>'ppat'</code> resource as described on page V-79. Thanks for pointing out this discrepancy.</p><P><A HREF="#top">Back to top</A></p><H2>Disabling Macintosh Color QuickDraw for testing</h2><p>Date written:  9/14/92</p><p>Last reviewed:  6/14/93</p><p>Is there an easy way to disable Color QuickDraw on a Macintosh? I want to dothis for testing our application, to make sure it works correctly on a machinewithout Color QuickDraw.</p><p>There's no easy, or perhaps even hard way to disable features built into thesystem software your particular machine requires. It's designed to work well,not to be toggle-able.</p><p>Even the hard way isn't a sure thing - trying to patch out all the ColorQuickDraw traps could confuse the rest of the system software, which internallymay use undocumented routines to accomplish its tasks.</p><p>The easiest way to test on non-Color QuickDraw machines is to get one.Fortunately, the machines without Color QD are the lowest end of the Macintoshprice spectrum - such as the Macintosh Classic, PowerBook 100, and Macintosh SE.You can probably rent or borrow one of these if the prices don't fit yourcurrent budget.</p><P><A HREF="#top">Back to top</A></p><H2>Using a Macintosh PICT file that's larger than available memory</h2><p>Date Written:  6/18/90</p><p>Last reviewed:  6/14/93</p><p>How can I read a 2 MB PICT file into only 1 MB of memory?</p><p>You can't read it in since you don't have enough memory, but drawing thepicture contained in the file using a technique called "spooling" increases your chances of using a 2 MB PICT file with 1 MB memory. Spooling is documented in the Color QuickDraw chapter of <i>Inside Macintosh</i> Volume V (pages 88-89).</p><P><A HREF="#top">Back to top</A></p><H2>Getting a single scan line from a PICT file</h2><p>Date Written:  6/18/90</p><p>Last reviewed:  6/14/93</p><p>Is there any way to obtain a particular scan line from a PICT file?</p><p>A PICT file may contain more than just pixmaps, so getting one scan line out ofit is not possible. The file may also contain other elements that overlap, suchas rects and arcs. The only way to obtain a single line is to draw itoff-screen and then, once the whole image is in memory, you can go and studyindividual pixels.</p><P><A HREF="#top">Back to top</A></p><H2>Determining pixel depth from PICT files</h2><p>Date Written:  6/20/90</p><p>Last reviewed:  9/17/91</p><p>How do you find out the pixel size of a PICT file on the disk?</p><p>A picture is by nature independent of depth. For example, you can have apicture containing <code>DrawRects</code> and <code>LineTos</code> and therefore lacking any inforegarding depth.</p><p>On the other hand, if the picture you are looking at has pixmap opcodes in it,then each pixmap contains its own pixel size and in this case a picture canhave a number of depths associated with it.</p><p>If you want to see the pixel size for each pixmap opcode in a picture, replaceall the bottleneck routines and every time the <code>bitsProc</code> is called you can seethe pixmap and get the info out. Since the picture is in a file, you can usethe spooling technique described in the QuickDraw chapter in <i>InsideMacintosh</i> Volume V. Be ready to deal with multiple, possibly different,pixmaps as well as direct pixmaps if the picture was created under 32-bit QuickDraw.</p><p>"KnowsPICT," on the <i>Developer CD Series</i> disc, extracts this kind ofinformation. The System 7.0 Picture Utilities package gets this information too.</p><P><A HREF="#top">Back to top</A></p><H2>BitMapToRgn for non-Color QuickDraw Macintosh models</h2><p>Date Written:  11/9/90</p><p>Last reviewed:  6/14/93</p><p>Is <code>_BitmapToRegion</code> available on any pre-System 7 non-Color QuickDrawconfigurations such as the Macintosh Classic, Plus, or SE? If not, is source ora library module available so that I don't have to take the time andcompatibility risk of rolling my own?</p><p><code>BitMapToRegion</code> works on pre-color Macintosh systems. You can license <code>BitMapToRegion</code> from</p><p>Software Licensing</p><p>Apple Computer, Inc.</p>    <p>20525 Mariani Ave. MS:38-I</p>    <p>Cupertino, CA 95014</p>    <p>Phone:(408) 974-4667</p><P><A HREF="#top">Back to top</A></p><H2>Macintosh QuickDraw pixel map stack requirements</h2><p>Date Written:  12/3/90</p><p>Last reviewed:  5/21/91</p><p>What are the guidelines for determining how much of an image <code>CopyBits</code> can copyto a Macintosh pixel map at one time, given a particular set of characteristicsfor the source map and the destination map and given how much stack space isavailable? For example, say that we have an 8-bit-deep pixmap to be copied to a32-bit-deep pixMap using the <code>ditherCopy</code> mode and expanded by a factor of 4, andwe have 45K of stack space.</p><p><code>CopyBits</code>' stack requirement depends on the width of each scan line (<code>rowBytes</code>).The rule of thumb is that you need at least as much stack as the <code>rowBytes</code> valuein your image (which can be huge with 32-Bit QuickDraw), with the followingadditional modifiers: Add an additional <code>rowBytes</code> for dithering; add anadditional <code>rowBytes</code> for any stretching (source rect != dest rect); add anadditional <code>rowBytes</code> for any color map changing; add an additional <code>rowBytes</code> forany color aliasing. The stack space you need is roughly five times the <code>rowBytes</code>of your image. In general, you're better off processing narrower scan lines.Reducing the vertical size will not affect stack requirements. Narrow, tallbands (if you can use them) will reduce the stack requirements.</p><P><A HREF="#top">Back to top</A></p><H2>Color and non-Color QuickDraw trap dispatch differences</h2><p>Date Written:  1/28/91</p><p>Last reviewed:  6/14/93</p><p>Why does a call to <code>RGBForeColor</code> cause a corruption of the stack withoutresulting in an unimplemented trap error on non-Color QuickDraw Macintosh systems?</p><p>The trap dispatcher on Color QuickDraw and non-Color QuickDraw machines aredifferent. If you look at page 89 of <i>Inside Macintosh</i> Volume I, you'll see the toolbox trap word format as it was in the days before Color QuickDraw. Bit 9 was "reserved for future use" and was ignored by the trap dispatcher, and so it was normally set to 0. That means that valid toolbox traps could either look like $A8XX or $A9XX as long as the auto-pop bit was turned off. Color QuickDraw machines have a trap dispatcher that uses that reserved bit to allow for more trap words, and therefore it has a much larger trap dispatch table. Color QuickDraw traps have that reserved bit set, so those traps look like $AAXX or $ABXX.</p><p>When a non-Color QuickDraw machine tests to see if a trap is implemented ornot, it just checks the trap dispatch table to see if a routine is implementedfor that trap or not. Because the reserved bit is ignored, trap words that looklike $AAXX are treated as equivalent to $A8XX and trap words that look like$ABXX are treated as equivalent to $A9XX. The trap word for RGBForeColor is$AA14. If you call <code>RGBForeColor</code> on a non-Color QuickDraw machine, $AA14 istreated as $A814, which is the trap word for <code>SetFractEnable</code>. <code>SetFractEnable</code> isimplemented on 128K ROM machines or greater, so no unimplemented trap error occurs.</p><p>If you look at recent DTS sample programs, such as the Utilities sample(SC.025.Utilities, which you can find on AppleLink in Developer Support and onthe current developer CD), you'll see a routine in Utilities.c called<code>TrapExists</code>. It takes into account the size of the trap dispatch table so thatyou can tell in one call whether a routine is implemented or not regardless ofwhether it's a Color QuickDraw trap or not and regardless of what kind ofMacintosh you're running on.</p><p>Under system software version 7.0, the trap dispatcher is modified on non-ColorQuickDraw machines so that many Color QuickDraw traps are implemented and workas well as they can in black and white.</p><P><A HREF="#top">Back to top</A></p><H2>Macintosh OpenCPicture 72-dpi calculation bug</h2><p>Date Written:  2/12/91</p><p>Last reviewed:  6/14/93</p><p>The 32-Bit QuickDraw <code>_OpenCPicture</code> call incorrectly calculates the 72-dpi framewidth if the height of the native resolution srcRect exceeds 910 dots. To workaround this problem, I calculate the 72-dpi frame independently, and store itin the <code>PicHandle</code> returned by <code>_OpenCPicture</code>.</p><p>It's a known bug that under Macintosh system software versions 6.0.5 and 6.0.7with 32-Bit QuickDraw 1.2, <code>OpenCPicture</code> doesn't properly calculate the rightcoordinate of the 72-dpi <code>picFrame</code> if the height of the <code>srcRect</code> (nativeresolution rectangle) multiplied by 72 exceeds $0000FFFF. That works out to amaximum height of 910 pixels, just as you found. This bug is fixed in System7.0, but <code>gestaltQuickdrawVersion</code> returns $0220 both under system softwareversions 6.0.5 and 7.0, so you can't tell whether the bug is fixed that way.Instead, you should use Gestalt with the <code>gestaltSystemVersion</code> selector. If thereturned value is $0700 or greater, then let <code>OpenCPicture</code> handle the <code>picFrame</code>calculation; otherwise you should do the calculation yourself.</p><P><A HREF="#top">Back to top</A></p><H2>GetGWorldPixMap bug and workaround</h2><p>Date Written:  3/12/91</p><p>Last reviewed:  6/14/93</p><p>Why does <code>GetGWorldPixMap</code> (when called on a Macintosh II, IIcx, or IIx runningsystem software version 6.0.5 or 6.0.7 with 32-Bit QuickDraw 1.2) return acombination of the device field (two bytes) and the first two bytes of the<code>portPixMap</code> field? Is this a bug?</p><p>Your analysis of <code>GetGWorldPixMap</code> is exactly right: It doesn't work correctly insystem software version 6.0.5 and 6.0.7 with 32-Bit QuickDraw 1.2. It returns avalue that's two bytes before the value it's supposed to return.</p><p>The solution is to use <code>GWorldPtr</code>-&gt;<code>portPixMap</code> instead of <code>GetGWorldPixMap</code>. It's safe to do this, but you should use <code>GetGWorldPixMap</code> under System 7. Not only is the bug fixed there, but dereferencing the port is dangerous under System 7 because it may not be <code>CGrafPort</code>. Use Gestalt with the <code>gestaltQuickdrawVersion</code> selector to determine whether you can use <code>GetGWorldPixMap</code>. If <code>Gestalt</code> returns a value from <code>gestalt8BitQD</code> ($0100) through <code>gestalt32BitQD12</code> ($0220), then <code>GetGWorldPixMap</code> either doesn't exist or is the buggy version. If it returns <code>gestalt32BitQD13</code> ($0230) or higher, then <code>GetGWorldPixMap</code> does exist and works correctly. Interestingly, <code>GetGWorldPixMap</code> can be called on a black-and-white QuickDraw machine under System 7. It returns a handle to a structure which should be treated as a <code>BitMap</code> structure, though there are some undocumented fields after the normal <code>BitMap</code> fields. To tell whether <code>GetGWorldPixMap</code> is available on a black-and-white QuickDraw machine, you must check the system software version by calling <code>Gestalt</code> with the <code>gestaltSystemVersion</code> selector. If it returns $0700 or higher, <code>GetGWorldPixMap</code> is available.</p><P><A HREF="#top">Back to top</A></p><H2>System 7 TextMode problem and workaround</h2><p>Date Written:  6/12/91</p><p>Last reviewed:  8/13/91</p><p>Our application uses the <code>TextMode</code> (blend + mask) as documented in <i>InsideMacintosh</i> Volume V (blend is equal to the current <code>ditherCopy</code> constant) tomake translucent text. Under System 7, this transfer mode causes garbage toappear when the text is drawn. Is there a way to work around the problem? Willthere be a fix?</p><p>The problem you are seeing is due to the use of <code>CopyDeepMask</code> instead of theold-fashioned <code>CopyBits</code> to do the job. It is being studied now, and the hope isthat it will work as advertised in a future release. One workaround is torender the text to an off-screen pixmap and then call <code>CopyBits</code> (using<code>blendMode</code>) to actually put it in the picture.</p><P><A HREF="#top">Back to top</A></p><H2>Using dithering and animation on the same Macintosh image</h2><p>Date Written:  6/19/91</p><p>Last reviewed:  6/14/93</p><p>When setting up a dithered grayscale image for subsequent animation (to adjustbrightness, for example), a conflict arises between the use of Paletteanimation and the <code>ditherCopy</code> <code>CopyBits</code> mode. This problem is demonstrated in the<i>develop</i> #5 <code>GiMeDaPalette</code> code sample: If you change <code>srcCopy</code> to<code>ditherCopy</code> in the <code>CopyBits</code> call, then run the program and select Animate, theresulting image is pure black and white, with what appears to be an attempt todither with just the black-and-white color table entries (that are not reservedfor animation).</p><p>This happens because <code>ditherCopy</code> tries to use the inverse table to do colormatching, but when the image is animated, the inverse table colors are limitedto just black and white.</p><p>To work around the problem, you can jump into the bottlenecks and when you seethe PICT hitting the opcode for <code>CopyBits</code>, change the mode adding the <code>ditherCopy</code>constant. This way the dithering happens when you do the call to <code>DrawPicture</code>and not later on. This makes it possible to use dithering and animation on thesame image.</p><P><A HREF="#top">Back to top</A></p><H2>Rendering color PICTs in a black-and-white environment</h2><p>Date Written:  7/22/91</p><p>Last reviewed:  9/17/91</p><p>I want to be able to render a color PICT as a black-and-white imagesubstituting patterns for colors. My images are pretty small and have fewerthan 16 colors. What do you suggest as the easiest way?</p><p>One easy way is to take advantage of 32-Bit QuickDraw and System 7.0'sditherCopy transfer mode modifier or flag (documented in <i>Inside Macintosh</i> Volume VI, page 17-17). Call <code>DrawPicture</code> into an off-screen pixmap with the pixel depth of the original color PICT. Then call <code>CopyBits</code> tocopy the pixmap to the screen, with <code>srcCopy</code> + <code>ditherCopy</code> as the transfer mode. This will result in a nicely dithered image on the black-and-white end.</p><p>Under System 6 without 32-Bit QuickDraw, the solution is not nearly so cut anddried. One way might be to take advantage of the fact that <code>DrawPicture</code> goesthrough the QuickDraw bottlenecks for drawing. For each <code>grafproc</code> in your PICT,you'd intercept <code>StdBits</code> during <code>DrawPicture</code> and call your own dithering routineto examine the foreground color and set the pen pattern or fill pattern so thatit has about the same lightness as the original color.</p><p>Well, this came out as a great sales pitch for writing a System 7-savvy app!</p><P><A HREF="#top">Back to top</A></p><H2>Highlighting ignored if foreground same as background color</h2><p>Date Written:  8/7/91</p><p>Last reviewed:  6/14/93</p><p>Under System 7, but not System 6, HiliteMode doesn't work when the foregroundand background colors are similar. Is this a bug?</p><p>Yes, it's a bug. The problem you encounter exists whenever the background andforeground color map to the same color table index. If the foreground color isthe same as the background color, highlighting is ignored. Therefore, youshould always make sure the foreground and background colors are different whenusing <code>HiliteMode</code>.</p><P><A HREF="#top">Back to top</A></p><H2>Gestalt 'qdrw' selector bug and workaround</h2><p>Date Written:  8/1/91</p><p>Last reviewed:  6/14/93</p><p>Why does Gestalt tell me I have Color QuickDraw features on a non-ColorQuickDraw machine?</p><p>The <code>gestaltQuickdrawFeatures</code> (<code>'qdrw'</code>) selector, used for determining yoursystem's Color QuickDraw features, has a bug that causes it to tell youincorrectly that noncolor machines have color. The fix is quite simple: <code>Gestalt</code>has another selector, <code>gestaltQuickdrawVersion ('qd  ')</code>, which simply returnsthe QuickDraw version number. This version number is &lt; <code>gestalt8BitQD</code> forclassic QuickDraw and &gt;= <code>gestalt8BitQD</code> for Color QuickDraw (see <i>InsideMacintosh</i> Volume VI, page 3-39, for more information). The trick is to askGestalt for the QuickDraw version first; once you've determined that you haveColor QuickDraw, the <code>'qdrw'</code> selector is OK to use to find out specifics.</p><P><A HREF="#top">Back to top</A></p><H2>GetPixelsState is slow sometimes</h2><p>Date Written:  8/27/91</p><p>Last reviewed:  6/14/93</p><p>Why do I sometimes see incredible slowdowns under System 7.0 when callingeither <code>GetPixelsState</code> or <code>LockPixels</code> (I'm not sure which) for the <code>PixMapHandle</code>of a <code>GWorld</code> allocated in temporary memory?</p><p><code>GetPixelsState</code> takes an arbitrary amount of time since it makes a call to<code>RecoverHandle</code> to get the handle pointing to the <code>baseaddr</code>. Therefore, the slowdown you see as actually due to the call to <code>RecoverHandle</code>, which is slow because it must traverse the heap to find the pointer to the <code>baseaddr</code>. <code>LockPixels</code> is not responsible for the slowdown because it does not make call to any traps that could take an extended amount of time.</p><P><A HREF="#top">Back to top</A></p><H2>OpenCPicture and PICTs other than 72 dpi</h2><p>Date Written:  10/2/91</p><p>Last reviewed:  6/14/93</p><p>Can I use <code>OpenCPicture</code> to create PICTs with a higher resolution than 72 dotsper inch (dpi)?</p><p>__</p><p>There's good news and bad news: The good news is that you're on top of thesituation, which means the bad news is that there aren't better ways to do whatyou want to do, mostly. Here's the scoop:</p><p>You can use <code>vRes</code> and <code>hRes</code> in pictures opened with <code>OpenCPicture</code> to tellQuickDraw it's not a 72-dpi picture, and as long as the application thatreceives the picture uses <code>DrawPicture</code> to image it, QuickDraw will Do The RightThing--scaling it on the screen to 72 dpi instead of making it humongouslylarge. Unfortunately, this way you lose hairlines; if you print such a pictureto a 72-dpi <code>grafPort</code> (like the LaserWriter driver normally returns), you'll get1/72-inch lines instead of 1/300-inch lines as you probably want.</p><p>(This <i>can</i> work correctly, but the receiving application has to noticethat your picture is bigger than 72 dpi and ask <code>PrGeneral</code> to increase theresolution of the printing <code>grafPort</code> accordingly, and this doesn't always oroften happen.)</p><P><A HREF="#top">Back to top</A></p><H2>No System 7 QuickDraw alpha channel support</h2><p>Date Written:  10/23/91</p><p>Last reviewed:  6/14/93</p><p>How can I directly access the alpha channel (the unused 8 bits in a 32-bitdirect pixel using QuickDraw) under System 7? Under System 6 it was easy, but under System 7's <code>CopyBits</code> the alpha channel works with <code>srcXor</code> but not with srcCopy.</p><p>With the System 7 QuickDraw rewrite, all "accidental" support for the unusedbyte was removed, because QuickDraw isn't supposed to operate on the unused byte of each pixel. QuickDraw has never officially supported use of the extra byte for such purposes as an alpha channel. As stated in <i>Inside Macintosh</i> Volume VI, page 17-5, "8 bits in the pixel are not part of any component. These bits are unused: Color QuickDraw sets them to 0 in any image it creates. If presented with a 32-bit image--for example, in the <code>CopyBits</code> procedure--it passes whatever bits are there."</p><p>Therefore, you cannot rely on any QuickDraw procedure to preserve the contentsof the unused byte, which in your case is the alpha channel. In fact, even<code>CopyBits</code> may alter the byte, if stretching or dithering is involved in the<code>CopyBits</code>, by setting it to 0. Your alternatives are not to use the unused bytefor alpha channel storage since the integrity of the data cannot be guaranteed,or not to use QuickDraw drawing routines that can alter the unused byte.</p><P><A HREF="#top">Back to top</A></p><H2>BitsToRgn and MPW BitMapToRegionGlue</h2><p>Date Written:  10/29/91</p><p>Last reviewed:  6/14/93</p><p>Which version of the system software first contained the call <code>BitsToRgn</code>? Is there a workaround for this call if my users have an earlier version of system software?</p><p>The call <code>BitmapToRegion</code> was introduced with 32-Bit QuickDraw and became fullydocumented in Volume VI of <i>Inside Macintosh,</i> which is primarily System 7 information. However, since the differences between System 7's QuickDraw and 32-Bit QuickDraw are minor, most of System 7's QuickDraw routines are available in system software prior to System 7.0 using the 32-bit QuickDraw INIT.</p><p>To check to see if a system contains 32-bit QuickDraw, you can use thefollowing snippet of code:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    /* Find out if GWorlds and CQD are implemented on this machine */    (void) Gestalt (gestaltQuickdrawVersion, /*&lt;*/&amp;qdVersion);    gHasGWorlds = (qdVersion &gt; gestaltOriginalQD &amp;&amp;                   qdVersion &lt; gestalt8BitQD)                  || qdVersion &gt;= gestalt32BitQD;</pre>	</TD></TR></TABLE></CENTER><p>If you are using MPW as a development platform, MPW has a library call you canuse that will allow you to use the routine regardless of whether or not 32-bitQuickDraw exists. The glue routine is called <code>BitMapToRegionGlue()</code> and isavailable to MPW users. Substitute this call for <code>BitMapToRegion</code> calls and theglue code will take care of patching in the proper code if 32-bit QuickDrawdoes not exist. If you're using Think C, you can use the oConv utility toconvert the MPW object file into a Think C usable format.</p><P><A HREF="#top">Back to top</A></p><H2>Ensuring even <code>rowBytes</code> for 'cicn' resources</h2><p>Date Written:  12/4/91</p><p>Last reviewed:  6/14/93</p><p>Is there any way to force bitmaps and masks within a <code>'cicn'</code> resource to have aneven <code>rowBytes</code> (using ResEdit)? I want to avoid duplicating icon bitmaps--onefor color systems set to B&amp;W and one for B&amp;W systems--to reduce programsize as well as development and maintenance costs. The bitmaps in the <code>'cicn'</code>can also be sized specifically to the task, whereas the old B&amp;W icons areof a fixed size and contain no sizing information. It's simple enough to readin a <code>'cicn'</code> and extract the bitmap. The problem is that on a 68000 (no ColorQuickDraw), if <code>rowBytes</code> is odd, an odd address trap results.</p><p>There isn't any way to get ResEdit itself to create bitmaps with even <code>rowBytes</code>for 8 x 8 'cicn' resources, but here are few suggestions:</p><p>You could process your <code>'cicn'</code> resources first, so that they have bitmaps as yourequire them. To alter the resource with a quick little program would betrivial, especially given that the bitmap data sits last in the <code>'cicn'</code>. Allyou'd need to do is expand the bitmap image data by padding each line to aneven length and then changing the <code>rowBytes</code> value. Or you could de-rez the<code>'cicn'</code>s and patch them with a text editor, either by hand or with asearch-and-replace script of some kind.</p><P><A HREF="#top">Back to top</A></p><H2><code>CopyBits</code> blend mode: OpColor's affect &amp; eliminating banding</h2><p>Date Written:  12/11/91</p><p>Last reviewed:  6/14/93</p><p>I have two gray-colored pixmaps that I wish to blend together; one is on thescreen, the other in an off-screen pixmap. I use <code>CopyBits</code> to copy theoff-screen to the screen, but it does not seem to blend them. Instead, it seemsto match the colors of the screen bitmap to the closest colors in some table,thus having the effect of reducing the number of colors displayed on the screenbitmap. Any suggestions?</p><p>There are two distinct questions here: 1) Why ain't it blending? and 2) What's this banding for? The first problem is almost certainly because <code>OpColor</code> isn't set properly. This is a third, implicit, operand on several arithmetic graphics operations, including blend. For blend, it describes the proportions to mix thesource and destination colors in the blend. For an equal mix, you should set this color to a halfway gray. (Call <code>OpColor()</code> with a color where red, green, and blue all equal $8000.) This effect is described in the description of the blend mode on page 60 of <i>Inside Macintosh</i> Volume V. Unfortunately, the initial value for <code>OpColor</code> is black (0,0,0), so you were seeing no mixing of your off-screen data.</p><p>The second half of your question is why you're getting a banding effect. (When you fix the above problem, you'll still get banding.) Unfortunately, thearithmetic modes are constrained by the size of the inverse table. As yourscreen no doubt uses the default 4-bit inverse table, you'll find that you'llget only 2^4 = 16 levels of gray. If you enlarge your screen's inverse table to5 bits, the maximum allowable, you'll still only get 32 gray levels. (To dothis, set the <code>gdResPref</code> field in the <code>GDevice</code> to 5, then call <code>MakeITable()</code>.) Theonly way to get a fully-gradual, great-looking effect is to do all the workoff-screen in 24-bit deep pixmaps, and then copy it to the screen. Because theycan operate directly on colors, rather than having to work through theintermediary of color indices, direct pixmaps are not limited by inverse tables(in fact, they don't even have real inverse tables). You could use 16-bitpixmaps, but they only provide 32 grays (having only 5 bits for eachcomponent), so this wouldn't be any better than increasing the size of theinverse table.</p><P><A HREF="#top">Back to top</A></p><H2>Icon dimming under System 7 and System 6</h2><p>Date Written:  1/6/92</p><p>Last reviewed:  6/14/93</p><p>When you bring up the Finder windows under System 7 on a color system and clicka control panel item icon, it paints itself that fancy gray. How can I get that effect?</p><p>To get the fancy System 7 icon dimming to work in your program, read theMacintosh Technical Note "Drawing Icons the System 7 Way," and use theicon-drawing routines contained in it. The routines show how to use the IconToolkit, which is what the Finder uses. If you want the same effect underSystem 6, you'll have to emulate the dimming of the icons via QuickDraw; the <code>IconDimming</code> sample code in the Snippets folder on the <i>Developer CD Series</i> disc shows how to do this.</p><P><A HREF="#top">Back to top</A></p><H2>QuickDraw out of memory if debugger invoked by "Jackson"</h2><p>Date Written:  3/11/92</p><p>Last reviewed:  6/14/93</p><p>I am getting a strange bug in which the Macintosh debugger is being invoked byan A-trap marked "Jackson" when I call <code>SetCCursor</code> in certain situations and asecond monitor is hooked up. The cursor structure being passed appears to bevalid. I've also been crashing unexpectedly in this same spot for the past fewweeks. I assume Jackson is some kind of error assertion that was left in System7's Color QuickDraw code. What gives?</p><p>Jackson was a code name for 32-Bit QuickDraw. The trap you refer to is in factnever called; it's not supposed to be encountered by you ever. The trap isreserved for Apple to use in future versions of Color QuickDraw. If you examinethe code directly preceding the <code>_Debugger</code>, you will notice that it is doing</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>        MOVEQ      #$19,D0        JSR        ([$1524])</pre>	</TD></TR></TABLE></CENTER><p>which for you and me is</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>         MoveQ #25,D0                ; say that memory is full...        _SysError                    ; and call syserror</pre>	</TD></TR></TABLE></CENTER><p>the line following would be...</p><p>What's all this tell you? You have a debugger installed that is rts'ing fromthe SysError vector (you aren't supposed to return from <code>SysError</code> normally), oryou have installed your own <code>SysError</code> vector which is rts'ing. At any rate, ifyou examine the code directly following the debugger statement and see what itdoes, you might imagine the source code looks something like this:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>MemFull       MoveQ #25,D0              ; say that memory is full...              _SysError                 ; and call syserror; If it returns better go into the debugger since its not supposed to return              _Debugger                 ; Hey! sysError came back!;CallNewHand   _NewHandle              bne.S  MemFull            ; could not get the memory, just die              rts</pre>	</TD></TR></TABLE></CENTER><p>What's happening is that you're running out of memory somehow (several placescall <code>MemFull</code>, not just the above place), so you'd need to use a stack crawl tofigure out how you got there. But, the bottom line, QuickDraw has run out ofmemory and cannot continue; it tried to put up a system error dialog to tellthe user and for some reason the machine did not get restarted and the SysErrorvector returned. You are now in your debugger, since QuickDraw put up thesystem error dialog because it could not continue.</p><P><A HREF="#top">Back to top</A></p><H2>ditherCopy not supported on LaserWriter or ImageWriter</h2><p>Date Written:  5/31/91</p><p>Last reviewed:  11/6/91</p><p><code>ditherCopy</code> is not supported on LaserWriters or ImageWriters. On a LaserWriter,<code>ditherCopy</code> gets misinterpreted and inverts the image. On an ImageWriter it'streated as a <code>srcCopy</code>. The ImageWriter driver doesn't support color <code>grafPorts</code>,which is the only way to do the pixel image required for <code>ditherCopy</code>. Use<code>srcCopy</code> instead for both printers.</p><P><A HREF="#top">Back to top</A></p><H2>Macintosh Color QuickDraw CalcCMask and SeedCFill clarified</h2><p>Date Written:  1/1/90</p><p>Last reviewed:  11/21/90</p><p>I'm having trouble using <code>CalcCMask</code> and <code>SeedCFill</code>. What am I doing wrong?</p><p>There is some confusion regarding the use of the Macintosh Color QuickDrawroutines <code>CalcCMask</code> and <code>SeedCFill</code>, which are analogous to the older <code>CalcMask</code> and<code>SeedFill</code>. Much of the confusion was caused by early documentation errors. Besure you have the release version of Volume 5 of <i>Inside Macintosh</i> andversion 2.0 or later of the MPW interface files.</p><p>The correct interface for CalcCMask is:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>PROCEDURE CalcCMask(srcBits, dstBits: BitMap;          srcRect, dstRect: Rect;          seedRGB:     RGBColor;          matchProc:    ProcPtr;          matchData:    LongInt);</pre>	</TD></TR></TABLE></CENTER><p>The correct interface for SeedCFill is:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>PROCEDURE SeedCFill(srcBits, dstBits: BitMap;          srcRect, dstRect: Rect;          seedH, seedV:   INTEGER;          matchProc:    Ptr;          matchData:    LongInt);</pre>	</TD></TR></TABLE></CENTER><p>Each routine calculates a one-bit deep bitmap representing either the mask orthe fill area depending upon the routine. In both cases, the source bitmap maybe either a bitmap or a pixmap, but the destination must be a bitmap, becauseit must have a depth of one-bit.</p><p>It is difficult to pass a pixmap for the source parameter because of Pascal'stype checking. To get around this difficulty, you can declare a new type:</p><p>then use it to coerce the pixmap as follows:</p><p>If you have a <code>PixMapHandle</code>, do the following:</p><p>If you are using a <code>grafPort</code> (or a window), you can pass <code>myWindow^.portBits</code> andnot have to worry about whether the port uses a bitmap or a pixmap.</p><p>Most of the other parameters are explained in detail in <i>InsideMacintosh.</i> To use the <code>matchProc</code> and the <code>matchData</code> parameters, though, youneed more information.</p><p>As stated in <i>Inside Macintosh,</i> the <code>matchProc</code> parameter is a pointer to aroutine that you would like to use as a custom <code>SearchProc</code>. To better understandhow this is used, it is helpful to know how <code>SeedCFill</code> and <code>CalcCMask</code> actually work.</p><p>Both routines start by creating a temporary bitmap which, by definition, is onebit deep. The source pixmap (or bitmap) is then copied to the temporary bitmapusing <code>CopyBits</code>. This copy causes the image to be converted to a depth ofone-bit. Now with a normal black-and-white image, the standard <code>CalcMask</code> or<code>SeedFill</code> routine is used to generate the destination bitmap.</p><p>Most of the real work is done in the original call to <code>CopyBits</code>, which maps thepixmap image to a monochrome bitmap equivalent. For each color in the sourcepixmap, <code>CopyBits</code> will map it to either black or white. Which colors map toblack and which ones to white is determined by the <code>SearchProc</code>.</p><p><code>SeedCFill</code> installs a default <code>SearchProc</code> that maps all colors to black exceptfor the color of the pixel at (<code>seedH,seedV</code>). <code>SeedFill</code> then calculates as usualthe fill mask for the white bits.</p><p>The default <code>SearchProc</code> for <code>CalcCMask</code> maps all colors to white except the colorpassed in the <code>seedRGB</code> parameter. The <code>seedRGB</code> parameter, then, would be thecolor of the item that you wanted to "lasso."</p><p>But suppose you want to fill over all colors that were shades of green, notjust the particular shade of green at (<code>seedH,seedV</code>). Or maybe you want to fillover all colors that are lighter than 50 percent brightness. Or maybe you wantto use dark colors as edge colors for <code>CalcCMask</code>. To do such things, you need topass a pointer to your own <code>SearchProc</code> in the <code>matchProc</code> parameter.</p><p>Because your <code>matchProc</code> is just a custom search procedure for the Color Manager,it should be declared as one, but Volumes I-V of <i>Inside Macintosh</i> havedocumented this routine incorrectly. The correct declaration for a customSearchProc is as follows:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>FUNCTION SearchProc(VAR RGB: RGBColor;          VAR result: LongInt) : Boolean;</pre>	</TD></TR></TABLE></CENTER><p>Normally, as each <code>SearchProc</code> is installed, it is added to the head of the<code>SearchProc</code> chain, so that it is called before all of the other ones that were already installed. When a <code>SearchProc</code> is installed, it can do one of three things:</p><ol type="1" start="1">	<li>Completely ignore the call by returning FALSE and not modifying any of the input parameters;</li>	<li>Completely handle the call by setting the result parameter to be the index into the color table that matches (according to your rules) the RGB parameter. In that case, the <code>SearchProc</code> returns TRUE;</li>	<li>Partially handle the call by modifying the RGB parameter, then returning FALSE.</li></ol><p>In cases 1 and 3, the Color Manager continues down the <code>SearchProc</code> chain untilit finds one that returns TRUE. If none of the custom routines handle the call,then the built-in default routine is used. In case 3, you can change the RGBcolor that is being matched. For example, if you want all shades of green tomap to pure green, modify the RGB color, then return FALSE, letting the ColorManager find the index of that green in the color table.</p><p>In case 2, you return TRUE to indicate that you handled the call, and youreturn the color table index in the result parameter. The Color Manager thenuses that index. For example, if you want to substitute white for all colorsthat can't be matched exactly in the color table, then each time you get calledyou either return the index into the color table of the exact color, or 0(which is the index for white) for all other colors.</p><p>A custom <code>SearchProc</code> for <code>SeedCFill</code> and <code>CalcCMask</code> should always return TRUEbecause the default Color Manager SearchProc usually doesn't make sense.Because <code>SeedCFill</code> and <code>CalcCMask</code> are using <code>CopyBits</code> to copy to a 1-bit bitmap,you need to set the result to be either 0 or 1 (the only possible values in a1-bit bitmap). A result of 0 is white, and a result of 1 is black.</p><p>All colors for <code>SeedCFill</code> that should be "filled over" would generate a resultof 0 (white), and all colors that stop the fill generate a 1 (black). <code>SeedFill</code>is then called to fill the white area. All colors for <code>CalcCMask</code> that you wantto form boundaries should generate results of 1 (black).</p><p>When your <code>SearchProc</code> gets called, the <code>gdRefCon</code> field of the current <code>GDevice(theGDevice^^.gdRefCon)</code> contains a pointer to the following record:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    matchRec  =  RECORD      red:       Integer;      green:     Integer;      blue:      Integer;      matchData: LongInt;    END;</pre>	</TD></TR></TABLE></CENTER><p>The red, green, and blue parameters for <code>SeedCFill</code> are the values of the colorof the pixel at (<code>seedH,seedV</code>). For <code>CalcCMask</code>, they are the fields from the <code>seedRGB</code> parameter. Your <code>SearchProc</code> can use this information to decide which colors are "fill-over" colors and which colors are "boundary" colors. For example, if you always set (<code>seedH,seedV</code>) to be the mouse point, your <code>SearchProc</code> then bases its decisions using the color of the pixel under the cursor. For example, the user clicks a shade of green, so all shades of green get filled over.</p><p>The <code>matchData</code> field contains the value that you passed into the <code>SeedCFill</code> or<code>CalcCMask</code> routines in the <code>matchData</code> parameter. The use of this field iscompletely user-defined. For example, since your <code>SearchProc</code> routine may be aseparate module, you might want to use this field to pass a handle to yourvariables. This field can contain a handle, a pointer, a long integer, orwhatever; or you can just ignore this field altogether.</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Warning:</B><BR>There are some features of <code>CalcCMask</code> and <code>SeedCFill</code> you should be awareof. To understand them, you should be familiar with the use of <code>CalcMask</code> and<code>SeedFill</code>, which are described in the QuickDraw chapter of <i>InsideMacintosh</i> Volume IV.</p></TD></TR></TABLE></CENTER><p><code>CalcCMask</code> and <code>SeedCFill</code> both use a parameter set that is very similar to theone used by <code>CopyBits</code>. <code>CalcMask</code> and <code>SeedFill</code>, however, are a different story.Instead of passing bitmaps and rectangles to <code>SeedFill</code> and <code>CalcMask</code>, theseroutines use an unusual set of parameters that describe the memory to beoperated upon in terms of pointers, height, width, and offsets to the next row(<code>rowBytes</code>). Although these parameters are fairly easy to calculate, there aresome limitations.</p><p>The most restrictive limitation is that the width of the rectangle used must bean even multiple of 16 bits. This limitation exists because the width of therectangle is passed to <code>SeedFill</code> and <code>CalcMask</code> as a number of words (2 bytes).When calculating this parameter, <code>SeedCFill</code> and <code>CalcCMask</code> round down to an evenword boundary. This rounding means that the rectangles you pass to <code>CalcCMask</code>and <code>SeedCFill</code> should be an even multiple of 16 pixels in width. If they arenot, then the rightmost portion of the mask will be garbage.</p><p>To figure out the color of the pixel at (<code>seedH,seedV</code>), <code>SeedCFill</code> calls<code>GetCPixel</code>. <code>GetCPixel</code> finds the color of the pixel at (h,v) in the current port.Therefore, if you pass a pixmap that is not the pixmap of the current port youwill get bizarre results. In other words, seedH and seedV are expressed in thelocal coordinates of the current port, not the coordinate of the source pixmap.</p><p>You have two methods to make it work. First, always pass the pixmap of thecurrent port as the source parameter. If you are using an off-screen pixmap, itis a good idea to have an associated port for it, and then call <code>SetPort</code>,passing it a pointer your off-screen port, before you call <code>SeedCFill</code>.</p><p>The second method involves letting <code>SeedCFill</code> get some wrong value for the colorat (<code>seedH,seedV</code>) then using your own custom SearchProc to do the real work. Thedefault <code>SearchProc</code> for <code>SeedCFill</code> relies on getting the correct color, but your<code>SearchProc</code> doesn't have to.</p><p>SeedCFill also makes the assumption that the <code>seedH</code> and <code>seedV</code> parameters are inthe local coordinate system of the destination bitmap. This assumption comesinto play when <code>SeedCFill</code> calculates the seedH and seedV parameters for SeedFill.</p><p>All this means that <code>SeedCFill</code> only works correctly if the source pixmap,destination pixmap, and current port all use the same coordinate system.Because of the above problem, this is almost automatic since the current port's<code>portRect</code> and the bounds of the source pixmap have to be the same anyway.</p><p>The easiest way to make all this work is to have your main port be an evenmultiple of 16 pixels wide. Then, make sure that your source and destinationstructures (pixmap or bitmap) are all the same size and all have origins of (0,0).</p><P><A HREF="#top">Back to top</A></p><H2>Macintosh PICT color picture file format</h2><p>Date Written:  1/1/90</p><p>Last reviewed:  6/14/93</p><p>Is there a general file format for color pictures that is common to all of thecolor paint programs? If so, where is it documented?</p><p>Apple supports (and encourages developers to support) one file type forpictures: the PICT file type. Most paint-type programs handle PICT files.</p><p>A PICT file is composed of two parts in its data fork; the first 512 bytes arefor the file header, which contains application-dependent information. You haveto contact the individual publishers to find out their particular datastructures. For example, you can contact Claris Technical Support at AppleLinkCLARIS.TECH or (415) 962-0371 for the file header MacDraw writes to its files.</p><p>The rest of the data in the file is picture data as created by MacintoshQuickDraw with OpenPicture. You can find the information about this data inVolume V of <i>Inside Macintosh </i>(pages 84-105); this section also shows howto read/write PICT files.</p><p>You can also check the Macintosh Technote <A HREF = "qd_05.html">"Displaying Large PICT Files"</a> formore details on the subject.</p><p>X-Refs:</p><p>DTS Macintosh Technical Note <A HREF = "qd_14.html">"QuickDraw's Internal Picture Definition"</a></p><p>DTS Macintosh Technical Note <A HREF = "qd_05.html">"Displaying Large PICT Files"</a></p><P><A HREF="#top">Back to top</A></p><H2>Mac pixmap is clipped to visRgn defined by screenBits.bounds</h2><p>Date Written:  1/1/90</p><p>Last reviewed:  11/21/90</p><p>I'm drawing into a large off-screen bitmap (pixmap), but anything drawn outsidethe 640- by 480-pixel Macintosh screen area doesn't get written to the pixmap. Why not?</p><p>When you create a new port with <code>OpenPort</code> or <code>OpenCPort</code> the <code>visRgn</code> is initializedto the rectangular region defined by <code>screenBits.bounds</code> (IM I:163). If your porthas a large <code>portRect</code>, any drawing will be clipped to the <code>visRgn</code> and you willlose any drawing outside of the <code>screenBits.bounds</code> rectangle.</p><p>To correct this set the <code>visRgn</code> of the port to coincide with your port'sportRect after creating the port.</p><p>Also note that OpenPort initializes the <code>clipRgn</code> to a wide-open rectangularregion (-32768, -32768, 32767, 32767). Some operations, like <code>OpenPicture</code>, canfail with this setup, so try setting clipRgn to a smaller rectangle.</p><p>X-Refs:</p><p>DTS Macintosh Technical Note <A HREF = "qd_11.html">"Pictures and Clip Regions"</a></p><p>DTS Macintosh Technical Note "Drawing into an Off-Screen Pixel Map"</p><P><A HREF="#top">Back to top</A></p><H2>Using Macintosh System 7 OpenCPicture for higher resolution</h2><p>Date Written:  1/1/90</p><p>Last reviewed:  6/14/93</p><p>We want to use <code>OpenCPicture</code> for higher resolution, not for color per se. Can<code>OpenCPicture</code> in System 7 be used with non-Color as well as Color QuickDrawMacintosh computers?</p><p>Yes, with System 7, <code>OpenCPicture</code> can be used to create extended PICT2 filesfrom all Macintosh computers. Under System 6.0.7 or later, you must test for32-Bit QuickDraw before using <code>OpenCPicture</code>. You can do this by calling Gestaltwith the <code>gestaltQuickdrawVersion</code> selector. If it returns <code>gestalt32BitQD</code> orgreater, then 32-Bit QuickDraw is installed.</p><P><A HREF="#top">Back to top</A></p><H2>How to identify 32-Bit QuickDraw version</h2><p>Date Written:  1/1/90</p><p>Last reviewed:  6/14/93</p><p>How can my program find out which version of Macintosh 32-Bit QuickDraw is running?</p><p>The following code snippet demonstrates how to use the Gestalt Manager todetermine which version of 32-Bit QuickDraw is installed. There is no way todetermine the version of 32-Bit QuickDraw before Gestalt. For 32-Bit QuickDrawversion 1.2, <code>Gestalt</code> returns 2.2. <i>Inside Macintosh</i> Volume VI describesthe Gestalt Manager in detail.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>#defineTRUE0xFF#defineFALSE0#define Gestalttest0xA1AD#define NoTrap0xA89Fmain(){OSErrerr;longfeature;if ((GetTrapAddress(Gestalttest) != GetTrapAddress(NoTrap))) {err = Gestalt(gestaltQuickdrawVersion, &amp;feature);if (!err) {if ((feature &amp; 0x0f00) == 0x0000)printf (&quot;We have Original QuickDraw version 0.%x\n&quot;, (feature &amp; 0x00ff));else if ((feature &amp; 0x0f00) == 0x0100)printf (&quot;We have 8 Bit QuickDraw version 1.%x\n&quot;, (feature &amp; 0x00ff));else if ((feature &amp; 0x0f00) == 0x0200)printf (&quot;We have 32 Bit QuickDraw version 2.%x\n&quot;, (feature &amp; 0x00ff));elseprintf (&quot;We don't have QD\n&quot;);}elseprintf (&quot;Gestalt err = %i\n&quot;,err);}elseprintf (&quot;No Gestalt\n&quot;);}</pre>	</TD></TR></TABLE></CENTER><P><A HREF="#top">Back to top</A></p><H2>Macintosh QDError function under System 6 and System 7</h2><p>Date Written:  1/1/90</p><p>Last reviewed:  12/7/90</p><p>Under what System 7 and System 6 conditions is it legal to call the MacintoshQDError function?</p><p>Under System 7, <code>QDError</code> can be called from all Macintosh computers. (System 7supports <code>RGBForeColor</code>, <code>RGBBackColor</code>, <code>GetForeColor</code>, and <code>GetBackColor</code> for allMacintosh computers as well.) On a non-Color QuickDraw Macintosh, <code>QDError</code>always returns a "no error." Under System 6, QDError cannot be used fornon-Color QuickDraw Macintosh systems.</p><P><A HREF="#top">Back to top</A></p><H2>Macintosh <code>CopyBits</code> transfer modes changed for System 7</h2><p>Date Written:  1/1/90</p><p>Last reviewed:  6/14/93</p><p>Why do some Macintosh <code>CopyBits</code> transfer modes produce different results forSystem 7 than for System 6?</p><p>Under System 6, the <code>srcOr</code>, <code>srcXor</code>, <code>srcBic</code>, <code>notSrcCopy</code>, <code>notSrcOr</code>, <code>notSrcXor</code>, and<code>notSrcBic</code> transfer modes do not produce the same effect for a 16- or 32-bit(direct) pixel map as for an 8-bit or shallower (indexed) pixel map. With ColorQuickDraw these classic transfer modes on direct pixel maps aren't color-based;they're pixel-value-based. Color QuickDraw performs logical operationscorresponding to the transfer mode on the source and destination pixel valuesto get the resulting pixel value.</p><p>For example, say that a multicolored source is being copied onto ablack-and-white destination using the <code>srcOr</code> transfer mode, and both the sourceand destination are 8 bits per pixel. Except in unusual cases, the pixel valuefor black on an indexed pixel map has all its bits set, so an 8-bit black pixelhas a pixel value of $FF. Similarly, the pixel value for white has all its bitsclear, so an 8-bit white pixel has a pixel value of $00. <code>CopyBits</code> takes eachpixel value of the source and performs a logical OR with the correspondingpixel value of the destination. Using OR to combine any value with 0 results inthe original value, so using OR to combine any pixel value with the pixel valuefor white results in the original pixel value. Using OR to combine any valuewith 1 results in 1, so using OR to combine any pixel value with the pixelvalue for black results in the pixel value for black. The resulting image showsthe original image in all areas where the destination image was white and showsblack in all areas where the destination image was black.</p><p>Take the same example, but this time make the source and destination 32 bitsper pixel. The direct-color pixel value for black is $00000000 and thedirect-color pixel value for white is $00FFFFFF. <code>CopyBits</code> still performs alogical OR on the source and destination pixel values, but notice what happensin this case. Using OR to combine any source pixel value with the pixel valuefor white results in white, and using OR to combine any source pixel value withthe pixel value for black results in the original color. The resulting imageshows the original image in all areas where the destination image was black andshows white in all areas where the destination image was white--roughly theopposite of what you see on an indexed pixel map.</p><p>The newer transfer modes <code>addOver</code>, <code>addPin</code>, <code>subOver</code>, <code>subPin</code>, <code>adMax</code>, and <code>adMin</code>work consistently at all pixel depths, and often, though not always, correspondto the theoretical effect of the old transfer modes. For example, the adMinmode works similarly to the <code>srcOr</code> mode on both direct and indexed pixel maps.Also, 1-bit deep source pixel maps work consistently and predictably regardlessof the pixel depth of the destination even with the old transfer modes.</p><p>Under system software version 7.0, the old transfer modes now perform bycalculating with colors rather than pixel values. You'll find that transfer modes like <code>srcOr</code> and <code>srcBic</code> work much more consistently even on direct pixel maps.</p><P><A HREF="#top">Back to top</A></p><H2>Which QuickDraw versions support SetEntries</h2><p>Date Written:  3/3/92</p><p>Last reviewed:  6/14/93</p><p>I'm calling <code>SetEntries</code> to update the on-screen CLUT. Who implements this call?Does 32-Bit QuickDraw? In other words, does the 32-Bit QuickDraw INIT need tobe around for this to work? What about monochrome machines? </p><p>I'm creating off-screen buffers by hand instead of using <code>GWorlds</code>. Is this theproper way of doing off-screen buffering when we don't want to require the userto have 32-Bit QuickDraw?</p><p>SetEntries is part of the Color Manager, which exists with all Color QuickDrawversions. A good rule of thumb to follow is that if it is documented in <i>Inside Macintosh</i> Volume V, you don't need 32-Bit QuickDraw to use it. <i>Inside Macintosh</i> Volume V documents standard Color QuickDraw. <code>SetEntries</code> does not work on monochrome Macintosh models, including the Classic II, SE, and PowerBooks.</p><p>Off-screen buffering: You should always use <code>GWorlds</code> if they exist; use <code>Gestalt</code>to test for them. This will assure that you can take advantage of the latestspeed improvements. It is important to remember that under System 7 <code>NewGWorld</code>and accompanying calls are present in all Macintosh computers includingblack-and-white systems such as Classic and PowerBook 100 systems.</p><P><A HREF="#top">Back to top</A></p><H2>Macintosh pixel map maximum <code>rowBytes</code> change</h2><p>Date Written:  4/22/91</p><p>Last reviewed:  6/14/93</p><p>The Color QuickDraw section of <i>Inside Macintosh</i> Volume VI states thatthe restriction on the <code>rowBytes</code> field in a pixmap has been relaxed from $2000to $4000. When did this happen? Is it true for all 32-Bit QuickDraw versions?This affects our user configuration recommendations.</p><p>The maximum <code>rowBytes</code> extension to $3FFE or less applies only to 32-bitQuickDraw. Using pixmaps with <code>rowBytes</code> greater than $1FFE when 32-bit QuickDraw is not present is likely to cause problems such as garbage images or system crashes. Remember that 32-bit QuickDraw is always present under System 7.0 or higher.</p><P><A HREF="#top">Back to top</A></p><H2>Use assembly to flip a 24-bit off-port color pixmap</h2><p>Date Written:  5/7/91</p><p>Last reviewed:  7/25/91</p><p>What's the best approach to horizontally flip a 24-bit off-port color pixmap?</p><p>Unfortunately, you won't be able to use <code>CopyBits</code> for this kind of procedure;you'll have to write your own routine to move each pixel. I'd suggest doing this in assembly language to squeeze the best possible performance out of your code.</p><P><A HREF="#top">Back to top</A></p><H2>Why PlotCIcon requires GetCIcon instead of Get1Resource</h2><p>Date Written:  4/26/91</p><p>Last reviewed:  6/17/91</p><p>Why do I have to use <code>GetCIcon(resID)</code> instead of <code>Get1Resource('cicn',resID)</code>for <code>PlotCIcon</code> to work correctly?</p><p>You apparently thought something that, at first, I thought also: that<code>GetCIcon(resID)</code> is just a utility routine that translates to<code>Get1Resource('cicn',resID)</code>. However, this is not the case; <code>GetCIcon</code> not onlygets the <code>'cicn'</code> resource, but it also performs some minor surgery on theresults, fills in some placeholder fields in the resource data, and the like.Basically, <code>PlotCIcon</code> can't work without the things that <code>GetCIcon</code> does.</p><P><A HREF="#top">Back to top</A></p><H2>How Macintosh system draws small color icons</h2><p>Date Written:  3/31/92</p><p>Last reviewed:  6/14/93</p><p>The code I added to my application's MDEF to plot a small icon in color worksexcept when I hold the cursor over an item with color. The color of the smallicon is wrong because it's just doing an <code>InvertRect</code>. When I drag over the Applemenu, the menu inverts behind the icon but the icon is untouched. Is this doneby brute force, redrawing the small icon after every InvertRect?</p><p>The Macintosh system draws color icons, such as the Apple icon in the menu bar,every time the title has to be inverted. First <code>InvertRect</code> is called to invertthe menu title, and then <code>PlotIconID</code> is called to draw the icon in its place.The advantage of using <code>PlotIconID</code> is that you don't have to worry about thedepth and size of the icon being used. The system picks the best match from thefamily whose ID is being passed, taking into consideration the target rectangleand the depth of the device(s) that will contain the icon's image.</p><p>The Icon Utilities call PlotIconID is documented in the Macintosh TechnicalNote <A HREF = "qd_18.html">"Drawing Icons the System 7 Way"</a>; see this Note for details on using the Icon Utilities calls.</p><P><A HREF="#top">Back to top</A></p><H2>Spooling and preserving Macintosh QuickDraw pixmap depth</h2><p>Date Written:  2/11/92</p><p>Last reviewed:  6/14/93</p><p>When a picture that contains a pixmap is spooled into a window, how and when isthe depth of the pixmap in the picture converted to the depth of the screensthe window is on?</p><p>When a picture is spooled in, if QuickDraw encounters any bitmap opcode, itallocates a pixmap of the same depth as the data associated with the bitmapopcode, expands the data into the temporary pixmap, and then calls <code>StdBits</code>.<code>StdBits</code> is what triggers the depth and color conversions as demanded by thecolor environment (depth, color table, B&amp;W settings) of the devices thetarget port may span (as when a window crosses two or more screens).</p><p>If there's not enough memory in the application heap or in the temporary memorypool, QuickDraw bands the image down to one scan line and calls <code>StdBits</code> foreach of these bands. Note that if you're providing your own <code>bitsProc</code>, QuickDrawwill call it instead of <code>StdBits</code>.</p><p>This process is the same when the picture is in memory, with the obviousexception that all the picture data is present; the color mapping occurs whenStdBits does its stuff.</p><P><A HREF="#top">Back to top</A></p><H2>Determining the resolution of a PICT</h2><p>Date Written:  6/10/92</p><p>Last reviewed:  6/14/93</p><p>In a version 2 picture, the <code>picFrame</code> is the rectangular bounding box of thepicture, at 72 dpi. I would like to determine the bounding rectangle at thestored resolution or the resolution itself. Is there a way to do this withoutreading the raw data of the PICT resource itself?</p><p>With regular version 2 PICTs (or any pictures), figuring out the realresolution of the PICT is pretty tough. Applications use different techniquesto save the information. But if you make a picture with <code>OpenCPicture</code>, theresolution information is stored in the <code>headerOp</code> data, and you can get at thisby searching for the <code>headerOp</code> opcode in the picture data (it's always thesecond opcode in the picture data, but you still have to search for it in casethere are any zero opcodes before it). Or you can use the Picture UtilitiesPackage to extract this information.</p><p>With older picture formats, the resolution and original bounds information issometimes not as obvious or easily derived. In fact, in some applications, thePICT's resolution and original bounds aren't stored in the header, but ratherin the pixel map structure(s) contained within the PICT.</p><p>To examine these pixmaps, you'll first need to install your own <code>bitsProc</code>, andthen manually check the bounds, <code>hRes</code>, and <code>vRes</code> fields of any pixmap beingpassed. In most cases the <code>hRes</code> and <code>vRes</code> fields will be set to the <code>Fixed</code> value0x00480000 (72 dpi); however, some applications will set these fields to thePICT's actual resolution, as shown in the code below.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>Rect      gPictBounds;Fixed      gPictHRes, gPictVRes;pascal void ColorBitsProc (srcBits, srcRect, dstRect, mode,  maskRgn)BitMap    *srcBits;Rect      *srcRect, *dstRect;short      mode;RgnHandle  maskRgn;{  PixMapPtr  pm;  pm = (PixMapPtr)srcBits;  gPictBounds = (*pm).bounds;  gPictHRes = (*pm).hRes;    /* Fixed value */  gPictVRes = (*pm).vRes;    /* Fixed value */}void FindPictInfo(picture)PicHandle  picture;{  CQDProcs    bottlenecks;  SetStdCProcs (&amp;bottlenecks);  bottlenecks.bitsProc = (Ptr)ColorBitsProc;  (*(qd.thePort)).grafProcs = (QDProcs *)&amp;bottlenecks;  DrawPicture (picture, &amp;((**picture).picFrame));  (*(qd.thePort)).grafProcs = 0L;}</pre>	</TD></TR></TABLE></CENTER><a name="Downloads"></a>         <P><A HREF="#top">Back to top</A></p><H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (92K).</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/qd_515.pdf">Download</A></P>               </TD>            </TR>                    </TABLE>         <BR></TD></TR></table></center><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/qd/qd_515.html%3Fid%3DDTS10002737-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/qd/qd_515.html%3Fid%3DDTS10002737-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/qd/qd_515.html%3Fid%3DDTS10002737-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>