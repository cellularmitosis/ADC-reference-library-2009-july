<html><head><title>Mac OS X
 Manual Page For MIME::Entity(3pm)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3pm/MIME::Entity" title="Mac OS X
 Manual Page for MIME::Entity(3pm)"><a name="//apple_ref/doc/man/3/MIME::Entity" title="Mac OS X
 Manual Page for MIME::Entity(3pm)"><!-- headerDoc=man; indexgroup=Section 3pm; uid="//apple_ref/doc/man/3pm/MIME::Entity"; name=MIME::Entity(3pm) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
MIME::Entity(3)                      User Contributed Perl Documentation                     MIME::Entity(3)



<b>NAME</b>
       MIME::Entity - class for parsed-and-decoded MIME message

<b>SYNOPSIS</b>
       Before reading further, you should see MIME::Tools to make sure that you understand where this module
       fits into the grand scheme of things.  Go on, do it now.  I'll wait.

       Ready?  Ok...

           ### Create an entity:
           $top = MIME::Entity-&gt;build(From    =&gt; 'me@myhost.com',
                                      To      =&gt; 'you@yourhost.com',
                                      Subject =&gt; "Hello, nurse!",
                                      Data    =&gt; \@my_message);

           ### Attach stuff to it:
           $top-&gt;attach(Path     =&gt; $gif_path,
                        Type     =&gt; "image/gif",
                        Encoding =&gt; "base64");

           ### Sign it:
           $top-&gt;sign;

           ### Output it:
           $top-&gt;print(\*STDOUT);

<b>DESCRIPTION</b>
       A subclass of <b>Mail::Internet</b>.

       This package provides a class for representing MIME message entities, as specified in RFC 1521,
       <u>Multipurpose</u> <u>Internet</u> <u>Mail</u> <u>Extensions</u>.

<b>EXAMPLES</b>
       <b>Construction</b> <b>examples</b>

       Create a document for an ordinary 7-bit ASCII text file (lots of stuff is defaulted for us):

           $ent = MIME::Entity-&gt;build(Path=&gt;"english-msg.txt");

       Create a document for a text file with 8-bit (Latin-1) characters:

           $ent = MIME::Entity-&gt;build(Path     =&gt;"french-msg.txt",
                                      Encoding =&gt;"quoted-printable",
                                      From     =&gt;'jean.luc@inria.fr',
                                      Subject  =&gt;"C'est bon!");

       Create a document for a GIF file (the description is completely optional; note that we have to
       specify content-type and encoding since they're not the default values):

           $ent = MIME::Entity-&gt;build(Description =&gt; "A pretty picture",
                                      Path        =&gt; "./docs/mime-sm.gif",
                                      Type        =&gt; "image/gif",
                                      Encoding    =&gt; "base64");

       Create a document that you already have the text for, using "Data":

           $ent = MIME::Entity-&gt;build(Type        =&gt; "text/plain",
                                      Encoding    =&gt; "quoted-printable",
                                      Data        =&gt; ["First line.\n",
                                                     "Second line.\n",
                                                     "Last line.\n"]);

       Create a multipart message, with the entire structure given explicitly:

           ### Create the top-level, and set up the mail headers:
           $top = MIME::Entity-&gt;build(Type     =&gt; "multipart/mixed",
                                      From     =&gt; 'me@myhost.com',
                                      To       =&gt; 'you@yourhost.com',
                                      Subject  =&gt; "Hello, nurse!");

           ### Attachment #1: a simple text document:
           $top-&gt;attach(Path=&gt;"./testin/short.txt");

           ### Attachment #2: a GIF file:
           $top-&gt;attach(Path        =&gt; "./docs/mime-sm.gif",
                        Type        =&gt; "image/gif",
                        Encoding    =&gt; "base64");

           ### Attachment #3: text we'll create with text we have on-hand:
           $top-&gt;attach(Data =&gt; $contents);

       Suppose you don't know ahead of time that you'll have attachments?  No problem: you can "attach" to
       singleparts as well:

           $top = MIME::Entity-&gt;build(From    =&gt; 'me@myhost.com',
                                      To      =&gt; 'you@yourhost.com',
                                      Subject =&gt; "Hello, nurse!",
                                      Data    =&gt; \@my_message);
           if ($GIF_path) {
               $top-&gt;attach(Path     =&gt; $GIF_path,
                            Type     =&gt; 'image/gif');
           }

       Copy an entity (headers, parts... everything but external body data):

           my $deepcopy = $top-&gt;dup;

       <b>Access</b> <b>examples</b>

           ### Get the head, a MIME::Head:
           $head = $ent-&gt;head;

           ### Get the body, as a MIME::Body;
           $bodyh = $ent-&gt;bodyhandle;

           ### Get the intended MIME type (as declared in the header):
           $type = $ent-&gt;mime_type;

           ### Get the effective MIME type (in case decoding failed):
           $eff_type = $ent-&gt;effective_type;

           ### Get preamble, parts, and epilogue:
           $preamble   = $ent-&gt;preamble;          ### ref to array of lines
           $num_parts  = $ent-&gt;parts;
           $first_part = $ent-&gt;parts(0);          ### an entity
           $epilogue   = $ent-&gt;epilogue;          ### ref to array of lines

       <b>Manipulation</b> <b>examples</b>

       Muck about with the body data:

           ### Read the (unencoded) body data:
           if ($io = $ent-&gt;open("r")) {
               while (defined($_ = $io-&gt;getline)) { print $_ }
               $io-&gt;close;
           }

           ### Write the (unencoded) body data:
           if ($io = $ent-&gt;open("w")) {
               foreach (@lines) { $io-&gt;print($_) }
               $io-&gt;close;
           }

           ### Delete the files for any external (on-disk) data:
           $ent-&gt;purge;

       Muck about with the signature:

           ### Sign it (automatically removes any existing signature):
           $top-&gt;sign(File=&gt;"$ENV{HOME}/.signature");

           ### Remove any signature within 15 lines of the end:
           $top-&gt;remove_sig(15);

       Muck about with the headers:

           ### Compute content-lengths for singleparts based on bodies:
           ###   (Do this right before you print!)
           $entity-&gt;sync_headers(Length=&gt;'COMPUTE');

       Muck about with the structure:

           ### If a 0- or 1-part multipart, collapse to a singlepart:
           $top-&gt;make_singlepart;

           ### If a singlepart, inflate to a multipart with 1 part:
           $top-&gt;make_multipart;

       Delete parts:

           ### Delete some parts of a multipart message:
           my @keep = grep { keep_part($_) } $msg-&gt;parts;
           $msg-&gt;parts(\@keep);

       <b>Output</b> <b>examples</b>

       Print to filehandles:

           ### Print the entire message:
           $top-&gt;print(\*STDOUT);

           ### Print just the header:
           $top-&gt;print_header(\*STDOUT);

           ### Print just the (encoded) body... includes parts as well!
           $top-&gt;print_body(\*STDOUT);

       Stringify... note that "stringify_xx" can also be written "xx_as_string"; the methods are synonymous,
       and neither form will be deprecated:

           ### Stringify the entire message:
           print $top-&gt;stringify;              ### or $top-&gt;as_string

           ### Stringify just the header:
           print $top-&gt;stringify_header;       ### or $top-&gt;header_as_string

           ### Stringify just the (encoded) body... includes parts as well!
           print $top-&gt;stringify_body;         ### or $top-&gt;body_as_string

       Debug:

           ### Output debugging info:
           $entity-&gt;dump_skeleton(\*STDERR);

<b>PUBLIC</b> <b>INTERFACE</b>
       <b>Construction</b>


       new [SOURCE]
           <u>Class</u> <u>method.</u>  Create a new, empty MIME entity.  Basically, this uses the Mail::Internet
           constructor...

           If SOURCE is an ARRAYREF, it is assumed to be an array of lines that will be used to create both
           the header and an in-core body.

           Else, if SOURCE is defined, it is assumed to be a filehandle from which the header and in-core
           body is to be read.

           <b>Note:</b> in either case, the body will not be <u>parsed:</u> merely read!

       add_part ENTITY, [OFFSET]
           <u>Instance</u> <u>method.</u>  Assuming we are a multipart message, add a body part (a MIME::Entity) to the
           array of body parts.  Returns the part that was just added.

           If OFFSET is positive, the new part is added at that offset from the beginning of the array of
           parts.  If it is negative, it counts from the end of the array.  (An INDEX of -1 will place the
           new part at the very end of the array, -2 will place it as the penultimate item in the array,
           etc.)  If OFFSET is not given, the new part is added to the end of the array.  <u>Thanks</u> <u>to</u> <u>Jason</u> <u>L</u>
           <u>Tibbitts</u> <u>III</u> <u>for</u> <u>providing</u> <u>support</u> <u>for</u> <u>OFFSET.</u>

           <b>Warning:</b> in general, you only want to attach parts to entities with a content-type of
           "multipart/*").

       attach PARAMHASH
           <u>Instance</u> <u>method.</u>  The real quick-and-easy way to create multipart messages.  The PARAMHASH is
           used to "build" a new entity; this method is basically equivalent to:

               $entity-&gt;add_part(ref($entity)-&gt;build(PARAMHASH, Top=&gt;0));

           <b>Note:</b> normally, you attach to multipart entities; however, if you attach something to a
           singlepart (like attaching a GIF to a text message), the singlepart will be coerced into a
           multipart automatically.

       build PARAMHASH
           <u>Class/instance</u> <u>method.</u>  A quick-and-easy catch-all way to create an entity.  Use it like this to
           build a "normal" single-part entity:

              $ent = MIME::Entity-&gt;build(Type     =&gt; "image/gif",
                                         Encoding =&gt; "base64",
                                         Path     =&gt; "/path/to/xyz12345.gif",
                                         Filename =&gt; "saveme.gif",
                                         Disposition =&gt; "attachment");

           And like this to build a "multipart" entity:

              $ent = MIME::Entity-&gt;build(Type     =&gt; "multipart/mixed",
                                         Boundary =&gt; "---1234567");

           A minimal MIME header will be created.  If you want to add or modify any header fields
           afterwards, you can of course do so via the underlying head object... but hey, there's now a
           prettier syntax!

              $ent = MIME::Entity-&gt;build(Type          =&gt;"multipart/mixed",
                                         From          =&gt; $myaddr,
                                         Subject       =&gt; "Hi!",
                                         'X-Certified' =&gt; ['SINED',
                                                           'SEELED',
                                                           'DELIVERED']);

           Normally, an "X-Mailer" header field is output which contains this toolkit's name and version
           (plus this module's RCS version).  This will allow any bad MIME we generate to be traced back to
           us.  You can of course overwrite that header with your own:

              $ent = MIME::Entity-&gt;build(Type        =&gt; "multipart/mixed",
                                         'X-Mailer'  =&gt; "myprog 1.1");

           Or remove it entirely:

              $ent = MIME::Entity-&gt;build(Type       =&gt; "multipart/mixed",
                                         'X-Mailer' =&gt; undef);

           OK, enough hype.  The parameters are:

           (FIELDNAME)
               Any field you want placed in the message header, taken from the standard list of header
               fields (you don't need to worry about case):

                   Bcc           Encrypted     Received      Sender
                   Cc            From          References    Subject
                   Comments      Keywords      Reply-To      To
                   Content-*     Message-ID    Resent-*      X-*
                   Date          MIME-Version  Return-Path
                                 Organization

               To give experienced users some veto power, these fields will be set <u>after</u> the ones I set...
               so be careful: <u>don't</u> <u>set</u> <u>any</u> <u>MIME</u> <u>fields</u> (like "Content-type") unless you know what you're
               doing!

               To specify a fieldname that's <u>not</u> in the above list, even one that's identical to an option
               below, just give it with a trailing ":", like "My-field:".  When in doubt, that <u>always</u>
               signals a mail field (and it sort of looks like one too).

           Boundary
               <u>Multipart</u> <u>entities</u> <u>only.</u> <u>Optional.</u>  The boundary string.  As per RFC-1521, it must consist
               only of the characters "[0-9a-zA-Z'()+_,-./:=?]" and space (you'll be warned, and your
               boundary will be ignored, if this is not the case).  If you omit this, a random string will
               be chosen... which is probably safer.

           Charset
               <u>Optional.</u>  The character set.

           Data
               <u>Single-part</u> <u>entities</u> <u>only.</u> <u>Optional.</u>  An alternative to Path (q.v.): the actual data, either
               as a scalar or an array reference (whose elements are joined together to make the actual
               scalar).  The body is opened on the data using MIME::Body::InCore.

           Description
               <u>Optional.</u>  The text of the content-description.  If you don't specify it, the field is not
               put in the header.

           Disposition
               <u>Optional.</u>  The basic content-disposition ("attachment" or "inline").  If you don't specify
               it, it defaults to "inline" for backwards compatibility.  <u>Thanks</u> <u>to</u> <u>Kurt</u> <u>Freytag</u> <u>for</u>
               <u>suggesting</u> <u>this</u> <u>feature.</u>

           Encoding
               <u>Optional.</u>  The content-transfer-encoding.  If you don't specify it, a reasonable default is
               put in.  You can also give the special value '-SUGGEST', to have it chosen for you in a
               heavy-duty fashion which scans the data itself.

           Filename
               <u>Single-part</u> <u>entities</u> <u>only.</u> <u>Optional.</u>  The recommended filename.  Overrides any name extracted
               from "Path".  The information is stored both the deprecated (content-type) and preferred
               (content-disposition) locations.  If you explicitly want to <u>avoid</u> a recommended filename
               (even when Path is used), supply this as empty or undef.

           Id  <u>Optional.</u>  Set the content-id.

           Path
               <u>Single-part</u> <u>entities</u> <u>only.</u> <u>Optional.</u>  The path to the file to attach.  The body is opened on
               that file using MIME::Body::File.

           Top <u>Optional.</u>  Is this a top-level entity?  If so, it must sport a MIME-Version.  The default is
               true.  (NB: look at how "attach()" uses it.)

           Type
               <u>Optional.</u>  The basic content-type ("text/plain", etc.).  If you don't specify it, it defaults
               to "text/plain" as per RFC-1521.  <u>Do</u> <u>yourself</u> <u>a</u> <u>favor:</u> <u>put</u> <u>it</u> <u>in.</u>

       dup <u>Instance</u> <u>method.</u>  Duplicate the entity.  Does a deep, recursive copy, <u>but</u> <u>beware:</u> external data
           in bodyhandles is <u>not</u> copied to new files!  Changing the data in one entity's data file, or
           purging that entity, <u>will</u> affect its duplicate.  Entities with in-core data probably need not
           worry.

       <b>Access</b>


       body [VALUE]
           <u>Instance</u> <u>method.</u>  Get the <u>encoded</u> (transport-ready) body, as an array of lines.  This is a read-<font color="#ffffff" class="whiteout">only&nbsp;readonly</font>
           only data structure: changing its contents will have no effect.  Its contents are identical to
           what is printed by <u>print</u><b>_</b><u>body()</u>.

           Provided for compatibility with Mail::Internet, so that methods like "smtpsend()" will work.
           Note however that if VALUE is given, a fatal exception is thrown, since you cannot use this
           method to <u>set</u> the lines of the encoded message.

           If you want the raw (unencoded) body data, use the <u>bodyhandle()</u> method to get and use a
           MIME::Body.  The content-type of the entity will tell you whether that body is best read as text
           (via <u>getline()</u>) or raw data (via <u>read()</u>).

       bodyhandle [VALUE]
           <u>Instance</u> <u>method.</u>  Get or set an abstract object representing the body of the message.  The body
           holds the decoded message data.

           <b>Note</b> <b>that</b> <b>not</b> <b>all</b> <b>entities</b> <b>have</b> <b>bodies!</b>  An entity will have either a body or parts: not both.
           This method will <u>only</u> return an object if this entity can have a body; otherwise, it will return
           undefined.  Whether-or-not a given entity can have a body is determined by (1) its content type,
           and (2) whether-or-not the parser was told to extract nested messages:

               Type:        | Extract nested? | bodyhandle() | parts()
               -----------------------------------------------------------------------<font color="#ffffff" class="whiteout">multipart/*&nbsp;----------------------------------------------------------------------multipart/*</font>
               multipart/*  | -               | undef        | 0 or more MIME::Entity
               message/*    | true            | undef        | 0 or 1 MIME::Entity
               message/*    | false           | MIME::Body   | empty list
               (other)      | -               | MIME::Body   | empty list

           If "VALUE" <u>is</u> <u>not</u> given, the current bodyhandle is returned, or undef if the entity cannot have a
           body.

           If "VALUE" <u>is</u> given, the bodyhandle is set to the new value, and the previous value is returned.

           See "parts" for more info.

       effective_type [MIMETYPE]
           <u>Instance</u> <u>method.</u>  Set/get the <u>effective</u> MIME type of this entity.  This is <u>usually</u> identical to
           the actual (or defaulted) MIME type, but in some cases it differs.  For example, from RFC-2045:

              Any entity with an unrecognized Content-Transfer-Encoding must be
              treated as if it has a Content-Type of "application/octet-stream",
              regardless of what the Content-Type header field actually says.

           Why? because if we can't decode the message, then we have to take the bytes as-is, in their
           (unrecognized) encoded form.  So the message ceases to be a "text/foobar" and becomes a bunch of
           undecipherable bytes -- in other words, an "application/octet-stream".

           Such an entity, if parsed, would have its <u>effective</u><b>_</b><u>type()</u> set to "application/octet_stream",
           although the <u>mime</u><b>_</b><u>type()</u> and the contents of the header would remain the same.

           If there is no effective type, the method just returns what <u>mime</u><b>_</b><u>type()</u> would.

           <b>Warning:</b> the effective type is "sticky"; once set, that <u>effective</u><b>_</b><u>type()</u> will always be returned
           even if the conditions that necessitated setting the effective type become no longer true.

       epilogue [LINES]
           <u>Instance</u> <u>method.</u>  Get/set the text of the epilogue, as an array of newline-terminated LINES.
           Returns a reference to the array of lines, or undef if no epilogue exists.

           If there is a epilogue, it is output when printing this entity; otherwise, a default epilogue is
           used.  Setting the epilogue to undef (not []!) causes it to fallback to the default.

       head [VALUE]
           <u>Instance</u> <u>method.</u>  Get/set the head.

           If there is no VALUE given, returns the current head.  If none exists, an empty instance of
           MIME::Head is created, set, and returned.

           <b>Note:</b> This is a patch over a problem in Mail::Internet, which doesn't provide a method for
           setting the head to some given object.

       is_multipart
           <u>Instance</u> <u>method.</u>  Does this entity's effective MIME type indicate that it's a multipart entity?
           Returns undef (false) if the answer couldn't be determined, 0 (false) if it was determined to be
           false, and true otherwise.  Note that this says nothing about whether or not parts were
           extracted.

           NOTE: we switched to effective_type so that multiparts with bad or missing boundaries could be
           coerced to an effective type of "application/x-unparseable-multipart".

       mime_type
           <u>Instance</u> <u>method.</u>  A purely-for-convenience method.  This simply relays the request to the
           associated MIME::Head object.  If there is no head, returns undef in a scalar context and the
           empty array in a list context.

           <b>Before</b> <b>you</b> <b>use</b> <b>this,</b> consider using <u>effective</u><b>_</b><u>type()</u> instead, especially if you obtained the
           entity from a MIME::Parser.

       open READWRITE
           <u>Instance</u> <u>method.</u>  A purely-for-convenience method.  This simply relays the request to the
           associated MIME::Body object (see <u>MIME::Body::open()</u>).  READWRITE is either 'r' (open for read)
           or 'w' (open for write).

           If there is no body, returns false.

       parts
       parts INDEX
       parts ARRAYREF
           <u>Instance</u> <u>method.</u>  Return the MIME::Entity objects which are the sub parts of this entity (if
           any).

           <u>If</u> <u>no</u> <u>argument</u> <u>is</u> <u>given,</u> returns the array of all sub parts, returning the empty array if there
           are none (e.g., if this is a single part message, or a degenerate multipart).  In a scalar
           context, this returns you the number of parts.

           <u>If</u> <u>an</u> <u>integer</u> <u>INDEX</u> <u>is</u> <u>given,</u> return the INDEXed part, or undef if it doesn't exist.

           <u>If</u> <u>an</u> <u>ARRAYREF</u> <u>to</u> <u>an</u> <u>array</u> <u>of</u> <u>parts</u> <u>is</u> <u>given,</u> then this method <u>sets</u> the parts to a copy of that
           array, and returns the parts.  This can be used to delete parts, as follows:

               ### Delete some parts of a multipart message:
               $msg-&gt;parts([ grep { keep_part($_) } $msg-&gt;parts ]);

           <b>Note:</b> for multipart messages, the preamble and epilogue are <u>not</u> considered parts.  If you need
           them, use the "preamble()" and "epilogue()" methods.

           <b>Note:</b> there are ways of parsing with a MIME::Parser which cause certain message parts (such as
           those of type "message/rfc822") to be "reparsed" into pseudo-multipart entities.  You should read
           the documentation for those options carefully: it <u>is</u> possible for a diddled entity to not be
           multipart, but still have parts attached to it!

           See "bodyhandle" for a discussion of parts vs. bodies.

       parts_DFS
           <u>Instance</u> <u>method.</u>  Return the list of all MIME::Entity objects included in the entity, starting
           with the entity itself, in depth-first-search order.  If the entity has no parts, it alone will
           be returned.

           <u>Thanks</u> <u>to</u> <u>Xavier</u> <u>Armengou</u> <u>for</u> <u>suggesting</u> <u>this</u> <u>method.</u>

       preamble [LINES]
           <u>Instance</u> <u>method.</u>  Get/set the text of the preamble, as an array of newline-terminated LINES.
           Returns a reference to the array of lines, or undef if no preamble exists (e.g., if this is a
           single-part entity).

           If there is a preamble, it is output when printing this entity; otherwise, a default preamble is
           used.  Setting the preamble to undef (not []!) causes it to fallback to the default.

       <b>Manipulation</b>


       make_multipart [SUBTYPE], OPTSHASH...
           <u>Instance</u> <u>method.</u>  Force the entity to be a multipart, if it isn't already.  We do this by
           replacing the original [singlepart] entity with a new multipart that has the same non-MIME
           headers ("From", "Subject", etc.), but all-new MIME headers ("Content-type", etc.).  We then
           create a copy of the original singlepart, <u>strip</u> <u>out</u> the non-MIME headers from that, and make it a
           part of the new multipart.  So this:

               From: me
               To: you
               Content-type: text/plain
               Content-length: 12

               Hello there!

           Becomes something like this:

               From: me
               To: you
               Content-type: multipart/mixed; boundary="----abc----"

               ------abc----<font color="#ffffff" class="whiteout">Content-type:&nbsp;------abc---Content-type:</font>
               Content-type: text/plain
               Content-length: 12

               Hello there!
               ------abc------<font color="#ffffff" class="whiteout">The&nbsp;------abc-----The</font>

           The actual type of the new top-level multipart will be "multipart/SUBTYPE" (default SUBTYPE is
           "mixed").

           Returns 'DONE'    if we really did inflate a singlepart to a multipart.  Returns 'ALREADY' (and
           does nothing) if entity is <u>already</u> multipart and Force was not chosen.

           If OPTSHASH contains Force=&gt;1, then we <u>always</u> bump the top-level's content and content-headers
           down to a subpart of this entity, even if this entity is already a multipart.  This is apparently
           of use to people who are tweaking messages after parsing them.

       make_singlepart
           <u>Instance</u> <u>method.</u>  If the entity is a multipart message with one part, this tries hard to rewrite
           it as a singlepart, by replacing the content (and content headers) of the top level with those of
           the part.  Also crunches 0-part multiparts into singleparts.

           Returns 'DONE'    if we really did collapse a multipart to a singlepart.  Returns 'ALREADY' (and
           does nothing) if entity is already a singlepart.  Returns '0'       (and does nothing) if it
           can't be made into a singlepart.

       purge
           <u>Instance</u> <u>method.</u>  Recursively purge (e.g., unlink) all external (e.g., on-disk) body parts in
           this message.  See <u>MIME::Body::purge()</u> for details.

           <b>Note:</b> this does <u>not</u> delete the directories that those body parts are contained in; only the
           actual message data files are deleted.  This is because some parsers may be customized to create
           intermediate directories while others are not, and it's impossible for this class to know what
           directories are safe to remove.  Only your application program truly knows that.

           <b>If</b> <b>you</b> <b>really</b> <b>want</b> <b>to</b> <b>"clean</b> <b>everything</b> <b>up",</b> one good way is to use "MIME::Parser::file_under()",
           and then do this before parsing your next message:

               $parser-&gt;filer-&gt;purge();

           I wouldn't attempt to read those body files after you do this, for obvious reasons.  As of MIME-<font color="#ffffff" class="whiteout">tools&nbsp;MIMEtools</font>
           tools 4.x, each body's path <u>is</u> undefined after this operation.  I warned you I might do this;
           truly I did.

           <u>Thanks</u> <u>to</u> <u>Jason</u> <u>L.</u> <u>Tibbitts</u> <u>III</u> <u>for</u> <u>suggesting</u> <u>this</u> <u>method.</u>

       remove_sig [NLINES]
           <u>Instance</u> <u>method,</u> <u>override.</u>  Attempts to remove a user's signature from the body of a message.

           It does this by looking for a line matching "/^-- $/" within the last "NLINES" of the message.
           If found then that line and all lines after it will be removed. If "NLINES" is not given, a
           default value of 10 will be used.  This would be of most use in auto-reply scripts.

           For MIME entity, this method is reasonably cautious: it will only attempt to un-sign a message
           with a content-type of "text/*".

           If you send <u>remove</u><b>_</b><u>sig()</u> to a multipart entity, it will relay it to the first part (the others
           usually being the "attachments").

           <b>Warning:</b> currently slurps the whole message-part into core as an array of lines, so you probably
           don't want to use this on extremely long messages.

           Returns truth on success, false on error.

       sign PARAMHASH
           <u>Instance</u> <u>method,</u> <u>override.</u>  Append a signature to the message.  The params are:

           Attach
               Instead of appending the text, add it to the message as an attachment.  The disposition will
               be "inline", and the description will indicate that it is a signature.  The default behavior
               is to append the signature to the text of the message (or the text of its first part if
               multipart).  <u>MIME-specific;</u> <u>new</u> <u>in</u> <u>this</u> <u>subclass.</u>

           File
               Use the contents of this file as the signature.  Fatal error if it can't be read.  <u>As</u> <u>per</u>
               <u>superclass</u> <u>method.</u>

           Force
               Sign it even if the content-type isn't "text/*".  Useful for non-standard types like
               "x-foobar", but be careful!  <u>MIME-specific;</u> <u>new</u> <u>in</u> <u>this</u> <u>subclass.</u>

           Remove
               Normally, we attempt to strip out any existing signature.  If true, this gives us the NLINES
               parameter of the remove_sig call.  If zero but defined, tells us <u>not</u> to remove any existing
               signature.  If undefined, removal is done with the default of 10 lines.  <u>New</u> <u>in</u> <u>this</u>
               <u>subclass.</u>

           Signature
               Use this text as the signature.  You can supply it as either a scalar, or as a ref to an
               array of newline-terminated scalars.  <u>As</u> <u>per</u> <u>superclass</u> <u>method.</u>

           For MIME messages, this method is reasonably cautious: it will only attempt to sign a message
           with a content-type of "text/*", unless "Force" is specified.

           If you send this message to a multipart entity, it will relay it to the first part (the others
           usually being the "attachments").

           <b>Warning:</b> currently slurps the whole message-part into core as an array of lines, so you probably
           don't want to use this on extremely long messages.

           Returns true on success, false otherwise.

       suggest_encoding
           <u>Instance</u> <u>method.</u>  Based on the effective content type, return a good suggested encoding.

           "text" and "message" types have their bodies scanned line-by-line for 8-bit characters and long
           lines; lack of either means that the message is 7bit-ok.  Other types are chosen independent of
           their body:

               Major type:      7bit ok?    Suggested encoding:
               -----------------------------------------------------------<font color="#ffffff" class="whiteout">text&nbsp;----------------------------------------------------------text</font>
               text             yes         7bit
               text             no          quoted-printable
               message          yes         7bit
               message          no          binary
               multipart        *           binary (in case some parts are bad)
               image, etc...    *           base64

       sync_headers OPTIONS
           <u>Instance</u> <u>method.</u>  This method does a variety of activities which ensure that the MIME headers of
           an entity "tree" are in-synch with the body parts they describe.  It can be as expensive an
           operation as printing if it involves pre-encoding the body parts; however, the aim is to produce
           fairly clean MIME.  <b>You</b> <b>will</b> <b>usually</b> <b>only</b> <b>need</b> <b>to</b> <b>invoke</b> <b>this</b> <b>if</b> <b>processing</b> <b>and</b> <b>re-sending</b> <b>MIME</b>
           <b>from</b> <b>an</b> <b>outside</b> <b>source.</b>

           The OPTIONS is a hash, which describes what is to be done.

           Length
               One of the "official unofficial" MIME fields is "Content-Length".  Normally, one doesn't care
               a whit about this field; however, if you are preparing output destined for HTTP, you may.
               The value of this option dictates what will be done:

               <b>COMPUTE</b> means to set a "Content-Length" field for every non-multipart part in the entity, and
               to blank that field out for every multipart part in the entity.

               <b>ERASE</b> means that "Content-Length" fields will all be blanked out.  This is fast, painless,
               and safe.

               <b>Any</b> <b>false</b> <b>value</b> (the default) means to take no action.

           Nonstandard
               Any header field beginning with "Content-" is, according to the RFC, a MIME field.  However,
               some are non-standard, and may cause problems with certain MIME readers which interpret them
               in different ways.

               <b>ERASE</b> means that all such fields will be blanked out.  This is done <u>before</u> the <b>Length</b> option
               (q.v.) is examined and acted upon.

               <b>Any</b> <b>false</b> <b>value</b> (the default) means to take no action.

           Returns a true value if everything went okay, a false value otherwise.

       tidy_body
           <u>Instance</u> <u>method,</u> <u>override.</u>  Currently unimplemented for MIME messages.  Does nothing, returns
           false.

       <b>Output</b>


       dump_skeleton [FILEHANDLE]
           <u>Instance</u> <u>method.</u>  Dump the skeleton of the entity to the given FILEHANDLE, or to the currently-<font color="#ffffff" class="whiteout">selected&nbsp;currentlyselected</font>
           selected one if none given.

           Each entity is output with an appropriate indentation level, the following selection of
           attributes:

               Content-type: multipart/mixed
               Effective-type: multipart/mixed
               Body-file: NONE
               Subject: Hey there!
               Num-parts: 2

           This is really just useful for debugging purposes; I make no guarantees about the consistency of
           the output format over time.

       print [OUTSTREAM]
           <u>Instance</u> <u>method,</u> <u>override.</u>  Print the entity to the given OUTSTREAM, or to the currently-selected
           filehandle if none given.  OUTSTREAM can be a filehandle, or any object that reponds to a <u>print()</u>
           message.

           The entity is output as a valid MIME stream!  This means that the header is always output first,
           and the body data (if any) will be encoded if the header says that it should be.  For example,
           your output may look like this:

               Subject: Greetings
               Content-transfer-encoding: base64

               SGkgdGhlcmUhCkJ5ZSB0aGVyZSEK

           <u>If</u> <u>this</u> <u>entity</u> <u>has</u> <u>MIME</u> <u>type</u> <u>"multipart/*",</u> the preamble, parts, and epilogue are all output with
           appropriate boundaries separating each.  Any bodyhandle is ignored:

               Content-type: multipart/mixed; boundary="*----*"
               Content-transfer-encoding: 7bit

               [Preamble]
               --*----*
               [Entity: Part 0]
               --*----*
               [Entity: Part 1]
               --*----*--<font color="#ffffff" class="whiteout">[Epilogue]&nbsp;--*----*-[Epilogue]</font>
               [Epilogue]

           <u>If</u> <u>this</u> <u>entity</u> <u>has</u> <u>a</u> <u>single-part</u> <u>MIME</u> <u>type</u> <u>with</u> <u>no</u> <u>attached</u> <u>parts,</u> then we're looking at a normal
           singlepart entity: the body is output according to the encoding specified by the header.  If no
           body exists, a warning is output and the body is treated as empty:

               Content-type: image/gif
               Content-transfer-encoding: base64

               [Encoded body]

           <u>If</u> <u>this</u> <u>entity</u> <u>has</u> <u>a</u> <u>single-part</u> <u>MIME</u> <u>type</u> <u>but</u> <u>it</u> <u>also</u> <u>has</u> <u>parts,</u> then we're probably looking at
           a "re-parsed" singlepart, usually one of type "message/*" (you can get entities like this if you
           set the "parse_nested_messages(NEST)" option on the parser to true).  In this case, the parts are
           output with single blank lines separating each, and any bodyhandle is ignored:

               Content-type: message/rfc822
               Content-transfer-encoding: 7bit

               [Entity: Part 0]

               [Entity: Part 1]

           In all cases, when outputting a "part" of the entity, this method is invoked recursively.

           <b>Note:</b> the output is very likely <u>not</u> going to be identical to any input you parsed to get this
           entity.  If you're building some sort of email handler, it's up to you to save this information.

       print_body [OUTSTREAM]
           <u>Instance</u> <u>method,</u> <u>override.</u>  Print the body of the entity to the given OUTSTREAM, or to the
           currently-selected filehandle if none given.  OUTSTREAM can be a filehandle, or any object that
           reponds to a <u>print()</u> message.

           The body is output for inclusion in a valid MIME stream; this means that the body data will be
           encoded if the header says that it should be.

           <b>Note:</b> by "body", we mean "the stuff following the header".  A printed multipart body includes the
           printed representations of its subparts.

           <b>Note:</b> The body is <u>stored</u> in an un-encoded form; however, the idea is that the transfer encoding
           is used to determine how it should be <u>output.</u>  This means that the "print()" method is always
           guaranteed to get you a sendmail-ready stream whose body is consistent with its head.  If you
           want the <u>raw</u> <u>body</u> <u>data</u> to be output, you can either read it from the bodyhandle yourself, or use:

               $ent-&gt;bodyhandle-&gt;print($outstream);

           which uses <u>read()</u> calls to extract the information, and thus will work with both text and binary
           bodies.

           <b>Warning:</b> Please supply an OUTSTREAM.  This override method differs from Mail::Internet's
           behavior, which outputs to the STDOUT if no filehandle is given: this may lead to confusion.

       print_header [OUTSTREAM]
           <u>Instance</u> <u>method,</u> <u>inherited.</u>  Output the header to the given OUTSTREAM.  You really should supply
           the OUTSTREAM.

       stringify
           <u>Instance</u> <u>method.</u>  Return the entity as a string, exactly as "print" would print it.  The body
           will be encoded as necessary, and will contain any subparts.  You can also use "as_string()".

       stringify_body
           <u>Instance</u> <u>method.</u>  Return the <u>encoded</u> message body as a string, exactly as "print_body" would
           print it.  You can also use "body_as_string()".

           If you want the <u>unencoded</u> body, and you are dealing with a singlepart message (like a
           "text/plain"), use "bodyhandle()" instead:

               if ($ent-&gt;bodyhandle) {
                   $unencoded_data = $ent-&gt;bodyhandle-&gt;as_string;
               }
               else {
                   ### this message has no body data (but it might have parts!)
               }

       stringify_header
           <u>Instance</u> <u>method.</u>  Return the header as a string, exactly as "print_header" would print it.  You
           can also use "header_as_string()".

<b>NOTES</b>
       <b>Under</b> <b>the</b> <b>hood</b>

       A <b>MIME::Entity</b> is composed of the following elements:

          A <u>head</u>, which is a reference to a MIME::Head object containing the header information.

          A <u>bodyhandle</u>, which is a reference to a MIME::Body object containing the decoded body data.  This
           is only defined if the message is a "singlepart" type:

               application/*
               audio/*
               image/*
               text/*
               video/*

          An array of <u>parts</u>, where each part is a MIME::Entity object.  The number of parts will only be
           nonzero if the content-type is <u>not</u> one of the "singlepart" types:

               message/*        (should have exactly one part)
               multipart/*      (should have one or more parts)

       <b>The</b> <b>"two-body</b> <b>problem"</b>

       MIME::Entity and Mail::Internet see message bodies differently, and this can cause confusion and some
       inconvenience.  Sadly, I can't change the behavior of MIME::Entity without breaking lots of code
       already out there.  But let's open up the floor for a few questions...

       What is the difference between a "message" and an "entity"?
           A <b>message</b> is the actual data being sent or received; usually this means a stream of newline-<font color="#ffffff" class="whiteout">terminated&nbsp;newlineterminated</font>
           terminated lines.  An <b>entity</b> is the representation of a message as an object.

           This means that you get a "message" when you print an "entity" <u>to</u> a filehandle, and you get an
           "entity" when you parse a message <u>from</u> a filehandle.

       What is a message body?
           <b>Mail::Internet:</b> The portion of the printed message after the header.

           <b>MIME::Entity:</b> The portion of the printed message after the header.

       How is a message body stored in an entity?
           <b>Mail::Internet:</b> As an array of lines.

           <b>MIME::Entity:</b> It depends on the content-type of the message.  For "container" types
           ("multipart/*", "message/*"), we store the contained entities as an array of "parts", accessed
           via the "parts()" method, where each part is a complete MIME::Entity.  For "singlepart" types
           ("text/*", "image/*", etc.), the unencoded body data is referenced via a MIME::Body object,
           accessed via the "bodyhandle()" method:

                                 bodyhandle()   parts()
               Content-type:     returns:       returns:
               ------------------------------------------------------------<font color="#ffffff" class="whiteout">application/*&nbsp;-----------------------------------------------------------application/*</font>
               application/*     MIME::Body     empty
               audio/*           MIME::Body     empty
               image/*           MIME::Body     empty
               message/*         undef          MIME::Entity list (usually 1)
               multipart/*       undef          MIME::Entity list (usually &gt;0)
               text/*            MIME::Body     empty
               video/*           MIME::Body     empty
               x-*/*             MIME::Body     empty

           As a special case, "message/*" is currently ambiguous: depending on the parser, a "message/*"
           might be treated as a singlepart, with a MIME::Body and no parts.  Use <u>bodyhandle()</u> as the final
           arbiter.

       What does the <u>body()</u> method return?
           <b>Mail::Internet:</b> As an array of lines, ready for sending.

           <b>MIME::Entity:</b> As an array of lines, ready for sending.

       If an entity has a body, does it have a soul as well?
           The soul does not exist in a corporeal sense, the way the body does; it is not a solid [Perl]
           object.  Rather, it is a virtual object which is only visible when you <u>print()</u> an entity to a
           file... in other words, the "soul" it is all that is left after the body is DESTROY'ed.

       What's the best way to get at the body data?
           <b>Mail::Internet:</b> Use the <u>body()</u> method.

           <b>MIME::Entity:</b> Depends on what you want... the <u>encoded</u> data (as it is transported), or the
           <u>unencoded</u> data?  Keep reading...

       How do I get the "encoded" body data?
           <b>Mail::Internet:</b> Use the <u>body()</u> method.

           <b>MIME::Entity:</b> Use the <u>body()</u> method.  You can also use:

               $entity-&gt;print_body()
               $entity-&gt;stringify_body()   ### a.k.a. $entity-&gt;body_as_string()

       How do I get the "unencoded" body data?
           <b>Mail::Internet:</b> Use the <u>body()</u> method.

           <b>MIME::Entity:</b> Use the <u>bodyhandle()</u> method!  If <u>bodyhandle()</u> method returns true, then that value
           is a MIME::Body which can be used to access the data via its <u>open()</u> method.  If <u>bodyhandle()</u>
           method returns an undefined value, then the entity is probably a "container" that has no real
           body data of its own (e.g., a "multipart" message): in this case, you should access the
           components via the <u>parts()</u> method.  Like this:

               if ($bh = $entity-&gt;bodyhandle) {
                   $io = $bh-&gt;open;
                   ...access unencoded data via $io-&gt;getline or $io-&gt;read...
                   $io-&gt;close;
               }
               else {
                   foreach my $part (@parts) {
                       ...do something with the part...
                   }
               }

           You can also use:

               if ($bh = $entity-&gt;bodyhandle) {
                   $unencoded_data = $bh-&gt;as_string;
               }
               else {
                   ...do stuff with the parts...
               }

       What does the <u>body()</u> method return?
           <b>Mail::Internet:</b> The transport-encoded message body, as an array of lines.

           <b>MIME::Entity:</b> The transport-encoded message body, as an array of lines.

       What does <u>print</u><b>_</b><u>body()</u> print?
           <b>Mail::Internet:</b> Exactly what <u>body()</u> would return to you.

           <b>MIME::Entity:</b> Exactly what <u>body()</u> would return to you.

       Say I have an entity which might be either singlepart or multipart. How do I print out just "the
       stuff after the header"?
           <b>Mail::Internet:</b> Use <u>print</u><b>_</b><u>body()</u>.

           <b>MIME::Entity:</b> Use <u>print</u><b>_</b><u>body()</u>.

       Why is MIME::Entity so different from Mail::Internet?
           Because MIME streams are expected to have non-textual data...  possibly, quite a lot of it, such
           as a tar file.

           Because MIME messages can consist of multiple parts, which are most-easily manipulated as
           MIME::Entity objects themselves.

           Because in the simpler world of Mail::Internet, the data of a message and its printed
           representation are <u>identical</u>... and in the MIME world, they're not.

           Because parsing multipart bodies on-the-fly, or formatting multipart bodies for output, is a non-<font color="#ffffff" class="whiteout">trivial&nbsp;nontrivial</font>
           trivial task.

       This is confusing.  Can the two classes be made more compatible?
           Not easily; their implementations are necessarily quite different.  Mail::Internet is a simple,
           efficient way of dealing with a "black box" mail message... one whose internal data you don't
           care much about.  MIME::Entity, in contrast, cares <u>very</u> <u>much</u> about the message contents: that's
           its job!

       <b>Design</b> <b>issues</b>


       Some things just can't be ignored
           In multipart messages, the <u>"preamble"</u> is the portion that precedes the first encapsulation
           boundary, and the <u>"epilogue"</u> is the portion that follows the last encapsulation boundary.

           According to RFC-1521:

               There appears to be room for additional information prior
               to the first encapsulation boundary and following the final
               boundary.  These areas should generally be left blank, and
               implementations must ignore anything that appears before the
               first boundary or after the last one.

               NOTE: These "preamble" and "epilogue" areas are generally
               not used because of the lack of proper typing of these parts
               and the lack of clear semantics for handling these areas at
               gateways, particularly X.400 gateways.  However, rather than
               leaving the preamble area blank, many MIME implementations
               have found this to be a convenient place to insert an
               explanatory note for recipients who read the message with
               pre-MIME software, since such notes will be ignored by
               MIME-compliant software.

           In the world of standards-and-practices, that's the standard.  Now for the practice:

           <u>Some</u> <u>"MIME"</u> <u>mailers</u> <u>may</u> <u>incorrectly</u> <u>put</u> <u>a</u> <u>"part"</u> <u>in</u> <u>the</u> <u>preamble</u>.  Since we have to parse over
           the stuff <u>anyway</u>, in the future I <u>may</u> allow the parser option of creating special MIME::Entity
           objects for the preamble and epilogue, with bogus MIME::Head objects.

           For now, though, we're MIME-compliant, so I probably won't change how we work.

<b>AUTHOR</b>
       Eryq (<u>eryq@zeegee.com</u>), ZeeGee Software Inc (<a href="http://www.zeegee.com)"><u>http://www.zeegee.com</u>)</u></a><u>  David F. Skoll
       (dfs@roaringpenguin.com) <a href="http://www.roaringpenguin.com">http://www.roaringpenguin.com</u></a><u>

       All rights reserved.  This program is free software; you can redistribute it and/or modify it under
       the same terms as Perl itself.

<b>VERSION</b>
       $Revision: 1.18 $ $Date: 2006/03/17 21:15:49 $



perl v5.8.8                                      2006-03-17                                  MIME::Entity(3)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/MIME__Entity.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/MIME__Entity.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/MIME__Entity.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
