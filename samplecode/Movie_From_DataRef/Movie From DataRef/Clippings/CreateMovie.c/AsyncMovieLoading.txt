		// Handle asynchronous movie loading here. We use the new		// GetMovieLoadState function to determine the load state		// of the movie.		do		{			long newLoadState;						// Get new load state to see if there was a change in			// state.			newLoadState = GetMovieLoadState(theMovie);			if (newLoadState != loadState)			{				loadState = newLoadState;				if (loadState < 0)				{					// failed to load the movie - this will cause					// us to drop out of this loop and report an					// error				}								if (loadState < kMovieLoadStatePlayable)				{					// we need to keep tasking the movie so it gets					// time to load										MoviesTask(theMovie, 0);				}								if (loadState < kMovieLoadStateComplete)				{					// we just became playable				}								if (loadState >= kMovieLoadStateComplete)				{					// now we know all media data is available					// this will drop us out of this loop so we					// can display the movie				}			}		} 		while ((loadState > kMovieLoadStateError) && (loadState < kMovieLoadStateComplete));				CheckError(err, "NewMovieFromDataRef error");				// dispose of our data reference handle since it is no longer needed		DisposeHandle(dataRef);				result = GetMovieStatus (theMovie, &firstProblemTrack);				// if GetMovieLoadState from above returned kMovieLoadStateError, and		// GetMovieStatus returns nil for the firstProblemTrack parameter we		// know an error occurred		if ((loadState == kMovieLoadStateError) && (firstProblemTrack == nil))		{			CheckError(-1, "NewMovieFromDataRef error");		}