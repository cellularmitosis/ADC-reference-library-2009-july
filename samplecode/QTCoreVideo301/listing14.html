<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>QTCoreVideo301 - /Classes/OpenGL/Shaders/ShaderUnit/GLSLUnit.m</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../index.html#//apple_ref/doc/uid/TP30000925" target="_top">Sample Code</a> &gt; <a href="../GraphicsImaging/index.html#//apple_ref/doc/uid/TP30000925-TP30000424" target="_top">Graphics &amp; Imaging</a> &gt; <a href="../GraphicsImaging/idxQuickTime-date.html#//apple_ref/doc/uid/TP30000925-TP30000424-TP30000457">QuickTime</a> &gt; <A HREF="javascript:location.replace('index.html');">QTCoreVideo301</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->


	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">QTCoreVideo301</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Classes/OpenGL/Shaders/ShaderUnit/GLSLUnit.m</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Classes/Alert/Alert.c</option>
<option value="listing2.html">/Classes/Alert/Alert.h</option>
<option value="listing3.html">/Classes/Alert/AlertPanelKit.h</option>
<option value="listing4.html">/Classes/Alert/AlertPanelKit.m</option>
<option value="listing5.html">/Classes/MemObject/MemObject.h</option>
<option value="listing6.html">/Classes/MemObject/MemObject.m</option>
<option value="listing7.html">/Classes/MemObject/Memory.c</option>
<option value="listing8.html">/Classes/MemObject/Memory.h</option>
<option value="listing9.html">/Classes/OpenGL/Quad/OpenGLQuad.h</option>
<option value="listing10.html">/Classes/OpenGL/Quad/OpenGLQuad.m</option>
<option value="listing11.html">/Classes/OpenGL/Shaders/ShaderKit/GLSLKit.h</option>
<option value="listing12.html">/Classes/OpenGL/Shaders/ShaderKit/GLSLKit.m</option>
<option value="listing13.html">/Classes/OpenGL/Shaders/ShaderUnit/GLSLUnit.h</option>
<option value="listing14.html">/Classes/OpenGL/Shaders/ShaderUnit/GLSLUnit.m</option>
<option value="listing15.html">/Classes/OpenGL/Shaders/ShaderUnit/GLSLUnitDictConsts.h</option>
<option value="listing16.html">/Classes/OpenGL/Shaders/ShaderUnit/GLSLUnitsController.h</option>
<option value="listing17.html">/Classes/OpenGL/Shaders/ShaderUnit/GLSLUnitsController.m</option>
<option value="listing18.html">/Classes/OpenGL/Shaders/Types/GLSLTypes.h</option>
<option value="listing19.html">/Classes/OpenGL/Shaders/Units/Blur/GLSLBlurUnit.h</option>
<option value="listing20.html">/Classes/OpenGL/Shaders/Units/Blur/GLSLBlurUnit.m</option>
<option value="listing21.html">/Classes/OpenGL/Shaders/Units/Brighten/GLSLBrightenUnit.h</option>
<option value="listing22.html">/Classes/OpenGL/Shaders/Units/Brighten/GLSLBrightenUnit.m</option>
<option value="listing23.html">/Classes/OpenGL/Shaders/Units/ColorInvert/GLSLColorInvertUnit.h</option>
<option value="listing24.html">/Classes/OpenGL/Shaders/Units/ColorInvert/GLSLColorInvertUnit.m</option>
<option value="listing25.html">/Classes/OpenGL/Shaders/Units/Dilation/GLSLDilationUnit.h</option>
<option value="listing26.html">/Classes/OpenGL/Shaders/Units/Dilation/GLSLDilationUnit.m</option>
<option value="listing27.html">/Classes/OpenGL/Shaders/Units/EdgeDetection/GLSLEdgeDetectionUnit.h</option>
<option value="listing28.html">/Classes/OpenGL/Shaders/Units/EdgeDetection/GLSLEdgeDetectionUnit.m</option>
<option value="listing29.html">/Classes/OpenGL/Shaders/Units/Erosion/GLSLErosionUnit.h</option>
<option value="listing30.html">/Classes/OpenGL/Shaders/Units/Erosion/GLSLErosionUnit.m</option>
<option value="listing31.html">/Classes/OpenGL/Shaders/Units/ExtractColor/GLSLExtractColorUnit.h</option>
<option value="listing32.html">/Classes/OpenGL/Shaders/Units/ExtractColor/GLSLExtractColorUnit.m</option>
<option value="listing33.html">/Classes/OpenGL/Shaders/Units/Fog/GLSLFogUnit.h</option>
<option value="listing34.html">/Classes/OpenGL/Shaders/Units/Fog/GLSLFogUnit.m</option>
<option value="listing35.html">/Classes/OpenGL/Shaders/Units/GrayInvert/GLSLGrayInvertUnit.h</option>
<option value="listing36.html">/Classes/OpenGL/Shaders/Units/GrayInvert/GLSLGrayInvertUnit.m</option>
<option value="listing37.html">/Classes/OpenGL/Shaders/Units/Grayscale/GLSLGrayscaleUnit.h</option>
<option value="listing38.html">/Classes/OpenGL/Shaders/Units/Grayscale/GLSLGrayscaleUnit.m</option>
<option value="listing39.html">/Classes/OpenGL/Shaders/Units/HeatSig/GLSLHeatSignatureUnit.h</option>
<option value="listing40.html">/Classes/OpenGL/Shaders/Units/HeatSig/GLSLHeatSignatureUnit.m</option>
<option value="listing41.html">/Classes/OpenGL/Shaders/Units/Saturation/GLSLSaturationUnit.h</option>
<option value="listing42.html">/Classes/OpenGL/Shaders/Units/Saturation/GLSLSaturationUnit.m</option>
<option value="listing43.html">/Classes/OpenGL/Shaders/Units/Sepia/GLSLSepiaUnit.h</option>
<option value="listing44.html">/Classes/OpenGL/Shaders/Units/Sepia/GLSLSepiaUnit.m</option>
<option value="listing45.html">/Classes/OpenGL/Shaders/Units/Sharpen/GLSLSharpenUnit.h</option>
<option value="listing46.html">/Classes/OpenGL/Shaders/Units/Sharpen/GLSLSharpenUnit.m</option>
<option value="listing47.html">/Classes/OpenGL/Shaders/Units/Sky/GLSLSkyUnit.h</option>
<option value="listing48.html">/Classes/OpenGL/Shaders/Units/Sky/GLSLSkyUnit.m</option>
<option value="listing49.html">/Classes/OpenGL/Shaders/Units/Toon/GLSLToonUnit.h</option>
<option value="listing50.html">/Classes/OpenGL/Shaders/Units/Toon/GLSLToonUnit.m</option>
<option value="listing51.html">/Classes/OpenGL/View/OpenGLViewKit.h</option>
<option value="listing52.html">/Classes/OpenGL/View/OpenGLViewKit.m</option>
<option value="listing53.html">/Classes/QT/CoreVideo/QTCoreVideoController.h</option>
<option value="listing54.html">/Classes/QT/CoreVideo/QTCoreVideoController.m</option>
<option value="listing55.html">/Classes/QT/CoreVideo/QTCoreVideoOpenGLView.h</option>
<option value="listing56.html">/Classes/QT/CoreVideo/QTCoreVideoOpenGLView.m</option>
<option value="listing57.html">/Classes/QT/VisualContext/QTVisualContextKit.h</option>
<option value="listing58.html">/Classes/QT/VisualContext/QTVisualContextKit.m</option>
<option value="listing59.html">/main.m</option>
<option value="listing60.html">/QTCoreVideo301_Prefix.pch</option></select>
				</p>
				</form>
				<p><strong><a href="QTCoreVideo301.zip">Download Sample</a></strong> (&#147;QTCoreVideo301.zip&#148;, 1.56M)<BR>
<strong><a href="QTCoreVideo301.dmg">Download Sample</a></strong> (&#147;QTCoreVideo301.dmg&#148;, 1.83M)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">//---------------------------------------------------------------------------
//
//    File: GLSLUnit.h
//
//  Abstract: A utility toolkit for managing shaders along with their 
//            uniforms
//                         
//  Disclaimer: IMPORTANT:  This Apple software is supplied to you by
//  Inc. (&quot;Apple&quot;) in consideration of your agreement to the following terms, 
//  and your use, installation, modification or redistribution of this Apple 
//  software constitutes acceptance of these terms.  If you do not agree with 
//  these terms, please do not use, install, modify or redistribute this 
//  Apple software.
//  
//  In consideration of your agreement to abide by the following terms, and
//  subject to these terms, Apple grants you a personal, non-exclusive
//  license, under Apple&apos;s copyrights in this original Apple software (the
//  &quot;Apple Software&quot;), to use, reproduce, modify and redistribute the Apple
//  Software, with or without modifications, in source and/or binary forms;
//  provided that if you redistribute the Apple Software in its entirety and
//  without modifications, you must retain this notice and the following
//  text and disclaimers in all such redistributions of the Apple Software. 
//  Neither the name, trademarks, service marks or logos of Apple Inc. may 
//  be used to endorse or promote products derived from the Apple Software 
//  without specific prior written permission from Apple.  Except as 
//  expressly stated in this notice, no other rights or licenses, express
//  or implied, are granted by Apple herein, including but not limited to
//  any patent rights that may be infringed by your derivative works or by
//  other works in which the Apple Software may be incorporated.
//  
//  The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE
//  MAKES NO WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION
//  THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS
//  FOR A PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND
//  OPERATION ALONE OR IN COMBINATION WITH YOUR PRODUCTS.
//  
//  IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL
//  OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
//  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
//  INTERRUPTION) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION,
//  MODIFICATION AND/OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED
//  AND WHETHER UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE),
//  STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
// 
//  Copyright (c) 2004-2007 Apple Inc., All rights reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------

#import &quot;MemObject.h&quot;

#import &quot;GLSLUnit.h&quot;

//------------------------------------------------------------------------

//------------------------------------------------------------------------

static const GLuint kSizeOfGLint   = sizeof(GLint);
static const GLuint kSizeOfGLfloat = sizeof(GLfloat);

//------------------------------------------------------------------------

//------------------------------------------------------------------------

@implementation GLSLUnit

//------------------------------------------------------------------------

#pragma mark -- initializer --

//------------------------------------------------------------------------

- (void) initUniformLocForIntValue:(NSDictionary *)theSamplerDict
{
    NSString *theSamplerKey;
    
    NSNumber  *theSamplerNumber;
    
    GLint  theSamplerLoc   = 0;
    GLint  theSamplerValue = 0;
    
    [self enable];
    
        for (theSamplerKey in theSamplerDict) 
        {
            theSamplerNumber = [theSamplerDict objectForKey:theSamplerKey];
            theSamplerValue  = [theSamplerNumber integerValue];
            theSamplerLoc    = [self uniformLocation:theSamplerKey];
                    
            glUniform1iARB(theSamplerLoc, theSamplerValue);
        } // for
    
    [self disable];
} // initUniformLocForIntValue

//------------------------------------------------------------------------

- (id) initWithShadersInAppBundleAndSamplers:(NSString *)theShadersName
                                        size:(const NSSize *)theSize
                                        samplers:(NSDictionary *)theSamplersDict
{
    self = [super initWithGLSLShadersInAppBundle:theShadersName];
    
    if ( self )
    {
        // Get sampler uniforms
        
        [self initUniformLocForIntValue:theSamplersDict];

        // Initialize a quad of size for rendering the results
        
        quad = [[OpenGLQuad alloc] initQuadWithSize:theSize range:1];
    } // if
    
    return self;
} // initWithShadersInAppBundleAndSamplers

//------------------------------------------------------------------------

#pragma mark -- Deallocating Resources --

//------------------------------------------------------------------------

- (void) dealloc
{
    // Quad is no longer needed
    
    if ( quad )
    {
        [quad release];
        
        quad = nil;
    } // if
    
    // Dealloc the superclass
    
    [super dealloc];
} // dealloc

//------------------------------------------------------------------------

#pragma mark -- Integer Scalar Uniforms --

//---------------------------------------------------------------------------

- (void) uniform1i:(const GLint)theUniformLocation
            value:(const GLint)theUniformValue
{
    [self enable];
    
        glUniform1iARB( theUniformLocation, theUniformValue );
        
    [self disable];
} // uniform1i

//---------------------------------------------------------------------------

- (void) uniform2i:(const GLint)theUniformLocation
            values:(const GLint *)theUniformValues
{
    [self enable];
    
        glUniform2iARB(    theUniformLocation, 
                        theUniformValues[0], 
                        theUniformValues[1] );        
        
    [self disable];
} // uniform2i

//---------------------------------------------------------------------------

- (void) uniform3i:(const GLint)theUniformLocation
            values:(const GLint *)theUniformValues
{
    [self enable];
    
        glUniform3iARB(    theUniformLocation, 
                        theUniformValues[0], 
                        theUniformValues[1], 
                        theUniformValues[2] );        
        
    [self disable];
} // uniform3i

//---------------------------------------------------------------------------

- (void) uniform4i:(const GLint)theUniformLocation
            values:(const GLint *)theUniformValues
{
    [self enable];
    
        glUniform4iARB(    theUniformLocation, 
                        theUniformValues[0], 
                        theUniformValues[1], 
                        theUniformValues[2], 
                        theUniformValues[3] );        
        
    [self disable];
} // uniform4i

//------------------------------------------------------------------------

#pragma mark -- Scalar Float Uniforms --

//---------------------------------------------------------------------------

- (void) uniform1f:(const GLint)theUniformLocation
            value:(const GLfloat)theUniformValue
{
    [self enable];
    
        glUniform1fARB( theUniformLocation, theUniformValue );
        
    [self disable];
} // uniform1f

//---------------------------------------------------------------------------

- (void) uniform2f:(const GLint)theUniformLocation
            values:(const GLfloat *)theUniformValues
{
    [self enable];
    
        glUniform2fARB(    theUniformLocation, 
                        theUniformValues[0], 
                        theUniformValues[1] );        
        
    [self disable];
} // uniform2f

//---------------------------------------------------------------------------

- (void) uniform3f:(const GLint)theUniformLocation
            values:(const GLfloat *)theUniformValues
{
    [self enable];
    
        glUniform3fARB(    theUniformLocation, 
                        theUniformValues[0], 
                        theUniformValues[1], 
                        theUniformValues[2] );        
        
    [self disable];
} // uniform3f

//---------------------------------------------------------------------------

- (void) uniform4f:(const GLint)theUniformLocation
            values:(const GLfloat *)theUniformValues
{
    [self enable];
    
        glUniform4fARB(    theUniformLocation, 
                        theUniformValues[0], 
                        theUniformValues[1], 
                        theUniformValues[2], 
                        theUniformValues[3] );        
        
    [self disable];
} // uniform4f

//------------------------------------------------------------------------

#pragma mark -- Integer Vector Uniforms --

//---------------------------------------------------------------------------

- (void) uniform1iv:(const GLint)theUniformLocation
            count:(const GLsizei)theUniformCount
            values:(const GLint *)theUniformValues
{
    [self enable];
    
        glUniform1ivARB( theUniformLocation, theUniformCount, theUniformValues );
        
    [self disable];
} // uniform1iv

//---------------------------------------------------------------------------

- (void) uniform2iv:(const GLint)theUniformLocation
            count:(const GLsizei)theUniformCount
            values:(const GLint *)theUniformValues
{
    [self enable];
    
        glUniform2ivARB( theUniformLocation, theUniformCount, theUniformValues );
        
    [self disable];
} // uniform2iv

//---------------------------------------------------------------------------

- (void) uniform3iv:(const GLint)theUniformLocation
            count:(const GLsizei)theUniformCount
            values:(const GLint *)theUniformValues
{
    [self enable];
    
        glUniform3ivARB( theUniformLocation, theUniformCount, theUniformValues );
        
    [self disable];
} // uniform3iv

//---------------------------------------------------------------------------

- (void) uniform4iv:(const GLint)theUniformLocation
            count:(const GLsizei)theUniformCount
            values:(const GLint *)theUniformValues
{
    [self enable];
    
        glUniform4ivARB( theUniformLocation, theUniformCount, theUniformValues );
        
    [self disable];
} // uniform4iv

//------------------------------------------------------------------------

#pragma mark -- Float Vector Uniforms --

//---------------------------------------------------------------------------

- (void) uniform1fv:(const GLint)theUniformLocation
            count:(const GLsizei)theUniformCount
            values:(const GLfloat *)theUniformValues
{
    [self enable];
    
        glUniform1fvARB( theUniformLocation, theUniformCount, theUniformValues );
        
    [self disable];
} // uniform1fv

//---------------------------------------------------------------------------

- (void) uniform2fv:(const GLint)theUniformLocation
            count:(const GLsizei)theUniformCount
            values:(const GLfloat *)theUniformValues
{
    [self enable];
    
        glUniform2fvARB( theUniformLocation, theUniformCount, theUniformValues );
        
    [self disable];
} // uniform2fv

//---------------------------------------------------------------------------

- (void) uniform3fv:(const GLint)theUniformLocation
            count:(const GLsizei)theUniformCount
            values:(const GLfloat *)theUniformValues
{
    [self enable];
    
        glUniform3fvARB( theUniformLocation, theUniformCount, theUniformValues );
        
    [self disable];
} // uniform3fv

//---------------------------------------------------------------------------

- (void) uniform4fv:(const GLint)theUniformLocation
            count:(const GLsizei)theUniformCount
            values:(const GLfloat *)theUniformValues
{
    [self enable];
    
        glUniform4fvARB( theUniformLocation, theUniformCount, theUniformValues );
        
    [self disable];
} // uniform4fv

//------------------------------------------------------------------------

#pragma mark -- Float Matrix Uniforms --

//---------------------------------------------------------------------------

- (void) uniformMatrix2fv:(const GLint)theUniformLocation
                    count:(const GLsizei)theUniformCount
                    tanspose:(const GLboolean)theTransposeFlag
                    values:(const GLfloat *)theUniformValues
{
    [self enable];
    
        glUniformMatrix2fvARB(    theUniformLocation, 
                                theUniformCount, 
                                theTransposeFlag, 
                                theUniformValues );
        
    [self disable];
} // uniformMatrix2fv

//---------------------------------------------------------------------------

- (void) uniformMatrix3fv:(const GLint)theUniformLocation
                    count:(const GLsizei)theUniformCount
                    tanspose:(const GLboolean)theTransposeFlag
                    values:(const GLfloat *)theUniformValues
{
    [self enable];
    
        glUniformMatrix3fvARB(    theUniformLocation, 
                                theUniformCount, 
                                theTransposeFlag, 
                                theUniformValues );
        
    [self disable];
} // uniformMatrix3fv

//---------------------------------------------------------------------------

- (void) uniformMatrix4fv:(const GLint)theUniformLocation
                    count:(const GLsizei)theUniformCount
                    tanspose:(const GLboolean)theTransposeFlag
                    values:(const GLfloat *)theUniformValues
{
    [self enable];
    
        glUniformMatrix4fvARB(    theUniformLocation, 
                                theUniformCount, 
                                theTransposeFlag, 
                                theUniformValues );
        
    [self disable];
} // uniformMatrix4fv

//------------------------------------------------------------------------

#pragma mark -- Setting Integer Uniform Dictionaries --

//------------------------------------------------------------------------

- (NSDictionary *) getDictUniformIntScalar:(const GLint)theUniformLoc 
                                    value:(const GLint)theUniformValue
{
    NSArray *uniformKeys = [NSArray arrayWithObjects:    kUniformLocKey,
                                                        kUniformTypeKey,
                                                        kUniformValueKey,
                                                        nil ];
    
    NSArray *uniformObjects = [NSArray arrayWithObjects:[NSNumber numberWithInt:theUniformLoc],
                                                        [NSNumber numberWithInt:kUniform1i],
                                                        [NSNumber numberWithInt:theUniformValue],
                                                        nil ];
    
    NSDictionary *uniformDict = [[NSDictionary alloc] initWithObjects:uniformObjects
                                                              forKeys:uniformKeys];
    return  uniformDict;
} // getDictUniform1i

//------------------------------------------------------------------------

- (NSDictionary *) getDictUniformIntScalars:(const GLint)theUniformLoc
                                    type:(const UniformScalarTypes)theUniformScalarType
                                    value:(const GLint *)theUniformValue
{
    NSDictionary *uniformDict = nil;
    
    if ( ( theUniformScalarType &gt; kScalar ) &amp;&amp; ( theUniformScalarType &lt;= k4Scalars ) )
    {
        NSArray *uniformKeys = [NSArray arrayWithObjects:    kUniformLocKey,
                                                            kUniformTypeKey,
                                                            kUniformValueKey,
                                                            nil ];
        
        NSNumber    *uniformLoc     = [NSNumber numberWithInt:theUniformLoc];
        NSUInteger   uniformLength  = theUniformScalarType * kSizeOfGLint;
        NSData      *uniformValues  = [NSData dataWithBytes:theUniformValue length:uniformLength];
        NSNumber    *uniformType    = nil;
        NSArray     *uniformObjects = nil;
        
        switch( theUniformScalarType )
        {
            case k2Scalars:
                uniformType  = [NSNumber numberWithInt:kUniform2i];
                break;
            case k3Scalars:
                uniformType  = [NSNumber numberWithInt:kUniform3i];
                break;
            case k4Scalars:
                uniformType  = [NSNumber numberWithInt:kUniform4i];
                break;
        } // switch
        
        uniformObjects = [NSArray arrayWithObjects:uniformLoc,uniformType,uniformValues,nil];
        uniformDict    = [[NSDictionary alloc] initWithObjects:uniformObjects forKeys:uniformKeys];
    } // if
    
    return  uniformDict;
} // getDictUniformIntScalars

//------------------------------------------------------------------------

- (NSDictionary *) getDictUniformIntVectors:(const GLint)theUniformLoc
                                    type:(const UniformVectorTypes)theUniformVectorType
                                    count:(const GLuint)theUniformVectorCount
                                    vectors:(const GLint *)theUniformVectors
{
    NSDictionary *uniformDict = nil;
    
    if ( theUniformVectorCount &gt;= 1 )
    {
        NSArray *uniformKeys = [NSArray arrayWithObjects:    kUniformLocKey,
                                                            kUniformTypeKey,
                                                            kUniformValueKey,
                                                            kUniformCountKey,
                                                            nil ];
        
        NSNumber    *uniformLoc     = [NSNumber numberWithInt:theUniformLoc];
        NSNumber    *uniformCount   = [NSNumber numberWithInt:theUniformVectorCount];
        NSUInteger   uniformLength  = theUniformVectorType * theUniformVectorCount * kSizeOfGLint;
        NSData      *uniformValues  = [NSData dataWithBytes:theUniformVectors length:uniformLength];
        NSNumber    *uniformType    = nil;
        NSArray     *uniformObjects = nil;
        
        switch( theUniformVectorType )
        {
            case kVector:
                uniformType  = [NSNumber numberWithInt:kUniform1iv];
                break;
            case k2Vector:
                uniformType  = [NSNumber numberWithInt:kUniform2iv];
                break;
            case k3Vector:
                uniformType  = [NSNumber numberWithInt:kUniform3iv];
                break;
            case k4Vector:
                uniformType  = [NSNumber numberWithInt:kUniform4iv];
                break;
        } // switch
        
        uniformObjects = [NSArray arrayWithObjects:uniformLoc,uniformType,uniformValues,uniformCount,nil];
        uniformDict    = [[NSDictionary alloc] initWithObjects:uniformObjects forKeys:uniformKeys];
    } // if
    
    return  uniformDict;
} // getDictUniformIntVectors

//------------------------------------------------------------------------

#pragma mark -- Setting Float Uniform Dictionaries --

//------------------------------------------------------------------------

- (NSDictionary *) getDictUniformFloatScalar:(const GLint)theUniformLoc 
                                        value:(const GLfloat)theUniformValue
{
    NSArray *uniformKeys = [NSArray arrayWithObjects:    kUniformLocKey,
                                                        kUniformTypeKey,
                                                        kUniformValueKey,
                                                        nil ];
    
    NSArray *uniformObjects = [NSArray arrayWithObjects:[NSNumber numberWithInt:theUniformLoc],
                                                        [NSNumber numberWithInt:kUniform1f],
                                                        [NSNumber numberWithFloat:theUniformValue],
                                                        nil ];
    
    NSDictionary *uniformDict = [[NSDictionary alloc] initWithObjects:uniformObjects
                                                              forKeys:uniformKeys];
    return  uniformDict;
} // getDictUniformFloatScalar

//------------------------------------------------------------------------

- (NSDictionary *) getDictUniformFloatScalars:(const GLint)theUniformLoc
                                    type:(const UniformScalarTypes)theUniformType
                                    value:(const GLfloat *)theUniformValue
{
    NSDictionary *uniformDict = nil;
    
    if ( (  theUniformType &gt; kScalar ) &amp;&amp; (  theUniformType &lt;= k4Scalars ) )
    {
        NSArray *uniformKeys = [NSArray arrayWithObjects:    kUniformLocKey,
                                                            kUniformTypeKey,
                                                            kUniformValueKey,
                                                            nil ];
        
        NSNumber    *uniformLoc     = [NSNumber numberWithInt:theUniformLoc];
        NSUInteger   uniformLength  = theUniformType * kSizeOfGLfloat;
        NSData      *uniformValues  = [NSData dataWithBytes:theUniformValue length:uniformLength];
        NSNumber    *uniformType    = nil;
        NSArray     *uniformObjects = nil;
        
        switch( theUniformType )
        {
            case k2Scalars:
                uniformType  = [NSNumber numberWithInt:kUniform2f];
                break;
            case k3Scalars:
                uniformType  = [NSNumber numberWithInt:kUniform3f];
                break;
            case k4Scalars:
                uniformType  = [NSNumber numberWithInt:kUniform4f];
                break;
        } // switch
        
        uniformObjects = [NSArray arrayWithObjects:uniformLoc,uniformType,uniformValues,nil];
        uniformDict    = [[NSDictionary alloc] initWithObjects:uniformObjects forKeys:uniformKeys];
    } // if
    
    return  uniformDict;
} // getDictUniformFloatScalars

//------------------------------------------------------------------------

- (NSDictionary *) getDictUniformFloatVectors:(const GLint)theUniformLoc
                                    type:(const UniformVectorTypes)theUniformVectorType
                                    count:(const GLuint)theUniformVectorCount
                                    vectors:(const GLfloat *)theUniformVectors
{
    NSDictionary *uniformDict = nil;
    
    if ( theUniformVectorCount &gt;= 1 )
    {
        NSArray *uniformKeys = [NSArray arrayWithObjects:    kUniformLocKey,
                                                            kUniformTypeKey,
                                                            kUniformValueKey,
                                                            kUniformCountKey,
                                                            nil ];
        
        NSNumber    *uniformLoc     = [NSNumber numberWithInt:theUniformLoc];
        NSNumber    *uniformCount   = [NSNumber numberWithInt:theUniformVectorCount];
        NSUInteger   uniformLength  = theUniformVectorType * theUniformVectorCount * kSizeOfGLfloat;
        NSData      *uniformValues  = [NSData dataWithBytes:theUniformVectors length:uniformLength];
        NSNumber    *uniformType    = nil;
        NSArray     *uniformObjects = nil;
        
        switch( theUniformVectorType )
        {
            case kVector:
                uniformType  = [NSNumber numberWithInt:kUniform1fv];
                break;
            case k2Vector:
                uniformType  = [NSNumber numberWithInt:kUniform2fv];
                break;
            case k3Vector:
                uniformType  = [NSNumber numberWithInt:kUniform3fv];
                break;
            case k4Vector:
                uniformType  = [NSNumber numberWithInt:kUniform4fv];
                break;
        } // switch
        
        uniformObjects = [NSArray arrayWithObjects:uniformLoc,uniformType,uniformValues,uniformCount,nil];
        uniformDict    = [[NSDictionary alloc] initWithObjects:uniformObjects forKeys:uniformKeys];
    } // if
    
    return  uniformDict;
} // getDictUniformFloatVectors

//------------------------------------------------------------------------

- (NSDictionary *) getDictUniformFloatMatrices:(const GLint)theUniformLoc
                                        type:(const UniformMatrixTypes)theUniformMatrixType
                                        count:(const GLuint)theUniformMatrixCount
                                        transpose:(const GLboolean)theUniformMatrixTranspose
                                        matrices:(const GLfloat *)theUniformMatrices
{
    NSDictionary *uniformDict = nil;
    
    if ( theUniformMatrixCount &gt;= 1 )
    {
        NSArray *uniformKeys = [NSArray arrayWithObjects:    kUniformLocKey,
                                                            kUniformTypeKey,
                                                            kUniformValueKey,
                                                            kUniformCountKey,
                                                            kUniformTransposeKey,
                                                            nil ];
        
        NSNumber    *uniformLoc       = [NSNumber numberWithInt:theUniformLoc];
        NSNumber    *uniformCount     = [NSNumber numberWithInt:theUniformMatrixCount];
        NSNumber    *uniformTranspose = [NSNumber numberWithInt:theUniformMatrixTranspose];
        NSUInteger   uniformLength    = theUniformMatrixType * theUniformMatrixType * theUniformMatrixCount * kSizeOfGLfloat;
        NSData      *uniformValues    = [NSData dataWithBytes:theUniformMatrices length:uniformLength];
        NSNumber    *uniformType      = nil;
        NSArray     *uniformObjects   = nil;
        
        switch( theUniformMatrixType )
        {
            case k2x2Matrix:
                uniformType  = [NSNumber numberWithInt:kUniformMatrix2fv];
                break;
            case k3x3Matrix:
                uniformType  = [NSNumber numberWithInt:kUniformMatrix3fv];
                break;
            case k4x4Matrix:
                uniformType  = [NSNumber numberWithInt:kUniformMatrix4fv];
                break;
        } // switch
        
        uniformObjects = [NSArray arrayWithObjects:uniformLoc,uniformType,uniformValues,uniformCount,uniformTranspose,nil];
        uniformDict    = [[NSDictionary alloc] initWithObjects:uniformObjects forKeys:uniformKeys];
    } // if
    
    return  uniformDict;
} // getDictUniformFloatMatrices

//------------------------------------------------------------------------

#pragma mark -- Setting Integer Scalar Uniforms --

//------------------------------------------------------------------------

- (void) setUniform1i:(const GLuint)theUniformLoc 
          dictionaary:(NSDictionary *)theUniformDict
{
    NSNumber *uniformINum   = [theUniformDict objectForKey:kUniformValueKey];
    GLint     uniformIValue = [uniformINum intValue];
    
    glUniform1iARB( theUniformLoc, uniformIValue );
} // setUniform1i

//------------------------------------------------------------------------

- (void) setUniform2i:(const GLuint)theUniformLoc 
          dictionaary:(NSDictionary *)theUniformDict
{
    GLint   uniformIVec2[2] = { 0, 0 };
    NSData *uniformIData    = [theUniformDict objectForKey:kUniformValueKey];
    
    [uniformIData getBytes:uniformIVec2];
    
    glUniform2iARB(    theUniformLoc, 
                   uniformIVec2[0], 
                   uniformIVec2[1] );    
} // setUniform2i

//------------------------------------------------------------------------

- (void) setUniform3i:(const GLuint)theUniformLoc 
          dictionaary:(NSDictionary *)theUniformDict
{
    GLint   uniformIVec3[3] = { 0, 0, 0 };
    NSData *uniformIData    = [theUniformDict objectForKey:kUniformValueKey];
    
    [uniformIData getBytes:uniformIVec3];
    
    glUniform3iARB(    theUniformLoc, 
                    uniformIVec3[0], 
                    uniformIVec3[1],
                    uniformIVec3[2] );    
} // setUniform3i

//------------------------------------------------------------------------

- (void) setUniform4i:(const GLuint)theUniformLoc 
          dictionaary:(NSDictionary *)theUniformDict
{
    GLint   uniformIVec4[4] = { 0, 0, 0, 0 };
    NSData *uniformIData    = [theUniformDict objectForKey:kUniformValueKey];
    
    [uniformIData getBytes:uniformIVec4];
    
    glUniform4iARB(    theUniformLoc, 
                    uniformIVec4[0], 
                    uniformIVec4[1],
                    uniformIVec4[2],
                    uniformIVec4[3] );    
} // setUniform4i

//------------------------------------------------------------------------

#pragma mark -- Setting Integer Vector Uniforms --

//------------------------------------------------------------------------

- (void) setUniform1iv:(const GLuint)theUniformLoc
           dictionaary:(NSDictionary *)theUniformDict
{
    NSData   *uniformIData    = [theUniformDict objectForKey:kUniformValueKey];
    NSNumber *uniformCountNum = [theUniformDict objectForKey:kUniformCountKey];
    GLuint    uniformCount    = [uniformCountNum intValue];
    GLuint    uniformCapacity = uniformCount * kSizeOfGLint;
    GLint    *uniformIVec     = (GLint *)[[MemObject memoryWithType:kMemAlloc size:uniformCapacity] pointer];
    
    if ( uniformIVec != NULL )
    {
        [uniformIData getBytes:uniformIVec];
        
        glUniform1ivARB( theUniformLoc, uniformCount, uniformIVec );
    } // if
} // setUniform1iv

//------------------------------------------------------------------------

- (void) setUniform2iv:(const GLuint)theUniformLoc
           dictionaary:(NSDictionary *)theUniformDict
{
    NSData   *uniformIData    = [theUniformDict objectForKey:kUniformValueKey];
    NSNumber *uniformCountNum = [theUniformDict objectForKey:kUniformCountKey];
    GLuint    uniformCount    = [uniformCountNum intValue];
    GLuint    uniformCapacity = 2 * uniformCount * kSizeOfGLint;
    GLint    *uniformIVec     = (GLint *)[[MemObject memoryWithType:kMemAlloc size:uniformCapacity] pointer];
    
    if ( uniformIVec != NULL )
    {
        [uniformIData getBytes:uniformIVec];
        
        glUniform2ivARB( theUniformLoc, uniformCount, uniformIVec );
    } // if
} // setUniform2iv

//------------------------------------------------------------------------

- (void) setUniform3iv:(const GLuint)theUniformLoc
           dictionaary:(NSDictionary *)theUniformDict
{
    NSData   *uniformIData    = [theUniformDict objectForKey:kUniformValueKey];
    NSNumber *uniformCountNum = [theUniformDict objectForKey:kUniformCountKey];
    GLuint    uniformCount    = [uniformCountNum intValue];
    GLuint    uniformCapacity = 3 * uniformCount * kSizeOfGLint;
    GLint    *uniformIVec     = (GLint *)[[MemObject memoryWithType:kMemAlloc size:uniformCapacity] pointer];
    
    if ( uniformIVec != NULL )
    {
        [uniformIData getBytes:uniformIVec];
        
        glUniform3ivARB( theUniformLoc, uniformCount, uniformIVec );
    } // if
} // setUniform3iv

//------------------------------------------------------------------------

- (void) setUniform4iv:(const GLuint)theUniformLoc
           dictionaary:(NSDictionary *)theUniformDict
{
    NSData   *uniformIData    = [theUniformDict objectForKey:kUniformValueKey];
    NSNumber *uniformCountNum = [theUniformDict objectForKey:kUniformCountKey];
    GLuint    uniformCount    = [uniformCountNum intValue];
    GLuint    uniformCapacity = 4 * uniformCount * kSizeOfGLint;
    GLint    *uniformIVec     = (GLint *)[[MemObject memoryWithType:kMemAlloc size:uniformCapacity] pointer];
    
    if ( uniformIVec != NULL )
    {
        [uniformIData getBytes:uniformIVec];
        
        glUniform4ivARB( theUniformLoc, uniformCount, uniformIVec );
    } // if
} // setUniform4iv

//------------------------------------------------------------------------

#pragma mark -- Setting Float Scalar Uniforms --

//------------------------------------------------------------------------

- (void) setUniform1f:(const GLuint)theUniformLoc 
          dictionaary:(NSDictionary *)theUniformDict
{
    NSNumber *uniformFNum   = [theUniformDict objectForKey:kUniformValueKey];
    GLfloat   uniformFValue = [uniformFNum floatValue];
    
    glUniform1fARB( theUniformLoc, uniformFValue );
} // setUniform1f

//------------------------------------------------------------------------

- (void) setUniform2f:(const GLuint)theUniformLoc 
          dictionaary:(NSDictionary *)theUniformDict
{
    GLfloat  uniformFVec2[2] = { 0.0f, 0.0f };
    NSData  *uniformFData    = [theUniformDict objectForKey:kUniformValueKey];
    
    [uniformFData getBytes:uniformFVec2];
    
    glUniform2fARB(    theUniformLoc, 
                    uniformFVec2[0], 
                    uniformFVec2[1] );    
} // setUniform2f

//------------------------------------------------------------------------

- (void) setUniform3f:(const GLuint)theUniformLoc 
          dictionaary:(NSDictionary *)theUniformDict
{
    GLfloat uniformFVec3[3] = { 0.0f, 0.0f, 0.0f };
    NSData *uniformFData    = [theUniformDict objectForKey:kUniformValueKey];
    
    [uniformFData getBytes:uniformFVec3];
    
    glUniform3fARB(    theUniformLoc, 
                    uniformFVec3[0], 
                    uniformFVec3[1],
                    uniformFVec3[2] );    
} // setUniform3f

//------------------------------------------------------------------------

- (void) setUniform4f:(const GLuint)theUniformLoc 
          dictionaary:(NSDictionary *)theUniformDict
{
    GLfloat uniformFVec4[4] = { 0.0f, 0.0f, 0.0f, 0.0f };
    NSData *uniformFData    = [theUniformDict objectForKey:kUniformValueKey];
    
    [uniformFData getBytes:uniformFVec4];

    glUniform4iARB(    theUniformLoc, 
                    uniformFVec4[0], 
                    uniformFVec4[1],
                    uniformFVec4[2],
                    uniformFVec4[3] );    
} // setUniform4f

//------------------------------------------------------------------------

#pragma mark -- Setting Float Vector Uniforms --

//------------------------------------------------------------------------

- (void) setUniform1fv:(const GLuint)theUniformLoc
           dictionaary:(NSDictionary *)theUniformDict
{
    NSData   *uniformFData    = [theUniformDict objectForKey:kUniformValueKey];
    NSNumber *uniformCountNum = [theUniformDict objectForKey:kUniformCountKey];
    GLuint    uniformCount    = [uniformCountNum intValue];
    GLuint    uniformCapacity = uniformCount * kSizeOfGLfloat;
    GLfloat  *uniformFVec     = (GLfloat *)[[MemObject memoryWithType:kMemAlloc size:uniformCapacity] pointer];
    
    if ( uniformFVec != NULL )
    {
        [uniformFData getBytes:uniformFVec];
        
        glUniform1fvARB( theUniformLoc, uniformCount, uniformFVec );
    } // if
} // setUniform1fv

//------------------------------------------------------------------------

- (void) setUniform2fv:(const GLuint)theUniformLoc
           dictionaary:(NSDictionary *)theUniformDict
{
    NSData   *uniformFData    = [theUniformDict objectForKey:kUniformValueKey];
    NSNumber *uniformCountNum = [theUniformDict objectForKey:kUniformCountKey];
    GLuint    uniformCount    = [uniformCountNum intValue];
    GLuint    uniformCapacity = 2 * uniformCount * kSizeOfGLfloat;
    GLfloat  *uniformFVec     = (GLfloat *)[[MemObject memoryWithType:kMemAlloc size:uniformCapacity] pointer];
    
    if ( uniformFVec != NULL )
    {
        [uniformFData getBytes:uniformFVec];
        
        glUniform2fvARB( theUniformLoc, uniformCount, uniformFVec );
    } // if
} // setUniform2fv

//------------------------------------------------------------------------

- (void) setUniform3fv:(const GLuint)theUniformLoc
           dictionaary:(NSDictionary *)theUniformDict
{
    NSData   *uniformFData    = [theUniformDict objectForKey:kUniformValueKey];
    NSNumber *uniformCountNum = [theUniformDict objectForKey:kUniformCountKey];
    GLuint    uniformCount    = [uniformCountNum intValue];
    GLuint    uniformCapacity = 3 * uniformCount * kSizeOfGLfloat;
    GLfloat  *uniformFVec     = (GLfloat *)[[MemObject memoryWithType:kMemAlloc size:uniformCapacity] pointer];
    
    if ( uniformFVec != NULL )
    {
        [uniformFData getBytes:uniformFVec];
        
        glUniform3fvARB( theUniformLoc, uniformCount, uniformFVec );
    } // if
} // setUniform3fv

//------------------------------------------------------------------------

- (void) setUniform4fv:(const GLuint)theUniformLoc
           dictionaary:(NSDictionary *)theUniformDict
{
    NSData   *uniformFData    = [theUniformDict objectForKey:kUniformValueKey];
    NSNumber *uniformCountNum = [theUniformDict objectForKey:kUniformCountKey];
    GLuint    uniformCount    = [uniformCountNum intValue];
    GLuint    uniformCapacity = 4 * uniformCount * kSizeOfGLfloat;
    GLfloat  *uniformFVec     = (GLfloat *)[[MemObject memoryWithType:kMemAlloc size:uniformCapacity] pointer];
    
    if ( uniformFVec != NULL )
    {
        [uniformFData getBytes:uniformFVec];
        
        glUniform4fvARB( theUniformLoc, uniformCount, uniformFVec );
    } // if
} // setUniform4fv

//------------------------------------------------------------------------

#pragma mark -- Setting Float Matrix Uniforms --

//------------------------------------------------------------------------

- (void) setUniformMatrix2fv:(const GLuint)theUniformLoc
                 dictionaary:(NSDictionary *)theUniformDict
{
    NSData     *uniformFData        = [theUniformDict objectForKey:kUniformValueKey];
    NSNumber   *uniformCountNum     = [theUniformDict objectForKey:kUniformCountKey];
    GLuint      uniformCount        = [uniformCountNum intValue];
    GLuint      uniformCapacity     = 4 * uniformCount * kSizeOfGLfloat;
    NSNumber   *uniformTransposeNum = [theUniformDict objectForKey:kUniformTransposeKey];
    GLboolean   uniformTranspose    = [uniformTransposeNum intValue];
    GLfloat    *uniformFVec         = (GLfloat *)[[MemObject memoryWithType:kMemAlloc size:uniformCapacity] pointer];
    
    if ( uniformFVec != NULL )
    {
        [uniformFData getBytes:uniformFVec];
        
        glUniformMatrix2fvARB( theUniformLoc, uniformCount, uniformTranspose, uniformFVec );
    } // if
} // setUniformMatrix2fv

//------------------------------------------------------------------------

- (void) setUniformMatrix3fv:(const GLuint)theUniformLoc
                 dictionaary:(NSDictionary *)theUniformDict
{
    NSData     *uniformFData        = [theUniformDict objectForKey:kUniformValueKey];
    NSNumber   *uniformCountNum     = [theUniformDict objectForKey:kUniformCountKey];
    GLuint      uniformCount        = [uniformCountNum intValue];
    GLuint      uniformCapacity     = 9 * uniformCount * kSizeOfGLfloat;
    NSNumber   *uniformTransposeNum = [theUniformDict objectForKey:kUniformTransposeKey];
    GLboolean   uniformTranspose    = [uniformTransposeNum intValue];
    GLfloat    *uniformFVec         = (GLfloat *)[[MemObject memoryWithType:kMemAlloc size:uniformCapacity] pointer];
    
    if ( uniformFVec != NULL )
    {
        [uniformFData getBytes:uniformFVec];
        
        glUniformMatrix3fvARB( theUniformLoc, uniformCount, uniformTranspose, uniformFVec );
    } // if
} // setUniformMatrix3fv

//------------------------------------------------------------------------

- (void) setUniformMatrix4fv:(const GLuint)theUniformLoc
                 dictionaary:(NSDictionary *)theUniformDict
{
    NSData     *uniformFData        = [theUniformDict objectForKey:kUniformValueKey];
    NSNumber   *uniformCountNum     = [theUniformDict objectForKey:kUniformCountKey];
    GLuint      uniformCount        = [uniformCountNum intValue];
    GLuint      uniformCapacity     = 16 * uniformCount * kSizeOfGLfloat;
    NSNumber   *uniformTransposeNum = [theUniformDict objectForKey:kUniformTransposeKey];
    GLboolean   uniformTranspose    = [uniformTransposeNum intValue];
    GLfloat    *uniformFVec         = (GLfloat *)[[MemObject memoryWithType:kMemAlloc size:uniformCapacity] pointer];
    
    if ( uniformFVec != NULL )
    {
        [uniformFData getBytes:uniformFVec];
        
        glUniformMatrix4fvARB( theUniformLoc, uniformCount, uniformTranspose, uniformFVec );
    } // if
} // setUniformMatrix4fv

//------------------------------------------------------------------------

- (void) setUniformsUsingDicts:(NSArray *)theUniforms
{
    NSDictionary *uniformDict    = nil;
    NSNumber     *uniformLocNum  = nil;
    NSNumber     *uniformTypeNum = nil;
    GLuint        uniformLoc     = 0;
    GLuint        uniformType    = 0;
    
    for (uniformDict in theUniforms) 
    {
        uniformLocNum  = [uniformDict objectForKey:kUniformLocKey];
        uniformLoc     = [uniformLocNum intValue];
        uniformTypeNum = [uniformDict objectForKey:kUniformTypeKey];
        uniformType    = [uniformTypeNum intValue];

        switch( uniformType )
        {
            case kUniformSampler1D:
            case kUniformSampler2D:
            case kUniformSampler3D:
            case kUniformSampler2DRect:
            case kUniform1i:
                
                [self setUniform1i:uniformLoc dictionaary:uniformDict];
                break;
                
            case kUniform2i:

                [self setUniform2i:uniformLoc dictionaary:uniformDict];
                break;
                
            case kUniform3i:

                [self setUniform3i:uniformLoc dictionaary:uniformDict];
                break;

            case kUniform4i:

                [self setUniform4i:uniformLoc dictionaary:uniformDict];
                break;

            case kUniform1iv:
                
                [self setUniform1iv:uniformLoc dictionaary:uniformDict];
                break;
                
            case kUniform2iv:

                [self setUniform2iv:uniformLoc dictionaary:uniformDict];
                break;
                
            case kUniform3iv:

                [self setUniform3iv:uniformLoc dictionaary:uniformDict];
                break;
                
            case kUniform4iv:

                [self setUniform4iv:uniformLoc dictionaary:uniformDict];
                break;

            case kUniform1f:

                [self setUniform1f:uniformLoc dictionaary:uniformDict];
                break;

            case kUniform2f:

                [self setUniform2f:uniformLoc dictionaary:uniformDict];
                break;

            case kUniform3f:

                [self setUniform3f:uniformLoc dictionaary:uniformDict];
                break;

            case kUniform4f:
                
                [self setUniform4f:uniformLoc dictionaary:uniformDict];
                break;

            case kUniform1fv:
                
                [self setUniform1fv:uniformLoc dictionaary:uniformDict];                    
                break;

            case kUniform2fv:
                
                [self setUniform2fv:uniformLoc dictionaary:uniformDict];
                break;

            case kUniform3fv:
                
                [self setUniform3fv:uniformLoc dictionaary:uniformDict];
                break;
                
            case kUniform4fv:
                
                [self setUniform4fv:uniformLoc dictionaary:uniformDict];                    
                break;

            case kUniformMatrix2fv:
                
                [self setUniformMatrix2fv:uniformLoc dictionaary:uniformDict];
                break;

            case kUniformMatrix3fv:
                
                [self setUniformMatrix3fv:uniformLoc dictionaary:uniformDict];
                break;

            case kUniformMatrix4fv:
                
                [self setUniformMatrix4fv:uniformLoc dictionaary:uniformDict];
                break;
        } // switch
    } // for
} // setUniformsUsingDicts

//------------------------------------------------------------------------

- (void) setUniforms:(NSArray *)theUniforms
{
    [self enable];
    
        [self setUniformsUsingDicts:theUniforms];
    
    [self disable];
} // setUniforms

//------------------------------------------------------------------------

#pragma mark -- Shader Execution --

//---------------------------------------------------------------------------

- (void) excuteWithCVTexture:(CVOpenGLTextureRef)theVideoFrame
{
    // Get the texture target

    GLenum target = CVOpenGLTextureGetTarget( theVideoFrame );

    // Get the texture target id

    GLuint name = CVOpenGLTextureGetName( theVideoFrame );

    [self enable];
    
        glEnable( target );
        
        glBindTexture( target, name );
        
        [quad draw];
    
    [self disable];
} // excuteWithCVTexture

//---------------------------------------------------------------------------

- (void) executeWithCVTextureAndUniforms:(CVOpenGLTextureRef)theVideoFrame uniforms:(NSArray *)theUniforms
{
    // Get the texture target

    GLenum target = CVOpenGLTextureGetTarget( theVideoFrame );

    // Get the texture target id

    GLuint name = CVOpenGLTextureGetName( theVideoFrame );

    [self enable];
    
        [self setUniformsUsingDicts:theUniforms];
        
        glEnable( target );
        
        glBindTexture( target, name );
        
        [quad draw];
    
    [self disable];
} // executeWithCVTextureAndUniforms

//------------------------------------------------------------------------

@end

//------------------------------------------------------------------------

//------------------------------------------------------------------------

</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/QTCoreVideo301/listing14.html%3Fid%3DDTS40007785-1.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/QTCoreVideo301/listing14.html%3Fid%3DDTS40007785-1.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/QTCoreVideo301/listing14.html%3Fid%3DDTS40007785-1.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>