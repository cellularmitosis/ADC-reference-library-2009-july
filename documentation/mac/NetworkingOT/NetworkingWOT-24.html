<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>About Providers</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING24></A>
<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->

<!-- Main Body -->

<CENTER>
<P>
<A HREF="NetworkingWOT-23.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="NetworkingWOT-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="NetworkingWOT-491.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A>  <A HREF="NetworkingWOT-25.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html"><B>Inside Macintosh:</B></A> <A HREF="NetworkingWOT-2.html"><B>Networking With Open Transport </B></A> / <A HREF="NetworkingWOT-10.html"><B>Part 1 - Open Transport Essentials</B></A><BR><DD><A HREF="NetworkingWOT-23.html"><B>Chapter 3 - Providers</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING24-0></A>
<H1><A NAME=MARKER-9-30></A>About Providers</H1>
 A <B><A NAME=MARKER-13-31></A>provider</B> is a layered set of protocols, implemented by STREAMS modules, that provides some kind of data-oriented service. That service might be implementing a networking protocol, encrypting data, filtering data, and so on. When you configure a provider, you can layer the modules that implement the provider to create an arbitrarily complex service. For example, you can place an encryption module above the AppleTalk Data Stream Protocol (ADSP) module. This combination would provide a stream of network data that was secure from snooping on the network. <P>
 Open Transport defines three main types of providers: <A NAME=MARKER-13-32></A><P>
<UL>
<P><LI>endpoint providers
<P><LI>mapper providers
<P><LI>service providers<P>
</UL>
 An <B>endpoint provider</B> offers a service that creates connections and moves data from one logical address to another. A <B>mapper provider</B> offers services that you use to associate, or "map," network entity names with network addresses. A <B>service provider</B> lets you perform tasks that are specific to a particular protocol, such as AppleTalk or TCP/IP. Each protocol family has the option of providing a service provider if one is needed.<P>
 In the normal course of events you do not communicate directly with the STREAMS modules that make up a provider. For example, to use an endpoint provider, you must open an endpoint and use the functions defined in the Open Transport application programming interface (API) for endpoints. The Open Transport API shields your application from the details of the provider implementation, allowing your application to run with little or no change, even when the implementation of the provider is changed, or updated. <A NAME=MARKER-13-33></A><P>
 To use a provider, you must initialize Open Transport and then call the function that opens the provider. When that function returns, it passes back to you a reference to the provider you have just created. A <B>provider reference</B> is like a file handle or a driver reference number. It associates a function called from your application with a specific provider that must implement the function; you pass the provider reference as a parameter to all provider functions. The data type of a provider reference depends on the type of the provider (endpoint reference, mapper reference, AppleTalk service reference, and so on). <A NAME=MARKER-13-34></A><P>
 You can open one provider or many. For example, a server application might open many providers and use them concurrently. The number of providers you can create is limited mainly by the availability of memory. The memory used to create a provider comes partly from your application heap but mostly from the system heap. <A NAME=MARKER-13-35></A><A NAME=MARKER-13-36></A><P>
<B>C++ note</B><P>
<DL>
<DD>The C++ API for Open Transport includes a class called <CODE>TProvider</CODE> that is the superclass for all provider-related member functions. Endpoint functions are in class <CODE>TEndpoint</CODE>, mapper functions are in class <CODE>TMapper</CODE>, and service provider functions are in classes corresponding to specific protocol stacks. For example, the classes <CODE>TAppleTalkServices</CODE> and <CODE>TInternetServices</CODE> contain AppleTalk-specific and TCP/IP-specific member functions.<P>
<DD>In object-oriented programming parlance, endpoints, mappers, and the data structures maintained by Open Transport for service providers are all objects. An endpoint, for example, is an object instantiating the class <CODE>TEndpoint</CODE>. An endpoint contains all the data that Open Transport needs to link together software modules, drivers, and hardware for a specific endpoint provider. All of the Open Transport API functions except the functions that open providers and some utility functions are included in the class definitions of the various classes of providers.<P>
<DD>You can call public member functions of the <CODE>TProvider</CODE> class for provider objects of any type: these functions are the general provider functions. Public member functions defined in a subclass of the <CODE>TProvider</CODE> class (for example, <CODE>TEndpoint</CODE>) can be called only for providers belonging to that subclass--in this example, only from the <CODE>TEndpoint</CODE> subclass. These functions are the type-specific provider functions. Note that, as with endpoints and mappers, each kind of service (for AppleTalk, TCP/IP, and so on) derives directly from the <CODE>TProvider</CODE> class; there is no other class for services-type providers.  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING24-14></A>
<H2>Provider Functions</H2>
 Functions that manipulate providers are known as <A NAME=MARKER-13-37></A><B>provider functions.</B> Some provider functions can manipulate providers of any type. These are called <A NAME=MARKER-13-38></A><B>general provider functions</B> and they are documented in detail in <A HREF=NetworkingWOT-97.html#MARKER-9-19>"Providers Reference"</A>. You use general provider functions to<P>
<UL>
<P><LI>get or set a provider's default <A NAME=MARKER-13-39></A><B>mode of operation,</B> which determines whether provider functions execute synchronously or asynchronously, whether a provider can wait to send or receive data, and whether functions that send data make a copy of that data <A NAME=MARKER-13-40></A>
<P><LI>install and remove a notifier callback function, which the provider uses to pass information to your application 
<P><LI>send a module-specific command, which allows you to communicate directly with the STREAMS modules that make up your provider
<P><LI>close a provider<P>
</UL>
 In addition to the general provider functions, each type of provider has type-specific provider functions; these functions work with only that particular type of provider. For example, endpoint functions work only with endpoint providers, and mapper functions work only with mapper providers. Each type of service provider (for AppleTalk, TCP/IP, and so on) has its own type-specific provider functions. <P>
 Provider functions that accept a provider reference of type <CODE>ProviderRef</CODE> are general: they accept any other type of provider reference as well. But functions that require a type of provider reference other than <CODE>ProviderRef</CODE> (for example, <CODE>EndpointRef</CODE>) are type-specific: they accept only that type of provider reference.<P>
<A NAME=HEADING24-22></A>
<H2><A NAME=MARKER-9-41></A>Interrupt-Time Processing</H2>
 The Open Transport functions that you can call and the means by which you call them vary with the level of execution: system task time, deferred task time, and hardware interrupt time.<P>
 In general you can call all Open Transport functions at system task time and most Open Transport functions, asynchronously, at deferred task time. At hardware interrupt time, you are much more limited: you cannot call any of the provider functions and you can call only a small number of Open Transport functions. Software executed at hardware interrupt level includes installable interrupt handlers for NuBus and other devices, Time Manager tasks, VBL tasks, and routines called from within a hardware interrupt handler. <P>
 Because it is possible to call many more Open Transport functions from deferred-task level than from hardware-interrupt level, if you need to call an Open Transport function from hardware-interrupt level, you can use the Open Transport function <CODE>OTScheduleDeferredTask</CODE> or the system function <CODE>DTInstall</CODE> to have those functions execute at deferred task time. Deferred tasks are scheduled to run when all other hardware interrupt processing is done but before system task processing resumes.<P>
 For more information about execution levels and deferred tasks, see <I><A HREF="../Processes/Processes-2.html">Inside Macintosh: Processes</A></I>. For a more detailed view of processing and Open Transport, see <A HREF=NetworkingWOT-43.html#MARKER-9-19>Chapter 5, "Programming With Open Transport."</A> For a list of those functions you can call at hardware-interrupt level and deferred-task level, see <A HREF=NetworkingWOT-480.html#MARKER-9-9>"Special Functions"</A>.<P>
<A NAME=HEADING24-27></A>
<H2>Modes of Operation</H2>
 For each provider, you can use general provider functions to specify how providers execute, whether the provider can block when sending or receving data, and whether endpoint providers acknowledge sends.<P>
 A provider can execute in synchronous mode or in asynchronous mode. In <B>synchronous mode,</B> provider functions return only when they complete execution. In <B>asynchronous mode,</B> they return as soon as they are queued for execution. <A NAME=MARKER-13-42></A><P>
 A provider's <B>blocking status</B> affects how functions that send and receive data behave when they must wait to complete an operation. If a provider is <B>blocking,</B> it either waits for as long as it takes to send or receive data (for a synchronous call) or it returns with a result indicating why the operation could not be done immediately (asynchronous call). If a provider is <B>nonblocking,</B> the provider attempts to send or receive data and, if it cannot do so immediately, it returns with a result indicating why it could not complete the operation.<A NAME=MARKER-13-43></A> <P>
 A provider's mode of execution and blocking status act together to control the provider's behavior. There are four possible combinations; of these, though only three offer a practical use:<P>
<UL>
<P><LI>synchronous blocking<P>
In this mode, if flow control or other conditions prevent data from being sent or received, the function returns when it is actually able to send or receive the data. Placing a provider in sychronous blocking mode can halt all operations on a Mac OS computer until the operation can complete. For information on how to manage this situation, see <A HREF=NetworkingWOT-39.html#MARKER-9-49>"Specifying How Provider Functions Execute"</A>.<P>
<P><LI>synchronous nonblocking<P>
In this mode, if flow-control conditions prevent data from being sent or received, the function returns with the result <CODE>kOTFlowErr</CODE> or a number indicating only a partial send. Open Transport calls the provider's notifier with a <CODE>T_GODATA</CODE> or <CODE>T_GOEXDATA</CODE> event when flow control lifts. You must call the function again to continue to send or receive data.<P>
<P><LI>asynchronous blocking<P>
In this mode, if flow-control conditions prevent data from being sent or received, the function returns with the result <CODE>kOTFlowErr</CODE> or a number indicating only a partial send. Open Transport calls the provider's notifier with a <CODE>T_GODATA</CODE> or <CODE>T_GOEXDATA</CODE> event when flow control lifts. You must call the function again to send or receive data. If the function cannot complete due to contention for STREAMS resources, it will wait until the required resources are available.<P>
<P><LI>asynchronous nonblocking<P>
In this mode, if flow-control conditions prevent data from being sent or received, the function returns with <CODE>kOTFlowErr,</CODE> It can also return <CODE>kEAgainErr</CODE>. if the function cannot execute as a result of contention for STREAMS resources. Since the point of using asynchronous functions is to be able to continue processing undisturbed until the function returns, using asynchronous nonblocking mode is not practical, as the function might return with the <CODE>kEAgainErr</CODE> result a number of times before it actually completes.<P>
</UL>
 A provider's blocking status also governs what happens when you close a provider. In non-blocking mode, closing the provider flushes all outgoing commands in the stream and immediately closes the provider. In blocking mode, the stream is given up to 15 seconds per module to allow outgoing commands to be processed before the stream is closed.<P>
 A provider's<B> send-acknowledgment status</B> determines whether endpoint functions that send data make an internal copy of the data before sending it. Open Transport ignores the send-acknowledgment status for mapper and service providers. <A NAME=MARKER-13-44></A><P>
 For specific recommendations about which mode to use and how to set that mode, see <A HREF=NetworkingWOT-25.html#MARKER-9-50>"Controlling a Provider's Modes of Operation"</A>.<P>
<A NAME=HEADING24-43></A>
<H2><A NAME=MARKER-9-45></A>Provider Events</H2>
 Open Transport defines three kinds of events called <B>provider events.</B> These events are unique to the Open Transport architecture and are not events in the usual Macintosh sense: they are not processed by the Event Manager, and they have no associated Event Record. Rather, Open Transport uses provider events to inform your application that something has occurred which demands your immediate attention or to signal the fact that a function executing in asynchronous mode has completed. The first kind of provider event is called an <B>asynchronous event,</B> the second kind is called a <B>completion event, </B>and the third kind is called a<B> miscellaneous event. </B>In this book, the term <I>event</I> refers to a provider event, except where noted otherwise. <A NAME=MARKER-13-46></A><P>
 A provider uses asynchronous events to notify your application that data has arrived or that a request for a connection or disconnection is pending. Most asynchronous events defined for Open Transport have equivalents in the X/Open Transport Interface (XTI), from which the Open Transport interface derives. <P>
 XTI does not define completion events. A provider uses completion events to notify your application that an asynchronous function has finished executing. Some functions are inherently synchronous and have no corresponding completion event. For example, if an endpoint provider is in asynchronous mode and you execute the <CODE>OTGetEndpointState</CODE> function, the function returns information about the state of the endpoint immediately. The description of a function indicates whether the function behaves differently in asynchronous mode. <P>
 Miscellaneous events are used to notify you or warn you of a change of state in the provider: for example, the provider is about to be closed.<P>
 A provider event is identified by a provider event code. These are listed and described in the event codes enumeration <A HREF=NetworkingWOT-100.html#MARKER-9-22></A>.<P>
<UL>
<P><LI>Completion events have a prefix of <CODE>T_</CODE> and the suffix <CODE>COMPLETE</CODE>; for example, <CODE>T_BINDCOMPLETE</CODE>.
<P><LI>Asyncronous events have a prefix of <CODE>T_</CODE> and no uniform suffix; for example, <CODE>T_DATA</CODE> or <CODE>T_MEMORYRELEASED.</CODE>
<P><LI>Miscellaneous events have a prefix of <CODE>kOT </CODE>and no uniform suffix; for example, <CODE>kOTProviderWillClose</CODE>.<P>
</UL>
 In general, to receive notice of provider events, you must provide a notifier function and install it for the provider. A <B>notifier function</B> is a function that you write and that the provider will call when an event occurs. When the provider calls this function, it uses the function's parameters to pass back information about the event that occurred, and if this is a completion event, it also passes back additional information about the result of the function that completed and a pointer to any other information passed back by the function. The section <A HREF=NetworkingWOT-25.html#MARKER-9-70>"Using Notifier Functions to Handle Provider Events"</A> provides additional information about notifier functions and the issues involved in asynchronous processing. You can also refer to <A HREF=NetworkingWOT-117.html#MARKER-9-113>"Using Notifier Functions"</A> for a description of the notifier functions. <A NAME=MARKER-13-47></A><P>
<A NAME=HEADING24-53></A>
<H2>Function Results</H2>
 Most Open Transport functions return a result of type <CODE>OSStatus</CODE> or <CODE>OTResult</CODE>. The main difference between these is that a result of type <CODE>OSStatus</CODE> is either 0 (<CODE>kOTNoError</CODE>) or a negative number indicating an error code; a result of type <CODE>OTResult</CODE> can be either a positive value whose meaning varies with the function called or a negative value indicating an error code. Appendix B <A HREF=NetworkingWOT-479.html#MARKER-9-72></A> lists all result codes returned by Open Transport.<P>
<UL>
<P><LI>For synchronous function calls, a result of <CODE>kOTNoError</CODE> indicates that the function succeeded. A negative value indicates an error.
<P><LI>For asynchronous function calls, if the result code is <CODE>kOTNoError</CODE>, the operation was successfully started. When the function completes execution, the provider will call the notification function you installed with an event code to indicate which operation completed and a result code indicating whether it succeeded. If an asynchronous function returns any immediate result other than <CODE>kOTNoError</CODE>, this means that the operation failed before it was started; your notifier will not be called.<P>
</UL>
 The discussion of functions in the reference section of this book describes the meaning of the errors that are most likely to occur for each function. In addition, every Open Transport function might return the result codes listed in <A HREF=#MARKER-9-48>Table 3-1</A>. For additional information, please look up the meaning of these result codes in Appendix B <A HREF=NetworkingWOT-479.html#MARKER-9-72></A>.<P>
<B>Table 3-1  Result codes that all Open Transport functions can return</B><A NAME=MARKER-9-48></A>
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Result code<TH>Meaning<TR>
<TD><CODE><A NAME=MARKER-15-37></A>kEBADFErr</CODE><TD>The provider reference you supplied is invalid.<TR>
<TD><CODE><A NAME=MARKER-15-31></A>kOTBadSyncErr</CODE><TD>You made a synchronous call at an inappropriate level.<TR>
<TD><CODE><A NAME=MARKER-15-39></A>kENOMEMErr</CODE><TD>There is not enough memory to complete the request.<TR>
<TD><CODE><A NAME=MARKER-15-65></A>kENOSRErr</CODE><TD>There are not enough system resources to complete the request.<TR>
<TD><CODE><A NAME=MARKER-15-38></A>kEAGAINErr</CODE><P><CODE><A NAME=MARKER-15-45></A>kEWOULDBLOCKErr</CODE><TD>A provider is in non-blocking mode and Open Transport would have to block to complete the request.<TR>
<TD><CODE><A NAME=MARKER-15-30></A>kOTProtocolErr</CODE><TD>An unspecified protocol error occurred. This is usually fatal. To recover, close the provider.<TR>
<TD><CODE><A NAME=MARKER-15-67></A>kOTClientNotInittedErr&nbsp;&nbsp;</CODE><TD>You have not initialized Open Transport or Open Transport Utilities.<TR>
<TD><CODE><A NAME=MARKER-15-20></A>kOTOutStateErr</CODE><TD>The endpoint is not in an appropriate state for the operation you wish to execute.<TR>
<TD>kOTStateChangeErr<TD>The endpoint is undergoing a transient state change. This error is returned when you call a function while an endpoint is in the process of changing states. You should wait for an event indicating the endpoint has finished changing state and call the function again. The provider also returns this error if you attempt to call an "incompatible" function while another operation is still ongoing; for example if you call the function <CODE>OTSndUData</CODE> while a call to the <CODE>OTOptionManagement</CODE> function is still outstanding.</TABLE><P>
<HR>
<B>Subtopics</B>
<B><!-- TOC --><DL>
<DT><A HREF="NetworkingWOT-24.html#HEADING24-14">Provider Functions</A>
<DD>
<DT><A HREF="NetworkingWOT-24.html#HEADING24-22">Interrupt-Time Processing</A>
<DD>
<DT><A HREF="NetworkingWOT-24.html#HEADING24-27">Modes of Operation</A>
<DD>
<DT><A HREF="NetworkingWOT-24.html#HEADING24-43">Provider Events</A>
<DD>
<DT><A HREF="NetworkingWOT-24.html#HEADING24-53">Function Results</A>
<DD>
</DL>
</B>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="NetworkingWOT-23.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="NetworkingWOT-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="NetworkingWOT-491.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A>  <A HREF="NetworkingWOT-25.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="NetworkingWOT-4.html">&copy; Apple Computer, Inc.</A><br>15 JAN 1998<P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML> 
