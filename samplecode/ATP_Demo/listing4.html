<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>ATP Demo - /ATP.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxNetworking-date.html">Networking</a> &gt; <A HREF="javascript:location.replace('index.html');">ATP Demo</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Networking/index.html" target="_blank">Reference Library > Networking</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">ATP Demo</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/ATP.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Atalk.c</option>
<option value="listing2.html">/ATP Demo.h</option>
<option value="listing3.html">/ATP Demo.r</option>
<option value="listing4.html">/ATP.c</option>
<option value="listing5.html">/Main.c</option>
<option value="listing6.html">/PreCompletion.a</option></select>
				</p>
				</form>
				<p><strong><a href="ATP_Demo.zip">Download Sample</a></strong> (&#147;ATP_Demo.zip&#148;, 42.8K)<BR>
<strong><a href="ATP_Demo.dmg">Download Sample</a></strong> (&#147;ATP_Demo.dmg&#148;, 104.3K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*****************************************************************  Program:  &lt; ATP Demo &gt;  File:    &lt; ATP.c &gt;    Written by  Scott Kuechle  of &lt;Apple Macintosh Developer Technical Support&gt;    10/92 SRK created  8/94 SRK Modified to use a queue of parameter           blocks.  Copyright &copy; 1992, 1994 Apple Computer, Inc.  All rights reserved.  *****************************************************************//*****************************************************************//*  I N C L U D E S/*****************************************************************/#include  &quot;ATP Demo.h&quot;#include  &quot;ATP Demo.protos&quot;/********************************************************************/*  G L O B A L   V A R I A B L E   D E C L A R A T I O N S/********************************************************************/char         gOurATPSocket;Str255         gDataSizeStr;Boolean       gDoContinuous;AddrBlock       gTargetAddress;myATPParamBlock   gOurPB[maxQElements];ourRespBuf      gRespBuf[maxQElements];BDSType        gBDS[maxQElements];ourReqData      gOurReqData[maxQElements];QHdr        gAvailQueue;QHdr        gDoneQueue;QHdr        gRequestQueue;/*****************************************************************//*/* E X T E R N A L S/*/*****************************************************************/extern void   ShowError(short index);extern void   Exit(short message);extern Str255   gZoneString, gObjStr, gTypeStr;extern void   registerMyName(char socket);extern DialogPtr myDialog;extern void   removeMyName();extern void   FatalError(error);extern void   HiliteSendReqButton (short mode);extern void   PreCompletion();extern Boolean  gReqClockTime,gSingleRequest,gStopRequests;extern Handle   gTestDataHdl;extern long   gTestDataSize;#pragma segment atp// *****************************************************************// *  GetASocket// *// *  Opens a socket for us to receive requests - we will accept// *  requests from any machine.// *// *****************************************************************Boolean GetASocket(char *socket){ATPParamBlock atp;  *socket = 0;    atp.ATP.ioCompletion = nil;    /* dynamically allocate us a socket */  atp.ATP.atpSocket = 0;      /* accept requests from anyone */  atp.ATP.addrBlock.aNet = 0;  atp.ATP.addrBlock.aNode = 0;  atp.ATP.addrBlock.aSocket = 0;    if (POpenATPSkt(&amp;atp,false) == noErr)  {    if (atp.ATP.ioResult == noErr)    {      *socket = atp.ATP.atpSocket;      return true;    }  }    return false;}// *****************************************************************// *  InitQueues// *// *  initialize our &quot;Available&quot; , &quot;Done&quot; and &quot;Read&quot; queues// *****************************************************************void InitQueues(){short i;long myA5;  gAvailQueue.qHead   = NULL;  gAvailQueue.qTail   = NULL;  gDoneQueue.qHead   = NULL;  gDoneQueue.qTail   = NULL;  gRequestQueue.qHead = NULL;  gRequestQueue.qTail = NULL;    myA5 = *(long *)CurrentA5;    for (i=0; (i &lt; maxQElements); ++i)  {    gOurPB[i].reqData         = (Ptr)&amp;gOurReqData[i];    gOurPB[i].respData         = (Ptr)&amp;gRespBuf[i];    gOurPB[i].bdsPtr         = (Ptr)&amp;gBDS[i];    gOurPB[i].myA5           = myA5;    gOurPB[i].u.ATP.ioCompletion   = (ProcPtr)&amp;PreCompletion;    Enqueue((QElemPtr)&amp;gOurPB[i].u,&amp;gAvailQueue);  }}// *****************************************************************// *  GetQElement// *// *  retrieve a queue element from the specified queue// *****************************************************************ATPPBPtr GetQElement(QHdrPtr qHdrPtr){OSErr err;QElemPtr qElemPtr;  CheckDoneQueue();  qElemPtr = qHdrPtr-&gt;qHead;  if (qElemPtr != NULL)  {    err = Dequeue((QElemPtr)qElemPtr,qHdrPtr);    if (err != noErr)    {      return NULL;    }    else    {      return (ATPPBPtr)(qElemPtr);    }  }  else    return NULL;}// *****************************************************************// *  GetOurPBPtr// *// *    Returns a pointer to our custom parameter block// *****************************************************************myATPParamBlockPtr GetOurPBPtr(ATPPBPtr atpPBPtr){Ptr p;myATPParamBlockPtr myATPPBPtr;  p = (Ptr)atpPBPtr;    /* set a pointer to our parameter block,      which is offset kOurPBNegOffset bytes      above the standard ATP param block */  myATPPBPtr = (myATPParamBlockPtr)(p - kOurPBNegOffset);    return (myATPPBPtr);  }// *****************************************************************// *  SetOurCompletionRoutine// *// *    Sets the &quot;real&quot; completion routine for our async. calls// *****************************************************************void SetOurCompletionRoutine(ProcPtr procPtr,              ATPPBPtr atpPBPtr){myATPParamBlockPtr myATPPBPtr;  myATPPBPtr = GetOurPBPtr(atpPBPtr);  myATPPBPtr-&gt;ourCompletion = procPtr;  }// *****************************************************************// *  SaveFunctionResultCode// *// *    Places the function result code in our pb structure for later// *    reporting.// *****************************************************************void SaveFunctionResultCode(OSErr err,              ATPPBPtr atpPBPtr){myATPParamBlockPtr myATPPBPtr;  myATPPBPtr = GetOurPBPtr(atpPBPtr);    /* save off the function result */  myATPPBPtr-&gt;functionResult = err;    /* place pb in &quot;done&quot; queue so we      can report the error later */  Enqueue((QElemPtr)atpPBPtr,&amp;gDoneQueue);}// *****************************************************************// *  doGetRequestIOComp// *// *  Completion routine for our get request call. We get here if// *  another machine sends us a request with the send request call.// *****************************************************************pascal void doGetRequestIOComp(ATPPBPtr atpPBPtr){  if (atpPBPtr-&gt;ATP.ioResult == noErr)      /* place parameter block into the &quot;Request&quot; queue */    Enqueue((QElemPtr)atpPBPtr,&amp;gRequestQueue);  else  /* some kind of error was returned */      /* place parameter block back into the &quot;Done&quot; queue */    Enqueue((QElemPtr)atpPBPtr,&amp;gDoneQueue);}// *****************************************************************// *  doGetRequest// *// *  We issue an asynchronous get request call here. It will complete// *  if a request is received from another machine.// *****************************************************************void doGetRequest(ATPPBPtr atpPBPtr,          char socket,          short reqLength,          Ptr reqPointer){OSErr err;  SetOurCompletionRoutine((ProcPtr)&amp;doGetRequestIOComp,              atpPBPtr);  atpPBPtr-&gt;ATP.atpSocket   = socket;  atpPBPtr-&gt;ATP.reqLength   = reqLength;  atpPBPtr-&gt;ATP.reqPointer   = reqPointer;  err = PGetRequest(atpPBPtr,true);  if (err != noErr)  {    SaveFunctionResultCode(err,              atpPBPtr);  }  }// *****************************************************************// *  doSndRequestIOComp// *// *  This is the completion routine for our send request call. It// *  will get called as soon as a response is received from the target.// *****************************************************************pascal void doSndRequestIOComp(ATPPBPtr atpPBPtr){  if (atpPBPtr-&gt;ATP.ioResult == noErr)  {      /* place parameter block into the &quot;Request&quot; queue */    Enqueue((QElemPtr)atpPBPtr,&amp;gRequestQueue);  }  else  /* we got an error */  {    /* place parameter block into the &quot;Done&quot; queue */    Enqueue((QElemPtr)atpPBPtr,&amp;gDoneQueue);  }  }// *****************************************************************// *  doSndRequest// *// *  This is our send request call. We send a request to the target,// *  as specified in the popup menu. The call completes when a // *  response is received back.// *****************************************************************void doSndRequest(ATPPBPtr     atpPBPtr,          AddrBlock   address,          char    socket,          Ptr     bdsPtr,          short     reqLength,          Ptr     reqPointer,          char     numOfBuffs){OSErr err;  SetOurCompletionRoutine((ProcPtr)&amp;doSndRequestIOComp,              atpPBPtr);  atpPBPtr-&gt;SREQ.atpSocket     = socket;    atpPBPtr-&gt;SREQ.addrBlock.aNet   = address.aNet;  atpPBPtr-&gt;SREQ.addrBlock.aNode   = address.aNode;  atpPBPtr-&gt;SREQ.addrBlock.aSocket = address.aSocket;    atpPBPtr-&gt;SREQ.reqLength     = reqLength;  atpPBPtr-&gt;SREQ.reqPointer     = reqPointer;    atpPBPtr-&gt;SREQ.bdsPointer     = bdsPtr;  atpPBPtr-&gt;SREQ.atpFlags     = atpEOMvalue + atpSendChkvalue;    atpPBPtr-&gt;SREQ.timeOutVal     = kATPTimeOutVal;  atpPBPtr-&gt;SREQ.retryCount     = kATPRetryCount;    /* number of response datagrams that will be accepted */  atpPBPtr-&gt;SREQ.filler       = numOfBuffs;  err = PNSendRequest(atpPBPtr,true);  if (err != noErr)  {    SaveFunctionResultCode(err,              atpPBPtr);  }  }// *****************************************************************// *  SendOurResponseData// *// *****************************************************************void SendOurResponseData(ATPPBPtr atpPBPtr){char reqCode;BDSPtr bdsPtr;myATPParamBlockPtr myATPBPtr;short nElements;    reqCode = *(atpPBPtr-&gt;ATP.reqPointer);    switch( reqCode )    {      case kSendTime:          myATPBPtr = GetOurPBPtr(atpPBPtr);          bdsPtr = (BDSPtr)myATPBPtr-&gt;bdsPtr;          GetClockTime(myATPBPtr-&gt;respData);          nElements = BuildBDS(myATPBPtr-&gt;respData,                    myATPBPtr-&gt;bdsPtr,                    4);          doSendResponse(atpPBPtr,                  gOurATPSocket,                  (Ptr)bdsPtr,                  nElements,                  nElements);        break;      case kSendData:          myATPBPtr = GetOurPBPtr(atpPBPtr);                    bdsPtr = (BDSPtr)myATPBPtr-&gt;bdsPtr;                      /* copy &quot;data&quot; from our resource into our buffer */          HLock(gTestDataHdl);          BlockMove(*gTestDataHdl,                myATPBPtr-&gt;respData,                gTestDataSize);            /* fill the BDS with our &quot;data&quot; */          nElements = BuildBDS(myATPBPtr-&gt;respData,                    myATPBPtr-&gt;bdsPtr,                    gTestDataSize);          HUnlock(gTestDataHdl);                    doSendResponse(atpPBPtr,                  gOurATPSocket,                  (Ptr)bdsPtr,                  nElements,                  nElements);        break;            }}// *****************************************************************// *  doSendResponseIOComp// *// *  completion routine for our send response call.// *****************************************************************pascal void doSendResponseIOComp(ATPPBPtr atpPBPtr){myATPParamBlockPtr myATPPBPtr;  if (atpPBPtr-&gt;ATP.ioResult == noErr)  {    myATPPBPtr = GetOurPBPtr(atpPBPtr);      /* our response was sent, so issue another async. GetRequest        so that we may receive another request */    doGetRequest(atpPBPtr,          gOurATPSocket,          sizeof(struct ourReqData),          myATPPBPtr-&gt;reqData);  }  else  {      /* place parameter block back into the &quot;Done&quot; queue */    Enqueue((QElemPtr)atpPBPtr,&amp;gDoneQueue);  }}// *****************************************************************// *  doSendResponse// *// *  We send a response back to the requestor in this routine.// *****************************************************************void doSendResponse(ATPPBPtr atpPBPtr,          char   socket,          Ptr    bdsPtr,          char  numOfBuffs,          char  bdsSize){OSErr err;  SetOurCompletionRoutine((ProcPtr)&amp;doSendResponseIOComp,              atpPBPtr);  atpPBPtr-&gt;ATP.atpSocket     = socket;  atpPBPtr-&gt;ATP.atpFlags       = atpEOMvalue + atpSendChkvalue;  atpPBPtr-&gt;ATP.bdsPointer     = bdsPtr;  atpPBPtr-&gt;OTH1.u0.numOfBuffs   = numOfBuffs;    /* num. of resp. bufs being sent */  atpPBPtr-&gt;OTH2.bdsSize       = bdsSize;    /* note: the &quot;addrBlock&quot; and &quot;transID' fields are already      set up for us by the just completed GetRequest call */  err = PSendResponse(atpPBPtr,true);  if (err != noErr)  {    SaveFunctionResultCode(err,              atpPBPtr);  }}// *****************************************************************// *  closeOurSocket// *// *  close the socket that we used to listen for requests.// *****************************************************************void closeOurSocket(char socket){ATPParamBlock pb;  pb.ATP.atpSocket     = socket;    PCloseATPSkt(&amp;pb,false);}// *****************************************************************// *  CheckDoneQueue// *// *  This routine looks through the &quot;Done&quot; queue for calls that// *  have completed and reports any errors.// *****************************************************************void CheckDoneQueue(){QElemPtr qElemPtr;ATPPBPtr atpPBPtr;myATPParamBlockPtr myATPPBPtr;OSErr err;    /* have any calls completed? */  if (gDoneQueue.qHead != nil)  {    qElemPtr = gDoneQueue.qHead;    err = Dequeue((QElemPtr)qElemPtr,&amp;gDoneQueue);    if (err == noErr)    {      atpPBPtr = (ATPPBPtr)qElemPtr;              /* first check function result - was the          call queued successfully by the driver? */      myATPPBPtr = GetOurPBPtr(atpPBPtr);      if (myATPPBPtr-&gt;functionResult != noErr)      {        ShowError(DrvrErr);      }        /* now check ioResult - were there any          errors on this particular call? */      else if (atpPBPtr-&gt;ATP.ioResult != noErr)      {        ShowATPError(atpPBPtr);      }        /* place queue element back into the &quot;available&quot; queue */      Enqueue((QElemPtr)qElemPtr,&amp;gAvailQueue);    }  }}// *****************************************************************// *  VerifyData// *// *    Verifies that the test data we received matches our own// *****************************************************************Boolean VerifyData(myATPParamBlockPtr myATPPbPtr){BDSPtr bds;Ptr original,received;Boolean valid;short i,j;  valid = true;  bds = (BDSPtr)myATPPbPtr-&gt;bdsPtr;  HLock(gTestDataHdl);  original = *gTestDataHdl;  for (i = 0;    (i &lt; (myATPPbPtr-&gt;u.SREQ.numOfResps)) &amp;&amp; (valid == true);    ++i)  {    received = bds-&gt;buffPtr;    for (j = 0;      (j &lt; bds-&gt;dataSize) &amp;&amp; (valid == true);      ++j)    {      if (*original != *received)        valid = false;      ++original;      ++received;    }    ++bds;  /* next BDS Element */  }  HUnlock(gTestDataHdl);    return valid;}// *****************************************************************// *  CheckRequests// *// *****************************************************************void CheckRequests(){QElemPtr qElemPtr;ATPPBPtr atpPBPtr;OSErr err;short reqCode;myATPParamBlockPtr myATPPBPtr;Boolean valid;short nElements;    /* have we received any requests? or have any requests that we      sent completed? */  if (gRequestQueue.qHead != nil)  {    qElemPtr = gRequestQueue.qHead;    err = Dequeue((QElemPtr)qElemPtr,&amp;gRequestQueue);    if (err == noErr)    {      atpPBPtr = (ATPPBPtr)qElemPtr;      switch (atpPBPtr-&gt;ATP.csCode)      {        case nSendRequest:  /* request that we sent */        case sendRequest:              /* did we request clock time or data? */            reqCode = *(atpPBPtr-&gt;ATP.reqPointer);            switch (reqCode)            {              case kSendTime:                  /* show the clock time */                ShowClockTime(atpPBPtr);                break;              case kSendData:                myATPPBPtr = GetOurPBPtr(atpPBPtr);                  /* insert your routine here to verify data */                valid = VerifyData(myATPPBPtr);                                  /* if &quot;single request&quot; mode is selected,                  put up a dialog to report status */                if (gSingleRequest == true)                {                  if (valid == true)                    ShowError(dataIsValid);                  else                    ShowError(dataNotValidErr);                }                else  /* &quot;continuous&quot; mode, so print status text in window */                {                  if (valid == true)                    ShowStatusString(kTestDataCorrect);                  else                    ShowStatusString(kTestDataIncorrect);                }                break;            }                          /* should we re-issue another request to the target? */            if ((gSingleRequest == false) &amp;&amp;              (gStopRequests == false))            {              myATPPBPtr = GetOurPBPtr(atpPBPtr);              if (gReqClockTime == true)              {                *(myATPPBPtr-&gt;reqData) = kSendTime;                  /* setup response BDS to hold our                    clock/time value */                nElements = BuildBDS(myATPPBPtr-&gt;respData,                          myATPPBPtr-&gt;bdsPtr,                          4);              }              else  /* send test &quot;data&quot; */              {                *(myATPPBPtr-&gt;reqData) = kSendData;                nElements = BuildBDS(myATPPBPtr-&gt;respData,                          myATPPBPtr-&gt;bdsPtr,                          gTestDataSize);              }                              /* clear status string first */              ShowStatusString(kBlankText);                /* send a request to target machine */              doSndRequest(atpPBPtr,                    gTargetAddress,                    gOurATPSocket,                    myATPPBPtr-&gt;bdsPtr,                    2,                    myATPPBPtr-&gt;reqData,                    nElements);            }            else            {                /* place parameter block back into the &quot;Avail&quot; queue */              Enqueue((QElemPtr)atpPBPtr,&amp;gAvailQueue);            }                      break;                  case getRequest:  /* request that we received */                    /* send back either our machines's clock time              or test &quot;data&quot; */            SendOurResponseData(atpPBPtr);          break;      }    }  }}// *****************************************************************// *  ATPLoop// *// *****************************************************************void ATPLoop(){  CheckDoneQueue();  CheckRequests();}// *****************************************************************// *  SendReqToTarget// *// *  issues a request to the selected target machine. The target is// *  selected using the popup menus.// *****************************************************************Boolean SendReqToTarget(){  MPPParamBlock pbLKP;  Ptr ntePtr, buffer;  EntityName abEntity;  AddrBlock address;  ATPPBPtr atpPBPtr;  myATPParamBlockPtr myATPPBPtr;  Boolean reqSent;  short nElements;    reqSent = false;        ntePtr = nil;    buffer = nil;        ntePtr = NewPtr(sizeof(NamesTableEntry));    if (ntePtr == nil)      goto Done;    buffer = NewPtr(100);    if (buffer == nil)      goto Done;    NBPSetEntity(ntePtr, gObjStr, gTypeStr, gZoneString);    pbLKP.NBP.interval = 3;    pbLKP.NBP.count = 3;    pbLKP.NBP.NBPPtrs.entityPtr = ntePtr;    pbLKP.NBP.parm.Lookup.retBuffSize = 100;    pbLKP.NBP.parm.Lookup.retBuffPtr = buffer;    pbLKP.NBP.parm.Lookup.maxToGet = 1;      /* first let's try and locate the selected machine on the network */    if (PLookupName(&amp;pbLKP, false) == noErr)    {    /* did we find it? */      if ( pbLKP.NBP.parm.Lookup.numGotten &gt; 0)      {    /* go ahead and send a request to the target */        if (NBPExtract(buffer, pbLKP.NBP.parm.Lookup.numGotten, 1, &amp;abEntity, &amp;address) == noErr)        {            /* save the target address */          gTargetAddress = address;                    atpPBPtr = GetQElement(&amp;gAvailQueue);          if (atpPBPtr != NULL)          {            myATPPBPtr = GetOurPBPtr(atpPBPtr);              /* sending clock time or &quot;data&quot; ? */            if (gReqClockTime == true)            {              *(myATPPBPtr-&gt;reqData) = kSendTime;                /* setup response BDS to hold our                  clock/time value */              nElements = BuildBDS(myATPPBPtr-&gt;respData,                        myATPPBPtr-&gt;bdsPtr,                        4);            }            else  /* send test &quot;data&quot; */            {              *(myATPPBPtr-&gt;reqData) = kSendData;              nElements = BuildBDS(myATPPBPtr-&gt;respData,                        myATPPBPtr-&gt;bdsPtr,                        gTestDataSize);            }                          /* send a request to target machine */            doSndRequest(atpPBPtr,                  address,                  gOurATPSocket,                  myATPPBPtr-&gt;bdsPtr,                  2,                  myATPPBPtr-&gt;reqData,                  nElements);                              reqSent = true;          }        }                  }      else  /* target not found */      {        ShowError(noTargetErr);          /* re-enable send request button */        HiliteSendReqButton (0);      }    }        Done:        if (ntePtr != nil)      DisposPtr(ntePtr);    if (buffer != nil)      DisposPtr(buffer);        return reqSent;}// *****************************************************************// *  initializeATP// *// *  allocates parameter blocks for our atp calls, opens a socket// *  for us to receive requests on, registers our name on the network.// *****************************************************************void initializeATP(){  InitQueues();  if (GetASocket(&amp;gOurATPSocket) == true)    registerMyName(gOurATPSocket);  else    FatalError(SktErr);}// *****************************************************************// *  removeATP// *// *  removes our nbp name from the network, closes our atp socket// *  and de-allocates the memory we used for our parameter blocks.// *****************************************************************void removeATP(){  closeOurSocket(gOurATPSocket);  removeMyName();}// *****************************************************************// *  GetClockTime// *// *****************************************************************void GetClockTime(Ptr buf){  unsigned long secs;    GetDateTime(&amp;secs);    BlockMove(&amp;secs, buf, 4);}// *****************************************************************// *  ShowStatusString// *// *****************************************************************void ShowStatusString(StringPtr str){  Rect r;  short kind;  Handle h;    GetDItem(myDialog, kStatusText, &amp;kind, &amp;h, &amp;r);    SetIText(h, str);}// *****************************************************************// *  ShowClockTime// *// *****************************************************************void ShowClockTime(ATPPBPtr atpPBPtr){  Rect r;  short kind;  Handle h;  Str255 str,str2;  BDSPtr bdsPtr;  long dateTime;    GetDItem(myDialog, kClockTime, &amp;kind, &amp;h, &amp;r);    GetIText(h, str2);        bdsPtr = (BDSPtr)atpPBPtr-&gt;ATP.bdsPointer;    BlockMove(bdsPtr-&gt;buffPtr, &amp;dateTime, 4);    IUTimeString(dateTime, true, str);      /* this just checks to see that we're not already displaying this time already */      /* flashing text sucks... so sayeth me */    if (IUCompString(str,str2) != 0)      SetIText(h, &amp;str);}// *****************************************************************// *  SetUpATPError// *// *  sets our error string for the desired error code// *****************************************************************void SetUpATPError(OSErr err,          StringPtr displayStr){  switch (err)  {    case reqFailed:      PStrCat(&quot;\pSend Request failed. Retry count exceeded.&quot;,(Ptr)displayStr);      break;          case tooManyReqs:      PStrCat(&quot;\pToo many concurrent requests.&quot;,(Ptr)displayStr);      break;    case noDataArea:      PStrCat(&quot;\pToo many outstanding ATP calls.&quot;,(Ptr)displayStr);      break;          case badATPSkt:      PStrCat(&quot;\pBad responding socket.&quot;,(Ptr)displayStr);      break;    case noRelErr:      PStrCat(&quot;\pNo release received.&quot;,(Ptr)displayStr);      break;    case badBuffNum:      PStrCat(&quot;\pBad sequence number.&quot;,(Ptr)displayStr);      break;    case sktClosedErr:      PStrCat(&quot;\pAsynchronous call aborted because socket was closed.&quot;,(Ptr)displayStr);      break;          default:      NumToString(err,(Ptr)displayStr);      }}// *****************************************************************// *  ShowATPError// *// *  If one of our asynchronous atp calls returned an error, the// *  parameter block gets stuffed into an error OSQueue by the completion// *  routine. This error queue is checked periodically by this routine.// *  If the queue is not empty, then we got an error so we display it here// *  and do any processing of the error that we want.// *****************************************************************void ShowATPError(ATPPBPtr atpPBPtr){  Rect r;  short kind;  Handle h;  short itemHit;  Str255 displayStr,theError;        displayStr[0] = 0;              /*  Use cscode field of the parameter block           to see which call this error is for*/      switch (atpPBPtr-&gt;ATP.csCode)      {        case getRequest:            /* dont report errors if we cancel the call */          if (atpPBPtr-&gt;ATP.ioResult != reqAborted)          {            CopyPstr(&quot;\pGetRequest error. &quot;,&amp;displayStr);            SetUpATPError(atpPBPtr-&gt;ATP.ioResult, &amp;displayStr);          }         break;          case nSendRequest:          CopyPstr(&quot;\pSendRequest error. &quot;,&amp;displayStr);          SetUpATPError(atpPBPtr-&gt;ATP.ioResult, &amp;displayStr);                    /* we got an error so stop sending requests if we are in            &quot;continuous&quot; mode */          if (gDoContinuous == true)          {            GetDItem(myDialog, kReqDataButton, &amp;kind, &amp;h, &amp;r);            SetCTitle((ControlHandle)h, &quot;\pRequest Data&quot;);          }         break;              case sendResponse:          CopyPstr(&quot;\pSendResponse error. &quot;,&amp;displayStr);          SetUpATPError(atpPBPtr-&gt;ATP.ioResult, &amp;displayStr);         break;        default:          CopyPstr(&quot;\pError: &quot;,&amp;displayStr);          NumToString(atpPBPtr-&gt;ATP.ioResult,theError);          PStrCat(theError,(Ptr)displayStr);        break;        }        /* if we have a message we want to show, put up a dialog          for the user */      if (displayStr[0] != 0)      {        ParamText(displayStr,&quot;\p&quot;,&quot;\p&quot;,&quot;\p&quot;);        itemHit = Alert(rErrorDialog, nil);      }          /* re-enable send request button */      HiliteSendReqButton (0);    }</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/ATP_Demo/listing4.html%3Fid%3DDTS10000228-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/ATP_Demo/listing4.html%3Fid%3DDTS10000228-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/ATP_Demo/listing4.html%3Fid%3DDTS10000228-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>