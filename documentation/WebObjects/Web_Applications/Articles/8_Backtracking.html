<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>WebObjects Web Applications Programming Guide: Backtracking and Cache Management</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Backtracking and Cache Management"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40003273" title="Backtracking and Cache Management"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../DeveloperTools/index.html#//apple_ref/doc/uid/TP30000440-TP30000436" target="_top">Tools</a> &gt; <a href="../../../DeveloperTools/WebObjects-date.html#//apple_ref/doc/uid/TP30000440-TP30000436-TP30000592" target="_top">WebObjects</a> &gt; <a href="../index.html" target="_top">WebObjects Web Applications Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="5_AppAndSession.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../RevisionHistory.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>
        
        
        <a name="//apple_ref/doc/uid/TP40003273-SW1" title="Backtracking and Cache Management"></a><hr /><H1>Backtracking and Cache Management</H1><p>Backtracking, client-side page caching, and web component caching are three closely related issues that cause many headaches for web application developers. Fortunately, WebObjects offers a number of mechanisms that help you deal with the collective problem of managing page state.</p><p>Dynamic web applications are possible because of, among other things, server-side state persistence and state management. HTTP, the protocol of the web, is inherently stateless. However, storing state in an application server makes persistence management in web applications possible. In WebObjects, the Session object holds state but is not solely responsible for state management. The Session object tracks sessions, flags WOComponent and WOElement objects with special identifiers, and uses other mechanisms to hold and manage state. WOComponent objects manage the state of their internal instance variables and dynamic elements.</p><p>Along with these mechanisms, caching plays an important role in managing the state of visual components. Caching allows a user to view a previously viewed webpage (even a dynamically generated one) without the application needing to regenerate the page. Caching also plays a crucial role in providing a good user experience in web applications. Caching lets users backtrack using their web browser’s Back button, which often allows for instantaneous loading of pages from the client-side cache rather than requesting a previously viewed page from the application server. However, because there are diverse implementations of the HTTP protocol in web browsers, backtracking behavior is inconsistent and requires considerable attention when developing web applications. </p><p>In addition to client-side page caching, WebObjects also caches components in a server-side cache. If used correctly, this is a valuable feature that can improve performance and user experience. But you must be conscious of the relationship between server-side component caching and client-side page caching, and how inconsistencies in backtracking behavior affect the result when either or both caching features are active.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <!-- TopicBook.pm uses this template for its miniTOCs, but needs a different title. -->
    <h4>Contents:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="8_Backtracking.html#//apple_ref/doc/uid/TP40003273-DontLinkElementID_46">Client-Side Page Cache</a>
				
			<br/>
			
        
			
			
				<a href="8_Backtracking.html#//apple_ref/doc/uid/TP40003273-DontLinkElementID_47">Server-Side Component Definition Cache</a>
				
			<br/>
			
        
			
			
				<a href="8_Backtracking.html#//apple_ref/doc/uid/TP40003273-SW5">Server-Side Page Cache</a>
				
			<br/>
			
        
			
			
				<a href="8_Backtracking.html#//apple_ref/doc/uid/TP40003273-SW4">Web Browser Backtracking Behavior</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40003273-DontLinkElementID_46" title="Client-Side Page Cache"></a><h2>Client-Side Page Cache</h2><p>A web component is the aggregate of WebObjects elements and subcomponents. When a web browser caches a webpage from a WebObjects application, it caches the static HTML code of a generated page (which does not include a web component’s programmatic entities, such as instance variables). In contrast, server-side component caching caches a web component’s definition and state.</p><p>Client-side page caching is a feature implemented by web browsers to improve performance and user experience. Although WebObjects applications primarily publish dynamic webpages, many websites serve static pages: They do not change as rapidly as content-driven dynamic sites.</p><p>For instance, consider a website that publishes news stories and other articles. Although the front page of the site probably changes a few times each day, it likely would not change in the few minutes an average user spends browsing headlines and reading a few articles. </p><p>With client-side page caching active, the front page of the news website is cached on the client’s computer upon the first visit. The first page could be large, containing images, banner ads, and text. The user could select an article, read part of it, and access other articles through URLs in the first article. Then, having visited five or six pages within the website, the user could backtrack to the main page. Since the content of that page is not likely to change in the time the user took to peruse the five or six pages, the page should be reloaded from the local cache. So the web browser—instead of requesting and downloading the main page from the web server again—would retrieve it from the local cache, avoiding a round trip over the network to the web server. In this case, page caching serves a sensible and user-friendly function.</p><p>Now, consider the case of an online store: A user chooses items to buy and adds them to a shopping cart. It’s generally not a good idea for the user to view a cached webpage representing the shopping cart as it likely does not contain the most up-to-date information. If client-side page caching is active, however, this is a real possibility.</p><p>WebObjects offers a number of mechanisms to deal with the problems of backtracking and client-side caching. The first one you should use is a flag on the Application object that you set using the <code>setPageRefreshOnBacktrackEnabled</code> method of the WOApplication class (<code>com.webobjects.appserver</code>). When <code>pageRefreshOnBacktrackEnabled</code> is <code>true</code>, a number of HTTP headers are added to each response generated by the WebObjects application to disable client-side page caching. <span class="content_text">Table 1</span> shows these headers and their values.</p><a name="//apple_ref/doc/uid/TP40003273-SW2" title="Table 1HTTP response headers that deactivate client-side page caching"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1&nbsp;&nbsp;</strong>HTTP response headers that deactivate client-side page caching</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Header</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Value</p></th></tr><tr><td  scope="row"><p><code>date</code></p></td><td ><p><em>The time the response page was generated.</em></p></td></tr><tr><td  scope="row"><p><code>expires</code></p></td><td ><p><em>The time the response is to expire.</em> (Same as <code>date</code>.)</p></td></tr><tr><td  scope="row"><p><code>pragma</code></p></td><td ><p><code>no-cache</code></p></td></tr><tr><td  scope="row"><p><code>cache-control</code></p></td><td ><p><code>private</code>, <code>no-cache</code>, <code>no-store</code>, <code>must-revalidate</code>, <code>max-age = 0</code></p></td></tr></table></div><p>See section 14.9 of the HTTP 1.1 specification (RFC 2616) for more details on each of these headers.</p><p>The <code>pageRefreshOnBacktrackEnabled</code> property affects all responses generated by an application. If you want to restrict the behavior to a specific response, invoke the <code>disableClientCaching</code> method of the WOResponse object (<code>com.webobjects.appserver</code>). WOResponse also includes the methods <code>setHeader</code> and <code>setHeaders</code>, which allow you to explicitly set the HTTP headers for a particular response.</p><p>When a web browser receives a response page with the headers shown in <span class="content_text">Table 1</span>, it should not add the page to its local cache and it should invalidate the page as soon as it is displayed. In other words, when users backtrack to retrieve previously viewed pages, the web browser should request the response page from the application server. However, not all web browsers follow this protocol, as demonstrated in <span class="content_text"><a href="8_Backtracking.html#//apple_ref/doc/uid/TP40003273-SW4">“Web Browser Backtracking Behavior.”</a></span> The first few times the user backtracks to previously viewed pages, most web browsers ignore the HTTP headers and render the page stored in the cache.</p><p>When a web browser needs to refresh an expired page, it sends a request to the application server, which accesses the server-side cache to reconstruct the page (see <span class="content_text"><a href="8_Backtracking.html#//apple_ref/doc/uid/TP40003273-SW5">“Server-Side Page Cache”</a></span> for more information on server-side caching). <span class="content_text"><a href="1_Architecture.html#//apple_ref/doc/uid/TP40003268-SW13">“Request-Response Loop Messages”</a></span> explains the phases of the request-response loop in detail. The main phases are sync, action, and response. When processing a refresh request, an application does not go through the sync and action phases; it performs only the response phase.</p><p>So how does an application know to perform only the response phase (just returning the response page stored in the server cache, rather than regenerating it)? WebObjects assigns each response a context ID. The context ID is increased by 1 each time a web browser requests a specific page from the application server during a session. It identifies a specific instance of the corresponding WOComponent. (<span class="content_text">Figure 1</span> shows the elements of a WebObjects URL.) Specifically, an application assigns the outermost component of a WOComponent a context ID each time that component is part of a response. So, if the same component is dynamically generated multiple times, each instance of the page (each response) is assigned a unique context ID.</p><br/><div><a name="//apple_ref/doc/uid/TP40003273-SW6" title="Figure 1Structure of a component action URL"></a><p><strong>Figure 1&nbsp;&nbsp;</strong>Structure of a component action URL</p><img src = "../Art/incomingurl.gif" alt = "Structure of a component action URL" width="515" height="93"></div><br/><a name="//apple_ref/doc/uid/TP40003273-DontLinkElementID_47" title="Server-Side Component Definition Cache"></a><h2>Server-Side Component Definition Cache</h2><p>When a web component is accessed for the first time, its definition is placed on the server-side cache. Subsequent requests for the same component use the definition stored in the cache. Using the web component cache improves performance because the application looks up a component’s definition only one time during the lifetime of the application. You can control web component caching at the application level and the component level. You can set a caching policy for the application (either active or inactive) for all components, but you can also override such policy on specific components. To set the caching policy for an application or a web component you use the <code>setCachingEnabled</code> method of WOApplication or WOComponent, respectively. Sending <code>true</code> as the argument activates web component–definition caching, while sending <code>false</code> deactivates it.</p><a name="//apple_ref/doc/uid/TP40003273-SW5" title="Server-Side Page Cache"></a><h2>Server-Side Page Cache</h2><p>In addition to component-definition caching, WebObjects applications can also cache responses sent to a client. When an already-generated page is requested from the application server, WebObjects checks the context ID of the requested page with the context ID of pages in its cache. If it finds a match, it performs the response phase of the request-response loop. This returns a response that has a new context ID and updated content from the invocation of the response phase of the request-response loop (dynamic bindings are again resolved in the response phase).</p><p>By default, the WebObjects application server maintains a page cache for each session. Each page a user accesses is added to the session’s page cache. When a user backtracks, accesses a URL, or selects a bookmark of a page that is cached but expired in the local cache, the web browser requests a refreshed version of that page from the application server. The server-side page cache preserves resources as it hands out the result of previously generated pages. When the page the user backtracks to is no longer in the cache, WebObjects returns an error page.</p><p>If you deactivate the server-side page cache (by passing <code>0</code> to the <code>setPageCacheSize</code> method of WOApplication), the application assumes that you intend to provide custom component state persistence rather than rely on WebObjects inherent support. Deactivating the component cache means that new WOComponent objects are instantiated (that is, each request for a component creates a new instance of that component) with each cycle of the request-response loop, even for component action requests that return the invoking page. This means that any nondefault instance variable values are discarded with each subsequent cycle of the request-response loop. In large applications, this redundancy and overhead could hinder performance.</p><p>WebObjects also provides a permanent page cache that is useful for storing subcomponents such as navigation bars or page headers, or when using frame sets. You have to explicitly add components to it using the <code>savePageInPermanentCache</code> method of WOSession (<code>com.webobjects.appserver</code>). Read <em><a href="../../Reference/WO53_Reference/index.html#//apple_ref/doc/uid/TP40002174" target="_top">WebObjects 5.3 Reference</a></em> for details.</p><a name="//apple_ref/doc/uid/TP40003273-SW4" title="Web Browser Backtracking Behavior"></a><h2>Web Browser Backtracking Behavior</h2><p>To better understand the concepts of backtracking, client-side page caching, and component-definition caching, perform the tasks described in the following sections.</p><a name="//apple_ref/doc/uid/TP40003273-DontLinkElementID_48" title="Viewing the HTML Headers"></a><h3>Viewing the HTML Headers</h3><p>Open the web application you developed in <span class="content_text"><a href="4_WebComponents.html#//apple_ref/doc/uid/TP40003271-SW1">“Creating Web Components”</a></span> or any other simple web application.</p><p>In <code>Main.java</code>, add a method called <code>outgoingHeaders</code>:</p><div class="codesample"><table><tr><td scope="row"><pre>public String outgoingHeaders() {<span></span></pre></td></tr><tr><td scope="row"><pre>    return context().response().headers().toString();<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>This gets the headers that are attached to each outgoing WOResponse object. To view these headers, override the <code>sleep</code> method in the Main class so that it prints the headers to the console:</p><div class="codesample"><table><tr><td scope="row"><pre>public void sleep() {<span></span></pre></td></tr><tr><td scope="row"><pre>    System.out.println("&lt;Main.sleep> headers=" + outgoingHeaders());<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Build and run the application. You should see output similar to this in the console:</p><div class="codesample"><table><tr><td scope="row"><pre>Welcome to WebApp!<span></span></pre></td></tr><tr><td scope="row"><pre>[2003-01-08 17:53:56 PST] &lt;main> Opening application's URL in browser:<span></span></pre></td></tr><tr><td scope="row"><pre>http://17.203.33.19:8888/cgi-bin/WebObjects/WebApp.woa<span></span></pre></td></tr><tr><td scope="row"><pre>[2003-01-08 17:53:56 PST] &lt;main> Waiting for requests...<span></span></pre></td></tr><tr><td scope="row"><pre>&lt;Main.sleep> headers={cache-control = ("private", "no-cache", "no-store", "must-revalidate", "max-age=0");<span></span></pre></td></tr><tr><td scope="row"><pre> expires = ("Thu, 09-Jan-2003 01:53:54 GMT"); date = ("Thu, 09-Jan-2003 01:53:54 GMT"); pragma = ("no-<span></span></pre></td></tr><tr><td scope="row"><pre>cache"); content-type = ("text/html"); }<span></span></pre></td></tr></table></div><p>The <code>expires</code> header is set to the time the component is generated, so that when the web browser receives the webpage, it is already expired in the web browser’s cache. These headers (except <code>content-type</code>) are appended to the response when the <code>isPageRefreshOnBacktrackEnabled</code> method of WOApplication returns <code>true</code>, which it does by default.</p><p>In <code>Application.java</code>, set the <code>pageRefreshOnBacktrackEnabled</code> property to <code>false</code> in the constructor:</p><div class="codesample"><table><tr><td scope="row"><pre>public Application() {<span></span></pre></td></tr><tr><td scope="row"><pre>    super();<span></span></pre></td></tr><tr><td scope="row"><pre>    System.out.println("Welcome to " + this.name() + "!");<span></span></pre></td></tr><tr><td scope="row"><pre>    setPageRefreshOnBacktrackEnabled(false);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Build and run the application. You should see output similar to the following in the console:</p><div class="codesample"><table><tr><td scope="row"><pre>Welcome to WebApp!<span></span></pre></td></tr><tr><td scope="row"><pre>[2003-01-08 17:57:15 PST] &lt;main> Opening application's URL in browser:<span></span></pre></td></tr><tr><td scope="row"><pre>http://17.203.33.19:8888/cgi-bin/WebObjects/WebApp.woa<span></span></pre></td></tr><tr><td scope="row"><pre>[2003-01-08 17:57:15 PST] &lt;main> Waiting for requests...<span></span></pre></td></tr><tr><td scope="row"><pre>&lt;Main.sleep> headers={content-type = ("text/html"); }<span></span></pre></td></tr></table></div><p>Notice that the headers disabling client-side caching are not generated in the response.</p><a name="//apple_ref/doc/uid/TP40003273-DontLinkElementID_49" title="Standard Webpage Backtracking"></a><h3>Standard Webpage Backtracking</h3><p>So, how does the <code>pageRefreshOnBacktrackEnabled</code> property of WOApplication affect user backtracking? You need to add some more code to trace what WebObjects does behind the scenes. Modify the constructor in the Main class to look like this:</p><div class="codesample"><table><tr><td scope="row"><pre>public Main(WOContext context) {<span></span></pre></td></tr><tr><td scope="row"><pre>    super(context);<span></span></pre></td></tr><tr><td scope="row"><pre>    System.out.println("&lt;Main> context ID="+ context().contextID());<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Each time an instance of Main is created, this code outputs the context ID of the WOResponse object associated with the new instance. This allows you to see when user actions like clicking the Refresh hyperlink on the webpage or the web browser’s Back button produce a new instance of the Main component. While this is useful information, you may also want to know when a user action causes the application to send a new response page to the client web browser. You can trace this by adding similar code to the <code>refreshTime</code> method:</p><div class="codesample"><table><tr><td scope="row"><pre>public WOComponent refreshTime() {<span></span></pre></td></tr><tr><td scope="row"><pre>    System.out.println("&lt;Main.refresh> context ID=" + context().contextID());<span></span></pre></td></tr><tr><td scope="row"><pre>    loadCount++;<span></span></pre></td></tr><tr><td scope="row"><pre>    return null;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Now, remove the <code>sleep</code> and <code>outgoingHeaders</code> methods and build and run the application.</p><p>Click Refresh Time three times. This prints the incremental context ID of the instance of Main through which you navigate. When you click Refresh Time, the application invokes the <code>refreshTime</code> method, which outputs the context ID of the outgoing response to the console:</p><div class="codesample"><table><tr><td scope="row"><pre>Welcome to WebApp!<span></span></pre></td></tr><tr><td scope="row"><pre>[2003-01-08 18:56:18 PST] &lt;main> Opening application's URL in browser:<span></span></pre></td></tr><tr><td scope="row"><pre>http://17.203.33.19:8888/cgi-bin/WebObjects/WebApp.woa<span></span></pre></td></tr><tr><td scope="row"><pre>[2003-01-08 18:56:18 PST] &lt;main> Waiting for requests...<span></span></pre></td></tr><tr><td scope="row"><pre>&lt;Main> context ID=0<span></span></pre></td></tr><tr><td scope="row"><pre>&lt;Main.refreshTime> context ID: 1<span></span></pre></td></tr><tr><td scope="row"><pre>&lt;Main.refreshTime> context ID: 2<span></span></pre></td></tr><tr><td scope="row"><pre>&lt;Main.refreshTime> context ID: 3<span></span></pre></td></tr></table></div><p>Now, click your browser’s Back button three times. Notice that nothing is printed to the console. This is because, when <code>pageRefreshOnBacktrackEnabled</code> is set to <code>false</code>, backtracking does not result in a request to the application; the page is simply rendered using the copy in the browser’s cache. Similarly, choosing the bookmark of a page cached in the web browser does not result in a request to the application.</p><a name="//apple_ref/doc/uid/TP40003273-DontLinkElementID_50" title="Refreshing Pages When Backtracking"></a><h3>Refreshing Pages When Backtracking</h3><p>When <code>pageRefreshOnBacktrackEnabled</code> is set to <code>true</code>, backtracking should result in a request to the application (you should see a context ID line with a new context ID) when a user backtracks, although the actual behavior differs among various web browsers.</p><p>In Mac OS X, web browsers that use the Gecko HTML rendering engine (such as Chimera and Mozilla), comply most closely to the HTTP specification. Clicking the Back button causes the browser to ask for an updated version of an expired webpage. Other browsers, such as Internet Explorer and OmniWeb, behave differently: The first few clicks (two to three, depending on the browser) of the Back button reload the page from the cache. Subsequent clicks cause the browser to send a request to the application.</p><p>Notice that when the browser requests the updated version of the webpage from the application, the page-load counter doesn’t decrease, but the time is updated.</p><p>You must test your application on many configurations to ensure that it provides a good user experience.</p><a name="//apple_ref/doc/uid/TP40003273-DontLinkElementID_51" title="Disallowing Server-Side Caching"></a><h3>Disallowing Server-Side Caching</h3><p>A WebObjects application can hand back only the response of a previously generated page when server-side page caching is active, which is the default. When this feature is inactive, the <code>println</code> statement in the constructor of the Main class (of the web application described earlier in this article) is invoked each time you click the Refresh Time link. This indicates that the application instantiates a Main object each time the <code>refreshTime</code> method of Main is invoked, instead of returning the current Main object.</p><p>Modify the constructor in the Main class by adding a call to <code>setPageCacheSize</code>:</p><div class="codesample"><table><tr><td scope="row"><pre>public Application() {<span></span></pre></td></tr><tr><td scope="row"><pre>    super();<span></span></pre></td></tr><tr><td scope="row"><pre>    System.out.println("Welcome to " + this.name() + "!");<span></span></pre></td></tr><tr><td scope="row"><pre>    setPageRefreshOnBacktrackEnabled(true);<span></span></pre></td></tr><tr><td scope="row"><pre>    setPageCacheSize(0);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Build and run the application. After clicking Refresh Time three times, you should see the following console output:</p><div class="codesample"><table><tr><td scope="row"><pre>Welcome to WebApp!<span></span></pre></td></tr><tr><td scope="row"><pre>[2003-01-08 20:31:58 PST] &lt;main> Opening application's URL in browser:<span></span></pre></td></tr><tr><td scope="row"><pre>http://17.203.33.19:8888/cgi-bin/WebObjects/WebApp.woa<span></span></pre></td></tr><tr><td scope="row"><pre>[2003-01-08 20:31:57 PST] &lt;main> Waiting for requests...<span></span></pre></td></tr><tr><td scope="row"><pre>&lt;Main> context ID=0<span></span></pre></td></tr><tr><td scope="row"><pre>&lt;Main> context ID=1<span></span></pre></td></tr><tr><td scope="row"><pre>&lt;Main.refreshTime> context ID: 1<span></span></pre></td></tr><tr><td scope="row"><pre>&lt;Main> context ID=2<span></span></pre></td></tr><tr><td scope="row"><pre>&lt;Main.refreshTime> context ID: 2<span></span></pre></td></tr><tr><td scope="row"><pre>&lt;Main> context ID=3<span></span></pre></td></tr><tr><td scope="row"><pre>&lt;Main.refreshTime> context ID: 3<span></span></pre></td></tr></table></div><p>Notice that the constructor in the Main class is invoked each time you click Refresh Time, before the <code>refreshTime</code> method is executed. An instance of Main is created during each cycle of the request-response loop. Also notice that the page-view counter does not increase. The primary consequence of deactivating server-side page caching is that the values of variables in components are lost after each response is generated.</p><a name="//apple_ref/doc/uid/TP40003273-DontLinkElementID_52" title="Setting the Size of the Server-Side Cache"></a><h3>Setting the Size of the Server-Side Cache</h3><p>Instead of completely disallowing server-side caching, you can use the <code>setPageCacheSize</code> method of WOApplication to define the number of instances of a component an application is to keep in its cache. For example, if you want to maintain state between cycles of the request-response loop (that is, to ensure that state is transferred between user actions), set the <code>pageCacheSize</code> to <code>1</code>.</p><p>Modify the constructor in the Application class by adding a call to <code>setPageCacheSize</code>, setting the <code>pageCacheSize</code> property to <code>10</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>public Application() {<span></span></pre></td></tr><tr><td scope="row"><pre>    super();<span></span></pre></td></tr><tr><td scope="row"><pre>    System.out.println("Welcome to " + this.name() + "!");<span></span></pre></td></tr><tr><td scope="row"><pre>    setPageRefreshOnBacktrackEnabled(true);<span></span></pre></td></tr><tr><td scope="row"><pre>    setPageCacheSize(10);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p><span class="content_text">Figure 2</span> shows the page an application sends to a web browser when a user backtracks too far (the page is no longer in the cache).</p><br/><div><a name="//apple_ref/doc/uid/TP40003273-SW3" title="Figure 2Backtracking error page"></a><p><strong>Figure 2&nbsp;&nbsp;</strong>Backtracking error page</p><img src = "../Art/bt_errorpage.jpg" alt = "Backtracking error page" ></div><br/><p>You can customize the error page users receive by implementing the <code>handlePageRestorationErrorInContext</code> method in the Application class:</p><div class="codesample"><table><tr><td scope="row"><pre>public WOResponse handlePageRestorationErrorInContext(WOContext aContext) {<span></span></pre></td></tr><tr><td scope="row"><pre>    WOComponent nextPage;<span></span></pre></td></tr><tr><td scope="row"><pre>    nextPage = (Error)pageWithName("Error", aContext);<span></span></pre></td></tr><tr><td scope="row"><pre>    return nextPage.generateResponse();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>In this code listing, a page is instantiated from a web component named <code>Error</code>, which you must build. The contents of the component are completely up to you, but should include the name of the application, your company’s name, and a friendly message that tells the user that something went wrong and suggests ways they can return to normal operation.</p>

        <br/><br/> 

        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="5_AppAndSession.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../RevisionHistory.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-07-11<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/WebObjects/Web_Applications/Articles/8_Backtracking.html%3Fid%3DTP30001010-5.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/WebObjects/Web_Applications/Articles/8_Backtracking.html%3Fid%3DTP30001010-5.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/WebObjects/Web_Applications/Articles/8_Backtracking.html%3Fid%3DTP30001010-5.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>
