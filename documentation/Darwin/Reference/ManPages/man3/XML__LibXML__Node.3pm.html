<html><head><title>Mac OS X
 Manual Page For XML::LibXML::Node(3pm)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3pm/XML::LibXML::Node" title="Mac OS X
 Manual Page for XML::LibXML::Node(3pm)"><a name="//apple_ref/doc/man/3/XML::LibXML::Node" title="Mac OS X
 Manual Page for XML::LibXML::Node(3pm)"><!-- headerDoc=man; indexgroup=Section 3pm; uid="//apple_ref/doc/man/3pm/XML::LibXML::Node"; name=XML::LibXML::Node(3pm) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
XML::LibXML::Node(3)                 User Contributed Perl Documentation                XML::LibXML::Node(3)



<b>NAME</b>
       XML::LibXML::Node - Abstract Base Class of XML::LibXML Nodes

<b>SYNOPSIS</b>
         $name = $node-&gt;nodeName;
         $node-&gt;setNodeName( $newName );
         $bool = $node-&gt;isSameNode( $other_node );
         $bool = $node-&gt;isEqual( $other_node );
         $content = $node-&gt;nodeValue;
         $content = $node-&gt;textContent;
         $type = $node-&gt;nodeType;
         $node-&gt;unbindNode();
         $childnode = $node-&gt;removeChild( $childnode );
         $oldnode = $node-&gt;replaceChild( $newNode, $oldNode );
         $node-&gt;replaceNode($newNode);
         $childnode = $node-&gt;appendChild( $childnode );
         $childnode = $node-&gt;addChild( $chilnode );
         $node = $parent-&gt;addNewChild( $nsURI, $name );
         $node-&gt;addSibling($newNode);
         $newnode =$node-&gt;cloneNode( $deep );
         $parentnode = $node-&gt;parentNode;
         $nextnode = $node-&gt;nextSibling();
         $prevnode = $node-&gt;previousSibling();
         $boolean = $node-&gt;hasChildNodes();
         $childnode = $node-&gt;firstChild;
         $childnode = $node-&gt;lastChild;
         $documentnode = $node-&gt;ownerDocument;
         $node = $node-&gt;getOwner;
         $node-&gt;setOwnerDocument( $doc );
         $node-&gt;insertBefore( $newNode, $refNode );
         $node-&gt;insertAfter( $newNode, $refNode );
         @nodes = $node-&gt;findnodes( $xpath_statement );
         $result = $node-&gt;find( $xpath );
         print $node-&gt;findvalue( $xpath );
         @childnodes = $node-&gt;childNodes;
         $xmlstring = $node-&gt;toString($format,$docencoding);
         $c14nstring = $node-&gt;toString($with_comments, $xpath_expression);
         $str = $doc-&gt;serialze($format);
         $c14nstr = $doc-&gt;serialize_c14n($comment_flag,$xpath);
         $localname = $node-&gt;localname;
         $nameprefix = $node-&gt;prefix;
         $uri = $node-&gt;namespaceURI();
         $boolean = $node-&gt;hasAttributes();
         @attributelist = $node-&gt;attributes();
         $URI = $node-&gt;lookupNamespaceURI( $prefix );
         $prefix = $node-&gt;lookupNamespacePrefix( $URI );
         $iter = $node-&gt;iterator;
         $node-&gt;normalize;
         @nslist = $node-&gt;getNamespaces;
         $node-&gt;removeChildNodes();
         $node-&gt;nodePath();
         $lineno = $node-&gt;line_number();

<b>DESCRIPTION</b>
       XML::LibXML::Node defines functions that are common to all Node Types. A LibXML::Node should never be
       created standalone, but as an instance of a high level class such as LibXML::Element or LibXML::Text.
       The class itself should provide only common functionality. In XML::LibXML each node is part either of
       a document or a document-fragment. Because of this there is no node without a parent. This may causes
       confusion with "unbound" nodes.

       <b>nodeName</b>
             $name = $node-&gt;nodeName;

           Returns the node's name. This Function is aware of namesaces and returns the full name of the
           current node (prefix:localname)

       <b>setNodeName</b>
             $node-&gt;setNodeName( $newName );

           In very limited situations, it is useful to change a nodes name. In the DOM specification this
           should throw an error. This Function is aware of namespaces.

       <b>isSameNode</b>
             $bool = $node-&gt;isSameNode( $other_node );

           returns TRUE (1) if the given nodes refer to the same node structure, otherwise FALSE (0) is
           returned.

       <b>isEqual</b>
             $bool = $node-&gt;isEqual( $other_node );

           deprecated version of <u>isSameNode()</u>.

           NOTE isEqual will change behaviour to follow the DOM specification

       <b>nodeValue</b>
             $content = $node-&gt;nodeValue;

           If the node has any content (such as stored in a text node) it can get requested through this
           function.

           NOTE: Element Nodes have no content per definition. To get the text value of an Element use
           <u>textContent()</u> instead!

       <b>textContent</b>
             $content = $node-&gt;textContent;

           this function returns the content of all text nodes in the descendants of the given node as
           spacified in DOM.

       <b>nodeType</b>
             $type = $node-&gt;nodeType;

           Retrun the node's type. The possible types are described in the libxml2 tree.h documentation. The
           return value of this function is a numeric value. Therefore it differs from the result of perl
           ref function.

       <b>unbindNode</b>
             $node-&gt;unbindNode();

           Unbinds the Node from its siblings and Parent, but not from the Document it belongs to. If the
           node is not inserted into the DOM afterwards it will be lost after the programm terminated. From
           a low level view, the unbound node is stripped from the context it is and inserted into a
           (hidden) document-fragment.

       <b>removeChild</b>
             $childnode = $node-&gt;removeChild( $childnode );

           This will unbind the Child Node from its parent $node. The function returns the unbound node. If
           oldNode is not a child of the given Node the function will fail.

       <b>replaceChild</b>
             $oldnode = $node-&gt;replaceChild( $newNode, $oldNode );

           Replaces the $oldNode with the $newNode. The $oldNode will be unbound from the Node. This
           function differs from the DOM L2 specification, in the case, if the new node is not part of the
           document, the node will be imported first.

       <b>replaceNode</b>
             $node-&gt;replaceNode($newNode);

           This function is very similar to <u>replaceChild()</u>, but it replaces the node itself rather than a
           childnode. This is useful if a node found by any XPath function, should be replaced.

       <b>appendChild</b>
             $childnode = $node-&gt;appendChild( $childnode );

           The function will add the $childnode to the end of $node's children. The function should fail, if
           the new childnode is allready a child of $node. This function differs from the DOM L2
           specification, in the case, if the new node is not part of the document, the node will be
           imported first.

       <b>addChild</b>
             $childnode = $node-&gt;addChild( $chilnode );

           As an alternative to <u>appendChild()</u> one can use the <u>addChild()</u> function. This function is a bit
           faster, because it avoids all DOM conformity checks.  Therefore this function is quite useful if
           one builds XML documents in memory where the order and ownership (ownerDocument) is assured.

           <u>addChild()</u> uses libxml2's own <u>xmlAddChild()</u> function. Thus it has to be used with extra care: If
           a text node is added to a node and the node itself or its last childnode is as well a text node,
           the node to add will be merged with the one already available. The current node will be removed
           from memory after this action. Because perl is not aware of this action, the perl instance is
           still available. XML::LibXML will catch the loss of a node and refuse to run any function called
           on that node.

              my $t1 = $doc-&gt;createTextNode( "foo" );
              my $t2 = $doc-&gt;createTextNode( "bar" );
              $t1-&gt;addChild( $t2 );       # is ok
              my $val = $t2-&gt;nodeValue(); # will fail, script dies

           Also <u>addChild()</u> will not check it the added node belongs to the same document as the node it will
           be added to. This could lead to inconsistent documents and in more worse cases even to memory
           violations, if one does not keep track of this issue.

           Although this sounds like a lot of trouble, <u>addChild()</u> is useful if a document is built from a
           stream, such as happens sometimes in SAX handlers or filters.

           If you are not sure about the source of your nodes, you better stay with <u>appendChild()</u>, because
           this function is more user friendly in the sense of being more error tolerant.

       <b>addNewChild</b>
             $node = $parent-&gt;addNewChild( $nsURI, $name );

           Similar to <u>addChild()</u>, this function uses low level libxml2 functionality to provide faster
           interface for DOM building. <u>addNewChild()</u> uses <u>xmlNewChild()</u> to create a new node on a given
           parent element.

           <u>addNewChild()</u> has two parameters $nsURI and $name, where $nsURI is an (optional) namespace URI.
           $name is the fully qualified element name; <u>addNewChild()</u> will determine the correct prefix if
           nessecary.

           The function returns the newly created node.

           This function is very useful for DOM building, where a created node can be directly associated
           with its parent. NOTE this function is not part of the DOM specification and its use will limit
           your code to XML::LibXML.

       <b>addSibling</b>
             $node-&gt;addSibling($newNode);

           <u>addSibling()</u> allows adding an additional node to the end of a nodelist, defined by the given
           node.

       <b>cloneNode</b>
             $newnode =$node-&gt;cloneNode( $deep );

           cloneNode creates a copy of $node. When $deep is set to 1 (true) the function will copy all
           childnodes as well. If $deep is 0 only the current node will be copied.

           cloneNode will not copy any namespace information if it is not run recursivly.

       <b>parentNode</b>
             $parentnode = $node-&gt;parentNode;

           Returns simply the Parent Node of the current node.

       <b>nextSibling</b>
             $nextnode = $node-&gt;nextSibling();

           Returns the next sibling if any .

       <b>previousSibling</b>
             $prevnode = $node-&gt;previousSibling();

           Analogous to getNextSibling the function returns the previous sibling if any.

       <b>hasChildNodes</b>
             $boolean = $node-&gt;hasChildNodes();

           If the current node has Childnodes this function returns TRUE (1), otherwise it returns FALSE (0,
           not undef).

       <b>firstChild</b>
             $childnode = $node-&gt;firstChild;

           If a node has childnodes this function will return the first node in the childlist.

       <b>lastChild</b>
             $childnode = $node-&gt;lastChild;

           If the $node has childnodes this function returns the last child node.

       <b>ownerDocument</b>
             $documentnode = $node-&gt;ownerDocument;

           Through this function it is always possible to access the document the current node is bound to.

       <b>getOwner</b>
             $node = $node-&gt;getOwner;

           This function returns the node the current node is associated with. In most cases this will be a
           document node or a document fragment node.

       <b>setOwnerDocument</b>
             $node-&gt;setOwnerDocument( $doc );

           This function binds a node to another DOM. This method unbinds the node first, if it is allready
           bound to another document.

           This function is the oposite calling of XML::LibXML::Document's <u>adoptNode()</u> function. Because of
           this it has the same limitations with Entity References as <u>adoptNode()</u>.

       <b>insertBefore</b>
             $node-&gt;insertBefore( $newNode, $refNode );

           The method inserts $newNode before $refNode. If $refNode is undefined, the newNode will be set as
           the new last child of the parent node. This function differs from the DOM L2 specification, in
           the case, if the new node is not part of the document, the node will be imported first,
           automatically.

           $refNode has to be passed to the function even if it is undefined:

              $node-&gt;insertBefore( $newNode, undef ); # the same as $node-&gt;appendChild( $newNode );
              $node-&gt;insertBefore( $newNode ); # wrong

           Note, that the reference node has to be a direct child of the node the function is called on.
           Also, $newChild is not allowed to be an ancestor of the new parent node.

       <b>insertAfter</b>
             $node-&gt;insertAfter( $newNode, $refNode );

           The method inserts $newNode after $refNode. If $refNode is undefined, the newNode will be set as
           the new last child of the parent node.

           Note, that $refNode has to be passed explicitly even if it is undef.

       <b>findnodes</b>
             @nodes = $node-&gt;findnodes( $xpath_statement );

           findnodes performs the xpath statement on the current node and returns the result as an array. In
           scalar context returns a XML::LibXML::NodeList object.

       <b>find</b>
             $result = $node-&gt;find( $xpath );

           find performs the xpath expression using the current node as the context of the expression, and
           returns the result depending on what type of result the XPath expression had. For example, the
           XPath "1 * 3 + 52" results in a XML::LibXML::Number object being returned. Other expressions
           might return a XML::LibXML::Boolean object, or a XML::LibXML::Literal object (a string). Each of
           those objects uses Perl's overload feature to "do the right thing" in different contexts.

       <b>findvalue</b>
             print $node-&gt;findvalue( $xpath );

           findvalue is exactly equivalent to:

              $node-&gt;find( $xpath )-&gt;to_literal;

           That is, it returns the literal value of the results. This enables you to ensure that you get a
           string back from your search, allowing certain shortcuts.  This could be used as the equivalent
           of XSLT's &lt;<a href="xsl:value-of select="some_xpath"/">xsl:value-of select="some_xpath"/</a>.

       <b>childNodes</b>
             @childnodes = $node-&gt;childNodes;

           getChildnodes implements a more intuitive interface to the childnodes of the current node. It
           enables you to pass all children directly to a map or grep. If this function is called in scalar
           context, a XML::LibXML::NodeList object will be returned.

       <b>toString</b>
             $xmlstring = $node-&gt;toString($format,$docencoding);

           This is the equivalent to XML::LibXML::Document::toString for a single node.  This means a node
           and all its childnodes will be dumped into the result string.

           Additionally to the $format flag of XML::LibXML::Document, this version accepts the optional
           $docencoding flag. If this flag is set this function returns the string in its original encoding
           (the encoding of the document) rather than UTF-8.

       <b>toStringC14N</b>
             $c14nstring = $node-&gt;toString($with_comments, $xpath_expression);

           The function is similar to <u>toString()</u>. Instead of simply serializing the document tree, it
           transforms it as it is specified in the XML-C14N Specification. Such transformation is known as
           canonization.

           If $with_comments is 0 or not defined, the result-document will not contain any comments that
           exist in the original document. To include comments into the canonized document, $with_comments
           has to be set to 1.

           The parameter $xpath_expression defines the nodeset of nodes that should be visible in the
           resulting document. This can be used to filter out some nodes.  One has to note, that only the
           nodes that are part of the nodeset, will be included into the result-document. Their child-nodes
           will not exist in the resulting document, unless they are part of the nodeset defined by the
           xpath expression.

           If $xpath_expression is ommitted or empty, <u>toStringC14N()</u> will include all nodes in the given
           sub-tree.

           No serializing flags will be recognized by this function!

       <b>serialize</b>
             $str = $doc-&gt;serialze($format);

           Alternative form of <u>toString()</u>. This function name added to be more conform with libxml2's
           examples.

       <b>serialize_c14n</b>
             $c14nstr = $doc-&gt;serialize_c14n($comment_flag,$xpath);

           Alternative form of <u>toStringC14N()</u>.

       <b>localname</b>
             $localname = $node-&gt;localname;

           Returns the local name of a tag. This is the part behind the colon.

       <b>prefix</b>
             $nameprefix = $node-&gt;prefix;

           Returns the prefix of a tag. This is the part before the colon.

       <b>namespaceURI</b>
             $uri = $node-&gt;namespaceURI();

           returns the URI of the current namespace.

       <b>hasAttributes</b>
             $boolean = $node-&gt;hasAttributes();

           returns 1 (TRUE) if the current node has any attributes set, otherwise 0 (FALSE) is returned.

       <b>attributes</b>
             @attributelist = $node-&gt;attributes();

           This function returns all attributes and namespace declarations assigned to the given node.

           Because XML::LibXML does not implement namespace declarations and attributes the same way, it is
           required to test what kind of node is handled while accessing the functions result.

           If this function is called in array context the attribute nodes are returned as an array. In
           scalar context the function will return a XML::LibXML::NamedNodeMap object.

       <b>lookupNamespaceURI</b>
             $URI = $node-&gt;lookupNamespaceURI( $prefix );

           Find a namespace URI by its prefix starting at the current node.

       <b>lookupNamespacePrefix</b>
             $prefix = $node-&gt;lookupNamespacePrefix( $URI );

           Find a namespace prefix by its URI starting at the current node.

           NOTE Only the namespace URIs are meant to be unique. The prefix is only document related. Also
           the document might have more than a single prefix defined for a namespace.

       <b>iterator</b>
             $iter = $node-&gt;iterator;

           This function is deprecated since XML::LibXML 1.54. It is only a dummy function that will get
           removed entirely in one of the next versions.

           To make use of iterator functions use XML::LibXML::Iterator Module available on CPAN.

       <b>normalize</b>
             $node-&gt;normalize;

           This function normalizes adjacent textnodes. This function is not as strict as libxml2's
           <u>xmlTextMerge()</u> function, since it will not free a node that is still referenced by the perl
           layer.

       <b>getNamespaces</b>
             @nslist = $node-&gt;getNamespaces;

           If a node has any namespaces defined, this function will return these namespaces. Note, that this
           will not return all namespaces that are in scope, but only the ones declared explicitly for that
           node.

           Although getNamespaces is available for all nodes, it only makes sense if used with element
           nodes.

       <b>removeChildNodes</b>
             $node-&gt;removeChildNodes();

           This function is not specified for any DOM level: It removes all childnodes from a node in a
           single step. Other than the libxml2 function itself (xmlFreeNodeList), this function will not
           immediately remove the nodes from the memory. This saves one from getting memory violations, if
           there are nodes still referred to from the Perl level.

       <b>nodePath</b>
             $node-&gt;nodePath();

           This function is not specified for any DOM level: It returns a cannonical structure based XPath
           for a given node.

       <b>line_number</b>
             $lineno = $node-&gt;line_number();

           This function returns the line number where the tag was found during parsing.  If a node is added
           to the document the line number is 0. Problems may occour, if a node from one document is passed
           to another one.

           Note: <u>line</u><b>_</b><u>number()</u> is special to XML::LibXML and not part of the DOM specification.

           If the line_numbers flag of the parser was not activated before parsing, <u>line</u><b>_</b><u>number()</u> will
           always return 0.

<b>AUTHORS</b>
       Matt Sergeant, Christian Glahn, Petr Pajas,

<b>VERSION</b>
       1.60

<b>COPYRIGHT</b>
       2001-2006, AxKit.com Ltd; 2002-2006 Christian Glahn; 2006 Petr Pajas, All rights reserved.



perl v5.8.8                                      2006-08-26                             XML::LibXML::Node(3)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/XML__LibXML__Node.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/XML__LibXML__Node.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/XML__LibXML__Node.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
