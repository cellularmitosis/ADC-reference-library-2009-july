<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Spinning the Cursor (IM: Pr)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING85></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Processes-84.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Processes-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Processes-171.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Processes-86.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html"><B>Inside Macintosh:</B></A> <A HREF="Processes-2.html"><B>Processes</B></A><BR><DD><A HREF="Processes-74.html"><B>Chapter 4 - Vertical Retrace Manager</B></A> / <A HREF="Processes-81.html"><B>Using the Vertical Retrace Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING85-0></A>
<H2><A NAME=MARKER-9-115></A>Spinning the Cursor<A NAME=MARKER-2-41></A></H2>
 <A NAME=MARKER-2-117></A>Some VBL tasks need access only to global variables that they do not share with the main program. For example, you might wish to design a VBL task that animates the beachball or watch cursor to indicate that the user must wait while the computer finishes some lengthy processing. The main application might use the application-defined procedures <CODE>StartSpinning</CODE> and <CODE>StopSpinning</CODE> to install and remove the VBL task, but the application might not need to know, for example, which beachball or watch cursor the VBL task is displaying at any given time. The VBL task itself would need to know this information, because it must know which cursor to display when it is time to change the cursor.<P>
 One way to implement such a VBL task is to use application global variables and set up the A5 register properly, as described in the previous section, <A HREF=Processes-84.html#MARKER-9-98>"Accessing Application Global Variables in a VBL Task."</A> An alternate method, however, is simply to store the information that the VBL task needs directly after the task record in memory, just as you can store information about the program's A5 value there. Then, because the VBL task has access to all of the information it needs, it does not need to set up and restore the A5 register.<A NAME=MARKER-2-114></A><P>
 The listings that follow use that strategy to implement cursor spinning. This cursor spinning task implements simple animation of any number of cursor frames stored in contiguous resources in the program's resource fork.<P>
 <A HREF=#MARKER-9-119>Listing 4-11</A> provides a type definition for a cursor information record. This record holds the task record and information specific to cursor spinning. <A HREF=#MARKER-9-119>Listing 4-11</A> also defines several constants and a global variable to hold a cursor information record.<P>
<B>Listing 4-11  <A NAME=MARKER-9-119></A>Defining a cursor information record</B><P>
<PRE>
CONST
   kInterval = 4;                   {frequency in interrupts}
   kNumberOfCursors = 4;            {total number of frames}
   kInitialResID = 128;             {ID of first cursor resource}
TYPE
   CursorsList = ARRAY[1..kNumberOfCursors] OF CursHandle;
   CursorTask = 
      RECORD
         myVBLTask:  VBLTask;       {the actual VBLTask}
         myCursors:  CursorsList;   {handles to the cursors}
         myFrame:    Integer;       {cursor frame to display next}
      END;
   CursorTaskPtr = ^CursorTask;
VAR
   gMyCursTask:   CursorTask;       {global cursor info. record}
</PRE>
 <A HREF=#MARKER-9-120>Listing 4-12</A> shows the VBL task itself. The task changes the cursor and resets the task record's <CODE>vblCount</CODE> field so that the Vertical Retrace Manager executes the task again.<P>
<B>Listing 4-12  <A NAME=MARKER-9-120></A>Changing the cursor within a VBL task</B><P>
<PRE>
PROCEDURE ChangeCursor;
TYPE
   BooleanPtr = ^Boolean;                    {to check a low-memory global}
VAR
   recPtr:  CursorTaskPtr;
BEGIN
   recPtr := CursorTaskPtr(GetVBLRec);       {get cursor information}
   {If the cursor is busy, we should not change it.}
   IF NOT BooleanPtr(CrsrBusy)^ THEN
      WITH recPtr^ DO                        {update cursor information}
      BEGIN
         SetCursor(myCursors[myFrame]^^);    {display the next cursor}
         myFrame := myFrame + 1;             {advance to next cursor frame}
         IF myFrame &gt; kNumberOfCursors THEN
            myFrame := 1;                    {wrap around to first frame}
      END;     
   recPtr^.myVBLTask.vblCount := kInterval;  {set task to run again}
END;
</PRE>
 The <CODE>ChangeCursor</CODE> procedure retrieves the address of the VBL task record. If the cursor isn't already being changed, then <CODE>ChangeCursor</CODE> changes the cursor to the next one in sequence and resets the index of the next cursor to display. Finally, <CODE>ChangeCursor</CODE> sets itself to run again after the appropriate number of interrupts have occurred.<P>
<DL>
<DT><B>Note</B>
<DD>It is permissible to call <CODE>SetCursor</CODE> at interrupt time, provided that the cursor handle is locked and that some other routine is not currently modifying the cursor. The system global variable <CODE>CrsrBusy</CODE> has the value <CODE>TRUE</CODE> if the cursor is busy; in that case, you should not call <CODE>SetCursor</CODE>. <A HREF=#MARKER-9-120>Listing 4-12</A> illustrates the proper way to change the cursor at interrupt time.<B></B><A NAME=MARKER-2-121></A><A NAME=MARKER-2-122></A>  <B>&#183;</B>
</DL>
 <A HREF=#MARKER-9-123>Listing 4-13</A> defines the procedure <CODE>StartSpinning</CODE>, which you can call before beginning some lengthy operation. Because VBL tasks cannot depend on the validity of unlocked handles, the <CODE>StartSpinning</CODE> procedure must lock the cursor handles in memory before <CODE>SetCursor</CODE> is called in the <CODE>ChangeCursor</CODE> procedure.<P>
<B>Listing 4-13  <A NAME=MARKER-9-123></A>Installing the cursor-spinning task into a vertical retrace queue</B><P>
<PRE>
PROCEDURE StartSpinning;
CONST
   kInitialDelay = 120;          {initial delay before starting to spin}
VAR
   myErr:   OSErr;
   count:   Integer;
BEGIN
   {Initialize cursor information.}
   FOR count := 1 TO kNumberOfCursors DO
   BEGIN
      {Load cursor into memory.}
      gMyCursTask.myCursors[count] := GetCursor(kInitialResID + count - 1);
      {Lock cursor so that we can call SetCursor at interrupt time.}
      HLockHi(Handle(gMyCursTask.myCursors[count]));
   END;
   gMyCursTask.myFrame := 1;     {display cursor with kInitialResID first}

   WITH gMyCursTask.myVBLTask DO {initialize the VBL task record}
   BEGIN
      qType := ORD(vType);       {set queue type}
      vblAddr := @ChangeCursor;  {get address of VBL task}
      vblCount := kInitialDelay; {set task frequency}
      vblPhase := 0;             {no phase}
   END;

   myErr := VInstall(@gMyCursTask.myVBLTask);
END;
</PRE>
 Notice that the initial delay (specified by the <CODE>kInitialDelay</CODE> constant in the <CODE>vblCount</CODE> field) is much larger than the number of interrupts between subsequent cursor changes (specified by the <CODE>kInterval</CODE> constant). This prevents the cursor from starting to spin until a reasonable time (about 2 seconds) has elapsed.<P>
 <A HREF=#MARKER-9-124>Listing 4-14</A> shows how to remove the cursor-spinning task from the vertical retrace queue.<P>
<B>Listing 4-14  <A NAME=MARKER-9-124></A>Removing the cursor-spinning task from its vertical retrace queue</B><P>
<PRE>
PROCEDURE StopSpinning;
VAR
   myErr:   OSErr;
   count:   Integer;
BEGIN
   {Remove the task record from its queue.}
   myErr := VRemove(@gMyCursTask.myVBLTask);

   {Free memory occupied by the cursors.}
   FOR count := 1 TO kNumberOfCursors DO
      ReleaseResource(Handle(gMyCursTask.myCursors[count]));

   InitCursor;                         {restore the arrow cursor}
END;
</PRE>
 Depending on the needs of your application, you might want to load the cursors into memory at application-launch time and release them when your application quits. If so, you need to modify the <CODE>StartSpinning</CODE> and <CODE>StopSpinning</CODE> procedures accordingly.<A NAME=MARKER-2-62></A><A NAME=MARKER-2-126></A><P>
</BLOCKQUOTE><P>
<HR>
<center>
<A HREF="Processes-84.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Processes-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Processes-171.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Processes-86.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Processes-3.html">&copy; Apple Computer, Inc.</A><br>17 JUN 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
