<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><html><head><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note TE27: Inline Input for TextEdit with TSMTE</title><meta name="categories" content="Text"><meta name="week-posted" content="Nov 29, 1993 - Dec 3, 1993"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002835" title="Inline Input for TextEdit with TSMTE"></a><a name="top"></A><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxTextFonts-date.html">Text & Fonts</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/TextFonts/index.html" target="_blank">Reference Library > Text & Fonts</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TE27</div>
<div id="pageheadsub">Inline Input for TextEdit with TSMTE</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->										<p id="menutext"><A HREF="#Section1">Introduction</A><BR><BR><A HREF="#Section2">TSMTE Overview</A><BR><BR><A HREF="#Section3">Preparing to Use TSMTE</A><BR><BR><A HREF="#Section4">Using TSMTE for Modal Dialogs</A><BR><BR><A HREF="#Section5">Using TSMTE for Document Windows and for <BR>Modeless Dialogs</A><BR><BR><A HREF="#Section6">Using TSMTE and TextEdit in Addition to <BR>Your Own Text Engine</A><BR><BR><A HREF="#Section7">More Inline Input Advice</A><BR><BR><A HREF="#Section8">Pascal Summary</A><BR><BR><A HREF="#Section9">C Summary</A><BR><BR><A HREF="#References">References</A><BR><BR><A HREF="#Changes">Change History</A><BR><BR><A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><P id = "introtext">This Technical Note describes TSMTE, an extension that simplifiesimplementation of inline input for TextEdit using the Text Services Manager inSystem 7.1 and later, and shows you how to make the best use of it. It alsocontains some advice for working with the Text Services Manager that applies toany application using TSM, not just those using TSMTE.</p><!-- end_intro_text --><!-- begin_date --><h3 align=center>[Dec 01 1993]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR>          <!-- begin_content --><a name=Section1></A><h2>Introduction</h2><p>System 7.1 introduced a new Toolbox manager, the Text Services Manager, thatmakes it easier for applications to provide inline input for 2-byte scriptsystems (see <a href="../../documentation/mac/Text/Text-409.html"><i>Inside Macintosh: Text</i></A>, pages 7-6 to 7-12, for anoverview). To implement inline input using the Text Services Manager, anapplication has to do two things: make some calls to the Text Services Managerin the right places, and provide Apple event handlers that respond to eventsfrom input methods by updating text data structures, displaying text, andtranslating text offsets and screen coordinates. The first part is easy (maybe50-100 lines of code), the second part can, depending on the complexity of thetext engine that you use, require substantial work (several hundred tothousands of lines of code).</p><p>TSMTE is an extension to the Text Services Manager that does the second part ofthe work for you if you use TextEdit. It provides Apple event handlers thathandle all interactions between an input method and TextEdit. The handlers arekept in the system heap, so they are shared between all applications.</p><p>TSMTE thus can reduce the effort needed to implement inline input to a day ortwo. If you use TextEdit in documents or modeless dialogs, you have to make afew calls to TSMTE in exchange for its help; if you use TextEdit only in modaldialogs, you only have to modify the <code>DLOG</code> resources that define them.</p><p>If you use a text engine other than TextEdit for editing in your application,you can still use TSMTE to handle inline input wherever you use TextEdit, e.g.,in dialogs.</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>KanjiTalk 6.0.7 had an extension that provided fully automaticsupport for inline input with TextEdit without any kind of modification toapplications. With TSMTE, inline input is not quite so automatic - you have tomake the necessary calls to TSMTE and the Text Services Manager to make itwork.</P></TD></TR></TABLE></CENTER><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR><a href="../../documentation/mac/Text/Text-120.html#HEADING120-0"><I>Inside Macintosh: Text</I></A>, pages 2-107 to 2-109, discusses two featurebits, <code>teFUseTextServices</code> and <code>teFInlineInput</code>. <code>TeFUseTextServices</code> doesn't haveany impact on the Text Services Manager or TSMTE, so you can safely ignore it.<code>TeFInlineInput</code> is handled by TSMTE, so there is no need for you to touch it.</P></TD></TR></TABLE></CENTER><BR><P><A HREF="#top">Back to top</A></p><a name="Section2"></a><h2>TSMTE Overview</h2><h3>Availability</h3><p>Currently, TSMTE is delivered as a system extension called "Inline TuikaKinou", which is shown here:</p><p align=center><img src="images/te_27_001.gif" alt="Inline Tuika Kinou extension file" width=128 height=45></p><p align=center><b>Figure 1</b>. Inline Tuika Kinou extension file</p><p>If you look for this file while running system software in some language usingthe Roman script system, the name of the extension file will be displayed as"&Eacute;C&Eacute;&igrave;&Eacute;&acirc;&Eacute;C&Eacute;&igrave;&iacute;&lt;&lt;&acirc;&#161;&atilde;@&icirc;\".</p><p>The extension is part of the Japanese version of System 7.1, KanjiTalk 7. It isnot part of the Japanese Language Kit or of any other version of System 7.1.This means that if you use TSMTE to implement inline input, it will currentlyonly benefit users of Japanese system software. However, TSMTE may get rolledinto a future version of the base system software, so that it would then beavailable for use with any 2-byte script system on any Macintosh worldwide.Your application should therefore use Gestalt to check for the presence ofTSMTE and use it whenever it is available.</p><p>For development purposes, if you don't feel comfortable using Japanese systemsoftware, you can install the Japanese Language Kit and the Inline Tuika Kinouextension into system software in any language that you like. Apple does notexactly guarantee that these configurations will work, but our experience sofar has been good. Final testing should of course be done on a real Japanesesystem. In order to get your application to use a Japanese font in dialogs orin documents where you don't allow the user to select a font, you have toregister your application as Japanese using the Language Register applicationthat comes with the Japanese Language Kit.</p><h3>Limitations</h3><p>You may find that with some fonts TSMTE truncates the lower portion ofcharacters drawn in the input area because it reserves a two-pixel high areafor underlining. This problem will be fixed in a future release.</p><h3>Prerequisites</h3><p>To use the Text Services Manager and TSMTE, your application has to supportApple events. At a minimum, it has to install at least one Apple event handlerusing <code>AEInstallEventHandler</code>. Usually of course you would install handlers forthe four required event types, and set the <code>isHighLevelEventAware</code> bit in theSIZE -1 resource.</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The SIZE resource also has a <code>useTextEditServices</code> bit. Contrary tothe comments in Types.r and in <i>Inside Macintosh: Text</i>, this bit doesn'thave any influence on inline input done with the Text Services Manager andTSMTE. It was used by the extension that provided inline input for TextEdit inKanjiTalk 6.0.7.</P></TD></TR></TABLE></CENTER><BR><P><A HREF="#top">Back to top</A></p><a name="Section3"></a><h2>Preparing to Use TSMTE</h2><p>Starting from this section, we assume that you have a good understanding of thehigh-level routines of the Text Services Manager. You can find the necessaryinformation in <a href="../../documentation/mac/Text/Text-412.html#HEADING412-0"><i>Inside Macintosh: Text</i></A>, pages 7-17 to 7-24. Please makesure to read the section "More Inline Input Advice" at the end of thisTechnical Note for additional hints on how to successfully use the TextServices Manager and input methods.</p><h3>Defining the Level of Functionality You Need</h3><p>Your application can provide several different kinds of text editingfunctionality, and your usage of TSMTE and the Text Services Manager depends onwhich one you offer. Your application may support text input:</p><ol><li>in modal dialogs (which use TextEdit)</li><li>in document windows using TextEdit and in modeless dialogs</li><li>in windows using your own text engine</li></ol><P>plus in any combination thereof.</p><P>The rest of this section discusses the steps you have to take to prepare yourapplication to use TSMTE in any possible context. The following sections thenlook at the individual cases.</p><h3>Testing for TSMTE</h3><p>Before making calls for TSMTE, you have to check for its presence usingGestalt. The selector for TSMTE is <code>gestaltTSMTEAttr</code>, and you know that it isavailable if the <code>gestaltTSMTEPresent</code> bit in the response is set.</p><p>The following code initializes separate Boolean variables to indicate thepresence of the Text Services Manager and TSMTE. Having separate variables isuseful if you use your own text engine in addition to TextEdit and want tosupport inline input for that engine even if TSMTE is not present.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>static void CheckForTextServices(void){    long gestaltResponse;    gHasTextServices = false;        // unless proven otherwise    gHasTSMTE = false;            // unless proven otherwise    if (TrapAvailable(_Gestalt))    {        if ((Gestalt(gestaltTSMgrVersion, &amp;gestaltResponse) == noErr) &amp;&amp;             (gestaltResponse &gt;= 1))        {            gHasTextServices = true;            if (Gestalt(gestaltTSMTEAttr, &amp;gestaltResponse) == noErr)                gHasTSMTE = BTst(gestaltResponse, gestaltTSMTEPresent);        };    };}</pre>	</TD></TR></TABLE></CENTER><h3>Initializing and Closing the Text Services Manager</h3><p>To enable inline input, you have to initialize the Text Services Manager bycalling <code>InitTSMAwareApplication</code> in your initialization sequence, and close itbefore quitting by calling <code>CloseTSMAwareApplication</code>. But what if TSMTE is notavailable? Then you have to make the floating input window available to theuser for entering text in a 2-byte script into a TextEdit field. How to do thisdepends on whether you use your own text engine in addition to TextEdit (weassume that your own text engine supports inline input - otherwise you probablywould not think about adding inline input support to TextEdit).</p><p>If you only use TextEdit in your application, you simply call<code>InitTSMAwareApplication</code> only if TSMTE is available. If you don't call<code>InitTSMAwareApplication</code>, system software will automatically handle input in2-byte scripts for your application in a floating input window. The followingcode performs the initialization and also shows how to move on without textservices if <code>InitTSMAwareApplication</code> fails:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>if (!(gHasTSMTE &amp;&amp; InitTSMAwareApplication() == noErr)){    // if this happens, just move on without text services    gHasTextServices = false;    gHasTSMTE = false;</pre>	</TD></TR></TABLE></CENTER><p>If you use your own text engine in addition to TextEdit and support inlineinput for it, you want to use inline input for your engine even if TSMTE is notavailable. To do this, you simply check <code>gHasTextServices</code> instead of <code>gHasTSMTE</code>in the first line of the code above. Later, you also have to make sure that youtell the Text Services Manager to use the floating input window whenever aTextEdit field is active - the section "Using TSMTE and TextEdit in Addition toYour Own Text Engine" discusses this in detail.</p><p>In either case, you have to call <code>CloseTSMAwareApplication</code> before quitting anapplication for which you successfully called <code>InitTSMAwareApplication</code>:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>if (gHasTextServices)    (void) CloseTSMAwareApplication();</pre>	</TD></TR></TABLE></CENTER><BR><P><A HREF="#top">Back to top</A></p><a name="Section4"></a><h2>Using TSMTE for Modal Dialogs</h2><p>Once you have initialized the Text Services Manager, TSMTE offers a very easyway to handle inline input for modal dialogs: you set the <code>refCon</code> field in the<code>DLOG</code> resource to <code>kTSMTEDialog</code> or <code>kTSMTEInterfaceType</code>, TSMTE handles the rest.Or, if circumstances force you to create a dialog programmatically, you canpass <code>kTSMTEInterfaceType</code> as the <code>refCon</code> argument to <code>NewDialog</code> or <code>NewCDialog</code>(these routines do not accept <code>kTSMTEDialog</code>). Either way, TSMTE willautomatically create a <code>TSMDocument</code> for you, activate and deactivate the<code>TSMDocument</code>, and enable inline input for the dialog. When you call <code>CloseDialog</code>or <code>DisposeDialog</code>, TSMTE disposes of the <code>TSMDocument</code> it created, activates the<code>TSMDocument</code> that was active before opening the dialog (if there was one), andresets the Text Services Manager flag that determines whether to use thefloating input window to its previous state.</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>If you use this feature, you can still use the <code>refCon</code> field foryour own purposes after creating the dialog - TSMTE doesn't need it any longer.</P></TD></TR></TABLE></CENTER><BR><p>The difference between the two constants is that <code>kTSMTEInterfaceType</code> tellsTSMTE to use an extended dialog record, <code>TSMDialogRecord</code>, while <code>kTSMTEDialog</code>uses the standard dialog record. Using the extended dialog record lets youaccess the information that TSMTE uses if you need it; without it, theinformation is stored in TSMTE's private data structures. If you use<code>kTSMTEInterfaceType</code> but don't provide storage for the dialog record, the DialogManager routines will automatically allocate an extended record.</p><P>If you use <code>kTSMTEInterfaceType</code> and allocate your own storage or add your ownfields to the dialog record, you have to take the additional 20 bytes of theextended dialog record into account. If you add your own fields, it's a goodidea to also allocate your own storage. This way you can always include thefields for TSMTE, otherwise the location of your fields in the record dependson whether TSMTE is installed or not.</p><P>If you provide an event filter function for <code>ModalDialog</code>, TSMTE gives you thechoice whether you want to handle Text Services Manager calls or whether TSMTEshould do it. To determine whether the function handles the calls, TSMTE callsit with a null event. If the function calls <code>TSMEvent</code>, TSMTE assumes that thefunction makes all the necessary calls to the Text Services Manager. If itdoesn't, or if there is no event filter function, TSMTE makes all the necessarycalls itself.</p><P>While using inline input, <code>ModalDialog</code> doesn't return because it doesn't get tosee any "real" events. If you have a dialog that opens with a disabled actionbutton and waits for the user to type text into an editable text item beforeenabling the button, checking the editable text item only after <code>ModalDialog</code>returns does not have the desired effect - if the user uses inline input toenter text, the button doesn't get enabled. A solution for this is to use anevent filter function that checks the text in the editable text item andenables the button if the text length is above zero. The event filter functionis guaranteed to be called with a null event whenever <code>TSMEvent</code> consumes a<code>keyDown</code> event.</p><P><A HREF="#top">Back to top</A></p><a name="Section5"></a><h2>Using TSMTE for Document Windows and for Modeless Dialogs</h2><p>If you use TextEdit to edit text in document windows or if you use modelessdialogs, some more work is shifted over to you: now it becomes yourresponsibility to call the high-level Text Services Manager routines. You'llhave to add calls to:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>NewTSMDocumentDeleteTSMDocumentActivateTSMDocumentDeactivateTSMDocumentTSMEventTSMMenuSelectSetTSMCursor</pre>	</TD></TR></TABLE></CENTER><p>Before making the Text Services Manager calls, you have to make sure that theirpreconditions are met. You only want to create a TSM document for a TextEdittext record if TSMTE is available. You only want to delete, activate, ordeactivate, or confirm ("fix") a TSM document if creating it was successful.The remaining routines depend on the Text Services Manager being available, butnot necessarily on TSMTE - you may be using your own text engine with inlineinput in addition to TextEdit. The variables <code>gHasTextServices</code> and <code>gHasTSMTE</code>introduced above can help you make the necessary decisions. For example, yourmenu handling code might look like this:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>menuResult = MenuSelect(event-&gt;where);if (!(gHasTextServices &amp;&amp; TSMMenuSelect(menuResult)))    DoMenuCommand(menuResult);</pre>	</TD></TR></TABLE></CENTER><p>The usage of Text Services Manager routines is documented in <i>InsideMacintosh: Text</i>, so we'll discuss only how TSMTE extends the Text ServicesManager interface.</p><h3>Creating a TSM Document</h3><p>When creating a TSMDocument for a TextEdit text record, you have to use aspecial interface type <code>kTSMTEInterfaceType</code> to indicate that TSMTE should handleApple events for this TSM document.</p><p>If you pass <code>kTSMTEInterfaceType</code> to NewTSMDocument, the <code>refCon</code> argument takes ona different meaning. Instead of a value to be stored in the TSM document, youshould pass in the address of a variable of type <code>TSMTERecHandle</code>. TSMTEallocates a data structure of type <code>TSMTERec</code> and assigns a handle to it to yourvariable. This data structure contains several fields that you can use totailor TSMTE's behavior to the needs of your application. It is yourapplication's responsibility to initialize the record.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>struct TSMTERec {    TEHandle             textH;    TSMTEPreUpdateUPP    preUpdateProc;    TSMTEPostUpdateUPP   postUpdateProc;    long                 updateFlag;    long                 refCon;</pre>	</TD></TR></TABLE></CENTER><P>The <code>textH</code> field has to be set to the text record handle that this TSM documentrelates to.</P><p>In <code>preUpdateProc</code> and <code>postUpdateProc</code> you can specify call-back routines thatTSMTE should call before and after its own code when handling the Update ActiveInput Area event (one of the Apple events that is sent by the input method).The interfaces and possible uses for both routines are described below. If youdon't have routines that TSMTE should call, set the fields to nil.</p><p>The <code>updateFlag</code> field is intended for customization of TSMTE's behavior. Theidea is that TSMTE can define several constants for variations in itsbehaviors, and you sum up the constants for the variations that you like andassign them to the <code>updateFlag</code> field. Currently, only one such constant,<code>kTSMTEAutoScroll</code>, is defined. It specifies that TSMTE automatically scrolls theselection range into view. If you set <code>updateFlag</code> to 0, automatic scrolling isdisabled, and you have to scroll the text yourself, e.g., in one of thecall-back routines.</p><p>The <code>refCon</code> field lets you specify a value that TSMTE will pass on to thecall-back routines. TSMTE doesn't make any other use of this field.</p><p>Here is some sample code for creating a <code>TSMDocument</code>. It assumes that you havejust created a <code>TEHandle</code> called <code>docTEHandle</code>, and that a Boolean variable good isused to indicate whether operations are successful, and that you want to pass apointer to the document window to your call-back routine.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>if (good &amp;&amp; gHasTSMTE){    supportedInterfaces[0] = kTSMTEInterfaceType;    if (NewTSMDocument(1, supportedInterfaces, &amp;doc-&gt;docTSMDoc,                (long) &amp;doc-&gt;docTSMTERecHandle) == noErr)    {        TSMTERecPtr tsmteRecPtr = *(doc-&gt;docTSMTERecHandle);        tsmteRecPtr-&gt;textH = doc-&gt;docTE;        tsmteRecPtr-&gt;preUpdateProc = gTSMTEPreUpdateUPP;        tsmteRecPtr-&gt;postUpdateProc = gTSMTEPostUpdateUPP;        tsmteRecPtr-&gt;updateFlag = kTSMTEAutoScroll;        tsmteRecPtr-&gt;refCon = (long) window;    }    else        good = false;</pre>	</TD></TR></TABLE></CENTER><p>You shouldn't dispose of the <code>TSMTERecHandle</code> - <code>DeleteTSMDocument</code> will do thisfor you.</p><h3>Using a Pre-Update Call-Back Routine</h3><p>Pre-update call-back routines for TSMTE have the following interface:</p><p>If you provide a pre-update routine for a TSM document, it is called beforeTSMTE's code for handling the Update Active Input Area events relating to thisdocument.</p><p>The values for the textH and <code>refCon</code> arguments are taken from the <code>TSMTERecHandle</code>of the TSM document.</p><p>One common use of the pre-update routine is to save information that will beneeded for Undo and Redo. Without inline input, an application typically treatsan uninterrupted sequence of <code>keyDown</code> events (other than arrow or function keys)as one action, and saves the currently selected text and related informationwhen receiving the first event in this sequence. In this regard, you shouldtreat a call to your pre-update routine as just another form of typing, and ifit's the first one in a typing sequence, save the information for Undo.</p><p>Another use is to work around a bug in TSMTE 1.0, which doesn't alwayssynchronize the font to be used with the current keyboard script. The followingroutine checks whether the current font can display the incoming characters,and if not, sets the font to the keyboard script's application font. A bettersolution would be to scan the text backwards for the most recently used font ofthe keyboard script. This solution will be used by future versions of TSMTE, somake sure to check the TSMTE version and use the workaround only for TSMTE 1.0,as shown below. The synchronization is only necessary when a new active inputarea is created, so you may want to use the post-update routine to trackwhether there is an active input area and only execute the font synchronizationcode when the pre-update routine is called while there's no active inputarea.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>static pascal void MyTSMTEPreUpdateProc(TEHandle textH, long refCon){    long response;    ScriptCode keyboardScript;    short mode;    TextStyle theStyle;    if ((Gestalt(gestaltTSMTEVersion, &amp;response) == noErr) &amp;&amp;         (response == gestaltTSMTE1))    {        keyboardScript = GetScriptManagerVariable(smKeyScript);        mode = doFont;        if (!(TEContinuousStyle(&amp;mode, &amp;theStyle, textH) &amp;&amp;                FontToScript(theStyle.tsFont) == keyboardScript))        {            theStyle.tsFont = GetScriptVariable(keyboardScript, smScriptAppFond);            TESetStyle(doFont, &amp;theStyle, false, textH);        };    };</pre>	</TD></TR></TABLE></CENTER><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Depending on which interface files you use, you may have to usethe old name <code>GetEnvirons</code> instead of the new <code>GetScriptManagerVariable</code>, becausethere's no correct declaration for the new name. The universal interfaces havea correct declaration.</P></TD></TR></TABLE></CENTER><BR><P>If your application occasionally changes the origin of the TextEdit record's<code>grafPort</code>, you can also use the pre-update routine to reset the origin so thatcharacters get drawn in the right location.</P><h3>Using a Post-Update Call-Back Routine</h3><p>Post-update call-back routines for TSMTE have the following interface:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal void MyTSMTEPostUpdateProc(TEHandle textH, long fixLen,            long inputAreaStart, long inputAreaEnd,</pre>	</TD></TR></TABLE></CENTER><p>If you provide a post-update routine for a TSM document, it is called afterTSMTE's code for handling Update Active Input Area events relating to thisdocument. If you have set the <code>updateFlag</code> field in the <code>TSMTERec</code> record to<code>kTSMTEAutoScroll</code>, TSMTE calls the call-back routine first, and then scrolls theselection range into view.</p><p>The values for the <code>textH</code> and <code>refCon</code> arguments are taken from the <code>TSMTERecHandle</code>of the TSM document. <code>InputAreaStart</code> and <code>inputAreaEnd</code> are the offsets of thestart and end of the active input area relative to the entire text handle; theyare both set to -1 if there is no active input area. The remaining parametersare a subset of the parameters for the Update Active Input Area event. The<code>fixLen</code> parameter is the length of the confirmed text. <code>PinStart</code> and <code>pinEnd</code> arethe offsets of the start and end of the text range that should be in view.</p><p>Common uses of the post-update routine are:</p><ul><li>adjusting scroll bars or input field widths to the width and height of thetext, which may have changed during editing,</li><li>setting a "modified" flag for the document,</li><li>saving information about the text being entered for Undo and Redo,</li><li>keeping track of whether there's an active input area.</li></ul><h3>Calling FixTSMDocument</h3><p>The <code>FixTSMDocument</code> routine should be called whenever the user switches fromtyping to a different kind of activity that operates on the text, e.g.,initiating an editing command from the menu or selecting text. It should not becalled for actions that would not be considered interrupting a typing sequence,e.g., resizing or scrolling the window. There are some actions in between forwhich we don't have clear guidelines yet; in these cases use your bestjudgment.</p><p>TSMTE will in some cases detect that <code>FixTSMDocument</code> needs to be called and doit for you, e.g., when the user clicks into a part of the document outside theinput area. In most cases however it is your responsibility to call<code>FixTSMDocument</code> when appropriate: when the user selects an editing command fromthe menu, closes a document, saves or prints it.</p><BR><P><A HREF="#top">Back to top</A></p><a name="Section6"></a><h2>Using TSMTE and TextEdit in Addition to Your Own Text Engine</h2><p>If you use your own text engine in addition to TextEdit, you will have toprovide your own Apple event handlers for the Text Services Apple events toimplement inline input for your engine. However, you can still use TSMTE toprovide inline input wherever you use TextEdit in your application.</p><p>Your Apple event handlers don't need to worry about TextEdit at all. TSMTEinstalls its event handlers in the system heap, so you can install yourhandlers in the application heap. The supported interface type that you specifywhen you create a TSM document is used to arbitrate between the handlers: forTSM documents that were created with <code>kTSMTEInterfaceType</code>, the TSMTE handlersare called, for those that  were created with kTextService, your handlers.</p><p>The only thing you have to worry about is what to do if the Text ServicesManager is available, but not TSMTE, so that you can provide inline input foryour engine, but not for TextEdit. In this case you want to make sure thatinline input is used whenever your engine is active, but that a floating inputwindow is made available whenever a TextEdit field is active (without thefloating input window users would not be able to type anything meaningful in a2-byte script). You can do this by calling <code>UseInputWindow</code> whenever you activateor deactivate a TextEdit record - here is sample code for activation:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>if (doc-&gt;docTSMDoc != nil)    CheckError(ActivateTSMDocument(doc-&gt;docTSMDoc));else</pre>	</TD></TR></TABLE></CENTER><BR>    <P><A HREF="#top">Back to top</A></p><a name="Section7"></a><h2>More Inline Input Advice</h2><p>This section contains some information that is not specific to TSMTE, butapplies to all applications that use the Text Services Manager in any form. Itshows workarounds for some unexpected features (we won't use entomologicalterminology here...) in the Text Services Manager and first-generation inputmethods written for it. Some of those unexpected features are expected to be orhave already been discontinued in newer versions.</p><h3>Incorrect Declaration in TextServices.p</h3><p>The Text Services interface file TextServices.p that is currently distributedon E.T.O. 12 and the November 1993 Developer CD contains an incorrectdeclaration for <code>NewTSMDocument</code>. The declaration should read:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>Function NewTSMDocument(numOfInterface: Integer;        VAR supportedInterfaceTypes: InterfaceTypeList;        VAR idocID: TSMDocumentID;        refCon: Longint): OSErr;</pre>	</TD></TR></TABLE></CENTER><p>Without the keyword "var" in front of "<code>supportedInterfaceTypes</code>", yourapplication will encounter a bus error in <code>NewTSMDocument</code>. So, go in and add thekeyword "var" if it's not there.</p><p>The declaration for <code>NewTSMDocument</code> in TextServices.h is correct.</p><h3>DeleteTSMDocument Uses Disposed Handle</h3><p>If a <code>TSMDocument</code> is deleted without being deactivated first, the routine<code>DeleteTSMDocument</code> may reuse a handle that it has already disposed of. Itdereferences this handle and writes a single byte. This may eventually causeyour application to crash mysteriously.</p><p>Workaround: make sure to deactivate each TSM document using<code>DeactivateTSMDocument</code> before calling <code>DeleteTSMDocument</code> to delete it. If TSMTEcalls <code>DeleteTSMDocument</code> for a TSM document it created for a modal dialog itdoes the right thing.</p><h3>ActivateTSMDocument Must Be Called From Foreground</h3><p><code>ActivateTSMDocument</code> does not work properly if called from the background. Whena window that owns a TSM document is coming to the foreground from thebackground, your application is supposed to call <code>ActivateTSMDocument</code> with the<code>TSMDocumentID</code> for that window.  However, if your application makes this callwhile still in the background, inline input may not become re-enabled in thatwindow. Applications that follow the usual scheme of activating windows afterreceiving an activate event shouldn't have any problems.</p><h3>SetTSMCursor and Cursor Regions</h3><p>Applications that use TSM are supposed to call <code>SetTSMCursor</code> generously in orderto allow TSM components to set the cursor when they need to do so.Unfortunately, there is no protocol for finding out in which region the inputmethod would want to set the cursor. This presents a problem for manyapplications that try to be cooperative by passing a cursor region to<code>WaitNextEvent</code>. Without information from the input method, an application usinginline input cannot calculate a meaningful cursor region, and thus has to berun whenever the mouse moved.</p><p>The only thing you can currently do is to define a 1-pixel cursor region underthe mouse point and pass this region to <code>WaitNextEvent</code>. This setup will causemouse-moved events to be generated whenever the mouse is moved, but will letthe application sleep if the mouse stays put.</p><h3>Strange Delete Key Behavior</h3><p>If you use version 1.0 of Kotoeri, Apple's Japanese input method, you maynotice that deletion of Japanese characters in the active input area using thedelete character does not work properly in your application. This is morelikely to happen with styled text or on non-Japanese system software (e.g.,with the Japanese Language Kit installed). Kotoeri thinks that it is using aRoman font and only deletes one byte for each delete key pressed. This resultsin the need to press the delete key twice to delete a single Japanese characteras well as other strange inline behavior. This bug has been fixed in version1.1.1, which was first shipped as part of the Japanese version of the systemsoftware for Power Macintosh.</p><p>Workaround: Add some code around your call to <code>TSMEvent</code> that sets the font inthe current <code>grafPort</code> to one of the keyboard script, and resets it afterwards ifnecessary. Kotoeri's behavior depends on the font in the current grafPort thatit encounters during your call to <code>TSMEvent</code>. Here is a routine that you can callinstead of <code>TSMEvent</code> to accomplish this:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>static Boolean IntlTSMEvent(EventRecord *event){    short oldFont;    ScriptCode keyboardScript;    // make sure we have a port and it's not the Window Manager port    if (qd.thePort != nil &amp;&amp; FrontWindow() != nil)    {        oldFont = qd.thePort-&gt;txFont;        keyboardScript = GetScriptManagerVariable(smKeyScript);        if (FontToScript(oldFont) != keyboardScript)            TextFont(GetScriptVariable(keyboardScript, smScriptAppFond));    };    return TSMEvent(event);</pre>	</TD></TR></TABLE></CENTER><p>You should also make sure that the current <code>grafPort</code> at this point is the one inwhich the input will be displayed.</p><h3>Input Methods Need Null Events</h3><p>Some input methods rely on receiving null events to function properly. Theeffects you may see if you don't feed them enough null events vary: An inputmethod may not redraw its windows correctly, or it may occasionally lose inputdata.</p><p>Workaround: you should call <code>IntlTSMEvent</code> (or <code>TSMEvent</code> if you don't use theworkaround in the previous section) even if <code>WaitNextEvent</code> returns false. Thesample code in <i>Inside Macintosh: Text ,</i> page 7-22, is wrong in thisrespect. Your code might look like this:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>gotEvent = WaitNextEvent(everyEvent, &amp;event, GetSleep(), cursorRgn);if (gHasTextServices &amp;&amp; (gotEvent || event.what == nullEvent))    if (IntlTSMEvent(&amp;event))        gotEvent = false;if (gotEvent)    HandleEvent(&amp;event);else</pre>	</TD></TR></TABLE></CENTER><BR><P><A HREF="#top">Back to top</A></p><a name="Section8"></a><h2>Pascal Summary</h2><h3>Constants</h3><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>const    { signature, interface types }    kTSMTESignature = 'tmTE';    kTSMTEInterfaceType = kTSMTESignature;    kTSMTEDialog = 'tmDI';    { Gestalt }    gestaltTSMTEAttr = kTSMTESignature;    gestaltTSMTEPresent = 0;    gestaltTSMTEVersion = 'tmTV';    gestaltTSMTE1 = $0100;    { update flag for TSMTERec }</pre>	</TD></TR></TABLE></CENTER>    <h3>Data Types</h3><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>type    TSMTERec = record        textH:          TEHandle;        preUpdateProc:  ProcPtr;        postUpdateProc: ProcPtr;        updateFlag:     Longint;        refCon:         Longint;        end;    TSMTERecPtr = ^TSMTERec;    TSMTERecHandle = ^TSMTERecPtr;    TSMDialogRecord = record        fDialog:        DialogRecord;        fDocID:         TSMDocumentID;        fTSMTERecH:     TSMTERecHandle;        fTSMTERsvd:     array [0..2] of Longint;        end;</pre>	</TD></TR></TABLE></CENTER>    <h3>Application-Defined Routines</h3><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>procedure MyTSMTEPreUpdateProc(textH: TEHandle; refCon: Longint);procedure MyTSMTEPostUpdateProc(textH: TEHandle; fixLen: Longint;        inputAreaStart, inputAreaEnd: Longint;</pre>	</TD></TR></TABLE></CENTER><BR><P><A HREF="#top">Back to top</A></p><a name="Section9"></a><h2>C Summary</h2><h3>Constants</h3><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>// signature, interface typesenum  {    kTSMTESignature     = 'tmTE',    kTSMTEInterfaceType = kTSMTESignature,    kTSMTEDialog        = 'tmDI'};// Gestaltenum  {    gestaltTSMTEAttr    = kTSMTESignature,    gestaltTSMTEPresent = 0,    gestaltTSMTEVersion = 'tmTV',    gestaltTSMTE1       = 0x100};// update flag for TSMTERecenum  {    kTSMTEAutoScroll    = 1</pre>	</TD></TR></TABLE></CENTER><h3>Data Types</h3><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>// the following proc ptr declarations come with the usual complements of// universal proc ptr declarations and related routinestypedef pascal void (*TSMTEPreUpdateProcPtr)(TEHandle textH, long refCon);typedef pascal void (*TSMTEPostUpdateProcPtr)(TEHandle textH, long fixLen,        long inputAreaStart, long inputAreaEnd,        long pinStart, long pinEnd, long refCon);struct TSMTERec {    TEHandle            textH;    TSMTEPreUpdateUPP   preUpdateProc;    TSMTEPostUpdateUPP  postUpdateProc;    long                updateFlag;    long                refCon;};typedef struct TSMTERec TSMTERec, *TSMTERecPtr, **TSMTERecHandle;struct TSMDialogRecord {    DialogRecord        fDialog;    TSMDocumentID       fDocID;    TSMTERecHandle      fTSMTERecH;    long                fTSMTERsvd[3];};</pre>	</TD></TR></TABLE></CENTER><h3>Application-Defined Routines</h3><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal void MyTSMTEPreUpdateProc(TEHandle textH, long refCon);pascal void MyTSMTEPostUpdateProc(TEHandle textH, long fixLen,        long inputAreaStart, long inputAreaEnd,</pre>	</TD></TR></TABLE></CENTER><BR><P><A HREF="#top">Back to top</A></p><a name="References"></a><h2>References</h2><p><a href="../../documentation/mac/Text/Text-409.html"><i>Inside Macintosh: Text,</i> Text Services Manager</A></p><p>Sample Code: <A HREF = "downloads/InlineInputSample.sea.hqx">"InlineInputSample"</a></p><P><A NAME=Changes></A></P>                  <H2>Change History</H2>                                <TABLE BORDER=0 CELLPADDING=3 WIDTH=544>            <TR>               <td width=100 align=left>                  <P ALIGN=center>01-January-1994</P>               </TD>               <td align="left">                  <P>Fixed a bug in the <code>IntlTSMEvent</code> routinethat could modify the Window Manager port's font, and updated the relatedinformation about the Japanese input method. Added section "Input Methods NeedNull Events". Clarified the information about required support for Apple eventsin the Prerequisites section.</P>               </TD>            </TR>            <TR>               <td width=100 align=left>                  <P ALIGN=center>01-December-1993</P>               </TD>               <td align="left">                  <P>Originally written.</P>               </TD>            </TR>         </TABLE>         <BR>                          <a name="Downloads"></a>       <P><A HREF="#top">Back to top</A></p><h2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (80K).</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/te_27.pdf">Download</A></P>               </TD>            </TR>                    </TABLE>         <BR></TD></TR></table></center><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/te/te_27.html%3Fid%3DDTS10002835-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/te/te_27.html%3Fid%3DDTS10002835-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/te/te_27.html%3Fid%3DDTS10002835-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>