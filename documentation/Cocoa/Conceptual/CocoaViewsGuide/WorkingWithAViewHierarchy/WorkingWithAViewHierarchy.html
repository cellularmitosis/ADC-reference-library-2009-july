<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>View Programming Guide for Cocoa: Working with the View Hierarchy</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Working with the View Hierarchy"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40002978-CH4" title="Working with the View Hierarchy"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../GraphicsImaging-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000450" target="_top">Graphics &amp; Imaging</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP40002978-CH1-SW1">View Programming Guide for Cocoa</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Coordinates/Coordinates.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../SubclassingNSView/SubclassingNSView.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40002978-CH4-SW1" title="Working with the View Hierarchy"></a><h1>Working with the View Hierarchy</h1><p>Along with their own direct responsibilities for drawing and event handling, views also act as containers for other views, creating a view hierarchy. This chapter describes the view hierarchy, its benefits, and how you work with views within a hierarchy. </p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="WorkingWithAViewHierarchy.html#//apple_ref/doc/uid/TP40002978-CH4-SW13">What Is a View Hierarchy?</a>
				
			<br/>
			
        
			
			
				<a href="WorkingWithAViewHierarchy.html#//apple_ref/doc/uid/TP40002978-CH4-SW14">Benefits of a View Hierarchy</a>
				
			<br/>
			
        
			
			
				<a href="WorkingWithAViewHierarchy.html#//apple_ref/doc/uid/TP40002978-CH4-SW15">Locating Views in the View Hierarchy</a>
				
			<br/>
			
        
			
			
				<a href="WorkingWithAViewHierarchy.html#//apple_ref/doc/uid/TP40002978-CH4-SW16">Adding and Removing Views from a Hierarchy</a>
				
			<br/>
			
        
			
			
				<a href="WorkingWithAViewHierarchy.html#//apple_ref/doc/uid/TP40002978-CH4-SW2">Repositioning and Resizing Views</a>
				
			<br/>
			
        
			
			
				<a href="WorkingWithAViewHierarchy.html#//apple_ref/doc/uid/TP40002978-CH4-SW20">Hiding Views</a>
				
			<br/>
			
        
			
			
				<a href="WorkingWithAViewHierarchy.html#//apple_ref/doc/uid/TP40002978-CH4-SW22">Converting Coordinates in the View Hierarchy</a>
				
			<br/>
			
        
			
			
				<a href="WorkingWithAViewHierarchy.html#//apple_ref/doc/uid/TP40002978-CH4-SW23">View Tags</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40002978-CH4-SW13" title="What Is a View Hierarchy?"></a><h2>What Is a View Hierarchy?</h2><p>In addition to being responsible for drawing and handling user events, a view instance can act as a container, enclosing other view instances. Those views are linked together creating a <strong>view hierarchy</strong>.  Unlike a class hierarchy, which defines the lineage of a class, the view hierarchy defines the layout of views relative to other views.</p><p>The window instance maintains a reference to a single top-level view instance, call the <strong>content view</strong>. The content view acts as the root of the visible view hierarchy in a window. The view instances enclosed within a view are called <strong>subviews</strong>. The parent view that encloses a view is referred to as its <strong>superview</strong>. While a view instance can have multiple subviews, it can have only one superview. In order for a view and its subviews to be visible to the user, the view must be inserted into a window's view hierarchy.</p><p><span class="content_text">Figure 3-1</span> shows a sample application window and its view hierarchy.</p><br/><div><a name="//apple_ref/doc/uid/TP40002978-CH4-SW5" title="Figure 3-1View hierarchy"></a><p><strong>Figure 3-1&nbsp;&nbsp;</strong>View hierarchy</p><img src = "../Art/view_hierarchy_enclose.gif" alt = "View hierarchy" width="529" height="131"></div><br/><p>This window's view hierarchy has these parts.</p><ul class="ul"><li class="li"><p>The window is represented by an <code>NSWindow</code> instance.</p></li><li class="li"><p>The content view serves as the root of the window's view hierarchy.</p></li><li class="li"><p>The content view contains a single subview, an instance of the <code>NSBox</code> class.</p></li><li class="li"><p>The <code>NSBox</code> instance in turn has two subviews, an <code>NSButton</code> instance, and an <code>NSTextField</code> instance.</p></li><li class="li"><p>The superview for both the button and text field is the <code>NSBox</code> object. The <code>NSBox</code> container actually encloses the button and text field views.</p></li></ul><a name="//apple_ref/doc/uid/TP40002978-CH4-SW14" title="Benefits of a View Hierarchy"></a><h2>Benefits of a View Hierarchy</h2><p>Managing views as a hierarchy benefits application design in several ways:</p><ul class="ul"><li class="li"><p>Complex view functionality can be assembled by using simpler <code>NSView</code> subclasses, avoiding monolithic and complex view classes. For example, a graphical keypad might be an <code>NSView</code> subclass that utilizes <code>NSButton</code> subviews for each key.</p></li><li class="li"><p>Each subview's coordinate system is positioned relative to its superview's coordinate system. <code>NSView</code> instances are positioned within their superviews, so that when an <code>NSView</code> instance is moved or its coordinate system is transformed, all its subviews are moved and transformed with it. Similarly, scaling an <code>NSView</code> instance causes all of the subviews to scale their drawing relative to the superview. Since each view draws within its own coordinate system, its drawing instructions remain constant no matter where it or its superview moves on the screen or how it is scaled.</p></li><li class="li"><p>A view hierarchy provides a clear definition of responsibility for event handling. When a view receives an event that it doesn't respond to, the event is forwarded up the view hierarchy through the superview for processing. The key window's view hierarchy takes part in an application's responder chain.</p></li><li class="li"><p>A view hierarchy also provides a defined structure for managing the redrawing of the window's content. When an <code>NSView</code> instance receives a display request, it draws itself, and then passes drawing responsibility to each of its subviews in turn. Each branch of the view hierarchy completes drawing before the next branch begins.</p></li><li class="li"><p>A view hierarchy is dynamic. It can be reconfigured as an application runs. View instances can be moved from window to window and installed as a subview first of one superview, then of another.</p></li></ul><a name="//apple_ref/doc/uid/TP40002978-CH4-SW15" title="Locating Views in the View Hierarchy"></a><h2>Locating Views in the View Hierarchy</h2><p>A rich selection of methods allows applications to access a view's hierarchy. The <code>superview</code> method returns the view that contains the receiver, while the <code>subviews</code> method returns an array containing the view's immediate descendants. If a view is the root of a view hierarchy, it returns <code>nil</code> when asked for its superview. Sending a view the <code>window</code> message returns the window the view resides in, or <code>nil</code> if the view is not currently in a window's view hierarchy. <span class="content_text">Figure 3-2</span> illustrates the relationships of the objects in the view hierarchy shown in <span class="content_text">Figure 3-1</span>.</p><br/><div><a name="//apple_ref/doc/uid/TP40002978-CH4-SW6" title="Figure 3-2Relationships among objects in a hierarchy"></a><p><strong>Figure 3-2&nbsp;&nbsp;</strong>Relationships among objects in a hierarchy</p><img src = "../Art/contents_sub_super_views.gif" alt = "Relationships among objects in a hierarchy" width="285" height="362"></div><br/><p>Other methods allow you to inspect relationships among views: <code>isDescendantOf:</code> confirms the containment of the receiver; <code>ancestorSharedWithView:</code> finds the common container containing the receiver and the view instance specified as the parameter. For example, assuming a view hierarchy as shown in <span class="content_text">Figure 3-2</span>, sending <code>viewC</code> a <code>isDescendentOf:</code> message with <code>contentView</code> as the parameter returns <code>YES</code>. Sending <code>viewB</code> the <code>ancestorSharedWithView:</code> message, passing <code>viewC</code> as the parameter, returns <code>viewA</code>.</p><p>The <code>opaqueAncestor</code> method returns the closest parent view that’s guaranteed to draw every pixel in the receiver’s frame (possibly the receiver itself).</p><a name="//apple_ref/doc/uid/TP40002978-CH4-SW16" title="Adding and Removing Views from a Hierarchy"></a><h2>Adding and Removing Views from a Hierarchy</h2><p>Creating a view subclass using the  <code>initWithFrame:</code> method establishes an <code>NSView</code> object's frame rectangle, but doesn’t insert it into a window's view hierarchy. You do this by sending an <code>addSubview:</code> message to the intended superview, passing the view to insert as the parameter. The frame rectangle is then interpreted in terms of the superview, properly locating the new view by both its place in the view hierarchy and its location in the superview’s window. An existing view in the view hierarchy can be replaced by sending the superview a <code>replaceSubview:with:</code> message, passing the view to replace and the replacement view as parameters. An additional method, <code>addSubview:positioned:relativeTo:</code>, allows you to specify the ordering of views.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002978-CH4-SW17" title="Note"></a><p><strong>Note:</strong>&nbsp;For performance reasons, Cocoa does not enforce clipping among sibling views or guarantee correct invalidation and drawing behavior when sibling views overlap. If you want a view to be drawn in front of another view, you should make the front view a subview (or descendant) of the rear view.</p></div><p>You remove a view from the view hierarchy by sending it a <code>removeFromSuperview</code> message. The <code>removeFromSuperviewWithoutNeedingDisplay</code> method is similar, removing the receiver from its superview, but it does not cause the superview to redraw.</p><p>When an <code>NSView</code> object is added as a subview of another view, it automatically invokes the <code>viewWillMoveToSuperview:</code> and <code>viewWillMoveToWindow:</code> methods. You can override these methods to allow an instance to query its new superview or window about relevant state and update itself accordingly. </p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40002978-CH4-DontLinkElementID_3" title="Important:"></a><p><strong>Important:</strong>&nbsp;When considering memory management, the view hierarchy should be thought of as any other Cocoa collection object. When an item is added to a collection, it is retained. When it is removed, it is released.</p><p>Specifically, when you insert a view as a subview using the <code>addSubview:</code> or  <code>addSubview:positioned:relativeTo:</code> methods, it is retained by the receiving view. Inversely, when you remove a subview from a view hierarchy by sending its superview a <code>removeFromSuperview</code> message, the view is released. The <code>replaceSubview:with:</code> method acts the same, releasing the view that is replaced and retaining the view that is inserted in its place.</p><p>See <em><a href="../../MemoryMgmt/index.html#//apple_ref/doc/uid/10000011i" target="_top">Memory Management Programming Guide for Cocoa</a></em> for a complete discussion of the Cocoa memory management conventions.</p><p></p></div><a name="//apple_ref/doc/uid/TP40002978-CH4-SW2" title="Repositioning and Resizing Views"></a><h2>Repositioning and Resizing Views</h2><p>Repositioning or resizing a view is a potentially complex operation. When a view moves or resizes it can expose portions of its superview that weren’t previously visible, requiring the superview to redisplay. Resizing can also affect the layout of the view’s subviews. Changes to a view's layout in either case may be of interest to other objects, which might need to be notified of the change. The following sections explore each of these areas.</p><a name="//apple_ref/doc/uid/TP40002978-CH4-SW18" title="Moving and Resizing Views Programmatically"></a><h3>Moving and Resizing Views Programmatically</h3><p>After a view instance has been created, you can move it programmatically using any of the frame-setting methods: <code>setFrame:</code>, <code>setFrameOrigin:</code>, and <code>setFrameSize:</code>.  If the bounds rectangle of the view has not been explicitly set using one of the <code>setBounds...</code> methods, the view's bounds rectangle is automatically updated to match the new frame size.</p><p>When you change the frame rectangle, the position and size of subviews' frame rectangles often need to be altered as well. If the repositioned view returns <code>YES</code> for <code>autoresizesSubviews</code>, its subviews are automatically resized as described in <span class="content_text"><a href="WorkingWithAViewHierarchy.html#//apple_ref/doc/uid/TP40002978-CH4-SW12">“Autoresizing of Subviews.”</a></span> Otherwise, it is the application's responsibility to reposition and resize the subviews manually.</p><p>None of the methods that alter a view's frame rectangle automatically redisplay the view or marks it as needing display. When using the <code>setFrame...</code> methods, you must mark both the view being repositioned and its superview as needing display as in the code fragment shown in <span class="content_text">Listing 3-1</span>.</p><a name="//apple_ref/doc/uid/TP40002978-CH4-SW7" title="Listing 3-1Marking view contents for display after modifying the frame"></a><p class="codesample"><strong>Listing 3-1&nbsp;&nbsp;</strong>Marking view contents for display after modifying the frame</p><div class="codesample"><table><tr><td scope="row"><pre>NSView *theView;        /* Assume this exists. */<span></span></pre></td></tr><tr><td scope="row"><pre>NSRect newFrame;        /* Assume this exists. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>[[theView superview] setNeedsDisplayInRect:[theView frame]];<span></span></pre></td></tr><tr><td scope="row"><pre>[theView setFrame:newFrame];<span></span></pre></td></tr><tr><td scope="row"><pre>[theView setNeedsDisplay:YES];<span></span></pre></td></tr></table></div><p>This code fragment marks the superview as needing display in the frame of the view about to be moved. Then, after the new frame rectangle of <code><!--a  -->theView<!--/a--></code> is set, the altered view is marked as needing display in its entirety, which is nearly always the case. The <code>setBounds...</code> methods also don’t redisplay the receiving view, but because their changes don’t affect superviews, you can simply mark the receiving view instance as needing display.</p><a name="//apple_ref/doc/uid/TP40002978-CH4-SW12" title="Autoresizing of Subviews"></a><h3>Autoresizing of Subviews</h3><p><code>NSView</code> provides a mechanism for automatically moving and resizing subviews in response to their superview being moved or resized. In many cases simply configuring the autoresizing mask for a view provides the appropriate behavior for an application. Autoresizing is on by default for views created programmatically, but you can turn it off using the <code>setAutoresizesSubviews:</code> method.   </p><p>Interface Builder allows you to set a view's autoresizing mask graphically with its Size inspector, and in test mode you can immediately examine the effects of autoresizing. The autoresizing mask can also be set programmatically.</p><p>A view's autoresizing mask is specified by combining the autoresizing mask constants using the bitwise OR operator and sending the view a  <code>setAutoresizingMask:</code> message, passing the mask as the parameter. <span class="content_text">Table 3-1</span> shows each mask constant and how it effects the view's resizing behavior.</p><a name="//apple_ref/doc/uid/TP40002978-CH4-SW8" title="Table 3-1Autoresizing mask constants"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 3-1&nbsp;&nbsp;</strong>Autoresizing mask constants</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Autoresizing Mask</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code>NSViewHeightSizable</code></p></td><td ><p>If set, the view's height changes proportionally to the change in the superview's height. Otherwise, the view's height does not change relative to the superview's height.</p></td></tr><tr><td  scope="row"><p><code>NSViewWidthSizable</code></p></td><td ><p>If set, the view's width changes proportionally to the change in the superview's width. Otherwise, the view's width does not change relative to the superview's width.</p></td></tr><tr><td  scope="row"><p><code>NSViewMinXMargin</code></p></td><td ><p>If set, the view's left edge is repositioned proportionally to the change in the superview's width. Otherwise, the view's left edge remains in the same position relative to the superview's left edge.</p></td></tr><tr><td  scope="row"><p><code>NSViewMaxXMargin</code></p></td><td ><p>If set, the view's right edge is repositioned proportionally to the change in the superview's width. Otherwise, the view's right edge remains in the same position relative to the superview.</p></td></tr><tr><td  scope="row"><p><code>NSViewMinYMargin</code></p></td><td ><p>If set and the superview is not flipped, the view's top edge is repositioned proportionally to the change in the superview's height. Otherwise, the view's top edge remains in the same position relative to the superview.</p><p>If set and the superview is flipped, the view's bottom edge is repositioned proportionally to the change in the superview's height. Otherwise, the view's bottom edge remains in the same position relative to the superview.</p></td></tr><tr><td  scope="row"><p><code>NSViewMaxYMargin</code></p></td><td ><p>If set and the superview is not flipped, the view's bottom edge is repositioned proportional to the change in the superview's height. Otherwise, the view's bottom edge remains in the same position relative to the superview.</p><p>If set and the superview is flipped, the view's top edge is repositioned proportional to the change in the superview's height. Otherwise, the view's top edge remains in the same position relative to the superview.</p></td></tr></table></div><p>For example, to keep a view in the lower-left corner of its superview, you specify <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/doc/c_ref/NSViewMaxXMargin" target="_top">NSViewMaxXMargin</a></code> | <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/doc/c_ref/NSViewMaxYMargin" target="_top">NSViewMaxYMargin</a></code>. When more than one aspect along an axis is made flexible, the resize amount is distributed evenly among them. <span class="content_text">Figure 3-3</span> provides a graphical representation of the position of the constant values in both normal and flipped superviews.</p><br/><div><a name="//apple_ref/doc/uid/TP40002978-CH4-SW3" title="Figure 3-3View autoresizing mask constants"></a><p><strong>Figure 3-3&nbsp;&nbsp;</strong>View autoresizing mask constants</p><img src = "../Art/nsview_autoresizeconstants.gif" alt = "View autoresize flags" width="475" height="464"></div><br/><p>When one of these constants is omitted, the view's layout is fixed in that aspect; when a constant is included in the mask the view's layout is flexible in that aspect. Including a constant in the mask is the same as configuring that autoresizing aspect with a spring in Interface Builder.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002978-CH4-SW19" title="Note"></a><p><strong>Note:</strong>&nbsp;If a view is created in Interface Builder and no autoresizing flags are set in the view's inspector, then <code>setAutoresizesSubviews:</code> is automatically set to <code>NO</code>. Before programmatically modifying the autoresizing mask, you need to explicitly enable autoresizing for the superview by sending the superview a <code>setAutoresizesSubviews:</code> message, passing <code>YES</code> as the parameter. </p></div><p>When you turn off a view's autoresizing, all of its descendants are likewise shielded from changes in the superview. Changes to subviews, however, can still percolate downward. Similarly, if a subview has no autoresize mask, it won’t change in size, and therefore none of its subviews autoresize.</p><p>A subclass can override <code>resizeSubviewsWithOldSize:</code> or <code>resizeWithOldSuperviewSize:</code> to customize the autoresizing behavior for a view. A view's <code>resizeSubviewsWithOldSize:</code> method is invoked automatically by a view whenever its frame size changes. This method then simply sends a <code>resizeWithOldSuperviewSize:</code> message to each subview. Each subview compares the old frame size to the new size and adjusts its position and size according to its autoresize mask.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40002978-CH4-DontLinkElementID_4" title="Important:"></a><p><strong>Important:</strong>&nbsp;Several cautions apply to autoresizing. For autoresizing to work correctly, the subview being autoresized must lie completely within its superview’s frame. Autoresizing doesn’t work at all in views that have been rotated. Subviews that have been rotated can autoresize within a nonaltered superview, but then their descendants aren’t autoresized.</p><p></p></div><a name="//apple_ref/doc/uid/TP40002978-CH4-SW11" title="Notifications"></a><h3>Notifications</h3><p>Beyond resizing its subviews, by default an <code>NSView</code> instance broadcasts notifications to interested observers any time its bounds or frame rectangles change. The notification names are <code>NSViewFrameDidChangeNotification</code> and <code>NSViewBoundsDidChangeNotification</code>, respectively. </p><p>An <code>NSView</code> instance that bases its own display on the layout of its subviews should register itself as an observer for those subviews and update itself any time they’re moved or resized. Both <code>NSScrollView</code> and <code>NSClipView</code> instances cooperate in this manner to adjust the scroll view's scrollers. </p><p>By default both frame and bounds rectangle changes are sent for a view instance. You can prevent an <code>NSView</code> instance from providing the notifications using <code>setPostsFrameChangedNotifications:</code> and <code>setPostsBoundsChangedNotifications:</code> and passing <code>NO</code> as the parameter. If your application does complicated view layout, turning change notifications off before layout and then restoring them upon completion may provide a performance improvement. As with all performance tuning, it is best to first sample your application to determine if the change notifications are having a negative impact on performance.</p><a name="//apple_ref/doc/uid/TP40002978-CH4-SW20" title="Hiding Views"></a><h2>Hiding Views</h2><p>You hide and “unhide” (that is, show) the views of a Cocoa application using the <code>NSView</code> method <code>setHidden:</code>. This method takes a Boolean parameter: <code>YES</code> (hide the receiving view) or <code>NO</code> (show the receiver).</p><p>When you hide a view using the  <code>setHidden:</code> method it remains in its view hierarchy, even though it disappears from its window and does not receive input events. A hidden view remains in its superview’s list of subviews and participates in autoresizing. If a view marked as hidden has subviews, they and their view descendants are hidden as well. When you hide a view, the Application Kit also disables any cursor rectangle, tool-tip rectangle, or tracking rectangle associated with the view.</p><p>Hiding the view that is the window’s current first responder causes the view’s next valid key view (<code>nextValidKeyView</code>) to become the new first responder. A hidden view remains in the <code>nextKeyView</code> chain of views it was previously part of but is ignored during keyboard navigation.</p><p>You can query the hidden state of a view by sending it either <code>isHidden</code> or <code>isHiddenOrHasHiddenAncestor</code> (both defined by <code>NSView</code>). The former method returns <code>YES</code> when the view has been explicitly marked as hidden with a <code>setHidden:</code> message. The latter returns <code>YES</code> both when the view has been explicitly marked as hidden and when it is hidden because an ancestor view has been marked as hidden.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002978-CH4-SW21" title="Note"></a><p><strong>Note:</strong>&nbsp;Before Mac OS X v10.3, to hide a view you had to remove it from its superview and retain it for later reinsertion into the view hierarchy. Because this approach separates a view from its hierarchy, it has some limitations. If the superview is resized, the removed view is not automatically adjusted to this new size upon reinsertion. In addition, if the removed view was part of a chain of key views (each responding to <code>nextKeyView</code>), it has to be reintegrated into the chain upon reinsertion. It is the application's responsibility to manage these issues programmatically.</p></div><a name="//apple_ref/doc/uid/TP40002978-CH4-SW22" title="Converting Coordinates in the View Hierarchy"></a><h2>Converting Coordinates in the View Hierarchy</h2><p>At various times, particularly when handling events, an application needs to convert rectangles or points from the coordinate system of one <code>NSView</code> instance to another (typically the superview or subview) in the same window. The <code>NSView</code> class defines six methods that convert rectangles, points, and sizes in either direction: </p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Convert to the receiver from the specified view</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Convert from the receiver to the specified view</p></th></tr><tr><td  scope="row"><p><code>convertPoint:fromView:</code></p></td><td ><p><code>convertPoint:toView:</code></p></td></tr><tr><td  scope="row"><p><code>convertRect:fromView:</code></p></td><td ><p><code>convertRect:toView:</code></p></td></tr><tr><td  scope="row"><p><code>convertSize:fromView:</code></p></td><td ><p><code>convertSize:toView:</code></p></td></tr></table></div><p>The <code>convert...:fromView:</code> methods convert the values to the receiver's coordinate system, from the coordinate system of the view passed as the second parameter. If <code>nil</code> is passed as the view, the values are assumed to be in the window's base coordinate system and are converted to the receiver's coordinate system. The <code>convertPoint:fromView:</code> method is commonly used to convert mouse-event coordinates, which are provided by <code>NSEvent</code> as relative to the window, to the receiving view as shown in <span class="content_text"><a href="WorkingWithAViewHierarchy.html#//apple_ref/doc/uid/TP40002978-CH4-SW10">Listing 3-2</a></span>.</p><a name="//apple_ref/doc/uid/TP40002978-CH4-SW10" title="Listing 3-2Converting event locations using convertPoint:fromView:"></a><p class="codesample"><strong>Listing 3-2&nbsp;&nbsp;</strong>Converting event locations using <code>convertPoint:fromView:</code></p><div class="codesample"><table><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>-(void)mouseDown:(NSEvent *)event<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSPoint clickLocation;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // convert the click location into the view coords<span></span></pre></td></tr><tr><td scope="row"><pre>    clickLocation = [self convertPoint:[event locationInWindow]<span></span></pre></td></tr><tr><td scope="row"><pre>                              fromView:nil];<span></span></pre></td></tr><tr><td scope="row"><pre>    // do something with the click location<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	<p>The <code>convert..:toView:</code> methods do the inverse, converting values in the receiver's coordinate system to the coordinate system of the view passed as a parameter. If the view parameter is <code>nil</code>, the values are converted to the base coordinate system of the receiver's window.</p><p>For converting to and from the screen coordinate system, <code>NSWindow</code> defines the <code>convertBaseToScreen:</code> and <code>convertScreenToBase:</code> methods. Using the <code>NSView</code> conversion methods along with these methods allows you to convert a geometric structure between a view's coordinate system and the screen’s with only two messages, as shown in <span class="content_text">Listing 3-3</span>.</p><a name="//apple_ref/doc/uid/TP40002978-CH4-SW9" title="Listing 3-3Converting a view location to the screen location"></a><p class="codesample"><strong>Listing 3-3&nbsp;&nbsp;</strong>Converting a view location to the screen location</p><div class="codesample"><table><tr><td scope="row"><pre>NSPoint pointInWindowCoordinates;<span></span></pre></td></tr><tr><td scope="row"><pre>NSPoint pointInScreenCoords;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>pointInWindowCoordinates=[self convertPoint:viewLocation toView:nil];<span></span></pre></td></tr><tr><td scope="row"><pre>pointInScreenCoords=[[self window] convertBaseToScreen:pointInWindowCoordinates];<span></span></pre></td></tr></table></div>	<p>Conversion is straightforward when neither view is rotated or when dealing only with points. When converting rectangles or sizes between views with different rotations, the geometric structure must be altered in a reasonable way. In converting a rectangle, the <code>NSView</code> class makes the assumption that you want to guarantee coverage of the original screen area. To this end, the converted rectangle is enlarged so that when located in the appropriate view, it completely covers the original rectangle.  <span class="content_text">Figure 3-4</span> shows the conversion of a rectangle in the <code>rotatedView</code> object's coordinate system to that of its superview, <code>outerView</code>.</p><br/><div><a name="//apple_ref/doc/uid/TP40002978-CH4-SW4" title="Figure 3-4Converting values in a rotated view"></a><p><strong>Figure 3-4&nbsp;&nbsp;</strong>Converting values in a rotated view</p><img src = "../Art/nsview_convertrotated1.gif" alt = "Converting values in a rotated view" width="551" height="247"></div><br/><p>In converting a size, <code>NSView</code> simply treats it as an delta offset from (0.0, 0.0) that you need to convert from one view to another. Though the offset distance remains the same, the balance along the two axes shifts according to the rotation. It's useful to note that in converting sizes Cocoa will always return sizes that consist of positive numbers.</p><a name="//apple_ref/doc/uid/TP40002978-CH4-SW23" title="View Tags"></a><h2>View Tags</h2><p>The <code>NSView</code> class defines methods that allow you to tag individual view objects with integer tags and to search the view hierarchy based on those tags. The receiver's subviews are searched depth-first, starting at the first subview returned by the receiver's <code>subviews</code> method. </p><p>The <code>NSView</code> method <code>tag</code> always returns <code>–1</code>. Subclasses can override this method to return a different value. It is common for a subclass to implement a <code>setTag:</code> method that stores the tag value in an instance variable, allowing the tag to be set on an individual view basis. Several Application Kit classes, including the <code>NSControl</code> subclasses, do just this. The <code>viewWithTag:</code> method proceeds through all of the receiver’s descendants (including itself) using a depth-first search, from back to front in the receiver's view hierarchy, looking for a subview with the given tag and returning it if it’s found.</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Coordinates/Coordinates.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../SubclassingNSView/SubclassingNSView.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-04-10<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/CocoaViewsGuide/WorkingWithAViewHierarchy/WorkingWithAViewHierarchy.html%3Fid%3DTP40002978-2.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/CocoaViewsGuide/WorkingWithAViewHierarchy/WorkingWithAViewHierarchy.html%3Fid%3DTP40002978-2.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/CocoaViewsGuide/WorkingWithAViewHierarchy/WorkingWithAViewHierarchy.html%3Fid%3DTP40002978-2.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>