<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>I/O Kit Device Driver Design Guidelines: The IOService API</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="The IOService API"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30000697" title="The IOService API"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../HardwareDrivers/index.html#//apple_ref/doc/uid/TP30000440-TP40003576" target="_top">Hardware &amp; Drivers</a> &gt; <a href="../Introduction/Intro.html#//apple_ref/doc/uid/TP40002799-TPXREF101">I/O Kit Device Driver Design Guidelines</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../ContainerClasses/Libkern_Classes.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../MakingHWAccessible/MakingHWAccessible.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30000697-CACIDGBG" title="The IOService API"></a><h1>The IOService API</h1><p>Even though the IOService class inherits directly from IORegistryEntry and, by extension, from OSObject, you can think of IOService as the root class of nearly every object in the I/O Registry and, at least indirectly, of every driver. The methods of the IOService API are numerous and wide-ranging, providing services for most aspects of device management, from driver matching and loading to device interrupts and power management.</p><p>The majority of these methods are for internal (IOService) and I/O Kit family use. Many IOService methods are helper methods that IOService uses to implement other methods. Many more are meant for the I/O Kit families to implement. As a driver developer for a family-supported device, you will implement or call only a small fraction of the methods in IOService. If you are developing a driver for a familyless device, such as a PCI device, you may need to implement some of the IOService methods that families typically implement.</p><p>This chapter explores the public IOService methods that are available for external use in each of the following categories: </p><ul class="ul"><li class="li"><p>Driver life cycle, including matching</p></li><li class="li"><p>Notifications and messaging</p></li><li class="li"><p>Accessing objects</p></li><li class="li"><p>Power management</p></li><li class="li"><p>Memory mapping</p></li><li class="li"><p>Interrupt handling</p></li></ul>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="IOService.html#//apple_ref/doc/uid/TP30000697-TPXREF101">Driver Life-Cycle and Matching Functionality</a>
				
			<br/>
			
        
			
			
				<a href="IOService.html#//apple_ref/doc/uid/TP30000697-TPXREF106">Notifications and Driver Messaging</a>
				
			<br/>
			
        
			
			
				<a href="IOService.html#//apple_ref/doc/uid/TP30000697-TPXREF109">Access Methods</a>
				
			<br/>
			
        
			
			
				<a href="IOService.html#//apple_ref/doc/uid/TP30000697-TPXREF113">Power Management</a>
				
			<br/>
			
        
			
			
				<a href="IOService.html#//apple_ref/doc/uid/TP30000697-TPXREF116">Memory Mapping and Interrupt Handling</a>
				
			<br/>
			
        
			
			
				<a href="IOService.html#//apple_ref/doc/uid/TP30000697-TPXREF119">Miscellaneous IOService Methods</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30000697-TPXREF101" title="Driver Life-Cycle and Matching Functionality"></a><h2>Driver Life-Cycle and Matching Functionality</h2><p>In the dynamic I/O Kit environment, a driver can be loaded and unloaded, or activated and deactivated, at any time. The constant in this flurry of activity is the set of IOService and IORegistryEntry methods that define every driver’s life cycle.</p><p>With the exception of <code>init</code> and <code>free</code>, which OSObject defines, the remaining driver life-cycle methods are IOService methods. Because these methods are well-documented elsewhere (see<em><a href="../../IOKitFundamentals/index.html#//apple_ref/doc/uid/TP0000011" target="_top"> I/O Kit Fundamentals</a></em>), this chapter does not cover them again. Instead, the following sections present the less well-known IOService methods related to the driver life cycle.</p><a name="//apple_ref/doc/uid/TP30000697-CACFFDHD" title="Driver Matching"></a><h3>Driver Matching</h3><p><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_353"></a><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_354"></a><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_355"></a><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_356"></a><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_357"></a>IOService includes a number of methods used in the driver-matching process, but unless you are developing a family or writing a familyless driver, you do not need to implement any of them. It is important, however, to understand the driver-matching process and how the I/O Kit uses IOService’s matching methods so you can successfully define your driver’s personality dictionary.</p><p><span class="content_text"><a href="IOService.html#//apple_ref/doc/uid/TP30000697-CACCJHAF">Table 3-1</a></span> shows the IOService matching methods and briefly describes how the I/O Kit uses them. </p><a name="//apple_ref/doc/uid/TP30000697-CACCJHAF" title="Table 3-1IOService matching methods"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 3-1&nbsp;&nbsp;</strong>IOService matching methods</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>IOService method</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Usage</p></th></tr><tr><td  scope="row"><p><code>compareProperties</code></p></td><td ><p>Helper function used in implementing <code>matchPropertyTable</code></p></td></tr><tr><td  scope="row"><p><code>compareProperty</code></p></td><td ><p>Helper function used in implementing <code>matchPropertyTable</code></p></td></tr><tr><td  scope="row"><p><code>getMatchingServices</code></p></td><td ><p>In-kernel counterpart of the user-space function <code>IOServiceGetMatchingServices</code></p></td></tr><tr><td  scope="row"><p><code>matchPropertyTable</code></p></td><td ><p>Optionally implemented by families (or familyless drivers) to examine family-specific match properties</p></td></tr><tr><td  scope="row"><p><code>nameMatching</code></p></td><td ><p>In-kernel counterpart of the user-space function <code>IOServiceNameMatching</code></p></td></tr><tr><td  scope="row"><p><code>resourceMatching</code></p></td><td ><p>In-kernel matching function to create a dictionary to search for <code>IOResources</code> objects</p></td></tr><tr><td  scope="row"><p><code>serviceMatching</code></p></td><td ><p>In-kernel counterpart of the user-space function <code>IOServiceMatching</code></p></td></tr></table></div><p>For more information on the user-space functions <code>IOServiceGetMatchingServices</code>, <code>IOServiceNameMatching</code>, and <code>IOServiceMatching</code>, see <em><a href="../../AccessingHardware/index.html#//apple_ref/doc/uid/TP30000376" target="_top">Accessing Hardware From Applications</a></em> or the HeaderDoc documentation for <code>IOKitLib.h</code> in <code>/Developer/ADC Reference Library/documentation/Darwin/Reference/IOKit</code>.</p><p>Understanding how the I/O Kit uses your driver’s personality in the driver-matching process is an important prerequisite to crafting successful personality dictionaries. As described in <em><a href="../../IOKitFundamentals/index.html#//apple_ref/doc/uid/TP0000011" target="_top">I/O Kit Fundamentals</a></em>, the I/O Kit uses the driver’s required <code>IOProviderClass<a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_358"></a></code> key during the class-matching<a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_359"></a><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_360"></a> step to eliminate all drivers with the wrong provider type. Usually, this step eliminates the majority of drivers, leaving only those that attach to the correct nub type.</p><p>In the passive-matching phase, the I/O Kit examines the remaining keys in a driver’s personality dictionary and compares them to the provider–class specific information in the device nub. It is during this phase that the family can implement the <code>matchPropertyTable<a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_361"></a></code> method to more closely inspect the match candidate.</p><p>When a family implements <code>matchPropertyTable</code>, it can interpret the match candidate’s property values in any way it chooses, without interference from the I/O Kit. Additionally, if a driver includes a family-defined property in its <code>Info.plist</code> file, the I/O Kit ignores it if the family does not implement the <code>matchPropertyTable</code> method. As a driver writer, you should be familiar with the properties your driver’s family uses. For example, the IOSCSIPeripheralDeviceNub class (in the IOSCSIArchitectureModel family) implements <code>matchPropertyTable</code> to rank a match candidate according to how many family-specific properties it has. <span class="content_text"><a href="IOService.html#//apple_ref/doc/uid/TP30000697-CACGCEFD">Listing 3-1</a></span> shows a fragment of IOSCSIPeripheralDeviceNub’s <code>matchPropertyTable</code> implementation.<a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_362"></a><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_363"></a><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_364"></a><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_365"></a><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_366"></a></p><a name="//apple_ref/doc/uid/TP30000697-CACGCEFD" title="Listing 3-1A matchPropertyTable implementation"></a><p class="codesample"><strong>Listing 3-1&nbsp;&nbsp;</strong>A <code>matchPropertyTable</code> implementation</p><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_367"></a><div class="codesample"><table><tr><td scope="row"><pre>bool IOSCSIPeripheralDeviceNub::matchPropertyTable ( OSDictionary * table,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    SInt32 * score )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    bool returnValue = true;<span></span></pre></td></tr><tr><td scope="row"><pre>    bool isMatch = false;<span></span></pre></td></tr><tr><td scope="row"><pre>    SInt32 propertyScore = * score;<span></span></pre></td></tr><tr><td scope="row"><pre>    /* Adjust a driver's initial score to avoid "promoting" it too far. */<span></span></pre></td></tr><tr><td scope="row"><pre>    /* ... */<span></span></pre></td></tr><tr><td scope="row"><pre>    /* Use IOSCSIPeripheralDeviceNub's sCompareProperty method to compare */<span></span></pre></td></tr><tr><td scope="row"><pre>    /* the driver's properties with family-specific properties. */<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( sCompareProperty ( this,table, kIOPropertySCSIPeripheralDeviceType,<span></span></pre></td></tr><tr><td scope="row"><pre>                            &amp;isMatch ) )<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        if ( isMatch ) {<span></span></pre></td></tr><tr><td scope="row"><pre>            *score = kDefaultProbeRanking;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        else {<span></span></pre></td></tr><tr><td scope="row"><pre>            *score = kPeripheralDeviceTypeNoMatch;<span></span></pre></td></tr><tr><td scope="row"><pre>            returnValue = false;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        if ( sCompareProperty ( this, table,<span></span></pre></td></tr><tr><td scope="row"><pre>                                kIOPropertySCSIVendorIdentification,<span></span></pre></td></tr><tr><td scope="row"><pre>                                &amp;isMatch ) ) {<span></span></pre></td></tr><tr><td scope="row"><pre>            if ( isMatch ) {<span></span></pre></td></tr><tr><td scope="row"><pre>                *score = kFirstOrderRanking;<span></span></pre></td></tr><tr><td scope="row"><pre>                /* Continue to test for additional properties, */<span></span></pre></td></tr><tr><td scope="row"><pre>                /* promoting the driver to the next rank with each */<span></span></pre></td></tr><tr><td scope="row"><pre>                /* property found. */<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    } else {<span></span></pre></td></tr><tr><td scope="row"><pre>        /* Take care of SCSITaskUserClient "driver" here. */<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( *score != 0 )<span></span></pre></td></tr><tr><td scope="row"><pre>        *score += propertyScore;<span></span></pre></td></tr><tr><td scope="row"><pre>    return returnValue;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000697-CACHHDHB" title="Passive-Matching Keys"></a><h3>Passive-Matching Keys</h3><p><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_368"></a><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_369"></a><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_370"></a>In addition to the family-specific keys the family may require, there are several passive-matching keys the I/O Kit defines:</p><ul class="spaceabove"><li class="li"><p><code>IOProviderClass</code></p></li><li class="li"><p><code>IOPropertyMatch</code></p></li><li class="li"><p><code>IONameMatch</code></p></li><li class="li"><p><code>IOResourceMatch</code></p></li><li class="li"><p><code>IOParentMatch</code></p></li><li class="li"><p><code>IOPathMatch</code></p></li></ul><p><code>IOProviderClass<a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_371"></a></code> is required for all driver personalities because it declares the name of the nub class the driver attaches to. The provider class name also determines the remaining match keys.</p><p>The <code>IOPropertyMatch<a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_372"></a></code> key represents a specific list of properties that must match exactly in order for the I/O Kit to load the driver. For example, the IOBlockStorageDriver defines the following personality:</p><div class="codesample"><table><tr><td scope="row"><pre>&lt;key>IOProviderClass&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>&lt;string>IOBlockStorageDevice&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>&lt;key>IOClass&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>&lt;string>IOBlockStorageDriver&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>&lt;key>IOPropertyMatch&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>&lt;dict><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>device-type&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>Generic&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>&lt;/dict><span></span></pre></td></tr></table></div><p>After the I/O Kit determines that the IOBlockStorageDriver is a match candidate for a nub of class IOBlockStorageDevice, it examines the value of the <code>IOPropertyMatch</code> key. If the nub has a <code>device-type</code> key with the value <code>Generic</code>, the I/O Kit loads this personality of the IOBlockStorageDriver.</p><p>The utility of the <code>IOPropertyMatch</code> key lies in the fact that the I/O Kit uses its value in the matching process regardless of whether the family implements the <code>matchPropertyTable</code> method. Unlike the <code>matchPropertyTable</code> method, however, the <code>IOPropertyMatch</code> key does not allow the family to interpret its value—if the <code>IOPropertyMatch</code> value does not match the nub’s corresponding property exactly, the I/O Kit removes the driver from the pool of match candidates.</p><p><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_373"></a><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_374"></a>The <code>IONameMatch</code> key matches on the <code>compatible</code>, <code>name</code>, or <code>device-type</code> properties of a provider. The value of the <code>IONameMatch</code> key can be an array of strings representing a list of all such properties your driver can match on. After the I/O Kit has matched and loaded your driver, it places the <code>IONameMatched</code> property and the value of the actual property value your driver matched on in your driver’s I/O Registry property table. </p><p><span class="content_text"><a href="IOService.html#//apple_ref/doc/uid/TP30000697-CACEGFFH">Listing 3-2</a></span> shows part of one of the personalities of the GossamerPE (a Platform Expert for the Blue and White G3 computer):</p><a name="//apple_ref/doc/uid/TP30000697-CACEGFFH" title="Listing 3-2A personality of the GossamerPE"></a><p class="codesample"><strong>Listing 3-2&nbsp;&nbsp;</strong>A personality of the GossamerPE</p><div class="codesample"><table><tr><td scope="row"><pre>&lt;key>GossamerPE&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>&lt;dict><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>IOClass&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>GossamerPE&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>IONameMatch&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;array><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;string>AAPL,Gossamer&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;string>AAPL,PowerMac G3&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;string>AAPL,PowerBook1998&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;string>iMac,1&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;string>PowerMac1,1&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;string>PowerMac1,2&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;string>PowerBook1,1&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;/array><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>IOProviderClass&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>IOPlatformExpertDevice&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>&lt;/dict><span></span></pre></td></tr></table></div><p>The <code>IONameMatch</code> key contains an array of several possible names. Note that there is no <code>IONameMatched</code> key in this personality. <span class="content_text"><a href="IOService.html#//apple_ref/doc/uid/TP30000697-CACGCCGJ">Listing 3-3</a></span> shows part of the I/O Registry entry for the GossamerPE after the I/O Kit matched and loaded it for a particular device:</p><a name="//apple_ref/doc/uid/TP30000697-CACGCCGJ" title="Listing 3-3Partial I/O Registry entry for GossamerPE"></a><p class="codesample"><strong>Listing 3-3&nbsp;&nbsp;</strong>Partial I/O Registry entry for GossamerPE</p><div class="codesample"><table><tr><td scope="row"><pre>GossamerPE  &lt;class GossamerPE><span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    "IOClass" = "GossamerPE"<span></span></pre></td></tr><tr><td scope="row"><pre>    "IOProviderClass" = "IOPlatformExpertDevice"<span></span></pre></td></tr><tr><td scope="row"><pre>    "IONameMatched" = "PowerMac1,1"<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_375"></a><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_376"></a>The <code>IOResourceMatch<a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_377"></a></code> key declares a dependency or connection between your driver and a specific resource, such as the BSD kernel or a particular resource on a device, like an audio-video jack. If you add the key-value pair</p><div class="codesample"><table><tr><td scope="row"><pre>&lt;key>IOResourceMatch&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>&lt;string>IOBSD&lt;/string><span></span></pre></td></tr></table></div><p>to your driver’s personality, for example, your driver will not load until the resource, in this case the BSD kernel, is available. In this way, you can effectively stall the loading of your driver until its required resource is available. You can examine the available resources in IOResources<a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_378"></a> on a running Mac OS X system using the I/O Registry Explorer application (available in <code>/Developer/Applications</code>). In the IOService plane (I/O Registry Explorer’s default plane), click Root, click the platform expert device for your machine (such as PowerMac3,3), and then click IOResources.</p><p>The remaining passive-matching keys, <code>IOParentMatch<a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_379"></a></code> and <code>IOPathMatch<a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_380"></a></code>, are useful for user-space driver-client matching and are very rarely used in in-kernel driver personalities. These keys depend on information about the location of an object or service in the I/O Registry rather than on the device-specific or service-specific information a nub publishes. An application developer can examine the I/O Registry to determine the location of a specific object and create a matching dictionary using that information. This is much more difficult for an in-kernel driver developer, however, because accurate I/O Registry location of objects may not be available at development time.<a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_381"></a><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_382"></a><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_383"></a></p><a name="//apple_ref/doc/uid/TP30000697-TPXREF102" title="Driver State"></a><h3>Driver State</h3><p><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_384"></a>IOService<a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_385"></a> provides some methods that give you information about an IOService object’s state<a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_386"></a> which is described in the IOService private instance variable <code>state<a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_387"></a></code>. You can view the states of objects currently attached in the I/O Registry by typing <code>ioreg -s</code> on the command line.</p><p>When a driver is in the midst of registration, matching, or termination, its busy state is set to one. When these activities conclude, the busy state is reduced to zero. Any change in an IOService object’s busy state causes an identical change in its provider’s busy state, so that a driver or other IOService object is considered busy when any of its clients is busy.</p><p>A driver may need to wait for a change in another IOService object’s state. The <code>waitQuiet</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_388"></a>method allows a driver to block until the specified IOService object’s busy state is zero.</p><p>A driver can call the <code>adjustBusy</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_389"></a> method to mark itself busy if, for example, it wishes to asynchronously probe a device after exiting from its <code>start</code> method. </p><p>Two IOService methods return information about a driver’s stage in its life cycle. The <code>isOpen</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_390"></a> method determines if a specified client has an IOService object open. If you pass zero instead of a pointer to a particular client object, <code>isOpen</code> returns the open state for all clients of an object.</p><p>The second method, <code>isInactive</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_391"></a>, indicates that an IOService object has been terminated. An inactive object does not support matching, attachments, or notifications.</p><a name="//apple_ref/doc/uid/TP30000697-TPXREF103" title="Resources"></a><h3>Resources</h3><p><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_392"></a><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_393"></a>The I/O Kit’s resource service uses the matching and notification methods usually used for driver objects to make resources available system-wide through IOResources, an instance of IOService<a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_394"></a> attached to the root of the I/O Registry. A resource might be an audio-output jack on a device or a service, such as the BSD kernel. The I/O Kit itself appears as a resource.</p><p>A driver, or other IOService object, can publish a resource in IOResources using the IOService method <code>publishResource</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_395"></a>. The publication of a resource triggers any notifications set on its presence, and the objects holding those notifications can then access the resource.</p><p>The IOKernelDebugger (in the IONetworking family) publishes its presence as a resource in this way:</p><div class="codesample"><table><tr><td scope="row"><pre>publishResource ( "kdp" );<span></span></pre></td></tr></table></div><p>A driver can request a notification about the resource, make the resource a matching condition (as described in<span class="content_text"><a href="IOService.html#//apple_ref/doc/uid/TP30000697-CACHHDHB">“Passive-Matching Keys”</a></span>), or, as in the AppleUSBCDCDriver, call the <code>waitForService</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_396"></a> method to wait until a particular resource appears:</p><div class="codesample"><table><tr><td scope="row"><pre>waitForService ( resourceMatching ( "kdp" ) );<span></span></pre></td></tr></table></div><p>The <code>waitForService</code> method allows an IOService object to block until the object matching the specified matching dictionary is registered. Optionally, a driver can also specify a maximum time to wait.<a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_397"></a><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_398"></a><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_399"></a></p><a name="//apple_ref/doc/uid/TP30000697-TPXREF104" title="User Clients"></a><h3>User Clients</h3><p>IOService<a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_400"></a> provides the <code>newUserClient</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_401"></a> method for families that support user clients<a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_402"></a>. A family that provides user clients implements the <code>newUserClient</code> method to create a connection between a user-space client application and an in-kernel user-client object. </p><p>The default implementation of <code>newUserClient</code> looks up the <code>IOUserClientClass</code> key in the given IOService object’s properties. If the key is found, IOService creates an instance of the class given in the value. Then, it calls the methods <code>initWithTask</code>, <code>attach</code>, and <code>start</code> on the newly instantiated user-client class object. If, on the other hand, there is no <code>IOUserClientClass</code> key (or its value is invalid) or any of the initialization methods fail, IOService returns <code>kIOReturnUnsupported</code>.</p><p>For more information on implementing a user-client object, see <span class="content_text"><a href="../MakingHWAccessible/MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCCJDEH">“Making Hardware Accessible to Applications.”</a></span></p><a name="//apple_ref/doc/uid/TP30000697-TPXREF105" title="Probing"></a><h3>Probing</h3><p>In addition<a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_403"></a> to the <code>probe</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_404"></a> method your driver can choose to implement to examine a device during the matching process (described in detail in <em><a href="../../IOKitFundamentals/index.html#//apple_ref/doc/uid/TP0000011" target="_top"> I/O Kit Fundamentals</a></em>), IOService<a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_405"></a> provides the <code>requestProbe</code> method for discovering newly added or removed devices. The <code>requestProbe</code> method gives the families that do not automatically detect device addition and removal a way to rescan the bus and publish new devices and detach removed devices.</p><p>A family, or perhaps a bus-controller driver, implements <code>requestProbe</code> and passes it a set of options contained in an object of type IOOptionBits, which is not interpreted by IOService.</p><a name="//apple_ref/doc/uid/TP30000697-TPXREF106" title="Notifications and Driver Messaging"></a><h2>Notifications and Driver Messaging</h2><p><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_406"></a>A driver frequently communicates with other entities in the I/O Registry to perform its functions. During the course of its life, a driver must be prepared to receive status and other types of messages from its provider, register for and receive notifications of various events, and send messages to its clients. IOService provides a small number of methods to handle these tasks.</p><a name="//apple_ref/doc/uid/TP30000697-TPXREF107" title="Notification Methods"></a><h3>Notification Methods</h3><p><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_407"></a>The <code>addNotification</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_408"></a> method expects a pointer to a notification handler that IOService calls when the specified IOService object attains the specified state. For example, a driver might need to know when a particular IOService object is published. <span class="content_text"><a href="IOService.html#//apple_ref/doc/uid/TP30000697-CACHAIAE">Listing 3-4</a></span> shows how an instance of IOBSDConsole requests notification of the appearance of an IOHIKeyboard object:</p><a name="//apple_ref/doc/uid/TP30000697-CACHAIAE" title="Listing 3-4Using the addNotification method"></a><p class="codesample"><strong>Listing 3-4&nbsp;&nbsp;</strong>Using the <code>addNotification</code> method</p><div class="codesample"><table><tr><td scope="row"><pre>OSObject * notify;<span></span></pre></td></tr><tr><td scope="row"><pre>notify = addNotification( gIOPublishNotification,<span></span></pre></td></tr><tr><td scope="row"><pre>    serviceMatching( "IOHIKeyboard" ),<span></span></pre></td></tr><tr><td scope="row"><pre>    ( IOServiceNotificationHandler )<span></span></pre></td></tr><tr><td scope="row"><pre>        &amp;IOBSDConsole::publishNotificationHandler,<span></span></pre></td></tr><tr><td scope="row"><pre>    this, 0 );<span></span></pre></td></tr><tr><td scope="row"><pre>assert( notify );<span></span></pre></td></tr></table></div><p>The first parameter <code>addNotification</code> expects is of class OSSymbol; it defines the type of event or status change. IOService delivers the notification types shown in <span class="content_text"><a href="IOService.html#//apple_ref/doc/uid/TP30000697-CACEDDBD">Table 3-2</a></span>.</p><a name="//apple_ref/doc/uid/TP30000697-CACEDDBD" title="Table 3-2Notification types and events"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 3-2&nbsp;&nbsp;</strong>Notification types and events</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Notification type</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Event type</p></th></tr><tr><td  scope="row"><p><code>gIOPublishNotification</code></p></td><td ><p>An IOService object is newly registered.</p></td></tr><tr><td  scope="row"><p><code>gIOFirstPublishNotification</code></p></td><td ><p>Similar to <code>gIOPublishNotification</code>, but delivered only once for each IOService instance, even if the object is reregistered when its state changes.</p></td></tr><tr><td  scope="row"><p><code>gIOMatchedNotification</code></p></td><td ><p>An IOService object is matched with all client objects, which have all been started.</p></td></tr><tr><td  scope="row"><p><code>gIOFirstMatchNotification</code></p></td><td ><p>Similar to <code>gIOMatchedNotification</code>, but delivered only once for each IOService instance, even if the object is reregistered when its state changes.</p></td></tr><tr><td  scope="row"><p><code>gIOTerminatedNotification</code></p></td><td ><p>An IOService object is terminated during its <code>finalize</code> stage.</p></td></tr></table></div><p>The second parameter is a dictionary describing the IOService object to match on. In <span class="content_text"><a href="IOService.html#//apple_ref/doc/uid/TP30000697-CACHAIAE">Listing 3-4</a></span>, the IOBSDConsole object uses the IOService method <code>serviceMatching</code> (introduced in <span class="content_text"><a href="IOService.html#//apple_ref/doc/uid/TP30000697-CACFFDHD">“Driver Matching”</a></span>) to create a dictionary with the class name IOHIKeyboard. When a matching object is published in the I/O Registry, IOService calls the notification-handling method passed to <code>addNotification</code> in the third parameter<a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_409"></a>.</p><p><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_410"></a>IOService calls the notification handler with a reference to each of the matching IOService objects that attain the specified state, beginning with the objects already in that state. The notification handler code can then use that reference in any way it chooses. Often, as in the case of the IOBSDConsole object, the notification handler examines one of the properties of the matching IOService object to update its own object’s properties. <span class="content_text"><a href="IOService.html#//apple_ref/doc/uid/TP30000697-CACCFAED">Listing 3-5</a></span> shows a fragment of the IOBSDConsole’s notification-handler code.</p><a name="//apple_ref/doc/uid/TP30000697-CACCFAED" title="Listing 3-5Implementing a notification-handling method"></a><p class="codesample"><strong>Listing 3-5&nbsp;&nbsp;</strong>Implementing a notification-handling method</p><div class="codesample"><table><tr><td scope="row"><pre>bool IOBSDConsole::publishNotificationHandler( IOBSDConsole * self,<span></span></pre></td></tr><tr><td scope="row"><pre>    void * ref, IOService * newService ) {<span></span></pre></td></tr><tr><td scope="row"><pre>    IOHIKeyboard * keyboard = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    IOService * audio = 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if ( ref ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        audio = OSDynamicCast( IOService,<span></span></pre></td></tr><tr><td scope="row"><pre>            newService->metaCast( "IOAudioStream" ) );<span></span></pre></td></tr><tr><td scope="row"><pre>        if ( audio != 0 ) {<span></span></pre></td></tr><tr><td scope="row"><pre>            OSNumber * out;<span></span></pre></td></tr><tr><td scope="row"><pre>            out = OSDynamicCast( OSNumber, newService->getProperty( "Out" );<span></span></pre></td></tr><tr><td scope="row"><pre>            if ( out ) {<span></span></pre></td></tr><tr><td scope="row"><pre>                if ( out->unsigned8BitValue == 1 ) {<span></span></pre></td></tr><tr><td scope="row"><pre>                    self->fAudioOut = newService;<span></span></pre></td></tr><tr><td scope="row"><pre>                }<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else { /* Handle other case here */ }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The <code>installNotification</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_411"></a> method is very similar to the <code>addNotification</code> method, except that you pass it an object of class OSIterator into which the method places an iterator over the set of matching IOService objects currently in the specified state.<a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_412"></a><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_413"></a><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_414"></a></p><a name="//apple_ref/doc/uid/TP30000697-TPXREF108" title="Messaging Methods"></a><h3>Messaging Methods</h3><p><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_415"></a>The primary lines of communication between a driver and its provider and clients are the messaging methods. In order to receive messages from its provider, your driver must implement the <code>message</code> method. To send messages to its clients, your driver must implement the <code>messageClient</code> or <code>messageClients</code> method.</p><p>Frequently, your driver will receive messages defined by the I/O Kit in <code>IOMessage.h</code> (available in <code>/System/Library/Frameworks/Kernel.framework/Headers/IOKit</code>), but your driver’s family may also define its own messages. The IOUSBDevice class, for example, implements the <code>message</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_416"></a> method to handle a number of USB family-specific messages, in addition to messages defined in <code>IOMessage.h</code>. <span class="content_text"><a href="IOService.html#//apple_ref/doc/uid/TP30000697-CACJJCEJ">Listing 3-6</a></span> shows a fragment of IOUSBDevice’s implementation of the <code>message</code> method.</p><a name="//apple_ref/doc/uid/TP30000697-CACJJCEJ" title="Listing 3-6Implementing the message method"></a><p class="codesample"><strong>Listing 3-6&nbsp;&nbsp;</strong>Implementing the <code>message</code> method</p><div class="codesample"><table><tr><td scope="row"><pre>IOReturn IOUSBDevice::message( UInt32 type, IOService * provider, void<span></span></pre></td></tr><tr><td scope="row"><pre>     *argument ) {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* local variable declarations */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    switch ( type ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        case kIOUSBMessagePortHasBeenReset:<span></span></pre></td></tr><tr><td scope="row"><pre>            /* handle this case */<span></span></pre></td></tr><tr><td scope="row"><pre>        case kIOUSBMessageHubIsDeviceConnected:<span></span></pre></td></tr><tr><td scope="row"><pre>            /* handle this case */<span></span></pre></td></tr><tr><td scope="row"><pre>        case kIOUSBMessagePortHasBeenResumed:<span></span></pre></td></tr><tr><td scope="row"><pre>            /* handle this case */<span></span></pre></td></tr><tr><td scope="row"><pre>        /* handle messages defined in IOMessage.h */<span></span></pre></td></tr><tr><td scope="row"><pre>        /* ... */<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>A provider uses the <code>messageClient</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_417"></a> and <code>messageClients</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_418"></a> methods to send messages to its clients. Although you can override the <code>messageClient</code> method, you rarely need to do so unless, for example, you’re writing a framework. IOService implements the <code>messageClients</code> method by applying the <code>messageClient</code> method to each client in turn. Referring again to the IOUSBDevice implementation of <code>message</code> (shown in <span class="content_text"><a href="IOService.html#//apple_ref/doc/uid/TP30000697-CACJJCEJ">Listing 3-6</a></span>), an instance of IOUSBDevice calls <code>messageClients</code> on its clients to forward the messages it received from its provider, as in the following code fragment:<a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_419"></a><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_420"></a></p><div class="codesample"><table><tr><td scope="row"><pre>/* Previous cases of the switch statement handled here. */<span></span></pre></td></tr><tr><td scope="row"><pre>case kIOUSBMessagePortHasBeenResumed:<span></span></pre></td></tr><tr><td scope="row"><pre>    // Forward the message to our clients.<span></span></pre></td></tr><tr><td scope="row"><pre>    messageClients( kIOUSBMessagePortHasBeenResumed, this, _portNumber );<span></span></pre></td></tr><tr><td scope="row"><pre>    break;<span></span></pre></td></tr><tr><td scope="row"><pre>/* Following cases of the switch statement handled here. */<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000697-TPXREF109" title="Access Methods"></a><h2>Access Methods</h2><p><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_421"></a>IOService provides a number of methods you can use to access your driver’s provider, clients, and various other objects in the I/O Registry. A few of these methods are for internal use only, but most are available for your driver to call when it needs to access other objects currently in the I/O Registry.</p><a name="//apple_ref/doc/uid/TP30000697-TPXREF110" title="Getting Work Loops"></a><h3>Getting Work Loops</h3><p>Perhaps the most widely used IOService access method is <code>getWorkLoop</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_422"></a>. Any time you need to ensure single-threaded access to data structures or handle asynchronous events, such as timer events or I/O commands driver clients issue to their providers, you should use a work loop<a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_423"></a>. For extensive information on the architecture and use of work loops, see <em><a href="../../IOKitFundamentals/index.html#//apple_ref/doc/uid/TP0000011" target="_top">I/O Kit Fundamentals</a></em>.</p><p>Many drivers can successfully share their provider’s work loop to protect sensitive data and handle events. A call to <code>getWorkLoop</code> returns your provider’s work loop or, if you provider does not have one, the work loop of the object below your provider in the driver stack. At the root of the I/O Registry, the IOPlatformExpertDevice object holds a system-wide work loop your driver can share, even if your providers do not have work loops.</p><p>The ApplePCCardSample driver gets the PCCard family work loop with the following lines of code:</p><div class="codesample"><table><tr><td scope="row"><pre>IOWorkLoop * workLoop;<span></span></pre></td></tr><tr><td scope="row"><pre>workLoop = getWorkLoop();<span></span></pre></td></tr><tr><td scope="row"><pre>if ( !workLoop ) {<span></span></pre></td></tr><tr><td scope="row"><pre>    /* Handle error. */<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_70" title="Note"></a><p><strong>Note:</strong>&nbsp;You can find the code for the ApplePCCardSample driver in <code>/Developer/Examples/Kernel/IOKit/pccard</code>.</p></div><p>Although most drivers do not need to create their own work loops, a driver for a PCI controller or PCI device or any driver that interacts directly with an interrupt controller should create its own, dedicated work loop. For an example of how to do this, see <em><a href="../../IOKitFundamentals/index.html#//apple_ref/doc/uid/TP0000011" target="_top">I/O Kit Fundamentals</a></em>.</p><a name="//apple_ref/doc/uid/TP30000697-TPXREF111" title="Getting Clients and Providers"></a><h3>Getting Clients and Providers</h3><p>The methods for accessing providers and clients fall into two categories: Those that return the provider or client object itself and those that return an iterator over a set of providers or clients. The methods in the first category, <code>getClient</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_424"></a> and <code>getProvider</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_425"></a>, return an IOService object’s primary client and primary provider, respectively. IOService defines the primary client as the first client to attach to the IOService object and the primary provider as the provider to which the IOService object first attached. Most often, your driver will have only one provider and one client, so these methods provide a convenient way to access them without having to further specify the provider or client you want.</p><p>The IOService objects returned by the <code>getClient</code> and <code>getProvider</code> methods should not be released by the caller. The client object is retained as long as it is attached and the provider object is retained as long as the client is attached to it. It is unlikely you will need to override these methods, but one possibility is implementing them to narrow down the type of IOService object returned. For example, as a convenience to subclass developers, the IOCDMedia object overrides its superclass’s <code>getProvider</code> method to return IOCDBlockStorageDriver rather than the more generic IOService:</p><div class="codesample"><table><tr><td scope="row"><pre>IOCDBlockStorageDriver * IOCDMedia::getProvider() const<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return (IOCDBlockStorageDriver *) IOService::getProvider();<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The methods <code>getClientIterator</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_426"></a>, <code>getOpenClientIterator</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_427"></a>, <code>getProviderIterator</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_428"></a>, and <code>getOpenProviderIterator</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_429"></a> comprise the set of IOService client-provider access methods that return iterators. When you use <code>getClientIterator</code> or <code>getProviderIterator</code> to access your driver’s clients or providers, each object the iterator returns is retained as long as the iterator is valid, although it is possible that the object may detach itself from the I/O Registry during the iteration. In addition, you must release the iterator when you are finished with the iteration. <span class="content_text"><a href="IOService.html#//apple_ref/doc/uid/TP30000697-CACBADCA">Listing 3-7</a></span> shows how the IOFireWireAVCUnit object uses <code>getClientIterator</code> to check for existing subunits before creating a new one.</p><a name="//apple_ref/doc/uid/TP30000697-CACBADCA" title="Listing 3-7getClientIterator example"></a><p class="codesample"><strong>Listing 3-7&nbsp;&nbsp;</strong><code>getClientIterator</code> example</p><div class="codesample"><table><tr><td scope="row"><pre>/* Create propTable property table with the subunit type property. */<span></span></pre></td></tr><tr><td scope="row"><pre>OSIterator * childIterator;<span></span></pre></td></tr><tr><td scope="row"><pre>IOFireWireAVCSubUnit * found = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>childIterator = getClientIterator();<span></span></pre></td></tr><tr><td scope="row"><pre>if ( childIterator ) {<span></span></pre></td></tr><tr><td scope="row"><pre>    OSObject * child;<span></span></pre></td></tr><tr><td scope="row"><pre>    while ( ( child = childIterator->getNextObject() ) ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        found = OSDynamicCast( IOFireWireAVCSubUnit, child );<span></span></pre></td></tr><tr><td scope="row"><pre>        if ( found &amp;&amp; found->matchPropertyTable( propTable ) ) {<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        else<span></span></pre></td></tr><tr><td scope="row"><pre>            found = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    childIterator->release();<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( found )<span></span></pre></td></tr><tr><td scope="row"><pre>        /* Continue searching for existing subunits. */<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The <code>getOpenClientIterator</code> and <code>getOpenProviderIterator</code> methods differ from the <code>getClientIterator</code> and <code>getProviderIterator</code> methods in two important ways. First, as their names suggest, <code>getOpenClientIterator</code> and <code>getOpenProviderIterator</code> return iterators for only the open clients and providers. For <code>getOpenClientIterator</code>, this means an iterator for a provider’s clients that have opened the provider, and for <code>getOpenProviderIterator</code>, it means an iterator for a client’s providers that the client currently has open. Second, IOService uses the <code>lockForArbitration</code> method to lock the current object in the iteration so that its state does not change while you are accessing it.</p><p>The <code>getOpenClientIterator</code> and <code>getOpenProviderIterator</code> methods mirror the <code>getClientIterator</code> and <code>getProviderIterator</code> methods in that the objects the iterator returns are retained as long as the iterator is valid and in that you must release the iterator when you no longer need it.<a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_430"></a><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_431"></a></p><a name="//apple_ref/doc/uid/TP30000697-TPXREF112" title="Getting Other I/O Kit Objects"></a><h3>Getting Other I/O Kit Objects</h3><p>The remaining IOService access methods are:</p><ul class="spaceabove"><li class="li"><p><code>getPlatform</code></p></li><li class="li"><p><code>getResources</code></p></li><li class="li"><p><code>getState</code></p></li></ul><p>Of these three, two are used almost exclusively by the I/O Kit and IOService. The <code>getResources</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_432"></a> method allows for lazy allocation of resources during the registration process for an IOService object by deferring the allocation until a matching driver is found for the object. The <code>getState</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_433"></a> method returns the IOService state for an IOService object and is not typically used outside of IOService’s internal implementations.</p><p>In the unlikely event that your driver needs to find out which platform it is running on, it can call the <code>getPlatform</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_434"></a> method, as in this example that determines the platform’s computer type:</p><div class="codesample"><table><tr><td scope="row"><pre>if ( getPlatform()->getMachineType() == kGossamerTypeYosemite )<span></span></pre></td></tr><tr><td scope="row"><pre>    /* Do something here. */<span></span></pre></td></tr></table></div><p>The <code>getPlatform</code> method gives you a reference to the platform expert instance for the computer you’re currently running on. With this reference, you can then call platform expert methods, such as <code>getModelName</code> and <code>getMachineName</code> to get specific information about it (for more information on platform expert methods, see <code>/System/Library/Frameworks/Kernel.framework/Headers/IOKit/IOPlatformExpert.h</code>).<a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_435"></a></p><a name="//apple_ref/doc/uid/TP30000697-TPXREF113" title="Power Management"></a><h2>Power Management</h2><p><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_436"></a>On a Mac OS X system, changes in power state can happen at any time. Whether it is due to the hot-unplugging of a device or system sleep, your driver must be prepared to handle a change in its power state whenever it happens.</p><p>The IOService class includes a large number of methods related to power management but unless your driver serves as a policy maker or as the power controller for your device, you will probably not need to implement or call any of them.</p><p>This section briefly introduces policy makers and power controllers and how they can interact with your driver to give context for the IOService power management methods. For more information on power management in general and how to implement policy makers and power controllers in particular, see<em><a href="../../IOKitFundamentals/index.html#//apple_ref/doc/uid/TP0000011" target="_top"> I/O Kit Fundamentals</a></em>.</p><p>The power-management subsystem of a Mac OS X system is responsible for providing enough power to function at the required level while at the same time prolonging display life and conserving power. To do this, power management keeps track of the power needs and states of all devices and subsystems, and uses that information to make power-supply decisions.</p><a name="//apple_ref/doc/uid/TP30000697-TPXREF114" title="Power-Management Entities"></a><h3>Power-Management Entities</h3><p>A power domain<a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_437"></a> is a switchable source of power in the system that provides power for one or more devices considered to be members of the domain. The root power domain represents the main power of the Mac OS X system itself and contains all other power domains. You can view the (current) hierarchical structure of the root power domain and all its dependent domains in the I/O Registry’s IOPower plane by entering <code>ioreg -p IOPower</code> at the command line.</p><p>Each entity in power management, such as a power domain or device, is represented by an object that inherits from the IOService class. The power management methods IOService provides allow all power-management objects to communicate with each other to manage the power usage of the system.</p><p>Two types of power-management objects perform most of the power-related tasks for the system: policy makers<a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_438"></a> and power controllers<a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_439"></a>. A policy maker is usually an instance of an I/O Kit family class, but it can be any object at an appropriate level in a driver stack. The policy maker for a device (or domain) considers factors such as aggressiveness (a measure of how urgently a device should conserve power) when making decisions that affect the power level of that device or domain.</p><p>As its name suggests, the power controller for a device is the expert on that device’s power capabilities and carries out the decisions of the policy maker. The communication between policy maker and power controller flows in both directions: The policy maker decides to change the power state of a device and tells the power controller and the power controller gives the policy maker information about the device that helps the policy maker make its decisions.</p><p>Because a policy maker needs to know about the type of device being controlled, including its power-usage patterns, it is usually implemented as an instance of an I/O Kit family class. For the same reasons, an I/O Kit family class may also choose to implement a power controller for its devices, although it is more common for the driver that actually controls a device’s I/O to be that device’s power controller. It's important to read the documentation for the family to which your driver belongs, because each family may apportion power management tasks a little differently.</p><a name="//apple_ref/doc/uid/TP30000697-TPXREF115" title="Using the Power Management Methods"></a><h3>Using the Power Management Methods</h3><p>If you are implementing a driver that represents physical hardware, such as a PCI device, or a physical subsystem, such as an Ethernet driver, you may be responsible for being both policy maker and power controller for your device. At minimum, you should be familiar with the following subset of IOService power management methods:</p><ul class="spaceabove"><li class="li"><p><code>PMinit</code></p></li><li class="li"><p><code>PMstop</code></p></li><li class="li"><p><code>joinPMTree</code></p></li><li class="li"><p><code>registerPowerDriver</code></p></li><li class="li"><p><code>changePowerStateTo</code></p></li><li class="li"><p><code>setAggressiveness</code></p></li><li class="li"><p><code>setPowerState</code></p></li><li class="li"><p><code>activityTickle</code></p></li><li class="li"><p><code>setIdleTimerPeriod</code></p></li><li class="li"><p><code>acknowledgePowerChange</code></p></li><li class="li"><p><code>acknowledgeSetPowerState</code></p></li></ul><p>If your driver is serving as the power controller for your device, it should first create an array of structures that describe your device’s power requirements and capabilities. Each structure is of type <code>IOPMPowerState</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_440"></a> (declared in <code>IOPMpowerState.h</code> available at <code>/System/Library/Frameworks/Kernel.framework/Headers/IOKit/pwr_mgt</code>). For example, the ApplePCCardSample driver defines the following array:</p><div class="codesample"><table><tr><td scope="row"><pre>static const IOPMPowerState myPowerStates[ kIOPCCard16DevicePowerStateCount ]<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },<span></span></pre></td></tr><tr><td scope="row"><pre>    { 1, 0, IOPMSoftSleep, IOPMSoftSleep, 0, 0, 0, 0, 0, 0, 0, 0 },<span></span></pre></td></tr><tr><td scope="row"><pre>    { 1, IOPMPowerOn, IOPMPowerOn, IOPMPowerOn, 0, 0, 0, 0, 0, 0, 0, 0 }<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><p>In order for a policy maker or a power controller to participate in the power-management subsystem, it must first initialize the protected power-management instance variables in the IOPMpriv and IOPMprot objects (for more information on these objects, see<em><a href="../../IOKitFundamentals/index.html#//apple_ref/doc/uid/TP0000011" target="_top"> I/O Kit Fundamentals</a></em>). A driver does this by calling the <code>PMinit</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_441"></a> method, typically in its <code>start</code> method. At the end of a driver’s life span, usually in its <code>stop</code> method, a driver resigns its power-management responsibilities and disables its power-management participation by calling the <code>PMstop</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_442"></a> method, which erases the IOPMpriv and IOPMprot objects and serves to de-register the driver.</p><p>Not surprisingly, different I/O Kit families can handle the exact distribution of power-management responsibilities in different ways. For example, in its <code>stop</code> method, the IOFramebuffer superclass calls <code>PMstop</code> automatically for all its subclasses, so an IOFramebuffer subclass should not call <code>PMstop</code> itself. Before implementing power management in your driver, therefore, be sure to find out how your driver’s I/O Kit family assigns power-management responsibilities.</p><p>After creating the array of power states, your driver can then volunteer as the power controller<a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_443"></a> for your device by calling the method <code>registerPowerDriver</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_444"></a>, passing it a pointer to itself, the power state array, and the number of states in the array, as in this example from ApplePCCardSample’s <code>start</code> method:</p><div class="codesample"><table><tr><td scope="row"><pre>registerPowerDriver ( this, (IOPMPowerState *) myPowerStates,<span></span></pre></td></tr><tr><td scope="row"><pre>                    kIOPCCard16DevicePowerStateCount );<span></span></pre></td></tr></table></div><p>Although the <code>PMinit</code> method initializes the power-management variables, it does not attach the calling driver to the power-management hierarchy, or tree. Therefore, after registering as the power controller, the ApplePCCardSample then becomes a member of the power-management tree by calling the <code>joinPMTree</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_445"></a> method on its provider:</p><div class="codesample"><table><tr><td scope="row"><pre>provider->joinPMtree ( this );<span></span></pre></td></tr></table></div><p>When a power-controller driver needs to change its power state, it calls the <code>changePowerStateTo</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_446"></a> method, passing in the ordinal value of the desired power state in the power state array. Conversely, when a policy maker needs to tell a power controller to change its power state, the policy maker calls the <code>setPowerState</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_447"></a> method. It passes in the ordinal value of the desired power state in the power state array and a pointer to the particular IOService object whose power state the power controller should change.</p><p><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_448"></a>Aggressiveness<a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_449"></a> is a measure of how aggressive the power-management subsystem should be in conserving power. Policy makers need to be aware of the current aggressiveness in order to appropriately determine when a device or domain is idle. In general, a policy maker should implement the <code>setAggressiveness</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_450"></a> method to receive information about changes in aggressiveness, but it should be sure to invoke its superclass’s <code>setAggressiveness</code> method, as well. </p><p>The IODisplayWrangler, for example, is the policy maker for displays. It senses when a display is idle or active and adjusts the power accordingly. The IODisplayWrangler uses aggressiveness levels from its power domain parent in its calculation of an idle-timer period. When the timer expires and no user activity has occurred since the last timer expiration, the IODisplayWrangler lowers the power state of the display. <span class="content_text"><a href="IOService.html#//apple_ref/doc/uid/TP30000697-CACIIGJG">Listing 3-8</a></span> shows IODisplayWrangler’s implementation of the <code>setAggressiveness</code> method.</p><a name="//apple_ref/doc/uid/TP30000697-CACIIGJG" title="Listing 3-8The IODisplayWrangler setAggressiveness method"></a><p class="codesample"><strong>Listing 3-8&nbsp;&nbsp;</strong>The IODisplayWrangler <code>setAggressiveness</code> method</p><div class="codesample"><table><tr><td scope="row"><pre>IOReturn IODisplayWrangler::setAggressiveness( unsigned long type, unsigned<span></span></pre></td></tr><tr><td scope="row"><pre>                                             long newLevel )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if( type == kPMMinutesToDim) {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Minutes to dim received.<span></span></pre></td></tr><tr><td scope="row"><pre>        if( newLevel == 0) {<span></span></pre></td></tr><tr><td scope="row"><pre>            // Power management turned off while idle?<span></span></pre></td></tr><tr><td scope="row"><pre>            if( pm_vars->myCurrentState &lt; kIODisplayWranglerMaxPowerState) {<span></span></pre></td></tr><tr><td scope="row"><pre>                // Yes, bring displays up again.<span></span></pre></td></tr><tr><td scope="row"><pre>                changePowerStateToPriv( kIODisplayWranglerMaxPowerState );<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        fMinutesToDim = newLevel;<span></span></pre></td></tr><tr><td scope="row"><pre>        fUseGeneralAggressiveness = false;<span></span></pre></td></tr><tr><td scope="row"><pre>        // No. Currently in emergency level?<span></span></pre></td></tr><tr><td scope="row"><pre>        if( pm_vars->aggressiveness &lt; kIOPowerEmergencyLevel) {<span></span></pre></td></tr><tr><td scope="row"><pre>            // No, set new timeout.<span></span></pre></td></tr><tr><td scope="row"><pre>            setIdleTimerPeriod( newLevel*60 / 2);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // general factor received.<span></span></pre></td></tr><tr><td scope="row"><pre>    } else if( type == kPMGeneralAggressiveness) {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Emergency level?<span></span></pre></td></tr><tr><td scope="row"><pre>        if( newLevel >= kIOPowerEmergencyLevel ) {<span></span></pre></td></tr><tr><td scope="row"><pre>            // Yes.<span></span></pre></td></tr><tr><td scope="row"><pre>            setIdleTimerPeriod( 5 );<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        else {<span></span></pre></td></tr><tr><td scope="row"><pre>            // No. Coming out of emergency level?<span></span></pre></td></tr><tr><td scope="row"><pre>            if( pm_vars->aggressiveness >= kIOPowerEmergencyLevel ) {<span></span></pre></td></tr><tr><td scope="row"><pre>                if( fUseGeneralAggressiveness) {<span></span></pre></td></tr><tr><td scope="row"><pre>                    // Yes, set new timer period.<span></span></pre></td></tr><tr><td scope="row"><pre>                    setIdleTimerPeriod( (333 - (newLevel/3)) / 2 );<span></span></pre></td></tr><tr><td scope="row"><pre>                }<span></span></pre></td></tr><tr><td scope="row"><pre>                else {<span></span></pre></td></tr><tr><td scope="row"><pre>                    setIdleTimerPeriod( fMinutesToDim * 60 / 2);<span></span></pre></td></tr><tr><td scope="row"><pre>                }<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            else {<span></span></pre></td></tr><tr><td scope="row"><pre>                if( fUseGeneralAggressiveness) {<span></span></pre></td></tr><tr><td scope="row"><pre>                    // No, maybe set period.<span></span></pre></td></tr><tr><td scope="row"><pre>                    setIdleTimerPeriod( (333 - (newLevel/3)) / 2 );<span></span></pre></td></tr><tr><td scope="row"><pre>                }<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    super::setAggressiveness(type, newLevel);<span></span></pre></td></tr><tr><td scope="row"><pre>    return( IOPMNoErr );<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_451"></a>A policy maker uses the <code>activityTickle</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_452"></a> method to help it determine when a device is idle. If the policy maker is solely responsible for determining idleness, it should implement the <code>activityTickle</code> method to intercept any calls by other driver objects and use its own methods to determine idleness periods. In this situation, power-controller drivers call the <code>activityTickle</code> method when there is device activity or for any other reason the device needs to be fully powered, with the <code>kIOPMSubclassPolicy</code> parameter.</p><p>A policy maker that determines idleness in cooperation with IOService, on the other hand, should first call <code>setIdleTimerPeriod</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_453"></a> on its superclass, passing in the number of seconds for the timer interval. If the policy maker needs other objects to inform it of device activity, it should implement <code>activityTickle</code> as described above. When it becomes aware of activity, the policy maker should call <code>activityTickle</code> on its superclass, passing in the <code>kIOPMSubclassPolicy1</code> parameter. Then, when the idle timer expires, the IOService superclass checks to see if <code>activityTickle(kIOPMSubclassPolicy1)</code> has been called on it. If it has, then there has been activity and the IOService superclass restarts the idleness timer. If it hasn’t, and there has been no activity, the IOService superclass calls <code>setPowerState</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_454"></a> on the power controller to tell it to lower the device’s power state to the next lower level.<a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_455"></a></p><p>A policy maker tells interested IOService objects when a device’s power state is changing. In return, such an object can tell the policy maker that it is either prepared for the change or needs time to prepare by calling the <code>acknowledgePowerChange</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_456"></a> method on the policy maker.</p><p>When a policy maker tells a power controller to change a device’s power state, the power controller uses the <code>acknowledgeSetPowerState</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_457"></a> method to tell the policy maker either that it has made the change or that it needs time to make the change.<a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_458"></a></p><a name="//apple_ref/doc/uid/TP30000697-TPXREF116" title="Memory Mapping and Interrupt Handling"></a><h2>Memory Mapping and Interrupt Handling</h2><p>IOService provides a number of methods for low-level access of device memory and interrupt-handling. Most driver writers will not need to use these because the I/O Kit families generally take care of such low-level access. In addition, unless you are implementing an interrupt controller, you should use the interrupt-handling facilities IOInterruptEventSource provides or, for PCI devices, IOFilterInterruptEventSource (both available in <code>/System/Library/Frameworks/Kernel.framework/Headers/IOKit</code>.)</p><p>If you’re writing a device driver for a familyless device, however, you may need to gain direct access to your device’s memory or implement an interrupt-controller driver. This section describes the IOService methods that can help you.</p><a name="//apple_ref/doc/uid/TP30000697-TPXREF117" title="Accessing Device Memory"></a><h3>Accessing Device Memory</h3><p><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_459"></a><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_460"></a>The IOService methods for accessing device memory handle <a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_461"></a>IODeviceMemory objects. IODeviceMemory is a simple subclass of IOMemoryDescriptor<a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_462"></a>, the abstract base class that defines common methods for describing physical or virtual memory. An IODeviceMemory object describes a single range of physical memory on a device and implements a handful of factory methods to create instances with particular memory ranges or subranges.</p><p>You can think of the memory-access methods in IOService as wrappers for IOMemoryDescriptor methods. If your device’s provider is a memory-mapped device, IOService provides it with its own array of memory descriptors (IODeviceMemory objects). The first member of the array might be the IODeviceMemory object that represents the <code>vram</code> and the second might represent the device’s registers. The IOService memory-access methods allow you to specify a member of this array so that you can then create a mapping for it and access the memory it represents.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_71" title="Note"></a><p><strong>Note:</strong>&nbsp;If you are writing a device driver for a PCI device , you can use the API in <code>IOPCIDevice.h</code> (available in <code>/System/Library/Frameworks/Kernel.framework/Headers/IOKit/pci</code>) for more device-specific support.</p></div><p>IOService defines three methods you can use to get information about and access your device’s array of physical memory ranges:</p><ul class="spaceabove"><li class="li"><p><code>getDeviceMemory</code></p></li><li class="li"><p><code>getDeviceMemoryCount</code></p></li><li class="li"><p><code>getDeviceMemoryWithIndex</code></p></li></ul><p>The <code>getDeviceMemory</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_463"></a> method returns the array of IODeviceMemory objects that represent a device’s memory-mapped ranges. It is most likely that you will need to access specific members of this array using the other two methods, but a nub might call <code>getDeviceMemory</code> on its provider and use the returned array in its <code>start</code> method to set up a corresponding array of IODeviceMemory objects.</p><p>The <code>getDeviceMemoryCount</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_464"></a> method returns the number of physical memory ranges available for a device; in effect, it returns a value you can use as an index into the IODeviceMemory array. As its name suggests, <code>getDeviceMemoryWithIndex</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_465"></a> returns the IODeviceMemory object representing a memory-mapped range at the specified index.</p><p>In its <code>start</code> method, the AppleSamplePCI driver uses the <code>getDeviceMemoryCount</code> and <code>getDeviceMemoryWithIndex</code> methods to display all the device’s memory ranges, as shown in <span class="content_text"><a href="IOService.html#//apple_ref/doc/uid/TP30000697-CACBBGIE">Listing 3-9</a></span>.</p><a name="//apple_ref/doc/uid/TP30000697-CACBBGIE" title="Listing 3-9Using getDeviceMemoryCount and getDeviceMemoryWithIndex"></a><p class="codesample"><strong>Listing 3-9&nbsp;&nbsp;</strong>Using <code>getDeviceMemoryCount</code> and <code>getDeviceMemoryWithIndex</code></p><div class="codesample"><table><tr><td scope="row"><pre>bool AppleSamplePCI::start( IOService * provider )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    IOMemoryDescriptor * mem;<span></span></pre></td></tr><tr><td scope="row"><pre>    /* Other code here */<span></span></pre></td></tr><tr><td scope="row"><pre>    fPCIDevice = ( IOPCIDevice * ) provider;<span></span></pre></td></tr><tr><td scope="row"><pre>    /* Use IOPCIDevice API to enable memory response from the device */<span></span></pre></td></tr><tr><td scope="row"><pre>    fPCIDevice->setMemoryEnable( true );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Use IOLog (defined in IOLib.h) to display the device's memory<span></span></pre></td></tr><tr><td scope="row"><pre>        ranges. */<span></span></pre></td></tr><tr><td scope="row"><pre>    for ( UInt32 index = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>        index &lt; fPCIDevice->getDeviceMemoryCount();<span></span></pre></td></tr><tr><td scope="row"><pre>        index++ ) {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        mem = fPCIDevice->getDeviceMemoryWithIndex( index );<span></span></pre></td></tr><tr><td scope="row"><pre>        /* Use assert (defined in IOKit/assert.h) for debugging purposes */<span></span></pre></td></tr><tr><td scope="row"><pre>        IOLog( "Range[%ld] %081x\n", index,<span></span></pre></td></tr><tr><td scope="row"><pre>                mem->getPhysicalAddress(), mem->getLength() );<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    /* Work with a range based on the device's config BAR (base<span></span></pre></td></tr><tr><td scope="row"><pre>     address register) here */<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>AppleSamplePCI’s <code>start</code> method uses an IOMemoryDescriptor object instead of an IODeviceMemory object to contain the object returned by <code>getDeviceMemoryWithIndex</code> because it uses IOMemoryDescriptor’s <code>getPhysicalAddress</code> and <code>getLength</code> methods.</p><p><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_466"></a>IOService provides one device memory–mapping method, <code>mapDeviceMemoryWithIndex</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_467"></a>, that maps a physical memory range of a device at the given index (passed in the first parameter). The second parameter of the <code>mapDeviceMemoryWithIndex</code> method contains the same options IOMemoryDescriptor’s <code>map</code> method uses (defined in <code>/System/Library/Frameworks/IOKit.framwork/Headers/IOTypes.h</code>), as shown in <span class="content_text"><a href="IOService.html#//apple_ref/doc/uid/TP30000697-CACHGDEF">Table 3-3</a></span>:</p><a name="//apple_ref/doc/uid/TP30000697-CACHGDEF" title="Table 3-3Memory-mapping options for mapDeviceMemoryWithIndex"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 3-3&nbsp;&nbsp;</strong>Memory-mapping options for <code>mapDeviceMemoryWithIndex</code></caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Option name</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code>kIOMapAnywhere</code></p></td><td ><p>Create the mapping anywhere.</p></td></tr><tr><td  scope="row"><p><code>kIOMapInhibitCache</code>, <code>kIOMapDefaultCache</code>, <code>kIOMapCopybackCache</code>, <code>kIOMapWriteThruCache</code></p></td><td ><p>Set the appropriate caching.</p></td></tr><tr><td  scope="row"><p><code>kIOMapReadOnly</code></p></td><td ><p>Allow only read-only access to the mapped memory.</p></td></tr><tr><td  scope="row"><p><code>kIOMapReference</code></p></td><td ><p>Create a new reference to a preexisting mapping.</p></td></tr></table></div><p>If you choose to specify a combination of these options, you use a variable of type <code>IOOptionsBits</code> and perform a logical <code>OR</code> on the options you want.</p><p>Further along in its <code>start</code> method, the ApplePCCardSample driver calls the <code>mapDeviceMemoryWithIndex</code> method on its nub, using the number of windows (or mappings) the nub has created as the index, as <span class="content_text"><a href="IOService.html#//apple_ref/doc/uid/TP30000697-CACIEBGE">Listing 3-10</a></span> shows.</p><a name="//apple_ref/doc/uid/TP30000697-CACIEBGE" title="Listing 3-10Part of the ApplePCCardSample class declaration"></a><p class="codesample"><strong>Listing 3-10&nbsp;&nbsp;</strong>Part of the ApplePCCardSample class declaration</p><div class="codesample"><table><tr><td scope="row"><pre>/* From ApplePCCardSample class declaration: */<span></span></pre></td></tr><tr><td scope="row"><pre>unsigned windowCount;<span></span></pre></td></tr><tr><td scope="row"><pre>IOMemoryMap * windowMap[10];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Other initialization and configuration performed here. */<span></span></pre></td></tr><tr><td scope="row"><pre>/* ... */<span></span></pre></td></tr><tr><td scope="row"><pre>/* Find out how many windows we have configured. */<span></span></pre></td></tr><tr><td scope="row"><pre>windowCount = nub->getWindowCount();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Map in the windows. */<span></span></pre></td></tr><tr><td scope="row"><pre>for ( unsigned i = 0; i &lt; windowCount; i++ ) {<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 attributes;<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( !nub->getWindowAttributes( i, &amp;attributes ))<span></span></pre></td></tr><tr><td scope="row"><pre>        /* Log error. */<span></span></pre></td></tr><tr><td scope="row"><pre>    windowMap[i] = nub->mapDeviceMemoryWithIndex( i );<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( !windowMap[i] )<span></span></pre></td></tr><tr><td scope="row"><pre>        /* Log error, call stop on provider, and return false from start. */<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000697-TPXREF118" title="Handling Interrupts"></a><h3>Handling Interrupts</h3><p><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_468"></a><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_469"></a><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_470"></a><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_471"></a>The vast majority of drivers should use the interrupt-handling facilities the IOInterruptEventSource class provides. The work-loop mechanism provides a safe, easy way to handle all types of asynchronous events, including interrupts.</p><p>For interrupt-controller or PCI device driver developers, however, IOService provides a handful of methods for low-level interrupt handling, outside the work-loop mechanism:</p><ul class="spaceabove"><li class="li"><p><code>getInterruptType</code></p></li><li class="li"><p><code>causeInterrupt</code></p></li><li class="li"><p><code>disableInterrupt</code></p></li><li class="li"><p><code>enableInterrupt</code></p></li><li class="li"><p><code>registerInterrupt</code></p></li><li class="li"><p><code>unregisterInterrupt</code></p></li></ul><p>The first task in implementing an interrupt controller is to determine which type of interrupt the device uses, edge-triggered or level-sensitive. Most PCI devices use level-sensitive interrupts by specification. The <code>getInterruptType</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_472"></a> method is valid even before you register your interrupt handler so you can choose which handler to register based on the type of the interrupt. The implementation of IOInterruptEventSource does just this in its <code>init</code> method, as <span class="content_text"><a href="IOService.html#//apple_ref/doc/uid/TP30000697-CACFFGDB">Listing 3-11</a></span> shows.</p><a name="//apple_ref/doc/uid/TP30000697-CACFFGDB" title="Listing 3-11Determining interrupt type with getInterruptType"></a><p class="codesample"><strong>Listing 3-11&nbsp;&nbsp;</strong>Determining interrupt type with <code>getInterruptType</code></p><div class="codesample"><table><tr><td scope="row"><pre>bool IOInterruptEventSource::init( OSObject *inOwner,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    Action inAction = 0,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    IOService *inProvider = 0,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    int inIntIndex = 0 )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    bool res = true;<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( !super::init( inOwner, ( IOEventSourceAction) inAction ) )<span></span></pre></td></tr><tr><td scope="row"><pre>            return false;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    provider = inProvider;<span></span></pre></td></tr><tr><td scope="row"><pre>    autoDisable = false;<span></span></pre></td></tr><tr><td scope="row"><pre>    intIndex = -1;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if ( inProvider ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        int intType;<span></span></pre></td></tr><tr><td scope="row"><pre>        res = ( kIOReturnSuccess ==<span></span></pre></td></tr><tr><td scope="row"><pre>            inProvider->getInterruptType( intIntIndex, &amp;intType ) );<span></span></pre></td></tr><tr><td scope="row"><pre>        if ( res ) {<span></span></pre></td></tr><tr><td scope="row"><pre>            IOInterruptAction intHandler;<span></span></pre></td></tr><tr><td scope="row"><pre>            autoDisable = ( intType == kIOInterruptTypeLevel );<span></span></pre></td></tr><tr><td scope="row"><pre>            if ( autoDisable ) {<span></span></pre></td></tr><tr><td scope="row"><pre>                intHandler = ( IOInterruptAction )<span></span></pre></td></tr><tr><td scope="row"><pre>                    &amp;IOInterruptEventSource::disableInterruptOccurred;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            else<span></span></pre></td></tr><tr><td scope="row"><pre>                intHandler = ( IOInterruptAction )<span></span></pre></td></tr><tr><td scope="row"><pre>                    &amp;IOInterruptEventSource::normalInterruptOccurred;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            res = ( kIOReturnSuccess == inProvider->registerInterrupt<span></span></pre></td></tr><tr><td scope="row"><pre>                    ( inIntIndex, this, intHandler ) );<span></span></pre></td></tr><tr><td scope="row"><pre>            if ( res )<span></span></pre></td></tr><tr><td scope="row"><pre>                intIndex = inIntIndex;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return res;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>After you’ve determined which type of interrupt is valid for your device, you should register an interrupt handler for the device’s interrupt source. The <code>registerInterrupt</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_473"></a> method requires an integer giving the index of the interrupt source in the device, a reference to the interrupt controller class (often the <code>this</code> pointer), a reference to the interrupt-handling routine, and an optional reference constant for the interrupt handler’s use. <span class="content_text"><a href="IOService.html#//apple_ref/doc/uid/TP30000697-CACFFGDB">Listing 3-11</a></span> shows how IOInterruptEventSource registers the appropriate interrupt handler. </p><p>When you call <code>registerInterrupt</code> on an interrupt source, that interrupt source always starts disabled. It does not take interrupts until you enable it with the <code>enableInterrupt</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_474"></a> method.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_72" title="Important:"></a><p><strong>Important:</strong>&nbsp;As soon as you call the <code>enableInterrupt</code> method, you could start handling interrupts from the enabled source, even <em>before</em><code>enableInterrupt</code> returns. Therefore, make sure you are prepared to handle interrupts before you call the <code>enableInterrupt</code> method.</p><p></p></div><p>The <code>disableInterrupt</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_475"></a> method disables the physical interrupt source, disabling it for all consumers of the interrupt if it is shared. You should call the <code>disableInterrupt</code> method sparingly and only for very short periods of time. If, for some reason, you need to disable an interrupt source for a longer time, you should instead use the <code>unregisterInterrupt</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_476"></a> method to unregister the interrupt handler for a particular source and then reregister it later.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_73" title="Important:"></a><p><strong>Important:</strong>&nbsp;When you call <code>disableInterrupt</code>, you must be prepared to handle interrupts until <em>after</em><code>disableInterrupt</code> returns. The <code>disableInterrupt</code> method waits until all currently active interrupts have been serviced before returning.</p><p></p></div><p>Internal services and top-level interrupt handlers sometimes use the <code>causeInterrupt</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_477"></a> method to ensure that certain interrupts behave in an expected manner. Interrupt controllers are not required to implement this method so you should check before calling <code>causeInterrupt</code> to tickle your interrupt controller.</p><p>By using these methods instead of the IOInterruptEventSource and work-loop mechanism, you are responsible for keeping track of the state of your own interrupts. If, for example, your interrupt source is not registered, you must make sure that your device does not assert that interrupt, otherwise it could adversely affect other sources sharing that interrupt.<a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_478"></a><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_479"></a></p><a name="//apple_ref/doc/uid/TP30000697-TPXREF119" title="Miscellaneous IOService Methods"></a><h2>Miscellaneous IOService Methods</h2><p>The remaining IOService methods do not fall neatly into any single, functional category. This section describes the following methods:</p><ul class="ul"><li class="li"><p><code>errnoFromReturn</code></p></li><li class="li"><p><code>stringFromReturn</code></p></li><li class="li"><p><code>callPlatformFunction</code></p></li><li class="li"><p><code>lockForArbitration</code></p></li><li class="li"><p><code>unlockForArbitration</code></p></li></ul><p>The <code>errnoFromReturn</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_480"></a> and <code>stringFromReturn</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_481"></a> methods are utilities that translate the error codes in <code>IOReturn.h</code> (available in <code>/System/Library/Frameworks/IOKit.framework/Headers</code>) into more usable formats. The <code>errnoFromReturn</code> method translates an <code>IOReturn</code> error code into the error codes BSD defines for its functions in <code>errno.h</code> (available in <code>/System/Library/Frameworks/Kernel.framework/Headers/sys</code>). The IOCDMediaBSDClient class, for example, uses <code>errnoFromReturn</code> to return a BSD error code when it encounters errors while processing an <code>ioctl</code> system call, as <span class="content_text"><a href="IOService.html#//apple_ref/doc/uid/TP30000697-CACIJCBD">Listing 3-12</a></span> shows.</p><a name="//apple_ref/doc/uid/TP30000697-CACIJCBD" title="Listing 3-12Using errnoFromReturn"></a><p class="codesample"><strong>Listing 3-12&nbsp;&nbsp;</strong>Using <code>errnoFromReturn</code></p><div class="codesample"><table><tr><td scope="row"><pre>int IOCDMediaBSDClient::ioctl ( dev_t dev, u_long cmd, caddr_t data,<span></span></pre></td></tr><tr><td scope="row"><pre>                                int flags, struct proc * proc )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    /* Process a CD-specific ioctl. */<span></span></pre></td></tr><tr><td scope="row"><pre>    int error = 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    switch ( cmd )<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        /* Switch cases not shown. */<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return error ? error : getProvider()->errnoFromReturn ( status );<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The <code>stringFromReturn</code> method translates the <code>IOReturn</code> error code into an easier-to-read string. For example, IOService translates the error code <code>kIOReturnLockedRead</code> into the string “device is read locked”.</p><p>You can override either <code>errnoFromReturn</code> or <code>stringFromReturn</code> to interpret family-dependent return codes or if you choose to support other <code>IOReturn</code> codes in addition to the ones IOService translates. If you do implement one of these methods, however, you should call the corresponding class in your superclass if you cannot translate the given error code.</p><p>The <code>callPlatformFunction</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_482"></a> method is an internal method that routes requests to other I/O Registry objects or resources. There is no need for your driver to call this method.</p><p>The <code>lockForArbitration</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_483"></a> and <code>unlockForArbitration</code><a name="//apple_ref/doc/uid/TP30000697-DontLinkElementID_484"></a> methods protect an IOService object from changes in its state or ownership. Most drivers do not need to use these methods because they get called when their state should change so they can then synchronize their internal state. Internally, IOService uses these methods extensively in its implementation of the driver life-cycle methods, such as <code>attach</code>, <code>detach</code>, <code>open</code>, and <code>close</code>.</p><p>Some I/O Kit families also use these methods to prevent changes in an IOService object’s state or ownership while accessing it. For example, <span class="content_text"><a href="IOService.html#//apple_ref/doc/uid/TP30000697-CACICIBG">Listing 3-13</a></span> shows a fragment of the IOBlockStorageDriver’s <code>mediaStateHasChanged</code> method, which determines a course of action based on a media’s new state.</p><a name="//apple_ref/doc/uid/TP30000697-CACICIBG" title="Listing 3-13Using lockForArbitration and unlockForArbitration"></a><p class="codesample"><strong>Listing 3-13&nbsp;&nbsp;</strong>Using <code>lockForArbitration</code> and <code>unlockForArbitration</code></p><div class="codesample"><table><tr><td scope="row"><pre>IOReturn IOBlockStorageDriver::mediaStateHasChanged( IOMediaState state )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    IOReturn result;<span></span></pre></td></tr><tr><td scope="row"><pre>    /* Determine if media has been inserted or removed. */<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( state == kIOMediaStateOnline ) /* Media is now present. */<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        /* Allow a subclass to decide whether to accept or reject the<span></span></pre></td></tr><tr><td scope="row"><pre>            media depending on tests like password protection. */<span></span></pre></td></tr><tr><td scope="row"><pre>        /* ... */<span></span></pre></td></tr><tr><td scope="row"><pre>        /* Get new media's parameters. */<span></span></pre></td></tr><tr><td scope="row"><pre>        /* ... */<span></span></pre></td></tr><tr><td scope="row"><pre>        /* Now make new media show in system. */<span></span></pre></td></tr><tr><td scope="row"><pre>        lockForArbitration();<span></span></pre></td></tr><tr><td scope="row"><pre>        result = acceptNewMedia(); /* Instantiate new media object */<span></span></pre></td></tr><tr><td scope="row"><pre>                                 /* and attach to I/O Registry. */<span></span></pre></td></tr><tr><td scope="row"><pre>        if ( result != kIOReturnSuccess )<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            /* Deal with error. */<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        unlockForArbitration();<span></span></pre></td></tr><tr><td scope="row"><pre>        return ( result );<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else { /* Deal with removed media. */<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../ContainerClasses/Libkern_Classes.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../MakingHWAccessible/MakingHWAccessible.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2002, 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-03-06<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeviceDrivers/Conceptual/WritingDeviceDriver/IOService/IOService.html%3Fid%3DTP30000694-2.13&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeviceDrivers/Conceptual/WritingDeviceDriver/IOService/IOService.html%3Fid%3DTP30000694-2.13&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeviceDrivers/Conceptual/WritingDeviceDriver/IOService/IOService.html%3Fid%3DTP30000694-2.13&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>