<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Finding Word, Line, and Script Run Boundaries(IM: Tx)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING289></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Text-288.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Text-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Text-594.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Text-290.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Text-2.html"><B>Text</B></A> / <BR><DD><A HREF="Text-279.html"><B>Chapter 5 - Text Utilities</B></A> / <A HREF="Text-284.html"><B>Using the Text Utilities</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING289-0></A>
<H2><A NAME=MARKER-2-70></A>Finding Word, Line, and Script Run Boundaries<A NAME=MARKER-2-3></A><A NAME=MARKER-2-4></A><A NAME=MARKER-2-166></A></H2>
 This section describes the Text Utilities routines that you can use to determine where the boundaries of the current word in a text sequence are, where to break the line for drawing text, and where the end of the current subscript text run is. These routines are commonly used in word-processing applications.<A NAME=MARKER-2-5></A><P>
<A NAME=HEADING289-2></A>
<H3>Finding Word Boundaries</H3>
 When working with text in your application, you sometimes need to process each word in the text. You can use the <CODE>FindWordBreaks</CODE> procedure to determine the starting and ending locations in a string of a word. You pass <CODE>FindWordBreaks</CODE> a string and a starting position, and it searches backward for the start of the word, then searches forward for the end of the word.<A NAME=MARKER-2-130></A><P>
 This procedure normally uses the string-manipulation (<CODE>'itl2'</CODE>) resource of the current script system in determining where the word boundaries are. Most string-manipulation resources include a word-selection break table of type <CODE>NBreakTable</CODE> that specifies what constitutes a word boundary in that script; however, some string-manipulation resources do not include such a table, in which case <CODE>FindWordBreaks</CODE> uses default definitions of word boundaries. Some script systems provide a separate extension that allows <CODE>FindWordBreaks</CODE> to find word breaks in a more sophisticated fashion such as using a dictionary lookup. The format of the word-selection break table is described in the appendix "International Resources" in this book.<A NAME=MARKER-2-131></A><P>
 This procedure returns the beginning and ending of a word in a string. Theses values are returned in a table of type <CODE>OffsetTable</CODE>, which contains values that indicate the starting and ending positions in the string of the word. The <CODE>OffsetTable</CODE> data structure is described in the section <A HREF=Text-294.html#MARKER-9-269>"The Offset Table Record" on page 5-44</A>.<A NAME=MARKER-2-400></A><P>
 You can also use <CODE>FindWordBreaks</CODE> to break lines of text, although the procedure is more complicated than using <CODE>StyledLineBreak</CODE>, as described in the next section. For more information, see the discussion of text drawing in the chapter "QuickDraw Text" in this book.<P>
<A NAME=HEADING289-7></A>
<H3><A NAME=MARKER-9-171></A>Finding Line Breaks<A NAME=MARKER-2-185></A></H3>
 You display text on the Macintosh screen by calling the QuickDraw text routines. These routines handle text in different fonts, styles, and sizes, and even draw text that is displayed in different directions. However, the QuickDraw text display routines do not break lines for you to fit into screen areas of your own designation, which means that you have to display your text line-by-line. (The QuickDraw text routines are described in the chapter "QuickDraw Text" in this book.)<A NAME=MARKER-2-268></A><P>
 To draw a string line-by-line, you need to use the <CODE>StyledLineBreak</CODE> function. What you do is start at the first character in your text and use <CODE>StyledLineBreak</CODE> to search for the first line break, draw that portion of the string, and then start up again with the character that follows the line break. You continue this process until the remaining characters all fit on one line. The size and style of the glyphs are factors in determining how many characters fit onto a line, since they affect the number of pixels required for each glyph on the line. Another factor in breaking lines is that it is desirable to break a line on a word boundary whenever possible.<P>
 The <CODE>StyledLineBreak</CODE> function looks for the next line break in a string. It accommodates different fonts, styles, and glyph sizes, and accounts for complications such as the word boundary rules for the script system of the text. You usually call <CODE>StyledLineBreak</CODE> to traverse a line in memory order, which is not necessarily the same as display order for mixed-directional text. <CODE>StyledLineBreak</CODE> finds line breaks on word boundaries whenever possible. <CODE>StyledLineBreak</CODE> always chooses a line break for the last style run on the line as if all trailing whitespace in that style run would be stripped.<P>
 The <CODE>StyledLineBreak</CODE> function works on one style run at a time. To use <CODE>StyledLineBreak</CODE>, you must represent the text in your documents in a manner that allows you to quickly iterate through script runs in your text and style runs within each script run. <A HREF=#MARKER-9-174>Figure 5-9</A> shows an example of a line break in a text string with multiscript text runs.<P>
<B>Figure 5-9  <A NAME=MARKER-9-174></A>Finding line breaks in multiscript text</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/TU_L-07.jpg">
 Use the <CODE>StyledLineBreak</CODE> function when you are displaying text in a screen area to determine the best place to break each displayed line. You can only use this function when you have organized your text in script runs and style runs within each script run. This type of text organization used by most text-processing applications that allow for multiscript text.<P>
 What you do is iterate through your text, a script run at a time, using <CODE>StyledLineBreak</CODE> to check each style run in the script run until the function determines that it has arrived at a line break. As you loop through each style run, before calling <CODE>StyledLineBreak</CODE>, you must set the text values in the current graphics port that are used by QuickDraw to measure the text. These include the font, font size, and font style of the style run. For details on these parameters, see the chapter "QuickDraw Text" in this book.<P>
 Once <CODE>StyledLineBreak</CODE> has arrived at a line break, you can display the line, advance the pointers into your text, and call the function again to find the next line break. You continue to follow this sequence until you've reached the end of your text. <CODE>StyledLineBreak</CODE> does not break on a space character, so a sequence of spaces of any length remains with the previous line.<P>
 The <CODE>StyledLineBreak</CODE> function uses a number of parameters; the value of some of these parameters must change for each style run, and the value of others must change for each script run. <A HREF=#MARKER-9-175>Figure 5-10</A> illustrates how the parameters of the <CODE>StyledLineBreak</CODE> function are used when finding a line break in text that contains a number of script and style runs.<P>
<B>Figure 5-10  <A NAME=MARKER-9-175></A>Relationships of the parameters of <CODE>StyledLineBreak</CODE></B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/TU_L-09.jpg">
 The <CODE>textPtr</CODE> parameter points to the start of the script run, the <CODE>textStart</CODE> parameter is the location of the start of the style run, and the <CODE>textLen</CODE> parameter is the number of bytes in the style run. The <CODE>textWidth</CODE> parameter specifies the number of pixels in the display line. Other parameters are <CODE>textEnd</CODE>, which specifies the number of bytes in the script run, and <CODE>textOffset</CODE>, in which the location of the break is returned. Declarations and descriptions of these parameters are found in the section <A HREF=Text-332.html#MARKER-9-379>"StyledLineBreak" beginning on page 5-79</A>.<P>
 Note that the style runs in <CODE>StyledLineBreak</CODE> must be traversed in memory order, not in display order. For more information about this, read about the <CODE>GetFormatOrder</CODE> routine in the chapter "QuickDraw Text" in this book. It is also important to remember that word boundaries can extend across style runs, but cannot extend across script runs.<P>
 The <CODE>StyledLineBreak</CODE> function looks for a line break on a word boundary. The only time it cannot find such a break is when a word spans across an entire line. If such a word starts past the beginning of the line, <CODE>StyledLineBreak</CODE> determines that a break should occur before the start of the word; otherwise, it breaks the line in the middle of the word, at a character boundary instead of at a word boundary. <CODE>StyledLineBreak</CODE> uses the value of the <CODE>textOffset</CODE> parameter to differentiate between these two cases. The <CODE>textOffset</CODE> parameter must be nonzero for the first call on a line and zero for each subsequent call to the function on the line.<P>
 No matter which case occurs, <CODE>StyledLineBreak</CODE> returns a code that specifies whether or not it found a break and what kind of break (word or character boundary) it is. This value is one of the constants defines as the <CODE>StyledLineBreakCode</CODE> type:
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT><CODE>StyledLineBreak<BR></CODE>constant<TH>Value<BR><TH>Meaning<BR><TR>
<TD>BreakOverflow<TD>2<TD>No break is necessary because the current style run fits on the line (within the width)<A NAME=MARKER-2-10></A><TR>
<TD>BreakChar<TD>1<TD>Line breaks on character boundary<A NAME=MARKER-2-11></A><TR>
<TD>BreakWord<TD>0<TD>Line breaks on word boundary<A NAME=MARKER-2-23></A></TABLE>
<A NAME=MARKER-2-176></A><P>
 <CODE>StyledLineBreak</CODE> automatically decrements the <CODE>textWidth</CODE> variable by the width of the style run for use on the next call. You need to set the value of <CODE>textWidth</CODE> before calling it to process a line. <A HREF=#MARKER-9-178>Listing 5-4</A> shows a basic loop structure that you can use to call <CODE>StyledLineBreak</CODE> in your application.<A NAME=MARKER-2-55></A><P>
<B>Listing 5-4  <A NAME=MARKER-9-178></A>Using the <CODE>StyledLineBreak</CODE> function</B><P>
<PRE>
REPEAT                           {repeat for each line}
   textOffset := 1
   textWidth := number of display pixels available for line
   done := FALSE;
   WHILE not done DO
      BEGIN                      {for each script run}
      textPtr := the address of the first byte of the script run
      textLen := the number of bytes in the script run
      WHILE not done DO
         BEGIN                   {for each style run}
         textStart := byte offset within script run of the start
                     of the style run
         textEnd := byte offset within script run of the end
                     of the style run
         {Set up the QuickDraw font parameters for style run}
         ...
         ans := StyledLineBreak(textPtr, textLen, textStart,
                        textEnd, flags, textWidth, textOffset);
         if ans &lt;&gt; smBreakOverflow
            THEN done := TRUE;
            ELSE textOffset := 0;{always 0 after first call}
         END;
      END;
      {Display the text that starts at textPtr &amp; continues }
      { for textOffset bytes}
      ...
UNTIL                            {until no more text to process}
</PRE>
<A NAME=HEADING289-27></A>
<H3>Finding Subscripts Within a Script Run<A NAME=MARKER-2-61></A></H3>
 <A NAME=MARKER-2-21></A>Some script systems include subscripts, which are character sets that are subsidiary to the main character set. One useful subscript is the set of all character codes that have the same meaning in Roman as they do in a non-Roman script. For other scripts such as Japanese, there are additional useful subscripts. For example, a Japanese script system might include some Hiragana characters that are useful for input methods.<P>
 When you are displaying or working with a string that contains subscript characters, it is often convenient to identify the subscript text runs so that you can treat those characters differently. You might, for instance, want to display the Roman subscript text in a different font, or apply different rules to it when searching for word boundaries. In <A HREF=#MARKER-9-181>Figure 5-11</A>, the English words "Hebrew" and "Russian" are initially drawn in native language fonts from their script systems. Each of these words is then extracted and redrawn using a font from the Roman script system.<P>
<B>Figure 5-11  <A NAME=MARKER-9-181></A>Extracting blocks of Roman text <A NAME=MARKER-2-66></A></B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/TU_L-08.jpg">
 The <CODE>FindScriptRun</CODE> function is used to identify blocks of subscript text in a string. <CODE>FindScriptRun</CODE> searches a string for such a block, and sets a <CODE>VAR</CODE> parameter to the length in bytes of the subscript run that begins with the first character in the string. <CODE>FindScriptRun</CODE> also returns a script-run status record, which specifies the script code and subscript information for the block of text. The fields of the script-run status record are described in the section <A HREF=Text-333.html#MARKER-9-386>"FindScriptRun,"</A> beginning on <A HREF=Text-333.html#MARKER-9-386>page 5-81</A>.<A NAME=MARKER-2-8></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Text-288.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Text-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Text-594.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Text-290.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Text-3.html">&copy; Apple Computer, Inc.</A><br>6 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
