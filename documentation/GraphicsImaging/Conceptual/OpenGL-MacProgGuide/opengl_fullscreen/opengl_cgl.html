<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>OpenGL Programming Guide for Mac OS X: Drawing to the Full Screen</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Drawing to the Full Screen"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40001987-CH210" title="Drawing to the Full Screen"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000424" target="_top">Graphics &amp; Imaging</a> &gt; <a href="../../../OpenGL-date.html#//apple_ref/doc/uid/TP30000440-TP30000424-TP30000549" target="_top">OpenGL</a> &gt; <a href="../opengl_intro/opengl_intro.html#//apple_ref/doc/uid/TP40001987-CH207-TP9">OpenGL Programming Guide for Mac OS X</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../opengl_drawing/opengl_drawing.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../opengl_offscreen/opengl_offscreen.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40001987-CH210-SW6" title="Drawing to the Full Screen"></a><h1>Drawing to the Full Screen</h1><p>In Mac OS X, you don't have to restrict your OpenGL drawing to views and windows. You also have the option to draw to the entire screen. The primary difference between drawing to a view or window and drawing to the full screen is that you must prevent other applications and system services from trying to do the same thing. You can capture the display by using the Quartz Display Services API. Once captured by your application, other applications are not notified of display changes, thus preventing them from repositioning their windows and preventing the Finder from repositioning desktop icons. The screen is all yours for OpenGL drawing.</p><br/><div><a name="//apple_ref/doc/uid/TP40001987-CH210-SW10" title="Figure 3-1Drawing OpenGL content to the full screen"></a><p><strong>Figure 3-1&nbsp;&nbsp;</strong>Drawing OpenGL content to the full screen</p><img src = "../art/full_screen.jpg" alt = "Drawing OpenGL content to the full screen" ></div><br/><p>Each of the Apple-specific OpenGL APIs provides routines for setting up full-screen drawing. The approach for using each is similar, as you'll see by reading the first section in this chapter, which describes the general approach. This chapter also provides specific information for using each of the Apple-specific OpenGL APIs and shows how to use Quartz Display Services to switch the display mode and change screen resolutions, two tasks that are useful for any application that uses the full screen.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="opengl_cgl.html#//apple_ref/doc/uid/TP40001987-CH210-SW11">General Approach</a>
				
			<br/>
			
        
			
			
				<a href="opengl_cgl.html#//apple_ref/doc/uid/TP40001987-CH210-SW8">Using Cocoa  to Create a Full-Screen Context</a>
				
			<br/>
			
        
			
			
				<a href="opengl_cgl.html#//apple_ref/doc/uid/TP40001987-CH210-SW4">Using AGL  to Create a Full-Screen Context</a>
				
			<br/>
			
        
			
			
				<a href="opengl_cgl.html#//apple_ref/doc/uid/TP40001987-CH210-SW1">Using CGL to Create a Full-Screen Context</a>
				
			<br/>
			
        
			
			
				<a href="opengl_cgl.html#//apple_ref/doc/uid/TP40001987-CH210-SW2">Adjusting Display Modes</a>
				
			<br/>
			
        
			
			
				<a href="opengl_cgl.html#//apple_ref/doc/uid/TP40001987-CH210-SW14">What's Next?</a>
				
			<br/>
			
        
			
			
				<a href="opengl_cgl.html#//apple_ref/doc/uid/TP40001987-CH210-SW15">See Also</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40001987-CH210-SW11" title="General Approach"></a><h2>General Approach</h2><p>Many of the tasks for setting up full-screen drawing are similar to those required to set up drawing OpenGL content to a Cocoa view or a Carbon window. The tasks that are similar are explained in detail in <span class="content_text"><a href="../opengl_drawing/opengl_drawing.html#//apple_ref/doc/uid/TP40001987-CH404-SW8">“Drawing to a Window or View”</a></span> but only mentioned here. If you haven't read that chapter, you should read it first.</p><p>Drawing OpenGL content to a full screen requires performing the following tasks:</p><ol class="ol"><li class="li"><p>Capture the display you want to draw to by calling the Quartz Display Services function <code><a href="../../../Reference/Quartz_Services_Ref/Reference/reference.html#//apple_ref/doc/c_ref/CGDisplayCapture" target="_top">CGDisplayCapture</a></code> and supplying a display ID that represents a unique ID for an attached display. The constant <code>kCGDirectMainDisplay</code> represents the main display, the one that’s shown in the menu bar.</p><p>If you want to capture all the displays attached to a system, call the function <code><!--a-->CGDisplayCaptureAllDisplays<!--/a--></code>.</p></li><li class="li"><p>Convert the display ID to an OpenGL display mask by calling the function <code><a href="../../../Reference/Quartz_Services_Ref/Reference/reference.html#//apple_ref/doc/c_ref/CGDisplayIDToOpenGLDisplayMask" target="_top">CGDisplayIDToOpenGLDisplayMask</a></code>. </p></li><li class="li"><p>Set up the renderer and buffer attributes that support the OpenGL drawing you want to perform, making sure to include a full-screen attribute and the OpenGL display mask that you obtained in the previous step.</p></li><li class="li"><p>Request a pixel format object that encapsulates the renderer and buffer attributes required by your application.</p><p>Some OpenGL renderers, such as the software renderer, do not support full-screen mode. If the system returns <code><!--a  -->NULL<!--/a--></code> for the pixel format object, your application needs to take appropriate action.</p></li><li class="li"><p>Create a rendering context and bind the pixel format object to it.</p></li><li class="li"><p>Release the pixel format object.</p></li><li class="li"><p>Make the context the current context.</p></li><li class="li"><p>Bind a full-screen drawable object to the rendering context.</p></li><li class="li"><p>Perform your drawing.</p></li><li class="li"><p>When you are done drawing, perform the necessary cleanup work and make sure that you release the captured display.</p></li></ol><a name="//apple_ref/doc/uid/TP40001987-CH210-SW8" title="Using Cocoa  to Create a Full-Screen Context"></a><h2>Using Cocoa  to Create a Full-Screen Context</h2> <p>When you set up an attributes array, you need to include the attribute  <code>NSOpenGLPFAFullScreen</code> to specify that only renderers that are capable of rendering to the full screen should be considered when the system creates a pixel format object.  You also need to include the attribute <code>NSOpenGLPFAScreenMask</code> along with the appropriate OpenGL display mask.</p><p><span class="content_text">Listing 3-1</span> is a code fragment that shows how to use the  <code>NSOpenGLPixelFormat</code> and <code>NSOpenGLContext</code> classes along with calls from Quartz Display Services to set up full-screen drawing in a Cocoa application. A detailed explanation for each numbered line of code appears following the listing.</p><a name="//apple_ref/doc/uid/TP40001987-CH210-SW9" title="Listing 3-1Using Cocoa to set up full-screen drawing"></a><p class="codesample"><strong>Listing 3-1&nbsp;&nbsp;</strong>Using Cocoa to set up full-screen drawing</p><div class="codesample"><table><tr><td scope="row"><pre>CGDisplayErr err;<span></span></pre></td></tr><tr><td scope="row"><pre>NSOpenGLContext *fullScreenContext;<span></span></pre></td></tr><tr><td scope="row"><pre>NSOpenGLPixelFormatAttribute attrs[] = { <span>// 1</span></pre></td></tr><tr><td scope="row"><pre>    NSOpenGLPFAFullScreen,<span></span></pre></td></tr><tr><td scope="row"><pre>    NSOpenGLPFAScreenMask,<span></span></pre></td></tr><tr><td scope="row"><pre>                CGDisplayIDToOpenGLDisplayMask(kCGDirectMainDisplay),<span></span></pre></td></tr><tr><td scope="row"><pre>    NSOpenGLPFAColorSize, 24,  <span>// 2</span></pre></td></tr><tr><td scope="row"><pre>    NSOpenGLPFADepthSize, 16,<span></span></pre></td></tr><tr><td scope="row"><pre>    NSOpenGLPFADoubleBuffer,<span></span></pre></td></tr><tr><td scope="row"><pre>    NSOpenGLPFAAccelerated,<span></span></pre></td></tr><tr><td scope="row"><pre>    0<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr><tr><td scope="row"><pre>NSOpenGLPixelFormat *pixelFormat = [[NSOpenGLPixelFormat alloc]<span></span></pre></td></tr><tr><td scope="row"><pre>                                initWithAttributes:attrs];<span></span></pre></td></tr><tr><td scope="row"><pre>fullScreenContext = [[NSOpenGLContext alloc] initWithFormat:pixelFormat<span></span></pre></td></tr><tr><td scope="row"><pre>                         shareContext:NULL];<span></span></pre></td></tr><tr><td scope="row"><pre>[pixelFormat release];<span></span></pre></td></tr><tr><td scope="row"><pre>pixelFormat = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>if (fullScreenContext == nil) {<span></span></pre></td></tr><tr><td scope="row"><pre>        NSLog(@"Failed to create fullScreenContext");<span></span></pre></td></tr><tr><td scope="row"><pre>        return;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>err = CGCaptureAllDisplays(); <span>// 3</span></pre></td></tr><tr><td scope="row"><pre>if (err != CGDisplayNoErr) {<span></span></pre></td></tr><tr><td scope="row"><pre>        [fullScreenContext release];<span></span></pre></td></tr><tr><td scope="row"><pre>        fullScreenContext = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>        return;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>[fullScreenContext setFullScreen]; <span>// 4</span></pre></td></tr><tr><td scope="row"><pre>[fullScreenContext makeCurrentContext]; <span>// 5</span></pre></td></tr></table></div><p>Here's what the code does:</p><ol class="ol"><li class="li"><p>Sets up an array of renderer and buffer attributes, including the appropriate attributes to specify  full-screen mode and the display ID for the main display. This example also supplies a number of other attributes. You would supply the attributes that are appropriate for your application.</p></li><li class="li"><p>Supplies a color size that matches the current display depth. Note that this value must match the current display depth.</p></li><li class="li"><p>Calls the Quartz Display Services function that captures all displays. If you want to capture only one display, you can call the function <code><a href="../../../Reference/Quartz_Services_Ref/Reference/reference.html#//apple_ref/c/func/CGDisplayCapture" target="_top">CGDisplayCapture</a></code>, passing the ID of the display that you want to capture.</p></li><li class="li"><p>Attaches the full-screen drawable object to the rendering context.</p></li><li class="li"><p>Makes the full-screen context the current context that will receive OpenGL commands. If you fail to perform this step, you won't see any content drawn to the screen.</p></li></ol><p>When you no longer need to draw full-screen OpenGL content, you must release resources and release the captured display (or displays).</p><a name="//apple_ref/doc/uid/TP40001987-CH210-SW4" title="Using AGL  to Create a Full-Screen Context"></a><h2>Using AGL  to Create a Full-Screen Context</h2><p>This extended code example is an excerpt from an application that uses an application-defined structure—<code>pRecContext</code>—to store information about the context, including display IDs for the displays attached to the system and a rendering context. The <code>MySetupAGL</code> routine in <span class="content_text">Listing 3-2</span> takes as parameters a <code>pRecContext</code> data type, a width and height that specifies the screen resolution, a bit depth, and the refresh rate of the display. </p><p>The <code>MySetupAGL</code> routine sets the display mode and sets up a full-screen context. A detailed explanation for each numbered line of code appears following the listing. </p><a name="//apple_ref/doc/uid/TP40001987-CH210-SW5" title="Listing 3-2A function that sets up a full-screen context using AGL"></a><p class="codesample"><strong>Listing 3-2&nbsp;&nbsp;</strong>A function that sets up a full-screen context using AGL</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus MySetupAGL (pRecContext pContextInfo, size_t width, size_t height,<span></span></pre></td></tr><tr><td scope="row"><pre>                        size_t depth, CGRefreshRate refresh)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSStatus err = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    GLint attribs[] = { AGL_RGBA, AGL_NO_RECOVERY,<span></span></pre></td></tr><tr><td scope="row"><pre>            AGL_FULLSCREEN, AGL_DOUBLEBUFFER,<span></span></pre></td></tr><tr><td scope="row"><pre>            AGL_DEPTH_SIZE, 32,<span></span></pre></td></tr><tr><td scope="row"><pre>                        0 }; <span>// 1</span></pre></td></tr><tr><td scope="row"><pre>    AGLPixelFormat pixelFormat = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    long i, index;<span></span></pre></td></tr><tr><td scope="row"><pre>    GDHandle gdhDisplay;<span></span></pre></td></tr><tr><td scope="row"><pre>    CFDictionaryRef refDisplayMode = 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (NULL == pContextInfo)<span></span></pre></td></tr><tr><td scope="row"><pre>        return paramErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    refDisplayMode = CGDisplayBestModeForParametersAndRefreshRate(<span></span></pre></td></tr><tr><td scope="row"><pre>                            pContextInfo->display,<span></span></pre></td></tr><tr><td scope="row"><pre>                            depth, width, height, refresh, NULL); <span>// 2</span></pre></td></tr><tr><td scope="row"><pre>    if (refDisplayMode) {<span></span></pre></td></tr><tr><td scope="row"><pre>        gOldDisplayMode = CGDisplayCurrentMode( pContextInfo->display); <span>// 3</span></pre></td></tr><tr><td scope="row"><pre>        gOldDisplayModeValid = GL_TRUE;<span></span></pre></td></tr><tr><td scope="row"><pre>        CGDisplaySwitchToMode (pContextInfo->display, refDisplayMode); <span>// 4</span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    for (i = 0; i &lt; gNumDisplays; i++) { <span>// 5</span></pre></td></tr><tr><td scope="row"><pre>        if (pContextInfo->display == gDisplayCaps[i].cgDisplayID) index = i;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    err = DMGetGDeviceByDisplayID ((DisplayIDType)pContextInfo->display,<span></span></pre></td></tr><tr><td scope="row"><pre>                                 &amp;gdhDisplay, false); <span>// 6</span></pre></td></tr><tr><td scope="row"><pre>    if (noErr == err)<span></span></pre></td></tr><tr><td scope="row"><pre>        if (!(pixelFormat = aglChoosePixelFormat (&amp;gdhDisplay, 1, attribs)))<span></span></pre></td></tr><tr><td scope="row"><pre>            err = aglReportError ();<span></span></pre></td></tr><tr><td scope="row"><pre>    if (pixelFormat) {<span></span></pre></td></tr><tr><td scope="row"><pre>        if (!(pContextInfo->aglContext = aglCreateContext( pixelFormat,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                         NULL)))<span></span></pre></td></tr><tr><td scope="row"><pre>            err = aglReportError ();<span></span></pre></td></tr><tr><td scope="row"><pre>        aglDestroyPixelFormat (pixelFormat);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    if (pContextInfo->aglContext) {<span></span></pre></td></tr><tr><td scope="row"><pre>        short fNum;<span></span></pre></td></tr><tr><td scope="row"><pre>        GLint swap = 1;<span></span></pre></td></tr><tr><td scope="row"><pre>        if (!aglSetCurrentContext (pContextInfo->aglContext)) <span>// 7</span></pre></td></tr><tr><td scope="row"><pre>            err = aglReportError ();<span></span></pre></td></tr><tr><td scope="row"><pre>        if ((noErr == err) &amp;&amp; !aglSetFullScreen( pContextInfo->aglContext,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            0, 0, 0, 0)) <span>// 8</span></pre></td></tr><tr><td scope="row"><pre>            err = aglReportError ();<span></span></pre></td></tr><tr><td scope="row"><pre>        if (noErr == err) {<span></span></pre></td></tr><tr><td scope="row"><pre>            if (!aglSetInteger (pContextInfo->aglContext,<span></span></pre></td></tr><tr><td scope="row"><pre>                                AGL_SWAP_INTERVAL, &amp;swap)); <span>// 9</span></pre></td></tr><tr><td scope="row"><pre>                err = aglReportError ();<span></span></pre></td></tr><tr><td scope="row"><pre>            /* Your code to perform other initializations here */<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return err;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here's what the code does:</p><ol class="ol"><li class="li"><p>Sets up renderer and buffer attributes. You must supply <code>AGL_FULLSCREEN</code> when you want to set up a full-screen context using the AGL API. This example also provides a number of other attributes: RGBA pixel format, double buffering, a depth size of 32 bits, and the no recovery attribute. No recovery indicates that if a suitable hardware renderer isn't found, the operating system should not substitute a software renderer.</p></li><li class="li"><p>Obtains the best display mode for the screen resolution, bit depth, and refresh rate passed to the <code>MySetupAGL</code> function.</p></li><li class="li"><p>Gets the current display mode and then saves it so that it can be restored later. It's recommended practice for you to save and restore the display mode.</p></li><li class="li"><p>Switches to the display mode.</p></li><li class="li"><p>Gets the display capabilities of interest for current display. For more information on determining the capabilities of a display, see <span class="content_text"><a href="../opengl_general/opengl_gen_tasks.html#//apple_ref/doc/uid/TP40001987-CH211-SW7">“Determining the OpenGL Capabilities Supported by the Hardware.”</a></span></p></li><li class="li"><p>Calls the Display Manager function that obtains a handle for the video device with the specified display ID. You must pass this handle to <code><a href="../../../Reference/AGL_OpenGL/Reference/reference.html#//apple_ref/c/func/aglChoosePixelFormat" target="_top">aglChoosePixelFormat</a></code>.</p></li><li class="li"><p>Sets the current context to the newly created context. If you fail to perform this task, you won't see any OpenGL content drawn on the screen.</p></li><li class="li"><p>Attaches the full-screen drawable object to the rendering context.</p></li><li class="li"><p>Synchronizes to the refresh rate by setting the swap interval to <code>1</code>. (Recall that the <code>swap</code> variable was previously assigned a value of <code>1</code>). For more information, see <span class="content_text"><a href="../opengl_performance/opengl_performance.html#//apple_ref/doc/uid/TP40001987-CH213-SW4">“Synchronize with the Screen Refresh Rate.”</a></span> The function <code><a href="../../../Reference/AGL_OpenGL/Reference/reference.html#//apple_ref/c/func/aglSetInteger" target="_top">aglSetInteger</a></code>  allows you to set a variety of  rendering context parameters. For more information see <span class="content_text"><a href="../opengl_contexts/opengl_contexts.html#//apple_ref/doc/uid/TP40001987-CH216-SW12">“Techniques for Working with Rendering Contexts.”</a></span></p></li></ol><a name="//apple_ref/doc/uid/TP40001987-CH210-SW1" title="Using CGL to Create a Full-Screen Context"></a><h2>Using CGL to Create a Full-Screen Context</h2><p>Because the CGL API is at a lower level in the system architecture than either Cocoa or the AGL API, you can use it to create a full-screen context in either a Cocoa or a Carbon application. The code in  <span class="content_text">Listing 3-3</span> shows how to capture the main display and create a full-screen context. As you can see, the code parallels the examples shown in <span class="content_text"><a href="opengl_cgl.html#//apple_ref/doc/uid/TP40001987-CH210-SW8">“Using Cocoa  to Create a Full-Screen Context”</a></span> and <span class="content_text"><a href="opengl_cgl.html#//apple_ref/doc/uid/TP40001987-CH210-SW4">“Using AGL  to Create a Full-Screen Context.”</a></span> A detailed explanation for each numbered line of code appears following the listing.</p><p>Depending on what you want to accomplish, there are a number of modifications that you can make to the code, such as adjusting the display mode and synchronizing rendering to the screen refresh rate. See <span class="content_text"><a href="opengl_cgl.html#//apple_ref/doc/uid/TP40001987-CH210-SW2">“Adjusting Display Modes”</a></span> and <span class="content_text"><a href="../opengl_quartz_services/opengl_quartz_services.html#//apple_ref/doc/uid/TP40001987-CH302-SW6">“Quartz Display Services and Full-Screen Mode.”</a></span></p><a name="//apple_ref/doc/uid/TP40001987-CH210-SW3" title="Listing 3-3Setting up a full-screen context using CGL"></a><p class="codesample"><strong>Listing 3-3&nbsp;&nbsp;</strong>Setting up a full-screen context using CGL</p><div class="codesample"><table><tr><td scope="row"><pre>CGDisplayCapture (kCGDirectMainDisplay); <span>// 1</span></pre></td></tr><tr><td scope="row"><pre>CGLPixelFormatAttribute attribs[] = { kCGLPFADoubleBuffer,<span></span></pre></td></tr><tr><td scope="row"><pre>        kCGLPFAFullScreen,<span></span></pre></td></tr><tr><td scope="row"><pre>        kCGLPFADisplayMask,<span></span></pre></td></tr><tr><td scope="row"><pre>        CGDisplayIDToOpenGLDisplayMask(kCGDirectMainDisplay),<span></span></pre></td></tr><tr><td scope="row"><pre>        NULL<span></span></pre></td></tr><tr><td scope="row"><pre>    }; <span>// 2</span></pre></td></tr><tr><td scope="row"><pre>CGLPixelFormatObj pixelFormatObj;<span></span></pre></td></tr><tr><td scope="row"><pre>long numPixelFormats ;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CGLChoosePixelFormat( attribs, &amp;pixelFormatObj, &amp;numPixelFormats );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CGLContextObj contextObj ;<span></span></pre></td></tr><tr><td scope="row"><pre>CGLCreateContext( pixelFormatObj, NULL, &amp;contextObj );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CGLDestroyPixelFormat( pixelFormatObj );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CGLSetCurrentContext( contextObj ); <span>// 3</span></pre></td></tr><tr><td scope="row"><pre>CGLSetFullScreen( contextObj );<span>// 4</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>//****** Perform your application's main loop<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CGLSetCurrentContext(NULL); <span>// 5</span></pre></td></tr><tr><td scope="row"><pre>CGLClearDrawable(contextObj);<span></span></pre></td></tr><tr><td scope="row"><pre>CGLDestroyContext(contextObj);<span></span></pre></td></tr><tr><td scope="row"><pre>CGReleaseAllDisplays();<span></span></pre></td></tr></table></div><p>Here's what the code does:</p><ol class="ol"><li class="li"><p>Captures the main display.</p></li><li class="li"><p>Sets up an array of attributes that includes the full-screen attribute and the display mask associated with the captured display.</p></li><li class="li"><p>Sets the current context to the one it will use for full-screen drawing.</p></li><li class="li"><p>Attaches a full-screen drawable object to the current context.</p></li><li class="li"><p>After all drawing is completed, sets the current context to <code>NULL</code>, and goes on to perform the other necessary clean up work: clearing the drawable object, destroying the rendering context, and releasing the displays. </p></li></ol><a name="//apple_ref/doc/uid/TP40001987-CH210-SW2" title="Adjusting Display Modes"></a><h2>Adjusting Display Modes</h2><p>The Quartz Display Services API provides several functions that adjust the display mode: </p><ul class="ul"><li class="li"><p><code><a href="../../../Reference/Quartz_Services_Ref/Reference/reference.html#//apple_ref/c/func/CGDisplayBestModeForParameters" target="_top">CGDisplayBestModeForParameters</a></code> finds the display mode that is closest to a specified depth and screen size.</p></li><li class="li"><p><code><a href="../../../Reference/Quartz_Services_Ref/Reference/reference.html#//apple_ref/c/func/CGDisplayBestModeForParametersAndRefreshRate" target="_top">CGDisplayBestModeForParametersAndRefreshRate</a></code> finds the display mode that is closest to a specified depth and resolution, and that also uses a refresh rate equal to or near the specified rate.</p></li><li class="li"><p><code><a href="../../../Reference/Quartz_Services_Ref/Reference/reference.html#//apple_ref/c/func/CGDisplayBestModeForParametersAndRefreshRateWithProperty" target="_top">CGDisplayBestModeForParametersAndRefreshRateWithProperty</a></code> finds the display mode that is closest to a specified depth, resolution, and refresh rate and that also has a specific property. Properties include whether the mode is  safe for hardware, is interlaced, is stretched, or can provide output suitable for  television.</p></li></ul><p>If you want to adjust the display mode, you first need to capture the display, as shown in <span class="content_text">Listing 3-4</span>. The Quartz Display Services function <code><a href="../../../Reference/Quartz_Services_Ref/Reference/reference.html#//apple_ref/c/func/CGDisplaySwitchToMode" target="_top">CGDisplaySwitchToMode</a></code> switches to the display mode returned by the function <code><a href="../../../Reference/Quartz_Services_Ref/Reference/reference.html#//apple_ref/doc/c_ref/CGDisplayBestModeForParameters" target="_top">CGDisplayBestModeForParameters</a></code>, which in this case, is the best display mode for the main display with a bit depth of 32 bits per pixel and a screen resolution of 1024 by 768 pixels. The display mode that's returned is not always what you asked for. It's the closest mode for the given parameter. The last parameter passed to this function—<code>exactMatch</code>—specifies whether the returned display mode matches exactly. If you don't need this information, you can pass <code>NULL</code>. When your application quits, Quartz Display Services automatically restores the user’s display settings.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40001987-CH210-SW12" title="Note"></a><p><strong>Note:</strong>&nbsp;Calling <code><a href="../../../Reference/Quartz_Services_Ref/Reference/reference.html#//apple_ref/doc/c_ref/CGDisplaySwitchToMode" target="_top">CGDisplaySwitchToMode</a></code> does not guarantee that the display mode switches successfully. Displays have physical limitations that can prevent them from operating in a particular mode.</p></div><a name="//apple_ref/doc/uid/TP40001987-CH210-SW13" title="Listing 3-4Adjusting the display mode"></a><p class="codesample"><strong>Listing 3-4&nbsp;&nbsp;</strong>Adjusting the display mode</p><div class="codesample"><table><tr><td scope="row"><pre>CGDisplayCapture (kCGDirectMainDisplay ) ;<span></span></pre></td></tr><tr><td scope="row"><pre>CGDisplaySwitchToMode (kCGDirectMainDisplay,<span></span></pre></td></tr><tr><td scope="row"><pre>            CGDisplayBestModeForParameters (kCGDirectMainDisplay,<span></span></pre></td></tr><tr><td scope="row"><pre>                                 32, 1024, 768, NULL) );<span></span></pre></td></tr></table></div><p><span class="content_text">Listing 3-5</span> shows how to switch the main display to a pixel depth of 32 bits per pixel, a resolution of 640 x 480,  and a refresh rate of 60 Hz. A detailed explanation for each numbered line of code appears following the listing.</p><a name="//apple_ref/doc/uid/TP40001987-CH210-SW7" title="Listing 3-5Switching the resolution of a display"></a><p class="codesample"><strong>Listing 3-5&nbsp;&nbsp;</strong>Switching the resolution of a display</p><div class="codesample"><table><tr><td scope="row"><pre>CFDictionaryRef displayMode ;<span></span></pre></td></tr><tr><td scope="row"><pre>CFNumberRef number ;<span></span></pre></td></tr><tr><td scope="row"><pre>boolean_t exactMatch ;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CGDisplayCapture (kCGDirectMainDisplay); <span>// 1</span></pre></td></tr><tr><td scope="row"><pre>displayMode =<span></span></pre></td></tr><tr><td scope="row"><pre>    CGDisplayBestModeForParametersAndRefreshRate (kCGDirectMainDisplay,<span></span></pre></td></tr><tr><td scope="row"><pre>                            32,640,480,60,&amp;exactMatch); <span>// 2</span></pre></td></tr><tr><td scope="row"><pre>if (exactMatch){        <span>// 3</span></pre></td></tr><tr><td scope="row"><pre>     CGDisplaySwitchToMode (kCGDirectMainDisplay, displayMode);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>else {<span></span></pre></td></tr><tr><td scope="row"><pre>    // Your code to take appropriate action<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>// Run the event loop.<span></span></pre></td></tr><tr><td scope="row"><pre>CGReleaseAllDisplays(); <span>// 4</span></pre></td></tr></table></div><p>Here's what the code does:</p><ol class="ol"><li class="li"><p>Captures the main display.</p></li><li class="li"><p>Requests a display mode with a depth of 32 bits per pixel, a resolution 640 x 480, and a refresh rate 60 Hz. The function finds the best match for these parameters.</p></li><li class="li"><p>If there is an exact match, then switches to the display mode.</p></li><li class="li"><p>Before the application quits, releases all displays.</p></li></ol><a name="//apple_ref/doc/uid/TP40001987-CH210-SW14" title="What&#39;s Next?"></a><h2>What's Next?</h2><p>The Quartz Display Services API performs a number of other tasks that are useful when drawing OpenGL to the full screen. <span class="content_text"><a href="../opengl_quartz_services/opengl_quartz_services.html#//apple_ref/doc/uid/TP40001987-CH302-SW6">“Quartz Display Services and Full-Screen Mode”</a></span> describes many of them, including enumerating displays and display modes, accessing display properties, fading the display, and programmatically controlling the pointer. You may also want to read <span class="content_text"><a href="../opengl_performance/opengl_performance.html#//apple_ref/doc/uid/TP40001987-CH213-SW3">“Draw Only When Necessary”</a></span> to see how to use Quartz Display Services to synchronize drawing with the screen refresh.</p><a name="//apple_ref/doc/uid/TP40001987-CH210-SW15" title="See Also"></a><h2>See Also</h2><p>OpenGL sample code projects (<span class="content_text"><a href="http://developer.apple.com/referencelibrary/" target="_top">ADC Reference Library</a></span>):</p><ul class="ul"><li class="li"><p> <em><!--a target="_top" -->GLCarbonAGLFullScreen<!--/a--></em> is a full-featured OpenGL application that uses the AGL API to draw to the full screen.</p></li><li class="li"><p><em><!--a target="_top" -->GLCarbonCGLFullScreen<!--/a--></em> is a full-featured OpenGL application that uses the CGL API to draw to the full screen.</p></li><li class="li"><p><em><a href="../../../../../samplecode/NSOpenGL_Fullscreen/index.html#//apple_ref/doc/uid/DTS10003168" target="_top">NSOpenGL Fullscreen</a></em> shows how to create and switch between windowed and full-screen OpenGL contexts.</p></li></ul>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../opengl_drawing/opengl_drawing.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../opengl_offscreen/opengl_offscreen.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2004, 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-06-09<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/GraphicsImaging/Conceptual/OpenGL-MacProgGuide/opengl_fullscreen/opengl_cgl.html%3Fid%3DTP40001987-3.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/GraphicsImaging/Conceptual/OpenGL-MacProgGuide/opengl_fullscreen/opengl_cgl.html%3Fid%3DTP40001987-3.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/GraphicsImaging/Conceptual/OpenGL-MacProgGuide/opengl_fullscreen/opengl_cgl.html%3Fid%3DTP40001987-3.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>