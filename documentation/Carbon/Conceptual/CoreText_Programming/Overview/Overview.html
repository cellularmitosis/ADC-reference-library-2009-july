<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Core Text Programming Guide: Core Text Overview</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Core Text Overview"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40005533-CH3" title="Core Text Overview"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000420" target="_top">Carbon</a> &gt; <a href="../../../TextFonts-date.html#//apple_ref/doc/uid/TP30000440-TP30000420-TP30000461" target="_top">Text &amp; Fonts</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP40005533-CH1-SW1">Core Text Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Introduction/Introduction.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../Operations/Operations.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40005533-CH3-SW1" title="Core Text Overview"></a><h1>Core Text Overview</h1><p>The Core Text framework is an advanced, low-level technology for laying out text and handling fonts. Designed for high performance and ease of use, the Core Text layout engine is up to twice as fast as ATSUI (Apple Type Services for Unicode Imaging). The Core Text layout API is simple, consistent, and tightly integrated with Core Foundation, Core Graphics, and Cocoa.</p><p>The Core Text font API is complementary to the Core Text layout engine. Core Text font technology is designed to handle Unicode fonts natively, bridging the gap between Carbon and Cocoa font references, and providing efficient font handling for Core Text layout. Core Text brings the capabilities and coherent design of Cocoa text and fonts to a broader, lower-level client base.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="Overview.html#//apple_ref/doc/uid/TP40005533-CH3-SW2">Mac OS X Text Technologies</a>
				
			<br/>
			
        
			
			
				<a href="Overview.html#//apple_ref/doc/uid/TP40005533-CH3-DontLinkElementID_9">Design Goals and Principles</a>
				
			<br/>
			
        
			
			
				<a href="Overview.html#//apple_ref/doc/uid/TP40005533-CH3-DontLinkElementID_10">Core Text Features and Capabilities</a>
				
			<br/>
			
        
			
			
				<a href="Overview.html#//apple_ref/doc/uid/TP40005533-CH3-DontLinkElementID_14">Core Text Objects</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40005533-CH3-SW2" title="Mac OS X Text Technologies"></a><h2>Mac OS X Text Technologies</h2><p>The Macintosh operating system has provided sophisticated text handling and typesetting capabilities from its beginning. In fact, these features sparked the desktop publishing revolution. Core Text is the most modern text-handling technology on the platform. It is designed specifically for Mac OS X and is written in C, so it can be called from any language in the system. It is positioned as a core technology to provide consistent, high-performance text services to other frameworks throughout the system, and the Core Text API is accessible to applications that need to use it directly. Core Text resides in the Application Services umbrella framework (<code>ApplicationServices</code>) so that it is callable from both Carbon and Cocoa and has all of the lower-level services it needs.</p><p>Core Text is not meant to replace the Cocoa text system, although it provides the underlying implementation for many Cocoa text technologies. If you can deal with high-level constructs, such as text views, you can probably use Cocoa. For this reason, Cocoa developers typically have no need to use Core Text directly. Carbon developers, on the other hand, will find Core Text faster and easier to use, in many cases, than preexisting Mac OS X text layout and font APIs.</p><p>To decide whether Core Text is the right Mac OS X text technology for your application, apply the following guidelines:</p><ul class="ul"><li class="li"><p>If you can, use Cocoa text. The <code>NSTextView</code> class is the most advanced, full-featured, flexible text view in Mac OS X. For small amounts of text, use <code>NSTextField</code>. </p></li><li class="li"><p>To display web content in your application, use Web Kit.</p></li><li class="li"><p>If you need to use Carbon only, consider using <code>NSTextView</code> with HICocoaView.</p></li><li class="li"><p>If you need a lower-level API for drawing any kind of text into a Quartz graphics context (CGContext), consider using Core Text directly.</p></li><li class="li"><p>If you need features that Core Text does not provide (such as text editing and font activation) and you can't use Cocoa, look at other technologies such as MLTE, ATSUI, and ATS. </p></li></ul><p>Generally speaking, Core Text is for applications that need a low-level text-handling technology correlating with the Core Graphics framework (Quartz). If you work directly with Quartz and you need to draw some text, use Core Text. If, for example, you have your own page layout engine—you have some text and you know where it needs to go in your view—you can use Core Text to generate the glyphs and position them relative to each other with all the features of fine typesetting, such as kerning, ligatures, line-breaking, and justification.</p><a name="//apple_ref/doc/uid/TP40005533-CH3-DontLinkElementID_9" title="Design Goals and Principles"></a><h2>Design Goals and Principles</h2><p>Core Text is designed to provide the following benefits:</p><ul class="ul"><li class="li"><p>A comprehensive, unified set of text-layout and font APIs</p></li><li class="li"><p>High performance and ease of use</p></li><li class="li"><p>Tight integration with Cocoa, Core Foundation, and Core Graphics (Quartz)</p></li><li class="li"><p>Native Unicode handling </p></li><li class="li"><p>64-bit application support</p></li><li class="li"><p>Clean, simple, consistent API design</p></li><li class="li"><p>Simple interfaces for simple operations</p></li><li class="li"><p>A flexible interface to layout and glyph data</p></li><li class="li"><p>A predictable cost structure and rational division of labor</p></li></ul><p>A primary design goal of Core Text layout is to make simple things easy to do. So, for example, if you want to draw a paragraph of text or a simple text label on the screen, you don’t need much code. A corollary principle of the Core Text design is that clients are not required to pay for features they don’t use. </p><p>The objects defined by Core Text opaque types provide a progression from simplicity to complexity, in terms of their use and interface. That is, higher-level objects do more for you, and so they are easier to use (although they may be more complex internally). For example, the highest-level object in Core Text is the framesetter, which fills a path (defined by a CGPath object representing a rectangle) with text. The framesetter object uses other Core Text objects, such as typesetter, line, and glyph run objects, to accomplish its work: creating frame objects, which are lines of glyphs laid out within a shape.</p><p>Clients who simply need to lay out  a paragraph need only work with the framesetter. Clients who need to intervene in the text layout process at a lower level can deal with lower level objects, such as line objects. Line objects can draw themselves individually or be used to obtain glyph information. With Core Text you use the highest-level object you can to get your job done. </p><a name="//apple_ref/doc/uid/TP40005533-CH3-DontLinkElementID_10" title="Core Text Features and Capabilities"></a><h2>Core Text Features and Capabilities</h2><p>Core Text performs text layout and font access. The text layout engine generates glyphs from characters and positions the glyphs into glyph runs, lines, and multiline frames. It also provides glyph- and layout-related data, such as glyph positioning and measurement of lines and frames. The API handles character attributes and paragraph styles, including various types of tab styles and positioning.</p><p>The Core Text font API brings to Carbon developers the same capabilities enjoyed by Cocoa developers through <code>NSFont</code> and <code>NSFontDescriptor</code>. The API provides font viewing and selecting. It provides font references, font descriptors (objects that encapsulate font data sufficient to instantiate a font reference), and easy access to font data. It also provides support for multiple master fonts, font variations, font cascading, and font linking. The Core Text font API is designed to be very complete, so that you don’t have to go to different layers to do what you need to do. </p><a name="//apple_ref/doc/uid/TP40005533-CH3-DontLinkElementID_11" title="System Data Types and Services"></a><h3>System Data Types and Services</h3><p>Core Text uses system data types and services wherever possible, and you use the same conventions that pertain to the other core frameworks in Mac OS X. So, for example, Core Text uses Core Foundation objects for many input and output parameters, enabling them to be retained, released, and stored in Core Foundation collection classes. Other objects handled by Core Text are provided by the Core Graphics framework, for example, CGPath objects. Moreover, because many Core Foundation objects are toll-free bridged with Cocoa Foundation objects, you can usually use Foundation objects in place of Core Foundation objects passed into Core Text functions. Use of these standard types and toll-free bridging ensure that you don’t have to perform expensive type conversions to get data into and out of Core Text. </p><p>Core Text is built to work directly with Core Graphics, also known as Quartz, which is the high-speed graphics rendering engine that handles two-dimensional imaging at the lowest level in Mac OS X. Quartz is the only way to get glyphs drawn at a fundamental level, and, because Core Text provides all data in a form directly usable by Quartz, the result is high-performance text rendering.</p><a name="//apple_ref/doc/uid/TP40005533-CH3-DontLinkElementID_12" title="Core Text Input"></a><h3>Core Text Input</h3><p>The input type most basic to Core Text is the Core Foundation attributed string, represented by <code>CFAttributedStringRef</code> or its Cocoa counterpart, <code>NSAttributedString</code>, which are toll-free bridged. The attributes are key-value pairs that define style characteristics of the characters in the string, which are grouped in ranges that share the same attributes. Examples of text attributes are font and color. The attributes themselves are passed into attributed strings, and retrieved from them, using CFDictionary objects. (Though <code>CFDictionaryRef</code> and <code>NSDictionary</code> are also toll-free bridged, the individual attribute objects stored in the dictionary may not be.) The typesetting mechanism in Core Text uses the information in the attributed string to perform character-to-glyph conversion. </p><a name="//apple_ref/doc/uid/TP40005533-CH3-DontLinkElementID_13" title="Characters and Glyphs"></a><h3>Characters and Glyphs</h3><p>One of the most important capabilities of fine typesetting is character-to-glyph conversion. It is important to distinguish between characters and glyphs in discussing a text layout engine. Characters are essentially numbers representing code points in a character set or encoding scheme, such as Unicode, the character set used for all text in Mac OS X. The Unicode standard provides a unique number for every character in every modern written language in the world, independent of the platform, program, and programming language being used.</p><p>A glyph is a graphic shape used to depict a character. Glyphs are also represented by numeric codes, called glyph codes, that are indexes into a particular font. Glyphs are selected during composition and layout processing by the character-to-glyph conversion process. There are any number of glyphs that correspond to a particular character. For example, the character “uppercase A” has different glyphs for different typefaces (such as Helvetica and Times) and type styles (such as bold and italic). <span class="content_text">Figure 1-1</span> shows various glyphs, all of which represent an “uppercase A.“</p><br/><div><a name="//apple_ref/doc/uid/TP40005533-CH3-SW3" title="Figure 1-1Glyphs of the character A"></a><p><strong>Figure 1-1&nbsp;&nbsp;</strong>Glyphs of the character A</p><img src = "../Art/glyph_a.gif" alt = "Glyphs of the character A" width="307" height="69"></div><br/><p>Moreover, the correspondence between characters and glyphs is not one to one, and the context within which a character appears can affect the glyph chosen to represent it. For example, in many fonts an “f” and “l” appearing side-by-side in a character string are replaced by a ligature, which is a single glyph depicting the letters joined together. <span class="content_text">Figure 1-2</span> shows two examples of individual characters and the single-glyph ligatures often used when they are adjacent. Character-to-glyph conversion is a complex and difficult task that Core Text performs quickly and efficiently.</p><br/><div><a name="//apple_ref/doc/uid/TP40005533-CH3-SW4" title="Figure 1-2Ligatures"></a><p><strong>Figure 1-2&nbsp;&nbsp;</strong>Ligatures</p><img src = "../Art/romanligatures.gif" alt = "Ligatures" width="133" height="124"></div><br/><a name="//apple_ref/doc/uid/TP40005533-CH3-DontLinkElementID_14" title="Core Text Objects"></a><h2>Core Text Objects</h2><p>Core Text objects are based on the corresponding opaque types defined by the framework. In the sections that follow, you learn how the primary Core Text objects interact to accomplish various client tasks. </p><a name="//apple_ref/doc/uid/TP40005533-CH3-DontLinkElementID_15" title="Layout Objects"></a><h3>Layout Objects</h3><p>Layout objects make up the Core Text layout engine. This section discusses the primary layout objects: framesetter, frame, typesetter, line, and glyph run objects. In addition this section briefly discusses the other Core Text layout objects: paragraph styles, text tabs, and glyph info objects.</p><a name="//apple_ref/doc/uid/TP40005533-CH3-DontLinkElementID_16" title="Framesetters and Frames"></a><h4>Framesetters and Frames</h4><p>The framesetter is the highest-level object in the Core Text layout engine, represented by the CTFramesetter opaque type. A framesetter generates text frames by filling a path with text. That is, CTFramesetter is an object factory for CTFrame objects that are ready to draw.</p><p>The framesetter takes an attributed string object (CFAttributedString) and a shape descriptor object (CGPath) and calls into the typesetter to create line objects that fill that shape. The output is a frame object containing an array of lines. This array of lines is a paragraph, a multiline layout. The frame can draw itself directly into a graphic context. You can also retrieve the lines to manipulate before drawing. For example, you might adjust their positioning. <span class="content_text">Figure 1-3</span> shows the data flow among objects performing text layout.</p><br/><div><a name="//apple_ref/doc/uid/TP40005533-CH3-SW7" title="Figure 1-3Text layout data flow"></a><p><strong>Figure 1-3&nbsp;&nbsp;</strong>Text layout data flow</p><img src = "../Art/text_layout_flow.jpg" alt = "Text layout data flow" ></div><br/><p>The framesetter applies paragraph styles to the frame text as it is laid out. Paragraph styles are represented in Core Text by objects storing attributes that affect paragraph layout. Among these attributes are alignment, tab stops, writing direction, line-breaking mode, and indentation settings.</p><p>It’s advantageous to use the framesetter to perform the common operation of typesetting a multiline paragraph because it handles all of the details of producing frames, instantiating other objects, such as the typesetter, as needed. The CTFramesetter opaque type provides functions to create a framesetter with an attributed string, to create frame objects, and to return its typesetter. As with all Core Text objects, CTFramesetter can also return its Core Foundation type identifier. </p><a name="//apple_ref/doc/uid/TP40005533-CH3-DontLinkElementID_17" title="Typesetters"></a><h4>Typesetters</h4><p>A typesetter performs the fundamental text layout operations of character-to-glyph conversion and positioning of those glyphs into lines. That is, it determines which glyphs to use and where to place them relative to each other, producing line objects. Typesetters are represented by the CTTypesetter opaque type.</p><p>The typesetter also suggests line breaks. It finds how many glyphs can fit within a single line within a given space. It then determines the length of the line by using word breaks, word wrapping, or finer-grained cluster breaks. Simple word wrapping is the default method of creating line breaks. </p><p>The framesetter instantiates a typesetter and uses it to create the line objects used to fill a frame. You can also use a typesetter directly, as described in <span class="content_text"><a href="../Operations/Operations.html#//apple_ref/doc/uid/TP40005533-CH4-SW16">“Manual Line Breaking.”</a></span></p><a name="//apple_ref/doc/uid/TP40005533-CH3-DontLinkElementID_18" title="Lines and Glyph Runs"></a><h4>Lines and Glyph Runs</h4><p>A line object represents a line of text and is represented in Core Text by the CTLine opaque type. A CTLine object contains an array of glyph runs. Line objects are created by the typesetter during a framesetting operation and, like frames, can draw themselves directly into a graphics context. Line objects hold the glyphs that are the result of the text layout process, created from text and style information.</p><p>A line corresponds to a range of characters. It could be miles long or, more often, one of a series of lines contained within a paragraph. The paragraph is represented in Core Text by a CTFrame object, which contains the paragraph’s line objects. Accordingly, you can retrieve line objects from their frame object.</p><p>A line object contains glyph-run objects, represented by the CTRun opaque type. A glyph run is a set of consecutive glyphs sharing the same attributes and direction. The typesetter creates glyph runs as it produces lines from character strings, attributes, and font objects. That is, a line is constructed of one or more glyphs runs. Glyph runs can draw themselves into a graphic context, if desired, although most clients have no need to interact directly with glyph runs. <span class="content_text">Figure 1-4</span> shows the conceptual hierarchy of a frame object containing line objects that, in turn, contain glyph-run objects.</p><br/><div><a name="//apple_ref/doc/uid/TP40005533-CH3-SW5" title="Figure 1-4A frame object containing lines and glyph runs"></a><p><strong>Figure 1-4&nbsp;&nbsp;</strong>A frame object containing lines and glyph runs</p><img src = "../Art/glyph_runs.jpg" alt = "A frame object containing lines and glyph runs" ></div><br/><p>CTLine has a convenience method for creating a freestanding line independent of a frame, <code><a href="../../../Reference/CTLineRef/Reference/reference.html#//apple_ref/c/func/CTLineCreateWithAttributedString" target="_top">CTLineCreateWithAttributedString</a></code>. You can use this method to create a line object directly from an attributed string without needing to create and manage a typesetter. Without a typesetter, however, there’s no way to calculate line breaks, so this method is meant for a single line only (for example, creating a text label).</p><p>After you have a line object, you can do a number of things with it. For example, you can have the line create a justified or truncated copy of itself, and you can ask the line for pen offsets for various degrees of flushness. You can use these pen offsets to draw the line with left, right, or centered alignments. You can also ask the line for measurements, such as its image bounds and typographic bounds. Image bounds represent the rectangle tightly enclosing the graphic shapes of the glyphs actually appearing in the line. Typographic bounds include the height of the ascenders in the font and the depth of its descenders, regardless of whether those features appear in the glyphs in a given line. </p><p>Like a frame object, a line object is ready to draw. You simply set the text position in a Core Graphics context and have the line draw itself. Core Text uses the same placement strategy as Quartz, setting the origin of the text on the text baseline.</p><p>In Quartz, you specify the location of text in user-space coordinates. The text matrix specifies the transform from text space to user space. The text position is stored in the t<em>x</em> and t<em>y</em> variables of the text matrix. When you first create a graphics context, it initializes the text matrix to the identity matrix; thus text-space coordinates are initially the same as user-space coordinates. Quartz conceptually concatenates the text matrix with the current transformation matrix and other parameters from the graphics state to produce the final text-rendering matrix, that is, the matrix actually used to draw the text on the page. </p><a name="//apple_ref/doc/uid/TP40005533-CH3-DontLinkElementID_19" title="Other Layout Objects"></a><h4>Other Layout Objects</h4><p>In addition to the framesetter, frame, typesetter, and line objects, Core Text provides other objects to complete the text layout process: paragraph style, text tab, and glyph info objects.</p><p>Paragraph style objects encapsulate paragraph or ruler attributes in an attributed string and are represented by the CTParagraphStyle opaque type. A paragraph style object is a complex attribute value in an attributed string, storing a number of subattributes that affect paragraph layout for the characters of the string. Among these subattributes are alignment, tab stops, writing direction, line-breaking mode, and indentation settings. The CTTextTab opaque type represents a tab stop in a paragraph style, storing an alignment type and location. The CTGlyphInfo opaque type enables you to override a font's specified mapping from Unicode to the glyph ID.</p><a name="//apple_ref/doc/uid/TP40005533-CH3-DontLinkElementID_20" title="Font Objects"></a><h3>Font Objects</h3><p>Font objects are those Core Text objects dealing directly with fonts: the font reference itself, font descriptor objects, and font collection objects.</p><a name="//apple_ref/doc/uid/TP40005533-CH3-DontLinkElementID_21" title="Fonts"></a><h4>Fonts</h4><p>Fonts provide assistance in laying out glyphs relative to one another and are used to establish the current font when drawing in a graphics context. The Core Text font opaque type (CTFont) is a specific font instance that encapsulates a lot of information. Its reference type, <code>CTFontRef</code>, is toll-free bridged with <code>NSFont</code>. When you create a CTFont object, you typically specify (or use a default) point size and transformation matrix, which gives the font instance specific characteristics. You can then query the font object for many kinds of information about the font at that particular point size, such as character-to-glyph mapping, encodings, font metric data, and glyph data, among other things. Font metrics are parameters such as ascent, descent, leading, cap height, x-height, and so on. Glyph data includes parameters such as bounding rectangles and glyph advances.</p><p>There are many ways to create font references. The preferred method is from a font descriptor using <code><a href="../../../Reference/CTFontRef/Reference/reference.html#//apple_ref/c/func/CTFontCreateWithFontDescriptor" target="_top">CTFontCreateWithFontDescriptor</a></code>. You can also use a number of conversion APIs, depending on what you have to start with. For example, you can use the PostScript name of the typeface (<code><a href="../../../Reference/CTFontRef/Reference/reference.html#//apple_ref/c/func/CTFontCreateWithName" target="_top">CTFontCreateWithName</a></code>), an ATS font reference (<code><a href="../../../Reference/CTFontRef/Reference/reference.html#//apple_ref/c/func/CTFontCreateWithPlatformFont" target="_top">CTFontCreateWithPlatformFont</a></code>), a Core Graphics font reference (<code><a href="../../../Reference/CTFontRef/Reference/reference.html#//apple_ref/c/func/CTFontCreateWithGraphicsFont" target="_top">CTFontCreateWithGraphicsFont</a></code>), or a QuickDraw font reference (<code><a href="../../../Reference/CTFontRef/Reference/reference.html#//apple_ref/c/func/CTFontCreateWithQuickdrawInstance" target="_top">CTFontCreateWithQuickdrawInstance</a></code>). There’s also <code><a href="../../../Reference/CTFontRef/Reference/reference.html#//apple_ref/c/func/CTFontCreateUIFontForLanguage" target="_top">CTFontCreateUIFontForLanguage</a></code>, which creates a reference for the user-interface font for the application you’re using in the localization you’re using.</p><p>Core Text font references provide a sophisticated, automatic font-substitution mechanism called font cascading. This mechanism takes font traits into account, so it does a better job than previous schemes of picking an appropriate font to substitute for a missing font. Font cascading is based on cascade lists, which are arrays of ordered font descriptors. There is a system default cascade list (which is polymorphic, based on the user's language setting and current font) and a font cascade list that is specified at font creation time. Using the information in the font descriptors, the cascading mechanism can match fonts according to style as well as matching characters. The <code><a href="../../../Reference/CTFontRef/Reference/reference.html#//apple_ref/c/func/CTFontCreateForString" target="_top">CTFontCreateForString</a></code> function uses cascade lists to pick an appropriate font to encode a given string. You specify and retrieve font cascade lists using the <code><a href="../../../Reference/CTFontDescriptorRef/Reference/reference.html#//apple_ref/c/data/kCTFontCascadeListAttribute" target="_top">kCTFontCascadeListAttribute</a></code> property. </p><a name="//apple_ref/doc/uid/TP40005533-CH3-DontLinkElementID_22" title="Font Descriptors"></a><h4>Font Descriptors</h4><p>Font descriptors, represented by the CTFontDescriptor opaque type, provide a mechanism to describe a font completely with a dictionary of attributes. <code>CTFontDescriptorRef</code> is toll-free bridged to <code>NSFontDescriptor</code>. The attributes are properties such as PostScript name, family, and style, and traits such as bold, italic, and monospace. The font descriptor can then be used to create or modify a CTFont object. Font descriptors can be serialized and stored in a document to provide persistence for fonts. <span class="content_text">Figure 1-5</span> illustrates the font system using a font descriptor to create a specific font instance.</p><br/><div><a name="//apple_ref/doc/uid/TP40005533-CH3-SW6" title="Figure 1-5Creating a font from a font descriptor"></a><p><strong>Figure 1-5&nbsp;&nbsp;</strong>Creating a font from a font descriptor</p><img src = "../Art/query_font_system.jpg" alt = "Creating a font from a font descriptor" ></div><br/><p>A font descriptor can also be considered as a query into the font system. You can create a font descriptor with an incomplete specification, that is, with one or just a few values in the attribute dictionary, and the system will choose the most appropriate font from those available. The system can also give you a complete list of font descriptors matching your query via <code><a href="../../../Reference/CTFontDescriptorRef/Reference/reference.html#//apple_ref/c/func/CTFontDescriptorCreateMatchingFontDescriptors" target="_top">CTFontDescriptorCreateMatchingFontDescriptors</a></code>.</p><a name="//apple_ref/doc/uid/TP40005533-CH3-DontLinkElementID_23" title="Font Collections"></a><h4>Font Collections</h4><p>Font collections are unions of font descriptors, that is, groups of font descriptors taken as a single object. A font collection is represented by the CTFontCollection opaque type. Font collections provide the capabilities of font enumeration, access to global and custom font collections, and access to the font descriptors comprising the collection. You can, for example, create a font collection of all the fonts available in the system by calling <code><a href="../../../Reference/CTFontCollectionRef/Reference/reference.html#//apple_ref/c/func/CTFontCollectionCreateFromAvailableFonts" target="_top">CTFontCollectionCreateFromAvailableFonts</a></code>, and you can use the collection to obtain an array of all of the member font descriptors. There is also a function that takes a callback parameter used to sort the returned array of font descriptors. </p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Introduction/Introduction.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../Operations/Operations.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-06-09<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Carbon/Conceptual/CoreText_Programming/Overview/Overview.html%3Fid%3DTP40005533-1.3&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Carbon/Conceptual/CoreText_Programming/Overview/Overview.html%3Fid%3DTP40005533-1.3&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Carbon/Conceptual/CoreText_Programming/Overview/Overview.html%3Fid%3DTP40005533-1.3&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>