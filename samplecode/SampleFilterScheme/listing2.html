<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>SampleFilterScheme - /SampleFilterScheme.cpp</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/Darwin/index.html">Darwin</a> &gt; <a href="../../samplecode/Darwin/idxHardwareDrivers-date.html">Hardware & Drivers</a> &gt; <A HREF="javascript:location.replace('index.html');">SampleFilterScheme</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">SampleFilterScheme</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/SampleFilterScheme.cpp</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Readme.txt</option>
<option value="listing2.html">/SampleFilterScheme.cpp</option>
<option value="listing3.html">/SampleFilterScheme.h</option></select>
				</p>
				</form>
				<p><strong><a href="SampleFilterScheme.zip">Download Sample</a></strong> (&#147;SampleFilterScheme.zip&#148;, 91.8K)<BR>
<strong><a href="SampleFilterScheme.dmg">Download Sample</a></strong> (&#147;SampleFilterScheme.dmg&#148;, 164.1K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*
  File:      SampleFilterScheme.cpp
  
  Description:  This sample demonstrates a simple filter scheme that matches an HFS+ media object
          with a custom content hint property. This is a null filter scheme which passes all
          operations through to its provider unchanged. 

          The sample also illustrates how such a media object can be created using the command 
          line disk image tool.
  
  Copyright:      &copy; Copyright 2002-2005 Apple Computer, Inc. All rights reserved.
  
  Disclaimer:    IMPORTANT:  This Apple software is supplied to you by Apple Computer,
          Inc. (&ldquo;Apple&rdquo;) in consideration of your agreement to the following
          terms, and your use, installation, modification or redistribution of
          this Apple software constitutes acceptance of these terms.  If you do
          not agree with these terms, please do not use, install, modify or
          redistribute this Apple software.
          
          In consideration of your agreement to abide by the following terms, and
          subject to these terms, Apple grants you a personal, non-exclusive
          license, under Apple&rsquo;s copyrights in this original Apple software (the
          &ldquo;Apple Software&rdquo;), to use, reproduce, modify and redistribute the Apple
          Software, with or without modifications, in source and/or binary forms;
          provided that if you redistribute the Apple Software in its entirety and
          without modifications, you must retain this notice and the following
          text and disclaimers in all such redistributions of the Apple Software. 
          Neither the name, trademarks, service marks or logos of Apple Computer,
          Inc. may be used to endorse or promote products derived from the Apple
          Software without specific prior written permission from Apple.  Except
          as expressly stated in this notice, no other rights or licenses, express
          or implied, are granted by Apple herein, including but not limited to
          any patent rights that may be infringed by your derivative works or by
          other works in which the Apple Software may be incorporated.
          
          The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE
          MAKES NO WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION
          THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS
          FOR A PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND
          OPERATION ALONE OR IN COMBINATION WITH YOUR PRODUCTS.
          
          IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL
          OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
          SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
          INTERRUPTION) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION,
          MODIFICATION AND/OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED
          AND WHETHER UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE),
          STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE
          POSSIBILITY OF SUCH DAMAGE.
          
  Change History (most recent first):
        
      &lt;3&gt;    11/01/2005      Updated to produce a universal binary. Now requires
                    Xcode 2.2 or later to build.
      &lt;2&gt;    03/03/2005      Updated hdiutil instructions for 10.3 and later.
                    Added support for filtering the boot volume.
            &lt;1&gt;     01/22/2002      New sample.
        
*/

#include &lt;IOKit/assert.h&gt;
#include &lt;IOKit/IODeviceTreeSupport.h&gt;
#include &lt;IOKit/IOLib.h&gt;
#include &quot;SampleFilterScheme.h&quot;

#ifdef DEBUG
#define DEBUG_LOG IOLog
#else
#define DEBUG_LOG(...)
#endif


//  This filter scheme is set up to match IOMedia objects with the Content Hint
//  property set to &quot;Apple_DTS_Filtered_HFS&quot; (see the matching personality in this project's
//  Info.plist). To test this filter scheme, please see the instructions in the Read Me file
//  that comes with this sample.  

#define super IOStorage
OSDefineMetaClassAndStructors(com_apple_dts_driver_SampleFilterScheme, IOStorage)

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

bool com_apple_dts_driver_SampleFilterScheme::init(OSDictionary* properties)
{    
  //
    // Initialize this object's minimal state.
    //

    // State our assumptions.

    // Ask our superclass' opinion.

    bool initSuccessful = super::init(properties);

  // The DEBUG_LOG call must follow the call to super::init(). Otherwise getName() 
  // will panic because the metaclass info isn't initialized until then.
  
  DEBUG_LOG(&quot;%s[%p]::%s(%p)\n&quot;, getName(), this, __FUNCTION__, properties);

    if (initSuccessful) {
    // Initialize our state.

    _childMedia = 0;
  }

    return initSuccessful;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

void com_apple_dts_driver_SampleFilterScheme::free(void)
{
    DEBUG_LOG(&quot;%s[%p]::%s()\n&quot;, getName(), this, __FUNCTION__);
    
  //
    // Free all of this object's outstanding resources.
    //

    if (_childMedia) {
    _childMedia-&gt;release();
  }

    super::free();
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

IOMedia* com_apple_dts_driver_SampleFilterScheme::getProvider(void) const
{
    DEBUG_LOG(&quot;%s[%p]::%s()\n&quot;, getName(), this, __FUNCTION__);
    
  //
    // Obtain this object's provider.  We override the superclass's method
    // to return a more specific subclass of OSObject -- an IOMedia.  This
    // method serves simply as a convenience to subclass developers.
    //

    return (IOMedia*) IOService::getProvider();
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

bool com_apple_dts_driver_SampleFilterScheme::start(IOService* provider)
{    
    DEBUG_LOG(&quot;%s[%p]::%s(%p)\n&quot;, getName(), this, __FUNCTION__, provider);
    
  //
    // Publish the new media object which represents our filtered content.
    //

    IOMedia* media = OSDynamicCast(IOMedia, provider);
    
    // State our assumptions.

    assert(media);
    
    // Ask our superclass' opinion.

    if (super::start(provider) == false) {
        return false;
  }

    // Attach and register the new media object.

    IOMedia* childMedia = new IOMedia;

    if (childMedia) {
        if (childMedia-&gt;init(
                /* base               */ 0,
                /* size               */ media-&gt;getSize(),
                /* preferredBlockSize */ media-&gt;getPreferredBlockSize(),
                /* isEjectable        */ media-&gt;isEjectable(),
                /* isWhole            */ false,
                /* isWritable         */ media-&gt;isWritable(),
                /* contentHint        */ &quot;Apple_HFS&quot; )) {
            
      // Set a name for this partition.
            
            UInt32 partitionID = 1;
            
            char name[24];
            sprintf(name, &quot;Apple_DTS_Filtered %ld&quot;, partitionID);
            childMedia-&gt;setName(name);

            // Set a location value (the partition number) for this partition.

            char location[12];
            sprintf(location, &quot;%ld&quot;, partitionID);
            childMedia-&gt;setLocation(location);

            // Attach the new media to this driver

            _childMedia = childMedia;
            
            childMedia-&gt;attach(this);
      
#ifdef FILTER_BOOT_VOLUME

      /*
        This next call allows this filter scheme to be installed on the boot partition.
        
        First, some background on why this is necessary.
        
        Once Open Firmware (OF) has chosen the volume to boot from, it loads the secondary loader (BootX)  
        from that volume and jumps to it. The secondary loader is responsible for actually loading
        and running the kernel, passing to it various parameters that are inherited from OF
        (primarily the device tree).
        
        Once the kernel comes up, it has to mount the root volume. By this point OF is no
        longer running, so the kernel determines the root volume by interpreting a parameter that  
        OF passed to it. This parameter is the &quot;rootpath&quot; property of the &quot;/chosen&quot; node in the OF
        device tree. The kernel gets this value and looks in the I/O Registry for a node whose
        OF path matches this value. The kernel then uses this node as the root device.
        
        The kernel has no knowledge that a filter scheme was installed on top of that node,
        so it continues booting from the unfiltered media object. Later on the  
        Disk Arbitration server comes up, notices that the filter scheme is  
        publishing a new leaf node that hasn't been mounted on, and mounts the file  
        system on that node. Hence two copies of the boot volume appear on the desktop with
        separate data paths, a recipe for quickly corrupting the contents of the volume.
        
        The solution is for the filter scheme to &quot;move&quot; the last device tree component from its parent
        to its child. That is, it needs to detach the parent from the device tree path, keeping track
        of its name@location value, then attach it to the child. This must be done before publishing the
        new media object via registerService(). The reverse needs to be done in stop().
        
        Note that if you want this filter scheme to be loaded at boot time (so that it can be installed
        on top of the boot volume), this project has a second target called &quot;Filter Boot Volume&quot;. Building
        this target will include the code bracketed by #ifdef FILTER_BOOT_VOLUME and will include a
        different Info.plist file containing the property OSBundleRequired = &quot;Local-Root&quot;. (Keep this
        detail in mind: if you change something in Info.plist, be sure to make the same change in
        Info-FILTER_BOOT_VOLUME.plist. There's no equivalent to #ifdef for plists.)
        
        Only build the &quot;Filter Boot Volume&quot; target if you really need to filter the boot volume.
        Otherwise, build the default &quot;Don't Filter Boot&quot; target.
      */

            (void) attachMediaObjectToDeviceTree(childMedia);

#endif
      
      // Now publish the child media object.
      
      childMedia-&gt;registerService();

            return true;
        }
        else {
            childMedia-&gt;release();
            childMedia = 0;
        }
    }

    return false;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

void com_apple_dts_driver_SampleFilterScheme::stop(IOService* provider)
{
    DEBUG_LOG(&quot;%s[%p]::%s(%p)\n&quot;, getName(), this, __FUNCTION__, provider);
    
  //
    // Clean up after the media object we published before terminating.
    //

    // State our assumptions.

    assert(_childMedia);

#ifdef FILTER_BOOT_VOLUME

    // Detach the media object we previously attached to the device tree.
  // See start() for an explanation of this call.
  
  if (_childMedia) {
    detachMediaObjectFromDeviceTree(_childMedia);
  }
  
#endif

    super::stop(provider);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

bool com_apple_dts_driver_SampleFilterScheme::handleOpen(IOService* client,
                                                         IOOptionBits options,
                                                         void* argument)
{
    //
    // The handleOpen method grants or denies permission to access this object
    // to an interested client.  The argument is an IOStorageAccess value that
    // specifies the level of access desired -- reader or reader-writer.
    //
    // This method can be invoked to upgrade or downgrade the access level for
    // an existing client as well.  The previous access level will prevail for
    // upgrades that fail, of course.   A downgrade should never fail.  If the
    // new access level should be the same as the old for a given client, this
    // method will do nothing and return success.  In all cases, one, singular
    // close-per-client is expected for all opens-per-client received.
    //
    // This implementation replaces the IOService definition of handleOpen().
    //
    // We are guaranteed that no other opens or closes will be processed until
    // we make our decision, change our state, and return from this method.
    //

    DEBUG_LOG(&quot;%s[%p]::%s(%p, %lu, %p)\n&quot;, getName(), this, __FUNCTION__, client, options, argument);

    return getProvider()-&gt;open(this, options, (IOStorageAccess) argument);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

bool com_apple_dts_driver_SampleFilterScheme::handleIsOpen(const IOService* client) const
{
    //
    // The handleIsOpen method determines whether the specified client, or any
    // client if none is specified, presently has an open on this object.
    //
    // This implementation replaces the IOService definition of handleIsOpen().
    //
    // We are guaranteed that no other opens or closes will be processed until
    // we return from this method.
    //

    DEBUG_LOG(&quot;%s[%p]::%s(%p)\n&quot;, getName(), this, __FUNCTION__, client);

    return getProvider()-&gt;isOpen(this);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

void com_apple_dts_driver_SampleFilterScheme::handleClose(IOService* client, IOOptionBits options)
{
    //
    // The handleClose method closes the client's access to this object.
    //
    // This implementation replaces the IOService definition of handleClose().
    //
    // We are guaranteed that no other opens or closes will be processed until
    // we change our state and return from this method.
    //

    DEBUG_LOG(&quot;%s[%p]::%s(%p, %lu)\n&quot;, getName(), this, __FUNCTION__, client, options);

    assert(client);

    getProvider()-&gt;close(this, options);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

void com_apple_dts_driver_SampleFilterScheme::read(IOService* __attribute__ ((unused)) client,
                                                   UInt64 byteStart,
                                                   IOMemoryDescriptor* buffer,
                                                   IOStorageCompletion completion)
{
    //
    // Read data from the storage object at the specified byte offset into the
    // specified buffer, asynchronously. When the read completes, the caller
    // will be notified via the specified completion action.
    //
    // The buffer will be retained for the duration of the read.
    //
    // For simple partition schemes, the default behavior is to simply pass the
    // read through to the provider media.  More complex partition schemes such
    // as RAID will need to do extra processing here.
    //

    DEBUG_LOG(&quot;%s[%p]::%s(%p, %llu, %p, %p)\n&quot;, getName(), this, __FUNCTION__, client, byteStart, buffer, &amp;completion);

    getProvider()-&gt;read(this, byteStart, buffer, completion);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

void com_apple_dts_driver_SampleFilterScheme::write(IOService* __attribute__ ((unused)) client,
                                                    UInt64 byteStart,
                                                    IOMemoryDescriptor* buffer,
                                                    IOStorageCompletion completion)
{
    //
    // Write data into the storage object at the specified byte offset from the
    // specified buffer, asynchronously. When the write completes, the caller
    // will be notified via the specified completion action.
    //
    // The buffer will be retained for the duration of the write.
    //
    // For simple partition schemes, the default behavior is to simply pass the
    // write through to the provider media. More complex partition schemes such
    // as RAID will need to do extra processing here.
    //

    DEBUG_LOG(&quot;%s[%p]::%s(%p, %llu, %p, %p)\n&quot;, getName(), this, __FUNCTION__, client, byteStart, buffer, &amp;completion);

    getProvider()-&gt;write(this, byteStart, buffer, completion);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

IOReturn com_apple_dts_driver_SampleFilterScheme::synchronizeCache(IOService* client)
{
    //
    // I/O Kit has provisions for data caches at the driver level, but this is
    // rarely needed and is discouraged by Apple. 99+% of the time the following
    // implementation is just fine.
    //
      
    DEBUG_LOG(&quot;%s[%p]::%s(%p)\n&quot;, getName(), this, __FUNCTION__, client);

    return getProvider()-&gt;synchronizeCache(this);
}

#ifdef FILTER_BOOT_VOLUME

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

bool com_apple_dts_driver_SampleFilterScheme::attachMediaObjectToDeviceTree(IOMedia* media)
{
  //
  // Attach the given media object to the device tree plane.
  //

  IORegistryEntry* child;

    DEBUG_LOG(&quot;%s[%p]::%s(%p)\n&quot;, getName(), this, __FUNCTION__, media);

  if ((child = getParentEntry(gIOServicePlane))) {

    IORegistryEntry* parent;

    if ((parent = child-&gt;getParentEntry(gIODTPlane))) {

      const char* location = child-&gt;getLocation(gIODTPlane);
      const char* name     = child-&gt;getName(gIODTPlane);

      if (media-&gt;attachToParent(parent, gIODTPlane)) {
        media-&gt;setLocation(location, gIODTPlane);
        media-&gt;setName(name, gIODTPlane);

        child-&gt;detachFromParent(parent, gIODTPlane);

        return true;
      }
    }
  }

  return false;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

void com_apple_dts_driver_SampleFilterScheme::detachMediaObjectFromDeviceTree(IOMedia* media)
{
  //
  // Detach the given media object from the device tree plane.
  //

  IORegistryEntry* child;

    DEBUG_LOG(&quot;%s[%p]::%s(%p)\n&quot;, getName(), this, __FUNCTION__, media);

  if ((child = getParentEntry(gIOServicePlane))) {
   
    IORegistryEntry * parent;

    if ((parent = media-&gt;getParentEntry(gIODTPlane))) {

      const char* location = media-&gt;getLocation(gIODTPlane);
      const char* name     = media-&gt;getName(gIODTPlane);

      if (child-&gt;attachToParent(parent, gIODTPlane)) {
        child-&gt;setLocation(location, gIODTPlane);
        child-&gt;setName(name, gIODTPlane);
      }

      media-&gt;detachFromParent(parent, gIODTPlane);
    }
  }
}

#endif</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/SampleFilterScheme/listing2.html%3Fid%3DDTS10000432-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/SampleFilterScheme/listing2.html%3Fid%3DDTS10000432-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/SampleFilterScheme/listing2.html%3Fid%3DDTS10000432-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>