<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>CarbonMDEF - /Sample.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/Carbon/index.html">Carbon</a> &gt; <a href="../../samplecode/Carbon/idxHumanInterfaceToolbox-date.html">Human Interface Toolbox</a> &gt; <A HREF="javascript:location.replace('index.html');">CarbonMDEF</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">CarbonMDEF</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Sample.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/main.c</option>
<option value="listing2.html">/Sample.c</option>
<option value="listing3.html">/Sample.h</option></select>
				</p>
				</form>
				<p><strong><a href="CarbonMDEF.zip">Download Sample</a></strong> (&#147;CarbonMDEF.zip&#148;, 21.4K)<BR>
<strong><a href="CarbonMDEF.dmg">Download Sample</a></strong> (&#147;CarbonMDEF.dmg&#148;, 84.6K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*
  File:    Sample.c

  Contains:  Sample Appearance-savvy, Mac OS X-compatible custom MDEF.

  Version:  1.0

  Disclaimer:  IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc.
        (&quot;Apple&quot;) in consideration of your agreement to the following terms, and your
        use, installation, modification or redistribution of this Apple software
        constitutes acceptance of these terms.  If you do not agree with these terms,
        please do not use, install, modify or redistribute this Apple software.

        In consideration of your agreement to abide by the following terms, and subject
        to these terms, Apple grants you a personal, non-exclusive license, under Apple's
        copyrights in this original Apple software (the &quot;Apple Software&quot;), to use,
        reproduce, modify and redistribute the Apple Software, with or without
        modifications, in source and/or binary forms; provided that if you redistribute
        the Apple Software in its entirety and without modifications, you must retain
        this notice and the following text and disclaimers in all such redistributions of
        the Apple Software.  Neither the name, trademarks, service marks or logos of
        Apple Computer, Inc. may be used to endorse or promote products derived from the
        Apple Software without specific prior written permission from Apple.  Except as
        expressly stated in this notice, no other rights or licenses, express or implied,
        are granted by Apple herein, including but not limited to any patent rights that
        may be infringed by your derivative works or by other works in which the Apple
        Software may be incorporated.

        The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE MAKES NO
        WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED
        WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR
        PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN
        COMBINATION WITH YOUR PRODUCTS.

        IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR
        CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
        GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
        ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION
        OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT
        (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN
        ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  Copyright &copy; 2000-2001 Apple Computer, Inc., All Rights Reserved
*/

#define TARGET_API_MAC_CARBON 1
#include &lt;Carbon.h&gt;

#include &quot;Sample.h&quot;


/*
  This sample code demonstrates how to write an Appearance-savvy, Mac OS X-compatible MDEF.
  It imitates the appearance the standard system MDEF as far as possible.
  
  Features of the standard MDEF that aren't implemented here:
  
    kMenuDrawItemsMsg
    icons
    glyph-based command keys
    custom menu font
    custom menu item text encoding, font, and style
    right-to-left drawing
    pencil glyph substitution
  
  This code has not yet been compiled or run on Mac OS 9. It should be fairly close to
  implementing an Appearance-savvy MDEF for 9, but will require at least CarbonLib 1.3.1
  for DrawThemeTextBox.
  
  There are several tricky platform-specific and OS-version-specific issues to deal with
  in writing an Appearance-savvy MDEF. The major ones:
  
    -  Because menus use a window buffer that contains an alpha channel, drawing into the
      menu must be done with CoreGraphics and not Quickdraw if you would like to have
      a transparent menu. Quickdraw does not understand alpha channels and will simply
      set the alpha channel component of each pixel to 0xFF (making the menu opaque).
      If you are drawing with the Appearance Manager menu-drawing APIs, you will automatically
      use CoreGraphics and your menus will be transparent.
    
    -  Because Quickdraw does not deal with alpha channels, you cannot use Quickdraw to
      scroll a menu's contents without making the menu opaque. Mac OS X 10.1 and later, and
      CarbonLib 1.5 and later, provide a new ScrollMenuImage API that scrolls the menu
      using CoreGraphics. On Mac OS X 10.0.x, there is no good substitute for ScrollMenuImage;
      this sample code just uses ScrollRect.
      
    -  Because menus are partially transparent on Mac OS X, when the Appearance Manager
      draws the menu background inside DrawThemeMenuBackground, it composites the menu
      background together with whatever was previously visible in the menu's window
      buffer. If the menu background is being redrawn because a previously selected menu
      item is being redrawn in an unhilited state, then the previous content of the
      menu's buffer is the blue hilited menu item, and a small fraction of the blue hilite
      will show through the background of the unhilited menu item. The solution to this
      is to erase the area where the menu background will be drawn before drawing the
      background. Mac OS X 10.1 and later, and CarbonLib 1.5 and later, will offer a new
      API to do this, EraseMenuBackground; on Mac OS X 10.0.x, you must use CoreGraphics
      directly.
      
    -  The GetThemeMetric API in Mac OS X 10.1 and later, and in CarbonLib 1.5 and later, has
      several new theme metrics to aid in the layout of a menu. These metrics are not available
      in 10.0.x and must be hard-coded on earlier systems.
      
    -  The check, diamond, bullet, and dash characters, when drawn as mark characters for a
      menu item by the Appearance Manager, are drawn with special customized glyphs that are
      different from the glyphs in the system font. On Mac OS 10.0.x, the public Appearance
      Manager APIs do not provide any way to get these special glyphs. On Mac OS X 10.1 and
      later, the DrawThemeTextBox API has been modified to provide these glyphs automatically,
      so an MDEF should simply always use DrawThemeTextBox to draw the mark characters.
      
    -  When drawing the command, option, control, and shift modifier glyphs in a menu item,
      for compatibility with both Mac OS X 10.0.x and 10.1, you must create the CFString
      containing the glyph characters using CFStringCreateWithBytes, providing a source
      string containing the kMenuCommand/Option/Control/Glyph character codes from Menus.h
      and using the kTextEncodingMacKeyboardGlyphs encoding. If you do not need compatibility
      with 10.0.x, and your MDEF will only run on later releases of Mac OS X, then you can
      create the CFString by specifying the Unicode characters for these glyphs directly
      (these Unicode characters are listed in Events.h). 
      
    -  The following theme fonts are used when drawing a menu:
      
        kThemeMenuItemFont      used for: menu item text, menu command key
        kThemeMenuItemMarkFont    used for: menu mark character
        kThemeMenuItemCmdKeyFont  used for: command key modifier glyphs, menu
                      command key if specified by glyph instead of
                      character code, menu mark if the mark's character
                      code is less than 32 (ASCII space)
                      
    -  DrawThemeTextBox uses the ThemeDrawState constant to modify the shadow and boldness
      of the text; it does not, however, modify the text color based on the draw state.
      It assumes that you have already set up the text color appropriately using 
      SetThemeTextColor. However, there is currently no API for setting the text color
      of a CoreGraphics context based on ThemeDrawState. For this reason, DrawThemeTextBox
      makes an exception to its no-text-color-setup rule; if you pass NULL for the context,
      the text color will be set up appropriately for you. This sample code therefore always
      passes NULL as the CGContextRef parameter to DrawThemeTextBox, even though a context
      is passed to the MDEF by the Menu Manager.
*/


//
// determines whether the MDEF is compatible with Mac OS X 10.0.x (set to zero)
// or only with Mac OS X 10.1 and later (set to one)
//
#define AFTER_MACOSX_10_0_x 0


/*==================================================================================================*/
/*  *\xCAConstants                                            */
/*==================================================================================================*/

// for our wrapper around GetThemeMetric
enum
{
  kThemeMenuMetricMarkColumnWidth,
  kThemeMenuMetricExcludedMarkColumnWidth,
  kThemeMenuMetricMarkIndent,
  kThemeMenuMetricTextLeadingEdgeMargin,
  kThemeMenuMetricTextTrailingEdgeMargin,
  kThemeMenuMetricIndentWidth,
  kThemeMenuMetricIconTrailingEdgeMargin
};
typedef int ThemeMenuMetric;


/*==================================================================================================*/
/*  *\xCATypes                                              */
/*==================================================================================================*/

// for our wrapper glue around EraseMenuBackground, ScrollMenuImage, and CGContextClearRect
typedef OSStatus 
(*EraseMenuBackgroundProc)(
  MenuRef        inMenu,
  const Rect *   inEraseRect,
  CGContextRef   inContext);

typedef OSStatus 
(*ScrollMenuImageProc)(
  MenuRef        inMenu,
  const Rect *   inScrollRect,
  int            inHScroll,
  int            inVScroll,
  CGContextRef   inContext);

typedef void
(*CGContextClearRectProc)(
  CGContextRef   context,
  CGRect         rect);


// useful metrics for menu drawing
typedef struct
{
  SInt16    extraWidth;        // extra width for each item
  SInt16    extraHeightPlain;    // extra height for plain text items
  SInt16    extraHeightIcon;    // extra height for items with icons
  SInt16    markWidth;        // width of the column used to draw the mark character
  SInt16    excludedMarkWidth;    // width of the column when the mark character is excluded
  SInt16    markIndent;        // indent into the mark column where drawing starts
  SInt16    textLeadingMargin;    // margin on the leading edge of the text to where text drawing starts
  SInt16    textTrailingMargin;    // margin on the trailing edge of the text to the end of the text box
  SInt16    indentWidth;      // space allocated per indent level as set by SetMenuItemIndent
  SInt16    itemHeight;        // height of a plain text icon
  SInt16    separatorHeight;    // height of a separator
  SInt16    itemBaseline;      // distance from top of item text to baseline
  SInt16    cmdGlyphWidth;      // width of the command key symbol; used as command key width for items without command keys
  SInt16    cmdCharWidth;      // width of 'W' in the menu item font; used as width of all command chars
}
MenuMetrics;

// info needed to calculate the size of an item
typedef struct
{
  MenuMetrics      metrics;
  MenuItemDataRec    itemData;
}
MenuItemCalcInfo;

// our MenuItem drawing callback gets a pointer to this in its userData
typedef struct
{
  MenuRef        menu;
  MenuAttributes    menuAttr;
  MenuItemCalcInfo  calcInfo;
  CGContextRef    context;
  Boolean        itemSelected;
}
MenuItemDrawInfo;


/*==================================================================================================*/
/*  * Prototypes                                          */
/*==================================================================================================*/

static void          DrawMenu( MenuRef menu, const Rect* bounds, MenuTrackingData* trackingData, CGContextRef context );
static void          SetupItemDrawInfo( MenuRef menu, CGContextRef context, MenuItemDrawInfo* outDrawInfo );
static void          SetupItemRect( const Rect* menuBounds, const MenuTrackingData* trackingData, Rect* outItemRect );
static void          DrawItem( MenuRef menu, MenuItemIndex item, const Rect* menuRect, const Rect* itemRect,
                    const MenuTrackingData* trackingData, Boolean eraseFirst,
                    const MenuItemDrawInfo* drawInfo, CGContextRef context );
static void          FetchMenuItemData( MenuRef menu, MenuItemIndex item, MenuItemDataRec* outItemData );
static void          ReleaseMenuItemData( const MenuItemDataRec* itemData );
//static ThemeMenuType    GetThemeMenuType( MenuRef menu );
static ThemeMenuState    GetItemState( MenuItemAttributes attr, Boolean hilite );
static ThemeMenuItemType  GetItemType( MenuRef menu, MenuItemIndex item, const MenuItemDataRec* itemData, Boolean eraseFirst );
static MenuItemDrawingUPP  GetItemDrawingProc();
static pascal void      ItemDrawingProc( const Rect *inBounds, SInt16 inDepth, Boolean inIsColorDevice, SInt32 inUserData);
static void          DrawCharTextBox( Byte ch, TextEncoding encoding, ThemeFontID font, ThemeDrawState drawState,
                       const Rect* bounds, int baseline, int just, CGContextRef context );
static int          MeasureUnicode( const UniChar* chars, ByteCount length, ThemeFontID font );
static void          DrawUnicode( const UniChar*, ByteCount length, ThemeFontID font, ThemeDrawState drawState, const Rect* bounds, int baseline, int just, CGContextRef context );
static void          DrawScrollArrow( MenuRef menu, const Rect* bounds, MenuTrackingData* trackingData, Boolean downArrow, const MenuMetrics* metrics, CGContextRef context );
static void          SizeMenu( MenuRef menu, Point maxSizes );
static void          GetMenuMetrics( MenuMetrics* outMetrics );
static UniChar        GetCommandGlyph( void );
static void          CalcItemSize( MenuRef menu, const MenuItemCalcInfo* calcInfo, int* outWidth, int* outHeight );
static int          GetCommandKeyWidth( const MenuItemCalcInfo* calcInfo );
static const UniChar*    BuildModifierString( UInt32 modifiers, ByteCount* outLength );
static void          CalcMenuPopUpRect( MenuRef menu, Rect* bounds, int mouseH, int mouseV, short* whichItem );
static void          FindMenuItem( MenuRef menu, const Rect* bounds, Point hitPt, MenuTrackingData* trackingData, CGContextRef context );
static void          AutoScroll( MenuRef menu, const Rect* bounds, Point hitPt, MenuTrackingData* trackingData, MenuItemIndex prevItemSelected, const MenuMetrics* metrics, CGContextRef context );
static void          DrawScrolledItem( MenuRef menu, MenuTrackingData* trackingData, const Rect* menuRect, const Rect* itemRect, const MenuMetrics* metrics, CGContextRef context );
static void          HiliteMenuItem( MenuRef menu, const Rect* bounds, HiliteMenuItemData* hiliteData, CGContextRef context );
static void          HiliteItem( MenuRef menu, const Rect* bounds, MenuTrackingData* trackingData, int i, Boolean hilite, CGContextRef context );
static void          CalcMenuItemBounds( MenuRef menu, Rect* bounds, int i );
static void          GetItemRect( MenuRef menu, const MenuTrackingData* trackingData, const Rect* bounds, int whichItem, int hintItem, int hintBottom, const MenuItemCalcInfo* whichItemInfo, Rect* itemRect );
static int          GetThemeMenuMetric( ThemeMenuMetric metric );
static Boolean        HasNoBackground();
static Boolean        HasAqua();
static void          DoEraseMenuBackground( MenuRef menu, const Rect* rect, CGContextRef context );
static void          DoCGContextClearRect( CGContextRef context, const Rect* rect );
static void          DoScrollMenuImage( MenuRef menu, const Rect* bounds, int dh, int dv, CGContextRef context );


/*==================================================================================================*/
/*  *\xCAFunctions                                            */
/*==================================================================================================*/

/*--------------------------------------------------------------------------------------------------*/
inline Boolean
HasCommandKey( const MenuItemDataRec* itemData )
{
  // the standard MDEF also checks for cmdKeyGlyph and kMenuItemAttrUseVirtualKey here
  return itemData-&gt;cmdKey != 0;
}

/*--------------------------------------------------------------------------------------------------*/
inline CGContextRef
GetTextContext( CGContextRef context )
{
  //
  // There is currently no API for setting up the appropriate text color for a ThemeDrawState
  // in a CGContext. If you pass NULL to DrawThemeTextBox, it will set up the color for you,
  // so we use NULL even though ideally we should be passing the actual context.
  //
  return NULL;
}

/*--------------------------------------------------------------------------------------------------*/
pascal void
SampleMDEF( short msg, MenuRef menu, Rect* bounds, Point hitPt, short* whichItem )
{
    switch ( msg )
    {
    case kMenuInitMsg:
      *whichItem = noErr;
      break;
    
        case kMenuDisposeMsg:
            break;

        case kMenuDrawMsg:
            DrawMenu( menu, bounds, (MenuTrackingData*) whichItem, (CGContextRef) ((MDEFDrawData*) whichItem)-&gt;context );
            break;

        case kMenuSizeMsg:
            SizeMenu( menu, hitPt );
            break;

    case kMenuPopUpMsg:
      CalcMenuPopUpRect( menu, bounds, hitPt.v, hitPt.h, whichItem );
      break;

        case kMenuFindItemMsg:
            FindMenuItem( menu, bounds, hitPt, (MenuTrackingData*) whichItem, (CGContextRef) ((MDEFFindItemData*) whichItem)-&gt;context );
            break;

        case kMenuHiliteItemMsg:
            HiliteMenuItem( menu, bounds, (HiliteMenuItemData*) whichItem, (CGContextRef) ((MDEFHiliteItemData*) whichItem)-&gt;context );
            break;

    case kMenuCalcItemMsg:
      CalcMenuItemBounds( menu, bounds, *whichItem );
      break;
    
        case kMenuThemeSavvyMsg:
            *whichItem = kThemeSavvyMenuResponse;
            break;
            
        default:
            break;
    }
}

/*--------------------------------------------------------------------------------------------------*/
static void
DrawMenu( MenuRef menu, const Rect* bounds, MenuTrackingData* trackingData, CGContextRef context )
{
    int          i;
    int          cItems;
  MenuItemDrawInfo  drawInfo;
  Rect        itemRect;

  trackingData-&gt;virtualMenuBottom = 0;
    
  NormalizeThemeDrawingState();
  SetupItemDrawInfo( menu, context, &amp;drawInfo );
  SetupItemRect( bounds, trackingData, &amp;itemRect );
  
    cItems = CountMenuItems( menu );
    for ( i = 1; i &lt;= cItems; i++ )
    {
    int    height;

    FetchMenuItemData( menu, i, &amp;drawInfo.calcInfo.itemData );
    CalcItemSize( menu, &amp;drawInfo.calcInfo, NULL, &amp;height );
    itemRect.bottom = itemRect.top + height;
        if ( ! ( itemRect.bottom &lt;= bounds-&gt;top || itemRect.top &gt;= bounds-&gt;bottom ) )
          DrawItem( menu, i, bounds, &amp;itemRect, trackingData, false, &amp;drawInfo, context );
    ReleaseMenuItemData( &amp;drawInfo.calcInfo.itemData );
    
    trackingData-&gt;virtualMenuBottom = itemRect.bottom;
    itemRect.top = itemRect.bottom;
    }

  if ( trackingData-&gt;virtualMenuTop &lt; bounds-&gt;top )
    DrawScrollArrow( menu, bounds, trackingData, false, &amp;drawInfo.calcInfo.metrics, context );

  if ( trackingData-&gt;virtualMenuBottom &gt; bounds-&gt;bottom )
    DrawScrollArrow( menu, bounds, trackingData, true, &amp;drawInfo.calcInfo.metrics, context );
}

/*--------------------------------------------------------------------------------------------------*/
static void
SetupItemDrawInfo( MenuRef menu, CGContextRef context, MenuItemDrawInfo* outDrawInfo )
{
  outDrawInfo-&gt;menu = menu;
  GetMenuAttributes( menu, &amp;outDrawInfo-&gt;menuAttr );
  GetMenuMetrics( &amp;outDrawInfo-&gt;calcInfo.metrics );
  outDrawInfo-&gt;context = context;
  outDrawInfo-&gt;itemSelected = false;
}

/*--------------------------------------------------------------------------------------------------*/
static void
SetupItemRect( const Rect* menuBounds, const MenuTrackingData* trackingData, Rect* outItemRect )
{
  outItemRect-&gt;left = menuBounds-&gt;left;
  outItemRect-&gt;right = menuBounds-&gt;right;
  outItemRect-&gt;top = trackingData-&gt;virtualMenuTop;
  outItemRect-&gt;bottom = outItemRect-&gt;top;
}

/*--------------------------------------------------------------------------------------------------*/
static void
DrawItem( MenuRef menu, MenuItemIndex item, const Rect* menuRect, const Rect* itemRect,
      const MenuTrackingData* trackingData, Boolean eraseFirst,
      const MenuItemDrawInfo* drawInfo, CGContextRef context )
{
  if ( eraseFirst )
    DoEraseMenuBackground( menu, itemRect, context );
  
  if ( ( drawInfo-&gt;calcInfo.itemData.attr &amp; kMenuItemAttrSeparator ) != 0 )
  {
    DrawThemeMenuSeparator( itemRect );
  }
  else
  {
    DrawThemeMenuItem( menuRect, itemRect,
               trackingData-&gt;virtualMenuTop, trackingData-&gt;virtualMenuBottom,
               GetItemState( drawInfo-&gt;calcInfo.itemData.attr, drawInfo-&gt;itemSelected ),
               GetItemType( menu, item, &amp;drawInfo-&gt;calcInfo.itemData, eraseFirst ),
               GetItemDrawingProc(), (UInt32) drawInfo );
  }
}

/*--------------------------------------------------------------------------------------------------*/
static void
FetchMenuItemData( MenuRef menu, MenuItemIndex item, MenuItemDataRec* outItemData )
{
  BlockZero( outItemData, sizeof( MenuItemDataRec ) );
  
  outItemData-&gt;whichData =  kMenuItemDataMark
              | kMenuItemDataCmdKey
              | kMenuItemDataCmdKeyModifiers
              | kMenuItemDataSubmenuID
              | kMenuItemDataSubmenuHandle
              | kMenuItemDataEnabled
              | kMenuItemDataAttributes
              | kMenuItemDataCFString
              | kMenuItemDataIndent;
             
  CopyMenuItemData( menu, item, false, outItemData );
}

/*--------------------------------------------------------------------------------------------------*/
static void
ReleaseMenuItemData( const MenuItemDataRec* itemData )
{
  if ( itemData-&gt;cfText != NULL )
    CFRelease( itemData-&gt;cfText );
}

#if 0  // not currently used
/*--------------------------------------------------------------------------------------------------*/
static ThemeMenuType
GetThemeMenuType( MenuRef menu )
{
  ThemeMenuType menuType;
  GetMenuType( menu, &amp;menuType );
  
  if ( !IsMenuItemEnabled( menu, 0 ) )
    menuType |= kThemeMenuTypeInactive;
    
  return menuType;
}
#endif

/*--------------------------------------------------------------------------------------------------*/
static ThemeMenuState
GetItemState( MenuItemAttributes attr, Boolean hilite )
{
  if ( hilite )
    return kThemeMenuSelected;
  else if ( ( attr &amp; kMenuItemAttrDisabled ) != 0 )
    return kThemeMenuDisabled;
  else
    return kThemeMenuActive;
}

/*--------------------------------------------------------------------------------------------------*/
static ThemeMenuItemType
GetItemType( MenuRef menu, MenuItemIndex item, const MenuItemDataRec* itemData, Boolean eraseFirst )
{
  ThemeMenuType    menuType;
  ThemeMenuItemType  itemType = kThemeMenuItemPlain;
  
  GetMenuType( menu, &amp;menuType );
  
  if ( itemData-&gt;submenuHandle != NULL || itemData-&gt;submenuID != 0 )
    itemType |= kThemeMenuItemHierarchical;
    
  if ( item == 1 )
    itemType |= kThemeMenuItemAtTop;
  else if ( item == CountMenuItems( menu ) )
    itemType |= kThemeMenuItemAtBottom;
    
  if ( menuType == kThemeMenuTypeHierarchical )
    itemType |= kThemeMenuItemHierBackground;
  else if ( menuType == kThemeMenuTypePopUp )
    itemType |= kThemeMenuItemPopUpBackground;
    
  if ( !eraseFirst &amp;&amp; HasNoBackground() )
    itemType |= kThemeMenuItemNoBackground;
    
  return itemType;
}

/*--------------------------------------------------------------------------------------------------*/
static MenuItemDrawingUPP
GetItemDrawingProc()
{
  static MenuItemDrawingUPP sDrawingProc;
  if ( sDrawingProc == NULL )
    sDrawingProc = NewMenuItemDrawingUPP( ItemDrawingProc );
  return sDrawingProc;
}

/*--------------------------------------------------------------------------------------------------*/
static pascal void
ItemDrawingProc(const Rect *inBounds, SInt16 inDepth, Boolean inIsColorDevice, SInt32 inUserData)
{
#pragma unused( inDepth, inIsColorDevice )

  MenuItemDrawInfo*  drawInfo = (MenuItemDrawInfo*) inUserData;
  ThemeDrawState    drawState;
  Rect        bounds = *inBounds;
  Rect        boundsT;
  int          baseline = bounds.top + drawInfo-&gt;calcInfo.metrics.itemBaseline;
  
  if ( drawInfo-&gt;itemSelected )
    drawState = kThemeStatePressed;
  else if ( ( drawInfo-&gt;calcInfo.itemData.attr &amp; kMenuItemAttrDisabled ) != 0 )
    drawState = kThemeStateInactive;
  else
    drawState = kThemeStateActive;
  
  // indent
  if ( drawInfo-&gt;calcInfo.itemData.indent &gt; 0 )
    bounds.left += drawInfo-&gt;calcInfo.itemData.indent * drawInfo-&gt;calcInfo.metrics.indentWidth;
  
  // mark character
  if ( ( drawInfo-&gt;menuAttr &amp; kMenuAttrExcludesMarkColumn ) == 0 )
  {
    boundsT = bounds;
    bounds.left += drawInfo-&gt;calcInfo.metrics.markWidth;
    
    if ( drawInfo-&gt;calcInfo.itemData.mark != 0 )
    {
      ThemeFontID font = kThemeMenuItemMarkFont;
      TextEncoding encoding = GetApplicationTextEncoding();
      
      if ( drawInfo-&gt;calcInfo.itemData.mark &lt; kSpaceCharCode )
      {
        font = kThemeMenuItemCmdKeyFont;
        encoding = kTextEncodingMacKeyboardGlyphs;
      }
      
      boundsT.left += drawInfo-&gt;calcInfo.metrics.markIndent;
      boundsT.right = bounds.left;
      
      DrawCharTextBox( drawInfo-&gt;calcInfo.itemData.mark, encoding, font, drawState,
                &amp;boundsT, baseline, teFlushDefault, drawInfo-&gt;context );
    }
  }
  
  // text
  if ( drawInfo-&gt;calcInfo.itemData.cfText != NULL )
  {
    boundsT = bounds;
    boundsT.left += drawInfo-&gt;calcInfo.metrics.textLeadingMargin;
    DrawThemeTextBox( drawInfo-&gt;calcInfo.itemData.cfText, kThemeMenuItemFont, drawState,
              false, &amp;boundsT, teFlushDefault, GetTextContext( drawInfo-&gt;context ) );
  }
  
  // command key
  if ( HasCommandKey( &amp;drawInfo-&gt;calcInfo.itemData ) )
  {
    ByteCount    cch;
    const UniChar*  modifiers;
    
    // the command key character itself
    boundsT = bounds;
    boundsT.left = boundsT.right - drawInfo-&gt;calcInfo.metrics.cmdCharWidth;
    DrawCharTextBox( drawInfo-&gt;calcInfo.itemData.cmdKey, GetApplicationTextEncoding(), kThemeMenuItemFont,
             drawState, &amp;boundsT, baseline, teFlushDefault, drawInfo-&gt;context );
    
    // the modifiers
    boundsT.right = boundsT.left;
    boundsT.left = bounds.right - GetCommandKeyWidth( &amp;drawInfo-&gt;calcInfo );
    modifiers = BuildModifierString( drawInfo-&gt;calcInfo.itemData.cmdKeyModifiers, &amp;cch );
    DrawUnicode( modifiers, cch, kThemeMenuItemCmdKeyFont, drawState, &amp;boundsT,
           baseline, teFlushDefault, drawInfo-&gt;context );
  }
}

/*--------------------------------------------------------------------------------------------------*/
static void
DrawCharTextBox( Byte ch, TextEncoding encoding, ThemeFontID font, ThemeDrawState drawState,
         const Rect* bounds, int baseline, int just, CGContextRef context )
{
  Rect    adjustedBounds = *bounds;
  CFStringRef string = CFStringCreateWithBytes( NULL, &amp;ch, 1, encoding, false );
  
  /*
    Menu item text drawn with the .Keyboard font (used for kThemeMenuItemCmdKeyFont) won't
    always have the same ascent and baseline as text drawn with the regular menu item font,
    since the glyphs in the .Keyboard font may have a different height. Therefore, we first
    determine the baseline of the text and then adjust the bounds rect so the baseline aligns
    with the overall baseline of the menu item.
  */
  if ( font == kThemeMenuItemCmdKeyFont )
  {
    Point   size;
    SInt16   cmdKeyBaseline;
    
    GetThemeTextDimensions( string, kThemeMenuItemCmdKeyFont, drawState, false, &amp;size, &amp;cmdKeyBaseline );
    OffsetRect( &amp;adjustedBounds, 0, baseline - bounds-&gt;top - size.v - cmdKeyBaseline );
  }
  
  DrawThemeTextBox( string, font, drawState, false, &amp;adjustedBounds, just, GetTextContext( context ) );
  CFRelease( string );
}

/*--------------------------------------------------------------------------------------------------*/
static int
MeasureUnicode( const UniChar* chars, ByteCount length, ThemeFontID font )
{
  CFStringRef  str = CFStringCreateWithCharacters( NULL, chars, length );
  Point    pt = {0, 0};
  SInt16    baseline;
  
  GetThemeTextDimensions( str, font, kThemeStateActive, false, &amp;pt, &amp;baseline );
  CFRelease( str );
  return pt.h;
}

/*--------------------------------------------------------------------------------------------------*/
static void
DrawUnicode( const UniChar* chars, ByteCount length, ThemeFontID font, ThemeDrawState drawState,
       const Rect* bounds, int baseline, int just, CGContextRef context )
{
  Rect    adjustedBounds = *bounds;
  CFStringRef  string = CFStringCreateWithCharacters( NULL, chars, length );
  
  /*
    Menu item text drawn with the .Keyboard font (used for kThemeMenuItemCmdKeyFont) won't
    always have the same ascent and baseline as text drawn with the regular menu item font,
    since the glyphs in the .Keyboard font may have a different height. Therefore, we first
    determine the baseline of the text and then adjust the bounds rect so the baseline aligns
    with the overall baseline of the menu item.
  */
  if ( font == kThemeMenuItemCmdKeyFont )
  {
    Point   size;
    SInt16   cmdKeyBaseline;
    
    GetThemeTextDimensions( string, kThemeMenuItemCmdKeyFont, drawState, false, &amp;size, &amp;cmdKeyBaseline );
    OffsetRect( &amp;adjustedBounds, 0, baseline - bounds-&gt;top - size.v - cmdKeyBaseline );
  }
  
  DrawThemeTextBox( string, font, drawState, false, &amp;adjustedBounds, just, GetTextContext( context ) );
  CFRelease( string );
}

/*--------------------------------------------------------------------------------------------------*/
static void
DrawScrollArrow( MenuRef menu, const Rect* bounds, MenuTrackingData* trackingData, Boolean downArrow,
         const MenuMetrics* metrics, CGContextRef context )
{
  Rect        itemRect  = *bounds;
  ThemeMenuState    menuState;
  ThemeMenuType    menuType;
  ThemeMenuItemType  itemType;

  if ( downArrow )
    itemRect.top = itemRect.bottom - metrics-&gt;itemHeight;
  else
    itemRect.bottom = itemRect.top + metrics-&gt;itemHeight;

  //
  // If the entire menu is inactive, disable the item so that it matches the rest of the menu.
  // The menu still scrolls, so technically the item really shouldn't be inactive, but it looks
  // wrong otherwise.
  //
  if ( IsMenuItemEnabled( menu, 0 ) )
    menuState = kThemeMenuActive;
  else
    menuState = kThemeMenuDisabled;

  if ( downArrow )
    itemType = kThemeMenuItemScrollDownArrow;
  else
    itemType = kThemeMenuItemScrollUpArrow;

  GetMenuType( menu, &amp;menuType );

  if ( menuType == kThemeMenuTypeHierarchical )
    itemType |= kThemeMenuItemHierBackground;
  else if ( menuType == kThemeMenuTypePopUp )
    itemType |= kThemeMenuItemPopUpBackground;

  // the arrow's background will be drawn on top of whatever was there before, so erase first
  DoEraseMenuBackground( menu, &amp;itemRect, context );
  
  DrawThemeMenuItem( bounds, &amp;itemRect, trackingData-&gt;virtualMenuTop, trackingData-&gt;virtualMenuBottom,
             menuState, itemType, NULL, NULL );
}

/*--------------------------------------------------------------------------------------------------*/
static void
SizeMenu( MenuRef menu, Point maxSizes )
{
    int          i;
    int          cItems;
  int          menuWidth = 0;
  int          menuHeight = 0;
  MenuItemCalcInfo  calcInfo;
  SInt32        result;
  int          maxWidth;
  int          maxHeight;
  Boolean        hasCmdKey = false;

  // determine the maximum allowed width and height of the menu
  if (  ( Gestalt( gestaltMenuMgrAttr, &amp;result ) == noErr )
     &amp;&amp; ( result &amp; gestaltMenuMgrSendsMenuBoundsToDefProcMask ) != 0 )
  {
    maxWidth = maxSizes.h;
    maxHeight = maxSizes.v;
  }
  else
  {
    Rect mainDeviceRect = (*GetMainDevice())-&gt;gdRect;
    maxWidth = mainDeviceRect.right - mainDeviceRect.left;
    maxHeight = mainDeviceRect.bottom - mainDeviceRect.top - GetMBarHeight();
  }
  
  GetMenuMetrics( &amp;calcInfo.metrics );
  
  //
  // Determine the true width and height of the menu. Note that we must examine every item,
  // even if the height of the menu has already exceeded the maximum height, because we need
  // to calculate the maximum width based on the width of every item.
  //
    cItems = CountMenuItems( menu );
    for ( i = 1; i &lt;= cItems; i++ )
    {
    int    itemWidth;
    int    itemHeight;
    int    newHeight;

    FetchMenuItemData( menu, i, &amp;calcInfo.itemData );
    hasCmdKey |= HasCommandKey( &amp;calcInfo.itemData );
    CalcItemSize( menu, &amp;calcInfo, &amp;itemWidth, &amp;itemHeight );
    ReleaseMenuItemData( &amp;calcInfo.itemData );
    
    if ( itemWidth &gt; menuWidth )
      menuWidth = itemWidth;
      
    newHeight = menuHeight + itemHeight;
    if ( newHeight &lt;= maxHeight )
      menuHeight = newHeight;
    }
  
  //
  // CalcItemSize will add the command key width to every item, even if the item doesn't have a command key.
  // This gives a better appearance when just some items have command keys. However, if no item has a command
  // key, then we remove the command key width entirely.
  //
  if ( !hasCmdKey &amp;&amp; menuWidth &gt;= calcInfo.metrics.cmdGlyphWidth )
    menuWidth -= calcInfo.metrics.cmdGlyphWidth;
  
  if ( menuWidth &gt; maxWidth )
    menuWidth = maxWidth;
  if ( menuHeight &gt; maxHeight )
    menuHeight = maxHeight;
  
  SetMenuWidth( menu, menuWidth );
  SetMenuHeight( menu, menuHeight );
}

/*--------------------------------------------------------------------------------------------------*/
static void
CalcItemSize( MenuRef menu, const MenuItemCalcInfo* calcInfo, int* outWidth, int* outHeight )
{
  MenuAttributes    menuAttr;
  
  // initial height
  if ( outHeight != NULL )
  {
    if ( ( calcInfo-&gt;itemData.attr &amp; kMenuItemAttrSeparator ) != 0 )
      *outHeight = calcInfo-&gt;metrics.separatorHeight;
    else
      *outHeight = calcInfo-&gt;metrics.itemHeight;
  }
  
  // initial width
  if ( outWidth == NULL )
    return;
  else
    *outWidth = 0;
  
  // indent
  if ( calcInfo-&gt;itemData.indent &gt; 0 )
    *outWidth += calcInfo-&gt;itemData.indent * calcInfo-&gt;metrics.indentWidth;
  
  // mark character
  GetMenuAttributes( menu, &amp;menuAttr );
  if ( ( menuAttr &amp; kMenuAttrExcludesMarkColumn ) != 0 )
    *outWidth += calcInfo-&gt;metrics.excludedMarkWidth;
  else
    *outWidth += calcInfo-&gt;metrics.markWidth;
  
  // text
  if ( calcInfo-&gt;itemData.cfText != NULL )
  {
    Point  pt;
    SInt16  baseline;
    
    GetThemeTextDimensions( calcInfo-&gt;itemData.cfText, kThemeMenuItemFont, kThemeStateActive, false, &amp;pt, &amp;baseline );
    *outWidth += pt.h + calcInfo-&gt;metrics.textLeadingMargin + calcInfo-&gt;metrics.textTrailingMargin;
  }
  
  // command key and modifiers
  *outWidth += GetCommandKeyWidth( calcInfo );
  
  // theme-specified extra spacing
  *outWidth += calcInfo-&gt;metrics.extraWidth;
}

/*--------------------------------------------------------------------------------------------------*/
static int
GetCommandKeyWidth( const MenuItemCalcInfo* calcInfo )
{
  int width = 0;
  
  if ( HasCommandKey( &amp;calcInfo-&gt;itemData ) )
  {
    width = calcInfo-&gt;metrics.cmdCharWidth;
    if ( calcInfo-&gt;itemData.cmdKeyModifiers == 0 )
    {
      width += calcInfo-&gt;metrics.cmdGlyphWidth;
    }
    else
    {
      ByteCount cch;
      const UniChar* modifiers = BuildModifierString( calcInfo-&gt;itemData.cmdKeyModifiers, &amp;cch );
      width += MeasureUnicode( modifiers, cch, kThemeMenuItemCmdKeyFont );
    }
  }
  else
  {
    width = calcInfo-&gt;metrics.cmdGlyphWidth;
  }
  
  return width;
}

/*--------------------------------------------------------------------------------------------------*/
static const UniChar*
BuildModifierString( UInt32 modifiers, ByteCount* outLength )
{
  static UniChar  ustr[4];
  ByteCount    cch = 0;

/*
  Mac OS X 10.0.x expects the CFStringRef used when drawing with kMenuItemCmdKeyFont to contain
  characters with values in the range given in Menus.h for glyph codes in the .Keyboard font.
  Those glyph codes are actually not valid Unicode values for the associated characters; that
  Mac OS X 10.0.x requires them is a bug in that release.
  
  Mac OS X 10.1 and later expects the CFStringRef to contain characters with the proper Unicode
  values (kCommand/Option/Shift/ControlUnicode).
  
  It so happens that creating a CFStringRef with CFStringCreateWithBytes, using byte values from
  the .Keyboard font encoding, and specifying kTextEncodingMacKeyboardGlyphs, will create a CFString
  with the right Unicode values on both platforms. That is the approach used by this sample code.
  
  However, if your MDEF will only run on Mac OS X 10.1 and later, then it's somewhat more efficient
  to just create the CFString by specifying the correct Unicode values in the first place.
*/  
#if AFTER_MACOSX_10_0_x
  if ( ( modifiers &amp; kMenuControlModifier ) != 0 )
    ustr[cch++] = kControlUnicode;
  if ( ( modifiers &amp; kMenuOptionModifier ) != 0 )
    ustr[cch++] = kOptionUnicode;
  if ( ( modifiers &amp; kMenuShiftModifier ) != 0 )
    ustr[cch++] = kShiftUnicode;
  if ( ( modifiers &amp; kMenuNoCommandModifier ) == 0 )
    ustr[cch++] = kCommandUnicode;
#else
  static Byte    str[4];
  CFStringRef    cfString;
  
  if ( ( modifiers &amp; kMenuControlModifier ) != 0 )
    str[cch++] = kMenuControlGlyph;
  if ( ( modifiers &amp; kMenuOptionModifier ) != 0 )
    str[cch++] = kMenuOptionGlyph;
  if ( ( modifiers &amp; kMenuShiftModifier ) != 0 )
    str[cch++] = kMenuShiftGlyph;
  if ( ( modifiers &amp; kMenuNoCommandModifier ) == 0 )
    str[cch++] = kMenuCommandGlyph;
  
  cfString = CFStringCreateWithBytes( NULL, str, cch, kTextEncodingMacKeyboardGlyphs, false );
  check( cfString != NULL );
  check( CFStringGetLength( cfString ) &lt;= 4 );
  CFStringGetCharacters( cfString, CFRangeMake( 0, cch ), ustr );
  CFRelease( cfString );
#endif
    
  *outLength = cch;
  return ustr;
}

/*--------------------------------------------------------------------------------------------------*/
static void
CalcMenuPopUpRect( MenuRef menu, Rect* bounds, int mouseH, int mouseV, short* whichItem )
{
  MenuTrackingData  trackingData;
  Rect        itemRect;
  MenuItemCalcInfo  calcInfo;

  GetMenuMetrics( &amp;calcInfo.metrics );
  FetchMenuItemData( menu, *whichItem, &amp;calcInfo.itemData );
  
  trackingData.virtualMenuTop = 0;  // GetItemRect uses only this field of the tracking data
  GetItemRect( menu, &amp;trackingData, bounds, *whichItem, 0, 0, &amp;calcInfo, &amp;itemRect );  

  ReleaseMenuItemData( &amp;calcInfo.itemData );
  
  // itemRect.left and right will be garbage now, because they're based on the bounds rect,
  // which is uninitialized. But we don't care.

  if ( IsMenuSizeInvalid( menu ) )
    CalcMenuSize( menu );

  SetRect( bounds, mouseH, mouseV - itemRect.top, mouseH + GetMenuWidth( menu ),
    mouseV + GetMenuHeight( menu ) - itemRect.top );

  *whichItem = bounds-&gt;top;
}

/*--------------------------------------------------------------------------------------------------*/
static void
FindMenuItem( MenuRef menu, const Rect* bounds, Point hitPt, MenuTrackingData* trackingData, CGContextRef context )
{
  Rect        visibleBounds    = *bounds;
  MenuItemIndex    prevItemSelected  = trackingData-&gt;itemSelected;
  MenuItemCalcInfo  calcInfo;
  
  GetMenuMetrics( &amp;calcInfo.metrics );
  
    trackingData-&gt;itemSelected = 0;
    trackingData-&gt;itemUnderMouse = 0;

  if ( trackingData-&gt;virtualMenuTop &lt; bounds-&gt;top )
    visibleBounds.top += calcInfo.metrics.itemHeight;

  if ( trackingData-&gt;virtualMenuBottom &gt; bounds-&gt;bottom )
    visibleBounds.bottom -= calcInfo.metrics.itemHeight;

  if ( PtInRect( hitPt, &amp;visibleBounds ) )
  {
      int    i;
      int    cItems;
        Rect  itemRect;
      
    SetupItemRect( bounds, trackingData, &amp;itemRect );
      cItems = CountMenuItems( menu );
      for ( i = 1; i &lt;= cItems; i++ )
      {
      int    height;

      FetchMenuItemData( menu, i, &amp;calcInfo.itemData );
      CalcItemSize( menu, &amp;calcInfo, NULL, &amp;height );
      ReleaseMenuItemData( &amp;calcInfo.itemData );
      
      itemRect.bottom = itemRect.top + height;
          if ( PtInRect( hitPt, &amp;itemRect ) )
          {
              trackingData-&gt;itemUnderMouse = i;
              trackingData-&gt;itemRect = itemRect;
              if ( IsMenuItemEnabled( menu, i ) )
                  trackingData-&gt;itemSelected = i;
              break;
          }
      
      // prepare for next item
      itemRect.top = itemRect.bottom;
      }
    }
    else
    {
      AutoScroll( menu, bounds, hitPt, trackingData, prevItemSelected, &amp;calcInfo.metrics, context );
    }
}

/*--------------------------------------------------------------------------------------------------*/
static void
AutoScroll( MenuRef menu, const Rect* bounds, Point hitPt, MenuTrackingData* trackingData,
      MenuItemIndex prevItemSelected, const MenuMetrics* metrics, CGContextRef context )
{
  enum
  {
    kSlowScrollSpeed  = 10,
    kFastScrollSpeed  = 1
  };
  
  int          scrollDist  = 0;
  Rect        arrowRect;
  Rect        itemRect;
  Rect        scrollRect  = *bounds;
  UInt32        temp;
  MenuTrackingData  deepestTrackingData;
  UInt32        delayTime  = 0;
  
  // are we in the top scrolling arrow?
  if ( trackingData-&gt;virtualMenuTop &lt; bounds-&gt;top )
  {
    // there's a top arrow, so remove that item from the scrollRect
    scrollRect.top += metrics-&gt;itemHeight;
    
    arrowRect = *bounds;
    arrowRect.bottom = arrowRect.top + metrics-&gt;itemHeight;
    if ( PtInRect( hitPt, &amp;arrowRect ) )
    {
      // this will be the bounds of the item that's newly exposed
      itemRect = arrowRect;
      
      // scrolling up means that bits move down on the screen
      scrollDist = metrics-&gt;itemHeight;
      
      if ( hitPt.v &gt;= ( ( arrowRect.top + arrowRect.bottom ) / 2 ) )
        delayTime = kSlowScrollSpeed;
      else
        delayTime = kFastScrollSpeed;
    }
  }
  
  // or the bottom scrolling arrow?
  if ( trackingData-&gt;virtualMenuBottom &gt; bounds-&gt;bottom )
  {
    // there's a bottom arrow, so remove that item from the scrollRect
    scrollRect.bottom -= metrics-&gt;itemHeight;
    
    arrowRect = *bounds;
    arrowRect.top = arrowRect.bottom - metrics-&gt;itemHeight;
    if ( PtInRect( hitPt, &amp;arrowRect ) )
    {
      // this will be the bounds of the item that's newly exposed
      itemRect = arrowRect;
      
      // scrolling down means that bits move up on the screen
      scrollDist = -metrics-&gt;itemHeight;
      
      if ( hitPt.v &lt;= ( ( arrowRect.top + arrowRect.bottom ) / 2 ) )
        delayTime = kSlowScrollSpeed;
      else
        delayTime = kFastScrollSpeed;
    }
  }
  
  if ( scrollDist == 0 )
    return;
  
  // don't scroll if there are other menus open above us
  verify_noerr( GetMenuTrackingData( NULL, &amp;deepestTrackingData ) );
  if ( deepestTrackingData.menu != menu )
    return;
  
  // turn off the hilite on the previous item
  if ( prevItemSelected != 0 )
    HiliteItem( menu, bounds, trackingData, prevItemSelected, false, context );
  
  // scroll me, baby
  DoScrollMenuImage( menu, &amp;scrollRect, 0, scrollDist, context );
  trackingData-&gt;virtualMenuTop += scrollDist;
  trackingData-&gt;virtualMenuBottom += scrollDist;
  
  // draw the newly exposed item
  OffsetRect( &amp;itemRect, 0, scrollDist );
  DrawScrolledItem( menu, trackingData, bounds, &amp;itemRect, metrics, context );
  
  // draw the arrows, if necessary
  if ( scrollDist &lt; 0 &amp;&amp; trackingData-&gt;virtualMenuTop &lt; bounds-&gt;top )
    DrawScrollArrow( menu, bounds, trackingData, false, metrics, context );

  if ( scrollDist &gt; 0 &amp;&amp; trackingData-&gt;virtualMenuBottom &gt; bounds-&gt;bottom )
    DrawScrollArrow( menu, bounds, trackingData, true, metrics, context );
  
  Delay( delayTime, &amp;temp );
}

/*--------------------------------------------------------------------------------------------------*/
static void
DrawScrolledItem( MenuRef menu, MenuTrackingData* trackingData, const Rect* menuRect, const Rect* itemRect, const MenuMetrics* metrics, CGContextRef context )
{
  int          i;
  MenuItemDrawInfo  drawInfo;
  
  
  i = ( itemRect-&gt;top - trackingData-&gt;virtualMenuTop ) / metrics-&gt;itemHeight;    // zero-based item number
  i++;                                      // one-based item number
  
  SetupItemDrawInfo( menu, context, &amp;drawInfo );
  FetchMenuItemData( menu, i, &amp;drawInfo.calcInfo.itemData );
  DrawItem( menu, i, menuRect, itemRect, trackingData, true, &amp;drawInfo, context );
  ReleaseMenuItemData( &amp;drawInfo.calcInfo.itemData );
}

/*--------------------------------------------------------------------------------------------------*/
static void
HiliteMenuItem( MenuRef menu, const Rect* bounds, HiliteMenuItemData* hiliteData, CGContextRef context )
{
    MenuTrackingData  trackingData;
  Boolean        oldFirst = false;
  Boolean        oldLast = false;
  MenuItemDrawInfo  oldDrawInfo;
  MenuItemDrawInfo  newDrawInfo;
  Rect        oldItemRect;
    Rect        newItemRect;
  
    GetMenuTrackingData( menu, &amp;trackingData );
  SetupItemDrawInfo( menu, context, &amp;oldDrawInfo );
  newDrawInfo = oldDrawInfo;
  
  //
  // determine whether previousItem or newItem comes first in the menu so we can get the item rect
  // for the earlier item first, and use its position as a hint to GetItemRect for the later item
  //
  if ( hiliteData-&gt;previousItem != 0 )
  {
    oldFirst = hiliteData-&gt;previousItem &lt; hiliteData-&gt;newItem;
    oldLast = !oldFirst;
  }
  
  if ( oldFirst )
  {
    FetchMenuItemData( menu, hiliteData-&gt;previousItem, &amp;oldDrawInfo.calcInfo.itemData );
    GetItemRect( menu, &amp;trackingData, bounds, hiliteData-&gt;previousItem, 0, 0,
           &amp;oldDrawInfo.calcInfo, &amp;oldItemRect );
  }
  
  if ( hiliteData-&gt;newItem != 0 )
  {
    FetchMenuItemData( menu, hiliteData-&gt;newItem, &amp;newDrawInfo.calcInfo.itemData );
    GetItemRect( menu, &amp;trackingData, bounds, hiliteData-&gt;newItem, hiliteData-&gt;previousItem,
           oldItemRect.bottom, &amp;newDrawInfo.calcInfo, &amp;newItemRect );
  }
  
  if ( oldLast )
  {
    FetchMenuItemData( menu, hiliteData-&gt;previousItem, &amp;oldDrawInfo.calcInfo.itemData );
    GetItemRect( menu, &amp;trackingData, bounds, hiliteData-&gt;previousItem, hiliteData-&gt;newItem,
           newItemRect.bottom, &amp;oldDrawInfo.calcInfo, &amp;oldItemRect );
  }
  
  if ( hiliteData-&gt;previousItem != 0 )
  {
    check( oldDrawInfo.itemSelected == false );
    DrawItem( menu, hiliteData-&gt;previousItem, bounds, &amp;oldItemRect, &amp;trackingData, true, &amp;oldDrawInfo, context );
    ReleaseMenuItemData( &amp;oldDrawInfo.calcInfo.itemData );
  }
  
  if ( hiliteData-&gt;newItem != 0 )
  {
    newDrawInfo.itemSelected = true;
    DrawItem( menu, hiliteData-&gt;newItem, bounds, &amp;newItemRect, &amp;trackingData, true, &amp;newDrawInfo, context );
    ReleaseMenuItemData( &amp;newDrawInfo.calcInfo.itemData );
  }
}

/*--------------------------------------------------------------------------------------------------*/
static void
HiliteItem( MenuRef menu, const Rect* bounds, MenuTrackingData* trackingData, int i, Boolean hilite, CGContextRef context )
{
  MenuItemDrawInfo  drawInfo;
  Rect        itemRect;

    if ( i == 0 )
        return;
    
  SetupItemDrawInfo( menu, context, &amp;drawInfo );
  drawInfo.itemSelected = hilite;
  
  FetchMenuItemData( menu, i, &amp;drawInfo.calcInfo.itemData );
    GetItemRect( menu, trackingData, bounds, i, 0, 0, &amp;drawInfo.calcInfo, &amp;itemRect );
  DrawItem( menu, i, bounds, &amp;itemRect, trackingData, true, &amp;drawInfo, context );
  ReleaseMenuItemData( &amp;drawInfo.calcInfo.itemData );
}

/*--------------------------------------------------------------------------------------------------*/
static void
CalcMenuItemBounds( MenuRef menu, Rect* bounds, int i )
{
  MenuTrackingData  trackingData;
  MenuItemCalcInfo  calcInfo;
  Rect        itemRect;
  int          width;
  
  // find the top of the menu, or use zero if the menu isn't open
  if ( GetMenuTrackingData( menu, &amp;trackingData ) != noErr )
    trackingData.virtualMenuTop = 0;
  
  GetMenuMetrics( &amp;calcInfo.metrics );
  FetchMenuItemData( menu, i, &amp;calcInfo.itemData );
  
  // use GetItemRect to determine the item's vertical position in the menu
  // use CalcItemSize to determine the item's actual width (GetItemRect will use the menu's width)
  GetItemRect( menu, &amp;trackingData, bounds, i, 0, 0, &amp;calcInfo, &amp;itemRect );
  CalcItemSize( menu, &amp;calcInfo, &amp;width, NULL );
  
  *bounds = itemRect;
  bounds-&gt;right = bounds-&gt;left + width;
  
  ReleaseMenuItemData( &amp;calcInfo.itemData );
}

/*--------------------------------------------------------------------------------------------------*/
static void
GetItemRect( MenuRef menu, const MenuTrackingData* trackingData, const Rect* bounds, int whichItem,
       int hintItem, int hintBottom, const MenuItemCalcInfo* whichItemInfo, Rect* itemRect )
{
  int          i;
  MenuItemCalcInfo  calcInfo;
  
  itemRect-&gt;left = bounds-&gt;left;
  itemRect-&gt;right = bounds-&gt;right;
  
  calcInfo.metrics = whichItemInfo-&gt;metrics;
  
  //
  // It would be possible to modify this code to use hintBottom even for items that are past whichItem
  // (by working backwards and subtracting off the height instead of adding it), but I didn't feel like
  // adding that complication to the code at this time.
  //
  if ( hintItem &gt;= whichItem )
    hintItem = 0;
  
  if ( hintItem == 0 )
    itemRect-&gt;bottom = trackingData-&gt;virtualMenuTop;
  else
    itemRect-&gt;bottom = hintBottom;
  
  i = hintItem + 1;
  while ( i &lt;= whichItem )
  {
    int    height;
    
    if ( i == whichItem )
      calcInfo.itemData = whichItemInfo-&gt;itemData;
    else
      FetchMenuItemData( menu, i, &amp;calcInfo.itemData );
    CalcItemSize( menu, &amp;calcInfo, NULL, &amp;height );
    if ( i != whichItem )
      ReleaseMenuItemData( &amp;calcInfo.itemData );
    
    itemRect-&gt;top = itemRect-&gt;bottom;
    itemRect-&gt;bottom += height;
    i++;
  }
}

/*--------------------------------------------------------------------------------------------------*/
static void
GetMenuMetrics( MenuMetrics* outMetrics )
{
  UniChar    uchCmdGlyph = GetCommandGlyph();
  FontInfo  fi;
  
  GetThemeMenuSeparatorHeight( &amp;outMetrics-&gt;separatorHeight );
  GetThemeMenuItemExtra( kThemeMenuItemPlain, &amp;outMetrics-&gt;extraHeightPlain, &amp;outMetrics-&gt;extraWidth );
  GetThemeMenuItemExtra( kThemeMenuItemHasIcon, &amp;outMetrics-&gt;extraHeightIcon, &amp;outMetrics-&gt;extraWidth );
  
  outMetrics-&gt;markWidth = GetThemeMenuMetric( kThemeMenuMetricMarkColumnWidth );
  outMetrics-&gt;excludedMarkWidth = GetThemeMenuMetric( kThemeMenuMetricExcludedMarkColumnWidth );
  outMetrics-&gt;markIndent = GetThemeMenuMetric( kThemeMenuMetricMarkIndent );
  outMetrics-&gt;textLeadingMargin = GetThemeMenuMetric( kThemeMenuMetricTextLeadingEdgeMargin );
  outMetrics-&gt;textTrailingMargin = GetThemeMenuMetric( kThemeMenuMetricTextTrailingEdgeMargin );
  outMetrics-&gt;indentWidth = GetThemeMenuMetric( kThemeMenuMetricIndentWidth );
  outMetrics-&gt;cmdGlyphWidth = MeasureUnicode( &amp;uchCmdGlyph, 1, kThemeMenuItemCmdKeyFont );
  
  UseThemeFont( kThemeMenuItemFont, smSystemScript );
  GetFontInfo( &amp;fi );
  outMetrics-&gt;itemHeight = fi.ascent + fi.descent + fi.leading + outMetrics-&gt;extraHeightPlain;
  outMetrics-&gt;itemBaseline = fi.ascent;
  outMetrics-&gt;cmdCharWidth = fi.widMax;
}

/*--------------------------------------------------------------------------------------------------*/
static UniChar
GetCommandGlyph( void )
{
// see prior discussion in BuildModifierString for why this is here
#if AFTER_MACOSX_10_0_x
  return kCommandUnicode;
#else
  static UniChar  uch;
  Byte      ch;
  CFStringRef    str;
  
  if ( uch == 0 )
  {
    ch = kMenuCommandGlyph;
    str = CFStringCreateWithBytes( NULL, &amp;ch, sizeof( ch ), kTextEncodingMacKeyboardGlyphs, false );
    CFStringGetCharacters( str, CFRangeMake( 0, 1 ), &amp;uch );
    CFRelease( str );
  }
  
  return uch;
#endif
}

/*--------------------------------------------------------------------------------------------------*/
static int
GetThemeMenuMetric( ThemeMenuMetric metric )
{
  SInt32  value;
  
  /*
    We first try to get the metric using GetThemeMetric. If that returns an error,
    we use some hardcoded constants that correspond to the values used by the Mac OS 9
    and Mac OS X system MDEFs.
    
    Unfortunately, we need to check for GetThemeMetric returning noErr but a metric
    value of zero also, because GetThemeMetric will return noErr for some out-of-bounds
    and unsupported metrics on 10.0.x.
  */
  switch ( metric )
  {
    case kThemeMenuMetricMarkColumnWidth:
      if ( GetThemeMetric( kThemeMetricMenuMarkColumnWidth, &amp;value ) != noErr || value == 0 )
      {
        if ( HasAqua() )
        {
          value = 21;
        }
        else
        {
          FontInfo fi;
          UseThemeFont( kThemeSystemFont, smSystemScript );
          GetFontInfo( &amp;fi );
          value = fi.widMax;
        }
      }
      break;
      
    case kThemeMenuMetricExcludedMarkColumnWidth:
      if ( GetThemeMetric( kThemeMetricMenuExcludedMarkColumnWidth, &amp;value ) != noErr || value == 0 )
        value = 5;
      break;
    
    case kThemeMenuMetricMarkIndent:
      if ( GetThemeMetric( kThemeMetricMenuMarkIndent, &amp;value ) != noErr || value == 0 )
      {
        if ( HasAqua() )
          value = 5;
        else
          value = 0;
      }
      break;
    
    case kThemeMenuMetricTextLeadingEdgeMargin:
      if ( GetThemeMetric( kThemeMetricMenuTextLeadingEdgeMargin, &amp;value ) != noErr || value == 0 )
      {
        if ( HasAqua() )
          value = 0;
        else
          value = 2;
      }
      break;
    
    case kThemeMenuMetricTextTrailingEdgeMargin:
      if ( GetThemeMetric( kThemeMetricMenuTextTrailingEdgeMargin, &amp;value ) != noErr || value == 0 )
      {
        if ( HasAqua() )
          value = 19;
        else
          value = 8;
      }
      break;
      
    case kThemeMenuMetricIndentWidth:
      if ( GetThemeMetric( kThemeMetricMenuIndentWidth, &amp;value ) != noErr || value == 0 )
        value = 12;
      break;
    
    case kThemeMenuMetricIconTrailingEdgeMargin:
      if ( GetThemeMetric( kThemeMetricMenuIconTrailingEdgeMargin, &amp;value ) != noErr || value == 0 )
      {
        if ( HasAqua() )
        {
          value = 4;
        }
        else
        {
          value = CharWidth( kSpaceCharCode );
        }
      }
      break;
    
    default:
      value = 0;
  }
  
  return value;
}

/*--------------------------------------------------------------------------------------------------*/
//  Determines whether kThemeMenuItemNoBackground is available. It is only available on Mac OS X and later.
static Boolean
HasNoBackground()
{
  static Boolean  sHasNoBackground;
  static Boolean  sInited;
  
  if ( !sInited )
  {
    SInt32 result;
    Gestalt( gestaltSystemVersion, &amp;result );
    sHasNoBackground = result &gt;= 0x1000;
    sInited = true;
  }
  
  return sHasNoBackground;
}

/*--------------------------------------------------------------------------------------------------*/
static Boolean
HasAqua()
{
  static Boolean  sHasAqua;
  static Boolean  sInited;
  
  if ( !sInited )
  {
    Collection  c = NewCollection();
    Str255    name;
    Size    size = sizeof( name );
    
    GetTheme( c );
    sHasAqua = GetTheme( c ) == noErr
        &amp;&amp; GetCollectionItem( c, kThemeNameTag, 0, &amp;size, name ) == noErr
        &amp;&amp; EqualString( name, &quot;\pAqua&quot;, true, true );
    DisposeCollection( c );
    sInited = true;
  }
  
  return sHasAqua;
}

/*--------------------------------------------------------------------------------------------------*/
static void
DoEraseMenuBackground( MenuRef menu, const Rect* rect, CGContextRef context )
{
#if TARGET_RT_MAC_MACHO
  static EraseMenuBackgroundProc  eraseProc;
  static Boolean          checked;
  
  if ( !checked )
  {
    CFBundleRef bundle = CFBundleGetBundleWithIdentifier( CFSTR(&quot;com.apple.Carbon&quot;) );
    eraseProc = CFBundleGetFunctionPointerForName( bundle, CFSTR(&quot;EraseMenuBackground&quot;) );
    checked = true;
  }
  
  if ( eraseProc != NULL )
    (*eraseProc)( menu, rect, context );
#else
  if ( EraseMenuBackground != NULL )
    EraseMenuBackground( menu, rect, context );
#endif
  else
    DoCGContextClearRect( context, rect );
}

/*--------------------------------------------------------------------------------------------------*/
static void
DoCGContextClearRect( CGContextRef context, const Rect* rect )
{
  Rect  portBounds;
  CGRect  cgRect;
  
#if TARGET_RT_MAC_CFM
  static CGContextClearRectProc  clearProc;
  static Boolean          checked;
  
  if ( !checked )
  {
    CFBundleRef bundle = CFBundleGetBundleWithIdentifier( CFSTR(&quot;com.apple.CoreGraphics&quot;) );
    clearProc = CFBundleGetFunctionPointerForName( bundle, CFSTR(&quot;CGContextClearRect&quot;) );
    checked = true;
  }
#endif
    
  // convert from Quickdraw coordinates (zero at top) to CG coordinates (zero at bottom)
  GetPortBounds( GetQDGlobalsThePort(), &amp;portBounds );
  cgRect.origin.x = rect-&gt;left;
  cgRect.origin.y = ( portBounds.bottom - portBounds.top ) - rect-&gt;bottom;
  cgRect.size.width = rect-&gt;right - rect-&gt;left;
  cgRect.size.height = rect-&gt;bottom - rect-&gt;top;
  
#if TARGET_RT_MAC_CFM
  (*clearProc)( context, cgRect );
#else
  CGContextClearRect( context, cgRect );
#endif
}

/*--------------------------------------------------------------------------------------------------*/
static void
DoScrollMenuImage( MenuRef menu, const Rect* bounds, int dh, int dv, CGContextRef context )
{
#if TARGET_RT_MAC_MACHO
  static ScrollMenuImageProc  scrollProc;
  static Boolean        checked;
  
  if ( !checked )
  {
    CFBundleRef bundle = CFBundleGetBundleWithIdentifier( CFSTR(&quot;com.apple.Carbon&quot;) );
    scrollProc = CFBundleGetFunctionPointerForName( bundle, CFSTR(&quot;ScrollMenuImage&quot;) );
    checked = true;
  }
  
  if ( scrollProc != NULL )
    (*scrollProc)( menu, bounds, dh, dv, context );
#else
  if ( ScrollMenuImage != NULL )
    ScrollMenuImage( menu, bounds, dh, dv, context );
#endif
  else
    ScrollRect( bounds, dh, dv, NULL );
}
</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/CarbonMDEF/listing2.html%3Fid%3DDTS10000562-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/CarbonMDEF/listing2.html%3Fid%3DDTS10000562-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/CarbonMDEF/listing2.html%3Fid%3DDTS10000562-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>