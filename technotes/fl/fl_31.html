<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 01-August-01 --><!-- Includes revisions to graphics tags --><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note FL31: Searching Volumes - Solutions and Problems</title><meta name="keywords" content="Mac OS 8 File Manager PBCatSearch PBGetCatInfo recursive indexed search"><meta name="Description" content="Technical Note FL31: This Technical Note discusses the PBCatSearchfunction and tells why it should be used. It also providessimple algorithms for searching both MFS and HFS volumesand details how to use a recursive indexed search when PBCatSearchis unavailable. Technical Note also discusses the problemswith indexed search routines, describing three instancesin which items may be missed or counted twice when searchingwith these routines.">                                       <meta name="categories" content="Files"><meta name="week-posted" content="Sep 26, 1988 - Oct 7, 1988"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002457" title="Searching Volumes - Solutions and Problems"></a><A NAME="top"></A><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/Carbon/index.html">Carbon</a> &gt; <a href="../../technicalnotes/Carbon/idxFileManagement-date.html">File Management</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Not Recommended Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>The information in this document is <strong>Not Recommended</strong> and should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/Carbon/idxFileManagement-date.html" target="_blank">Carbon > File Management</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note FL31</div>
<div id="pageheadsub">Searching Volumes - Solutions and Problems</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->										<p id="menutext">					<A HREF="#Section1">Introduction</a><BR><BR>					<A HREF="#Section2">Searching MFS Volumes</a><BR><BR><A HREF="#Section3">Searching HFS Volumes</a><BR><BR><A HREF="#Section4">Searching in a Multi-user/Multiprocess Environment</a><BR><BR><A HREF="#Summary">Summary</a><BR><BR> <A HREF="#References">References</A><BR><BR>   <A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><P id = "introtext">This Technical Note discusses the <code>PBCatSearch</code> function and tells why it should be used. It also provides simple algorithms for searching both MFSand HFS volumes and discusses the problems with indexed search routines.</p><p id = "introtext">This note includes information on <code>PBCatSearch</code>and notes the problems with indexed search routines. Thanks to John Norstad at Northwestern University for pointing out some of the shortcomings of the indexed search routines. Thanks to the System 7 engineering team for adding <code>PBCatSearch</code>.</p><!-- end_intro_text --><!-- begin_date --><h3 align=center>[Oct 01 1988]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR><!-- begin_content --><a name="Section1"></a><h2>Introduction</h2><p>It may be necessary to search the volume hierarchy for files or directorieswith specific characteristics. Generally speaking, your application shouldavoid searching entire volumes because searching can be a very time-consumingprocess on a large volume. Your application should rely instead on files beingin specific directories (the same directory as the application, or in one ofthe system-related folders that can be found with <code>FindFolder</code>) or onhaving the user find files with Standard File.</p><P><A HREF="#top">Back to top</A></P><a name="Section2"></a><h2>Searching MFS Volumes</h2><p>Under MFS, indexed calls to <code>PBGetFInfo</code> return information about allfiles on a given volume. Under HFS, the same technique returns information onlyabout files in the current directory. Here's a short code snippet showing howto use <code>PBGetFInfo</code> to list all files on an MFS volume:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    PROCEDURE EnumMFS (theVRefNum: Integer);    { search the MFS volume specified by theVRefNum }       VAR          pb: ParamBlockRec;          itemName: Str255;          index: Integer;          err: OSErr;    BEGIN       WITH pb DO          BEGIN             ioNamePtr := @itemName;             ioVRefNum := theVRefNum;             ioFVersNum := 0;          END;       index := 1;       REPEAT          pb.ioFDirIndex := index;          err := PBGetFInfoSync(@pb);          IF err = noErr THEN             BEGIN                { do something useful with the file information in pb }             END;          index := index + 1;       UNTIL err &lt;&gt; noErr;    END;</pre>	</TD></TR></TABLE></CENTER><p>As noted in <u><A HREF = "fl_35.html">Macintosh Technical Note #66</a></u>, a directory signature of $D2D7 means a volume is an MFS volume, while a directory signature of $4244 means the volume is an HFS volume.</p><P><A HREF="#top">Back to top</A></P><a name="Section3"></a><h2>Searching HFS Volumes</h2><p><b>Fast, Reliable Searches Using <code>PBCatSearch</code></b></p><p>The fastest and most reliable way to search an HFS volume's catalog is with theFile Manager's <code>PBCatSearch</code> function. <code>PBCatSearch</code> returns alist of <code>FSSpec</code> records to files or directories that match the searchcriteria specified by your application. However, <code>PBCatSearch</code> is notavailable on all volumes or under all versions of the File Manager. Volumesthat support <code>PBCatSearch</code> can be identified using the<code>PBHGetVolParms</code> function. (See the following code.) Versions of theFile Manager that support <code>PBCatSearch</code> can be identified with the<code>gestaltFSAttr</code> Gestalt selector and <code>gestaltFullExtFSDispatching</code> bit as shown in the following code:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    FUNCTION HasCatSearch (vRefNum: Integer): Boolean;    { See if volume specified by vRefNum supports PBCatSearch }       VAR          pb: HParamBlockRec;          infoBuffer: GetVolParmsInfoBuffer;          attrib: LongInt;    BEGIN       HasCatSearch := FALSE; { default to no PBCatSearch support }       IF GestaltAvailable THEN { See Inside Macintosh Volume VI, Chapter 3 }          IF Gestalt(gestaltFSAttr, attrib) = noErr THEN             IF BTst(attrib, gestaltFullExtFSDispatching) THEN                BEGIN { this version of the File Manager can call PBCatSearch }                   WITH pb DO                      BEGIN                         ioNamePtr := NIL;                         ioVRefNum := vRefNum;                         ioBuffer := @infoBuffer;                         ioReqCount := sizeof(infoBuffer);                      END;                   IF PBHGetVolParmsSync(@pb) = noErr THEN                      IF BTST(infoBuffer.vMAttrib, bHasCatSearch) THEN                         HasCatSearch := TRUE; { volume supports PBCatSearch }                END;    END;</pre>	</TD></TR></TABLE></CENTER><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>File servers that support the AppleTalk Filing Protocol (AFP)version 2.1 support <code>PBCatSearch</code>. That includes volumes and directoriesshared by System 7 File Sharing and by the AppleShare 3.0 file server. AlthoughAFP version 2.1 supports <code>PBCatSearch</code>, the <code>fsSBNegate</code> bit isnot supported in the <code>ioSearchBits</code> field. Using <code>PBCatSearch</code> toask the file server to perform the search is usually faster than using therecursive indexed search described in the next section.</P></TD></TR></TABLE></CENTER><BR><p><code>PBCatSearch</code> should be used if it is available because it is usually<i>much</i> faster than a recursive search. For example, the search time forfinding all files and directories on a recent Developer CD  was around 18 seconds with <code>PBCatSearch</code>. It took 6 minutes and 36 seconds with arecursive indexed search. How long do you want the users of your application to wait?</p><p><code>PBCatSearch</code> can be used to collect a list of <code>FSSpec</code> records toall items on a volume by setting <code>ioSearchBits</code> in the parameter block to 0.</p><p><b>Recursive Indexed Searches Using <code>PBGetCatInfo</code></b></p><p>When <code>PBCatSearch</code> is not available, an application must resort to arecursive indexed search. There are a couple of potential problems with arecursive indexed search; a recursive indexed search can use up a lot of stackspace and the volume directory structure can change in the multi-user/multiprocess Macintosh environment. The example code in this note addresses the stack space problem, but for reasons explained later, does not address problems caused by multiple users or processes changing the volume directory structure during a recursive search.</p><p>The default stack space on the Macintosh can be as small as 8K; therefore, therecursive indexed search example shown in this Note encloses the actual recursive routine in a shell that can hold most of the variables needed, which dramatically reduces the size of the stack frame. This example uses only 26 bytes of stack space each time the routine recurses. That is, it could search 100 levels deep (pretty unlikely) and use only 2600 bytes of stack space.</p><p>Please notice that when the routine comes back from recursing, it has to clearthe nonlocal variable <code>err</code> to <code>noErr</code>, since the reason the routinecame back from recursing is that <code>PBGetCatInfo</code> returned an error:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    EnumerateCatalog(myCPB.ioDrDirID);    err := noErr; {clear error return on way back}</pre>	</TD></TR></TABLE></CENTER><p>Please notice also that you must set <code>myCPB.ioDrDirId</code> each time youcall <code>PBGetCatInfo</code>, because if <code>PBGetCatInfo</code> gets informationabout a file, it returns <code>ioFlNum</code> (the file number) in the samelocation that <code>ioDrDirID</code> previously occupied.</p><p>Be sure to check bit 4, the fifth least significant bit, when you check thefile attributes bit to see if you've got a file or a folder. The followingroutine uses MPW Pascal's <code>BTST</code> function to check that bit. If you usethe Toolbox bit manipulation routines (e.g., <code>BitTst</code>), remember toorder the bits in reverse order from standard 68000 notation.</p><p>Here is the routine in MPW Pascal:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>PROCEDURE EnumerShell (vRefNumToSearch: Integer; { the vRefNum to search}                           dirIDToSearch: LongInt);  { the dirID to search }       VAR          itemName: Str63;          myCPB: CInfoPBRec;          err: OSErr;       {-----}       PROCEDURE EnumerateCatalog (dirIDToSearch: LongInt);          CONST             ioDirFlgBit = 4;          VAR             index: Integer;       BEGIN { EnumerateCatalog }          index := 1;          REPEAT             WITH myCBP DO                BEGIN                   ioFDirIndex := index;                   ioDrDirID := dirIDToSearch; { we need to do this every }                                               { time through }                   filler2 := 0; { Clear the ioACUser byte if search is  }                                 { interested in it. Nonserver volumes }                                 { won't clear it for you and the value  }                                 { returned is meaningless. }                END;             err := PBGetCatInfo(@myCPB, FALSE);             IF err = noErr THEN                IF BTST(myCPB.ioFlAttrib, ioDirFlgBit) THEN                   BEGIN { we have a directory }                      { do something useful with the directory information }                      { in myCPB }                      EnumerateCatalog(myCPB.ioDrDirID);                      err := noErr; {clear error return on way back}                   END                ELSE                   BEGIN { we have a file }                      { do something useful with the file information }                      { in myCPB }                   END;             index := index + 1;          UNTIL (err &lt;&gt; noErr);       END;  { EnumerateCatalog }       {-----}    BEGIN { EnumerShell }       WITH myCPB DO          BEGIN             ioNamePtr := @itemName;             ioVRefNum := vRefNumToSearch;          END;       EnumerateCatalog(dirIDToSearch);    END; { EnumerShell }</pre>	</TD></TR></TABLE></CENTER><p>In MPW C:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    /* the following variables are globals */    HFileInfo      gMyCPB;           /* for the PBGetCatInfo call */    Str63          gItemName;        /* place to hold file name */    OSErr          gErr;             /* the usual *//*---------------------------------------------------------------------*/    void EnumerateCatalog (long int dirIDToSearch)    {  /* EnumerateCatalog */       short int          index=1;       do       {          gMyCPB.ioFDirIndex= index;          gMyCPB.ioDirID= dirIDToSearch; /* we need to do this every time    */                                         /* through, since GetCatInfo        */                                         /* returns ioFlNum in this field */          gMyCPB.filler2= 0; /* Clear the ioACUser byte if search is         */                             /* interested in it. Nonserver volumes won't  */                             /* clear it for you and the value returned is */                             /* meaningless. */          gErr= PBGetCatInfo(&amp;gMyCPB,false);          if (gErr == noErr)          {             if ((gMyCPB.ioFlAttrib &amp; ioDirMask) != 0)             {  /* we have a directory */                /* do something useful with the directory information */                /* in gMyCPB */                EnumerateCatalog(gMyCPB.ioDirID); /* recurse */                gErr = noErr; /* clear error return on way back */             }             else             {  /* we have a file */                /* do something useful with the file information */                /* in gMyCPB */             }          }          ++index;       } while (gErr == noErr);    }  /* EnumerateCatalog *//*---------------------------------------------------------------------*/    EnumerShell(short int vRefNumToSearch, long int dirIDToSearch)    {  /* EnumerShell */       gMyCPB.ioNamePtr = gItemName;       gMyCPB.ioVRefNum = vRefNumToSearch;       EnumerateCatalog(dirIDToSearch);    }  /* EnumerShell */</pre>	</TD></TR></TABLE></CENTER><p>Please make sure that you are running under HFS before you use this routine(see <u><A HREF = "fl_35.html">Technical Note #66</a></u>). You can search the entire volume by specifying a starting directory ID of fsRtDirID, the root directory constant. You can do partial searches of a volume by specifying a starting directory ID other than fsRtDirID.</p><P><A HREF="#top">Back to top</A></P><a name="Section4"></a><h2>Searching in a Multi-user/Multiprocess Environment</h2><p>Volumes can be shared by multiple users accessing a file server or multipleprocesses running on a single Macintosh. Each user or process with access to such a shared volume may be able to make changes to the volume's catalog at any time. Changes in a volume's catalog in the middle of a search can cause two problems:</p><ul type="circle">	<li>Files and directories renamed or moved by another user or process can be entirely missed or found multiple times by a search routine.</li>	<li>A search routine can easily lose track of its position within the hierarchical directory structure when files or directories are created, deleted, or renamed by another user or process.</li></ul><p>A volume searched with a single call to <code>PBCatSearch</code> ensures that allparts of the volume are searched without another user or process changing thevolume's catalog. However, a single call to <code>PBCatSearch</code> may not bepossible or practical because of the number of matches you expect, or becauseyou may want to set a time limit on the search so that the user can cancel along search. <code>PBCatSearch</code> returns a <code>catChangedErr</code> (-1304) andno matches when the catalog of a volume is changed by another user or processin a way that might affect the current search. The search can be continued withthe <code>CatPositionRec</code> returned with the <code>catChangedErr</code> error, butat the risk of missing catalog entries or finding duplicate catalog entries.</p><p>Things aren't so nice for search routines based on indexed File Manager calls.The File Manager won't notify you when a volume's catalog has changed. In fact,there are several ways the catalog can change that are very difficult to detectand correct for. Since methods that attempt to resynchronize an indexed searchand find all catalog entries that might be missed or found multiple times whenthe catalog changes do not work for all cases, those methods are not discussedin this Technical Note. The following paragraphs describe why some changes arevery difficult to detect.</p><p>There are three changes you can make to the contents of a directory that changethe list of files and directories returned by an indexed search: creating,deleting, and renaming. Directories of an HFS volume are always sortedalphabetically, so when a file or subdirectory is deleted from a directory, anydirectory entries after it bubbles up to fill the vacated entry position; whena file or subdirectory is created, it is inserted into the list and all entriesafter it bubbles down one position. When a file or subdirectory is renamed, itis removed from its current position and moved into its alphabetically correctposition. The first two changes, creating and deleting, can be detected only atthe parent directory level. That's because a creation or deletion changes onlythe modification date of the parent directory but not the modification date ofany of the parent directory's ancestors. Renaming a file or subdirectory doesnot change the modification date of the file or subdirectory renamed or themodification date its parent directory, but it does change the order of filesand subdirectories found by an indexed search.</p><p>With this in mind, here are a couple of examples that are very difficult to detect.</p><p>The first example shows a file, Dashboard, moved (by another user or process)with <code>PBCatMove</code> from the CDevs subdirectory to the Control Panelssubdirectory. (See figures 1 and 2.) At the time of the move, the searchroutine has just finished recursively looking through the Development directoryand is ready to recursively search the Games directory. After the move, twodirectories, CDevs and Control Panels, have new modification dates but nochange is seen at the root directory of My Disk. There is nothing toimmediately tell the search routine something has changed (except for thevolume modification date which may or may not mean the directory structure haschanged), so the search will see Dashboard twice. If the move were in theopposite direction, from Control Panels to CDevs, Dashboard would be missed bythe search routine.</p><p align="center"><img src="images/fl_31_001.gif" alt="Before Dashboard Is Moved With PBCatMove" width=384 height=216></p><p align=center><b>Figure 1</b>.  Before Dashboard Is Moved With <code>PBCatMove</code></p><p align="center"><img src="images/fl_31_002.gif" alt="After Dashboard Is Moved With PBCatMove" width=384 height=278></p><p align=center><b>Figure 2</b>.  After Dashboard Is Moved With <code>PBCatMove</code></p><p>The second example (see Figures 3 and 4) shows a directory, Toys, renamed (byanother user or process) with <code>PBHRename</code> to Games. At the time of themove, the search routine has seen the files Aardvark and Letter and is lookingat the third object in the directory, the file R&eacute;sum&eacute;. After themove, the index pointer is still pointing at the third object but now the thirdobject is the file Letter, a file that has already been seen by the search.This change cannot be detected by looking at the parent directory'smodification date because <code>PBHRename</code> does not change any modificationdates. However, this change can be detected by checking to see if the indexpointer still points to the same file or directory. The search routine couldre-index through the directory to find the R&eacute;sum&eacute; file again andstart searching from there, but what about the directory that was renamed?  Thesearch routine either must miss it (and its contents) or it must repeat thesearch of the entire directory to ensure nothing is missed.</p><p align="center"><img src="images/fl_31_003.gif" alt="Before Toys Is Renamed With PBHRename" width=256 height=137></p><p align=center><b>Figure 3</b>.  Before Toys Is Renamed With <code>PBHRename</code></p><p align="center"><img src="images/fl_31_004.gif" alt="After Toys Is Renamed to Games With PBHRename" width=256 height=137></p><p align=center><b>Figure 4</b>.  After Toys Is Renamed to Games With <code>PBHRename</code></p><p>As these examples show, a change during a search of a hierarchical directorystructure with indexed File Manager calls involves the risk of missing catalogentries or finding duplicate catalog entries. If your application depends onseeing all items on a volume at least once and only once, you should make theusers of your application aware of the problems associated with indexedsearches and suggest to them ways to make sure the volume's catalog is notchanged during the indexed search. Here's a good suggestion you could make tothe user: do not use other programs during the search. Other programs maycreate, delete, or rename files during the search.</p><P><A HREF="#top">Back to top</A></P><a name="Summary"></a><h2>Summary</h2><p>You should always use <code>PBCatSearch</code> to search a volume if it isavailable. If <code>PBCatSearch</code> isn't available and you must use an indexedsearch, be aware that it is difficult to ensure that you do not miss some catalog entries or see some catalog entries multiple times during your search.</p><P><A HREF="#top">Back to top</A></P><a name="References"></a><h2>References</h2><p><i>Inside Macintosh</i>, Volume IV, The File Manager</p><p><i>Inside Macintosh</i>, Volume V, File Manager Extensions in a Shared Environment</p><p><i>Inside Macintosh</i>, Volume VI, The Finder Interface</p><p><i>Inside Macintosh</i>, Volume VI, The File Manager</p><p>Technical Note M.FL.ActiveFS -- <u><A HREF = "fl_35.html">Determining Which File System Is Active</a></u></p><p>Technical Note M.FL.PBSharePBUnshare -- <u><A HREF = "fl_28.html">PBShare, PBUnshare, and PBGetUGEntry</a></u></p><P><A HREF="#top">Back to top</A></P><P><A NAME=Downloads></A></P>                  <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (188K)</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/fl_31.pdf">Download</A></P>               </TD>            </TR></table><BR><P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/fl/fl_31.html%3Fid%3DDTS10002457-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/fl/fl_31.html%3Fid%3DDTS10002457-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/fl/fl_31.html%3Fid%3DDTS10002457-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>