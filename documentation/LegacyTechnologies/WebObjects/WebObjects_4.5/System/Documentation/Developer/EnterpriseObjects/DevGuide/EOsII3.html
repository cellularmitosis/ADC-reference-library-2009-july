<html><head><title>Advanced Enterprise Object Modeling</title></head><body bgcolor="#ffffff"><!--start of banner --><!--#include virtual="/includes/framesetheader" --><!-- end of banner --><!--start of path --><font face="Geneva,Helvetica,Arial" size="1"><b>PATH<spacer type="horizontal" size="5">&nbsp;</b> <a href="../../../../../../index.html" target="_top">Documentation</a> <b>&gt;</b> <a href="../../../../../webobjects.html" target="_top">WebObjects 4.5</a> <b>&gt;</b>EOF Developer's Guide</font><br><br><!--end of path --> <a href="EOsII.html"><IMG SRC="ArrowUp.gif">Table of Contents</a> <a href="EOsII2.html"><IMG SRC="ArrowLeft.gif">Previous Section</a> <a name="980"><h1> Modeling Inheritance</h1></a><a name="12948">One of the issues that may arise in designing your enterprise objects-whether you're creating your schema from scratch or working with an existing database-is the modeling of inheritance relationships. <p></a><a name="4344">In object-oriented programming, when a subclass inherits from a superclass, the instantiation of the subclass implies that all the superclass' data is available for use by the subclass. When you instantiate objects of a subclass from database data, all database tables that contain the data held in each class (whether subclass or superclass) must be accessed so that the data can be retrieved and put in the appropriate enterprise objects.<p></a><a name="4345">Even in the simplest scenario in which there is a one-to-one mapping between a single database table and an enterprise object, the database and the enterprise objects instantiated from its data have no knowledge of each other. Their mapping is determined by an EOModel. Likewise, inheritance relationships between enterprise objects and the mapping of those relationships onto a database are also managed by an EOModel.<p></a><a name="9905"><B>Note: </B> Enterprise Objects Framework doesn't support mapping inheritance hierarchies across tables in separate databases. Instead, you can set up groups of objects connected by cross-database relationships, where related objects forward messages to each other.<p></a><a name="4346"><h2> Types of Inheritance</h2></a><a name="4347">Suppose you're designing an application that includes Employee and Customer objects. Employees and customers share certain characteristics, such as a name and address, but they also have specialized characteristics. For example, an employee has a salary and a department, and a customer has account information.<p></a><a name="4348">Based on these data requirements, you might design a class hierarchy that has a Person class, and Employee and Customer subclasses. As subclasses of Person, Employee and Customer inherit Person's attributes (name and address), but they also implement attributes and behaviors that are specific to their classes.<p></a><a name="4352"><p><img src="EOsII6.gif"><p></a><a name="4353"><p>Figure 27.	  Class Hierarchy<p></a><a name="4354">In addition to designing your class hierarchy, you need to decide how to structure your database so that when objects of the classes are instantiated, the appropriate data is retrieved. Some of the issues you need to weigh in deciding on an approach are:<p></a><ul><a name="4355"><p><li>Are fetches usually directed at the leaves or the root of the class hierarchy?</a><a name="4356"><p>When a class hierarchy is mapped onto a relational database, data is accessed in two different ways: By fetching just the leaves (for example, just Employee or Customer), and by fetching at the root (Person) to get instances of all levels of the class hierarchy (Employees and Customers).<p></a><a name="4357"><p><li>How deep is the class hierarchy?</a><a name="9970"><p>While deep class hierarchies can be a useful technique in object-oriented programming, you should try to avoid them for enterprise objects. When you attempt to map a deep class hierarchy onto a relational database, the result is likely to be poor performance and a database that's difficult to maintain.<p></a><a name="4358"><p><li>What is the database storage cost for NULL attributes?</a><a name="4359"><p><li>Will I need to modify my schema on an ongoing basis?</a><a name="4360"><p><li>Will other tools be accessing the database?</a><a name="4361"><p><li>Do I need to use inheritance at all?</a></ul><a name="10263">The primary consideration in deciding whether to use inheritance is if you'll ever need to perform a deep fetch. In an inheritance hierarchy, fetching just objects of a particular class is a shallow fetch, while fetching all instances of a class and its subclasses is a deep fetch. For example, even if the Objective-C classes for Customer and Employee inherit from Person, if your application never performs a fetch for "all people including Customers and Employees," then there is no need to tell Enterprise Objects Framework about your class hierarchy.<p></a><a name="4363">Enterprise Objects Framework supports the three primary approaches for mapping inheritance hierarchies to database tables:<p></a><ul><a name="4364"><li>Vertical mapping</a><a name="4365"><li>Horizontal mapping</a><a name="4366"><li>One table mapping</a></ul><a name="8148">These approaches, along with the advantages and disadvantages of each, are discussed in the following sections. None of them represents a perfect solution-which one is appropriate depends on the needs of your application.<p></a><a name="8151"><h2> Vertical Mapping</h2></a><a name="4371">In this approach, each class has a separate table associated with it. There is a Person table, an Employee table, and a Customer table; each table contains only the attributes defined by that class.<p></a><a name="4375"><p><img src="EOsII7.gif"><p></a><a name="4376"><p>Figure 28.	  Vertical Inheritance Mapping<p></a><a name="4377">This method of storage directly reflects the class hierarchy. If an object of the Employee class is retrieved, data for the Employee's Person attributes must be fetched along with Employee data. The relationship between Employee and Person is resolved through a join to give Employee access to its Person data. This is also true for Customer.<p></a><a name="4379"><h3> Creating an EOModel for Vertical Mapping</h3></a><a name="4380">Assuming that the entities for each of the participating tables already exist, you do the following to implement vertical mapping in your EOModel:<p></a><ol><a name="4382"><P><li>Create a to-one relationship from each of the child entities (Employee and Customer) to the parent entity (Person) joining on &#32;the primary keys, and set it so it isn't a class property.</a><a name="4384"><P><li>Flatten the Person parent attributes into each child entity (Employee and Customer) setting them as class properties if they are class properties in Person.</a><a name="6359"><P><li>Flatten the Person parent entity's relationships into each child entity (Employee and Customer), setting them as class properties if they are class properties in Person.</a><a name="6555"><P><li>Set the parent entity for each child entity (Employee and Customer) to Person.</a><a name="6559"><P><li>In the Advanced Entity Inspector, set the Person parent entity to &#32;be abstract if you won't ever instantiate instances of Person.</a></ol><a name="9984"><h3> Advantages</h3></a><a name="9992">With vertical mapping, a subclass can be added at any time without modifying the Person table. Existing subclasses can also be modified without affecting the other classes in the class hierarchy. The primary virtue of this approach is its clean, "normalized" design.<p></a><a name="9985"><h3> Disadvantages</h3></a><a name="10285">Vertical mapping is the least efficient of all of the approaches. Every layer of the class hierarchy requires a join to resolve the relationships. For example, if you want to do a deep fetch from Person, three fetches are performed: a fetch from Employee (with a join to Person), a fetch from Customer (with a join to Person), and a fetch from Person to retrieve all the Person attributes. (If Person is an abstract superclass for which no objects are ever instantiated, the last fetch is not performed.)<p></a><a name="10287"><h2> Horizontal Mapping</h2></a><a name="10290">In this approach, you have separate tables for Employee and Customer that each contain columns for Person. The Employee and Customer tables contain not only their own attributes, but all of the Person attributes as well. If instances of Person exist that are not classified as Employees or Customers, a third table would be required (where Person is <em>not</em> an abstract class). In other words, with horizontal mapping every concrete class has a self-contained database table that contains all of the attributes necessary to instantiate objects of the class.<p></a><a name="4393"><p><img src="EOsII8.gif"><p></a><a name="4394"><p>Figure 29.	  Horizontal Inheritance Mapping<p></a><a name="4395">This technique entails the same fetching pattern as vertical mapping, except that no joins are performed.<p></a><a name="4397"><h3> Creating an EOModel for Horizontal Mapping</h3></a><a name="4398">To implement horizontal mapping, you do the following in your EOModel:<p></a><ol><a name="7387"><P><li>If a Person entity doesn't already exist, create one. (If there isn't a database table exclusively for Persons who aren't Employees or Customers, EOModeler doesn't automatically create an entity for Person.)</a><a name="4399"><P><li>Set Person as the parent entity of Employee and Customer.</a><a name="7398"><P><li>In the Advanced Entity Inspector, set the parent entity to be abstract if you never fetch Person objects that aren't Employees or Customers (you never instantiate instances of Person). Under horizontal mapping, if Person doesn't have its own table, then it's an abstract entity.</a></ol><a name="4401">Unlike vertical mapping, you don't need to flatten any of Person's attributes into Employee and Customer since they already include all of its attributes.<p></a><a name="10002"><h3> Advantages</h3></a><a name="10012">Similar to vertical mapping, a subclass can be added at any time without modifying other tables. Existing subclasses can also be modified without affecting the other classes in the class hierarchy. <p></a><a name="10003">This approach works well for deep class hierarchies, as long as the fetch occurs against the leaves of the class hierarchy (Employee and Customer) rather than against the root (Person). In the case of a deep fetch, it's more efficient than vertical mapping (since no joins are performed). It's the most efficient approach, if you only fetch instances of one leaf subclass at a time. <p></a><a name="10004"><h3> Disadvantages</h3></a><a name="10005">Problems may occur when attributes need to be added to the Person superclass. The number of tables that need to be altered is equal to the number of subclasses-the more subclasses you have, the more effort is required to maintain the superclass. However, if table maintenance happens far less often than fetches, this might be a viable approach for your application. <p></a><a name="4404"><h2> Single Table Mapping</h2></a><a name="10030">In this approach, you put all of the data in one table that contains all superclass and subclass attributes. Each row contains all of the columns for the superclass as well as for all of the subclasses. The attributes that don't apply for each object have NULL values. You fetch an Employee or Customer by using a query that just returns objects of the specified type (the table would probably include a type column to distinguish records of one type from the other).<p></a><a name="4409"><p><img src="EOsII9.gif"><p></a><a name="4410"><p>Figure 30.	  Single Table Mapping<p></a><a name="4413"><h3> Creating an EOModel for Single Table Mapping</h3></a><a name="4414">To implement a single table mapping, you do the following in your EOModel:<p></a><ol><a name="7428"><P><li>Add Employee and Customer entities to your model. (You can use EOModeler's Create Subclass command for this purpose.)</a><a name="7436"><P><li>Set Person as the parent entity of Employee and Customer.</a><a name="7468"><P><li>In the Advanced Entity Inspector, assign a restricting qualifier to the Employee entity that distinguishes its rows from the rows of other entities. Similarly, assign a restricting qualifier to the Customer entity.</a><a name="7456"><P><li>In the Advanced Entity Inspector, set the Person entity to be abstract if you won't ever instantiate Person instances.</a></ol><a name="4417">Unlike vertical mapping, you don't need to flatten any of Person's attributes into Employee and Customer since these entities already have all of Person's attributes.<p></a><a name="4418">Each sub-entity maps to the same table and contains attributes only for the properties that are relevant for that class.<p></a><a name="10038"><h3> Advantages</h3></a><a name="10042">This approach is faster than the other two methods for deep fetches. Unlike vertical or horizontal mapping, you can retrieve superclass objects with a single fetch, without performing joins. Adding a subclass or modifying the superclass requires changes to just one table. <p></a><a name="10039"><h3> Disadvantages</h3></a><a name="10043">Single table mapping can consume an inordinate amount of space since every row includes columns for every one of the other entities' attributes. This may depend on how your database stores NULLs. Some databases condense NULL values, thereby reducing the storage space needed, but some databases maintain the length of the actual data type of the column regardless of the value stored. Most databases also have limitations on how many columns a table can have (typically this is around 250 columns), which can make it impossible to use single table mapping for a &#32;deep class hierarchy that has lots of instance variables. <p></a><a name="10339">Also, if you have a lot of data, this approach can actually be less efficient than horizontal mapping since with single table mapping you have to search the entire table to find the rows needed to instantiate objects of &#32;a &#32;particular type. (Horizontal mapping is only more efficient if your application just fetches one type of leaf object at a time (instances of a particular subclass).<p></a><a name="4420"><h2> Data Access Patterns for Inheritance</h2></a><a name="4446">The following table summarizes how data is fetched in each of the approaches. <Table Border="3"><caption></caption><tr><td scope="row"><a name="4423"></a></td><td><a name="4425">Fetches from Leaves </a></td><td><a name="4427">Fetches from Root </a></td></tr><tr><td scope="row"><a name="4429">Vertical Mapping</a></td><td><a name="4431">1 fetch using join</a></td><td><a name="4433">n fetches using join</a></td></tr><tr><td scope="row"><a name="4435">Horizontal Mapping</a></td><td><a name="4437">1 fetch</a></td><td><a name="4439">n fetches	</a></td></tr><tr><td scope="row"><a name="4441">Single Table Mapping</a></td><td><a name="4443">1 fetch</a></td><td><a name="4445">1 fetch</a></td></tr></Table><Table><tr><td></Table><p></a><a name="4447">In the table, "n" represents the number of entities involved in a deep fetch. For example, when you perform a deep fetch against Person in the &#32;Person, Customer, Employee class hierarchy, n equals 3.<p></a><a name="4466"><h2> Fetching and Inheritance</h2></a><a name="10356">Once you've designed your class hierarchy and set up your EOModel to support that class hierarchy, you can use this information to fetch objects of the desired type. For example, you might want to just fetch Person objects, not Customer or Employee objects-or you might want to fetch all Person objects, including Customers and Employees.<p></a><a name="10357">You can control deep versus shallow fetches by using EOFetchSpecification's <strong>setIsDeep</strong> method (<strong>setIsDeep:</strong> in Objective-C). This method specifies whether a fetch should include sub-entities of the &#32;fetch specification's entity. If this method is set to <strong>true</strong> (YES in Objective-C), sub-entities are also fetched; if it's set to <strong>false</strong> (NO), they &#32;aren't. EOFetchSpecifications are deep by default.<p></a><a name="4471">When multiple entities are mapped to a single database table, you must set a qualifier on each entity to distinguish its rows from the rows of other entities. You can either do this programmatically by using EOEntity method <strong>setRestrictingQualifier</strong> (<strong>setRestrictingQualifier:</strong> in Objective-C), or you can directly specify the qualifier in the EOModeler Advanced Entity Inspector. A restricting qualifier maps an entity to a subset of rows in a table. If you're using single table inheritance mapping, you must use a restricting qualifier that identifies objects of the desired type.<p></a><a name="4474"><h2> Delegation Hooks for Optimizing Inheritance</h2></a><a name="4475">EOModelGroup includes delegate methods that you can use to exercise more fine-grained control over inheritance. These include:<p></a><a name="4477"> relationshipForRow<p></a><a name="4478">This method (<strong>entity:relationshipForRow:relationship:</strong> in Objective-C) is invoked when relationships are instantiated for a newly fetched object. The delegate can use the information in the row to determine which entity the target enterprise object should be associated with, and replace the relationship appropriately.<p></a><a name="4480"> subEntityForEntity<p></a><a name="4481">This method (<strong>subEntityForEntity:primaryKey:isFinal:</strong> in Objective-C) allows the delegate to fine-tune inheritance by indicating from which sub-entity an object should be fetched based on its primary key. The entity returned must be a sub-entity of the specified entity.<p></a><a name="12916">In Objective-C, if the delegate knows that the object should be fetched from the returned entity and not one of its sub-entities, it should set the <strong>isFinal</strong> argument (a pointer to a BOOL) to YES. (In Java, the object must be fetched from the returned entity; it must be final.)<p></a><a name="4483"> classForObjectWithGlobalID<p></a><a name="14031">This method (<strong>entity:classForObjectWithGlobalID:</strong> in Objective-C) is also &#32;used to fine-tune inheritance. The delegate can use the specified globalID to determine a subclass to be used in place of the one specified in the entity argument.<p></a><a name="14033"><h2> Java Limitation With Ambiguous To-One Relationships</h2></a><a name="10369">In both Java and Objective-C you can have to-many relationships to instances of both leaf and non-leaf subclasses in your class hierarchy. For &#32;example, the SoftballTeam entity can have a to-many relationship to &#32;Person or just the Employee entity (as in a company only team). <p></a><a name="10440">Similarly, you can have to-one relationships to instances of leaf subclasses. For example, the PurchaseOrder entity can have a to-one relationship to &#32;the Customer entity. <p></a><a name="10441">However, in Java you can <em>not</em> have a to-one relationship to a non-leaf entity, an <em>ambiguous to-one relationship</em>, unless you implement a workaround. Ambiguous to-one relationships are not possible in Java because of strong typing in the language. In Objective-C, the class of an instance can be changed after it is instantiated (i.e., from the parent class to the leaf class).<p></a><a name="10442">There are two workarounds for Java programmers. You can encode class information in your primary and foreign keys, and implement EOModelGroup's delegate methods as described in <a href="EOsII3.html#4474"> "Delegation Hooks for Optimizing Inheritance"</a>. If you choose this option, then consider using single table mapping since the table would already contain class information.<p></a><a name="10448">The second workaround is to implement the ambiguous to-one relationship as a to-many, similar to dealing with an optional to-one relationship above. <a href="EOsII2.html#953"> "Use a To-Many Relationship"</a><p></a><P> <a href="EOsII.html"><IMG SRC="ArrowUp.gif">Table of Contents</a> <a href="EOsII4.html"><IMG SRC="ArrowRight.gif">Next Section</a><P></body></html>