<HTML><HEAD><META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter"><script language="JavaScript" src="frametest.js"></script><TITLE>Manipulating Textures and Bitmaps</TITLE></HEAD><BODY BGCOLOR="#ffffff"><!-- start of header --><!--#include virtual="/includes/framesetheader" --><!-- end of header --><!-- path goes here --><H1 CLASS="RH3.RoutineHd3"><A NAME="pgfId=55099"> </A>Manipulating Textures and Bitmaps</H1><P CLASS="T1.Text1"><A NAME="pgfId=40215"> </A>QuickDraw&nbsp;3D RAVE provides routines that you can use to create and dispose of texture maps and bitmaps. It also provides routines that you can use to bind color lookup tables to texture maps and bitmaps.</P><DIV><H2 CLASS="RoH.RoutineHeading"><A NAME="pgfId=40726"> </A>QATextureNew</H2><P CLASS="T1.Text1"><A NAME="pgfId=40727"> </A><A NAME="marker=51923"> </A><A NAME="marker=51866"> </A>You can use the <TT CLASS="cv">QATextureNew</TT> function to create a new texture map.</P><CODE CLASS="RD.RoutineDeclare"><A NAME="pgfId=67448"> </A>TQAError QATextureNew (<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const TQAEngine *engine, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned long flags, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TQAImagePixelType pixelType, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const TQAImage images[], <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TQATexture **newTexture);<BR></CODE><DL COMPACT><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=67450"> </A><TT CLASS="cv">engine</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=40673"> </A>A drawing engine.</DD><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=67459"> </A><TT CLASS="cv">flags</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=40636"> </A>A set of bit flags specifying features of the new texture map. See <A HREF="qd3dravedriver.2d.htm#21829" CLASS="XRef">&quot;Texture Flags Masks&quot;</A> for complete information.</DD><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=67468"> </A><TT CLASS="cv">pixelType</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=40853"> </A>The type of pixels in the new texture map. See <A HREF="qd3dravedriver.16.htm#13225" CLASS="XRef">&quot;Pixel Types&quot;</A> for a description of the values you can pass in this parameter.</DD><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=67477"> </A><TT CLASS="cv">images</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=40855"> </A>An array of pixel images to use for the new texture map. The values in the <TT CLASS="cv">width</TT> and <TT CLASS="cv">height</TT> fields of these structures must be an even power of 2.</DD><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=67486"> </A><TT CLASS="cv">newTexture</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=40856"> </A>On entry, the address of a pointer variable. On exit, that variable points to a new texture map. If a new texture map cannot be created, <TT CLASS="cv">*newTexture</TT> is set to the value <TT CLASS="cv">NULL</TT>.</DD></DL COMPACT><DIV><H3 CLASS="RSb.RoutineSbhd"><A NAME="pgfId=40667"> </A>DESCRIPTION</H3><P CLASS="T1.Text1"><A NAME="pgfId=40786"> </A>The <TT CLASS="cv">QATextureNew</TT> function returns, through the <TT CLASS="cv">newTexture</TT> parameter, a new texture map associated with the drawing engine specified by the <TT CLASS="cv">engine</TT> parameter. You can use the returned texture map to set the value of the <TT CLASS="cv">kQATag_Texture</TT> state variable.</P><P CLASS="T1.Text1"><A NAME="pgfId=40817"> </A>The <TT CLASS="cv">flags</TT> parameter specifies a set of texture map features. If the <TT CLASS="cv">kQATexture_Lock</TT> bit in that parameter is set but the drawing engine cannot guarantee that the texture will remain locked in memory, the <TT CLASS="cv">QATextureNew</TT> function returns an error.</P><P CLASS="T1.Text1"><A NAME="pgfId=40839"> </A>If the <TT CLASS="cv">kQATexture_Mipmap</TT> bit of the <TT CLASS="cv">flags</TT> parameter is clear, the <TT CLASS="cv">images</TT> parameter points to a single pixel image that defines the texture map. If the <TT CLASS="cv">kQATexture_Mipmap</TT> bit is set, the <TT CLASS="cv">images</TT> parameter points to an array of pixel images of varying pixel depths. The first element in the array must be the mipmap page having the highest resolution, with a width and height that are even powers of 2. Each subsequent pixel image in the array should have a width and height that are half those of the previous image (with a minimum width and height of 1).<A NAME="marker=57744"> </A></P></DIV><DIV><H3 CLASS="RSb.RoutineSbhd"><A NAME="pgfId=40882"> </A>SPECIAL CONSIDERATIONS</H3><P CLASS="T1.Text1"><A NAME="pgfId=40998"> </A><TT CLASS="cv">QATextureNew</TT> does not automatically copy the pixmap data pointed to by the <TT CLASS="cv">images</TT> parameter. As a result, you should not release or reuse the storage occupied by the pixel images until you've called <TT CLASS="cv">QATextureDetach</TT>. Note, however, that <TT CLASS="cv">QATextureNew</TT> does copy all of the information contained in the <TT CLASS="cv">TQAImage</TT> structures in the array, so you can free or reuse that memory after <TT CLASS="cv">QATextureNew</TT> completes successfully.</P></DIV></DIV><DIV><H2 CLASS="RoH.RoutineHeading"><A NAME="pgfId=40999"> </A>QATextureDetach</H2><P CLASS="T1.Text1"><A NAME="pgfId=40235"> </A><A NAME="marker=51861"> </A>You can use the <TT CLASS="cv">QATextureDetach</TT> function to detach a texture map from a drawing engine.</P><CODE CLASS="RD.RoutineDeclare"><A NAME="pgfId=67497"> </A>TQAError QATextureDetach (const TQAEngine *engine, TQATexture *texture);<BR></CODE><DL COMPACT><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=67499"> </A><TT CLASS="cv">engine</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=40677"> </A>A drawing engine.</DD><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=67508"> </A><TT CLASS="cv">texture</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=40631"> </A>A texture map.</DD></DL COMPACT><DIV><H3 CLASS="RSb.RoutineSbhd"><A NAME="pgfId=40256"> </A>DESCRIPTION</H3><P CLASS="T1.Text1"><A NAME="pgfId=40257"> </A>The <TT CLASS="cv">QATextureDetach</TT> function causes the drawing engine specified by the <TT CLASS="cv">engine</TT> parameter to copy the data associated with the texture map specified by the <TT CLASS="cv">texture</TT> parameter. Once the data are copied, you can reuse or dispose of the memory you originally specified in a call to <TT CLASS="cv">QATextureNew</TT>.</P></DIV></DIV><DIV><H2 CLASS="RoH.RoutineHeading"><A NAME="pgfId=55872"> </A><A NAME="17123"> </A>QATextureBindColorTable</H2><P CLASS="T1.Text1"><A NAME="pgfId=55873"> </A><A NAME="marker=57975"> </A>You can use the <TT CLASS="cv">QATextureBindColorTable</TT> function to bind a color lookup table to a texture map.</P><CODE CLASS="RD.RoutineDeclare"><A NAME="pgfId=67519"> </A>TQAError QATextureBindColorTable (<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const TQAEngine *engine,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TQATexture *texture,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TQAColorTable *colorTable);<BR></CODE><DL COMPACT><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=67521"> </A><TT CLASS="cv">engine</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=55875"> </A>A drawing engine.</DD><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=67530"> </A><TT CLASS="cv">texture</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=55876"> </A>A texture map.</DD><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=67539"> </A><TT CLASS="cv">colorTable</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=55877"> </A>A color lookup table (as returned by a previous call to <TT CLASS="cv">QAColorTableNew</TT>).</DD></DL COMPACT><DIV><H3 CLASS="RSb.RoutineSbhd"><A NAME="pgfId=55878"> </A>DESCRIPTION</H3><P CLASS="T1.Text1"><A NAME="pgfId=55879"> </A>The <TT CLASS="cv">QATextureBindColorTable</TT> function binds the color lookup table specified by the <TT CLASS="cv">colorTable</TT> parameter to the texture map specified by the <TT CLASS="cv">texture</TT> parameter. Before you can draw any texture map whose pixel type is either <TT CLASS="cv">kQAPixel_CL4</TT> or <TT CLASS="cv">kQAPixel_CL8</TT>, you must bind a color lookup table to it. In addition, the type of the specified color lookup table must match that of the pixel type of the texture map to which it is bound. For example, a color lookup table of type <TT CLASS="cv">kQAColorTable_CL8_RGB32</TT> can be bound only to a texture map whose pixel type is <TT CLASS="cv">kQAPixel_CL8</TT>.</P></DIV></DIV><DIV><H2 CLASS="RoH.RoutineHeading"><A NAME="pgfId=40258"> </A>QATextureDelete</H2><P CLASS="T1.Text1"><A NAME="pgfId=40259"> </A><A NAME="marker=51856"> </A>You can use the <TT CLASS="cv">QATextureDelete</TT> function to delete a texture map.</P><CODE CLASS="RD.RoutineDeclare"><A NAME="pgfId=67550"> </A>void QATextureDelete (const TQAEngine *engine, TQATexture *texture);<BR></CODE><DL COMPACT><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=67552"> </A><TT CLASS="cv">engine</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=40681"> </A>A drawing engine.</DD><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=67561"> </A><TT CLASS="cv">texture</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=40917"> </A>A texture map.</DD></DL COMPACT><DIV><H3 CLASS="RSb.RoutineSbhd"><A NAME="pgfId=40266"> </A>DESCRIPTION</H3><P CLASS="T1.Text1"><A NAME="pgfId=40267"> </A>The <TT CLASS="cv">QATextureDelete</TT> function deletes the texture map specified by the <TT CLASS="cv">texture</TT> parameter from the drawing engine specified by the <TT CLASS="cv">engine</TT> parameter.<A NAME="marker=51922"> </A></P></DIV></DIV><DIV><H2 CLASS="RoH.RoutineHeading"><A NAME="pgfId=40268"> </A>QABitmapNew</H2><P CLASS="T1.Text1"><A NAME="pgfId=40269"> </A><A NAME="marker=51921"> </A><A NAME="marker=51851"> </A>You can use the <TT CLASS="cv">QABitmapNew</TT> function to create a new bitmap.</P><CODE CLASS="RD.RoutineDeclare"><A NAME="pgfId=67572"> </A>TQAError QABitmapNew (<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const TQAEngine *engine, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned long flags, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TQAImagePixelType pixelType, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const TQAImage *image, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TQABitmap **newBitmap);<BR></CODE><DL COMPACT><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=67574"> </A><TT CLASS="cv">engine</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=40685"> </A>A drawing engine.</DD><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=67583"> </A><TT CLASS="cv">flags</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=40567"> </A>A set of bit flags specifying features of the new bitmap. See <A HREF="qd3dravedriver.2e.htm#13462" CLASS="XRef">&quot;Bitmap Flags Masks&quot;</A> for complete information</DD><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=67592"> </A><TT CLASS="cv">pixelType</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=40568"> </A>The type of pixels in the new bitmap. See <A HREF="qd3dravedriver.16.htm#13225" CLASS="XRef">&quot;Pixel Types&quot;</A> for a description of the values you can pass in this parameter.</DD><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=67601"> </A><TT CLASS="cv">image</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=40569"> </A>A pixel image to use for the new bitmap. The <TT CLASS="cv">width</TT> and <TT CLASS="cv">height</TT> fields of this image can have any values greater than 0.</DD><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=67610"> </A><TT CLASS="cv">newBitmap</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=40570"> </A>On entry, the address of a pointer variable. On exit, that variable points to a new bitmap. If a new bitmap cannot be created, <TT CLASS="cv">*newBitmap</TT> is set to the value <TT CLASS="cv">NULL</TT>.</DD></DL COMPACT><DIV><H3 CLASS="RSb.RoutineSbhd"><A NAME="pgfId=40273"> </A>DESCRIPTION</H3><P CLASS="T1.Text1"><A NAME="pgfId=40274"> </A>The <TT CLASS="cv">QABitmapNew</TT> function returns, through the <TT CLASS="cv">newBitmap</TT> parameter, a pointer to a new bitmap associated with the drawing engine specified by the <TT CLASS="cv">engine</TT> parameter. You can draw the returned bitmap by calling the <TT CLASS="cv">QADrawBitmap</TT> function.</P><P CLASS="T1.Text1"><A NAME="pgfId=41056"> </A>The <TT CLASS="cv">flags</TT> parameter specifies a set of bitmap features. If the <TT CLASS="cv">kQABitmap_Lock</TT> bit in that parameter is set but the drawing engine cannot guarantee that the bitmap will remain locked in memory, the <TT CLASS="cv">QABitmapNew</TT> function returns an error.</P></DIV><DIV><H3 CLASS="RSb.RoutineSbhd"><A NAME="pgfId=41058"> </A>SPECIAL CONSIDERATIONS</H3><P CLASS="T1.Text1"><A NAME="pgfId=41059"> </A><TT CLASS="cv">QABitmapNew</TT> does not automatically copy the pixmap data pointed to by the <TT CLASS="cv">images</TT> parameter. As a result, you should not release or reuse the storage occupied by the pixel image until you've called <TT CLASS="cv">QABitmapDetach</TT>. Note, however, that <TT CLASS="cv">QABitmapNew</TT> does copy all of the information contained in the <TT CLASS="cv">TQAImage</TT> structure, so you can free or reuse that memory after <TT CLASS="cv">QABitmapNew</TT> completes successfully.</P></DIV></DIV><DIV><H2 CLASS="RoH.RoutineHeading"><A NAME="pgfId=40275"> </A>QABitmapDetach</H2><P CLASS="T1.Text1"><A NAME="pgfId=40276"> </A><A NAME="marker=51846"> </A>You can use the <TT CLASS="cv">QABitmapDetach</TT> function to detach a bitmap from a drawing engine.</P><CODE CLASS="RD.RoutineDeclare"><A NAME="pgfId=67621"> </A>TQAError QABitmapDetach (const TQAEngine *engine, TQABitmap *bitmap);<BR></CODE><DL COMPACT><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=67623"> </A><TT CLASS="cv">engine</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=40689"> </A>A drawing engine.</DD><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=67632"> </A><TT CLASS="cv">bitmap</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=40547"> </A>A bitmap.</DD></DL COMPACT><DIV><H3 CLASS="RSb.RoutineSbhd"><A NAME="pgfId=40280"> </A>DESCRIPTION</H3><P CLASS="T1.Text1"><A NAME="pgfId=40979"> </A>The <TT CLASS="cv">QABitmapDetach</TT> function causes the drawing engine specified by the <TT CLASS="cv">engine</TT> parameter to copy the data associated with the bitmap specified by the <TT CLASS="cv">bitmap</TT> parameter. Once the data are copied, you can reuse or dispose of the memory you originally specified in a call to <TT CLASS="cv">QABitmapNew</TT>.</P></DIV></DIV><DIV><H2 CLASS="RoH.RoutineHeading"><A NAME="pgfId=55860"> </A><A NAME="27774"> </A>QABitmapBindColorTable</H2><P CLASS="T1.Text1"><A NAME="pgfId=55861"> </A><A NAME="marker=58505"> </A><A NAME="marker=57983"> </A>You can use the <TT CLASS="cv">QABitmapBindColorTable</TT> function to bind a color lookup table to a bitmap.</P><CODE CLASS="RD.RoutineDeclare"><A NAME="pgfId=67643"> </A>TQAError QABitmapBindColorTable (<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const TQAEngine *engine,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TQABitmap *bitmap,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TQAColorTable *colorTable);<BR></CODE><DL COMPACT><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=67645"> </A><TT CLASS="cv">engine</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=55863"> </A>A drawing engine.</DD><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=67654"> </A><TT CLASS="cv">bitmap</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=55864"> </A>A bitmap.</DD><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=67663"> </A><TT CLASS="cv">colorTable</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=55865"> </A>A color lookup table (as returned by a previous call to <TT CLASS="cv">QAColorTableNew</TT>).</DD></DL COMPACT><DIV><H3 CLASS="RSb.RoutineSbhd"><A NAME="pgfId=55866"> </A>DESCRIPTION</H3><P CLASS="T1.Text1"><A NAME="pgfId=55867"> </A>The <TT CLASS="cv">QABitmapBindColorTable</TT> function binds the color lookup table specified by the <TT CLASS="cv">colorTable</TT> parameter to the bitmap specified by the <TT CLASS="cv">bitmap</TT> parameter. Before you can draw any bitmap whose pixel type is either <TT CLASS="cv">kQAPixel_CL4</TT> or <TT CLASS="cv">kQAPixel_CL8</TT>, you must bind a color lookup table to it. In addition, the type of the specified color lookup table must match that of the pixel type of the bitmap to which it is bound. For example, a color lookup table of type <TT CLASS="cv">kQAColorTable_CL8_RGB32</TT> can be bound only to a bitmap whose pixel type is <TT CLASS="cv">kQAPixel_CL8</TT>.</P></DIV></DIV><DIV><H2 CLASS="RoH.RoutineHeading"><A NAME="pgfId=40282"> </A>QABitmapDelete</H2><P CLASS="T1.Text1"><A NAME="pgfId=40283"> </A><A NAME="marker=51841"> </A>You can use the <TT CLASS="cv">QABitmapDelete</TT> function to delete a bitmap.</P><CODE CLASS="RD.RoutineDeclare"><A NAME="pgfId=67674"> </A>void QABitmapDelete (const TQAEngine *engine, TQABitmap *bitmap);<BR></CODE><DL COMPACT><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=67676"> </A><TT CLASS="cv">engine</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=40693"> </A>A drawing engine.</DD><DT CLASS="DT.DefinitionTerm"><A NAME="pgfId=67685"> </A><TT CLASS="cv">bitmap</TT></DT><DD CLASS="DD.DefinitionDef"><A NAME="pgfId=40523"> </A>A bitmap.</DD></DL COMPACT><DIV><H3 CLASS="RSb.RoutineSbhd"><A NAME="pgfId=40290"> </A>DESCRIPTION</H3><P CLASS="T1.Text1"><A NAME="pgfId=55570"> </A>The <TT CLASS="cv">QABitmapDelete</TT> function deletes the bitmap specified by the <TT CLASS="cv">bitmap</TT> parameter from the drawing engine specified by the <TT CLASS="cv">engine</TT> parameter.<A NAME="marker=55571"> </A></P></DIV></DIV><hr>&#169; 1997 Apple Computer, Inc.</DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV><!-- start of footer --><!--#include virtual="/includes/framesetfooter" --><!-- end of footer --></BODY></HTML>