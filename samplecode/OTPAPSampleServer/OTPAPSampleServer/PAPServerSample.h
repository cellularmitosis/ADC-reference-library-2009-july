/*	File:		PAPServerSample.h	Contains:	headers, defines for the PAPServerSample.c file	Written by:	Rich Kubota	Copyright:	© 1993-1996 by Apple Computer, Inc., all rights reserved.	Change History (most recent first):	To Do:*/#ifndef __PAPSERVERSAMPLE__#define __PAPSERVERSAMPLE__#ifndef __CONDITIONALMACROS__#include <ConditionalMacros.h>#endif#ifdef __cplusplusextern "C" {#endif#if PRAGMA_ALIGN_SUPPORTED#pragma options align=mac68k#endif#if PRAGMA_IMPORT_SUPPORTED#pragma import on#endif#include <stdio.h>#include <Types.h>#include <Memory.h>#include <Resources.h>#include <Events.h>#include "OpenTransport.h"		// open transport files	#include "OpenTptAppleTalk.h"	//#define SHOW_DEBUG_FLOW		1	// enable display of DebugStr showing program flow#if SHOW_DEBUG_FLOW#define	DO_DEBUG_LOG		0	// enable a debug log at the beginning#endif// defines for the STR# resource#define kServerStrID	1000	// STR# resource ID for the PAP Server Sample strings#define kOTVersion111	0x01118000#define kOTVersion120	0x01208000enum {	kServerNBPStrID	= 1,	kIdleStrID,	kBusyStrID,	kForceClose = 'clos'};#define kZeroQLen		0#define kDynamicSocket	0#define kATPType		3#define TIMEOUT			25 		// seconds#define kMaxHandoffEPs	1		// maximum number of handoff endpoints supported by this sample#define kDITop			0x0050		/* kTopLeft - for positioning the Disk											   Initialization dialogs. */#define kDILeft			0x0070#define kNumBuffers		25		// initial number of packet buffers to allocate#define kUserByteSize	4#define	kPAPDataSize	32768	// if we can, collect 16K of data at a time		// defines for gFlags bits#define OTActiveFlag		0#define	dumpAllPktsFlag		1#define BufsInitdFlag		4#define InBackGndFlag		5#define BuffsHeldFlag		6#define CheckOptFlag		7#define StatusBusyFlag		8#define StatusIdleFlag		9// flags macros for setting, testing and clearing the gFlag bits#define SetOTActiveFlag(flags)		((flags) |= 1 << OTActiveFlag)#define ClrOTActiveFlag(flags)		((flags) &= (-1 ^ (1 << OTActiveFlag)))#define TstOTActiveFlag(flags)		(((flags) & (1 << OTActiveFlag)) != 0)#define SetdumpAllPktsFlag(flags)	((flags) |= 1 << dumpAllPktsFlag)#define ClrdumpAllPktsFlag(flags)	((flags) &= (-1 ^ (1 << dumpAllPktsFlag)))#define TstdumpAllPktsFlag(flags)	(((flags) & (1 << dumpAllPktsFlag)) != 0)#define SetBufsInitdFlag(flags)		((flags) |= 1 << BufsInitdFlag)#define ClrBufsInitdFlag(flags)		((flags) &= (-1 ^ (1 << BufsInitdFlag)))#define TstBufsInitdFlag(flags)		(((flags) & (1 << BufsInitdFlag)) != 0)#define SetInBackGndFlag(flags)		((flags) |= 1 << InBackGndFlag)#define ClrInBackGndFlag(flags)		((flags) &= (-1 ^ (1 << InBackGndFlag)))#define TstInBackGndFlag(flags)		(((flags) & (1 << InBackGndFlag)) != 0)#define SetBuffsHeldFlag(flags)		((flags) |= 1 << BuffsHeldFlag)#define ClrBuffsHeldFlag(flags)		((flags) &= (-1 ^ (1 << BuffsHeldFlag)))#define TstBuffsHeldFlag(flags)		(((flags) & (1 << BuffsHeldFlag)) != 0)#define SetCheckOptFlag(flags)		((flags) |= 1 << CheckOptFlag)#define ClrCheckOptFlag(flags)		((flags) &= (-1 ^ (1 << CheckOptFlag)))#define TstCheckOptFlag(flags)		(((flags) & (1 << CheckOptFlag)) != 0)#define SetStatusBusyFlag(flags)	((flags) |= 1 << StatusBusyFlag)#define ClrStatusBusyFlag(flags)	((flags) &= (-1 ^ (1 << StatusBusyFlag)))#define TstStatusBusyFlag(flags)	(((flags) & (1 << StatusBusyFlag)) != 0)#define SetStatusIdleFlag(flags)	((flags) |= 1 << StatusIdleFlag)#define ClrStatusIdleFlag(flags)	((flags) &= (-1 ^ (1 << StatusIdleFlag)))#define TstStatusIdleFlag(flags)	(((flags) & (1 << StatusIdleFlag)) != 0)// defines for the semaphore bits#define kInListenLoop		0		// this bit used with OTAtomicSetBit to control re-entrancy into the DoListenAccept procedure#define kInRcvDataFlag		1		// used with OTAtomic calls to check whether in DoReceive call// defines for flags bits#define EPActiveFlag		0		// indicates that the endpoint is active#define EPBoundFlag			1		// indicates the endpoint is bound#define EPBusyFlag			2		// used with handoff endpoint to indicate it has accepted 									// a handoff endpoint#define PassconFlag			3		// the passive connection has completed#define ListenPendFlag		4#define AcceptPendFlag		5#define UnbindPendFlag		7		// indicates that the endpoint is pending an unbind request to									// to complete#define DisconPendFlag		8		// indicates that a disconnect request is pending#define ForceCloseFlag		9		// indicates that we want to force the CloseProvider and and re-open									// the endpoint#define OpenPendFlag		10		// indicates that we are awaiting a OpenComplete event#define EOMOnFlag			11		// EOM option enabled#define	TempFileFlag		12		// indicates that a temp file has been opened for data to this endpoint#define InPSQueryFlag		13		// indicates that the endpoint is currently processing a PS query#define HasDataFlag			14		// indicates that there is more to read for this endpoint#define FirstPktFlag		15		// indicates that we are looking for the first packet to set time in value#define DumpPktsFlag		16		// indicates that for this endpoint we will dump all packets// flags macros for setting, testing and clearing the flag bits#define SetEPActiveFlag(flags)		((flags) |= 1 << EPActiveFlag)#define ClrEPActiveFlag(flags)		((flags) &= (-1 ^ (1 << EPActiveFlag)))#define TstEPActiveFlag(flags)		(((flags) & (1 << EPActiveFlag)) != 0)#define SetEPBoundFlag(flags)		((flags) |= 1 << EPBoundFlag)#define ClrEPBoundFlag(flags)		((flags) &= (-1 ^ (1 << EPBoundFlag)))#define TstEPBoundFlag(flags)		(((flags) & (1 << EPBoundFlag)) != 0)#define SetEPBusyFlag(flags)		((flags) |= 1 << EPBusyFlag)#define ClrEPBusyFlag(flags)		((flags) &= (-1 ^ (1 << EPBusyFlag)))#define TstEPBusyFlag(flags)		(((flags) & (1 << EPBusyFlag)) != 0)#define SetPassconFlag(flags)		((flags) |= 1 << PassconFlag)#define ClrPassconFlag(flags)		((flags) &= (-1 ^ (1 << PassconFlag)))#define TstPassconFlag(flags)		(((flags) & (1 << PassconFlag)) != 0)#define SetListenPendFlag(flags)	((flags) |= 1 << ListenPendFlag)#define ClrListenPendFlag(flags)	((flags) &= (-1 ^ (1 << ListenPendFlag)))#define TstListenPendFlag(flags)	(((flags) & (1 << ListenPendFlag)) != 0)#define SetAcceptPendFlag(flags)	((flags) |= 1 << AcceptPendFlag)#define ClrAcceptPendFlag(flags)	((flags) &= (-1 ^ (1 << AcceptPendFlag)))#define TstAcceptPendFlag(flags)	(((flags) & (1 << AcceptPendFlag)) != 0)#define SetUnbindPendFlag(flags)	((flags) |= 1 << UnbindPendFlag)#define ClrUnbindPendFlag(flags)	((flags) &= (-1 ^ (1 << UnbindPendFlag)))#define TstUnbindPendFlag(flags)	(((flags) & (1 << UnbindPendFlag)) != 0)#define SetDisconPendFlag(flags)	((flags) |= 1 << DisconPendFlag)#define ClrDisconPendFlag(flags)	((flags) &= (-1 ^ (1 << DisconPendFlag)))#define TstDisconPendFlag(flags)	(((flags) & (1 << DisconPendFlag)) != 0)#define SetForceCloseFlag(flags)	((flags) |= 1 << ForceCloseFlag)#define ClrForceCloseFlag(flags)	((flags) &= (-1 ^ (1 << ForceCloseFlag)))#define TstForceCloseFlag(flags)	(((flags) & (1 << ForceCloseFlag)) != 0)#define SetOpenPendFlag(flags)		((flags) |= 1 << OpenPendFlag)#define ClrOpenPendFlag(flags)		((flags) &= (-1 ^ (1 << OpenPendFlag)))#define TstOpenPendFlag(flags)		(((flags) & (1 << OpenPendFlag)) != 0)#define SetEOMOnFlag(flags)			((flags) |= 1 << EOMOnFlag)#define ClrEOMOnFlag(flags)			((flags) &= (-1 ^ (1 << EOMOnFlag)))#define TstEOMOnFlag(flags)			(((flags) & (1 << EOMOnFlag)) != 0)#define SetTempFileFlag(flags)		((flags) |= 1 << TempFileFlag)#define ClrTempFileFlag(flags)		((flags) &= (-1 ^ (1 << TempFileFlag)))#define TstTempFileFlag(flags)		(((flags) & (1 << TempFileFlag)) != 0)#define SetInPSQueryFlag(flags)		((flags) |= 1 << InPSQueryFlag)#define ClrInPSQueryFlag(flags)		((flags) &= (-1 ^ (1 << InPSQueryFlag)))#define TstInPSQueryFlag(flags)		(((flags) & (1 << InPSQueryFlag)) != 0)#define SetHasDataFlag(flags)		((flags) |= 1 << HasDataFlag)#define ClrHasDataFlag(flags)		((flags) &= (-1 ^ (1 << HasDataFlag)))#define TstHasDataFlag(flags)		(((flags) & (1 << HasDataFlag)) != 0)#define SetFirstPktFlag(flags)		((flags) |= 1 << FirstPktFlag)#define ClrFirstPktFlag(flags)		((flags) &= (-1 ^ (1 << FirstPktFlag)))#define TstFirstPktFlag(flags)		(((flags) & (1 << FirstPktFlag)) != 0)#define SetDumpPktsFlag(flags)		((flags) |= 1 << DumpPktsFlag)#define ClrDumpPktsFlag(flags)		((flags) &= (-1 ^ (1 << DumpPktsFlag)))#define TstDumpPktsFlag(flags)		(((flags) & (1 << DumpPktsFlag)) != 0)enum {	kLookingForEndStr = 1,	kLookingForQueryStr,	kLookingForDefaultResponse,	kLookingForEOFStr};enum {	kSetBusyStr = 1,	kSetIdleStr,	kAcceptOption,	kDeclineOption,	kQuitTest};	/********************************************************************************* Structures********************************************************************************/typedef struct MyEndpointRef MyEndpointRef;typedef struct {		OTLink		fLink;						// first field standard for OTLink list		OTFlags		flags;		MyEndpointRef *theEp;					// save the endpoint ref associated with the endpoint		UInt32		lastPos;					// last scanned position in the buffer		UInt32		numBytes;					// numBytes in this packet		OTTimeStamp	timeStamp;					// timestamp of this packet		UInt8		data[kPAPDataSize];			// data bytes of packet} PacketBuffer;typedef PacketBuffer *PacketPtr;struct MyEndpointRef{	EndpointRef		ep;	UInt32			flags;	OTLIFO			*usedQ;					// ptr to incoming packet queue for this connection	PacketPtr		prevPtr;				// used while processing a postscript											// query where we have to save the previous packet											// in order to complete processing of queries.	OTTimeStamp		timeDataIn;				// timestamp of first incoming packet	OTTimeStamp 	timeDataEnd;			// timestamp of last incoming packet	OTTimeStamp		timerDog;				// timestamp of most recent packet	UInt32			numBytesIn;				// number of bytes received for a connection	UInt16			psState;				// state while processing a postscript query	short			fRefNum;				// file ref num of temp file associated											//	with this endpoint	UInt8			semaphore;	UInt8			dummy;};// Prototypesextern void DoValueBreak(long value, const char* message);#if PRAGMA_IMPORT_SUPPORTED#pragma import off#endif#if PRAGMA_ALIGN_SUPPORTED#pragma options align=reset#endif#ifdef __cplusplus}#endif#endif /* __PAPSERVERSAMPLE__ */