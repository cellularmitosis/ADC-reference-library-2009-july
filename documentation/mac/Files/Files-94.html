<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Searching a Volume (IM: F)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING94></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Files-93.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Files-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Files-390.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Files-95.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Files-2.html"><B>Files</B></A> / <BR><DD><A HREF="Files-72.html"><B>Chapter 2 - File Manager</B></A> / <A HREF="Files-89.html"><B>Using the File Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING94-0></A>
<H2><A NAME=MARKER-9-355></A>Searching a Volume</H2>
 <A NAME=MARKER-2-127></A><A NAME=MARKER-2-125></A><A NAME=MARKER-2-358></A>To search a volume efficiently, you can use the <CODE>PBCatSearch</CODE> function. The <CODE>PBCatSearch</CODE> function looks at all entries in the volume's catalog file and returns a list of all files or directories that match the criteria you specify. You can ask <CODE>PBCatSearch</CODE> to match files or directories using many types of criteria, including<P>
<UL>
<LI>names or partial names
<LI>file and directory attributes
<LI>Finder information
<LI>physical and logical file length
<LI>creation, modification, and backup dates
<LI>parent directory ID<P>
</UL>
 Like all low-level File Manager functions, <CODE>PBCatSearch</CODE> exchanges information with your application through a parameter block. The <CODE>PBCatSearch</CODE> function uses the <CODE>csParam</CODE> variant of the basic parameter block defined by the <CODE>HParamBlockRec</CODE> data type. That variant includes two fields, <CODE>ioSearchInfo1</CODE> and <CODE>ioSearchInfo2</CODE>, that contain the addresses of two catalog information records (of type <CODE>CInfoPBRec</CODE>). You specify which kinds of files or directories you want to search for by filling in the fields of those two records.<A NAME=MARKER-9-212></A><P>
 The fields in <CODE>ioSearchInfo1</CODE> and <CODE>ioSearchInfo2</CODE> have different uses:<P>
<UL>
<LI>The <CODE>ioNamePtr</CODE> field in <CODE>ioSearchInfo1</CODE> holds a pointer to the target string; the <CODE>ioNamePtr</CODE> field in <CODE>ioSearchInfo2</CODE> must be <CODE>NIL</CODE>. (If you're not searching for the name, the <CODE>ioNamePtr</CODE> field in <CODE>ioSearchInfo1</CODE> must also be <CODE>NIL</CODE>.)<A NAME=MARKER-2-361></A><A NAME=MARKER-2-126></A>
<LI>The date and length fields in <CODE>ioSearchInfo1</CODE> hold the lowest values in the target range, and the date and length fields in <CODE>ioSearchInfo2</CODE> hold the highest values in the target range. The <CODE>PBCatSearch</CODE> function looks for values greater than or equal to the field values in <CODE>ioSearchInfo1</CODE> and less than or equal to the values in <CODE>ioSearchInfo2</CODE>.
<LI>The <CODE>ioFlAttrib</CODE> and <CODE>ioFlFndrInfo</CODE> fields in <CODE>ioSearchInfo1</CODE> hold the target values, and the same fields in <CODE>ioSearchInfo2</CODE> hold masks that specify which bits are relevant.<A NAME=MARKER-2-363></A><A NAME=MARKER-2-364></A><P>
</UL>
 Some fields in the catalog information records apply only to files, some only to directories, and some to both. Some of the fields that apply to both have different names, depending on whether the target of the record is a file or a directory. The <CODE>PBCatSearch</CODE> function uses only some fields in the catalog information record. <A HREF=#MARKER-9-189>Table 2-11</A> lists the fields used for files.<A NAME=MARKER-2-184></A> <P>
 <A HREF=#MARKER-9-367>Table 2-12</A> lists the fields in catalog information records used for directories.<A NAME=MARKER-2-366></A> <P>
<TABLE BORDER="0" CELLPADDING=3>
<B> Table 2-11  <A NAME=MARKER-9-189></A>Fields in <CODE>ioSearchInfo1</CODE> and <CODE>ioSearchInfo2</CODE> used for a file
<TH>Field<TH>Meaning in <CODE>ioSearchInfo1</CODE><TH>Meaning in <CODE>ioSearchInfo2</CODE><TR>
<TD>ioNamePtr<TD>Pointer to filename<TD>Reserved (must be <CODE>NIL</CODE>)<TR>
<TD>ioFlAttrib<TD>Desired file attributes<TD>Mask for file attributes<TR>
<TD>ioFlFndrInfo<TD>Desired Finder information<TD>Mask for Finder information<TR>
<TD>ioFlLgLen<TD>Smallest logical size of data fork<TD>Largest logical size<TR>
<TD>ioFlPyLen<TD>Smallest physical size of data fork<TD>Largest physical size<TR>
<TD>ioFlRLgLen<TD>Smallest logical size of resource fork<TD>Largest logical size<TR>
<TD>ioFlRPyLen<TD>Smallest physical size of resource fork<TD>Largest physical size<TR>
<TD>ioFlCrDat<TD>Earliest file creation date<TD>Latest file creation date<TR>
<TD>ioFlMdDat<TD>Earliest file modification date<TD>Latest file modification date<TR>
<TD>ioFlBkDat<TD>Earliest file backup date<TD>Latest file backup date<TR>
<TD>ioFlXFndrInfo<TD>Desired extended Finder information<TD>Mask for Finder information<TR>
<TD>ioFlParID<TD>Smallest directory ID of file's parent<TD>Largest parent directory ID</TABLE>
<P>
<B>Table 2-12  <A NAME=MARKER-9-367></A>Fields in <CODE>ioSearchInfo1</CODE> and <CODE>ioSearchInfo2</CODE> used for a directory<DFN>
<TABLE BORDER="0" CELLPADDING=3><TH>Field<TH>Meaning in <CODE>ioSearchInfo1</CODE><TH>Meaning in <CODE>ioSearchInfo2</CODE><TR>
<TD>ioNamePtr<TD>Pointer to directory name<TD>Reserved (must be <CODE>NIL</CODE>)<TR>
<TD>ioFlAttrib<TD>Desired directory attributes<TD>Mask for directory attributes<TR>
<TD>ioDrUsrWds<TD>Desired Finder information<TD>Mask for Finder information<TR>
<TD>ioDrNmFls<TD>Smallest number of files in directory<TD>Largest number of files<TR>
<TD>ioDrCrDat<TD>Earliest directory creation date<TD>Latest creation date<TR>
<TD>ioDrMdDat<TD>Earliest directory modification date<TD>Latest modification date<TR>
<TD>ioDrBkDat<TD>Earliest directory backup date<TD>Latest backup date<TR>
<TD>ioDrFndrInfo<TD>Desired extended Finder information<TD>Mask for Finder information<TR>
<TD>ioDrParID<TD>Smallest directory ID of directory's parent<TD>Largest parent directory ID<A NAME=MARKER-2-17></A></TABLE>
</DFN></B><P>
 The <CODE>PBCatSearch</CODE> function searches only on bits 0 and 4 in the file attributes <BR>field (<CODE>ioFlAttrib</CODE>).<A NAME=MARKER-2-195></A> 
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Bit<TH>Meaning<TR>
<TD>0<TD>Set if the file or directory is locked.<TR>
<TD>4<TD>Set if the item is a directory.</TABLE>
<P>
<DL>
<DT><B>Note</B></B>
<DD>The <CODE>PBCatSearch</CODE> function cannot use the additional bits returned in the <CODE>ioFlAttrib</CODE> field by the <CODE>PBGetCatInfo</CODE> function.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 To give <CODE>PBCatSearch</CODE> a full description of the search criteria, you pass it a pair of catalog information records that determine the limits of the search and a mask that identifies the relevant fields within the records. You pass the mask in the <CODE>ioSearchBits</CODE> field in the <CODE>PBCatSearch</CODE> parameter block. To determine the value of <CODE>ioSearchBits</CODE>, add the appropriate constants. To match all files and directories on a volume (including the volume's root directory), set <CODE>ioSearchBits</CODE> to 0.<A NAME=MARKER-2-369></A><P>
<PRE>
CONST
   fsSBPartialName   =  1;    {substring of name}
   fsSBFullName      =  2;    {full name}
   fsSBFlAttrib      =  4;    {directory flag; software lock flag}
   fsSBNegate        =  16384;{reverse match status}
   {for files only}
   fsSBFlFndrInfo    =  8;    {Finder file info}
   fsSBFlLgLen       =  32;   {logical length of data fork}
   fsSBFlPyLen       =  64;   {physical length of data fork}
   fsSBFlRLgLen      =  128;  {logical length of resource fork}
   fsSBFlRPyLen      =  256;  {physical length of resource fork}
   fsSBFlCrDat       =  512;  {file creation date}
   fsSBFlMdDat       =  1024; {file modification date}
   fsSBFlBkDat       =  2048; {file backup date}
   fsSBFlXFndrInfo   =  4096; {more Finder file info}
   fsSBFlParID       =  8192; {file's parent ID}
   {for directories only}
   fsSBDrUsrWds      =  8;    {Finder directory info}
   fsSBDrNmFls       =  16;   {number of files in directory}
   fsSBDrCrDat       =  512;  {directory creation date}
   fsSBDrMdDat       =  1024; {directory modification date}
   fsSBDrBkDat       =  2048; {directory backup date}
   fsSBDrFndrInfo    =  4096; {more Finder directory info}
   fsSBDrParID       =  8192; {directory's parent ID}
</PRE>
 For example, to search for a file that was created between two specified dates and whose name contains a specified string, set <CODE>ioSearchBits</CODE> to 517 (that is, to fsSBFlAttrib<CODE> + fsSBFlCrDat</CODE> + <CODE>fsSBPartialName</CODE>).<P>
 A catalog entry must meet all of the specified criteria to be placed in the list of matches. After <CODE>PBCatSearch</CODE> has completed its scan of each entry, it checks the <CODE>fsSBNegate</CODE> bit. If that bit is set, <CODE>PBCatSearch</CODE> reverses the entry's match status (that is, if the entry is a match but the <CODE>fsSBNegate</CODE> bit is set, the entry is not put in the list of matches; if it is not a match, it is put in the list).<A NAME=MARKER-2-164></A><P>
<DL>
<DT><B>Note</B>
<DD>The <CODE>fsSBNegate</CODE> bit is ignored during searches of remote volumes that support AFP version 2.1.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 Although using <CODE>PBCatSearch</CODE> is significantly more efficient than searching the directories recursively, searching a large volume can still take long enough to affect user response time. You can break a search into several shorter searches by specifying a maximum length of time in the <CODE>ioSearchTime</CODE> field of the parameter block and keeping an index in the <CODE>ioCatPosition</CODE> field. The <CODE>PBCatSearch</CODE> function stores its directory-location index in a catalog position record, which is defined by the <CODE>CatPositionRec</CODE> data type.<P>
<PRE>
TYPE CatPositionRec =                  {catalog position record}
RECORD
   initialize: LongInt;                {starting point}
   priv:       ARRAY[1..6] OF Integer; {private data}
END;
</PRE>
 To start a search at the beginning of the catalog, set the <CODE>initialize</CODE> field to 0. When <CODE>PBCatSearch</CODE> exits because of a timeout, it updates the record so that it describes the next entry to be searched. When you call <CODE>PBCatSearch</CODE> to resume the search after a timeout, pass the entire record that was returned by the last call. <CODE>PBCatSearch</CODE> returns a list of the names and parent directories of all files and directories that match the criteria you specify. It places the list in an array pointed to by the <CODE>ioMatchPtr</CODE> field.<P>
<DL>
<DT><B>Note</B>
<DD>The <CODE>ioSearchTime</CODE> field is not used by AFP volumes. To break up a potentially lengthy search into smaller searches on AFP volumes, use <BR>the <CODE>ioReqMatchCount</CODE> field to specify the maximum number of matches to return. <EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 <A HREF=#MARKER-9-371>Listing 2-3</A> illustrates how to use <CODE>PBCatSearch</CODE> to find all files (not directories) whose names contain the string "Temp" and that were created within the past two days.<P>
<B>Listing 2-3  <A NAME=MARKER-9-371></A>Searching a volume with <CODE>PBCatSearch</CODE></B><P>
<PRE>
CONST
   kMaxMatches       =  30;      {find up to 30 matches in one pass}
   kOptBufferSize    =  $4000;   {use a 16K search cache for speed}
VAR
   myErr:      OSErr;            {result code of function calls}
   myCount:    Integer;          {loop control variable}
   myFName:    Str255;           {name of string to look for}
   myVRefNum:  Integer;          {volume to search}
   myDirID:    LongInt;          {ignored directory ID for HGetVol}
   myCurrDate: LongInt;          {current date, in seconds}
   twoDaysAgo: LongInt;          {date two days ago, in seconds}
   myPB:       HParamBlockRec;   {parameter block for PBCatSearch}
   myMatches:  PACKED ARRAY[1..kMaxMatches] OF FSSpec;
                                 {put matches here}
   mySpec1:    CInfoPBRec;       {search criteria, part 1}
   mySpec2:    CInfoPBRec;       {search criteria, part 2}
   myBuffer:   PACKED ARRAY[1..kOptBufferSize] OF Char;
                                 {search cache}
   done:       Boolean;          {have all matches been found?}
PROCEDURE SetupForFirstTime;
BEGIN
   myErr := HGetVol(NIL, myVRefNum, myDirID);
                                          {search on the default volume}
   myFName := 'Temp';                     {search for &quot;Temp&quot;}
   GetDateTime(myCurrDate);               {get current time in seconds}
   twoDaysAgo := myCurrDate - (2 * 24 * 60 * 60);
   WITH myPB DO
   BEGIN
      ioCompletion   := NIL;              {no completion routine}
      ioNamePtr      := NIL;              {no volume name; use vRefNum}
      ioVRefNum      := myVRefNum;        {volume to search}
      ioMatchPtr     := FSSpecArrayPtr(@myMatches);
                                          {points to results buffer}
      ioReqMatchCount:= kMaxMatches;      {number of matches}
      ioSearchBits   := fsSBPartialName   {search on partial name}
                        + fsSBFlAttrib    {search on file attributes}
                        + fsSBFlCrDat;    {search on creation date}
      ioSearchInfo1  := @mySpec1;         {points to first criteria set}
      ioSearchInfo2  := @mySpec2;         {points to second criteria set}
      ioSearchTime   := 0;                {no timeout on searches}
      ioCatPosition.initialize := 0;      {set hint to 0}
      ioOptBuffer := @myBuffer;           {point to search cache}
      ioOptBufSize := kOptBufferSize;     {size of search cache}
   END;
   WITH mySpec1 DO
   BEGIN
      ioNamePtr := @myFName;              {point to string to find}
      ioFlAttrib := $00;                  {clear bit 4 to ask for files}
      ioFlCrDat := twoDaysAgo;            {lower bound of creation date}
   END;
   WITH mySpec2 DO
   BEGIN
      ioNamePtr := NIL;                   {set to NIL}
      ioFlAttrib := $10;                  {set mask for bit 4}
      ioFlCrDat := myCurrDate;            {upper bound of creation date}
   END;
END;
BEGIN
   SetupForFirstTime;                     {initialize data records}
   REPEAT
      myErr := PBCatSearchSync(@myPB);    {get some files}
      done := (myErr = eofErr);           {eofErr returned when all done}
      IF ((myErr = noErr) | done) &amp; (myPB.ioActMatchCount &gt; 0) THEN
         FOR myCount := 1 TO myPB.ioActMatchCount DO
            Writeln(myMatches[myCount].name);
                                          {report all matches found}
   UNTIL done;
END;
</PRE>
 <A NAME=MARKER-2-372></A>When <CODE>PBCatSearch</CODE> is not available in the current operating environment or is not supported by the volume you wish to search, you'll need to use <CODE>PBGetCatInfo</CODE> to perform a recursive, indexed search through the volume's directory hierarchy. This <BR>kind of search is usually much slower than a search with <CODE>PBCatSearch</CODE>, and you <BR>can encounter problems you avoid by using <CODE>PBCatSearch</CODE>. For example, a <BR>recursive, indexed search can require a large amount of stack space. The procedure <CODE>EnumerateShell</CODE> defined in <A HREF=#MARKER-9-373>Listing 2-4</A> is designed to minimize the amount of stack space used. As a result, it should execute even in environments with very limited <BR>stack space.<P>
<B>Listing 2-4  <A NAME=MARKER-9-373></A>Searching a volume using a recursive, indexed search</B><P>
<PRE>
PROCEDURE EnumerateShell (vRefNum: Integer; dirID: LongInt);
VAR
   myName:        Str63;
   myCPB:         CInfoPBRec;
   myErr:         OSErr;
   PROCEDURE EnumerateCatalog (dirID: LongInt);
   CONST
         kFolderBit = 4;
   VAR
         index:   Integer;
   BEGIN
      index := 1;
      REPEAT
         WITH myCBP DO
         BEGIN
            ioFDirIndex := index;
            ioDrDirID := dirID;     {reset dirID; PBGetCatInfo may change it}
            ioACUser := 0;
         END;
         myErr := PBGetCatInfo(@myCPB, FALSE);
         IF myErr = noErr THEN
            IF BTst(myCPB.ioFlAttrib, kFolderBit) THEN
               BEGIN {we have a directory}
                  {Do something useful with the dir. information in myCPB.}
                  EnumerateCatalog(myCPB.ioDrDirID);
                  myErr := noErr;      {clear error return on way back}
               END
            ELSE
               BEGIN {we have a file}
                  {Do something useful with the file information in myCPB.}
               END;
         index := index + 1;
      UNTIL (myErr &lt;&gt; noErr);
   END; {EnumerateCatalog}
BEGIN {EnumerateShell}
   WITH myCPB DO
      BEGIN
         ioNamePtr := @myName;
         ioVRefNum := vRefNum;
      END;
   EnumerateCatalog(dirID);
END; {EnumerateShell}
</PRE>
 The <CODE>EnumerateShell</CODE> procedure sets up a catalog information parameter block with a pointer to a string variable and the volume reference number passed to it. It then calls the <CODE>EnumerateDir</CODE> procedure, which uses indexed calls to <CODE>PBGetCatInfo</CODE> to read the catalog information about all items in the specified directory. If an item is a directory (as indicated by the <CODE>kFolderBit</CODE> bit of the <CODE>ioFlAttrib</CODE> field of the parameter block), <CODE>EnumerateDir</CODE> calls itself recursively to enumerate the contents of that directory. If an item is a file, <CODE>EnumerateDir</CODE> performs whatever processing is appropriate.<P>
 Note that <CODE>EnumerateDir</CODE> resets the <CODE>ioDrDirID</CODE> field before calling <CODE>PBGetCatInfo</CODE>. This is necessary because <CODE>PBGetCatInfo</CODE> returns a file ID number in that field if the item is a file. The <CODE>EnumerateDir</CODE> procedure also clears the <CODE>ioACUser</CODE> field. You need to do this if your search depends on the value in that field after the call to <CODE>PBGetCatInfo</CODE>, because the value returned in that field for local volumes is meaningless.<P>
 To search an entire volume, call the <CODE>EnumerateShell</CODE> procedure with the <CODE>vRefNum</CODE> parameter set to the volume reference number of the volume you want to search and the <CODE>dirID</CODE> parameter set to <CODE>fsRtDirID</CODE>. You can also do a partial search of a volume by specifying a different directory ID in the <CODE>dirID</CODE> parameter.<A NAME=MARKER-2-374></A><A NAME=MARKER-2-375></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Files-93.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Files-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Files-390.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Files-95.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Files-3.html">&copy; Apple Computer, Inc.</A><br>2 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
