<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Accessing Hardware From Applications: The IOKitLib API</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="The IOKitLib API"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30000380" title="The IOKitLib API"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../HardwareDrivers/index.html#//apple_ref/doc/uid/TP30000440-TP40003576" target="_top">Hardware &amp; Drivers</a> &gt; <a href="../AH_Intro/AH_Intro.html#//apple_ref/doc/uid/TP40002714-BAJDAJDJ">Accessing Hardware From Applications</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../AH_Finding_Devices/AH_Finding_Devices.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../AH_Handling_Errors/AH_Handling_Errors.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30000380-BAJDAJDJ" title="The IOKitLib API"></a><h1>The IOKitLib API</h1><p>When you access a device from user space, whether you use a device interface or the POSIX API, you use a combination of I/O Kit functions and specific device-family functions to work with the I/O Kit objects that represent the device. The IOKitLib, located in the I/O Kit framework, contains the generic I/O Kit functions you use to implement user-space task access to in-kernel device objects.</p><p>This chapter surveys the IOKitLib functions, describing how to use them to get access to and manipulate in-kernel objects and providing insight into how the IOKitLib implements these functions.</p><p>Some of the functions in the IOKitLib are intended for developers of custom device interfaces rather than for developers of applications that use existing device interfaces. Although this chapter covers these functions at a high level, you should read <span class="content_text"><a href="../../WritingDeviceDriver/MakingHWAccessible/MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698" target="_top"> “Making Hardware Accessible to Applications”</a></span> in <em><a href="../../WritingDeviceDriver/index.html#//apple_ref/doc/uid/TP30000694" target="_top">I/O Kit Device Driver Design Guidelines</a></em> if you need to develop your own device interface–user client solution.</p><p>The IOKitLib functions can be divided into several categories, based on the type of service they provide. This chapter mirrors these groupings and is divided into the following sections, each of which covers a functional category:</p><ul class="ul"><li class="li"><p><span class="content_text"><a href="AH_IOKitLib_API.html#//apple_ref/doc/uid/TP30000380-BABCCDHF">“Object Reference-Counting and Introspection”</a></span> introduces the types of objects you use to communicate with in-kernel entities and describes how to get information about them and keep track of their reference counts.</p></li><li class="li"><p><span class="content_text"><a href="AH_IOKitLib_API.html#//apple_ref/doc/uid/TP30000380-BABJIBIA">“Device Discovery and Notification”</a></span> describes the functions you use to create matching dictionaries, look up and access matching devices in the I/O Registry, and receive notifications about a device’s state change.</p></li><li class="li"><p><span class="content_text"><a href="AH_IOKitLib_API.html#//apple_ref/doc/uid/TP30000380-BABGFHJE">“I/O Registry Access”</a></span> describes other IOKitLib functions you can use to get access to objects in the I/O Registry.</p></li><li class="li"><p><span class="content_text"><a href="AH_IOKitLib_API.html#//apple_ref/doc/uid/TP30000380-BABEFFID">“Device-Interface Development”</a></span> gives a brief overview of the IOKitLib functions you use when no I/O Kit device-family or third-party device interface exists and you need to develop your own device interface.</p></li></ul><a name="//apple_ref/doc/uid/TP30000380-BABCCDHF" title="Object Reference-Counting and Introspection"></a><h2>Object Reference-Counting and Introspection</h2><p><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_241"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_242"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_243"></a>Functions in the IOKitLib communicate with in-kernel objects using the Mach port transport mechanism to cross the user-kernel boundary. The file <code>IOTypes.h</code>, located in the I/O Kit framework, defines the objects you use with IOKitLib functions to communicate with such in-kernel entities as I/O Registry entries (objects of class IORegistryEntry) or iterators (objects of class IOIterator). Notice in <span class="content_text"><a href="AH_IOKitLib_API.html#//apple_ref/doc/uid/TP30000380-BABIFCAE">Listing 4-1</a></span>, however, that <code>IOTypes.h</code> seems to define all these objects in the same way, specifically, as <code>mach_port_t</code> objects (<code>mach_port_t</code> is defined in <code>mach/port.h</code> in the Kernel framework).</p><a name="//apple_ref/doc/uid/TP30000380-BABIFCAE" title="Listing 4-1Object definitions in IOTypes.h"></a><p class="codesample"><strong>Listing 4-1&nbsp;&nbsp;</strong>Object definitions in IOTypes.h</p><div class="codesample"><table><tr><td scope="row"><pre>typedef mach_port_t io_object_t;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>typedef io_object_t io_connect_t;<span></span></pre></td></tr><tr><td scope="row"><pre>typedef io_object_t io_iterator_t;<span></span></pre></td></tr><tr><td scope="row"><pre>typedef io_object_t io_registry_entry_t;<span></span></pre></td></tr><tr><td scope="row"><pre>typedef io_object_t io_service_t;<span></span></pre></td></tr><tr><td scope="row"><pre>typedef io_object_t io_enumerator_t;<span></span></pre></td></tr></table></div><p>To understand why this is so, recall that a Mach port is the communication transport mechanism an application uses to communicate with the I/O Kit. As far as the kernel is concerned, every time your application communicates with any in-kernel object using one of the object types defined in <code>IOTypes.h</code>, it’s using the same generic mechanism (namely, a Mach port) to cross the user-kernel boundary. </p><p>From the application’s point of view, however, the transport mechanism is unimportant and what matters is the type of object on the other side of the port. The fact that an <code>io_iterator_t</code> object<a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_244"></a>, for example, encapsulates the association of a Mach port with an in-kernel IOIterator object is not as important to the application as the fact that an <code>io_iterator_t</code> object refers to an in-kernel object that knows how to iterate over the I/O Registry.</p><p>The <code>io_object_t</code> objects in user space not only refer to the in-kernel objects, they also reflect the in-kernel C++ class hierarchy. Because IOService is a subclass of IORegistryEntry, for example, you can use an <code>io_service_t</code> object<a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_245"></a> with any IOKitLib function that expects an <code>io_registry_entry_t</code> object<a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_246"></a>, such as <code><!--a-->IORegistryEntryGetPath<!--/a--></code>.</p><p>With few exceptions (such as getting the I/O Kit master port to initiate communication with the I/O Kit and reference-counting of the <code>io_object_t</code> objects themselves) you should not concern yourself with the cross-boundary communication mechanism. Rather, you should focus on the specific in-kernel object you are working with, making sure you use each object type appropriately.<a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_247"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_248"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_249"></a></p><a name="//apple_ref/doc/uid/TP30000380-TPXREF108" title="Reference Counting "></a><h3>Reference Counting </h3><p><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_250"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_251"></a>The IOKitLib contains three reference-counting functions:</p><ul class="spaceabove"><li class="li"><p><code><!--a-->IOObjectGetRetainCount<!--/a--></code></p></li><li class="li"><p><code><!--a-->IOObjectRetain<!--/a--></code></p></li><li class="li"><p><code><!--a-->IOObjectRelease<!--/a--></code></p></li></ul><p>Each of these functions operates on the retain count of the underlying kernel object (the object on the other side of the Mach port) and not on the <code>io_object_t</code> object itself. In other words, if you want to retain, release, or get the retain count of the in-kernel IORegistryEntry object an <code>io_registry_entry_t</code> object represents, you use one of the IOKitLib reference-counting functions<a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_252"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_253"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_254"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_255"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_256"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_257"></a>. For example, <span class="content_text"><a href="AH_IOKitLib_API.html#//apple_ref/doc/uid/TP30000380-BABIFCHF">Listing 4-2</a></span> shows a code fragment that releases the in-kernel IOIterator object underlying an <code>io_iterator_t</code> object after it’s been used to find a serial port modem.</p><a name="//apple_ref/doc/uid/TP30000380-BABIFCHF" title="Listing 4-2Releasing the underlying kernel object of an io_iterator_t object"></a><p class="codesample"><strong>Listing 4-2&nbsp;&nbsp;</strong>Releasing the underlying kernel object of an <code>io_iterator_t</code> object</p><div class="codesample"><table><tr><td scope="row"><pre>io_iterator_t serialPortIterator = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>char deviceFilePath[ MAXPATHLEN ];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>kernResult = MyFindSerialPortModems(&amp;serialPortIterator, &amp;masterPort);<span></span></pre></td></tr><tr><td scope="row"><pre>if (kernResult == kIOReturnSuccess) {<span></span></pre></td></tr><tr><td scope="row"><pre>    kernResult = MyGetPathOfFirstModem (serialPortIterator, deviceFilePath,<span></span></pre></td></tr><tr><td scope="row"><pre>            sizeof(deviceFilePath));<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    //Release the iterator since we want only the first modem.<span></span></pre></td></tr><tr><td scope="row"><pre>    IOObjectRelease(serialPortIterator);<span></span></pre></td></tr><tr><td scope="row"><pre>    //If MyGetPathOfFirstModem found a modem, communicate with it.<span></span></pre></td></tr><tr><td scope="row"><pre>...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>As a matter of good programming practice, you should use <code><!--a-->IOObjectRelease<!--/a--></code> to release all <code>io_object_t</code> objects you create in your code when they’re no longer needed.</p><p>If you suspect that you are leaking <code>io_object_t</code> objects<a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_258"></a>, however, <code><!--a-->IOObjectGetRetainCount<!--/a--></code> won’t help you because this function informs you of the underlying kernel object’s retain count (which is often much higher). Instead, because the retain count of an <code>io_object_t</code> object is essentially the retain count of the send rights on the Mach port, you use a Mach function to get this information. <span class="content_text"><a href="AH_IOKitLib_API.html#//apple_ref/doc/uid/TP30000380-BABBHFCD">Listing 4-3</a></span> shows how to use the Mach function<a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_259"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_260"></a><code><!--a-->mach_port_get_refs<!--/a--></code> (defined in <code>mach/mach_port.h</code> in the Kernel framework) to get the retain count of an <code>io_object_t</code> object.<a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_261"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_262"></a></p><a name="//apple_ref/doc/uid/TP30000380-BABBHFCD" title="Listing 4-3Getting the retain count of an io_object_t object"></a><p class="codesample"><strong>Listing 4-3&nbsp;&nbsp;</strong>Getting the retain count of an <code>io_object_t</code> object</p><div class="codesample"><table><tr><td scope="row"><pre>#include &lt;mach/mach_port.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>kern_return_t kr;<span></span></pre></td></tr><tr><td scope="row"><pre>unsigned int count;<span></span></pre></td></tr><tr><td scope="row"><pre>io_object_t theObject;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>kr = mach_port_get_refs ( mach_task_self(), theObject, MACH_PORT_RIGHT_SEND,<span></span></pre></td></tr><tr><td scope="row"><pre>            &amp;count );<span></span></pre></td></tr><tr><td scope="row"><pre>printf ("Retain count for object ID %#X is %d\n", theObject, count);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000380-TPXREF109" title="Introspection "></a><h3>Introspection </h3><p><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_263"></a>The IOKitLib provides three object-introspection functions that operate on the in-kernel object the passed-in <code>io_object_t</code> object represents (not the <code>io_object_t</code> object itself):</p><ul class="spaceabove"><li class="li"><p><code><!--a-->IOObjectConformsTo<!--/a--></code></p></li><li class="li"><p><code><!--a-->IOObjectGetClass<!--/a--></code></p></li><li class="li"><p><code><!--a-->IOObjectIsEqualTo<!--/a--></code></p></li></ul><p>The first function<a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_264"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_265"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_266"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_267"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_268"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_269"></a>, <code><!--a-->IOObjectConformsTo<!--/a--></code>, simply performs the in-kernel object’s <code>metaCast</code> method and returns the Boolean result. The <code><!--a-->IOObjectGetClass<!--/a--></code> function calls the in-kernel object’s <code>getMetaClass</code> method and then calls that class’s <code>getClassName</code> method to return the class name as a C string. IOKitLib implements the <code><!--a-->IOObjectIsEqualTo<!--/a--></code> function as a shallow pointer comparison of the two passed-in objects, returning the result as a Boolean value.<a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_270"></a></p><a name="//apple_ref/doc/uid/TP30000380-BABJIBIA" title="Device Discovery and Notification"></a><h2>Device Discovery and Notification</h2><p>Even if you use few other IOKitLib functions in your device-access application, you will certainly use the device-discovery functions. If you’re working with hot-pluggable devices, such as USB or FireWire devices, you may also use the notification functions.</p><p>The following sections cover the IOKitLib device-discovery and notification functions, describing how the IOKitLib implements:</p><ul class="ul"><li class="li"><p>Matching dictionary–creation</p></li><li class="li"><p>Device look-up</p></li><li class="li"><p>Notification set-up</p></li><li class="li"><p>Device iteration</p></li></ul><a name="//apple_ref/doc/uid/TP30000380-TPXREF110" title="Creating Matching Dictionaries"></a><h3>Creating Matching Dictionaries</h3><p>When you use IOKitLib functions to create a matching dictionary, you receive a reference to a Core Foundation dictionary object. The IOKitLib uses Core Foundation classes, such as CFMutableDictionary and CFString, because they closely corrrespond to the in-kernel collection and container classes, such as OSDictionary and OSString (defined in <code>libkern/c++</code> in the Kernel framework). </p><p><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_271"></a>The I/O Kit automatically translates a CFDictionary object into its in-kernel counterpart when it crosses the user-kernel boundary, allowing you to create an object in user-space that is later used in the kernel. For more information on using Core Foundation objects to represent in-kernel objects, see <span class="content_text"><a href="AH_IOKitLib_API.html#//apple_ref/doc/uid/TP30000380-BABIDJDI">“Viewing Properties of I/O Registry Objects.”</a></span></p><p>The IOKitLib defines the following functions to create matching dictionaries:</p><ul class="spaceabove"><li class="li"><p><code><!--a-->IOServiceMatching<!--/a--></code></p></li><li class="li"><p><code><!--a-->IOServiceNameMatching<!--/a--></code></p></li><li class="li"><p><code><!--a-->IOBSDNameMatching<!--/a--></code></p></li></ul><p>These functions<a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_272"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_273"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_274"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_275"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_276"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_277"></a> create a mutable Core Foundation dictionary object containing the appropriate key and your passed-in value. <span class="content_text"><a href="AH_IOKitLib_API.html#//apple_ref/doc/uid/TP30000380-CDEBCFAE">Table 4-1</a></span> shows the keys each of the dictionary-creation functions use, along with the I/O Kit framework files in which the keys are defined.</p><a name="//apple_ref/doc/uid/TP30000380-CDEBCFAE" title="Table 4-1Dictionary-creation functions and the keys they use"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 4-1&nbsp;&nbsp;</strong>Dictionary-creation functions and the keys they use</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Function name</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Key name</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Key-definition file</p></th></tr><tr><td  scope="row"><p><code><!--a-->IOServiceMatching<!--/a--></code></p></td><td ><p><code><!--a  -->kIOProviderClassKey<!--/a--></code></p></td><td ><p><code>IOKitKeys.h</code></p></td></tr><tr><td  scope="row"><p><code><!--a-->IOServiceNameMatching<!--/a--></code></p></td><td ><p><code><!--a  -->kIONameMatchKey<!--/a--></code></p></td><td ><p><code>IOKitKeys.h</code></p></td></tr><tr><td  scope="row"><p><code><!--a-->IOBSDNameMatching<!--/a--></code></p></td><td ><p><code><!--a  -->kIOBSDNameKey<!--/a--></code></p></td><td ><p><code>IOBSD.h</code></p></td></tr></table></div><p>If, for example, you call <code><!--a-->IOServiceNameMatching<!--/a--></code> with the argument <em>i2c-modem</em>, the resulting dictionary looks like this:</p><div class="codesample"><table><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    IONameMatch = i2c-modem;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>All dictionary-creation functions return a reference to a CFMutableDictionary object. Usually, you pass the dictionary to one of the look-up functions (discussed next in <span class="content_text"><a href="AH_IOKitLib_API.html#//apple_ref/doc/uid/TP30000380-BABDBJCA">“Looking Up Devices”</a></span>), each of which consumes one reference to it. If you use the dictionary in some other way, you should adjust its retain count accordingly, using <code><a href="../../../../CoreFoundation/Reference/CFTypeRef/Reference/reference.html#//apple_ref/doc/c_ref/CFRetain" target="_top">CFRetain</a></code> or <code><a href="../../../../CoreFoundation/Reference/CFTypeRef/Reference/reference.html#//apple_ref/doc/c_ref/CFRelease" target="_top">CFRelease</a></code> (defined in the Core Foundation framework).</p><a name="//apple_ref/doc/uid/TP30000380-BABDBJCA" title="Looking Up Devices"></a><h3>Looking Up Devices</h3><p><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_278"></a>IOKitLib provides three look-up functions that look up registered objects in the I/O Registry that match a passed-in matching dictionary:</p><ul class="spaceabove"><li class="li"><p><code><!--a-->IOServiceGetMatchingServices<!--/a--></code></p></li><li class="li"><p><code><!--a-->IOServiceGetMatchingService<!--/a--></code></p></li><li class="li"><p><code><!--a-->IOServiceAddMatchingNotification<!--/a--></code></p></li></ul><p>IOKitLib implements its most general look-up function<a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_279"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_280"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_281"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_282"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_283"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_284"></a>, <code><!--a-->IOServiceGetMatchingServices<!--/a--></code>, by transforming your matching dictionary into an OSDictionary object and invoking the IOService method <code>getMatchingServices</code>. This method returns an IOIterator object that contains a list of matching IOService objects. <code><!--a-->IOServiceGetMatchingServices<!--/a--></code> then releases the matching dictionary you passed in and returns to you an <code>io_iterator_t</code> object representing the in-kernel IOIterator object.</p><p>The <code><!--a-->IOServiceGetMatchingService<!--/a--></code> function is simply a special case of <code><!--a-->IOServiceGetMatchingServices<!--/a--></code>: It returns the first matching object in the list instead of an iterator that provides access to the entire list.</p><p>If you receive an <code>io_iterator_t</code> object from <code><!--a-->IOServiceGetMatchingServices<!--/a--></code>, you should release it with <code><!--a-->IOObjectRelease<!--/a--></code> when you’re finished with it; similarly, you should use <code><!--a-->IOObjectRelease<!--/a--></code> to release the <code>io_object_t</code> object you receive from <code><!--a-->IOServiceGetMatchingService<!--/a--></code>.</p><p>The <code><!--a-->IOServiceAddMatchingNotification<!--/a--></code> function not only looks up matching objects in the I/O Registry, it also installs a request for notification of matching objects that meet your passed-in criterion. The IOKitLib implements this function by invoking the IOService <code>addNotification</code> method, which creates a persistent notification handler that can be notified of IOService events.</p><p>To use <code><!--a-->IOServiceAddMatchingNotification<!--/a--></code>, however, you must first use some other functions in the IOKitLib to set up the notification mechanism. For more information on these functions, see the next section, <span class="content_text"><a href="AH_IOKitLib_API.html#//apple_ref/doc/uid/TP30000380-BABEEFDJ">“Setting Up and Receiving Notifications.”</a></span> For an outline of the steps your application takes to set up a notification mechanism using a run loop, see <span class="content_text"><a href="../AH_Finding_Devices/AH_Finding_Devices.html#//apple_ref/doc/uid/TP30000379-BABEACCJ">“Getting Notifications of Device Arrival and Departure.”</a></span></p><a name="//apple_ref/doc/uid/TP30000380-BABEEFDJ" title="Setting Up and Receiving Notifications"></a><h3>Setting Up and Receiving Notifications</h3><p>The<a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_285"></a> IOKitLib provides several functions you use to set up and manage notification objects:</p><ul class="spaceabove"><li class="li"><p><code><!--a-->IONotificationPortCreate<!--/a--></code></p></li><li class="li"><p><code><!--a-->IONotificationPortGetRunLoopSource<!--/a--></code></p></li><li class="li"><p><code><!--a-->IONotificationPortGetMachPort<!--/a--></code></p></li><li class="li"><p><code><!--a-->IODispatchCalloutFromMessage<!--/a--></code></p></li><li class="li"><p><code><!--a-->IONotificationPortDestroy<!--/a--></code></p></li></ul><p>Whether you<a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_286"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_287"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_288"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_289"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_290"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_291"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_292"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_293"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_294"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_295"></a> choose to receive notifications on a run loop or a Mach port (using a run loop is the recommended approach), you must first create an object that can listen for I/O Kit notifications. To do this, you use the <code><!--a-->IONotificationPortCreate<!--/a--></code> function, which returns an object of type IONotificationPortRef. IOKitLib implements this function by allocating a receive right on the current Mach port, giving it the name of the IONotificationPort object you pass in.</p><p>To receive notifications on a run loop, you first use the <code><!--a-->IONotificationPortGetRunLoopSource<!--/a--></code> function to get a run-loop source you can install on your application’s current run loop. In Mac OS X, a run loop registers input sources, such as Mach ports, and enables the delivery of events, such as IOService object status changes, through those sources. The run-loop source object you receive from <code><!--a-->IONotificationPortGetRunLoopSource<!--/a--></code> function is of type CFRunLoopSourceRef. (For more information about how to install the run-loop source on your application’s run loop, see <span class="content_text"><a href="../AH_Finding_Devices/AH_Finding_Devices.html#//apple_ref/doc/uid/TP30000379-BABEACCJ">“Getting Notifications of Device Arrival and Departure.”</a></span>)</p><p>The IOKitLib provides two functions that allow you use a Mach port you create on which to listen for notifications, rather than a run loop. Although this method is available to you, it’s recommended that you use the easier-to-implement and more automatic run-loop solution instead. The <code><!--a-->IONotificationPortGetMachPort<!--/a--></code> function returns a Mach port on which the IONotificationPortRef object can listen for notifications. When the notification object receives a message, you pass the message to the <code><!--a-->IODispatchCalloutFromMessage<!--/a--></code> function to generate the callback function associated with the notification.</p><p>The <code><!--a-->IONotificationPortDestroy<!--/a--></code> function cleans up and destroys all rights named by the passed-in port name (the IONotificationPortRef object you received from <code><!--a-->IONotficationPortCreate<!--/a--></code>). You should call this function when you no longer want to receive notifications.</p><a name="//apple_ref/doc/uid/TP30000380-TPXREF111" title="Iterating Over Matching Devices"></a><h3>Iterating Over Matching Devices</h3><p>To<a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_296"></a> access the matching objects a look-up function returns, you use the <code><!--a-->IOIteratorNext<!--/a--></code> function. IOKitLib contains three functions that operate on <code>io_iterator_t</code> objects:</p><ul class="spaceabove"><li class="li"><p><code><!--a-->IOIteratorNext<!--/a--></code></p></li><li class="li"><p><code><!--a-->IOIteratorIsValid<!--/a--></code></p></li><li class="li"><p><code><!--a-->IOIteratorReset<!--/a--></code></p></li></ul><p>As a<a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_297"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_298"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_299"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_300"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_301"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_302"></a> subclass of OSIterator, the in-kernel IOIterator object defines the methods <code>getNextObject</code>, <code>isValid</code>, and <code>reset</code>. IOKitLib invokes these methods in its implementation of <code><!--a-->IOIteratorNext<!--/a--></code>, <code><!--a-->IOIteratorIsValid<!--/a--></code>, and <code><!--a-->IOIteratorReset<!--/a--></code>, respectively. </p><p><code><!--a-->IOIteratorNext<!--/a--></code> simply returns a reference to the current object in the list (an <code>io_object_t</code> object) and advances the iterator to the next object.</p><p><code><!--a-->IOIteratorIsValid<!--/a--></code> returns a Boolean value indicating whether the iterator is still valid. Sometimes, if the I/O Registry changes while you’re using an iterator, the iterator becomes invalid. When this is the case, <code><!--a-->IOIteratorIsValid<!--/a--></code> returns zero and you can reset the invalid iterator to the beginning of the list, using <code><!--a-->IOIteratorReset<!--/a--></code>. Of course, you can use <code><!--a-->IOIteratorReset<!--/a--></code> to start over at the beginning of the list for any reason, not only because the iterator is invalid.</p><a name="//apple_ref/doc/uid/TP30000380-BABGFHJE" title="I/O Registry Access"></a><h2>I/O Registry Access</h2><p>The IOKitLib provides a range of functions that find and provide information about objects in the I/O Registry. Unlike the device-discovery functions, which focus on finding and accessing registered device objects that match your matching dictionary, the I/O Registry–access functions allow you to view objects more broadly as entries in the I/O Registry, providing ways to freely navigate the I/O Registry and get information about any object in it. If you’re unfamiliar with the structure of the I/O Registry, you can read more about it in <span class="content_text"><a href="../../IOKitFundamentals/TheRegistry/TheRegistry.html#//apple_ref/doc/uid/TP0000014" target="_top">“The I/O Registry”</a></span> in <em><a href="../../IOKitFundamentals/index.html#//apple_ref/doc/uid/TP0000011" target="_top">I/O Kit Fundamentals</a></em>. The following paragraphs provide a summary.</p><p>The I/O Registry is a dynamic database that captures the connections of all driver and nub objects currently active in a running Mac OS X system. You can think of the I/O Registry as a tree-like structure rooted in the Platform Expert, the driver of the main logic board that knows the type of platform your Mac OS X system is running on. </p><p>The I/O Registry uses the concept of a plane<a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_303"></a> to describe the different provider-client relationships between objects. The Service plane displays the instantiation hierarchy of the I/O Registry: Every object in the I/O Registry is a client of the services provided by its parent, so every object’s connection to its ancestor in the I/O Registry tree is visible on the Service plane. Other planes express the provider-client relationships between objects that participate in a specific hierarchy, such as the flow of power from power provider to power client.</p><p>Many of the I/O Registry–access functions require you to pass in an argument designating a specific plane. In most cases, you will probably specify the all-inclusive Service plane, but there may be times when you want to narrow the focus a bit. The file <code>IOKitKeys.h</code> (in the I/O Kit framework) contains the plane name definitions you use in your code.</p><p>The IOKitLib provides I/O Registry–access functions that:</p><ul class="ul"><li class="li"><p>Traverse the I/O Registry in some way</p></li><li class="li"><p>Provide information about a particular object in the I/O Registry</p></li><li class="li"><p>Allow you to view an I/O Registry object’s properties</p></li><li class="li"><p>Allow you to set properties in an I/O Registy object’s property table</p></li></ul><p>IOKitLib implements most of these functions by invoking similarly named IORegistryEntry methods (see <code>IORegistryEntry.h</code> in the <code>IOKit</code> directory of the Kernel framework for more). The following sections describe how you use the I/O Registry functions.</p><a name="//apple_ref/doc/uid/TP30000380-TPXREF112" title="Traversing the I/O Registry"></a><h3>Traversing the I/O Registry</h3><p><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_304"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_305"></a>When you use the <code><!--a-->IOServiceGetMatchingServices<!--/a--></code> look-up function, you get an iterator you can use to access each object in a list of matching I/O Registry objects. But what if you want to search the I/O Registry using some criteria other than a matching dictionary? Say, for example, you want to find all the children (clients) of a particular object, regardless of whether they are currently registered in the I/O Registry. The following functions give you access to the parents and children of an <code>io_registry_entry_t</code> object:</p><ul class="spaceabove"><li class="li"><p><code><!--a-->IORegistryEntryGetChildEntry<!--/a--></code></p></li><li class="li"><p><code><!--a-->IORegistryEntryGetChildIterator<!--/a--></code></p></li><li class="li"><p><code><!--a-->IORegistryEntryGetParentEntry<!--/a--></code></p></li><li class="li"><p><code><!--a-->IORegistryEntryGetParentIterator<!--/a--></code></p></li></ul><p>Not surprisingly, the functions with the word “iterator” in their names supply you with an <code>io_iterator_t</code> object you can pass to <code><!--a-->IOIteratorNext<!--/a--></code> to access each <code>io_registry_entry_t</code> object in the list. <code><!--a-->IORegistryEntryGetParentIterator<!--/a--></code>, for example, looks in the specified plane to find all ancestors of the passed-in object and returns an iterator you can use to access them. As you do with the <code><!--a-->IOServiceGetMatchingService<!--/a--></code> and <code><!--a-->IOServiceAddMatchingNotification<!--/a--></code> functions, be sure to release the returned <code>io_iterator_t</code> object when you’re finished with it (recall that releasing the iterator you receive from <code><!--a-->IOServiceAddMatchingNotification<!--/a--></code> also disables that notification). The other two functions, <code><!--a-->IORegistryEntryGetChildEntry<!--/a--></code> and <code><!--a-->IORegistryEntryGetParentEntry<!--/a--></code>, return the first child or ancestor of the passed-in object in the specified plane.</p><p>For even broader searches, you can use the following functions to search the entire I/O Registry, from any point and to any depth:</p><ul class="spaceabove"><li class="li"><p><code><!--a-->IORegistryCreateIterator<!--/a--></code></p></li><li class="li"><p><code><!--a-->IORegistryEntryCreateIterator<!--/a--></code></p></li><li class="li"><p><code><!--a-->IORegistryIteratorEnterEntry<!--/a--></code></p></li><li class="li"><p><code><!--a-->IORegistryIteratorExitEntry<!--/a--></code></p></li><li class="li"><p><code><!--a-->IORegistryGetRootEntry<!--/a--></code></p></li></ul><p>The <code><!--a-->IORegistryCreateIterator<!--/a--></code> function returns an <code>io_iterator_t</code> object that begins at the root of the I/O Registry and iterates over all its children in the specified plane. Similarly, <code><!--a-->IORegistryEntryCreateIterator<!--/a--></code> returns an <code>io_iterator_t</code> object that begins at the passed-in <code>io_registry_entry_t</code> object and iterates over either all its ancestors or all its children in the passed-in plane. </p><p>Both these functions allow you to specify an option that tells the iterator to automatically recurse into objects as they are returned, or only when you call <code><!--a-->IORegistryIteratorEnterEntry<!--/a--></code> to recurse into the current object. The <code><!--a-->IORegistryIteratorExitEntry<!--/a--></code> function undoes the effect of <code><!--a-->IORegistryIteratorEnterEntry<!--/a--></code> by resetting the iterator to the current object, allowing the iterator to continue from where it left off. As its name implies, <code><!--a-->IORegistryGetRootEntry<!--/a--></code> returns an <code>io_registry_entry_t</code> object representing the root of the I/O Registry.<a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_306"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_307"></a></p><a name="//apple_ref/doc/uid/TP30000380-TPXREF113" title="Getting Information About I/O Registry Objects"></a><h3>Getting Information About I/O Registry Objects</h3><p><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_308"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_309"></a>The IOKitLib provides a handful of functions, listed below, that return information about a particular I/O Registry object, such as its name or path.</p><ul class="spaceabove"><li class="li"><p><code><!--a-->IORegistryEntryGetName<!--/a--></code><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_310"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_311"></a></p></li><li class="li"><p><code><!--a-->IORegistryEntryGetNameInPlane<!--/a--></code><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_312"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_313"></a></p></li><li class="li"><p><code><!--a-->IORegistryEntryGetPath<!--/a--></code><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_314"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_315"></a></p></li><li class="li"><p><code><!--a-->IORegistryEntryGetLocationInPlane<!--/a--></code><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_316"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_317"></a></p></li><li class="li"><p><code><!--a-->IORegistryEntryInPlane<!--/a--></code><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_318"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_319"></a></p></li></ul><p>IOKitLib implements these functions by invoking IORegistryEntry methods such as <code>getName</code> and <code>getLocation</code>. Each function returns a C string that contains the object’s name or location. For example, <span class="content_text"><a href="AH_IOKitLib_API.html#//apple_ref/doc/uid/TP30000380-BABFBGCJ">Listing 4-4</a></span> shows how to use some of these functions on the object representing an Apple USB keyboard.</p><a name="//apple_ref/doc/uid/TP30000380-BABFBGCJ" title="Listing 4-4Using the IORegistryEntryGet functions"></a><p class="codesample"><strong>Listing 4-4&nbsp;&nbsp;</strong>Using the <code>IORegistryEntryGet</code> functions</p><div class="codesample"><table><tr><td scope="row"><pre>io_service_t device;<span></span></pre></td></tr><tr><td scope="row"><pre>io_name_t devName;<span></span></pre></td></tr><tr><td scope="row"><pre>io_string_t pathName;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>IORegistryEntryGetName(device, devName);<span></span></pre></td></tr><tr><td scope="row"><pre>printf("Device's name = %s\n", devName);<span></span></pre></td></tr><tr><td scope="row"><pre>IORegistryEntryGetPath(device, kIOServicePlane, pathName);<span></span></pre></td></tr><tr><td scope="row"><pre>printf("Device's path in IOService plane = %s\n", pathName);<span></span></pre></td></tr><tr><td scope="row"><pre>IORegistryEntryGetPath(device, kIOUSBPlane, pathName);<span></span></pre></td></tr><tr><td scope="row"><pre>printf("Device's path in IOUSB plane = %s\n", pathName);<span></span></pre></td></tr></table></div><p>The code in <span class="content_text"><a href="AH_IOKitLib_API.html#//apple_ref/doc/uid/TP30000380-BABFBGCJ">Listing 4-4</a></span> displays information like the following:</p><div class="codesample"><table><tr><td scope="row"><pre>Device's name = Apple Extended USB Keyboard<span></span></pre></td></tr><tr><td scope="row"><pre>Device's path in IOService plane = IOService:/MacRISC2PE/pci@f2000000/<span></span></pre></td></tr><tr><td scope="row"><pre>    AppleMacRiscPCI/usb@18/AppleUSBOHCI/Apple Extended USB Keyboard@1211000<span></span></pre></td></tr><tr><td scope="row"><pre>Device's path in IOUSB plane = IOUSB:/IOUSBHubDevice@1200000/Hub in Apple<span></span></pre></td></tr><tr><td scope="row"><pre>    Extended USB Keyboard@1210000/Apple Extended USB Keyboard@1211000<span></span></pre></td></tr></table></div><p>If you’re more interested in whether an object exists in a particular plane than in its path or name, you can use the <code><!--a-->IORegistryEntryInPlane<!--/a--></code> function, which returns <code>TRUE</code> if the object has a parent in the plane and <code>FALSE</code> otherwise.<a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_320"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_321"></a></p><a name="//apple_ref/doc/uid/TP30000380-BABIDJDI" title="Viewing Properties of I/O Registry Objects"></a><h3>Viewing Properties of I/O Registry Objects</h3><p><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_322"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_323"></a>Each object in the I/O Registry has two dictionaries associated with it:</p><ul class="spaceabove"><li class="li"><p>The property table for the object—if the object is a driver, this is the matching dictionary that defines one of the driver’s personalities (if the object is a nub, the device family publishes device properties in the nub’s property table).</p></li><li class="li"><p>The plane dictionary—this dictionary describes how the object is connected to other objects in the I/O Registry.</p></li></ul><p>These dictionaries are instances of OSDictionary. The libkern C++ library defines container classes, which hold primitive values, such as numbers and strings, and collection classes, which hold groups of both container objects and other collection objects. To view the contents of these objects in an application, you must use IOKitLib functions to convert the in-kernel collection or container object (such as OSDictionary or OSString) to the equivalent Core Foundation object. Currently, only the following libkern classes are available as Core Foundation analogues:</p><ul class="spaceabove"><li class="li"><p>OSDictionary</p></li><li class="li"><p>OSArray</p></li><li class="li"><p>OSSet</p></li><li class="li"><p>OSSymbol</p></li><li class="li"><p>OSString</p></li><li class="li"><p>OSData</p></li><li class="li"><p>OSNumber</p></li><li class="li"><p>OSBoolean</p></li></ul><p>The following IOKitLib functions allow you to access an object’s properties as Core Foundation types:</p><ul class="spaceabove"><li class="li"><p><code><!--a-->IORegistryEntryCreateCFProperty<!--/a--></code></p></li><li class="li"><p><code><!--a-->IORegistryEntryCreateCFProperties<!--/a--></code></p></li><li class="li"><p><code><!--a-->IORegistryEntrySearchCFProperty<!--/a--></code></p></li></ul><p>The <code><!--a-->IORegistryEntryCreateCFProperty<!--/a--></code><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_324"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_325"></a> function creates a Core Foundation container representing the value associated with the passed-in property key. For example, you can get a CFTypeRef to a storage device’s device-file name by passing a handle to the device (an <code>io_object_t</code> object) and the key <code>kIOBSDNameKey</code> (defined in <code>IOBSD.h</code>) to <code><!--a-->IORegistryEntryCreateCFProperty<!--/a--></code>:</p><div class="codesample"><table><tr><td scope="row"><pre>CFTypeRef deviceFileName;<span></span></pre></td></tr><tr><td scope="row"><pre>deviceFileName = IORegistryEntryCreateCFProperty(deviceHandle,<span></span></pre></td></tr><tr><td scope="row"><pre>                CFSTR(kIOBSDNameKey), kCFAllocatorDefault, 0);<span></span></pre></td></tr></table></div><p>The <code><!--a-->IORegistryEntryCreateCFProperties<!--/a--></code><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_326"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_327"></a> function creates a Core Foundation dictionary object containing the passed-in object’s property table. After your application gets the CFDictionary representation of an object’s property table, it can call Core Foundation functions (such as <code><a href="../../../../CoreFoundation/Reference/CFDictionaryRef/Reference/reference.html#//apple_ref/doc/c_ref/CFDictionaryGetValue" target="_top">CFDictionaryGetValue</a></code> and <code><a href="../../../../CoreFoundation/Reference/CFNumberRef/Reference/reference.html#//apple_ref/doc/c_ref/CFNumberGetValue" target="_top">CFNumberGetValue</a></code>) to access the dictionary’s values.</p><p>The <code><!--a-->IORegistryEntrySearchCFProperty<!--/a--></code><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_328"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_329"></a> function searches for the passed-in property, beginning with a specified <code>io_registry_entry_t</code> object’s property table, and continuing with either its parents or its children in the specified plane. When it finds the property you passed in, it returns a Core Foundation container object representing the property.</p><p>When you’re finished with the Core Foundation container object you receive from these functions, you should call <code><a href="../../../../CoreFoundation/Reference/CFTypeRef/Reference/reference.html#//apple_ref/doc/c_ref/CFRelease" target="_top">CFRelease</a></code> on it.</p><p>Because the I/O Registry is a dynamic database that is constantly being updated, the properties a function such as <code><!--a-->IORegistryEntryCreateCFProperties<!--/a--></code> returns represent a snapshot of the I/O Registry’s state at a single instant. For this reason<a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_330"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_331"></a>, you should not assume that the properties you receive are static—if you call these functions multiple times in your application, you may get different results each time.</p><a name="//apple_ref/doc/uid/TP30000380-TPXREF114" title="Setting Properties of I/O Registry Objects"></a><h3>Setting Properties of I/O Registry Objects</h3><p><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_332"></a>I<a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_333"></a>n addition to viewing an object’s properties in an application, you can also use IOKitLib functions to place new properties into an object’s property table. </p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_21" title="Important:"></a><p><strong>Important:</strong>&nbsp;This is not an action most applications need to take. Because these functions rely on the implementation of the <code>setProperties</code> method in the corresponding in-kernel driver, you should not use them unless your device family specifically recommends it or unless you control both the user and kernel side of a connection.</p><p></p></div><p>Setting properties from user space is suitable for some types of device control, in particular, single downloads of data, such as the loading of firmware. This type of user space–kernel communication works because both the application and the in-kernel object have access to the device object’s property table in the I/O Registry. Of course, when you use IOKitLib functions to set properties in an object’s property table, it’s important to realize that you’re only manipulating the OSDictionary representation of an object’s information property list, not the property list itself. </p><p>Before you consider setting an object’s properties in your application, make sure your situation meets the following conditions:</p><ul class="spaceabove"><li class="li"><p>Your device family implements the <code>setProperties</code> method or you control the in-kernel driver, and in it, you implement the <code>setProperties</code> method.</p></li><li class="li"><p>The driver does not have to allocate permanent resources to complete the transaction.</p></li><li class="li"><p>The data sent either causes no change in the driver’s state, or causes a single, permanent change.</p></li><li class="li"><p>If the application transfers data by copy, it sends only a limited amount, such as a page or less. (If the application sends data by reference, it can send an arbitrary amount of data.)</p></li></ul><p>The IOKitLib provides four functions that allow you to set properties in an object’s I/O Registry property table:</p><ul class="spaceabove"><li class="li"><p><code><!--a-->IORegistryEntrySetCFProperty<!--/a--></code><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_334"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_335"></a></p></li><li class="li"><p><code><!--a-->IORegistryEntrySetCFProperties<!--/a--></code><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_336"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_337"></a></p></li><li class="li"><p><code><!--a-->IOConnectSetCFProperty<!--/a--></code><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_338"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_339"></a></p></li><li class="li"><p><code><!--a-->IOConnectSetCFProperties<!--/a--></code><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_340"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_341"></a></p></li></ul><p>The first two functions, <code><!--a-->IORegistryEntrySetCFProperty<!--/a--></code> and <code><!--a-->IORegistryEntrySetCFProperties<!--/a--></code>, are generic functions that set either a single property value or a collection of property values (typically, in a CFDictionary object) in the specified <code>io_registry_entry_t</code> object. The in-kernel object interprets the Core Foundation container or collection object as it chooses.</p><p>If you’re developing your own device interface–user client solution, you’re more likely to use the <code><!--a-->IOConnectSetCFProperty<!--/a--></code> and <code><!--a-->IOConnectSetCFProperties<!--/a--></code> functions to set properties. This is because you are working with the <code>io_connect_t</code> object that represents the connection you opened to the in-kernel driver object with <code><!--a-->IOServiceOpen<!--/a--></code> and these functions provide more access control than <code><!--a-->IORegistryEntrySetProperty<!--/a--></code> and <code><!--a-->IORegistryEntrySetProperties<!--/a--></code>. For a brief overview of how to create a connection to a user client, see <span class="content_text"><a href="AH_IOKitLib_API.html#//apple_ref/doc/uid/TP30000380-BABEFFID">“Device-Interface Development.”</a></span><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_342"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_343"></a></p><a name="//apple_ref/doc/uid/TP30000380-TPXREF115" title="Determining Busy States"></a><h3>Determining Busy States</h3><p><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_344"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_345"></a>The IOKitLib includes a handful of functions that give you information about the busy state of various IOService objects and allow you to wait until these objects are no longer busy:</p><ul class="spaceabove"><li class="li"><p><code><!--a-->IOServiceGetBusyState<!--/a--></code><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_346"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_347"></a></p></li><li class="li"><p><code><!--a-->IOKitGetBusyState<!--/a--></code><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_348"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_349"></a></p></li><li class="li"><p><code><!--a-->IOServiceWaitQuiet<!--/a--></code><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_350"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_351"></a></p></li><li class="li"><p><code><!--a-->IOKitWaitQuiet<!--/a--></code><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_352"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_353"></a></p></li></ul><p>Because activities such as registration, matching, and termination are asynchronous, an IOService object in the process of one of these activities is considered busy and its <code>busyState</code> value is increased by one. When any of these activities concludes, the IOService’s <code>busyState</code> value is decreased by one. Additionally, any time an IOService object’s <code>busyState</code> value changes, its provider’s <code>busyState</code> value changes to match, which means that an IOService object is considered to be busy when any of its clients is busy.</p><p>To get the busy state of an individual <code>io_service_t</code> object, you use the <code><!--a-->IOServiceGetBusyState<!--/a--></code> function, which IOKitLib implements by invoking the object’s <code>getBusyState</code> method. </p><p>You can get the busy state of all IOService objects by calling the <code><!--a-->IOKitGetBusyState<!--/a--></code> function. As the provider of all IOService objects in the I/O Registry, the root of the Service plane is busy when any of its clients (in other words, any IOService object) is busy. The <code><!--a-->IOKitGetBusyState<!--/a--></code> function returns the busy state of the Service plane root, effectively informing you of the busy state of the I/O Registry as a whole.</p><p>You can wait until objects cease to be busy by calling either the <code><!--a-->IOServiceWaitQuiet<!--/a--></code> or <code><!--a-->IOKitWaitQuiet<!--/a--></code> functions. Both functions allow you to specify a maximum time to wait and block the calling process until either the time runs out or the object becomes nonbusy.<a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_354"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_355"></a></p><a name="//apple_ref/doc/uid/TP30000380-BABEFFID" title="Device-Interface Development"></a><h2>Device-Interface Development</h2><p><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_356"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_357"></a>If you need to implement both an in-kernel user client and a device-interface library, you should read <span class="content_text"><a href="../../WritingDeviceDriver/MakingHWAccessible/MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698" target="_top"> “Making Hardware Accessible”</a></span> in <em><a href="../../WritingDeviceDriver/index.html#//apple_ref/doc/uid/TP30000694" target="_top">I/O Kit Device Driver Design Guidelines</a></em> for in-depth information on how to do this. This section covers only the user-space side of this process, briefly describing the IOKitLib functions involved.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_22" title="Important:"></a><p><strong>Important:</strong>&nbsp;The IOKitLib contains several functions that are intended for developers of custom<a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_358"></a> user clients<a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_359"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_360"></a> and device interfaces<a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_361"></a>. If you are using an I/O Kit family (or third-party) device interface to access a device, you will not need to use these functions; in fact, using these functions may circumvent the family’s (or third party’s) device-interface functions and produce undesired results.</p><p></p></div><p>Although you may not directly use the IOKitLib functions this sections describes, knowing how they work will give you some insight into how device interfaces and user clients cooperate.</p><a name="//apple_ref/doc/uid/TP30000380-TPXREF116" title="Creating a User Space&acirc;&#128;&#147;Kernel Connection"></a><h3>Creating a User Space–Kernel Connection</h3><p>The IOKitLib provides several functions that allow you to create and manipulate connections to in-kernel objects, typically user clients. As with the other functions described in this section, you should use them only when your device family does not provide a device-interface solution and you’ve decided to implement both the in-kernel user client and the user-space device interface.</p><p>For an application to communicate with a device, the first thing it must do is create a connection between itself and the in-kernel object representing the device. To do this, it creates a user client object. </p><p>After it gets the <code>io_service_t</code> object representing the device driver (by calling <code><!--a-->IOServiceGetMatchingServices<!--/a--></code>, for example), the application calls the IOKitLib <code><!--a-->IOServiceOpen<!--/a--></code> function to create the connection. The <code><!--a-->IOServiceOpen<!--/a--></code><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_362"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_363"></a> function invokes the <code>io_service_t</code> object’s <code>newUserClient</code> method, which instantiates, initializes, and attaches the user client. As a result of calling <code><!--a-->IOServiceOpen<!--/a--></code>, the application receives an <code>io_connect_t</code> object (representing the user-client object) that it can use with the IOKitLib <code><!--a-->IOConnect<!--/a--></code> functions. </p><p>For example, in the <em><a href="../../../../../samplecode/SimpleUserClient/index.html#//apple_ref/doc/uid/DTS10000450" target="_top">SimpleUserClient</a></em> example project, the application portion of the project creates a user client with code like that shown in <span class="content_text"><a href="AH_IOKitLib_API.html#//apple_ref/doc/uid/TP30000380-BABEEDFJ">Listing 4-5</a></span>.</p><a name="//apple_ref/doc/uid/TP30000380-BABEEDFJ" title="Listing 4-5Creating a user client"></a><p class="codesample"><strong>Listing 4-5&nbsp;&nbsp;</strong>Creating a user client</p><div class="codesample"><table><tr><td scope="row"><pre>//Code to get the I/O Kit master port, create a matching dictionary, and get<span></span></pre></td></tr><tr><td scope="row"><pre>//an io_service_t object representing the in-kernel driver is not shown here.<span></span></pre></td></tr><tr><td scope="row"><pre>io_service_t serviceObject;<span></span></pre></td></tr><tr><td scope="row"><pre>io_connect_t dataPort;<span></span></pre></td></tr><tr><td scope="row"><pre>kern_return_t kernResult;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>kernResult = IOServiceOpen(serviceObject, mach_task_self(), 0, &amp;dataPort);<span></span></pre></td></tr></table></div><p>An application destroys a connection to a user client with a call to the <code><!--a-->IOServiceClose<!--/a--></code><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_364"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_365"></a> function, which invokes the <code>clientClose</code> method in the user client. If, for some reason, the application terminates before it’s able to call <code><!--a-->IOServiceClose<!--/a--></code>, the user client invokes the <code>clientDied</code> method. Typically, the user client responds to both methods by invoking <code>close</code> on its provider (usually the device nub).</p><p>If you’re developing your own user client and device-interface library, the IOKitLib functions you’re most likely to use are the four <code><!--a-->IOConnectMethod<!--/a--></code> functions (which call the user client’s external methods) and, if your user client can map hardware registers into your application’s address space, <code><!--a-->IOConnectMapMemory<!--/a--></code> and <code><!--a-->IOConnectUnmapMemory<!--/a--></code>.</p><a name="//apple_ref/doc/uid/TP30000380-TPXREF117" title="IOConnectMethod Functions"></a><h4>IOConnectMethod Functions</h4><p>The <code><!--a-->IOConnectMethod<!--/a--></code> functions use arrays of structures containing pointers to methods to invoke in a user-client object. The user client defines the list of methods it implements in an <code>IOExternalMethod</code> array. Typically, these methods include the user client’s <code>open</code> and <code>close</code> methods and methods that pass data between the in-kernel driver and the application. To use an <code><!--a-->IOConnectMethod<!--/a--></code> function, an application passes in the <code>io_connect_t</code> object, the index into the <code>IOExternalMethod</code> array, and, if the application is passing or receiving data, arguments that describe the general data type (scalar or structure), number of scalar parameters, size of data structures, and direction (input or output).</p><p>To open the user client, the application calls any of the <code><!--a-->IOConnectMethod<!--/a--></code> functions, passing in just the <code>io_connect_t</code> object representing the user client and the <code>IOExternalMethod</code> array index corresponding to the user client’s <code>open</code> method. Because the application is not passing or receiving any data at this point, the remaining two arguments passed to the <code><!--a-->IOConnectMethod<!--/a--></code> function are zero. For example, the code below shows how the application in the SimpleUserClient project uses the <code>io_connect_t</code> object it received in <span class="content_text"><a href="AH_IOKitLib_API.html#//apple_ref/doc/uid/TP30000380-BABEEDFJ">Listing 4-5</a></span> to open its user client:</p><div class="codesample"><table><tr><td scope="row"><pre>//kMyUserClientOpen is one of the enum constants the SimpleUserClient<span></span></pre></td></tr><tr><td scope="row"><pre>//project uses as indexes into the IOExternalMethod array.<span></span></pre></td></tr><tr><td scope="row"><pre>kernResult = IOConnectMethodScalarIScalarO(dataPort, kMyUserClientOpen,<span></span></pre></td></tr><tr><td scope="row"><pre>                 0, 0);<span></span></pre></td></tr></table></div><p>To pass untyped data back and forth across the user-kernel boundary, an application uses one of the <code><!--a-->IOConnectMethod<!--/a--></code> functions in <span class="content_text"><a href="AH_IOKitLib_API.html#//apple_ref/doc/uid/TP30000380-BABGGFFB">Table 4-2</a></span>, depending on the type of data and the direction of data flow.</p><a name="//apple_ref/doc/uid/TP30000380-BABGGFFB" title="Table 4-2IOConnectMethod functions"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 4-2&nbsp;&nbsp;</strong><code>IOConnectMethod</code> functions</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Function</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code><!--a-->IOConnectMethodScalarIScalarO<!--/a--></code><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_366"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_367"></a></p></td><td ><p>One or more scalar input parameters, one or more scalar output parameters</p></td></tr><tr><td  scope="row"><p><code><!--a-->IOConnectMethodScalarIStructureO<!--/a--></code><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_368"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_369"></a></p></td><td ><p>One or more scalar input parameters, one structure output parameter</p></td></tr><tr><td  scope="row"><p><code><!--a-->IOConnectMethodScalarIStructureI<!--/a--></code><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_370"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_371"></a></p></td><td ><p>One or more scalar input parameters, one structure input parameter</p></td></tr><tr><td  scope="row"><p><code><!--a-->IOConnectMethodStructureIStructureO<!--/a--></code><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_372"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_373"></a></p></td><td ><p>One structure input parameter, one structure output parameter</p></td></tr></table></div><p>The <code><!--a-->IOConnectMethod<!--/a--></code> functions are designed to accept variable argument lists, depending on the data type and direction you choose. Following the first two arguments—the <code><!--a-->io_connect_t<!--/a--></code> object and the method array index—is some combination of arguments that identify:</p><ul class="spaceabove"><li class="li"><p>The number of scalar input or output values</p></li><li class="li"><p>The size of the input or output structure</p></li><li class="li"><p>Scalar input or output values</p></li><li class="li"><p>A pointer to an input or output structure</p></li></ul><p>The application in the SimpleUserClient, for example, uses the <code><!--a-->IOConnectMethodScalarIStructureI<!--/a--></code> function as shown in <span class="content_text"><a href="AH_IOKitLib_API.html#//apple_ref/doc/uid/TP30000380-BABGCEAI">Listing 4-6</a></span>.</p><a name="//apple_ref/doc/uid/TP30000380-BABGCEAI" title="Listing 4-6Requesting I/O with the IOConnectMethodScalarIStructureI function"></a><p class="codesample"><strong>Listing 4-6&nbsp;&nbsp;</strong>Requesting I/O with the <code>IOConnectMethodScalarIStructureI</code> function</p><div class="codesample"><table><tr><td scope="row"><pre>//MySampleStruct is defined in the header file both the user client<span></span></pre></td></tr><tr><td scope="row"><pre>//and the application include and consists of two integer variable<span></span></pre></td></tr><tr><td scope="row"><pre>//declarations.<span></span></pre></td></tr><tr><td scope="row"><pre>MySampleStruct sampleStruct = {586, 8756}; //Random numbers.<span></span></pre></td></tr><tr><td scope="row"><pre>int sampleNumber = 15; //Random number.<span></span></pre></td></tr><tr><td scope="row"><pre>IOByteCount structSize = sizeof(MySampleStruct);<span></span></pre></td></tr><tr><td scope="row"><pre>kern_return_t kernResult;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>kernResult = IOConnectMethodScalarIStructureI(dataPort, // from IOServiceOpen<span></span></pre></td></tr><tr><td scope="row"><pre>                kMyScalarIStructImethod, // method index<span></span></pre></td></tr><tr><td scope="row"><pre>                1, // number of scalar input values<span></span></pre></td></tr><tr><td scope="row"><pre>                structSize, // size of input structure<span></span></pre></td></tr><tr><td scope="row"><pre>                sampleNumber, // scalar input value<span></span></pre></td></tr><tr><td scope="row"><pre>                &amp;sampleStruct // pointer to input structure<span></span></pre></td></tr><tr><td scope="row"><pre>                );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000380-TPXREF118" title="Memory-Mapping Functions"></a><h4>Memory-Mapping Functions</h4><p>If your device driver has full PIO (Programmed Input/Output) memory management and your device does not require the use of interrupts, you can write a dedicated application that moves large amounts of data to and from the device, using the <code><!--a-->IOConnectMapMemory<!--/a--></code><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_374"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_375"></a> and <code><!--a-->IOConnectUnmapMemory<!--/a--></code><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_376"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_377"></a> functions. For example, a frame-buffer application can use these functions to handle the large amounts of on-board memory that needs to be accessible from user space. The <code><!--a-->IOConnectMapMemory<!--/a--></code> function allows a user process to share memory with an in-kernel driver by mapping the same memory into both processes.</p><p>When a user process calls <code><!--a-->IOConnectMapMemory<!--/a--></code>, it passes in, among other arguments, a pointer to an area in its own address space that will contain the mapped memory. The call to <code><!--a-->IOConnectMapMemory<!--/a--></code> causes the invocation of the user client’s <code>clientMemoryForType</code> method. The user client implements this method by creating an IOMemoryDescriptor object that backs the mapping to the hardware registers. The user process receives a virtual memory <code>vm_address_t</code> object containing the address of the mapped memory and a <code>vm_size_t</code> object that contains the size of the mapping. At this point, the user process can freely write to and read from the hardware registers.</p><p>When the user process or device interface is finished performing I/O with the mapped memory, it should call <code><!--a-->IOConnectUnmapMemory<!--/a--></code> to remove the mapping.</p><a name="//apple_ref/doc/uid/TP30000380-TPXREF119" title="Managing the User Space&acirc;&#128;&#147;Kernel Connection"></a><h3>Managing the User Space–Kernel Connection</h3><p>The remaining <code><!--a-->IOConnect<!--/a--></code> functions in IOKitLib are primarily intended to help you manage your custom user space–kernel connection. As with the other <code><!--a-->IOConnect<!--/a--></code> functions, you should not use them with I/O Kit family-supplied or third-party device interfaces because they operate directly on the <code>io_connect_t</code> object representing the connection, circumventing the existing device interface.</p><p>The IOKitLib contains the following functions to manipulate the <code>io_connect_t</code> object:</p><ul class="spaceabove"><li class="li"><p><code><!--a-->IOConnectAddClient<!--/a--></code><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_378"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_379"></a></p></li><li class="li"><p><code><!--a-->IOConnectAddRef<!--/a--></code><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_380"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_381"></a></p></li><li class="li"><p><code><!--a-->IOConnectRelease<!--/a--></code><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_382"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_383"></a></p></li><li class="li"><p><code><!--a-->IOConnectGetService<!--/a--></code><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_384"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_385"></a></p></li><li class="li"><p><code><!--a-->IOConnectSetNotificationPort<!--/a--></code><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_386"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_387"></a></p></li></ul><p>The <code><!--a-->IOConnectAddClient<!--/a--></code> function creates a connection between two user-client objects in the kernel by invoking the first user client’s <code>connectClient</code> method. You can use this function in the unlikely event that you have two user clients that need to be able to communicate.</p><p>As their names suggest, <code><!--a-->IOConnectAddRef<!--/a--></code> and <code><!--a-->IOConnectRelease<!--/a--></code> adjust the reference count on the passed-in <code>io_connect_t</code> object.</p><p>The <code><!--a-->IOConnectGetService<!--/a--></code> function returns an <code>io_service_t</code> object representing the IOService object on which the passed-in <code>io_connect_t</code> object was opened. IOKitLib implements this function by invoking the user client’s <code>getService</code> method.</p><p>To identify a Mach port on which to receive family-specific notifications (notification types not interpreted by the I/O Kit), you use the <code><!--a-->IOConnectSetNotificationPort<!--/a--></code> function. You pass in, among other arguments, the <code>io_connect_t</code> object representing the user client connection and a <code>mach_port_t</code> object representing the Mach port on which you want to receive notifications. The IOKitLib implements this function by invoking the user client’s <code>registerNotificationPort</code> method.<a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_388"></a><a name="//apple_ref/doc/uid/TP30000380-DontLinkElementID_389"></a></p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../AH_Finding_Devices/AH_Finding_Devices.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../AH_Handling_Errors/AH_Handling_Errors.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2001, 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-02-08<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeviceDrivers/Conceptual/AccessingHardware/AH_IOKitLib_API/AH_IOKitLib_API.html%3Fid%3DTP30000376-2.10&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeviceDrivers/Conceptual/AccessingHardware/AH_IOKitLib_API/AH_IOKitLib_API.html%3Fid%3DTP30000376-2.10&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeviceDrivers/Conceptual/AccessingHardware/AH_IOKitLib_API/AH_IOKitLib_API.html%3Fid%3DTP30000376-2.10&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>