<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>DTS.Utilities - /Utilities.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">DTS.Utilities</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/index.html" target="_blank">Reference Library</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">DTS.Utilities</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Utilities.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Utilities.c</option>
<option value="listing2.html">/Utilities.h</option>
<option value="listing3.html">/Utilities.r</option>
<option value="listing4.html">/UtilitiesCommon.h</option></select>
				</p>
				</form>
				<p><strong><a href="DTS.Utilities.zip">Download Sample</a></strong> (&#147;DTS.Utilities.zip&#148;, 140.4K)<BR>
<strong><a href="DTS.Utilities.dmg">Download Sample</a></strong> (&#147;DTS.Utilities.dmg&#148;, 217.5K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    Utilities.c  Contains:  Collection of Utilities for DTS Sample code  Written by:     Copyright:  Copyright &copy; 1988-1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        8/18/1999  Karl Groethe  Updated for Metrowerks Codewarror Pro 2.1        */#ifndef __CONTROLS__#include &lt;Controls.h&gt;#endif#ifndef __DEVICES__#include &lt;Devices.h&gt;#endif#ifndef __EVENTS__#include &lt;Events.h&gt;#endif#ifndef __FIXMATH__#include &lt;FixMath.h&gt;#endif#ifndef __FONTS__#include &lt;Fonts.h&gt;#endif#ifndef __MENUS__#include &lt;Menus.h&gt;#endif#ifndef __PACKAGES__#include &lt;Packages.h&gt;#endif#ifndef __RESOURCES__#include &lt;Resources.h&gt;#endif#ifndef __SCRIPT__#include &lt;Script.h&gt;#endif#ifndef __SEGLOAD__#include &lt;SegLoad.h&gt;#endif#ifndef __STRING__#include &lt;String.h&gt;#endif#ifndef __LOWMEM__#include &lt;LowMem.h&gt;#endif#ifndef __TEXTEDIT__#include &lt;TextEdit.h&gt;#endif#ifndef __TOOLUTILS__#include &lt;ToolUtils.h&gt;#endif#ifndef __TRAPS__#include &lt;Traps.h&gt;#endif#ifndef __ERRORS__#include &lt;Errors.h&gt;#endif#include &quot;Utilities.h&quot;#include &lt;TextUtils.h&gt;/*-----------------------------------------------------------------------------------------  Private Functions -----------------------------------------------------------------------------------------*//*-----------------------------------------------------------------------------------------  Global variables -- See Utilities.h for more explanation-----------------------------------------------------------------------------------------*/short      gMachineType;      /* which machine this is */short      gSystemVersion;      /* System version number */short      gProcessorType;      /* which CPU this is */Boolean      gHasFPU;        /* true if machine has an FPU */short      gQDVersion;        /* major QD version #; 0 for original,                           1 for color QD, 2 for 32-bit QD */short      gKeyboardType;      /* which type of keyboard is present */short      gAppleTalkVersion;    /* AppleTalk version number */Boolean      gHasPMMU;        /* true if machine has a PMMU or equivalent */short      gAUXVersion;      /* major A/UX version number (0 if not present) */Boolean      gHasWaitNextEvent;short      gAppResRef;Boolean      gInBackground;Str255      gAppName;OSType      gSignature = '????';Boolean      gUtilitiesInited;/*****************************************************************************//* Given an alert ID and a window pointer the alert relates to, this function** will center the alert's rectangle before showing it on the proper screen.** This follows the Apple Human Interface Guidelines for where to place a** centered window on the screen.  If the alert is not closely associated with** another window, pass a NULL for the window pointer of the related window.  If** you pass a NULL, the alert is simply displayed where the resource** would indicate.  Note that if an error occurs when getting the resource for** the alert, then the alert is not displayed, and the returned value is not** the item hit, but is the error that occured when reading the resource. */#pragma segment UtilMainshort  CenteredAlert(short alertID, WindowPtr relatedWindow){  AlertTHndl  alertHandle;  WindowPtr  tempWindow;  Rect    alertRect;  short    itemHit;  char    hstate;  OSErr    err;    alertHandle = (AlertTHndl)GetAppResource('ALRT', alertID, &amp;err);  if (err) return((short)err);  hstate = LockHandleHigh((Handle)alertHandle);    /* Do our part to help prevent fragmentation. */  alertRect = (*alertHandle)-&gt;boundsRect;    /* Preserve the real alert bounding rectangle. */  if (tempWindow = NewWindow(NULL, &amp;alertRect, &quot;\p&quot;, false, dBoxProc,                (WindowPtr)NULL, false, 0)) {    /* Use an invisible temporary window to calculate where the alert will go. */    (*alertHandle)-&gt;boundsRect = CenterWindow(tempWindow, relatedWindow);    DisposeWindow(tempWindow);  }  itemHit = Alert(alertID, NULL);  (*alertHandle)-&gt;boundsRect = alertRect;    /* Restore the resource's bounding rect, so if this resource is ever used    ** not through this function, it will open where the resource indicates. */  HSetState((Handle)alertHandle, hstate);  return(itemHit);}/*****************************************************************************//* Given two rects, this function centers the second one within the first. */#pragma segment UtilMainvoid  CenterRectInRect(Rect outerRect, Rect *innerRect){  PositionRectInRect(outerRect, innerRect, FixRatio(1, 2), FixRatio(1, 2));}/*****************************************************************************//* Center a window within a particular device.  The device to center the window** within is determined by passing a related window.  This allows related** windows to be kept on the same device.  This is useful if an alert related** to a specific window, for example. */#pragma segment UtilMainRect  CenterWindow(WindowPtr window, WindowPtr relatedWindow){  WindowPtr  whichDevice;  Rect    deviceRect, oldWindowRect, newWindowRect, contentRect;  if (!(whichDevice = relatedWindow)) whichDevice = window;    /* If we have a window to center against, use the device for that window,    ** else use the device for the window that is getting centered. */  deviceRect = GetWindowDeviceRectNMB(whichDevice);    /* We now have the rectangle of the device we want to center within. */  oldWindowRect = newWindowRect = GetWindowStructureRect(window);  PositionRectInRect(deviceRect, &amp;newWindowRect, FixRatio (1, 2),             FixRatio (1, 3));    /* Figure out the new window strucRect so we can compare it against    ** the old strucRect.  This will tell us how much to move the window. */  contentRect = GetWindowContentRect(window);    /* Get where the window is now. */  OffsetRect(&amp;contentRect, newWindowRect.left - oldWindowRect.left,              newWindowRect.top  - oldWindowRect.top);    /* Calculate the new content rect. */  MoveWindow(window, contentRect.left, contentRect.top, false);    /* Move the window to the new location. */  return(contentRect);}/*****************************************************************************//* Close a window.  This handles desk accessory and application windows.  Use** this call (instead of DisposeAnyWindow) if the memory for the window was** allocated by you.  (Same as CloseWindow v.s. DisposeWindow.) */#pragma segment UtilMainvoid  CloseAnyWindow(WindowPtr window){  if (IsDAWindow(window))    CloseDeskAcc(((WindowPeek)window)-&gt;windowKind);  else {    if (IsAppWindow(window))      CloseWindow(window);    else if (((WindowPeek)window)-&gt;windowKind &gt;= dialogKind)      CloseDialog((DialogPtr)window);  }}/*****************************************************************************//* Dispose a window.  This handles desk accessory and application windows.  Use** this call (instead of CloseAnyWindow) if you want the memory for the window** record to be disposed of.  (Same as CloseWindow v.s. DisposeWindow.) */#pragma segment UtilMainvoid  DisposeAnyWindow(WindowPtr window){  if (IsDAWindow(window))    CloseDeskAcc(((WindowPeek)window)-&gt;windowKind);  else {    if (IsAppWindow(window))      DisposeWindow(window);    else if (((WindowPeek)window)-&gt;windowKind &gt;= dialogKind)      DisposeDialog((DialogPtr)window);  }}/*****************************************************************************//* Display an alert that tells the user an error occurred, then exit the** program.  This function is used as an ultimate bail-out for serious errors** that prohibit the continuation of the application.  Errors that do not** require the termination of the application should be handled in a different** manner. */  #pragma segment UtilMainvoid  DeathAlert(short errResID, short errStringIndex){  ErrorAlert(errResID, errStringIndex);  ExitToShell();}/*****************************************************************************//* Display an alert that tells the user an error occurred, then exit the** program.  This function is used as an ultimate bail-out for serious errors** that prohibit the continuation of the application.  Errors that do not** require the termination of the application should be handled in a different** manner.  The message parameter is an error code that is to be displayed. */#pragma segment UtilMainvoid  DeathAlertMessage(short errResID, short errStringIndex, short message){  ErrorAlertMessage(errResID, errStringIndex, message);  ExitToShell();}/*****************************************************************************//* Display an alert that tells the user an error occurred. */#pragma segment UtilMainvoid  ErrorAlert(short errResID, short errStringIndex){  ErrorAlertMessage(errResID, errStringIndex, 0);}/*****************************************************************************//* Display an alert to inform the user of an error.  errStringIndex acts as an** index into a STR# resource of error messages.  If no errStringIndex is** given, i.e. = 0, then use a standard message.  If message is not noErr then** display it as well.**** BUG NOTE:  GetIndString returns a bogus String if the index is**            not positive. */  #pragma segment UtilMainvoid  ErrorAlertMessage(short errResID, short errStringIndex, short message){  Str255  msg1, msg2;  SetCursor(&amp;QD(arrow));  if (errStringIndex &lt;= 0) {    errStringIndex = eStandardErr;    errResID = rUtilStrings;  }  GetIndString(msg1, errResID, errStringIndex);  if (message == noErr) {    ParamText(msg1, &quot;\p&quot;, &quot;\p&quot;, &quot;\p&quot;);    CenteredAlert(rUtilErrorAlert, NULL);  } else {    NumToString(message, msg2);    ParamText(msg1, msg2, &quot;\p&quot;, &quot;\p&quot;);    CenteredAlert(rUtilErrorMessageAlert, NULL);  }}/*****************************************************************************//* FindSysFolder returns the (real) vRefNum, and the DirID of the current** system folder.  It uses the Folder Manager if present, otherwise it falls** back to SysEnvirons.  It returns zero on success, otherwise a standard** system error. */#pragma segment UtilMainOSErr  FindSysFolder(short *foundVRefNum, long *foundDirID){  long      gesResponse;  SysEnvRec    envRec;  WDPBRec      myWDPB;  unsigned char  volName[34];  OSErr      err;      *foundVRefNum = 0;  *foundDirID = 0;  if (!Gestalt (gestaltFindFolderAttr, &amp;gesResponse) &amp;&amp;    BTstQ (gesResponse, gestaltFindFolderPresent)) {  /* Does Folder Manager exist? */      err = FindFolder (kOnSystemDisk, kSystemFolderType, kDontCreateFolder,         foundVRefNum, foundDirID);  } else {    /* Gestalt can't give us the answer, so we resort to SysEnvirons */    if (!(err = SysEnvirons (curSysEnvVers, &amp;envRec))) {      myWDPB.ioVRefNum = envRec.sysVRefNum;      volName[0] = '\000';          /* Zero volume name */      myWDPB.ioNamePtr = volName;      myWDPB.ioWDIndex = 0;      myWDPB.ioWDProcID = 0;      if (!(err = PBGetWDInfo (&amp;myWDPB, 0))) {        *foundVRefNum = myWDPB.ioWDVRefNum;        *foundDirID = myWDPB.ioWDDirID;      }    }  }  return (err);}/*****************************************************************************//* GetAppIndResource gets a resource from the application's resource file** by index. */#pragma segment UtilMainHandle  GetAppIndResource(ResType theType, short index, OSErr *err){#pragma unused (err)  short  savedResFile;  Handle  returnHandle;    savedResFile = CurResFile ();  UseResFile (gAppResRef);  returnHandle = Get1IndResource(theType, index);  UseResFile (savedResFile);  return (returnHandle);}/*****************************************************************************//* GetAppNamedResource gets a resource from the application's resource file** by name. */#pragma segment UtilMainHandle  GetAppNamedResource(ResType theType, Str255 name, OSErr *err){  short  savedResFile;  Handle  returnHandle;    savedResFile = CurResFile ();  UseResFile (gAppResRef);  returnHandle = Get1NamedResource(theType, name);  *err = ResError();  UseResFile (savedResFile);  return (returnHandle);}/*****************************************************************************//* GetAppResource gets a resource from the application's resource file by** resource ID. */#pragma segment UtilMainHandle  GetAppResource(ResType theType,short theID, OSErr *err){  short  savedResFile;  Handle  returnHandle;    savedResFile = CurResFile ();  UseResFile (gAppResRef);  returnHandle = Get1Resource(theType, theID);  *err = ResError();  UseResFile (savedResFile);  return (returnHandle);}/*****************************************************************************//* Checks for the presence of A/UX by whatever means is appropriate.  Returns** the major version number of A/UX (i.e. 0 if A/UX is not present, 1 for** any 1.x.x version 2 for any 2.x version, etc.**** This code should work for all past, present and future A/UX systems. */#pragma segment UtilMainshort  GetAUXVersion(void){  long  auxVersion;  short  err;      /*   *  This code assumes the Gestalt glue checks for the presence of the _Gestalt   *  trap and does something intelligent if the trap is unavailable, i.e.   *  return unknown selector.   */  auxVersion = 0;  err = Gestalt(gestaltAUXVersion, &amp;auxVersion);  /*   *  If gestaltUnknownErr or gestaltUndefSelectorErr was returned, then either    *  we weren't running on A/UX, or the _Gestalt trap is unavailable so use    *  HWCfgFlags instead.   *  All other errors are ignored (implies A/UX not present).   */  if (err == gestaltUnknownErr || err == gestaltUndefSelectorErr) {  /* Use HWCfgFlags */    if (BTstQ(LMGetHWCfgFlags(), 9))      auxVersion = 0x100;      /* Do Have A/UX, so assume version 1.x.x */  }  /*   *  Now right shift auxVersion by 8 bits to get major version number   */  auxVersion &gt;&gt;= 8;  return((short)auxVersion);}/*****************************************************************************//* Given a dialog ID and a window pointer the dialog relates to, this function** will center the dialog's rectangle before showing it on the proper screen.** This follows the Apple Human Interface Guidelines for where to place a** centered window on the screen.  If the dialog is not closely associated with** another window, pass a NULL for the window pointer of the related window.  If** you pass a NULL, the dialog is simply displayed where the resource** would indicate. */#pragma segment UtilMainDialogPtr  GetCenteredDialog(short id, DialogPtr storage, WindowPtr relatedWindow, WindowPtr behind){  DialogTHndl    dlogResource;  DialogPtr    dialog;  Boolean      oldVis;  char      hstate;  OSErr      err;    dialog = NULL;  if (dlogResource = (DialogTHndl)GetAppResource('DLOG', id, &amp;err)) {    hstate = LockHandleHigh((Handle)dlogResource);    oldVis = (*dlogResource)-&gt;visible;    (*dlogResource)-&gt;visible = false;    if (dialog = GetNewDialog(id, storage, behind)) {      CenterWindow(dialog, relatedWindow);      if (oldVis) ShowWindow(dialog);    }    (*dlogResource)-&gt;visible = oldVis;    HSetState((Handle)dlogResource, hstate);  }  return(dialog);}/*****************************************************************************//* Given a window ID and a window pointer the window relates to, this function** will center the window's rectangle before showing it on the proper screen.** This follows the Apple Human Interface Guidelines for where to place a** centered window on the screen.  If the window is not closely associated with** another window, pass a NULL for the window pointer of the related window.  If** you pass a NULL, the window is simply displayed where the resource** would indicate. */#pragma segment UtilMainWindowPtr  GetCenteredWindow(short id, Ptr storage, WindowPtr relatedWindow,                WindowPtr behind, Boolean inColor){  return(GetSomeKindOfWindow(CenterWindow, id, storage, relatedWindow, behind, inColor));}/*****************************************************************************/#pragma segment UtilMainBoolean GetCheckOrRadio(DialogPtr dlgPtr, short itemNo){  short  iKind;  Handle  iHandle;  Rect  iRect;  GetDialogItem(dlgPtr, itemNo, &amp;iKind, &amp;iHandle, &amp;iRect);  return(GetControlValue((ControlHandle)iHandle) != 0);}/*****************************************************************************//* GetGestaltResult returns the result value from Gestalt for the specified** selector.  If Gestalt returned an error GetGestaltResult returns zero.** Use of this function is only cool if we don't care whether Gestalt returned** an error.  In many cases you may need to know the exact Gestalt error code** so then this function would be inappropriate.** See GetAUXVersion for an example. */#pragma segment UtilMainlong  GetGestaltResult(OSType gestaltSelector){  long  gestaltResult;    if (Gestalt(gestaltSelector, &amp;gestaltResult) == noErr)    return(gestaltResult);  else    return(0);}/*****************************************************************************//* Get the global coordinates of the mouse.  When you call OSEventAvail it will** return either a pending event or a null event.  In either case, the where** field of the event record will contain the current position of the mouse in** global coordinates and the modifiers field will reflect the current state of** the modifiers.  Another way to get the global coordinates is to call** GetMouse and LocalToGlobal, but that requires being sure that thePort is set** to a valid port. */#pragma segment UtilMainPoint  GetGlobalMouse(void){  EventRecord  event;    OSEventAvail(kNoEvents, &amp;event);  /* we aren't interested in any events */  return(event.where);        /* just the mouse position */}/*****************************************************************************//* Given a window, this will return the top left point of the window's port in** global coordinates.  Something this doesn't include is the window's drag** region (or title bar).  This returns the top left point of the window's** content area only. */  #pragma segment UtilMainPoint  GetGlobalTopLeft(WindowPtr window){  GrafPtr      oldPort;  Point      globalPt;    GetPort(&amp;oldPort);  SetPort(window);  globalPt = TopLeft(window-&gt;portRect);  LocalToGlobal(&amp;globalPt);  SetPort(oldPort);  return(globalPt);}/*****************************************************************************//* Return the amount of free space on the volume in KBytes. -1 is returned as** the size if there is an error. */#pragma segment UtilInitlong  GetKFreeSpace(short vRefNum){  HParamBlockRec  pb;  OSErr      err;  pb.volumeParam.ioNamePtr = NULL;      /* we don't care about the name */  pb.volumeParam.ioVRefNum = vRefNum;  pb.volumeParam.ioVolIndex = 0;      /* use ioVRefNum only */  err = PBHGetVInfo(&amp;pb, false);  if (err == noErr)    return((pb.volumeParam.ioVFrBlk * pb.volumeParam.ioVAlBlkSiz) / 1024);  else    return(-1);}/*****************************************************************************/#pragma segment UtilMainRect  GetMainScreenRect(void){  GDHandle  mainDevice;  GrafPtr    mainPort;  if (gQDVersion &gt; kQDOriginal) {    mainDevice = GetMainDevice();    return((*mainDevice)-&gt;gdRect);  } else {    GetWMgrPort(&amp;mainPort);    return(mainPort-&gt;portRect);  }}/*****************************************************************************//* Find the greatest overlap device for the given global rectangle. */#pragma segment UtilInitGDHandle  GetRectDevice(Rect globalRect){  long    area;  long    maxArea;  GDHandle  device;  GDHandle  deviceToReturn;  Rect    intersection;  deviceToReturn = GetMainDevice();      /* Use as default choice. */  maxArea = 0;  for (device = GetDeviceList(); device; device = GetNextDevice(device)) {    if (TestDeviceAttribute(device, screenDevice)      &amp;&amp; TestDeviceAttribute(device, screenActive)      &amp;&amp; SectRect(&amp;globalRect, &amp;((*device)-&gt;gdRect), &amp;intersection)) {      area = (intersection.right - intersection.left) *           (intersection.bottom - intersection.top);      if (area &gt; maxArea) {        deviceToReturn = device;        maxArea = area;      }    }  }  return(deviceToReturn);}/*****************************************************************************//* Find the rect of the greatest overlap device for the given global rect. */#pragma segment UtilInitRect  GetRectDeviceRect(Rect globalRect){  if (gQDVersion &gt; kQDOriginal)    return((*GetRectDevice(globalRect))-&gt;gdRect);  else    return(GetMainScreenRect());}/*****************************************************************************//* Given a window positioning procedure pointer, a window ID and a window** pointer the window relates to, this function open a new window by either** a NewCWindow or a NewWindow call, depending on the value of inColor.  The** window will be opened invisible, independent of what the resource says.** Once the window is opened successfully, the positioning procedure is** called.  The positioning procedure is passed a pointer to the just-opened** invisible window and a pointer to the related window.  It is up to the** positioning procedure to move the invisible window to the correct location** on the correct device.  Once the positioning procedure returns, the window** will be made visible if so indicated by the resource. */#pragma segment UtilMainWindowPtr  GetSomeKindOfWindow(PositionWndProcPtr whatKind, short windID,                Ptr storage, WindowPtr relatedWindow,                WindowPtr behind, Boolean inColor){  WindowTHndl    windowResource;  WindowTemplate  wt;        /* Window template. */  WindowPtr    aWindow;  OSErr      err;  if (!gQDVersion) inColor = false;  aWindow = NULL;    /* Assume we will fail.  (Good attitude.) */  if (!storage) storage = NewPtr(sizeof(WindowRecord));  if (storage) {      /* If we have memory for the window record... */    if (windowResource = (WindowTHndl)GetAppResource('WIND', windID, &amp;err)) {      /* If we can load the window resource... */      wt = **windowResource;    /* Make local copy of resource. */      aWindow = (inColor ? NewCWindow(storage, &amp;wt.boundsRect,                      wt.title, false, wt.procID,                      behind, wt.goAwayFlag, wt.refCon)                 : NewWindow(storage, &amp;wt.boundsRect, wt.title,                       false, wt.procID,                       behind, wt.goAwayFlag, wt.refCon));        /* Open either a regular or color window. */      if (aWindow) {    /* If we were able to open a window... */        (*whatKind)(aWindow, relatedWindow);          /* Call the designated window positioning procedure. */        if (wt.visible) ShowWindow(aWindow);          /* If resource says window should be visible, do it. */      }    }    if (!aWindow) DisposePtr(storage);      /* If we failed, then get rid of window record memory. */  }  return(aWindow);}/*****************************************************************************//* Given a window ID and a window pointer the window relates to, this function** will stagger the window's rectangle before showing it on the proper screen.** This follows the Apple Human Interface Guidelines for where to place a** staggered window on the screen.  If the window is not closely associated** with another window, pass a NULL for the window pointer of the related** window.  If you pass a NULL, the window is simply displayed where the** resource would indicate. */#pragma segment UtilMainWindowPtr  GetStaggeredWindow(short id, Ptr storage, WindowPtr relatedWindow,                 WindowPtr behind, Boolean inColor){  return(GetSomeKindOfWindow(StaggerWindow, id, storage, relatedWindow, behind, inColor));}/*****************************************************************************//*  Check the bits of a trap number to determine its type. */#pragma segment UtilInitTrapType  GetTrapType(short theTrap){  /* OS traps start with A0, Tool with A8 or AA. */  if ((theTrap &amp; 0x0800) == 0)          /* per D.A. */    return (OSTrap);  else    return (ToolTrap);}/*****************************************************************************//* Given a window pointer, return the global rectangle that encloses the** content area of the window. */#pragma segment UtilMainRect  GetWindowContentRect(WindowPtr window){  WindowPtr  oldPort;  Rect    contentRect;  GetPort(&amp;oldPort);  SetPort(window);  contentRect = window-&gt;portRect;  LocalToGlobalRect(&amp;contentRect);  SetPort(oldPort);  return(contentRect);}/*****************************************************************************//* This procedure counts the number of windows in the application plane.** You have the choices of also including DAs and invisible windows in** this count. */#pragma segment UtilMainshort  GetWindowCount(Boolean includeDAs, Boolean includeInvisibles){  WindowPeek  window;  short    count;  for (count = 0, window = (WindowPeek)LMGetWindowList();     (window != NULL); window = window-&gt;nextWindow) {    if ((window-&gt;windowKind &lt; 0) &amp;&amp; (!includeDAs)) continue;    if ((window-&gt;visible) || (includeInvisibles)) count++;  }  return (count);}/*****************************************************************************//* Find the greatest overlap device for the given window. */#pragma segment UtilInitGDHandle  GetWindowDevice(WindowPtr window){  return(GetRectDevice(GetWindowStructureRect(window)));}/*****************************************************************************//* Given a window pointer, find the device that contains most of the window** and return the device's bounding rectangle. */#pragma segment UtilMainRect  GetWindowDeviceRect(WindowPtr window){  if (gQDVersion &gt; kQDOriginal)    return((*GetWindowDevice(window))-&gt;gdRect);  else    return(GetMainScreenRect());}/*****************************************************************************//* Given a window pointer, find the device that contains most of the window** and return the device's bounding rectangle.  If this device is the main** device, then remove the menubar area from the rectangle. */#pragma segment UtilMainRect  GetWindowDeviceRectNMB(WindowPtr window){  Rect    deviceRect, tempRect;  deviceRect = GetWindowDeviceRect(window);  tempRect = GetMainScreenRect();  if (EqualRect(&amp;deviceRect, &amp;tempRect)) deviceRect.top += GetMBarHeight();  return(deviceRect);}/*****************************************************************************//* This procedure is used to get the rectangle that surrounds the entire** structure of a window.  This is true whether or not the window is visible.** If the window is visible, then it is a simple matter of using the bounding** rectangle of the structure region.  If the window is invisible, then the** strucRgn is not correct.  To make it correct, then window has to be moved** way off the screen and then made visible.  This generates a valid strucRgn,** although it is valid for the position that is way off the screen.  It still** needs to be offset back into the original position.  Once the bounding** rectangle for the strucRgn is obtained, the window can then be hidden again** and moved back to its correct location.  Note that ShowHide is used,** instead of ShowWindow and HideWindow.  HideWindow can change the plane of** the window.  Also, ShowHide does not affect the hiliting of windows. */#pragma segment UtilMainRect  GetWindowStructureRect(WindowPtr window){#define kOffscreenLoc 0x4000  GrafPtr    oldPort;  Rect    structureRect;  Point    windowLoc;    if (((WindowPeek)window)-&gt;visible)    structureRect = (*(((WindowPeek)window)-&gt;strucRgn))-&gt;rgnBBox;  else {    GetPort(&amp;oldPort);    SetPort(window);    windowLoc = GetGlobalTopLeft(window);    MoveWindow(window, windowLoc.h, kOffscreenLoc, false);    ShowHide(window, true);    structureRect = (*(((WindowPeek)window)-&gt;strucRgn))-&gt;rgnBBox;    ShowHide(window, false);    MoveWindow(window, windowLoc.h, windowLoc.v, false);    SetPort(oldPort);    OffsetRect(&amp;structureRect, 0, windowLoc.v - kOffscreenLoc);  }  return(structureRect);}/*****************************************************************************/#pragma segment UtilMainvoid  GlobalToLocalRect(Rect *aRect){  GlobalToLocal(&amp;TopLeft(*aRect));  GlobalToLocal(&amp;BotRight(*aRect));}/*****************************************************************************/#pragma segment UtilInitvoid  InitToolBox(void){  InitGraf((Ptr) &amp;QD(thePort));  InitFonts();  InitWindows();  InitMenus();  TEInit();  InitDialogs(NULL);  InitCursor();}  /*****************************************************************************//* InitUtilities sets up some global variables for use by the utilities** package.  If you call StandardInitialization, you don't need to call this,** as it will do it for you. */ #pragma segment UtilInitvoid  InitUtilities(void){  //Handle  apParam;  Handle  bndlResource;  OSErr  err;  gUtilitiesInited = false;  /* Init all the Gestalt variables */  gMachineType = GetGestaltResult (gestaltMachineType);  gSystemVersion = GetGestaltResult (gestaltSystemVersion);  gProcessorType = GetGestaltResult (gestaltProcessorType);  /* We only concern ourselves with there being an FPU, not which type it is */  gHasFPU = (GetGestaltResult (gestaltFPUType) != gestaltNoFPU);    /*   *  We only concern ourselves with the major QD version number   *  0 for original QD, 1 for 8-bit color QD, and 2 for 32-bit QD   */  gQDVersion = (GetGestaltResult (gestaltQuickdrawVersion) &gt;&gt; 8) &amp; 0xFF;  gKeyboardType = GetGestaltResult (gestaltKeyboardType);  gAppleTalkVersion = GetGestaltResult (gestaltAppleTalkVersion);    /* We only concern ourselves with there being an PMMU, not which type it is */  gHasPMMU = GetGestaltResult (gestaltMMUType) &gt;= gestalt68851;  gAUXVersion = GetAUXVersion ();  gHasWaitNextEvent = TrapExists(_WaitNextEvent);  gInBackground = false;  /* 10/16/90 pvh/MacDTSWith GetAppParams(), THINK C in project mode returns the project resource file AND NOT the .rsrc file, which is what one really wants (trust me).  If THINK is present we will return CurResFile() which will be the .rsrc file instead.  The name will still be the project name in project mode, so be aware of that.*/  //GetAppParms(gAppName, &amp;gAppResRef, &amp;apParam);  gAppResRef = CurResFile();      /* returns refNum of .rsrc file */  bndlResource = GetAppIndResource('BNDL', 1, &amp;err);  if (bndlResource)    gSignature = *(OSType *) (*bndlResource);  gUtilitiesInited = true;}/*****************************************************************************//* Check to see if a window belongs to the application.  If the window pointer** passed was NULL, then it could not be an application window.  WindowKinds** that are negative belong to the system and windowKinds less than userKind** are reserved by Apple except for windowKinds equal to dialogKind, which** mean it is a dialog. */  #pragma segment UtilMainBoolean  IsAppWindow(WindowPtr window){  if (window)    return (((WindowPeek)window)-&gt;windowKind &gt;= userKind);  else     return false;}/*****************************************************************************//* Check to see if a window belongs to a desk accessory. */#pragma segment UtilMainBoolean  IsDAWindow(WindowPtr window){  if (window)  /* DA windows have negative windowKinds */    return (((WindowPeek) window)-&gt;windowKind &lt; 0);  else    return false;}/*****************************************************************************/#pragma segment UtilMainvoid  LocalToGlobalRect(Rect *aRect){  LocalToGlobal(&amp;TopLeft(*aRect));  LocalToGlobal(&amp;BotRight(*aRect));}/*****************************************************************************/#pragma segment UtilMainchar  LockHandleHigh(Handle theHandle){  char  hstate;  hstate = HGetState(theHandle);  MoveHHi(theHandle);  HLock(theHandle);  return(hstate);}/*****************************************************************************//* InitGraf is always implemented (trap $A86E).  If the trap table is big** enough, trap $AA6E will always point to either Unimplemented or some other** trap, but will never be the same as InitGraf.  Thus, you can check the size** of the trap table by asking if the address of trap $A86E is the same as** $AA6E. */#pragma segment UtilInitshort  NumToolboxTraps(void){  if (NGetTrapAddress(_InitGraf, ToolTrap) == NGetTrapAddress(0xAA6E, ToolTrap))    return (0x200);  else    return (0x400);}/*****************************************************************************//* Given any control handle, this will draw an outline around it.  This is used** for the default button of a window.  The extra nice feature here is that** I'll erase the outline for buttons that are inactive.  Seems like there** should be a Toolbox call for getting a control's hilite state.  Since there** isn't, I have to look into the control record myself.  This should be called** for update and activate events.**** The method for determining the oval diameters for the roundrect is a little** different than that recommended by Inside Mac. IM I-407 suggests that you** use a hardcoded (16,16) for the diameters.  However, this only looks good** for small roundrects.  For larger ones, the outline doesn't follow the inner** roundrect because the CDEF for simple buttons doesn't use (16,16).  Instead,** it uses half the height of the button as the diameter.  By using this** formula, too, our outlines look better.**** WARNING: This will set the current port to the control's window. */#pragma segment UtilMainvoid  OutlineControl(ControlHandle button){  Rect    theRect;  PenState  curPen;  short    buttonOval;  if (button) {    SetPort((*button)-&gt;contrlOwner);    GetPenState(&amp;curPen);    PenNormal();    theRect = (*button)-&gt;contrlRect;    InsetRect(&amp;theRect, kButtonFrameInset, kButtonFrameInset);    buttonOval = (theRect.bottom - theRect.top) / 2 + 2;    PenPat((*button)-&gt;contrlHilite == kCntlActivate ? &amp;QD(black) : &amp;QD(gray));    PenSize(kButtonFrameSize, kButtonFrameSize);    FrameRoundRect(&amp;theRect, buttonOval, buttonOval);    SetPenState(&amp;curPen);  }}/*****************************************************************************/#pragma segment UtilMainvoid  OutlineDialogItem(DialogPtr dlgPtr, short item){  short iKind;  Handle iHandle;  Rect iRect;  GetDialogItem (dlgPtr, item, &amp;iKind, &amp;iHandle, &amp;iRect);  OutlineControl((ControlHandle) iHandle);}/*****************************************************************************//* Given two rectangles, this function positions the second within the first** one so that it maintains the spacing specified by the horzRatio and** vertRatio parameters.  In other words, to center an inner rectangle** hoizontally, but have its center be 1/3 from the top of the outer rectangle,** call this function with horzRatio = FixRatio (1, 2), vertRatio =** FixRatio(1, 3).  We use Fixed rather than floating point to avoid** complications when mixing MC68881/non-MC68881 versions of Utilities. */#pragma segment UtilMainvoid  PositionRectInRect(Rect outerRect, Rect *innerRect, Fixed horzRatio, Fixed vertRatio){  short    outerRectHeight;  short    outerRectWidth;  short    innerRectHeight;  short    innerRectWidth;  short    yLocation;  short    xLocation;  outerRectHeight = outerRect.bottom - outerRect.top;  outerRectWidth = outerRect.right - outerRect.left;  innerRectHeight = innerRect-&gt;bottom - innerRect-&gt;top;  innerRectWidth = innerRect-&gt;right - innerRect-&gt;left;    yLocation = Fix2Long(FixMul(Long2Fix(outerRectHeight - innerRectHeight), vertRatio))      + outerRect.top;    xLocation = Fix2Long(FixMul(Long2Fix(outerRectWidth - innerRectWidth), horzRatio))      + outerRect.left;  innerRect-&gt;top = yLocation;  innerRect-&gt;left = xLocation;  innerRect-&gt;bottom = yLocation + innerRectHeight;  innerRect-&gt;right = xLocation + innerRectWidth;}/*****************************************************************************//* Concatenate a Pascal string onto another. */#pragma segment UtilMainvoid  PStrConcat(Str255 targetStr, Str255 appendStr){  long appendLen;  /* Figure out number of bytes to copy, up to 255 */  if ((StrLength (targetStr) + StrLength (appendStr)) &gt; 255)    appendLen = 255 - StrLength (targetStr);  else    appendLen = StrLength (appendStr);  if (appendLen &gt; 0) {    BlockMove (appendStr + 1, targetStr + StrLength (targetStr) + 1, appendLen);    targetStr [0] += appendLen;  }}/*****************************************************************************/#pragma segment UtilInitvoid  PullApplicationToFront(void){#define kBroughtToFront 3  EventRecord event;  short    count;  for (count = 1; count &lt;= kBroughtToFront; count++)    EventAvail(everyEvent, &amp;event);}/*****************************************************************************//* Given the button control handle, this will cause the button to look as if it** has been clicked in.  This is nice to do for the user if they type return or** enter to select the default item. */#pragma segment UtilMainvoid  SelectButton(ControlHandle button){  unsigned long      finalTicks;    HiliteControl(button, kSelect);  Delay(kDelayTime, &amp;finalTicks);  HiliteControl(button, kDeselect);}/*****************************************************************************//* Handy function for setting the value of a radio button.  Given a dialog** pointer, and item number, and a state, this function will take care of the** rest. */#pragma segment UtilMainvoid  SetCheckOrRadioButton(DialogPtr dlgPtr, short itemNo, short state){  short  iKind;  Handle  iHandle;  Rect  iRect;  GetDialogItem(dlgPtr, itemNo, &amp;iKind, &amp;iHandle, &amp;iRect);  SetControlValue((ControlHandle) iHandle, state);}/*****************************************************************************//* This algorithm for staggering windows does quite a good job.  It also is** quite gnarly.  Here's the deal:** There are pre-designated positions that we will try when positioning a** window.  These slots will be tried from the upper-left corner towards the** lower-right corner.  If there are other windows in that slot, then we will** consider that slot taken, and proceed to the next slot.  A slot is** determined to be taken by checking a point with a slop area.  This slop** area is diamond-shaped, not simply rectangular.  If there is no other** visible window with an upper-left corner within the slopt diamond, then** we are allowed to position our window there.** The above rule holds true unless this forces the window to be partly** off the screen.  If the window ends up partly off the screen, then we try** a new diagonal just below the first diagonal we tried.  We keep trying** lower and lower diagonals until we find a spot for the window, or the** diagonal doesn't fit on the screen at all.  If the diagonal doesn't fit,** then we try diagonals to the right of the first diagonal.  If even this** doesn't work, then we give up and put the window in the original spot** we tried. */#pragma segment UtilMainRect  StaggerWindow(WindowPtr window, WindowPtr relatedWindow){  WindowPtr  whichDevice, staggerFromWindow;  Rect    deviceRect, oldWindowRect, newWindowRect, slot1;  Rect    testRect, contentRect, staggerFromRect;  Point    delta, absdelta;  Boolean    contained, vertTry;  short    diamondSize, diagNum, tryNum;  if (!(whichDevice = relatedWindow)) whichDevice = window;    /* If we have a window to stagger from, use the device for that window,    ** else use the device for the window that is getting staggered. */  deviceRect = GetWindowDeviceRectNMB(whichDevice);    /* We now have the rect of the device we want to stagger within. */  oldWindowRect = GetWindowStructureRect(window);  newWindowRect.top    = deviceRect.top  + kStartPtV;  newWindowRect.left   = deviceRect.left + kStartPtH;  newWindowRect.bottom = newWindowRect.top  + oldWindowRect.bottom - oldWindowRect.top;  newWindowRect.right  = newWindowRect.left + oldWindowRect.right  - oldWindowRect.left;    /* We now have a new rect for the first window position slot. */  slot1 = newWindowRect;    /* We keep this slot in case we find no acceptable slots.  If we    ** don't find an acceptable one, we will use this one anyway. */  diamondSize = (kStaggerH &lt; kStaggerV) ? kStaggerH : kStaggerV;  for (diagNum = 0, vertTry = true;;) {    for (tryNum = 0;; ++tryNum) {      SectRect(&amp;newWindowRect, &amp;deviceRect, &amp;testRect);      if (!(contained = EqualRect(&amp;newWindowRect, &amp;testRect))) break;        /* Break if the slot we are testing went off the device. */      for (staggerFromWindow = FrontWindow();         staggerFromWindow;         staggerFromWindow =          (WindowPtr)((WindowPeek)staggerFromWindow)-&gt;nextWindow      ) {        if (!((WindowPeek)staggerFromWindow)-&gt;visible) continue;          /* This window is invisible.  Staggering from an invisible          ** window is going to confuse the user, so don't do it. */        testRect = GetWindowDeviceRectNMB(staggerFromWindow);        if (!EqualRect(&amp;testRect, &amp;deviceRect)) continue;          /* This window doesn't belong to the device we are trying to          ** stagger on, so skip it and go to the next window. */        staggerFromRect = GetWindowStructureRect(staggerFromWindow);        delta.v = staggerFromRect.top  - newWindowRect.top;        delta.h = staggerFromRect.left - newWindowRect.left;        if ((absdelta.v = delta.v) &lt; 0) absdelta.v = -delta.v;        if ((absdelta.h = delta.h) &lt; 0) absdelta.h = -delta.h;        if ((absdelta.h + absdelta.v) &lt; diamondSize) {          if ((delta.h + delta.v) &gt; 0)            OffsetRect(&amp;newWindowRect, delta.h, delta.v);              /* If the window that took our slot is closer to              ** the lower-right corner than we are, then use              ** this window's location as the basis for the              ** slots from now on.  This will align new windows              ** with previous windows that are not gridded to              ** the default slot positions.  The check for &gt; 0              ** is necessary to prevent bouncing between two              ** existing windows.  This check guarantees that              ** we are progressing with the evaluation. */          break;            /* Break because this slot is already used. */          }      }      if (!staggerFromWindow) break;        /* If the window pointer is NULL, then we tried all the windows        ** and none of them occupied this slot.  This means that the        ** slot is available for the new window. */        OffsetRect(&amp;newWindowRect, kStaggerH, kStaggerV);        /* Since this slot was taken, try the next slot and go through        ** the window list again. */    }    if (contained) break;    newWindowRect = slot1;    if (!tryNum) {      if (!vertTry) break;    /* Nothing works.  No spots at all. */      vertTry = false;      /* Try across for the next pass. */      diagNum = 0;    }    ++diagNum;    if (vertTry) OffsetRect(&amp;newWindowRect, 0, diagNum * kStaggerV);    else         OffsetRect(&amp;newWindowRect, diagNum * kStaggerH, 0);  }  contentRect = GetWindowContentRect(window);    /* Get where the window is now. */  OffsetRect(&amp;contentRect, newWindowRect.left - oldWindowRect.left,              newWindowRect.top  - oldWindowRect.top);    /* Calculate the new content rect. */  MoveWindow(window, contentRect.left, contentRect.top, false);    /* Move the window to the new location. */  return(contentRect);}/*****************************************************************************/#pragma segment UtilMainvoid  StandardAbout(short appNameStringID){  StringHandle  apNameHndl;  VersRecHndl    curVersion;  Str255      apName;  Str255      verNum = &quot;\p????&quot;;  Ptr        verNumLocation;  OSErr      err;  if (!gUtilitiesInited)        /* Make sure we were initialized */    InitUtilities();      apNameHndl = (StringHandle)NULL;  if (appNameStringID != kUseRealAppName) {    if (appNameStringID != kUseCreatorString)      apNameHndl = GetString(appNameStringID);    if (!apNameHndl)      apNameHndl = (StringHandle) GetAppResource(gSignature, 0, &amp;err);  }  if ((!apNameHndl) || (appNameStringID == kUseRealAppName))    PStrCopy(apName, gAppName);  else    PStrCopy(apName, *apNameHndl);  curVersion = (VersRecHndl) GetAppResource('vers', 1, &amp;err);  if (curVersion) {    verNumLocation = (Ptr) ((long)(*curVersion)-&gt;shortVersion            + (long)*(*curVersion)-&gt;shortVersion + 1);    PStrCopy(verNum, verNumLocation);  }  ParamText(apName, verNum, &quot;\p&quot;, &quot;\p&quot;);  CenteredAlert(rStdAboutAlert, NULL);}/*****************************************************************************/#pragma segment UtilInitvoid  StandardInitialization(short callsToMoreMasters){  InitToolBox();  while (callsToMoreMasters--)    MoreMasters();    PullApplicationToFront();    InitUtilities();}/*****************************************************************************/#pragma segment UtilInitvoid  StandardMenuSetup(short MBARID, short AppleMenuID){  Handle menuBar = GetNewMBar(MBARID);      /* read menus into menu bar */  if (!menuBar)     DeathAlert(rUtilStrings, eNoMenuBar);  SetMenuBar(menuBar);              /* install menus */  DisposeHandle(menuBar);  AppendResMenu(GetMenuHandle(AppleMenuID), 'DRVR');  /* add DA names to Apple menu */  DrawMenuBar();}/*****************************************************************************/#pragma segment UtilMainvoid  ToggleCheck(DialogPtr dlgPtr, short chkItem){  short iKind;  Handle iHandle;  Rect iRect;  GetDialogItem (dlgPtr, chkItem, &amp;iKind, &amp;iHandle, &amp;iRect);  SetControlValue((ControlHandle) iHandle, !GetControlValue((ControlHandle)iHandle));}/*****************************************************************************//* Check to see if a given trap is implemented.  This is only used by the** Initialize function in this program, so we put it in the** Initialize segment. */ #pragma segment UtilInitBoolean TrapExists(short theTrap){  TrapType  theTrapType;  theTrapType = GetTrapType(theTrap);  if ((theTrapType == ToolTrap) &amp;&amp; ((theTrap &amp;= 0x07FF) &gt;= NumToolboxTraps()))    theTrap = _Unimplemented;  return (NGetTrapAddress(_Unimplemented, ToolTrap) != NGetTrapAddress(theTrap,          theTrapType));}/*****************************************************************************//* Zoom the window to the size appropriate for the device that contains the** most of the window.  An additional feature is that you can state the** maximum that a window should be zoomed, either horizontally or vertically.** If you pass in a maximum of 0 for the zoom for either direction, then that** direction will be zoomed to fit the device. */#pragma segment UtilMainvoid  ZoomToWindowDevice(WindowPtr window, short maxWidth, short maxHeight,               short zoomDir, Boolean front){   GrafPtr    oldPort;  Rect    contentRect, structureRect, deviceRect, newRect;  short    width, height, dx, dy;  GetPort(&amp;oldPort);  SetPort(window);  EraseRect(&amp;window-&gt;portRect);     /* Recommended for cosmetic reasons. */  /* If there is the possibility of multiple gDevices, then we must check them to  ** make sure we are zooming onto the right display device when zooming out. */  if ((zoomDir == inZoomOut) &amp;&amp; (gQDVersion &gt; kQDOriginal)) {    contentRect    = GetWindowContentRect(window);    structureRect = GetWindowStructureRect(window);    deviceRect    = GetWindowDeviceRectNMB(window);    deviceRect.left   += (contentRect.left - structureRect.left + 2);    deviceRect.top    += (contentRect.top - structureRect.top + 2);    deviceRect.right  -= (structureRect.right - contentRect.right + 2);    deviceRect.bottom -= (structureRect.bottom - contentRect.bottom + 2);    newRect = deviceRect;    if (maxWidth)      if ((width = deviceRect.right - deviceRect.left) &gt; maxWidth)        newRect.right = (newRect.left = contentRect.left) + maxWidth;    if (maxHeight)      if ((height = deviceRect.bottom - deviceRect.top) &gt; maxHeight)        newRect.bottom = (newRect.top = contentRect.top) + maxHeight;    if ((dx = deviceRect.left - newRect.left) &lt; 0)      if ((dx = deviceRect.right - newRect.right) &gt; 0)        dx = 0;    if ((dy = deviceRect.top - newRect.top) &lt; 0)      if ((dy = deviceRect.bottom - newRect.bottom) &gt; 0)        dy = 0;    OffsetRect(&amp;newRect, dx, dy);    (*(WStateDataHandle)(((WindowPeek)window)-&gt;dataHandle))-&gt;stdState = newRect;      /* Set up the WStateData record for this window. */  }  ZoomWindow(window, zoomDir, front);  SetPort(oldPort);}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/DTS.Utilities/listing1.html%3Fid%3DDTS10000277-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/DTS.Utilities/listing1.html%3Fid%3DDTS10000277-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/DTS.Utilities/listing1.html%3Fid%3DDTS10000277-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>