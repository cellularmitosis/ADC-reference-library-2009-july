<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Object-Oriented Programming with Objective-C: Object-Oriented Programming</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Object-Oriented Programming"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40005149-CH8" title="Object-Oriented Programming"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../DesignGuidelines-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000556" target="_top">Design Guidelines</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP40005149-CH1-SW2">Object-Oriented Programming with Objective-C</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="ooWhy.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="ooObjectModel.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40005149-CH8-SW1" title="Object-Oriented Programming"></a>
    <h1>Object-Oriented Programming</h1>
    
        
            <p>
                <a name="//apple_ref/doc/uid/TP40005149-CH8-DontLinkElementID_2"></a>As humans, we’re constantly faced with myriad facts and impressions that we must make sense of. To do so, we have to abstract underlying structure away from surface details and discover the fundamental relations at work. Abstractions reveal causes and effects, expose patterns and frameworks, and separate what’s important from what’s not. Object-orientation provides an abstraction of the data on which you operate—moreover, it provides a concrete grouping between the data and the operations you can perform with the data, in effect giving the data behavior.
            </p>
        
    
    
        
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="ooOOP.html#//apple_ref/doc/uid/TP40005149-CH8-SW3">Data and Operations</a>
				
			<br/>
			
        
			
			
				<a href="ooOOP.html#//apple_ref/doc/uid/TP40005149-CH8-SW2">Interface and Implementation</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40005149-CH8-SW3" title="Data and Operations"></a>
            <h2>Data and Operations</h2>
            <p>Programming languages have traditionally divided the world into two parts—data and operations on data. Data is static and immutable, except as the operations may change it. The procedures and functions that operate on data have no lasting state of their own; they’re useful only in their ability to affect data.</p>
            <p>This division is, of course, grounded in the way computers work, so it’s not one that you can easily ignore or push aside. Like the equally pervasive distinctions between matter and energy and between nouns and verbs, it forms the background against which we work. At some point, all programmers—even object-oriented programmers—must lay out the data structures that their programs will use and define the functions that will act on the data.</p>
            <p>With a procedural programming language like C, that’s about all there is to it. The language may offer various kinds of support for organizing data and functions, but it won’t divide the world any differently. Functions and data structures are the basic elements of design. 
            </p>
            <p>Object-oriented programming doesn’t so much dispute this view of the world as restructure it at a higher level. It groups operations and data into modular units called <strong>objects</strong>
                <a name="//apple_ref/doc/uid/TP40005149-CH8-DontLinkElementID_3"></a> and lets you combine objects into structured networks to form a complete program. In an object-oriented programming language, objects and object interactions are the basic elements of design.</p>
            <p>Every object has both state (data) and behavior<a name="//apple_ref/doc/uid/TP40005149-CH8-DontLinkElementID_4"></a> (operations on data). In that, they’re not much different from ordinary physical objects. It’s easy to see how a mechanical device, such as a pocket watch or a piano, embodies both state and behavior. But almost anything that’s designed to do a job does, too. Even simple things with no moving parts such as an ordinary bottle combine state (how full the bottle is, whether or not it’s open, how warm its contents are) with behavior (the ability to dispense its contents at various flow rates, to be opened or closed, to withstand high or low temperatures).</p>
            <p>It’s this resemblance to real things that gives objects much of their power and appeal. They can not only model components of real systems, but equally as well fulfill assigned roles as components in software systems.</p>
        
        <a name="//apple_ref/doc/uid/TP40005149-CH8-SW2" title="Interface and Implementation"></a>
            <h2>Interface and Implementation</h2>
            <p>To invent programs, you need to be able to capture abstractions<a name="//apple_ref/doc/uid/TP40005149-CH8-DontLinkElementID_5"></a> and express them in the program design. It’s the job of a programming language to help you do this. The language should facilitate the process of invention and design by letting you encode abstractions that reveal the way things work. It should let you make your ideas concrete in the code you write. Surface details shouldn’t obscure the architecture of your program.</p>
            <p>All programming languages provide devices that help express abstractions. In essence, these devices are ways of grouping implementation details, hiding them, and giving them, at least to some extent, a common interface—much as a mechanical object separates its interface from its implementation, as illustrated in <span class="content_text">“Interface and Implementation.”</span></p>
            <br/><div><a name="//apple_ref/doc/uid/TP40005149-CH8-85774" title="Figure 2-1Interface and Implementation"></a><a name="//apple_ref/doc/uid/TP40005149-CH8-SW4" title="Figure 2-1Interface and Implementation"></a>
                <p><strong>Figure 2-1&nbsp;&nbsp;</strong>Interface and Implementation</p>
                <img src = "../Art/watchcalls_35.gif" alt = "" width="202" height="184">
            </div><br/>
            <p>Looking at such a unit from the inside, as the implementor, you’d be concerned with what it’s composed of and how it works. Looking at it from the outside, as the user, you’re concerned only with what it is and what it does. You can look past the details and think solely in terms of the role that the unit plays at a higher level.</p>
            <p>The principal units of abstraction in the C language are structures and functions<a name="//apple_ref/doc/uid/TP40005149-CH8-DontLinkElementID_6"></a>. Both, in different ways, hide elements of the implementation:</p>
            <ul class="ul">
                <li class="li">
                    <p>On the data side of the world, C structures group data elements into larger units which can then be handled as single entities. While some code must delve inside the structure and manipulate the fields separately, much of the program can regard it as a single thing—not as a collection of elements, but as what those elements taken together represent. One structure can include others, so a complex arrangement of information can be built from simpler layers.</p>
                    <p>In modern C, the fields of a structure live in their own name space—that is, their names won’t conflict with identically named data elements outside the structure. Partitioning the program name space is essential for keeping implementation details out of the interface. Imagine, for example, the enormous task of assigning a different name to every piece of data in a large program and of making sure new names don’t conflict with old ones.</p>
                </li>
                <li class="li">
                    <p>On the procedural side of the world, functions encapsulate behaviors<a name="//apple_ref/doc/uid/TP40005149-CH8-DontLinkElementID_7"></a> that can be used repeatedly without being reimplemented. Data elements local to a function, like the fields within a structure, are protected within their own name space. Functions can reference (call) other functions, so quite complex behaviors can be built from smaller pieces.</p>
                    <p>Functions are reusable<a name="//apple_ref/doc/uid/TP40005149-CH8-DontLinkElementID_8"></a>. Once defined, they can be called any number of times without again considering the implementation. The most generally useful functions can be collected in libraries and reused in many different applications. All the user needs is the function interface, not the source code.</p>
                    <p>However, unlike data elements, functions aren’t partitioned into separate name spaces. Each function must have a unique name. Although the function may be reusable, its name is not.</p>
                </li>
            </ul>
            <p>C structures and functions are able to express significant abstractions, but they maintain the distinction between data and operations on data. In a procedural programming language, the highest units of abstraction still live on one side or the other of the data-versus-operations divide. The programs you design must always reflect, at the highest level, the way the computer works.</p>
            <p>Object-oriented programming languages don’t lose any of the virtues of structures and functions—they go a step further and add a unit capable of abstraction at a higher level, a unit that hides the interaction between a function and its data.</p>
            <p>Suppose, for example, that you have a group of functions that act on a particular data structure. You want to make those functions easier to use by, as far as possible, taking the structure out of the interface. So you supply a few additional functions to manage the data. All the work of manipulating the data structure—allocating it, initializing it, getting information from it, modifying values within it, keeping it up to date, and freeing it—is done through the functions. All the user does is call the functions and pass the structure to them.</p>
            <p>With these changes, the structure has become an opaque token that other programmers never need to look inside. They can concentrate on what the functions do, not how the data is organized. You’ve taken the first step toward creating an object.</p>
            <p>The next step is to give this idea support in the programming language and completely hide the data structure so that it doesn’t even have to be passed between the functions. The data becomes an internal implementation detail; all that’s exported to users is a functional interface. Because objects completely encapsulate their data (hide it), users can think of them solely in terms of their behavior.</p>
            <p>With this step, the interface to the functions has become much simpler. Callers don’t need to know how they’re implemented (what data they use). It’s fair now to call this an “object.”</p>
            <p>The hidden data structure unites all the functions that share access to it. So, an object is more than a collection of random functions; it’s a bundle of related behaviors that are supported by shared data. To use a function that belongs to an object, you first create the object (thus giving it its internal data structure), then tell the object which function it should perform. You begin to think in terms of what the object does, rather than in terms of the individual functions.</p>
            <p>This progression from thinking about functions and data structures to thinking about object behaviors is the essence of learning object-oriented programming. It may seem unfamiliar at first, but as you gain experience with object-oriented programming, you find it’s a more natural way to think about things. Everyday programming terminology is replete with analogies to real-world objects of various kinds—lists, containers, tables, controllers, even managers. Implementing such things as programming objects merely extends the analogy in a natural way.</p>
            <p>A programming language can be judged by the kinds of abstractions that it enables you to encode. You shouldn’t be distracted by extraneous matters or forced to express yourself using a vocabulary that doesn’t match the reality you’re trying to capture.</p>
            <p>If, for example, you must always tend to the business of keeping the right data matched with the right procedure, you’re forced at all times to be aware of the entire program at a low level of implementation. While you might still invent programs at a high level of abstraction, the path from imagination to implementation can become quite tenuous—and more and more difficult as programs become bigger and more complicated.</p>
            <p>By providing another, higher level of abstraction, object-oriented programming languages give you a larger vocabulary and a richer model to program in.<a name="//apple_ref/doc/uid/TP40005149-CH8-DontLinkElementID_9"></a>
            </p>
        
    


        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="ooWhy.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="ooObjectModel.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-11-19<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/OOP_ObjC/Articles/ooOOP.html%3Fid%3DTP40005149-1.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/OOP_ObjC/Articles/ooOOP.html%3Fid%3DTP40005149-1.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/OOP_ObjC/Articles/ooOOP.html%3Fid%3DTP40005149-1.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>