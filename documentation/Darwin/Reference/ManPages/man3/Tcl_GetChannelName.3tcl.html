<html><head><title>Mac OS X Developer Tools
 Manual Page For Tcl_GetChannelName(3tcl)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3tcl/Tcl_GetChannelName" title="Mac OS X Developer Tools
 Manual Page for Tcl_GetChannelName(3tcl)"><a name="//apple_ref/doc/man/3/Tcl_GetChannelName" title="Mac OS X Developer Tools
 Manual Page for Tcl_GetChannelName(3tcl)"><!-- headerDoc=man; indexgroup=Section 3tcl; uid="//apple_ref/doc/man/3tcl/Tcl_GetChannelName"; name=Tcl_GetChannelName(3tcl) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac&nbsp;OS&nbsp;X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>

<p style='text-align:justify;'>This manual page is associated with the Mac&nbsp;OS&nbsp;X
developer tools.  The software or headers described may not be present on your
Mac&nbsp;OS&nbsp;X installation until you install the developer tools
package.  This package is available on your Mac&nbsp;OS&nbsp;X installation DVD,
and the latest versions can be downloaded from
<a href="http://developer.apple.com/tools/download/">developer.apple.com</a>.</p>

<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
Tcl_CreateChannel(3)                       Tcl Library Procedures                       <a href="Tcl_CreateChannel.3tcl.html#//apple_ref/doc/man/3/Tcl_CreateChannel">Tcl_CreateChannel(3)</a>



____________________________________________________________________________________________________________

<b>NAME</b>
       Tcl_CreateChannel,  Tcl_GetChannelInstanceData,  Tcl_GetChannelType, Tcl_GetChannelName, Tcl_GetChan-<font color="#ffffff" class="whiteout">nelHandle,&nbsp;Tcl_GetChannelHandle,</font>
       nelHandle, Tcl_GetChannelMode, Tcl_GetChannelBufferSize, Tcl_SetChannelBufferSize, Tcl_NotifyChannel,
       Tcl_BadChannelOption,  Tcl_ChannelName,  Tcl_ChannelVersion,  Tcl_ChannelBlockModeProc,  Tcl_Channel-<font color="#ffffff" class="whiteout">CloseProc,&nbsp;Tcl_ChannelCloseProc,</font>
       CloseProc, Tcl_ChannelClose2Proc, Tcl_ChannelInputProc,  Tcl_ChannelOutputProc,  Tcl_ChannelSeekProc,
       Tcl_ChannelWideSeekProc,  Tcl_ChannelSetOptionProc,  Tcl_ChannelGetOptionProc,  Tcl_ChannelWatchProc,
       Tcl_ChannelGetHandleProc,    Tcl_ChannelFlushProc,    Tcl_ChannelHandlerProc,    Tcl_IsChannelShared,
       Tcl_IsChannelRegistered,  Tcl_CutChannel, Tcl_SpliceChannel, Tcl_IsChannelExisting, Tcl_ClearChannel-<font color="#ffffff" class="whiteout">Handlers,&nbsp;Tcl_ClearChannelHandlers,</font>
       Handlers, Tcl_GetChannelThread, Tcl_ChannelBuffered - procedures for creating and manipulating  chan-<font color="#ffffff" class="whiteout">nels&nbsp;channels</font>
       nels

<b>SYNOPSIS</b>
       <b>#include</b> <b>&lt;tcl.h&gt;</b>

       Tcl_Channel
       <b>Tcl_CreateChannel</b>(<u>typePtr,</u> <u>channelName,</u> <u>instanceData,</u> <u>mask</u>)

       ClientData
       <b>Tcl_GetChannelInstanceData</b>(<u>channel</u>)

       Tcl_ChannelType *
       <b>Tcl_GetChannelType</b>(<u>channel</u>)

       CONST char *
       <b>Tcl_GetChannelName</b>(<u>channel</u>)

       int
       <b>Tcl_GetChannelHandle</b>(<u>channel,</u> <u>direction,</u> <u>handlePtr</u>)

       Tcl_ThreadId                                                                                          |
       <b>Tcl_GetChannelThread</b>(<u>channel</u>)                                                                         |

       int
       <b>Tcl_GetChannelBufferSize</b>(<u>channel</u>)

       <b>Tcl_SetChannelBufferSize</b>(<u>channel,</u> <u>size</u>)

       <b>Tcl_NotifyChannel</b>(<u>channel,</u> <u>mask</u>)

       int
       <b>Tcl_BadChannelOption</b>(<u>interp,</u> <u>optionName,</u> <u>optionList</u>)

       int                                                                                                   |
       <b>Tcl_IsChannelShared</b>(<u>channel</u>)                                                                          |

       int                                                                                                   |
       <b>Tcl_IsChannelRegistered</b>(<u>interp,</u> <u>channel</u>)                                                              |

       int                                                                                                   |
       <b>Tcl_IsChannelExisting</b>(<u>channelName</u>)                                                                    |

       void                                                                                                  |
       <b>Tcl_CutChannel</b>(<u>channel</u>)                                                                               |

       void                                                                                                  |
       <b>Tcl_SpliceChannel</b>(<u>channel</u>)                                                                            |

       void                                                                                                  |
       <b>Tcl_ClearChannelHandlers</b>(<u>channel</u>)                                                                     |

       int
       <b>Tcl_ChannelBuffered</b>(<u>channel</u>)

       CONST char *
       <b>Tcl_ChannelName</b>(<u>typePtr</u>)

       Tcl_ChannelTypeVersion
       <b>Tcl_ChannelVersion</b>(<u>typePtr</u>)

       Tcl_DriverBlockModeProc *
       <b>Tcl_ChannelBlockModeProc</b>(<u>typePtr</u>)

       Tcl_DriverCloseProc *
       <b>Tcl_ChannelCloseProc</b>(<u>typePtr</u>)

       Tcl_DriverClose2Proc *
       <b>Tcl_ChannelClose2Proc</b>(<u>typePtr</u>)

       Tcl_DriverInputProc *
       <b>Tcl_ChannelInputProc</b>(<u>typePtr</u>)

       Tcl_DriverOutputProc *
       <b>Tcl_ChannelOutputProc</b>(<u>typePtr</u>)

       Tcl_DriverSeekProc *
       <b>Tcl_ChannelSeekProc</b>(<u>typePtr</u>)

       Tcl_DriverWideSeekProc *                                                                              |
       <b>Tcl_ChannelWideSeekProc</b>(<u>typePtr</u>)                                                                      |

       Tcl_DriverSetOptionProc *
       <b>Tcl_ChannelSetOptionProc</b>(<u>typePtr</u>)

       Tcl_DriverGetOptionProc *
       <b>Tcl_ChannelGetOptionProc</b>(<u>typePtr</u>)

       Tcl_DriverWatchProc *
       <b>Tcl_ChannelWatchProc</b>(<u>typePtr</u>)

       Tcl_DriverGetHandleProc *
       <b>Tcl_ChannelGetHandleProc</b>(<u>typePtr</u>)

       Tcl_DriverFlushProc *
       <b>Tcl_ChannelFlushProc</b>(<u>typePtr</u>)

       Tcl_DriverHandlerProc *
       <b>Tcl_ChannelHandlerProc</b>(<u>typePtr</u>)


<b>ARGUMENTS</b>
       Tcl_ChannelType   <u>*typePtr</u>       (in)      Points  to  a structure containing the addresses of proce-<font color="#ffffff" class="whiteout">dures&nbsp;procedures</font>
                                                  dures that can be called to perform I/O  and  other  func-<font color="#ffffff" class="whiteout">tions&nbsp;functions</font>
                                                  tions on the channel.

       CONST char        <u>*channelName</u>   (in)      The  name  of  this channel, such as <b>file3</b>; must not be in
                                                  use by any other channel. Can be NULL, in which  case  the
                                                  channel is created without a name.

       ClientData        <u>instanceData</u>   (in)      Arbitrary  one-word value to be associated with this chan-<font color="#ffffff" class="whiteout">nel.&nbsp;channel.</font>
                                                  nel.  This value is passed to procedures in  <u>typePtr</u>  when
                                                  they are invoked.

       int               <u>mask</u>           (in)      OR-ed  combination  of  <b>TCL_READABLE</b>  and  <b>TCL_WRITABLE</b> to
                                                  indicate whether a channel is readable and writable.

       Tcl_Channel       <u>channel</u>        (in)      The channel to operate on.

       int               <u>direction</u>      (in)      <b>TCL_READABLE</b>   means   the   input   handle   is   wanted;
                                                  <b>TCL_WRITABLE</b> means the output handle is wanted.

       ClientData        <u>*handlePtr</u>     (out)     Points  to the location where the desired OS-specific han-<font color="#ffffff" class="whiteout">dle&nbsp;handle</font>
                                                  dle should be stored.

       int               <u>size</u>           (in)      The size, in bytes, of buffers to allocate in  this  chan-<font color="#ffffff" class="whiteout">nel.&nbsp;channel.</font>
                                                  nel.

       int               <u>mask</u>           (in)      An  OR-ed  combination  of  <b>TCL_READABLE</b>, <b>TCL_WRITABLE</b> and
                                                  <b>TCL_EXCEPTION</b> that indicates events that have occurred  on
                                                  this channel.

       Tcl_Interp        <u>*interp</u>        (in)      Current interpreter. (can be NULL)

       CONST char        <u>*optionName</u>    (in)      Name of the invalid option.

       CONST char        <u>*optionList</u>    (in)      Specific options list (space separated words, without "-")
                                                  to append to the standard generic options  list.   Can  be
                                                  NULL for generic options error message only.

____________________________________________________________________________________________________________


<b>DESCRIPTION</b>
       Tcl  uses  a  two-layered channel architecture. It provides a generic upper layer to enable C and Tcl
       programs to perform input and output using the same APIs for a variety  of  files,  devices,  sockets
       etc. The generic C APIs are described in the manual entry for <b>Tcl_OpenFileChannel</b>.

       The  lower  layer  provides  type-specific  channel drivers for each type of device supported on each
       platform.  This manual entry describes the C APIs used to communicate between the generic  layer  and
       the  type-specific  channel drivers.  It also explains how new types of channels can be added by pro-<font color="#ffffff" class="whiteout">viding&nbsp;providing</font>
       viding new channel drivers.

       Channel drivers consist of a number of components: First, each channel driver provides a <b>Tcl_Channel</b>-<font color="#ffffff" class="whiteout">Type&nbsp;Tcl_ChannelType</font>
       <b>Type</b>  structure  containing  pointers  to  functions  implementing the various operations used by the
       generic layer to communicate with the channel driver. The <b>Tcl_ChannelType</b> structure and the functions
       referenced by it are described in the section TCL_CHANNELTYPE, below.

       Second,  channel  drivers  usually provide a Tcl command to create instances of that type of channel.
       For example, the Tcl <b>open</b> command creates channels that use the file and command channel drivers, and
       the Tcl <b>socket</b> command creates channels that use TCP sockets for network communication.

       Third,  a channel driver optionally provides a C function to open channel instances of that type. For
       example, <b>Tcl_OpenFileChannel</b> opens a channel that uses the file channel driver, and <b>Tcl_OpenTcpClient</b>
       opens  a channel that uses the TCP network protocol.  These creation functions typically use <b>Tcl_Cre</b>-<font color="#ffffff" class="whiteout">ateChannel&nbsp;Tcl_CreateChannel</font>
       <b>ateChannel</b> internally to open the channel.

       To add a new type of channel you must implement a C API or a Tcl command  that  opens  a  channel  by
       invoking  <b>Tcl_CreateChannel</b>.  When your driver calls <b>Tcl_CreateChannel</b> it passes in a <b>Tcl_ChannelType</b>
       structure describing the driver's I/O procedures.  The generic layer will then invoke  the  functions
       referenced in that structure to perform operations on the channel.

       <b>Tcl_CreateChannel</b>  opens  a new channel and associates the supplied <u>typePtr</u> and <u>instanceData</u> with it.
       The channel is opened in the mode indicated by <u>mask</u>.  For a  discussion  of  channel  drivers,  their
       operations and the <b>Tcl_ChannelType</b> structure, see the section TCL_CHANNELTYPE, below.

       <b>Tcl_CreateChannel</b> interacts with the code managing the standard channels. Once a standard channel was
       initialized either through a call to <b>Tcl_GetStdChannel</b> or a call to  <b>Tcl_SetStdChannel</b>  closing  this
       standard  channel will cause the next call to <b>Tcl_CreateChannel</b> to make the new channel the new stan-<font color="#ffffff" class="whiteout">dard&nbsp;standard</font>
       dard channel too. See <b>Tcl_StandardChannels</b> for a general treatise about standard channels and the be-<font color="#ffffff" class="whiteout">haviour&nbsp;behaviour</font>
       haviour of the Tcl library with regard to them.

       <b>Tcl_GetChannelInstanceData</b>  returns the instance data associated with the channel in <u>channel</u>. This is
       the same as the <u>instanceData</u> argument in the call to <b>Tcl_CreateChannel</b> that created this channel.

       <b>Tcl_GetChannelType</b> returns a pointer to the <b>Tcl_ChannelType</b> structure used  by  the  channel  in  the
       <u>channel</u> argument. This is the same as the <u>typePtr</u> argument in the call to <b>Tcl_CreateChannel</b> that cre-<font color="#ffffff" class="whiteout">ated&nbsp;created</font>
       ated this channel.

       <b>Tcl_GetChannelName</b> returns a string containing the name associated with the channel, or NULL  if  the
       <u>channelName</u> argument to <b>Tcl_CreateChannel</b> was NULL.

       <b>Tcl_GetChannelHandle</b>  places  the  OS-specific  device  handle  associated with <u>channel</u> for the given
       <u>direction</u> in the location specified by <u>handlePtr</u> and returns <b>TCL_OK</b>.  If the channel does not have  a
       device  handle  for  the  specified direction, then <b>TCL_ERROR</b> is returned instead.  Different channel
       drivers will return different types of handle.  Refer to the manual entries for each driver to deter-<font color="#ffffff" class="whiteout">mine&nbsp;determine</font>
       mine what type of handle is returned.                                                                 |

       <b>Tcl_GetChannelThread</b>  returns  the  id  of  the thread currently managing the specified <u>channel</u>. This |
       allows channel drivers to send their file events to the correct event queue even for a multi-threaded |
       core.

       <b>Tcl_GetChannelMode</b>  returns an OR-ed combination of <b>TCL_READABLE</b> and <b>TCL_WRITABLE</b>, indicating whether
       the channel is open for input and output.

       <b>Tcl_GetChannelBufferSize</b> returns the size, in bytes, of buffers allocated to store input or output in
       <u>channel</u>.  If  the  value was not set by a previous call to <b>Tcl_SetChannelBufferSize</b>, described below,
       then the default value of 4096 is returned.

       <b>Tcl_SetChannelBufferSize</b> sets the size, in bytes, of buffers that will  be  allocated  in  subsequent
       operations  on  the channel to store input or output. The <u>size</u> argument should be between ten and one
       million, allowing buffers of ten bytes  to  one  million  bytes.  If  <u>size</u>  is  outside  this  range,
       <b>Tcl_SetChannelBufferSize</b> sets the buffer size to 4096.

       <b>Tcl_NotifyChannel</b>  is  called  by  a  channel driver to indicate to the generic layer that the events
       specified by <u>mask</u> have occurred on the channel.  Channel drivers are responsible  for  invoking  this
       function  whenever  the  channel handlers need to be called for the channel.  See <b>WATCHPROC</b> below for
       more details.

       <b>Tcl_BadChannelOption</b> is called from driver specific set or get option procs to  generate  a  complete
       error message.

       <b>Tcl_ChannelBuffered</b>  returns  the  number of bytes of input currently buffered in the internal buffer
       (push back area) of the channel itself. It does not report about the data in the overall buffers  for
       the stack of channels the supplied channel is part of.

       <b>Tcl_IsChannelShared</b>  checks the refcount of the specified <u>channel</u> and returns whether the <u>channel</u> was |
       shared among multiple interpreters (result == 1) or not (result == 0).                                |

       <b>Tcl_IsChannelRegistered</b> checks whether the specified <u>channel</u> is registered in the  given  <u>interp</u>reter |
       (result == 1) or not (result == 0).                                                                   |

       <b>Tcl_IsChannelExisting</b>  checks  whether  a  channel  with  the  specified  name  is  registered in the |
       (thread)-global list of all channels (result == 1) or not (result == 0).                              |

       <b>Tcl_CutChannel</b> removes the specified <u>channel</u> from the (thread)global list of  all  channels  (of  the |
       current thread).  Application to a channel still registered in some interpreter is not allowed.       |

       <b>Tcl_SpliceChannel</b>  adds the specified <u>channel</u> to the (thread)global list of all channels (of the cur- |
       rent thread).  Application to a channel registered in some interpreter is not allowed.                |

       <b>Tcl_ClearChannelHandlers</b> removes all channelhandlers and event scripts associated with the  specified |
       <u>channel</u>, thus shutting down all event processing for this channel.


<b>TCL_CHANNELTYPE</b>
       A channel driver provides a <b>Tcl_ChannelType</b> structure that contains pointers to functions that imple-<font color="#ffffff" class="whiteout">ment&nbsp;implement</font>
       ment the various operations on a channel; these operations are  invoked  as  needed  by  the  generic
       layer.  The structure was versioned starting in Tcl 8.3.2/8.4 to correct a problem with stacked chan-<font color="#ffffff" class="whiteout">nel&nbsp;channel</font>
       nel drivers.  See the <b>OLD</b> <b>CHANNEL</b> <b>TYPES</b> section below for details about the old structure.

       The <b>Tcl_ChannelType</b> structure contains the following fields:
              typedef struct Tcl_ChannelType {
                char *<u>typeName</u>;
                Tcl_ChannelTypeVersion <u>version</u>;
                Tcl_DriverCloseProc *<u>closeProc</u>;
                Tcl_DriverInputProc *<u>inputProc</u>;
                Tcl_DriverOutputProc *<u>outputProc</u>;
                Tcl_DriverSeekProc *<u>seekProc</u>;
                Tcl_DriverSetOptionProc *<u>setOptionProc</u>;
                Tcl_DriverGetOptionProc *<u>getOptionProc</u>;
                Tcl_DriverWatchProc *<u>watchProc</u>;
                Tcl_DriverGetHandleProc *<u>getHandleProc</u>;
                Tcl_DriverClose2Proc *<u>close2Proc</u>;
                Tcl_DriverBlockModeProc *<u>blockModeProc</u>;
                Tcl_DriverFlushProc *<u>flushProc</u>;
                Tcl_DriverHandlerProc *<u>handlerProc</u>;
                Tcl_DriverWideSeekProc *<u>wideSeekProc</u>;
              } Tcl_ChannelType;

       The driver must provide implementations for all functions except <u>blockModeProc</u>, <u>seekProc</u>,  <u>setOption</u>-<font color="#ffffff" class="whiteout">Proc,&nbsp;setOptionProc,</font>
       <u>Proc</u>, <u>getOptionProc</u>, and <u>close2Proc</u>, which may be specified as NULL.  Other functions that can not be
       implemented for this type of device should return <b>EINVAL</b> when invoked to indicate that they  are  not
       implemented,  except  in the case of <u>flushProc</u> and <u>handlerProc</u>, which should specified as NULL if not
       otherwise defined.

       The user should only use the above structure for  <b>Tcl_ChannelType</b>  instantiation.   When  referencing
       fields  in  a <b>Tcl_ChannelType</b> structure, the following functions should be used to obtain the values:
       <b>Tcl_ChannelName</b>,  <b>Tcl_ChannelVersion</b>,  <b>Tcl_ChannelBlockModeProc</b>,  <b>Tcl_ChannelCloseProc</b>,  <b>Tcl_Channel</b>-<font color="#ffffff" class="whiteout">Close2Proc,&nbsp;Tcl_ChannelClose2Proc,</font>
       <b>Close2Proc</b>,    <b>Tcl_ChannelInputProc</b>,    <b>Tcl_ChannelOutputProc</b>,    <b>Tcl_ChannelSeekProc</b>,   <b>Tcl_Channel-</b> |
       <b>WideSeekProc</b>, <b>Tcl_ChannelSetOptionProc</b>, <b>Tcl_ChannelGetOptionProc</b>, <b>Tcl_ChannelWatchProc</b>,  <b>Tcl_Channel</b>-<font color="#ffffff" class="whiteout">GetHandleProc,&nbsp;Tcl_ChannelGetHandleProc,</font>
       <b>GetHandleProc</b>, <b>Tcl_ChannelFlushProc</b>, or <b>Tcl_ChannelHandlerProc</b>.

       The  change  to the structures was made in such a way that standard channel types are binary compati-<font color="#ffffff" class="whiteout">ble.&nbsp;compatible.</font>
       ble.  However, channel types that use stacked channels (ie: TLS, Trf) have new versions to correspond
       to the above change since the previous code for stacked channels had problems.


<b>TYPENAME</b>
       The  <u>typeName</u>  field  contains a null-terminated string that identifies the type of the device imple-<font color="#ffffff" class="whiteout">mented&nbsp;implemented</font>
       mented by this driver, e.g.  <b>file</b> or <b>socket</b>.

       This value can be retrieved with <b>Tcl_ChannelName</b>, which returns a pointer to the string.


<b>VERSION</b>
       The <u>version</u> field should be set to <b>TCL_CHANNEL_VERSION_2</b>.  If it is not set to this  value  <b>TCL_CHAN</b>-<font color="#ffffff" class="whiteout">NEL_VERSION_3,&nbsp;TCL_CHANNEL_VERSION_3,</font>
       <b>NEL_VERSION_3</b>,  then  this  <b>Tcl_ChannelType</b>  is assumed to have the older structure.  See <b>OLD</b> <b>CHANNEL</b>
       <b>TYPES</b> for more details.  While Tcl will recognize and function with either structure,  stacked  chan-<font color="#ffffff" class="whiteout">nels&nbsp;channels</font>
       nels must be of at least <b>TCL_CHANNEL_VERSION_2</b> to function correctly.

       This  value  can  be  retrieved  with <b>Tcl_ChannelVersion</b>, which returns one of <b>TCL_CHANNEL_VERSION_3</b>, |
       <b>TCL_CHANNEL_VERSION_2</b> or <b>TCL_CHANNEL_VERSION_1</b>.


<b>BLOCKMODEPROC</b>
       The <u>blockModeProc</u> field contains the address of a function called by the generic layer to set  block-<font color="#ffffff" class="whiteout">ing&nbsp;blocking</font>
       ing and nonblocking mode on the device.  <u>BlockModeProc</u> should match the following prototype:

              typedef int Tcl_DriverBlockModeProc(
                ClientData <u>instanceData</u>,
                int <u>mode</u>);

       The  <u>instanceData</u> is the same as the value passed to <b>Tcl_CreateChannel</b> when this channel was created.
       The <u>mode</u> argument is either <b>TCL_MODE_BLOCKING</b> or <b>TCL_MODE_NONBLOCKING</b> to set the device into blocking
       or  nonblocking  mode.  The function should return zero if the operation was successful, or a nonzero
       POSIX error code if the operation failed.

       If the operation is successful, the function can modify the supplied <u>instanceData</u> to record that  the
       channel  entered  blocking or nonblocking mode and to implement the blocking or nonblocking behavior.
       For some device types, the blocking and nonblocking behavior can be  implemented  by  the  underlying
       operating system; for other device types, the behavior must be emulated in the channel driver.

       This value can be retrieved with <b>Tcl_ChannelBlockModeProc</b>, which returns a pointer to the function.

       A  channel  driver  <b>not</b>  supplying  a  <u>blockModeProc</u> has to be very, very careful. It has to tell the
       generic layer exactly which blocking mode is acceptable to it, and should this also document for  the
       user  so that the blocking mode of the channel is not changed to an inacceptable value. Any confusion
       here may lead the interpreter into a (spurious and difficult to find) deadlock.



<b>CLOSEPROC</b> <b>AND</b> <b>CLOSE2PROC</b>
       The <u>closeProc</u> field contains the address of a function called  by  the  generic  layer  to  clean  up
       driver-related information when the channel is closed. <u>CloseProc</u> must match the following prototype:

              typedef int Tcl_DriverCloseProc(
                ClientData <u>instanceData</u>,
                Tcl_Interp *<u>interp</u>);

       The <u>instanceData</u> argument is the same as the value provided to <b>Tcl_CreateChannel</b> when the channel was
       created. The function should release any storage maintained by the channel driver for  this  channel,
       and close the input and output devices encapsulated by this channel. All queued output will have been
       flushed to the device before this function is called,  and  no  further  driver  operations  will  be
       invoked  on this instance after calling the <u>closeProc</u>. If the close operation is successful, the pro-<font color="#ffffff" class="whiteout">cedure&nbsp;procedure</font>
       cedure should return zero; otherwise it should return a nonzero POSIX error code. In addition, if  an
       error occurs and <u>interp</u> is not NULL, the procedure should store an error message in the interpreter's
       result.

       Alternatively, channels that support closing the read and write sides independently may set <u>closeProc</u>
       to  <b>TCL_CLOSE2PROC</b>  and set <u>close2Proc</u> to the address of a function that matches the following proto-<font color="#ffffff" class="whiteout">type:&nbsp;prototype:</font>
       type:

              typedef int Tcl_DriverClose2Proc(
                ClientData <u>instanceData</u>,
                Tcl_Interp *<u>interp</u>,
                int <u>flags</u>);

       The <u>close2Proc</u> will  be  called  with  <u>flags</u>  set  to  an  OR'ed  combination  of  <b>TCL_CLOSE_READ</b>  or
       <b>TCL_CLOSE_WRITE</b>  to  indicate that the driver should close the read and/or write side of the channel.
       The channel driver may be invoked to perform additional operations on the channel after <u>close2Proc</u> is
       called  to close one or both sides of the channel.  If <u>flags</u> is <b>0</b> (zero), the driver should close the
       channel in the manner described above for <u>closeProc</u>.  No further operations will be invoked  on  this
       instance  after  <u>close2Proc</u>  is called with all flags cleared.  In all cases, the <u>close2Proc</u> function
       should return zero if the close operation was successful; otherwise it should return a nonzero  POSIX
       error  code.  In  addition,  if an error occurs and <u>interp</u> is not NULL, the procedure should store an
       error message in the interpreter's result.

       These value can be retrieved with <b>Tcl_ChannelCloseProc</b>  or  <b>Tcl_ChannelClose2Proc</b>,  which  returns  a
       pointer to the respective function.


<b>INPUTPROC</b>
       The  <u>inputProc</u> field contains the address of a function called by the generic layer to read data from
       the file or device and store it in an internal buffer. <u>InputProc</u> must match the following prototype:

              typedef int Tcl_DriverInputProc(
                ClientData <u>instanceData</u>,
                char *<u>buf</u>,
                int <u>bufSize</u>,
                int *<u>errorCodePtr</u>);

       <u>InstanceData</u> is the same as the value passed to <b>Tcl_CreateChannel</b> when the channel was created.   The
       <u>buf</u>  argument  points  to  an array of bytes in which to store input from the device, and the <u>bufSize</u>
       argument indicates how many bytes are available at <u>buf</u>.

       The <u>errorCodePtr</u> argument points to an integer variable provided by the generic layer.  If  an  error
       occurs,  the  function  should  set the variable to a POSIX error code that identifies the error that
       occurred.

       The function should read data from the input device encapsulated by the channel and store it at  <u>buf</u>.
       On success, the function should return a nonnegative integer indicating how many bytes were read from
       the input device and stored at <u>buf</u>. On error, the function should return -1. If an error occurs after
       some data has been read from the device, that data is lost.

       If  <u>inputProc</u>  can determine that the input device has some data available but less than requested by
       the <u>bufSize</u> argument, the function should only attempt to read as  much  data  as  is  available  and
       return  without  blocking. If the input device has no data available whatsoever and the channel is in
       nonblocking mode, the function should return an <b>EAGAIN</b> error. If the input device has no data  avail-<font color="#ffffff" class="whiteout">able&nbsp;available</font>
       able  whatsoever and the channel is in blocking mode, the function should block for the shortest pos-<font color="#ffffff" class="whiteout">sible&nbsp;possible</font>
       sible time until at least one byte of data can be read from the device; then,  it  should  return  as
       much data as it can read without blocking.

       This value can be retrieved with <b>Tcl_ChannelInputProc</b>, which returns a pointer to the function.


<b>OUTPUTPROC</b>
       The  <u>outputProc</u> field contains the address of a function called by the generic layer to transfer data
       from an internal buffer to the output device.  <u>OutputProc</u> must match the following prototype:

              typedef int Tcl_DriverOutputProc(
                ClientData <u>instanceData</u>,
                CONST char *<u>buf</u>,
                int <u>toWrite</u>,
                int *<u>errorCodePtr</u>);

       <u>InstanceData</u> is the same as the value passed to <b>Tcl_CreateChannel</b> when the channel was  created.  The
       <u>buf</u>  argument  contains an array of bytes to be written to the device, and the <u>toWrite</u> argument indi-<font color="#ffffff" class="whiteout">cates&nbsp;indicates</font>
       cates how many bytes are to be written from the <u>buf</u> argument.

       The <u>errorCodePtr</u> argument points to an integer variable provided by the generic layer.  If  an  error
       occurs, the function should set this variable to a POSIX error code that identifies the error.

       The  function  should write the data at <u>buf</u> to the output device encapsulated by the channel. On suc-<font color="#ffffff" class="whiteout">cess,&nbsp;success,</font>
       cess, the function should return a nonnegative integer indicating how many bytes were written to  the
       output  device.  The return value is normally the same as <u>toWrite</u>, but may be less in some cases such
       as if the output operation is interrupted by a signal. If an error occurs the function should  return
       -1.  In case of error, some data may have been written to the device.

       If  the  channel  is  nonblocking  and the output device is unable to absorb any data whatsoever, the
       function should return -1 with an <b>EAGAIN</b> error without writing any data.

       This value can be retrieved with <b>Tcl_ChannelOutputProc</b>, which returns a pointer to the function.


<b>SEEKPROC</b> <b>AND</b> <b>WIDESEEKPROC</b>
       The <u>seekProc</u> field contains the address of a function called by the generic layer to move the  access
       point at which subsequent input or output operations will be applied. <u>SeekProc</u> must match the follow-<font color="#ffffff" class="whiteout">ing&nbsp;following</font>
       ing prototype:

              typedef int Tcl_DriverSeekProc(
                ClientData <u>instanceData</u>,
                long <u>offset</u>,
                int <u>seekMode</u>,
                int *<u>errorCodePtr</u>);

       The <u>instanceData</u> argument is the same as the value given to <b>Tcl_CreateChannel</b> when this  channel  was
       created.   <u>Offset</u>  and <u>seekMode</u> have the same meaning as for the <b>Tcl_Seek</b> procedure (described in the
       manual entry for <b>Tcl_OpenFileChannel</b>).

       The <u>errorCodePtr</u> argument points to an integer variable provided by the generic layer  for  returning
       <b>errno</b>  values  from  the function.  The function should set this variable to a POSIX error code if an
       error occurs.  The function should store an <b>EINVAL</b> error code if the channel type does not  implement
       seeking.

       The  return  value is the new access point or -1 in case of error. If an error occurred, the function
       should not move the access point.

       If there is a non-NULL <u>seekProc</u> field, the <u>wideSeekProc</u> field may contain the address of an  alterna- |
       tive  function  to use which handles wide (i.e. larger than 32-bit) offsets, so allowing seeks within |
       files larger than 2GB.  The <u>wideSeekProc</u> will be called in preference to the <u>seekProc</u>, but both  must |
       be defined if the <u>wideSeekProc</u> is defined.  <u>WideSeekProc</u> must match the following prototype:          |

              typedef Tcl_WideInt Tcl_DriverWideSeekProc(                                                    |
                ClientData <u>instanceData</u>,                                                                     |
                Tcl_WideInt <u>offset</u>,                                                                          |
                int <u>seekMode</u>,                                                                                |
                int *<u>errorCodePtr</u>);                                                                          |

       The  arguments  and return values mean the same thing as with <u>seekProc</u> above, except that the type of |
       offsets and the return type are different.                                                            |

       The <u>seekProc</u> value can be retrieved with <b>Tcl_ChannelSeekProc</b>, which returns a pointer  to  the  func- |
       tion, and similarly the <u>wideSeekProc</u> can be retrieved with <b>Tcl_ChannelWideSeekProc</b>.


<b>SETOPTIONPROC</b>
       The <u>setOptionProc</u> field contains the address of a function called by the generic layer to set a chan-<font color="#ffffff" class="whiteout">nel&nbsp;channel</font>
       nel type specific option on a channel.  <u>setOptionProc</u> must match the following prototype:

              typedef int Tcl_DriverSetOptionProc(
                ClientData <u>instanceData</u>,
                Tcl_Interp *<u>interp</u>,
                CONST char *<u>optionName</u>,
                CONST char *<u>newValue</u>);

       <u>optionName</u> is the name of an option to set, and <u>newValue</u> is the new  value  for  that  option,  as  a
       string.  The  <u>instanceData</u>  is the same as the value given to <b>Tcl_CreateChannel</b> when this channel was
       created. The function should do whatever channel type specific action is required  to  implement  the
       new value of the option.

       Some  options  are  handled  by  the generic code and this function is never called to set them, e.g.
       <b>-blockmode</b>. Other options are specific to each channel type and the <u>setOptionProc</u>  procedure  of  the
       channel  driver  will  get called to implement them. The <u>setOptionProc</u> field can be NULL, which indi-<font color="#ffffff" class="whiteout">cates&nbsp;indicates</font>
       cates that this channel type supports no type specific options.

       If the option value is successfully modified to the new  value,  the  function  returns  <b>TCL_OK</b>.   It
       should  call  <b>Tcl_BadChannelOption</b>  which itself returns <b>TCL_ERROR</b> if the <u>optionName</u> is unrecognized.
       If <u>newValue</u> specifies a value for the option that is not supported or if a system call error  occurs,
       the  function  should leave an error message in the <u>result</u> field of <u>interp</u> if <u>interp</u> is not NULL. The
       function should also call <b>Tcl_SetErrno</b> to store an appropriate POSIX error code.

       This value can be retrieved with <b>Tcl_ChannelSetOptionProc</b>, which returns a pointer to the function.


<b>GETOPTIONPROC</b>
       The <u>getOptionProc</u> field contains the address of a function called by the generic  layer  to  get  the
       value  of  a channel type specific option on a channel. <u>getOptionProc</u> must match the following proto-<font color="#ffffff" class="whiteout">type:&nbsp;prototype:</font>
       type:

              typedef int Tcl_DriverGetOptionProc(
                ClientData <u>instanceData</u>,
                Tcl_Interp *<u>interp</u>,
                CONST char *<u>optionName</u>,
                Tcl_DString *<u>optionValue</u>);

       <u>OptionName</u> is the name of an option supported by this type of channel. If  the  option  name  is  not
       NULL,  the function stores its current value, as a string, in the Tcl dynamic string <u>optionValue</u>.  If
       <u>optionName</u> is NULL, the function stores in <u>optionValue</u> an alternating list of all  supported  options
       and their current values.  On success, the function returns <b>TCL_OK</b>.  It should call <b>Tcl_BadChannelOp</b>-<font color="#ffffff" class="whiteout">tion&nbsp;Tcl_BadChannelOption</font>
       <b>tion</b> which itself returns <b>TCL_ERROR</b> if the <u>optionName</u> is unrecognized. If a system call error occurs,
       the  function  should leave an error message in the result of <u>interp</u> if <u>interp</u> is not NULL. The func-<font color="#ffffff" class="whiteout">tion&nbsp;function</font>
       tion should also call <b>Tcl_SetErrno</b> to store an appropriate POSIX error code.

       Some options are handled by the generic code and this function is  never  called  to  retrieve  their
       value,  e.g. <b>-blockmode</b>. Other options are specific to each channel type and the <u>getOptionProc</u> proce-<font color="#ffffff" class="whiteout">dure&nbsp;procedure</font>
       dure of the channel driver will get called to implement them. The <u>getOptionProc</u> field  can  be  NULL,
       which indicates that this channel type supports no type specific options.

       This value can be retrieved with <b>Tcl_ChannelGetOptionProc</b>, which returns a pointer to the function.


<b>WATCHPROC</b>
       The  <u>watchProc</u> field contains the address of a function called by the generic layer to initialize the
       event notification mechanism to notice events of interest on this channel.   <u>WatchProc</u>  should  match
       the following prototype:

              typedef void Tcl_DriverWatchProc(
                ClientData <u>instanceData</u>,
                int <u>mask</u>);

       The  <u>instanceData</u> is the same as the value passed to <b>Tcl_CreateChannel</b> when this channel was created.
       The <u>mask</u> argument is an OR-ed combination of <b>TCL_READABLE</b>, <b>TCL_WRITABLE</b> and <b>TCL_EXCEPTION</b>;  it  indi-<font color="#ffffff" class="whiteout">cates&nbsp;indicates</font>
       cates events the caller is interested in noticing on this channel.

       The function should initialize device type specific mechanisms to notice when an event of interest is
       present on the channel.  When one or more of the designated events occurs on the channel, the channel
       driver is responsible for calling <b>Tcl_NotifyChannel</b> to inform the generic channel module.  The driver
       should take care not to starve other channel drivers or sources of callbacks by invoking  Tcl_Notify-<font color="#ffffff" class="whiteout">Channel&nbsp;Tcl_NotifyChannel</font>
       Channel  too  frequently.   Fairness can be insured by using the Tcl event queue to allow the channel
       event to be scheduled in sequence with other events.   See  the  description  of  <b>Tcl_QueueEvent</b>  for
       details on how to queue an event.

       This value can be retrieved with <b>Tcl_ChannelWatchProc</b>, which returns a pointer to the function.


<b>GETHANDLEPROC</b>
       The  <u>getHandleProc</u> field contains the address of a function called by the generic layer to retrieve a
       device-specific handle from the channel.  <u>GetHandleProc</u> should match the following prototype:

              typedef int Tcl_DriverGetHandleProc(
                ClientData <u>instanceData</u>,
                int <u>direction</u>,
                ClientData *<u>handlePtr</u>);

       <u>InstanceData</u> is the same as the value passed to <b>Tcl_CreateChannel</b> when this channel was created.  The
       <u>direction</u>  argument  is either <b>TCL_READABLE</b> to retrieve the handle used for input, or <b>TCL_WRITABLE</b> to
       retrieve the handle used for output.

       If the channel implementation has device-specific handles, the function should retrieve the appropri-<font color="#ffffff" class="whiteout">ate&nbsp;appropriate</font>
       ate  handle  associated  with  the  channel,  according the <u>direction</u> argument.  The handle should be
       stored in the location referred to by <u>handlePtr</u>, and <b>TCL_OK</b> should be returned.  If  the  channel  is
       not  open  for the specified direction, or if the channel implementation does not use device handles,
       the function should return <b>TCL_ERROR</b>.

       This value can be retrieved with <b>Tcl_ChannelGetHandleProc</b>, which returns a pointer to the function.


<b>FLUSHPROC</b>
       The <u>flushProc</u> field is currently reserved for future use.  It  should  be  set  to  NULL.   <u>FlushProc</u>
       should match the following prototype:

              typedef int Tcl_DriverFlushProc(
                ClientData <u>instanceData</u>);

       This value can be retrieved with <b>Tcl_ChannelFlushProc</b>, which returns a pointer to the function.


<b>HANDLERPROC</b>
       The  <u>handlerProc</u>  field  contains the address of a function called by the generic layer to notify the
       channel that an event occurred.  It should be defined for stacked channel drivers  that  wish  to  be
       notified of events that occur on the underlying (stacked) channel.  <u>HandlerProc</u> should match the fol-<font color="#ffffff" class="whiteout">lowing&nbsp;following</font>
       lowing prototype:

              typedef int Tcl_DriverHandlerProc(
                ClientData <u>instanceData</u>,
                int <u>interestMask</u>);

       <u>InstanceData</u> is the same as the value passed to <b>Tcl_CreateChannel</b> when this channel was created.  The
       <u>interestMask</u> is an OR-ed combination of <b>TCL_READABLE</b> or <b>TCL_WRITABLE</b>; it indicates what type of event
       occurred on this channel.

       This value can be retrieved with <b>Tcl_ChannelHandlerProc</b>, which returns a pointer to the function.


<b>TCL_BADCHANNELOPTION</b>
       This procedure generates a "bad option" error message in an (optional) interpreter.  It  is  used  by
       channel drivers when a invalid Set/Get option is requested. Its purpose is to concatenate the generic
       options list to the specific ones and factorize the generic options error message string.

       It always return <b>TCL_ERROR</b>

       An error message is generated in <u>interp</u>'s result object to indicate that a command was  invoked  with
       the a bad option The message has the form
                  bad option "blah": should be one of
                  &lt;...generic options...&gt;+&lt;...specific options...&gt;
              so you get for instance:
                  bad option "-blah": should be one of -blocking,
                  -buffering, -buffersize, -eofchar, -translation,
                  -peername, or -sockname
              when called with <u>optionList</u>="peername sockname"
       ``blah''  is the <u>optionName</u> argument and ``&lt;specific options&gt;'' is a space separated list of specific
       option words.  The function takes good care of inserting  minus  signs  before  each  option,  commas
       after, and an ``or'' before the last option.


<b>OLD</b> <b>CHANNEL</b> <b>TYPES</b>
       The original (8.3.1 and below) <b>Tcl_ChannelType</b> structure contains the following fields:

              typedef struct Tcl_ChannelType {
                char *<u>typeName</u>;
                Tcl_DriverBlockModeProc *<u>blockModeProc</u>;
                Tcl_DriverCloseProc *<u>closeProc</u>;
                Tcl_DriverInputProc *<u>inputProc</u>;
                Tcl_DriverOutputProc *<u>outputProc</u>;
                Tcl_DriverSeekProc *<u>seekProc</u>;
                Tcl_DriverSetOptionProc *<u>setOptionProc</u>;
                Tcl_DriverGetOptionProc *<u>getOptionProc</u>;
                Tcl_DriverWatchProc *<u>watchProc</u>;
                Tcl_DriverGetHandleProc *<u>getHandleProc</u>;
                Tcl_DriverClose2Proc *<u>close2Proc</u>;
              } Tcl_ChannelType;

       It  is  still  possible  to  create channel with the above structure.  The internal channel code will
       determine the version.  It is imperative to use the new <b>Tcl_ChannelType</b> structure if you are creating
       a  stacked  channel driver, due to problems with the earlier stacked channel implementation (in 8.2.0
       to 8.3.1).

       Prior to 8.4.0 (i.e. during the later releases of 8.3 and early part of the  8.4  development  cycle) |
       the <b>Tcl_ChannelType</b> structure contained the following fields:                                         |

              typedef struct Tcl_ChannelType {                                                               |
                char *<u>typeName</u>;                                                                              |
                Tcl_ChannelTypeVersion <u>version</u>;                                                              |
                Tcl_DriverCloseProc *<u>closeProc</u>;                                                              |
                Tcl_DriverInputProc *<u>inputProc</u>;                                                              |
                Tcl_DriverOutputProc *<u>outputProc</u>;                                                            |
                Tcl_DriverSeekProc *<u>seekProc</u>;                                                                |
                Tcl_DriverSetOptionProc *<u>setOptionProc</u>;                                                      |
                Tcl_DriverGetOptionProc *<u>getOptionProc</u>;                                                      |
                Tcl_DriverWatchProc *<u>watchProc</u>;                                                              |
                Tcl_DriverGetHandleProc *<u>getHandleProc</u>;                                                      |
                Tcl_DriverClose2Proc *<u>close2Proc</u>;                                                            |
                Tcl_DriverBlockModeProc *<u>blockModeProc</u>;                                                      |
                Tcl_DriverFlushProc *<u>flushProc</u>;                                                              |
                Tcl_DriverHandlerProc *<u>handlerProc</u>;                                                          |
              } Tcl_ChannelType;                                                                             |

       When  the  above  structure  is  registered  as  a  channel  type, the <u>version</u> field should always be |
       <b>TCL_CHANNEL_VERSION_2</b>.


<b>SEE</b> <b>ALSO</b>
       <a href="Tcl_Close.3tcl.html#//apple_ref/doc/man/3/Tcl_Close">Tcl_Close(3)</a>,  <a href="Tcl_OpenFileChannel.3tcl.html#//apple_ref/doc/man/3/Tcl_OpenFileChannel">Tcl_OpenFileChannel(3)</a>,   <a href="Tcl_SetErrno.3tcl.html#//apple_ref/doc/man/3/Tcl_SetErrno">Tcl_SetErrno(3)</a>,   <a href="Tcl_QueueEvent.3tcl.html#//apple_ref/doc/man/3/Tcl_QueueEvent">Tcl_QueueEvent(3)</a>,   <a href="Tcl_StackChannel.3tcl.html#//apple_ref/doc/man/3/Tcl_StackChannel">Tcl_StackChannel(3)</a>,
       <a href="Tcl_GetStdChannel.3tcl.html#//apple_ref/doc/man/3/Tcl_GetStdChannel">Tcl_GetStdChannel(3)</a>


<b>KEYWORDS</b>
       blocking, channel driver, channel registration, channel type, nonblocking



Tcl                                                  8.3                                <a href="Tcl_CreateChannel.3tcl.html#//apple_ref/doc/man/3/Tcl_CreateChannel">Tcl_CreateChannel(3)</a>
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/Tcl_GetChannelName.3tcl.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/Tcl_GetChannelName.3tcl.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/Tcl_GetChannelName.3tcl.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
