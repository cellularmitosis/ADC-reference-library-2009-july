<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>CFNetwork Programming Guide: Working with Streams</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Working with Streams"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30001132-CH6" title="Working with Streams"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000429" target="_top">Networking</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP30001132-CH1-DontLinkElementID_24">CFNetwork Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Concepts/Concepts.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../CFHTTPTasks/CFHTTPTasks.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30001132-CH6-SW1" title="Working with Streams"></a><h1>Working with Streams</h1><p>This chapter discusses how to create, open, and check for errors on read and write streams. It also describes how to read from a read stream, how to write to a write stream, how to prevent blocking when reading from or writing to a stream, and how to navigate a stream through a proxy server.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="CFStreamTasks.html#//apple_ref/doc/uid/TP30000230-61466">Working with Read Streams</a>
				
			<br/>
			
        
			
			
				<a href="CFStreamTasks.html#//apple_ref/doc/uid/TP30000230-61801">Working with Write Streams</a>
				
			<br/>
			
        
			
			
				<a href="CFStreamTasks.html#//apple_ref/doc/uid/TP30001132-CH6-SW19">Preventing Blocking When Working with Streams</a>
				
			<br/>
			
        
			
			
				<a href="CFStreamTasks.html#//apple_ref/doc/uid/TP30001132-CH6-DontLinkElementID_12">Navigating Firewalls</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30000230-61466" title="Working with Read Streams"></a><h2>Working with Read Streams</h2><p>Start by creating a read stream. <span class="content_text">Listing 2-1</span> creates a read stream for a file.</p><a name="//apple_ref/doc/uid/TP30001132-CH6-SW2" title="Listing 2-1Creating a read stream from a file"></a><p class="codesample"><strong>Listing 2-1&nbsp;&nbsp;</strong>Creating a read stream from a file</p><div class="codesample"><table><tr><td scope="row"><pre>CFReadStreamRef myReadStream = CFReadStreamCreateWithFile(kCFAllocatorDefault, fileURL);<span></span></pre></td></tr></table></div><p>In this listing, the <code>kCFAllocatorDefault</code> parameter specifies that the current default system allocator be used to allocate memory for the stream and the <code>fileURL</code> parameter specifies the name of the file for which this read stream is being created, such as <code>file:///Users/joeuser/Downloads/MyApp.sit</code>.</p><p>Now that the stream has been created, it can be opened. Opening a stream causes the stream to reserve any system resources that it requires, such as the file descriptor needed to open the file. <span class="content_text">Listing 2-2</span> is an example of opening the read stream.</p><a name="//apple_ref/doc/uid/TP30001132-CH6-SW3" title="Listing 2-2Opening a read stream"></a><p class="codesample"><strong>Listing 2-2&nbsp;&nbsp;</strong>Opening a read stream</p><div class="codesample"><table><tr><td scope="row"><pre>if (!CFReadStreamOpen(myReadStream)) {<span></span></pre></td></tr><tr><td scope="row"><pre>    CFStreamError myErr = CFReadStreamGetError(myReadStream);<span></span></pre></td></tr><tr><td scope="row"><pre>    // An error has occurred.<span></span></pre></td></tr><tr><td scope="row"><pre>        if (myErr.domain == kCFStreamErrorDomainPOSIX) {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Interpret myErr.error as a UNIX errno.<span></span></pre></td></tr><tr><td scope="row"><pre>        } else if (myErr.domain == kCFStreamErrorDomainMacOSStatus) {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Interpret myErr.error as a MacOS error code.<span></span></pre></td></tr><tr><td scope="row"><pre>            OSStatus macError = (OSStatus)myErr.error;<span></span></pre></td></tr><tr><td scope="row"><pre>        // Check other error domains.<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The <code>CFReadStreamOpen</code> function returns <code>TRUE</code> to indicate success and <code>FALSE</code> if the open fails for any reason. If <code>CFReadStreamOpen</code> returns <code>FALSE</code>, the example calls the <code>CFReadStreamGetError</code> function, which returns a structure of type <code>CFStreamError</code> consisting of two values: a domain code and an error code. The domain code indicates how the error code should be interpreted. For example, if the domain code is <code>kCFStreamErrorDomainPOSIX</code>, the error code is a UNIX <code>errno</code> value. The other error domains are <code>kCFStreamErrorDomainMacOSStatus</code>, which indicates that the error code is an <code>OSStatus</code> value defined in <code>MacErrors.h</code>, and <code>kCFStreamErrorDomainHTTP</code>, which indicates that the error code is the one of the values defined by the <code>CFStreamErrorHTTP</code> enumeration.</p><p>Opening a stream can be a lengthy process, so the <code>CFReadStreamOpen</code> and <code>CFWriteStreamOpen</code> functions avoid blocking by returning <code>TRUE</code> to indicate that the process of opening the stream has begun. To check the status of the open, call the functions <code>CFReadStreamGetStatus</code> and <code>CFWriteStreamGetStatus</code>, which return <code>kCFStreamStatusOpening</code> if the open is still in progress, <code>kCFStreamStatusOpen</code> if the open is complete, or <code>kCFStreamStatusErrorOccurred</code> if the open has completed but failed. In most cases, it doesn’t matter whether the open is complete because the CFStream functions that read and write will block until the stream is open.</p><p>To read from a read stream, call the function <code>CFReadStreamRead</code>, which is similar to the UNIX <code>read()</code> system call. Both take buffer and buffer length parameters. Both return the number of bytes read, <code>0</code> if at the end of stream or file, or <code>-1</code> if an error occurred. Both block until at least one byte can be read, and both continue reading as long as they can do so without blocking. <span class="content_text">Listing 2-3</span> is an example of reading from the read stream.</p><a name="//apple_ref/doc/uid/TP30001132-CH6-SW4" title="Listing 2-3Reading from a read stream (blocking)"></a><p class="codesample"><strong>Listing 2-3&nbsp;&nbsp;</strong>Reading from a read stream (blocking)</p><div class="codesample"><table><tr><td scope="row"><pre>CFIndex numBytesRead;<span></span></pre></td></tr><tr><td scope="row"><pre>do {<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt8 buf[kReadBufSize];<span></span></pre></td></tr><tr><td scope="row"><pre>    numBytesRead = CFReadStreamRead(myReadStream, buf, sizeof(buf));<span></span></pre></td></tr><tr><td scope="row"><pre>    if( numBytesRead > 0 ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        handleBytes(buf, numBytesRead);<span></span></pre></td></tr><tr><td scope="row"><pre>    } else if( numBytesRead &lt; 0 ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        CFStreamError error = CFReadStreamGetError(myReadStream);<span></span></pre></td></tr><tr><td scope="row"><pre>        reportError(error);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>} while( numBytesRead > 0 );<span></span></pre></td></tr></table></div><p>When all data has been read, you should call the <code>CFReadStreamClose</code> function to close the stream, thereby releasing system resources associated with it. Then release the stream reference by calling the function <code><a href="../../../../CoreFoundation/Reference/CFTypeRef/Reference/reference.html#//apple_ref/doc/c_ref/CFRelease" target="_top">CFRelease</a></code>. You may also want to invalidate the reference by setting it to <code>NULL</code>. See <span class="content_text">Listing 2-4</span> for an example.</p><a name="//apple_ref/doc/uid/TP30001132-CH6-SW5" title="Listing 2-4Releasing a read stream"></a><p class="codesample"><strong>Listing 2-4&nbsp;&nbsp;</strong>Releasing a read stream</p><div class="codesample"><table><tr><td scope="row"><pre>CFReadStreamClose(myReadStream);<span></span></pre></td></tr><tr><td scope="row"><pre>CFRelease(myReadStream);<span></span></pre></td></tr><tr><td scope="row"><pre>myReadStream = NULL;<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000230-61801" title="Working with Write Streams"></a><h2>Working with Write Streams</h2><p>Working with write streams is similar to working with read streams. One major difference is that the function <code><a href="../../../../CoreFoundation/Reference/CFWriteStreamRef/Reference/reference.html#//apple_ref/doc/c_ref/CFWriteStreamWrite" target="_top">CFWriteStreamWrite</a></code> does not guarantee to accept all of the bytes that you pass it. Instead, <code>CFWriteStreamWrite</code> returns the number of bytes that it accepted. You'll notice in the sample code shown in <span class="content_text">Listing 2-5</span> that if the number of bytes written is not the same as the total number of bytes to be written, the buffer is adjusted to accommodate this.</p><a name="//apple_ref/doc/uid/TP30001132-CH6-SW6" title="Listing 2-5Creating, opening, writing to, and releasing a write stream"></a><p class="codesample"><strong>Listing 2-5&nbsp;&nbsp;</strong>Creating, opening, writing to, and releasing a write stream</p><div class="codesample"><table><tr><td scope="row"><pre>CFWriteStreamRef myWriteStream =<span></span></pre></td></tr><tr><td scope="row"><pre>        CFWriteStreamCreateWithFile(kCFAllocatorDefault, fileURL);<span></span></pre></td></tr><tr><td scope="row"><pre>if (!CFWriteStreamOpen(myWriteStream)) {<span></span></pre></td></tr><tr><td scope="row"><pre>    CFStreamError myErr = CFWriteStreamGetError(myWriteStream);<span></span></pre></td></tr><tr><td scope="row"><pre>    // An error has occurred.<span></span></pre></td></tr><tr><td scope="row"><pre>    if (myErr.domain == kCFStreamErrorDomainPOSIX) {<span></span></pre></td></tr><tr><td scope="row"><pre>    // Interpret myErr.error as a UNIX errno.<span></span></pre></td></tr><tr><td scope="row"><pre>    } else if (myErr.domain == kCFStreamErrorDomainMacOSStatus) {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Interpret myErr.error as a MacOS error code.<span></span></pre></td></tr><tr><td scope="row"><pre>        OSStatus macError = (OSStatus)myErr.error;<span></span></pre></td></tr><tr><td scope="row"><pre>        // Check other error domains.<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>UInt8 buf[] = "Hello, world";<span></span></pre></td></tr><tr><td scope="row"><pre>UInt32 bufLen = strlen(buf);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>while (!done) {<span></span></pre></td></tr><tr><td scope="row"><pre>    CFTypeRef bytesWritten = CFWriteStreamWrite(myWriteStream, buf, strlen(buf));<span></span></pre></td></tr><tr><td scope="row"><pre>    if (bytesWritten &lt; 0) {<span></span></pre></td></tr><tr><td scope="row"><pre>        CFStreamError error = CFWriteStreamGetError(myWriteStream);<span></span></pre></td></tr><tr><td scope="row"><pre>        reportError(error);<span></span></pre></td></tr><tr><td scope="row"><pre>    } else if (bytesWritten == 0) {<span></span></pre></td></tr><tr><td scope="row"><pre>        if (CFWriteStreamGetStatus(myWriteStream) == kCFStreamStatusAtEnd) {<span></span></pre></td></tr><tr><td scope="row"><pre>            done = TRUE;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    } else if (bytesWritten != strlen(buf)) {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Determine how much has been written and adjust the buffer<span></span></pre></td></tr><tr><td scope="row"><pre>        bufLen = bufLen - bytesWritten;<span></span></pre></td></tr><tr><td scope="row"><pre>        memmove(buf, buf + bytesWritten, bufLen);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Figure out what went wrong with the write stream<span></span></pre></td></tr><tr><td scope="row"><pre>        CFStreamError error = CFWriteStreamGetError(myWriteStream);<span></span></pre></td></tr><tr><td scope="row"><pre>        reportError(error);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>CFWriteStreamClose(myWriteStream);<span></span></pre></td></tr><tr><td scope="row"><pre>CFRelease(myWriteStream);<span></span></pre></td></tr><tr><td scope="row"><pre>myWriteStream = NULL;<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000230-61973" title="Preventing Blocking When Working with Streams"></a><a name="//apple_ref/doc/uid/TP30001132-CH6-SW19" title="Preventing Blocking When Working with Streams"></a><h2>Preventing Blocking When Working with Streams</h2><p>When using streams to communicate, there is always a chance, especially with socket-based streams, that a data transfer could take a long time. If you are implementing your streams synchronously your entire application will be forced to wait on the data transfer. Therefore, it is highly recommended that your code use alternate methods to prevent blocking.</p><p>There are two ways to prevent blocking when reading from or writing to a CFStream object:</p><ul class="ul"><li class="li"><p>Polling — For read streams, find out if there are bytes to read before reading from the stream. For write streams, find out whether the stream can be written to without blocking before writing to the stream.</p></li><li class="li"><p>Using a run loop — Register to receive stream-related events and schedule the stream on a run loop. When a stream-related event occurs, your callback function (specified by the registration call) is called.</p></li></ul><p>Each of these approaches is described in the following sections.</p><a name="//apple_ref/doc/uid/TP30000230-62008" title="Using Polling to Prevent Blocking"></a><h3>Using Polling to Prevent Blocking</h3><p>To poll the read or write stream, you need to see if the streams are ready. When writing to a write stream, this is done by calling the function <code>CFWriteStreamCanAcceptBytes</code>. If it returns <code>TRUE</code>, then you can use the <code>CFWriteStreamWrite</code> function because it will be able to write immediately and will not block. Similarly, for a read stream, before calling <code><a href="../../../../CoreFoundation/Reference/CFReadStreamRef/Reference/reference.html#//apple_ref/doc/c_ref/CFReadStreamRead" target="_top">CFReadStreamRead</a></code>, call the function <code>CFReadStreamHasBytesAvailable</code>. By polling the stream, you avoid blocking the thread by waiting for the stream to become ready.</p><p><span class="content_text">Listing 2-6</span> is a polling example for a read stream.</p><a name="//apple_ref/doc/uid/TP30001132-CH6-SW7" title="Listing 2-6Polling a read stream"></a><p class="codesample"><strong>Listing 2-6&nbsp;&nbsp;</strong>Polling a read stream</p><div class="codesample"><table><tr><td scope="row"><pre>while (!done) {<span></span></pre></td></tr><tr><td scope="row"><pre>    if (CFReadStreamHasBytesAvailable(myReadStream)) {<span></span></pre></td></tr><tr><td scope="row"><pre>        UInt8 buf[BUFSIZE];<span></span></pre></td></tr><tr><td scope="row"><pre>        CFIndex bytesRead = CFReadStreamRead(myReadStream, buf, BUFSIZE);<span></span></pre></td></tr><tr><td scope="row"><pre>        if (bytesRead &lt; 0) {<span></span></pre></td></tr><tr><td scope="row"><pre>            CFStreamError error = CFReadStreamGetError(myReadStream);<span></span></pre></td></tr><tr><td scope="row"><pre>            reportError(error);<span></span></pre></td></tr><tr><td scope="row"><pre>        } else if (bytesRead == 0) {<span></span></pre></td></tr><tr><td scope="row"><pre>            if (CFReadStreamGetStatus(myReadStream) == kCFStreamStatusAtEnd) {<span></span></pre></td></tr><tr><td scope="row"><pre>                done = TRUE;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>        } else {<span></span></pre></td></tr><tr><td scope="row"><pre>            handleBytes(buf, bytesRead);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    } else {<span></span></pre></td></tr><tr><td scope="row"><pre>        // ...do something else while you wait...<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p><span class="content_text">Listing 2-7</span> is a polling example for a write stream.</p><a name="//apple_ref/doc/uid/TP30001132-CH6-SW8" title="Listing 2-7Polling a write stream"></a><p class="codesample"><strong>Listing 2-7&nbsp;&nbsp;</strong>Polling a write stream</p><div class="codesample"><table><tr><td scope="row"><pre>UInt8 buf[] = "Hello, world";<span></span></pre></td></tr><tr><td scope="row"><pre>UInt32 bufLen = strlen(buf);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>while (!done) {<span></span></pre></td></tr><tr><td scope="row"><pre>    if (CFWriteStreamCanAcceptBytes(myWriteStream)) {<span></span></pre></td></tr><tr><td scope="row"><pre>        int bytesWritten = CFWriteStreamWrite(myWriteStream, buf, strlen(buf));<span></span></pre></td></tr><tr><td scope="row"><pre>        if (bytesWritten &lt; 0) {<span></span></pre></td></tr><tr><td scope="row"><pre>            CFStreamError error = CFWriteStreamGetError(myWriteStream);<span></span></pre></td></tr><tr><td scope="row"><pre>            reportError(error);<span></span></pre></td></tr><tr><td scope="row"><pre>        } else if (bytesWritten == 0) {<span></span></pre></td></tr><tr><td scope="row"><pre>            if (CFWriteStreamGetStatus(myWriteStream) == kCFStreamStatusAtEnd)<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                done = TRUE;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>        } else if (bytesWritten != strlen(buf)) {<span></span></pre></td></tr><tr><td scope="row"><pre>            // Determine how much has been written and adjust the buffer<span></span></pre></td></tr><tr><td scope="row"><pre>            bufLen = bufLen - bytesWritten;<span></span></pre></td></tr><tr><td scope="row"><pre>            memmove(buf, buf + bytesWritten, bufLen);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            // Figure out what went wrong with the write stream<span></span></pre></td></tr><tr><td scope="row"><pre>            CFStreamError error = CFWriteStreamGetError(myWriteStream);<span></span></pre></td></tr><tr><td scope="row"><pre>            reportError(error);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    } else {<span></span></pre></td></tr><tr><td scope="row"><pre>        // ...do something else while you wait...<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000230-62233" title="Using a Run Loop to Prevent Blocking"></a><h3>Using a Run Loop to Prevent Blocking</h3><p>The run loop of a thread watches for certain events to happen. When those events take place the run loop calls a specified function. The run loop is constantly monitoring all of its input sources for events. In the case of network transfers, your callback function will be executed by the run loop when the event you registered for occurs. This allows you to not have to poll your socket stream, which would slow down the thread. Please make sure you are familiar with run loops by reading <em><a href="../../../../CoreFoundation/Conceptual/CFRunLoops/index.html#//apple_ref/doc/uid/10000135i" target="_top">Run Loops</a></em>.</p><p>This example begins by creating a socket read stream:</p><div class="codesample"><table><tr><td scope="row"><pre>CFStreamCreatePairWithSocketToCFHost(kCFAllocatorDefault, host, port,<span></span></pre></td></tr><tr><td scope="row"><pre>                                   &amp;myReadStream, NULL);<span></span></pre></td></tr></table></div><p>where the CFHost object reference, <code>host</code>, specifies the remote host with which the read stream is to be made and the <code>port</code> parameter specifies the port number that the host uses. The <code>CFStreamCreatePairWithSocketToCFHost</code> function returns the new read stream reference in <code>myReadStream</code>. The last parameter, <code>NULL</code>, indicates that the caller does not want to create a write stream. If you wanted to create a write steam, the last parameter would be, for example, <code>&amp;myWriteStream</code>.</p><p>Before opening the socket read stream, create a context that will be used when you register to receive stream-related events:</p><div class="codesample"><table><tr><td scope="row"><pre>CFStreamClientContext myContext = {0, myPtr, myRetain, myRelease, myCopyDesc};<span></span></pre></td></tr></table></div><p>The first parameter is <code>0</code> to specify the version number. The <code>info</code> parameter, <code>myPtr</code>, is a pointer to data you want to be passed to your callback function. Usually, <code>myPtr</code> is a pointer to a structure you’ve defined that contains information relating to the stream. The <code>retain</code> parameter is a pointer to a function to retain the <code>info</code> parameter.  So if you set it to your function <code>myRetain</code>, as in the code above, CFStream will call <code>myRetain(myPtr)</code> to retain the <code>info</code> pointer. Similarly, the <code>release</code> parameter, <code>myRelease</code>, is a pointer to a function to release the info parameter. When the stream is disassociated from the context, CFStream would call <code>myRelease(myPtr)</code>. Finally, <code>copyDescription</code> is a parameter to a function to provide a description of the stream. For example, if you were to call <code>CFCopyDesc(myReadStream)</code> with the stream client context shown above, CFStream would call <code>myCopyDesc(myPtr)</code>.</p><p>The client context also allows you the option of setting the <code>retain</code>, <code>release</code>, and <code>copyDescription</code> parameters to <code>NULL</code>. If you set the <code>retain</code> and <code>release</code> parameters to <code>NULL</code>, then the system will expect you to keep the memory pointed to by the <code>info</code> pointer alive until the stream itself is destroyed. If you set the <code>copyDescription</code> parameter to <code>NULL</code>, then the system will provide, if requested, a rudimentary description of what is in the memory pointed to by the <code>info</code> pointer.</p><p>With the client context set up, call the function <code>CFReadStreamSetClient</code> to register to receive stream-related events. <code>CFReadStreamSetClient</code> requires that you specify the callback function and the events you want to receive. The following example in <span class="content_text">Listing 2-8</span> specifies that the callback function wants to receive the <code>kCFStreamEventHasBytesAvailable</code>, <code>kCFStreamEventErrorOccurred</code>, and <code>kCFStreamEventEndEncountered</code> events. Then schedule the stream on a run loop with the <code><a href="../../../../CoreFoundation/Reference/CFReadStreamRef/Reference/reference.html#//apple_ref/doc/c_ref/CFReadStreamScheduleWithRunLoop" target="_top">CFReadStreamScheduleWithRunLoop</a></code> function. See <span class="content_text">Listing 2-8</span> for an example of how to do this.</p><a name="//apple_ref/doc/uid/TP30001132-CH6-SW10" title="Listing 2-8Scheduling a stream on a run loop"></a><p class="codesample"><strong>Listing 2-8&nbsp;&nbsp;</strong>Scheduling a stream on a run loop</p><div class="codesample"><table><tr><td scope="row"><pre>CFOptionFlags registeredEvents = kCFStreamEventHasBytesAvailable |<span></span></pre></td></tr><tr><td scope="row"><pre>        kCFStreamEventErrorOccurred | kCFStreamEventEndEncountered;<span></span></pre></td></tr><tr><td scope="row"><pre>if (CFReadStreamSetClient(myReadStream, registeredEvents, myCallBack, &amp;myContext)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CFReadStreamScheduleWithRunLoop(myReadStream, CFRunLoopGetCurrent(),<span></span></pre></td></tr><tr><td scope="row"><pre>                                    kCFRunLoopCommonModes);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>With the stream scheduled on the run loop, you are ready to open the stream as shown in <span class="content_text">Listing 2-9</span>.</p><a name="//apple_ref/doc/uid/TP30001132-CH6-SW9" title="Listing 2-9Opening a nonblocking read stream"></a><p class="codesample"><strong>Listing 2-9&nbsp;&nbsp;</strong>Opening a nonblocking read stream</p><div class="codesample"><table><tr><td scope="row"><pre>if (!CFReadStreamOpen(myReadStream)) {<span></span></pre></td></tr><tr><td scope="row"><pre>    CFStreamError myErr = CFReadStreamGetError(myReadStream);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (myErr.error != 0) {<span></span></pre></td></tr><tr><td scope="row"><pre>    // An error has occurred.<span></span></pre></td></tr><tr><td scope="row"><pre>        if (myErr.domain == kCFStreamErrorDomainPOSIX) {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Interpret myErr.error as a UNIX errno.<span></span></pre></td></tr><tr><td scope="row"><pre>            strerror(myErr.error);<span></span></pre></td></tr><tr><td scope="row"><pre>        } else if (myErr.domain == kCFStreamErrorDomainMacOSStatus) {<span></span></pre></td></tr><tr><td scope="row"><pre>            OSStatus macError = (OSStatus)myErr.error;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>        // Check other domains.<span></span></pre></td></tr><tr><td scope="row"><pre>    } else<span></span></pre></td></tr><tr><td scope="row"><pre>        // start the run loop<span></span></pre></td></tr><tr><td scope="row"><pre>        CFRunLoopRun();<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr></table></div><p>Now, wait for your callback function to be executed. In your callback function, check the event code and take appropriate action. See <span class="content_text">Listing 2-10</span>.</p><a name="//apple_ref/doc/uid/TP30001132-CH6-SW11" title="Listing 2-10Network events callback function"></a><p class="codesample"><strong>Listing 2-10&nbsp;&nbsp;</strong>Network events callback function</p><div class="codesample"><table><tr><td scope="row"><pre>void myCallBack (CFReadStreamRef stream, CFStreamEventType event, void *myPtr) {<span></span></pre></td></tr><tr><td scope="row"><pre>    switch(event) {<span></span></pre></td></tr><tr><td scope="row"><pre>        case kCFStreamEventHasBytesAvailable:<span></span></pre></td></tr><tr><td scope="row"><pre>            // It is safe to call CFReadStreamRead; it won’t block because bytes<span></span></pre></td></tr><tr><td scope="row"><pre>            // are available.<span></span></pre></td></tr><tr><td scope="row"><pre>            UInt8 buf[BUFSIZE];<span></span></pre></td></tr><tr><td scope="row"><pre>            CFIndex bytesRead = CFReadStreamRead(stream, buf, BUFSIZE);<span></span></pre></td></tr><tr><td scope="row"><pre>            if (bytesRead > 0) {<span></span></pre></td></tr><tr><td scope="row"><pre>                handleBytes(buf, bytesRead);<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            // It is safe to ignore a value of bytesRead that is less than or<span></span></pre></td></tr><tr><td scope="row"><pre>            // equal to zero because these cases will generate other events.<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kCFStreamEventErrorOccurred:<span></span></pre></td></tr><tr><td scope="row"><pre>            CFStreamError error = CFReadStreamGetError(stream);<span></span></pre></td></tr><tr><td scope="row"><pre>            reportError(error);<span></span></pre></td></tr><tr><td scope="row"><pre>            CFReadStreamUnscheduleFromRunLoop(stream, CFRunLoopGetCurrent(),<span></span></pre></td></tr><tr><td scope="row"><pre>                                              kCFRunLoopCommonModes);<span></span></pre></td></tr><tr><td scope="row"><pre>            CFReadStreamClose(stream);<span></span></pre></td></tr><tr><td scope="row"><pre>            CFRelease(stream);<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kCFStreamEventEndEncountered:<span></span></pre></td></tr><tr><td scope="row"><pre>            reportCompletion();<span></span></pre></td></tr><tr><td scope="row"><pre>            CFReadStreamUnscheduleFromRunLoop(stream, CFRunLoopGetCurrent(),<span></span></pre></td></tr><tr><td scope="row"><pre>                                              kCFRunLoopCommonModes);<span></span></pre></td></tr><tr><td scope="row"><pre>            CFReadStreamClose(stream);<span></span></pre></td></tr><tr><td scope="row"><pre>            CFRelease(stream);<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>When the callback function receives the <code>kCFStreamEventHasBytesAvailable</code> event code, it calls <code>CFReadStreamRead</code> to read the data.</p><p>When the callback function receives the <code>kCFStreamEventErrorOccurred</code> event code, it calls <code>CFReadStreamGetError</code> to get the error and its own error function (<code>reportError</code>) to handle the error.</p><p>When the callback function receives the <code>kCFStreamEventEndEncountered</code> event code, it calls its own function (<code>reportCompletion</code>) for handling the end of data and then calls the <code>CFReadStreamUnscheduleFromRunLoop</code> function to remove the stream from the specified run loop. Then the <code>CFReadStreamClose</code> function is run to close the stream and <code>CFRelease</code> to release the stream reference.</p><a name="//apple_ref/doc/uid/TP30001132-CH6-DontLinkElementID_12" title="Navigating Firewalls"></a><h2>Navigating Firewalls</h2><p>There are two ways to apply firewall settings to a stream. For most streams, you can retrieve the proxy settings using the <code><!--a-->SCDynamicStoreCopyProxies<!--/a--></code> function and then apply the result to the stream by setting the <code>kCFStreamHTTPProxy</code> (or <code>kCFStreamFTPProxy</code>) property. The <code><!--a-->SCDynamicStoreCopyProxies<!--/a--></code> function is part of the System Configuration framework, so you need to include <code>&lt;SystemConfiguration/SystemConfiguration.h></code> in your project to use the function. Then just release the proxy dictionary reference when you are done with it. The process would look like that in <span class="content_text">Listing 2-11</span>.</p><a name="//apple_ref/doc/uid/TP30001132-CH6-SW18" title="Listing 2-11Navigating a stream through a proxy server"></a><p class="codesample"><strong>Listing 2-11&nbsp;&nbsp;</strong>Navigating a stream through a proxy server</p><div class="codesample"><table><tr><td scope="row"><pre>CFDictionaryRef proxyDict = SCDynamicStoreCopyProxies(NULL);<span></span></pre></td></tr><tr><td scope="row"><pre>CFReadStreamSetProperty(readStream, kCFStreamPropertyHTTPProxy, proxyDict);<span></span></pre></td></tr></table></div><p>However, if you need to use the proxy settings often for multiple streams, it becomes a bit more complicated. In this case retrieving the firewall settings of a user's machine requires five steps:</p><ol class="ol"><li class="li"><p>Create a single, persistent handle to a dynamic store session, <code>SCDynamicStoreRef</code>.</p></li><li class="li"><p>Put the handle to the dynamic store session into the run loop to be notified of proxy changes.</p></li><li class="li"><p>Use <code><!--a-->SCDynamicStoreCopyProxies<!--/a--></code> to retrieve the latest proxy settings.</p></li><li class="li"><p>Update your copy of the proxies when told of the changes.</p></li><li class="li"><p>Clean up the <code>SCDynamicStoreRef</code> when you are through with it.</p></li></ol><p>To create the handle to the dynamic store session, use the function <code><!--a-->SCDynamicStoreCreate<!--/a--></code> and pass an allocator, a name to describe your process, a callback function and a dynamic store context, <code>SCDynamicStoreContext</code>. This is run when initializing your application. The code would be similar to that in <span class="content_text">Listing 2-12</span>.</p><a name="//apple_ref/doc/uid/TP30001132-CH6-SW12" title="Listing 2-12Creating a handle to a dynamic store session"></a><p class="codesample"><strong>Listing 2-12&nbsp;&nbsp;</strong>Creating a handle to a dynamic store session</p><div class="codesample"><table><tr><td scope="row"><pre>SCDynamicStoreContext context = {0, self, NULL, NULL, NULL};<span></span></pre></td></tr><tr><td scope="row"><pre>systemDynamicStore = SCDynamicStoreCreate(NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>                                          CFSTR("SampleApp"),<span></span></pre></td></tr><tr><td scope="row"><pre>                                          proxyHasChanged,<span></span></pre></td></tr><tr><td scope="row"><pre>                                          &amp;context);<span></span></pre></td></tr></table></div><p>After creating the reference to the dynamic store, you need to add it to the run loop. First, take the dynamic store reference and set it up to monitor for any changes to the proxies. This is accomplished with the functions <code><!--a-->SCDynamicStoreKeyCreateProxies<!--/a--></code> and <code><!--a-->SCDynamicStoreSetNotificationKeys<!--/a--></code>. Then, you can add the dynamic store reference to the run loop with the functions <code><!--a-->SCDynamicStoreCreateRunLoopSource<!--/a--></code> and <code><a href="../../../../CoreFoundation/Reference/CFRunLoopRef/Reference/reference.html#//apple_ref/doc/c_ref/CFRunLoopAddSource" target="_top">CFRunLoopAddSource</a></code>. Your code should look like that in <span class="content_text">Listing 2-13</span>.</p><a name="//apple_ref/doc/uid/TP30001132-CH6-SW13" title="Listing 2-13Adding a dynamic store reference to the run loop"></a><p class="codesample"><strong>Listing 2-13&nbsp;&nbsp;</strong>Adding a dynamic store reference to the run loop</p><div class="codesample"><table><tr><td scope="row"><pre>// Set up the store to monitor any changes to the proxies<span></span></pre></td></tr><tr><td scope="row"><pre>CFStringRef proxiesKey = SCDynamicStoreKeyCreateProxies(NULL);<span></span></pre></td></tr><tr><td scope="row"><pre>CFArrayRef keyArray = CFArrayCreate(NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    (const void **)(&amp;proxiesKey),<span></span></pre></td></tr><tr><td scope="row"><pre>                                    1,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    &amp;kCFTypeArrayCallBacks);<span></span></pre></td></tr><tr><td scope="row"><pre>SCDynamicStoreSetNotificationKeys(systemDynamicStore, keyArray, NULL);<span></span></pre></td></tr><tr><td scope="row"><pre>CFRelease(keyArray);<span></span></pre></td></tr><tr><td scope="row"><pre>CFRelease(proxiesKey);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Add the dynamic store to the run loop<span></span></pre></td></tr><tr><td scope="row"><pre>CFRunLoopSourceRef storeRLSource =<span></span></pre></td></tr><tr><td scope="row"><pre>    SCDynamicStoreCreateRunLoopSource(NULL, systemDynamicStore, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>CFRunLoopAddSource(CFRunLoopGetCurrent(), storeRLSource, kCFRunLoopCommonModes);<span></span></pre></td></tr><tr><td scope="row"><pre>CFRelease(storeRLSource);<span></span></pre></td></tr></table></div><p>Once the dynamic store reference has been added to the run loop, use it to preload the proxy dictionary the current proxy settings by calling <code><!--a-->SCDynamicStoreCopyProxies<!--/a--></code>. See <span class="content_text">Listing 2-14</span> for how to do this.</p><a name="//apple_ref/doc/uid/TP30001132-CH6-SW14" title="Listing 2-14Loading the proxy dictionary"></a><p class="codesample"><strong>Listing 2-14&nbsp;&nbsp;</strong>Loading the proxy dictionary</p><div class="codesample"><table><tr><td scope="row"><pre>gProxyDict = SCDynamicStoreCopyProxies(systemDynamicStore);<span></span></pre></td></tr></table></div><p>As a result of adding the dynamic store reference to the run loop, each time the proxies are changed your callback function will be run. Release the current proxy dictionary and reload it with the new proxy settings. A sample callback function would look like the one in <span class="content_text">Listing 2-15</span>.</p><a name="//apple_ref/doc/uid/TP30001132-CH6-SW15" title="Listing 2-15Proxy callback function"></a><p class="codesample"><strong>Listing 2-15&nbsp;&nbsp;</strong>Proxy callback function</p><div class="codesample"><table><tr><td scope="row"><pre>void proxyHasChanged() {<span></span></pre></td></tr><tr><td scope="row"><pre>    CFRelease(gProxyDict);<span></span></pre></td></tr><tr><td scope="row"><pre>    gProxyDict = SCDynamicStoreCopyProxies(systemDynamicStore);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Since all of the proxy information is up-to-date, apply the proxies. After creating your read or write stream, set the <code>kCFStreamPropertyHTTPProxy</code> proxy by calling the functions <code><a href="../../../../CoreFoundation/Reference/CFReadStreamRef/Reference/reference.html#//apple_ref/doc/c_ref/CFReadStreamSetProperty" target="_top">CFReadStreamSetProperty</a></code> or <code><a href="../../../../CoreFoundation/Reference/CFWriteStreamRef/Reference/reference.html#//apple_ref/doc/c_ref/CFWriteStreamSetProperty" target="_top">CFWriteStreamSetProperty</a></code>. If your stream was a read stream called <code>readStream</code>, your function call would be like that in <span class="content_text">Listing 2-16</span>.</p><a name="//apple_ref/doc/uid/TP30001132-CH6-SW16" title="Listing 2-16Adding proxy information to a stream"></a><p class="codesample"><strong>Listing 2-16&nbsp;&nbsp;</strong>Adding proxy information to a stream</p><div class="codesample"><table><tr><td scope="row"><pre>CFReadStreamSetProperty(readStream, kCFStreamPropertyHTTPProxy, gProxyDict);<span></span></pre></td></tr></table></div><p>When you are all done with using the proxy settings, make sure to release the dictionary and dynamic store reference, and to remove the dynamic store reference from the run loop. See <span class="content_text">Listing 2-17</span>.</p><a name="//apple_ref/doc/uid/TP30001132-CH6-SW17" title="Listing 2-17Cleaning up proxy information"></a><p class="codesample"><strong>Listing 2-17&nbsp;&nbsp;</strong>Cleaning up proxy information</p><div class="codesample"><table><tr><td scope="row"><pre>if (gProxyDict) {<span></span></pre></td></tr><tr><td scope="row"><pre>    CFRelease(gProxyDict);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Invalidate the dynamic store's run loop source<span></span></pre></td></tr><tr><td scope="row"><pre>// to get the store out of the run loop<span></span></pre></td></tr><tr><td scope="row"><pre>CFRunLoopSourceRef rls = SCDynamicStoreCreateRunLoopSource(NULL, systemDynamicStore, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>CFRunLoopSourceInvalidate(rls);<span></span></pre></td></tr><tr><td scope="row"><pre>CFRelease(rls);<span></span></pre></td></tr><tr><td scope="row"><pre>CFRelease(systemDynmaicStore);<span></span></pre></td></tr></table></div>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Concepts/Concepts.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../CFHTTPTasks/CFHTTPTasks.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-05-06<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Networking/Conceptual/CFNetwork/CFStreamTasks/CFStreamTasks.html%3Fid%3DTP30001132-6.3&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Networking/Conceptual/CFNetwork/CFStreamTasks/CFStreamTasks.html%3Fid%3DTP30001132-6.3&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Networking/Conceptual/CFNetwork/CFStreamTasks/CFStreamTasks.html%3Fid%3DTP30001132-6.3&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>