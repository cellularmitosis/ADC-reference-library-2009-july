UNIT TransQueue;INTERFACEUSES MemTypes, QuickDraw, OSIntf, ToolIntf, OSUtils, AppleTalk, ToolUtils;CONST{----------------------------------------------------------------------		Transition Queue Constants----------------------------------------------------------------------}(*  Comment the following 4 constants since they are already defined in the AppleTalk unit 	ATTransOpen							= 	0;	{ .MPP is opening }	ATTransClose							=	2;	{ .MPP is closing }	ATTransClosePrep					=	3;	{ OK for .MPP to close? }	ATTransCancelClose					=	4;	{ .MPP close was cancelled }*)	ATTransNetworkTransition		=	5;	{ .MPP Network ADEV transition }	ATTransNameChangeTellTask	= 	6;	{ Flagship name is changing }	ATTransNameChangeAskTask	= 	7;	{ OK to change Flagship name }	ATTransCancelNameChange		= 	8;	{ Flagship name change was cancelled }	ATTransCableChange					=	'rnge'; { Cable Range Change has occured }	ATTransSpeedChange				=	'sped'; { Change in processor speed has occured }{----------------------------------------------------------------------	'STR ' Resource ID'd----------------------------------------------------------------------}	kATTransOpenMsgNum							= 128;	kATTransCloseMsgNum							= 129;	kATTransClosePrepMsgNum					= 130;	kATTransCancelCloseMsgNum				= 131;	kATTransNetworkTransitionMsgNum		= 132;	kATTransNameChangeTellTaskMsgNum	= 133;	kATTransNameChangeAskTaskMsgNum	= 134;	kATTransCancelNameChangeMsgNum		= 135;	kATTransCableChangeMsgNum				= 136;	kATTransSpeedChangeMsgNum				= 137;	kNewFlagshipNameMsg							= 138;	kCancelFlagshipNameMsg						= 139;	kLoCableRangeMsg								= 140;	kHiCableRangeMsg									= 141;	kNewConnection									= 142;	kCloseConnection									= 143;	kOurAppName										= 200;	kNumRecs												= 5;	{ number of transition records to maintain }	{----------------------------------------------------------------------		NBP Name Change Info record----------------------------------------------------------------------}TYPE	NameChangeInfo = RECORD	newObjStr	: Str32;		{ new NBP name }	name			: Ptr;			{ -> to place ptr to name of process that NAK'd the event }	END;NameChangePtr = ^NameChangeInfo;NameChangeHdl = ^NameChangePtr;{----------------------------------------------------------------------		Network Transition Info Record----------------------------------------------------------------------}TNetworkTransition = RECORD	private		: Ptr;			{ pointer to private structure }	netValidProc	: ProcPtr;	{ pointer to network validation procedure }	newConnectivity : Boolean;	{ true = new connection, }									{ false = loss of connection }	END;TNetworkTransitionPtr = ^TNetworkTransition;TNetworkTransitionHdl = ^TNetworkTransitionPtr;{  The following is the C prototype for the netValidProc function pointer routine 	}{  In the sample ATQ Handler here, the call is implemented through an 			}{  Assembler glue procedure - CallNetValidProc	- declared as an EXTERNAL		}{  routine.																											}{typedef pascal long	(*NetworkTransitionProcPtr)(TNetworkTransitionPtr netTrans, \					  unsigned long theNet);}{----------------------------------------------------------------------		Cable Range Transition Info Record----------------------------------------------------------------------}TNewCRTrans = RECORD	newCableLo	: INTEGER;	{ the new Cable Lo received from RTMP }	newCableHi	: INTEGER;	{ the new Cable Hi received from RTMP }	END;TNewCRTransPtr = ^TNewCRTrans;TNewCRTransHdl = ^TNewCRTransPtr;{ * The ATQEntry record is defined in the AppleTalk unit, however, the following  * definition provides the flexibility to include a pointer to some global data  * structure.}   {----------------------------------------------------------------------		My Transition Event Record Element----------------------------------------------------------------------}IndEventRecord			= RECORD	evtMsgNum		: INTEGER;	evtTime			: LONGINT;	END;	TransEventRec = RECORD	nextFreeEvt		: INTEGER;	nextEvt2Proc	: INTEGER;	appNameHandle	: StringHandle;	oldFlagName		: Str32;	newFlagName	: Str32;	newCableLo		: INTEGER;	newCableHi		: INTEGER;	allowClose		: Boolean;	allowChange		: Boolean;	newConnFlag		: Boolean;	docTE				: TEHandle;	indEvtRec			: ARRAY[1..kNumRecs] of IndEventRecord;	END;TransEventPtr = ^TransEventRec;TransEventHdl = ^TransEventPtr;TransEvtPtrArr = ARRAY [1..kNumRecs] of TransEventPtr;	{----------------------------------------------------------------------		AppleTalk Transition Queue Element----------------------------------------------------------------------}myATQEntry = RECORD	qlink		: Ptr;						{ -> next queue element }	qType		: INTEGER;			{ unused }	CallAddr 	: ProcPtr;			{ -> transition procedure }	globs		: TransEventPtr;	{ -> to user defined globals }	END;myATQEntryPtr = ^myATQEntry;myATQEntryHdl = ^myATQEntryPtr;	{---------------- Prototypes --------------------}FUNCTION InitTransEventRec(VAR q : TransEventPtr) : OSErr;{ *  This function allocates a pointer to the global TransEvent Record. } FUNCTION ATQueueProc (selector :LONGINT; q :myATQEntryPtr; p : Handle) : LONGINT;{ *  Transition queue routines are designed with C calling conventions in mind. *  They are passed parameters with a C style stack and return values are expected *  to be in register D0.  Note that the CallTransQueue Assembler routine is used *  to reverse the C style stack to Pascal style before calling the handler.  The *  procedure CallTransQueue follows this listing.  To install the handler, assign  *  the address of the CallTransQueue procedure to the ATQEntry.CallAddr field. }  IMPLEMENTATIONFUNCTION GetFlagshipName : Str32;CONST	kMachineName	= -16413;VAR	nameHdl		: StringHandle;BEGIN	nameHdl := StringHandle (GetResource('STR ', kMachineName));	 { get Flagship Name string resource }	if (nameHdl <> nil) THEN		GetFlagshipName := nameHdl^^		{ if operating under System 7.0 or greater, the string exists. }	ELSE		GetFlagshipName := '';					{ otherwise return the empty string.  We won't be processing }															{ Flagship Transition events. }END;FUNCTION InitTransEventRec(VAR q : TransEventPtr) : OSErr;VAR	err	: OSErr;	i		: INTEGER;	BEGIN	err := noErr;									{ assume no error }	q := TransEventPtr(NewPtrSys(sizeof(TransEventRec)));  {allocate memory }	err := MemError;		if (err = noErr) THEN	BEGIN		q^.appNameHandle := StringHandle(NewHandle(sizeof(Str32)));		err := MemError;		if (err = noErr) THEN		BEGIN			q^.appNameHandle := StringHandle(GetResource ('STR ', kOurAppName));			if (q^.appNameHandle = nil) then				q^.appNameHandle^^ := 'TransQueueWatcher';	{ just in case the resource call failed }			q^.oldFlagName := GetFlagshipName;			q^.newFlagName := '';			q^.newCableLo := 0;			q^.newCableHi := 0;			q^.allowClose := TRUE;		{ Allow .MPP to close if ATTransClosePrep msg handled }			q^.allowChange := TRUE;	{ Allow Flagship name to be changed if  }													{	ATTransNameChangeAskTask msg handled }			q^.newConnFlag := FALSE; 			q^.docTE := nil;			q^.nextFreeEvt := 1;			q^.nextEvt2Proc := 1;			FOR i := 1 to kNumRecs DO			BEGIN				q^.indEvtRec[i].evtMsgNum := 0;				q^.indEvtRec[i].evtTime := 0;			END;		END;	END;	InitTransEventRec := err;END;		FUNCTION ATQueueProc (selector :LONGINT; q :myATQEntryPtr; p : Handle) : LONGINT;VAR	returnVal								: LONGINT;	myTransEventPtr					: TransEventPtr;	myNameChgPtr						: NameChangePtr;  	myTNewCRTransPtr				: TNewCRTransPtr;	myTNetworkTransitionPtr	: TNetworkTransitionPtr;	shortSelector						: INTEGER;	checkThisNet						: LONGINT;	i											: INTEGER;			BEGIN	myTransEventPtr := q^.globs;	{ get pointer to our trans event record pointer }	returnVal := 0;	WITH myTransEventPtr^ DO	BEGIN		i := nextFreeEvt;		GetDateTime(indEvtRec[i].evtTime);			{ get event time }		{		 *	This is the dispatch part of the routine.  We'll check the selector passed into		 *  the task, it's location is 4 bytes off the stack (selector).		 }		IF ((selector <=8) AND (selector >= 0)) THEN		{		 *  Check whether a numeric selector is being used whose known values are between		 *  8 and 0 so that we can implement a CASE statement with an INTEGER var.		 }		BEGIN			shortSelector := selector;			CASE shortSelector OF				ATTransOpen:				BEGIN					indEvtRec[i].evtMsgNum := kATTransOpenMsgNum; { .MPP Driver has opened }				END;									ATTransClose:				BEGIN					indEvtRec[i].evtMsgNum := kATTransCloseMsgNum; { .MPP Driver closing }				END;									ATTransClosePrep: 				BEGIN					indEvtRec[i].evtMsgNum := kATTransClosePrepMsgNum; 																		{ request to allow .MPP Driver to close }					if (NOT allowClose) THEN					BEGIN						returnVal := -1;						Ptr(p^) := Ptr(appNameHandle^); { return app name }					END;							END; 													ATTransCancelClose:				BEGIN					indEvtRec[i].evtMsgNum := kATTransCancelCloseMsgNum; 																		{ notification canceling .MPP Driver close }				END;									ATTransNetworkTransition:				BEGIN					indEvtRec[i].evtMsgNum := kATTransNetworkTransitionMsgNum; 																		{ Network Transition is occuring }					myTNetworkTransitionPtr :=  TNetworkTransitionPtr (p);						if (myTNetworkTransitionPtr^.newConnectivity) THEN						newConnFlag := TRUE					ELSE						newConnFlag := FALSE;						{ We could check for network connection here }				END;									ATTransNameChangeTellTask:				BEGIN					indEvtRec[i].evtMsgNum := kATTransNameChangeTellTaskMsgNum; 																		{ Flagship Name is changing }						myNameChgPtr := NameChangePtr (p);		{ get the new name }					BlockMove(@myNameChgPtr^.newObjStr, @newFlagName, LONGINT(myNameChgPtr^.newObjStr[0]) + 1);					BlockMove(@myNameChgPtr^.newObjStr, @oldFlagName, LONGINT(myNameChgPtr^.newObjStr[0]) + 1);				END;									ATTransNameChangeAskTask:				BEGIN					indEvtRec[i].evtMsgNum := kATTransNameChangeAskTaskMsgNum; 																		{ OK to change Flagship Name? }						myNameChgPtr := NameChangePtr (p);		{ get the new name }					BlockMove(@myNameChgPtr^.newObjStr, @newFlagName, LONGINT(myNameChgPtr^.newObjStr[0]) + 1);					if (allowChange = FALSE) THEN					BEGIN						returnVal := 1;						myNameChgPtr^.name := Ptr(appNameHandle); { return app name }					END;							END;									ATTransCancelNameChange:				BEGIN					indEvtRec[i].evtMsgNum := kATTransCancelNameChangeMsgNum; 																		{ Flagship Name change has been cancelled }				END;								OTHERWISE					returnVal := 0;					{					 *  Just in case some other numeric selector is implemented.					 }			END; { CASE }		END		ELSE IF (ResType(selector) = ATTransCableChange) THEN		BEGIN			indEvtRec[i].evtMsgNum := kATTransCableChangeMsgNum; 																{ Cable Range is changing }				myTNewCRTransPtr := TNewCRTransPtr (p);			newCableLo := myTNewCRTransPtr^.newCableLo;			newCableHi := myTNewCRTransPtr^.newCableHi;		END		ELSE IF (ResType(selector) = ATTransSpeedChange) THEN		BEGIN			indEvtRec[i].evtMsgNum := kATTransSpeedChangeMsgNum; 																{ CPU speed is changing }		END; { IF }				nextFreeEvt := nextFreeEvt + 1;	{ adjust nextFreeEvt to point to next IndEvtRecord }		IF nextFreeEvt > kNumRecs THEN			nextFreeEvt := 1;	END; { WITH myTransEventPtr^ }	ATQueueProc := returnVal;END;END. { of UNIT }