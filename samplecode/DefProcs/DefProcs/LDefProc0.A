;EASE$$$ READ ONLY COPY of file “LDefProc0.A”; 1.0	CCH 11/16/1988 Added to EASE.; END EASE MODIFICATION HISTORY ; File LDefProc0.a;-------------------------------------------------------------;; Standard List Definition Procedure for simple text;;	  Ernie Beernink  March 1985;; This is the standard List defProc.  Its primary task is to draw; the contents of a list manager cell, either selected or deselected.; It is passed a pointer to the cell's data, the length of the cell's; data, and a rectangle in which to draw the cell.  When it is called,; the clip region is set to that rect.  The cell data does NOT include a; length byte.;; MODIFICATION HISTORY:; S3	05Jan87	JTC	32-bit support changes.;;		version $0001;		 8jun87 sad color hilighting, trucation (conditional);-------------------------------------------------------------               BLANKS         ON               STRING         ASIS;				LOAD	  	'sysallqk.d'				LOAD	  	'nequ.d'				INCLUDE		'SysEqu.a'				INCLUDE		'Traps.a'				INCLUDE		'QuickEqu.a'				INCLUDE		'PackMacs.a'truncate	equ 0	; truncation offLDEF0          PROC	  EXPORT; PROCEDURE    DrawCell(LMessage:INTEGER; LSelect:BOOLEAN; LRect:Rect; LCell: Cell;;		        LDataOffset, LDataLen:INTEGER; LHandle:Handle);; Message equates:;InitMsg        .EQU	  0		      ; tell drawing routines to init themselves;DrawMsg        .EQU	  1		      ; draw (and de/select) the indicated data;HiliteMsg      .EQU	  2		      ; de/select the indicated data;CloseMsg       .EQU	  3		      ; shut down, the list is being disposed; Stack Frame definition for ListDefProc 0LHandle	       EQU	  8		     ; Handle to list data recordLDataLen       EQU	  LHandle+4	     ; length of dataLDataOffset    EQU	  LDataLen+2	     ; offset to dataLCell	       EQU	  LDataOffset+2	     ; cell that was hitLRect	       EQU	  LCell+4	     ; rect to draw inLSelect	       EQU	  LRect+4	     ; 1=selected, 0=not selectedLMessage       EQU	  LSelect+2	     ; 0=Init, 1=Draw, 2=Hilite, 3=CloseLParamSize     EQU	  LMessage+2-8	     ; # of bytes of parameters               BRA.S	 @0		     ; enter here; standard header               DC.W	  0			; flags word               DC.B	  'LDEF'	; type               DC.W	  0 		; ID               DC.W	  $0001		; version@0               LINK	 A6,#0		     ; set up a stack frame               MOVEM.L	 D3-D7/A2-A4,-(SP)   ; save the usual stuff               MOVE.L	 LHandle(A6),A4	     ; get handle to list record               MOVE.L	 (A4),A3	     ; get pointer to (locked) record               MOVE.W	 LMessage(A6),D0     ; why am I being called?               SUBQ	 #1,D0		     ; check next in line               BEQ.S	ListDraw		; code = 1 -> draw cell               SUBQ	 #1,D0		     ; check next               BEQ.S	 LHilite	     ; code = 2 -> invert cell               BPL.S	 LDefExit	     ; other calls not needed here;---------------; LInit; Here is the code that does the initialization for this defprocLInit; just set up our indent               SUBQ	 #8,SP		     ; make room for GetFontInfo record               MOVE.L	 SP,-(SP)	     ; point to it               _GetFontInfo		     ; and go get info               MOVE.W	 (SP),indent+v(A3)   ; indent.v := ascent               MOVE.W	 #4,indent+h(A3)     ; indent.h := 4               ADDQ	 #8,SP		     ; fix up stackLDefExit               MOVEM.L	 (SP)+,D3-D7/A2-A4   ; restore the usual stuff               UNLK	 A6		     ; unlink our frame               MOVE.L	 (SP)+,A0	     ; get return address               ADD.L	 #LParamSize,SP	     ; strip off parameters               JMP	 (A0)		     ; and return;---------------; LHilite -- Here is the code that hilights/unhilights the; cell.	 We know that it's drawn, and that we're only called; if it needs to be de/selected, so inverrect is all we need.LHilite			   bclr		#7,HiliteMode		; now in color! <8jun87>               MOVE.L	 LRect(A6),-(SP)     ; push rect               _InverRect		     ; and invert it               BRA.S	 LDefExit	     ; all done;---------------; ListDraw -- Here is the code that does the drawing; for the defProc.ListDraw			MOVE.L	LRect(A6),A4		; get rect into A4			MOVE.L	topLeft(A4),-(SP)	; move pen to indent point			MOVE.L	indent(A3),-(SP)			PEA		4(SP)			_AddPt			_MoveTo; use default text mode			_PenNormal			MOVE.L	 cells(A3),A2		; get data handle			MOVEA.L	A2,A0				; data handle			<S3>			TST.W	ROM85				; old ROMs?				<S3>			BMI.S	@oldROMs			; MI means old			<S3>			_HGetState					; D0 := lock state		<S3>			MOVE.B	D0,-(SP)			; save lock state		<S3>			BRA.S	@oldEnd				; skip over old way		<S3>@oldROMs								;						<S3>			MOVE.B	(A0),-(SP)			; save lock state old way<S3>@oldEnd									;						<S3>			_HLock						; lock across QD calls	<S3>			MOVE.L	A4,-(SP)			; clear out the rect			_EraseRect			MOVE.W	LDataLen(A6),D3		; anything to draw?			BLE.S	@nodraw				; =>nope, don't draw <22jul87 sad> if truncate then						; <22jul87 sad> to endif 			MOVE.L	(a2),d6				; d6.l = ptr to the text <22jul87 sad>			MOVE.W	LDataOffset(a6),d5	; d5.w = offset to first byte of this cell <22jul87 sad>	; calculate avail width			move	right(a4),d7			sub		left(a4),d7			sub		indent+h(a3),d7		; left indent			sub		#1,d7				; right indent			moveq	#0,d4				; no trunc yet@truncloop			sub		#2,sp			move.l	d6,-(sp)			move	d5,-(sp)			move	d3,-(sp)			_TextWidth			cmp		(sp)+,d7			; will string fit?			bge.s	@truncout			; yes, leave				; no, truncate by one char			tst.b	d4					; truncated any yet?			bnz.s	@3					; yes, just drop a char				; no, add elipsis and drop a character			sub		#2,sp			move	#'…',-(sp)			_CharWidth			sub		(sp)+,d7			moveq	#1,d4				; remember that we have truncated@3			sub		#1,d3				; drop the last character			bz.s	@nodraw				; no more chars			bra.s	@truncloop			@truncout			MOVE.L	d6,-(sp)			; point to the text			MOVE.W	d5,-(sp)			; offset to first byte of this cell else 			MOVE.L	(A2),-(SP)			; point to the text			MOVE.W	LDataOffset(A6),-(SP)	; offset to first byte endif				; end <22jul87 sad>			MOVE.W	D3,-(SP)			; and number of bytes			_DrawText if truncate then						; <22jul87 sad> to endif 			tst.b	d4					; truncated any?			bz.s	@noelipsis			; no, don’t draw elipsis				; yes			move	#'…',-(sp)			_DrawChar@noelipsis endif									; end <22jul87 sad>@nodraw				; <22jul87 sad>			MOVEA.L	A2,A0				; data handle			<S3>			TST.W	ROM85				; do we have new ROMs?	<S3>			BMI.S	@old2ROMs			; MI means no, do it the old way	<S3>			MOVE.B	(SP)+,D0			; saved lock state		<S3>			_HSetState					; stuffed back to handle<S3>			BRA.S	@old2End			;						<S3>@old2ROMs								;						<S3>			MOVE.B	(SP)+,(A0)			; restore lock state@old2End								;						<S3>			TST.B	LSelect(A6)			; selected? <22jul87 sad> if truncate then			bnz		LHilite				; yes <22jul87 sad> else			bnz.s	LHilite				; yes <22jul87 sad> endif				; no <22jul87 sad> if truncate then			BRA		LDefExit			; and return <22jul87 sad> else			BRA.S	LDefExit			; and return endif 			END