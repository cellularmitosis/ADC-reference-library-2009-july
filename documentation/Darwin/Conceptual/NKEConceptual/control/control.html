<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Network Kernel Extensions Programming Guide: KEXT Controls and Notifications</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="KEXT Controls and Notifications"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40001858-CH227" title="KEXT Controls and Notifications"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000422" target="_top">Darwin</a> &gt; <a href="../../../Kernel-date.html#//apple_ref/doc/uid/TP30000440-TP30000422-TP30000532" target="_top">Kernel</a> &gt; <a href="../intro/intro.html#//apple_ref/doc/uid/TP40001858-CH225-DontLinkElementID_68">Network Kernel Extensions Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../SocketManipulation/SocketManipulation.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../socket_nke/socket_nke.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40001858-CH227-DontLinkElementID_35" title="KEXT Controls and Notifications"></a><h1>KEXT Controls and Notifications</h1><p>This chapter describes two mechanisms for interacting with a network kernel extension: the kernel control and kernel event APIs. These socket-based APIs allow you to communicate with a KEXT and receive broadcast notifications from the KEXT, respectively.</p><p>To support this communication, Mac OS X defines a new socket domain—the <code>PF_SYSTEM</code> domain—to provide a way for applications to configure and control KEXTs. The <code>PF_SYSTEM</code> domain, in turn, supports two protocols, <code><!--a  -->SYSPROTO_CONTROL<!--/a--></code> and <code>SYSPROTO_EVENT</code>.</p><p>The kernel control (<code>kern_control</code>) API, which uses the <code>SYSPROTO_CONTROL</code> protocol, allows applications to configure and control a KEXT.</p><p>The kernel event (<code>kern_event</code>) API, which uses the <code>SYSPROTO_EVENT</code> protocol, allows applications and other KEXTs to be notified when certain kernel events occur. It should be used when multiple clients need to know about a given event, and is not intended as a point-to-point communication mechanism. In general, the kernel control API is preferred, as it provides bidirectional communication.</p><p>For detailed reference documentation on these APIs, see <em><a href="../../../Reference/KPI_Reference/index.html#//apple_ref/doc/uid/TP40001274" target="_top">KPI Reference</a></em>.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="control.html#//apple_ref/doc/uid/TP40001858-CH227-CHDCHEHG">Using the Kernel Control API for KEXT Control</a>
				
			<br/>
			
        
			
			
				<a href="control.html#//apple_ref/doc/uid/TP40001858-CH227-CHDJGEIB">Using the kern_event API for Kernel Notifications</a>
				
			<br/>
			
        
			
			
				<a href="control.html#//apple_ref/doc/uid/TP40001858-CH227-DontLinkElementID_14">Implementing a Preference File for an NKE</a>
				
			<br/>
			
        
			
			
				<a href="control.html#//apple_ref/doc/uid/TP40001858-CH227-DontLinkElementID_15">Helpful Tips</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40001858-CH227-CHDCHEHG" title="Using the Kernel Control API for KEXT Control"></a><h2>Using the Kernel Control API for KEXT Control</h2><p>The kernel control API is a bidirectional communication mechanism between a user space application and a KEXT. This section describes this API at the kernel level and the user space level.</p><a name="//apple_ref/doc/uid/TP40001858-CH227-DontLinkElementID_11" title="Supporting Kernel Controls in Your KEXT"></a><h3>Supporting Kernel Controls in Your KEXT</h3><p>Supporting kernel controls in a KEXT is relatively straightforward.</p><p>In the KEXT’s start function, you must register a kernel control structure using the <code><a href="../../../Reference/KPI_Reference/kern_control/CompositePage.html#//apple_ref/c/func/ctl_register" target="_top">ctl_register</a></code> function. The <code><!--a-->ctl_register<!--/a--></code> function is defined in <code>&lt;sys/kern_control.h></code> as follows:</p><div class="codesample"><table><tr><td scope="row"><pre>int ctl_register(struct kern_ctl_reg *userctl,<span></span></pre></td></tr><tr><td scope="row"><pre>            kern_ctl_ref *ctlref);<span></span></pre></td></tr></table></div><p>The <code>kern_ctl_reg</code> structure contains three fields that are used to identify the control. The fields <code>ctl_id</code> and <code>ctl_name</code> can be shared across multiple controls.</p><p>The final field, <code>ctl_unit</code>, contains a value that is specific to a given control. A control can be registered multiple times with the same <code>ctl_id</code>, but for each instance a different unit number must be used. For dynamically-allocated control IDs, this value is filled in automatically.</p><p>Other fields of the <code>kern_ctl_reg</code> structure contain handler functions that you must create to handle various control requests.</p><p>The structure’s fields are defined as follows:</p><dl class="termdef">	<dt><code>ctl_name</code></dt><dd><p>a bundle ID string for your control of up to <code><!--a  -->MAX_KCTL_NAME<!--/a--></code> bytes (including the terminating null). This may be used to generate <code>ctl_id</code>.</p></dd><dt><code>ctl_id</code></dt><dd><p>a unique 4 byte ID for the control. (See note below.)</p></dd><dt><code>ctl_unit</code></dt><dd><p>the unit number for the control. The value is automatically assigned for dynamically-allocated <code>ctl_id</code> values.</p></dd><dt><code>ctl_flags</code></dt><dd><p>flags that affect the behavior of a control. You can set the <code>CTL_FLAG_PRIVILEGED</code> flag to require that the user have admin privileges to contact the control.</p><p>For more TCP-like behavior, the flag <code><!--a  -->CTL_FLAG_REG_SOCK_STREAM<!--/a--></code> may be specified to indicate that the control should be registered for stream connections rather than datagrams. Note, however, that if you set <code><!--a  -->CTL_FLAG_REG_SOCK_STREAM<!--/a--></code>, you <em>must</em> connect to the control using <code><!--a  -->SOCK_STREAM<!--/a--></code> instead of <code><!--a  -->SOCK_DGRAM<!--/a--></code>.</p></dd><dt><code>ctl_sendsize</code></dt><dd><p>size of buffer reserved for sending messages. A value of 0 indicates that the default size should be used.</p></dd><dt><code>ctl_recvsize</code></dt><dd><p>size of buffer reserved for receiving messages. A value of 0 indicates that the default size should be used.</p></dd><dt><code>ctl_connect</code></dt><dd><p>called when the client process calls connect on the socket with the ID/unit number of the registered control.</p></dd><dt><code>ctl_disconnect</code></dt><dd><p>called when the user client process closes the control socket.</p></dd><dt><code>ctl_send</code></dt><dd><p>called when the user client process writes data to the socket.</p></dd><dt><code>ctl_setopt</code></dt><dd><p>called when the user client process calls <code><!--a-->setsockopt<!--/a--></code> to set the control configuration. </p></dd><dt><code>ctl_getopt</code></dt><dd><p>called when the user client process calls <code><!--a-->getsockopt<!--/a--></code> on the socket.</p></dd></dl><div class="notebox"><a name="//apple_ref/doc/uid/TP40001858-CH227-DontLinkElementID_36" title="Note"></a><p><strong>Note:</strong>&nbsp; You may use either a registered Creator ID (available from the Apple Developer Creator ID web page at <span class="content_text"><a href="http://developer.apple.com/dev/cftype/" target="_top">http://developer.apple.com/dev/cftype/</a></span>) or you may use a dynamically-assigned ID.</p>It is strongly recommended that you use a dynamically-assigned ID. This is the default behavior. In that case, the memory referenced by the <code>ctl_id</code> field will be overwritten with the dynamically-generated ID value when <code><a href="../../../Reference/KPI_Reference/kern_control/CompositePage.html#//apple_ref/c/func/ctl_register" target="_top">ctl_register</a></code> returns.</p>If you need to use a registered ID, you must set the <code><!--a  -->CTL_FLAG_REG_ID_UNIT<!--/a--></code> flag in <code>ctl_flags</code>. If this flag is set, the value of <code>ctl_name</code> will be ignored.</p></div><p>On successful return, the second parameter, <code>ctlref</code>, will contain a reference to the registered kernel control. This reference must be used to unregister the control, and is also passed as an argument to any callbacks when they are called.</p><p>It is possible to take advantage of kernel control naming to allow processes to interact with a KEXT in different ways. A KEXT may, for example, register a root-only control for configuring the KEXT. It might register a second control, available to any process, for gathering statistics. Each instance of the control will have a different <code>ctlref</code>, and this value can then be used to determine which behavior to use.</p><p>When the kernel control receives a connection from a user-space process, the control’s <code><a href="../../../Reference/KPI_Reference/kern_control/CompositePage.html#//apple_ref/c/tdef/ctl_connect_func" target="_top">ctl_connect_func</a></code> callback is called. In this function, you should determine the unit number associated with the connection so that you can later send data back to the connecting process. You should then create a data structure (of your choosing) to store connection-specific data, and should return this structure by assignment through the <code>void **</code> handle passed in as the third parameter. This value will be passed to the other callbacks when they are called.</p><p>At this point, the user process can communicate with the control using <code><a href="../../../Reference/ManPages/man2/getsockopt.2.html#//apple_ref/doc/man/2/getsockopt" target="_top">getsockopt(2)</a></code>, <code><a href="../../../Reference/ManPages/man2/setsockopt.2.html#//apple_ref/doc/man/2/setsockopt" target="_top">setsockopt(2)</a></code>, <code><a href="../../../Reference/ManPages/man2/read.2.html#//apple_ref/doc/man/2/read" target="_top">read(2)</a></code>/<code><a href="../../../Reference/ManPages/man2/recv.2.html#//apple_ref/doc/man/2/recv" target="_top">recv(2)</a></code>, and <code><a href="../../../Reference/ManPages/man2/write.2.html#//apple_ref/doc/man/2/write" target="_top">write(2)</a></code>/<code><a href="../../../Reference/ManPages/man2/send.2.html#//apple_ref/doc/man/2/send" target="_top">send(2)</a></code> on the socket. With the exception of <code><a href="../../../Reference/ManPages/man2/recv.2.html#//apple_ref/doc/man/2/recv" target="_top">recv(2)</a></code> (which reads data from a queue), calls in user space to these functions result in a kernel-space call to the equivalent callbacks in the control, <code><a href="../../../Reference/KPI_Reference/kern_control/CompositePage.html#//apple_ref/c/tdef/ctl_getopt_func" target="_top">ctl_getopt_func</a></code>, <code><a href="../../../Reference/KPI_Reference/kern_control/CompositePage.html#//apple_ref/c/tdef/ctl_setopt_func" target="_top">ctl_setopt_func</a></code>, and <code><!--a target="_top" -->ctl_send<!--/a--></code>, respectively.</p><p>The kernel process can, in turn, call a number of functions to send data back to the user space process. This data can be read by the user process using the <code><a href="../../../Reference/ManPages/man2/read.2.html#//apple_ref/doc/man/2/read" target="_top">read(2)</a></code> or <code><a href="../../../Reference/ManPages/man2/recv.2.html#//apple_ref/doc/man/2/recv" target="_top">recv(2)</a></code> system calls. In particular, you can use <code><a href="../../../Reference/KPI_Reference/kern_control/CompositePage.html#//apple_ref/c/func/ctl_enqueuedata" target="_top">ctl_enqueuedata</a></code> and <code><a href="../../../Reference/KPI_Reference/kern_control/CompositePage.html#//apple_ref/c/func/ctl_enqueuembuf" target="_top">ctl_enqueuembuf</a></code> to queue up data to send to the user space process, and <code><a href="../../../Reference/KPI_Reference/kern_control/CompositePage.html#//apple_ref/c/func/ctl_getenqueuespace" target="_top">ctl_getenqueuespace</a></code> to find out how much free space is available in the queue.</p><p>When the user process closes the communication socket to the control, the <code><a href="../../../Reference/KPI_Reference/kern_control/CompositePage.html#//apple_ref/c/tdef/ctl_disconnect_func" target="_top">ctl_disconnect_func</a></code> callback is called. At this point, the control should free any connection-specific resources that it has allocated.</p><p><span class="content_text"><a href="control.html#//apple_ref/doc/uid/TP40001858-CH227-CHDICHGI">Listing 3-1</a></span> shows some basic example functions to use as a starting point:</p><a name="//apple_ref/doc/uid/TP40001858-CH227-CHDICHGI" title="Listing 3-1A basic kern_control example"></a><p class="codesample"><strong>Listing 3-1&nbsp;&nbsp;</strong>A basic <code>kern_control</code> example</p><div class="codesample"><table><tr><td scope="row"><pre>errno_t error;<span></span></pre></td></tr><tr><td scope="row"><pre>struct kern_ctl_reg     ep_ctl; // Initialize control<span></span></pre></td></tr><tr><td scope="row"><pre>kern_ctl_ref     kctlref;<span></span></pre></td></tr><tr><td scope="row"><pre>bzero(&amp;ep_ctl, sizeof(ep_ctl));  // sets ctl_unit to 0<span></span></pre></td></tr><tr><td scope="row"><pre>ep_ctl.ctl_id = 0; /* OLD STYLE: ep_ctl.ctl_id = kEPCommID; */<span></span></pre></td></tr><tr><td scope="row"><pre>ep_ctl.ctl_unit = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>strcpy(ep_ctl.ctl_name, "org.mklinux.nke.foo");<span></span></pre></td></tr><tr><td scope="row"><pre>ep_ctl.ctl_flags = CTL_FLAG_PRIVILEGED &amp; CTL_FLAG_REG_ID_UNIT;<span></span></pre></td></tr><tr><td scope="row"><pre>ep_ctl.ctl_send = EPHandleWrite;<span></span></pre></td></tr><tr><td scope="row"><pre>ep_ctl.ctl_getopt = EPHandleGet;<span></span></pre></td></tr><tr><td scope="row"><pre>ep_ctl.ctl_setopt = EPHandleSet;<span></span></pre></td></tr><tr><td scope="row"><pre>ep_ctl.ctl_connect = EPHandleConnect;<span></span></pre></td></tr><tr><td scope="row"><pre>ep_ctl.ctl_disconnect = EPHandleDisconnect;<span></span></pre></td></tr><tr><td scope="row"><pre>error = ctl_register(&amp;ep_ctl, &amp;kctlref);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* A simple setsockopt handler */<span></span></pre></td></tr><tr><td scope="row"><pre>errno_t EPHandleSet( kern_ctl_ref ctlref, unsigned int unit, void *userdata, int opt, void *data, size_t len )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    int    error = EINVAL;<span></span></pre></td></tr><tr><td scope="row"><pre>#if DO_LOG<span></span></pre></td></tr><tr><td scope="row"><pre>    log(LOG_ERR, "EPHandleSet opt is %d\n", opt);<span></span></pre></td></tr><tr><td scope="row"><pre>#endif<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    switch ( opt )<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        case kEPCommand1:               // program defined symbol<span></span></pre></td></tr><tr><td scope="row"><pre>            error = Do_First_Thing();<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        case kEPCommand2:               // program defined symbol<span></span></pre></td></tr><tr><td scope="row"><pre>            error = Do_Command2();<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return error;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* A simple A simple getsockopt handler */<span></span></pre></td></tr><tr><td scope="row"><pre>errno_t EPHandleGet(kern_ctl_ref ctlref, unsigned int unit, void *userdata, int opt, void *data, size_t *len)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    int    error = EINVAL;<span></span></pre></td></tr><tr><td scope="row"><pre>#if DO_LOG<span></span></pre></td></tr><tr><td scope="row"><pre>    log(LOG_ERR, "EPHandleGet opt is %d *****************\n", opt);<span></span></pre></td></tr><tr><td scope="row"><pre>#endif<span></span></pre></td></tr><tr><td scope="row"><pre>    return error;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* A minimalist connect handler */<span></span></pre></td></tr><tr><td scope="row"><pre>errno_t<span></span></pre></td></tr><tr><td scope="row"><pre>EPHandleConnect(kern_ctl_ref ctlref, struct sockaddr_ctl *sac, void **unitinfo)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>#if DO_LOG<span></span></pre></td></tr><tr><td scope="row"><pre>    log(LOG_ERR, "EPHandleConnect called\n");<span></span></pre></td></tr><tr><td scope="row"><pre>#endif<span></span></pre></td></tr><tr><td scope="row"><pre>    return (0);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* A minimalist disconnect handler */<span></span></pre></td></tr><tr><td scope="row"><pre>errno_t<span></span></pre></td></tr><tr><td scope="row"><pre>EPHandleDisconnect(kern_ctl_ref ctlref, unsigned int unit, void *unitinfo)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>#if DO_LOG<span></span></pre></td></tr><tr><td scope="row"><pre>    log(LOG_ERR, "EPHandleDisconnect called\n");<span></span></pre></td></tr><tr><td scope="row"><pre>#endif<span></span></pre></td></tr><tr><td scope="row"><pre>    return;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* A minimalist write handler */<span></span></pre></td></tr><tr><td scope="row"><pre>errno_t EPHandleWrite(kern_ctl_ref ctlref, unsigned int unit, void *userdata, mbuf_t m, int flags)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>#if DO_LOG<span></span></pre></td></tr><tr><td scope="row"><pre>    log(LOG_ERR, "EPHandleWrite called\n");<span></span></pre></td></tr><tr><td scope="row"><pre>#endif<span></span></pre></td></tr><tr><td scope="row"><pre>    return (0);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	<a name="//apple_ref/doc/uid/TP40001858-CH227-DontLinkElementID_12" title="Connection from the Client Process"></a><h3>Connection from the Client Process</h3><p>Adding <code>kern_control</code> support in your NKE is only half of the story. The other half is actually using this support from a client application.</p><p>To communicate with an NKE, you must first open a <code>PF_SYSTEM</code> socket using the <code><!--a-->socket<!--/a--></code> call as follows:</p><div class="codesample"><table><tr><td scope="row"><pre>fd = socket(PF_SYSTEM, SOCK_DGRAM, SYSPROTO_CONTROL);<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40001858-CH227-DontLinkElementID_37" title="Note"></a><p><strong>Note:</strong>&nbsp;A kernel control may register either a datagram or stream control (<code><!--a  -->SOCK_DGRAM<!--/a--></code> or <code><!--a  -->SOCK_STREAM<!--/a--></code>). If you registered your control with <code><!--a  -->CTL_FLAG_REG_SOCK_STREAM<!--/a--></code>, you should specify <code><!--a  -->SOCK_STREAM<!--/a--></code> here. Otherwise, specify <code><!--a  -->SOCK_DGRAM<!--/a--></code>.</p></div><p>Next, your application must associate the socket with a particular kernel control. To do this, the client process should call <code><a href="../../../Reference/ManPages/man2/connect.2.html#//apple_ref/doc/man/2/connect" target="_top">connect(2)</a></code> with the file descriptor returned from the <code><a href="../../../Reference/ManPages/man2/socket.2.html#//apple_ref/doc/man/2/socket" target="_top">socket(2)</a></code> call, along with a filled in <code><a href="../../../Reference/usr_APIs/kern_control/CompositePage.html#//apple_ref/c/tag/sockaddr_ctl" target="_top">sockaddr_ctl</a></code> structure containing the ID and unit number of the NKE's kernel control.</p><p>For example:</p><div class="codesample"><table><tr><td scope="row"><pre>sockaddr_ctl addr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* (initialize addr here) */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>result = connect(fd, (struct sockaddr *)&amp;addr, sizeof(addr));<span></span></pre></td></tr></table></div><p>The second parameter, of type <code><a href="../../../Reference/usr_APIs/kern_control/CompositePage.html#//apple_ref/c/tag/sockaddr_ctl" target="_top">sockaddr_ctl</a></code>, should be filled in as follows:</p><div class="codesample"><table><tr><td scope="row"><pre>addr.sc_len = sizeof(struct sockaddr_ctl);<span></span></pre></td></tr><tr><td scope="row"><pre>addr.sc_family = AF_SYSTEM;<span></span></pre></td></tr><tr><td scope="row"><pre>addr.ss_sysaddr = AF_SYS_CONTROL;<span></span></pre></td></tr><tr><td scope="row"><pre>addr.sc_id = MY_ID;     // set to value of ctl_id registered by the NKE in<span></span></pre></td></tr><tr><td scope="row"><pre>                        // the ctl_register call described above.<span></span></pre></td></tr><tr><td scope="row"><pre>addr.sc_unit = MY_UNIT; // set to the unit number registered by the NKE<span></span></pre></td></tr><tr><td scope="row"><pre>                        // in the ctl_register call described above.<span></span></pre></td></tr></table></div><p>Of course, in the case of a dynamically-generated control ID, you must obtain the value for <code>sc_id</code> using the <code>CTLIOCGINFO</code> ioctl, as shown in <span class="content_text"><a href="control.html#//apple_ref/doc/uid/TP40001858-CH227-CHDICHGI">Listing 3-1</a></span>. When using a dynamically-generated control ID, the unit number is ignored. The stack will automatically pick an unused unit number and fill in the <code>sc_unit</code> field before passing the <code><a href="../../../Reference/ManPages/man2/connect.2.html#//apple_ref/doc/man/2/connect" target="_top">connect(2)</a></code> call to the kernel control’s connect callback. While the kernel side must keep track of the unit number for sending data back to the client, from the client’s perspective, the unit number is unused.</p><p>Now that a communication channel is in place, the client process may use the <code><!--a-->setsockopt<!--/a--></code> call to send commands to the NKE, or the <code><!--a-->getsockopt<!--/a--></code> call to obtain status information from the NKE. The NKE defines which socket option names it will handle. The client process should pass only supported option names to the NKE in the <code><!--a-->setsockopt<!--/a--></code> call. However, for safety, it is the responsibility of the NKE to ignore options that it does not understand, returning <code><a href="../../../../Carbon/Reference/Open_Transport/Reference/reference.html#//apple_ref/doc/c_ref/EOPNOTSUPP" target="_top">EOPNOTSUPP</a></code>.</p><p><span class="content_text"><a href="control.html#//apple_ref/doc/uid/TP40001858-CH227-CHDHFFBA">Listing 3-2</a></span> shows a code example for opening a <code>PF_SYSTEM</code> socket to communicate with an NKE.</p><a name="//apple_ref/doc/uid/TP40001858-CH227-CHDHFFBA" title="Listing 3-2Opening a PF_SYSTEM socket to use with kern_control"></a><p class="codesample"><strong>Listing 3-2&nbsp;&nbsp;</strong>Opening a <code>PF_SYSTEM</code> socket to use with <code>kern_control</code></p><div class="codesample"><table><tr><td scope="row"><pre>    struct sockaddr_ctl       addr;<span></span></pre></td></tr><tr><td scope="row"><pre>    int                       ret = 1;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    fd = socket(PF_SYSTEM, SOCK_DGRAM, SYSPROTO_CONTROL);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (fd != -1) {<span></span></pre></td></tr><tr><td scope="row"><pre>        bzero(&amp;addr, sizeof(addr)); // sets the sc_unit field to 0<span></span></pre></td></tr><tr><td scope="row"><pre>        addr.sc_len = sizeof(addr);<span></span></pre></td></tr><tr><td scope="row"><pre>        addr.sc_family = AF_SYSTEM;<span></span></pre></td></tr><tr><td scope="row"><pre>        addr.ss_sysaddr = AF_SYS_CONTROL;<span></span></pre></td></tr><tr><td scope="row"><pre>#ifdef STATIC_ID<span></span></pre></td></tr><tr><td scope="row"><pre>        addr.sc_id = kEPCommID;  // should be unique - use a registered Creator ID here<span></span></pre></td></tr><tr><td scope="row"><pre>        addr.sc_unit = kEPCommUnit;  // should be unique.<span></span></pre></td></tr><tr><td scope="row"><pre>#else<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            struct ctl_info info;<span></span></pre></td></tr><tr><td scope="row"><pre>            memset(&amp;info, 0, sizeof(info));<span></span></pre></td></tr><tr><td scope="row"><pre>            strncpy(info.ctl_name, MYCONTROLNAME, sizeof(info.ctl_name));<span></span></pre></td></tr><tr><td scope="row"><pre>            if (ioctl(fd, CTLIOCGINFO, &amp;info)) {<span></span></pre></td></tr><tr><td scope="row"><pre>                perror("Could not get ID for kernel control.\n");<span></span></pre></td></tr><tr><td scope="row"><pre>                exit(-1);<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            addr.sc_id = info.ctl_id;<span></span></pre></td></tr><tr><td scope="row"><pre>            addr.sc_unit = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>#endif<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        result = connect(fd, (struct sockaddr *)&amp;addr, sizeof(addr));<span></span></pre></td></tr><tr><td scope="row"><pre>        if (result) {<span></span></pre></td></tr><tr><td scope="row"><pre>           fprintf(stderr, "connect failed %d\n", result);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    } else { /* no fd */<span></span></pre></td></tr><tr><td scope="row"><pre>            fprintf(stderr, "failed to open socket\n");<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (!result) {<span></span></pre></td></tr><tr><td scope="row"><pre>        result = setsockopt( fd, SYSPROTO_CONTROL, kEPCommand1, NULL, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>        if (result){<span></span></pre></td></tr><tr><td scope="row"><pre>            fprintf(stderr, "setsockopt failed on kEPCommand1 call - result was %d\n", result);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr></table></div>	<a name="//apple_ref/doc/uid/TP40001858-CH227-CHDJGEIB" title="Using the kern_event API for Kernel Notifications"></a><h2>Using the kern_event API for Kernel Notifications</h2><p>The kernel event notification mechanism, or <code>kern_event</code>, is a lightweight mechanism that allows applications to be notified when certain kernel events occur. It is a one-shot event from kernel space to user space that is broadcast to all processes that are listening. For bidirectional communication, you must use the <code>kern_control</code> API, described in <span class="content_text"><a href="control.html#//apple_ref/doc/uid/TP40001858-CH227-CHDCHEHG">“Using the Kernel Control API for KEXT Control.”</a></span></p><p>This API is relatively straightforward. At initialization time, your NKE should call <code><!--a-->kev_vendor_code_find<!--/a--></code> with the bundle name of your NKE (up to 200 characters in length). It will return a unique identifier that your KEXT should use to identify any notifications that it posts. This identifier value is not persistent across reboots.</p><p>Once you have a vendor code, your NKE can post notifications. To post a notification, your NKE calls <code><!--a-->kev_message_post<!--/a--></code> with a <code>kev_msg</code> structure containing the vendor code obtained previously, along with the event’s class, subclass, event code, and up to five pieces of data of arbitrary length associated with the event.</p><p>You can define your own class and subclass values as appropriate for your NKE. The Apple-defined class values used by kernel events built into Mac OS X can be found in the header file <code>kern_event.h</code>.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40001858-CH227-DontLinkElementID_38" title="Note"></a><p><strong>Note:</strong>&nbsp;Kernel extensions cannot post <code>KEV_VENDOR_APPLE</code> events.</p></div><a name="//apple_ref/doc/uid/TP40001858-CH227-DontLinkElementID_13" title="Receiving Kernel Event Notifications"></a><h3>Receiving Kernel Event Notifications</h3><p>To receive kernel notifications in a client application, you must first create a kernel event socket as follows:</p><div class="codesample"><table><tr><td scope="row"><pre>fd = socket(PF_SYSTEM, SOCK_RAW, SYSPROTO_EVENT);<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40001858-CH227-DontLinkElementID_39" title="Note"></a><p><strong>Note:</strong>&nbsp;Kernel event notifications can only be received by processes running as the root user.</p></div><p>Once you have created this socket, you can use this to receive event notifications. There are several ioctls available to help you filter notifications:</p><ul class="spaceabove"><li class="li"><p><code>SIOCGKEVFILT</code>—get the kernel event filter for this socket.</p></li><li class="li"><p><code>SIOCGKEVID</code>—get the current event ID pending on the socket. Each event will have a different ID.</p></li><li class="li"><p><code>SIOCGKEVVENDOR</code>—look up a vendor code.</p></li><li class="li"><p><code>SIOCSKEVFILT</code>—set the kernel event filter for this socket.</p></li></ul><p>For example, to set the event filter to filter only for Apple-generated events from AppleTalk, you might do the following:</p><div class="codesample"><table><tr><td scope="row"><pre>struct kev_request req;<span></span></pre></td></tr><tr><td scope="row"><pre>req.vendor_code=KEV_VENDOR_APPLE;<span></span></pre></td></tr><tr><td scope="row"><pre>req.kev_class=KEV_APPLESHARE_CLASS;<span></span></pre></td></tr><tr><td scope="row"><pre>req.kev_subclass=KEV_ANY_SUBCLASS;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if (ioctl(fd, SIOCSKEVFILT, &amp;req)) {<span></span></pre></td></tr><tr><td scope="row"><pre>    perror("SIOCSKEVFILT");<span></span></pre></td></tr><tr><td scope="row"><pre>    exit(-1);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Using the <code>SIOCGKEVFILT</code> ioctl is similar:</p><div class="codesample"><table><tr><td scope="row"><pre>struct kev_request req;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if (ioctl(fd, SIOCGKEVFILT, &amp;req)) {<span></span></pre></td></tr><tr><td scope="row"><pre>    perror("SIOCSKEVFILT");<span></span></pre></td></tr><tr><td scope="row"><pre>    exit(-1);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>printf("The current filter is vendor code %d, class %d, subclass %d\n",<span></span></pre></td></tr><tr><td scope="row"><pre>    req.vendor_code, req.class, req.subclass);<span></span></pre></td></tr></table></div><p>To look up a vendor code for another vendor, you might do the following:</p><div class="codesample"><table><tr><td scope="row"><pre>struct kev_vendor_code vc;<span></span></pre></td></tr><tr><td scope="row"><pre>strcpy(vc.vendor_string, "org.mklinux.driver.swim3");<span></span></pre></td></tr><tr><td scope="row"><pre>if (ioctl(fd, SIOCGKEVVENDOR, &amp;vc)) exit(-1);<span></span></pre></td></tr><tr><td scope="row"><pre>printf("Vendor code returned was %d\n", vc.vendor_code);<span></span></pre></td></tr></table></div><p>Finally, to obtain the next event ID from the socket, you might do something like this:</p><div class="codesample"><table><tr><td scope="row"><pre>uint32_t id;<span></span></pre></td></tr><tr><td scope="row"><pre>if (ioctl(fd, SIOCGKEVID, &amp;id)) exit(-1);<span></span></pre></td></tr><tr><td scope="row"><pre>printf("ID returned was %d\n", id);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001858-CH227-DontLinkElementID_14" title="Implementing a Preference File for an NKE"></a><h2>Implementing a Preference File for an NKE</h2><p>Developers often ask how an NKE can open a “preference file” in an NKE’s start function. Under the existing architecture, the NKE cannot reliably access a preference file. When the system starts the NKE, there are no APIs that the NKE can use to open a file and read preference information.</p><p>The proper way to dynamically configure an NKE is with a startup daemon or other application-level process. The daemon finds the NKE using the kernel control (<code><!--a-->kern_control<!--/a--></code>) mechanism described in <span class="content_text"><a href="control.html#//apple_ref/doc/uid/TP40001858-CH227-CHDCHEHG">“Using the Kernel Control API for KEXT Control,”</a></span> and passes in configuration information that the NKE may require.</p><a name="//apple_ref/doc/uid/TP40001858-CH227-DontLinkElementID_15" title="Helpful Tips"></a><h2>Helpful Tips</h2><p>To avoid crashes, unexplained behavior, and other pitfalls, there are a few simple rules you should follow when using <code>kern_control</code> and <code>kern_event</code> in your NKE.</p><dl class="termdef">	<dt>Unregister your control.</dt><dd><p>When someone tries to talk to you after your KEXT is unloaded, a kernel panic ensues. You must use <code><!--a-->ctl_deregister<!--/a--></code> to unregister your control before your NKE is unloaded. This call will fail if there are clients still connected to your kernel control.</p></dd><dt>The maximum data size for events is 2KB.</dt><dd><p>Data passed with the <code>kern_event</code> APIs must be sent in chunks no larger than the <code>mbuf</code> cluster size, or 2KB. Otherwise, truncation will occur.</p></dd></dl><p></p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../SocketManipulation/SocketManipulation.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../socket_nke/socket_nke.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2003, 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-03-02<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Conceptual/NKEConceptual/control/control.html%3Fid%3DTP40001858-2.3&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Conceptual/NKEConceptual/control/control.html%3Fid%3DTP40001858-2.3&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Conceptual/NKEConceptual/control/control.html%3Fid%3DTP40001858-2.3&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>