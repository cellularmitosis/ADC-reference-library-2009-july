/****************************//*   	PROCESS.C     		*//* By Brian Greenstone      *//****************************//****************************//*    EXTERNALS             *//****************************/#include <QD3D.h>#include <QD3DGeometry.h>#include <timer.h>#include "myglobals.h"#include "objects.h"#include "mymenus.h"#include "mywindows.h"#include "myevents.h"#include "misc.h"#include "process.h"#include "qd3d_support.h"#include "3dmf.h"extern	EventRecord			gTheEvent;extern	NewObjectDefinitionType	gNewObjectDefinition;extern	ObjNode				*gCurrentNode,*gFirstNodePtr;extern	float				gFramesPerSecond;/****************************//*    PROTOTYPES            *//****************************/static void InitModelWindow(void);static void BuildTestModel(void);/****************************//*    CONSTANTS             *//****************************/#define	MODEL_WIND_ID			400#define	MAKE_TRIMESH			1#define	USE_TEXTURE				1/*********************//*    VARIABLES      *//*********************/WindowPtr				gModelWindow = nil;QD3DSetupOutputType		gModelViewInfo;ObjNode					*gModelObjNode = nil;TQ3Object				gModelGroup = nil;TQ3AttributeSet			gVertAttr[3] = {nil,nil,nil};float					gCi[3] = {0,1.5,3.1};/******************** INIT TEST ************************/void InitTest(void){ObjNode *newObj;			/* INIT THE WINDOW */				InitModelWindow();			/* CREATE THE TEST MODEL */				BuildTestModel();			/* CREATE OBJNODE */				gNewObjectDefinition.genre = DISPLAY_GROUP_GENRE;									// make new one	gNewObjectDefinition.coord.x = 0;	gNewObjectDefinition.coord.y = 0;	gNewObjectDefinition.coord.z = 0;	gNewObjectDefinition.flags = OBJ_MODE_DRAW;	gNewObjectDefinition.slot = 100;	gNewObjectDefinition.moveCall = MoveModel;	newObj = MakeNewDisplayGroupObject(&gNewObjectDefinition);	gModelObjNode = newObj;																// remember this	newObj->ScaleX = newObj->ScaleY = newObj->ScaleZ = 1;	AttachGeometryToDisplayGroupObject(newObj,gModelGroup);		DrawModelWindow();}/************** INIT MODEL WINDOW *******************/static void InitModelWindow(void){QD3DSetupInputType	viewDef;TQ3Point3D			cameraFrom = { 0,0, 100 };TQ3Point3D			cameraTo = { 0, 0, 0 };TQ3Vector3D			cameraUp = { 0.0, 1.0, 0 };TQ3ColorARGB		clearColor = {1,0,0,1};TQ3ColorRGB			ambientColor = { 1.0, 1.0, 1.0 };TQ3Vector3D			fillDirection1 = {0, -.3, -.8 };TQ3Vector3D			fillDirection2 = { -.5, -.1, -.1 };			/* CREATE THE WINDOW */				gModelWindow = GetNewCWindow(MODEL_WIND_ID, NIL_POINTER,MOVE_TO_FRONT);	if (gModelWindow == nil)		DoFatalAlert("\pWhere did the GameWindow window go?");						SetPort((GrafPtr)gModelWindow);			/***********************/			/* SET QD3D PARAMETERS */			/***********************/	viewDef.view.displayWindow 		= gModelWindow;	viewDef.view.rendererType 		= kQ3RendererTypeInteractive;	viewDef.view.clearColor 		= clearColor;	viewDef.view.paneClip.left 		= 0;	viewDef.view.paneClip.right 	= 0;	viewDef.view.paneClip.top 		= 0;	viewDef.view.paneClip.bottom 	= 0; 	viewDef.styles.interpolation 	= kQ3InterpolationStyleVertex; 	viewDef.styles.backfacing 		= kQ3BackfacingStyleBoth;	viewDef.styles.fill				= kQ3FillStyleFilled; 	viewDef.styles.illuminationType	= kQ3IlluminationTypeNULL; //Lambert; 	viewDef.camera.from 			= cameraFrom;	viewDef.camera.to 				= cameraTo;	viewDef.camera.up 				= cameraUp;	viewDef.camera.hither 			= 5;	viewDef.camera.yon 				= 3000;	viewDef.camera.fov 				= 1.0;	viewDef.lights.ambientBrightness = .8;	viewDef.lights.ambientColor 	= ambientColor;	viewDef.lights.numFillLights 	= 2;	viewDef.lights.fillDirection[0] = fillDirection1;	viewDef.lights.fillDirection[1] = fillDirection2;	viewDef.lights.fillColor[0] 	= ambientColor;	viewDef.lights.fillColor[1] 	= ambientColor;	viewDef.lights.fillBrightness[0] = .9;	viewDef.lights.fillBrightness[1] = 0.4;	QD3D_SetupWindow(&viewDef, &gModelViewInfo);}/******************* DRAW MODEL WINDOW *********************///// Calls the support function QD3D_DrawScene.// It passes the view info and a pointer to the game draw callback.//void DrawModelWindow(void){	QD3D_DrawScene(&gModelViewInfo,(void *)DrawObjects);}/*************** DO MODEL WINDOW NULL EVENT **********************/void DoModelWindowNullEvent(void){	QD3D_CalcFramesPerSecond();	MoveObjects();	DrawModelWindow();}/****************** UPDATE MODEL WINDOW ******************///// Called when there is an update event from the event manager//void UpdateModelWindow(void){	DrawModelWindow();	}/***************** MOVE MODEL *********************/void MoveModel(void){ObjNode	*theNode = gCurrentNode;			/* ROTATE IT */				theNode->RotY += 1.1/gFramesPerSecond;//	theNode->RotZ += 0.5/gFramesPerSecond;	UpdateObjectTransforms(theNode);	#if 0			/* UPDATE VERT ATTRIBS */		gCi[0] += .3 / gFramesPerSecond;	gCi[1] += .7 / gFramesPerSecond;	gCi[2] += .4 / gFramesPerSecond;			if (gVertAttr[0])	{		Q3AttributeSet_Get(gVertAttr[0], kQ3AttributeTypeDiffuseColor, &color);				color.r = fabs(cos(gCi[0]));		color.g = fabs(sin(gCi[0]));		color.b = fabs(sin(gCi[0]));		Q3AttributeSet_Add(gVertAttr[0], kQ3AttributeTypeDiffuseColor, &color);				Q3AttributeSet_Get(gVertAttr[1], kQ3AttributeTypeDiffuseColor, &color);				color.r = fabs(sin(gCi[1]));		color.g = fabs(cos(gCi[1]));		color.b = fabs(sin(gCi[1]));		Q3AttributeSet_Add(gVertAttr[1], kQ3AttributeTypeDiffuseColor, &color);				Q3AttributeSet_Get(gVertAttr[2], kQ3AttributeTypeDiffuseColor, &color);				color.r = fabs(sin(gCi[2]));		color.g = fabs(cos(gCi[2]));		color.b = fabs(sin(gCi[2]));		Q3AttributeSet_Add(gVertAttr[2], kQ3AttributeTypeDiffuseColor, &color);			}#endif	}#if !MAKE_TRIMESH/********************* BUILD TEST MODEL **************************/static void BuildTestModel(void){TQ3TriangleData			myTriData;TQ3SurfaceShaderObject	texture;TQ3AttributeSet			attr;TQ3Point3D points[3] = {	0,25,0,	-25,-25,0,	25,-25,0};TQ3ColorRGB colorArray[3] ={	1,0,0,	0,1,0,	0,0,1};TQ3Param2D uvArray[3] ={	.5,1,	0,0,	1,0};TQ3ColorRGB white = {1,1,1};			/* FIRST LOAD THE TEXTUREMAP */						attr = Q3AttributeSet_New();#if USE_TEXTURE		Q3AttributeSet_Add(attr, kQ3AttributeTypeSurfaceShader, &texture);			texture = QD3D_GetTextureMap(128, nil);		#endif		Q3AttributeSet_Add(attr, kQ3AttributeTypeDiffuseColor, &white);					/* BUILD MAIN TRIANGLE DATA STRUCTURE */	myTriData.triangleAttributeSet = attr;	gVertAttr[0] = Q3AttributeSet_New();	Q3AttributeSet_Add(gVertAttr[0], kQ3AttributeTypeDiffuseColor, &colorArray[0]);		#if USE_TEXTURE		Q3AttributeSet_Add(gVertAttr[0], kQ3AttributeTypeSurfaceUV, &uvArray[0]);		#endif	gVertAttr[1] = Q3AttributeSet_New();	Q3AttributeSet_Add(gVertAttr[1], kQ3AttributeTypeDiffuseColor, &colorArray[1]);		#if USE_TEXTURE		Q3AttributeSet_Add(gVertAttr[1], kQ3AttributeTypeSurfaceUV, &uvArray[1]);		#endif	gVertAttr[2] = Q3AttributeSet_New();	Q3AttributeSet_Add(gVertAttr[2], kQ3AttributeTypeDiffuseColor, &colorArray[2]);		#if USE_TEXTURE		Q3AttributeSet_Add(gVertAttr[2], kQ3AttributeTypeSurfaceUV, &uvArray[2]);		#endif	myTriData.vertices[0].point = points[0];	myTriData.vertices[0].attributeSet = gVertAttr[0];	myTriData.vertices[1].point = points[1];	myTriData.vertices[1].attributeSet = gVertAttr[1];	myTriData.vertices[2].point = points[2];	myTriData.vertices[2].attributeSet = gVertAttr[2];			/* MAKE THE TRIANGLE GEOMETRY OBJECT */	gModelGroup = Q3Triangle_New(&myTriData);	if (gModelGroup == nil)		DoFatalAlert("\pQ3Triangle_New failed!");}#else/********************* BUILD TEST MODEL **************************/static void BuildTestModel(void){TQ3TriMeshData					myTriMeshData;TQ3TriMeshAttributeData			vertexAttribs[3],faceAttribs;TQ3Point3D points[3] = {	0,25,0,	-25,-25,0,	25,-25,0};TQ3Vector3D	vertexNormals[3] = {	0,0,1,	0,0,1,	0,0,1};TQ3Vector3D	faceNormals[1] ={	0,0,1};TQ3Param2D uvArray[3] ={	.5,1,	0,0,	1,0};TQ3ColorRGB colorArray[3] ={	1,0,0,	0,1,0,	0,0,1};TQ3TriMeshTriangleData	triangles[1] ={	0,1,2};		TQ3SurfaceShaderObject	texture;TQ3AttributeSet			attr;			/* FIRST LOAD THE TEXTUREMAP */						texture = QD3D_GetTextureMap(128, nil);			attr = Q3AttributeSet_New();#if USE_TEXTURE		Q3AttributeSet_Add(attr, kQ3AttributeTypeSurfaceShader, &texture);		#endif				/* BUILD MAIN TRIMESH DATA STRUCTURE */	myTriMeshData.triMeshAttributeSet = attr;	myTriMeshData.numTriangles = 1;	myTriMeshData.triangles = &triangles[0];	myTriMeshData.numTriangleAttributeTypes = 1;	myTriMeshData.triangleAttributeTypes = &faceAttribs;	myTriMeshData.numEdges = 0;	myTriMeshData.edges = nil;	myTriMeshData.numEdgeAttributeTypes = 0;	myTriMeshData.edgeAttributeTypes = nil;	myTriMeshData.numPoints = 3;	myTriMeshData.points = &points[0];#if USE_TEXTURE		myTriMeshData.numVertexAttributeTypes = 2;#else	myTriMeshData.numVertexAttributeTypes = 1;	#endif	 	myTriMeshData.vertexAttributeTypes = &vertexAttribs[0];			/* CALCULATE BOUNDING BOX */	Q3BoundingBox_SetFromPoints3D(&myTriMeshData.bBox, &points[0],	3, sizeof(TQ3Point3D));			/* CREATE FACE ATTRIBUTES */ 	faceAttribs.attributeType = kQ3AttributeTypeNormal;	faceAttribs.data = &faceNormals[0];	faceAttribs.attributeUseArray = nil;			/* CREATE VERTEX ATTRIBUTES */ 	vertexAttribs[0].attributeType = kQ3AttributeTypeDiffuseColor;	vertexAttribs[0].data = &colorArray[0];	vertexAttribs[0].attributeUseArray = nil;#if USE_TEXTURE		vertexAttribs[1].attributeType = kQ3AttributeTypeSurfaceUV;	vertexAttribs[1].data = &uvArray[0];	vertexAttribs[1].attributeUseArray = nil;#endif		/* MAKE THE TRIMESH GEOMETRY OBJECT */	gModelGroup = Q3TriMesh_New(&myTriMeshData);	if (gModelGroup == nil)		DoFatalAlert("\pQ3TriMesh_New failed!");}#endif