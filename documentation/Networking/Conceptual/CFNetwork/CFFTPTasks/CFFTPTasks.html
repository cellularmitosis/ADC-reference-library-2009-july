<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>CFNetwork Programming Guide: Working with FTP Servers</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Working with FTP Servers"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30001132-CH9" title="Working with FTP Servers"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000429" target="_top">Networking</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP30001132-CH1-DontLinkElementID_24">CFNetwork Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../CFHTTPAuthenticationTasks/CFHTTPAuthenticationTasks.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../UsingNetworkDiagnostics/UsingNetworkDiagnostics.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30001132-CH9-SW1" title="Working with FTP Servers"></a><h1>Working with FTP Servers</h1><p>This chapter explains how to use some of the basic features of the CFFTP API. Managing the FTP transactions is performed asynchronously, while managing the file transfer is implemented synchronously.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="CFFTPTasks.html#//apple_ref/doc/uid/TP30001132-CH9-DontLinkElementID_1">Downloading a File</a>
				
			<br/>
			
        
			
			
				<a href="CFFTPTasks.html#//apple_ref/doc/uid/TP30001132-CH9-DontLinkElementID_3">Uploading a File</a>
				
			<br/>
			
        
			
			
				<a href="CFFTPTasks.html#//apple_ref/doc/uid/TP30001132-CH9-DontLinkElementID_4">Creating a Remote Directory</a>
				
			<br/>
			
        
			
			
				<a href="CFFTPTasks.html#//apple_ref/doc/uid/TP30001132-CH9-DontLinkElementID_5">Downloading a Directory Listing</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30001132-CH9-DontLinkElementID_1" title="Downloading a File"></a><h2>Downloading a File</h2><p>Using CFFTP is very similar to using CFHTTP because they are both based on CFStream. As with any other API that uses CFStream asynchronously, downloading a file with CFFTP requires that you create a read stream for the file, and a callback function for that read stream. When the read stream receives data, the callback function will be run and you will need to appropriately download the bytes. This procedure should normally be performed using two functions: one to set up the streams and one to act as the callback function.</p><a name="//apple_ref/doc/uid/TP30001132-CH9-SW2" title="Setting Up the FTP Streams"></a><h3>Setting Up the FTP Streams</h3><p>Begin by creating a read stream using the <code><a href="../../../../CoreFoundation/Reference/CFFTPStreamRef/Reference/reference.html#//apple_ref/doc/c_ref/CFReadStreamCreateWithFTPURL" target="_top">CFReadStreamCreateWithFTPURL</a></code> function and passing it the URL string of the file to be downloaded on the remote server. An example of a URL string might be <code>ftp://ftp.example.com/file.txt</code>. Note that the string contains the server name, the path, and the file. Next, create a write stream for the local location where the file will be downloaded. This is accomplished using the <code><a href="../../../../CoreFoundation/Reference/CFWriteStreamRef/Reference/reference.html#//apple_ref/doc/c_ref/CFWriteStreamCreateWithFile" target="_top">CFWriteStreamCreateWithFile</a></code> function, passing the path where the file will be downloaded.</p><p>Since the write stream and the read stream need to stay in sync, it is a good idea to create a structure that contains all of the common information, such as the proxy dictionary, the file size, the number of bytes written, the number of bytes left over, and a buffer. This structure might look like that in <span class="content_text">Listing 5-1</span>.</p><a name="//apple_ref/doc/uid/TP30001132-CH9-SW4" title="Listing 5-1A stream structure"></a><p class="codesample"><strong>Listing 5-1&nbsp;&nbsp;</strong>A stream structure</p><div class="codesample"><table><tr><td scope="row"><pre>typedef struct MyStreamInfo {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    CFWriteStreamRef  writeStream;<span></span></pre></td></tr><tr><td scope="row"><pre>    CFReadStreamRef   readStream;<span></span></pre></td></tr><tr><td scope="row"><pre>    CFDictionaryRef   proxyDict;<span></span></pre></td></tr><tr><td scope="row"><pre>    SInt64            fileSize;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32            totalBytesWritten;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32            leftOverByteCount;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt8             buffer[kMyBufferSize];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>} MyStreamInfo;<span></span></pre></td></tr></table></div><p>Initialize your structure with the read stream and write stream you just created. You can then define the <code>info</code> field of your stream client context (<code>CFStreamClientContext</code>) to point to your structure. This will become useful later.</p><p>Open your write stream with the <code><a href="../../../../CoreFoundation/Reference/CFWriteStreamRef/Reference/reference.html#//apple_ref/doc/c_ref/CFWriteStreamOpen" target="_top">CFWriteStreamOpen</a></code> function so you can begin writing to the local file. To make sure the stream opens properly, call the function <code><a href="../../../../CoreFoundation/Reference/CFWriteStreamRef/Reference/reference.html#//apple_ref/doc/c_ref/CFWriteStreamGetStatus" target="_top">CFWriteStreamGetStatus</a></code> and check whether it returns either <code>kCFStreamStatusOpen</code> or <code>kCFStreamStatusOpening</code>.</p><p>With the write stream open, associate a callback function with the read stream. Call the function <code><a href="../../../../CoreFoundation/Reference/CFReadStreamRef/Reference/reference.html#//apple_ref/doc/c_ref/CFReadStreamSetClient" target="_top">CFReadStreamSetClient</a></code> and pass the read stream, the network events your callback function should receive, the callback function's name and the <code>CFStreamClientContext</code> object. By having earlier set the <code>info</code> field of the stream client context, your structure will now be sent to your callback function whenever it is run.</p><p>Some FTP servers may require a user name, and some may also require a password. If the server you are accessing needs a user name for authentication, call the <code><a href="../../../../CoreFoundation/Reference/CFReadStreamRef/Reference/reference.html#//apple_ref/doc/c_ref/CFReadStreamSetProperty" target="_top">CFReadStreamSetProperty</a></code> function and pass the read stream, <code>kCFStreamPropertyFTPUserName</code> for the property, and a reference to a <code>CFString</code> object containing the user name. In addition, if you need to set a password, set the <code>kCFStreamPropertyFTPPassword</code> property.</p><p>Some computers may also use FTP proxies. Retrieve the proxy settings in a dictionary by calling the <code><!--a-->SCDynamicStoreCopyProxies<!--/a--></code> function and passing it <code>NULL</code>. The function then returns a dynamic store reference. Then set the <code>kCFStreamPropertyFTPProxy</code> property of the read stream, and pass the proxy dictionary as the value. This sets the proxy server, specifies the port, and returns a Boolean value indicating whether passive mode is enforced for the FTP stream.</p><p>In addition to the properties mentioned, there are a number of other properties available for FTP streams. The complete list follows.</p><ul class="spaceabove"><li class="li"><p><code>kCFStreamPropertyFTPUserName</code> — user name to use to log in (settable and retrievable; do not set for anonymous FTP connections)</p></li><li class="li"><p><code>kCFStreamPropertyFTPPassword</code> — password to use to log in (settable and retrievable; do not set for anonymous FTP connections)</p></li><li class="li"><p><code>kCFStreamPropertyFTPUsePassiveMode</code> — whether to use passive mode (settable and retrievable)</p></li><li class="li"><p><code>kCFStreamPropertyFTPResourceSize</code> — the expected size of an item that is being downloaded, if available (retrievable; available only for FTP read streams)</p></li><li class="li"><p><code>kCFStreamPropertyFTPFetchResourceInfo</code> — whether to require that resource information, such as size, be required before starting a download (settable and retrievable); setting this property may impact performance</p></li><li class="li"><p><code>kCFStreamPropertyFTPFileTransferOffset</code> — file offset at which to start a transfer (settable and retrievable)</p></li><li class="li"><p><code>kCFStreamPropertyFTPAttemptPersistentConnection</code> — whether to try to reuse connections (settable and retrievable)</p></li><li class="li"><p><code>kCFStreamPropertyFTPProxy</code> — CFDictionary type that holds key-value pairs of proxy dictionary (settable and retrievable)</p></li><li class="li"><p><code>kCFStreamPropertyFTPProxyHost</code> — name of an FTP proxy host (settable and retrievable) </p></li><li class="li"><p><code>kCFStreamPropertyFTPProxyPort</code> — port number of an FTP proxy host (settable and retrievable)</p></li></ul><p>After the correct properties have been assigned to the read stream, open the stream using the <code><a href="../../../../CoreFoundation/Reference/CFReadStreamRef/Reference/reference.html#//apple_ref/doc/c_ref/CFReadStreamOpen" target="_top">CFReadStreamOpen</a></code> function. Assuming that this does not return an error, all the streams have been properly set up.</p><a name="//apple_ref/doc/uid/TP30001132-CH9-DontLinkElementID_2" title="Implementing the Callback Function"></a><h3>Implementing the Callback Function</h3><p>Your callback function will receive three parameters: the read stream, the type of event, and your <code>MyStreamInfo</code> structure. The type of event determines what action must be taken.</p><p>The most common event is <code>kCFStreamEventHasBytesAvailable</code>, which is sent when the read stream has received bytes from the server. First, check how many bytes have been read by calling the <code><a href="../../../../CoreFoundation/Reference/CFReadStreamRef/Reference/reference.html#//apple_ref/doc/c_ref/CFReadStreamRead" target="_top">CFReadStreamRead</a></code> function. Make sure the return value is not less than zero (an error), or equal to zero (download has completed). If the return value is positive, then you can begin writing the data in the read stream to disk via the write stream.</p><p>Call the <code><a href="../../../../CoreFoundation/Reference/CFWriteStreamRef/Reference/reference.html#//apple_ref/doc/c_ref/CFWriteStreamWrite" target="_top">CFWriteStreamWrite</a></code> function to write the data to the write stream. Sometimes <code><a href="../../../../CoreFoundation/Reference/CFWriteStreamRef/Reference/reference.html#//apple_ref/doc/c_ref/CFWriteStreamWrite" target="_top">CFWriteStreamWrite</a></code> can return without writing all of the data from the read stream. For this reason, set up a loop to run as long as there is still data to be written. The code for this loop is in <span class="content_text">Listing 5-2</span>, where <code>info</code> is the <code>MyStreamInfo</code> structure from <span class="content_text"><a href="CFFTPTasks.html#//apple_ref/doc/uid/TP30001132-CH9-SW2">“Setting up the Streams.”</a></span> This method of writing to the write stream uses blocking streams. You can achieve better performance by making the write stream event driven, but the code is more complex.</p><a name="//apple_ref/doc/uid/TP30001132-CH9-SW5" title="Listing 5-2Writing data to a write stream from the read stream"></a><p class="codesample"><strong>Listing 5-2&nbsp;&nbsp;</strong>Writing data to a write stream from the read stream</p><div class="codesample"><table><tr><td scope="row"><pre>bytesRead = CFReadStreamRead(info->readStream, info->buffer, kMyBufferSize);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>//...make sure bytesRead > 0 ...<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>bytesWritten = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>while (bytesWritten &lt; bytesRead) {<span></span></pre></td></tr><tr><td scope="row"><pre>    CFIndex result;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    result = CFWriteStreamWrite(info->writeStream, info->buffer + bytesWritten, bytesRead - bytesWritten);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (result &lt;= 0) {<span></span></pre></td></tr><tr><td scope="row"><pre>        fprintf(stderr, "CFWriteStreamWrite returned %ld\n", result);<span></span></pre></td></tr><tr><td scope="row"><pre>        goto exit;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    bytesWritten += result;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>info->totalBytesWritten += bytesWritten;<span></span></pre></td></tr></table></div><p>Repeat this entire procedure as long as there are available bytes in the read stream.</p><p>The other two events you need to watch out for are <code>kCFStreamEventErrorOccurred</code> and <code>kCFStreamEventEndEncountered</code>. If an error occurs, retrieve the error using <code><a href="../../../../CoreFoundation/Reference/CFReadStreamRef/Reference/reference.html#//apple_ref/doc/c_ref/CFReadStreamGetError" target="_top">CFReadStreamGetError</a></code> and then exit. If the end of the file occurs, then your download has completed and you can exit. </p><p>Make sure to remove all your streams after everything is completed and no other process is using the streams. First, close the write stream and set the client to <code>NULL</code>. Then unschedule the stream from the run loop and release it. Remove the streams from the run loop when you are done.</p><a name="//apple_ref/doc/uid/TP30001132-CH9-DontLinkElementID_3" title="Uploading a File"></a><h2>Uploading a File</h2><p>Uploading a file is similar to downloading a file. As with downloading a file, you need a read stream and a write stream. However, when uploading a file, the read stream will be for the local file and the write stream will be for the remote file. Follow the instructions in <span class="content_text"><a href="CFFTPTasks.html#//apple_ref/doc/uid/TP30001132-CH9-SW2">“Setting up the Streams,”</a></span> but wherever it refers to the read stream, adapt the code for a write stream and visa versa.</p><p>In the callback function, rather than looking for the <code>kCFStreamEventHasBytesAvailable</code> event, now look for the event <code>kCFStreamEventCanAcceptBytes</code>. First, read bytes from the file using the read stream and place the data into the buffer in <code>MyStreamInfo</code>. Then, run the <code><a href="../../../../CoreFoundation/Reference/CFWriteStreamRef/Reference/reference.html#//apple_ref/doc/c_ref/CFWriteStreamWrite" target="_top">CFWriteStreamWrite</a></code> function to push bytes from the buffer into the write stream. <code><a href="../../../../CoreFoundation/Reference/CFWriteStreamRef/Reference/reference.html#//apple_ref/doc/c_ref/CFWriteStreamWrite" target="_top">CFWriteStreamWrite</a></code> returns the number of bytes that have been written to the stream. If the number of bytes written to the stream is fewer than the number read from the file, calculate the leftover bytes and store them back into the buffer. During the next write cycle, if there are leftover bytes, write them to the write stream rather than loading new data from the read stream. Repeat this whole procedure as long as the write stream can accept bytes (<code><a href="../../../../CoreFoundation/Reference/CFWriteStreamRef/Reference/reference.html#//apple_ref/doc/c_ref/CFWriteStreamCanAcceptBytes" target="_top">CFWriteStreamCanAcceptBytes</a></code>). See this loop in code in <span class="content_text">Listing 5-3</span>.</p><a name="//apple_ref/doc/uid/TP30001132-CH9-SW6" title="Listing 5-3Writing data to the write stream"></a><p class="codesample"><strong>Listing 5-3&nbsp;&nbsp;</strong>Writing data to the write stream</p><div class="codesample"><table><tr><td scope="row"><pre>do {<span></span></pre></td></tr><tr><td scope="row"><pre>    // Check for leftover data<span></span></pre></td></tr><tr><td scope="row"><pre>    if (info->leftOverByteCount > 0) {<span></span></pre></td></tr><tr><td scope="row"><pre>        bytesRead = info->leftOverByteCount;<span></span></pre></td></tr><tr><td scope="row"><pre>    } else {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Make sure there is no error reading from the file<span></span></pre></td></tr><tr><td scope="row"><pre>        bytesRead = CFReadStreamRead(info->readStream, info->buffer,<span></span></pre></td></tr><tr><td scope="row"><pre>                                     kMyBufferSize);<span></span></pre></td></tr><tr><td scope="row"><pre>        if (bytesRead &lt; 0) {<span></span></pre></td></tr><tr><td scope="row"><pre>            fprintf(stderr, "CFReadStreamRead returned %ld\n", bytesRead);<span></span></pre></td></tr><tr><td scope="row"><pre>            goto exit;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        totalBytesRead += bytesRead;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Write the data to the write stream<span></span></pre></td></tr><tr><td scope="row"><pre>     bytesWritten = CFWriteStreamWrite(info->writeStream, info->buffer, bytesRead);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (bytesWritten > 0) {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        info->totalBytesWritten += bytesWritten;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Store leftover data until kCFStreamEventCanAcceptBytes event occurs again<span></span></pre></td></tr><tr><td scope="row"><pre>        if (bytesWritten &lt; bytesRead) {<span></span></pre></td></tr><tr><td scope="row"><pre>            info->leftOverByteCount = bytesRead - bytesWritten;<span></span></pre></td></tr><tr><td scope="row"><pre>            memmove(info->buffer, info->buffer + bytesWritten,<span></span></pre></td></tr><tr><td scope="row"><pre>                    info->leftOverByteCount);<span></span></pre></td></tr><tr><td scope="row"><pre>        } else {<span></span></pre></td></tr><tr><td scope="row"><pre>            info->leftOverByteCount = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    } else {<span></span></pre></td></tr><tr><td scope="row"><pre>        if (bytesWritten &lt; 0)<span></span></pre></td></tr><tr><td scope="row"><pre>            fprintf(stderr, "CFWriteStreamWrite returned %ld\n", bytesWritten);<span></span></pre></td></tr><tr><td scope="row"><pre>        break;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>} while (CFWriteStreamCanAcceptBytes(info->writeStream));<span></span></pre></td></tr></table></div><p>Also account for the <code>kCFStreamEventErrorOccurred</code> and <code>kCFStreamEventEndEncountered</code> events as you do when downloading a file.</p><a name="//apple_ref/doc/uid/TP30001132-CH9-DontLinkElementID_4" title="Creating a Remote Directory"></a><h2>Creating a Remote Directory</h2><p>To create a directory on a remote server, set up a write stream as if you were going to be uploading a file. However, provide a directory path, not a file, for the <code>CFURL</code> object that is passed to the <code><a href="../../../../CoreFoundation/Reference/CFFTPStreamRef/Reference/reference.html#//apple_ref/doc/c_ref/CFWriteStreamCreateWithFTPURL" target="_top">CFWriteStreamCreateWithFTPURL</a></code> function. End the path with a forward slash. For example, a proper directory path would be <code>ftp://ftp.example.com/newDirectory/</code>, not <code>ftp://ftp.example.com/newDirectory/newFile.txt</code>. When the callback function is executed by the run loop, it sends the event <code>kCFStreamEventOpenCompleted</code>, which means the directory has been created.</p><p>Only one level of directories can be created with each call to <code><a href="../../../../CoreFoundation/Reference/CFFTPStreamRef/Reference/reference.html#//apple_ref/doc/c_ref/CFWriteStreamCreateWithFTPURL" target="_top">CFWriteStreamCreateWithFTPURL</a></code>. Also, a directory is created only if you have the correct permissions on the server.</p><a name="//apple_ref/doc/uid/TP30001132-CH9-DontLinkElementID_5" title="Downloading a Directory Listing"></a><h2>Downloading a Directory Listing</h2><p>Downloading a directory listing via FTP is slightly different from downloading or uploading a file. This is because the incoming data has to be parsed. First, set up a read stream to get the directory listing. This should be done as it was for downloading a file: create the stream, register a callback function, schedule the stream with the run loop (if necessary, set up user name, password and proxy information), and finally open the stream. In the following example you do not need both a read and a write stream when retrieving the directory listing, because the incoming data is going to the screen rather than a file.</p><p>In the callback function, watch for the <code>kCFStreamEventHasBytesAvailable</code> event. Prior to loading data from the read stream, make sure there is no leftover data in the stream from the previous time the callback function was run. Load the offset from the <code>leftOverByteCount</code> field of your <code>MyStreamInfo</code> structure. Then, read data from the stream, taking into account the offset you just calculated. The buffer size and number of bytes read should be calculated too. This is all accomplished in <span class="content_text">Listing 5-4</span>.</p><a name="//apple_ref/doc/uid/TP30001132-CH9-SW3" title="Listing 5-4Loading data for a directory listing"></a><p class="codesample"><strong>Listing 5-4&nbsp;&nbsp;</strong>Loading data for a directory listing</p><div class="codesample"><table><tr><td scope="row"><pre>// If previous call had unloaded data<span></span></pre></td></tr><tr><td scope="row"><pre>int offset = info->leftOverByteCount;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Load data from the read stream, accounting for the offset<span></span></pre></td></tr><tr><td scope="row"><pre>bytesRead = CFReadStreamRead(info->readStream, info->buffer + offset,<span></span></pre></td></tr><tr><td scope="row"><pre>                             kMyBufferSize - offset);<span></span></pre></td></tr><tr><td scope="row"><pre>if (bytesRead &lt; 0) {<span></span></pre></td></tr><tr><td scope="row"><pre>    fprintf(stderr, "CFReadStreamRead returned %ld\n", bytesRead);<span></span></pre></td></tr><tr><td scope="row"><pre>    break;<span></span></pre></td></tr><tr><td scope="row"><pre>} else if (bytesRead == 0) {<span></span></pre></td></tr><tr><td scope="row"><pre>    break;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>bufSize = bytesRead + offset;<span></span></pre></td></tr><tr><td scope="row"><pre>totalBytesRead += bufSize;<span></span></pre></td></tr></table></div><p>After the data has been read to a buffer, set up a loop to parse the data. The data that is parsed is not necessarily the entire directory listing; it could (and probably will) be chunks of the listing. Create the loop to parse the data using the function <code><a href="../../../../CoreFoundation/Reference/CFFTPStreamRef/Reference/reference.html#//apple_ref/doc/c_ref/CFFTPCreateParsedResourceListing" target="_top">CFFTPCreateParsedResourceListing</a></code>, which should be passed the buffer of data, the size of the buffer, and a dictionary reference. It returns the number of bytes parsed. As long as this value is greater than zero, continue to loop. The dictionary that <code><a href="../../../../CoreFoundation/Reference/CFFTPStreamRef/Reference/reference.html#//apple_ref/doc/c_ref/CFFTPCreateParsedResourceListing" target="_top">CFFTPCreateParsedResourceListing</a></code> creates contains all the directory listing information; more information about the keys is available in <span class="content_text"><a href="CFFTPTasks.html#//apple_ref/doc/uid/TP30001132-CH9-SW2">“Setting up the Streams.”</a></span></p><p>It is possible for <code>CFFTPCreateParsedResourceListing</code> to return a positive value, but not create a parse dictionary. For example, if the end of the listing contains information that cannot be parsed, <code>CFFTPCreateParsedResourceListing</code> will return a positive value to tell the caller that data has been consumed. However, <code>CFFTPCreateParsedResourceListing</code> will not create a parse dictionary since it could not understand the data.</p><p>If a parse dictionary is created, recalculate the number of bytes read and the buffer size as shown in <span class="content_text">Listing 5-5</span>.</p><a name="//apple_ref/doc/uid/TP30001132-CH9-SW7" title="Listing 5-5Loading the directory listing and parsing it"></a><p class="codesample"><strong>Listing 5-5&nbsp;&nbsp;</strong>Loading the directory listing and parsing it</p><div class="codesample"><table><tr><td scope="row"><pre>do<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    bufRemaining = info->buffer + totalBytesConsumed;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    bytesConsumed = CFFTPCreateParsedResourceListing(NULL, bufRemaining,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                     bufSize, &amp;parsedDict);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (bytesConsumed > 0) {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Make sure CFFTPCreateParsedResourceListing was able to properly<span></span></pre></td></tr><tr><td scope="row"><pre>        // parse the incoming data<span></span></pre></td></tr><tr><td scope="row"><pre>        if (parsedDict != NULL) {<span></span></pre></td></tr><tr><td scope="row"><pre>            // ...Print out data from parsedDict...<span></span></pre></td></tr><tr><td scope="row"><pre>            CFRelease(parsedDict);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        totalBytesConsumed += bytesConsumed;<span></span></pre></td></tr><tr><td scope="row"><pre>        bufSize -= bytesConsumed;<span></span></pre></td></tr><tr><td scope="row"><pre>        info->leftOverByteCount = bufSize;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    } else if (bytesConsumed == 0) {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // This is just in case. It should never happen due to the large buffer size<span></span></pre></td></tr><tr><td scope="row"><pre>        info->leftOverByteCount = bufSize;<span></span></pre></td></tr><tr><td scope="row"><pre>        totalBytesRead -= info->leftOverByteCount;<span></span></pre></td></tr><tr><td scope="row"><pre>        memmove(info->buffer, bufRemaining, info->leftOverByteCount);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    } else if (bytesConsumed == -1) {<span></span></pre></td></tr><tr><td scope="row"><pre>        fprintf(stderr, "CFFTPCreateParsedResourceListing parse failure\n");<span></span></pre></td></tr><tr><td scope="row"><pre>        // ...Break loop and cleanup...<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>} while (bytesConsumed > 0);<span></span></pre></td></tr></table></div><p>When the stream has no more bytes available, clean up all the streams and remove them from the run loop.</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../CFHTTPAuthenticationTasks/CFHTTPAuthenticationTasks.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../UsingNetworkDiagnostics/UsingNetworkDiagnostics.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-05-06<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Networking/Conceptual/CFNetwork/CFFTPTasks/CFFTPTasks.html%3Fid%3DTP30001132-6.3&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Networking/Conceptual/CFNetwork/CFFTPTasks/CFFTPTasks.html%3Fid%3DTP30001132-6.3&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Networking/Conceptual/CFNetwork/CFFTPTasks/CFFTPTasks.html%3Fid%3DTP30001132-6.3&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>