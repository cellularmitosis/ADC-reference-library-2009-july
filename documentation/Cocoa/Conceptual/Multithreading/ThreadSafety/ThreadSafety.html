<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Threading Programming Guide: Synchronization and Thread Safety</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Synchronization and Thread Safety"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/10000057i-CH8" title="Synchronization and Thread Safety"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../ProcessManagement-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000456" target="_top">Process Management</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/10000057i-CH1-SW1">Threading Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../CreatingThreads/CreatingThreads.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../RunLoopManagement/RunLoopManagement.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/10000057i-CH8-SW1" title="Synchronization and Thread Safety"></a><h1>Synchronization and Thread Safety</h1><p>The presence of multiple threads in an application opens up potential issues regarding safe access to resources from multiple threads of execution. Two threads modifying the same resource might interfere with each other in unintended ways. For example, one thread might overwrite another’s changes or put the application into an unknown and potentially invalid state. If you are lucky, the corrupted resource might cause obvious performance problems or crashes that are relatively easy to track down and fix. If you are unlucky, however, the corruption may cause subtle errors that do not manifest themselves until much later, or the errors might require a significant overhaul of your underlying coding assumptions.</p><p>When it comes to thread safety, a good design is the best protection you have. Avoiding shared resources and minimizing the interactions between your threads makes it less likely for those threads to interfere with each other. A completely interference-free design is not always possible, however. In cases where your threads must interact, you need to use synchronization tools to ensure that when they interact, they do so safely. </p><p>Mac OS X provides numerous synchronization tools for you to use, ranging from tools that provide mutually exclusive access to those that sequence events correctly in your application. The following sections describe these tools and how you use them in your code to affect safe access to your program’s resources. </p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-124887">Synchronization Tools</a>
				
			<br/>
			
        
			
			
				<a href="ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW10">Synchronization and Performance</a>
				
			<br/>
			
        
			
			
				<a href="ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW13">Thread Safety and Signals</a>
				
			<br/>
			
        
			
			
				<a href="ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW6">Tips for Thread-Safe Designs</a>
				
			<br/>
			
        
			
			
				<a href="ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW14">Using Atomic Operations</a>
				
			<br/>
			
        
			
			
				<a href="ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW16">Using Locks</a>
				
			<br/>
			
        
			
			
				<a href="ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW4">Using Conditions</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/10000057i-CH8-124887" title="Synchronization Tools"></a><h2>Synchronization Tools</h2><p>To prevent different threads from changing data unexpectedly, you can either design your application to not have synchronization issues or you can use synchronization tools. Although avoiding synchronization issues altogether is preferable, it is not always possible. The following sections describe the basic categories of synchronization tools available for you to use. </p><a name="//apple_ref/doc/uid/10000057i-CH8-SW2" title="Atomic Operations"></a><h3>Atomic Operations</h3><p>Atomic operations are a simple form of synchronization that work on simple data types. The advantage of atomic operations is that they do not block competing threads. For simple operations, such as incrementing a counter variable, this can lead to much better performance than taking a lock. </p><p>Mac OS X includes numerous operations to perform basic mathematical and logical operations on 32-bit and 64-bit values. Among these operations are atomic versions of the compare-and-swap, test-and-set, and test-and-clear operations. For a list of supported atomic operations, see the <code>/usr/include/libkern/OSAtomic.h</code> header file or see the <code><a href="../../../../Darwin/Reference/ManPages/man3/atomic.3.html#//apple_ref/doc/man/3/atomic" target="_top">atomic</a></code> man page. </p><a name="//apple_ref/doc/uid/10000057i-CH8-SW9" title="Memory Barriers and Volatile Variables"></a><h3>Memory Barriers and Volatile Variables</h3><p>In order to achieve optimal performance, compilers often reorder assembly-level instructions to keep the instruction pipeline for the processor as full as possible. As part of this optimization, the compiler may reorder instructions that access main memory when it thinks doing so would not generate incorrect data. Unfortunately, it is not always possible for the compiler to detect all memory-dependent operations. If seemingly separate variables actually influence each other, the compiler optimizations could update those variables in the wrong order, generating potentially incorrect results. </p><p>A memory barrier is a type of nonblocking synchronization tool used to ensure that memory operations occur in the correct order. A memory barrier acts like a fence, forcing the processor to complete any load and store operations positioned in front of the barrier before it is allowed to perform load and store operations positioned after the barrier. Memory barriers are typically used to ensure that memory operations by one thread (but visible to another) always occur in an expected order. The lack of a memory barrier in such a situation might allow other threads to see seemingly impossible results. (For an example, see the Wikipedia entry for <span class="content_text"><a href="http://en.wikipedia.org/wiki/Memory_barrier" target="_blank">memory barriers</a></span>.) To employ a memory barrier, you simply call the <code>OSMemoryBarrier</code> function at the appropriate point in your code.</p><p>Volatile variables apply another type of memory constraint to individual variables. The compiler often optimizes code by loading the values for variables into registers. For local variables, this is usually not a problem. If the variable is visible from another thread however, such an optimization might prevent the other thread from noticing any changes to it. Applying the <code>volatile</code> keyword to a variable forces the compiler to load that variable from memory each time it is used. You might declare a variable as <code>volatile</code> if its value could be changed at any time by an external source that the compiler may not be able to detect.</p><p>Because both memory barriers and volatile variables decrease the number of optimizations the compiler can perform, they should be used sparingly and only where needed to ensure correctness. For information about using memory barriers, see the  <code><a href="../../../../Darwin/Reference/ManPages/man3/OSMemoryBarrier.3.html#//apple_ref/doc/man/3/OSMemoryBarrier" target="_top">OSMemoryBarrier</a></code> man page.</p><a name="//apple_ref/doc/uid/10000057i-CH8-126320" title="Locks"></a><h3>Locks</h3><p>Locks are one of the most commonly used synchronization tools. You can use locks to protect a <strong>critical section</strong> of your code, which is a segment of code that only one thread at a time is allowed access. For example, a critical section might manipulate a particular data structure or use some resource that supports at most one client at a time. By placing a lock around this section, you exclude other threads from making changes that might affect the correctness of your code. </p><p><span class="content_text">Table 4-1</span> lists some of the locks that are commonly used by programmers. Mac OS X provides implementations for most of these lock types, but not all of them. For unsupported lock types, the description column explains the reasons why those locks are not implemented directly on the platform.</p><a name="//apple_ref/doc/uid/10000057i-CH8-SW5" title="Table 4-1Lock types"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 4-1&nbsp;&nbsp;</strong>Lock types</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Lock</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p>Mutex</p></td><td ><p><a name="//apple_ref/doc/uid/10000057i-CH8-DontLinkElementID_17"></a>A mutually exclusive (or <strong>mutex</strong>) lock acts as a protective barrier around a resource. A mutex is a type of semaphore that grants access to only one thread at a time. If a mutex is in use and another thread tries to acquire it, that thread blocks until the mutex is released by its original holder. If multiple threads compete for the same mutex, only one at a time is allowed access to it.</p></td></tr><tr><td  scope="row"><p>Recursive lock</p></td><td ><p>A recursive lock is a variant on the mutex lock. A recursive lock allows a single thread to acquire the lock multiple times before releasing it. Other threads remain blocked until the owner of the lock releases the lock the same number of times it acquired it. Recursive locks are used during recursive iterations primarily but may also be used in cases where multiple methods each need to acquire the lock separately.  </p></td></tr><tr><td  scope="row"><p>Read-write lock</p></td><td ><p>A read-write lock is also referred to as a shared-exclusive lock. This type of lock is typically used in larger-scale operations and can significantly improve performance if the protected data structure is read frequently and modified only occasionally. During normal operation, multiple readers can access the data structure simultaneously. When a thread wants to write to the structure, though, it blocks until all readers release the lock, at which point it acquires the lock and can update the structure. While a writing thread is waiting for the lock, new reader threads block until the writing thread is finished. Mac OS X supports read-write locks using POSIX threads only. For more information on how to use these locks, see the <code><a href="../../../../Darwin/Reference/ManPages/man3/pthread.3.html#//apple_ref/doc/man/3/pthread" target="_top">pthread</a></code> man page. </p></td></tr><tr><td  scope="row"><p>Distributed lock</p></td><td ><p>A distributed lock provides mutually exclusive access at the process level. Unlike a true mutex, a distributed lock does not block a process or prevent it from running. It simply reports when the lock is busy and lets the process decide how to proceed. </p></td></tr><tr><td  scope="row"><p>Spin lock</p></td><td ><p>A spin lock polls its lock condition repeatedly until that condition becomes true. Spin locks are most often used on multiprocessor systems where the expected wait time for a lock is small. In these situations, it is often more efficient to poll than to block the thread, which involves a context switch and the updating of thread data structures. Mac OS X does not provide any implementations of spin locks because of their polling nature, but you can easily implement them in specific situations. For information on implementing spin locks in the kernel, see <em><a href="../../../../Darwin/Conceptual/KernelProgramming/index.html#//apple_ref/doc/uid/TP30000905" target="_top">Kernel Programming Guide</a></em>.</p></td></tr><tr><td  scope="row"><p>Double-checked lock</p></td><td ><p>A double-checked lock is an attempt to reduce the overhead of taking a lock by testing the locking criteria prior to taking the lock. Because double-checked locks are potentially unsafe, Mac OS X does not provide explicit support for them and their use is discouraged. </p></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/10000057i-CH8-SW29" title="Note"></a><p><strong>Note:</strong>&nbsp;Most types of locks also incorporate a memory barrier to ensure that any preceding load and store instructions are completed before entering the critical section.</p></div><p>For information on how to use locks, see <span class="content_text"><a href="ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW16">“Using Locks.”</a></span>  </p><a name="//apple_ref/doc/uid/10000057i-CH8-126424" title="Conditions"></a><h3>Conditions</h3><p><a name="//apple_ref/doc/uid/10000057i-CH8-DontLinkElementID_18"></a>A condition is another type of semaphore that allows threads to signal each other when a certain condition is true. Conditions are typically used to indicate the availability of a resource or to ensure that tasks are performed in a specific order. When a thread tests a condition, it blocks unless that condition is already true. It remains blocked until some other thread explicitly changes and signals the condition. The difference between a condition and a mutex lock is that multiple threads may be permitted access to the condition at the same time. The condition is more of a gatekeeper that lets different threads through the gate depending on some specified criteria. </p><p>One way you might use a condition is to manage a pool of pending events. The event queue would use a condition variable to signal waiting threads when there were events in the queue. If one event arrives, the queue would signal the condition appropriately. If a thread were already waiting, it would be woken up whereupon it would pull the event from the queue and process it. If two events came in to the queue at roughly the same time, the queue would signal the condition twice to wake up two threads.</p><p>Mac OS X provides support for conditions in several different technologies. The correct implementation of conditions requires careful coding, however, so you should look at the examples in <span class="content_text"><a href="ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW4">“Using Conditions”</a></span> before using them in your own code. </p><a name="//apple_ref/doc/uid/10000057i-CH8-SW15" title="Perform Selector Routines"></a><h3>Perform Selector Routines</h3><p>Cocoa applications have a convenient way of delivering messages in a synchronized manner to a single thread. The <code>NSObject</code> class declares methods for performing a selector on one of the application’s active threads. These methods let your threads deliver messages asynchronously with the guarantee that they will be performed synchronously by the target thread. For example, you might use perform selector messages to deliver results from a distributed computation to your application’s main thread or to a designated coordinator thread. Each request to perform a selector is queued on the target thread’s run loop and the requests are then processed sequentially in the order in which they were received.</p><p>For a summary of perform selector routines and more information about how to use them, see <span class="content_text"><a href="../RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW44">“Cocoa Perform Selector Sources.”</a></span> </p><a name="//apple_ref/doc/uid/10000057i-CH8-SW10" title="Synchronization and Performance"></a><h2>Synchronization and Performance</h2><p>Synchronization helps ensure the correctness of your code, but does so at the expense of performance. The use of synchronization tools introduces delays, even in uncontested cases. Locks and atomic operations generally involve the use of memory barriers and kernel-level synchronization to ensure code is properly protected. And if there is contention for a lock, your threads could block and experience even greater delays.</p><p>When designing your concurrent tasks, correctness is always the most important factor, but you should also consider performance factors as well. Code that executes correctly under multiple threads, but slower than the same code running on a single thread, is hardly an improvement. </p><p>If you are retrofitting an existing single-threaded application, you should always take a set of baseline measurements of the performance of key tasks. Upon adding additional threads, you should then take new measurements for those same tasks and compare the performance of the multithreaded case to the single-threaded case. If after tuning your code, threading does not improve performance, you may want to reconsider your specific implementation or the use of threads altogether. </p><p>For information about performance and the tools for gathering metrics, see <em><a href="../../../../Performance/Conceptual/PerformanceOverview/index.html#//apple_ref/doc/uid/TP40001410" target="_top">Performance Overview</a></em>. For specific information about the cost of locks and atomic operations, see <span class="content_text"><a href="../CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW7">“Thread Costs.”</a></span></p><a name="//apple_ref/doc/uid/10000057i-CH8-SW13" title="Thread Safety and Signals"></a><h2>Thread Safety and Signals</h2><p>When it comes to threaded applications, nothing causes more fear or confusion than the issue of handling signals. Signals are a low-level BSD mechanism that can be used to deliver information to a process or manipulate it in some way. Some programs use signals to detect certain events, such as the death of a child process. The system uses signals to terminate runaway processes and communicate other types of information.</p><p>The problem with signals is not what they do, but their behavior when your application has multiple threads. In a single-threaded application, all signal handlers run on the main thread. In a multithreaded application, signals that are not tied to a specific hardware error (such as an illegal instruction) are delivered to whichever thread happens to be running at the time. If  multiple threads are running simultaneously, the signal is delivered to whichever one the system happens to pick. In other words, signals can be delivered to any thread of your application. </p><p>The first rule for implementing signal handlers in Mac OS X applications is to avoid assumptions about which thread is handling the signal. If a specific thread wants to handle a given signal, you need to work out some way of notifying that thread when the signal arrives. You cannot just assume that installation of a signal handler from that thread will result in the signal being delivered to the same thread.</p><p>For more information about signals and installing signal handlers, see <code><a href="../../../../Darwin/Reference/ManPages/man3/signal.3.html#//apple_ref/doc/man/3/signal" target="_top">signal</a></code> and <code><a href="../../../../Darwin/Reference/ManPages/man2/sigaction.2.html#//apple_ref/doc/man/2/sigaction" target="_top">sigaction</a></code> man pages.</p><a name="//apple_ref/doc/uid/10000057i-CH8-SW6" title="Tips for Thread-Safe Designs"></a><h2>Tips for Thread-Safe Designs</h2><p>Synchronization tools are a useful way to make your code thread-safe, but they are not a panacea. Used too much, locks and other types of synchronization primitives can actually decrease your application’s threaded performance compared to its nonthreaded performance. Finding the right balance between safety and performance is an art that takes experience. The following sections provide tips to help you choose the appropriate level of synchronization for your application.</p><a name="//apple_ref/doc/uid/10000057i-CH8-SW7" title="Avoid Synchronization Altogether"></a><h3>Avoid Synchronization Altogether</h3><p>For any new projects you work on, and even for existing projects, designing your code and data structures to avoid the need for synchronization is the best possible solution. Although locks and other synchronization tools are useful, they do impact the performance of any application. And if the overall design causes high contention among specific resources, your threads could be waiting even longer. </p><p>The best way to implement concurrency is to reduce the interactions and inter-dependencies between your concurrent tasks. If each task operates on its own private data set, it does not need to protect that data using locks. Even in situations where two tasks do share a common data set, you can look at ways of partitioning that set or providing each task with its own copy. Of course, copying data sets has its costs too, so you have to weigh those costs against the costs of synchronization before making your decision.</p><a name="//apple_ref/doc/uid/10000057i-CH8-SW28" title="Understand the Limits of Synchronization"></a><h3>Understand the Limits of Synchronization</h3><p>Synchronization tools are effective only when they are used consistently by all threads in an application. If you create a mutex to restrict access to a specific resource, all of your threads must acquire the same mutex before trying to manipulate the resource. Failure to do so defeats the protection offered by the mutex and is a programmer error. </p><a name="//apple_ref/doc/uid/10000057i-CH8-SW8" title="Be Aware of Threats to Code Correctness"></a><h3>Be Aware of Threats to Code Correctness</h3><p>When using locks and memory barriers, you should always give careful thought to their placement in your code. Even locks that seem well placed can actually lull you into a false sense of security. The following series of examples attempt to illustrate this problem by pointing out the flaws in seemingly innocuous code. The basic premise is that you have a mutable array containing a set of immutable objects. Suppose you want to invoke a method of the first object in the array. You might do so using the following code:</p><div class="codesample"><table><tr><td scope="row"><pre>NSLock* arrayLock = GetArrayLock();<span></span></pre></td></tr><tr><td scope="row"><pre>NSMutableArray* myArray = GetSharedArray();<span></span></pre></td></tr><tr><td scope="row"><pre>id anObject;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>[arrayLock lock];<span></span></pre></td></tr><tr><td scope="row"><pre>anObject = [myArray objectAtIndex:0];<span></span></pre></td></tr><tr><td scope="row"><pre>[arrayLock unlock];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>[anObject doSomething];<span></span></pre></td></tr></table></div><p>Because the array is mutable, the lock around the array prevents other threads from modifying the array until you get the desired object. And because the object you retrieve is itself immutable, a lock is not needed around the call to the <code>doSomething</code> method.</p><p>There is a problem with the preceding example, though. What happens if you release the lock and another thread comes in and removes all objects from the array before you have a chance to execute the <code>doSomething</code> method? In an application without garbage collection, the object your code is holding could be released, leaving <code>anObject</code> pointing to an invalid memory address. To fix the problem, you might decide to simply rearrange your existing code and release the lock after your call to <code>doSomething</code>, as shown here: </p><div class="codesample"><table><tr><td scope="row"><pre>NSLock* arrayLock = GetArrayLock();<span></span></pre></td></tr><tr><td scope="row"><pre>NSMutableArray* myArray = GetSharedArray();<span></span></pre></td></tr><tr><td scope="row"><pre>id anObject;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>[arrayLock lock];<span></span></pre></td></tr><tr><td scope="row"><pre>anObject = [myArray objectAtIndex:0];<span></span></pre></td></tr><tr><td scope="row"><pre>[anObject doSomething];<span></span></pre></td></tr><tr><td scope="row"><pre>[arrayLock unlock];<span></span></pre></td></tr></table></div><p>By moving the <code>doSomething</code> call inside the lock, your code guarantees that the object is still valid when the method is called. Unfortunately, if the <code>doSomething</code> method takes a long time to execute, this could cause your code to hold the lock for a long time, which could create a performance bottleneck. </p><p>The problem with the code is not that the critical region was poorly defined, but that the actual problem was not understood. The real problem is a memory management issue that is triggered only by the presence of other threads. Because it can be released by another thread, a better solution would be to retain <code>anObject</code> before releasing the lock. This solution addresses the real problem of the object being released and does so without introducing a potential performance penalty. </p><div class="codesample"><table><tr><td scope="row"><pre>NSLock* arrayLock = GetArrayLock();<span></span></pre></td></tr><tr><td scope="row"><pre>NSMutableArray* myArray = GetSharedArray();<span></span></pre></td></tr><tr><td scope="row"><pre>id anObject;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>[arrayLock lock];<span></span></pre></td></tr><tr><td scope="row"><pre>anObject = [myArray objectAtIndex:0];<span></span></pre></td></tr><tr><td scope="row"><pre>[anObject retain];<span></span></pre></td></tr><tr><td scope="row"><pre>[arrayLock unlock];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>[anObject doSomething];<span></span></pre></td></tr></table></div><p>Although the preceding examples are very simple in nature, they do illustrate a very important point. When it comes to correctness, you have to think beyond the obvious problems. Memory management and other aspects of your design may also be affected by the presence of multiple threads, so you have to think about those problems up front. In addition, you should always assume that the compiler will do the worst possible thing when it comes to safety. This kind of awareness and vigilance should help you avoid potential problems and ensure that your code behaves correctly. </p><p>For additional examples of how to make your program thread-safe, see Technical Note TN2059: “<span class="content_text"><a href="../../../../../technotes/tn2002/tn2059.html" target="_top">Using Collection Classes Safely in Multithreaded Applications</a></span>.” </p><a name="//apple_ref/doc/uid/10000057i-CH8-SW11" title="Watch Out for Deadlocks and Livelocks"></a><h3>Watch Out for Deadlocks and Livelocks</h3><p>Any time a thread tries to take more than one lock at the same time, there is a potential for a deadlock to occur. A deadlock occurs when two different threads hold a lock that the other one needs and then try to acquire the lock held by the other thread. The result is that each thread blocks permanently because it can never acquire the other lock. </p><p>A livelock is similar to a deadlock and occurs when two threads compete for the same set of resources. In a livelock situation, a thread gives up its first lock in an attempt to acquire its second lock. Once it acquires the second lock, it goes back and tries to acquire the first lock again. It locks up because it spends all its time releasing one lock and trying to acquire the other lock rather than doing any real work. </p><p>The best way to avoid both deadlock and livelock situations is to take only one lock at a time. If you must acquire more than one lock at a time, you should make sure that other threads do not try to do something similar. </p><a name="//apple_ref/doc/uid/10000057i-CH8-SW12" title="Use Volatile Variables Correctly"></a><h3>Use Volatile Variables Correctly</h3><p>If you are already using mutexes to protect a section of code, you should avoid using the <code>volatile</code> keyword to protect variables used in those sections. A mutex includes a memory barrier to ensure the proper ordering of load and store operations. Adding the <code>volatile</code> keyword to a variable that is protected by that critical section only serves to slow down operations that involve that variable. </p><p>It is also important that you do not use volatile variables in an attempt to avoid the use of mutexes. In general, mutexes and other synchronization mechanisms are a better way to protect the integrity of your data structures than volatile variables. The <code>volatile</code> keyword only ensures that a variable is loaded from memory rather than stored in a register. It does not ensure that the variable is accessed correctly by your code. </p><a name="//apple_ref/doc/uid/10000057i-CH8-SW14" title="Using Atomic Operations"></a><h2>Using Atomic Operations</h2><p>Nonblocking synchronization is a way to perform some types of operations and avoid the expense of locks. Although locks are an effective way to synchronize two threads, acquiring a lock is a relatively expensive operation, even in the uncontested case. By contrast, many atomic operations take a fraction of the time to complete and can be just as effective as a lock. </p><p>Atomic operations let you perform simple mathematical and logical operations on 32-bit or 64-bit values. These operations rely on special hardware instructions (and an optional memory barrier) to ensure that the given operation completes before the affected memory is accessed again. In the multithreaded case, you should always use the atomic operations that incorporate a memory barrier to ensure that the memory is synchronized correctly between threads.</p><p><span class="content_text">Table 4-2</span> lists the available atomic mathematical and logical operations and the corresponding function names. These functions are all declared in the <code>/usr/include/libkern/OSAtomic.h</code> header file, where you can also find the complete syntax. The 64-bit versions of these functions are available only in 64-bit processes. </p><a name="//apple_ref/doc/uid/10000057i-CH8-SW26" title="Table 4-2Atomic math and logic operations"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 4-2&nbsp;&nbsp;</strong>Atomic math and logic operations</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Operation</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Function name</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p>Add</p></td><td ><p><code>OSAtomicAdd32</code></p><p><code>OSAtomicAdd32Barrier</code></p><p><code>OSAtomicAdd64</code></p><p><code>OSAtomicAdd64Barrier</code></p></td><td ><p>Adds two integer values together and stores the result in one of the specified variables. </p></td></tr><tr><td  scope="row"><p>Increment</p></td><td ><p><code>OSAtomicIncrement32</code></p><p><code>OSAtomicIncrement32Barrier</code></p><p><code>OSAtomicIncrement64</code></p><p><code>OSAtomicIncrement64Barrier</code></p></td><td ><p>Increments the specified integer value by 1. </p></td></tr><tr><td  scope="row"><p>Decrement</p></td><td ><p><code>OSAtomicDecrement32</code></p><p><code>OSAtomicDecrement32Barrier</code></p><p><code>OSAtomicDecrement64</code></p><p><code>OSAtomicDecrement64Barrier</code></p></td><td ><p>Decrements the specified integer value by 1.</p></td></tr><tr><td  scope="row"><p>Logical OR</p></td><td ><p><code>OSAtomicOr32</code></p><p><code>OSAtomicOr32Barrier</code></p></td><td ><p>Performs a logical OR between the specified 32-bit value and a 32-bit mask.</p></td></tr><tr><td  scope="row"><p>Logical AND</p></td><td ><p><code>OSAtomicAnd32</code></p><p><code>OSAtomicAnd32Barrier</code></p></td><td ><p>Performs a logical AND between the specified 32-bit value and a 32-bit mask.</p></td></tr><tr><td  scope="row"><p>Logical XOR</p></td><td ><p><code>OSAtomicXor32</code></p><p><code>OSAtomicXor32Barrier</code></p></td><td ><p>Performs a logical XOR between the specified 32-bit value and a 32-bit mask.</p></td></tr><tr><td  scope="row"><p>Compare and swap</p></td><td ><p><code>OSAtomicCompareAndSwap32</code></p><p><code>OSAtomicCompareAndSwap32Barrier</code></p><p><code>OSAtomicCompareAndSwap64</code></p><p><code>OSAtomicCompareAndSwap64Barrier</code></p><p><code>OSAtomicCompareAndSwapPtr</code></p><p><code>OSAtomicCompareAndSwapPtrBarrier</code></p><p><code>OSAtomicCompareAndSwapInt</code></p><p><code>OSAtomicCompareAndSwapIntBarrier</code></p><p><code>OSAtomicCompareAndSwapLong</code></p><p><code>OSAtomicCompareAndSwapLongBarrier</code></p></td><td ><p>Compares a variable against the specified old value. If the two values are equal, this function assigns the specified new value to the variable; otherwise, it does nothing. The comparison and assignment are done as one atomic operation and the function returns a Boolean value indicating whether the swap actually occurred. </p></td></tr><tr><td  scope="row"><p>Test and set</p></td><td ><p><code>OSAtomicTestAndSet</code></p><p><code>OSAtomicTestAndSetBarrier</code></p></td><td ><p>Tests a bit in the specified variable, sets that bit to 1, and returns the value of the old bit as a Boolean value. Bits are tested according to the formula <code>(0x80 >> (n &amp; 7)) </code>of byte <code>((char*)address + (n >> 3))</code> where <code>n</code> is the bit number and <code>address</code> is a pointer to the variable. This formula effectively breaks up the variable into 8-bit sized chunks and orders the bits in each chunk in reverse. For example, to test the lowest-order bit (bit 0) of a 32-bit integer, you would actually specify 7 for the bit number; similarly, to test the highest order bit (bit 32), you would specify 24 for the bit number. </p></td></tr><tr><td  scope="row"><p>Test and clear</p></td><td ><p><code>OSAtomicTestAndClear</code></p><p><code>OSAtomicTestAndClearBarrier</code></p></td><td ><p>Tests a bit in the specified variable, sets that bit to 0, and returns the value of the old bit as a Boolean value. Bits are tested according to the formula <code>(0x80 >> (n &amp; 7)) </code>of byte <code>((char*)address + (n >> 3))</code> where <code>n</code> is the bit number and <code>address</code> is a pointer to the variable. This formula effectively breaks up the variable into 8-bit sized chunks and orders the bits in each chunk in reverse. For example, to test the lowest-order bit (bit 0) of a 32-bit integer, you would actually specify 7 for the bit number; similarly, to test the highest order bit (bit 32), you would specify 24 for the bit number. </p></td></tr></table></div><p>The behavior of most atomic functions should be relatively straightforward and what you would expect. <span class="content_text">Listing 4-1</span>, however, shows the behavior of atomic test-and-set and compare-and-swap operations, which are a little more complex. The first three calls to the <code>OSAtomicTestAndSet</code> function demonstrate how the bit manipulation formula being used on an integer value and its results might differ from what you would expect. The last two calls show the behavior of the <code>OSAtomicCompareAndSwap32</code> function. In all cases, these functions are being called in the uncontested case when no other threads are manipulating the values. </p><a name="//apple_ref/doc/uid/10000057i-CH8-SW27" title="Listing 4-1Performing atomic operations"></a><p class="codesample"><strong>Listing 4-1&nbsp;&nbsp;</strong>Performing atomic operations</p><div class="codesample"><table><tr><td scope="row"><pre>int32_t  theValue = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>OSAtomicTestAndSet(0, &amp;theValue);<span></span></pre></td></tr><tr><td scope="row"><pre>// theValue is now 128.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>theValue = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>OSAtomicTestAndSet(7, &amp;theValue);<span></span></pre></td></tr><tr><td scope="row"><pre>// theValue is now 1.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>theValue = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>OSAtomicTestAndSet(15, &amp;theValue)<span></span></pre></td></tr><tr><td scope="row"><pre>// theValue is now 256.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>OSAtomicCompareAndSwap32(256, 512, &amp;theValue);<span></span></pre></td></tr><tr><td scope="row"><pre>// theValue is now 512.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>OSAtomicCompareAndSwap32(256, 1024, &amp;theValue);<span></span></pre></td></tr><tr><td scope="row"><pre>// theValue is still 512.<span></span></pre></td></tr></table></div><p>For information about atomic operations, see the <code><a href="../../../../Darwin/Reference/ManPages/man3/atomic.3.html#//apple_ref/doc/man/3/atomic" target="_top">atomic</a></code> man page and the <code>/usr/include/libkern/OSAtomic.h</code> header file.</p><a name="//apple_ref/doc/uid/10000057i-CH8-SW16" title="Using Locks"></a><h2>Using Locks</h2><p>Locks are a fundamental synchronization tool for threaded programming. Locks enable you to protect large sections of code easily so that you can ensure the correctness of that code. Mac OS X provides basic mutex locks for all application types and Cocoa defines some additional variants of the mutex lock for special situations. The following sections show you how to use several of these lock types. </p><a name="//apple_ref/doc/uid/10000057i-CH8-132741" title="Using a POSIX Mutex Lock"></a><h3>Using a POSIX Mutex Lock</h3><p>POSIX mutex locks<a name="//apple_ref/doc/uid/10000057i-CH8-DontLinkElementID_19"></a><a name="//apple_ref/doc/uid/10000057i-CH8-DontLinkElementID_20"></a> are extremely easy to use from any application in Mac OS X. To create the mutex lock, you declare and initialize a <code>pthread_mutex_t</code> structure. To lock and unlock the mutex lock, you use the <code>pthread_mutex_lock</code><a name="//apple_ref/doc/uid/10000057i-CH8-DontLinkElementID_21"></a> and <code>pthread_mutex_unlock</code><a name="//apple_ref/doc/uid/10000057i-CH8-DontLinkElementID_22"></a> functions. <span class="content_text">Listing 4-2</span> shows the basic code required to initialize and use a POSIX thread mutex lock. When you are done with the lock, simply call <code>pthread_mutex_destroy</code><a name="//apple_ref/doc/uid/10000057i-CH8-DontLinkElementID_23"></a> to free up the lock data structures. </p><a name="//apple_ref/doc/uid/10000057i-CH8-132782-BBCEBGCI" title="Listing 4-2Using a mutex lock"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40001522-132782" title="Listing 4-2Using a mutex lock"></a><strong>Listing 4-2&nbsp;&nbsp;</strong>Using a mutex lock</p><div class="codesample"><table><tr><td scope="row"><pre>pthread_mutex_t mutex;<span></span></pre></td></tr><tr><td scope="row"><pre>void MyInitFunction()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    pthread_mutex_init(&amp;mutex, NULL);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void MyLockingFunction()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    pthread_mutex_lock(&amp;mutex);<span></span></pre></td></tr><tr><td scope="row"><pre>    // Do work.<span></span></pre></td></tr><tr><td scope="row"><pre>    pthread_mutex_unlock(&amp;mutex);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/10000057i-CH8-SW30" title="Note"></a><p><strong>Note:</strong>&nbsp;The preceding code is a simplified example intended to show the basic usage of the POSIX thread mutex functions. Your own code should check the error codes returned by these functions and handle them appropriately. </p></div><a name="//apple_ref/doc/uid/10000057i-CH8-SW17" title="Using the NSLock Class"></a><h3>Using the NSLock Class</h3><p>An <code>NSLock</code><a name="//apple_ref/doc/uid/10000057i-CH8-DontLinkElementID_24"></a> object implements a basic mutex for Cocoa applications. The interface for all locks (including <code>NSLock</code>) is actually defined by the <code>NSLocking</code> protocol, which defines the <code>lock</code> and <code>unlock</code> methods. You use these methods to acquire and release the lock just as you would any mutex.</p><p>In addition to the standard locking behavior, the <code>NSLock</code> class adds the <code>tryLock</code><a name="//apple_ref/doc/uid/10000057i-CH8-DontLinkElementID_25"></a> and <code>lockBeforeDate:</code><a name="//apple_ref/doc/uid/10000057i-CH8-DontLinkElementID_26"></a> methods. The <code>tryLock</code> method attempts to acquire the lock but does not block if the lock is unavailable; instead, the method simply returns <code>NO</code>. The <code>lockBeforeDate:</code> method attempts to acquire the lock but unblocks the thread (and returns <code>NO</code>) if the lock is not acquired within the specified time limit.</p><p>The following example shows how you could use an <code>NSLock</code> object to coordinate the updating of a visual display, whose data is being calculated by several threads. If the thread cannot acquire the lock immediately, it simply continues its calculations until it can acquire the lock and update the display. </p><div class="codesample"><table><tr><td scope="row"><pre>BOOL moreToDo = YES;<span></span></pre></td></tr><tr><td scope="row"><pre>NSLock *theLock = [[NSLock alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>...<span></span></pre></td></tr><tr><td scope="row"><pre>while (moreToDo) {<span></span></pre></td></tr><tr><td scope="row"><pre>    /* Do another increment of calculation */<span></span></pre></td></tr><tr><td scope="row"><pre>    /* until there’s no more to do. */<span></span></pre></td></tr><tr><td scope="row"><pre>    if ([theLock tryLock]) {<span></span></pre></td></tr><tr><td scope="row"><pre>        /* Update display used by all threads. */<span></span></pre></td></tr><tr><td scope="row"><pre>        [theLock unlock];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/10000057i-CH8-SW3" title="Using the @synchronized Directive"></a><h3>Using the @synchronized Directive</h3><p>The <code>@synchronized</code> directive is a convenient way to create mutex locks on the fly in Objective-C code. The <code>@synchronized</code> directive does what any other mutex lock would do—it prevents different threads from acquiring the same lock at the same time. In this case, however, you do not have to create the mutex or lock object directly. Instead, you simply use any Objective-C object as a lock token, as shown in the following example:</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)myMethod:(id)anObj<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    @synchronized(anObj)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Everything between the braces is protected by the @synchronized directive.<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The object passed to the <code>@synchronized</code> directive is a unique identifier used to distinguish the protected block. If you execute the preceding method in two different threads, passing a different object for the <code>anObj</code> parameter on each thread, each would take its lock and continue processing without being blocked by the other. If you pass the same object in both cases, however, one of the threads would acquire the lock first and the other would block until the first thread completed the critical section. </p><p>As a precautionary measure, the <code>@synchronized</code> block implicitly adds an exception handler to the protected code. This handler automatically releases the mutex in the event that an exception is thrown. This means that in order to use the <code>@synchronized</code> directive, you must also enable Objective-C exception handling in your code. If you do not want the additional overhead caused by the implicit exception handler, you should consider using the lock classes.</p><p>For more information about the <code>@synchronized</code> directive, see <em><a href="../../ObjectiveC/index.html#//apple_ref/doc/uid/TP30001163" target="_top">The Objective-C 2.0 Programming Language</a></em>. </p><a name="//apple_ref/doc/uid/10000057i-CH8-SW20" title="Using Other Cocoa Locks"></a><h3>Using Other Cocoa Locks</h3><p>The following sections describe the process for using several other types of Cocoa locks. </p><a name="//apple_ref/doc/uid/10000057i-CH8-SW21" title="Using an NSRecursiveLock Object"></a><h4>Using an NSRecursiveLock Object</h4><p><a name="//apple_ref/doc/uid/10000057i-CH8-DontLinkElementID_27"></a>The <code>NSRecursiveLock</code> class<a name="//apple_ref/doc/uid/10000057i-CH8-DontLinkElementID_28"></a> defines a lock that can be acquired multiple times by the same thread without causing the thread to deadlock. A recursive lock keeps track of how many times it was successfully acquired. Each successful acquisition of the lock must be balanced by a corresponding call to unlock the lock. Only when all of the lock and unlock calls are balanced is the lock actually released so that other threads can acquire it. </p><p>As its name implies, this type of lock is commonly used inside a recursive function to prevent the recursion from blocking the thread. You could similarly use it in the nonrecursive case to call functions whose semantics demand that they also take the lock. Here’s an example of a simple recursive function that acquires the lock through recursion. If you did not use an <code>NSRecursiveLock</code> object for this code, the thread would deadlock when the function was called again. </p><div class="codesample"><table><tr><td scope="row"><pre>NSRecursiveLock *theLock = [[NSRecursiveLock alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void MyRecursiveFunction(int value)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [theLock lock];<span></span></pre></td></tr><tr><td scope="row"><pre>    if (value != 0)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        --value;<span></span></pre></td></tr><tr><td scope="row"><pre>        MyRecursiveFunction(value);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    [theLock unlock];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>MyRecursiveFunction(5);<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/10000057i-CH8-SW31" title="Note"></a><p><strong>Note:</strong>&nbsp;Because a recursive lock is not released until all lock calls are balanced with unlock calls, you should carefully weigh the decision to use a performance lock against the potential performance implications. Holding any lock for an extended period of time can cause other threads to block until the recursion completes. If you can rewrite your code to eliminate the recursion or eliminate the need to use a recursive lock, you may achieve better performance.</p></div><a name="//apple_ref/doc/uid/10000057i-CH8-SW22" title="Using an NSConditionLock Object"></a><h4>Using an NSConditionLock Object</h4><p>An <code>NSConditionLock</code> object defines a mutex lock that can be locked and unlocked with specific values. You should not confuse this type of lock with a condition (see <span class="content_text"><a href="ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-126424">“Conditions”</a></span>). The behavior is somewhat similar to conditions, but is implemented very differently. </p><p>Typically, you use an <code>NSConditionLock</code> object when threads need to perform tasks in a specific order, such as when one thread produces data that another consumes. While the producer is executing, the consumer acquires the lock using a condition that is specific to your program. (The condition itself is just an integer value that you define.) When the producer finishes, it unlocks the lock and sets the lock condition to the appropriate integer value to wake the consumer thread, which then proceeds to process the data. </p><p>The locking and unlocking methods that <code>NSConditionLock</code> objects respond to can be used in any combination. For example, you can pair a <code>lock</code> message with <code>unlockWithCondition:</code><a name="//apple_ref/doc/uid/10000057i-CH8-DontLinkElementID_29"></a>, or a <code>lockWhenCondition:</code><a name="//apple_ref/doc/uid/10000057i-CH8-DontLinkElementID_30"></a> message with <code>unlock</code>. Of course, this latter combination unlocks the lock but might not release any threads waiting on a specific condition value.</p><p>The following example shows how the producer-consumer problem might be handled using condition locks. Imagine that an application contains a queue of data. A producer thread adds data to the queue, and consumer threads extract data from the queue. The producer need not wait for a specific condition, but it must wait for the lock to be available so it can safely add data to the queue. </p><div class="codesample"><table><tr><td scope="row"><pre>id condLock = [[NSConditionLock alloc] initWithCondition:NO_DATA];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>while(true)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [condLock lock];<span></span></pre></td></tr><tr><td scope="row"><pre>    /* Add data to the queue. */<span></span></pre></td></tr><tr><td scope="row"><pre>    [condLock unlockWithCondition:HAS_DATA];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Because the initial condition of the lock is set to <code>NO_DATA</code>, the producer thread should have no trouble acquiring the lock initially. It fills the queue with data and sets the condition to <code>HAS_DATA</code>. During subsequent iterations, the producer thread can add new data as it arrives, regardless of whether the queue is empty or still has some data. The only time it blocks is when a consumer thread is extracting data from the queue. </p><p>Because the consumer thread must have data to process, it waits on the queue using a specific condition. When the producer puts data on the queue, the consumer thread wakes up and acquires its lock. It can then extract some data from the queue and update the queue status. The following example shows the basic structure of the consumer thread’s processing loop. </p><div class="codesample"><table><tr><td scope="row"><pre>while (true)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [condLock lockWhenCondition:HAS_DATA];<span></span></pre></td></tr><tr><td scope="row"><pre>    /* Remove data from the queue. */<span></span></pre></td></tr><tr><td scope="row"><pre>    [condLock unlockWithCondition:(isEmpty ? NO_DATA : HAS_DATA)];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Process the data locally.<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/10000057i-CH8-SW23" title="Using an NSDistributedLock Object"></a><h4>Using an NSDistributedLock Object</h4><p>The <code>NSDistributedLock</code> class<a name="//apple_ref/doc/uid/10000057i-CH8-DontLinkElementID_31"></a> can be used by multiple applications on multiple hosts to restrict access to some shared resource, such as a file<a name="//apple_ref/doc/uid/10000057i-CH8-DontLinkElementID_32"></a>. The lock itself is effectively a mutex lock that is implemented using a file-system item, such as a file or directory. For an <code>NSDistributedLock</code> object to be usable, the lock must be writable by all applications that use it. This usually means putting it on a file system that is accessible to all of the computers that are running the application. </p><p>Unlike other types of lock, <code>NSDistrubutedLock</code> does not conform to the <code>NSLocking</code> protocol and thus does not have a <code>lock</code> method. A <code>lock</code> method would block the execution of the thread and require the system to poll the lock at a predetermined rate. Rather than impose this penalty on your code, <code>NSDistributedLock</code> provides a <code>tryLock</code><a name="//apple_ref/doc/uid/10000057i-CH8-DontLinkElementID_33"></a> method and lets you decide whether or not to poll.</p><p>Because it is implemented using the file system, an <code>NSDistributedLock</code> object is not released unless the owner explicitly releases it. If your application crashes while holding a distributed lock, other clients will be unable to access the protected resource. In this situation, you can use the <code>breakLock</code><a name="//apple_ref/doc/uid/10000057i-CH8-DontLinkElementID_34"></a> method to break the existing lock so that you can acquire it. Breaking locks should generally be avoided, though, unless you are certain the owning process died and cannot release the lock. </p><p>As with other types of locks, when you are done using an <code>NSDistributedLock</code> object, you release it by calling the <code>unlock</code> method. </p><a name="//apple_ref/doc/uid/10000057i-CH8-SW4" title="Using Conditions"></a><h2>Using Conditions</h2><p>Conditions are a special type of lock that you can use to synchronize the order in which operations must proceed. They differ from mutex locks in a subtle way.  A thread waiting on a condition remains blocked until that condition is signaled explicitly by another thread. </p><p>Due to the subtleties involved in implementing operating systems, condition locks are permitted to return with spurious success even if they were not actually signaled by your code. To avoid problems caused by these spurious signals, you should always use a predicate in conjunction with your condition lock. The predicate is a more concrete way of determining whether it is safe for your thread to proceed. The condition simply keeps your thread asleep until the predicate can be set by the signaling thread. </p><p>The following sections show you how to use conditions in your code.</p><a name="//apple_ref/doc/uid/10000057i-CH8-SW18" title="Using the NSCondition Class"></a><h3>Using the NSCondition Class</h3><p>The <code>NSCondition</code> class provides the same semantics as POSIX conditions, but wraps both the required lock and condition data structures in a single object. The result is an object that you can lock like a mutex and then wait on like a condition.</p><p><span class="content_text">Listing 4-3</span> shows a code snippet demonstrating the sequence of events for waiting on an <code>NSCondition</code> object. The <code>cocoaCondition</code> variable contains an <code>NSCondition</code> object and the <code>timeToDoWork</code> variable is an integer that is incremented from another thread immediately prior to signaling the condition. </p><a name="//apple_ref/doc/uid/10000057i-CH8-SW24" title="Listing 4-3Using a Cocoa condition"></a><p class="codesample"><strong>Listing 4-3&nbsp;&nbsp;</strong>Using a Cocoa condition</p><div class="codesample"><table><tr><td scope="row"><pre>[cocoaCondition lock];<span></span></pre></td></tr><tr><td scope="row"><pre>while (timeToDoWork &lt;= 0)<span></span></pre></td></tr><tr><td scope="row"><pre>    [cocoaCondition wait];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>timeToDoWork--;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Do real work here.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>[cocoaCondition unlock];<span></span></pre></td></tr></table></div><p><span class="content_text">Listing 4-4</span> shows the code used to signal the Cocoa condition and increment the predicate variable. You should always lock the condition before signaling it. </p><a name="//apple_ref/doc/uid/10000057i-CH8-SW25" title="Listing 4-4Signaling a Cocoa condition"></a><p class="codesample"><strong>Listing 4-4&nbsp;&nbsp;</strong>Signaling a Cocoa condition</p><div class="codesample"><table><tr><td scope="row"><pre>[cocoaCondition lock];<span></span></pre></td></tr><tr><td scope="row"><pre>timeToDoWork++;<span></span></pre></td></tr><tr><td scope="row"><pre>[cocoaCondition signal];<span></span></pre></td></tr><tr><td scope="row"><pre>[cocoaCondition unlock];<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/10000057i-CH8-124690" title="Using POSIX Conditions"></a><h3>Using POSIX Conditions</h3><p>POSIX thread condition locks<a name="//apple_ref/doc/uid/10000057i-CH8-DontLinkElementID_35"></a><a name="//apple_ref/doc/uid/10000057i-CH8-DontLinkElementID_36"></a> require the use of both a condition data structure and a mutex. Although the two lock structures are separate, the mutex lock is intimately tied to the condition structure at runtime. Threads waiting on a signal should always use the same mutex lock and condition structures together. Changing the pairing can cause errors. </p><p><span class="content_text">Listing 4-5</span> shows the basic initialization and usage of a condition and predicate. After initializing both the condition and the mutex lock, the waiting thread enters a while loop using the <code>ready_to_go</code> variable as its predicate. Only when the predicate is set and the condition subsequently signaled does the waiting thread wake up and start doing its work.  </p><a name="//apple_ref/doc/uid/10000057i-CH8-125418-BBCJIDDF" title="Listing 4-5Using a POSIX condition"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40001522-125418" title="Listing 4-5Using a POSIX condition"></a><strong>Listing 4-5&nbsp;&nbsp;</strong>Using a POSIX condition</p><div class="codesample"><table><tr><td scope="row"><pre>pthread_mutex_t mutex;<span></span></pre></td></tr><tr><td scope="row"><pre>pthread_cond_t condition;<span></span></pre></td></tr><tr><td scope="row"><pre>Boolean     ready_to_go = true;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void MyCondInitFunction()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    pthread_mutex_init(&amp;mutex);<span></span></pre></td></tr><tr><td scope="row"><pre>    pthread_cond_init(&amp;condition, NULL);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void MyWaitOnConditionFunction()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // Lock the mutex.<span></span></pre></td></tr><tr><td scope="row"><pre>    pthread_mutex_lock(&amp;mutex);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // If the predicate is already set, then the while loop is bypassed;<span></span></pre></td></tr><tr><td scope="row"><pre>    // otherwise, the thread sleeps until the predicate is set.<span></span></pre></td></tr><tr><td scope="row"><pre>    while(ready_to_go == false)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        pthread_cond_wait(&amp;condition, &amp;mutex);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Do work. (The mutex should stay locked.)<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Reset the predicate and release the mutex.<span></span></pre></td></tr><tr><td scope="row"><pre>    ready_to_go = false;<span></span></pre></td></tr><tr><td scope="row"><pre>    pthread_mutex_unlock(&amp;mutex);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The signaling thread is responsible both for setting the predicate and for sending the signal to the condition lock.  <span class="content_text">Listing 4-6</span> shows the code for implementing this behavior. In this example, the condition is signaled inside of the mutex to prevent race conditions from occurring between the threads waiting on the condition. </p><a name="//apple_ref/doc/uid/10000057i-CH8-SW19" title="Listing 4-6Signaling a condition lock"></a><p class="codesample"><strong>Listing 4-6&nbsp;&nbsp;</strong>Signaling a condition lock</p><div class="codesample"><table><tr><td scope="row"><pre>void SignalThreadUsingCondition()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // At this point, there should be work for the other thread to do.<span></span></pre></td></tr><tr><td scope="row"><pre>    pthread_mutex_lock(&amp;mutex);<span></span></pre></td></tr><tr><td scope="row"><pre>    ready_to_go = true;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Signal the other thread to begin work.<span></span></pre></td></tr><tr><td scope="row"><pre>    pthread_cond_signal(&amp;condition);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    pthread_mutex_unlock(&amp;mutex);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/10000057i-CH8-SW32" title="Note"></a><p><strong>Note:</strong>&nbsp;The preceding code is a simplified example intended to show the basic usage of the POSIX thread condition functions. Your own code should check the error codes returned by these functions and handle them appropriately. </p></div>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../CreatingThreads/CreatingThreads.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../RunLoopManagement/RunLoopManagement.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-02-08<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html%3Fid%3D10000057i-4.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html%3Fid%3D10000057i-4.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html%3Fid%3D10000057i-4.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>