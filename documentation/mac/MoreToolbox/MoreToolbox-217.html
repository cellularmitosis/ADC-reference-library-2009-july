<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Supporting Keyboard Navigation of Lists (IM: MTb)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING217></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="MoreToolbox-216.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MoreToolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MoreToolbox-513.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MoreToolbox-218.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="MoreToolbox-2.html"><B>More Macintosh Toolbox</B></A> / <BR><DD><A HREF="MoreToolbox-202.html"><B>Chapter 4 - List Manager</B></A> / <A HREF="MoreToolbox-209.html"><B>Using the List Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING217-0></A>
<H2><A NAME=MARKER-9-228></A>Supporting Keyboard Navigation of Lists<A NAME=MARKER-2-132></A></H2>
 This section discusses how your application can support keyboard navigation of lists. In particular, this section first shows how your application can respond to the user's typing to select an item in a text-only list. Second, this section shows how your application can respond to the user's pressing of the arrow keys.<A NAME=MARKER-2-78></A><A NAME=MARKER-2-100></A><A NAME=MARKER-2-232></A><P>
<A NAME=HEADING217-2></A>
<H3>Supporting Type Selection of List Items<A NAME=MARKER-2-128></A></H3>
 To support type selection of list items, your application must keep a record of the characters the user has typed, the time when the user last typed a character, and which list the last typed character affected. For example, the SurfWriter application defines the following four variables to keep track of this information:<P>
<PRE>
VAR
   gListNavigateString:       {current string being searched}
                  Str255;     
   gTSThresh:     Integer;    {ticks before type selection resets}
   gLastKeyTime:  LongInt;    {time in ticks of last click time}
   gLastListHit:  ListHandle; {last list type selection affected}
</PRE>
 The <CODE>gListNavigateString</CODE> variable stores the current status of the type selection. For example, if the user types <CODE>'h'</CODE> and then <CODE>'e'</CODE> and then <CODE>'l'</CODE> and then <CODE>'l'</CODE> and then <CODE>'o'</CODE>, this string should be <CODE>'hello'</CODE>.<P>
 The <CODE>gTSThresh</CODE> variable stores the number of ticks after which type selection resets. For example, if the user has typed <CODE>'hello'</CODE> but then waits more than this amount of time before typing <CODE>'g'</CODE>, the SurfWriter application sets <CODE>gListNavigateString</CODE> to <CODE>'g'</CODE>, not to <CODE>'hellog'</CODE>. The value of <CODE>gTSThresh</CODE> is dependent on the value the user sets for "Delay Until Repeat" in the Keyboard control panel. SurfWriter also resets the type selection if the user begins typing in a different list from the list last typed in. Thus, if the difference between the current tick count and the <CODE>gLastKeyTime</CODE> variable is greater than <CODE>gTSThresh</CODE>, or if <CODE>gLastListHit</CODE> is not equal to the current list, then the SurfWriter application must reset the type selection.<A NAME=MARKER-2-18></A><A NAME=MARKER-9-227></A><P>
 <A HREF=#MARKER-9-236>Listing 4-17</A> shows how the SurfWriter application initializes or resets its type-selection variables. <P>
<B>Listing 4-17  <A NAME=MARKER-9-236></A>Resetting variables related to type selection<A NAME=MARKER-2-237></A></B><P>
<PRE>
PROCEDURE MyResetTypeSelection;
CONST
   KeyThresh = $18E;    {location of low-memory word}
   kMaxKeyThresh = 120; {120 ticks = 2 seconds}
TYPE
   IntPtr = ^Integer;   {for accessing low memory}
BEGIN
   gListNavigateString := '';          {reset navigation string}
   gLastListHit := NIL;                {remember active list}
   gLastKeyTime := 0;                  {no keys yet hit}
   gTSThresh := 2 * IntPtr(KeyThresh)^;{update type-selection }
                                       { threshold}
   IF gTSThresh &gt; kMaxKeyThresh THEN
      gTSThresh := kMaxKeyThresh;      {set threshold to maximum}
END;
</PRE>
 The <CODE>MyResetTypeSelection</CODE> procedure defined in <A HREF=#MARKER-9-236>Listing 4-17</A> initializes three of the variables to default values and sets the <CODE>gTSThresh</CODE> variable to twice the value of the system global variable <CODE>KeyThresh</CODE>, up to a maximum of 120 ticks. By using the same formula as <CODE>MyResetTypeSelection</CODE> for computing the type-selection threshold, you make sure your application is consistent with other applications as well as with the Finder. The SurfWriter application calls the <CODE>MyResetTypeSelection</CODE> procedure when it starts up and when it wishes to reset the type selection because the type-selection threshold has expired. It also calls the procedure whenever it receives a resume event, because the user might have used the Keyboard control panel, in which case SurfWriter needs to update the value of the type-selection threshold.<A NAME=MARKER-2-19></A><P>
 Having initialized variables related to type selection, the SurfWriter application needs to respond to appropriate key-down events. <A HREF=#MARKER-9-239>Listing 4-18</A> illustrates an application-defined procedure that does this.<P>
<B>Listing 4-18  <A NAME=MARKER-9-239></A>Selecting an item in response to a key-down event<A NAME=MARKER-2-240></A></B><P>
<PRE>
PROCEDURE MyKeySearchInList (theList: ListHandle; theEvent: EventRecord);
VAR
   newChar: Char;                      {character to add to search string}
   theCell: Cell;                      {cell containing found string}
BEGIN
   newChar := CHR(BAnd(theEvent.message, charCodeMask));
   IF (gLastListHit &lt;&gt; theList) OR 
            (theEvent.when - gLastKeyTime &gt;= gTSThresh) OR
            (Length(gListNavigateString) = 255) THEN
      MyResetTypeSelection;
   gLastListHit := theList;            {remember list keyed in}
   gLastKeyTime := theEvent.when;      {record time of key-down event}
                                       {set length of string}
   gListNavigateString[0] := Char(Length(gListNavigateString) + 1);
                                       {add character to string}
   gListNavigateString[Length(gListNavigateString)] := newChar;

   SetPt(theCell, 0, 0);
   IF LSearch(@gListNavigateString[1], Length(gListNavigateString),
               @MyMatchNextAlphabetically, theCell, theList) THEN
   BEGIN
                                       {deselect all cells but new cell}
      MySelectOneCell(theList, theCell);     
                                       {make sure new selection is visible}
      MyMakeCellVisible(theList, theCell); 
   END;
END;
</PRE>
 The <CODE>MyKeySearchInList</CODE> procedure defined in <A HREF=#MARKER-9-239>Listing 4-18</A> first updates variables related to type selection. Then it searches through the list for a cell containing the current search string or for the next cell alphabetically. It searches using the <CODE>LSearch</CODE> function in conjunction with a custom match function defined in <A HREF=MoreToolbox-216.html#MARKER-9-223>Listing 4-15 on page 4-34</A>. The procedure also uses the <CODE>MySelectOneCell</CODE> procedure defined in <A HREF=MoreToolbox-213.html#MARKER-9-192>Listing 4-9 on page 4-27</A> and the <CODE>MyMakeCellVisible</CODE> procedure defined in <A HREF=MoreToolbox-213.html#MARKER-9-195>Listing 4-10 on page 4-28</A>.<A NAME=MARKER-2-241></A><P>
<DL>
<DT><B>Note</B>
<DD>If your compiler enforces range checking, you may need to disable it before using the code in <A HREF=#MARKER-9-239>Listing 4-18</A>, because the code accesses the length byte of a string directly. See your development system's documentation for more information on range checking.<EM></EM><A NAME=MARKER-2-127></A>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING217-16></A>
<H3>Supporting Arrow-Key Navigation of Lists<A NAME=MARKER-2-103></A><A NAME=MARKER-9-383></A></H3>
 This section discusses how your application can support the use of arrow keys to move the current selection or to extend the current selection using a simple extension algorithm. For information on implementing a more complex anchor algorithm for extending the selection, read this section and then the next section, beginning on <A HREF=#MARKER-9-253>page 4-43</A>.<P>
 The following constants define the ASCII character codes for the various arrow keys. These ASCII values for these keys are the same for U.S. and international keyboards.<P>
<PRE>
CONST
   kLeftArrow     = Char(28);             {move left}
   kRightArrow    = Char(29);             {move right}
   kUpArrow       = Char(30);             {move up}
   kDownArrow     = Char(31);             {move down}
</PRE>
 To support both the moving of a selection (the user's pressing an arrow key without pressing the Shift key) and the extending of a selection (the user's pressing of an arrow key while pressing the Shift key), your application needs to define a routine that computes a new selection location given an old one. For example, if the user presses Command-Left Arrow, the routine should find the cell as far to the left of the first currently selected cell as possible. <A HREF=#MARKER-9-245>Listing 4-19</A> illustrates an application-defined procedure that does this. <P>
<B>Listing 4-19  <A NAME=MARKER-9-245></A>Determining the location of a new cell in response to an arrow-key event<A NAME=MARKER-2-58></A></B><P>
<PRE>
PROCEDURE MyFindNewCellLoc 
            (theList: ListHandle; oldCellLoc: Cell;
             VAR newCellLoc: Cell; keyHit: Char;
             moveToExtreme: Boolean);
VAR
   listRows, listColumns: Integer;     {list dimensions}
BEGIN
   WITH theList^^.dataBounds DO
   BEGIN
      listRows := bottom - top;        {number of rows in list}
      listColumns := right - left;     {number of columns in list}
   END;
   newCellLoc := oldCellLoc;
   IF moveToExtreme THEN
      CASE keyHit OF
         kUpArrow: 
            newCellLoc.v := 0;               {move to row 0}
         kDownArrow: 
            newCellLoc.v := listRows - 1;    {move to last row}
         kLeftArrow: 
            newCellLoc.h := 0;               {move to column 0}
         kRightArrow: 
            newCellLoc.h := listColumns - 1; {move to last column}
      END
   ELSE
      CASE keyHit OF
         kUpArrow: 
            IF oldCellLoc.v &lt;&gt; 0 THEN
               newCellLoc.v := oldCellLoc.v - 1;   {row up}
         kDownArrow: 
            IF oldCellLoc.v &lt;&gt; listRows - 1 THEN
               newCellLoc.v := oldCellLoc.v + 1;   {row down}
         kLeftArrow: 
            IF oldCellLoc.h &lt;&gt; 0 THEN
               newCellLoc.h := oldCellLoc.h - 1;   {column left}
         kRightArrow: 
            IF oldCellLoc.h &lt;&gt; listColumns - 1 THEN
               newCellLoc.h := oldCellLoc.h + 1;   {column right}
      END;
END;
</PRE>
 The <CODE>MyFindNewCellLoc</CODE> procedure defined in <A HREF=#MARKER-9-245>Listing 4-19</A> computes the coordinates of the cell referenced by the <CODE>newCellLoc</CODE> parameter based on the coordinates of the <CODE>oldCellLoc</CODE> parameter and the direction of the arrow key pressed. The <CODE>oldCellLoc</CODE> parameter contains the coordinates of the first or last cell in a selection, depending on which arrow key was pressed. The behavior of <CODE>MyFindNewCellLoc</CODE> also depends on the value passed in the <CODE>moveToExtreme</CODE> parameter. For example, if the user pressed the Command key while pressing an arrow key, the SurfWriter application passes <CODE>TRUE</CODE>; otherwise, it passes <CODE>FALSE</CODE>. If <CODE>moveToExtreme</CODE> is <CODE>TRUE</CODE>, then <CODE>MyFindNewCellLoc</CODE> returns in <CODE>newCellLoc</CODE> a cell that is as far as possible from the cell specified in <CODE>oldCellLoc</CODE>. Otherwise, it returns a cell that is within one cell of <CODE>oldCellLoc</CODE>. If a cell cannot be moved in the direction specified by the arrow key, <CODE>newCellLoc</CODE> is equivalent on exit to <CODE>oldCellLoc</CODE>.<P>
 Having defined the <CODE>MyFindNewCellLoc</CODE> procedure, it is easy to move or extend a selection in response to an arrow-key event. <A HREF=#MARKER-9-247>Listing 4-20</A> illustrates an application-defined procedure that moves the selection in response to the user's pressing an arrow key without pressing the Shift key.<P>
<B>Listing 4-20  <A NAME=MARKER-9-247></A>Moving the selection in response to an arrow-key event<A NAME=MARKER-2-207></A></B><P>
<PRE>
PROCEDURE MyArrowKeyMoveSelection (theList: ListHandle;
                                   keyHit: Char; 
                                   moveToExtreme: Boolean);
VAR
   currentSelection:       Cell;
   newSelection:           Cell;
BEGIN
   IF MyGetFirstSelectedCell(theList, currentSelection) THEN
   BEGIN
      IF (keyHit = kRightArrow) OR (keyHit = kDownArrow) THEN
         {find last selected cell}
         MyGetLastSelectedCell(theList, currentSelection);
      {move relative to appropriate cell}
      MyFindNewCellLoc(theList, currentSelection,
                       newSelection, keyHit, moveToExtreme);
      {make this cell the selection}
      MySelectOneCell(theList, newSelection);
      {make sure new selection is visible}
      MyMakeCellVisible(theList, newSelection);
   END;
END;
</PRE>
 The <CODE>MyArrowKeyMoveSelection</CODE> procedure defined in <A HREF=#MARKER-9-247>Listing 4-20</A> calls the <CODE>MyFindNewCellLoc</CODE> procedure defined in <A HREF=#MARKER-9-245>Listing 4-19</A> to find the coordinates of a cell to select. It computes the coordinates of that new cell relative to the first selected cell if the user pressed a Left Arrow or Up Arrow key; otherwise, it computes the coordinates of the new cell relative to the last selected cell. After computing the coordinates of the new cell, <CODE>MyArrowKeyMoveSelection</CODE> selects it by calling routines defined in <BR><A HREF=MoreToolbox-213.html#MARKER-9-192>Listing 4-9</A> and <A HREF=MoreToolbox-213.html#MARKER-9-195>Listing 4-10</A>.<P>
 <A HREF=#MARKER-9-249>Listing 4-21</A> illustrates an application-defined procedure that extends the selection in response to the user's pressing an arrow key while pressing the Shift key.<P>
<B>Listing 4-21  <A NAME=MARKER-9-249></A>Extending the selection in response to an arrow-key event<A NAME=MARKER-2-232></A></B><P>
<PRE>
PROCEDURE MyArrowKeyExtendSelection (theList: ListHandle;
                                    keyHit: Char; 
                                    moveToExtreme: Boolean);
VAR
   currentSelection: Cell;
   newSelection:     Cell;
BEGIN
   IF MyGetFirstSelectedCell(theList, currentSelection) THEN
   BEGIN
      IF (keyHit = kRightArrow) OR (keyHit = kDownArrow) THEN
                              {find last selected cell}
         MyGetLastSelectedCell(theList, currentSelection);
                              {move relative to appropriate cell}
      MyFindNewCellLoc(theList, currentSelection,
                       newSelection, keyHit, moveToExtreme);
                              {add a new cell to the selection}
      IF NOT LGetSelect(FALSE, newSelection, theList) THEN
         LSetSelect(TRUE, newSelection, theList);
                              {make sure new selection is visible}
      MyMakeCellVisible(theList, newSelection);
   END;
END;
</PRE>
 The <CODE>MyArrowKeyExtendSelection</CODE> procedure defined in <A HREF=#MARKER-9-249>Listing 4-21</A> works just <BR>like the <CODE>MyArrowKeyMoveSelection</CODE> procedure defined in <A HREF=#MARKER-9-247>Listing 4-20</A>, but it does not deselect all other cells besides the newly selected cell.<P>
 <A HREF=#MARKER-9-251>Listing 4-22</A> shows an application-defined procedure that takes advantage of the <BR>code listings provided in this section. The SurfWriter application calls the procedure in <BR><A HREF=#MARKER-9-251>Listing 4-22</A> every time it receives an arrow-key event that affects a list.<P>
<B>Listing 4-22  <A NAME=MARKER-9-251></A>Processing an arrow-key event<A NAME=MARKER-2-252></A></B><P>
<PRE>
PROCEDURE MyArrowKeyInList (theList: ListHandle; theEvent: EventRecord;
                           allowExtendedSelections: Boolean);
BEGIN
   IF (NOT allowExtendedSelections) OR 
         (BAnd(theEvent.modifiers, shiftKey) = 0) THEN
      MyArrowKeyMoveSelection(theList, 
                              CHR(BAnd(theEvent.message, charCodeMask)),
                              BAnd(theEvent.modifiers, cmdKey) &lt;&gt; 0)
   ELSE
      MyArrowKeyExtendSelection(theList, 
                                CHR(BAnd(theEvent.message, charCodeMask)),
                                BAnd(theEvent.modifiers, cmdKey) &lt;&gt; 0);
END;
</PRE>
 The <CODE>MyArrowKeyInList</CODE> procedure defined in <A HREF=#MARKER-9-251>Listing 4-22</A> takes three parameters, the third of which is a Boolean variable that indicates whether the application supports the use of Shift-arrow key combinations to extend the current selection. If the application does support this and the user held down the Shift key, the <CODE>MyArrowKeyInList</CODE> procedure calls the procedure in <A HREF=#MARKER-9-249>Listing 4-21</A> to extend the selection. Otherwise, it calls the procedure in <A HREF=#MARKER-9-247>Listing 4-20</A> to move the selection. Either way, it checks the status of the Command key to determine whether the appropriate procedure should move as far in the direction of the arrow key as possible before selecting a new cell.<P>
<A NAME=HEADING217-36></A>
<H3><A NAME=MARKER-9-253></A>Supporting the Anchor Algorithm for Extending Lists With Arrow Keys</H3>
 This section summarizes how your application can support the anchor method for extending lists with arrow keys. Implementing this method takes a lot of work, but the extra work may pay off if you expect many users of your application's lists to make range selections or if your application uses multicolumn lists. For a comparison between the anchor algorithm and the extension algorithm illustrated in the previous section, see <A HREF=MoreToolbox-206.html#MARKER-9-78>"Extension of a Selection With Arrow Keys" on page 4-10</A>.<P>
 To support the anchor algorithm, your application must keep track of several types of information between Shift-arrow key events. Most importantly, your application must store information about which cell in a list is the anchor cell and which cell is the moving cell. In response to a Shift-arrow key event, your application should change the location of the moving cell. It should then highlight all cells in the rectangle whose corners are the anchor cell and the moving cell. This permits the user to use several consecutive Shift-arrow key combinations to move a rectangular range of cells around the anchor cell.<P>
 Your application must thus save the location of the anchor cell the first time the user uses a Shift-arrow key combination to affect a certain rectangular range of cells. For example, if the user presses Shift-Right Arrow and the user has not before used a Shift-arrow key combination, then your application should store as the anchor cell the upper-left cell in the rectangular range of cells to be affected. The moving cell is then one cell to the right of what was the lower-right corner of this range.<P>
 Your application can determine what rectangular range of cells a Shift-arrow key combination is meant to affect by using the <CODE>LLastClick</CODE> function, which returns the coordinates of the last cell that was clicked. (If your application relies on this function, it must always update the <CODE>lastClick</CODE> field of the list record in response to keyboard selection of any list item, since keyboard selection of a list item is functionally equivalent to clicking.) Your application must check the selection status of adjacent cells to find as big a rectangular range of selected cells surrounding this cell as possible. <P>
 Your application can check whether a Shift-arrow key event is affecting a new range of cells simply by checking the <CODE>clikTime</CODE> field of the list record. (Your application must thus also update this field in response to keyboard selection of any list item.) If the last click time changes between Shift-arrow key events, your application knows that the user has clicked the list or used the keyboard to change the selection. In this case, your application must compute a new anchor cell and moving cell based on the <CODE>LLastClick</CODE> function and the direction of the arrow key pressed. Otherwise, your application can keep the same anchor cell, move the moving cell in the direction specified by the arrow key, and highlight cells in the rectangular range of the anchor cell and the moving cell.<P>
 In summary, if your application is to support the anchor algorithm for extending a list selection, it must keep track of an anchor cell, a moving cell, and the time of the last click in a list. (Your application might store a handle to a relocatable block containing this information in the <CODE>userHandle</CODE> field of the list record.) Whenever a Shift-arrow key event is meant to affect a new range of cells, your application updates all three of these variables. Otherwise, it only changes the coordinates of the moving cell from one Shift-arrow key event to the next. <A NAME=MARKER-9-231></A> <A NAME=MARKER-2-147></A><A NAME=MARKER-2-148></A><A NAME=MARKER-2-61></A><A NAME=MARKER-9-199></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="MoreToolbox-216.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MoreToolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MoreToolbox-513.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MoreToolbox-218.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="MoreToolbox-3.html">&copy; Apple Computer, Inc.</A><br>6 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>   
