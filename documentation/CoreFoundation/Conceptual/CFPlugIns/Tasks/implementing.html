<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Plug-ins: Implementing a Plug-in</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Implementing a Plug-in"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/20001164" title="Implementing a Plug-in"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000421" target="_top">Core Foundation</a> &gt; <a href="../../../ProcessManagement-date.html#//apple_ref/doc/uid/TP30000440-TP30000421-TP30000456" target="_top">Process Management</a> &gt; <a href="../index.html" target="_top">Plug-ins</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="defining.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="loading.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>
        
        
        <a name="//apple_ref/doc/uid/20001164-CJBEHAAG" title="Implementing a Plug-in"></a><hr /><H1>Implementing a Plug-in</H1><p>This section details all of the steps necessary to actually implement a plug-in that supports the type declared in <span class="content_text"><a href="defining.html#//apple_ref/doc/uid/20001163-CJBEHAAG">“Defining Types and Interfaces”</a></span></p>
<!-- This template is being used for both PDF and HTML. -->

    
    <!-- TopicBook.pm uses this template for its miniTOCs, but needs a different title. -->
    <h4>Contents:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="implementing.html#//apple_ref/doc/uid/20001164-100971-TPXREF106">Registering Types and Interfaces</a>
				
			<br/>
			
        
			
			
				<a href="implementing.html#//apple_ref/doc/uid/20001164-101076-TPXREF107">Implementing the Types, Factories, and Interfaces</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/20001164-100971" title="Registering Types and Interfaces"></a><a name="//apple_ref/doc/uid/20001164-100971-TPXREF106" title="Registering Types and Interfaces"></a><h2>Registering Types and Interfaces</h2><p>Now that we have a type and some interfaces, let's look at how a plug-in that supported this type would be implemented. First, consider the information property list for the plug-in in <span class="content_text"><a href="implementing.html#//apple_ref/doc/uid/20001164-100988-BAJDHAEB">Listing 1</a></span> </p><a name="//apple_ref/doc/uid/20001164-100988-BAJDHAEB" title="Listing 1An Info.plist file for a plug-in"></a><p class="codesample"><a name="//apple_ref/doc/uid/20001164-100988" title="Listing 1An Info.plist file for a plug-in"></a><strong>Listing 1&nbsp;&nbsp;</strong>An Info.plist file for a plug-in</p><div class="codesample"><table><tr><td scope="row"><pre>&lt;?xml version="1.0" encoding="UTF-8"?><span></span></pre></td></tr><tr><td scope="row"><pre>&lt;!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"><span></span></pre></td></tr><tr><td scope="row"><pre>&lt;plist version="1.0"><span></span></pre></td></tr><tr><td scope="row"><pre>&lt;dict><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>CFBundleDevelopmentRegion&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>English&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>CFBundleExecutable&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>CFTestPlugin&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>CFBundleIconFile&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>CFBundleIdentifier&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>com.apple.yourcfbundle&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>CFBundleInfoDictionaryVersion&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>6.0&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>CFBundlePackageType&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>BNDL&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>CFBundleSignature&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>????&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>CFBundleVersion&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>1.0&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>CFPlugInDynamicRegisterFunction&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>CFPlugInDynamicRegistration&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>NO&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>CFPlugInFactories&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;dict><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;key>68753A44-4D6F-1226-9C60-0050E4C00067&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;string>MyFactoryFunction&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;/dict><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>CFPlugInTypes&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;dict><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;key>D736950A-4D6E-1226-803A-0050E4C00067&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;array><span></span></pre></td></tr><tr><td scope="row"><pre>            &lt;string>68753A44-4D6F-1226-9C60-0050E4C00067&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;/array><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;/dict><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>CFPlugInUnloadFunction&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>&lt;/dict><span></span></pre></td></tr><tr><td scope="row"><pre>&lt;/plist><span></span></pre></td></tr></table></div><p>The information property list defines various aspects of the plug-in’s runtime behavior and contains optional static registration information for the various types the plug-in supports. For more information about static and dynamic registration, see <span class="content_text"><a href="../Concepts/registration.html#//apple_ref/doc/uid/20001161-CJBEJBHH">“Plug-in Registration”</a></span></p><p>In this example, the <code>CFBundleExecutable</code> key tells CFBundle the name of the executable and is used by the primitive code-loading API of bundles. The rest of the keys are specific to the plug-in model.</p><p>The <code>CFPlugInDynamicRegistration</code> key indicates whether this plug-in requires dynamic registration. In this example, static registration is used, so the dynamic registration key is set to <code>NO</code>.</p><p>The <code>CFPlugInFactories</code> key is used to statically register factory functions, and the <code>CFPlugInTypes</code> key is used to statically register the factories that can create each supported type.</p><a name="//apple_ref/doc/uid/20001164-101076" title="Implementing the Types, Factories, and Interfaces"></a><a name="//apple_ref/doc/uid/20001164-101076-TPXREF107" title="Implementing the Types, Factories, and Interfaces"></a><h2>Implementing the Types, Factories, and Interfaces</h2><p>When implementing a plug-in, you must provide </p><ul class="ul"><li class="li"><p>the implementation for any factory functions registered for the plug-in</p></li><li class="li"><p>implementations for all the functions in all the interfaces for any types supported by your plug-in</p></li><li class="li"><p>an interface function table for each interface you implement</p></li><li class="li"><p>the required COM functions, <code>QueryInterface</code>, <code>AddRef</code> and <code>Release</code></p></li></ul><p><span class="content_text"><a href="implementing.html#//apple_ref/doc/uid/20001164-101138-BAJIABDD">Listing 2</a></span> contains the code for a plug-in that implements the type <code>kTestTypeID</code> and its interface.</p><a name="//apple_ref/doc/uid/20001164-101138-BAJIABDD" title="Listing 2Example plug-in implementation"></a><p class="codesample"><a name="//apple_ref/doc/uid/20001164-101138" title="Listing 2Example plug-in implementation"></a><strong>Listing 2&nbsp;&nbsp;</strong>Example plug-in implementation</p><div class="codesample"><table><tr><td scope="row"><pre> #include &lt;CoreFoundation/CoreFoundation.h><span></span></pre></td></tr><tr><td scope="row"><pre> #include "TestInterface.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// The UUID for the factory function.<span></span></pre></td></tr><tr><td scope="row"><pre>#define kTestFactoryID (CFUUIDGetConstantUUIDWithBytes(NULL,<span></span></pre></td></tr><tr><td scope="row"><pre> 0x68, 0x75, 0x3A, 0x44, 0x4D, 0x6F, 0x12, 0x26, 0x9C, 0x60,<span></span></pre></td></tr><tr><td scope="row"><pre>0x00, 0x50, 0xE4, 0xC0, 0x00, 0x67))<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// The layout for an instance of MyType.<span></span></pre></td></tr><tr><td scope="row"><pre>typedef struct _MyType {<span></span></pre></td></tr><tr><td scope="row"><pre>    TestInterfaceStruct *_testInterface;<span></span></pre></td></tr><tr><td scope="row"><pre>    CFUUIDRef _factoryID;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 _refCount;<span></span></pre></td></tr><tr><td scope="row"><pre> } MyType;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Forward declaration for the IUnknown implementation.<span></span></pre></td></tr><tr><td scope="row"><pre>static void _deallocMyType( MyType *this );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Implementation of the IUnknown QueryInterface function.<span></span></pre></td></tr><tr><td scope="row"><pre>static HRESULT myQueryInterface( void *this, REFIID iid, LPVOID *ppv )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // Create a CoreFoundation UUIDRef for the requested interface.<span></span></pre></td></tr><tr><td scope="row"><pre>    CFUUIDRef interfaceID = CFUUIDCreateFromUUIDBytes( NULL, iid );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Test the requested ID against the valid interfaces.<span></span></pre></td></tr><tr><td scope="row"><pre>    if (CFEqual(interfaceID, kTestInterfaceID))<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        // If the TestInterface was requested, bump the ref count,<span></span></pre></td></tr><tr><td scope="row"><pre>        // set the ppv parameter equal to the instance, and<span></span></pre></td></tr><tr><td scope="row"><pre>        // return good status.<span></span></pre></td></tr><tr><td scope="row"><pre>        ((MyType *)this)->_testInterface->AddRef( this );<span></span></pre></td></tr><tr><td scope="row"><pre>        *ppv = this;<span></span></pre></td></tr><tr><td scope="row"><pre>        CFRelease(interfaceID);<span></span></pre></td></tr><tr><td scope="row"><pre>        return S_OK;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (CFEqual(interfaceID, IUnknownUUID))<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        // If the IUnknown interface was requested, same as above.<span></span></pre></td></tr><tr><td scope="row"><pre>        ((MyType *)this)->_testInterface->AddRef( this );<span></span></pre></td></tr><tr><td scope="row"><pre>        *ppv = this;<span></span></pre></td></tr><tr><td scope="row"><pre>        CFRelease( interfaceID );<span></span></pre></td></tr><tr><td scope="row"><pre>        return S_OK;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Requested interface unknown, bail with error.<span></span></pre></td></tr><tr><td scope="row"><pre>    *ppv = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    CFRelease( interfaceID );<span></span></pre></td></tr><tr><td scope="row"><pre>    return E_NOINTERFACE;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Implementation of reference counting for this type.<span></span></pre></td></tr><tr><td scope="row"><pre>// Whenever an interface is requested, bump the refCount for<span></span></pre></td></tr><tr><td scope="row"><pre>// the instance. NOTE: returning the refcount is a convention<span></span></pre></td></tr><tr><td scope="row"><pre>// but is not required so don’t rely on it.<span></span></pre></td></tr><tr><td scope="row"><pre>static ULONG myAddRef( void *this )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    ((MyType *)this)->_refCount += 1;<span></span></pre></td></tr><tr><td scope="row"><pre>    return ((MyType *)this)->_refCount;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// When an interface is released, decrement the refCount.<span></span></pre></td></tr><tr><td scope="row"><pre>// If the refCount goes to zero, deallocate the instance.<span></span></pre></td></tr><tr><td scope="row"><pre>static ULONG myRelease( void *this )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    ((MyType *)this)->_refCount -= 1;<span></span></pre></td></tr><tr><td scope="row"><pre>    if (((MyType *)this)->_refCount == 0)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        _deallocMyType( (MyType *)this );<span></span></pre></td></tr><tr><td scope="row"><pre>        return 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return ((MyType *)this)->_refCount;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// The implementation of the TestInterface function.<span></span></pre></td></tr><tr><td scope="row"><pre>static void myFooMe( void *this, Boolean flag )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    printf("myFooMe: instance 0x%x: I've been fooed.  %s\n",<span></span></pre></td></tr><tr><td scope="row"><pre>            (unsigned)this, (flag ? "YES" : "NOPE"));<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// The TestInterface function table.<span></span></pre></td></tr><tr><td scope="row"><pre>static TestInterfaceStruct testInterfaceFtbl =<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>        NULL,               // Required padding for COM<span></span></pre></td></tr><tr><td scope="row"><pre>        myQueryInterface,   // These three are the required COM functions<span></span></pre></td></tr><tr><td scope="row"><pre>        myAddRef,<span></span></pre></td></tr><tr><td scope="row"><pre>        myRelease,<span></span></pre></td></tr><tr><td scope="row"><pre>        myFooMe<span></span></pre></td></tr><tr><td scope="row"><pre>}; // Interface implementation<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Utility function that allocates a new instance.<span></span></pre></td></tr><tr><td scope="row"><pre>static MyType *_allocMyType( CFUUIDRef factoryID )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // Allocate memory for the new instance.<span></span></pre></td></tr><tr><td scope="row"><pre>    MyType *newOne = (MyType *)malloc( sizeof(MyType) );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Point to the function table<span></span></pre></td></tr><tr><td scope="row"><pre>    newOne->_testInterface = &amp;testInterfaceFtbl;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Retain and keep an open instance refcount<span></span></pre></td></tr><tr><td scope="row"><pre>    // for each factory.<span></span></pre></td></tr><tr><td scope="row"><pre>    newOne->_factoryID = CFRetain( factoryID );<span></span></pre></td></tr><tr><td scope="row"><pre>    CFPlugInAddInstanceForFactory( factoryID );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // This function returns the IUnknown interface<span></span></pre></td></tr><tr><td scope="row"><pre>    // so set the refCount to one.<span></span></pre></td></tr><tr><td scope="row"><pre>    newOne->_refCount = 1;<span></span></pre></td></tr><tr><td scope="row"><pre>    return newOne;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Utility function that deallocates the instance<span></span></pre></td></tr><tr><td scope="row"><pre>// when the refCount goes to zero.<span></span></pre></td></tr><tr><td scope="row"><pre>static void _deallocMyType( MyType *this )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CFUUIDRef factoryID = this->_factoryID;<span></span></pre></td></tr><tr><td scope="row"><pre>    free(this);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (factoryID)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        CFPlugInRemoveInstanceForFactory( factoryID );<span></span></pre></td></tr><tr><td scope="row"><pre>        CFRelease( factoryID );<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Implementation of the factory function for this type.<span></span></pre></td></tr><tr><td scope="row"><pre>void *MyFactory(CFAllocatorRef allocator, CFUUIDRef typeID)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // If correct type is being requested, allocate an<span></span></pre></td></tr><tr><td scope="row"><pre>    // instance of TestType and return the IUnknown interface.<span></span></pre></td></tr><tr><td scope="row"><pre>    if (CFEqual(typeID, kTestTypeID))<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        MyType *result = _allocMyType( kTestFactoryID );<span></span></pre></td></tr><tr><td scope="row"><pre>        return result;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    // If the requested type is incorrect, return NULL.<span></span></pre></td></tr><tr><td scope="row"><pre>    return NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>As illustrated in <span class="content_text"><a href="implementing.html#//apple_ref/doc/uid/20001164-101138-BAJIABDD">Listing 2</a></span> the first step in implementing a plug-in to is define the UUID for the factory you are going to supply. This is the same UUID that was used in the <code>CFPlugInFactories</code> key in the information property list. Next, the data structure for instances of the <code>TestType</code> implementation is defined. </p><p>After defining the instance structure, you implement the IUnknown interface functions required for every plug-in. In this example, <code>QueryInterface</code>, relies on the fact that the first pointer in the instance structure is an interface, so returning a pointer to the <code>MyType</code> structure is the same as returning a pointer to a pointer to <code>TestInterface</code>. Types that implement more than one interface would be more complicated. In C++, this can be accomplished using multiple inheritance and static casting. In C, you would have to keep track of the interface pointers by hand.</p><p>After the IUnknown functions, there is the implementation for the <code>fooMe</code> function from <code>TestInterface</code>. In this example it just prints a message. Next comes the static definition of the actual <code>TestInterface</code> function table. This table is filled in with the IUnknown and <code>TestInterface</code> functions.</p><p>Following the function table are two utility functions that allow easy creation and freeing of <code>MyType</code> structures. The allocator fills in the pointer to the interface function table and sets the initial reference count to 1. It also takes care of registering the instance with the factory so plug-ins knows not to unload the plug-in’s code while there are still instances active. The deallocator function frees the memory for <code>MyType</code> and unregisters the instance from the factory.</p><p>Finally, there is the actual factory function that creates a new instance and returns a pointer to it. This pointer is also a pointer to the IUnknown interface. The <code>MyFactory</code> function must conform to the <code>CFPlugInFactoryFunction</code> prototype. Factory functions take allocators and type UUIDs as parameters.</p><p><span class="content_text"><a href="implementing.html#//apple_ref/doc/uid/20001164-101138-BAJIABDD">Listing 2</a></span> contains a lot of glue code that would be unnecessary for C++ developers using a compiler with built-in support for generating COM interface layouts. If you wish to implement CFPlugIns in C++, refer to the wealth of COM documentation by Microsoft and others.</p>

        <br/><br/> 

        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="defining.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="loading.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2003, 2005 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2005-03-03<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/CoreFoundation/Conceptual/CFPlugIns/Tasks/implementing.html%3Fid%3D10000128i-2.3&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/CoreFoundation/Conceptual/CFPlugIns/Tasks/implementing.html%3Fid%3D10000128i-2.3&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/CoreFoundation/Conceptual/CFPlugIns/Tasks/implementing.html%3Fid%3D10000128i-2.3&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>
