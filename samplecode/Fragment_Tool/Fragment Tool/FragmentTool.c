/*	File:		FragmentTool.c	Contains:	Main event loop and basic keyboard/mouse processing	Written by: Chris White		Copyright:	Copyright © 1995-1999 by Apple Computer, Inc., All Rights Reserved.				You may incorporate this Apple sample source code into your program(s) without				restriction. This Apple sample source code has been provided "AS IS" and the				responsibility for its operation is yours. You are not permitted to redistribute				this Apple sample source code as "Apple sample source code" after having made				changes. If you're going to re-distribute the source, we require that you make				it clear in the source that the code was descended from Apple sample source				code, but that you've made changes.	Change History (most recent first):				8/5/1999	Karl Groethe	Updated for Metrowerks Codewarror Pro 2.1				*/#include <Memory.h>#include <AppleEvents.h>#include <Dialogs.h>#include <Devices.h>#include <Windows.h>#define	__MAIN__#include "FragmentTool.h"#include "Prototypes.h"#if defined(powerc) && !defined(__MWERKS__) // MetroWerks declares "qd" in their runtime	QDGlobals	qd;#endifvoid main ( void );static void DoKey ( EventRecord*theEvent );static void DoMouseDown ( EventRecord* theEvent );static void EventLoop ( void );void main ( void ){	MaxApplZone ( );		// We don't use too many more handles, so we onyl need to call	// MoreMasters a couple of times.	MoreMasters ( );	MoreMasters ( );			InitToolbox ( );						// Init toolbox stuff	InitApplication ( );					// Init application specific stuff	EventLoop ( );			return;}static void EventLoop ( void ){	OSErr			theErr;	EventRecord		theEvent;			while ( !gQuit )	{		WaitNextEvent ( everyEvent, &theEvent, gSleepTime, nil );					switch ( theEvent.what )		{			case nullEvent:			{				DialogRef	theDialog;								theDialog = FrontWindow ( );				if ( GetWindowType ( theDialog ) == kGetInfoWindowType )					TEIdle ( ((DialogPeek) theDialog)->textH );			}			break;						case mouseDown: 				DoMouseDown ( &theEvent );			break;						case keyDown:			case autoKey: 				DoKey ( &theEvent );			break;						case activateEvt: 				DoActivate ( &theEvent );			break;						case updateEvt:				DoUpdate ( &theEvent );			break;						case osEvt:				if ( (theEvent.message >> 24) & suspendResumeMessage )	/* suspend or resume */				{					/* Modify the event record to look like an activate/deactivate event */					theEvent.modifiers = theEvent.message; /* Copy suspend/resume flag */					theEvent.message = (long) FrontWindow ( );						DoActivate ( &theEvent );				}			break;						case kHighLevelEvent:				theErr = AEProcessAppleEvent ( &theEvent );			break;		}	}		return;	} // EventLoopstatic void DoMouseDown ( EventRecord* theEvent ){	Point			globalPt = theEvent->where;	int16			windowPart;	WindowRef		theWindow;	long			theMenu;			windowPart = FindWindow ( globalPt, &theWindow );	switch ( windowPart )	{		case inMenuBar: 			theMenu = MenuSelect ( globalPt );			MenuDispatch ( theMenu );		break;				case inSysWindow:			// The SystemClick toolbox routine handles system events			SystemClick ( theEvent, theWindow );		break;				case inGoAway: 			if ( TrackGoAway ( theWindow, theEvent->where ) )			{				// Very easy to implement, and very useful on occasion				if ( theEvent->modifiers & optionKey )					DoCloseAllDocuments ( );				else					DoCloseDocument ( theWindow );			}		break;				case inDrag:			DoDragWindow ( theWindow, theEvent );		break;		case inGrow: 			DoGrowWindow ( theWindow, theEvent );		break;				case inContent:			DoContentClick ( theWindow, theEvent );		break;		case inZoomIn:		case inZoomOut: 			DoZoomWindow ( theWindow, theEvent, windowPart );		break;	}		return;	} // DoMouseDownstatic void DoKey ( EventRecord* theEvent ){	char keyPressed = (theEvent->message & charCodeMask);			if ( theEvent->modifiers & cmdKey )	{		// Command keys get handled by the menu handling routines		AdjustMenus ( );		MenuDispatch ( MenuKey ( keyPressed ) );	}	else	{		// Pass other key strokes to the dialog handling routines		int16		itemHit;		WindowRef	theWindow = FrontWindow ( );				if ( IsMovableModal ( theWindow ) )		{			if ( DialogSelect ( theEvent, &theWindow, &itemHit ) )				DoDialogItemHit ( theWindow, itemHit );		}	}		return;	} // DoKey