<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>I/O Kit Device Driver Design Guidelines: libkern Collection and Container Classes</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="libkern Collection and Container Classes"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30000696" title="libkern Collection and Container Classes"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../HardwareDrivers/index.html#//apple_ref/doc/uid/TP30000440-TP40003576" target="_top">Hardware &amp; Drivers</a> &gt; <a href="../Introduction/Intro.html#//apple_ref/doc/uid/TP40002799-TPXREF101">I/O Kit Device Driver Design Guidelines</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../CPluPlusRuntime/CPlusPlusRuntime.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../IOService/IOService.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30000696-BABDHFJJ" title="libkern Collection and Container Classes"></a><h1>libkern Collection and Container Classes</h1><p>Your driver’s information property list contains at least one personality dictionary<a name="//apple_ref/doc/uid/TP30000696-DontLinkElementID_137"></a> that specifies the type of device your driver can manage. A personality dictionary can also contain information pertinent to your driver’s runtime configuration. When your driver is instantiated, it receives a copy of the I/O Kit personality for which it was loaded and it can use this information to make sure it is suitable to drive the device and, optionally, to configure itself to meet the device’s needs.</p><p>The I/O Kit personality your driver receives is in the form of an OSDictionary, which is one of the libkern collection classes. The libkern C++ library defines container classes, which hold primitive values, such as numbers and strings, and collection classes, which hold groups of both container objects and other collection objects. This chapter first describes ways in which your driver can use the libkern collection and container classes, then it gives an overview of these classes and their methods. The chapter concludes with code samples that illustrate how your driver can use the libkern classes to configure itself.</p><p>For more information on the libkern library and how it supports loadable kernel modules, see <span class="content_text"><a href="../CPluPlusRuntime/CPlusPlusRuntime.html#//apple_ref/doc/uid/TP30000695-BAJIBFDE">“The libkern C++ Runtime”</a></span> and <em><a href="../../IOKitFundamentals/index.html#//apple_ref/doc/uid/TP0000011" target="_top">I/O Kit Fundamentals</a></em>. For API reference documentation on the libkern classes, see <span class="content_text"><!--a target="_top" -->Device Drivers Documentation<!--/a--></span>. On Mac OS X, you can find the libkern library in <code>/System/Library/Frameworks/Kernel.framework/Headers/libkern/c++</code>.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="Libkern_Classes.html#//apple_ref/doc/uid/TP30000696-CJABEIEE">The libkern Classes and Your Driver</a>
				
			<br/>
			
        
			
			
				<a href="Libkern_Classes.html#//apple_ref/doc/uid/TP30000696-TPXREF101">libkern Collection and Container Class Overview</a>
				
			<br/>
			
        
			
			
				<a href="Libkern_Classes.html#//apple_ref/doc/uid/TP30000696-CJAJFIJC">Using the libkern Collection and Container Classes</a>
				
			<br/>
			
        
			
			
				<a href="Libkern_Classes.html#//apple_ref/doc/uid/TP30000696-CJACHIAJ">Configuring Your Driver Using the libkern Classes</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30000696-CJABEIEE" title="The libkern Classes and Your Driver"></a><h2>The libkern Classes and Your Driver</h2><p><a name="//apple_ref/doc/uid/TP30000696-DontLinkElementID_138"></a>The libkern collection and container classes offer powerful services your driver can use to configure its runtime environment. Although these services may seem perfect for use in your driver’s I/O routines, they are too costly to use outside your driver’s dynamic configuration phases. During your driver’s <code><!--a-->init<!--/a--></code>, <code><!--a-->start<!--/a--></code>, and <code><!--a-->probe<!--/a--></code> routines, however, the trade-off between cost and benefit make the libkern container and collection classes attractive.</p><p>The libkern classes offer many benefits, such as object introspection, encapsulation, and ability to serialize. In addition, the libkern container and collection classes closely correspond to the Core Foundation classes in both name and behavior. This allows the system to automatically translate between libkern and Core Foundation classes of the same type. For example, the libkern collection object OSDictionary is converted into the Core Foundation object CFDictionary when crossing the user-kernel boundary.</p><p><a name="//apple_ref/doc/uid/TP30000696-DontLinkElementID_139"></a><a name="//apple_ref/doc/uid/TP30000696-DontLinkElementID_140"></a>For a driver, one of the greatest benefits of the libkern classes lies in their ability to make a driver’s XML property list available to the driver during its life span. There are three general ways your driver can use the OSDictionary representation of its I/O Kit personality.</p><ul class="ul"><li class="li"><p>A driver can configure itself to drive a particular type of device by reading the contents of its property list and performing the appropriate set-up.</p></li><li class="li"><p>A driver can modify its property list (and, optionally, that of its provider) based on information it receives from the device or other service objects currently in the I/O Registry. It can then use that information to customize its runtime environment.</p></li><li class="li"><p>A user-space process can access a driver’s property list and use it to send small amounts of data that the driver can use to customize its runtime environment.</p></li></ul><p>Although this chapter’s information on the libkern collection and container classes is applicable to all three situations, the code examples in <span class="content_text"><a href="Libkern_Classes.html#//apple_ref/doc/uid/TP30000696-CJACHIAJ">“Configuring Your Driver Using the libkern Classes”</a></span> focus on the first two uses. For more information on user space–driver communication using the property list (including a code sample), see <span class="content_text"><a href="../MakingHWAccessible/MakingHWAccessible.html#//apple_ref/doc/uid/TP30000698-BBCCJDEH">“Making Hardware Accessible to Applications.”</a></span></p><p>It is important to distinguish between manipulating the OSDictionary representation of your driver’s I/O Kit personality and manipulating the information property list (or <code>Info.plist</code> file) itself. Note that all property list manipulation this chapter discusses concerns the OSDictionary representation of your driver’s personality, <em>not</em> the XML personality defined in your driver’s bundle settings. You cannot modify your driver’s <code>Info.plist</code> file in any way during your driver’s life span. When you manipulate your driver’s personality during its <code><!--a-->start<!--/a--></code> or <code><!--a-->init<!--/a--></code> routines, you are only manipulating a kernel representation of the personality that exists in the IORegistryEntry parent class of your driver. Your driver (and other objects currently residing in the I/O Registry) can access this property list and even make changes to it, but those changes will be lost when your driver terminates and the I/O Kit removes the corresponding IORegistryEntry object from the I/O Registry<a name="//apple_ref/doc/uid/TP30000696-DontLinkElementID_141"></a>.<a name="//apple_ref/doc/uid/TP30000696-DontLinkElementID_142"></a><a name="//apple_ref/doc/uid/TP30000696-DontLinkElementID_143"></a></p><a name="//apple_ref/doc/uid/TP30000696-TPXREF101" title="libkern Collection and Container Class Overview"></a><h2>libkern Collection and Container Class Overview</h2><p>Although the libkern collection and container classes inherit from OSMetaClassBase, it’s more helpful to think of them as inheriting from OSObject. OSObject defines the dynamic typing and allocation features loadable kernel modules need and its virtual methods and overridden operators define how objects are created, retained, and disposed of in the kernel. For more information on the OSObject class, see <em><a href="../../IOKitFundamentals/index.html#//apple_ref/doc/uid/TP0000011" target="_top">I/O Kit Fundamentals</a></em>.</p><p>With the exception of Date (which is not used in the kernel because of overhead associated with routines needed to support date formats), the XML tags you use to specify data types in your driver’s <code>Info.plist</code> file have a direct, one-to-one relationship with the libkern container<a name="//apple_ref/doc/uid/TP30000696-DontLinkElementID_144"></a> and collection<a name="//apple_ref/doc/uid/TP30000696-DontLinkElementID_145"></a> classes of similar names. <span class="content_text"><a href="Libkern_Classes.html#//apple_ref/doc/uid/TP30000696-CJAHGGDI">Table 2-1</a></span> shows this relationship.</p><a name="//apple_ref/doc/uid/TP30000696-CJAHGGDI" title="Table 2-1XML tags and libkern class names"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 2-1&nbsp;&nbsp;</strong>XML tags and libkern class names</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>XML tag</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>libkern class</p></th></tr><tr><td  scope="row"><p>Array</p></td><td ><p>OSArray</p></td></tr><tr><td  scope="row"><p>Boolean</p></td><td ><p>OSBoolean</p></td></tr><tr><td  scope="row"><p>Data</p></td><td ><p>OSData</p></td></tr><tr><td  scope="row"><p>Date</p></td><td ><p>No libkern equivalent</p></td></tr><tr><td  scope="row"><p>Dictionary</p></td><td ><p>OSDictionary</p></td></tr><tr><td  scope="row"><p>Number</p></td><td ><p>OSNumber</p></td></tr><tr><td  scope="row"><p>String</p></td><td ><p>OSString</p></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000696-TPXREF102" title="libkern Container Classes"></a><h3>libkern Container Classes</h3><p><a name="//apple_ref/doc/uid/TP30000696-DontLinkElementID_146"></a>The libkern library defines container classes that hold primitive values or raw data, similar to C scalar types. <span class="content_text"><a href="Libkern_Classes.html#//apple_ref/doc/uid/TP30000696-BABDJHEA">Table 2-2</a></span> shows the libkern container classes along with the types of values they can hold.</p><a name="//apple_ref/doc/uid/TP30000696-BABDJHEA" title="Table 2-2The libkern container classes"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 2-2&nbsp;&nbsp;</strong>The libkern container classes</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Container class name</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Contents</p></th></tr><tr><td  scope="row"><p>OSBoolean</p></td><td ><p>Boolean values <code>true</code> and <code>false</code></p></td></tr><tr><td  scope="row"><p>OSData</p></td><td ><p>arrays of bytes</p></td></tr><tr><td  scope="row"><p>OSNumber</p></td><td ><p>numeric values</p></td></tr><tr><td  scope="row"><p>OSString</p></td><td ><p>arrays of characters</p></td></tr><tr><td  scope="row"><p>OSSymbol</p></td><td ><p>references to unique strings</p></td></tr></table></div><p>OSData, OSNumber, and OSString objects are mutable objects, however, you can make them unchangeable by declaring them to be <code>const</code>. This is useful if you know your code should never change a particular object: Declare the object to be <code>const</code> and the compiler will catch any attempts to modify it. </p><p>OSSymbol and OSBoolean are different from the other container classes. An OSSymbol object is an immutable object representing a unique string value that usually resides in the OSSymbol Pool. Although the creation of OSSymbols is not cheap, they provide great efficiency when you need to access the same strings many times. For example, if you examine the I/O Registry, you’ll see the same strings used over and over, such as “IOProviderClass” and “IOProbeScore”. In fact, all these strings are OSSymbol objects. Because kernel space is limited, it is efficient to keep a pool of commonly used strings for ready access rather than to waste space storing the same strings more than once. For more information on how to create and use OSSymbol objects, see <span class="content_text"><a href="Libkern_Classes.html#//apple_ref/doc/uid/TP30000696-CJADHFCJ">“Container Object Creation and Initialization”</a></span> and <span class="content_text"><a href="Libkern_Classes.html#//apple_ref/doc/uid/TP30000696-CJAHBEJG">“Container Object Introspection and Access.”</a></span></p><p>OSBoolean is a variation of OSSymbol. Because there are only two values associated with an OSBoolean object, <code>true</code> and <code>false</code>, there is no need to create multiple copies of the same values.</p><p>Each container class defines several methods to manage the data it holds. Common among them are methods to initialize an instance with a particular value, return the current value, and compare the current value with a passed-in value. <span class="content_text"><a href="Libkern_Classes.html#//apple_ref/doc/uid/TP30000696-CJAJFIJC">“Using the libkern Collection and Container Classes”</a></span> describes some of these methods in more detail.<a name="//apple_ref/doc/uid/TP30000696-DontLinkElementID_147"></a></p><a name="//apple_ref/doc/uid/TP30000696-TPXREF103" title="libkern Collection Classes"></a><h3>libkern Collection Classes</h3><p>The libkern collection classes<a name="//apple_ref/doc/uid/TP30000696-DontLinkElementID_148"></a> manage groups of OSObject-derived objects, including both container objects and other collection objects. Inheriting from the libkern class OSCollection, the collection classes make their contents accessible through a positional or associative key and provide iteration services that allow you to peruse their contents one member at a time. All collection class objects are mutable. <span class="content_text"><a href="Libkern_Classes.html#//apple_ref/doc/uid/TP30000696-BABCCHCA">Table 2-3</a></span> shows the libkern collection classes along with the types of objects they can hold.</p><a name="//apple_ref/doc/uid/TP30000696-BABCCHCA" title="Table 2-3The libkern collection classes"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 2-3&nbsp;&nbsp;</strong>The libkern collection classes</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Collection class name</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Contents</p></th></tr><tr><td  scope="row"><p>OSArray</p></td><td ><p>A list of references to OSObject-derived objects, each accessible by positional index</p></td></tr><tr><td  scope="row"><p>OSDictionary</p></td><td ><p>A list of OSObject-derived objects, each accessible by unique associative key</p></td></tr><tr><td  scope="row"><p>OSOrderedSet</p></td><td ><p>A sorted list of unique OSObject-derived objects, each accessible by numeric order or member function</p></td></tr><tr><td  scope="row"><p>OSSet</p></td><td ><p>An unsorted list of unique OSObject-derived objects, each accessible by member function</p></td></tr></table></div><p>Although you can use OSSet and OSOrderedSet in your driver (for statistics-gathering perhaps) you will probably be more interested in OSArray and OSDictionary because they are direct counterparts of the XML tags Array and Dictionary you use in your driver’s property list.</p><p>The libkern collection classes have in common methods that retrieve objects, check for the presence of objects, and create instances with predefined groups of objects. <span class="content_text"><a href="Libkern_Classes.html#//apple_ref/doc/uid/TP30000696-CJABJIGD">“Collection Object Creation and Initialization”</a></span> and <span class="content_text"><a href="Libkern_Classes.html#//apple_ref/doc/uid/TP30000696-CJABHJGA">“Collection Object Introspection and Access”</a></span> describe some of these methods in more detail.</p><p>Because they inherit from OSCollection, the libkern collection classes also provide access to their contents through an iterator. OSCollectionIterator defines a consistent mechanism that iterates over any given collection. When you instantiate an OSCollectionIterator for your particular collection object, you automatically have access to each collection member without having to be concerned about how the collection object organizes its contents.</p><a name="//apple_ref/doc/uid/TP30000696-CJAJFIJC" title="Using the libkern Collection and Container Classes"></a><h2>Using the libkern Collection and Container Classes</h2><p>The libkern collection and container classes implement a variety of methods that create, initialize, access, and examine instances. This section presents an overview of these methods, along with information on libkern class reference-counting and thread safety.</p><a name="//apple_ref/doc/uid/TP30000696-CJADHFCJ" title="Container Object Creation and Initialization"></a><h3>Container Object Creation and Initialization</h3><p><a name="//apple_ref/doc/uid/TP30000696-DontLinkElementID_149"></a>All container classes implement one or more static methods for creating instances. These method names follow the form <code>with</code><em>Arguments</em> where <em>Arguments</em> describes the initialization arguments. For example, OSData defines a static creation method <code><!--a-->withBytes<!--/a--></code> that creates an instance of OSData and initializes it with the provided buffer of data.</p><p>This example uses OSData’s <code><!--a-->withCapacity<!--/a--></code> creation method to create an empty OSData object initialized to a given size:</p><div class="codesample"><table><tr><td scope="row"><pre>OSData *tmpData;<span></span></pre></td></tr><tr><td scope="row"><pre>int size = 16; //Initial capacity of tmpData in bytes.<span></span></pre></td></tr><tr><td scope="row"><pre>tmpData = OSData::withCapacity( size );<span></span></pre></td></tr></table></div><p>Some of the static creation methods specify a “no copy” variant, such as OSData’s <code><!--a-->withBytesNoCopy<!--/a--></code> and OSString’s <code><!--a-->withCStringNoCopy<!--/a--></code>. These creation methods create an instance of the container object but do not actually copy the provided initialization data into it. Instead, the method gives the container object a reference to the provided data.</p><p>To see why this is useful, suppose your driver needs to use the string <code>device_type</code>. You instantiate an OSString object to contain the string with the creation method <code><!--a-->withCString<!--/a--></code>, as in the following</p><div class="codesample"><table><tr><td scope="row"><pre>OSString * myString;<span></span></pre></td></tr><tr><td scope="row"><pre>myString = OSString::withCString("device_type");<span></span></pre></td></tr></table></div><p>But because you define <code>device_type</code> as a literal string in your driver’s executable code, bytes are already wired down for it and creating an OSString object to contain it simply wastes kernel space. Therefore, if you need to reference data that you define in your driver’s executable code, such as the string <code>device_type</code>, and no one will need that data after your driver unloads, you should use the “no copy” creation methods. When you create libkern container objects with a “no copy” creation method, the resulting objects are immutable because they contain only a pointer to the data, not the data itself.</p><p>When you create an OSSymbol object, you pass a string (either an OSString object or a simple C-string) to one of OSSymbol’s static creation methods. If your string already exists in the OSSymbol Pool, you receive a reference to the original string. The OSSymbol representing that string then increments its retain count to keep track of the additional reference to the string. If your string does not already exist in the symbol pool, you receive a pointer to a fresh OSSymbol object and your string is added to the pool. </p><p>If your driver defines a string that will be needed by other IORegistryEntry objects after your driver terminates, you can create an OSSymbol for it using OSSymbol’s <code><!--a-->withCStringNoCopy<!--/a--></code> creation method. If your string does not already exist in the OSSymbol Pool, the <code><!--a-->withCStringNoCopy<!--/a--></code> method does not immediately add it. Instead, OSSymbol uses the string in your driver as its own, unique pool for as long as your driver stays loaded. During this time, if other IORegistryEntry objects create the same symbol, they receive a pointer to your string. When your driver is about to unload, OSSymbol then copies your string into the general OSSymbol Pool so it remains available to the other objects that have references to it.</p><p>The container classes OSData, OSString, and OSNumber also implement initialization methods that initialize existing instances of the container objects with the provided data. For example, OSString implements three initialization methods. The first two, <code><!--a-->initWithCString<!--/a--></code> and <code><!--a-->initWithString<!--/a--></code>, copy the provided C string or OSString object, respectively, into an instance of OSString. The third, <code><!--a-->initWithCStringNoCopy<!--/a--></code>, is a “no copy” variant that initializes an instance of OSString but does not copy the provided C string into it. Similarly, OSData implements several initialization methods that initialize an OSData object with a block of data, including the variant <code><!--a-->initWithBytesNoCopy<!--/a--></code> that initializes the OSData object but does not copy the bytes into it.</p><p>OSBoolean and OSSymbol do not implement <code><!--a-->init<!--/a--></code> methods. OSBoolean can only be one of two predefined values and OSSymbol is never instantiated without referring to a particular string value.<a name="//apple_ref/doc/uid/TP30000696-DontLinkElementID_150"></a></p><a name="//apple_ref/doc/uid/TP30000696-CJAHBEJG" title="Container Object Introspection and Access"></a><h3>Container Object Introspection and Access</h3><p>All container<a name="//apple_ref/doc/uid/TP30000696-DontLinkElementID_151"></a> objects implement various methods that provide access to the values they contain. For example, all container classes implement at least one <code><!--a-->isEqualTo<!--/a--></code> method that tests the equality of the container’s contents and the value of a provided object. Each <code><!--a-->isEqualTo<!--/a--></code> method handles one of the different types of data a container object can hold. OSString, for example, implements four <code><!--a-->isEqualTo<!--/a--></code> methods that test equality with simple C strings, other OSString objects, OSData objects, and unknown OSObject-derived objects.</p><p>OSSymbol implements three <code><!--a-->isEqualTo<!--/a--></code> methods, two that test equality with string or OSObject-derived objects and one that tests equality with other OSSymbol objects. Because two OSSymbol objects are equal only if they reference the same string in the OSSymbol pool, this <code><!--a-->isEqualTo<!--/a--></code> method merely performs an economical pointer comparison.</p><p>Most of the container classes implement <code><!--a-->get<!--/a--></code><a name="//apple_ref/doc/uid/TP30000696-DontLinkElementID_152"></a> methods that return both information about their contents and the contents itself. OSString, for example, implements <code><!--a-->getLength<!--/a--></code>, which returns the length of the string, and <code><!--a-->getChar<!--/a--></code>, which returns the character at the provided position in the string. It also implements <code><!--a-->getCStringNoCopy<!--/a--></code>, which returns a pointer to the internal string representation, rather than the string itself.</p><p>OSData implements several <code><!--a-->get<!--/a--></code> methods you can use to find out the size of the object’s internal data buffer and how much it will grow, and to get a pointer to the data buffer.</p><a name="//apple_ref/doc/uid/TP30000696-CJABJIGD" title="Collection Object Creation and Initialization"></a><h3>Collection Object Creation and Initialization</h3><p><a name="//apple_ref/doc/uid/TP30000696-DontLinkElementID_153"></a>As with the container classes, the libkern collection classes each implement a number of creation methods of the form <code>with</code><em>Arguments</em>. Each creation method uses the passed-in object described by <em>Arguments</em> to initialize a fresh object. OSArray, for example, implements three creation methods, <code><!--a-->withArray<!--/a--></code>, <code><!--a-->withCapacity<!--/a--></code>, and <code><!--a-->withObjects<!--/a--></code>. As its name suggests, the <code><!--a-->withArray<!--/a--></code> method creates a fresh OSArray object and populates it with the provided OSArray object. The <code><!--a-->withCapacity<!--/a--></code> method creates an OSArray object that can hold the given number of references and the <code><!--a-->withObjects<!--/a--></code> method creates an OSArray object and populates it with the members of a static array of OSObjects.</p><p>The OSDictionary <code><!--a-->withCapacity<!--/a--></code> and <code><!--a-->withDictionary<!--/a--></code> creation methods are similar to OSArray’s but its two <code><!--a-->withObjects<!--/a--></code> creation methods require a little more explanation. Because an OSDictionary object contains a collection of key-value pairs, you must supply both the keys and the values to populate a fresh OSDictionary object. The <code><!--a-->withObjects<!--/a--></code> creation methods each require two static arrays, one of OSObject values and one of either OSString or OSSymbol keys. Both methods then create a fresh OSDictionary object and populate it with key-value pairs consisting of a member of the key array and the member of the value array at the same index.</p><p>The initialization methods mirror the creation methods except that they operate on existing collection objects instead of creating new ones first.<a name="//apple_ref/doc/uid/TP30000696-DontLinkElementID_154"></a></p><a name="//apple_ref/doc/uid/TP30000696-CJABHJGA" title="Collection Object Introspection and Access"></a><h3>Collection Object Introspection and Access</h3><p>All collection<a name="//apple_ref/doc/uid/TP30000696-DontLinkElementID_155"></a> classes implement several methods that give you information about their contents and allow you to get references to particular members. In addition, the libkern library provides the OSCollectionIterator class which implements methods that allow you to iterate over any collection object and access its members. Because the collection classes inherit from OSCollection, an OSCollectionIterator object automatically knows how to iterate over all types of collection objects.</p><p>The collection classes each implement several <code><!--a-->get<!--/a--></code><a name="//apple_ref/doc/uid/TP30000696-DontLinkElementID_156"></a> methods that give you information about the collection itself or about specific objects within the collection. OSDictionary, for example, implements six <code><!--a-->get<!--/a--></code> methods, three of which get the value associated with a key of type OSString, OSSymbol, or <code>const char</code>. The other three return information about the dictionary itself, such as its storage capacity, the size of increment by which it grows, and the current number of objects it contains.</p><p>The collection classes implement methods to both set an object into and remove an object from a collection. Each collection class implements at least one <code><!--a-->set<!--/a--></code> method that inserts a passed-in object into a collection object. Additionally, each collection class implements a <code><!--a-->setCapacityIncrement<!--/a--></code> method that sets the increment size by which the collection will grow. Each collection class also implements at least one <code><!--a-->removeObject<!--/a--></code> method that removes the specified object and automatically releases it. In the case of OSArray, the contents shift to fill the vacated spot.</p><a name="//apple_ref/doc/uid/TP30000696-TPXREF104" title="Reference Counting for Collection and Container Classes"></a><h3>Reference Counting for Collection and Container Classes</h3><p>OSObject<a name="//apple_ref/doc/uid/TP30000696-DontLinkElementID_157"></a> provides the retain<a name="//apple_ref/doc/uid/TP30000696-DontLinkElementID_158"></a>-release mechanism the libkern container and collection objects use. A common source of problems in driver development is unmatched reference counting.</p><p>When you first create a libkern object, its reference count is equal to one. Therefore, if you created an object, you should also release it when you no longer need it. You do this by calling the <code>release</code><a name="//apple_ref/doc/uid/TP30000696-DontLinkElementID_159"></a><a name="//apple_ref/doc/uid/TP30000696-DontLinkElementID_160"></a>method and then setting the object’s pointer to <code>NULL</code> so you can’t accidentally refer to the released object again. If you have a pointer to an object that you did not create, you should retain that object only if you need to rely on its presence and release it when you no longer need it.</p><p>Some confusion arises with the use of the <code>get</code> and<a name="//apple_ref/doc/uid/TP30000696-DontLinkElementID_161"></a><code>set</code> methods common to all libkern collection classes. When you use a <code>get</code> method to get a member object from a collection, that member object’s reference count is <em>not</em> incremented. Unless you also retain the object, you should not release the object you receive from a <code>get</code> method. Although this isn’t a general feature of dictionaries, it is a feature of IORegistryEntry objects. </p><p>The collection classes also implement a range of <code>set</code><a name="//apple_ref/doc/uid/TP30000696-DontLinkElementID_162"></a> methods that allow you to place an object into a collection. The <code>set</code> methods do increment the new member object’s reference count. If, for example, you create an OSString object and then use <code>setObject</code> to set it into an OSDictionary object, the OSString object will have a reference count of 2, one from its creation and one from OSDictionary’s <code>setObject</code> method.</p><p><span class="content_text"><a href="Libkern_Classes.html#//apple_ref/doc/uid/TP30000696-CJAJFCDA">Table 2-4</a></span> summarizes the retain behavior of the collection classes’s methods.</p><a name="//apple_ref/doc/uid/TP30000696-CJAJFCDA" title="Table 2-4libkern methods and reference-counting behavior"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 2-4&nbsp;&nbsp;</strong>libkern methods and reference-counting behavior</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Method</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Retain behavior</p></th></tr><tr><td  scope="row"><p>get</p></td><td ><p>Never retains</p></td></tr><tr><td  scope="row"><p>set</p></td><td ><p>Always retains</p></td></tr><tr><td  scope="row"><p><code>remove</code></p></td><td ><p>Always releases</p></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000696-TPXREF105" title="Thread Safety and the Container and Collection Classes"></a><h3>Thread Safety and the Container and Collection Classes</h3><p>None of the libkern container and collection class methods are thread<a name="//apple_ref/doc/uid/TP30000696-DontLinkElementID_163"></a>-safe. If, for example, you use a <code>get</code> method to get an object from a dictionary and then you call <code>retain</code> on it, there is no guarantee that the object is still valid by the time you perform the <code>retain</code>. This is because the object you received is only valid as long as the collection containing it exists. If you do not also hold a reference to the collection, you cannot be sure that it won’t be released before you get a chance to retain the object in it.</p><p>In most cases, however, you will be modifying your own dictionaries and you can use your driver’s locking mechanism to protect them, if necessary. If you hold a reference to a collection whose member objects you are modifying, you can be reasonably sure that those objects will continue to exist as long as you don’t release the collection. Because the I/O Kit will not free any of your objects until your driver terminates (implements its <code>free</code> method), you are responsible for maintaining your collection objects and not releasing them prematurely.</p><a name="//apple_ref/doc/uid/TP30000696-TPXREF106" title="libkern Objects and XML"></a><h3>libkern Objects and XML</h3><p>All container and collection objects, with the exception of OSSymbol and OSOrderedSet, implement a <code>serialize</code> method<a name="//apple_ref/doc/uid/TP30000696-DontLinkElementID_164"></a>. You use a serialization<a name="//apple_ref/doc/uid/TP30000696-DontLinkElementID_165"></a> method when you want to represent an arbitrarily complex data structure in a location-independent way. Each time you call <code>serialize</code> on a libkern object, an OSSerialize<a name="//apple_ref/doc/uid/TP30000696-DontLinkElementID_166"></a> object is created that contains both the XML<a name="//apple_ref/doc/uid/TP30000696-DontLinkElementID_167"></a> (in an array of bytes) and the state of the serialization.</p><p>A good example of serialization is the output of the <code>ioreg</code> tool. The I/O Registry is a collection of interconnected dictionaries. When you type <code>ioreg</code> on the command line, the entire collection is serialized for output on your screen.</p><a name="//apple_ref/doc/uid/TP30000696-CJACHIAJ" title="Configuring Your Driver Using the libkern Classes"></a><h2>Configuring Your Driver Using the libkern Classes</h2><p><a name="//apple_ref/doc/uid/TP30000696-DontLinkElementID_168"></a>As described in <span class="content_text"><a href="Libkern_Classes.html#//apple_ref/doc/uid/TP30000696-CJABEIEE">“The libkern Classes and Your Driver,”</a></span> the best uses for the libkern classes are in your driver’s dynamic configuration phase, during routines such as <code><!--a-->init<!--/a--></code>, <code><!--a-->probe<!--/a--></code>, and <code><!--a-->start<!--/a--></code>. This section presents code samples that illustrate how you can use the libkern container and collection classes to configure your driver’s runtime environment.</p><a name="//apple_ref/doc/uid/TP30000696-TPXREF107" title="Configuring a Subclass of IOAudioDevice"></a><h3>Configuring a Subclass of IOAudioDevice</h3><p>The PhantomAudioDevice is an example subclass of IOAudioDevice (the PhantomAudioDriver project is available in <code>/Developer/Examples/Kernel/IOKit/Audio/PhantomAudioDriver</code> and on the CVSWeb at <span class="content_text"><a href="http://developer.apple.com/darwin/tools/cvs" target="_top">http://developer.apple.com/darwin/tools/cvs</a></span>). In its <code>createAudioEngines</code> method, PhantomAudioDevice uses libkern objects and methods to access its property list and create a new audio engine for each audio engine array in its personality. The <code>createAudioEngines</code> method is shown in <span class="content_text"><a href="Libkern_Classes.html#//apple_ref/doc/uid/TP30000696-BABEFHEH">Listing 2-1</a></span>.</p><a name="//apple_ref/doc/uid/TP30000696-BABEFHEH" title="Listing 2-1Using libkern objects and methods in audio-engine creation"></a><p class="codesample"><strong>Listing 2-1&nbsp;&nbsp;</strong>Using libkern objects and methods in audio-engine creation</p><div class="codesample"><table><tr><td scope="row"><pre>bool PhantomAudioDevice::createAudioEngine()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    bool result = false;<span></span></pre></td></tr><tr><td scope="row"><pre>    OSArray *audioEngineArray;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    audioEngineArray = OSDynamicCast(OSArray,<span></span></pre></td></tr><tr><td scope="row"><pre>                            getProperty(AUDIO_ENGINES_KEY));<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (audioEngineArray) {<span></span></pre></td></tr><tr><td scope="row"><pre>        OSCollectionIterator *audioEngineIterator;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        audioEngineIterator =<span></span></pre></td></tr><tr><td scope="row"><pre>                OSCollectionIterator::withCollection(audioEngineArray);<span></span></pre></td></tr><tr><td scope="row"><pre>        if (audioEngineIterator) {<span></span></pre></td></tr><tr><td scope="row"><pre>            OSDictionary *audioEngineDict;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            while (audioEngineDict = (OSDictionary*)<span></span></pre></td></tr><tr><td scope="row"><pre>                                audioEngineIterator->getNextObject()) {<span></span></pre></td></tr><tr><td scope="row"><pre>                if (OSDynamicCast(OSDictionary, audioEngineDict) != NULL) {<span></span></pre></td></tr><tr><td scope="row"><pre>                    PhantomAudioEngine *audioEngine;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                    audioEngine = new PhantomAudioEngine;<span></span></pre></td></tr><tr><td scope="row"><pre>                    if (audioEngine) {<span></span></pre></td></tr><tr><td scope="row"><pre>                        if (audioEngine->init(audioEngineDict)) {<span></span></pre></td></tr><tr><td scope="row"><pre>                            activateAudioEngine(audioEngine);<span></span></pre></td></tr><tr><td scope="row"><pre>                        }<span></span></pre></td></tr><tr><td scope="row"><pre>                        audioEngine->release();<span></span></pre></td></tr><tr><td scope="row"><pre>                    }<span></span></pre></td></tr><tr><td scope="row"><pre>                }<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            audioEngineIterator->release();<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    } else {<span></span></pre></td></tr><tr><td scope="row"><pre>        IOLog("PhantomAudioDevice[%p]::createAudioEngine() - Error:<span></span></pre></td></tr><tr><td scope="row"><pre>                        no AudioEngine array in personality.\n", this);<span></span></pre></td></tr><tr><td scope="row"><pre>        goto Done;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    result = true;<span></span></pre></td></tr><tr><td scope="row"><pre>Done:<span></span></pre></td></tr><tr><td scope="row"><pre>    return result;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000696-TPXREF108" title="Configuring a Subclass of IOUSBMassStorageClass"></a><h3>Configuring a Subclass of IOUSBMassStorageClass</h3><p>The IOUSBMassStorageClass driver matches on mass storage class–compliant interfaces of USB devices that declare their device class to be composite. Sometimes, however, USB devices that have mass storage class–compliant interfaces declare their device class to be vendor-specific instead of composite. The IOUSBMassStorageClass driver can still drive these interfaces, but because the device’s reported class type is vendor-specific, the IOUSBMassStorageClass driver won’t match on them. </p><p>The solution is to provide a KEXT that consists of only an <code>Info.plist</code> file containing a personality for the device. This personality acts as a sort of bridge between the interface and the IOUSBMassStorageClass driver: It matches on the interface and causes the I/O Kit to instantiate the IOUSBMassStorageClass driver. The IOUSBMassStorageClass driver then examines the personality for a special dictionary named “USB Mass Storage Characteristics” that contains interface subclass and protocol values. If the dictionary is present, the IOUSBMassStorageClass driver uses these values instead of the corresponding values reported by the device.</p><p><span class="content_text"><a href="Libkern_Classes.html#//apple_ref/doc/uid/TP30000696-BABCDGAJ">Listing 2-2</a></span> shows the portion of the IOUSBMassStorageClass <code>start</code> method that locates the USB Mass Storage Characteristics dictionary and gets its contents.<a name="//apple_ref/doc/uid/TP30000696-DontLinkElementID_169"></a></p><a name="//apple_ref/doc/uid/TP30000696-BABCDGAJ" title="Listing 2-2Partial listing of IOUSBMassStorageClass start method"></a><p class="codesample"><strong>Listing 2-2&nbsp;&nbsp;</strong>Partial listing of IOUSBMassStorageClass start method</p><div class="codesample"><table><tr><td scope="row"><pre>bool IOUSBMassStorageClass::start( IOService * provider )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // Code calling super::start, opening the interface,<span></span></pre></td></tr><tr><td scope="row"><pre>    // and initializing some member variables not shown here.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Make sure provider is an IOUSBInterface object.<span></span></pre></td></tr><tr><td scope="row"><pre>    SetInterfaceReference(OSDynamicCast(IOUSBInterface, provider));<span></span></pre></td></tr><tr><td scope="row"><pre>    if (GetInterfaceReference() == NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>        return false;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Check if the personality for this device specifies a preferred<span></span></pre></td></tr><tr><td scope="row"><pre>    // protocol.<span></span></pre></td></tr><tr><td scope="row"><pre>    if (getProperty(kIOUSBMassStorageCharacteristics) == NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        // This device does not specify a preferred protocol, use the<span></span></pre></td></tr><tr><td scope="row"><pre>        // protocol defined in the descriptor.<span></span></pre></td></tr><tr><td scope="row"><pre>        // fPreferredProtocol and fPreferredSubclass are private member<span></span></pre></td></tr><tr><td scope="row"><pre>        // variables of the IOUSBMassStorageClass class.<span></span></pre></td></tr><tr><td scope="row"><pre>        fPreferredProtocol =<span></span></pre></td></tr><tr><td scope="row"><pre>             GetInterfaceReference()->GetInterfaceProtocol();<span></span></pre></td></tr><tr><td scope="row"><pre>        fPreferredSubclass =<span></span></pre></td></tr><tr><td scope="row"><pre>             GetInterfaceReference()->GetInterfaceSubClass();<span></span></pre></td></tr><tr><td scope="row"><pre>    } else {<span></span></pre></td></tr><tr><td scope="row"><pre>        OSDictionary * characterDict;<span></span></pre></td></tr><tr><td scope="row"><pre>        characterDict = OSDynamicCast(OSDictionary,<span></span></pre></td></tr><tr><td scope="row"><pre>             getProperty(kIOUSBMassStorageCharacteristics));<span></span></pre></td></tr><tr><td scope="row"><pre>        // Check if the personality for this device specifies a preferred<span></span></pre></td></tr><tr><td scope="row"><pre>             protocol<span></span></pre></td></tr><tr><td scope="row"><pre>        if (characterDict->getObject(kIOUSBMassStoragePreferredProtocol)<span></span></pre></td></tr><tr><td scope="row"><pre>             == NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            // This device does not specify a preferred protocol, use the<span></span></pre></td></tr><tr><td scope="row"><pre>            // protocol defined in the descriptor.<span></span></pre></td></tr><tr><td scope="row"><pre>            fPreferredProtocol =<span></span></pre></td></tr><tr><td scope="row"><pre>                 GetInterfaceReference()->GetInterfaceProtocol();<span></span></pre></td></tr><tr><td scope="row"><pre>        } else {<span></span></pre></td></tr><tr><td scope="row"><pre>            OSNumber * preferredProtocol;<span></span></pre></td></tr><tr><td scope="row"><pre>            preferredProtocol = OSDynamicCast(OSNumber, characterDict-><span></span></pre></td></tr><tr><td scope="row"><pre>                getObject(kIOUSBMassStoragePreferredProtocol);<span></span></pre></td></tr><tr><td scope="row"><pre>            // This device has a preferred protocol, use that.<span></span></pre></td></tr><tr><td scope="row"><pre>            fPreferredProtocol = preferredProtocol->unsigned32BitValue();<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        // Check if the personality for this device specifies a preferred<span></span></pre></td></tr><tr><td scope="row"><pre>        // subclass.<span></span></pre></td></tr><tr><td scope="row"><pre>        if (characterDict->getObject(kIOUSBMassStoragePreferredSubclass)<span></span></pre></td></tr><tr><td scope="row"><pre>             == NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            // This device does not specify a preferred subclass, use the<span></span></pre></td></tr><tr><td scope="row"><pre>            // subclass defined in the descriptor.<span></span></pre></td></tr><tr><td scope="row"><pre>            fPreferredSubclass =<span></span></pre></td></tr><tr><td scope="row"><pre>                 GetInterfaceReference()->GetInterfaceSubClass();<span></span></pre></td></tr><tr><td scope="row"><pre>        } else {<span></span></pre></td></tr><tr><td scope="row"><pre>            OSNumber * preferredSubclass;<span></span></pre></td></tr><tr><td scope="row"><pre>            preferredSubclass = OSDynamicCast(OSNumber, characterDict-><span></span></pre></td></tr><tr><td scope="row"><pre>                getObject(kIOUSBMassStoragePreferredSubclass));<span></span></pre></td></tr><tr><td scope="row"><pre>            // This device has a preferred subclass, use that.<span></span></pre></td></tr><tr><td scope="row"><pre>            fPreferredSubclass = preferredSubclass->unsigned32BitValue();<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr></table></div>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../CPluPlusRuntime/CPlusPlusRuntime.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../IOService/IOService.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2002, 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-03-06<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeviceDrivers/Conceptual/WritingDeviceDriver/ContainerClasses/Libkern_Classes.html%3Fid%3DTP30000694-2.13&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeviceDrivers/Conceptual/WritingDeviceDriver/ContainerClasses/Libkern_Classes.html%3Fid%3DTP30000694-2.13&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeviceDrivers/Conceptual/WritingDeviceDriver/ContainerClasses/Libkern_Classes.html%3Fid%3DTP30000694-2.13&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>