<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Carbon Porting Guide (Legacy): Preparing Your Code for Carbon</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Preparing Your Code for Carbon"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	<meta name="ROBOTS" content="NOINDEX"/>
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30000991-CH202" title="Preparing Your Code for Carbon"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../LegacyTechnologies/index.html#//apple_ref/doc/uid/TP30000440-TP30000470" target="_top">Legacy Documents</a> &gt; <a href="../../../../LegacyTechnologies/Carbon-date.html#//apple_ref/doc/uid/TP30000440-TP30000470-TP30000494" target="_top">Carbon</a> &gt; <a href="../cpg_intro_struct/cpg_intro_struct.html#//apple_ref/doc/uid/TP30000991-CH201-TPXREF101">Carbon Porting Guide (Legacy)</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../cpg_intro_struct/cpg_intro_struct.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../cpg_buildstruct/cpg_build_struct.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        <script type="text/javascript" language="JavaScript">placeWatermark()</script>
<div id="legacyOuterWrapper"><div align="center" id="watermark">
<div class="legacybox">
<h1>Legacy Document<span class="closebutton"><a href="javascript:closeWatermark()"><img src="../../../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>
        <a name="//apple_ref/doc/uid/TP30000991-CH202-TPXREF101" title="Preparing Your Code for Carbon"></a><h1>Preparing Your Code for Carbon</h1><p>This chapter describes the modifications you need to make to your source code to create a Carbon application. These changes are divided into three categories:</p><ul class="ul"><li class="li"><p>Essential changes. Applications that follow these steps should run on Mac OS X, but may suffer from performance or responsiveness problems. </p></li><li class="li"><p>Other porting issues. These are topics that could affect the porting process depending on the capabilities and needs of your application. </p></li><li class="li"><p>Optimization steps. This section describes steps and issues to consider so your application can take best advantage of Mac OS X. Apple highly recommends that you address at least some of the topics described in this section. </p></li></ul><div class="notebox"><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_6" title="Note"></a><p><strong>Note:</strong>&nbsp;Carbon also provides new technologies that give additional functionality to your application. While entirely optional, these additions can improve performance, enhance the user experience, and even simplify future code development. See <span class="content_text"><a href="../cpg_newtechstruct/cpg_newtech_struct.html#//apple_ref/doc/uid/TP30000991-CH205-TPXREF101">“New Carbon Technologies”</a></span> for more information. </p></div><p>For more details about porting an application, see <span class="content_text"><a href="../cpg_portexampstruct/cpg_portexamp_struct.html#//apple_ref/doc/uid/TP30000991-CH204-TPXREF101">“A Porting Example”</a></span></p><p>Technote TN2003, “Moving Your Code to Mac OS X,” contains additional porting information that you may find useful:</p><p><span class="content_text"><a href="../../../../../technotes/tn/tn2003.html" target="_top">http://developer.apple.com/technotes/tn/tn2003.html</a></span></p><p>To make your job easier, begin by using the Carbon Dater tool to analyze the current compatibility level of your application.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="cpg_prep_struct.html#//apple_ref/doc/uid/TP30000991-CH202-TPXREF102">Using Carbon Dater</a>
				
			<br/>
			
        
			
			
				<a href="cpg_prep_struct.html#//apple_ref/doc/uid/TP30000991-CH202-BABDDJIA">Essential Steps for Porting Your Application</a>
				
			<br/>
			
        
			
			
				<a href="cpg_prep_struct.html#//apple_ref/doc/uid/TP30000991-CH202-BABCAFCH">Additional Porting Issues</a>
				
			<br/>
			
        
			
			
				<a href="cpg_prep_struct.html#//apple_ref/doc/uid/TP30000991-CH202-BABDAEDF">Optimizing Your Code for Carbon</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30000991-CH202-TPXREF102" title="Using Carbon Dater"></a><h2>Using Carbon Dater</h2><p><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_151"></a>Apple has developed a tool called Carbon Dater to analyze compiled applications and libraries for compatibility with Carbon. You can use Carbon Dater to obtain information about the compatibility of your existing code and the scope of your future conversion efforts.</p><p><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_152"></a>Carbon Dater works by examining PEF containers in application binaries and CFM libraries. It compares the list of Mac OS symbols your code imports against Apple’s database of Carbon-supported functions.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_7" title="Note"></a><p><strong>Note:</strong>&nbsp;Because Carbon Dater examines only PEF containers, it cannot examine 68K-based executable files. If you are porting an older 68K application, you must convert it to PowerPC before running the Carbon Dater tool. </p></div><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_8" title="Important:"></a><p><strong>Important:</strong>&nbsp;The Carbon Dater application is no longer available online and is no longer accepting reports.</p><p></p></div><a name="//apple_ref/doc/uid/TP30000991-CH202-TPXREF103" title="Analyzing Your Application"></a><h3>Analyzing Your Application</h3><p>Using Carbon Dater is a two-step process. You begin by dropping your compiled application or CFM library file onto the Carbon Dater tool. The tool examines the first PEF container in your file and outputs a text file named <em>filename</em><code>.CCT</code> (Carbon Compatibility Test). You can drop more than one file onto the Carbon Dater tool to get a combined report, but the tool examines only the first PEF container in each file.</p><p>The CCT file contains a list of all the Mac OS functions referenced by your code. If applicable, it may also include information about your application’s use of direct access to low memory addresses or about resources stored in the system heap.</p><p>The second step is to send your CCT file to Apple for analysis. The information gathered by the Carbon Dater tool is used to create a compatibility report for your application. Attach the CCT file as an email enclosure (preferably compressed) and send it to <code>CarbonDating@apple.com</code>.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_9" title="Important:"></a><p><strong>Important:</strong>&nbsp;Carbon Dater does not expose any proprietary information about your product. The CCT file only lists calls to Mac OS functions and certain other potential compatibility issues. You can examine the CCT file to verify its contents.</p><p></p></div><a name="//apple_ref/doc/uid/TP30000991-CH202-TPXREF104" title="Reading the Report"></a><h3>Reading the Report</h3><p>The CCT file you send to Apple will be processed by an automated analysis tool. The analyzer compares the list of Mac OS functions your code calls against Apple’s Carbon API database, and returns a report to you by email. This report is an HTML document that provides a snapshot of your application’s Carbon compatibility level.</p><a name="//apple_ref/doc/uid/TP30000991-CH202-TPXREF105" title="Analysis of Imports"></a><h4>Analysis of Imports</h4><p>For each Mac OS function your code calls that is not fully supported in Carbon, the compatibility report specifies whether the function is</p><ul class="spaceabove"><li class="li"><p>supported but modified in some way from how it is used in previous versions of the Mac OS</p></li><li class="li"><p>supported but not recommended—that is, you can use the function, but it may not be supported in the future</p></li><li class="li"><p>unsupported</p></li><li class="li"><p>not found in the latest version of Universal Interfaces </p></li></ul><p>The report includes a chart that shows the percentages of Mac OS functions in each category. For many functions, the report also describes how to modify your application. For example, text accompanying an unsupported function might describe a replacement function or recommended workaround.</p><a name="//apple_ref/doc/uid/TP30000991-CH202-TPXREF106" title="Analysis of Access to Low Memory Addresses"></a><h4>Analysis of Access to Low Memory Addresses</h4><p><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_153"></a>This section of the compatibility report lists instances where your code makes a direct access to low memory. For information on how to access low memory correctly, see <span class="content_text"><a href="cpg_prep_struct.html#//apple_ref/doc/uid/TP30000991-CH202-BABCHAII">“Remove Direct Access to Low-Memory Globals.”</a></span> If the tested code was built with symbolic debugging information enabled, the report specifies the names of the routines that access low memory directly. </p><p>Many of the low-memory accessor functions currently defined in the Universal Interfaces are implemented as inline macros that insert load or store instructions directly in your code. Carbon Dater can’t tell the difference between one of these macros and the code you wrote yourself, so you’ll need to verify that you’re using an approved accessor function.</p><a name="//apple_ref/doc/uid/TP30000991-CH202-TPXREF107" title="Analysis of Resources Loaded Into the System Heap"></a><h4>Analysis of Resources Loaded Into the System Heap</h4><p>This section of the compatibility report lists resources that have their system heap bit set, indicating they should be stored in the system heap. For each flagged resource, the report lists the resource type and ID, as well as the resource name if one is available. Applications do not have access to the system heap in Mac OS X, so Carbon applications cannot store resources there.</p><a name="//apple_ref/doc/uid/TP30000991-CH202-TPXREF108" title="Additional Reports"></a><h3>Additional Reports</h3><p>You can obtain additional compatibility reports as often as you wish. This is a good way to see how much progress you’ve made in your porting effort. Also, as work on Mac OS X and Carbon continues, there may be changes in the level of support for some functions, which Carbon Dater may bring to your attention.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_10" title="Important:"></a><p><strong>Important:</strong>&nbsp;The Carbon dating process cannot guarantee that your application is entirely compatible with Carbon and Mac OS X, even if your report lists no specific incompatibilities. For example, applications might access low memory in a way that is not supported but that cannot be detected by the compatibility analyzer.</p><p></p></div><a name="//apple_ref/doc/uid/TP30000991-CH202-BABCIIDG" title="The Carbon Specification"></a><h3>The Carbon Specification</h3><p><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_154"></a>To determine compatibility, Carbon Dater uses the Carbon Specification available at </p><p><span class="content_text"><a href="../../../../../documentation/carbon/" target="_top">http://developer.apple.com/documentation/carbon/</a></span></p><p>You can browse this document for general compatibility information. Apple updates the Carbon Specification regularly to reflect the latest state of the Carbon APIs. </p><a name="//apple_ref/doc/uid/TP30000991-CH202-BABDDJIA" title="Essential Steps for Porting Your Application"></a><h2>Essential Steps for Porting Your Application</h2><p>This section describes the bare minimum steps you must take to port your application to Carbon. Applications ported by following these instructions will run on Mac OS 8 and 9 and Mac OS X, but may not function optimally. To further improve performance and responsiveness, see the guidelines in <span class="content_text"><a href="cpg_prep_struct.html#//apple_ref/doc/uid/TP30000991-CH202-BABDAEDF">“Optimizing Your Code for Carbon.”</a></span></p><p>In addition to reading this section, you should also read the information provided in <span class="content_text"><a href="cpg_prep_struct.html#//apple_ref/doc/uid/TP30000991-CH202-BABCAFCH">“Additional Porting Issues”</a></span> before beginning to port your application. </p><a name="//apple_ref/doc/uid/TP30000991-CH202-TPXREF110" title="Make Sure All of Your Code Is PowerPC-Native"></a><h3>Make Sure All of Your Code Is PowerPC-Native</h3><p>Because Mac OS X requires 100% native PowerPC code, you will need to remove any dependencies on 68K instructions. This applies to custom definition procedures (defprocs) and plug-ins as well as your main application. See <span class="content_text"><a href="cpg_prep_struct.html#//apple_ref/doc/uid/TP30000991-CH202-BABBGIHA">“Move Custom Definition Procedures Out of Resources”</a></span> and <span class="content_text"><a href="../cpg_apdx_func/cpg_apdx_funcs.html#//apple_ref/doc/uid/TP30000991-CH206-BABCFEGG">“Custom Definition Procedures”</a></span> for information about new functions for creating native defprocs.</p><a name="//apple_ref/doc/uid/TP30000991-CH202-TPXREF109" title="Update to the Current Universal Interfaces"></a><h3>Update to the Current Universal Interfaces</h3><p><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_155"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_156"></a>Your transition to Carbon will be easier if your application already compiles using the latest version of Universal Interfaces (as of this writing, the most recent version is 3.4). Although updating is not a requirement, doing so will minimize the number of compatibility problems. Once your project compiles without errors, you should switch to the Carbon headers provided with the Carbon SDK.</p><p>You’ll find the most recent Universal Interfaces on Apple’s website at</p><p><span class="content_text"><a href="http://developer.apple.com/sdk/" target="_top">http://developer.apple.com/sdk/</a></span></p><a name="//apple_ref/doc/uid/TP30000991-CH202-BABBFHAE" title="Use the Carbon SDK"></a><h3>Use the Carbon SDK</h3><p><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_157"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_158"></a>The Carbon SDK contains the headers, stub libraries, extensions and other material that you will need to build your Carbon application. You can download it from the following website:</p><p><span class="content_text"><a href="http://developer.apple.com/carbon/index.html" target="_top">http://developer.apple.com/carbon/index.html</a></span></p><a name="//apple_ref/doc/uid/TP30000991-CH202-BABDFJEG" title="Target Mac OS 8 and 9 First"></a><h3>Target Mac OS 8 and 9 First</h3><p>To ease the transition to Carbon, you should initially focus on getting your application running on Mac OS 8 and 9 with the CarbonLib extension. Then you can test your application on Mac OS X. </p><p>Note that just because your Carbon application runs on Mac OS 8 and 9, there is no guarantee that it will correctly run on Mac OS X. For example, Mac OS X is stricter about direct casting of types, so what is allowable on Mac OS 8 and 9 may not work on Mac OS X.</p><a name="//apple_ref/doc/uid/TP30000991-CH202-TPXREF111" title="Begin With CarbonAccessors.o"></a><h3>Begin With CarbonAccessors.o</h3><p><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_159"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_160"></a><code>CarbonAccessors.o</code> is a static library that may help ease your transition to Carbon by allowing you to begin using certain Carbon features while continuing to link against <code>InterfaceLib</code> and other non-Carbon libraries.</p><p>Because many toolbox data structures are opaque in Carbon, one of the first steps you should take in porting your application is to begin using the new accessor functions. It’s easier to do this if you can continue compiling as a classic <code>InterfaceLib</code>-based application, because you can keep your application running and qualify your changes incrementally. <code>CarbonAccessors.o</code> facilitates this by providing implementations of the accessor functions for opaque toolbox data structures. For a list of the functions in <code>CarbonAccessors.o</code>, see <span class="content_text"><a href="../cpg_apdx_func/cpg_apdx_funcs.html#//apple_ref/doc/uid/TP30000991-CH206-TPXREF114">Table A-3</a></span>.</p><p><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_161"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_162"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_163"></a>We recommend that as the first step in the porting process, you add <code>CarbonAccessors.o</code> to your link, and then begin modifying your source code to use Carbon accessor functions, one file at a time. You can do this by setting the following conditional macro at the top of each source file you plan to convert:</p><div class="codesample"><table><tr><td scope="row"><pre>#define ACCESSOR_CALLS_ARE_FUNCTIONS 1<span></span></pre></td></tr></table></div><p>This conditional makes the prototypes for the accessor functions available to that source file.</p><p>When you have converted all of your source files to use accessor functions, you can add the following conditional macro to your build options to ensure that you are no longer directly accessing any opaque toolbox data structures:</p><div class="codesample"><table><tr><td scope="row"><pre>#define OPAQUE_TOOLBOX_STRUCTS 1<span></span></pre></td></tr></table></div><p>At this point you have an application that uses the Carbon accessor functions but does not link against the Carbon libraries. You can continue to run and test your application on any Mac OS release, because it does not require the <code>CarbonLib</code> extension at runtime. </p><p>The next step in the conversion process is to allow only Carbon-compatible APIs in your code by adding the following conditional macro to your build options:</p><div class="codesample"><table><tr><td scope="row"><pre>#define TARGET_API_MAC_CARBON 1<span></span></pre></td></tr></table></div><p>You can now begin modifying your code so that it no longer calls functions that are obsolete in Carbon. At this point you must stop linking against <code>InterfaceLib</code> (and <code>CarbonAccessors.o</code>) and begin linking against <code>CarbonLibStub</code> (that is, the <code>CarbonLib</code> shared library). </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_11" title="Note"></a><p><strong>Note:</strong>&nbsp;<a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_164"></a>You can also use <code>CarbonAccessors.o</code> to maintain some backwards compatibility with non-Carbon systems. For example, if you don’t require functions that are available only in CarbonLib, by linking against the <code>CarbonAccessors.o</code> static library you can build an application from a Carbon-compliant code base that runs on non-Carbon systems.</p></div><a name="//apple_ref/doc/uid/TP30000991-CH202-BABBBJEA" title="Use Casting Functions to Convert DialogPtrs and WindowPtrs"></a><h3>Use Casting Functions to Convert DialogPtrs and WindowPtrs</h3><p><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_165"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_166"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_167"></a>You cannot directly cast values of type <code>DialogPtr</code> or <code>WindowPtr</code> to a <code>GrafPtr</code>, but instead you must use the new functions described in <span class="content_text"><a href="../cpg_apdx_func/cpg_apdx_funcs.html#//apple_ref/doc/uid/TP30000991-CH206-BAAEBEHJ">“Casting Functions.”</a></span> Direct casting will not affect compilation, but it will cause crashes on Mac OS X. </p><a name="//apple_ref/doc/uid/TP30000991-CH202-BABEAGGI" title="Replace Macro Calls to the Mixed Mode Manager With UPP Accessor Functions"></a><h3>Replace Macro Calls to the Mixed Mode Manager With UPP Accessor Functions</h3><p><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_168"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_169"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_170"></a>Carbon introduces significant changes to the Mixed Mode Manager. Static routine descriptors are not supported, and you must use the system-supplied functions for creating, invoking, and disposing of universal procedure pointers. For example, Carbon provides the following functions to replace the macros previously used to create, invoke, and dispose of universal procedure pointers:</p><div class="codesample"><table><tr><td scope="row"><pre>ControlActionUPP NewControlActionUPP (ControlActionProcPtr userRoutine);<span></span></pre></td></tr><tr><td scope="row"><pre>void InvokeControlActionUPP (ControlRef theControl,<span></span></pre></td></tr><tr><td scope="row"><pre>                             ControlPartCode partCode<span></span></pre></td></tr><tr><td scope="row"><pre>                             ControlActionUPP userUPP);<span></span></pre></td></tr><tr><td scope="row"><pre>void DisposeControlActionUPP (ControlActionUPP userUPP);<span></span></pre></td></tr></table></div><p>Similar functions are provided for all supported UPPs. Note that Carbon does not support the generic functions <code>NewRoutineDescriptor</code>, <code>DisposeRoutineDescriptor</code>, and <code>CallUniversalProc</code>.</p><p>On Mac OS 8 and 9, the UPP creation functions allocate routine descriptors in memory just as you would expect. On Mac OS X, the implementation of UPPs depends on various factors, including the object file format you choose. Universal procedure pointers will allocate memory if your application is compiled as a CFM binary, but are likely to return a simple procedure pointer if your application is compiled as a Mach-O binary. </p><p>On Mac OS X, UPPs are opaque types that may or may not require memory allocation, depending on the particular function and the runtime they are created in. By using the system-supplied UPP functions, your application will operate correctly in either environment. You must dispose of your UPPs using the system-supplied functions to ensure that any allocated memory is released. See <span class="content_text"><a href="cpg_prep_struct.html#//apple_ref/doc/uid/TP30000991-CH202-BABBCDCB">“Consider Mach-O Executables”</a></span> for more information about the differences between these formats.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_12" title="Important:"></a><p><strong>Important:</strong>&nbsp;If you are using the Thread Manager, be aware that functions that did not require UPPs for designating callbacks (such as <code>SetThreadScheduler</code> and <code>SetThreadSwitcher</code>) now require them in Carbon. See the Thread Manager documentation or the header file <code>Threads.h</code> for a list of these functions and for information on the required UPP creation and disposal functions. </p><p></p></div><p>Your own plug-ins must be compiled as PowerPC code, so there is no need to create universal procedure pointers for them. Use normal procedure pointers instead.</p><a name="//apple_ref/doc/uid/TP30000991-CH202-BABBGIHA" title="Move Custom Definition Procedures Out of Resources"></a><h3>Move Custom Definition Procedures Out of Resources</h3><p>The resource-based format for custom definition functions (such as WDEFs, CDEFs, and so on) is defined to start with 68K instructions. Because Mac OS X does not support 68K code, you must move your custom definition functions out of resources and compile them directly in your application. </p><p>To access your custom code, you can do either of the following: </p><ul class="spaceabove"><li class="li"><p>Use new Carbon functions (<code>CreateCustomXXXX</code>) to create your objects. For example, to create a custom window, pass a universal procedure pointer (UPP) to your window definition function into the <code>CreateCustomWindow</code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus CreateCustomWindow (<span></span></pre></td></tr><tr><td scope="row"><pre>    const WindowDefSpec *def,<span></span></pre></td></tr><tr><td scope="row"><pre>    WindowClass windowClass,<span></span></pre></td></tr><tr><td scope="row"><pre>    WindowAttributes attributes,<span></span></pre></td></tr><tr><td scope="row"><pre>    const Rect *contentBounds,<span></span></pre></td></tr><tr><td scope="row"><pre>    WindowRef *outWindow<span></span></pre></td></tr><tr><td scope="row"><pre>);<span></span></pre></td></tr></table></div><p>You can specify your function pointer in the <code>WindowDefSpec</code> structure by taking the following steps:</p><div class="codesample"><table><tr><td scope="row"><pre>WindowDefSpec defSpec;<span></span></pre></td></tr><tr><td scope="row"><pre>defSpec.defType = kWindowDefProcPtr;<span></span></pre></td></tr><tr><td scope="row"><pre>defSpec.u.defProc = NewWindowDefUPP( MyWindowDefProc );<span></span></pre></td></tr></table></div></li><li class="li"><p>Map the old <code>procID</code> s to pointers to your custom code using the <code>RegisterXXXDefinition</code> functions. For example, if you still want to use <code>NewCWindow</code> to create your window, you should call <code>RegisterWindowDefinition</code>, passing it the resource ID referenced by your <code>procID</code>s and a UPP to your window definition function: </p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus RegisterWindowDefinition (<span></span></pre></td></tr><tr><td scope="row"><pre>    SInt16 inResID,<span></span></pre></td></tr><tr><td scope="row"><pre>    const WindowDefSpec *inDefSpec<span></span></pre></td></tr><tr><td scope="row"><pre>);<span></span></pre></td></tr></table></div><p>When <code>NewCWindow</code> receives a <code>procID</code> that isn’t one of the standard system <code>procID</code>s, it will look in the mapping table to find the function that’s registered for the resource ID embedded in the <code>procID</code>. </p><p>For more details about changes to custom definition procedures, see <span class="content_text"><a href="../cpg_apdx_func/cpg_apdx_funcs.html#//apple_ref/doc/uid/TP30000991-CH206-BABCFEGG">“Custom Definition Procedures.”</a></span></p></li></ul><a name="//apple_ref/doc/uid/TP30000991-CH202-BABCHAII" title="Remove Direct Access to Low-Memory Globals"></a><h3>Remove Direct Access to Low-Memory Globals</h3><p><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_171"></a>Low-memory globals are system and application global data located below the system heap in the Mac OS 8 and 9 runtime environment. They typically fall between the hexadecimal addresses $100 and $2800. Carbon applications can continue to use many of the existing low-memory globals, although in some cases the scope and impact of the global has changed. But in all cases, Carbon applications must use the supplied accessor routines to examine or change global variables. Attempting to access them directly with an absolute address will crash your application when running on Mac OS X.</p><p>The complete list of low-memory globals supported in Carbon is not yet finalized, but your transition to Carbon will be easier if you follow these guidelines:</p><ul class="spaceabove"><li class="li"><p>Use high-level calls instead of low-memory accessors whenever possible. For example, use <code>GetGlobalMouse</code> instead of <code>LMGetMouseLocation</code>.</p></li><li class="li"><p>If a high-level call is not available, use an accessor function.</p></li><li class="li"><p>Rely on global data only from Mac OS managers supported in Carbon. For example, because the driver-related calls in the Device Manager are not supported in Carbon, low-memory accessors like <code>LMGetUTableBase</code> are not likely to be available. Similarly, direct access to hardware is not supported in Carbon, so calls like <code>LMGetVIA</code> will no longer be useful.</p></li></ul><p>Table 2-1 lists some frequently used low-memory accessors that are unsupported in Carbon. Refer to the Carbon Specification for the most recent information.</p><a name="//apple_ref/doc/uid/TP30000991-CH202-TPXREF121" title="Table 1-1Summary of Carbon low memory accessor support "></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1-1&nbsp;&nbsp;</strong>Summary of Carbon low memory accessor support </caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Accessor</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Replacement</p></th></tr><tr><td  scope="row"><p><code>LMGet/SetAuxCtlHead</code></p></td><td ><p>not supported</p></td></tr><tr><td  scope="row"><p><code>LMGet/SetAuxWinHead</code></p></td><td ><p>not supported</p></td></tr><tr><td  scope="row"><p><code>LMGet/SetCurActivate</code></p></td><td ><p>not supported</p></td></tr><tr><td  scope="row"><p><code>LMGet/SetCurDeactive</code></p></td><td ><p>not supported</p></td></tr><tr><td  scope="row"><p><code>LMGet/SetDABeeper</code></p></td><td ><p>not supported</p></td></tr><tr><td  scope="row"><p><code>LMGet/SetDAStrings</code></p></td><td ><p><code>GetParamText, ParamText</code></p></td></tr><tr><td  scope="row"><p><code>LMGet/SetDeskPort</code></p></td><td ><p>not supported</p></td></tr><tr><td  scope="row"><p><code>LMGet/SetDlgFont</code></p></td><td ><p>not supported</p></td></tr><tr><td  scope="row"><p><code>LMGet/SetGhostWindow</code></p></td><td ><p>not supported</p></td></tr><tr><td  scope="row"><p><code>LMGetGrayRgn</code></p></td><td ><p><code>GetGrayRgn</code></p></td></tr><tr><td  scope="row"><p><code>LMGetMBarHeight</code></p></td><td ><p><code>GetMBarHeight</code></p></td></tr><tr><td  scope="row"><p><code>LMSetMBarHeight</code></p></td><td ><p>not supported</p></td></tr><tr><td  scope="row"><p><code>LMGet/SetMBarHook</code></p></td><td ><p>not supported</p></td></tr><tr><td  scope="row"><p><code>LMGet/SetMenuHook</code></p></td><td ><p>not supported</p></td></tr><tr><td  scope="row"><p><code>LMGetMouseLocation</code></p></td><td ><p><code>GetGlobalMouse</code></p></td></tr><tr><td  scope="row"><p><code>LMSetMouseLocation</code></p></td><td ><p>not supported</p></td></tr><tr><td  scope="row"><p><code>LMGet/SetPaintWhite</code></p></td><td ><p>not supported</p></td></tr><tr><td  scope="row"><p><code>LMGetWindowList</code></p></td><td ><p><code>GetWindowList</code></p></td></tr><tr><td  scope="row"><p><code>LMSetWindowList</code></p></td><td ><p>not supported</p></td></tr><tr><td  scope="row"><p><code>LMGet/SetWMgrPort</code></p></td><td ><p>not supported</p></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000991-CH202-BABECEFG" title="Use DebuggingCarbonLib"></a><h3>Use DebuggingCarbonLib</h3><p><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_172"></a>The debugging version of <code>CarbonLib</code> on Mac OS 8 and 9 checks for the validity of ports and windows, so using it is a good way to quickly identify potential problem areas. However, you should be aware that it runs considerably slower than the standard version of the library.</p><a name="//apple_ref/doc/uid/TP30000991-CH202-BABDJBJE" title="Modify or Conditionalize Your Headers"></a><h3>Modify or Conditionalize Your Headers</h3><p>If you plan to build your application on Mac OS X using Project Builder, be aware that the standard flat Mac OS 8 and 9 headers (such as <code>Dialogs.h</code> and <code>MacWindows.h</code>) do not correspond directly with Mac OS X frameworks. To address this issue, you can do either of the following: </p><ul class="spaceabove"><li class="li"><p><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_173"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_174"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_175"></a>Add <code>-I /Developer/Headers/FlatCarbon</code> to the cc compiler command line when building your application. The files in the FlatCarbon folder act as a compatibility layer, mapping the standard flat header includes to the proper frameworks. </p></li><li class="li"><p>Replace your flat headers with the single include statement <code>#include &lt;Carbon/Carbon.h></code>. This statement lets you access the Carbon framework directly. You should choose this method if you plan to build exclusively on Mac OS X, as it will improve compile times. </p></li></ul><p>If you choose not to include the path to FlatCarbon at build time, you can also conditionalize your code to use the proper headers :</p><div class="codesample"><table><tr><td scope="row"><pre>#if &lt;Some flag for building on X is set><span></span></pre></td></tr><tr><td scope="row"><pre>        #include &lt;Carbon/Carbon.h><span></span></pre></td></tr><tr><td scope="row"><pre>#else<span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;The usual Mac OS 8 and 9 includes><span></span></pre></td></tr><tr><td scope="row"><pre>#endif<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_13" title="Note"></a><p><strong>Note:</strong>&nbsp;<code>Carbon.h</code> is treated as a flat Mac OS 8 and 9 header, so the suggested workarounds will still apply.</p></div><a name="//apple_ref/doc/uid/TP30000991-CH202-BABDGIJD" title="Update Modified or Obsolete Functions"></a><h3>Update Modified or Obsolete Functions</h3><p>From the list given to you by Carbon Dater, you should replace all functions listed as “out” or “modified” with their suggested replacements. Depending on the function it may have been easier to remove them earlier in the process (such as removing A5 functions when purging all 68K-related code). </p><a name="//apple_ref/doc/uid/TP30000991-CH202-TPXREF112" title="Adopt Required Carbon Technologies"></a><h3>Adopt Required Carbon Technologies</h3><p>Carbon requires you to replace some older system services with newer ones as follows:</p><ul class="spaceabove"><li class="li"><p><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_176"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_177"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_178"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_179"></a>Navigation Services replaces the Standard File Package. For documentation, see the web site:</p><p><span class="content_text"><a href="../../../../../documentation/Carbon/Reference/Navigation_Services_Ref/" target="_top">http://developer.apple.com/documentation/Carbon/Reference/Navigation_Services_Ref/</a></span></p></li><li class="li"><p>The Carbon Printing Manager replaces the Classic Printing Manager. For documentation, see the web site:</p><p><span class="content_text"><a href="../../../../../documentation/carbon/Reference/CarbonPrintingManager_Ref/" target="_top">http://developer.apple.com/documentation/carbon/Reference/CarbonPrintingManager_Ref/</a></span></p></li></ul><a name="//apple_ref/doc/uid/TP30000991-CH202-TPXREF113" title="Add a &#39;plst&#39; 0 Resource"></a><h3>Add a 'plst' 0 Resource</h3><p><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_180"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_181"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_182"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_183"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_184"></a>On Mac OS X, Carbon applications that do not contain a <code>'plst' 0</code> resource will open in the Classic compatibility environment and will not gain all the advantages of Mac OS X. To ensure that Mac OS X properly recognizes your application, your application must include a resource of type <code>'plst'</code> with ID 0 or a plist file in a bundle. You can also store additional information about your application in a plist resource or file. See <span class="content_text"><a href="cpg_prep_struct.html#//apple_ref/doc/uid/TP30000991-CH202-BABBFHIH">“Consider Using Bundles”</a></span> for more information about plists and bundles. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_14" title="Note"></a><p><strong>Note:</strong>&nbsp;The <code>'plst' 0</code> resource supersedes the older <code>'carb' 0</code> resource. While you can continue to use the <code>'carb' 0</code> resource, the <code>'plst' 0</code> resource provides the exact same functionality while also allowing you to store additional information useful to the Mac OS X Finder. </p></div><p>Even if you include a <code>'plst' 0</code> resource, you can still launch the application in the Classic environment:</p><ul class="spaceabove"><li class="li"><p>If you include an empty <code>'plst' 0</code> resource, a “user choice” checkbox appears in the Finder’s Get Info window, allowing the user to choose whether to launch the application in Mac OS X or the Classic compatibility environment. The default is Mac OS X. (This checkbox feature does not appear if you include only a <code>'carb' 0</code> resource).</p></li><li class="li"><p>By specifying options in the <code>'plst' 0</code> resource, you can force the application to launch into either Mac OS X or the Classic environment. </p></li></ul><p>If your application does not contain a resource fork, it launches in Mac OS X by default.</p><p>See <em>Inside Mac OS X: System Overview</em> for more information about specifying Launch Services keys in your plist file or resource. </p><a name="//apple_ref/doc/uid/TP30000991-CH202-TPXREF114" title="Conditionalize Quit Menu Items"></a><h3>Conditionalize Quit Menu Items</h3><p><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_185"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_186"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_187"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_188"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_189"></a>Carbon applications running on Mac OS X automatically adopt the Aqua interface. Because Aqua provides a Quit menu item under the Application menu, your application does not need to add one to the File menu. As long as your application supports the Quit Apple event, it will quit normally. However, because the Mac OS 8 and 9 user interfaces still require a Quit menu item, you must conditionalize your code to add one in the File menu when running under Mac OS 8 or 9. The easiest way to identify the user interface is to check the <code>gestaltMenuMgrAquaLayoutBit</code> bit of the <code>gestaltMenuMgrAttr</code> gestalt selector. If the bit is set, the application is using the Aqua interface, and you should not add a Quit item to the File menu.</p><p>For example, you could use code such as the following to conditionalize your menus:</p><div class="codesample"><table><tr><td scope="row"><pre>Gestalt( gestaltMenuMgrAttr, &amp;result);<span></span></pre></td></tr><tr><td scope="row"><pre>if (result &amp; gestaltMenuMgrAquaLayoutMask)<span></span></pre></td></tr><tr><td scope="row"><pre>    menuBar = GetNewMBar(rSysXMenuBar);<span></span></pre></td></tr><tr><td scope="row"><pre>else<span></span></pre></td></tr><tr><td scope="row"><pre>    menuBar = GetNewMBar(rMenuBar);<span></span></pre></td></tr></table></div><p>This method uses two different <code>'MBAR'</code> resources, each with a different <code>'MENU'</code> resource for the File menu. </p><p>If you must enable and disable the Quit menu item programmatically, you can use the new functions <code>DisableMenuCommand</code> and <code>EnableMenuCommand</code> to do so. Pass <code>NULL</code> for the menu reference and <code>'quit'</code> for the command ID. </p><a name="//apple_ref/doc/uid/TP30000991-CH202-BABCAFCH" title="Additional Porting Issues"></a><h2>Additional Porting Issues</h2><p>In addition to the steps described in the <span class="content_text"><a href="cpg_prep_struct.html#//apple_ref/doc/uid/TP30000991-CH202-BABDDJIA">“Essential Steps for Porting Your Application,”</a></span> you should be aware of these other issues that can affect the porting process. </p><a name="//apple_ref/doc/uid/TP30000991-CH202-TPXREF115" title="Determine the Appropriate CarbonLib Version"></a><h3>Determine the Appropriate CarbonLib Version</h3><p><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_190"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_191"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_192"></a>Just like system software, <code>CarbonLib</code> also exists in various versions, each of which contains different levels of functionality. Because some calls to <code>CarbonLib</code> merely call through to the underlying system software, the functions available can depend on the system software version. </p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>CarbonLib version</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Reflects Universal Interfaces version</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Compatible  back to </p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Notes</p></th></tr><tr><td  scope="row"><p>1.0 </p></td><td ><p>3.3.1</p></td><td ><p>Mac OS 8.1</p></td><td ><p><em>Shipped with Mac OS 9. Do not develop with this version.</em></p></td></tr><tr><td  scope="row"><p></p></td><td ><p></p></td><td ><p></p></td><td ><p></p></td></tr><tr><td  scope="row"><p>1.0.4</p></td><td ><p>3.3.1</p></td><td ><p>Mac OS 8.1</p></td><td ><p><em>Includes the following</em>: </p></td></tr><tr><td  scope="row"><p></p></td><td ><p></p></td><td ><p></p></td><td ><p>All Carbon APIs available with Mac OS 8.1</p></td></tr><tr><td  scope="row"><p></p></td><td ><p></p></td><td ><p></p></td><td ><p>Toolbox accessor functions</p></td></tr><tr><td  scope="row"><p></p></td><td ><p></p></td><td ><p></p></td><td ><p>Control, Window, and Menu properties</p></td></tr><tr><td  scope="row"><p></p></td><td ><p></p></td><td ><p></p></td><td ><p>Appearance Manager 1.1</p></td></tr><tr><td  scope="row"><p></p></td><td ><p></p></td><td ><p></p></td><td ><p>Navigation Services</p></td></tr><tr><td  scope="row"><p></p></td><td ><p></p></td><td ><p></p></td><td ><p>Core Foundation</p></td></tr><tr><td  scope="row"><p></p></td><td ><p></p></td><td ><p></p></td><td ><p>Carbon Printing Manager</p></td></tr><tr><td  scope="row"><p></p></td><td ><p></p></td><td ><p></p></td><td ><p></p></td></tr><tr><td  scope="row"><p>1.2</p></td><td ><p>3.4</p></td><td ><p>Mac OS 8.6 </p></td><td ><p><em>Adds the following: </em></p></td></tr><tr><td  scope="row"><p></p></td><td ><p></p></td><td ><p></p></td><td ><p>DataBrowser</p></td></tr><tr><td  scope="row"><p></p></td><td ><p></p></td><td ><p></p></td><td ><p>Carbon Event Manager</p></td></tr><tr><td  scope="row"><p></p></td><td ><p></p></td><td ><p></p></td><td ><p>XML</p></td></tr><tr><td  scope="row"><p></p></td><td ><p></p></td><td ><p></p></td><td ><p>URL Access Manager</p></td></tr><tr><td  scope="row"><p></p></td><td ><p></p></td><td ><p></p></td><td ><p>Apple Type Services for Unicode Imaging (ATSUI)</p></td></tr><tr><td  scope="row"><p></p></td><td ><p></p></td><td ><p></p></td><td ><p>Interface Builder Services</p></td></tr><tr><td  scope="row"><p></p></td><td ><p></p></td><td ><p></p></td><td ><p>Font Sync</p></td></tr><tr><td  scope="row"><p></p></td><td ><p></p></td><td ><p></p></td><td ><p>Apple Help Viewer</p></td></tr><tr><td  scope="row"><p></p></td><td ><p></p></td><td ><p></p></td><td ><p>Font Management</p></td></tr><tr><td  scope="row"><p></p></td><td ><p></p></td><td ><p></p></td><td ><p></p></td></tr><tr><td  scope="row"><p></p></td><td ><p></p></td><td ><p>Mac OS 9</p></td><td ><p><em>Adds the following: </em></p></td></tr><tr><td  scope="row"><p></p></td><td ><p></p></td><td ><p></p></td><td ><p>Keychain Manager </p></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000991-CH202-TPXREF116" title="Draw Only Within Your Own Windows"></a><h3>Draw Only Within Your Own Windows</h3><p>Because Mac OS X is a truly preemptive system, any number of applications may be drawing into their windows at the same time. Carbon applications, therefore, cannot draw outside their own windows. In the past you could call the <code>GetWMgrPort</code> function and use that port to draw anywhere on the screen. This port does not exist in Mac OS X, so you will need to use alternate methods to implement window dragging and resizing. For more detailed information about handling windows in Carbon, see <span class="content_text"><a href="cpg_prep_struct.html#//apple_ref/doc/uid/TP30000991-CH202-BABCDCAD">“Window Manager Issues.”</a></span> </p><a name="//apple_ref/doc/uid/TP30000991-CH202-TPXREF117" title="Do Not Patch Traps"></a><h3>Do Not Patch Traps</h3><p><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_193"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_194"></a>Carbon applications should not patch traps because there is no trap table in Mac OS X. The Patch Manager is unsupported, and functions like <code>GetTrapAddress</code> and <code>SetTrapAddress</code> are not available in Carbon. You can, of course, conditionalize your code and continue to patch traps when running under Mac OS 9, but your programs will be much easier to maintain if you avoid patching entirely. </p><a name="//apple_ref/doc/uid/TP30000991-CH202-BABDGDJD" title="Don&acirc;&#128;&#153;t Pass Pointers Across Processes"></a><h3>Don’t Pass Pointers Across Processes</h3><p><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_195"></a>In Mac OS X, every process has its own address space, so attempting to pass a pointer to another process is meaningless at best and may cause your application to misbehave. Threads or tasks created by an application (for example, Multiprocessing Services tasks or Thread Manager threads) occupy the application’s address space, so you can pass pointers between them. </p><a name="//apple_ref/doc/uid/TP30000991-CH202-BABHFADA" title="Do Not Write to Your Application&acirc;&#128;&#153;s Resource Fork"></a><h3>Do Not Write to Your Application’s Resource Fork</h3><p>While writing to your application’s resource fork is acceptable (if not encouraged) in Mac OS 8 and 9, you should not do so in Mac OS X, as there are many common instances that will cause such write attempts to fail. Some examples:</p><ul class="spaceabove"><li class="li"><p>when file-system permissions don't allow itwhen the application resides on a network serverwhen the application resides on read-only media</p></li></ul><p>If you have application-specific data that you need to save, you should store them in a preferences file. </p><p>Ideally you should remove resource forks from your application altogether and place your resources in the data fork (see <span class="content_text"><a href="cpg_prep_struct.html#//apple_ref/doc/uid/TP30000991-CH202-BABCBBGJ">“Move Resources to Data Fork–Based Files.”</a></span> Note, however, that such resources are also read-only.</p><p>Note that you can still write to other resource forks (such as in document files). </p><a name="//apple_ref/doc/uid/TP30000991-CH202-BABDDGIE" title="Check Your OpenGL Code"></a><h3>Check Your OpenGL Code</h3><p><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_196"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_197"></a>If you use OpenGL in your application, you should continue to link to the OpenGLLibrary, OpenGLMemory, and OpenGLUtility stubs as you would for non-Carbon applications. On Mac OS X these functions will link with the OpenGL framework.</p><p>Note that if you are building a Mach-O–based Carbon application that uses the OpenGL header <code>aglMacro.h</code>, you must make the following call before creating any OpenGL contexts:</p><div class="codesample"><table><tr><td scope="row"><pre>aglConfigure(AGL_TARGET_OS_MAC_OSX,GL_TRUE);<span></span></pre></td></tr></table></div><p>Do not make this call from CFM-based Carbon applications. </p><p>See <span class="content_text"><a href="cpg_prep_struct.html#//apple_ref/doc/uid/TP30000991-CH202-BABBCDCB">“Consider Mach-O Executables”</a></span> for more information about the Mach-O format. </p><a name="//apple_ref/doc/uid/TP30000991-CH202-BABCEJAG" title="Examine Your Plug-ins"></a><h3>Examine Your Plug-ins</h3><p><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_198"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_199"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_200"></a>Carbon applications can load non-Carbon plug-ins. You must make sure, however, that your plug-ins do not link to <code>InterfaceLib</code>. On Mac OS 8 and 9 this will not cause a problem, but it can cause a crash on Mac OS X (because <code>InterfaceLib</code> is unavailable).</p><p>You can use the MPW tool DumpPEF with the <code>-loader i library</code> option to find unintentional links to non-Carbon libraries. </p><a name="//apple_ref/doc/uid/TP30000991-CH202-BABCCFCC" title="Linking to Non-Carbon-Compliant Code"></a><h3>Linking to Non-Carbon-Compliant Code</h3><p><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_201"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_202"></a>In some cases, your CFM application may need to call code that is not Carbon-compliant to maintain cross-platform compatibility between Mac OS 8 and 9 and Mac OS X. For example, say your application makes calls to the Device Manager. The Device Manager is not part of Carbon as it cannot run on Mac OS X. However, its replacement, I/O Kit, is a Mac OS X technology that cannot run on Mac OS 8 and 9. The only way to maintain your application’s functionality is to fork your code and make calls to either the Device Manager or I/O Kit, depending on the platform. </p><p>Forking your code in this manner brings up some build issues. For example, if you had set preprocessor directives to build with Carbon, the Universal Interfaces will conditionalize out any non-Carbon functions, and attempting to call non-Carbon functions will generate a compiler error indicating missing prototypes. </p><p>The easiest way to work around this problem is to compile your noncompliant code separately, using non-Carbon headers. You can package your non-Carbon code as a shared library, which you can then call from your application. </p><p>The safest method for calling non-Carbon functions in shared libraries is to prepare the fragment and locate the symbols manually. That is, call <code>GetSharedLibrary</code> to prepare the library and use <code>FindSymbol</code> to get the symbol address. You can then call the function through the returned pointer. This method gives you maximum flexibility in handling missing symbols or libraries. See the sample code included with the Mac OS X Developer Tools CD for examples.</p><a name="//apple_ref/doc/uid/TP30000991-CH202-BABCDCAD" title="Window Manager Issues"></a><h3>Window Manager Issues</h3><p>This section addresses common issues encountered when porting code that draws or otherwise manipulates windows. </p><a name="//apple_ref/doc/uid/TP30000991-CH202-BABBHJHG" title="Handling Buffered Windows"></a><h4>Handling Buffered Windows</h4><p><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_203"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_204"></a>In Mac OS X, all windows are buffered. A window’s contents are written first to a buffer and then the Window Manager periodically refreshes the screen with the contents of the buffers. As you don’t automatically have control over when a window’s contents are written to the screen, you may need to make some minor changes to your windowing code to account for buffering. </p><p>If you are writing periodically to the screen in a loop that doesn’t call <code>WaitNextEvent</code>, you must call <code>QDFlushPortBuffer</code> to flush your drawing to the screen. Otherwise, you are only updating the contents of the buffer.</p><p>If you draw directly into a window’s pixel map, QuickDraw cannot tell which parts of the pixel map are dirty. To work around this, you must do one of the following:</p><ul class="spaceabove"><li class="li"><p>Call <code>QDFlushPortBuffer</code> explicitly, passing a nonempty region parameter describing the modified area.</p></li><li class="li"><p>Call, <code>QDGetDirtyRegion</code> to get the port’s dirty region, add in the area you modified by calling <code>UnionRgn</code>, and then set the updated dirty region by calling <code>QDSetDirtyRegion</code>. The Window Manager will the update the region during the next call to <code>WaitNextEvent</code>. </p></li></ul><p>If you draw directly into the pixel map of your windows without using QuickDraw, you’ll need to wrap those blits with two new calls that signal the Window Manager not to update the window until your drawing operation completes. Here are the basic steps:</p><ol class="ol"><li class="li"><p>Use the <code>GetWindowPort</code> function to get the window’s port.</p></li><li class="li"><p>Use the <code>LockPortBits</code> function to lock the port’s pixel map. Note that this function is different from <code>LockPixels</code>; they are not interchangeable. </p></li><li class="li"><p>Use the <code>GetPortPixMap</code> function to get a handle to the port’s pixel map. The <code>baseAddr</code> field of the <code>PixMap</code> structure contains the base address of the actual port bits in memory. </p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_15" title="Important:"></a><p><strong>Important:</strong>&nbsp;The port address is valid only after you’ve locked the port using the <code>LockPortBits</code> function, and is invalid after you call the <code>UnlockPortBits</code> function.</p><p></p></div></li><li class="li"><p>Perform your drawing operation as quickly as possible. Because the <code>LockPortBits</code> function blocks all other updates to the port, it’s important that your drawing code be small and fast to avoid impacting system performance.</p></li><li class="li"><p>Call the <code>UnlockPortBits</code> function to release the port. The <code>PixMapHandle</code> is automatically disposed when you call this function. Do not attempt to reuse the handle.</p></li></ol><p>Note that the <code>UnlockPortBits</code> function does not initiate a window update, it merely allows any pending or future updates to occur. An update is initiated either by the <code>BeginUpdate/EndUpdate</code> routines or when the <code>QDFlushPortBuffer</code> function is called.</p><a name="//apple_ref/doc/uid/TP30000991-CH202-BABBJGDB" title="Bypassing the Window Manager Port"></a><h4>Bypassing the Window Manager Port</h4><p><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_205"></a>Prior to Carbon and Mac OS X, any Mac application could access the Window Manager port, which included all available screens. Using that port, an application could write directly to the screen on top of all windows. Developers used this capability to implement a number of features, such as custom window grow outlines and custom window dragging.</p><p>Because recent releases of Mac OS 8 and 9 offer improved Window Manager functionality, as well as robust drag-and-drop support through the Drag Manager, many applications no longer need to use the Window Manager port. This is a good thing, because in Mac OS X, there is no Window Manager port, and Carbon provides no access to the Window Manager port for applications running in Mac OS 8 and 9.</p><p>The Carbon Window Manager does supply alternate mechanisms to implement features that may have relied on use of the Window Manager port. To learn more about when to use these mechanisms, see <span class="content_text"><a href="cpg_prep_struct.html#//apple_ref/doc/uid/TP30000991-CH202-BABBDFEF">“Window Dragging and Resizing Q&amp;A.”</a></span></p><p>If your application is drawing in the Window Manager port and you don’t see an alternate mechanism described, you should consider whether you can achieve the same results by modifying your user interface. If that’s not appropriate, send an email to <code>carbon@apple.com</code> explaining what you need and some APIs may be added to support additional features.</p><a name="//apple_ref/doc/uid/TP30000991-CH202-BABBDFEF" title="Window Dragging and Resizing Q&amp;amp;A"></a><h4>Window Dragging and Resizing Q&amp;A</h4><p><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_206"></a>This section answers some frequently asked questions about dragging and resizing windows in Carbon and Mac OS X. For related information, see <span class="content_text"><a href="cpg_prep_struct.html#//apple_ref/doc/uid/TP30000991-CH202-BABBJGDB">“Bypassing the Window Manager Port.”</a></span></p><ul class="spaceabove"><li class="li"><p>Q. What is the standard window dragging feedback supplied by <code>DragWindow</code>?</p><p>A. In Mac OS X, if you call <code>DragWindow</code> for a buffered window, the Carbon Window Manager provides live dragging—that is, the contents of the window remain visible as a user moves the window around the screen. </p><p>For a Carbon application running in Mac OS 8 or 9, <code>DragWindow</code> supplies the traditional outline feedback.</p></li><li class="li"><p>Q. Can I still use <code>DragGrayRegion</code>?</p><p>A. Although <code>DragGrayRegion</code> is fully supported in Carbon, it only applies to the current port. If you’re currently using <code>DragGrayRegion</code> with the Window Manager port, you should instead use one of the other mechanisms described here, such as calling <code>DragWindow</code> or using Carbon event handlers.</p></li><li class="li"><p>Q. How do I implement custom window dragging—for example, to modify the position and shape of a tool palette as the user moves it to dock with another palette?</p><p><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_207"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_208"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_209"></a>A. You can implement features of this type using a Carbon event handler that tracks move events. When a user starts to drag a window, your handler receives a move window event (<code>kEventWindowOriginChange</code>). If you so request, your event handler can also receive periodic move window events as the user continues to drag the window. When the user completes the move, your handler receives a window moved event that includes the final position of the window. Your handler should get the <code>kEventParamCurrentBounds</code> parameter from the event, modify the <code>Rect</code> structure as needed, update the parameter, and then return <code>noErr</code>. In the example of docking a palette to another palette, you can either make changes to the palettes during the move as the current position warrants, or you can modify them after the move is complete.</p><p>Keep in mind that using a move event handler that receives and processes events during the move may have an impact on performance.</p><p>The Carbon Window Manager may also support custom dragging as part of an API to be added later. However, in Mac OS X this approach would only provide outline feedback for the drag, rather than live feedback.</p></li><li class="li"><p>Q. What is the standard window resizing feedback supplied by <code>GrowWindow</code>?</p><p>A. If you do not supply a resize event handler (described in another question), <code>GrowWindow</code> provides the traditional outline feedback.</p><p><span class="content_text"><a href="cpg_prep_struct.html#//apple_ref/doc/uid/TP30000991-CH202-BABDEAEJ">Figure 1-1</a></span> shows the traditional outline feedback for resizing a window.</p></li></ul><br/><div><a name="//apple_ref/doc/uid/TP30000991-CH202-BABDEAEJ" title="Figure 1-1Outline feedback as a user resizes a window"></a><p><strong>Figure 1-1&nbsp;&nbsp;</strong>Outline feedback as a user resizes a window</p><img src = "../Art/cpg03.gif" alt = "Outline feedback as a user resizes a window" width="639" height="545"></div><br/><ul class="spaceabove"><li class="li"><p>Q. How do I take advantage of live resizing in Mac OS X?</p><p>A. If you want live resizing in Mac OS X—that is, the contents of a window remain visible and are adjusted and redrawn as needed as a user resizes the window—you must set the <code>kWindowLiveResizeAttribute</code> attribute on the window (either at creation time using <code>CreateNewWindow</code> or <code>CreateCustomWindow</code>, or by called <code>ChangeWindowAttributes</code> on an existing window) and then provide a resize event handler. The Carbon Window Manager sends an event (<code>kEventWindowBoundsChanged</code>) to your handler that indicates when it should adjust its scrollbars, redraw its content, and so on, as the user resizes the window.</p><p>Carbon applications running in Mac OS 8 and 9 will only get outline resizing.</p></li><li class="li"><p>Q. <a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_210"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_211"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_212"></a>How do I implement custom window resize feedback—for example, to make the window snap to a grid as a user resizes the window?</p><p>A. You can implement custom resizing using the same Carbon event handler you use to support live resizing. When a user starts to resize a window, your handler receives a resize window event (<code>kEventWindowBoundsChanged</code>). Your handler also receives periodic events as the user continues the resize. When the user completes the resize, your handler receives a window resized event that includes the final size. You can modify the <code>kEventParamCurrentBounds</code> parameter to constrain resizing to the desired grid as the user resizes, or do so after the resize is complete.</p><p>If you are already using a custom window definition (WDEF) and you do not need live resizing, the easiest way to provide custom resize feedback is to support the new WDEF message <code>kWindowMsgGrowImageRegion</code>. Your WDEF receives this message periodically as the user moves the mouse during a resize operation. You can use this message to override the region that gets displayed during resize. To get these messages, your WDEF must report the <code>kWindowSupportsSetGrowImageRegion</code> feature bit.</p></li><li class="li"><p>Q. Do I need to make any other changes to my existing WDEF?</p><p>A. In most cases, you should not have to change your custom window definition. Prior to Carbon and Mac OS X, custom window definitions expected to draw directly in the global port. Now the Carbon Window Manager automatically sets up an appropriate port for drawing. When your window definition gets a draw message, it can go ahead and draw—but it shouldn’t assume it’s drawing in a global port, because it isn’t.</p></li><li class="li"><p>Q.<a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_213"></a> I use the Window Manager port to implement custom dragging with translucent drag images. How do I keep my translucent drag images without the Window Manager port?</p><p>A. The Drag Manager has supported translucent dragging since version 1.3 and System 7.5.3. This feature is fully supported in Carbon, so you don’t need to write any custom code.</p></li><li class="li"><p>Q. How can I capture a region of the current global screen?</p><p>A. There is currently no way to do this in Carbon, although we are considering providing an interface that will allow you to grab an arbitrary screen region.</p><p>You should not rely on calling <code>CreateNewPort</code> and determining the location of the screen bits from the new port. This behavior is no longer supported and code that relies on it is likely to break in future versions of Mac OS X.</p></li><li class="li"><p>Q. <a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_214"></a>How can I write a screen saver or other application that needs to take over the whole screen?</p><p>A. Use the QuickTime functions <code>BeginFullScreen</code> and <code>EndFullScreen</code>. For more information, see the QuickTime documentation at</p><p><span class="content_text"><a href="../../../../../documentation/QuickTime/index.html" target="_top">http://developer.apple.com/documentation/QuickTime/index.html</a></span></p></li><li class="li"><p>Q. I don’t want to modify my user interface and I don’t see anything described here that will help me do what I want to do.</p><p>A. Tell us what you need and why, so that we can help provide a solution.</p></li></ul><a name="//apple_ref/doc/uid/TP30000991-CH202-BABDAEDF" title="Optimizing Your Code for Carbon"></a><h2>Optimizing Your Code for Carbon</h2><p>This section describes steps and issues you should consider for your application to take best advantage of the Mac OS X environment. </p><a name="//apple_ref/doc/uid/TP30000991-CH202-TPXREF119" title="Manage Memory Efficiently"></a><h3>Manage Memory Efficiently</h3><p><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_215"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_216"></a>Memory management doesn’t change much for Carbon applications running on Mac OS 9. You’ll need all the code you use today to handle heap fragmentation, low memory situations, and stack depth.</p><p>However, there are some techniques you can adopt now that will help your application perform well when running on Mac OS X, which uses an entirely different heap structure and allocation behavior. The most significant change is in determining the amounts of free memory and stack space available. For example, you should avoid preallocating memory, as doing so will not make best use of the allocators available in Mac OS X. Similarly, using suballocators (allocating a block of memory and then allocating from within the block) is not suggested.</p><p>The functions <code>FreeMem</code>, <code>PurgeMem</code>, <code>MaxMem</code>, and <code>StackSpace</code> are all included in Carbon. You should, however, think about how and why you are using them. You’ll probably want to consider additional code to better tune your performance.</p><p>The <code>FreeMem</code>, <code>PurgeMem</code>, and <code>MaxMem</code> functions behave as expected when your Carbon application is running on Mac OS 9, but they’re almost meaningless when it’s running on Mac OS X, where the system provides essentially unlimited virtual memory. Although you can still use these calls to ensure that your memory allocations won’t fail, you shouldn’t use them to allocate all available memory. Allocating too much virtual memory will cause excessive page faults and reduce system performance. Instead, determine how much memory you really need for your data, and allocate that amount.</p><p>Before Carbon, you would use the <code>StackSpace</code> function to determine how much space was left before the stack collided with the heap. This routine could not be called at interrupt time, but was useful for preventing heap corruption in code using recursion or deep call chains. But because a Carbon application may have different stack sizes under Mac OS 9 and Mac OS X, the <code>StackSpace</code> function is no longer very useful. You shouldn’t rely on it for your logic to terminate a recursive function. It might still be useful as a safety check to prevent heap corruption, but for terminating runaway recursion, you should consider passing a counter or the address of a stack local variable instead of calling <code>StackSpace</code>.</p><p>The Carbon API does not include any subzone creation or manipulation routines. If you use subzones today to track system or plug-in memory allocations, you must use a different mechanism. For plug-ins, you might switch to using your own allocator routines. To prevent memory leaks, make sure all your allocations are matched with the appropriate dispose calls.</p><p>The Carbon API also removes the definition of zone headers. You can no longer modify the variables in a zone header to change the behavior of routines like <code>MoreMasters</code>. Simply call <code>MoreMasters</code> multiple times instead, which will allocate 128 master pointers each time. (You can also use the new Carbon call <code>MoreMasterPointers</code>, which allows you to specify the number of master pointers to allocate in one relocatable block.)</p><a name="//apple_ref/doc/uid/TP30000991-CH202-BABDGAHE" title="Avoid Polling and Busy Waiting"></a><h3>Avoid Polling and Busy Waiting</h3><p><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_217"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_218"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_219"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_220"></a>Polling for events or using a timer loop is allowable (but not recommended) on Mac OS 9, but it can cause severe performance problems on Mac OS X. In the Mac OS X multitasking environment, the OS gives time to all active processes. A process that is busy waiting for an event is considered active, even though it is not actually doing anything. Such waiting reduces the performance of other active processes. As an extreme example, multiple instances of a shared library, all polling for an event, can easily bog down the system. Instead of polling, your code should implement some sort of notification mechanism (such as an event queue or semaphore).</p><p>Note that triggering actions on null events (to blink the cursor, for example) does not work on Mac OS X, as the system will notify your application only when real events occur. To work around this issue you should use Carbon Event Manager timers. </p><a name="//apple_ref/doc/uid/TP30000991-CH202-BABDIGFE" title="Use &acirc;&#128;&#156;Lazy&acirc;&#128;&#157; Initialization for Shared Libraries"></a><h3>Use “Lazy” Initialization for Shared Libraries</h3><p><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_221"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_222"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_223"></a>To allow Mac OS X to manage memory efficiently, you should not prepare shared libraries at application launch time, but rather only when you need them. Also, try to avoid using initialization functions if possible. See <em>Mac OS Runtime Architectures</em> for more information about initialization functions. </p><a name="//apple_ref/doc/uid/TP30000991-CH202-BABCCHJI" title="Adopt HFS Plus APIs"></a><h3>Adopt HFS Plus APIs</h3><p><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_224"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_225"></a>HFS Plus, the Mac OS Extended File Format, is the default file system for Mac OS X, so you should consider using HFS Plus APIs if you need to programmatically access files on hard drives. Some of the advantages of HFS Plus are as follows:</p><ul class="spaceabove"><li class="li"><p>support for long Unicode filenames (255 characters)</p></li><li class="li"><p>support for files larger than 2 GB</p></li><li class="li"><p>support for extended file attributes</p></li></ul><p>See the File Manager documentation at</p><p><span class="content_text"><a href="../../../../../documentation/carbon/Reference/File_Manager" target="_top">http://developer.apple.com/documentation/carbon/Reference/File_Manager</a></span></p><p>for more information about HFS Plus. </p><a name="//apple_ref/doc/uid/TP30000991-CH202-BABBCDCB" title="Consider Mach-O Executables"></a><h3>Consider Mach-O Executables</h3><p><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_226"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_227"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_228"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_229"></a>You can build Carbon applications in two object file formats: PEF, which uses the Code Fragment Manager introduced with PowerPC Macintosh computers, and Mach-O, which is the preferred format for Mac OS X. Depending on your needs, you may want to consider creating Mach-O-based Carbon applications. There are advantages and disadvantages. </p><p>Advantages:</p><ul class="spaceabove"><li class="li"><p>Applications get access to all native Mac OS X APIs such as Quartz and POSIX. CFM-based Carbon applications can access only Carbon APIs. </p></li><li class="li"><p>Symbolic debugging is easier on Mac OS X (using GDB). </p></li><li class="li"><p>You can take full advantage of the Interface Builder and Project Builder development tools on Mac OS X.</p></li></ul><p>Disadvantages:</p><ul class="spaceabove"><li class="li"><p>Applications cannot run on Mac OS 8 and 9.</p></li><li class="li"><p>Mach-O doesn’t support the existing CFM plug-in architecture. </p></li><li class="li"><p>Programmatic manipulation of the Code Fragment Manager (for example, calling <code>GetSharedLibrary</code>) may not work as expected. </p></li></ul><p>You can also package CFM-based code and Mach-O–based executables together in bundles (as described in <span class="content_text"><a href="cpg_prep_struct.html#//apple_ref/doc/uid/TP30000991-CH202-BABBFHIH">“Consider Using Bundles”</a></span>). Bundling creates file packages analogous to PowerPC/68K fat applications built during the transition to PowerPC. Such CFM/Mach-O packages will execute the CFM version of the application on Mac OS 8 and 9, and the Mach-O version on Mac OS X. See <em>Inside Mac OS X: System Overview</em> for more information about the Mach-O format. </p><p>Eventually, as customer focus shifts to Mac OS X, you should concentrate on building Mach-O binaries. </p><a name="//apple_ref/doc/uid/TP30000991-CH202-BABCBBGJ" title="Move Resources to Data Fork&acirc;&#128;&#147;Based Files"></a><h3>Move Resources to Data Fork–Based Files</h3><p><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_230"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_231"></a>While Mac OS X can handle application resources stored in the resource fork of an executable file, in general you should begin storing these resources in the data fork. The major reason for doing this is to maximize compatibilty when moving files between different file systems. Many computing environments and file copying tools recognize only single-fork files; copying uncompressed files usually results in the loss of any information stored in the resource fork. </p><p>The only exceptions at this time are the <code>'cfrg' 0</code> and <code>'plst' 0</code> (or <code>'carb' 0</code> ) resources, which must remain in the resource fork for CFM-based applications so the Mac OS X Finder can launch them properly.</p><p>In general you should use the Core Foundation CFBundle APIs to package and access resources in the data fork. While you can simply move your existing resource files to the data fork, a better solution is to save each resource as an individual data fork–based file. Doing so makes it much easier to access (and perhaps modify) any individual resource.</p><p>See <span class="content_text"><a href="cpg_prep_struct.html#//apple_ref/doc/uid/TP30000991-CH202-BABBFHIH">“Consider Using Bundles”</a></span> and <em>Inside Mac OS X: System Overview</em> for more information about bundling resources. </p><a name="//apple_ref/doc/uid/TP30000991-CH202-BABBFHIH" title="Consider Using Bundles"></a><h3>Consider Using Bundles</h3><p><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_232"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_233"></a>A bundle is a Mac OS X concept that lets you store all the software resources and executable files that an application requires in one package. Essentially a directory or folder hierarchy, a bundle could contain any of the following:</p><ul class="spaceabove"><li class="li"><p>images, sounds, or other files used by the application</p></li><li class="li"><p>localized character strings</p></li><li class="li"><p>multiple executable versions of an application. </p></li></ul><p>A bundle can contain multiple sets of resources, grouped by language, locale, and platform. By combining all these resources and executables in one package, you can create one version of your application that is localized for multiple languages and can run on multiple platforms. </p><p>On Mac OS X, a bundle hierarchy normally appears as a single file, unless the bundle bit is unset, in which case it appears as a folder hierarchy. </p><p>On Mac OS 8 and 9, a bundle appears as a folder hierarchy, because the system software does not have knowledge of bundles. For this reason you should generally place an alias to your application prominently in the top level folder where the user can find it. </p><p>For maximum compatibility, you should use the Core Foundation CFBundle APIs to access bundled resources and executable files. See the Core Foundation Bundle Services documentation at</p><p><span class="content_text"><a href="../../../../../documentation/MacOSX/Conceptual/BPBundles/index.html" target="_top">http://developer.apple.com/documentation/MacOSX/Conceptual/BPBundles/index.html</a></span></p><p><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_234"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_235"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_236"></a><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_237"></a>Note that if you do not wish to adopt bundles at this time, you can include some of the information stored in a bundle’s <code>Info.plist</code> file in a resource of type <code>'plst'</code> with ID 0. Doing so allows you to specify attributes that provide information to the Finder (for example, what icons to use, what document types the application recognizes). You can also access data in the <code>'plst'</code> resource using Resource Manager or CFBundle APIs. </p><p>See <em>Inside Mac OS X: System Overview</em> for more specific information about packaging files in bundles.</p><a name="//apple_ref/doc/uid/TP30000991-CH202-BABCHHHG" title="Begin Transitioning to the Aqua Interface"></a><h3>Begin Transitioning to the Aqua Interface</h3><p><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_238"></a>By linking with CarbonLib, your Carbon application will automatically register itself with the Appearance Manager and adopt the basic Aqua look and feel. You should make sure that your interface elements are Appearance Manager–compliant; generally this means using system-defined controls, menus, and windows as much as possible.</p><p>To provide the best user experience, however, you should take the additional time to  modify dialog boxes, windows, icons, controls, and so on, to conform with the Aqua specification. Doing so ensures that your application will look its best on Mac OS X. For details, see the document <em>Aqua Human Interface Guidelines</em> available at </p><p><span class="content_text"><a href="../../../../../documentation/macosx/" target="_top">http://developer.apple.com/documentation/macosx/</a></span></p><p>For additional information on icons, see <span class="content_text"><a href="cpg_prep_struct.html#//apple_ref/doc/uid/TP30000991-CH202-BABCAHBH">“Provide Thumbnail Icons for Your Application.”</a></span> </p><p>You should also consider adding some new interface elements introduced with Aqua, such as the following:</p><ul class="spaceabove"><li class="li"><p>Sheets: Sheets are the new window-centric modal dialogs that slide down from the title bar. Sheet functions appear in <code>MacWindows.h</code>.</p></li><li class="li"><p>Help Tags: A help tag is a little yellow text field that appears over a control when you roll the cursor on top of it. The tag typically describes or clarifies the control’s purpose. Help tags replace the Help balloons available on older Mac OS systems. Help tag functions appear in <code>MacHelp.h</code>.</p></li></ul><a name="//apple_ref/doc/uid/TP30000991-CH202-BABDHGFC" title="Adopt a Terse Name for the Application Menu"></a><h3>Adopt a Terse Name for the Application Menu</h3><p><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_239"></a>The leftmost pull-down menu in Mac OS X is the application menu. To maximize space for other menus, you should adopt a short version of your application name (16 characters or less) for this menu. You should add this information in your application’s <a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_240"></a><code>InfoPlist.strings</code> file. </p><a name="//apple_ref/doc/uid/TP30000991-CH202-BABCAHBH" title="Provide Thumbnail Icons for Your Application"></a><h3>Provide Thumbnail Icons for Your Application</h3><p><a name="//apple_ref/doc/uid/TP30000991-CH202-DontLinkElementID_241"></a>The information in this section supplements the document “Obtaining and Using Icons With Icon Services,” available at the Carbon documentation website at </p><p><span class="content_text"><a href="../../../../../documentation/carbon/" target="_top">http://developer.apple.com/documentation/carbon/</a></span></p><p>In Mac OS X, a user may choose to display very large icons for the desktop, the application Dock, and so on. The Finder uses a high-quality scaling algorithm, supplied by Icon Services, to generate the variable-sized icons it needs. To help ensure a pleasing result for your application, you should provide a thumbnail icon and a thumbnail mask as part of the <code>'icns'</code> resource for your icon family. <span class="content_text"><a href="cpg_prep_struct.html#//apple_ref/doc/uid/TP30000991-CH202-BABCHBFF">Figure 1-2</a></span> shows the icon family, including thumbnail icons, for <code>Classic.app</code> in Mac OS X.</p><br/><div><a name="//apple_ref/doc/uid/TP30000991-CH202-BABCHBFF" title="Figure 1-2Thumbnail icons in a .icns file, displayed in Icon Browser"></a><p><strong>Figure 1-2&nbsp;&nbsp;</strong>Thumbnail icons in a <code>.icns</code> file, displayed in Icon Browser</p><img src = "../Art/cpg04.gif" alt = "Thumbnail icons in a .icns file, displayed in Icon Browser" width="743" height="491"></div><br/><p>A thumbnail icon is 128x128 pixels with 32-bit depth. A thumbnail mask is 128x128 pixels with 8-bit depth (there is no one-bit mask for a thumbnail). Within an icon family resource, you specify thumbnail elements with the following constants:</p><div class="codesample"><table><tr><td scope="row"><pre>enum {<span></span></pre></td></tr><tr><td scope="row"><pre>    kThumbnail32BitData = 'it32',<span></span></pre></td></tr><tr><td scope="row"><pre>    kThumbnail8BitMask  = 't8mk'<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><p>You can use these icon types only for an icon element within an <code>'icns'</code> icon family, not for an individual icon or icon mask resource.</p><p>Your application can continue to provide small (16x16) and large (32x32) icons as a complement to its thumbnail icons, especially if you need to preserve certain fine details at smaller resolutions. Icon Services will pick the best available icon for a particular size, so providing additional icons gives it more flexibility and gives you more control.</p><p>As of this writing, some third-party resource editor applications support editing of thumbnail icons, so you can investigate to determine which one best meets your needs. </p><p>If you want to add a thumbnail icon or mask to an icon family yourself, you can do so with the Icon Services function <code>SetIconFamilyData</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>pascal OSErr SetIconFamilyData (<span></span></pre></td></tr><tr><td scope="row"><pre>                        IconFamilyHandle iconFamily,<span></span></pre></td></tr><tr><td scope="row"><pre>                        OSType iconType,<span></span></pre></td></tr><tr><td scope="row"><pre>                        Handle h)<span></span></pre></td></tr></table></div><dl class="termdef">	<dt><code>iconFamily</code></dt><dd><p>A handle to an <code>iconFamily</code> data structure to be used as the target.</p></dd><dt><code>iconType</code></dt><dd><p>A value of type <code>OSType</code> specifying the format of the icon data you provide. For a thumbnail icon, for example, you specify <code>kThumbnail32BitData</code> in this parameter. For a thumbnail mask, you specify <code>kThumbnail8BitMask</code>.</p></dd><dt><code>h</code></dt><dd><p>A handle to the icon data you provide. For a thumbnail icon, the handle contains raw image data in the form of 128x128, four bytes per pixel, RGB data. For a thumbnail mask, the data is in the same format except that it is one byte per pixel.</p></dd></dl><p>When you are finished constructing the icon family, you can write it to a file with the <code>WriteIconFile</code> function. For more information on these functions, see the document “Obtaining and Using Icons With Icon Services.”</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../cpg_intro_struct/cpg_intro_struct.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../cpg_buildstruct/cpg_build_struct.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2002 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2002-12-01<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Carbon/Conceptual/carbon_porting_guide/cpg_prepstruct/cpg_prep_struct.html%3Fid%3DTP30000991-2.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Carbon/Conceptual/carbon_porting_guide/cpg_prepstruct/cpg_prep_struct.html%3Fid%3DTP30000991-2.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Carbon/Conceptual/carbon_porting_guide/cpg_prepstruct/cpg_prep_struct.html%3Fid%3DTP30000991-2.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>