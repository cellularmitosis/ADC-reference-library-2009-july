<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>SndPlayDoubleBuffer - /_source/DoubleBufferFromFile.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">SndPlayDoubleBuffer</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/index.html" target="_blank">Reference Library</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">SndPlayDoubleBuffer</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/_source/DoubleBufferFromFile.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/_headers/DBFF.h</option>
<option value="listing2.html">/_headers/DBFF_Errors.h</option>
<option value="listing3.html">/_headers/Defines.h</option>
<option value="listing4.html">/_headers/DoubleBufferFromFile.h</option>
<option value="listing5.html">/_headers/Interrupt_Routines.h</option>
<option value="listing6.html">/_headers/LDandFix.h</option>
<option value="listing7.html">/_headers/MungeBuffer.h</option>
<option value="listing8.html">/_headers/MyAIFF.h</option>
<option value="listing9.html">/_headers/MyGestalt.h</option>
<option value="listing10.html">/_headers/Private_DBFFFunctions.h</option>
<option value="listing11.html">/_headers/ReadResource.h</option>
<option value="listing12.html">/_headers/SetupDBHeader.h</option>
<option value="listing13.html">/_headers/SimpleApp_Sound.h</option>
<option value="listing14.html">/_headers/SND.h</option>
<option value="listing15.html">/_headers/SoundStruct.h</option>
<option value="listing16.html">/_headers/ULAW.h</option>
<option value="listing17.html">/_headers/WAVE.h</option>
<option value="listing18.html">/_source/AIFF.c</option>
<option value="listing19.html">/_source/DoubleBufferFromFile.c</option>
<option value="listing20.html">/_source/Interrupt_Routines.c</option>
<option value="listing21.html">/_source/LDandFix.c</option>
<option value="listing22.html">/_source/MungeBuffer.c</option>
<option value="listing23.html">/_source/MyGestalt.c</option>
<option value="listing24.html">/_source/Private_DBFFFunctions.c</option>
<option value="listing25.html">/_source/ReadResource.c</option>
<option value="listing26.html">/_source/SetupDBHeader.c</option>
<option value="listing27.html">/_source/SimpleApp_Sound.c</option>
<option value="listing28.html">/_source/SND.c</option>
<option value="listing29.html">/_source/ULAW.c</option>
<option value="listing30.html">/_source/WAVE.c</option>
<option value="listing31.html">/SAL Æ’/SAL_Public.h</option></select>
				</p>
				</form>
				<p><strong><a href="SndPlayDoubleBuffer.zip">Download Sample</a></strong> (&#147;SndPlayDoubleBuffer.zip&#148;, 185.7K)<BR>
<strong><a href="SndPlayDoubleBuffer.dmg">Download Sample</a></strong> (&#147;SndPlayDoubleBuffer.dmg&#148;, 253.5K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    DoubleBufferFromFile.c  Contains:  Routines demonstrating how to play a sound from disk using SndPlayDoubleBuffer.  Written by: Mark Cookson    Copyright:  Copyright &copy; 1996-1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        8/31/1999  Karl Groethe  Updated for Metrowerks Codewarror Pro 2.1        */#include &quot;MyAIFF.h&quot;#include &quot;DoubleBufferFromFile.h&quot;/*  Purpose:    This creates a new SoundInfo structure and initializes          it by calling the private function ASoundInit.  Side Effects:  None.*//*-----------------------------------------------------------------------*/SoundInfoPtr  ASoundNew        (OSErr *theErr)/*-----------------------------------------------------------------------*/{  SoundInfoPtr  theSoundInfo  = nil;  *theErr = noErr;  theSoundInfo = (SoundInfoPtr)NewPtrClear (sizeof (SoundInfo));  if (MemError () != noErr || theSoundInfo == nil) {    *theErr = kInitErr;  }  else {    *theErr = ASoundInit (theSoundInfo);  }  if (*theErr != noErr) {    DebugPrint (&quot;\pError in ASoundNew&quot;);  }  return theSoundInfo;}/*  Purpose:    Display a StandardFile dialog to select a file.          Opens the file selected by the user.  Side Effects:  None.*//*-----------------------------------------------------------------------*/OSErr      ASoundGetFileToPlay    (SoundInfoPtr theSoundInfo)/*-----------------------------------------------------------------------*/{  FileFilterUPP    myFilterUPP  = nil;  OSErr        theErr    = noErr;  short        i      = 0;  Boolean        good    = false;  if (IsValid (theSoundInfo)) {    myFilterUPP = NewFileFilterProc (ASoundFileFilter);    if ((theSoundInfo-&gt;globals.ggestaltStandardFileAttr &amp; gestaltStandardFile58) == false) {      StandardFileReply  theSFReply;      short        showTypes;      if ((theSoundInfo-&gt;globals.ggestaltTranslationAttr &amp; (1 &lt;&lt; gestaltTranslationMgrExists)) == true) {        showTypes = kUseOpenResourceTypes;      }      else {        showTypes = kNoFirstFiltering;      }      StandardGetFile (myFilterUPP, showTypes, nil, &amp;theSFReply);      theSoundInfo-&gt;vRefNum = theSFReply.sfFile.vRefNum;      if (theSFReply.sfGood == true) {        switch (theSFReply.sfType) {          case kSNDResource:          case kResource:            theErr = FSpOpenRF (&amp;theSFReply.sfFile, fsCurPerm, &amp;(theSoundInfo-&gt;refNum));            break;          case kCompressedAIFFFile:          case kUncompressedAIFFFile:          case kWAVEFile:          case kWAVFile:          case kAUFile:            theErr = FSpOpenDF (&amp;theSFReply.sfFile, fsCurPerm, &amp;(theSoundInfo-&gt;refNum));            break;          default:            DebugPrint (&quot;\pASoundGetFileToPlay should have never executed this line&quot;);        }        if (theErr != noErr) {          DebugPrint (&quot;\pCouldn't open file&quot;);        }        else {          theSoundInfo-&gt;fileType = theSFReply.sfType;          for (i = 0; i &lt;= theSFReply.sfFile.name[0]+1; i++)            theSoundInfo-&gt;theName[i] = theSFReply.sfFile.name[i];        }      }      else {        theErr = userCanceledErr;      }    }    else {      SFReply      theSFReply;      Point      where    = {kInit, kInit};      Rect      screenRect  = GetMainScreenRect();      long      dirID    = kInit,              procID    = kInit;      where.h = screenRect.right / kHorizAdjust;  /* This will put the SFGetFile dialog in the same place */      where.v = screenRect.bottom / kVertAdjust;  /* as the StandardGetFile dialog (or really close). */      if ((GetMBarHeight() + kOne) &gt; where.h) {        where.h = GetMBarHeight() + kOne;      }      SFGetFile (where, nil, myFilterUPP, kNoFirstFiltering, nil, nil, &amp;theSFReply);      good = theSFReply.good;      if (theSFReply.good == true) {        theErr = GetWDInfo (theSFReply.vRefNum, &amp;(theSoundInfo-&gt;vRefNum), &amp;dirID, &amp;procID);        if (theErr == noErr) {          switch (theSFReply.fType) {            case kSNDResource:            case kResource:              theErr = HOpenRF (theSoundInfo-&gt;vRefNum, dirID, theSFReply.fName, fsCurPerm, &amp;(theSoundInfo-&gt;refNum));              break;            case kCompressedAIFFFile:            case kUncompressedAIFFFile:            case kWAVEFile:            case kWAVFile:            case kAUFile:              theErr = HOpenDF (theSoundInfo-&gt;vRefNum, dirID, theSFReply.fName, fsCurPerm, &amp;(theSoundInfo-&gt;refNum));              break;            default:              DebugPrint (&quot;\pASoundGetFileToPlay should have never executed this line&quot;);          }          if (theErr != noErr) {            DebugPrint (&quot;\pCouldn't open file&quot;);          }          else {            theSoundInfo-&gt;fileType = theSFReply.fType;            for (i = 0; i &lt;= theSFReply.fName[0]+1; i++)              theSoundInfo-&gt;theName[i] = theSFReply.fName[i];          }        }        else {          theErr = kFileErr;          DebugPrint (&quot;\pCouldn't translate working directory&quot;);        }      }      else {        theErr = userCanceledErr;      }    }    DisposeRoutineDescriptor (myFilterUPP);  }  else {    theErr = kNilPtrErr;  }  if (theErr != noErr &amp;&amp; theErr != userCanceledErr) {    DebugPrint (&quot;\pError in ASoundGetFileToPlay&quot;);  }  return theErr;}/*  Purpose:    Checks a file to see if its header can be parsed          and the file can be played.          This will return an error if the sound will not play,          returning noErr means that sound will play.          Parsing a header can take some time, this routine          is a canidate for speed improvements.  Side Effects:  None.*//*-----------------------------------------------------------------------*/OSErr      ASoundCanThisPlay    (CInfoPBPtr theFileInfo)/*-----------------------------------------------------------------------*/{  SoundInfoPtr  theSoundInfo  = nil;  long      dataStart    = kInit,          sndLength    = kInit;  OSErr      theErr      = noErr,          closeErr    = noErr;  if (theFileInfo  != nil) {    theSoundInfo = ASoundNew (&amp;theErr);    if (theErr == noErr) {      theSoundInfo-&gt;vRefNum = theFileInfo-&gt;hFileInfo.ioVRefNum;      theSoundInfo-&gt;fileType = theFileInfo-&gt;hFileInfo.ioFlFndrInfo.fdType;      theErr = HOpenDF (theFileInfo-&gt;hFileInfo.ioVRefNum, theFileInfo-&gt;hFileInfo.ioFlParID, theFileInfo-&gt;hFileInfo.ioNamePtr, fsRdPerm, &amp;theSoundInfo-&gt;refNum);      if (theErr == noErr) {        switch (theSoundInfo-&gt;fileType) {          case kCompressedAIFFFile:          case kUncompressedAIFFFile:            theErr = ASoundGetAIFFHeader (theSoundInfo, &amp;dataStart, &amp;sndLength);            break;          case kWAVEFile:          case kWAVFile:            theErr = ASoundGetWAVEHeader (theSoundInfo, &amp;dataStart, &amp;sndLength);            break;          case kAUFile:            theErr = ASoundGetULAWHeader (theSoundInfo, &amp;dataStart, &amp;sndLength);            break;          case kSNDResource:          case kResource:            theErr = noErr;            break;          default:            /* The file type is not one that we can even parse. */            theErr = kUnknownFormat;            break;        }      }    }  }  else {    theErr = kNilPtrErr;  }  closeErr = FSClose (theSoundInfo-&gt;refNum);  DisposeRoutineDescriptor (ASoundGetSoundCallBack (theSoundInfo));  DisposePtr ((Ptr)theSoundInfo);  if (closeErr != noErr) {    theErr = closeErr;  }  if (theErr != noErr &amp;&amp; theErr != kUnknownFormat) {    DebugPrint (&quot;\pError in ASoundCanThisPlay&quot;);  }  return theErr;}/*  Purpose:    This function is called to get ready to play a sound.          Use this if you want to make sure that there is enough          memory to play the sound.  Side Effects:  This will call routines that will allocate memory needed          to all of the various structures needed by the Sound Manager          and memory to be used as the sounds' buffers.*//*-----------------------------------------------------------------------*/OSErr      ASoundReadyForPlaying  (SoundInfoPtr theSoundInfo,                    unsigned long bufferSize)/*-----------------------------------------------------------------------*/{  OSErr        theErr    = noErr;  if (IsValid (theSoundInfo)) {    if (theSoundInfo-&gt;globals.gSupportsSPDB == false) {      DebugPrint (&quot;\pThis machine doesn't support SoundPlayDoubleBuffer, can't play!&quot;);      theErr = kNoSPDBErr;    }    else {      /* do we want to start at the begining of the file? */      if ((ASoundGetBytesCopied (theSoundInfo) &lt;= kMaxAIFFHeaderSize) &amp;&amp; theSoundInfo-&gt;paused == false) {        theSoundInfo-&gt;soundDone = false;        theErr = SndNewChannel (&amp;(theSoundInfo-&gt;chan), sampledSynth, nil, ASoundGetSoundCallBack (theSoundInfo));        if (theErr != noErr) {          DebugPrint (&quot;\pSndNewChannel error!&quot;);        }        else {          theErr = SetUpSoundHeader (theSoundInfo, bufferSize);          if (theErr == noErr) {            theErr = ASoundPrimeBuffers (theSoundInfo);            ASoundSetCurBuffer (theSoundInfo, kStart);          }        }      }      else {        theErr = ASoundPrimeBuffers (theSoundInfo);      }    }  }  else {    theErr = kNilPtrErr;  }  if (theErr != noErr) {    DebugPrint (&quot;\pError in ASoundReadyForPlaying!&quot;);    (void)ASoundDonePlaying (theSoundInfo, kCloseFile + kFreeMem);  }  return theErr;}/*  Purpose:    Call this after you have called ASoundReadyForPlaying to          start playing the sound you prepaired.  Side Effects:  Starts the sound playing.*//*-----------------------------------------------------------------------*/OSErr      ASoundPlay        (SoundInfoPtr theSoundInfo)/*-----------------------------------------------------------------------*/{  OSErr        theErr    = noErr;  if (IsValid (theSoundInfo)) {    if (theSoundInfo-&gt;playing == false || theSoundInfo-&gt;paused == true) {      if (theSoundInfo-&gt;globals.gSupportsSPDB == false) {        theErr = kNoSPDBErr;        DebugPrint (&quot;\pThis machine doesn't support SoundPlayDoubleBuffer, can't play!&quot;);      }      else {        if (theSoundInfo-&gt;paused == false) {          theErr = SndPlayDoubleBuffer (theSoundInfo-&gt;chan, (SndDoubleBufferHeaderPtr)&amp;(theSoundInfo-&gt;doubleHeader));          if (theErr == noErr) {            theErr = InstallCallBack (theSoundInfo);          }          if (theErr == noErr) {            theSoundInfo-&gt;playing = true;          }        }      }    }  }  else {    theErr = kNilPtrErr;  }  if (theErr != noErr) {    DebugPrint (&quot;\pError in ASoundPlay!&quot;);    (void)ASoundDonePlaying (theSoundInfo, kCloseFile + kFreeMem);  }  return theErr;}/*  Purpose:    Wrapper function called to start playing a sound.          Use this if you are pretty sure the sound will play, or          just don't care specifically what goes wrong.  Side Effects:  This will call routines that will allocate memory needed          for all of the various structures needed by the Sound Manager          and memory to be used as the sounds' buffers.*//*-----------------------------------------------------------------------*/OSErr      ASoundStartPlaying    (SoundInfoPtr theSoundInfo,                    unsigned long bufferSize)/*-----------------------------------------------------------------------*/{  OSErr        theErr    = noErr;  theErr = ASoundReadyForPlaying (theSoundInfo, bufferSize);  if (theErr == noErr) {    theErr = ASoundPlay (theSoundInfo);  }  if (theErr != noErr) {    DebugPrint (&quot;\pError in ASoundStartPlaying!&quot;);    (void)ASoundDonePlaying (theSoundInfo, kCloseFile + kFreeMem);  }  return theErr;}/*  Purpose:    Stops the currently playing sound.  Side Effects:  Stopping the currently playing sound will cause the          sound completion routine to run.*//*-----------------------------------------------------------------------*/OSErr      ASoundStop        (SoundInfoPtr theSoundInfo)/*-----------------------------------------------------------------------*/{  SndCommand    theCmd    = {quietCmd, kInit, kInit};  OSErr      theErr    = noErr;  if (StrictIsValid (theSoundInfo)) {    /* So that ASoundDoubleBackProc knows that it doesn't have to       actually read any data */    theSoundInfo-&gt;stopping = true;    theErr = SndDoImmediate (theSoundInfo-&gt;chan, &amp;theCmd);    if (theErr == noErr) {      theSoundInfo-&gt;playing = false;      theSoundInfo-&gt;paused = false;    }  }  else {    theErr = kNilPtrErr;  }  if (theErr != noErr) {    DebugPrint (&quot;\pError in ASoundStop&quot;);  }  return theErr;}/*  Purpose:    Wrapper so the user doesn't have to keep track of if          the sound is playing or not.  Side Effects:  If resuming a sound and the user had also called          ASoundPauseForAdjust this will reinstall the sound          completion callback.*//*-----------------------------------------------------------------------*/OSErr      ASoundPause        (SoundInfoPtr theSoundInfo)/*-----------------------------------------------------------------------*/{  OSErr      theErr    = noErr;  if (StrictIsValid (theSoundInfo)) {    if (theSoundInfo-&gt;paused == false) {      theErr = PauseSound (theSoundInfo);    }    else {      theErr = ResumeSound (theSoundInfo);    }  }  else {    theErr = kNilPtrErr;  }  if (theErr != noErr) {    DebugPrint (&quot;\pError in ASoundPause&quot;);  }  return theErr;}/*  Purpose:    If the sound is paused, resume playing.  If the sound is          playing, pause playing.          This differs from ASoundPause because it actually stops          the sound instead of pausing it.  When the sound is          paused for adjusting you can reset where the sound will          next start playing from without having to play the          remainder of the current buffer.  This routine is used          for the QuickTime style playing.  Side Effects:  Removes the callback from the sound channel because          otherwise while adjusting the sound the Sound Manager          would call our clean up routine.          When resuming a sound ASoundStartPlaying will install          our callback routine if necessary (if the sound wasn't          already paused).*//*-----------------------------------------------------------------------*/OSErr      ASoundPauseForAdjust  (SoundInfoPtr theSoundInfo)/*-----------------------------------------------------------------------*/{  SndCommand    theCmd      = {kInit, kInit, kInit};  OSErr      theErr      = noErr;  static Fixed  oldRate      = kInit;  if (StrictIsValid (theSoundInfo)) {    if (theSoundInfo-&gt;adjusting == false) {      theCmd.cmd = flushCmd;      /* so the sound completion callback doesn't get called */      theErr = SndDoImmediate (theSoundInfo-&gt;chan, &amp;theCmd);      if (theErr == noErr) {        theSoundInfo-&gt;adjusting = true;        theCmd.cmd = quietCmd;        theErr = SndDoImmediate (theSoundInfo-&gt;chan, &amp;theCmd);        if (theErr == noErr) {          theSoundInfo-&gt;hasBeenAdjusted = true;          theSoundInfo-&gt;playing = false;        }      }    }    else {      theSoundInfo-&gt;adjusting = false;      ASoundStartPlaying (theSoundInfo, nil);    }  }  else {    theErr = kNilPtrErr;  }  if (theErr != noErr) {    DebugPrint (&quot;\pError in ASoundPauseForAdjust&quot;);  }  return theErr;}/*  Purpose:    Sound is done playing, dispose of the memory we no          longer need.  Side Effects:  None.*//*-----------------------------------------------------------------------*/OSErr      ASoundDonePlaying    (SoundInfoPtr theSoundInfo,                    unsigned long options)/*-----------------------------------------------------------------------*/{  myParamBlockRec  *myPB      = nil;  OSErr      theErr      = noErr;  short       i        = kInit,          savedVRefNum  = kInit,          savedRefNum    = kInit;  if (IsValid (theSoundInfo)) {    theSoundInfo-&gt;soundDone = false;      /* so we don't get called multiple times */    theSoundInfo-&gt;playing = false;    savedVRefNum = theSoundInfo-&gt;vRefNum;    savedRefNum = theSoundInfo-&gt;refNum;    if ((options == kCloseFile) || (options &gt; kCloseFile + kFreeMem)) {      DebugPrint (&quot;\pInvalid selector passed to ASoundDonePlaying&quot;);      theErr = kBadValue;    }    else {      theSoundInfo-&gt;stopping = false;  /* Sound is done stopping, hopefully... */      if (options &gt; kNoOptions) {        myPB = (myParamBlockRec*)theSoundInfo-&gt;doubleHeader.dbhBufferPtr[kDBBufOne]-&gt;dbUserInfo[kPBPtr];        if (myPB != nil) {          if (options == kCloseFile + kFreeMem) {            theErr = FSClose (myPB-&gt;pb.ioParam.ioRefNum);          }          if (theErr == noErr) {            for (i = kInit; i &lt;= kOne; i++) {              DisposeRoutineDescriptor (((myParamBlockRec*)theSoundInfo-&gt;doubleHeader.dbhBufferPtr[i]-&gt;dbUserInfo[kPBPtr])-&gt;pb.ioParam.ioCompletion);              DisposePtr ((Ptr)theSoundInfo-&gt;doubleHeader.dbhBufferPtr[i]-&gt;dbUserInfo[kPBPtr]);              /* Have to unhold memory that was held */              UnholdMemory ((Ptr)theSoundInfo-&gt;doubleHeader.dbhBufferPtr[i], sizeof(SndDoubleBuffer) + ASoundGetBufferSize (theSoundInfo));              DisposePtr ((Ptr)theSoundInfo-&gt;doubleHeader.dbhBufferPtr[i]);            }          }          else {            DebugPrint (&quot;\pFSClose error!&quot;);          }          theErr = SndDisposeChannel (theSoundInfo-&gt;chan, true);          DisposeRoutineDescriptor (ASoundGetSoundCallBack (theSoundInfo));          DisposeRoutineDescriptor (theSoundInfo-&gt;doubleHeader.dbhDoubleBack);          if (theErr != noErr) {            DebugPrint (&quot;\pSndDisposeChannel error!&quot;);          }        }      }      if (options == kNoOptions) {        ASoundSetBytesCopied (theSoundInfo, theSoundInfo-&gt;dataStart);        ASoundSetCurBuffer (theSoundInfo, kStart);        theSoundInfo-&gt;doubleHeader.dbhBufferPtr[kDBBufOne]-&gt;dbFlags = nil;        theSoundInfo-&gt;doubleHeader.dbhBufferPtr[kDBBufTwo]-&gt;dbFlags = nil;        theErr = ASoundPrimeBuffers (theSoundInfo);      }      if (options == kFreeMem) {        ASoundInit (theSoundInfo);        theSoundInfo-&gt;vRefNum = savedVRefNum;        theSoundInfo-&gt;refNum = savedRefNum;      }      else {        if (options == kCloseFile + kFreeMem) {          ASoundInit (theSoundInfo);        }      }    }  }  else {    theErr = kNilPtrErr;  }  if (theErr != noErr) {    DebugPrint (&quot;\pError in ASoundDonePlaying&quot;);  }  return theErr;}/*  Purpose:    Returns the channel for the sound in case you want to          send it specific commands.  Side Effects:  None.*//*-----------------------------------------------------------------------*/SndChannelPtr  ASoundGetChan      (SoundInfoPtr theSoundInfo)/*-----------------------------------------------------------------------*/{  SndChannelPtr  returnValue;  if (StrictIsValid (theSoundInfo)) {    returnValue = theSoundInfo-&gt;chan;  } else {    returnValue = nil;  }  return returnValue;}/*  Purpose:    Returns the name of the file containing the currently          playing sound.  Side Effects:  None.*//*-----------------------------------------------------------------------*/OSErr      ASoundGetSoundName    (SoundInfoPtr theSoundInfo,                    Str63 theName)/*-----------------------------------------------------------------------*/{  OSErr      theErr    = noErr;  short      i      = 0;  if (StrictIsValid (theSoundInfo) &amp;&amp; theName != nil) {    /* This should probably be a BlockMoveData */    for (i = 0; i &lt;= theSoundInfo-&gt;theName[0]+1; i++)      theName[i] = theSoundInfo-&gt;theName[i];  }  return theErr;}/*  Purpose:    Gets the number of the current buffer          (in the range 1 to ASoundGetNumBuffers()) of the          currently playing sound.  Side Effects:  None.*//*-----------------------------------------------------------------------*/long      ASoundGetCurBuffer    (SoundInfoPtr theSoundInfo)/*-----------------------------------------------------------------------*/{  long    returnValue    = kInit;  OSErr    theErr      = noErr;  if (StrictIsValid (theSoundInfo)) {    returnValue = theSoundInfo-&gt;currentBuffer;  }  else {    theErr = kNilPtrErr;    returnValue = nil;  }  if (theErr != noErr) {    DebugPrint (&quot;\pError in ASoundGetCurBuffer&quot;);  }  return returnValue;}/*  Purpose:    Sets which buffer should be the next buffer to play          from (in the range 1 to ASoundGetNumBuffers())          for the currently playing sound.  Side Effects:  None.*//*-----------------------------------------------------------------------*/OSErr      ASoundSetCurBuffer    (SoundInfoPtr theSoundInfo,                    long newValue)/*-----------------------------------------------------------------------*/{  OSErr    theErr      = noErr;  if (IsValid (theSoundInfo)) {    if ((newValue &gt;= kStart) &amp;&amp; (newValue &lt;= ASoundGetNumBuffers (theSoundInfo))) {      theSoundInfo-&gt;currentBuffer = newValue;      ASoundSetBytesCopied (theSoundInfo, newValue * ASoundGetBufferSize (theSoundInfo) + theSoundInfo-&gt;dataStart);    }    else {      theErr = kBadRange;    }  }  else {    theErr = kNilPtrErr;  }  return theErr;}/*  Purpose:    Gets the number of buffers that the currently playing          sound will need to play in its entirety.  Side Effects:  None.*//*-----------------------------------------------------------------------*/long      ASoundGetNumBuffers    (SoundInfoPtr theSoundInfo)/*-----------------------------------------------------------------------*/{  long    returnValue    = kInit;  OSErr    theErr      = noErr;  if (IsValid (theSoundInfo)) {    returnValue = theSoundInfo-&gt;numBuffers;  }  else {    theErr = kNilPtrErr;    returnValue = nil;  }  if (theErr != noErr) {    DebugPrint (&quot;\pError in ASoundGetNumBuffers&quot;);  }  return returnValue;}/*  Purpose:    Gets the length (in bytes) of the currently playing          sound.  This number does not include any header bytes.  Side Effects:  None.*//*-----------------------------------------------------------------------*/long      ASoundGetNumTotalBytes  (SoundInfoPtr theSoundInfo)/*-----------------------------------------------------------------------*/{  long    returnValue    = kInit;  OSErr    theErr      = noErr;  if (IsValid (theSoundInfo)) {    returnValue = theSoundInfo-&gt;bytesTotal;  }  else {    theErr = kNilPtrErr;    returnValue = nil;  }  if (theErr != noErr) {    DebugPrint (&quot;\pError in ASoundGetNumTotalBytes&quot;);  }  return returnValue;}/*  Purpose:    Gets the number of bytes that will be played by the end          of the current buffer of the currently playing sound.  Side Effects:  None.*//*-----------------------------------------------------------------------*/long      ASoundGetBytesCopied  (SoundInfoPtr theSoundInfo)/*-----------------------------------------------------------------------*/{  long    returnValue    = kInit;  OSErr    theErr      = noErr;  if (IsValid (theSoundInfo)) {    returnValue = theSoundInfo-&gt;bytesCopied;  }  else {    theErr = kNilPtrErr;    returnValue = nil;  }  if (theErr != noErr) {    DebugPrint (&quot;\pError in ASoundGetBytesCopied&quot;);  }  return returnValue;}/*  Purpose:    Sets the location in the file where the next buffer          should be filled from for the currently playing sound.  Side Effects:  None.*//*-----------------------------------------------------------------------*/OSErr      ASoundSetBytesCopied  (SoundInfoPtr theSoundInfo,                    long newValue)/*-----------------------------------------------------------------------*/{  OSErr    theErr      = noErr;  if (IsValid (theSoundInfo)) {    if (newValue &gt;= theSoundInfo-&gt;dataStart || newValue == kInit) {      theSoundInfo-&gt;bytesCopied = newValue;    }    else {      theErr = kBadValue;    }  }  else {    theErr = kNilPtrErr;  }  if (theErr != noErr) {    DebugPrint (&quot;\pError in ASoundSetBytesCopied&quot;);  }  return theErr;}/*  Purpose:    Gets the size of a buffer of the currently playing          sound.  Multiply by two to know how much memory is          reserved for buffering the currently playing sound.  Side Effects:  None.*//*-----------------------------------------------------------------------*/long      ASoundGetBufferSize    (SoundInfoPtr theSoundInfo)/*-----------------------------------------------------------------------*/{  long    returnValue    = kInit;  OSErr    theErr      = noErr;  if (IsValid (theSoundInfo)) {    returnValue = theSoundInfo-&gt;doubleBufferSize;  }  else {    theErr = kNilPtrErr;    returnValue = nil;  }  if (theErr != noErr) {    DebugPrint (&quot;\pError in ASoundGetBufferSize&quot;);  }  return returnValue;}/*  Purpose:    Gets the UPP for the function that should be called when          the currently playing sound finishes.  Side Effects:  None.*//*-----------------------------------------------------------------------*/SndCallBackUPP  ASoundGetSoundCallBack  (SoundInfoPtr theSoundInfo)/*-----------------------------------------------------------------------*/{  SndCallBackUPP    returnValue    = nil;  OSErr        theErr      = noErr;  if (IsValid (theSoundInfo)) {    returnValue = theSoundInfo-&gt;theSoundCallBackUPP;  }  else {    theErr = kNilPtrErr;    returnValue = nil;  }  if (theErr != noErr) {    DebugPrint (&quot;\pError in ASoundGetSoundCallBack&quot;);  }  return returnValue;}/*  Purpose:    Sets the function that should be called when the the          currently playing sound finishes.  Side Effects:  None.*//*-----------------------------------------------------------------------*/OSErr      ASoundSetSoundCallBack  (SoundInfoPtr theSoundInfo,                    void* newValue)/*-----------------------------------------------------------------------*/{  OSErr    theErr    = noErr;  if (IsValid (theSoundInfo)) {    if (theSoundInfo-&gt;theSoundCallBackUPP != nil) {      DisposeRoutineDescriptor (theSoundInfo-&gt;theSoundCallBackUPP);    }    if (newValue != nil) {      theSoundInfo-&gt;theSoundCallBackUPP = NewSndCallBackProc(newValue);    }    else {      theSoundInfo-&gt;theSoundCallBackUPP = NewSndCallBackProc(ASoundDoneCallBack);      DebugPrint (&quot;\pDid you really want the default sound callback?&quot;);    }  }  else {    theErr = kNilPtrErr;  }  if (theErr != noErr) {    DebugPrint (&quot;\pError in ASoundSetSoundCallBack&quot;);  }  return theErr;}/*  Purpose:    Says whether to play the currently playing sound backwards          (it actually reverses the sound in the buffer).  Side Effects:  Takes effect when the next sound buffer gets filled.*//*-----------------------------------------------------------------------*/OSErr      ASoundPlayBackwards    (SoundInfoPtr theSoundInfo,                    Boolean newValue)/*-----------------------------------------------------------------------*/{  OSErr    theErr    = noErr;  if (StrictIsValid (theSoundInfo)) {    theSoundInfo-&gt;backwards = newValue;  }  else {    theErr = kNilPtrErr;  }  if (theErr != noErr) {    DebugPrint (&quot;\pError in ASoundPlayBackwards&quot;);  }  return theErr;}/*  Purpose:    Returns true if the currently playing sound's buffer          is set to be reversed.  Side Effects:  None.*//*-----------------------------------------------------------------------*/Boolean      ASoundIsBackwards    (SoundInfoPtr theSoundInfo)/*-----------------------------------------------------------------------*/{  OSErr    theErr      = noErr;  Boolean    returnValue    = false;  if (StrictIsValid (theSoundInfo)) {    returnValue = theSoundInfo-&gt;backwards;  }  else {    theErr = kNilPtrErr;  }  if (theErr != noErr) {    DebugPrint (&quot;\pError in ASoundIsBackwards&quot;);  }  return returnValue;}/*  Purpose:    Returns true if the sound has finished playing.  Side Effects:  None.*//*-----------------------------------------------------------------------*/Boolean      ASoundIsDone      (SoundInfoPtr theSoundInfo)/*-----------------------------------------------------------------------*/{  OSErr    theErr      = noErr;  Boolean    returnValue    = false;  if (StrictIsValid (theSoundInfo)) {    returnValue = theSoundInfo-&gt;soundDone;  }  else {    theErr = kNilPtrErr;  }  if (theErr != noErr) {    DebugPrint (&quot;\pError in ASoundIsDone&quot;);  }  return returnValue;}/*  Purpose:    Changes the volume of the currently playing sound.          The values you pass in are added to the current values.          Negitive values will decrease the volume, positive values          will increase the volume.  Side Effects:  None.*//*-----------------------------------------------------------------------*/OSErr      ASoundChangeVolume    (SoundInfoPtr theSoundInfo,                    unsigned short leftVol,                    unsigned short rightVol)/*-----------------------------------------------------------------------*/{  SndCommand    theCmd    = {volumeCmd, kInit, kInit};  OSErr      theErr    = noErr;  unsigned short  tempLeft  = kInit,          tempRight  = kInit;  if (StrictIsValid (theSoundInfo)) {    theErr = ASoundGetVolume (theSoundInfo, &amp;tempLeft, &amp;tempRight);    if (theErr == noErr) {      if ((tempLeft + leftVol) &gt; kMaxVolume) leftVol = kMaxVolume - tempLeft;      if ((tempRight + rightVol) &gt; kMaxVolume) rightVol = kMaxVolume - tempRight;      if ((tempLeft + leftVol) &lt; kMinVolume) leftVol = -tempLeft;      if ((tempRight + rightVol) &lt; kMinVolume) rightVol = -tempRight;      theErr = ASoundSetVolume (theSoundInfo, tempLeft+leftVol, tempRight+rightVol);    }  }  else {    theErr = kNilPtrErr;  }  if (theErr != noErr) {    DebugPrint (&quot;\pError in ASoundChangeVolume&quot;);  }  return theErr;}/*  Purpose:    Gets the volume of the currently playing sound.  Side Effects:  None.*//*-----------------------------------------------------------------------*/OSErr      ASoundGetVolume      (SoundInfoPtr theSoundInfo,                    unsigned short *leftVol,                    unsigned short *rightVol)/*-----------------------------------------------------------------------*/{  SndCommand    theCmd    = {getVolumeCmd, kInit, kInit};  unsigned long  theVol    = kInit;  OSErr      theErr    = noErr;  if (StrictIsValid (theSoundInfo)) {    theCmd.param2 = (long)&amp;theVol;    theErr = SndDoImmediate(theSoundInfo-&gt;chan, &amp;theCmd);    if (theErr == noErr) {      *leftVol = theVol &amp; kLeftMask;      *rightVol = theVol &gt;&gt; kSixteen;    }  }  else {    theErr = kNilPtrErr;  }  if (theErr != noErr) {    DebugPrint (&quot;\pError in ASoundGetVolume&quot;);  }  return theErr;}/*  Purpose:    Sets the volume of the currently playing sound.  Side Effects:  None.*//*-----------------------------------------------------------------------*/OSErr      ASoundSetVolume      (SoundInfoPtr theSoundInfo,                    unsigned short leftVol,                    unsigned short rightVol)/*-----------------------------------------------------------------------*/{  SndCommand    theCmd    = {volumeCmd, kInit, kInit};  OSErr      theErr    = noErr;  if (StrictIsValid (theSoundInfo)) {    theCmd.param2 = (rightVol &lt;&lt; kSixteen) | leftVol;    theErr = SndDoImmediate(theSoundInfo-&gt;chan, &amp;theCmd);  }  else {    theErr = kNilPtrErr;  }  if (theErr != noErr) {    DebugPrint (&quot;\pError in ASoundSetVolume&quot;);  }  return theErr;}/*  Purpose:    Gets the rate multiplier of the currently playing sound.  Side Effects:  None.*//*-----------------------------------------------------------------------*/OSErr      ASoundGetRateMul    (SoundInfoPtr theSoundInfo,                    UnsignedFixed *theRateMul)/*-----------------------------------------------------------------------*/{  SndCommand    theCmd    = {getRateMultiplierCmd, kInit, kInit};  OSErr      theErr    = noErr;  if (StrictIsValid (theSoundInfo)) {    theCmd.param2 = (long)theRateMul;    theErr = SndDoImmediate(theSoundInfo-&gt;chan, &amp;theCmd);  }  else {    theErr = kNilPtrErr;  }  if (theErr != noErr) {    DebugPrint (&quot;\pError in ASoundGetRateMul&quot;);  }  return theErr;}/*  Purpose:    Gets the rate multiplier of the currently playing sound.  Side Effects:  None.*//*-----------------------------------------------------------------------*/OSErr      ASoundSetRateMul    (SoundInfoPtr theSoundInfo,                    UnsignedFixed theRateMul)/*-----------------------------------------------------------------------*/{  SndCommand    theCmd    = {rateMultiplierCmd, kInit, kInit};  OSErr      theErr    = noErr;  if (StrictIsValid (theSoundInfo)) {    theCmd.param2 = (long)theRateMul;    theErr = SndDoImmediate(theSoundInfo-&gt;chan, &amp;theCmd);  }  else {    theErr = kNilPtrErr;  }  if (theErr != noErr) {    DebugPrint (&quot;\pError in ASoundSetRateMul&quot;);  }  return theErr;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/SndPlayDoubleBuffer/listing19.html%3Fid%3DDTS10000371-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/SndPlayDoubleBuffer/listing19.html%3Fid%3DDTS10000371-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/SndPlayDoubleBuffer/listing19.html%3Fid%3DDTS10000371-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>