<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Mass Storage Device Driver Programming Guide: Developing a Filter Scheme</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Developing a Filter Scheme"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30000739" title="Developing a Filter Scheme"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../HardwareDrivers/index.html#//apple_ref/doc/uid/TP30000440-TP40003576" target="_top">Hardware &amp; Drivers</a> &gt; <a href="../../../../HardwareDrivers/MassStorageDevices-date.html#//apple_ref/doc/uid/TP30000440-TP40003576-TP30001039" target="_top">Storage</a> &gt; <a href="../01_Introduction/Introduction.html#//apple_ref/doc/uid/TP30000733-TPXREF101">Mass Storage Device Driver Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../07_SCSI_Example/MS_SCSI_Example.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../09_RevisionHistory/MS_RevHistory.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30000739-SW1" title="Developing a Filter Scheme"></a><h1><a name="//apple_ref/doc/uid/TP30000739-TPXREF101" title="Developing a Filter Scheme"></a>Developing a Filter Scheme</h1><p><a name="//apple_ref/doc/uid/TP30000739-DontLinkElementID_294"></a><a name="//apple_ref/doc/uid/TP30000739-DontLinkElementID_295"></a>On Mac OS X, a filter-scheme driver provides a filtering mechanism between generic I/O requests and content on a media. A media-filter scheme matches on an <code>IOMedia</code> object representing the content present in a partition and publishes in the I/O Registry another <code>IOMedia</code> object that represents the unfiltered content. Because filter-scheme drivers are both consumers and producers of <code>IOMedia</code> objects, there can be an arbitrary number of filter schemes in the mass storage driver stack.</p><p>To create your own filter-scheme driver, you subclass<a name="//apple_ref/doc/uid/TP30000739-DontLinkElementID_296"></a> <code>IOStorage</code> and implement your filtering functionality in the <code>read</code> and <code>write</code> methods. Other methods you implement, such as <code>init</code>, <code>start</code>, and <code>free</code>, create and initialize the new <code>IOMedia</code> object, attach it to the I/O Registry, and release it.</p><p>As described in <span class="content_text"><a href="../02_Overview/MS_Overview.html#//apple_ref/doc/uid/TP30000734-TPXREF103">“Filter Schemes,”</a></span> a filter-scheme driver should not produce an <code>IOCDMedia</code> or <code>IODVDMedia</code> object, because these objects have provider requirements specific to CD and DVD media that can be met only by an <code>IOCDBlockStorageDriver</code> or <code>IODVDBlockStorageDriver</code>, respectively.</p><p>This chapter guides you through the process of creating a filter-scheme driver. It also describes how to test the driver by creating a disk image that contains a partition the driver can match on. The sample code in this chapter is generic and emphasizes the form your driver should take, rather than the implementation of specific filtering functionality. When you use this code as a basis for your own filter-scheme driver, you should replace the generic values, such as <code>MySoftwareCompany</code>, with your own values and add your filtering code to the appropriate methods.</p><p>The sample filter scheme described in this chapter includes code that allows you to install the filter scheme on the boot partition. If you do not need to do this, you can skip the portions of the code that implement this.</p><p>The sample code in this chapter is from an Xcode project that builds a filter-scheme driver. To download the complete project (which includes debugging and installation information), see <em><a href="../../../../../samplecode/SampleFilterScheme/index.html#//apple_ref/doc/uid/DTS10000432" target="_top">SampleFilterScheme</a></em> in the ADC Reference Library. Note that the <em>SampleFilterScheme</em> project defines two different targets, one of which allows you to install the filter scheme on the boot partition. Be sure to read the comments in the project’s files before you decide which target to build.</p><p>For more information on how to develop kernel extensions in general and I/O Kit drivers in particular, see <em><a href="../../../../Darwin/Conceptual/KEXTConcept/index.html#//apple_ref/doc/uid/TP40001063" target="_top">Kernel Extension Programming Topics</a></em> and <em><a href="../../WritingDeviceDriver/index.html#//apple_ref/doc/uid/TP30000694" target="_top">I/O Kit Device Driver Design Guidelines</a></em>.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000739-DontLinkElementID_13" title="Important:"></a><p><strong>Important:</strong>&nbsp;The sample code in this chapter is designed to work with Mac OS X version 10.1 and later. It will not work with earlier versions.</p><p></p></div>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="MS_Media_Example.html#//apple_ref/doc/uid/TP30000739-TPXREF104">Edit Your Driver’s Property List</a>
				
			<br/>
			
        
			
			
				<a href="MS_Media_Example.html#//apple_ref/doc/uid/TP30000739-TPXREF105">Creating Your Filter Scheme</a>
				
			<br/>
			
        
			
			
				<a href="MS_Media_Example.html#//apple_ref/doc/uid/TP30000739-TPXREF108">Testing Your Filter Scheme</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30000739-TPXREF104" title="Edit Your Driver&acirc;&#128;&#153;s Property List"></a><h2>Edit Your Driver’s Property List</h2><p><a name="//apple_ref/doc/uid/TP30000739-DontLinkElementID_297"></a><a name="//apple_ref/doc/uid/TP30000739-DontLinkElementID_298"></a><a name="//apple_ref/doc/uid/TP30000739-DontLinkElementID_299"></a><a name="//apple_ref/doc/uid/TP30000739-DontLinkElementID_300"></a><a name="//apple_ref/doc/uid/TP30000739-DontLinkElementID_301"></a>Every driver has an <code>Info.plist</code> file that contains information about the driver and what it needs, including its personalities. A filter-scheme driver matches on content in a partition rather than on a device, so its personality contains information that identifies specific content. As described in <span class="content_text"><a href="../04_Matching/MS_Matching.html#//apple_ref/doc/uid/TP30000736-BCIBACGH">“Filter-Scheme Driver Matching,”</a></span> a filter-scheme driver uses the <code>Content Hint</code> property to match on the content-hint string a disk utility program places in a partition. To make sure your driver loads for your content, you add the <code>Content Hint</code> property and associated content-hint value to its personality dictionary. You can also add other properties that identify media characteristics, such as ejectability and writability.</p><p>For step-by-step instructions that describe how to create a personality dictionary for a driver and add children to it, see the <span class="content_text"><a href="../../../../Darwin/Conceptual/KEXTConcept/KEXTConceptIOKit/hello_iokit.html#//apple_ref/doc/uid/20002366" target="_top">Hello I/O Kit</a></span> tutorial in <em><a href="../../../../Darwin/Conceptual/KEXTConcept/index.html#//apple_ref/doc/uid/TP40001063" target="_top">Kernel Extension Programming Topics</a></em>.</p><p>The sample code uses the following five property keys:</p><ul class="ul"><li class="li"><p><code>CFBundleIdentifier</code></p></li><li class="li"><p><code>IOClass</code></p></li><li class="li"><p><code>IOProviderClass</code></p></li><li class="li"><p><code>Content Hint</code></p></li><li class="li"><p><code>IOMatchCategory</code></p></li></ul><p>Create five new children of the <code>MyFilterScheme</code> personality dictionary, one for each of the five properties you’ll be adding. <span class="content_text"><a href="MS_Media_Example.html#//apple_ref/doc/uid/TP30000739-CAHFJDDE">Table 7-1</a></span> shows the properties, along with their classes and values. To test the sample code with your device, replace values such as <code>MySoftwareCompany_MyContentHint</code> with actual values for your content.<a name="//apple_ref/doc/uid/TP30000739-DontLinkElementID_302"></a><a name="//apple_ref/doc/uid/TP30000739-DontLinkElementID_303"></a><a name="//apple_ref/doc/uid/TP30000739-DontLinkElementID_304"></a></p><a name="//apple_ref/doc/uid/TP30000739-CAHFJDDE" title="Table 7-1Personality properties for MyFilterScheme"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 7-1&nbsp;&nbsp;</strong>Personality properties for MyFilterScheme</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Property</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Class</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Value</p></th></tr><tr><td  scope="row"><p><code>CFBundleIdentifier</code></p></td><td ><p>String</p></td><td ><p><code>com.MySoftwareCompany.driver.MyFilterScheme</code></p></td></tr><tr><td  scope="row"><p><code>IOClass</code></p></td><td ><p>String</p></td><td ><p><code>com_MySoftwareCompany_driver_MyFilterScheme</code></p></td></tr><tr><td  scope="row"><p><code>IOProviderClass</code></p></td><td ><p>String</p></td><td ><p><code>IOMedia</code></p></td></tr><tr><td  scope="row"><p><code>Content Hint</code></p></td><td ><p>String</p></td><td ><p><code>MySoftwareCompany_MyContent</code></p></td></tr><tr><td  scope="row"><p><code>IOMatchCategory</code></p></td><td ><p>String</p></td><td ><p><code>IOStorage</code></p></td></tr></table></div><p>A driver declares its dependencies on other loadable kernel extensions and in-kernel components in the <code>OSBundleLibraries</code> dictionary. Each dependency has a string value that declares the earliest version of the dependency the driver is compatible with.</p><p>The sample driver depends on one loadable extension from the Storage family and three kernel components. To add these dependencies to the <code>OSBundleLibraries</code> dictionary, you create a new child for each dependency. <span class="content_text"><a href="MS_Media_Example.html#//apple_ref/doc/uid/TP30000739-CAHIDEDD">Table 7-2</a></span> shows the dependencies you add for the sample driver.<a name="//apple_ref/doc/uid/TP30000739-DontLinkElementID_305"></a><a name="//apple_ref/doc/uid/TP30000739-DontLinkElementID_306"></a></p><a name="//apple_ref/doc/uid/TP30000739-CAHIDEDD" title="Table 7-2Dependencies for MyFilterScheme"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 7-2&nbsp;&nbsp;</strong>Dependencies for MyFilterScheme</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Property</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Class</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Value</p></th></tr><tr><td  scope="row"><p><code>com.apple.iokit.IOStorageFamily</code></p></td><td ><p>String</p></td><td ><p><code>1.1</code></p></td></tr><tr><td  scope="row"><p><code>com.apple.kernel.iokit</code></p></td><td ><p>String</p></td><td ><p><code>1.1</code></p></td></tr><tr><td  scope="row"><p><code>com.apple.kernel.libkern</code></p></td><td ><p>String</p></td><td ><p><code>1.1</code></p></td></tr><tr><td  scope="row"><p><code>com.apple.kernel.mach</code></p></td><td ><p>String</p></td><td ><p><code>1.1</code></p></td></tr></table></div><p>Finally, to allow this filter scheme to filter the boot volume, you must ensure that it is loaded at boot time so that it can be installed on top of the boot volume. To do this, you add the <code>OSBundleRequired</code> property to the top level of your <code>Info.plist</code> file and give it the string value <code>Local-Root</code>. If you do not need to filter the boot partition, do not add this property-value pair to your <code>Info.plist</code> file.</p><a name="//apple_ref/doc/uid/TP30000739-TPXREF105" title="Creating Your Filter Scheme"></a><h2>Creating Your Filter Scheme</h2><p><a name="//apple_ref/doc/uid/TP30000739-DontLinkElementID_307"></a>This section describes some of the elements that must be included in your driver’s source files. To demonstrate the process of creating a filter-scheme driver, the sample driver implements most of the needed methods by acting as a pass-through, in other words, calling through to its provider media. You should replace these trivial implementations with your own code that supports your filtering functionality.</p><a name="//apple_ref/doc/uid/TP30000739-TPXREF106" title="Edit the Header File"></a><h3>Edit the Header File</h3><p>The header file for the sample filter-scheme driver includes ten method declarations and two external header files. In the interests of brevity, the sample code includes only a condensed version of the standard comments accompanying each method declaration. You can find fully commented versions of these method declarations in <code>IOMedia.h</code> and <code>IOStorage.h</code> (both of which are in <code>/System/Library/Frameworks/IOKit.framework/Headers/storage</code>).</p><p>Edit the <code>MyFilterScheme.h</code> file to match the code in <span class="content_text"><a href="MS_Media_Example.html#//apple_ref/doc/uid/TP30000739-CJDJIGJB">Listing 7-1</a></span>.</p><a name="//apple_ref/doc/uid/TP30000739-CJDJIGJB" title="Listing 7-1The MyFilterScheme header file"></a><p class="codesample"><strong>Listing 7-1&nbsp;&nbsp;</strong>The MyFilterScheme header file</p><div class="codesample"><table><tr><td scope="row"><pre>#include &lt;IOKit/storage/IOMedia.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;IOKit/storage/IOStorage.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>class com_MySoftwareCompany_driver_MyFilterScheme : public IOStorage {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    OSDeclareDefaultStructors(com_MySoftwareCompany_driver_MyFilterScheme)<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>protected:<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    IOMedia*    _childMedia;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Free all of this object's outstanding resources.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    virtual void free(void);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // The handleOpen method grants or denies permission to access this<span></span></pre></td></tr><tr><td scope="row"><pre>    // object to an interested client.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    virtual bool handleOpen(IOService*   client,<span></span></pre></td></tr><tr><td scope="row"><pre>                            IOOptionBits options,<span></span></pre></td></tr><tr><td scope="row"><pre>                            void*        access);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // The handleIsOpen method determines whether the specified client,<span></span></pre></td></tr><tr><td scope="row"><pre>    // or any client if none is specified, presently has an open<span></span></pre></td></tr><tr><td scope="row"><pre>    // on this object.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    virtual bool handleIsOpen(const IOService* client) const;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>     // The handleClose method closes the client's access to this object.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    virtual void handleClose(IOService* client, IOOptionBits options);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Attach the passed-in media object to the device tree plane.<span></span></pre></td></tr><tr><td scope="row"><pre>    // This is necessary if you want to stack this filter scheme on top<span></span></pre></td></tr><tr><td scope="row"><pre>    // of the boot volume. You do not need to include this method if you<span></span></pre></td></tr><tr><td scope="row"><pre>    // do not need to filter the boot volume.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    virtual bool attachMediaObjectToDeviceTree(IOMedia* media);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Detach the passed-in media object from the device tree plane.<span></span></pre></td></tr><tr><td scope="row"><pre>    // This is necessary if you want to stack this filter scheme on top<span></span></pre></td></tr><tr><td scope="row"><pre>    // of the boot volume. You do not need to include this method if you<span></span></pre></td></tr><tr><td scope="row"><pre>    // do not need to filter the boot volume.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    virtual void detachMediaObjectFromDeviceTree(IOMedia* media);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>public:<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>     // Initialize this object's minimal state.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    virtual bool init(OSDictionary* properties = 0);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>     // Publish the new IOMedia object that represents the filtered content.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    virtual bool start(IOService* provider);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Clean up after the published media object before terminating.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    virtual void stop(IOService* provider);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Read data from the storage object at the specified byte offset into<span></span></pre></td></tr><tr><td scope="row"><pre>    // the specified buffer, asynchronously.   When the read completes,<span></span></pre></td></tr><tr><td scope="row"><pre>    // the caller will be notified via the specified completion action.<span></span></pre></td></tr><tr><td scope="row"><pre>    // The buffer will be retained for the duration of the read.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    virtual void read(IOService*           client,<span></span></pre></td></tr><tr><td scope="row"><pre>                      UInt64               byteStart,<span></span></pre></td></tr><tr><td scope="row"><pre>                      IOMemoryDescriptor*  buffer,<span></span></pre></td></tr><tr><td scope="row"><pre>                      IOStorageCompletion  completion);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Write data into the storage object at the specified byte offset from<span></span></pre></td></tr><tr><td scope="row"><pre>    // the specified buffer, asynchronously.   When the write completes, the<span></span></pre></td></tr><tr><td scope="row"><pre>    // caller will be notified via the specified completion action.<span></span></pre></td></tr><tr><td scope="row"><pre>    // The buffer will be retained for the duration of the write.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    virtual void write(IOService*           client,<span></span></pre></td></tr><tr><td scope="row"><pre>                       UInt64               byteStart,<span></span></pre></td></tr><tr><td scope="row"><pre>                       IOMemoryDescriptor*  buffer,<span></span></pre></td></tr><tr><td scope="row"><pre>                       IOStorageCompletion  completion);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Flush the cached data in the storage object, if any, synchronously.<span></span></pre></td></tr><tr><td scope="row"><pre>    // The I/O Kit provides for data caches at the driver level, but<span></span></pre></td></tr><tr><td scope="row"><pre>    // Apple discourages this because it is rarely needed. In the majority<span></span></pre></td></tr><tr><td scope="row"><pre>    // of cases, a pass-through implementation is sufficient.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    virtual IOReturn synchronizeCache(IOService* client);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Obtain this object's provider.  This method returns IOMedia,<span></span></pre></td></tr><tr><td scope="row"><pre>    // rather than the less-specific OSObject, as a convenience.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    virtual IOMedia* getProvider() const;<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000739-TPXREF107" title="Edit the C++ File"></a><h3>Edit the C++ File</h3><p>The C++ file provides the code to implement the chosen methods. The sample driver’s C++ file contains all the elements required for a subclassed filter-scheme driver even though it performs no filtering. To implement your filtering scheme, add code to the <code>read</code> and <code>write</code> methods.</p><p>The sample code in includes two methods you must implement if you want your filter scheme to filter the boot volume:</p><ul class="spaceabove"><li class="li"><p><code>attachMediaObjectToDeviceTree</code></p></li><li class="li"><p><code>detachMediaObjectFromDeviceTree</code></p></li></ul><div class="notebox"><a name="//apple_ref/doc/uid/TP30000739-DontLinkElementID_14" title="Note"></a><p><strong>Note:</strong>&nbsp;If you do not need to filter the boot volume, you can skip ahead to the code in <span class="content_text"><a href="MS_Media_Example.html#//apple_ref/doc/uid/TP30000739-CJDJJBDG">Listing 7-2</a></span>, ignoring the code for these two methods.</p></div><p>The <code>attachMediaObjectToDeviceTree</code> method, is called in your <code><!--a-->start<!--/a--></code> routine after the call to the standard <code>attach</code> method that attaches the new media to your filter scheme. This method detaches your filter scheme’s parent object from the Open Firmware device tree and attaches the filter scheme’s child object to the Open Firmware device tree in its place. This must be done before you publish the new media object in the I/O Registry using the <code>registerService</code> method. The second method, the <code>detachMediaObjectFromDeviceTree</code> method, performs the operation in reverse in your <code><!--a-->stop<!--/a--></code> routine.</p><p>To understand why this rearranging of device tree nodes is necessary, it helps to know more about the Mac OS X boot process. When you turn on your computer, Open Firmware determines which volume to boot from. It then loads the secondary booter (named BootX) from that volume and jumps to it. BootX loads and runs the kernel, passing to it parameters it inherits from Open Firmware, including the device tree.</p><p>After the kernel comes up, it must mount the root volume. By this time, Open Firmware is no longer running, so the kernel determines the root volume by interpreting a parameter Open Firmware passed to it earlier. The parameter contains the root path property of the <code>/chosen</code> node in the Open Firmware device tree. The kernel searches the I/O Registry for a node whose Open Firmware path matches the root path. The kernel uses this node as the root device.</p><p>If there is a filter scheme installed on top of this node, the kernel is not aware of it and it continues to boot from the unfiltered node. Later on in the process, the system notices that the filter scheme is publishing a new child node that hasn’t been mounted on, so it mounts the file system on that node. This results in the appearance of two copies of the boot volume on the Desktop, each with a separate data path, which is an undesirable outcome.</p><p>Edit the <code>MyFilterScheme.cpp</code> file to match the code in <span class="content_text"><a href="MS_Media_Example.html#//apple_ref/doc/uid/TP30000739-CJDJJBDG">Listing 7-2</a></span>.</p><a name="//apple_ref/doc/uid/TP30000739-CJDJJBDG" title="Listing 7-2The MyFilterScheme C++ file"></a><p class="codesample"><strong>Listing 7-2&nbsp;&nbsp;</strong>The MyFilterScheme C++ file</p><div class="codesample"><table><tr><td scope="row"><pre>#include &lt;IOKit/assert.h>   // For debugging purposes.<span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;IOKit/IOLib.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include "MyFilterScheme.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// This definition allows you to use the more convenient "super" in<span></span></pre></td></tr><tr><td scope="row"><pre>// place of "IOStorage", where appropriate.<span></span></pre></td></tr><tr><td scope="row"><pre>#define super IOStorage<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// This macro must appear before you define any of your class's methods.<span></span></pre></td></tr><tr><td scope="row"><pre>// Note that you must use the literal name of the superclass here,<span></span></pre></td></tr><tr><td scope="row"><pre>// not "super" as defined above.<span></span></pre></td></tr><tr><td scope="row"><pre>OSDefineMetaClassAndStructors(com_MySoftwareCompany_driver_MyFilterScheme,<span></span></pre></td></tr><tr><td scope="row"><pre>                                IOStorage)<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Define the methods to implement.<span></span></pre></td></tr><tr><td scope="row"><pre>bool com_MySoftwareCompany_driver_MyFilterScheme::init(OSDictionary*<span></span></pre></td></tr><tr><td scope="row"><pre>                                            properties = 0)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    //<span></span></pre></td></tr><tr><td scope="row"><pre>    // Initialize this object's minimal state.<span></span></pre></td></tr><tr><td scope="row"><pre>    //<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Call superclass's init.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (super::init(properties) == false)  return false;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Initialize state.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    _childMedia = 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return true;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void com_MySoftwareCompany_driver_MyFilterScheme::free(void)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    //<span></span></pre></td></tr><tr><td scope="row"><pre>    // Free all of this object's outstanding resources.<span></span></pre></td></tr><tr><td scope="row"><pre>    //<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if ( _childMedia )  _childMedia->release();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Call superclass's free.<span></span></pre></td></tr><tr><td scope="row"><pre>    super::free();<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>IOMedia* com_MySoftwareCompany_driver_MyFilterScheme::getProvider(void)<span></span></pre></td></tr><tr><td scope="row"><pre>    const<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return (IOMedia*) IOService::getProvider();<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>bool com_MySoftwareCompany_driver_MyFilterScheme::start(IOService* provider)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    //<span></span></pre></td></tr><tr><td scope="row"><pre>    // Publish the new media object that represents the filtered content.<span></span></pre></td></tr><tr><td scope="row"><pre>    //<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    IOMedia* media = OSDynamicCast (IOMedia, provider);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // State assumptions.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    assert(media);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Call superclass's start.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if ( super::start(provider) == false )<span></span></pre></td></tr><tr><td scope="row"><pre>        return false;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Attach and register the new media object.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    IOMedia* childMedia = new IOMedia;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if ( childMedia )<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        if ( childMedia->init(<span></span></pre></td></tr><tr><td scope="row"><pre>                /* base               */ 0,<span></span></pre></td></tr><tr><td scope="row"><pre>                /* size               */ media->getSize(),<span></span></pre></td></tr><tr><td scope="row"><pre>                /* preferredBlockSize */ media->getPreferredBlockSize(),<span></span></pre></td></tr><tr><td scope="row"><pre>                /* isEjectable        */ media->isEjectable(),<span></span></pre></td></tr><tr><td scope="row"><pre>                /* isWhole            */ false,<span></span></pre></td></tr><tr><td scope="row"><pre>                /* isWritable         */ media->isWritable(),<span></span></pre></td></tr><tr><td scope="row"><pre>                /* contentHint        */ "Apple_HFS" ) )<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            // Set a name for this partition.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            UInt32 partitionID = 1;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            char name[24];<span></span></pre></td></tr><tr><td scope="row"><pre>            sprintf(name, "MySoftwareCompany_Filtered %ld", partitionID);<span></span></pre></td></tr><tr><td scope="row"><pre>            childMedia->setName(name);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            // Set a location value (partition number) for this partition.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            char location[12];<span></span></pre></td></tr><tr><td scope="row"><pre>            sprintf(location, "%ld", partitionID);<span></span></pre></td></tr><tr><td scope="row"><pre>            childMedia->setLocation(location);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            // Attach the new media to this driver<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            _childMedia = childMedia;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            childMedia->attach(this);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            // Move parent node to child node.<span></span></pre></td></tr><tr><td scope="row"><pre>            (void) attachMediaObjectToDeviceTree(childMedia);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            // Publish the new media object.<span></span></pre></td></tr><tr><td scope="row"><pre>            childMedia->registerService();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            return true;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        else<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            childMedia->release();<span></span></pre></td></tr><tr><td scope="row"><pre>            childMedia = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return false;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void com_MySoftwareCompany_driver_MyFilterScheme::stop(IOService* provider)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // Clean up after the media object before terminating.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // State assumptions.<span></span></pre></td></tr><tr><td scope="row"><pre>    assert(_childMedia);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Detach the media object previously attached in start().<span></span></pre></td></tr><tr><td scope="row"><pre>    if (_childMedia)<span></span></pre></td></tr><tr><td scope="row"><pre>        detachMediaObjectFromDeviceTree(_childMedia);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    super::stop(provider);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>bool com_MySoftwareCompany_driver_MyFilterScheme::handleOpen(IOService*<span></span></pre></td></tr><tr><td scope="row"><pre>                                            client,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            IOOptionBits options,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            void* argument)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return getProvider()->open(this, options, (IOStorageAccess) argument);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>bool com_MySoftwareCompany_driver_MyFilterScheme::handleIsOpen(const<span></span></pre></td></tr><tr><td scope="row"><pre>                                            IOService* client) const<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return getProvider()->isOpen(this);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void com_MySoftwareCompany_driver_MyFilterScheme::handleClose(IOService*<span></span></pre></td></tr><tr><td scope="row"><pre>                                        client, IOOptionBits options)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    getProvider()->close(this, options);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>bool com_MySoftwareCompany_driver_MyFilterScheme::attachMediaObjectToDeviceTree(<span></span></pre></td></tr><tr><td scope="row"><pre>                                            IOMedia* media)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    //<span></span></pre></td></tr><tr><td scope="row"><pre>    // Attach the given media object to the device tree plane.<span></span></pre></td></tr><tr><td scope="row"><pre>    //<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    IORegistryEntry* child;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if ((child = getParentEntry(gIOServicePlane))) {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        IORegistryEntry* parent;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        if ((parent = child->getParentEntry(gIODTPlane))) {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            const char* location = child->getLocation(gIODTPlane);<span></span></pre></td></tr><tr><td scope="row"><pre>            const char* name     = child->getName(gIODTPlane);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            if (media->attachToParent(parent, gIODTPlane)) {<span></span></pre></td></tr><tr><td scope="row"><pre>                media->setLocation(location, gIODTPlane);<span></span></pre></td></tr><tr><td scope="row"><pre>                media->setName(name, gIODTPlane);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                child->detachFromParent(parent, gIODTPlane);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                return true;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return false;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void com_MySoftwareCompany_driver_MyFilterScheme::detachMediaObjectFromDeviceTree<span></span></pre></td></tr><tr><td scope="row"><pre>                                            (IOMedia* media)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    //<span></span></pre></td></tr><tr><td scope="row"><pre>    // Detach the given media object from the device tree plane.<span></span></pre></td></tr><tr><td scope="row"><pre>    //<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    IORegistryEntry* child;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if ((child = getParentEntry(gIOServicePlane))) {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        IORegistryEntry * parent;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        if ((parent = media->getParentEntry(gIODTPlane))) {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            const char* location = media->getLocation(gIODTPlane);<span></span></pre></td></tr><tr><td scope="row"><pre>            const char* name     = media->getName(gIODTPlane);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            if (child->attachToParent(parent, gIODTPlane)) {<span></span></pre></td></tr><tr><td scope="row"><pre>                child->setLocation(location, gIODTPlane);<span></span></pre></td></tr><tr><td scope="row"><pre>                child->setName(name, gIODTPlane);<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            media->detachFromParent(parent, gIODTPlane);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void com_MySoftwareCompany_driver_MyFilterScheme::read(IOService* __attribute__ ((unused)) client,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        UInt64 byteStart,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        IOMemoryDescriptor* buffer,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        IOStorageCompletion completion)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // Add filtering code here.<span></span></pre></td></tr><tr><td scope="row"><pre>       getProvider()->read(this, byteStart, buffer, completion);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void com_MySoftwareCompany_driver_MyFilterScheme::write(IOService* __attribute__ ((unused)) client,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        UInt64 byteStart,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        IOMemoryDescriptor* buffer,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        IOStorageCompletion completion)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>   // Add filtering code here.<span></span></pre></td></tr><tr><td scope="row"><pre>    getProvider()->write(this, byteStart, buffer, completion);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>IOReturn com_MySoftwareCompany_driver_MyFilterScheme::synchronizeCache(<span></span></pre></td></tr><tr><td scope="row"><pre>                                                    IOService* client)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return getProvider()->synchronizeCache(this);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000739-TPXREF108" title="Testing Your Filter Scheme"></a><h2>Testing Your Filter Scheme</h2><p><a name="//apple_ref/doc/uid/TP30000739-DontLinkElementID_308"></a><a name="//apple_ref/doc/uid/TP30000739-DontLinkElementID_309"></a><a name="//apple_ref/doc/uid/TP30000739-DontLinkElementID_310"></a>To test the sample filter-scheme driver, you must first create a disk image for it to match on. You do this using the command-line tools <code>hdiutil</code>, which creates and manipulates disk images and <code>newfs_hfs</code>, which builds a file system on the disk image. For full documentation on these commands, see the <code>man</code> pages.</p><p>To create the disk image, open a window in the Terminal application (located at <code>/Applications/Utilities/Terminal</code>) and type the following commands.</p><div class="codesample"><table><tr><td scope="row"><pre>$ hdiutil create -megabytes 5 -partitionType MySoftwareCompany_MyContent<span></span></pre></td></tr><tr><td scope="row"><pre>                            ~/MySoftwareCompany_MyContent_Example.dmg<span></span></pre></td></tr></table></div><p>Then, you attach the disk image without mounting it, because it doesn’t yet contain a valid file system. In Mac OS X version 10.2 and later, use this command:</p><div class="codesample"><table><tr><td scope="row"><pre>$ hdiutil attach -nomount ~/MySoftwareCompany_MyContent_Example.dmg<span></span></pre></td></tr></table></div><p>In version of Mac OS X prior to 10.2, use this command (the <code>-nomount</code> option was added in Mac OS X version 10.2):</p><div class="codesample"><table><tr><td scope="row"><pre>$ hdiutil attach ~/MySoftwareCompany_MyContent_Example.dmg<span></span></pre></td></tr></table></div><p>The <code>hdiutil attach</code> command displays the special device name that is associated with each partition on the disk image:</p><div class="codesample"><table><tr><td scope="row"><pre>/dev/disk1          Apple_partition_scheme<span></span></pre></td></tr><tr><td scope="row"><pre>/dev/disk1s1        Apple_partition_map<span></span></pre></td></tr><tr><td scope="row"><pre>/dev/disk1s2        MySoftwareCompany_MyContent<span></span></pre></td></tr></table></div><p>Then, use the <code>newfs_hfs</code> command to create the file system on your disk image. Because you should always use the raw, uncached disk, you add an <code>r</code> to the disk node representing the partition with your content.</p><div class="codesample"><table><tr><td scope="row"><pre>$ newfs_hfs -v "My_Volume_Name" /dev/rdisk1s2<span></span></pre></td></tr></table></div><p>The <code>-v</code> option allows you to specify a volume name.</p><p>After you’ve created the disk image and its file system, you can assume super user (or <code>root</code>) privileges and use the <code>kextload</code> command to load the sample filter-scheme driver. Alternately, if the <code>root</code> account owns the filter-scheme driver, you can copy it to <code>/System/Library/Extensions</code>, reboot, and the driver will load automatically.</p><p>To use the <code>kextload</code> command, type the following line in a Terminal window:</p><div class="codesample"><table><tr><td scope="row"><pre>$ kextload -v MyFilterScheme.kext<span></span></pre></td></tr></table></div><p>The <code>-v</code> option makes <code>kextload</code> provide more verbose information.</p><p>After you’ve successfully loaded the driver, you can use Disk Copy to open the disk image (double-click on the disk image in the Finder).<a name="//apple_ref/doc/uid/TP30000739-DontLinkElementID_311"></a><a name="//apple_ref/doc/uid/TP30000739-DontLinkElementID_312"></a><a name="//apple_ref/doc/uid/TP30000739-DontLinkElementID_313"></a><a name="//apple_ref/doc/uid/TP30000739-DontLinkElementID_314"></a></p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../07_SCSI_Example/MS_SCSI_Example.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../09_RevisionHistory/MS_RevHistory.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2002, 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-04-03<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeviceDrivers/Conceptual/MassStorage/08_Media_Example/MS_Media_Example.html%3Fid%3DTP40000974-4.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeviceDrivers/Conceptual/MassStorage/08_Media_Example/MS_Media_Example.html%3Fid%3DTP40000974-4.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeviceDrivers/Conceptual/MassStorage/08_Media_Example/MS_Media_Example.html%3Fid%3DTP40000974-4.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>