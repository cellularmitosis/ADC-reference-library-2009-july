(*	File:		ResolveRelativeAlias.p		Description:A document contains an alias to a file in a known folder.  The problem  				is that the document might be on a floppy, and the known folder might  				be on a drive whose name is unknown.    				For example, say the boot drive will contain "Super Folder" in the root  				directory, and "Super File" in that folder.  The goal is to create an  				alias to "Super File" which will work regardless of the drive's name.      			Solution:    				Create an alias to the the target (e.g. "SuperFile") which is relative to  				the System file.  This presumes that the folder structure of the drive  				is known, but makes no presumption about the name of the drive.   	 			This sample tool demonstrates the steps involved in creating and resolving  				the alias.  Instead of creating a document to store the alias, the tool wimps  				out and stores the alias in a preference file.    				The tool puts up a StandardGetFile dialog.  Selecting a file creates the  				preference file containing the relative alias; clicking Cancel instead  				gets the preference file, resolves it, and prints the vRefNum and name  				of the target.      			Alternative strategies:    				Well, you could call PBGetVInfo to find the name of the boot volume  				and then build a full pathname, or SetVol to the root directory of the  				boot volume and then use a relative pathname.  But both of those  				solutions are ugly and un-Seven like.	Author:		GR	Copyright: 	Copyright: © 1992-1999 by Apple Computer, Inc.				all rights reserved.		Disclaimer:	You may incorporate this sample code into your applications without				restriction, though the sample code has been provided "AS IS" and the				responsibility for its operation is 100% yours.  However, what you are				not permitted to do is to redistribute the source as "DSC Sample Code"				after having made changes. If you're going to re-distribute the source,				we require that you make it clear in the source that the code was				descended from Apple Sample Code, but that you've made changes.		Change History (most recent first):				6/25/99	Updated for Metrowerks Codewarror Pro 2.1(KG)				3/92	Created(GR)*)PROGRAM resolveRelativeAlias;USES 	Quickdraw,		Fonts,		Processes, 		Files, 		Aliases, 		Packages, 		Script, 		Resources, 		Errors, 		StandardFile,		Folders;	VAR		retCode: OSErr;		mySFR: StandardFileReply;		mySFTypeList: SFTypeList;		sysVRefNum, prefVRefNum, myResRefNum: Integer;		sysDirID, prefDirID: LongInt;		resolvedFSSpec, sysFSSpec, fileFSSpec: FSSpec;		targetAliasHandle: AliasHandle;		changeFlag: Boolean;		PROCEDURE Fail(msg: Str255; retCode: OSErr);	BEGIN		WriteLn(msg, ' failed: ', retCode);			END;	PROCEDURE PrintFSSpec(theFSSpec: FSSpec);	BEGIN		WriteLn('FSSpec: ', theFSSpec.vRefNum, ' ', theFSSpec.parID, ' ',			theFSSpec.name);	END;BEGIN	InitGraf(@qd.thePort);	InitFonts;   	InitWindows;   	TEInit;   	InitDialogs (nil);	{ find the vRefNum and dirID of the system and preferences folders }	retCode := FindFolder(kOnSystemDisk, kSystemFolderType, false,		sysVRefNum, sysDirID);	IF retCode <> noErr THEN Fail('FindFolder', retCode);	retCode := FindFolder(kOnSystemDisk, kPreferencesFolderType, true,		prefVRefNum, prefDirID);	IF retCode <> noErr THEN Fail('FindFolder2', retCode);	{ make a FSSpec for the system folder }	retCode := FSMakeFSSpec(sysVRefNum, sysDirID, 'System', sysFSSpec);	IF retCode <> noErr THEN Fail('FSMakeFSSpec', retCode);			{ get a file to point the alias at }	StandardGetFile(nil, -1, @mySFTypeList, mySFR);		IF mySFR.sfGood THEN { got a file }		BEGIN			{ make an alias to the file relative to the system file }			retCode := NewAlias(@sysFSSpec, mySFR.sfFile, targetAliasHandle);			IF retCode <> noErr THEN Fail('NewAlias', retCode);						{ create the preferences file }			retCode := FSMakeFSSpec(prefVRefNum, prefDirID, 'My Alis Preference', fileFSSpec);			FSpCreateResFile(fileFSSpec, '????', 'pref', smRoman);			retCode := ResError;			IF retCode <> noErr THEN Fail('FSpCreateResFile', retCode);						{ add the alias to the preferences file }			myResRefNum := FSpOpenResFile(fileFSSpec, fsRdWrPerm);			IF myResRefNum = -1 THEN Fail('FSpOpenResFile', ResError);			AddResource(Handle(targetAliasHandle), rAliasType, 128,'');			WriteResource(Handle(targetAliasHandle));			CloseResFile(myResRefNum);			WriteLn('done');		END	ELSE { user clicked cancel, get the alias from preferences and resolve it }		BEGIN			{ open the preferences file and get the alias }			retCode := FSMakeFSSpec(prefVRefNum, prefDirID,			                        'My Alis Preference', fileFSSpec);			IF retCode <> noErr THEN Fail('FSMakeFSSpec', retCode);			myResRefNum := FSpOpenResFile(fileFSSpec, fsRdPerm);			IF myResRefNum = -1 THEN Fail('FSpOpenResFile', ResError);			targetAliasHandle := AliasHandle(GetResource(rAliasType, 128));			IF targetAliasHandle = NIL THEN Fail('GetResource', ResError);						{ resolve the alias relative to the system file }			retCode := ResolveAlias(@sysFSSpec, targetAliasHandle, resolvedFSSpec, changeFlag);			IF retCode <> noErr THEN Fail('ResolveAlias', retCode);						Write('resolves to: ');			PrintFSSpec(resolvedFSSpec);			CloseResFile(myResRefNum);		END;END.