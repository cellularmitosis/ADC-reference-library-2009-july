<html><head><title>Mac OS X
 Manual Page For XML::LibXML::Document(3pm)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3pm/XML::LibXML::Document" title="Mac OS X
 Manual Page for XML::LibXML::Document(3pm)"><a name="//apple_ref/doc/man/3/XML::LibXML::Document" title="Mac OS X
 Manual Page for XML::LibXML::Document(3pm)"><!-- headerDoc=man; indexgroup=Section 3pm; uid="//apple_ref/doc/man/3pm/XML::LibXML::Document"; name=XML::LibXML::Document(3pm) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
XML::LibXML::Document(3)             User Contributed Perl Documentation            XML::LibXML::Document(3)



<b>NAME</b>
       XML::LibXML::Document - XML::LibXML DOM Document Class

<b>SYNOPSIS</b>
         $dom = XML::LibXML::Document-&gt;new( $version, $encoding );
         $dom = XML::LibXML::Document-&gt;createDocument( $version, $encoding );
         $strEncoding = $doc-&gt;encoding();
         $doc-&gt;setEncoding($new_encoding);
         $strVersion = $doc-&gt;version();
         $doc-&gt;standalone
         $doc-&gt;setStandalone($numvalue);
         my $compression = $doc-&gt;compression;
         $doc-&gt;setCompression($ziplevel);
         $docstring = $dom-&gt;toString($format);
         $c14nstr = $doc-&gt;toStringC14N($comment_flag,$xpath);
         $str = $doc-&gt;serialze($format);
         $c14nstr = $doc-&gt;serialize_c14n($comment_flag,$xpath);
         $state = $doc-&gt;toFile($filename, $format);
         $state = $doc-&gt;toFH($fh, $format);
         $str = $document-&gt;toStringHTML();
         $str = $document-&gt;serialize_html();
         $bool = $dom-&gt;is_valid();
         $dom-&gt;validate();
         $root = $dom-&gt;documentElement();
         $dom-&gt;setDocumentElement( $root );
         $element = $dom-&gt;createElement( $nodename );
         $element = $dom-&gt;createElementNS( $namespaceURI, $qname );
         $text = $dom-&gt;createTextNode( $content_text );
         $comment = $dom-&gt;createComment( $comment_text );
         $attrnode = $doc-&gt;createAttribute($name [,$value]);
         $attrnode = $doc-&gt;createAttributeNS( namespaceURI, $name [,$value] );
         $fragment = $doc-&gt;createDocumentFragment();
         $cdata = $dom-&gt;create( $cdata_content );
         my $pi = $doc-&gt;createProcessingInstruction( $target, $data );
         my $entref = $doc-&gt;createEntityReference($refname);
         $dtd = $document-&gt;createInternalSubset( $rootnode, $public, $system);
         $dtd = $document-&gt;createExternalSubset( $rootnode, $public, $system);
         $document-&gt;importNode( $node );
         $document-&gt;adoptNode( $node );
         my $dtd = $doc-&gt;externalSubset;
         my $dtd = $doc-&gt;internalSubset;
         $doc-&gt;setExternalSubset($dtd);
         $doc-&gt;setInternalSubset($dtd);
         my $dtd = $doc-&gt;removeExternalSubset();
         my $dtd = $doc-&gt;removeInternalSubset();
         my @nodelist = $doc-&gt;getElementsByTagName($tagname);
         my @nodelist = $doc-&gt;getElementsByTagName($nsURI,$tagname);
         my @nodelist = $doc-&gt;getElementsByLocalName($localname);
         my $node = $doc-&gt;getElementById($id);
         $dom-&gt;indexElements();

<b>DESCRIPTION</b>
       The Document Class is in most cases the result of a parsing process. But sometimes it is necessary to
       create a Document from scratch. The DOM Document Class provides functions that conform to the DOM
       Core naming style.

       It inherits all functions from XML::LibXML::Node as specified in the DOM specification. This enables
       access to the nodes besides the root element on document level - a DTD for example. The support for
       these nodes is limited at the moment.

       While generaly nodes are bound to a document in the DOM concept it is suggested that one should
       always create a node not bound to any document. There is no need of really including the node to the
       document, but once the node is bound to a document, it is quite safe that all strings have the
       correct encoding. If an unbound textnode with an iso encoded string is created (e.g. with
       $CLASS-&gt;<u>new()</u>), the toString function may not return the expected result.

       All this seems like a limitation as long as UTF-8 encoding is assured. If iso encoded strings come
       into play it is much safer to use the node creation functions of XML::LibXML::Document.

       <b>new</b>
             $dom = XML::LibXML::Document-&gt;new( $version, $encoding );

           alias for <u>createDocument()</u>

       <b>createDocument</b>
             $dom = XML::LibXML::Document-&gt;createDocument( $version, $encoding );

           The constructor for the document class. As Parameter it takes the version string and (optionally)
           the encoding string. Simply calling <u>createDocument()</u> will create the document:

             &lt;?xml version="your version" encoding="your encoding"?&gt;

           Both parameter are optional. The default value for $version is 1.0, of course.  If the $encoding
           parameter is not set, the encoding will be left unset, which means UTF-8 is implied.

           The call of <u>createDocument()</u> without any parameter will result the following code:

             &lt;?xml version="1.0"?&gt;

           Alternatively one can call this constructor directly from the XML::LibXML class level, to avoid
           some typing. This will not have any effect on the class instance, which is always
           XML::LibXML::Document.

              my $document = XML::LibXML-&gt;createDocument( "1.0", "UTF-8" );

           is therefore a shortcut for

             my $document = XML::LibXML::Document-&gt;createDocument( "1.0", "UTF-8" );

       <b>encoding</b>
             $strEncoding = $doc-&gt;encoding();

           returns the encoding string of the document.

             my $doc = XML::LibXML-&gt;createDocument( "1.0", "ISO-8859-15" );
             print $doc-&gt;encoding; # prints ISO-8859-15

           Optionally this function can be accessed by actualEncoding or getEncoding.

       <b>setEncoding</b>
             $doc-&gt;setEncoding($new_encoding);

           From time to time it is useful to change the effective encoding of a document.  This method
           provides the interface to manipulate the encoding of a document.

           Note that this function has to be used very carefully, since you can't simply convert one
           encoding in any other, since some (or even all) characters may not exist in the new encoding.
           XML::LibXML will not test if the operation is allowed or possible for the given document. The
           only switching assured to work is to UTF-8.

       <b>version</b>
             $strVersion = $doc-&gt;version();

           returns the version string of the document

           <u>getVersion()</u> is an alternative form of this function.

       <b>standalone</b>
             $doc-&gt;standalone

           This function returns the Numerical value of a documents XML declarations standalone attribute.
           It returns 1 if standalone="yes" was found, 0 if standalone="no" was found and -1 if standalone
           was not specified (default on creation).

       <b>setStandalone</b>
             $doc-&gt;setStandalone($numvalue);

           Through this method it is possible to alter the value of a documents standalone attribute. Set it
           to 1 to set standalone="yes", to 0 to set standalone="no" or set it to -1 to remove the
           standalone attribute from the XML declaration.

       <b>compression</b>
             my $compression = $doc-&gt;compression;

           libxml2 allows reading of documents directly from gziped files. In this case the compression
           variable is set to the compression level of that file (0-8). If XML::LibXML parsed a different
           source or the file wasn't compressed, the returned value will be -1.

       <b>setCompression</b>
             $doc-&gt;setCompression($ziplevel);

           If one intends to write the document directly to a file, it is possible to set the compression
           level for a given document. This level can be in the range from 0 to 8. If XML::LibXML should not
           try to compress use -1 (default).

           Note that this feature will only work if libxml2 is compiled with zlib support and <u>toFile()</u> is
           used for output.

       <b>toString</b>
             $docstring = $dom-&gt;toString($format);

           toString is a deparsing function, so the DOM Tree can be translated into a string, ready for
           output.

           The optional $format parameter sets the indenting of the output. This parameter is expected to be
           an integer value, that specifies that indentation should be used. The format parameter can have
           three different values if it is used:

           If $format is 0, than the document is dumped as it was originally parsed

           If $format is 1, libxml2 will add ignorable whitespaces, so the nodes content is easier to read.
           Existing text nodes will not be altered

           If $format is 2 (or higher), libxml2 will act as $format == 1 but it add a leading and a trailing
           linebreak to each text node.

           libxml2 uses a hardcoded indentation of 2 space characters per indentation level. This value can
           not be altered on runtime.

           NOTE: XML::LibXML::Document::toString returns the data in the document encoding rather than
           UTF-8! If you want UTF-8 ecoded XML, you have to change the conding by using <u>setEncoding()</u>

       <b>toStringC14N</b>
           $c14nstr = $doc-&gt;toStringC14N($comment_flag,$xpath); A variation to toString, that returns the
           canonized form of the given document.

       <b>serialize</b>
             $str = $doc-&gt;serialze($format);

           Alternative form of <u>toString()</u>. This function name added to be more conformant with libxml2's
           examples.

       <b>serialize_c14n</b>
             $c14nstr = $doc-&gt;serialize_c14n($comment_flag,$xpath);

           Alternative form of <u>toStringC14N()</u>.

       <b>toFile</b>
             $state = $doc-&gt;toFile($filename, $format);

           This function is similar to <u>toString()</u>, but it writes the document directly into a filesystem.
           This function is very useful, if one needs to store large documents.

           The format parameter has the same behaviour as in <u>toString()</u>.

       <b>toFH</b>
             $state = $doc-&gt;toFH($fh, $format);

           This function is similar to <u>toString()</u>, but it writes the document directly to a filehandler or a
           stream.

           The format parameter has the same behaviour as in <u>toString()</u>.

       <b>toStringHTML</b>
             $str = $document-&gt;toStringHTML();

           toStringHTML deparses the tree to a string as HTML. With this method indenting is automatic and
           managed by libxml2 internally.

       <b>serialize_html</b>
             $str = $document-&gt;serialize_html();

           Alternative form of <u>toStringHTML()</u>.

       <b>is_valid</b>
             $bool = $dom-&gt;is_valid();

           Returns either TRUE or FALSE depending on whether the DOM Tree is a valid Document or not.

           You may also pass in a XML::LibXML::Dtd object, to validate against an external DTD:

              if (!$dom-&gt;is_valid($dtd)) {
                  warn("document is not valid!");
              }

       <b>validate</b>
             $dom-&gt;validate();

           This is an exception throwing equivalent of is_valid. If the document is not valid it will throw
           an exception containing the error. This allows you much better error reporting than simply
           is_valid or not.

           Again, you may pass in a DTD object

       <b>documentElement</b>
             $root = $dom-&gt;documentElement();

           Returns the root element of the Document. A document can have just one root element to contain
           the documents data.

           Optionaly one can use getDocumentElement.

       <b>setDocumentElement</b>
             $dom-&gt;setDocumentElement( $root );

           This function enables you to set the root element for a document. The function supports the
           import of a node from a different document tree.

       <b>createElement</b>
             $element = $dom-&gt;createElement( $nodename );

           This function creates a new Element Node bound to the DOM with the name $nodename.

       <b>createElementNS</b>
             $element = $dom-&gt;createElementNS( $namespaceURI, $qname );

           This function creates a new Element Node bound to the DOM with the name $nodename and placed in
           the given namespace.

       <b>createTextNode</b>
             $text = $dom-&gt;createTextNode( $content_text );

           As an equivalent of createElement, but it creates a Text Node bound to the DOM.

       <b>createComment</b>
             $comment = $dom-&gt;createComment( $comment_text );

           As an equivalent of createElement, but it creates a Comment Node bound to the DOM.

       <b>createAttribute</b>
             $attrnode = $doc-&gt;createAttribute($name [,$value]);

           Creates a new Attribute node.

       <b>createAttributeNS</b>
             $attrnode = $doc-&gt;createAttributeNS( namespaceURI, $name [,$value] );

           Creates an Attribute bound to a namespace.

       <b>createDocumentFragment</b>
             $fragment = $doc-&gt;createDocumentFragment();

           This function creates a DocumentFragment.

       <b>createCDATASection</b>
             $cdata = $dom-&gt;create( $cdata_content );

           Similar to createTextNode and createComment, this function creates a CDataSection bound to the
           current DOM.

       <b>createProcessingInstruction</b>
             my $pi = $doc-&gt;createProcessingInstruction( $target, $data );

           create a processing instruction node.

           Since this method is quite long one may use its short form <u>createPI()</u>.

       <b>createEntityReference</b>
             my $entref = $doc-&gt;createEntityReference($refname);

           If a document has a DTD specified, one can create entity references by using this function. If
           one wants to add a entity reference to the document, this reference has to be created by this
           function.

           An entity reference is unique to a document and cannot be passed to other documents as other
           nodes can be passed.

           NOTE: A text content containing something that looks like an entity reference, will not be
           expanded to a real entity reference unless it is a predefined entity

              my $string = "&amp;foo;";
              $some_element-&gt;appendText( $string );
              print $some_element-&gt;textContent; # prints "&amp;amp;foo;"

       <b>createInternalSubset</b>
             $dtd = $document-&gt;createInternalSubset( $rootnode, $public, $system);

           This function creates and adds an internal subset to the given document.  Because the function
           automaticly adds the DTD to the document there is no need to add the created node explicitly to
           the document.

              my $document = XML::LibXML::Document-&gt;new();
              my $dtd      = $document-&gt;createInternalSubset( "foo", undef, "foo.dtd" );

           will result in the following XML document:

             &lt;?xml version="1.0"?&gt;
              &lt;!DOCTYPE foo SYSTEM "foo.dtd"&gt;

           By setting the public parameter it is possible to set PUBLIC dtds to a given document. So

             my $document = XML::LibXML::Document-&gt;new();
             my $dtd      = $document-&gt;createInternalSubset( "foo", "-//FOO//DTD FOO 0.1//EN", undef );

           will cause the following declaration to be created on the document:

             &lt;?xml version="1.0"?&gt;
             &lt;!DOCTYPE foo PUBLIC "-//FOO//DTD FOO 0.1//EN"&gt;

       <b>createExternalSubset</b>
             $dtd = $document-&gt;createExternalSubset( $rootnode, $public, $system);

           This function is similar to <u>createInternalSubset()</u> but this DTD is considered to be external and
           is therefore not added to the document itself. Nevertheless it can be used for validation
           purposes.

       <b>importNode</b>
             $document-&gt;importNode( $node );

           If a node is not part of a document, it can be imported to another document. As specified in DOM
           Level 2 Specification the Node will not be altered or removed from its original document
           ($node-&gt;<u>cloneNode</u>(1) will get called implicitly).

           NOTE: Don't try to use <u>importNode()</u> to import subtrees that contain an entity reference - even if
           the entity reference is the root node of the subtree. This will cause serious problems to your
           program. This is a limitation of libxml2 and not of XML::LibXML itself.

       <b>adoptNode</b>
             $document-&gt;adoptNode( $node );

           If a node is not part of a document, it can be imported to another document. As specified in DOM
           Level 3 Specification the Node will not be altered but it will removed from its original
           document.

           After a document adopted a node, the node, its attributes and all its descendants belong to the
           new document. Because the node does not belong to the old document, it will be unlinked from its
           old location first.

           NOTE: Don't try to <u>adoptNode()</u> to import subtrees that contain entity references - even if the
           entity reference is the root node of the subtree. This will cause serious problems to your
           program. This is a limitation of libxml2 and not of XML::LibXML itself.

       <b>externalSubset</b>
             my $dtd = $doc-&gt;externalSubset;

           If a document has an external subset defined it will be returned by this function.

           NOTE Dtd nodes are no ordinary nodes in libxml2. The support for these nodes in XML::LibXML is
           still limited. In particular one may not want use common node function on doctype declaration
           nodes!

       <b>internalSubset</b>
             my $dtd = $doc-&gt;internalSubset;

           If a document has an internal subset defined it will be returned by this function.

           NOTE Dtd nodes are no ordinary nodes in libxml2. The support for these nodes in XML::LibXML is
           still limited. In particular one may not want use common node function on doctype declaration
           nodes!

       <b>setExternalSubset</b>
             $doc-&gt;setExternalSubset($dtd);

           EXPERIMENTAL!

           This method sets a DTD node as an external subset of the given document.

       <b>setInternalSubset</b>
             $doc-&gt;setInternalSubset($dtd);

           EXPERIMENTAL!

           This method sets a DTD node as an internal subset of the given document.

       <b>removeExternalSubset</b>
             my $dtd = $doc-&gt;removeExternalSubset();

           EXPERIMENTAL!

           If a document has an external subset defined it can be removed from the document by using this
           function. The removed dtd node will be returned.

       <b>removeInternalSubset</b>
             my $dtd = $doc-&gt;removeInternalSubset();

           EXPERIMENTAL!

           If a document has an internal subset defined it can be removed from the document by using this
           function. The removed dtd node will be returned.

       <b>getElementsByTagName</b>
             my @nodelist = $doc-&gt;getElementsByTagName($tagname);

           Implements the DOM Level 2 function

           In SCALAR context this function returns a XML::LibXML::NodeList object.

       <b>getElementsByTagNameNS</b>
             my @nodelist = $doc-&gt;getElementsByTagName($nsURI,$tagname);

           Implements the DOM Level 2 function

           In SCALAR context this function returns a XML::LibXML::NodeList object.

       <b>getElementsByLocalName</b>
             my @nodelist = $doc-&gt;getElementsByLocalName($localname);

           This allows the fetching of all nodes from a given document with the given Localname.

           In SCALAR context this function returns a XML::LibXML::NodeList object.

       <b>getElementById</b>
             my $node = $doc-&gt;getElementById($id);

           Returns the element that has an ID attribute with the given value. If no such element exists,
           this returns undef.

           Note: the ID of an element may change while manipulating the document. For documents with a DTD,
           the information about ID attributes is only available if DTD loading/validation has been
           requested. For HTML documents parsed with the HTML parser ID detection is done automatically. In
           XML documents, all "xml:id" attributes are considered to be of type ID. You can test ID-ness of
           an attribute node with $attr-&gt;<u>isId()</u>.

           In versions 1.59 and earlier this method was called <u>getElementsById()</u> (plural) by mistake.
           Starting from 1.60 this name is maintained as an alias only for backward compatibility.

       <b>indexElements</b>
             $dom-&gt;indexElements();

           This function causes libxml2 to stamp all elements in a document with their document position
           index which considerably speeds up XPath queries for large documents. It should only be used with
           static documents that won't be further changed by any DOM methods, because once a document is
           indexed, XPath will always prefer the index to other methods of determining the document order of
           nodes. XPath could therefore return improperly ordered node-lists when applied on a document that
           has been changed after being indexed. It is of course possible to use this method to re-index a
           modified document before using it with XPath again. This function is not a part of the DOM
           specification.

           This function returns number of elements indexed, -1 if error occurred, or -2 if this feature is
           not available in the running libxml2.

<b>AUTHORS</b>
       Matt Sergeant, Christian Glahn, Petr Pajas,

<b>VERSION</b>
       1.60

<b>COPYRIGHT</b>
       2001-2006, AxKit.com Ltd; 2002-2006 Christian Glahn; 2006 Petr Pajas, All rights reserved.



perl v5.8.8                                      2006-08-26                         XML::LibXML::Document(3)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/XML__LibXML__Document.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/XML__LibXML__Document.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/XML__LibXML__Document.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
