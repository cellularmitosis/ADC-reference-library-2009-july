<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>NetSprocketTestOld - /NetStuff.cp</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGames-date.html">Games</a> &gt; <A HREF="javascript:location.replace('index.html');">NetSprocketTestOld</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Games/index.html" target="_blank">Reference Library > Games</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">NetSprocketTestOld</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/NetStuff.cp</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/aevt.c</option>
<option value="listing2.html">/App.h</option>
<option value="listing3.html">/events.c</option>
<option value="listing4.html">/Global.h</option>
<option value="listing5.html">/init.c</option>
<option value="listing6.html">/main.c</option>
<option value="listing7.html">/NetStuff.cp</option>
<option value="listing8.html">/NetStuff.h</option>
<option value="listing9.html">/Proto.h</option>
<option value="listing10.html">/windows.c</option></select>
				</p>
				</form>
				<p><strong><a href="NetSprocketTestOld.zip">Download Sample</a></strong> (&#147;NetSprocketTestOld.zip&#148;, 54.3K)<BR>
<strong><a href="NetSprocketTestOld.dmg">Download Sample</a></strong> (&#147;NetSprocketTestOld.dmg&#148;, 112.4K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    NetStuff.cp  Contains:  xxx put contents here xxx  Version:  xxx put version here xxx  Copyright:  &copy; 1999 by Apple Computer, Inc., all rights reserved.  File Ownership:    DRI:        xxx put dri here xxx    Other Contact:    xxx put other contact here xxx    Technology:      xxx put technology here xxx  Writers:    (cjd)  Chris De Salvo  Change History (most recent first):     &lt;SP8&gt;    3/9/99  cjd    Added new enumerations depending on whether you're the client or                  the host.*///*  ------------------------------------------------------------------------------------------  *//*//*  Copyright &copy; 1996, 1997 Apple Computer, Inc., All Rights Reserved//*//*//*    You may incorporate this sample code into your applications without//*    restriction, though the sample code has been provided &quot;AS IS&quot; and the//*    responsibility for its operation is 100% yours.  However, what you are//*    not permitted to do is to redistribute the source as &quot;DSC Sample Code&quot;//*    after having made changes. If you're going to re-distribute the source,//*    we require that you make it clear in the source that the code was//*    descended from Apple Sample Code, but that you've made changes.//*//*    Authors://*      Jamie Osborne//*      Chris De Salvo//*//*  ------------------------------------------------------------------------------------------  *//*  ------------------------------  Includes#include &lt;Fonts.h&gt;#include &lt;MacWindows.h&gt;#include &lt;Menus.h&gt;#include &lt;OpenTptInternet.h&gt;#include &lt;Resources.h&gt;#include &lt;TextUtils.h&gt;#include &quot;NetStuff.h&quot;#include &lt;PLStringFuncs.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;//*  ------------------------------  Private Definitions//*  If this is set to 1 then the player enumeration menu item iterates by calling NSpPlayer_GetInfo//*  rather than using the data in the PlayerEnumeration data structure.  This is merely for coverage//*  testing of the GetInfo call on the client side.#define USE_PLAYER_GET_INFO      1//*  ------------------------------  Private Typesenum{  kStandardMessageSize  = 1500,  kBufferSize        = 0,   kQElements        = 0,  kTimeout        = 5000,  kMaxPlayers        = 8};//*  ------------------------------  Private Variablesstatic Str31        gameName;static Str31        password;static Str31        playerName;static Str31        kJoinDialogLabel = &quot;\pChoose a Game:&quot;;static Boolean        gInCallback = false;static UInt32        gLastUpdate = 0;static UInt32        gUpdateFrequency = 2;static PlayerInputMessage  gPlayerMessage;static UInt32        gPlayerMessageSize = 400;static GameStateMessage    gGameStateMessage;static UInt32        gGameStateMessageSize = 1024;static UInt32        gSendOptions = kNSpSendFlag_Normal;static UInt32        gHostSendOptions = kNSpSendFlag_Registered | kNSpSendFlag_SelfSend;static MenuHandle      gHostMenuH;static UInt32        gHostUpdateFrequency = 2;static UInt32        gLastHostUpdate = 0;static WindowStuff      gWindowStuff[8];static NSpPlayerID      gMyPlayerID = 0;static Str255        gContextString = &quot;\pNetSprocket Test Context!!&quot;;//*  ------------------------------  Private Functionsstatic WindowStuff *GetFreeWindowStuff(void);static void ReleaseWindowStuff(WindowStuff *inStuff);static WindowStuff *GetPlayersWindowStuff(NSpPlayerID inPlayer);static WindowPtr FindPlayersWindow(NSpPlayerID inPlayer);static void InvalPlayerWindow(NSpPlayerID inPlayer);static pascal Boolean MessageHandler(NSpGameReference inGameRef, NSpMessageHeader *inMessage, void *inContext);static void InitNetMenu(MenuHandle menu);static void GetChooserName(Str255 name);static void CloseAllWindows(void);static void AddHostMenu(void);static void DoAdjustMenu(MenuRef m, UInt32 options, UInt32 updateFrequency, UInt32 messageSize);static void DoSendLeaveMessage(NSpPlayerID inID);static void DoHandleMessage(NSpMessageHeader *inMessage);static void GetMessages(void);static void UpdateNetWindows(void);static void GetInfoEnumeratePlayers(void);static void EnumeratePlayers(void);//*  ------------------------------  Public VariablesBoolean       gHost = false;NSpGameReference  gNetGame = nil;//*  --------------------  GetFreeWindowStuff// this is not reentrantstatic WindowStuff *GetFreeWindowStuff(void){  for (int i = 0; i &lt; 8; i++)  {    if (gWindowStuff[i].id == 0)      return &amp;gWindowStuff[i];  }    return nil;}//*  --------------------  ReleaseWindowStuffstatic voidReleaseWindowStuff(WindowStuff *inStuff){  if (inStuff == nil)    printf(&quot;passed in nill stuff pointer!\n&quot;);  else    memset(inStuff, 0, sizeof(WindowStuff));}//*  --------------------  GetPlayersWindowStuffstatic WindowStuff *GetPlayersWindowStuff(NSpPlayerID inPlayer){  for (int i = 0; i &lt; 8; i++)  {    if (gWindowStuff[i].id == inPlayer)      return &amp;gWindowStuff[i];  }    return nil;}//*  --------------------  FindPlayersWindow//*//*    Finds the window associated with the given playerstatic WindowPtrFindPlayersWindow(NSpPlayerID inPlayer){  WindowPtr  w;  WindowStuff *stuff;  w = FrontWindow();  while (w != nil)  {    stuff = (WindowStuff *) GetWRefCon(w);      if (stuff-&gt;id == inPlayer)      break;    else      w = GetNextWindow(w);  }    return w;}//*  --------------------  InvalPlayerWindowstatic voidInvalPlayerWindow(NSpPlayerID inPlayer){WindowPtr  w = FindPlayersWindow(inPlayer);  if (w)  {  GrafPtr    oldPort;      GetPort(&amp;oldPort);    SetPort(w);    InvalRect(&amp;w-&gt;portRect);    SetPort(oldPort);  }}//*  --------------------  MessageHandler//*//*  this function gets called every time NetSprocket receives a new message.//*  we use it to prevent our message q from getting too full if we don't idle enough//*  a good example is when the user has clicked in the menu bar and is reading menusstatic pascal BooleanMessageHandler(NSpGameReference inGameRef, NSpMessageHeader *inMessage, void *inContext){  gInCallback = true;//  if it's a system message, just leave it in the q, so that we can handle it later (when we're//  not at interrupt time)  if (inMessage-&gt;what &amp; kNSpSystemMessagePrefix)    return true;  // tells NetSprocket to put the message in the message Q  else  // it's one of ours  {    if (inMessage-&gt;what == kPlayerInputMessage &amp;&amp; gHost)    {            WindowStuff *stuff = GetPlayersWindowStuff(inMessage-&gt;from);      if (stuff)      {        stuff-&gt;lastMessage = inMessage-&gt;id;        stuff-&gt;changed = true;      }              return false;    }    else if (inMessage-&gt;what == kGameStateMessage &amp;&amp; !gHost)    {      WindowStuff *stuff = GetPlayersWindowStuff(gMyPlayerID);      if (stuff)      {        stuff-&gt;lastMessage = inMessage-&gt;id;        stuff-&gt;changed = true;      }              return false;    }  }  gInCallback = false;  //*  If it's some state we haven't considered then better leave it in the queue  return (true);}//*  --------------------  GetChooserNamestatic voidGetChooserName(Str255 name){StringHandle  userName;    userName = GetString(-16096);  if (userName == nil)  {    name[0] = 0;  }  else  {      PLstrcpy(name, *userName);    ReleaseResource ((Handle) userName);  }}//*  --------------------  RefreshWindowvoidRefreshWindow(WindowPtr inWindow){  WindowStuff *stuff = (WindowStuff *) GetWRefCon(inWindow);    if (stuff-&gt;lastMessage != 0)    NumToString(stuff-&gt;lastMessage, stuff-&gt;text);  EraseRect(&amp;inWindow-&gt;portRect);    MoveTo(20,20);  DrawString(stuff-&gt;text);  }//*  --------------------  InitNetMenustatic voidInitNetMenu(MenuHandle menu){  SetItemMark(menu, iJunk, noMark);  SetItemMark(menu, iNormal, noMark);  SetItemMark(menu, iRegistered, noMark);  SetItemMark(menu, iBlocking, noMark);  SetItemMark(menu, i1X, noMark);  SetItemMark(menu, i10X, noMark);  SetItemMark(menu, i30X, noMark);  SetItemMark(menu, iNoLimit, noMark);  SetItemMark(menu, iLess500, noMark);  SetItemMark(menu, i1K, noMark);  SetItemMark(menu, i10K, noMark);  SetItemMark(menu, i100K, noMark);}//*  --------------------  InitNetworkingOSStatusInitNetworking(NSpGameID inGameID){  OSStatus  status;    printf(&quot;Initializing NetSprocket... &quot;);  memset(gWindowStuff, 0, sizeof(WindowStuff) * 8);  status = NSpInitialize(kStandardMessageSize, kBufferSize, kQElements, inGameID, kTimeout);  if (status != noErr)    printf(&quot;NSpInitialize returned error %d\n&quot;, status);  else    printf(&quot;Done\n&quot;);    //  Install an async message handler.  We do this so that we won't get hosed if we//  don't call HandleNetworking often enough (such as a tight loop for mouse-down  status = NSpInstallAsyncMessageHandler(MessageHandler, gContextString);  if (status != noErr)    printf(&quot;NSpInstallAsyncMessageHandler returned error %d\n&quot;, status);    MenuHandle h = GetMenuHandle(131);  if (h)    InitNetMenu(h);    return status;}//*  --------------------  CloseAllWindowsstatic voidCloseAllWindows(void){WindowPtr  w, nextWind;  w = FrontWindow();  while (w != nil)  {    nextWind = GetNextWindow(w);    WindowStuff *stuff = (WindowStuff *) GetWRefCon(w);    if (stuff)    {      DisposePtr((Ptr) stuff);      DisposeWindow(w);    }        w = nextWind;  }}//*  --------------------  ShutdownNetworkingvoidShutdownNetworking(void){OSStatus  status;    if (gNetGame)  {    status = NSpGame_Dispose( gNetGame, 0 );    if (status != noErr)    {      printf(&quot;NSpGame_Dispose returned error %d\n&quot;, status);//      I REALLY want it to shutdown      status = NSpGame_Dispose( gNetGame, kNSpGameFlag_ForceTerminateGame );        if (status != noErr)        printf(&quot;NSpGame_Dispose (force) returned error %d\n&quot;, status);    }        if (gHost)    {      DeleteMenu(132);      ReleaseResource((Handle) gHostMenuH);      DrawMenuBar();    }    gNetGame = NULL;  }//  if there are any windows left, kill them  CloseAllWindows();}//*  --------------------  AddHostMenustatic voidAddHostMenu(void){  gHostMenuH = GetMenu(132);  if (gHostMenuH == nil)    DebugStr(&quot;\pCouldn't find menu resource!&quot;);  else    InsertMenu(gHostMenuH, 0);      InitNetMenu(gHostMenuH);    DrawMenuBar();}//*  --------------------  HandleNetMenuChoicevoidHandleNetMenuChoice(short menu, short item){  MenuHandle h = GetMenuHandle(menu);  UInt32 *options;  UInt32 *frequency;  UInt32 *size;  if (menu == 132)  // host menu  {    options = &amp;gHostSendOptions;    frequency = &amp;gHostUpdateFrequency;    size = &amp;gGameStateMessageSize;  }  else  {    options = &amp;gSendOptions;    frequency = &amp;gUpdateFrequency;    size = &amp;gPlayerMessageSize;  }          switch(item)  {    case iJunk:      *options &amp;= 0xFF0FFFFF;      *options |= kNSpSendFlag_Junk;    break;    case iNormal:      *options &amp;= 0xFF0FFFFF;      *options |= kNSpSendFlag_Normal;    break;    case iRegistered:      *options &amp;= 0xFF0FFFFF;      *options |= kNSpSendFlag_Registered;    break;    case iBlocking:      if (*options &amp; kNSpSendFlag_Blocking)        *options &amp;= ~kNSpSendFlag_Blocking;      else        *options |= kNSpSendFlag_Blocking;    break;    case i1X:      *frequency = 60;      break;          case i10X:      *frequency = 6;      break;          case i30X:      *frequency = 2;      break;          case iNoLimit:      *frequency = 0;      break;          case iLess500:      *size = 400;      break;          case i1K:      *size = 1024;      break;          case i10K:      *size = 10240;      break;          case i100K:      *size = 102400;      break;          case iEnumerate:#if USE_PLAYER_GET_INFO      if (131 != menu)        GetInfoEnumeratePlayers();      else#endif        EnumeratePlayers();      break;          default:    break;  }  }//*  --------------------  DoAdjustMenustatic voidDoAdjustMenu(MenuRef m, UInt32 options, UInt32 updateFrequency, UInt32 messageSize){  if (options &amp; kNSpSendFlag_Junk)    SetItemMark(m, iJunk, checkMark);  else    SetItemMark(m, iJunk, noMark);  if (options &amp; kNSpSendFlag_Normal)    SetItemMark(m, iNormal, checkMark);  else    SetItemMark(m, iNormal, noMark);  if (options &amp; kNSpSendFlag_Registered)    SetItemMark(m, iRegistered, checkMark);  else    SetItemMark(m, iRegistered, noMark);      if (options &amp; kNSpSendFlag_Blocking)    SetItemMark(m, iBlocking, checkMark);  else    SetItemMark(m, iBlocking, noMark);      SetItemMark(m, i1X, noMark);  SetItemMark(m, i10X, noMark);  SetItemMark(m, i30X, noMark);  SetItemMark(m, iNoLimit, noMark);  switch(updateFrequency)  {    case 60:      SetItemMark(m, i1X, checkMark);    break;    case 6:      SetItemMark(m, i10X, checkMark);    break;    case 2:      SetItemMark(m, i30X, checkMark);    break;    default:      SetItemMark(m, iNoLimit, checkMark);    break;  }  SetItemMark(m, iLess500, noMark);  SetItemMark(m, i1K, noMark);  SetItemMark(m, i10K, noMark);  SetItemMark(m, i100K, noMark);  switch(messageSize)  {    case 400:      SetItemMark(m, iLess500, checkMark);    break;    case 1024:      SetItemMark(m, i1K, checkMark);    break;    case 10240:      SetItemMark(m, i10K, checkMark);    break;    case 102400:      SetItemMark(m, i100K, checkMark);    break;  }  }  //*  --------------------  AdjustNetMenusvoidAdjustNetMenus(void){  MenuRef m = GetMenu(131);    DoAdjustMenu(m, gSendOptions, gUpdateFrequency, gPlayerMessageSize);  if (gHost)  {    m = GetMenu(132);    if (m)      DoAdjustMenu(m, gHostSendOptions, gHostUpdateFrequency, gGameStateMessageSize);  }}//*  --------------------  DoHostOSStatusDoHost(void){  OSStatus   status;  Str255    chooserName;  NSpProtocolListReference  theList = NULL;  Boolean okHit;  //  Create an empty protocol list  status = NSpProtocolList_New(NULL, &amp;theList);  if (status != noErr)  {    printf(&quot;NSpProtocolList_New returned error: %d\n&quot;, status);    goto failure;  }  //  Now present a UI for the hosting//  Note!  Do NOT pass in string constants, as the user can change these values  GetChooserName(chooserName);  PLstrncpy(playerName, chooserName, 31);    PLstrcpy(gameName, &quot;\pNetSprocket Test&quot;);  password[0] = 0;    okHit = NSpDoModalHostDialog(theList, gameName, playerName, password, nil);  if (!okHit)  {    status = kUserCancelled;    goto failure;  }  //  Now host the game  status = NSpGame_Host(&amp;gNetGame, theList, kMaxPlayers, gameName,        password, playerName, 0, kNSpClientServer, 0);  if (status != noErr)  {    printf(&quot;NSpGame_Host returned error %d\n&quot;, status);    goto failure;  }    gHost = true;      if (status == noErr)    AddHostMenu();      return status;  failure:  if (theList != nil)    NSpProtocolList_Dispose(theList);      return status;}//*  --------------------  DoJoinOSStatusDoJoin(void){  NSpAddressReference  theAddress;  OSStatus      status;  Str255        chooserName;    GetChooserName(chooserName);  PLstrncpy(playerName, chooserName, 31);    password[0] = 0;  //  Present the UI for joining a game//  passing an empty string (not nil) for the type causes NetSprocket to use//  the game id passed in to initialize  theAddress = NSpDoModalJoinDialog(&quot;\p&quot;, kJoinDialogLabel, playerName, password, NULL);  if (theAddress == NULL)    // The user cancelled    return kUserCancelled;      status = NSpGame_Join(&amp;gNetGame, theAddress, playerName, password, 0, NULL, 0, 0);  if (status != noErr)    printf(&quot;NSpGame_Join returned error %d\n&quot;, status);  else        gHost = false;    return status;}//*  --------------------  DoSendLeaveMessagestatic voidDoSendLeaveMessage(NSpPlayerID inID){NSpMessageHeader m;OSStatus status;    NSpClearMessageHeader(&amp;m);    m.what = kLeaveMessage;  m.to = inID;  m.messageLen = sizeof(NSpMessageHeader);  status = NSpMessage_Send(gNetGame, &amp;m, kNSpSendFlag_Registered);}//*  --------------------  DoCloseNetWindowvoidDoCloseNetWindow(WindowPtr inWindow){  if (gHost)  {    WindowStuff *stuff = (WindowStuff *) GetWRefCon(inWindow);      DoSendLeaveMessage(stuff-&gt;id);  }  else    ShutdownNetworking();  }//*  --------------------  DoHandleMessagestatic voidDoHandleMessage(NSpMessageHeader *inMessage){  switch (inMessage-&gt;what)  {    case kLeaveMessage:      printf(&quot;Got a message telling us to leave the game.&quot;);      ShutdownNetworking();    break;    case kNSpPlayerJoined:    {      NSpPlayerJoinedMessage *theMessage = (NSpPlayerJoinedMessage *) inMessage;      printf(&quot;Got player joined message: %d\n&quot;, theMessage-&gt;playerInfo.id);      if (gHost || theMessage-&gt;playerInfo.id == NSpPlayer_GetMyID(gNetGame))      {        gMyPlayerID = NSpPlayer_GetMyID(gNetGame);        WindowPtr wind = GetNewCWindow(128, nil, (WindowPtr) -1L);        if (!wind)          printf(&quot;Failed to create a new window!\n&quot;);        else        {          WindowStuff *stuff = GetFreeWindowStuff();          if (stuff == nil)          {            printf(&quot;Couldn't alloc memory to show window.\n&quot;);            DisposeWindow(wind);          }          else          {            stuff-&gt;id = theMessage-&gt;playerInfo.id;            stuff-&gt;lastMessage = 0;            PLstrcpy(stuff-&gt;text, &quot;\pNew Player&quot;);                        SetWTitle(wind,theMessage-&gt;playerInfo.name);            SetWRefCon(wind, (long) stuff);            InvalPlayerWindow(stuff-&gt;id);          }        }      }    }      break;          case kNSpPlayerLeft:    {    char  name[32];          NSpPlayerLeftMessage *theMessage = (NSpPlayerLeftMessage *) inMessage;      BlockMoveData(theMessage-&gt;playerName + 1, name, theMessage-&gt;playerName[0]);      name[theMessage-&gt;playerName[0]] = '\0';            printf(&quot;Got player left message: %s, player #%d\n&quot;, name, theMessage-&gt;playerID);            if (gHost)      {        WindowPtr w = FindPlayersWindow(theMessage-&gt;playerID);        if (w)        {          WindowStuff *stuff = (WindowStuff *) GetWRefCon(w);          ReleaseWindowStuff(stuff);          DisposeWindow(w);        }        else          printf(&quot;Didn't find the window for the player that left!!\n&quot;);      }      }    break;    case kNSpGameTerminated:      printf(&quot;Got Game terminated message\n&quot;);      ShutdownNetworking();    break;                default:      break;  }}//*  --------------------  GetMessagesstatic voidGetMessages(void){  NSpMessageHeader  *theMessage;    do   {    theMessage = NSpMessage_Get(gNetGame);    DoHandleMessage(theMessage);    NSpMessage_Release(gNetGame, theMessage);  } while (gNetGame &amp;&amp; theMessage != NULL);  }//*  --------------------  UpdateNetWindowsstatic voidUpdateNetWindows(void){WindowPtr  w;  w = FrontWindow();  while (w != nil)  {    WindowStuff *stuff = (WindowStuff *) GetWRefCon(w);    if (stuff &amp;&amp; stuff-&gt;changed)    {      GrafPtr    oldPort;          GetPort(&amp;oldPort);      SetPort(w);      RefreshWindow(w);      SetPort(oldPort);            stuff-&gt;changed = false;    }    w = GetNextWindow(w);      }}//*  --------------------  HandleNetworkvoidHandleNetwork(void){OSStatus  status;  if (!gNetGame)    return;  GetMessages();//  update any windows as necessary  UpdateNetWindows();    UInt32 time = TickCount();    if (gNetGame &amp;&amp; time &gt; gLastUpdate + gUpdateFrequency)  {    NSpClearMessageHeader(&amp;gPlayerMessage.h);    gPlayerMessage.h.what = kPlayerInputMessage;    gPlayerMessage.h.to = kNSpHostOnly;    gPlayerMessage.h.messageLen = gPlayerMessageSize;//    Send my info to the host    status = NSpMessage_Send(gNetGame, &amp;gPlayerMessage.h, gSendOptions);    if (status != noErr)      printf(&quot;NSpMessage_Send returned error: %d\n&quot;, status);        if (gHost &amp;&amp; time &gt; gLastHostUpdate + gHostUpdateFrequency)    {      NSpClearMessageHeader(&amp;gGameStateMessage.h);      gGameStateMessage.h.what = kGameStateMessage;      gGameStateMessage.h.to = kNSpAllPlayers;      gGameStateMessage.h.messageLen = gGameStateMessageSize;  //    Send my info to the host      status = NSpMessage_Send(gNetGame, &amp;gGameStateMessage.h, gHostSendOptions);      if (status != noErr)        printf(&quot;NSpMessage_Send returned error: %d\n&quot;, status);            gLastHostUpdate = time;    }    gLastUpdate = time;  }    }//*  --------------------  GetInfoEnumeratePlayersstatic voidGetInfoEnumeratePlayers(void){OSStatus        theErr;NSpPlayerEnumerationPtr  thePlayers;UInt32          i;  if (nil == gNetGame)  {    printf(&quot;gNetGame is nil.\n&quot;);    return;  }  theErr = NSpPlayer_GetEnumeration(gNetGame,  &amp;thePlayers);  if (noErr != theErr)  {    printf(&quot;NSpPlayer_GetEnumeration returned %ld\n&quot;, theErr);    return;  }    printf(&quot;PlayerID    IP Address         Name\n&quot;);  printf(&quot;--------    ---------------    ----------------\n&quot;);  for (i = 0; i &lt; thePlayers-&gt;count; i++)  {  char        name[sizeof (NSpPlayerName)];  NSpPlayerInfoPtr  thePlayer;  OTAddress      *address;  OSStatus      theErr;      NSpPlayer_GetInfo(gNetGame, thePlayers-&gt;playerInfo[i]-&gt;id, &amp;thePlayer);      BlockMoveData(thePlayer-&gt;name + 1, name, thePlayer-&gt;name[0]);    name[thePlayer-&gt;name[0]] = '\0';    printf(&quot;%0.8ld    &quot;, thePlayer-&gt;id);    theErr = NSpPlayer_GetAddress(gNetGame, thePlayer-&gt;id, &amp;address);        if ((noErr != theErr) || (NULL == address))    {      printf(&quot;Error %9ld&quot;, theErr);    }    else    {      if (AF_INET == address-&gt;fAddressType)      {      InetAddress  *ip;        ip = (InetAddress *) address;                printf(&quot;%3d.%3d.%3d.%3d&quot;,          (ip-&gt;fHost &amp; 0xFF000000) &gt;&gt; 24,          (ip-&gt;fHost &amp; 0x00FF0000) &gt;&gt; 16,          (ip-&gt;fHost &amp; 0x0000FF00) &gt;&gt;  8,          (ip-&gt;fHost &amp; 0x000000FF) &gt;&gt;  0);      }      else      {        printf(&quot;N/A - AppleTalk&quot;);      }    }        if (NULL != address)      DisposePtr((Ptr) address);        printf(&quot;    %s\n&quot;, name);  }}//*  --------------------  EnumeratePlayersstatic voidEnumeratePlayers(void){OSStatus  theErr;NSpPlayerEnumerationPtr  thePlayers;UInt32    i;  if (nil == gNetGame)    printf(&quot;gNetGame is nil.\n&quot;);  theErr = NSpPlayer_GetEnumeration(gNetGame,  &amp;thePlayers);  if (noErr != theErr)  {    printf(&quot;NSpPlayer_GetEnumeration returned %ld\n&quot;, theErr);    return;  }      printf(&quot;PlayerID    Name\n&quot;);    printf(&quot;--------    -------------------------------\n&quot;);  for (i = 0; i &lt; thePlayers-&gt;count; i++)  {  char  name[sizeof (NSpPlayerName)];      BlockMoveData(thePlayers-&gt;playerInfo[i]-&gt;name + 1, name, thePlayers-&gt;playerInfo[i]-&gt;name[0]);    name[thePlayers-&gt;playerInfo[i]-&gt;name[0]] = '\0';    printf(&quot;%0.8ld    %s\n&quot;, thePlayers-&gt;playerInfo[i]-&gt;id, name);  }}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/NetSprocketTestOld/listing7.html%3Fid%3DDTS10000058-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/NetSprocketTestOld/listing7.html%3Fid%3DDTS10000058-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/NetSprocketTestOld/listing7.html%3Fid%3DDTS10000058-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>