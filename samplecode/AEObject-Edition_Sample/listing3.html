<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>AEObject-Edition Sample - /AEUtilities.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxCarbon-date.html">Carbon</a> &gt; <A HREF="javascript:location.replace('index.html');">AEObject-Edition Sample</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxInterapplicationCommunication-date.html" target="_blank">Carbon > Interapplication Communication</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">AEObject-Edition Sample</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/AEUtilities.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/AEObject-Edition Sample.r</option>
<option value="listing2.html">/AEObject.c</option>
<option value="listing3.html">/AEUtilities.c</option>
<option value="listing4.html">/AppleEventCore.c</option>
<option value="listing5.html">/BuildHeaders.c</option>
<option value="listing6.html">/Files.c</option>
<option value="listing7.html">/globals.c</option>
<option value="listing8.html">/Initialize.c</option>
<option value="listing9.html">/Macros.h</option>
<option value="listing10.html">/main.c</option>
<option value="listing11.html">/Menu.c</option>
<option value="listing12.html">/Print.c</option>
<option value="listing13.html">/prototypes.h</option>
<option value="listing14.html">/Publish.c</option>
<option value="listing15.html">/SampConstants.h</option>
<option value="listing16.html">/Sampdefines.h</option>
<option value="listing17.html">/Structs.h</option>
<option value="listing18.html">/Subscribe.c</option>
<option value="listing19.html">/TextSections.c</option>
<option value="listing20.html">/Utilities.c</option>
<option value="listing21.html">/Windows.c</option></select>
				</p>
				</form>
				<p><strong><a href="AEObject-Edition_Sample.zip">Download Sample</a></strong> (&#147;AEObject-Edition_Sample.zip&#148;, 895.6K)<BR>
<strong><a href="AEObject-Edition_Sample.dmg">Download Sample</a></strong> (&#147;AEObject-Edition_Sample.dmg&#148;, 1.22M)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*------------------------------------------------------------------------------**  Apple Developer Technical Support**  AppleEvent utility routines**  Program:AEObject-Edition Sample*  File:   AEUtilityRoutines.c - C Source**  by: C.K. Haun &lt;TR&gt;**  Copyright &copy; 1991-1992 Apple Computer, Inc.*  All rights reserved.**------------------------------------------------------------------------------* This file contains some generic and specific utility routines I wrote* to help with the AppleEvent manager.  The prime motivation for this file* is to NOT have to type in all the fields needed for many of the* AEM parameter accessing routines, since I do them so often.  * There aren't all that many calls here yet, this will grow as the AEM world grows*----------------------------------------------------------------------------*/#define __AEMU__#include &quot;Sampdefines.h&quot;#pragma segment AEUtils/* A little routine that returns a short from a descriptor */OSErr ShortFromDesc(short *theData, const AppleEvent *theDesc){    OSErr myErr = noErr;    AEDesc tempDesc;    long temp;    if (theDesc-&gt;descriptorType == typeShortInteger) {                temp = *((short *)*(theDesc-&gt;dataHandle));        *theData = temp;    } else {  /* if it wasn't a short to begin with, try and coerce it into a short */        myErr = AECoerceDesc(theDesc, typeShortInteger, &amp;tempDesc);        if (!myErr) {            /* it coerced.  grab it */            temp = *((short *)*(tempDesc.dataHandle));            *theData = temp;            AEDisposeDesc(&amp;tempDesc);        }    }    return(myErr);    }/* this has been replaced by my coercion handler, see AppleEventCore.c  */void PStringFromTextDesc(Str255 theString, const AEDesc *theDesc){    theString[0] = GetHandleSize(theDesc-&gt;dataHandle);    BlockMove((Ptr)*theDesc-&gt;dataHandle, (Ptr)&amp;theString[1], theString[0]);    }/* Puts up the PPCBrowser, and creates a target address *//* based on the user selection */OSErr BrowseForTarget(AEDesc *theAddress){    Str32 prompt1;    Str32 prompt2;    LocationNameRec theLoc;    PortInfoRec theRec;    OSErr myErr = noErr;  TargetID theID;  GetIndString(prompt1,kGeneralStrings,kPPCPrompt1);  GetIndString(prompt2,kGeneralStrings,kPPCPrompt2);    myErr = PPCBrowser(prompt1, prompt2, false, &amp;theLoc, &amp;theRec, nil, nil);    if (!myErr) {        /* make a target descriptor */        BlockMove(theRec.name.name, targetName, theRec.name.name[0] + 1);        ParamText(&amp;targetName, &quot;&quot;, &quot;&quot;, &quot;&quot;);        theID.name = theRec.name;        theID.location = theLoc;        myErr = AECreateDesc(typeTargetID, (Ptr)&amp;theID, sizeof(theID), theAddress);            }    mAEErrorDisplay(&quot;\pBrowser Error&quot;, myErr)    return(myErr);}/* Makes an AppleEvent address descriptor based on the settings in the Dialog Box *//* in AppleEventCore.c */OSErr MakeAddress(AEDesc *theAddress){    OSErr myErr = noErr;    ProcessSerialNumber myNumber;    switch (gAddressMode) {  /* Remember, if you use this case (using the PSN of kCurrentProcess) the  */  /* AppleEvent Manager will bypass the event loop and directly call (like a normal */  /* subroutine call) your handler, the event will _not_ come through */  /* WaitNextEvent */        case kSelfCur:            myNumber.highLongOfPSN = 0;            myNumber.lowLongOfPSN = kCurrentProcess;            myErr = AECreateDesc(typeProcessSerialNumber, (Ptr)&amp;myNumber, sizeof(ProcessSerialNumber), theAddress);            break;  /* If you use your real PSN, then the event will come through WNE */            case kSelfPSN:            myErr = AECreateDesc(typeProcessSerialNumber, (Ptr)&amp;gOurSN, sizeof(ProcessSerialNumber), theAddress);            break;        case kOtherApp:            if (gTargetAddress.dataHandle == nil) {                myErr = BrowseForTarget(theAddress);            } else {      /* If I already have one, duplicate it and pass it back */                myErr = AEDuplicateDesc(&amp;gTargetAddress, theAddress);            }            break;    }    mAEErrorDisplay(&quot;\pMakeAddress &quot;, myErr)    return(myErr);}/* generic sender, so I don't have to duplicate the various conditional code *//* (for replies, interactions, or whatever) all over */OSErr DoSend(AppleEvent *theEvent, AEDesc *reply){    AEDesc *replyPointer = nil;    short response = 2;    OSErr myErr;    long timeOut = kAEDefaultTimeout;    if (gReplyMode)        replyPointer = reply;    if (gReplyMode == 1 &amp;&amp; gAddressMode == 1) {    ModalFilterUPP upp = NewModalFilterProc(standardAlertFilter);    timeOut = 0;    response = CautionAlert(kBadMix, upp);    DisposeRoutineDescriptor(upp);    }    if (response == 2) {        myErr = AESend(theEvent, replyPointer,                       (gSendInteractArray[gAESendInteraction] + gAESwitchLayer) + gReplyLevels[gReplyMode], kAENormalPriority,                       timeOut, gCommonIdleFunctionUPP, nil);                mAEErrorDisplay(&quot;\pAESend in DoSend &quot;, myErr)    } else {        myErr = userCanceledErr;    }    return(myErr);}/* lil routine that will print out actual error text for AEM errors, since I *//* got real tired of trying to remeber what -1723 was. *//* revised to reflect the new error codes, and to use my ERST &lt;ckh 1.0.2&gt;*//* resource &lt;ckh 1.0.2&gt;*/void AEErrorText(OSErr theError){    Str63 theWords;  Ptr theErrors;  OSErr tempError;  register qq;  short errCount;  Byte stringLen;  /* get my errors &lt;ckh 1.0.2&gt;*/  Handle scratch = GetResource(kErrorStringResourceType,kTheErrorStrings);  theWords[0] = 0;  if(scratch){    /* if I got it, lock it and deref &lt;ckh 1.0.2&gt;*/    HLock(scratch);    theErrors = *scratch;    errCount =  *((short *)theErrors);    /* position to the first error code &lt;ckh 1.0.2&gt;*/    theErrors = theErrors+sizeof(short);    errCount--;    for(qq = 0;qq&lt;errCount;qq++){      tempError =  *((short *)theErrors);      theErrors = theErrors + sizeof (OSErr);      /* get the string count, we'll need this whatever we do &lt;ckh 1.0.2&gt;*/      stringLen = *theErrors;      stringLen ++;        if(tempError == theError){        /* it's this one, theErrors points to the string &lt;ckh 1.0.2&gt;*/        BlockMove(theErrors,(Ptr)&amp;theWords,stringLen);        break;                } else {        /* next errror please &lt;ckh 1.0.2&gt;*/        theErrors = theErrors + stringLen;        }      }    if(theWords[0] == 0){      GetIndString(theWords,kGeneralStrings,kUnknownError);      }      AddAEText(theWords);    HUnlock(scratch);    ReleaseResource(scratch);    }}/* this just pumps out the returned data to the AEWindow *//* just a utility for this sample */void DisplayReturnedData(AEDesc *reply){    AEDesc theData;    OSErr myErr;    long errorCode = 0;    DescType returnedType;    Size returnedSize;    Str255 returnedText;    /* I can do most of this by asking for typeChar and getting the desc. */    /* this is because the AEM can coerce any numeric data to typeChar */    /* (as described in the AEM chapter of IM VI) */    /* For things that the AEM _doesn't_ know about, I will install */    /* coercion handlers! */    /* if the coercion completely fails, because I got something I no nothing about, I bail */    mVerboseOutput(&quot;\p\n Returned Data was : &quot;)    myErr = AEGetParamDesc(reply, keyDirectObject, typeChar, &amp;theData);    if (!myErr) {        long size = GetHandleSize(theData.dataHandle);        HLock(theData.dataHandle);                AddToAEWindow((Ptr)*(theData.dataHandle), size);            } else {        /* get it as a wildcard, and just show me the descType */        myErr = AEGetParamDesc(reply, keyDirectObject, typeWildCard, &amp;theData);        AddToAEWindow((Ptr)&amp;theData.descriptorType, kFour);    }    /* I got a desc, I need to dispose a desc */    if (!myErr)        AEDisposeDesc(&amp;theData);    else        AddAEText(&quot;\p not available&quot;);    /* see if there was an 'errs' or 'errn' added */    myErr = AEGetParamPtr(reply, keyErrorNumber, typeLongInteger, &amp;returnedType, (Ptr)&amp;errorCode, sizeof(long), &amp;returnedSize);    if (myErr &amp;&amp; myErr != errAEDescNotFound) {                mVerboseOutput(&quot;\p\n Had an error descriptor, but I can't access it&quot;)    }    if (!myErr) {        mVerboseOutput(&quot;\p\n Error number (errn) returned, was: &quot;)        AddAENum(errorCode);        AEErrorText(errorCode);    }    /* try for the error string */    myErr = AEGetParamPtr(reply, keyErrorString, typeMyPString, &amp;returnedType, (Ptr)&amp;returnedText, 255, &amp;returnedSize);    if (!myErr) {        mVerboseOutput(&quot;\p\n Error string (errs) returned, was: &quot;)        AddAEText(&amp;returnedText);    }}/* DoObjectDefinition drives the dialog that sets up the default containers *//* for this sample, boring dialog stuff */void DoObjectDefinition(short which){    DialogPtr tdial;    short hitItem = 0;    Boolean r5, r6;    Str32 tempNum;    register qq;    long realNum;    DescType shapeTypes[] =  {       cGraphicLine, cRectangle, cOval    };    tdial = SetUpObjectDialog(which);    ShowWindow(tdial);    {    ModalFilterUPP upp = NewModalFilterProc(standardDialogFilter);    while (hitItem != ok &amp;&amp; hitItem != cancel) {      ModalDialog(upp, &amp;hitItem);      switch (which) {        case kSetWindowObject:          switch (hitItem) {            case kWByIndex:            case kWByName:              if (hitItem == kWByIndex) {                r5 = true;                r6 = false;              } else {                r5 = false;                r6 = true;              }              SetControlValue(SnatchHandle(tdial, kWByIndex), r5);              SetControlValue(SnatchHandle(tdial, kWByName), r6);                            break;          }          break;        case kSetTextObject:          switch (hitItem) {            case kWordIndex:                        /* checkbox only to worry about */              SetControlValue(SnatchHandle(tdial, kWordIndex), (GetControlValue(SnatchHandle(tdial, kWordIndex)) ? 0 : 1));          }          break;        case kSetShapeObject:          switch (hitItem) {            case kLineRadio:            case kRectangleRadio:            case kOvalRadio:              /* find out which one is true */              for (qq = kLineRadio; qq &lt; kOvalRadio + 1; qq++) {                if (GetControlValue(SnatchHandle(tdial, qq))) {                  if (!(qq == hitItem)) {                    SetControlValue(SnatchHandle(tdial, qq), false);                    SetControlValue(SnatchHandle(tdial, hitItem), true);                  }                }              }              break;          }          break;      }    }    DisposeRoutineDescriptor(upp);  }    /* make the changes permenent */    if (hitItem == ok) {        gPreferences.prefsChanged = true;    switch (which) {            case kSetWindowObject:                HLock((Handle)gWindObjSpecHandle);                if (GetControlValue(SnatchHandle(tdial, kWByIndex))) {                    /* going by absolute position */                    (*gWindObjSpecHandle)-&gt;form = formAbsolutePosition;                    GetDialogItemText((Handle)SnatchHandle(tdial, kWIndexNum), tempNum);                    StringToNum(tempNum, &amp;realNum);                    (*gWindObjSpecHandle)-&gt;u.index = realNum;                } else {                    /* going by name */                    (*gWindObjSpecHandle)-&gt;form = formName;                    /* put the name where it belongs */                    GetDialogItemText((Handle)SnatchHandle(tdial, kWIndexName), (*gWindObjSpecHandle)-&gt;u.name);                                    }                HUnlock((Handle)gWindObjSpecHandle);                break;            case kSetTextObject:                                HLock((Handle)gTextObjSpecHandle);                /* fewer choices here */                GetDialogItemText((Handle)SnatchHandle(tdial, kTextONumber), tempNum);                                StringToNum(tempNum, &amp;realNum);                (*gTextObjSpecHandle)-&gt;u.index = realNum;                (*gTextObjSpecHandle)-&gt;andWord = GetControlValue(SnatchHandle(tdial, kWordIndex));                /* see if word is being asked for */                if ((*gTextObjSpecHandle)-&gt;andWord) {                    GetDialogItemText((Handle)SnatchHandle(tdial, kWordIndexString), tempNum);                    StringToNum(tempNum, &amp;realNum);                    (*gTextObjSpecHandle)-&gt;wordNumber = realNum;                                    }                HUnlock((Handle)gTextObjSpecHandle);                break;            case kSetShapeObject:                HLock((Handle)gShapeObjSpecHandle);                for (qq = kLineRadio; qq &lt; kOvalRadio + 1; qq++) {                    if (GetControlValue(SnatchHandle(tdial, qq))) {                        (*gShapeObjSpecHandle)-&gt;type = qq - kLineRadio;                        (*gShapeObjSpecHandle)-&gt;form = shapeTypes[qq - kLineRadio];                        break;                    }                }                /* and the index number */                GetDialogItemText((Handle)SnatchHandle(tdial, kSIEditLine), tempNum);                StringToNum(tempNum, &amp;realNum);                (*gShapeObjSpecHandle)-&gt;u.index = realNum;                HUnlock((Handle)gShapeObjSpecHandle);                break;        }    }    DisposeDialog(tdial);}/* Anther case of not wanting to type dialog code all over the sample */DialogPtr SetUpObjectDialog(short which){    DialogPtr tdial = CommonDStart(which, nil, nil);    short tempItem;    Str63 tempString;    switch (which) {                case kSetWindowObject:            HLock((Handle)gWindObjSpecHandle);            if ((*gWindObjSpecHandle)-&gt;form == 0) {                tempItem = kWPosRadio;                               /* default for the first time the app is run */            } else {                                if ((*gWindObjSpecHandle)-&gt;form == formAbsolutePosition) {                                        tempItem = kWPosRadio;                    NumToString((*gWindObjSpecHandle)-&gt;u.index, tempString);                    SetDialogItemText((Handle)SnatchHandle(tdial, kWPosNum), tempString);                } else {                    tempItem = kWTitleRadioSet;                    SetDialogItemText((Handle)SnatchHandle(tdial, kWTitleELine), (*gWindObjSpecHandle)-&gt;u.name);                }            }            SetControlValue(SnatchHandle(tdial, tempItem), true);            HUnlock((Handle)gWindObjSpecHandle);            break;        case kSetTextObject:            HLock((Handle)gTextObjSpecHandle);            /* fewer choices here */            NumToString((*gTextObjSpecHandle)-&gt;u.index, tempString);            SetDialogItemText((Handle)SnatchHandle(tdial, kWPosRadio), tempString);            /* see if word is being asked for */            if ((*gTextObjSpecHandle)-&gt;andWord) {                SetControlValue(SnatchHandle(tdial, kWTitleRadioSet), true);                NumToString((*gTextObjSpecHandle)-&gt;wordNumber, tempString);                SetDialogItemText((Handle)SnatchHandle(tdial, kWPosNum), tempString);                            }            HUnlock((Handle)gTextObjSpecHandle);            break;        case kSetShapeObject:            HLock((Handle)gShapeObjSpecHandle);            if (!(*gShapeObjSpecHandle)-&gt;u.index)                (*gShapeObjSpecHandle)-&gt;u.index = 1;            NumToString((*gShapeObjSpecHandle)-&gt;u.index, tempString);            SetDialogItemText((Handle)SnatchHandle(tdial, kSIEditLine), tempString);            SetControlValue(SnatchHandle(tdial, ((*gShapeObjSpecHandle)-&gt;type) + kLineRadio), true);            /* byIndex defaults to on for now */            SetControlValue(SnatchHandle(tdial, kSByIndexRadio), true);                        break;        default:            break;    }    return(tdial);}/* this is a central point to add keyErrorText and keyErrorNumber  *//* parameters to a reply *//* just a handy thing to do. *//* It first checks to see if an error is already recorded, if there is one *//* (for an earlier stage in the process) they we exit, since the user will have to *//* deal with the ealier problem before they tackle the one we've just been called  *//* to add *//* **** BE SURE that you null out the gCurrentReply (or whatever you use) pointer *//* when you exit from your handler, or you could end up writing to a desc that isn't  *//* there.  And of course, if you send events to yourself from within a handler *//* you're going to have to use a differrent method than this.  It's a sample, see? */void AddToReply(ConstStr255Param theWords, long theError){    OSErr myErr = noErr;    long errNo;    DescType returnedType;    Size returnedSize;        /* First, is therre a reply hanging out? */    if (gCurrentReply) {        /* test to see if there is one already*/        myErr = AEGetParamPtr(gCurrentReply, keyErrorNumber, typeLongInteger, &amp;returnedType, (Ptr)&amp;errNo, sizeof(long),                              &amp;returnedSize);                if (myErr == errAEDescNotFound) {            /* cool, press on.  */            myErr = AEPutParamPtr(gCurrentReply, keyErrorNumber, typeLongInteger, (Ptr)&amp;theError, sizeof(long));            if (!myErr)                myErr = AEPutParamPtr(gCurrentReply, keyErrorString, typeChar, (Ptr)&amp;theWords[1], theWords[0]);                    }    }}OSErr MakeTypeRect(CShapeObjHandle theShape, AEDesc *theValue){    OSErr myErr = noErr;    AEDesc pixDesc;    AEDescList theList;    RGBColor black =  {        0, 0, 0    };    RGBColor white =  {        0xffff, 0xffff, 0xffff    };    short penSize = 1;    long copyWord = kAEQDCopy;    ShapesHandle theRealShape = (*theShape)-&gt;theShape;    HLock((Handle)theRealShape);    /* Now, a typeRectangle is a bunch of stuff, and as the AE Registry so clearly says... */    /* &quot;Note that the Apple Event Manager can coerce any Apple event record into any     other descriptor type. A special coercion handler is not required.&quot;    */    /* If you always wondered what that meant (I know I did) then watch */    /* create a list that is a record */    myErr = AECreateList(nil, nil, true, &amp;theList);    /* now start adding all the junk I have lying around, rectangle, color, kitchen sink.... */    if (!myErr)        myErr = MakeSinglePixelMap(&amp;pixDesc, &amp;(*theRealShape)-&gt;theColor);    /* jeeez don't try and write code while the Finder is doing a copy across LocalTalk in the background Like I'm trying to now.... */    if (!myErr)        myErr = AEPutParamDesc(&amp;theList, keyAEPenPattern, &amp;pixDesc);    if (!myErr)        myErr = AEPutParamDesc(&amp;theList, keyAEFillPattern, &amp;pixDesc);    AEDisposeDesc(&amp;pixDesc);    if (!myErr)        myErr = MakeSinglePixelMap(&amp;pixDesc, &amp;white);    if (!myErr)        myErr = AEPutParamDesc(&amp;theList, keyAEFillColor, &amp;pixDesc);    AEDisposeDesc(&amp;pixDesc);    if (!myErr)        myErr = AEPutParamPtr(&amp;theList, keyAEPenWidth, typeShortInteger, (Ptr)&amp;penSize, sizeof(short));    if (!myErr)        myErr = AEPutParamPtr(&amp;theList, keyAETransferMode, typeEnumeration, (Ptr)&amp;copyWord, sizeof(long));        if (!myErr)        myErr = AEPutParamPtr(&amp;theList, keyAEBounds, typeQDRectangle, (Ptr)&amp;(*theRealShape)-&gt;theRect, sizeof(Rect));    if (!myErr)        myErr = AEPutParamPtr(&amp;theList, keyAEDefinitionRect, typeQDRectangle, (Ptr)&amp;(*theRealShape)-&gt;theRect, sizeof(Rect));    HUnlock((Handle)theRealShape);    /* and coerce it into what we want */    if (!myErr)        myErr = AECoerceDesc(&amp;theList, typeRectangle, theValue);    AEDisposeDesc(&amp;theList);    mAEErrorDisplay(&quot;\p\n Error creating typeRectangle&quot;, myErr)    return(myErr);}/* MakeGraphicLine is similar to making a typeRectangle */OSErr MakeGraphicLine(CShapeObjHandle theShape, AEDesc *theValue){    OSErr myErr = noErr;    AEDesc emptyList;    AEDesc pixDesc;    AEDescList theList;    RGBColor black =  {        0, 0, 0    };    RGBColor white =  {        0xffff, 0xffff, 0xffff    };    short penSize = 1;    long copyWord = kAEQDCopy;    DescType noArr = kAENoArrow;    ShapesHandle theRealShape = (*theShape)-&gt;theShape;    HLock((Handle)theRealShape);    myErr = AECreateList(nil, nil, true, &amp;theList);    /* now start adding all the junk I have lying around, rectangle, color, kitchen sink.... */    if (!myErr)        myErr = MakeSinglePixelMap(&amp;pixDesc, &amp;(*theRealShape)-&gt;theColor);    /* jeeez don't try and write code while the Finder is doing a copy across LocalTalk in the background Like I'm trying to now.... */    if (!myErr)        myErr = AEPutParamDesc(&amp;theList, keyAEPenPattern, &amp;pixDesc);    if (!myErr)        myErr = AEPutParamDesc(&amp;theList, keyAEPenColor, &amp;pixDesc);    AEDisposeDesc(&amp;pixDesc);    if (!myErr)        myErr = AEPutParamPtr(&amp;theList, keyAEPenWidth, typeShortInteger, (Ptr)&amp;penSize, sizeof(short));    if (!myErr)        myErr = AEPutParamPtr(&amp;theList, keyAETransferMode, typeEnumeration, (Ptr)&amp;copyWord, sizeof(long));        if (!myErr)        myErr = AEPutParamPtr(&amp;theList, keyAEBounds, typeQDRectangle, (Ptr)&amp;(*theRealShape)-&gt;theRect, sizeof(Rect));    if (!myErr)        myErr = AEPutParamPtr(&amp;theList, keyAELineArrow, typeEnumeration, (Ptr)&amp;noArr, sizeof(DescType));    /* we have no dash styles, so add an empty list */    myErr = AECreateList(nil, nil, false, &amp;emptyList);    if (!myErr)        myErr = AEPutParamDesc(&amp;theList, keyAEDashStyle, &amp;emptyList);    AEDisposeDesc(&amp;emptyList);    if (!myErr)        myErr = AEPutParamPtr(&amp;theList, keyAEStartPoint, typeQDRectangle, (Ptr)&amp;(*theRealShape)-&gt;theRect, sizeof(Point));    if (!myErr)        myErr = AEPutParamPtr(&amp;theList, keyAEStartPoint, typeQDRectangle, (Ptr)&amp;(*theRealShape)-&gt;theRect.bottom, sizeof(Point));        HUnlock((Handle)theRealShape);    /* and coerce it into what we want */    if (!myErr)        myErr = AECoerceDesc(&amp;theList, typeGraphicLine, theValue);    AEDisposeDesc(&amp;theList);    mAEErrorDisplay(&quot;\p\n Error creating typeGraphicLine&quot;, myErr)    return(myErr);}/* Now some of the definitions in the AE Registry are rather broad, but they *//* really need to be.  SO you'll want little routines like this */OSErr MakeSinglePixelMap(AEDesc *thePlace, RGBColor *theColor){    OSErr myErr = noErr;    AEDescList thePixelList, tempList;    AEDesc scratchDesc;    long copyWord = kAEQDCopy;    Rect miniRect =  {        0, 0, 1, 1    };    myErr = AECreateList(nil, nil, false, &amp;thePixelList);    if (!myErr)        myErr = AECreateDesc(typeRGBColor, (Ptr)theColor, sizeof(RGBColor), &amp;scratchDesc);    if (!myErr)        myErr = AEPutDesc(&amp;thePixelList, 0, &amp;scratchDesc);    if (!myErr)        myErr = AEDisposeDesc(&amp;scratchDesc);    /* now create the other list */    if (!myErr)        myErr = AECreateList(nil, nil, true, &amp;tempList);    /* add the pixels */    if (!myErr)        myErr = AEPutParamDesc(&amp;tempList, typePixMapMinus, &amp;thePixelList);    if (!myErr)        myErr = AEDisposeDesc(&amp;thePixelList);    if (!myErr)        myErr = AECreateDesc(typeQDRectangle, (Ptr)&amp;miniRect, sizeof(Rect), &amp;scratchDesc);    /* add it */    if (!myErr)        myErr = AEPutParamDesc(&amp;tempList, keyAEBounds, &amp;scratchDesc);    if (!myErr)        myErr = AEDisposeDesc(&amp;scratchDesc);    /* and the transfer mode, I'm using Copy for all of these */    if (!myErr)        myErr = AECreateDesc(typeEnumeration, (Ptr)&amp;copyWord, sizeof(long), &amp;scratchDesc);    /* add it */    if (!myErr)        myErr = AEPutParamDesc(&amp;tempList, keyAETransferMode, &amp;scratchDesc);    if (!myErr)        myErr = AEDisposeDesc(&amp;scratchDesc);    /* and coerce thePlace into a typePixelMap */    if (!myErr)        myErr = AECoerceDesc(&amp;tempList, typePixelMap, thePlace);        /* See?  Simplicity itself */    mAEErrorDisplay(&quot;\p\n Error creating pixMap&quot;, myErr)    return(myErr);}#undef __AEMU__</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/AEObject-Edition_Sample/listing3.html%3Fid%3DDTS10000204-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/AEObject-Edition_Sample/listing3.html%3Fid%3DDTS10000204-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/AEObject-Edition_Sample/listing3.html%3Fid%3DDTS10000204-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>