<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>AEObject-Edition Sample - /AEObject.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxCarbon-date.html">Carbon</a> &gt; <A HREF="javascript:location.replace('index.html');">AEObject-Edition Sample</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxInterapplicationCommunication-date.html" target="_blank">Carbon > Interapplication Communication</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">AEObject-Edition Sample</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/AEObject.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/AEObject-Edition Sample.r</option>
<option value="listing2.html">/AEObject.c</option>
<option value="listing3.html">/AEUtilities.c</option>
<option value="listing4.html">/AppleEventCore.c</option>
<option value="listing5.html">/BuildHeaders.c</option>
<option value="listing6.html">/Files.c</option>
<option value="listing7.html">/globals.c</option>
<option value="listing8.html">/Initialize.c</option>
<option value="listing9.html">/Macros.h</option>
<option value="listing10.html">/main.c</option>
<option value="listing11.html">/Menu.c</option>
<option value="listing12.html">/Print.c</option>
<option value="listing13.html">/prototypes.h</option>
<option value="listing14.html">/Publish.c</option>
<option value="listing15.html">/SampConstants.h</option>
<option value="listing16.html">/Sampdefines.h</option>
<option value="listing17.html">/Structs.h</option>
<option value="listing18.html">/Subscribe.c</option>
<option value="listing19.html">/TextSections.c</option>
<option value="listing20.html">/Utilities.c</option>
<option value="listing21.html">/Windows.c</option></select>
				</p>
				</form>
				<p><strong><a href="AEObject-Edition_Sample.zip">Download Sample</a></strong> (&#147;AEObject-Edition_Sample.zip&#148;, 895.6K)<BR>
<strong><a href="AEObject-Edition_Sample.dmg">Download Sample</a></strong> (&#147;AEObject-Edition_Sample.dmg&#148;, 1.22M)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*------------------------------------------------------------------------------**  Apple Developer Technical Support**  AppleEvent(tm) Object Model and Object Support Library routines**  Program:AEObject-Edition Sample*  File: AEObject.c -C Source**  by:   C.K. Haun &lt;TR&gt;**  Copyright &copy; 1991,1992 Apple Computer, Inc.*  All rights reserved.**------------------------------------------------------------------------------* This file contains most of the routines that deal with AppleEvent Objects, and* the routines that use them.* Object resolution, and Object accessors play a large part here.  Once you under-* stand and have written a few accessors, you'll see that this stuff becomes a great* deal easier.* vers 1.0.1- All AE constants changed to reflect Winter '92 registry *----------------------------------------------------------------------------*//* And another Note:* I am resolving simple objects in this file and sample.  I intend to* go on to complex objects in a future sample, please stay tuned *//* Some words about the objects and handlers *//* Windows *//* When a window is asked for or used, the token I create is an AEDesc *//* of type cWindow, and the data associated with this is  *//* (suprisingly enough) a window pointer.  In this sample I can do anything *//* with my data based on a window pointer. *//* The rest of the tokens are AEDescs containing structures in the dataHandle, *//* please see the AESampStructs.h file for the definition of these structures *//* *** Remember ---  A token can be anything you like. It does NOT get passed outside *//* your application, it only stays inside it.   */#define __AEOBJ__#include &quot;Sampdefines.h&quot;#pragma segment MyInit/* InstallObjectHandlers normally would be in the Initialize.c file, but I wanted to put it here, *//* along with the rest of the Object Model code so you could see everything in one place *//* This routine starts the ObjectSupportLibrary, and installs all the callbacks and  *//* object accessors for this program. */OSErr InstallObjectHandlers(void){    /* Initialize the library.  This makes some internal calls to the AppleEvent manager */    OSErr myErr = AEObjectInit();    if (!myErr) {        /* The meat of the initialization.  Here I'm installing all the object accessors */        /* I've written.  These are the routines that the OSL will call when I call */        /* AEResolve on an object in an AppleEvent.  These routines do all the  */        /* parsing of the object specifier, segment by segment.  Each of them returns a */        /* token that describes the in-memory structure of the object specified in a way */        /* my application can understand.  No one else will ever see these tokens */        /* they are ONLY for use inside my program.  This means that they can be anything that */        /* makes sense to me and my appliction. */        /* The actual token structures I use are defined in the AESampStructs.h file. */        /* This accessor returns a window token from a null descriptor.  This  */        /* accessor will be called a LOT, since specifing anything in my application */        /* will usually reference an owning window. */                myErr = AEInstallObjectAccessor(cWindow, typeNull, NewOSLAccessorProc(WindFromNull), 0, false);                /* This accessor gets ANY property from a window token */        /* Since a window token describes all the important junk about the window */        /* I only need one property from window accessor */                myErr = AEInstallObjectAccessor(typeProperty, cWindow, NewOSLAccessorProc(PropertyFromWindow), 0, false);                /* This installs my Text from Window accessor.  If there is a text object in this window */        /* this routine will return a token for it */                myErr = AEInstallObjectAccessor(cText, cWindow, NewOSLAccessorProc(TextFromWindow), 0, false);                /* Now be able to pass back properties of my Text objects */                myErr = AEInstallObjectAccessor(typeProperty, cText, NewOSLAccessorProc(PropertyFromText), 0, false);                /* This installs my Word from Text accessor. */                myErr = AEInstallObjectAccessor(cWord, cText, NewOSLAccessorProc(WordFromText), 0, false);                myErr = AEInstallObjectAccessor(cDrawingArea, cWindow, NewOSLAccessorProc(DrawFromWindow), 0, false);                /* This guy graps a graphic shape from my window, no matter what it actually is */                myErr = AEInstallObjectAccessor(cGraphicShape, cDrawingArea, NewOSLAccessorProc(ShapeFromDraw), 0, false);        myErr = AEInstallObjectAccessor(cGraphicShape, cWindow, NewOSLAccessorProc(ShapeFromDraw), 0, false);        /* these grab specific shapes from the drawing area */        /* The canny observer will notice that these all call the ShapeFromDraw routine */        /* Since my shapes are all defined in the same type of structure, this makes  */        /* a lot of sense for me */                    myErr = AEInstallObjectAccessor(cGraphicLine, cDrawingArea, NewOSLAccessorProc(ShapeFromDraw), 0, false);        myErr = AEInstallObjectAccessor(cOval, cDrawingArea, NewOSLAccessorProc(ShapeFromDraw), 0, false);        myErr = AEInstallObjectAccessor(cRectangle, cDrawingArea, NewOSLAccessorProc(ShapeFromDraw), 0, false);        myErr = AEInstallObjectAccessor(cGraphicLine, cWindow, NewOSLAccessorProc(ShapeFromDraw), 0, false);        myErr = AEInstallObjectAccessor(cOval, cWindow, NewOSLAccessorProc(ShapeFromDraw), 0, false);        myErr = AEInstallObjectAccessor(cRectangle, cWindow, NewOSLAccessorProc(ShapeFromDraw), 0, false);        /* and the same type o' thing for shape properties */        myErr = AEInstallObjectAccessor(typeProperty, cGraphicLine, NewOSLAccessorProc(PropertyFromShape), 0, false);        myErr = AEInstallObjectAccessor(typeProperty, cOval, NewOSLAccessorProc(PropertyFromShape), 0, false);        myErr = AEInstallObjectAccessor(typeProperty, cRectangle, NewOSLAccessorProc(PropertyFromShape), 0, false);                /* And the list will go on and on.  Once you've written a few accessors, you realize  */        /* how handy they are, and you start installing them for everything that can  */        /* possibly be gotten from anything else.  The only limit will be the  */        /* amount of code space you want to dedicate to accessors. */        /* Remember, the more accessors you put in, the more ways users will have to */        /* get at your data, and the less they will have to learn or remember. */        /* Our goal, as always, is to make it as easy for the user as possible. */        /* I will also use the same routine to go from a null */                /* Here I am installing all the call back routines that the OSL needs.  */        /* These are not all implemented as doing something, but they will eventually */        /* These tokens will be called by the OSL as it does it's parsing  */        /* thrugh a passed object specifier. */        /* You may not need all of these, any you don't need just pass */        /* a nil */                myErr = AESetObjectCallbacks(NULL,       NewOSLCountProc(MyCountProc),       NewOSLDisposeTokenProc(MyDisposeTokenProc),      NULL, NULL, NULL, NULL);            }    return(myErr);}#pragma segment AEOSL/* My GetData event handler.  This routine resolves the object passed (calling AEResolve) *//* and then returns the appropriate data to the sender of the event */pascal OSErr AEGetDataHandler(AppleEvent *messagein, AppleEvent *reply, long refIn){ #pragma unused (refIn)    OSErr myErr = noErr;    AEDesc tokenBack;    AEDesc theObject;    AEDesc returnDesc;    /* variables for the various tokens I'll be getting back */    CWordObjHandle wordToken;    CTextObjHandle textToken;    PropertyTHdl propertyToken;    Handle myDataHandle, tempHandle;    Size dataSize;    /* window is just a window ptr */    gCurrentReply = reply;    mVerboseOutput(&quot;\p\nEntering GetData handler&quot;)    myErr = AEGetParamDesc(messagein, keyDirectObject, typeObjectSpecifier, &amp;theObject);      mAEErrorDisplay(&quot;\p getting object spec&quot;, myErr)    if (!myErr) {        returnDesc.descriptorType = typeNull;               /* set this up for a later check */        myErr = AEResolve(&amp;theObject, kAEIDoMinimum, &amp;tokenBack);        mAEErrorDisplay(&quot;\p AEResolve&quot;, myErr)                if (!myErr) {            /* Hey, marvy, we got an object token back.  That means that we have  */            /*  enough information to derive the data. */            /* Again, and forever, we don't care how you actually access data and create tokens */            /* inside your application, you know how to do that much bettern than we ever will. */            /* As long as it makes sense, and is efficient, for you, it's fine with us. */            /* I am going to have to do some switching and stuff here to put the data I got into the reply */                        /* By the Way:  You could make all your tokens with the same field for the  */            /* data and descriptor type.  If you did that, you wouldn't need the case */            /* here for a GetData event, you would just pass back what you got. */            /* I thought about it for this sample, but it seems more descriptive to */            /* go through the specific objects.  I may change my mind.... */                        /* Anyway, I switch off the type of token I got back... */            switch (tokenBack.descriptorType) {                case cWindow:                    /* for this, I'm going to pass back the Window ID I use in this program. */                    /* Why not the window pointer?  Because we don't have shared memory in the current */                    /* Mac OS, so I don't want people mucking around in my windows directly. */                    /* And really, if you're getting a request for a bare window, all the other side */                    /* is probably trying to see is if a window exisits.  I hope. */                    /* they can pass back this as a selector for NewElement, or something */                    /* You won't see this for a GetData much, in fact you can't from this  */                    /* sample get it.  I mean it ain't in the GetData menu */                                        break;                case cText:                    /* Pass back the chunk o' text.  Since I'm using TextEdit, I know that I'll */                    /* never be over 32k here.  Keep in mind that the AppleEvent manager can only */                    /* handle data up to 64k, so if you are passing back more text (or whatever) */                    /* than that you'll have to do it in a series of returns, or pass back an */                    /* alias to a file, or some such. */                    textToken = (CTextObjHandle)tokenBack.dataHandle;                    myDataHandle = (Handle)TEGetText((*textToken)-&gt;theText);                    HLock(myDataHandle);                    dataSize = GetHandleSize(myDataHandle);                    /* again, this check is not really necessary, but I want to put it here */                    /* as a warning, and maybe someday I'll stop using TextEdit. */                    if (dataSize &gt; k64k) {                        /* if this were true, you would have to do something. */                        dataSize = k64k;                    }                    myErr = AECreateDesc(typeChar, (Ptr)*myDataHandle, dataSize, &amp;returnDesc);                    HUnlock(myDataHandle);                    /* and kill the remaining token */                    myErr = MyDisposeTokenProc(&amp;tokenBack);                    /* the descriptor will be added to the reply later in this function */                    break;                case cWord:                    /* same basic thing for a word as for a text */                    wordToken = (CWordObjHandle)tokenBack.dataHandle;                    myDataHandle = NewHandle((*wordToken)-&gt;endPos - (*wordToken)-&gt;startPos);                    HLock(myDataHandle);                    dataSize = GetHandleSize(myDataHandle);                    /* move the text from the te chars handle to my data handle */                    tempHandle = (Handle)TEGetText((*wordToken)-&gt;theText);                    HLock(tempHandle);                    BlockMove((Ptr)(*tempHandle + (*wordToken)-&gt;startPos), (Ptr)*myDataHandle, dataSize);                    HUnlock(tempHandle);                    /* again, this check is not really necessary, but I want to put it here */                    /* as a warning. */                    if (dataSize &gt; k64k) {                        /* if this were true, you would have to do something. */                        dataSize = k64k;                    }                    myErr = AECreateDesc(typeChar, (Ptr)*myDataHandle, dataSize, &amp;returnDesc);                    HUnlock(myDataHandle);                    /* return value will be added to reply later in this function */                    /* and kill the remaining token */                    myErr = MyDisposeTokenProc(&amp;tokenBack);                                        break;                case typeProperty:                    /* just return the property as the type included in the token */                    /* The SetData handler (as you will see) needs to do a lot more */                    propertyToken = (PropertyTHdl)tokenBack.dataHandle;                    HLock((Handle)propertyToken);                    myDataHandle = (*propertyToken)-&gt;theData;                    dataSize = GetHandleSize(myDataHandle);                    /* again, this check is not really necessary, but I want to put it here */                    /* as a warning. */                    if (dataSize &gt; k64k) {                        /* if this were true, you would have to do something. */                        dataSize = k64k;                    }                    HLock(myDataHandle);                    myErr = AECreateDesc((*propertyToken)-&gt;theDataType, (Ptr)*myDataHandle, dataSize, &amp;returnDesc);                    myErr = MyDisposeTokenProc(&amp;tokenBack);                    break;                    /* and others as I add them */                case cGraphicShape:                case cGraphicLine:                    MakeGraphicLine((CShapeObjHandle)tokenBack.dataHandle, &amp;returnDesc);                    myErr = MyDisposeTokenProc(&amp;tokenBack);                    break;                case cRectangle:                case cOval:                    /* both of these have a default descriptor type of typeRectange, so I'll go make that */                    MakeTypeRect((CShapeObjHandle)tokenBack.dataHandle, &amp;returnDesc);                    myErr = MyDisposeTokenProc(&amp;tokenBack);                    break;                                }                        /* Here I either have a good descriptor for a return value, or I have  */            /* 'null' in the type field if something went wrong. */            if (returnDesc.descriptorType == typeNull) {                /* something bad happend, there will be no reply.   */        /* the error is already in myErr */            } else {                AEDesc newDesc;                AEDesc wantType;                OSErr tempErr;                /* we have a good descriptor.  THere's one more thing to do, and it's */                /* technically optional, but you should support it if you can.  That's  */                /* seeing if the sender included a type that the wanted the data back as. */                /* if they did, I will try and coerce my return descriptor to that type */                /* First, is there a wantType? */                /* I equate this to tempErr instead of myErr because it is not fatal if */                /* this get fails, I don't want to pass this error back to the sender */                tempErr = AEGetParamDesc(messagein, keyAERequestedType, typeType, &amp;wantType);                if (!tempErr) {                    /* there was a wantType.  Try and coerce my data to that type */                    /* If the coercion fails, I will just return my type of data.  The  */                    /* sender of this event may be able to do the coercion on their */                    /* end, perhaps they have more coercion handlers on their machine */                    /* * NOTE: DON'T assume that you can't coerce the descriptor! */                    /* i.e. don't  evaluate the wantType yourself and say */                    /* &quot;my application doesn't know how to do that&quot; and fail. */                    /* True, your app may not know.  But someone else on the */                    /* machine MIGHT know, and they may have installed a system */                    /* level coercion routine that will make this work even if */                    /* your application knew nothing about it.  So try the coercion */                    tempErr = AECoerceDesc(&amp;returnDesc, (DescType)**(wantType.dataHandle), &amp;newDesc);                    if (!tempErr) {                        AEDesc tempDesc;                        /* it coerced.  So, because of the way I'm doing this, swap */                        /* things around (kinda) */                        tempDesc = returnDesc;                        returnDesc = newDesc;                        AEDisposeDesc(&amp;tempDesc);                    }                }                myErr = AEPutParamDesc(reply, keyDirectObject, &amp;returnDesc);                myErr = AEDisposeDesc(&amp;returnDesc);                            }        }                                                   /* aeresolve error */    }                                                       /* get object */    gCurrentReply = nil;    return(myErr);    }pascal OSErr AESetDataHandler(AppleEvent *messagein, AppleEvent *reply, long refIn){#pragma unused (refIn)    OSErr myErr = noErr;    PropertyTHdl propertyBack;    CTextObjHandle cTextBack;    CWordObjHandle cWordBack;    AEDesc tokenBack;    AEDesc theObject;    AEDesc theData;    gCurrentReply = reply;    mVerboseOutput(&quot;\p\nEntering SetData handler&quot;)    myErr = AEGetParamDesc(messagein, keyDirectObject, typeObjectSpecifier, &amp;theObject);        mAEErrorDisplay(&quot;\p getting object spec&quot;, myErr)    /* get the data to set now also.  If we don't have any data, we can't */    /* do this event. */    /* I'm asking for the data as typeWildCard, so no coercions will take place. */    /* I may coerce the data later, but now I want it as sent. */    myErr = AEGetParamDesc(messagein, keyAEData, typeWildCard, &amp;theData);      mAEErrorDisplay(&quot;\p getting the data&quot;, myErr)    myErr = AEResolve(&amp;theObject, kAEIDoMinimum, &amp;tokenBack);      mAEErrorDisplay(&quot;\p AEResolve&quot;, myErr)    if (!myErr) {        /* we have a token telling us what the object to set is.  */        /* from that, we can do our setting */        /* How you actually implement this is again very much up to  */        /* you. This is only a simple sample, do what seems best in your application */        switch (tokenBack.descriptorType) {            case cWindow:                /* this shouldn't ever come back, since you can't set a  */                /* window per s\x8E.  Look at the property switch for that stuff */                break;            case cText:                /* setting the text of this text token */                /* our text token contains a TEHandle, so here's what we'll do.... */                cTextBack = (CTextObjHandle)tokenBack.dataHandle;                /* select all the text */                TESetSelect(0, 32000, (*cTextBack)-&gt;theText);                /* kill the old text */                TEDelete((*cTextBack)-&gt;theText);                HLock(theData.dataHandle);                /* and set the new text */                TESetText((Ptr)*(theData.dataHandle), GetHandleSize((theData.dataHandle)), (*cTextBack)-&gt;theText);                HUnlock(theData.dataHandle);                /* f\x93n */                MyDisposeTokenProc(&amp;tokenBack);                break;            case cWord:                /* changing this one word to something else */                /* basically the same as setting text, our range is just delimited */                /* setting the text of this text token */                /* our text token contains a TEHandle, so here's what we'll do.... */                cWordBack = (CWordObjHandle)tokenBack.dataHandle;                /* select all the text */                TESetSelect((*cWordBack)-&gt;startPos, (*cWordBack)-&gt;endPos, (*cWordBack)-&gt;theText);                TEDelete((*cWordBack)-&gt;theText);                HLock(theData.dataHandle);                TEInsert((Ptr)*(theData.dataHandle), GetHandleSize((theData.dataHandle)), (*cWordBack)-&gt;theText);                /* f\x93n */                MyDisposeTokenProc(&amp;tokenBack);                break;            case typeProperty:                propertyBack = (PropertyTHdl)tokenBack.dataHandle;                /* since there are so many properties to set, I'll switch off  */                /* the owner and set to that type */                switch ((*propertyBack)-&gt;owningTokenType) {                    case cWindow:                        myErr = SetWindowProperty(propertyBack, &amp;theData);      /* in Windows.c */                        MyDisposeTokenProc(&amp;tokenBack);                        break;                    case cText:          case cWord:                    /* I'm not setting text or word properties in this sample, since I'm */          /* using plain old TextEdit (not even style) */            myErr = errAENotModifiable;            AddToReply(&quot;\p Text property setting not implemented&quot;,0);                        break;          case cGraphicLine:          case cRectangle:          case cOval:            myErr = SetShapeProperty(propertyBack, &amp;theData);      /* in Windows.c */                        MyDisposeTokenProc(&amp;tokenBack);          break;                              case typeProperty:                        /* uhhh, if you ever have to set the property of a proprty, call me */                        /* and we'll find help */                        break;                                        }                break;        }    }    gCurrentReply = nil;    return(myErr);}/* TextFromWindow returns a token identifying a text object attached to a window. *//* If there is no text in this window, it returns an error */pascal OSErr TextFromWindow(DescType desiredClass, const AEDesc *container, DescType containerClass, DescType form,                            const AEDesc *selectionData, AEDesc *value, long LongInt){#pragma unused (desiredClass,form,LongInt)    OSErr myErr = noErr;    WindowPtr theWindow;    windowCHandle tempWC;    short textNumber;    CTextObjHandle newText;        mVerboseOutput(&quot;\p\nGetting a Text from a Window&quot;)    if (containerClass != cWindow) {        myErr = errAENoSuchObject;                          /* no such luck speedy */        AddToReply(&quot;\pYou did not ask for a text from a window, it's container&quot;, 0);    } else {        /* the container contains a window token in it's hot little datahandle */        theWindow = *((WindowPtr *)(*(container-&gt;dataHandle)));                tempWC = (windowCHandle)GetWRefCon(theWindow);        /* Does this window contain a text edit record???? */        if ((*tempWC)-&gt;boxHandle) {            /* which number Text did they ask for?  Our sample only allows one */            /* Text per window, so if it isn't one, bail */            ShortFromDesc(&amp;textNumber, selectionData);            if (textNumber == 1) {                /* create an cText object and pass it back */                newText = (CTextObjHandle)NewHandle(sizeof(CTextObject));                HLock((Handle)newText);                /* fill it in */                (*newText)-&gt;theOwningWindow = theWindow;                (*newText)-&gt;theText = (*tempWC)-&gt;boxHandle;                myErr = AECreateDesc(cText, (Ptr)*newText, sizeof(CTextObject), value);                DisposeHandle((Handle)newText);              /* no longer needed */            } else {                myErr = errAENoSuchObject;                AddToReply(&quot;\pNo Text Box with that index&quot;, 0);            }        } else {            /* no text in this window */            myErr = errAENoSuchObject;            AddToReply(&quot;\pNo Text Box in the window you specified&quot;, 0);        }    }    return(myErr);}/* Grab a word from the text *//* This is a 3rd level call from AEResolve.  Before we got to here, AEResolve has  *//* already called our WindFromNull and TextFromWindow accessors, the container *//* passed in is our text container token (probably) */pascal OSErr WordFromText(DescType desiredClass, const AEDesc *container, DescType containerClass, DescType form,                          const AEDesc *selectionData, AEDesc *value, long LongInt){ #pragma unused (desiredClass,containerClass,form,LongInt)    OSErr myErr = noErr;    long wordCount;    long wordStart;    long wordEnd;    short countToGet;    SignedByte textHState;    CWordObjHandle wordToken;    Handle theText;    /* Since we'e getting word from text, we know the container is our Text token */    CTextObjHandle ourTextObject = (CTextObjHandle)(container-&gt;dataHandle);    /* grab the text for later */    theText = (Handle)TEGetText((*ourTextObject)-&gt;theText);    textHState = HGetState(theText);    HLock(theText);    if (GetHandleSize(theText)) {        mVerboseOutput(&quot;\p\nGetting a word from a Text&quot;)        ShortFromDesc(&amp;countToGet, selectionData);                /* call my word counter with a stopAt of the selection data */        CountWords(container, &amp;wordCount, countToGet, &amp;wordStart);        /* CountWords returns negative if there weren't any, or if we went too far */        if (wordCount &gt; 0) {            /* now count to the next word, so we know the range */            /* I know, I know, this is horribly inefficient, but it's an example, OK? */            CountWords(container, &amp;wordCount, countToGet + 1, &amp;wordEnd);            if (wordCount &lt; 0) {                /* ooops, no more words.  Just go to text len then */                wordEnd = GetHandleSize(theText);            }            /* return a word token */            wordToken = (CWordObjHandle)NewHandleClear(sizeof(CWordObject));            /* fill in the token */            (*wordToken)-&gt;theOwningWindow = (*ourTextObject)-&gt;theOwningWindow;            (*wordToken)-&gt;theText = (*ourTextObject)-&gt;theText;            (*wordToken)-&gt;startPos = wordStart;            (*wordToken)-&gt;endPos = wordEnd;            /* create the token */            myErr = AECreateDesc(cWord, (Ptr)*wordToken, sizeof(CWordObject), value);        } else {            /* error, no words */            myErr = errAENoSuchObject;            AddToReply(&quot;\pCould not find this number word in this text&quot;, 0);        }    } else {        myErr = errAENoSuchObject;        AddToReply(&quot;\pNo words in this Text&quot;, 0);    }    HSetState(theText, textHState);    return(myErr);}pascal OSErr DrawFromWindow(DescType desiredClass, const AEDesc *container, DescType containerClass, DescType form,                            const AEDesc *selectionData, AEDesc *value, long LongInt){#pragma unused (desiredClass,containerClass,form,selectionData,LongInt)    OSErr myErr = noErr;    mVerboseOutput(&quot;\p\nGetting a Drawing Area from a window&quot;)    /* the drawing area token is the same as a window token (i.e. a window pointer) since it gives */    /* us everything we need to know */    /* so basically we duplicate the descriptor passed in to us, then change the descType */    myErr = AEDuplicateDesc(container, value);    value-&gt;descriptorType = cDrawingArea;    return(myErr);}/* ShapeFromDraw pulls _any_ kind of shape from my drawing area.  It's called for *//* a generic cGraphicShape, a cGraphicLine,cRectangle, and cOval.  This is where *//* your code gets optimized and shrunken, so it is not the nightmare you  *//* at first thought.  Really *//* Note that this also gets called for shapes from cWindow (if someone asks that way) *//* so golly, it's just so useful */pascal OSErr ShapeFromDraw(DescType desiredClass, const AEDesc *container, DescType containerClass, DescType form,                           const AEDesc *selectionData, AEDesc *value, long LongInt){ #pragma unused (LongInt)    OSErr myErr = noErr;    windowCHandle tempWC;    long selNumber;    long tempCounter;    CShapeObjHandle theToken = (CShapeObjHandle)NewHandleClear(sizeof(CShapeObject));    ShapesHandle theShapes;    short numShapes;    mVerboseOutput(&quot;\p\nGetting a Shape from a window, specifically a &quot;)    AddToAEWindow((Ptr)&amp;desiredClass, kFour);    /* the container may be either a cWindow or a cDrawingArea.  In our infinite wisdom, */    /* we have made these tokens the same, so we can use the same routine for both. */    if (containerClass == cWindow || containerClass == cDrawingArea) {        /* get the right window struct and the shapes attached to it */        tempWC = (windowCHandle)GetWRefCon(*((WindowPtr *)(*(container-&gt;dataHandle))));        theShapes = (*tempWC)-&gt;theShapes;        numShapes = (*tempWC)-&gt;numShapes;        /* do some default filling of the shape token, since there's some things */        /* we already know */        (*theToken)-&gt;theOwningWindow = *((WindowPtr *)(*(container-&gt;dataHandle)));        (*theToken)-&gt;type = typeNull;                          /* flag for later folks */        if (numShapes) {            /* case off the type of shape we're asking for for the specific one */            switch (desiredClass) {                case cGraphicShape:                    /* just any old thing */                    /* case off the form wanted.  Since I am only sending myself graphics */                    /* by index, that's the case I'll do first */                case cGraphicLine:                case cRectangle:                case cOval:                    /* and all these shapes are basically the same, so I'll use the same routine */                    /* in fact, I'm going to go back to my window routine and make the type filed in my Shapes */                    /* handle a desc type, hold on a minute....  OK, I'm back, this will make it even easier */                    switch (form) {                        case formAbsolutePosition:                            if (selectionData-&gt;descriptorType == typeLongInteger) {                                                                selNumber = *((long *)*(selectionData-&gt;dataHandle));                            } else {                                /* see if you can coerce it to a long */                            }                            /* find the selNumber-th line in this drawing area */                            if (selNumber == 0)                                selNumber = 1;              /* no 0th */                            tempCounter = 0;                            while (theShapes) {                                /* 'if' here depending on generic shape or specific type */                                if (desiredClass == cGraphicShape) {                                    tempCounter++;          /* doesn't matter what kind, we care about it */                                } else {                                    if ((*theShapes)-&gt;aeType == desiredClass)                                        tempCounter++;                                }                                if (tempCounter == selNumber) {                                    break;                                } else {                                    theShapes = (*theShapes)-&gt;nextShape;                                }                            }                            /* if theShapes is not nil, then we found a shape that suites */                                                        if (theShapes) {                                /* fill in my token */                                (*theToken)-&gt;theShape = theShapes;                                (*theToken)-&gt;shapeNumber = tempCounter;     /* why do I want this?  I dunno */                                (*theToken)-&gt;type = desiredClass;                            } else {                                myErr = errAENoSuchObject;                            }                            break;                        case formRelativePosition:          /* next, previous */                            break;                        case formTest:                      /* A logical or a comparison */                            break;                        case formRange:                     /* Two arbitrary objects and everything in between */                            break;                        case formPropertyID:                /* Key data is a 4-char property name */                            break;                        case formName:                      /* Key data may be of type 'TEXT' */                                                        break;                        default:                            myErr = errAENoSuchObject;                            break;                    }                    break;            }        } else {            /* no shapes with this window */            myErr = errAENoSuchObject;        }    } else {        myErr = errAENoSuchObject;    }    if (myErr == noErr &amp;&amp; (*theToken)-&gt;type != typeNull) {        HLock((Handle)theToken);        myErr = AECreateDesc((*theToken)-&gt;type, (Ptr)*theToken, sizeof(CShapeObject), value);        DisposeHandle((Handle)theToken);    }    return(myErr);}/* In this example, this will be the first accessor called by any call to AEResolve. *//* Since we have no other objects sprouting from null but windows, anyone who *//* wants to know about our documents has to have a cWindow object spec hanging off the *//* topmost null. */pascal OSErr WindFromNull(DescType desiredClass, const AEDesc *container, DescType containerClass, DescType form,                          const AEDesc *selectionData, AEDesc *value, long LongInt){ #pragma unused (desiredClass,container,LongInt)    WindowPtr returnedWindow = nil;    WindowPtr tempWindow = nil;    short index = 0;    short counter = 0;    OSErr myErr = noErr;    Str63 tempMatch;    Str63 windowName;        mVerboseOutput(&quot;\p\nGetting a Window from Nul&quot;)    /* first check to see if we can deal with this, are they asking for a window from Nul?  */    /* If they're not then we can't handle it */    if (containerClass != typeNull)        return(errAENoSuchObject);                          /* not something we recognize */    /* case off form to see how we'll get the window thing */    /* all of these may not be supported, but as time goes by they will be */        switch (form) {        case formAbsolutePosition:                          /* e.g., 1st, -2nd ( 2nd from end) */            /* ignore the AEStatusWindow in searching this list */            tempWindow = FrontWindow();            /* a little utilty routine, see which number window they want */            ShortFromDesc(&amp;index, (AppleEvent *)selectionData);            if (index == 0)                index = 1;            if (index == 1 &amp;&amp; (((WindowPeek)FrontWindow())-&gt;windowKind != kAEStatusWindow)) {                /* just grab the front window and return */                returnedWindow = FrontWindow();            } else {                /* walk the list  */                tempWindow = (WindowPtr)LMGetWindowList();                while (tempWindow) {                    windowCHandle tempWC = (windowCHandle)GetWRefCon(tempWindow);                    if (index == (*tempWC)-&gt;windowIndex) {                        returnedWindow = tempWindow;                        break;                    }                    tempWindow = (WindowPtr)((WindowPeek)tempWindow)-&gt;nextWindow;                }            }            if (returnedWindow) {                                myErr = AECreateDesc(cWindow, (Ptr)&amp;returnedWindow, sizeof(returnedWindow), value);                mAEErrorDisplay(&quot;\p creating object token&quot;, myErr);            } else {                /* error, couldn't find the thing */                myErr = errAENoSuchObject;                AddToReply(&quot;\pNo window of that index number&quot;, 0);            }            break;        case formRelativePosition:                          /* next, previous */            break;        case formTest:                                      /* A logical or a comparison */            break;        case formRange:                                     /* Two arbitrary objects and everything in between */            break;        case formPropertyID:                                /* Key data is a 4-char property name */                        break;        case formName:                                      /* Key data may be of type 'TEXT' */            /* gettting one of these here things by name */            /* so the AEDesc has a text thing in it.  Not a PString, just a charater thing, */            /* so I'll make it a PString */            PStringFromTextDesc(&amp;tempMatch, selectionData);            /* and as usual, walk the window list */            tempWindow = FrontWindow();            while (tempWindow) {                GetWTitle(tempWindow, windowName);                if (EqualString(windowName, tempMatch, false, false))                    break;                tempWindow = (WindowPtr)((WindowPeek)tempWindow)-&gt;nextWindow;            }            if (tempWindow) {                /* we have a match */                myErr = AECreateDesc(cWindow, (Ptr)&amp;tempWindow, sizeof(tempWindow), value);                mAEErrorDisplay(&quot;\p creating object token&quot;, myErr);            } else {                /* no match, return an error  */                myErr = errAENoSuchObject;                AddToReply(&quot;\pNo window with that name&quot;, 0);            }            break;                }    return(myErr);}/* PropertyFromWindow gets all the properties of my window object. */pascal OSErr PropertyFromWindow(DescType desiredClass, const AEDesc *container, DescType containerClass, DescType form,                                const AEDesc *selectionData, AEDesc *value, long LongInt){ #pragma unused (desiredClass,containerClass,form,LongInt)    OSErr myErr = noErr;    Str63 windowName;    WindowPtr tempPort;    PropertyTHdl propertyTokenH = (PropertyTHdl)NewHandleClear(sizeof(PropertyToken));    /* pull a property from the window */    DescType propertyType = *(DescType *)(*(selectionData-&gt;dataHandle));    ProcessSerialNumber tempPSN;    Boolean tempBool;  Handle theData;    WindowPtr owningWindow;    windowCHandle owningControl;    mVerboseOutput(&quot;\p\n Getting a window property &quot;)    AddToAEWindow((Ptr)&amp;propertyType, kFour);    /* I can fill in some of the token information right now, since I have the window */    owningWindow = *((WindowPtr *)(*(container-&gt;dataHandle)));    owningControl = (windowCHandle)GetWRefCon(owningWindow);    (*propertyTokenH)-&gt;owningTokenType = cWindow;           /* what this is a property of */    (*propertyTokenH)-&gt;token.window = owningWindow;    (*propertyTokenH)-&gt;inWindow = owningWindow;  /* for consistency, though it's redundant */    switch (propertyType) {        /* can't get all of them yet, as this sample grows the amount of properties will also */        /* grow */                /* What's the name of this window? */        case pName:            (*propertyTokenH)-&gt;theProperty = pName;            (*propertyTokenH)-&gt;theDataType = typeChar;            GetWTitle(owningWindow, windowName);            theData = NewHandle(windowName[0]);            HLock(theData);            BlockMove((Ptr)&amp;windowName[1], (Ptr)*theData, windowName[0]);            HUnlock(theData);            (*propertyTokenH)-&gt;theData = theData;            break;            /* Boundry rectangle, in global coordinates */        case pBounds:            (*propertyTokenH)-&gt;theProperty = pBounds;            (*propertyTokenH)-&gt;theDataType = typeQDRectangle;            theData = NewHandle(sizeof(Rect));            HLock(theData);            BlockMove((Ptr)&amp;owningWindow-&gt;portRect, (Ptr)*theData, sizeof(Rect));            /* now we have to globalize the coordiantes */            GetPort(&amp;tempPort);            SetPort(owningWindow);            SetPort(tempPort);            /* Now, can we force the MPW C compiler to beleive us that what we're passing is  */            /* a Point pointer???? */            LocalToGlobal((Point *)*theData);            LocalToGlobal((Point *)(*theData + sizeof(Point)));            /* yes we can, amazing */                        HUnlock(theData);            (*propertyTokenH)-&gt;theData = theData;                        break;            /* Do we have a title bar? */        case pHasTitleBar:            (*propertyTokenH)-&gt;theProperty = pHasTitleBar;            (*propertyTokenH)-&gt;theDataType = typeBoolean;            theData = NewHandle(sizeof(short));            **theData = kMyTrue;                            /* they all do */            (*propertyTokenH)-&gt;theData = theData;            break;            /* are we a modal window? */        case pIsModal:            (*propertyTokenH)-&gt;theProperty = pIsModal;            (*propertyTokenH)-&gt;theDataType = typeBoolean;            theData = NewHandle(sizeof(short));            **theData = ((WindowPeek)owningWindow)-&gt;windowKind &amp; dialogKind;            (*propertyTokenH)-&gt;theData = theData;            break;            /* is this window 'dirty'? */        case pIsModified:            (*propertyTokenH)-&gt;theProperty = pIsModified;            (*propertyTokenH)-&gt;theDataType = typeBoolean;            theData = NewHandle(sizeof(short));            **theData = (*owningControl)-&gt;windowDirty;            (*propertyTokenH)-&gt;theData = theData;            break;            /* can the size be changed? */        case pIsResizable:            (*propertyTokenH)-&gt;theProperty = pIsResizable;            (*propertyTokenH)-&gt;theDataType = typeBoolean;            theData = NewHandle(sizeof(short));            **theData = kMyTrue;            (*propertyTokenH)-&gt;theData = theData;            break;            /* stationary? */        case pIsStationeryPad:            (*propertyTokenH)-&gt;theProperty = pIsResizable;            (*propertyTokenH)-&gt;theDataType = typeBoolean;            theData = NewHandle(sizeof(short));            **theData = false;            (*propertyTokenH)-&gt;theData = theData;            break;            /* Are we in the users face right now? */        case pIsFrontProcess:            (*propertyTokenH)-&gt;theProperty = pIsResizable;            (*propertyTokenH)-&gt;theDataType = typeBoolean;            theData = NewHandle(sizeof(short));            GetFrontProcess(&amp;tempPSN);            SameProcess(&amp;tempPSN, &amp;gOurSN, &amp;tempBool);            **theData = tempBool;            (*propertyTokenH)-&gt;theData = theData;            break;            /* are we in the Zoomed state? */        case pIsZoomed:            break;            /* are we visible to the user now? */        case pVisible:            (*propertyTokenH)-&gt;theProperty = pVisible;            (*propertyTokenH)-&gt;theDataType = typeBoolean;            theData = NewHandle(sizeof(short));            **theData = kMyTrue;                            /* I'm only returning visible windows  */            (*propertyTokenH)-&gt;theData = theData;            break;            /* What's our class? */        case pClass:            (*propertyTokenH)-&gt;theProperty = pClass;            (*propertyTokenH)-&gt;theDataType = typeType;                        theData = NewHandle(sizeof(DescType));            HLock(theData);            *((DescType *)*theData)=cWindow;            HUnlock(theData);            (*propertyTokenH)-&gt;theData = theData;                        break;                }        /* and return the token */    if (!myErr) {        HLock((Handle)propertyTokenH);        myErr = AECreateDesc(typeProperty, (Ptr)*propertyTokenH, sizeof(PropertyToken), value);        /* dispose of the token handle, but NOT the data handle I added, since the AEM */        /* had no idea that I put a handle inside the data, so it didn't copy that */        /* Later, when the token itself is disposed that handle will be  */        /* freed up. */        DisposeHandle((Handle)propertyTokenH);        mAEErrorDisplay(&quot;\p creating property token&quot;, myErr);            }    return(myErr);}/* This allows someone to get properties from my text */pascal OSErr PropertyFromText(DescType desiredClass, const AEDesc *container, DescType containerClass, DescType form,                              const AEDesc *selectionData, AEDesc *value, long LongInt){#pragma unused (desiredClass,containerClass,form,value,LongInt)    OSErr myErr = noErr;    PropertyTHdl propertyTokenH = (PropertyTHdl)NewHandleClear(sizeof(PropertyToken));    CTextObjHandle myTextHandle;                            /* I include a text object token in my text property token */    /* kinda circular, but hey... */    /* pull a property from a text */        DescType propertyType = *(DescType *)(*(selectionData-&gt;dataHandle));    Handle theData;    RGBColor myBlack =  {        0, 0, 0    };                                                      /* for the Color question */    Str255 tempString;    windowCHandle owningControl;    mVerboseOutput(&quot;\p\n Getting a text property &quot;)    AddToAEWindow((Ptr)&amp;propertyType, kFour);    /* I can fill in some of the token information right now, since I have the window */    myTextHandle = (CTextObjHandle)container-&gt;dataHandle;    owningControl = (windowCHandle)GetWRefCon((*myTextHandle)-&gt;theOwningWindow);    (*propertyTokenH)-&gt;owningTokenType = cText;             /* what this is a property of */    (*propertyTokenH)-&gt;token.textHandle = (*myTextHandle)-&gt;theText;    (*propertyTokenH)-&gt;theProperty = propertyType;  (*propertyTokenH)-&gt;inWindow = (*myTextHandle)-&gt;theOwningWindow;    switch (propertyType) {WritingCodePtr theCode;                case pAnyCharTextStyles:            (*propertyTokenH)-&gt;theDataType = typeBoolean;            theData = NewHandle(sizeof(short));            **theData = false;                              /* we have no style */            (*propertyTokenH)-&gt;theData = theData;            break;        case pClass:            (*propertyTokenH)-&gt;theDataType = typeType;            theData = NewHandle(sizeof(DescType));            **theData = cText;                              /* they all do */            (*propertyTokenH)-&gt;theData = theData;            break;        case pColor:            (*propertyTokenH)-&gt;theDataType = typeRGBColor;            /* always black in this example */            theData = NewHandle(sizeof(RGBColor));            HLock(theData);            BlockMove((Ptr)&amp;myBlack, (Ptr)*theData, sizeof(RGBColor));            HUnlock(theData);            (*propertyTokenH)-&gt;theData = theData;            break;        case pFont:            /* get the ID, translate to a name, and return as text */            /* our token contains a TERecord, which contains the font ID */            GetFontName((*(*propertyTokenH)-&gt;token.textHandle)-&gt;txFont, &amp;tempString);            theData = NewHandle(tempString[0]);            HLock(theData);            BlockMove((Ptr)&amp;tempString[1], (Ptr)*theData, tempString[0]);            HUnlock(theData);            (*propertyTokenH)-&gt;theData = theData;                        break;        case pPointSize:            /* Object Class ID: cFixed16 */            (*propertyTokenH)-&gt;theDataType = typeFixed;            theData = NewHandleClear(sizeof(long));      *((short *)*theData) = (*(*propertyTokenH)-&gt;token.textHandle)-&gt;txSize;                (*propertyTokenH)-&gt;theData = theData;                    case pScriptTag:            (*propertyTokenH)-&gt;theDataType = typeIntlWritingCode;            theData = NewHandle(sizeof(WritingCode));      theCode = (WritingCodePtr) *theData;      HLock(theData);      theCode-&gt;theScriptCode = FontScript();      theCode-&gt;theLangCode = iuSystemCurLang;      HUnlock(theData);            (*propertyTokenH)-&gt;theData = theData;            break;        case pTextStyles:            /* in my sample, no style */            (*propertyTokenH)-&gt;theDataType = typeBoolean;            theData = NewHandle(sizeof(short));            **theData = false;                              /* we have no style */            (*propertyTokenH)-&gt;theData = theData;                        break;            /*****************************/                }                                                       /* endswitch */            return(myErr);}pascal OSErr PropertyFromShape(DescType desiredClass, const AEDesc *container, DescType containerClass, DescType form,                               const AEDesc *selectionData, AEDesc *value, long LongInt){#pragma unused (desiredClass,containerClass,form,LongInt)    OSErr myErr = noErr;    PropertyTHdl propertyTokenH = (PropertyTHdl)NewHandleClear(sizeof(PropertyToken));    /* pull a property from the window */    CShapeObjHandle theShapeToken;                          /* the token for this shape */    RGBColor white =  {        0xFFFF, 0xFFFF, 0xFFFF    };    ShapesHandle theShape;    short penSize = 1;    long myCopy = 0;    DescType propertyType = *(DescType *)(*(selectionData-&gt;dataHandle));    Handle theData;    windowCHandle owningControl;    DescType shapeType;    mVerboseOutput(&quot;\p\n Getting a property from a shape&quot;)    theShapeToken = (CShapeObjHandle)container-&gt;dataHandle;    owningControl = (windowCHandle)GetWRefCon((*theShapeToken)-&gt;theOwningWindow);    shapeType = (*theShapeToken)-&gt;type;    theShape = (*theShapeToken)-&gt;theShape;    (*propertyTokenH)-&gt;owningTokenType = shapeType;    (*propertyTokenH)-&gt;token.shapeHandle = (*theShapeToken)-&gt;theShape;    (*propertyTokenH)-&gt;theProperty = propertyType;  (*propertyTokenH)-&gt;inWindow = (*theShapeToken)-&gt;theOwningWindow;    /* so after filling in a bunch, all we need now is the data type and the data itself */    switch (propertyType) {        case pBounds:        case pDefinitionRect:            /* This is the same as the bounds rect in my example */                        /* return a bounds rect, pretty easy */            (*propertyTokenH)-&gt;theDataType = typeQDRectangle;            theData = NewHandle(sizeof(Rect));            HLock(theData);            BlockMove((Ptr)&amp;(*theShape)-&gt;theRect, (Ptr)*theData, sizeof(Rect));            /* this of course stays in local coordinates for the owning port */            (*propertyTokenH)-&gt;theData;            break;        case pClass:            (*propertyTokenH)-&gt;theDataType = typeType;            theData = NewHandle(sizeof(DescType));            HLock(theData);            /* I know, blockmoving 4 bytes is silly.  */            BlockMove((Ptr)&amp;shapeType, (Ptr)*theData, sizeof(DescType));            break;        case pFillColor:            (*propertyTokenH)-&gt;theDataType = typeRGBColor;            /* always white in this example */            theData = NewHandle(sizeof(RGBColor));            HLock(theData);            BlockMove((Ptr)&amp;white, (Ptr)*theData, sizeof(RGBColor));            HUnlock(theData);            (*propertyTokenH)-&gt;theData = theData;                        break;        case pFillPattern:        case pPenPattern:            break;        case pPenColor:            (*propertyTokenH)-&gt;theDataType = typeRGBColor;            theData = NewHandle(sizeof(RGBColor));            HLock(theData);            BlockMove((Ptr)&amp;(*theShape)-&gt;theColor, (Ptr)*theData, sizeof(RGBColor));            HUnlock(theData);            (*propertyTokenH)-&gt;theData = theData;                        break;                    case pPenWidth:            (*propertyTokenH)-&gt;theDataType = typeShortInteger;            /* always white in this example */            theData = NewHandle(sizeof(short));            HLock(theData);            BlockMove((Ptr)&amp;penSize, (Ptr)*theData, sizeof(short));            break;        case pTransferMode:            (*propertyTokenH)-&gt;theDataType = typeEnumeration;            /* always white in this example */            theData = NewHandle(sizeof(long));            HLock(theData);            BlockMove((Ptr)&amp;myCopy, (Ptr)*theData, sizeof(long));            break;    }    HUnlock(theData);  /* dangme I forgot to move what I just did into result..... */  if (!myErr) {        HLock((Handle)propertyTokenH);        myErr = AECreateDesc(typeProperty, (Ptr)*propertyTokenH, sizeof(PropertyToken), value);        /* dispose of the token handle, but NOT the data handle I added, since the AEM */        /* had no idea that I put a handle inside the data, so it didn't copy that */        /* Later, when the token itself is disposed that handle will be  */        /* freed up. */        DisposeHandle((Handle)propertyTokenH);        mAEErrorDisplay(&quot;\p creating property token&quot;, myErr);            }      return(myErr);}/* You may never need a dispose function.  If all you use for tokens are *//* simple AEDescs, the OSL will do all the disposal for you. *//* In my case, my tokens contain  handles, so I have to  *//* do some disposal myself. */pascal OSErr MyDisposeTokenProc(AEDesc *unneededToken){    OSErr myErr = noErr;    PropertyTHdl myProp;    mVerboseOutput(&quot;\p\nDisposing a Token: &quot;)    AddToAEWindow((Ptr)&amp;(unneededToken-&gt;descriptorType), kFour);    /* most of the time I'll be doing a simple AEDisposeDesc.  The only time I need  */    /* something more complex is when I'm disposing of a property descriptor, since */    /* I have a handle inside that */    switch (unneededToken-&gt;descriptorType) {        /* these two are simple */        case cWindow:        case cText:            myErr = AEDisposeDesc(unneededToken);            break;            /* these two have imbedded handles */        case cWord:            myErr = AEDisposeDesc(unneededToken);            break;        case typeProperty:            myProp = (PropertyTHdl)unneededToken-&gt;dataHandle;            DisposeHandle((*myProp)-&gt;theData);            myErr = AEDisposeDesc(unneededToken);                        break;                    default:            /* I default to just disposing of the token, ne ces pa  */            AEDisposeDesc(unneededToken);            break;    }    return(myErr);}/* not yet implemented (and also not installed as a callback) */pascal OSErr MyCompareProc(DescType oper, const AEDesc *obj1, const AEDesc *obj2, Boolean *result){#pragma unused (oper,obj1,obj2,result)    OSErr myErr = noErr;    mVerboseOutput(&quot;\p\nComparing Objects&quot;)    return(myErr);}pascal OSErr MyCountProc(DescType desiredType, DescType containerClass, const AEDesc *container, long *result){    OSErr myErr = noErr;    long counter = 0;    WindowPtr windows;    windowCHandle tempWC;    switch (desiredType) {        case cWindow:            /* should be conting windows from nul */            mVerboseOutput(&quot;\p\nCounting Windows&quot;)            windows = (WindowPtr)LMGetWindowList();            while (windows) {                counter++;                windows = (WindowPtr)((WindowPeek)windows)-&gt;nextWindow;            }            *result = counter;            break;        case kAEMyShape:            mVerboseOutput(&quot;\p\nCounting Shapes&quot;)            /* getting this from a specific container, i.e. a winder. */            switch (containerClass) {                case cWindow:        case cDrawingArea:                    /* we're OK so far */                    /* get my window pointer from the container passed */          CountShapes(container,&amp;counter,nil,nil,&amp;desiredType);          *result = counter;                    break;                case typeNull:                    /* this would mean all the possible shapes  */                    break;            }            break;        case cText:            mVerboseOutput(&quot;\p\nCounting Texts&quot;)            switch (containerClass) {                /* I can count texts in a window and in Null (the app) */                case typeNull:                    /* walk all my document windows and see how many texts exisit */                    windows = FrontWindow();                    /* there may not be any, o'course */                    while (windows) {                        tempWC = (windowCHandle)GetWRefCon(windows);                        if ((*tempWC)-&gt;boxHandle)                            counter++;                        windows = (WindowPtr)((WindowPeek)windows)-&gt;nextWindow;                    }                    *result = counter;                    break;                case cWindow:                    /* so we know the container desc is my window token */                    windows = (WindowPtr)*(container-&gt;dataHandle);                    tempWC = (windowCHandle)GetWRefCon(windows);                    /* there is either one or none */                    *result = (((*tempWC)-&gt;boxHandle) ? 1 : 0);                    break;                default:                    mVerboseOutput(&quot;\p\nAsked for text count from something we don't understand &quot;)                    myErr = errAECantHandleClass;              /* add new Winter '92 registry error code &lt;ckh 1.0.2&gt;*/          AddToReply(&quot;\p Cant count this class&quot;,errAECantHandleClass);                    counter = 0;                    break;            }            *result = counter;            break;        case cWord:            /* Since I have to count words in another place (when I get the word) */            /* I will call my subroutine, saying I don't want to stop */            mVerboseOutput(&quot;\p\nCounting Words &quot;)            CountWords(container, &amp;counter, nil, nil);      *result = counter;            break;        case cGraphicLine:        case cRectangle:        case cOval:        case cGraphicShape:            /* all these are basically the same */            CountShapes(container, &amp;counter, nil, nil, &amp;desiredType);      *result = counter;            break;    default:            myErr = errAENoSuchObject;                      /* I don't know what's being asked for */            break;    }    return(myErr);}void CountWords(const AEDesc *container, long *theCount, long stopAt, long *position){    CTextObjHandle ourTextObject;    Handle theText;    SignedByte textState;    char *textPtr;    register char letter;    long wordCount = 1;                                     /* I'm getting passed a 1 based count to find */    Boolean inSpaces = false;    register long positionNow = 0;    long lastLetter = 0;    /* So we have a text object here, which contains a TEHandle */    /* We step through the handle counting words */    /* get the text from my cText token */        AddAENum(stopAt);    ourTextObject = (CTextObjHandle)(container-&gt;dataHandle);    *position = -1;    theText = (Handle)TEGetText((*ourTextObject)-&gt;theText);    textState = HGetState(theText);    HLock(theText);                                         /* AddAENum makes some TextEdit calls, so I need to lock this */    /* how many characters are in it? */    lastLetter = GetHandleSize(theText);    if (lastLetter) {        /* now this is a slow and agonizing word count routine, it's not intended to be any more than that */        textPtr = (char *)*theText;        for (positionNow = 0; positionNow &lt; lastLetter; positionNow++) {            letter = *(textPtr + positionNow);            if (letter == kSpace) {                if (!inSpaces)                    wordCount++;                inSpaces = kMyTrue;                if (stopAt &amp;&amp; stopAt == wordCount) {                    if (position)                        *position = positionNow;                    break;                }            } else {                inSpaces = false;            }        }        /* Did we have fun counting words?  Yes? */        /* OK, we have a word count */        /* if position is still negative, we didn't get to this word.  Maybe there weren't enough */        if (*position &gt;= 0)            *theCount = wordCount;        else            *theCount = -1;        AddAENum(wordCount);    } else {        /* no words (or letters) in this thing */        *theCount = -1;    }    HSetState(theText, textState);}void CountShapes(const AEDesc *container, long *theCount, long stopAt, long *position, DescType *whichType){#pragma unused (stopAt,position)    WindowPtr owner;  windowCHandle tempWCH;  ShapesHandle  theShapes;    mVerboseOutput(&quot;\p\nCounting Shapes &quot;)    if (container-&gt;descriptorType == cWindow || container-&gt;descriptorType == cDrawingArea) {        owner = *((WindowPtr *)(*(container-&gt;dataHandle)));    tempWCH = (windowCHandle)GetWRefCon(owner);    if(*whichType == cGraphicShape){    *theCount = (*tempWCH)-&gt;numShapes;    } else {    /* find specific things */    *theCount = 0;    theShapes = (*tempWCH)-&gt;theShapes;    while(theShapes){    if((*theShapes)-&gt;aeType == *whichType)*theCount +=1;    theShapes = (*theShapes)-&gt;nextShape;    }    }        } else {        /* no luck joe, can't count items from this container */    *theCount = -1;    }}/* not yet implemented (and also not installed as a callback) */pascal OSErr MyGetMarkTokenProc(const AEDesc *dContainerToken, DescType containerClass, AEDesc *result){#pragma unused (dContainerToken,containerClass,result)    OSErr myErr = noErr;    mVerboseOutput(&quot;\p\nGetting a Mark token&quot;)    return(myErr);}/* not yet implemented (and also not installed as a callback) */pascal OSErr MyMarkProc(const AEDesc *dToken, const AEDesc *markToken, long index){    OSErr myErr = noErr;#pragma unused (dToken,markToken,index)     mVerboseOutput(&quot;\p\nMarking something&quot;)    return(myErr);}/* not yet implemented (and also not installed as a callback) */pascal OSErr MyAdjustMarksProc(long newStart, long newStop, const AEDesc *markToken){#pragma unused (newStart,newStop,markToken)    OSErr myErr = noErr;    mVerboseOutput(&quot;\p\nAdjusting Marks&quot;)    return(myErr);}/* This builds our GetData event, based on the things you've set up in the object *//* definition dialogs. */OSErr BuildGetDataEvent(AppleEvent *thisEvent, short which){    OSErr myErr = noErr;    AEDesc object;    myErr = BuildFullObject(&amp;object, which);    myErr = AEPutParamDesc(thisEvent, keyDirectObject, &amp;object);    mAEErrorDisplay(&quot;\p putting object&quot;, myErr)    if (!myErr)        AEDisposeDesc(&amp;object);    /* one last thing to deal with.  We _can_, if we want, add a keyAERequestedType parameter. */    /* this is optional, and specifies the format of the data we'd like to work with. */    /* NOTE:  The receiver of this event may ignore this completely.  There may be */    /* two reasons for the ignoring.... */    /* 1) It's an optional param.  That means the receiver may not even look for it, or */    /* know it's there. */    /* 2) They may not be able to do it.  They may not be able to coerce their data to the */    /* type you'd like to get back.  If so, they'll still send data back, it'll just */    /* be in the standard format (as described in the registry) for this event and object. */    /*  You will have to do the coercion yourself. */    /* By The Way:  If you add system level coercion routines for the types you like to see */    /* other apps on the same machine will be able to coerce to your types without having any */    /* understanding of them. */  /* By The Way II:  If you do not get back the type you want, you should also */  /* try and coerce it yourself.  Perhaps you have the correct coercion */  /* routine on your machine, one that was not available to the other app. */    return(myErr);}/* This builds our SetData event, based on the things you've set up in the object *//* definition dialogs. *//* It's a little more complicated, since I have to throw in dialogs to get the  *//* new value you want */OSErr BuildSetDataEvent(AppleEvent *thisEvent, short which){    OSErr myErr = noErr;    DialogPtr tdial;  short strung;  RGBColor oldColor = {0,0,0};  RGBColor newColor;    Str63 paramString;    short hitItem = 0;    DescType theDataDesc;    short doVis;    short *tempShortPtr;    Handle theDataHandle = NewHandle(0);    AEDesc object;    AEDesc dataToSet;    /* build the window based on previous things (from dialog) */    myErr = BuildFullObject(&amp;object, which);    mAEErrorDisplay(&quot;\p putting object&quot;, myErr)    if (!myErr) {        /* We've got the object built.  Since this is a SetData event, now we have to add the */        /* actual data to set to the thing.  Yes kids, its DialogBox time.... */        /* There's nothing interesting here except dialog box handling, if you want to get */        /* on to Objects and &reg;s again, skip ahead to **here** */        tdial = CommonDStart(kSetDDialog, 0, 0);        /* show the correct items */        switch (which) {            case kWindowBoundsItem:                ShowDialogItem(tdial, kRectTextItem);                ShowDialogItem(tdial, kRectEdit1);                ShowDialogItem(tdial, kRectEdit2);                ShowDialogItem(tdial, kRectEdit3);                ShowDialogItem(tdial, kRectEdit4);                break;            case kWindowTitleItem:                ShowDialogItem(tdial, kNewTitleWordsItem);                ShowDialogItem(tdial, kNewTitleEditLineItem);                break;            case kWindowVisiblityItem:                ShowDialogItem(tdial, kMakeVisItem);                ShowDialogItem(tdial, kMakeInvisItem);                                break;            case kAllText:                ShowDialogItem(tdial, kNewTextItem);                ShowDialogItem(tdial, kNewText);                                break;            case kWordText:                ShowDialogItem(tdial, kNewWordItem);                ShowDialogItem(tdial, kNewText);                                break;            case kShapeItem:                ShowDialogItem(tdial, kNewSBoundsRadio);                ShowDialogItem(tdial, kNewSColorRadio);        ShowDialogItem(tdial, kNewSColorButton);                ShowDialogItem(tdial, kRectEdit1);                ShowDialogItem(tdial, kRectEdit2);                ShowDialogItem(tdial, kRectEdit3);                ShowDialogItem(tdial, kRectEdit4);        HiliteControl(SnatchHandle(tdial, kNewSColorButton),255);        SetControlValue(SnatchHandle(tdial, kNewSBoundsRadio), true);                  break;        }        if(which != kShapeItem)      strung = which - 1 + kSettingVis;    else      strung = kSettingShape;    GetIndString(paramString, kGeneralStrings, strung);    /* I'm going to add a little more text here */    if(which == kShapeItem)      {DescType shapeTypes[] =  {           cGraphicLine, cRectangle, cOval        };      Str32 theNum;      HLock((Handle)gShapeObjSpecHandle);      theNum[0] = 6;      theNum[1] = ' ';      BlockMove((Ptr)&amp;(*gShapeObjSpecHandle)-&gt;form,(Ptr)&amp;theNum[2],kFour);      theNum[6] = ' ';      AppendString(&amp;paramString,&amp;theNum);      NumToString((*gShapeObjSpecHandle)-&gt;u.index,&amp;theNum);      AppendString(&amp;paramString,&amp;theNum);      HUnlock((Handle)gShapeObjSpecHandle);            }        ParamText(paramString, &quot;&quot;, &quot;&quot;, &quot;&quot;);        ShowWindow(tdial);        DrawDialog(tdial);        if (which == kWindowVisiblityItem)            SetControlValue(SnatchHandle(tdial, kMakeVisItem), true);        doVis = true;        {      ModalFilterUPP upp = NewModalFilterProc(standardDialogFilter);      while (hitItem != ok &amp;&amp; hitItem != cancel) {        ModalDialog(upp, &amp;hitItem);        /* the only one that has anything we need to set is the visibility one */        if (which == kWindowVisiblityItem) {          if (hitItem == kMakeVisItem || hitItem == kMakeInvisItem) {            SetControlValue(SnatchHandle(tdial, kMakeVisItem), false);            SetControlValue(SnatchHandle(tdial, kMakeInvisItem), false);            SetControlValue(SnatchHandle(tdial, hitItem), true);          }        }        if (which == kShapeItem) {          switch (hitItem){          Point where;          case kNewSBoundsRadio:          case kNewSColorRadio:            SetControlValue(SnatchHandle(tdial, kNewSBoundsRadio), false);            SetControlValue(SnatchHandle(tdial, kNewSColorRadio), false);            SetControlValue(SnatchHandle(tdial, hitItem), true);          if(GetControlValue(SnatchHandle(tdial, kNewSColorRadio)))          HiliteControl(SnatchHandle(tdial, kNewSColorButton),0);          else          HiliteControl(SnatchHandle(tdial, kNewSColorButton),255);          break;          case kNewSColorButton:        GetIndString(paramString, kGeneralStrings, kNewSCol);        where.v = -1;        where.h = -1;          GetColor(where,paramString,&amp;oldColor,&amp;newColor);          break;          }        }      }      DisposeRoutineDescriptor(upp);    }            if (hitItem == 1) {            /* and one more switch, pull parameters and create the actual data descriptor that */            /* we will pass along in the SetData event. */            /* **here** */            /* pull the various parameters for the data to set, create a Desc to hold them, */            /* and add that desc to our event */            switch (which) {                Str255 tempString;                long theNum;                register qq;                case kWindowBoundsItem:                    theDataDesc = typeQDRectangle;                    /* ugg.  Go through all the edit lines and make a rect  */                    SetHandleSize(theDataHandle, sizeof(Rect));                    tempShortPtr = (short *)*theDataHandle;                    HLock(theDataHandle);                    for (qq = kRectEdit1; qq &lt; kRectEdit4 + 1; qq++) {                        GetDialogItemText((Handle)SnatchHandle(tdial, qq), tempString);                        StringToNum(tempString, &amp;theNum);                        *tempShortPtr = theNum;                        tempShortPtr = tempShortPtr + 1;        /* I have had problems with MPW C dealing with a += on a pointer, so I don't do it */                    }                    break;                case kWindowTitleItem:                    theDataDesc = typeChar;                    GetDialogItemText((Handle)SnatchHandle(tdial, kNewTitleEditLineItem), tempString);                    SetHandleSize(theDataHandle, tempString[0]);                    /* move the text into the handle */                    HLock(theDataHandle);                    BlockMove((Ptr)&amp;tempString[1], (Ptr)*theDataHandle, tempString[0]);                    /* leave the data handle locked for later */                    break;                case kWindowVisiblityItem:                    theDataDesc = typeBoolean;                    doVis = GetControlValue(SnatchHandle(tdial, kMakeVisItem));                    SetHandleSize(theDataHandle, sizeof(short));        /* a boolean is short length */                    HLock(theDataHandle);                   /* for later */                    tempShortPtr = (short *)*theDataHandle;                    *tempShortPtr = (doVis ? -1 : false);                    break;                case kAllText:                case kWordText:                    /* these are both the same */                    theDataDesc = typeChar;                    GetDialogItemText((Handle)SnatchHandle(tdial, kNewText), tempString);                    SetHandleSize(theDataHandle, tempString[0]);                    /* move the text into the handle */                    HLock(theDataHandle);                    BlockMove((Ptr)&amp;tempString[1], (Ptr)*theDataHandle, tempString[0]);                                        break;                case kShapeItem:        /* make the parameters for the shape change */        if(GetControlValue(SnatchHandle(tdial, kNewSColorRadio))){        /* setting color, the color is in newColor */                            theDataDesc = typeRGBColor;                    SetHandleSize(theDataHandle, sizeof(RGBColor));          HLock(theDataHandle);          BlockMove((Ptr)&amp;newColor,*theDataHandle,sizeof(RGBColor));        } else {        /* setting rect, same stuff as window  */                            theDataDesc = typeQDRectangle;                    SetHandleSize(theDataHandle, sizeof(Rect));                    tempShortPtr = (short *)*theDataHandle;                    HLock(theDataHandle);                    for (qq = kRectEdit1; qq &lt; kRectEdit4 + 1; qq++) {                        GetDialogItemText((Handle)SnatchHandle(tdial, qq), tempString);                        StringToNum(tempString, &amp;theNum);                        *tempShortPtr = theNum;                        tempShortPtr = tempShortPtr + 1;        /* I have had problems with MPW C dealing with a += on a pointer, so I don't do it */                    }        }        AddShapeProperty(&amp;object,GetControlValue(SnatchHandle(tdial, kNewSColorRadio)));                    break;            }        } else {            myErr = userCanceledErr;        }        DisposeDialog(tdial);        /* dialog is gone, the data we want is in theDataHandle, the descriptor type is in theDataDesc, */        /* it's time to put the data on the event. */        /* create a desc to hold it */        if (hitItem == 1) {      /* put the object into the event now */      myErr = AEPutParamDesc(thisEvent, keyDirectObject, &amp;object);          AEDisposeDesc(&amp;object);                        myErr = AECreateDesc(theDataDesc, (Ptr)*theDataHandle, GetHandleSize(theDataHandle), &amp;dataToSet);            DisposeHandle(theDataHandle);                    /* don't need this anymore */            if (!myErr) {                /* the desc created fine.  Add this to the event */                myErr = AEPutParamDesc(thisEvent, keyAEData, &amp;dataToSet);                myErr = AEDisposeDesc(&amp;dataToSet);                /* and the event is all ready to be sent by the caller, so we return */            }        } else {            myErr = userCanceledErr;        }    }    return(myErr);}/* BuildFullObject builds an object specifier based on the parameters set in *//* the object dialogs in this sample. */OSErr BuildFullObject(AEDesc *object, short which){    OSErr myErr = noErr;    AEDesc tempDesc;    AEDesc otherTemp;    long number1 = 1;    DescType Props[3] =  {        pBounds, pName, pVisible    };        BuildWindowObject(object);    switch (which) {        /* we already have a window object, so for the first three, create a property desc and type */    /* since we're only working with the properties of windows */        case kWindowBoundsItem:        case kWindowTitleItem:        case kWindowVisiblityItem:            AEDuplicateDesc(object, &amp;otherTemp);            myErr = AECreateDesc(typeType, (Ptr)&amp;Props[which - 1], kFour, &amp;tempDesc);            myErr = CreateObjSpecifier(typeProperty, &amp;otherTemp, formPropertyID, &amp;tempDesc, true, object);                        break;                    case kAllText:            /* we're asking for all the text in the window */            AEDuplicateDesc(object, &amp;otherTemp);            HLock((Handle)gTextObjSpecHandle);            if ((*gTextObjSpecHandle)-&gt;u.index == 0)                (*gTextObjSpecHandle)-&gt;u.index = 1;            myErr = AECreateDesc(typeLongInteger, (Ptr)&amp;(*gTextObjSpecHandle)-&gt;u.index, sizeof(long), &amp;tempDesc);                        myErr = CreateObjSpecifier(cText, &amp;otherTemp, formAbsolutePosition, &amp;tempDesc, true, object);                        HUnlock((Handle)gTextObjSpecHandle);            break;        case kWordText:            /* one word from the window and text object  */            AEDuplicateDesc(object, &amp;otherTemp);            HLock((Handle)gTextObjSpecHandle);            if ((*gTextObjSpecHandle)-&gt;u.index == 0)                (*gTextObjSpecHandle)-&gt;u.index = 1;            myErr = AECreateDesc(typeLongInteger, (Ptr)&amp;(*gTextObjSpecHandle)-&gt;u.index, sizeof(long), &amp;tempDesc);                        myErr = CreateObjSpecifier(cText, &amp;otherTemp, formAbsolutePosition, &amp;tempDesc, true, object);            AEDuplicateDesc(object, &amp;otherTemp);            if ((*gTextObjSpecHandle)-&gt;wordNumber == 0)                (*gTextObjSpecHandle)-&gt;wordNumber = 0;            myErr = AECreateDesc(typeLongInteger, (Ptr)&amp;(*gTextObjSpecHandle)-&gt;wordNumber, sizeof(long), &amp;tempDesc);            myErr = CreateObjSpecifier(cWord, &amp;otherTemp, formAbsolutePosition, &amp;tempDesc, true, object);                        HUnlock((Handle)gTextObjSpecHandle);            break;            /* for these, we have to add the additional cDrawingArea container */        case kShapeItem:            AEDuplicateDesc(object, &amp;otherTemp);            /* this always defaults to 1, we have only one drawing area per window */            AECreateDesc(typeLongInteger, (Ptr)&amp;number1, sizeof(long), &amp;tempDesc);            myErr = CreateObjSpecifier(cDrawingArea, &amp;otherTemp, formAbsolutePosition, &amp;tempDesc, true, object);            /* now which the thing */            myErr = CreateShapeObject(object);            break;    }    mAEErrorDisplay(&quot;\p creating object&quot;, myErr)        return(myErr);    }/* BuildWindowObject builds a window object from null, based on the parameters you have *//* specified in the dialog boxes */OSErr BuildWindowObject(AEDesc *returnedObject){    long theLong = 1;    OSErr myErr = noErr;    AEDesc containerDesc;    AEDesc theIdentifier;    /* establish some defaults so the object will be right even if the Window Object dialog hasn't been used */    DescType theForm = formAbsolutePosition;    long number1 = 1;    HLock((Handle)gWindObjSpecHandle);    switch ((*gWindObjSpecHandle)-&gt;form) {        case formAbsolutePosition:            theForm = formAbsolutePosition;            /* make an abs for spec */            /* What??  What that comment really meant, was create an object specifier for a window */            /* based on the data we have stored in our window descriptor object, that's */            /* set with the dialog, based on absolute position or name */            if ((*gWindObjSpecHandle)-&gt;u.index == 0)                (*gWindObjSpecHandle)-&gt;u.index = 1;            myErr = AECreateDesc(typeLongInteger, (Ptr)&amp;(*gWindObjSpecHandle)-&gt;u.index, sizeof(long), &amp;theIdentifier);                        break;        case formName:            /* make an object specifier based on window name */                        theForm = formName;            myErr = AECreateDesc(typeChar, (Ptr)&amp;(*gWindObjSpecHandle)-&gt;u.name[1], (*gWindObjSpecHandle)-&gt;u.name[0],                                 &amp;theIdentifier);            break;        default:            /* defaults to a byindex, window one spec if nothing else has been set up */            myErr = AECreateDesc(typeLongInteger, (Ptr)&amp;number1, sizeof(long), &amp;theIdentifier);            break;    }    mAEErrorDisplay(&quot;\p creating formProperty for this thing&quot;, myErr)    /* Every event will act on a window */        /* we're always adding windows from nul, so duplicate nul */    AEDuplicateDesc(&amp;gNullDesc, &amp;containerDesc);        /* build a window object contained in nul */    myErr = CreateObjSpecifier(cWindow, &amp;containerDesc, theForm, &amp;theIdentifier, true, returnedObject);    mAEErrorDisplay(&quot;\p creating window object&quot;, myErr)    HUnlock((Handle)gWindObjSpecHandle);    return(myErr);}/* CreateShapeObject attached the shape object to the basic specifier *//* already created (nul&gt;cWindow&gt;cDrawingArea) *//* Since all my shapes are basically the same, we have one routine to do this for us */OSErr CreateShapeObject(AEDesc *theContainer){    AEDesc tempDesc;    AEDesc indexDesc;  DescType theType;    OSErr myErr = noErr;    HLock((Handle)gShapeObjSpecHandle);  theType = (*gShapeObjSpecHandle)-&gt;form;    /* duplicate what we have so far */    AEDuplicateDesc(theContainer, &amp;tempDesc);    /* In this example, we're only implementing a ByIndex form for graphics, so... */    if ((*gShapeObjSpecHandle)-&gt;u.index == 0)        (*gShapeObjSpecHandle)-&gt;u.index = 1;    myErr = AECreateDesc(typeLongInteger, (Ptr)&amp;(*gShapeObjSpecHandle)-&gt;u.index, sizeof(long), &amp;indexDesc);    myErr = CreateObjSpecifier(theType, &amp;tempDesc, formAbsolutePosition, &amp;indexDesc, true, theContainer);    HUnlock((Handle)gShapeObjSpecHandle);    return(myErr);}/* AddShapeProperty tacks a property specifier onto an already created shape specifier */OSErr AddShapeProperty(AEDesc *theObject,Boolean which){  AEDesc tempDesc,otherTemp;  DescType theProp;  OSErr myErr = noErr;  if(which)    theProp = pPenColor;  else    theProp = pBounds;  myErr = AEDuplicateDesc(theObject, &amp;otherTemp);  myErr |= AECreateDesc(typeType,(Ptr) &amp;theProp, kFour, &amp;tempDesc);  myErr |= CreateObjSpecifier(typeProperty, &amp;otherTemp, formPropertyID, &amp;tempDesc, true, theObject);    return(myErr);}#undef __AEOBJ__</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/AEObject-Edition_Sample/listing2.html%3Fid%3DDTS10000204-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/AEObject-Edition_Sample/listing2.html%3Fid%3DDTS10000204-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/AEObject-Edition_Sample/listing2.html%3Fid%3DDTS10000204-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>