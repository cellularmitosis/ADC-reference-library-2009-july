<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"        "http://www.w3.org/TR/1998/REC-html40-19980424/loose.dtd"><HTML><head><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css">   <title>Technical Note HW32: Speedy the Math Coprocessor</title><meta name="categories" content="Hardware"><meta name="week-posted" content="May 29, 1989 - Jun 2, 1989"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF" TEXT="#000000"><a name="//apple_ref/doc/uid/DTS10002501" title="Speedy the Math Coprocessor"></a><a name="top"></a><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxHardwareDrivers-date.html">Hardware & Drivers</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/HardwareDrivers/index.html" target="_blank">Reference Library > Hardware & Drivers</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --> <!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note HW32</div>
<div id="pageheadsub">Speedy the Math Coprocessor</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->                     <P id = "menutext">         <A HREF="#Introduction">Introduction</A><BR><BR> <A HREF="#Section1">So What Can These Chips Do?</A><BR><BR><A HREF="#Section2">Internal Registers for a Higher Capacity to Think</A><BR><BR><A HREF="#Section3">Floating-Point Data Formats</A><BR><BR><A HREF="#Section4">So What Tools Do I Have to Play With?</A><BR><BR><A HREF="#Section5">Why and How do I Program for a 68882?</A><BR><BR><A HREF="#Conclusion">Conclusion</A><BR><BR><A HREF="#References">References</A><BR><BR><A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><P id = "introtext">This Technical Note presents an overview of the 68881 and         68882 math coprocessors, and it covers general information         about the chips as well as how using the chips directly can         help speed your math-intensive code.</p><!-- end_intro_text --><!-- begin_date --><h3 align=center>[Sep 01 1992]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR><!-- begin_content --><a name="Introduction"></a>         <h2>Introduction</h2>                  <P>Generally we don't recommend that you assume the         existence of specific hardware. However, if your program         does proper feature checking using <code>_SysEnvirons</code> and there is         a Floating-Point Unit (FPU) available, than you can use code         which will run your math intensive code much faster. This         Technical Note is basically a condensed version of the         Motorola MC68881/MC68882 Floating-Point Coprocessor User's         Manual. I will cover some of the basics of what the chips         can do, their differences, and how to take advantage of what         they have to offer.</P>                                    <P>If <code>_SysEnvirons</code> returns hasFPU = FALSE, then your code         should use the routines provided by the Standard Apple         Numeric Environment (SANE). The routines which SANE provide         are covered in the Apple Numerics Manual.</p>         <a name="Section1"></a>         <P><A HREF="#top">Back to top</A></P><h2>So What Can These Chips Do?</h2>                  <P>The MC68881 and MC68882 are floating-point coprocessors         which implement the IEEE standard for binary floating-point         arithmetic. The two chips are fully interchangeable and are         primarily for use as coprocessors to the MC68020 and MC68030         central processors. The two chips will work as peripheral         processors to the MC68000, MC68008, and MC68010 central         processors.</P>                                    <P>Both chips have eight 80-bit general purpose         floating-point data registers (FP0-FP7), 67-bit arithmetic         units with precision greater than the extended format,         67-bit barrel shifter, 46 instructions, trigonometric and         transcendental functions, and 21 constants. The MC68882 also         has the capability of concurrent execution of multiple         floating-point instructions.</P>                  <a name="Section2"></a>         <P><A HREF="#top">Back to top</A></P><h2>Internal Registers for a Higher Capacity to Think</h2>                  <P>There are eleven separate registers in these puppies:         eight data registers, one control register, one status         register, and one address register.</P>                  <h3>Data Registers</h3>                  <P>There are eight 80-bit floating-point data registers         labeled FP0-FP7. The extended format, which is used by these         registers, will be covered later. When using the FPU from an         MPW C and Pascal application, you can us FP0-FP3 for         temporary storage without saving and restoring their values.         If you wish to use FP4-FP7 in your assembly routine, then         you must save these registers at the start of your assembly         code and restore them before you leave the assembly         code.</P>                  <h3>Control Register (FPCR)</h3>                  <P>Below is a representation of the control register. For         the most part, there is no need for you to do anything to         the control register directly. It is used internally for         determining precision, rounding, and error checking.</P>                  <P align=center><img src="images/hw_32_001.gif" align=bottom alt="Control Register" width=320 height=236></P>                                    <P align=center><B>Figure 1</B> - Control Register</P>                  <h3>Status Register (FPSR)</h3>                  <P>The status register is diagrammed in Figure 2. This         register is also used mostly for internal chores. The         condition-code byte is set at the end of each arithmetic         instruction. The condition-code byte is translated into a         data type; Table 1 shows the relationship between condition         codes and data types. The condition code is also used to         determine logic equates. If you wish to determine if two         numbers are equal, than the Compare statement (FCMP) will         check the condition code. Table 2 shows the relationship         between the condition codes and logic equates.</P>                                    <P>The quotient byte is set at the completion of FMOD         (Modulo Remainder) and FREM (IEEE Remainder). This byte can         be used before a transcendental function to determine the         quadrant of a circle in which an operand resides. The         FP-exception status byte is used in conjunction with the         exception-enable byte of the control register. The         FP-accrued exception byte is used to keep a history of the         FP exceptions that have occurred since the last set or         clear.</P>                  <P align=center><img src="images/hw_32_002.gif" align=bottom alt="Status Register" width=480 height=268></P>                                    <P align=center><B>Figure 2</B> - Status Register</P>                                    <P align=center><img src="images/hw_32_003.gif" align=bottom alt="" width=416 height=434></P>                                    <h3>Address Register (FPIAR)</h3>                  <P>Since the coprocessor can do concurrent processing with         the MC68020 and MC68030, as well as with itself, the program         counter is not necessarily pointing to the logical address         of the instruction upon which it is working. So the address         register stores the logical address of each floating-point         instruction before executing it.</P>         <a name="Section3"></a>         <P><A HREF="#top">Back to top</A></P><h2>Floating-Point Data Formats</h2>                  <P>There are four floating-point numeric formats:         single-precision binary real format, double-precision binary         real format, eXtended-precision binary real format, and Pack         decimal real format (a.k.a., BCD). I have given examples of         what the FPU will convert your numbers to. The number which         I have used for the four examples is Planck's constant         (4.136 x 10[-15] eV-sec)._ Other than the size, the         first three formats are very similar. The three formats all         have the same conversion method and ordering of         information.</P>                  <h3>Single (S) 32 bit</h3>                  <P>Single precision is represented by 32 bits of         information. The high bit (bit 31) is the sign bit (s). The         next byte of information (bits 30-23) is the exponent (e),         and the last 23 bits (bits 22-0) are the fraction (f). The         bits of information are converted into a floating-point         number by the following equation:</P>                                    <P align=center><img src="images/hw_32_004.gif" align=bottom alt="" width=136 height=24></P>                                    <P>The fraction (f) is the strange value. Each bit in the         fraction value represents a negative exponent of two. So if         bit 22 and bit 16 are high, and all the rest of the bits are         low, than the fraction would equal 0.5078125 or         (2[-1]+ 2[-7])._ So when I give the FPU the         number 4.136e-15, it converts the number into the         hexadecimal number $04F1503DE, which, in the above equation,         looks like:</P>                  <P>(-1)0*2(79-127)*         20+2-3+2-5+2-7+2-14+2-15+2-16+2-17+2-19+2-20+2-21+2-22</P>                  <P>This number is than converted back to a base ten number         as 4.13600004803759899e-15. As you can see, the number is         correct up to the seventh decimal place.</P>                                    <h3>Double (D) 64 bit</h3>                  <P>Double precision is represented by 64 bits of         information. The high bit (bit 63) is the sign bit (s), The         next 11 bits of information (bits 62-52) are the exponent         (e), and the last 52 bits (bits 51-0) are the fraction (f).         The bits of information are converted into a floating-point         number by the following equation:</P>                                    <P align=center><img src="images/hw_32_005.gif" align=bottom alt="" width=136 height=26></P>                  <P>When I give the FPU the number 4.136e-15 as a double, it         converts the number into the hexadecimal number         $03CF2A07BBC5ED155. This number is than converted back to a         base ten number as 4.13600000000000015e-15. As you can see,         the number is correct up to the fifteenth decimal place.</P>                                    <h3>Extended (X) 96/80 bit</h3>                  <P>Extended precision is represented by 96 bits of         information; SANE and FP data register use 80-bit extended         numbers, but the FPU extended numbers are 96 bits with 16         unused bits, so the two are basically the same. The high bit         (bit 95) is the sign bit (s), The next 15 bits of         information (bits 94-81) are the exponent (e), there are 16         unused bits (bits 80-64), and the last 64 bits (bits 63-0)         are the fraction (f). The bits of information are converted         into a floating-point number by the following equation:</P>                                    <P align=center><img src="images/hw_32_006.gif" align=bottom alt="" width=136 height=27></P>                  <P>When I give the FPU the number 4.136e-15 as a extended,         it converts the number into the hexadecimal number         $03FCF(0000)9503DDE2F68AA66F. This number is than converted         back to a base ten number as 4.136e-15. This number is         correct to about the nineteenth decimal place.</P>                  <UL>            <LI>Pack Decimal Real (P) BCD Format 96 bits</LI>                        <LI>Pack Decimal Real is represented by 96 bits of            information. The bits of these numbers are represented as            follows:</LI>                        <LI>bit 95 Sign of Mantissa</LI>                        <LI>bit 94 Sign of Exponent</LI>                        <LI>bit 93-92 used for +-infinity and NANs,otherwise            zero</LI>                        <LI>bits 91-81 10-bit Exponent (3 digit exponent)</LI>                        <LI>bits 80-68 unused, zero</LI>                        <LI>bit 67-0, 68 bit Mantissa (17 digit mantissa)</LI>         </UL>                  <P>When I give the FPU the number 4.136e-15 as a PDR, it         converts the number into the hexadecimal number         $401500041360000000000000. This hexadecimal number is filled         into the above bit as follows:</P>                  <UL>            <LI>bit 95 Sign of Mantissa 0 (binary)</LI>                        <LI>bit 94 Sign of Exponent 1 (binary)</LI>                        <LI>bit 93-92 used for +-infinity and NANs,otherwise zero            00 (binary)</LI>                        <LI>bits 91-80 11-bit Exponent (3 digit exponent)            000000010101 (binary)</LI>                        <LI>bits 79-68 unused, zero 000000000000 (binary )</LI>                        <LI>bit 67-0 68 bit Mantissa (17 digit mantissa)            41360000000000000 (hex)</LI>         </UL>                  <P>This number is than converted back to a base ten number         as 4.136e-15. This number is correct to the seventeenth         decimal place.</P>                           <a name="Section4"></a>         <P><A HREF="#top">Back to top</A></P><h2>So What Tools Do I Have to Play With?</h2>                  <P>There are four types of opcodes which the math         coprocessors support: moves, monodic, dyadic, and         miscellaneous conditions. When a coprocessor operation is         executed, the first operation which the coprocessor performs         is to convert the data to the internal extended precision         format, and when the operation is completed, the data is         converted to the destination data format.</P>                  <h3>Moves</h3>                  <P>The first type which I will describe are the move         opcodes. Below is a list of the various formats in which the         move commands come.</P>                                    <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    <B>Move         </B>        FMOVE.&lt;fmt&gt; &lt;ea&gt;, FPn        FMOVE.&lt;fmt &gt; FPm, &lt;ea&gt;        FMOVE.X FPm, FPn    <B>Move Multiple         </B>        FMOVEM &lt;ea&gt;, FP0 - FP3/FP7        FMOVEM FP2/FP4/FP6, &lt;ea&gt; ; the registers are always moved                                 ; as 96 bit extended                                 ; data without conversion    <B>Move Register         </B>        FMOVE.L &lt;ea&gt;, FPCR ;move to control register        FMOVE.L FPCR, &lt;ea&gt; ;move from control register    <B>Move Constants from ROM to floating-point register         </B>        FMOVECR.X #ccc, FPn ;see Table 3 for #ccc    <B>Save and Restore Machine State         </B>        FSAVE &lt;ea&gt; ;virtual machine state save        FRESTORE &lt;ea&gt; ;virtual machine state restore</pre>	</TD></TR></TABLE></CENTER>                                    <P>&lt;ea&gt; is a main processing unit (MPU) effective         address operand (any 68xxx addressing mode). &lt;fmt&gt; is         the data format size (Byte, Word, Long, Single, Double,         eXtended, Packed decimal). FPm and FPn are floating-point         data registers.</P>                                    <P align=center><img src="images/hw_32_007.gif" align=bottom alt="Constants" width=424 height=286> </P>                  <P><B>Table 3</B> - Constants</P>                                    <h3>Monodic</h3>                  <P>A monodic operation has one operand. The operand may be a         floating-point data register or an MPU effective address.         The result is always stored in a floating-point data         register. The syntax for monodic operations is listed         below:</P>                  <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    Fxxxx.&lt;fmt&gt;    &lt;ea&gt;, FPn    Fxxxx.X    FPm, FPn    Fxxxx.X    FPn    where: &lt;fmt&gt; is (B,W,L,S,D,X,P)</pre>	</TD></TR></TABLE></CENTER>                  <P>xxxx is one of the Trigonometric (SIN), Transcendental         (ATANH), Exponential (ETOXM1), Misc. commands (NEG)</P>                                    <h3>Dyadic</h3>                  <P>A dyadic operation has two operands. The first operand         can be in a floating-point data register, or an MPU         effective address. The second operand is the contents of a         floating-point data register. The result of the operation is         stored in the second operand. The syntax for dyadic         operations is listed below:</P>                  <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    Fxxxx.&lt;fmt&gt;    &lt;ea&gt;, FPn    Fxxxx.X    FPm, FPn    where &lt;fmt&gt; is (B,W,L,S,D,X,P)    xxxx is a arithmetic (ADD), compare (CMP)</pre>	</TD></TR></TABLE></CENTER>                                    <h3>Condition operations</h3>                  <P>There are four condition operations: branch (FBcc),         decrement and branch (FDBcc), set according to condition         (FScc), and trap on condition (FTRAPcc).</P>                                             <a name="Section5"></a>         <P><A HREF="#top">Back to top</A></P><h2>Why and How do I Program for a 68882?</h2>                  <P>Any code which runs on a 68881 will run on a 68882 and         vice versa. You do not need to take special care to program         for the 68882, but if the chip is available, than special         care can noticeably improve the speed of your code. Figure 3         demonstrates the difference between code run on a 68881 and         the same code run on a 68882. The 68882 is completely         finished running before the 68881 has even started executing         the FMOVE instruction. The extra work which you need to do         to take advantage of the concurrent processing is fairly         minimal.</P>                  <P align=center><img src="images/hw_32_008.gif" align=bottom alt="Concurrent Execution versus         Non-Concurrent Execution" width=384 height=280></P>                     <P align=center><B>Figure 3</B> - Concurrent Execution versus         Non-Concurrent Execution</P>                                    <P>Before you jump right in and start writing code, you need         to understand that there are three different levels of         concurrency. The first level is the minimum concurrency         operations. These are operations which cannot run         concurrently with other operations. Most of these operations         are non-floating-point format operations. The minimum         concurrency operations are listed in Table 4.</P>                                    <P><B>Table 4</B> - Minimum Concurrency</P>                  <P align=center><img src="images/hw_32_009.gif" align=bottom alt="Minimum Concurrency" width=360 height=219></P>                  <P>The next level of operations are the operations which can         share some of the FPU time with other operations, these are         the partial concurrency operations and they are listed in         Table 5. The partial concurrency operations include most of         the floating-point format operations.</P>                  <P align=center><img src="images/hw_32_010.gif" align=bottom alt="Partial Concurrency" width=360 height=120> </P>                  <P><B>Table 5</B> - Partial Concurrency</P>                                                      <P>The highest level of concurrency is the fully-concurrent         operations which are listed in Table 6. The only operations         which can run fully concurrently are the FMOVE operations.         There are certain guidelines which you need to follow in         order to achieve full concurrency, these guidelines are         outlined in Table 6. The most important rule to follow is to         avoid register conflict. There are basically two type of         register conflict. The first is when the destination         register of an operation is the source register of the         following operation, and the following operation is a         fully-concurrent operation:</P>                  <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    FADD.&lt;fmt&gt;    &lt;ea&gt;, FP0    FMOVE.&lt;fmt&gt;    FP0, &lt;ea&gt;    ;FP0 conflicts</pre>	</TD></TR></TABLE></CENTER>                  <P>The second type of register conflict occurs when the         destination register of an operation is the destination         register of the following operation, and the following         operation is a fully-concurrent operation:</P>                  <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    FADD.&lt;fmt&gt;    &lt;ea&gt;, FP0    FMOVE.&lt;fmt&gt;    &lt;ea&gt;, FP0    ;FP0 conflicts    where &lt;fmt&gt; is S, D, or X</pre>	</TD></TR></TABLE></CENTER>                  <P>No Concur Partial Concur</P>                  <P align=center><img src="images/hw_32_011.gif" align=bottom alt="" width=392 height=91></P>                  <P>a: Register conflict of FPm with preceding instruction's         destination FP data register</P>                  <P>b: NAN, unnormalized or denormalized data type</P>                  <P>c: Rounding Precision in FPCR set to Single or Double</P>                  <P>d: INEX2 bit in FPCR EXC byte is enabled</P>                  <P>e: An overflow or underflow occurs</P>                  <P>f: Register conflict of FPn with preceding instruction's         destination FP data register</P>                                    <P><B>Table 6</B>-Fully Concurrent</P>                                                      <P>The next most important optimization rule is to unroll         loops. If you properly unroll your loops, than you will be         able to eliminate more of the register conflicts. Most loops         are designed to do one iteration of a set of instructions.         This means that each iteration of the loop is accomplishing         one iteration of the set of instructions. If you unroll the         loop, then each iteration of the loop can accomplish two or         more iterations of the set of instructions. Figures 4 and 5         demonstrate how to unroll your code. The second version         (Figure 5) is 25-30 percent faster than the first.</P>                  <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>            MOVE.L     #count,D0LOOPTOP     FMOVE.X    &lt;ea_Xi&gt;, FP3            FNEG.X     FP3            FETOX.X    FP3            FMOVE.X    FP3,FP4    ;conflict            FSUB.X     &lt;ea_Xi&gt;, FP3            FNEG.X     FP4            FSUB.X     #1, FP4            FDIV.X     FP4,FP3            FNEG.X     FP3            FADD.X     &lt;ea_Xi&gt;,FP3            FMOVE.X    FP3, &lt;ea_Xi&gt;    ;conflict            DBRA       D0, LOOPTOP</pre>	</TD></TR></TABLE></CENTER>                  <P align=center><B>Figure 4</B> - Newton-Raphson's Method Xi+1 = Xi +         f(Xi)/f'(Xi) : f(X) = exp(-x) - x</P>                                                      <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>        MOVE.L  #count,D0        FMOVE.D &lt;ea_Xi&gt;, FP0LOOPTOP FNEG    FP0,FP3        FETOX   FP3        FMOVE   FP3,FP4 ;conflict        FSUB    FP0,FP3        FNEG    FP4        FSUB.X  #1,FP4        FDIV    FP4,FP3        FSUB    FP3,FP0        DBRA    D0, LOOPTOP        FMOVE.D FP0, &lt;ea_Xi&gt;</pre>	</TD></TR></TABLE></CENTER>                  <P align=center><B>Figure 5</B> - Newton-Raphson's Method (resister-based,         unrolled) Xi+1 = Xi + f(Xi)/f'(Xi) : f(X) = exp(-x) - x</P>         <a name="Conclusion">                           </a>                  <P><A HREF="#top">Back to top</A></P><h2>Conclusion</h2>                  <P>The last comment which I have to make is for code which         is to run during interrupt time. If you plan to use the math         coprocessor during interrupt time, you must call FSAVE at         the start of your routine and FRESTORE at the end of your         routine. If you do not make these calls and you interrupt         another program which is using the FPU, then the other         program will not find the FPU in the same state that it was         in before the interrupt, and this causes certain death. For         more information, refer to Technical Note #235, Cooperating         with the Coprocessor.</P>                                    <P>If you made it this far, and you are still awake, then         you should be already to start writing assembly routines for         your code which will speed up your math-intensive programs.         Just remember that before you try to use the code, you need         to check hasFPU with a call to <code>_SysEnvirons</code>, and if the         machine does not have an FPU, then use an alternate SANE         version of the math code.</p>         <a name="References"></a>         <P><A HREF="#top">Back to top</A></P><h2>References</h2>                  <P>Apple Numerics Manual, Second Edition</P>                  <P>Motorola MC68881/MC68882 User's Manual</P>                  <P>Technical Note M.OV.GestaltSysenvirons -                   <A HREF="../ov/ov_16.html">Gestatlt and Sysenvirons : a         Never Ending Story</A></P>                  <P>Technical Note M.HW.MathCoProc - <A HREF="hw_22.html">Cooperating with the         Coprocessor</A></P>         <P><A HREF="#top">Back to top</A></P><P><A NAME=Downloads></A></P>                  <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P align=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (648K)</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/hw_32.pdf">Download</A></P>               </TD>            </TR></table><BR><P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/hw/hw_32.html%3Fid%3DDTS10002501-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/hw/hw_32.html%3Fid%3DDTS10002501-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/hw/hw_32.html%3Fid%3DDTS10002501-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>