<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Writing a Requester ATP Application(IM:N)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING150></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Networking-149.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Networking-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Networking-304.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt= "Book Index"></A> <A HREF="Networking-151.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Networking-2.html"><B>Networking</B></A> / <BR><DD><A HREF="Networking-143.html"><B>Chapter 6 - AppleTalk Transaction Protocol (ATP)</B></A> / <A HREF="Networking-149.html"><B>Using ATP</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING150-0></A>
<H2><A NAME=MARKER-9-69></A>Writing a Requester ATP Application</H2>
 <A NAME=MARKER-9-24></A>You use the <A NAME=MARKER-2-18></A><CODE>PSendRequest</CODE> function or the <A NAME=MARKER-2-32></A><CODE>PNSendRequest</CODE> function to send an ATP request to another socket. <P>
 <A NAME=MARKER-2-70></A>Before you can use ATP, you must first open the .MPP driver, which in turn opens the .ATP driver. Use the Device Manager's <CODE>OpenDriver</CODE> function to open the .MPP driver. Even if you suspect that the .MPP and the .ATP drivers are open, you should call <BR>the <CODE>OpenDriver</CODE> function for the .MPP driver to ensure that this is the case. Calling <CODE>OpenDrive</CODE>r for a driver that is already open will not produce harmful repercussions. See the chapter "Device Manager" in <I><A HREF="../Devices/Devices-2.html">Inside Macintosh: Devices</A></I> for information on <BR>the <CODE>OpenDriver</CODE> function. Do not close the .MPP driver when you are finished using ATP because other applications dependent on it or on the .ATP driver require that it <BR>remain open. <P>
 To send an ATP request, follow these steps:<P>
<OL>
<LI>Create a buffer data structure (BDS) to hold the data that you expect to receive in response to your request. For information on how to do this, see <A HREF=#MARKER-9-76>"Creating a Buffer Data Structure" on page 6-12</A>.
<LI>To allow ATP to assign the socket to be used to send the request, use the <CODE>PSendRequest</CODE> function. To specify a particular socket to be used to send the request, use the <CODE>PNSendRequest</CODE> function; in this case, you must call <CODE>POpenATPSocket</CODE> to first open the socket (see <A HREF=Networking-163.html#MARKER-9-179>"POpenATPSkt" on page 6-30</A> for information about this function). For information on the parameters required for these functions, see <A HREF=#MARKER-9-79>"Specifying the Parameters for the Send Request Function" on page 6-12</A>.
<LI>You can get the <A NAME=MARKER-2-40></A>transaction ID that ATP assigns to a request from the <CODE>reqTID</CODE> parameter; you need this ID to cancel a request. However, before you check this <BR>field, make sure that the valid transaction ID (<CODE>atpTIDValidvalue</CODE>) bit (bit 1) of <BR>the <CODE>atpFlags</CODE> parameter is set. ATP sets this bit to inform you that it has assigned <BR>a transaction ID and that the <CODE>reqTID</CODE> field is now valid. 
<LI>If you opened a socket to be used for the <CODE>PNSendRequest</CODE> call, close the socket using <CODE>PCloseATPSkt</CODE>. See<A HREF=Networking-164.html#MARKER-9-189>"PCloseATPSkt" on page 6-31</A> for information on how to use this function. If you use the <CODE>PSendRequest</CODE> function, ATP allocates a socket and opens and closes it for you. <P>
</OL>
 The code in <A HREF=#MARKER-9-75>Listing 6-1</A> shows how to open a socket and issue a call to the <CODE>PSendRequest</CODE> function. The code uses the <CODE>BuildBDS</CODE> function to create a buffer data structure to <BR>hold the response data it expects in response. This segment of code assumes that the application has already called the <CODE>OpenDriver</CODE> function to open the .MPP and <BR>.ATP drivers. <P>
<B>Listing 6-1  Opening a socket and sending an ATP request<A NAME=MARKER-9-75></A></B><P>
<PRE>
CONST
   kMaxPacketSize = 578;            {maximum packet size we can receive}
   kNRespBuffs = 8;                 {you allow eight response buffers}
   kOurRespBufSize = kMaxPacketSize * kNRespBuffs;
                                    {response buffer size}
VAR
   err:           OSErr;
   reqLength:     Integer;
   nBufs:         Integer;
   ref:           Integer;
   targetAddr:    AddrBlock;
   gAtpPBPtr:     ATPPBPtr;
   gReqBufPtr:    Ptr;
   gRespBufPtr:   Ptr;
   gSRespBdsPtr:  BDSPtr;
BEGIN
   gAtpPBPtr := ATPPBPtr(NewPtr(SizeOf(ATPParamBlock)));
   gReqBufPtr := NewPtr(kMaxPacketSize);
   gRespBufPtr := NewPtr(kOurRespBufSize);
   gSRespBdsPtr := BDSPtr(NewPtr(SizeOf (BDSType)));
   err := OpenDriver('MPP',ref);
   if err &lt;&gt; noErr THEN DoErr(err);
   WITH gAtpPBPtr^ DO

   BEGIN
      atpSocket := 0;                  {dynamically allocate a socket}
      addrBlock.aNet := 0;             {accept requests from anyone}
      addrBlock.aNode := 0;
      addrBlock.aSocket := 0;
   END;
   err := POpenATPSkt(gAtpPBPtr,false);{socket is returned in }
                                       { gAtpPBPtr^.atpSocket}

   IF err &lt;&gt; noErr THEN DoErr(err);
   IF gAtpPBPtr^.ioResult &lt;&gt; noErr THEN DoErr(err);

   MyPrepareRequestData(gReqBufPtr,@reqLength);
                                       {user routine that prepares the }
                                       { request data to be sent}
   MyLocateTargetAddress(@targetAddr);
                                       {user routine that locates the }
                                       { target machine}
   {Set up your BDS structure.}
   nBufs := BuildBDS(gRespBufPtr,Ptr(gSRespBdsPtr),kOurRespBufSize);

   WITH gAtpPBPtr^ DO
   BEGIN
      atpFlags := atpXOvalue;          {issue an exactly-once transaction}
      addrBlock.aNet := targetAddr.aNet;
                                       {set up the target machine}
      addrBlock.aNode := targetAddr.aNode;
      addrBlock.aSocket := targetAddr.aSocket;
      reqLength := reqLength;          {size of your request data}
      reqPointer := gReqBufPtr;        {pointer to actual request data}
      numOfBuffs := nBufs;             {number of responses expected}
      bdsPointer := Ptr(gSRespBdsPtr); {your BDS pointer}
      timeOutVal := 3;                 {timeout interval}
      retryCount := 5;                 {number of retries}
   END;
   err := PSendRequest(gAtpPBPtr,false);
   IF err &lt;&gt; noErr THEN DoErr(err);

   MyProcessResponses(gAtpPBPtr^.bdsPointer,gAtpPBPtr^.numOfResps);
                                       {user routine to process the }
                                       { response data returned}
   
   {Clean up after you are done.}
   DisposePtr(Ptr(gAtpPBPtr));
   DisposePtr(gReqBufPtr);
   DisposePtr(gRespBufPtr);
   DisposePtr(Ptr(gSRespBdsPtr));
END.
</PRE>
<A NAME=HEADING150-15></A>
<H3><A NAME=MARKER-9-76></A>Creating a Buffer Data Structure</H3>
 <A NAME=MARKER-2-59></A>Response data can comprise up to eight packets. ATP uses the organization of the buffer data structure (BDS) to manage these packets and ensure their complete delivery. The BDS must be an array of up to eight elements. You can create the buffer data structure yourself, or you can use the <A NAME=MARKER-2-42></A><CODE>BuildBDS</CODE> function for this purpose. You pass <CODE>BuildBDS</CODE> a pointer to a buffer and the length of the buffer, and it creates up to eight elements, one for each packet, depending on the size of the buffer that you supply. <CODE>BuildBDS</CODE> returns as its function result the number of elements that it creates; you pass this number and a pointer to the buffer data structure to the <CODE>PSendRequest</CODE> or <CODE>PNSendRequest</CODE> function that you call to issue the request. The memory that you allocate for the buffer must be nonrelocatable until the <CODE>PSendResponse</CODE> call completes execution. After <CODE>PSendResponse</CODE> returns, you should release this memory if you do not intend to reuse it. <P>
<A NAME=HEADING150-17></A>
<H3><A NAME=MARKER-9-79></A>Specifying the Parameters for the Send Request Function</H3>
 When you call either the <CODE>PSendRequest</CODE> function or the <CODE>PNSendRequest</CODE> function to send an ATP request, you must do these tasks:<P>
<UL>
<LI>Specify as the value of the <CODE>addrBlock</CODE> parameter the AppleTalk internet address of the socket whose client responder application you are sending the request to. 
<LI>Specify in the <CODE>reqLength</CODE> field the size in bytes of the request and in the <CODE>reqPointer</CODE> field a pointer to the request data. The buffer that you use to store the request belongs to ATP until the <CODE>PSendRequest</CODE> (or <CODE>PNSendRequest</CODE>) function completes execution, after which you can either reuse the memory or release it. 
<LI>Set the <CODE>timeOutVa</CODE>l and <CODE>retryCount</CODE> parameters appropriately for your network. See the following section, <A HREF=#MARKER-9-81>"Setting the Timeout and Retry Count Parameters."</A> If this is an exactly-once request, set bit 5 (<CODE>atpXOvalue</CODE>) of the <CODE>atpFlags</CODE> parameter to ensure that the responder application receives a specific request only once. For additional information about exactly-once transactions, see <A HREF=Networking-146.html#MARKER-9-59>"At-Least-Once and Exactly-Once Transactions" on page 6-7</A>.<P>
</UL>
 You can send up to <A NAME=MARKER-2-74></A>4 bytes of additional information in the <CODE>userData</CODE> parameter, <BR>and ATP will pass this to the responder application in the <CODE>userData</CODE> parameter of its <CODE>PGetRequest</CODE> call. To make this parameter meaningful, both the requester and the responder applications should agree on the use of these additional data bytes that are separate from the request or response data sent in an ATP transaction.<P>
<A NAME=HEADING150-23></A>
<H4><A NAME=MARKER-9-81></A>Setting the Timeout and Retry Count Parameters</H4>
 <A NAME=MARKER-9-128></A>When a transaction does not complete on the first transmission, ATP retries it a number of times. You can control ATP's retry behavior by setting these two parameters: the <CODE><A NAME=MARKER-2-68></A>timeOutVal</CODE> field and the <CODE>retryCount</CODE> field. The <CODE>timeOutVal</CODE> value determines <BR>in seconds how long ATP waits before resending the original request packet; the <CODE>retryCount</CODE> value determines how many times ATP retries to send the request. <P>
 ATP optimizes how it performs retries based on the response bitmap; ATP on the requester side resends the request with the header bitmap indicating to the ATP driver on the responder side which packets it should resend. (See the <A HREF=Networking-145.html#MARKER-9-50>"The Bitmap/Sequence Number" on page 6-6</A> for more information.) ATP makes this request to resend until it receives all of the packets or it exhausts the number of retry attempts that you specify. If ATP exhausts all of the retry attempts before the requester side receives all of the packets, ATP returns an error. <P>
 To choose the correct <A NAME=MARKER-2-44></A>timeout value and <A NAME=MARKER-2-49></A>retry count combination, you should consider the speed and complexity of your network--for example, take into account the degree of traffic congestion and whether your network contains multiple routers. You can use the AppleTalk Echo Protocol (AEP) echo socket to test the network performance and adjust the values accordingly. For more information about using the AEP echo socket to test network performance, see the chapter "Datagram Delivery Protocol (DDP)" in this book. You can store various pairs of values in a preferences resource file so that you can easily change them to adapt to the speed of the network. <P>
 If you want ATP to retry indefinitely to send the request, you can set the <CODE>retryCount</CODE> parameter to 255. In this case, ATP will send the request repeatedly until either the ATP responder end satisfies the request and sends back a response or you cancel the request. To cancel a <CODE>PSendRequest</CODE> call, you can use either the <CODE>PKillSendReq</CODE> function or the <CODE>PRelTCB</CODE> function. To cancel a <CODE>PNSendRequest</CODE> call, you can use the <CODE>PKillSendReq</CODE> function only. <P>
<A NAME=HEADING150-28></A>
<H4>Setting the Release Timer Value</H4>
 For <A NAME=MARKER-2-84></A>exactly-once transactions, the ATP responder code saves the response packets until the ATP code on the requester side indicates that it has received all of them. When this is the case, the ATP code on the requester side sends a transaction release packet to tell the ATP code on the responder side to release the response packets. Because this packet could be dropped or lost during transmission, ATP uses a release timer to discard the retained packets after a specified amount of time and to release the memory used to <BR>store them. <P>
 If the nodes at both ends of the ATP connection are running AppleTalk Phase 2 <BR>drivers, you can control the release timer value that determines when ATP releases <BR>the response packets by setting the 3 lower bits of the <CODE>TRelTime</CODE> parameter to one <BR>of the following values:
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>TRelTime<TH>Setting of <BR>release timer<TR>
<TD>000<TD>30 seconds<TR>
<TD>001<TD>1 minute<TR>
<TD>010<TD>4 minutes<TR>
<TD>100<TD>8 minute<A NAME=MARKER-2-20></A>s<A NAME=MARKER-9-16></A></TABLE>
<P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Networking-149.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Networking-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Networking-304.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt= "Book Index"></A> <A HREF="Networking-151.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Networking-3.html">&copy; Apple Computer, Inc.</A><br>7 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
