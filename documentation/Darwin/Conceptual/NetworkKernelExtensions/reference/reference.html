<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Network Kernel Extensions (legacy): Network Kernel Extensions Reference</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Network Kernel Extensions Reference"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40001089-CH227" title="Network Kernel Extensions Reference"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000422" target="_top">Darwin</a> &gt; <a href="../../../Kernel-date.html#//apple_ref/doc/uid/TP30000440-TP30000422-TP30000532" target="_top">Kernel</a> &gt; <a href="../about/about.html#//apple_ref/doc/uid/TP40001089-CH225-DontLinkElementID_113">Network Kernel Extensions (legacy)</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../using/using.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../revision_history/revision_history.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_143" title="Network Kernel Extensions Reference"></a><h1>Network Kernel Extensions Reference</h1><div class="importantbox"><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_144" title="Important:"></a><p><strong>Important:</strong>&nbsp;The information provided in this document is relevant for Mac OS 10.1 through 10.3. Specific mention is made for items which apply to newer releases of the OS.</p><p>For all shipping releases of Mac OS X prior to 10.4, the Network Kernel Extensions (NKE) APIs have not been officially supported. The legacy NKE architecture was implemented as an interim solution. The legacy API was never designed to be officially supported. Other aspects of the OS X networking implementation have received a higher priority, and so the interim solution has remained in effect to OS X 10.3.x.</p><p>The NKE mechanism for Mac OS X version 10.4 and later is described in the document <em><a href="../../NKEConceptual/index.html#//apple_ref/doc/uid/TP40001858" target="_top">Network Kernel Extensions Programming Guide</a></em>.</p><p></p></div><p>This chapter describes the functions that NKEs can call and NKE-specific data types. The functions are organized into the following sections:</p><ul class="ul"><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAGEJJJ">“Kernel Utilities”</a></span> lists the kernel utilities that NKEs can call.</p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAGBHEC">“protosw Functions”</a></span> describes functions that access the <code>protosw</code> structure.</p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAFAAGA">“ifaddr Functions”</a></span> describes functions that access the <code>ifnet</code> structure.</p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBACHBBC">“mbuf Functions”</a></span> describes functions that access the <code>mbuf</code> structure.</p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAFJBGG">“Socket Functions”</a></span> describes functions that access the <code>socket</code> structure.</p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAGBFCB">“Socket Buffer Functions”</a></span> describes functions that access the sockbuf structure.</p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAHFFGI">“Protocol Family NKE Functions”</a></span> describes NKE functions that protocol families call.</p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBACEIEF">“Protocol Handler NKE Functions”</a></span> describes NKE functions that protocol handlers call.</p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAHDEIF">“Data Link NKE Functions”</a></span> describes functions that data link NKEs call.</p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAIDAAE">“NKE Structures and Data Types”</a></span> describes the NKE structures and data types.</p></li></ul><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAGEJJJ" title="Kernel Utilities"></a><h2>Kernel Utilities</h2><p>NKEs can call the following kernel utility functions:</p><ul class="ul"><li class="li"><p><code><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAGGGED">_MALLOC</a></code></p></li><li class="li"><p><code><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAHFHIC">_FREE</a></code></p></li><li class="li"><p><code><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAJFCCH">kalloc</a></code></p></li><li class="li"><p><code><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAEGAAI">kfree</a></code></p></li><li class="li"><p><code><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAHDHAG">kprintf</a></code></p></li><li class="li"><p><code><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAEIJFI">psignal</a></code></p></li><li class="li"><p><code><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAJCFGI">splimp</a></code></p></li><li class="li"><p><code><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAFIGFD">splnet</a></code></p></li><li class="li"><p><code><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBADAFED">splx</a></code></p></li><li class="li"><p><code><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAGIEGI">suser</a></code></p></li><li class="li"><p><code><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBABDAEA">timeout</a></code></p></li><li class="li"><p><code><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBACFIFE">tsleep</a></code></p></li><li class="li"><p><code><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBABCCGH">untimeout</a></code></p></li><li class="li"><p><code><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBACBGFG">wakeup</a></code></p></li></ul><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAGGGED" title="_MALLOC"></a><h3>_MALLOC</h3><p>Allocates kernel memory.</p><div class="codesample"><table><tr><td scope="row"><pre>    void *_MALLOC(size_t size, int type, int flags);<span></span></pre></td></tr></table></div><p><code><!--a-->_MALLOC<!--/a--></code> is much like the user-space <code><!--a-->malloc<!--/a--></code> function, but it has additional parameters that require some explanation.</p><p>The types argument is a number representing the type of data that will be stored in the argument. This is used primarily for accounting purposes.These are described in <code>&lt;sys/malloc.h></code>.</p><p>The flags argument consists of some combination of <code><!--a  -->M_WAITOK<!--/a--></code>, <code><!--a  -->M_NOWAIT<!--/a--></code>, and <code><!--a  -->M_ZERO<!--/a--></code>.</p><p>The flag <code><!--a  -->M_NOWAIT<!--/a--></code> causes <code><!--a-->_MALLOC<!--/a--></code> to immediately return a null pointer if no space is available rather than waiting for space to become available. While this is appropriate for time-sensitive tasks that can be retried, it is not always what you want.</p><p>The more traditional (and default) behavior is <code><!--a  -->M_WAITOK<!--/a--></code>, which indicates that it is safe to wait for space to become available. If your code is in a critical path for performance, you should probably use <code><!--a  -->M_NOWAIT<!--/a--></code> if possible, and depend on the networking stack to retry after resources become available.</p><p>Finally, the flag <code><!--a  -->M_ZERO<!--/a--></code> requests that the allocator should zero the resulting allocation before returning it.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAHFHIC" title="_FREE"></a><h3>_FREE</h3><p>Frees memory allocated with _MALLOC</p><div class="codesample"><table><tr><td scope="row"><pre>    void _FREE(void *addr, int type);<span></span></pre></td></tr></table></div><p>The <code>type</code> flag passed to <code><!--a-->_FREE<!--/a--></code> must be the same as the flag passed to the corresponding _MALLOC</p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAJFCCH" title="kalloc"></a><h3>kalloc</h3><p>Allocate kernel memory.</p><div class="codesample"><table><tr><td scope="row"><pre>    void *kalloc(vm_size_t size);<span></span></pre></td></tr></table></div><p>This is roughly the kernel equivalent of <code><!--a-->malloc<!--/a--></code>. (See usage note at <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAEGAAI">kfree</a></span>.) This should generally be used for memory associated with the loading and unloading of an NKE. For storing data coming from outside sources (such as an <code>mbuf</code>), <code><!--a-->_MALLOC<!--/a--></code> is more appropriate.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAEGAAI" title="kfree"></a><h3>kfree</h3><p>Frees memory allocated with <code><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAJFCCH">kalloc</a></code>.</p><div class="codesample"><table><tr><td scope="row"><pre>    void kfree(void *data, vm_size_t size);<span></span></pre></td></tr></table></div><p>This behaves much like the user-space <code><!--a-->free<!--/a--></code>.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_145" title="Note"></a><p><strong>Note:</strong>&nbsp;The kernel allocator does not keep track of allocation size. You are responsible for passing in the original size yourself. If you pass in a different size, unpredictable behavior may result.</p></div><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAHDHAG" title="kprintf"></a><h3>kprintf</h3><p>Print text to the console.</p><div class="codesample"><table><tr><td scope="row"><pre>    void kprintf(const char *format, ... );<span></span></pre></td></tr></table></div><p>Identical to <code><!--a-->printf<!--/a--></code> in user space. It is not safe to call <code><!--a-->kprintf<!--/a--></code> from within an interrupt context. This should generally not be an issue, as you should avoid calling NKE functions from within an I/O Kit driver’s filter routine as a matter of course, but it is worth noting.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAEIJFI" title="psignal"></a><h3>psignal</h3><p>Sends a signal to a user process.</p><div class="codesample"><table><tr><td scope="row"><pre>    void psignal(struct proc *p, int sig);<span></span></pre></td></tr></table></div><p></p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAJCFGI" title="splimp"></a><h3>splimp</h3><p>Sets priority level to prevent execution of any kernel thread whose priority is less than or equal to “IMP”.</p><div class="codesample"><table><tr><td scope="row"><pre>    spl_t splimp(void);<span></span></pre></td></tr></table></div><p>In effect, this prevents any concurrency with anything that would touch the networking stack’s data structures at any level. The function returns the previous spl level in a form suitable to pass to <code><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBADAFED">splx</a></code>.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_146" title="Note"></a><p><strong>Note:</strong>&nbsp;IMP is a legacy term, short for Interface Message Processor, which was essentially the early term for a network interface card (NIC).</p></div><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAFIGFD" title="splnet"></a><h3>splnet</h3><p>Sets priority level to prevent execution of any kernel thread whose priority is less than or equal to “Net”.</p><div class="codesample"><table><tr><td scope="row"><pre>    spl_t splnet(void);<span></span></pre></td></tr></table></div><p>This blocks interrupts from network devices and any execution that would result from those interrupts (at the network stack level, not the I/O Kit level). The function returns the previous spl level in a form suitable to pass to <code><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBADAFED">splx</a></code>.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBADAFED" title="splx"></a><h3>splx</h3><p>Restores a previously-saved priority level.</p><div class="codesample"><table><tr><td scope="row"><pre>    void splx(spl_t level);<span></span></pre></td></tr></table></div><p>The value passed in generally is the result of the use of another spl function. The <code>spl_t</code> type is an unsigned int.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAGIEGI" title="suser"></a><h3>suser</h3><p>Checks to see if a process is running as the super-user (root).</p><div class="codesample"><table><tr><td scope="row"><pre>    int suser(struct proc *proc);<span></span></pre></td></tr></table></div><p></p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBABDAEA" title="timeout"></a><h3>timeout</h3><p>Sets a timeout for the next call to <code><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBACFIFE">tsleep</a></code>.</p><div class="codesample"><table><tr><td scope="row"><pre>    void timeout(void (*)(void *)call_on_timeout, void *arg, int ticks);<span></span></pre></td></tr></table></div><p>The function <code><!--a-->call_on_timeout<!--/a--></code> is called after some number of ticks. This timeout can be removed with <code><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBABCCGH">untimeout</a></code>.</p><p>The length of a tick is system dependent, but the number of ticks per second can be obtained from the global variable <code>HZ</code>.</p><p>This function returns immediately, and is usually followed by some operation, followed by a <code><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBACFIFE">tsleep</a></code> call while waiting for the operation to complete. The operation (occurring in some other thread) would typically end by calling <code><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBABCCGH">untimeout</a></code> to prevent the error handler from being triggered, followed by a call to <code><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBACBGFG">wakeup</a></code> to actually wake the thread.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBACFIFE" title="tsleep"></a><h3>tsleep</h3><p>Sleep until an event is posted with <code><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBACBGFG">wakeup</a></code> or until a timeout occurs. This is commonly combined with a timeout value to bound the wait.</p><div class="codesample"><table><tr><td scope="row"><pre>    int tsleep(void *chan, int pri, const char *wmesg, int timo);<span></span></pre></td></tr></table></div><p>The timeout value is measured in ticks. The length of a tick is system-dependent, but the number of ticks per second can be obtained from the global variable <code>HZ</code>. To sleep until woken (as one might reasonably do when used in conjunction with a call to <code><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBABDAEA">timeout</a></code>, you should pass the value zero (0) for <code>timo</code>.</p><p>The parameter <code>chan</code> should be a unique identifier specific to a given wait event. Usually such an event is associated with the change in a variable, in which case the address of that variable makes a good value for <code>chan</code>.</p><p>The parameter <code>pri</code> is the desired priority on wake. After another thread has called <code><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBACBGFG">wakeup</a></code> on the desired event (specified by the value of <code>chan</code>), your code will begin executing at the specified priority. If the <code>PCATCH</code> flag is set on <code>pri</code>, signal handlers will be tried before and after the sleep.</p><p>This is frequently used in conjunction with <code><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBABDAEA">timeout</a></code> and <code><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBABCCGH">untimeout</a></code>.</p><p>Returns 0 if awakened with wakeup, <code>EWOULDBLOCK</code> on timeout expiry, and <code>ERESTART</code> or <code>EINTR</code> if <code>PCATCH</code> is set and a signal occurred, depending on whether the <code>SA_RESTART</code> flag is set on the signal.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBABCCGH" title="untimeout"></a><h3>untimeout</h3><p>Unregisters a timeout previously registered with <code><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBABDAEA">timeout</a></code>.</p><div class="codesample"><table><tr><td scope="row"><pre>    void untimeout(void (*)(void *), void *arg);<span></span></pre></td></tr></table></div><p>Note that <code><!--a-->untimeout<!--/a--></code> does not wake the thread that called <code><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBABDAEA">timeout</a></code>. If this is desired, you must explicitly do so using <code><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBACBGFG">wakeup</a></code>.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBACBGFG" title="wakeup"></a><h3>wakeup</h3><p>Wakes a thread that is sleeping through a call to <code><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBACFIFE">tsleep</a></code>.</p><div class="codesample"><table><tr><td scope="row"><pre>    void wakeup(void *chan);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAGBHEC" title="protosw Functions"></a><h2>protosw Functions</h2><p>This section describes the functions that access the <code>protosw</code> structure.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_20" title="pffindproto"></a><h3>pffindproto</h3><p>The <code>pffindproto</code> function obtains the <code>protosw</code> corresponding to the protocol family, protocol, and protocol type (or <code>NULL</code>). These values are passed to the <code>socket</code>(2) call from user mode.</p><div class="codesample"><table><tr><td scope="row"><pre>extern struct protosw *pffindproto(int, int, int);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_21" title="pffindtype"></a><h3>pffindtype</h3><p>The <code>pffindtype</code> function obtains the <code>protosw</code> corresponding to the protocol and protocol type requested. These values are passed to the <code>socket</code>(2) call from user mode.</p><div class="codesample"><table><tr><td scope="row"><pre>extern struct protosw *pffindtype(int, int);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAFAAGA" title="ifaddr Functions"></a><h2>ifaddr Functions</h2><p>This section describes the functions that access the <code>ifaddr</code> structure.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_22" title="ifa_ifwithaddr"></a><h3>ifa_ifwithaddr</h3><p>The <code>ifa_ifwithaddr</code> function searches the <code>ifnet</code> list for an interface with a matching address.</p><div class="codesample"><table><tr><td scope="row"><pre>struct ifaddr *ifa_ifwithaddr(struct sockaddr *);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_23" title="ifa_ifwithdstaddr"></a><h3>ifa_ifwithdstaddr</h3><p>The <code>ifa_ifwithdstaddr</code> function searches the <code>ifnet</code> list for an interface with a matching destination address.</p><div class="codesample"><table><tr><td scope="row"><pre>struct ifaddr *ifa_ifwithdstaddr(struct sockaddr *);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_24" title="ifa_ifwithnet"></a><h3>ifa_ifwithnet</h3><p>The <code>ifa_ifwithnet</code> function searches the <code>ifnet</code> list for an interface with the most specific matching address.</p><div class="codesample"><table><tr><td scope="row"><pre>struct ifaddr *ifa_ifwithnet(struct sockaddr *);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_25" title="ifa_ifwithaf"></a><h3>ifa_ifwithaf</h3><p>The <code>ifa_ifwithaf</code> function searches the <code>ifnet</code> list for an interface with the first matching address family.</p><div class="codesample"><table><tr><td scope="row"><pre>struct ifaddr *ifa_ifwithaf(int);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_26" title="ifa_ifafree"></a><h3>ifa_ifafree</h3><p>The<code> ifa_ifafree</code> function frees the specified <code>ifaddr</code> structure.</p><div class="codesample"><table><tr><td scope="row"><pre>void ifafree(struct ifaddr*);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_27" title="ifa_ifaof_ifpforaddr"></a><h3>ifa_ifaof_ifpforaddr</h3><p>The <code>ifa_ifaof_ifpforaddr</code> function searches the address list in the <code>ifnet</code> structure for the one matching the <code>sockaddr</code> structure. The matching rules are exact match, destination address on point-to-point link, matching network number, or same address family.</p><div class="codesample"><table><tr><td scope="row"><pre>struct ifaddr *ifaof_ifpforaddr(struct sockaddr *, struct ifnet *);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-BBACHBBC" title="mbuf Functions"></a><h2>mbuf Functions</h2><p>For a description of the mbuf routines, go to FreeBSD website (<span class="content_text"><a href="http://www.freebsd.org" target="_blank">http://www.freebsd.org</a></span>), click on the Manual-pages reference and search for "mbuf".</p><div class="codesample"><table><tr><td scope="row"><pre>struct mbuf *m_copy(struct mbuf *, int, int, int);<span></span></pre></td></tr><tr><td scope="row"><pre>struct mbuf *m_free(struct mbuf *);<span></span></pre></td></tr><tr><td scope="row"><pre>struct mbuf *m_get(int, int);<span></span></pre></td></tr><tr><td scope="row"><pre>struct mbuf *m_getclr(int, int);<span></span></pre></td></tr><tr><td scope="row"><pre>struct mbuf *m_gethdr(int, int);<span></span></pre></td></tr><tr><td scope="row"><pre>struct mbuf *m_prepend(struct mbuf *, int, int);<span></span></pre></td></tr><tr><td scope="row"><pre>struct mbuf *m_pullup(struct mbuf *, int);<span></span></pre></td></tr><tr><td scope="row"><pre>struct mbuf *m_retryhdr(int, int);<span></span></pre></td></tr><tr><td scope="row"><pre>void m_adj(struct mbuf *, int);<span></span></pre></td></tr><tr><td scope="row"><pre>int m_clalloc(int, int);<span></span></pre></td></tr><tr><td scope="row"><pre>void m_freem(struct mbuf *);<span></span></pre></td></tr><tr><td scope="row"><pre>struct mbuf *m_devget(char *, int, int, struct ifnet, void );<span></span></pre></td></tr><tr><td scope="row"><pre>void m_cat(struct mbuf *, struct mbuf *);<span></span></pre></td></tr><tr><td scope="row"><pre>void m_copydata(struct mbuf *, int, int, caddr_t);<span></span></pre></td></tr><tr><td scope="row"><pre>void m_freem(struct mbuf *);<span></span></pre></td></tr><tr><td scope="row"><pre>int m_leadingspace(struct mbuf *);<span></span></pre></td></tr><tr><td scope="row"><pre>int m_trailingspace(struct mbuf *);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_28" title="Caution About Using Malloc&#39;d Memory In mbufs"></a><h3>Caution About Using Malloc'd Memory In mbufs</h3><p>Prior to the release of the Power Mac G5 and to Mac OS X 10.3.x, it was possible to use malloc'd memory to hold data or packet headers on outbound mbufs. For compatibility with all G5's and Mac OS X 10.3.x and later, any memory, containing outbound packet data or headers, must have a recognized I/O Address compatible with PCI Address Translation.</p><p>When there is a requirement to obtain memory buffers to contain outbound packet data or headers, use the standard mbuf routines as defined in <code>&lt;/sys/mbuf.h></code> to allocate mbufs for your NKE needs. To understand more about this requirement, refer to <span class="content_text"><a href="../../../../../technotes/tn/tn2090.html" target="_top">Tech Note 2090</a></span> "Driver Tuning on Panther or G5" Section "Background Info on PCI Address Translation".</p><p>The standard <code>mbuf</code> routines have been modified to provide memory buffers, which are compatible for use with the PCI bus. If your driver allocates memory with <code><!--a-->malloc<!--/a--></code>, fills packet data into this memory, points the <code>mbuf</code> to this memory, and sends the <code>mbuf</code> to the driver to be sent across the network, one symptom may be that the hardware hangs on trying to send the packet.</p><p>Note that the NKE may continue to <code><!--a-->malloc<!--/a--></code>/<code><!--a-->free<!--/a--></code> memory for it's own needs, such as for internal processing of packet data. However, when processing is complete, outbound packet data must be placed in a buffer with a recognized I/O Address, compatible with PCI Address Translation.</p><p>An additional note about memory allocation/de-allocation - <code><!--a-->malloc<!--/a--></code>/<code><!--a-->free<!--/a--></code> are potential preemption points and may loose the funnel, which means that the NKE can get re-entered while doing a blocking malloc or a free. While a free call is not likely to result in the loss of a funnel, it can happen. When doing a <code><!--a-->malloc<!--/a--></code>/<code><!--a-->free<!--/a--></code>, the NKE should make sure that it's a safe point for the integrity of the data structures that it manipulates. For more information about funnels, refer to the following web references:</p><ul class="spaceabove"><li class="li"><p><span class="content_text"><a href="http://www.kernelthread.com/mac/osx/arch_xnu.html" target="_blank">http://www.kernelthread.com/mac/osx/arch_xnu.html</a></span></p></li><li class="li"><p><span class="content_text"><a href="http://www.usenix.org/publications/library/proceedings/bsdcon02/full_papers/gerbarg/gerbarg_html/" target="_blank">http://www.usenix.org/publications/library/proceedings/bsdcon02/full_papers/gerbarg/gerbarg_html/</a></span></p></li></ul><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAFJBGG" title="Socket Functions"></a><h2>Socket Functions</h2><p>This section describes the socket functions. For additional information on the use of these functions, read <em>TCP/IP Illustrated, Volume 2 - The Implementation</em> by Gary Wright and W. Richard Stevens, Addison Wesley, ISBN 0-201-63354-X.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_29" title="soabort"></a><h3>soabort</h3><p>The <code>soabort</code> function calls the protocol's <code>pr_abort</code> function at <code>slpnet</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>soabort(struct socket *);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_30" title="soaccept"></a><h3>soaccept</h3><p>The <code>soaccept</code> function calls the protocol's <code>pr_accept</code> function.</p><div class="codesample"><table><tr><td scope="row"><pre>soaccept(struct socket *, struct mbuf *);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_31" title="sobind"></a><h3>sobind</h3><p>The <code>sobind</code> function calls the protocol's <code>pr_bind</code> function.</p><div class="codesample"><table><tr><td scope="row"><pre>sobind(struct socket *, struct mbuf *);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_32" title="soclose"></a><h3>soclose</h3><p>The <code>soclose</code> function aborts pending and in-progress connections, calls <code>sodisconnect</code> for connected sockets, and sleeps if any connections linger or block. It then calls the protocol's <code>pr_detach</code> function and frees the socket.</p><div class="codesample"><table><tr><td scope="row"><pre>soclose(struct socket *);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_33" title="soconnect"></a><h3>soconnect</h3><p><code></code>If connected or connecting, the <code>soconnect</code> function tries to disconnect. It also calls the <code>pr_connect</code> function.</p><div class="codesample"><table><tr><td scope="row"><pre>soconnect(struct socket *, struct mbuf *);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_34" title="soconnect2"></a><h3>soconnect2</h3><p>The <code>soconnect2</code> function calls the <code>pr_connect2</code> function. This function is generally not supported, but it is used to support pipe usage in the <code>AF_LOCAL</code> domain.</p><div class="codesample"><table><tr><td scope="row"><pre>soconnect2(struct socket *, struct socket *);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_35" title="socreate"></a><h3>socreate</h3><p>The <code>socreate</code> function links the <code>protosw</code> structure and the socket. It calls the protocol's <code>pr_attach</code> function.</p><div class="codesample"><table><tr><td scope="row"><pre>socreate(int, struct socket**, int, int);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_36" title="sodisconnect"></a><h3>sodisconnect</h3><p>The<code> sodisconect</code> function calls the protocol's <code>pr_disconnect</code> function.</p><div class="codesample"><table><tr><td scope="row"><pre>sodisconnect(struct socket *);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_37" title="sofree"></a><h3>sofree</h3><p>The <code>sofree</code> function removes the caller from <code>q0</code> and <code>q</code> queues, releases the send <code>sockbuf</code>, flushes the receive <code>sockbuf</code>, and frees the socket.</p><div class="codesample"><table><tr><td scope="row"><pre>sofree(struct socket *);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_38" title="sogetopt"></a><h3>sogetopt</h3><p>The <code>sogetopt</code> function processes <code>SOL_SOCKET</code> requests and always calls the <code>PRCO_SETOPT</code> function.</p><div class="codesample"><table><tr><td scope="row"><pre>sogetopt(struct socket *, int, int, struct mbuf **);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_39" title="sohasoutofband"></a><h3>sohasoutofband</h3><p>The <code>sohasoutofband</code> function indicates that the caller has an out-of-band notifier.</p><div class="codesample"><table><tr><td scope="row"><pre>sooutofband(struct socket *);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_40" title="solisten"></a><h3>solisten</h3><p>The <code>solisten</code> function calls the protocol's <code>pr_listen</code> function and sets the queue backlog.</p><div class="codesample"><table><tr><td scope="row"><pre>solisten(struct socket *, int);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_41" title="soreceive"></a><h3>soreceive</h3><p>The <code>soreceive</code> function receives data.</p><div class="codesample"><table><tr><td scope="row"><pre>soreceive(struct socket *, struct mbuf **, struct uio *, struct mbuf **, struct mbuf **, int *);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_42" title="soflush"></a><h3>soflush</h3><p>The <code>soflush</code> function locks the socket, marks it as "can't receive," unlocks the socket, and calls <code>sbrelease</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>soflush(struct socket *);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_43" title="sosend"></a><h3>sosend</h3><p>The <code>sosend</code> function sends data.</p><div class="codesample"><table><tr><td scope="row"><pre>sosend(struct socket *, struct mbuf *, struct uio *, struct mbuf *, struct mbuf *, int);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_44" title="sosetopt"></a><h3>sosetopt</h3><p>The<code> sosetopt</code> function processes <code>SOL_SOCKET</code> requests and always calls the <code>PRCO_SETOPT</code> function.</p><div class="codesample"><table><tr><td scope="row"><pre>sosetopt(struct socket *, int, int, struct mbuf *);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_45" title="soshutdown"></a><h3>soshutdown</h3><p>The <code>soshutdown</code> function calls the <code>sorflush function </code>(<code>FREAD</code>) and the <code>pr_shutdown</code> function (<code>FWRITE</code>).</p><div class="codesample"><table><tr><td scope="row"><pre>soshutdown(struct socket *, int, int, struct mbuf *);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAGBFCB" title="Socket Buffer Functions"></a><h2>Socket Buffer Functions</h2><p>This section describes the socket buffer functions.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_46" title="sb_lock"></a><h3>sb_lock</h3><p>The <code>sb_lock</code> function locks a <code>sockbuf</code> structure. It sets <code>WANT</code> and sleeps if the structure is already locked.</p><div class="codesample"><table><tr><td scope="row"><pre>sb_lock(struct sockbuf *);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_47" title="sbappend"></a><h3>sbappend</h3><p>The <code>sbappend</code> function conditionally calls <code>sbappendrecord</code> and calls <code>sbcompress</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>sbappend(struct sockbuf *, struct mbuf *);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_48" title="sbappendaddr"></a><h3>sbappendaddr</h3><p>The <code>sbappendaddr</code> function conditionally calls <code>sbappendrecord</code> and <code>sbcompress</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>sbappendaddr(struct sockbuf *, struct sockaddr *, struct mbuf *, struct mbuf *);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_49" title="sbappendcontrol"></a><h3>sbappendcontrol</h3><p>The <code>sbappendcontrol</code> function calls <code>sbspace</code> and <code>sballoc</code>.</p><div class="codesample"><table><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>sbappendcontrol(struct sockbuf *, struct mbuf *, struct mbuf *);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_50" title="sbappendrecord"></a><h3>sbappendrecord</h3><p>The <code>sbappendrecord</code> function calls <code>sballoc</code> and <code>sbcompress</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>sbappendrecord(struct sockbuf *, struct mbuf *);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_51" title="sbcompress"></a><h3>sbcompress</h3><p>The <code>sbcompress</code> function calls <code>sballoc</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>sbcompress(struct sockbuf *, struct mbuf *, struct mbuf *);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_52" title="sbdrop"></a><h3>sbdrop</h3><p>The <code>sbdrop</code> function calls <code>sbfree</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>sbdrop(struct sockbuf *, int);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_53" title="sbdroprecord"></a><h3>sbdroprecord</h3><p>The <code>sbdroprecord</code> function calls <code>sbfree</code>.</p><div class="codesample"><table><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>sbdroprecord(struct sockbuf *);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_54" title="sbflush"></a><h3>sbflush</h3><p>The <code>sbflush</code> function calls <code>sbfree</code>.</p><div class="codesample"><table><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>sbflush(struct sockbuf *);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_55" title="sbinsertoob"></a><h3>sbinsertoob</h3><p>The <code>sbinsertoob</code> function calls <code>sballoc </code>and<code> sbcompress</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>sbinsertoob(struct sockbuf *, struct mbuf *);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_56" title="sbrelease"></a><h3>sbrelease</h3><p>The <code>sbrelease</code> function calls <code>sbflush </code>and clears the <code>selwait</code> structure.</p><div class="codesample"><table><tr><td scope="row"><pre>sbrelease(struct sockbuf *);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_57" title="sbreserve"></a><h3>sbreserve</h3><p>The <code>sbreserve</code> function sets up the <code>sockbuf</code> counts.</p><div class="codesample"><table><tr><td scope="row"><pre>sbreserve(struct sockbuf *, u_long);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_58" title="sbwait"></a><h3>sbwait</h3><p>The <code>sbwait</code> function sets <code>SB_WAIT and </code>calls <code>tsleep</code> on <code>sb_cc</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>sbwait(struct sockbuf *);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_59" title="socantrcvmore"></a><h3>socantrcvmore</h3><p>The <code>socantrcvmore</code> function marks socket and wakes up readers.</p><div class="codesample"><table><tr><td scope="row"><pre>socantrcvmore(struct socket *);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_60" title="socantsendmore"></a><h3>socantsendmore</h3><p>The <code>socantsendmore</code> function marks socket and wakes up writers.</p><div class="codesample"><table><tr><td scope="row"><pre>socantsendmore(struct socket *);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_61" title="soisconnected"></a><h3>soisconnected</h3><p>The <code>soisconnected</code> function sets state bits. It calls <code>soqremque</code>, <code>soqinsque</code>, <code>sorwakeup</code>, and <code>sowwakeup</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>soisconnected(struct socket *);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_62" title="soisconnecting"></a><h3>soisconnecting</h3><p>The <code>soisconnecting</code> function sets state bits. </p><div class="codesample"><table><tr><td scope="row"><pre>soisconnecting(struct socket *);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_63" title="soisdisconnected"></a><h3>soisdisconnected</h3><p>The <code>soisdisconnected</code> function sets state bits, calls timer wakeup, and wakes up readers and writers.</p><div class="codesample"><table><tr><td scope="row"><pre>soisdisconnected(struct socket *);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_64" title="soisdisconnecting"></a><h3>soisdisconnecting</h3><p>The <code>soisdisconnecting</code> function sets state bits, calls timer wakeup, and wakes up readers and writers.</p><div class="codesample"><table><tr><td scope="row"><pre>soisdisconnecting(struct socket *);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_65" title="su_sonewconn1"></a><h3>su_sonewconn1</h3><p>The <code>su_sonewconn1</code> function allocates socket, sets state, inserts into head queue, and calls <code>pr_attach</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>struct socket *su_sonewconn1(struct socket *, int);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_66" title="soqinsque"></a><h3>soqinsque</h3><p>The <code>soqinsque</code> function adds the socket to <code>q</code> or <code>q0</code> of "head."</p><div class="codesample"><table><tr><td scope="row"><pre>soqinsque(struct socket *, struct socket *, int);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_67" title="soqremque"></a><h3>soqremque</h3><p>The<code> soqremque</code> function removes socket from <code>q</code> or <code>q0</code> of "head."</p><div class="codesample"><table><tr><td scope="row"><pre>soqremque(struct socket *, int);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_68" title="soreserve"></a><h3>soreserve</h3><p>The <code>soreserve</code> function sets up send and receive <code>sockbuf</code> structures.</p><div class="codesample"><table><tr><td scope="row"><pre>soreserve(struct socket *, u_long, u_long);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAHFFGI" title="Protocol Family NKE Functions"></a><h2>Protocol Family NKE Functions</h2><p>This section describes the functions that support the dynamic addition and removal of protocol family NKEs. For additional descriptions of these routines, go to the <span class="content_text"><a href="http://www.freebsd.org/" target="_blank">FreeBSD website</a></span>, click on the Manual-pages reference and search for "net_add_domain".</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_69" title="net_add_domain"></a><h3>net_add_domain</h3><p>Adds a <code>domain</code> structure to the kernel's domain list.</p><div class="codesample"><table><tr><td scope="row"><pre>void net_add_domain(struct domain *domain);<span></span></pre></td></tr></table></div><p><code>domain</code>On input, a pointer to a <code>domain</code> structure to be linked into the system's list of domains.</p><p><code>function result: </code>None.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_70" title="DISCUSSION"></a><h4>DISCUSSION</h4><p>The <code>net_add_domain</code> function adds a <code>domain</code> (represented by the <code>domain</code> parameter) to the kernel's list of domains. </p><p>The <code>net_add_domain</code> function locks the <code>domain</code> structure, calls the domain's <code>init</code> function, and calls the protocol's <code>init</code> function for each attached protocol. The domain's <code>init</code> function updates certain system global structures, such as <code>max_protohdr</code>, and protects itself from repeated calls. You can choose whether to include the <code>protosw</code> structures in <code>domain</code>. The alternative is to attach protocol handler NKEs by calling <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAFDHHE">“net_add_proto.”</a></span></p><p>This function does not return a value because it cannot fail.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_71" title="net_del_domain"></a><h3>net_del_domain</h3><p>Removes a <code>domain</code> structure from the kernel's domain list.</p><div class="codesample"><table><tr><td scope="row"><pre>int net_del_domain(struct domain *domain);<span></span></pre></td></tr></table></div><p><code>domain</code>On input, a pointer to the <code>domain</code> structure that is to be removed.</p><p><code>function result</code>0 to indicate success, <code>EBUSY</code> when the reference count for the specified <code>domain</code> structure is not zero, and <code>EPFNOSUPPORT</code> if the specified <code>domain</code> structure cannot be found.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_72" title="DISCUSSION"></a><h4>DISCUSSION</h4><p>The <code>net_del_domain</code> function removes a <code>domain</code> structure from the kernel's list of <code>domain</code> structures. </p><p>You are responsible for reclaiming resources and handling dangling pointers before you call <code>net_del_domain</code>.</p><p>This function is only called from a domain implementation.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_73" title="pffinddomain"></a><h3>pffinddomain</h3><p>Finds a <code>domain</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>struct domain *pffinddomain(int x);<span></span></pre></td></tr></table></div><p><code>x</code>On input, a <code>PK</code> constant, such as <code>PF_INET</code> or <code>PF_NKE</code>.</p><p><code>function result</code>A pointer to the requested <code>domain</code> structure or <code>NULL</code>, which indicates that the domain could not be found. If <code>pffinddomain</code> returns <code>NULL</code>, the caller should return <code>EPFNOSUPPORT</code> in addition to performing normal error cleanup.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_74" title="DISCUSSION"></a><h4>DISCUSSION</h4><p>The <code>pffinddomain</code> function locates the <code>domain</code> structure for the specified protocol family in the kernel's list of <code>domain</code> structures.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_147" title="Note"></a><p><strong>Note:</strong>&nbsp;This function depends on matching an integer value with a value in the kernel. You can verify that the proper <code>domain</code> structure has been located by checking the value of the <code>dom_name</code> field in the <code>domain</code> structure.</p></div><a name="//apple_ref/doc/uid/TP40001089-CH227-BBACEIEF" title="Protocol Handler NKE Functions"></a><h2>Protocol Handler NKE Functions</h2><p>This section describes the functions that support the dynamic addition and removal of protocol handler NKEs.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAFDHHE" title="net_add_proto"></a><h3>net_add_proto</h3><p>Adds the specified <code>protosw</code> structure to the list of <code>protosw</code> structures for the specified <code>domain</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>int net_add_proto (struct protosw *protosw, struct domain *domain);<span></span></pre></td></tr></table></div><p><code>protosw</code>On input, a pointer to a <code>protosw</code> structure.</p><p><code>domain</code>On input, a pointer to a <code>domain</code> structure.</p><p><code>function result</code>0 to indicate success or <code>EEXISTS</code> if the <code>pr_type</code> and the <code>pr_protocol</code> fields in the <code>protosw</code> structure that is being added match the <code>pr_type</code> and <code>pr_protocol</code> fields in an existing <code>protosw</code> entry for the specified domain.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_75" title="DISCUSSION"></a><h4>DISCUSSION</h4><p>The <code>net_add_proto</code> function adds the specified <code>protosw</code> to the domain's list of <code>protosw</code> structures. </p><p>If the <code>protosw</code> structure is successfully added, the protocol's <code>init</code> function (if present) is called.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_76" title="net_del_proto"></a><h3>net_del_proto</h3><p>Removes a <code>protosw</code> structure from the list of <code>protosw</code> structures for the specified <code>domain</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>int net_del_proto(int type, int protocol, struct domain *domain);<span></span></pre></td></tr></table></div><p><code>type: </code>On input, an integer value that specifies the type of the <code>protosw </code> structure that is to be removed.</p><p><code>protocol: </code>On input, an integer value that specifies the protocol of the <code>protosw </code> structure that is to be removed.</p><p><code>domain: </code>On input, a pointer to a <code>domain</code> structure.</p><p><code>function result: </code>0 to indicate success or <code>ENXIO</code> if the specified values for <code>type</code> and <code>protocol</code> don't match a <code>protosw</code> structure in the domain's list of <code>protosw</code> structures.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_77" title="DISCUSSION"></a><h4>DISCUSSION</h4><p>The <code>net_del_proto</code> function removes the specified <code>protosw</code> structure from the list of <code>protosw</code> structures for the specified <code>domain</code> structure.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAHDEIF" title="Data Link NKE Functions"></a><h2>Data Link NKE Functions</h2><p>This section describes the Data Link Layer Interface (DLIL) functions. The section is organized under the following topics:</p><ul class="ul"><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAFDFGA">“Calling the DLIL From the Network Layer”</a></span></p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBADFADH">“Calling the Network Layer From the DLIL”</a></span></p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBABGJGJ">“Calling the Driver Layer From the DLIL”</a></span></p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBADAJJI">“Calling the DLIL From the Driver Layer”</a></span></p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBACEFBB">“Calling Interface Modules From the DLIL”</a></span></p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBACGDHG">“Calling the DLIL From a DLIL Filter”</a></span></p></li></ul><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAFDFGA" title="Calling the DLIL From the Network Layer"></a><h3>Calling the DLIL From the Network Layer</h3><p>This section describes DLIL functions that are called from the network layer. The functions are</p><ul class="spaceabove"><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAEDGCH">“dlil_attach_protocol_filter”</a></span> which is called to attach a protocol filter.</p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBADHACJ">“dlil_attach_interface_filter”</a></span> which is called to attach an interface filter.</p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBACJAEG">“dlil_attach_protocol”</a></span> which a protocol calls to attach itself to the DLIL.</p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBADGIJF">“dlil_detach_filter”</a></span> which a protocol calls to attach itself to the DLIL.</p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBABHIBH">“dlil_detach_protocol”</a></span> which a protocol calls to deattach itself from the DLIL.</p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAGICHH">“dlil_output”</a></span> which a protocol calls to send data to a network interface.</p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAHEBFA">“dlil_ioctl”</a></span> which a protocol calls to send ioctl commands to a network interface.</p></li></ul><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAEDGCH" title="dlil_attach_protocol_filter"></a><h4>dlil_attach_protocol_filter</h4><p>Inserts a DLIL protocol filter between a protocol and the DLIL.</p><div class="codesample"><table><tr><td scope="row"><pre>int dlil_attach_protocol_filter( u_long dl_tag, struct dlil_pr_flt_str *protocol_filter, u_long *filter_id, int insertion_point);<span></span></pre></td></tr></table></div><p><code>dl_tag</code>On input, a value of type <code>u_long</code>, previously obtained by calling <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBACJAEG">“dlil_attach_protocol,”</a></span> that identifies the protocol/interface pair between which the NKE is to be inserted.</p><p><code>protocol_filter</code>A pointer to a <code>dlil_pr_fil_str</code> structure that contains pointers to the functions the DLIL is to call when it intercepts calls. Each function pointed to by a member of this structure corresponds to a function pointed to by the <code>ifnet</code> structure for this protocol/interface pair.</p><p><code>filter_id</code>On input, a pointer to a <code>u_long</code>. On output, <code>filter_id</code> points to a tag value that identifies the NKE that has been inserted. The tag value is required to remove the NKE or insert another NKE after the current NKE.</p><p><code>insertion_point</code>On input, a value of type <code>int</code>. If this is the first DLIL protocol filter to be inserted, set <code>insertion_point</code> to <code>DLIL_LAST_FILTER</code>. If this is the second or greater insertion, set <code>insertion_point</code> to the value of <code>filter_id</code> returned by a previous call to <code>dlil_attach_protocol_filter</code> or to <code>DLIL_LAST_FILTER</code> to insert the filter at the end of the chain of inserted filters.</p><p><code>function result</code>0 for success.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_78" title="DISCUSSION"></a><h5>DISCUSSION</h5><p>The <code>dlil_attach_protocol_filter</code> function inserts a DLIL protocol filter between the specified protocol and the DLIL.</p><p>When more than one DLIL protocol filter is inserted, the DLIL calls the appropriate function of the first filter with the parameters provided by the caller. When that call returns successfully, the DLIL calls the appropriate function for the second filter with the parameters returned by the first filter, and so on until the appropriate functions have been called for each filter in the list. When the last filter in the list has been called, the DLIL calls the original destination function with the parameters returned by the last filter.</p><p>The DLIL skips any function pointers that are <code>NULL</code>, which allows DLIL protocol filters to intercept only a subset of the calls that may be made by a protocol to the interface to which the protocol is attached.</p><p>If a DLIL protocol filter returns a status other zero (which indicates success) or <code>EJUSTRETURN</code>, the DLIL frees any associated <code>mbuf</code> chain (for the <code>filter_dl_pre_output</code> and <code>filter_dl_input</code> functions only) and returns with that status.</p><p>If a DLIL protocol filter returns a status of <code>EJUSTRETURN</code>, the DLIL returns zero to indicate success without freeing any associated <code>mbuf</code> chain. The DLIL protocol filter is responsible for freeing or forwarding any associated <code>mbuf</code> chain.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBADHACJ" title="dlil_attach_interface_filter"></a><h4>dlil_attach_interface_filter</h4><p>Inserts a DLIL interface filter between the DLIL and the interface.</p><div class="codesample"><table><tr><td scope="row"><pre>int dlil_attach_interface_filter( struct ifnet *ifnet_ptr,<span></span></pre></td></tr><tr><td scope="row"><pre>        struct dlil_if_flt_str *interface_filter,<span></span></pre></td></tr><tr><td scope="row"><pre>        int *filter_id,<span></span></pre></td></tr><tr><td scope="row"><pre>        u_long insertion_point);<span></span></pre></td></tr></table></div><p><code>ifnet_ptr</code>A pointer to the <code>ifnet</code> structure for this interface.</p><p><code>interface_filter</code>A pointer to a <code>dlil_if_fil_str</code> structure that contains pointers to the function calls that the DLIL is to call when the family interface module calls common network driver code for the specified interface. Each function pointed to by a member of this structure corresponds to a function pointed to by the <code>ifnet</code> structure.</p><p><code>filter_id</code>On input, a pointer to a value of type <code>int</code>. On output, <code>filter_id</code> points to a value that identifies the NKE that has been inserted. This value is required to remove the NKE or insert another NKE after it.</p><p><code>insertion_point</code>On input, a value of type <code>u_long</code>. If this is the first insertion, set <code>insertion_point</code> to <code>DLIL_LAST_FILTER</code>. If this is the second or greater insertion, set <code>insertion_point</code> to the value of <code>filter_id</code> returned by a previous call to <code>dlil_attach_interface_filter</code> or to <code>DLIL_LAST_FILTER</code> to insert the filter at the end of the chain of inserted filters.</p><p><code>function result</code>0 for success. Other possible errors are defined in <code>&lt;errno.h></code>.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_79" title="DISCUSSION"></a><h5>DISCUSSION</h5><p>The <code>dlil_attach_interface_filter</code> function inserts a DLIL interface filter between the DLIL and an interface. When the filter is in place, the DLIL intercepts all calls between itself and the interface's driver and passes the call and its parameters to the filter.</p><p>You can insert multiple DLIL interface filters, in which case the DLIL calls the filters in the order specified by <code>insertion_point</code> at the time of insertion. The order in which filters are executed is reversed when an incoming packet is being processed (that is, the last filter called for an outbound packet will be the first filter called for an inbound packet).</p><p>When more than one DLIL interface filter is installed, the DLIL calls the appropriate function for the first filter with the parameters provided by the caller. When that call returns successfully, the DLIL calls the appropriate function for the second filter with the parameters returned by the first filter, and so on until the appropriate functions have been called for each filter in the list. When the last filter has been called, the DLIL calls the original destination function with the parameters returned by the last filter.</p><p>The DLIL skips any null function pointers, which allows DLIL interface filters to intercept only a subset of the calls that the DLIL may make to the driver for the specified interface.</p><p>If a DLIL interface filter returns a status other than zero (which indicates success) or <code>EJUSTRETURN</code>, the DLIL frees any associated <code>mbuf</code> chain (for the <code>filter_if_output</code> and <code>filter_if_input</code> functions only) and returns with that status.</p><p>If a DLIL interface extension returns a status of <code>EJUSTRETURN</code>, the DLIL returns zero to indicate success. The DLIL interface filter is responsible for freeing or forwarding any associated <code>mbuf</code> chain.</p><p>With a return value of zero, the DLIL continues to process the list of NKEs.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBACJAEG" title="dlil_attach_protocol"></a><h4>dlil_attach_protocol</h4><p>Attaches a protocol to the DLIL for use with an interface.</p><div class="codesample"><table><tr><td scope="row"><pre>int dlil_attach_protocol( struct dlil_proto_reg_str *proto_reg, u_long *dl_tag);<span></span></pre></td></tr></table></div><p><code>proto_reg</code>On input, a pointer to a <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAJDEHE">“dlil_proto_reg_str”</a></span> structure containing all of the information required to complete the attachment. </p><p><code>dl_tag</code>On input, a pointer to a value of type <code>u_long</code>. On output, <code>dl_tag</code> points to an opaque value identifying the interface/protocol pair that is passed in subsequent calls to the <code>dlil_output</code>, <code>dlil_ioctl</code>, and <code>dlil_detach</code> functions.</p><p><code>function result</code>0 for success and <code>ENOENT</code> if the specified interface does not exist. Other possible errors are defined in <code>&lt;errno.h></code>.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_80" title="DISCUSSION"></a><h5>DISCUSSION</h5><p>The dlil_attach_protocol function attaches a protocol to the DLIL for use with a specific network interface. For example, you would call <code>dlil_attach_protocol</code> to attach the TCP/IP protocol family to <code>en0</code>, which is the first Ethernet family interface.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBADGIJF" title="dlil_detach_filter"></a><h4>dlil_detach_filter</h4><p>Removes a DLIL interface filter or a DLIL protocol filter.</p><div class="codesample"><table><tr><td scope="row"><pre>int dlil_detach_filter( u_long filter_id );<span></span></pre></td></tr></table></div><p><code>filter_id</code>A value of type <code>u_long</code> obtained by previously calling <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBADHACJ">“dlil_attach_interface_filter”</a></span> or <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAEDGCH">“dlil_attach_protocol_filter.”</a></span></p><p><code>function result</code>0 for success or <code>ENOENT</code> of the specified filter does not exist.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_81" title="DISCUSSION"></a><h5>DISCUSSION</h5><p>The <code>dlil_detach_filter</code> function removes a DLIL interface filter or a DLIL protocol filter that was previously attached by calling <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBADHACJ">“dlil_attach_interface_filter”</a></span> or <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAEDGCH">“dlil_attach_protocol_filter.”</a></span></p><p>If the filter has a detach routine and a function pointer to it was supplied when the filter was attached, the DLIL calls the filter's detach routine before detaching the filter. The detach routine should complete any clean up tasks before it returns.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBABHIBH" title="dlil_detach_protocol"></a><h4>dlil_detach_protocol</h4><p>Detaches a protocol from the DLIL.</p><div class="codesample"><table><tr><td scope="row"><pre>int dlil_detach_protocol( u_long dl_tag );<span></span></pre></td></tr></table></div><p><code>dl_tag</code>On input, a value of type <code>u_long</code>, previously obtained by calling <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBACJAEG">“dlil_attach_protocol,”</a></span> that identifies the protocol and the interface from which the protocol is to be detached.</p><p><code>function result</code>0 for success and <code>ENOENT</code> if the defined protocol is not currently attached. Other possible errors are defined in <code>&lt;errno.h></code>.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_82" title="DISCUSSION"></a><h5>DISCUSSION</h5><p>The <code>dlil_detach_protocol</code> function detaches a protocol that was previously attached to the DLIL by calling <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBACJAEG">“dlil_attach_protocol.”</a></span> Before detaching the protocol, the DLIL calls the detach filter callback functions for any NKEs that may have been inserted between the protocol and the interface that is being detached from.</p><p>The DLIL keeps a reference count of protocols attached to each interface. When the reference count reaches zero as a result of calling <code>dlil_detach_protocol</code>, the DLIL calls the <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBADAFEB">“if_free”</a></span> function for the affected interface to notify the driver that no protocols are attached to the interface. The reference count can only reach zero if the driver detaches the interface.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAGICHH" title="dlil_output"></a><h4>dlil_output</h4><p>Sends data to a network interface.</p><div class="codesample"><table><tr><td scope="row"><pre>int dlil_output (u_long dl_tag, struct mbuf *buffer, caddr_t route, struct sockaddr *dest, int raw);<span></span></pre></td></tr></table></div><p><code>dl_tag</code>On input, a value of type <code>u_long</code>, previously obtained by calling <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBACJAEG">“dlil_attach_protocol,”</a></span> that identifies the associated protocol/interface pair.</p><p><code>buffer</code>On input, a pointer to the <code>mbuf</code> chain, which may contain multiple packets.</p><p><code>route</code>On input, a pointer to an opaque pointer-sized value whose use is specific to each protocol family, or <code>NULL</code>.</p><p><code>dest</code>On input, a pointer to an <code>sockaddr</code> structure that defines the target network address that the DLIL passes to the associated <code>dl_pre_output</code> function. If <code>raw</code> is <code>FALSE</code>, this parameter is ignored.</p><p><code>raw</code>On input, a Boolean value. Setting <code>raw</code> to <code>TRUE</code> indicates that the <code>mbuf</code> chain pointed to by <code>buffer</code> contains a link-level frame header (which means that no further processing by the protocol or by the interface family modules is required). If <code>raw</code> is <code>FALSE</code>, protocol filters are not called, but any interface filters attached to the target interface are called.</p><p><code>function result</code>0 for success.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_83" title="DISCUSSION"></a><h5>DISCUSSION</h5><p>The <code>dlil_output </code>function is a DLIL function that the network layer calls in order to send data to a network interface. The <code>dlil_output</code> function executes as follows:</p><ol class="ol"><li class="li"><p>If the <code>raw</code> parameter is <code>TRUE</code>, go to step 4. Otherwise, if the <code>raw</code> parameter is <code>FALSE</code> and the attached protocol identified by <code>dl_tag</code> has defined a <code>dl_pre_output</code> function, the DLIL calls that <code>dl_pre_output</code> function and passes to it all of the parameters passed to <code>dl_output</code> by the caller, as well as pointers to two buffers in which the <code>dl_pre_output</code> function can pass back the frame type and destination data link address.</p></li><li class="li"><p>If any data link protocol extensions are attached to the protocol/interface pair, those NKEs are called in the order they were inserted. If any NKE returns a value other than zero for success or <code>EJUSTRETURN</code>, the DLIL stops processing the packet, <code>dlil_output</code> frees the <code>mbuf</code> chain, and returns an error to its caller. When any NKE returns <code>EJUSTRETURN</code>, packet processing terminates without freeing the <code>mbuf</code> chain. In this case, the NKE is responsible for freeing or forwarding the <code>mbuf</code> chain.</p></li><li class="li"><p>If an <code>if_framer</code> function is defined for this interface, the DLIL calls the <code>if_framer</code> function. The <code>if_framer</code> function adds any necessary link-level framing to the outbound packet. This function usually prepends the frame header to the beginning of the <code>mbuf</code> chain.</p></li><li class="li"><p>If any data link interface NKEs have been attached to the interface specified by <code>dl_tag</code>, those NKEs are called in the order they were inserted. If any NKE returns a value other than zero for success or <code>EJUSTRETURN</code>, the DLIL stops processing the packet, frees the <code>mbuf</code> chain, and returns an error to its caller. When any NKE returns <code>EJUSTRETURN</code>, packet processing terminates without freeing the <code>mbuf</code> chain. In this case, the NKE is responsible for freeing or forwarding the <code>mbuf</code> chain.</p></li><li class="li"><p>As the last step, <code>dlil_output</code> calls <code>if_output</code> in order to pass the <code>mbuf</code> chain and a pointer to the <code>ifnet</code> structure to the interface's driver.</p></li></ol><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAHEBFA" title="dlil_ioctl"></a><h4>dlil_ioctl</h4><p>Accesses DLIL-specific or driver-specific functionality.</p><div class="codesample"><table><tr><td scope="row"><pre>int dlil_ioctl (u_long dl_tag, struct ifnet *ifp, u_long ioctl_code, caddr_t ioctl_arg);<span></span></pre></td></tr></table></div><p><code>dl_tag</code>On input, a value of type <code>u_long</code>, previously obtained by calling <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBACJAEG">“dlil_attach_protocol,”</a></span> that identifies the associated protocol/interface pair. If not <code>zero</code>, the DLIL uses the value of <code>dl_tag</code> to identify the target protocol module. If <code>dl_tag</code> is <code>zero</code>, <code>ifp</code> is not <code>NULL</code>, and the interface has defined an <code>if_ioctl</code> function, the DLIL calls the interface's <code>if_ioctl</code> function and passes to it the parameters supplied by the caller.</p><p><code>ifp</code>On input, a pointer to the <code>ifnet</code> structure associated with the target interface. This parameter is not used if <code>dl_tag</code> is non-zero.</p><p><code>ioctl_code</code>On input, a value of type <code>u_long</code> that specifies the specific ioctl function that is to be accessed.</p><p><code>ioctl_arg</code>On input, a value of type <code>caddr_t</code> whose contents depend on the value of <code>ioctl_code</code>.</p><p><code>function result</code>0 for success.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_84" title="DISCUSSION"></a><h5>DISCUSSION</h5><p>The <code>dlil_ioctl </code>function is a DLIL function that the network layer calls in order to send ioctl commands to a network interface.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBADFADH" title="Calling the Network Layer From the DLIL"></a><h3>Calling the Network Layer From the DLIL</h3><p>This section describes network layerfunctions called by the DLIL. The functions are</p><ul class="spaceabove"><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAJFEEE">“dl_pre_output,”</a></span> which the DLIL calls in order to perform protocol-specific processing (such as resolving the network address to a link-level address) for outbound packets.</p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAEFFIG">“dl_input,”</a></span> which the DLIL calls in order to pass incoming packets to the protocol.</p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAICJAF">“dl_offer,”</a></span> which the DLIL calls in order to identify incoming frames.</p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAGDEGG">“dl_event,”</a></span> which the DLIL calls in order to pass events from the driver layer to a protocol.</p></li></ul><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAJFEEE" title="dl_pre_output"></a><h4>dl_pre_output</h4><p>Obtains the destination link address and frame type for outgoing packets.</p><div class="codesample"><table><tr><td scope="row"><pre>int (*dl_pre_output) (struct mbuf *mbuf_ptr, caddr_t route_entry, struct sockaddr *dest, char *frame_type, char *dest_linkaddr, u_char dl_tag);<span></span></pre></td></tr></table></div><p><code>mbuf_ptr</code>On input, a pointer to an <code>mbuf</code> structure containing one or more outgoing packets.</p><p><code>route_entry</code>On input, a value of type <code>caddr_t</code> that is passed to the DLIL when a protocol calls <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAGICHH">“dlil_output.”</a></span></p><p><code>dest</code>On input, a pointer to a <code>sockaddr</code> structure that describes the packets' destination network address, or <code>NULL</code>. This parameter is passed to the DLIL when the protocol calls <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAGICHH">“dlil_output.”</a></span> The format of the <code>sockaddr</code> structure is specific to each protocol family.</p><p><code>frame_type</code>On input, a pointer to a byte array of undefined length. On output, <code>frame_type</code> contains the frame type for this protocol.</p><p><code>dest_linkaddr</code>On input, a pointer to a byte array of undefined length. On output, <code>dest_linkaddr</code> contains the destination link address.</p><p><code>dl_tag</code>On input, a value of type <code>u_long</code>, previously obtained by calling <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBACJAEG">“dlil_attach_protocol,”</a></span> that identifies the associated protocol/interface pair.</p><p><code>function result</code>0 for success. Errors are defined in<code> &lt;errno.h></code>.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_85" title="DISCUSSION"></a><h5>DISCUSSION</h5><p>The <code>dl_pre_output</code> function obtains the link address and frame type for outgoing packets whose destination is described by the <code>dest</code> parameter.</p><p>The <code>dl_pre_output</code> function pointer in the <code>if_proto</code> structure is optionally defined when a protocol calls the function <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBACJAEG">“dlil_attach_protocol”</a></span> to register a protocol family. The DLIL calls the <code>dl_pre_output</code> function when a protocol calls <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAGICHH">“dlil_output.”</a></span></p><p>In addition to defining the destination link address and the frame type, the <code>dl_pre_output</code> function may also add a packet header, such as 802.2 or SNAP.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAEFFIG" title="dl_input"></a><h4>dl_input</h4><p>Receives incoming packets.</p><div class="codesample"><table><tr><td scope="row"><pre>int (*dl_input) (struct mbuf *mbuf_ptr, char *frame_header, struct ifnet *ifnet_ptr, caddr_t dl_tag, int sync_ok);<span></span></pre></td></tr></table></div><p><code>mbuf_ptr</code>On input, a pointer to an <code>mbuf</code> structure.</p><p><code>frame_header</code>On input, a pointer to a byte array of undefined length containing the frame header.</p><p><code>ifnet_ptr</code>On input, a pointer to the <code>ifnet</code> structure for this protocol/interface pair.</p><p><code>dl_tag</code>On input, a value of type <code>u_long</code>, previously obtained by calling <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBACJAEG">“dlil_attach_protocol,”</a></span> that identifies the associated protocol/interface pair.</p><p><code>sync_ok</code>Reserved.</p><p><code>function result</code>0 for success. Errors are defined in<code> &lt;errno.h></code>.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_86" title="DISCUSSION"></a><h5>DISCUSSION</h5><p>The <code>dl_input</code> function is called by the DLIL. When a DLIL module receives a frame from the driver and finishes interface-specific processing, it calls the target protocol through the <code>dl_input</code> function pointer. The interface family's demultiplexing module identifies the target protocol by matching the data provided in the demultiplexing descriptors when the protocol was attached.</p><p>The <code>dl_input</code> function pointer in the <code>if_proto</code> structure is defined by the <code>input</code> member of the <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAJDEHE">“dlil_proto_reg_str”</a></span> structure, which the function <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBACJAEG">“dlil_attach_protocol”</a></span> passes to the DLIL when a protocol is attached.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAICJAF" title="dl_offer"></a><h4>dl_offer</h4><p>Examines unidentified frames.</p><div class="codesample"><table><tr><td scope="row"><pre>int (*dl_offer) (struct mbuf *mbuf_ptr, char *frame_header; u_long dl_tag);<span></span></pre></td></tr></table></div><p><code>mbuf_ptr</code>On input, a pointer to an <code>mbuf</code> structure containing incoming frames.</p><p><code>dl_tag</code>On input, a value of type <code>u_long</code>, previously obtained by calling <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBACJAEG">“dlil_attach_protocol,”</a></span> that identifies the associated protocol/interface pair.</p><p><code>frame_header</code>On input, a pointer to a byte array containing the frame header as received from the driver. The length of <code>frame_header</code> depends on the interface family.</p><p><code>function result</code><code>DLIL_FRAME_ACCEPTED</code> or <code>DLIL_FRAME_REJECTED</code>.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_87" title="DISCUSSION"></a><h5>DISCUSSION</h5><p>The <code>dl_offer</code> function accepts or rejects a frame that was not identified by a protocol's demultiplexing descriptors.</p><p>When the interface family demultiplexing module receives a frame that does not match any of the protocol's demultiplexing descriptors, the module calls any defined <code>dl_offer</code> function and passes to it the unidentified frame. The <code>dl_offer</code> function can accept or reject the frame.</p><p>The <code>dl_offer</code> function pointer in the <code>if_proto</code> structure is optionally defined by the <code>offer</code> member of the <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAJDEHE">“dlil_proto_reg_str”</a></span> structure, which the <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBACJAEG">“dlil_attach_protocol”</a></span> function passes to the DLIL when a protocol is attached.</p><p>If a <code>dl_offer</code> function accepts the frame, the frame is not offered to any other protocol's <code>dl_offer</code> function. If no <code>dl_offer</code> function accepts the frame, the frame is dropped.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_148" title="Note"></a><p><strong>Note:</strong>&nbsp;The <code>dl_offer</code> function only indicates whether it will accept the frame. It does not modify the frame or start processing it. Processing occurs when <code>dlil_input</code> calls the protocol's <code>dl_input</code> function.</p></div><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAGDEGG" title="dl_event"></a><h4>dl_event</h4><p>Receives events passed by the DLIL from the interface's driver.</p><div class="codesample"><table><tr><td scope="row"><pre>void (*dl_event) (struct event_msg *event, u_long dl_tag);<span></span></pre></td></tr></table></div><p><code>event</code>On input, a pointer to an <code>event_msg</code> structure.</p><p><code>dl_tag</code>On input, a value of type <code>u_long</code>, previously obtained by calling <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBACJAEG">“dlil_attach_protocol,”</a></span> that identifies the associated protocol/interface pair. The <code>dl_event</code> function uses <code>dl_tag</code> to determine the interface that was the source of the event.</p><p><code>function result</code>None.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_88" title="DISCUSSION"></a><h5>DISCUSSION</h5><p>The <code>dl_event</code> function receives events from the interface's driver. When the DLIL receives an event from the driver, the module calls the defined <code>dl_event</code> functions of all protocols that are attached to the interface, passing in <code>event_msg</code> an event-specific code and an event value that is interpreted by the <code>dl_event</code> function.</p><p>If <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBACJAEG">“dlil_attach_protocol”</a></span> was called with a null pointer for the <code>dl_event</code> function, no action is taken for that protocol family. </p><p>The <code>dl_event</code> function pointer in the <code>if_proto</code> structure is optionally defined by the <code>event</code> member of <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAJDEHE">“dlil_proto_reg_str”</a></span> structure, which <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBACJAEG">“dlil_attach_protocol”</a></span> passes to the DLIL when a protocol is attached.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBABGJGJ" title="Calling the Driver Layer From the DLIL"></a><h3>Calling the Driver Layer From the DLIL</h3><p>The functions described in this section are called by the DLIL to an interface's driver. The functions are</p><ul class="spaceabove"><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBABCGHI">“if_output,”</a></span> which the DLIL calls in order to pass outgoing packets to the interface's driver.</p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBACEGGB">“if_ioctl,”</a></span> which the DLIL calls in order to pass ioctl commands to the interface's driver.</p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAJBCDA">“if_set_bpf_tap,”</a></span> which the DLIL calls in order to enable or disable a binary packet filter tap.</p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBADAFEB">“if_free,”</a></span> which the DLIL calls in order to free the <code>ifnet</code> structure for an interface.</p></li></ul><a name="//apple_ref/doc/uid/TP40001089-CH227-BBABCGHI" title="if_output"></a><h4>if_output</h4><p>Accepts outgoing packets and passes them to the interface's driver.</p><div class="codesample"><table><tr><td scope="row"><pre>int (*if_output) (struct ifnet *ifnet_ptr, struct mbuf *buffer);<span></span></pre></td></tr></table></div><p><code>ifnet_ptr</code>On input, a pointer to the <code>ifnet</code> structure for this interface.</p><p><code>buffer</code>On input, a pointer to an <code>mbuf</code> structure containing one or more outgoing packets.</p><p><code>function result</code>0 for success. Errors are defined in<code> &lt;errno.h></code>.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_89" title="DISCUSSION"></a><h5>DISCUSSION</h5><p>The <code>if_output</code> function sends outgoing packets to the interface's driver. The DLIL calls <code>if_output</code> when the associated protocol calls <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAGICHH">“dlil_output.”</a></span></p><p>The <code>if_output</code> function must accept all of the packets in the <code>mbuf</code> chain.</p><p>The <code>if_output </code>function pointer is defined in the interface's <code>ifnet</code> structure and is initialized by the interface driver before the interface driver calls <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAHEJJA">“dlil_if_attach.”</a></span></p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBACEGGB" title="if_ioctl"></a><h4>if_ioctl</h4><p>Processes ioctl commands.</p><div class="codesample"><table><tr><td scope="row"><pre>int (*if_ioctl) (struct ifnet *ifnet_ptr, u_long ioctl_code, caddr_t ioctl_arg);<span></span></pre></td></tr></table></div><p><code>ifnet_ptr</code>On input, a pointer to the <code>ifnet</code> structure for this interface.</p><p><code>ioctl_code</code>On input, a value of type <code>u_long</code> containing the ioctl command.</p><p><code>ioctl_arg</code>On input, a value of type <code>caddr_t</code> whose contents depend on the value of <code>ioctl_code</code>.</p><p><code>function result</code>0 for success. Other results are specific to the driver's ioctl function.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_90" title="DISCUSSION"></a><h5>DISCUSSION</h5><p>The <code>if_ioctl </code>function accepts and processes ioctl commands that access driver-specific functionality.</p><p>The <code>if_ioctl</code> pointer is defined in the interface's <code>ifnet</code> structure and is initialized by the interface driver before the interface driver calls <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAHEJJA">“dlil_if_attach.”</a></span></p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAJBCDA" title="if_set_bpf_tap"></a><h4>if_set_bpf_tap</h4><p>Enables or disables a binary packet filter tap for an interface.</p><div class="codesample"><table><tr><td scope="row"><pre>int (*if_set_bpf_tap) (int mode, struct ifnet *ifnet_ptr, void (*bpf_callback) ( struct ifnet *ifnet_ptr, struct mbuf *mbuf_ptr, int direction);<span></span></pre></td></tr></table></div><p><code>mode</code>On input, a value of type <code>int</code> that is <code>BPF_TAP_DISABLE</code> (to disable the tap), <code>BPF_TAP_INPUT</code> (to enable the tap on incoming packets), <code>BPF_TAP_OUTPUT </code>(to enable the tap on outgoing packets), or <code>BPF_TAP_INPUT_OUTPUT</code> (to enable the tap on incoming and outgoing packets).</p><p><code>ifnet_ptr</code>On input, a pointer to the <code>ifnet</code> structure for this interface.</p><p><code>callback</code>On input, a function pointer to the tap.</p><p><code>function result</code>0 for success.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_91" title="DISCUSSION"></a><h5>DISCUSSION</h5><p>The <code>if_set_bpf_tap </code>function enables or disables a read-only binary packet filter tap for an interface. A tap is different from a NKE in that it is read-only and that it operates within the driver. Any network driver attached to the DLIL can be tapped.</p><p>The <code>if_set_bpf_tap</code> function pointer is defined in the interface's <code>ifnet</code> structure by the driver before the driver calls <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAHEJJA">“dlil_if_attach.”</a></span></p><p>If the value of the <code>mode</code> parameter is <code>BPF_TAP_INPUT</code>, <code>BPF_TAP_OUTPUT</code>, or <code>BPF_TAP_INPUT_OUTPUT</code>, the <code>bfp_callback</code> parameter points to a C function the driver calls when transmitting or receiving data over the interface (depending on the value of <code>mode</code>). If the value of <code>mode</code> is <code>BPF_TAP_DISABLE</code>, the tap is disabled for incoming and outgoing packets.</p><p>When the driver calls its <code>bpf_callback</code> function, it passes a pointer to the interface's <code>ifnet</code> structure and a pointer to the incoming or outgoing <code>mbuf</code> chain.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBADAFEB" title="if_free"></a><h4>if_free</h4><p>Frees the <code>inet</code> structure for an interface.</p><div class="codesample"><table><tr><td scope="row"><pre>void (*if_free) (struct ifnet *ifnet_ptr);<span></span></pre></td></tr></table></div><p><code>ifnet_ptr</code>On input, a pointer to the <code>ifnet</code> structure that is to be freed.</p><p><code>function result</code>None.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_92" title="DISCUSSION"></a><h5>DISCUSSION</h5><p>The <code>if_free </code>function frees the <code>ifnet</code> structure for an interface. It is called by the DLIL in response to a previous <code>dlil_if_detach</code> call from the driver that returned <code>DLIL_WAIT_FOR_FREE</code>. Once all references to the <code>ifnet</code> structure have been deallocated, the DLIL calls <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBADAFEB">“if_free”</a></span> to notify the driver that the associated <code>ifnet</code> structure pointed to by <code>ifnet_ptr</code> is no longer being referenced and can be deallocated.</p><p>The <code>if_free</code> pointer is defined in the interface's <code>ifnet</code> structure before the interface driver calls <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAHEJJA">“dlil_if_attach.”</a></span></p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBADAJJI" title="Calling the DLIL From the Driver Layer"></a><h3>Calling the DLIL From the Driver Layer</h3><p>Drivers call the following DLIL functions:</p><ul class="spaceabove"><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAHEJJA">“dlil_if_attach”</a></span> to attach an interface to the DLIL.</p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAHGIAJ">“dlil_if_detach”</a></span> to detach an interface from the DLIL.</p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBABCEEE">“dlil_reg_if_modules”</a></span> to register an interface family module.</p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAHEJBE">“dlil_find_dl_tag”</a></span> to locate the <code>dl_tag</code> value for a protocol and interface family pair.</p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAIICGD">“dlil_input”</a></span> to pass incoming packets to the DLIL.</p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBACAIAF">“dlil_event”</a></span> to pass event codes to the DLIL.</p></li></ul><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAHEJJA" title="dlil_if_attach"></a><h4>dlil_if_attach</h4><p>Attaches an interface to the DLIL for use by a specified protocol.</p><div class="codesample"><table><tr><td scope="row"><pre>int dlil_if_attach( struct ifnet *ifnet_ptr );<span></span></pre></td></tr></table></div><p><code>ifnet_ptr</code>A pointer to an <code>ifnet</code> structure containing all of the information required to complete the attachment. The <code>ifnet</code> structure may be embedded within an interface-family-specific structure, in which case the <code>ifnet</code> structure must be the first member of that structure.</p><p><code>function result</code>0 for success and <code>ENOENT</code> if no interface family module is found. Other possible errors are defined in <code>errno.h</code>.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_93" title="DISCUSSION"></a><h5>DISCUSSION</h5><p>The <code>dlil_if_attach</code> function attaches an interface to the DLIL. If the DLIL interface family module for the specified interface has not been loaded, an error is returned. (See <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBABCEEE">“dlil_reg_if_modules.”</a></span>)</p><p>The DLIL calls the <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAGCDGA">“add_if”</a></span> function for the interface family module in order to initialize the module's portion of the <code>ifnet</code> structure and perform any module-specific tasks. At minimum, the <code>add_if</code> function is responsible for initializing the <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBADCHFG">“if_demux”</a></span> and <code>if_framer</code> function pointers in the <code>ifnet</code> structure. Later, the DLIL uses the <code>if_demux</code> function pointer to call the demultiplexing descriptors for the interface in order to demultiplex incoming frames and uses the <code>if_framer</code> function pointer to frame outbound packets.</p><p>Once <code>add_if</code> initializes the members of the <code>ifnet</code> structure for which it is responsible, the DLIL places the interface on the list of network interfaces, and <code>dlil_if_attach</code> returns.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAHGIAJ" title="dlil_if_detach"></a><h4>dlil_if_detach</h4><p>Detaches an interface from the DLIL.</p><div class="codesample"><table><tr><td scope="row"><pre>int dlil_if_detach( struct ifnet *ifnet_ptr );<span></span></pre></td></tr></table></div><p><code>inet_ptr</code>A pointer to an <code>ifnet</code> structure that was previously used to call <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAHEJJA">“dlil_if_attach.”</a></span></p><p><code>function result</code>0 for success. <code>DLIL_WAIT_FOR_FREE</code> if the driver must wait for the DLIL to call the <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBADAFEB">“if_free”</a></span> callback function before deallocating the <code>ifnet</code> structure.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_94" title="DISCUSSION"></a><h5>DISCUSSION</h5><p>The <code>dlil_if_detach</code> function detaches a network interface from the DLIL, thereby disabling communication to and from the interface. Then the DLIL marks the interface as detached in the interface's <code>ifnet</code> structure. To notify the protocols that are attached to the interface that the interface has been detached, the DLIL then calls the <code>dl_event</code> function for all of the protocols have defined such a function. In response, attached protocols should call <code>dlil_detach_protocol</code> to detach themselves from the interface.</p><p>The protocols or the socket layer may still have references to the <code>ifnet</code> structure for the detached interface, so interface drivers should wait to deallocate the interface's <code>ifnet</code> structure until the DLIL calls the interface's <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBADAFEB">“if_free”</a></span> function to notify the driver that all protocols have detached from the interface.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBABCEEE" title="dlil_reg_if_modules"></a><h4>dlil_reg_if_modules</h4><p>Registers an interface family.</p><div class="codesample"><table><tr><td scope="row"><pre>dlil_reg_if_modules(u_longinterface_family, int (*add_if), int (*del_if), int (*add_proto), int (*del_proto), int (*shutdown)());<span></span></pre></td></tr></table></div><p><code>interface_family</code>On input, a value of type <code>u_long</code> specified that uniquely identifies the interface family. Values for the current interface families are defined in <code>&lt;net/if_var.h></code>. You can define new interface family values by contacting DTS.</p><p><code>add_if</code>On input, a pointer to the interface family module's <code>add_if</code> function.</p><p><code>del_if</code>On input, a pointer to the interface family module's <code>del_if</code> function.</p><p><code>add_proto</code>On input, a pointer to the interface family module's <code>add_proto</code> function.</p><p><code>del_proto</code>On input, a pointer to the interface family module's <code>del_proto</code> function.</p><p><code>shutdown</code>On input, a pointer to the interface family module's <code>shutdown </code>function.</p><p><code>function result</code>0 for success. Other errors are defined in <code>errno.h</code>.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_95" title="DISCUSSION"></a><h5>DISCUSSION</h5><p>The <code>dlil_reg_if_modules</code> function registers an interface family module that contains the necessary functions for processing inbound and outbound packets including<code> if_demux</code> and <code>if_framer</code> functions. Any null function pointers are skipped in DLIL processing.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAHEJBE" title="dlil_find_dl_tag"></a><h4>dlil_find_dl_tag</h4><p>Gets the <code>dl_tag</code> for an interface and protocol family pair.</p><div class="codesample"><table><tr><td scope="row"><pre>dlil_find_dl_tag(u_longif_family; short unit; u_long proto_family; u_long *dl_tag);<span></span></pre></td></tr></table></div><p><code>if_family</code>On input, a value of type <code>u_long</code> that uniquely identifies the interface family. See <code>&lt;net/if_var.h></code> for possible values.</p><p><code>unit</code>On input, a value of type <code>short</code> containing the unit number of the interface.</p><p><code>proto_family</code>On input, a value of type <code>u_long</code> that uniquely identifies the protocol family. See <code>&lt;net/if_var.h></code> for possible values.</p><p><code>dl_tag</code>On input, a pointer to a value of type <code>u_long</code> in which the <code>dl_tag</code> value for the specified interface and protocol family pair is to be returned.</p><p><code>function result</code>0 for success. <code>EPROTONOSUPPORT</code> if a matching pair is not found.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_96" title="DISCUSSION"></a><h5>DISCUSSION</h5><p>The <code>dlil_find_dl_tag</code> function locates the <code>dl_tag</code> value associated with the specified interface and protocol family pair.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAIICGD" title="dlil_input"></a><h4>dlil_input</h4><p>Passes incoming packets to the DLIL.</p><div class="codesample"><table><tr><td scope="row"><pre>int dlil_input(struct ifnet *ifp, struct mbuf *m);<span></span></pre></td></tr></table></div><p><code>ifp</code>On input, a pointer to the <code>ifnet</code> structure for this interface.</p><p><code>m</code>On input, a pointer to the head of a chain of <code>mbuf</code> structures containing one or more incoming frames.</p><p><code>function result</code>0 for success.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_97" title="DISCUSSION"></a><h5>DISCUSSION</h5><p>The <code>dlil_input</code> function is called by the driver layer to pass incoming frames from an interface to the DLIL. The <code>dlil_input</code> function performs the following sequence:</p><ol class="ol"><li class="li"><p>Any interface filters attached to the associated interface are called.</p></li><li class="li"><p>Assuming all filters return successfully, <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBADCHFG">“if_demux”</a></span> is called to determine the target protocol family. If <code>if_demux</code> cannot find a matching protocol family, <code>dlil_input</code> calls the <code>dl_offer</code> functions (if any) defined by the attached protocol families.</p></li><li class="li"><p>If no target protocol family is found, the frame is dropped.</p></li><li class="li"><p>Any protocol filters attached to the target protocol family/interface are called.</p></li><li class="li"><p>If all protocol filters return successfully, the frame is passed to the protocol family's <code>dl_input</code> function. DLIL frame processing is finished.</p></li></ol><a name="//apple_ref/doc/uid/TP40001089-CH227-BBACAIAF" title="dlil_event"></a><h4>dlil_event</h4><p>Notifies the DLIL of significant events.</p><div class="codesample"><table><tr><td scope="row"><pre>void (*dlil_event) (struct ifnet *ifnet_ptr, struct event_msg *event);<span></span></pre></td></tr></table></div><p><code>ifnet_ptr</code>On input, a pointer to the <code>ifnet</code> structure for this interface.</p><p><code>event</code>On input, a pointer to an <code>event_mgs</code> structure containing a unique event code and a pointer to event data.</p><p><code>function result</code>A result code.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_98" title="DISCUSSION"></a><h5>DISCUSSION</h5><p>The <code>dlil_event</code> function is called by the driver layer to pass event codes, such as a change in the status of power management, to the DLIL. The DLIL passes a pointer to the <code>ifnet</code> structure for this interface and the event parameter to those protocols that are attached to this interface and that have provided a pointer to a <code>dl_event</code> function for receiving events. The protocols may or may not react to any particular event code.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBACEFBB" title="Calling Interface Modules From the DLIL"></a><h3>Calling Interface Modules From the DLIL</h3><p>The DLIL calls the following interface module functions:</p><ul class="spaceabove"><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAGCDGA">“add_if”</a></span> to add an interface.</p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAFHHGH">“del_if”</a></span> to remove an interface.</p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAJBECC">“add_proto”</a></span> which is called to add a protocol.</p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAEABEC">“del_proto”</a></span> which is called to remove a protocol.</p></li></ul><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAGCDGA" title="add_if"></a><h4>add_if</h4><p>Adds an interface.</p><div class="codesample"><table><tr><td scope="row"><pre>int (*add_if) struct ifnet *ifp);<span></span></pre></td></tr></table></div><p><code>ifp</code>On input, a pointer to the <code>ifnet</code> structure for the interface that is being added.</p><p><code>function result</code>0 for success.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_99" title="DISCUSSION"></a><h5>DISCUSSION</h5><p>The <code>add_if </code>function is called by the DLIL in response to a call to <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAHEJJA">“dlil_if_attach.”</a></span> The DLIL calls <code>add_if</code> in the interface family module in order to initialize the module's portion of the <code>ifnet</code> structure and perform any module-specific tasks. </p><p>At minimum, the <code>add_if</code> function initializes the <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBADCHFG">“if_demux”</a></span> and <code>if_framer</code> function pointers in the <code>ifnet</code> structure. Later, the DLIL uses the <code>if_demux</code> function pointer to call the demultiplexing function for the interface to demultiplex incoming frames and calls the <code>if_framer</code> function to frame outbound packets.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAFHHGH" title="del_if"></a><h4>del_if</h4><p>Deinitializes portions of an <code>ifnet</code> structure.</p><div class="codesample"><table><tr><td scope="row"><pre>int (*del_if) struct ifnet *ifp);<span></span></pre></td></tr></table></div><p><code>ifp</code>On input, a pointer to the <code>ifnet</code> structure for the interface that is being deinitialized.</p><p><code>function result</code>0 for success.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_100" title="DISCUSSION"></a><h5>DISCUSSION</h5><p>The <code>del_if </code>function is called by the DLIL to notify an interface family module that an interface is being detached. The interface family module should remove any references to the interface and associated structures.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAJBECC" title="add_proto"></a><h4>add_proto</h4><p>Adds a protocol.</p><div class="codesample"><table><tr><td scope="row"><pre>int (*add_proto)(struct ddesc_head_str *demux_desc_head) struct if_proto *proto, u_long dl_tag);<span></span></pre></td></tr></table></div><p><code>demux_desc_head</code>On input, a pointer to the head of a linked list of one or more protocol demultiplexing descriptors for the protocol that is being added.</p><p><code>proto</code>On input, a pointer to the <code>if_proto</code> structure for the protocol that is being added.</p><p><code>dl_tag</code>On input, a value of type <code>u_long</code>, previously obtained by calling <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBACJAEG">“dlil_attach_protocol,”</a></span> that identifies the associated protocol/interface pair.</p><p><code>function result</code>0 for success.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_101" title="DISCUSSION"></a><h5>DISCUSSION</h5><p>The <code>add_proto </code>function is an interface family module function that processes the passed demux descriptor list, extracting any information needed to identify the attaching protocol in subsequent incoming frames.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAEABEC" title="del_proto"></a><h4>del_proto</h4><p>Removes a protocol.</p><div class="codesample"><table><tr><td scope="row"><pre>int (*del_proto) (struct if_proto *proto, u_long dl_tag);<span></span></pre></td></tr></table></div><p><code>proto</code>On input, a pointer to the <code>if_proto</code> structure for the protocol that is being removed.</p><p><code>dl_tag</code>On input, a value of type <code>u_long</code>, previously obtained by calling <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBACJAEG">“dlil_attach_protocol,”</a></span> that identifies the associated protocol/interface pair.</p><p><code>function result</code>0 for success.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_102" title="DISCUSSION"></a><h5>DISCUSSION</h5><p>The <code>del_proto </code>function is called by the DLIL to remove a protocol family from an interface family module's list of attached protocol families. Any references to the associated <code>if_proto</code> structure pointer should be removed before returning.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBADCHFG" title="if_demux"></a><h4>if_demux</h4><p>Locates demultiplexing descriptors.</p><div class="codesample"><table><tr><td scope="row"><pre>void (*if_demux) (struct ifnet *ifnet_ptr, struct mbuf *mbuf_ptr, char * frame_header);<span></span></pre></td></tr></table></div><p><code>ifnet_ptr</code>On input, a pointer to the <code>ifnet</code> structure for this interface.</p><p><code>mbuf_ptr</code>On input, a pointer to an <code>mbuf</code> structure containing one or more incoming frames.</p><p><code>frame_header</code>On input, a pointer to a character string in the <code>mbuf</code> structure containing a frame header.</p><p><code>function result</code>0 for success.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_103" title="DISCUSSION"></a><h5>DISCUSSION</h5><p>The <code>if_demux </code>function is an interface family function called by <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAEFFIG">“dl_input”</a></span> to determine the target protocol family for an incoming frame. This function uses the demultiplexting data passed in from previous calls to the <code>add_proto</code> function. When a match is found, <code>if_demux</code> returns the associated <code>if_proto</code> pointer.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBACGDHG" title="Calling the DLIL From a DLIL Filter"></a><h3>Calling the DLIL From a DLIL Filter</h3><p>DLIL filters call the following DLIL functions in order to inject data into a data path:</p><ul class="spaceabove"><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAHEBFI">“dlil_inject_if_input”</a></span> is called by a DLIL interface filter to inject frames into the inbound data path.</p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBABCHIJ">“dlil_inject_if_output”</a></span> is called by a DLIL interface filter to inject packets into the outbound data path.</p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAGHICJ">“dlil_inject_pr_input”</a></span> is called by a DLIL protocol filter to inject frames into the inbound data path.</p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAFBFII">“dlil_inject_pr_output”</a></span> is called by a DLIL protocol filter to inject packets into the output data path.</p></li></ul><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAHEBFI" title="dlil_inject_if_input"></a><h4>dlil_inject_if_input</h4><p>Injects frames into the inbound data path from the interface filter level.</p><div class="codesample"><table><tr><td scope="row"><pre>int dlil_inject_if_input (struct mbuf *buffer, char *frame_header, ulong from_id);<span></span></pre></td></tr></table></div><p><code>buffer</code>On input, a pointer to a chain of <code>mbuf</code> structures containing the packets that are to be injected.</p><p><code>frame_header</code>On input, a pointer to a byte array of undefined length containing the frame header for the frames that are to be injected.</p><p><code>from_id</code>On input, a value of type <code>ulong</code> containing the filter ID of the calling filter obtained by previously calling <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBADHACJ">“dlil_attach_interface_filter.”</a></span> If <code>from_id</code> is set to <code>DLIL_NULL_FILTER</code>, all attached interface filters are called.</p><p><code>function result</code>0 for success.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_104" title="DISCUSSION"></a><h5>DISCUSSION</h5><p>The <code>dlil_inject_if_input </code>function is called by an interface filter NKE to inject frames into the inbound data path. The frames can be frames that the filter generates or frames that were previously consumed.</p><p>When a filter injects a frame, the DLIL invokes all of the input interface filter NKEs that would normally be invoked after the filter identified by <code>filter_id</code>. The behavior is identical to the processing of a frame passed to <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAIICGD">“dlil_input”</a></span> from the driver layer except that all interface filter NKEs preceding and including the injecting filter are not executed.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBABCHIJ" title="dlil_inject_if_output"></a><h4>dlil_inject_if_output</h4><p>Injects packets into the outbound data path from the interface filter level.</p><div class="codesample"><table><tr><td scope="row"><pre>int dlil_inject_if_output ( struct mbuf *buffer, ulong from_id);<span></span></pre></td></tr></table></div><p><code>buffer</code>On input, a pointer to a chain of <code>mbuf</code> structures containing the packets that is to be injected.</p><p><code>from_id</code>On input, a value of type <code>ulong</code> containing the filter ID of the calling filter obtained by previously calling <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBADHACJ">“dlil_attach_interface_filter.”</a></span> If <code>from_id</code> is set to <code>DLIL_NULL_FILTER</code>, all attached interface filters are called.</p><p><code>function result</code>0 for success.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_105" title="DISCUSSION"></a><h5>DISCUSSION</h5><p>The <code>dlil_inject_if_output </code>function is called by an interface filter NKE to inject frames into the outbound data path. The packets can be packets that the filter generates or packets that were previously consumed.</p><p>When a filter injects a packet, the DLIL invokes all of the output interface filter NKEs that would normally be invoked after the filter that calls <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBABCHIJ">“dlil_inject_if_output.”</a></span> This behavior is identical to the last steps of packet processing done by <code>dlil_output</code>, except that all output interface filter NKEs preceding and including the injecting filter are not executed.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_149" title="Note"></a><p><strong>Note:</strong>&nbsp;The injected packets must contain any frame header that the driver layer requires.</p></div><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAGHICJ" title="dlil_inject_pr_input"></a><h4>dlil_inject_pr_input</h4><p>Injects frames into the inbound data path from the protocol filter level.</p><div class="codesample"><table><tr><td scope="row"><pre>int dlil_inject_pr_input (struct mbuf *buffer, char *frame_header, ulong from_id);<span></span></pre></td></tr></table></div><p><code>buffer</code>On input, a pointer to a chain of <code>mbuf</code> structures containing the data that is to be injected.</p><p><code>frame_header</code>On input, a pointer to a byte array of undefined length containing the frame header for the frames that are to be injected.</p><p><code>from_id</code>On input, the filter ID of the calling filter obtained by previously calling <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAEDGCH">“dlil_attach_protocol_filter.”</a></span> If <code>from_id</code> is set to the constant <code>DLIL_NULL_FILTER</code>, all attached interface filters are called.</p><p><code>function result</code>0 for success.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_106" title="DISCUSSION"></a><h5>DISCUSSION</h5><p>The <code>dlil_inject_pr_output </code>function is called by a protocol filter NKE to inject frames into the outbound data path. The frames can be frames that the filter generates or frames that were previously consumed.</p><p>When a protocol filter calls <code>dlil_inject_pr_output</code>, the DLIL invokes all of the input protocol filter NKEs that would normally be invoked after the filter that calls <code>dlil_inject_pr_input</code>. This behavior is identical to the last steps of processing that occur when a frame is passed to <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAEFFIG">“dl_input,”</a></span> except that all protocol filter NKEs preceding and including the injecting filter are not executed.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAFBFII" title="dlil_inject_pr_output"></a><h4>dlil_inject_pr_output</h4><p>Injects packets into the outbound data path from the protocol filter level.</p><div class="codesample"><table><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int dlil_inject_pr_output (struct mbuf *buffer,<span></span></pre></td></tr><tr><td scope="row"><pre>        struct sockaddr *dest, int raw, char *frame_type,<span></span></pre></td></tr><tr><td scope="row"><pre>        char *dst_linkaddr, ulong from_id);<span></span></pre></td></tr></table></div><p><code>buffer</code>On input, a pointer to a chain of <code>mbuf</code> structures containing the data that is to be injected.</p><p><code>dest</code>On input, a pointer to an opaque pointer-sized variable whose use is specific to each protocol family, or <code>NULL</code>.</p><p><code>raw</code>On input, a Boolean value. Setting <code>raw</code> to <code>TRUE</code> indicates that the <code>mbuf</code> chain pointed to by <code>buffer</code> contains a link-level frame header, which means that no further processing by the protocol or the interface family modules is required. The value of <code>raw</code> does not affect whether the DLIL calls any NKEs that are attached to the protocol/interface pair.</p><p><code>frame_type</code>On input, a pointer to a byte array of undefined length containing the frame type. The length and content of <code>frame_type</code> are specific to each interface family.</p><p><code>dst_linkaddr</code>A pointer to a byte array of undefined length containing the destination link address.</p><p><code>from_id</code>On input, a value of type <code>ulong</code> containing the filter ID of the calling filter obtained by previously calling <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAEDGCH">“dlil_attach_protocol_filter.”</a></span> If <code>from_id</code> is set to <code>DLIL_NULL_FILTER</code>, all attached interface filters are called.</p><p><code>function result</code>0 for success.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_107" title="DISCUSSION"></a><h5>DISCUSSION</h5><p>The <code>dlil_inject_pr_output </code>function is called by a protocol filter NKE to inject packets into the outbound data path. The packets can be packets that the filter generates or packets that were previously consumed.</p><p>When a protocol filter calls <code>dlil_inject_pr_output</code>, the DLIL invokes all of the output protocol filter NKEs that would normally be invoked after the filter that calls <code>dlil_inject_pr_output</code>. This behavior is identical to the execution of <code>dlil_output</code> following the call to <code>dl_pre_output</code> except that all output protocol filters preceding and including the injecting filter are not executed.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAIDAAE" title="NKE Structures and Data Types"></a><h2>NKE Structures and Data Types</h2><p>This section describes the NKE structures and data types. The structures are</p><ul class="ul"><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAJDEHE">“dlil_proto_reg_str”</a></span> which provides the information necessary to attach a protocol to the DLIL.</p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBADJGBH">“dlil_demux_desc”</a></span> which provides the information necessary to identify a protocol's packets.</p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBABGIBA">“dlil_if_flt_str”</a></span> which contains pointers to all of the functions the DLIL may call when sending or receiving a frame from an interface.</p></li><li class="li"><p><span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBABDHCF">“dlil_pr_flt_str”</a></span> which contains pointers to all of the functions the DLIL may call when it passes a call to an NKE.</p></li></ul><div class="notebox"><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_150" title="Note"></a><p><strong>Note:</strong>&nbsp;With the exception of the <code>ifnet</code> structure, the DLIL makes its own copy of all structures that are passed to it.</p></div><a name="//apple_ref/doc/uid/TP40001089-CH227-BBAJDEHE" title="dlil_proto_reg_str"></a><h3>dlil_proto_reg_str</h3><p>The <code>dlil_proto_reg_str</code> structure is passed as a parameter to the <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBACJAEG">“dlil_attach_protocol”</a></span> function, which attaches network protocol stacks to interfaces.</p><div class="codesample"><table><tr><td scope="row"><pre>struct dlil_proto_reg_str {<span></span></pre></td></tr><tr><td scope="row"><pre>    struct ddesc_head_str demux_desc_head;<span></span></pre></td></tr><tr><td scope="row"><pre>    u_long interface_family;<span></span></pre></td></tr><tr><td scope="row"><pre>    u_long protocol_family;<span></span></pre></td></tr><tr><td scope="row"><pre>    short unit_number;<span></span></pre></td></tr><tr><td scope="row"><pre>    int default_proto;<span></span></pre></td></tr><tr><td scope="row"><pre>    dl_input_func input;<span></span></pre></td></tr><tr><td scope="row"><pre>    dl_pre_output_func pre_output;<span></span></pre></td></tr><tr><td scope="row"><pre>    dl_event_func event;<span></span></pre></td></tr><tr><td scope="row"><pre>    dl_offer_func offer;<span></span></pre></td></tr><tr><td scope="row"><pre>    dl_ioctl_func ioctl;<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><p></p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_108" title="Field Descriptions"></a><h4>Field Descriptions</h4><p><code>ddesc_head_str</code> The head of a linked list of one or more protocol demultiplexing descriptors. Each demultiplexing descriptor defines several sub-structures that are used to identity and demultiplex incoming frames belonging to one or more attached protocols. When multiple methods of frame identification are used for an interface family, a chain of demultiplexing descriptors may be passed to <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBACJAEG">“dlil_attach_protocol”</a></span> and to <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAGCDGA">“add_if”</a></span> to identify each method. </p><p><code>interface_family</code>A unique unsigned long value that specifies the interface family. Values for current interface families are defined in <code>&lt;net/if_var.h></code>. Developers may define new interface family values through DTS.</p><p><code>protocol_family</code>A unique unsigned long value defined that specifies the protocol family being attached. Values for current protocol families are defined in<code> &lt;net/dlil.h></code>. Developers may define new protocol family values through DTS.</p><p><code>unit_number</code>Specifies the unit number of the interface to which the protocol is to be attached. Together, the <code>interface_family</code> and <code>unit_number</code> fields identify the interface to which the protocol is to be attached.</p><p><code>default_proto</code>Reserved. Always 0.</p><p><code>input</code> Contains a pointer to the function that the DLIL is to call in order to pass input packets to the protocol stack.</p><p><code>pre_output</code>Contains a pointer to the function that the DLIL is to call in order to perform protocol-specific processing for outbound packets, such as adding an 802.2/SNAP header and defining the target address.</p><p><code>event</code>Contains a pointer to the function that the DLIL is to call in order to notify the protocol stack of asynchronous events, or is <code>NULL</code>. If this field is <code>NULL</code>, events are not passed to the protocol stack.</p><p><code>offer</code> Contains a pointer to the function that the DLIL is to call in order to offer a frame to the attached protocol, or is <code>NULL</code>. If <code>offer</code> is <code>NULL</code>, the DLIL will not be able to offer frames that cannot be identified to the protocol and the frame may be dropped.</p><p><code>ioctl</code>Contains a pointer to the function that the DLIL is to call in order to send ioctl calls to the interface's driver. </p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBADJGBH" title="dlil_demux_desc"></a><h3>dlil_demux_desc</h3><p>The <code>dlil_demux_desc</code> structure is a member of the <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAJDEHE">“dlil_proto_reg_str”</a></span> structure. The <code>dlil_demux_desc</code> structure is the head of a linked list of protocol demultiplexing descriptors that identify the protocol's packets in incoming frames.</p><div class="codesample"><table><tr><td scope="row"><pre>struct dlil_demux_desc {<span></span></pre></td></tr><tr><td scope="row"><pre>    TAILQ_ENTRY(dlil_demux_desc) next;<span></span></pre></td></tr><tr><td scope="row"><pre>    int type;<span></span></pre></td></tr><tr><td scope="row"><pre>    u_char *native_type;<span></span></pre></td></tr><tr><td scope="row"><pre>    union {<span></span></pre></td></tr><tr><td scope="row"><pre>        struct {<span></span></pre></td></tr><tr><td scope="row"><pre>            u_long proto_id_length;<span></span></pre></td></tr><tr><td scope="row"><pre>            u_char *proto_d;<span></span></pre></td></tr><tr><td scope="row"><pre>            u_char *proto_id_mask;<span></span></pre></td></tr><tr><td scope="row"><pre>        } bitmask;<span></span></pre></td></tr><tr><td scope="row"><pre>        struct {<span></span></pre></td></tr><tr><td scope="row"><pre>            u_char dsap;<span></span></pre></td></tr><tr><td scope="row"><pre>            u_char ssap;<span></span></pre></td></tr><tr><td scope="row"><pre>            u_char control_code;<span></span></pre></td></tr><tr><td scope="row"><pre>            u_char pad;<span></span></pre></td></tr><tr><td scope="row"><pre>        } desc_802_2;<span></span></pre></td></tr><tr><td scope="row"><pre>        struct {<span></span></pre></td></tr><tr><td scope="row"><pre>            u_char dsap;<span></span></pre></td></tr><tr><td scope="row"><pre>            u_char ssap;<span></span></pre></td></tr><tr><td scope="row"><pre>            u_char control_code;<span></span></pre></td></tr><tr><td scope="row"><pre>            u_char org[3];<span></span></pre></td></tr><tr><td scope="row"><pre>            u_short protocol_type;<span></span></pre></td></tr><tr><td scope="row"><pre>        } desc_802_2_SNAP;<span></span></pre></td></tr><tr><td scope="row"><pre>    } variants;<span></span></pre></td></tr><tr><td scope="row"><pre>} TAILQ_HEAD {<span></span></pre></td></tr><tr><td scope="row"><pre>    ddesc_head_str,<span></span></pre></td></tr><tr><td scope="row"><pre>    dlil_demux_desc<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_109" title="Field Descriptions"></a><h4>Field Descriptions</h4><p><code>next</code>A link pointer used to chain multiple descriptors.</p><p><code>type</code>Specifies which variant of the descriptor has been defined. For Ethernet, the possible values are <code>DESC_802_2</code>, <code>DESC_802_2_SNAP</code>, and <code>DESC_BITMASK</code>.</p><p><code>native_type</code>A pointer to a byte array containing a self-identifying frame ID, such as the two-byte Ethertype field in an Ethernet II frame. This field may be used by itself, may be used in combination with other identifying information, or may not be used at all, in which case, its value is <code>NULL</code>.</p><p><code>variants</code>Three structures that comprise a union. The <code>bitmask</code> structure describes any combination of bits that identify frames that do not match Ethernet 802.2 frames and Ethernet 802.2/SNAP frames. The <code>desc_802_2</code> structure and the <code>desc_802_2_SNAP</code> structure describe Ethernet 802.2 frames and Ethernet 802.2/SNAP frames, respectively.</p><p>For each Ethernet interface, the following sequence must take place. The actual implementation may optimize the process.</p><ol class="ol"><li class="li"><p>The first <code>if_proto</code> structure is referenced. The structure is found through the <code>proto_head</code> pointer in the associated <code>ifnet</code> structure.</p></li><li class="li"><p>The frame is compared with the first demultiplexing descriptor in the protocol's list of demultiplexing descriptors (the <code>bitmask</code> structure).</p></li><li class="li"><p>If the native type is <code>NULL</code> or if the interface family's frame doesn't have a frame type field, go to step 4. Otherwise, the octet string in <code>native-type</code> is compared with the interface family's native frame-type specification field. The frame format for each interface family defines the number of bits to compare. If there is a match and the <code>proto_id</code> and <code>proto_id_mask</code> fields are defined, go to step 4. If there is a match and the <code>proto_id</code> and <code>proto_id_mask</code> fields are <code>NULL</code>, the frame is passed to the protocol's input function, thereby terminating DLIL processing of the frame.</p></li><li class="li"><p>If the <code>proto_id</code> or <code>proto_id_mask</code> fields in the <code>bitmask</code> structure are <code>NULL</code>, or if the <code>proto_id_length</code> field is 0, go to step 5. Otherwise, compare the first <code>proto_id_length</code> bytes of the frame's data field with <code>proto_id</code>, ignoring any bits defined as zero in the <code>proto_id_mask</code>. If there is a match, the frame is passed to the protocol's input function, thereby terminating DLIL processing of the frame.</p></li><li class="li"><p>This demultiplexing descriptor could not provide a match. Advance to the next demultiplexing descriptor in the list and go to step 3.</p></li><li class="li"><p>None of the demultiplexing descriptors could provide a match. If there is another <code>if_proto</code> structure in the interface's protocol list, go back to step 2 using the first demultiplexing descriptor for this protocol.</p></li><li class="li"><p>No match could be found using any demultiplexing descriptor for any of the protocols attached to the interface. Go back through the <code>if_proto</code> structures for the attached protocols and call any defined <code>dl_offer</code> function. If a <code>dl_offer</code> function returns <code>DLIL_FRAME_ACCEPTED</code>, the DLIL passes the frame to the responding protocol's <code>dl_input</code> function, thereby terminating DLIL processing of the frame.</p></li><li class="li"><p>None of the protocols attached to this interface have accepted the frame. The <code>mbuf</code> chain is freed and the frame is dropped.</p></li></ol><p>The <code>bitmask</code> structure or one of the predefined 802.2 structures can be used to identify frames.</p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBABGIBA" title="dlil_if_flt_str"></a><h3>dlil_if_flt_str</h3><p>The <code>dlil_ir_flt_str</code> structure is a parameter to the <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBADHACJ">“dlil_attach_interface_filter”</a></span> function, which inserts DLIL interface filters between the DLIL and an interface.</p><p>This structure contains pointers to all of the functions that are called at the point at which the filter is placed.</p><div class="codesample"><table><tr><td scope="row"><pre>struct dlil_if_flt_str {<span></span></pre></td></tr><tr><td scope="row"><pre>        caddr_t cookie;<span></span></pre></td></tr><tr><td scope="row"><pre>        int (*filter_if_input)(caddr_t cookie,<span></span></pre></td></tr><tr><td scope="row"><pre>            struct ifnet **ifnet_ptr,<span></span></pre></td></tr><tr><td scope="row"><pre>            struct mbuf **mbuf_ptr,<span></span></pre></td></tr><tr><td scope="row"><pre>            char **frame_ptr);<span></span></pre></td></tr><tr><td scope="row"><pre>        int (*filter_if_event)(caddr_t cookie,<span></span></pre></td></tr><tr><td scope="row"><pre>            struct ifnet **ifnet_ptr,<span></span></pre></td></tr><tr><td scope="row"><pre>            struct event_msg **event_msg_ptr);<span></span></pre></td></tr><tr><td scope="row"><pre>        int (*filter_if_output)(caddr_t cookie,<span></span></pre></td></tr><tr><td scope="row"><pre>            struct ifnet **ifnet_ptr,<span></span></pre></td></tr><tr><td scope="row"><pre>            struct mbuf **mbuf_ptr);<span></span></pre></td></tr><tr><td scope="row"><pre>        int (*filter_if_ioctl)(caddr_t cookie,<span></span></pre></td></tr><tr><td scope="row"><pre>            struct ifnet **ifnet_ptr,<span></span></pre></td></tr><tr><td scope="row"><pre>            u_long ioctl_code_ptr,<span></span></pre></td></tr><tr><td scope="row"><pre>            caddr_t ioctl_arg_ptr);<span></span></pre></td></tr><tr><td scope="row"><pre>        int (*filter_if_free)(caddr_t cookie,<span></span></pre></td></tr><tr><td scope="row"><pre>            struct ifnet **ifnet_ptr);<span></span></pre></td></tr><tr><td scope="row"><pre>        int (*filter_detatch)(caddr_t cookie);<span></span></pre></td></tr></table></div><p></p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_110" title="Field Descriptions"></a><h4>Field Descriptions</h4><p><code>filter_if_input</code>A pointer to the <code>filter_if_input</code> function for this DLIL interface filter. The parameters for this function are <code>cookie</code>, (an opaque value that is passed by the filter and is returned so that the filter can identify one attachment among many attachments), a pointer to the <code>ifnet</code> structure for this interface, a pointer to an <code>mbuf</code> structure, and pointer to the frame.</p><p><code>filter_if_event</code>A pointer to the <code>filter_if_event</code> function for this DLIL interface filter. The parameters for this function are <code>cookie</code>, (an opaque value that is passed by the filter and is returned so that the filter can identify one attachment among many attachments), a pointer to the <code>ifnet</code> structure for this interface, and a pointer to an <code>event_msg</code> structure containing the event that is being passed to the extension.</p><p><code>filter_if_output</code>A pointer to the <code>filter_if_output</code> function for this DLIL interface filter. The parameters for this function are <code>cookie </code>(an opaque value that is passed by the filter and is returned so that the filter can identify one attachment among many attachments), a pointer to the <code>ifnet</code> structure for this interface, and a pointer to the memory buffer for this packet.</p><p><code>filter_if_ioctl</code>A pointer to the <code>filter_if_ioctl</code> function for this DLIL interface filter. The parameters for this function are <code>cookie </code>(an opaque value that is passed by the filter and is returned so that the filter can identify one attachment among many attachments), a pointer to the <code>ifnet</code> structure for this interface, an unsigned long that points to the I/O control code for this call, and a pointer to parameters that the DLIL passes to the <code>filter_if_ioctl</code> function.</p><p><code>filter_if_free</code>A pointer to the <code>filter_if_free</code> function for this DLIL interface filter. The parameters for this function are <code>cookie </code>(an opaque value that is passed by the filter and is returned so that the filter can identify one attachment among many attachments) and a pointer to the <code>ifnet</code> structure for this interface.</p><p><code>filter_detach</code>A pointer to the <code>filter_detach </code>function for this DLIL interface filter. The parameter for this function is <code>cookie </code>(an opaque value that is passed by the filter and is returned so that the filter can identify one attachment among many attachments). For details, see <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBADGIJF">“dlil_detach_filter.”</a></span></p><a name="//apple_ref/doc/uid/TP40001089-CH227-BBABDHCF" title="dlil_pr_flt_str"></a><h3>dlil_pr_flt_str</h3><p>The <code>dlil_pr_flt_str</code> structure is a parameter to the function <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP40001089-CH227-BBAEDGCH">“dlil_attach_protocol_filter,”</a></span> which inserts DLIL protocol filters between a protocol and the DLIL.</p><p>This structure contains pointers to all of the functions that are called at the point at which the filter is placed.</p><div class="codesample"><table><tr><td scope="row"><pre>struct dlil_if_flt_str {<span></span></pre></td></tr><tr><td scope="row"><pre>    caddr_t cookie;<span></span></pre></td></tr><tr><td scope="row"><pre>    int (*filter_dl_input)(caddr_t cookie,<span></span></pre></td></tr><tr><td scope="row"><pre>            struct mbuf **m,<span></span></pre></td></tr><tr><td scope="row"><pre>            char **frame_header,<span></span></pre></td></tr><tr><td scope="row"><pre>            struct ifnet **ifp);<span></span></pre></td></tr><tr><td scope="row"><pre>    int (*filter_dl_output)(caddr_t cookie,<span></span></pre></td></tr><tr><td scope="row"><pre>            struct mbuf **m,<span></span></pre></td></tr><tr><td scope="row"><pre>            struct ifnet **ifp,<span></span></pre></td></tr><tr><td scope="row"><pre>            struct sockaddr **dest,<span></span></pre></td></tr><tr><td scope="row"><pre>            char *dest_linkaddr,<span></span></pre></td></tr><tr><td scope="row"><pre>            char *frame_type);<span></span></pre></td></tr><tr><td scope="row"><pre>    int (*filter_dl_event)(caddr_t cookie,<span></span></pre></td></tr><tr><td scope="row"><pre>            struct event_msg *event_msg);<span></span></pre></td></tr><tr><td scope="row"><pre>    int (*filter_dl_ioctl)(caddr_t cookie,<span></span></pre></td></tr><tr><td scope="row"><pre>            struct ifnet **ifp,<span></span></pre></td></tr><tr><td scope="row"><pre>            u_long ioctl_cmd,<span></span></pre></td></tr><tr><td scope="row"><pre>            caddr_t ioctl_arg);<span></span></pre></td></tr><tr><td scope="row"><pre>    int (*filter_detach)(caddr_t cookie);<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><p></p><a name="//apple_ref/doc/uid/TP40001089-CH227-DontLinkElementID_111" title="Field Descriptions"></a><h4>Field Descriptions</h4><p><code>filter_dl_input</code>A pointer to the <code>filter_dl_input</code> function for this DLIL protocol filter. The parameters for this function are <code>cookie</code>, (an opaque value that is passed by the filter and is returned so that the filter can identify one attachment among many attachments), a pointer to an <code>mbuf</code> structure, and a pointer to the <code>ifnet</code> structure for the interface. </p><p><code>filter_dl_output</code>A pointer to a <code>filter_dl_output</code> function for this DLIL protocol filter. The parameters for this function are <code>cookie </code>(an opaque value that is passed by the filter and is returned so that the filter can identify one attachment among many attachments), a pointer to the <code>ifnet</code> structure for the interface, a pointer to the socket address for this destination, a pointer to the link address for this destination, and a pointer to the frame type.</p><p><code>filter_dl_event</code>A pointer to the <code>filter_pr_event</code> function for this DLIL protocol filter. The parameters for this function are <code>cookie</code>, (an opaque value that is passed by the filter and is returned so that the filter can identify one attachment among many attachments), a pointer to the <code>ifnet</code> structure for the interface, and a pointer to an <code>event_msg</code> structure containing the event that is being passed to the extension.</p><p><code>filter_dl_ioctl</code>A pointer to a <code>filter_if_ioctl</code> function for this DLIL protocol filter. The parameters for this function are <code>cookie </code>(an opaque value that is passed by the filter and is returned so that the filter can identify one attachment among many attachments), a pointer to the <code>ifnet</code> structure for the interface, an <code>u_long</code> that points to the I/O control command for this call, and a pointer to parameters that the DLIL passes to the <code>filter_if_ioctl</code> function.</p><p><code>filter_detach</code>A pointer to the <code>filter_detach </code>function for this DLIL protocol filter. The parameter for this function is <code>cookie </code>(an opaque value that is passed by the filter and is returned so that the filter can identify one attachment among many attachments).</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../using/using.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../revision_history/revision_history.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2003, 2006 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2006-10-03<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Conceptual/NetworkKernelExtensions/reference/reference.html%3Fid%3DTP40001089-2.5&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Conceptual/NetworkKernelExtensions/reference/reference.html%3Fid%3DTP40001089-2.5&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Conceptual/NetworkKernelExtensions/reference/reference.html%3Fid%3DTP40001089-2.5&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>