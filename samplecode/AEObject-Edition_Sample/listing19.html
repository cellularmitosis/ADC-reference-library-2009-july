<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>AEObject-Edition Sample - /TextSections.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxCarbon-date.html">Carbon</a> &gt; <A HREF="javascript:location.replace('index.html');">AEObject-Edition Sample</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxInterapplicationCommunication-date.html" target="_blank">Carbon > Interapplication Communication</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">AEObject-Edition Sample</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/TextSections.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/AEObject-Edition Sample.r</option>
<option value="listing2.html">/AEObject.c</option>
<option value="listing3.html">/AEUtilities.c</option>
<option value="listing4.html">/AppleEventCore.c</option>
<option value="listing5.html">/BuildHeaders.c</option>
<option value="listing6.html">/Files.c</option>
<option value="listing7.html">/globals.c</option>
<option value="listing8.html">/Initialize.c</option>
<option value="listing9.html">/Macros.h</option>
<option value="listing10.html">/main.c</option>
<option value="listing11.html">/Menu.c</option>
<option value="listing12.html">/Print.c</option>
<option value="listing13.html">/prototypes.h</option>
<option value="listing14.html">/Publish.c</option>
<option value="listing15.html">/SampConstants.h</option>
<option value="listing16.html">/Sampdefines.h</option>
<option value="listing17.html">/Structs.h</option>
<option value="listing18.html">/Subscribe.c</option>
<option value="listing19.html">/TextSections.c</option>
<option value="listing20.html">/Utilities.c</option>
<option value="listing21.html">/Windows.c</option></select>
				</p>
				</form>
				<p><strong><a href="AEObject-Edition_Sample.zip">Download Sample</a></strong> (&#147;AEObject-Edition_Sample.zip&#148;, 895.6K)<BR>
<strong><a href="AEObject-Edition_Sample.dmg">Download Sample</a></strong> (&#147;AEObject-Edition_Sample.dmg&#148;, 1.22M)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*------------------------------------------------------------------------------ * *  Apple Developer Technical Support * *  Text section handling routines * *  Program:    AEObject-Edition Sample *  File:       TextSections.c -    C Source * *  by:         C.K. Haun &lt;TR&gt; * *  Copyright &copy; 1990-1992 Apple Computer, Inc. *  All rights reserved. * *------------------------------------------------------------------------------ * This file contains the functions for manipulating and bookkeeping * for published and subscribed text sections in this sample. *----------------------------------------------------------------------------*/#define __TEXTSECTIONS__#pragma segment TextHandler#include &quot;Sampdefines.h&quot;static Boolean Touching(mySectionDataHandle checkSection, TEHandle teText);extern void MyHiHook(void);Rect nulRect={0,0,0,0};/* the following few functions are for text, and will be expanded as this is fully implemented */Boolean HasTESelection(windowCHandle inWind){    TEHandle temp;    if (inWind == nil)        return(false);    temp = (*inWind)-&gt;boxHandle;    if (temp != nil)        return((*temp)-&gt;selStart != (*temp)-&gt;selEnd);    else        return(false);}Boolean PasteText(void){    windowCHandle tempWC;    tempWC = (windowCHandle)GetWRefCon(FrontWindow() );    if ((*tempWC)-&gt;boxHandle != nil &amp;&amp; gClipHasContents == kClipHasText) {        TEFromScrap();        CheckTextSections(tempWC, kAdding);        TEPaste((*tempWC)-&gt;boxHandle);        return(true);    }    return(false);}Boolean CutText(void){    windowCHandle tempWC;    tempWC = (windowCHandle)GetWRefCon(FrontWindow() );    if (HasTESelection(tempWC)) {        CheckTextSections(tempWC, kRemoving);               /* adjusts the end points on text sections */        TECut((*tempWC)-&gt;boxHandle);        ZeroScrap();        TEToScrap();        return(true);    }    return(false);}Boolean CopyText(void){    windowCHandle tempWC;    tempWC = (windowCHandle)GetWRefCon(FrontWindow() );    if (HasTESelection(tempWC)) {        TECopy((*tempWC)-&gt;boxHandle);        ZeroScrap();        TEToScrap();        return(true);    }    return(false);}Boolean ClearText(void){    windowCHandle tempWC;    tempWC = (windowCHandle)GetWRefCon(FrontWindow() );    if (HasTESelection(tempWC)) {        CheckTextSections(tempWC, kRemoving);        TEDelete((*tempWC)-&gt;boxHandle);        return(true);    }    return(false);}/* This checks all the publishers and subscribers in the current TE record, and sees *//* if their data needs to be modified based on the TE action pending */void CheckTextSections(windowCHandle inWindow, short Action){    TEHandle theTEHandle = (*inWindow)-&gt;boxHandle;    mySectionDataHandle startSection = (*inWindow)-&gt;textSections;    Boolean testFlag = true;                                /* a gen purp flag please */  Boolean whapBorder = false;    mySectionDataHandle currentSection = startSection;    short counter = 0;    /*  see if the insertion point or selection range is after all our sections.  */    /* if it is (a forlorn hope) we can exit without adjusting anything. */    if (startSection == nil)        return;                                             /* no sections, go away */    do {        if ((*currentSection)-&gt;endChar &gt; (*theTEHandle)-&gt;selStart) {            testFlag = false;            counter++;                                      /* a minimal aid to exiting this stuff later */        if((*currentSection)-&gt;bordered)whapBorder=true;    }        currentSection = (*currentSection)-&gt;nextSection;    } while (currentSection);    if (testFlag)        return;                                             /* no section is affected by this action, go away */        /* OK, someone (or two, or twenty) will be affected by this action */    /* so we have to see who, and how much, and if it's like adding in the middle, */    /* or like shifting start and end points down, or like whatever, y'know? */        currentSection = (*inWindow)-&gt;textSections;    switch (Action) {        unsigned long actionLen;        case kKeyStroke:            /* so we bump the start and end positions of all the sections after this point by 1 */            while (counter) {                               /* minimal aid in exiting this thing */                        if ((*theTEHandle)-&gt;selStart &lt;= (*currentSection)-&gt;startChar) {                    (*currentSection)-&gt;startChar++;                    (*currentSection)-&gt;endChar++;                    counter--;                } else {                    if ((*theTEHandle)-&gt;selStart &gt; (*currentSection)-&gt;startChar &amp;&amp;                        (*theTEHandle)-&gt;selStart &lt; (*currentSection)-&gt;endChar) {                        /* this should mean that the input char is between the start and the end */                        /* so the publisher expands by 1 */                        (*currentSection)-&gt;endChar++;                        counter--;                    }                }                currentSection = (*currentSection)-&gt;nextSection;                if (currentSection == nil)                    break;                                  /* hey, y'know? */            }            break;        case kAdding:            /* increase start and finished positions by the size of the clip being added */            actionLen = TEGetScrapLength();            /* so we bump the start and end positions of all the sections after this point by 1 */            while (counter) {                               /* minimal aid in exiting this thing */                if ((*currentSection)-&gt;startChar &gt; (*theTEHandle)-&gt;selStart) {                    (*currentSection)-&gt;startChar += actionLen;                    (*currentSection)-&gt;endChar += actionLen;                    counter--;                } else {Boolean temp=false;                    /* expand the published section */                  temp=(*currentSection)-&gt;bordered;            (*currentSection)-&gt;endChar += actionLen;                                    }                currentSection = (*currentSection)-&gt;nextSection;                if (currentSection == nil)                    break;                                  /* hey, y'know? */            }            break;        case kRemoving:            /* decrease start and finished positions by the size of the current selection */            /* You have another worry in this area, of course.  If the user has highlighted */            /* the WHOLE publisher or subscriber, that means that you will be deleting */            /* it completely */            actionLen = (*currentSection)-&gt;endChar - (*currentSection)-&gt;startChar;            /* so we bump the start and end positions of all the sections after this point by 1 */            while (counter) {                               /* minimal aid in exiting this thing */                if ((*currentSection)-&gt;startChar &gt; (*theTEHandle)-&gt;selStart) {                    (*currentSection)-&gt;startChar -= actionLen;                    (*currentSection)-&gt;endChar -= actionLen;                    counter--;                }                currentSection = (*currentSection)-&gt;nextSection;                if (currentSection == nil)                    break;                                          }            break;    }  /* if anything changed and borders are on in any section, we need to */  /* erase and redraw the borders */  /* This will cause a lot of screen flicker, you can do it neater in your app */  if(whapBorder)InvalRect(&amp;(*theTEHandle)-&gt;viewRect);}/* KillTextBorders does about what you'd expect, it turns off all the  *//* text borders */void KillTextBorders(void){windowCHandle tempWC = (windowCHandle)GetWRefCon(FrontWindow() );mySectionDataHandle startSection = (*tempWC)-&gt;textSections;while(startSection){(*startSection)-&gt;bordered = false;startSection = (*startSection)-&gt;nextSection;}}void ShowAllTextBorders(void){windowCHandle tempWC = (windowCHandle)GetWRefCon(FrontWindow() );mySectionDataHandle startSection = (*tempWC)-&gt;textSections;while(startSection){(*startSection)-&gt;bordered = true;startSection = (*startSection)-&gt;nextSection;}}/* SkipOverSubscriber is used to move the insertion point around any subscriptions *//* in response to a cursor or delete key action *//* This is, of course, because you cannot edit the contents of a subscription */Boolean SkipOverSubscriber(windowCHandle inWindow, unsigned short theKey){    long oldStart, oldEnd;    Boolean flagBack = false;    short newInsertionPoint;                                /* where the insertion point will be moving to as */    /*  a result of this key */    /* first, as usually, see if this action impinges on the target */    /* of course, this only counts for subscriptions */    TEHandle theTEHandle = (*inWindow)-&gt;boxHandle;    mySectionDataHandle startSection = (*inWindow)-&gt;textSections;    if (!startSection)        return(flagBack);                                   /* scat if no sections */    do {        /* first see if it's a publisher, if it is, skip it.  */        if (!(*startSection)-&gt;publishing) {            switch (theKey) {                               /* actions based on what direction this key is moving us */                case kLeftArrow:                    newInsertionPoint = ((*theTEHandle)-&gt;selStart) - 1;                    if (newInsertionPoint &lt;= (*startSection)-&gt;endChar &amp;&amp; newInsertionPoint &gt;= (*startSection)-&gt;startChar) {                        flagBack = true;                        TESetSelect(((*startSection)-&gt;startChar), ((*startSection)-&gt;startChar), theTEHandle);                    }                    break;                                    case kRightArrow:                    newInsertionPoint = ((*theTEHandle)-&gt;selEnd) + 1;                    if (newInsertionPoint &gt;= (*startSection)-&gt;startChar &amp;&amp; newInsertionPoint &lt;= (*startSection)-&gt;endChar) {                        flagBack = true;                        TESetSelect(((*startSection)-&gt;endChar), ((*startSection)-&gt;endChar), theTEHandle);                    }                    break;                case kUpArrow:                case kDownArrow:                    /* for up and down arrows, we actually have to do the TEKey thing here, then evaluate the */                    /* result and see if it landed in a subscription.  This is of course because we're using */                    /* TextEdit, if you're doing your own text processing you will know where any keystroke lands */                    /* Of course, you gotta save the current position of the insertion point first */                    oldStart = (*theTEHandle)-&gt;selStart;                    oldEnd = (*theTEHandle)-&gt;selEnd;                    TEKey(theKey, theTEHandle);                    /* see where it ended up */                    newInsertionPoint = (*theTEHandle)-&gt;selEnd;                    if (newInsertionPoint &gt;= (*startSection)-&gt;startChar &amp;&amp; newInsertionPoint &lt;= (*startSection)-&gt;endChar) {                        flagBack = true;                        /* now move before or after the section depending on the arrow */                        if (theKey == kUpArrow)                            TESetSelect(((*startSection)-&gt;startChar), ((*startSection)-&gt;startChar), theTEHandle);                        else                            TESetSelect(((*startSection)-&gt;endChar), ((*startSection)-&gt;endChar), theTEHandle);                    } else {                        TESetSelect(oldStart, oldEnd, theTEHandle);                    }                    break;                                }        }        startSection = (*startSection)-&gt;nextSection;        /* go to next in list */    } while (startSection);        return(flagBack);}/* RePackText makes sure we have the proper text in our lil publisher before writing the *//* thing out.  *//* Actually, since this function exists, we don't really need to keep a copy of the text attached *//* to the publisher.  */void RePackText(mySectionDataHandle currentSection, TEHandle theTEHandle){    short theLength;    CharsHandle theRawText;    Ptr src;    theLength = (*currentSection)-&gt;endChar - (*currentSection)-&gt;startChar;    SetHandleSize((*currentSection)-&gt;additionalData, theLength);    HLock((*currentSection)-&gt;additionalData);    theRawText = TEGetText(theTEHandle);    HLock((Handle)theRawText);    src = (Ptr)*theRawText;    src = src + (*currentSection)-&gt;startChar;    BlockMove((Ptr)((Ptr)*theRawText)+(*currentSection)-&gt;startChar, (Ptr)*((*currentSection)-&gt;additionalData), theLength);    HUnlock((Handle)theRawText);    HUnlock((*currentSection)-&gt;additionalData);}/* InTextBox tells us if the rectangle passed intersects the text rectangle *//* in the current window.  We use this for; *//* 1) Seeing if the mouse click was in the TERect, so we can call TEClick *//* 2) See if one of our drawing commands will overdraw the text, which is BaD */Boolean InTextBox(windowCHandle inName, Rect *where){    Rect temp;    if ((*inName)-&gt;boxHandle == nil) {        return(false);    } else {        return(SectRect(where, &amp;(*inName)-&gt;textBox, &amp;temp));    }}/* CheckSubscriberHit sees if the user person clicked inside a subscription.  If they did, then *//* we'll either highlight the whole subscriber and &lt;sometime&gt; draw a border around it, or *//* extend the selection range to include the whole subscription if they dragged into just part of it *//* for bording, things get a little more complicated.  If this is a publisher, and it's already *//* showing a border, we want to do a normal TEClick since the user can edit inside a publisher */void CheckSectionHit(){    windowCHandle shortName = (windowCHandle)GetWRefCon(FrontWindow());    TEHandle theTEHandle = (*shortName)-&gt;boxHandle;    long mySelStart = (*theTEHandle)-&gt;selStart;             /* added these variables just to make the code a */    long mySelEnd = (*theTEHandle)-&gt;selEnd;                 /* little easier to read */    long newStart = mySelStart;                             /* if any adjustments need to be made */    long newEnd = mySelEnd;    Boolean startedBordered;    mySectionDataHandle startSection = (*shortName)-&gt;textSections;    mySectionDataHandle currentSection = startSection;    /* and of course, the affected window is the front window, since they clicked there, y'know */    /* what we do here is see if the current mouse click lands in a publisher or */    /* subscriber.  If it's a publisher, check for a double click and highlite. */    /* if the selection range covers ANY part of a subscriber, extend the selection to */    /* encompass the whole subscriber.  Then border the subscriber also. */    /* This means that we cannot exit after finding one pub or sub, we must */    /* check all since the user could have selected all the text in the record */    while (currentSection) {        startedBordered = (*currentSection)-&gt;bordered;        if (Touching(currentSection, theTEHandle)) {            /* see if this is a subscriber.  If so, extend start and end positions to include it all */            if (!(*currentSection)-&gt;publishing) {                /* it is a subscriber */                if ((*currentSection)-&gt;startChar &lt; mySelStart)                    newStart = (*currentSection)-&gt;startChar;                if ((*currentSection)-&gt;endChar &gt; mySelEnd)                    newEnd = (*currentSection)-&gt;endChar;        TESetSelect(newStart, newEnd, theTEHandle);                            } else {      /* for a publisher, highlith the whole thing if it's the first click.  If it's the */      /* second (or subsequent, o' course) they want to edit, so let them */   if (startedBordered)        TESetSelect(newStart, newEnd, theTEHandle);      else    TESetSelect((*currentSection)-&gt;startChar, (*currentSection)-&gt;endChar, theTEHandle);      }        } else {    /* if this section was not hit, deborder it */    if(!gShowingAll &amp;&amp; (*currentSection)-&gt;bordered){(*currentSection)-&gt;bordered=false;      InvalRect(&amp;(*theTEHandle)-&gt;viewRect);    }}        currentSection = (*currentSection)-&gt;nextSection;    }       }/*  Touching was created just so I wouldn't have to have a huge if statement in *//* CheckSectionHit *//* All it does is see if the current selection range of the TEHandle touches or *//* fully encloses any text sections */static Boolean Touching(mySectionDataHandle checkSection, TEHandle teText){    Boolean ouch = false;                                   /* will turn true if a touch actually happened */        long tStart = (*teText)-&gt;selStart;    long tEnd = (*teText)-&gt;selEnd;    short ourStart = (*checkSection)-&gt;startChar;    short ourEnd = (*checkSection)-&gt;endChar;    /* first see if the start hits inside the section */    if (tStart &gt; ourStart &amp;&amp; tStart &lt; ourEnd)        ouch = true;    else if (tStart &lt; ourStart &amp;&amp; tEnd &gt; ourStart)        ouch = true;                                        /* now see if we got completely enclosed */    else if (tEnd &gt; ourStart &amp;&amp; tEnd &lt; ourEnd)        ouch = true;    /* and finally see if we got touched by the end of the thing */    if (ouch){        BorderTextSection(checkSection);    /* put this section in our gloabl section handle holder so we can do options on it */    gShowingSecHandle=(*checkSection)-&gt;theSection;    if((*checkSection)-&gt;publishing) {    gShowPub = true;    gShowPubRect=nulRect;    } else {     gShowSub = true;    gShowSubRect=nulRect;    }}    return(ouch);}/* ExcludeSubscriber removes subscriptions from the range of selected text, so when a keystroke *//* replaces a selection, the subscriber does not also get replaced. */void ExcludeSubscriber(windowCHandle tempCH){#pragma unused (tempCH)    }/* this borders the selected section.  It's a pain.  *//* BUT, it's a pain because I'm using TextEdit.  If you're writing a word processor *//* or another application which does it's own text processing, this will be a lot easier *//* **** NOTE:  this doesn't look very good when a subscriber is embedded in a publisher, since *//* the lines of course overlap.  I don't know how to deal with this yet. */void BorderTextSection(mySectionDataHandle theText){    TEHandle theTEHandle;    WindowPtr theWindow;    windowCHandle shortName;    PolyHandle borderPoly;    long origIStart;    long origIEnd;    long newStart;    long newEnd;    Point startPoint;    Point endPoint;    RgnHandle oldClip = NewRgn();    WindowPtr oldPort;    GetPort(&amp;oldPort);    GetClip(oldClip);        theWindow = FindSection((*theText)-&gt;theSection);    SetPort(theWindow);    shortName = (windowCHandle)GetWRefCon(theWindow);    HLock((Handle)shortName);    theTEHandle = (*shortName)-&gt;boxHandle;        origIStart = (*theTEHandle)-&gt;selStart;    origIEnd = (*theTEHandle)-&gt;selEnd;    TESetSelect((*theText)-&gt;startChar, (*theText)-&gt;endChar, theTEHandle);    newStart = (*theTEHandle)-&gt;selStart;    newEnd = (*theTEHandle)-&gt;selEnd;    ClipRect(&amp;(*theTEHandle)-&gt;viewRect);    /* so our poly doesn't exceed the bounds of our rect */    /* now what we do is create a Polygon that's the shape of the text section */    startPoint = TEGetPoint((short)newStart, theTEHandle);    endPoint = TEGetPoint((short)newEnd, theTEHandle);    /* **** NOTE:  This is a really simplistic check, since this is a simple sample.  */    /* In a more complex text document you'd be worrying about text scrolled out of the view rect, */    /* weird regions, and other things I'm not going to deal with here.  */    /* see if the verts are the same.  If they are, then all we need is a simple rect */        if (startPoint.v == endPoint.v) {        borderPoly = OpenPoly();        startPoint.v -= (*theTEHandle)-&gt;lineHeight;         /* top o' the line to you! */                MoveTo(startPoint.h, startPoint.v);        LineTo(endPoint.h, startPoint.v);        LineTo(endPoint.h, endPoint.v);        LineTo(startPoint.h, endPoint.v);        LineTo(startPoint.h, startPoint.v);        ClosePoly();        PenSize(3, 3);        if ((*theText)-&gt;publishing)            PenPat(&amp;qd.gray);        else            PenPat(&amp;qd.dkGray);        FramePoly(borderPoly);        PenPat(&amp;qd.black);        PenSize(1, 1);            } else {        short endTop = endPoint.v -(*theTEHandle)-&gt;lineHeight;        /* need to build a slightly more complex poly */        borderPoly = OpenPoly();        startPoint.v -= (*theTEHandle)-&gt;lineHeight;         /* top o' the line to you! */                MoveTo(startPoint.h, startPoint.v);        LineTo((*theTEHandle)-&gt;destRect.right, startPoint.v);        LineTo((*theTEHandle)-&gt;destRect.right, endTop);        LineTo(endPoint.h, endTop);                         /* may not be needed, but doesn't hurt anything */        LineTo(endPoint.h, endPoint.v);        LineTo((*theTEHandle)-&gt;destRect.left, endPoint.v);        LineTo((*theTEHandle)-&gt;destRect.left, (startPoint.v + ((*theTEHandle)-&gt;lineHeight)));        LineTo(startPoint.h, (startPoint.v + ((*theTEHandle)-&gt;lineHeight)));        LineTo(startPoint.h, startPoint.v);        ClosePoly();        PenSize(3, 3);        if ((*theText)-&gt;publishing)            PenPat(&amp;qd.gray);        else            PenPat(&amp;qd.dkGray);        FramePoly(borderPoly);        PenPat(&amp;qd.black);        PenSize(1, 1);            }  if((*theText)-&gt;bordered)  /* if it started bordered, and it's a publisher, then when set the selection range to */  /* what it was when we entered */    TESetSelect(origIStart,origIEnd, theTEHandle);     else     (*theText)-&gt;bordered = true;   /* log it bordered */    KillPoly(borderPoly);    SetClip(oldClip);    DisposeRgn(oldClip);    SetPort(oldPort);    HUnlock((Handle)shortName);}#undef __TEXTSECTIONS__</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/AEObject-Edition_Sample/listing19.html%3Fid%3DDTS10000204-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/AEObject-Edition_Sample/listing19.html%3Fid%3DDTS10000204-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/AEObject-Edition_Sample/listing19.html%3Fid%3DDTS10000204-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>