<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Fragment Tool - /DragStuff.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/Carbon/index.html">Carbon</a> &gt; <a href="../../samplecode/Carbon/idxRuntimeArchitecture-date.html">Runtime Architecture</a> &gt; <A HREF="javascript:location.replace('index.html');">Fragment Tool</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Fragment Tool</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/DragStuff.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/AppleEventStuff.c</option>
<option value="listing2.html">/AppleEventStuff.h</option>
<option value="listing3.html">/DialogStuff.c</option>
<option value="listing4.html">/DialogStuff.h</option>
<option value="listing5.html">/DragStuff.c</option>
<option value="listing6.html">/Fragments.c</option>
<option value="listing7.html">/FragmentStuff.h</option>
<option value="listing8.html">/FragmentTool.c</option>
<option value="listing9.html">/FragmentTool.h</option>
<option value="listing10.html">/Initialize.c</option>
<option value="listing11.html">/Lists.c</option>
<option value="listing12.html">/MenusStuff.c</option>
<option value="listing13.html">/MenuStuff.h</option>
<option value="listing14.html">/Prototypes.h</option>
<option value="listing15.html">/Streams.c</option>
<option value="listing16.html">/Streams.h</option>
<option value="listing17.html">/Utilities.c</option>
<option value="listing18.html">/Utilities.h</option>
<option value="listing19.html">/Windows.c</option></select>
				</p>
				</form>
				<p><strong><a href="Fragment_Tool.zip">Download Sample</a></strong> (&#147;Fragment_Tool.zip&#148;, 86.8K)<BR>
<strong><a href="Fragment_Tool.dmg">Download Sample</a></strong> (&#147;Fragment_Tool.dmg&#148;, 151.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    DragStuff.c  Contains:  Drag Manager handlers and associated routines  Written by: Chris White    Copyright:  Copyright &copy; 1995-1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        8/5/1999  Karl Groethe  Updated for Metrowerks Codewarror Pro 2.1        */// System includes#ifndef __DRAG__  #include &lt;Drag.h&gt;#endif#ifndef __ERRORS__  #include &lt;Errors.h&gt;#endif#ifndef __GESTALT__  #include &lt;Gestalt.h&gt;#endif#ifndef __CODEFRAGMENTS__  #include &lt;CodeFragments.h&gt;#endif#ifndef __SCRIPT__  #include &lt;Script.h&gt;#endif#ifndef __RESOURCES__  #include &lt;Resources.h&gt;#endif#ifndef __STDDEF__  #include &lt;stddef.h&gt;#endif// Application includes#ifndef __FRAGMENTTOOL__  #include &quot;FragmentTool.h&quot;#endif#ifndef __PROTOTYPES__  #include &quot;Prototypes.h&quot;#endif#include &quot;Utilities.h&quot;static Boolean gHasAcceptableDrag = false;static Boolean gHasHilitedList = false;static Boolean DragItemsAreAcceptable ( DragReference theDrag );static Boolean DragIsNotInSourceWindow ( DragReference theDrag );static pascal OSErr DragTracker ( DragTrackingMessage theMessage, WindowRef theWindow,                  void *handlerRefCon, DragReference theDrag );static pascal OSErr DragTracker ( DragTrackingMessage theMessage, WindowRef theWindow,                  void *handlerRefCon, DragReference theDrag );static pascal OSErr DragReceiver ( WindowRef theWindow, void *handlerRefCon,                   DragReference theDrag );static pascal OSErr SendDataProc ( FlavorType theType,  void *dragSendRefCon,                   ItemReference theItemRef, DragReference theDragRef );//// InitDragHandlers creates the UPPs for the Drag Manager // callback routines _if_ the Drag Manager is available.//OSErr InitDragHandlers ( void ){  OSErr  theErr = noErr;    if ( gHasDragManager )  {    gDragTrackingHandlerUPP = NewDragTrackingHandlerProc ( DragTracker );    gDragReceiveHandlerUPP = NewDragReceiveHandlerProc ( DragReceiver );    gDragSendDataProcUPP = NewDragSendDataProc ( SendDataProc );  }    return theErr;}//// InstallDragHandlers attaches the tracking and receive handlers to// one of the application's windows.//OSErr InstallDragHandlers ( WindowRef theWindow ){    OSErr   theErr = noErr;    if ( gHasDragManager )  {        theErr = InstallTrackingHandler ( gDragTrackingHandlerUPP, theWindow, nil );      if ( theErr == noErr )    {      theErr = InstallReceiveHandler ( gDragReceiveHandlerUPP, theWindow, nil );      if ( theErr )        (void) RemoveTrackingHandler ( gDragTrackingHandlerUPP, theWindow );    }      }    return theErr;}//// RemoveDragHandlers removes the tracking and receive handlers from// one of the application's windows (usually just prior to disposal).//void RemoveDragHandlers ( WindowRef theWindow ){  if ( gHasDragManager )  {        RemoveReceiveHandler ( gDragReceiveHandlerUPP, theWindow );    RemoveTrackingHandler ( gDragTrackingHandlerUPP, theWindow );      }    return;}//// DragItemsAreAcceptable returns true if the contents (data) of// the drag are acceptable. This is called by the tracking and // receive handlers.//static Boolean DragItemsAreAcceptable ( DragReference theDrag ){  OSErr      theErr;  unsigned short  totalItems;  ItemReference  itemRef;  Boolean      bAcceptIt;  OSType      currOSType;  Size      flavorDataSize;      bAcceptIt = false;      // this app can only accept the drag of a single item  theErr = CountDragItems ( theDrag, &amp;totalItems );    if ( theErr == noErr &amp;&amp; totalItems == 1 )  {    // get the reference number of the dragged item    theErr = GetDragItemReferenceNumber ( theDrag, 1, &amp;itemRef );    if ( theErr == noErr )    {      // check if the item is one of ours      flavorDataSize = sizeof ( OSType );      theErr = GetFlavorData ( theDrag, itemRef, kCreatorCode, &amp;currOSType,                    &amp;flavorDataSize, 0 );            //#if DEBUGGING      //if ( theErr ) DebugStr ( &quot;\p GetFlavorData returned an error&quot; );      //#endif            if ( theErr == noErr )         bAcceptIt = true;    }  }  return bAcceptIt;}//// DragIsNotInSourceWindow returns true if the drag in progress// is not in the same window it originated in. This is called by// the tracking and receive handlers.//static Boolean DragIsNotInSourceWindow ( DragReference theDrag ){  DragAttributes currDragFlags;    GetDragAttributes ( theDrag, &amp;currDragFlags );  return !(currDragFlags &amp; kDragInsideSenderWindow);}//// DragTracker is called by the drag manager whenever a drag is// over one of the application's windows. Upon entry, the Drag// Manager has already set the current port current to 'theWindow'.pascal OSErr DragTracker ( DragTrackingMessage theMessage, WindowRef theWindow,              void* handlerRefCon, DragReference theDrag ){  #pragma unused(handlerRefCon)  RgnHandle  tempRgn;  Boolean    mouseInList;  OSErr    err;    err = noErr;  switch ( theMessage )  {    case kDragTrackingEnterHandler:            // Any initialization for this window handler.      gHasAcceptableDrag = DragItemsAreAcceptable ( theDrag );      gHasHilitedList = false;            // Let the drag manager know if we can't accept this drag      if ( !gHasAcceptableDrag )        err = dragNotAcceptedErr;      break;          case kDragTrackingEnterWindow:     case kDragTrackingInWindow:    case kDragTrackingLeaveWindow:            // Highlighting of the window during a drag is done      // here.  Do it only if we can accept these items      // and we're not in the source window...            if ( gHasAcceptableDrag )      {        // Unless the mouse is leaving the visible area of the        // window, check if it's in the window's content region                mouseInList = false;        if ( theMessage != kDragTrackingLeaveWindow )        {          if ( DragIsNotInSourceWindow ( theDrag ) )          {            Point localPt;                      (void) GetDragMouse ( theDrag, &amp;localPt, 0L );            GlobalToLocal ( &amp;localPt );            mouseInList = PtInList ( localPt, GetWListRef ( theWindow ) );          }        }                // If the mouse is in the list and it isn't hilited...        if ( mouseInList &amp;&amp; !gHasHilitedList )        {          Rect  nuSpaceRect;          GetListRect ( &amp;nuSpaceRect, GetWListRef ( theWindow ) );          tempRgn = NewRgn ( );          RectRgn ( tempRgn, &amp;nuSpaceRect );          // ...draw the hilight...          if ( ShowDragHilite ( theDrag, tempRgn, true ) == noErr )            // ... and remember it's now hilited            gHasHilitedList = mouseInList;                    DisposeRgn ( tempRgn );        }                // else if the mouse is not in the list and the window is hilited...        else if ( !mouseInList &amp;&amp; gHasHilitedList )          // ...erase the hilight...          if ( HideDragHilite ( theDrag ) == noErr )            // ...remember that nothing is hilited            gHasHilitedList = false;      }      break;    // do nothing for the leaveHandler message    case kDragTrackingLeaveHandler:      break;        // let the drag manager know if we didn't recognize the message    default:      err = paramErr;  }    return err;}//// DragReceiver is called by the drag manager whenever an// item is dropped on one of the application's windows.//pascal OSErr DragReceiver ( WindowRef theWindow, void *handlerRefCon, DragReference theDrag ){#pragma unused (theWindow, handlerRefCon)  Boolean      bMove;  ItemReference  itemRef;  Size      dataSize;  OSErr      err = noErr;  unsigned short  numItems, counter;  tDragData    theData;  int16      mouseDownModifiers, mouseUpModifiers;        if (!DragItemsAreAcceptable(theDrag) || (gHasHilitedList == false))    return dragNotAcceptedErr;                err = GetDragModifiers ( theDrag, nil, &amp;mouseDownModifiers, &amp;mouseUpModifiers );  if ( err )  goto CleanupAndBail;  bMove = !((mouseDownModifiers &amp; optionKey) | (mouseUpModifiers &amp; optionKey));  CountDragItems(theDrag, &amp;numItems);  for (counter = 1; counter &lt;= numItems; counter++)  {    err = GetDragItemReferenceNumber(theDrag, counter, &amp;itemRef);    if (err != noErr)  goto CleanupAndBail;        dataSize = sizeof ( tDragData );    err = GetFlavorDataSize ( theDrag, itemRef, kCreatorCode, &amp;dataSize );    if ( dataSize == sizeof ( tDragData ) )      err = GetFlavorData ( theDrag, itemRef, kCreatorCode, &amp;theData, &amp;dataSize, 0 );            // We're going to first remove the drag hilite from here, because    // not doing so would result in a cleared out list rect, and when    // we go through the trackingLeaveWindow message up above, the    // HideDragHilite() call would draw the border again (since it's drawn    // in XOr mode).        if ( gHasHilitedList )    {      if ( HideDragHilite ( theDrag ) == noErr)        // remember that nothing is hilited        gHasHilitedList = false;    }            if ( bMove )      err = MoveWindowFragment ( theData.theWindow, theData.theIndex, theWindow );    else      err = CopyWindowFragment ( theData.theWindow, theData.theIndex, theWindow );  }  CleanupAndBail:  return err;}//// This is the Drag Manager's SendDataProc. It's called after a successful drag, when// the target application wants some data that was promised by the source application.//pascal OSErr SendDataProc ( FlavorType theType,  void* dragSendRefCon,              ItemReference theItemRef, DragReference theDragRef ){  // Gotcha: If we had just dragged out to the Finder, and we had a windowKind of  // 20, the system would have crashed by now. Why? The Finder uses a windowKind  // of 20, and thinks this is a drag from one of its windows. It then starts  // interpreting the window's refCon and inevitably doesn't like what it finds.  // A windowKind of 20 is now reserved for use by the system.      OSErr    result = noErr;  FSSpec    locationSpec;  tHeaderHan  theHeader = nil;  hdrHand    theResource = nil;      // We use the file type for the HFSPromise flavor type  // and we don't handle any other pomised flavour types.  if ( theType != kCFragLibraryFileType )    cantGetFlavorErr;      result = CreateTemporaryFile ( &amp;locationSpec );  if ( result == noErr )  {    OSErr      theErr;    int16      theIndex = 0;    int16      theRef, saveFile;    WindowRef    theWindow;    ListRef      theList;    tWindowInfoPtr  theInfo;        theWindow = (WindowRef) dragSendRefCon;    theInfo = (tWindowInfoPtr) GetWRefCon ( theWindow );    theList = GetWListRef ( theWindow );        theHeader = (tHeaderHan) NewHandleClear ( sizeof ( tHeader ) );    theErr = MemError ( );    if ( theErr ) goto CleanupAndBail;        (*theHeader)-&gt;version = 1;    // Current version number        // First, we'll add the content to the file    while ( GetSelection ( theList, &amp;theIndex ) )    {      int16  itemIndex;            itemIndex = GetIndexFromNthWindowItem ( theWindow, theIndex );      theErr = CopyFragment ( (tHeaderHan) theInfo-&gt;dataHandle, &amp;theInfo-&gt;fileSpec,                    itemIndex, theHeader, &amp;locationSpec );      if ( theErr )  goto CleanupAndBail;      theIndex++;    }        theResource = (hdrHand) NewHandleClear ( offsetof ( cfrgHeader, arrayStart ) );    (*theResource)-&gt;version = 1;    // Current version number        theErr = BuildResource ( (tHeaderHan) theHeader, (Handle) theResource );    if ( theErr )  goto CleanupAndBail;        saveFile = CurResFile ( );    theRef = FSpOpenResFile ( &amp;locationSpec, fsRdWrPerm );    // If the file is already open, it may not be the current resource file    UseResFile ( theRef );    AddResource ( (Handle) theResource, kCFragResourceType, kCFragResourceID, &quot;\p&quot; );    UpdateResFile ( theRef );    ReleaseResource ( (Handle) theResource );    CloseResFile ( theRef );    UseResFile ( saveFile );            // Now, set the flavor data of our kCFragLibraryFileType flavor     // with an FSSpec to the new file.    result = SetDragItemFlavorData ( theDragRef, theItemRef, theType,                      &amp;locationSpec, sizeof ( FSSpec ), 0L );      }      // Any errors? Return a cantGetFlavorErr  if ( result )    result = cantGetFlavorErr;      return result;  CleanupAndBail:    // We'll leave the temp file for the system to handle. It  // could still be useful, if only for debugging purposes.   if ( theHeader )     DisposeHandle ( (Handle) theHeader );         if ( theResource )   {    if ( IsAResource ( (Handle) theResource ) )      ReleaseResource ( (Handle) theResource );    else      DisposeHandle ( (Handle) theResource );  }    return cantGetFlavorErr;}//// This routine just promises the Drag Manager that we'll create a file// if the user drags out to the Finder//OSErr AddHFSPromise ( DragReference theDrag, ItemReference theItem ){  OSErr        theErr;  PromiseHFSFlavor  thePromise;      // Here's what we're going to promise to create in our send proc  thePromise.fileType = kCFragLibraryFileType;  thePromise.fileCreator = kFourQuestionMarks;  thePromise.fdFlags = 0;  thePromise.promisedFlavor = kCFragLibraryFileType;      // The promised flavor can be anything, just as long as we add a drag item  // that has the same type, and set it in our send proc. Failure to do this  // will cause the zoomback.    theErr = AddDragItemFlavor ( theDrag, theItem, flavorTypePromiseHFS, &amp;thePromise,                    sizeof ( PromiseHFSFlavor ), 0L );  if ( theErr == noErr )    // Here's the promised flavor we're going to deliver    theErr = AddDragItemFlavor ( theDrag, theItem, kCFragLibraryFileType, nil, 0L, 0L );    return theErr;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Fragment_Tool/listing5.html%3Fid%3DDTS10000572-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Fragment_Tool/listing5.html%3Fid%3DDTS10000572-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Fragment_Tool/listing5.html%3Fid%3DDTS10000572-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>