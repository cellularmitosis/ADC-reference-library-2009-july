<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>SimpleViewer - /SimpleViewer.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">SimpleViewer</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">SimpleViewer</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/SimpleViewer.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/SimpleViewer.c</option></select>
				</p>
				</form>
				<p><strong><a href="SimpleViewer.zip">Download Sample</a></strong> (&#147;SimpleViewer.zip&#148;, 65.7K)<BR>
<strong><a href="SimpleViewer.dmg">Download Sample</a></strong> (&#147;SimpleViewer.dmg&#148;, 136.5K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">//--------------------------------------------------------------------------------------------// simple viewer application // DEVELOPER SUPPORT May 95//// This is a simple viewer application, that illustrates a minimal, but// functionally complete viewer application.//// Nick Thompson, Developer Support, Apple Computer (DEVSUPPORT),// &copy;1995, Apple Computer Inc., All Rights Reserved#include &lt;AppleEvents.h&gt;#include &lt;menus.h&gt;#include &lt;PictUtils.h&gt;#include &lt;QDOffScreen.h&gt;#include &lt;Errors.h&gt;#include &quot;QD3D.h&quot;#include &quot;QD3DViewer.h&quot;#include &quot;QD3DGestalt.h&quot;#include &quot;QD3DViewerGestalt.h&quot;//--------------------------------------------------------------------------------------------//const int  kWindowWidth = 220 ;const int  kWindowHeight = 150 ;//--------------------------------------------------------------------------------------------//#define HiWrd(aLong)  (((aLong) &gt;&gt; 16) &amp; 0xFFFF)#define LoWrd(aLong)  ((aLong) &amp; 0xFFFF)  //--------------------------------------------------------------------------------------------// menu id'senum {  mApple = 128,  mFile,  mEdit} ;//--------------------------------------------------------------------------------------------// command id's, Apple menuenum {  iAbout = 1} ;//--------------------------------------------------------------------------------------------// command id's, File menuenum {  iNew = 1,  iOpen,  iUnused1,  iClose,  iSave,  iSaveAs,  iRevert,  iUnused2,  iQuit} ;//--------------------------------------------------------------------------------------------// command id's, Edit menuenum {  iUndo = 1,  iUnused3,  iCut,  iCopy,  iPaste,  iClear} ;//--------------------------------------------------------------------------------------------// static control variablesstatic Boolean gQuitFlag = false ;        // we ain't quittin yetstatic Point gStaggerPos = {50,50} ;      // start opening staggered windows at this pointstatic AEAddressDesc  gSelfAddress;      // A self-addressed address descriptor recordstatic ProcessSerialNumber  gSelfPSN;      // This application's psn//--------------------------------------------------------------------------------------------// function prototypesBoolean SupportsQuickDraw3D(void) ;Boolean   SupportsQuickDraw3DViewer(void) ;void     InitToolbox( void ) ;void    FailIfErr(OSErr something ) ;void     MainEventLoop( void ) ;void     HandleKeyPress( EventRecord *event ) ;Boolean    HandleEvent( EventRecord *theEvent ) ;void     HandleMenuCommand( long menuResult ) ;void     MyAdjustMenus( void ) ;OSErr    MyDisposeViewerWindow( WindowPtr theWindow ) ;CGrafPtr   MyCreateViewerWindow( void ) ;//-- AppleEvent RelatedBoolean SupportsAEVT(void) ;void RegisterMyEvents(void) ;pascal OSErr MyAEHandleOAPP( AppleEvent *theAppleEvent, AppleEvent *reply, long refCon) ;pascal OSErr MyAEHandleODOC(AppleEvent *theAppleEvent, AppleEvent *reply, long refCon) ;pascal OSErr MyAEHandlePDOC(AppleEvent *theAppleEvent,AppleEvent *reply,long refCon) ;pascal OSErr MyAEHandleQUIT(AppleEvent *theAppleEvent,AppleEvent *reply,long refCon) ;void DoAppOpenCommand( void ) ;void MySendQuitApp( void ) ;void MySendOpenDoc(FSSpec *myFSSpec) ;//--------------------------------------------------------------------------------------------// Constantsconst RGBColor  kRGBBlack = { 0x0000, 0x0000, 0x0000 } ;const RGBColor  kRGBWhite = { 0xFFFF, 0xFFFF, 0xFFFF } ;const int     kMyAboutDialogID = 128 ;const int     kMyFatalDialogID = 129 ;const int    kQD3DAlertID = 27309 ;//--------------------------------------------------------------------------------------------// Typestypedef struct _viewerData {  TQ3ViewerObject    theViewer ;  FSSpec        theFile ;  Boolean        isFileValid ;} ViewerData, *ViewerDataPtr, **ViewerDataHandle ;//--------------------------------------------------------------------------------------------////main(){  MoreMasters(); MoreMasters() ; MoreMasters() ;  MaxApplZone() ;      // Maximise the heap - the viewer requires at least 32k  InitToolbox() ;  // WE DON'T CHECK FOR 68K machine.  // Instead I use the NotPPC.rsrc resource file.  This is a file with a 68k CODE 0  // and CODE 1 resource that puts up a dialog that says &quot;this app only runs on a power  // macintosh computer.    if( SupportsAEVT() &amp;&amp; SupportsQuickDraw3D() &amp;&amp; SupportsQuickDraw3DViewer()  ) {      // AppleEvent stuff:    // Set up the self-addressed descriptor record.     gSelfPSN.highLongOfPSN = 0;     gSelfPSN.lowLongOfPSN = kCurrentProcess;    //* Use this instead of GetCurrentProcess *//     FailIfErr(AECreateDesc(typeProcessSerialNumber,(Ptr)&amp;gSelfPSN,sizeof(ProcessSerialNumber),&amp;gSelfAddress));    RegisterMyEvents() ;  // register the appleevents for this app    MainEventLoop() ;    // Handle events 'til we die  }   else {    Str255 theString ;    GetIndString(theString,kQD3DAlertID,3);    ParamText( theString, 0L,  0L,  0L ) ;    (void)Alert(kQD3DAlertID,nil);  }}//---------------------------------------------------------------------Boolean SupportsQuickDraw3D(void) {  OSErr err;  long response;      err = Gestalt(gestaltQD3D,&amp;response);  if (err!=noErr)    return false;      return (response &amp;&amp; (response &lt;&lt; gestaltQD3DAvailable));}//---------------------------------------------------------------------Boolean SupportsQuickDraw3DViewer(void) {  OSErr err;  long response;      err = Gestalt( gestaltQD3DViewer,&amp;response );  if (err!=noErr)    return false;      return (response &amp;&amp; ( response &lt;&lt; gestaltQD3DViewerAvailable ));}//--------------------------------------------------------------------------------------------////void FailIfErr( OSErr something ){   OSErr myErr ;   if(( myErr = something) != noErr ) {     ModalFilterUPP     theProc ;    DialogPtr      theDialog ;     short        itemHit ;    Str255        theError ;        NumToString(something,theError);      theDialog = GetNewDialog ( kMyFatalDialogID, nil, (WindowPtr)-1 );        // these two lil' snappers are system 7 only    // so if you use them, check before!!    // in this app we will only run on Power    // Macintosh, so we don't check        GetStdFilterProc( &amp;theProc ) ;    SetDialogDefaultItem(theDialog, ok) ;        ParamText( theError, 0L, 0L, 0L ) ;        // put the dialog up and loop 'til    // the user hits the OK button    do {      ModalDialog ( theProc, &amp;itemHit );    } while( itemHit != ok ) ;        DisposeDialog ( theDialog );        ExitToShell() ;   } } //--------------------------------------------------------------------------------------------////void InitToolbox(){  Handle    menuBar = nil;  InitGraf((Ptr) &amp;qd.thePort);  InitFonts();  InitWindows();  InitMenus();  TEInit();  InitDialogs((long)nil);  InitCursor();  // initialize application globals    gQuitFlag = false;      menuBar = GetNewMBar(128);        // Read menus into menu bar, MBAR res id is 128    if ( menuBar == nil )     ExitToShell();            // if we dont have it then quit - your app                        // needs a dialog here   SetMenuBar(menuBar);          // Install menus  DisposeHandle(menuBar);    AppendResMenu(GetMenuHandle(mApple), 'DRVR');  // Add DA names to Apple menu, ID 128  MyAdjustMenus() ;  DrawMenuBar();}//--------------------------------------------------------------------------------------------////void MainEventLoop(){  EventRecord     event;  WindowPtr       theWindow;  Boolean        wasViewerEvent ;  GrafPtr       savedPort ;  Point        localPt ;  TQ3ViewerObject   theViewer ;  ViewerDataHandle  myData ;  MyAdjustMenus() ;  while( !gQuitFlag )  {    if (WaitNextEvent( everyEvent, &amp;event, 0, nil ))    {            if((theWindow = FrontWindow()) != nil ) {              myData = (ViewerDataHandle)GetWRefCon(theWindow);        theViewer = (**myData).theViewer;      }            if( theViewer ) {        GetPort( &amp;savedPort ) ;        SetPort( (GrafPtr)theWindow ) ;        GetMouse(&amp;localPt);        if (!Q3ViewerAdjustCursor(theViewer, &amp;localPt))          InitCursor();        wasViewerEvent = Q3ViewerEvent ( theViewer, &amp;event );        SetPort( savedPort ) ;      }      else        wasViewerEvent = false ;            // was it a viewer event????      if( !wasViewerEvent )        HandleEvent( &amp;event );    }  }}//----------------------------------------------------------------------------------//  HandleActivateWindow is called when an event is received that reports that//  a window is being either activated or deactivated.static void HandleActivateWindow(WindowPtr theWindow, short activate){  if (theWindow) {    if (activate) {          // do whatever else you'd like to do for a activate event      LoadScrap() ;    } else {          // do whatever you'd like to do for a deactivate event      UnloadScrap() ;    }  }}//--------------------------------------------------------------------------------------------////Boolean    HandleEvent( EventRecord *theEvent ){  short           thePart;  WindowPtr      theWindow ;  Rect            screenRect;  GrafPtr        oldPort ;  Point        aPoint = {100, 100};  TQ3ViewerObject   theViewer ;  ViewerDataHandle  myData ;    switch (theEvent-&gt;what) {    case mouseDown:          thePart = FindWindow( theEvent-&gt;where, &amp;theWindow );            switch( thePart ) {        case inMenuBar:           MyAdjustMenus() ;          HandleMenuCommand(MenuSelect(theEvent-&gt;where));          break;                case inDrag:          screenRect = (**GetGrayRgn()).rgnBBox;          DragWindow( theWindow, theEvent-&gt;where, &amp;screenRect );          break ;              case inContent:          if (theWindow != FrontWindow())            SelectWindow( theWindow );          break ;              case inGoAway:          if (TrackGoAway( theWindow, theEvent-&gt;where )) {            MyDisposeViewerWindow( theWindow ) ;          }          break ;                  default:          break ;      }      break ;                      case updateEvt:          theWindow = (WindowPtr)theEvent-&gt;message;      myData = (ViewerDataHandle)GetWRefCon( theWindow ) ;      theViewer = (**myData).theViewer ;            GetPort(&amp;oldPort ) ;        SetPort( theWindow );            BeginUpdate( theWindow );      Q3ViewerDraw( theViewer ) ;      EndUpdate( theWindow );            SetPort( oldPort ) ;            break ;          case keyDown:    case autoKey:      HandleKeyPress(theEvent);      break;          case diskEvt:      if ( HiWrd(theEvent-&gt;message) != noErr )         (void) DIBadMount(aPoint, theEvent-&gt;message);      break;          case osEvt:      break ;    case activateEvt:      if ((theWindow = (WindowPtr) theEvent-&gt;message) != nil) {        HandleActivateWindow(theWindow, (theEvent-&gt;modifiers &amp; activeFlag));      }      break;    case kHighLevelEvent:            // Let the Apple Event Manager handle high level event.      AEProcessAppleEvent(theEvent);      break;  }  return true ;}//--------------------------------------------------------------------------------------------////void HandleKeyPress(EventRecord *event){  char  key;  key = event-&gt;message &amp; charCodeMask;    // just check to see if we want to quit...    if ( event-&gt;modifiers &amp; cmdKey ) {    /* Command key down? */    HandleMenuCommand(MenuKey(key));  } }//--------------------------------------------------------------------------------------------////static void HandleAboutApp( void ){  ModalFilterUPP     theProc ;  DialogPtr      theDialog ;   short        itemHit ;  theDialog = GetNewDialog ( kMyAboutDialogID, nil, (WindowPtr)-1 );    // these two lil' snappers are system 7 only  // so if you use them, check before!!  // in this app we will only run on Power  // Macintosh, so we don't check    GetStdFilterProc( &amp;theProc ) ;  SetDialogDefaultItem(theDialog, ok) ;    // put the dialog up and loop 'til  // the user hits the OK button    do {    ModalDialog ( theProc, &amp;itemHit );  } while( itemHit != ok ) ;    DisposeDialog ( theDialog );}//--------------------------------------------------------------------------------------------////static OSErr HandleOpenDoc(FSSpec *theFile){  OSErr        err ;  short        theRef ;  ViewerDataHandle  myData ;  TQ3ViewerObject   theViewer ;  WindowPtr      theWindow ;  // display the contents  theWindow = (WindowPtr)MyCreateViewerWindow() ;    // open the file  err = FSpOpenDF( theFile, fsRdPerm, &amp;theRef ) ;  if (err == noErr)  {    myData = (ViewerDataHandle)GetWRefCon( theWindow ) ;    theViewer = (**myData).theViewer ;    (**myData).theFile = *theFile ;    (**myData).isFileValid = true ;    Q3ViewerUseFile(theViewer, theRef) ;    err = FSClose(theRef) ;  }    // set the window title  SetWTitle( theWindow, theFile-&gt;name );  MyAdjustMenus() ;  return err ;}//--------------------------------------------------------------------------------------------////void HandleMenuCommand(long menuResult){  short        menuID;  short        menuItem;  Str255        daName;    short        numTypes = 2 ;  SFTypeList      myTypes = { '3DMF', 'TEXT', 0 } ;  OSErr        err ;  short        theRef ;    ViewerDataHandle  myData ;  TQ3ViewerObject   theViewer ;  WindowPtr      theWindow ;  GrafPtr        savedPort ;    FSSpec        theFile ;      StandardFileReply  theSFReply ;  menuID = HiWrd(menuResult);  menuItem = LoWrd(menuResult);    switch ( menuID ) {    //    //--------------------------------------------------------------------------      //    case mApple:      switch ( menuItem ) {        case iAbout:          HandleAboutApp() ;            break ;                        default:          GetMenuItemText(GetMenuHandle(mApple), menuItem, daName);          (void) OpenDeskAcc(daName);          break;      }      break;    //    //--------------------------------------------------------------------------      //    case mFile:      switch ( menuItem ) {        case iNew:          // display the contents          (void)MyCreateViewerWindow() ;          break ;                case iOpen:          // Get the file name to open          StandardGetFile( nil, numTypes, myTypes, &amp;theSFReply ) ;                    // did the user cancel, if not open the file?          if(theSFReply.sfGood)            MySendOpenDoc(&amp;theSFReply.sfFile) ;          break ;                            case iRevert:                  // we know this can't be called as long as there          // is an app window open (MyAdjustMenus) so get the refcon          // from the front window and get the FSSpec from that          theWindow = FrontWindow() ;          myData = (ViewerDataHandle)GetWRefCon( theWindow ) ;          theFile = (**myData).theFile ;                    // open the file and read it back into the viewer          err = FSpOpenDF( &amp;theFile, fsRdPerm, &amp;theRef ) ;          if (err == noErr)          {            theViewer = (**myData).theViewer ;            Q3ViewerUseFile(theViewer, theRef) ;            err = FSClose(theRef) ;          }          GetPort( &amp;savedPort ) ;          SetPort((GrafPtr)theWindow) ;          InvalRect( &amp;theWindow-&gt;portRect ) ;          SetPort( savedPort ) ;          break ;                          case iSave:                          // we know this can't be called as long as there          // is an app window open (MyAdjustMenus) so get the refcon          // from the front window and get the FSSpec from that          theWindow = FrontWindow() ;          myData = (ViewerDataHandle)GetWRefCon( theWindow ) ;          theFile = (**myData).theFile ;          theViewer = (**myData).theViewer ;          // assumes the original file still exists          err = FSpOpenDF(&amp;theFile, fsWrPerm, &amp;theRef);          if (err == noErr)          {            Q3ViewerWriteFile(theViewer, theRef);            err = FSClose(theRef);          }          break ;                case iSaveAs:          // we know this can't be called as long as there          // is an app window open (MyAdjustMenus) so get the refcon          // from the front window and get the FSSpec from that          theWindow = FrontWindow() ;          myData = (ViewerDataHandle)GetWRefCon( theWindow ) ;          theViewer = (**myData).theViewer ;          StandardPutFile(&quot;\pSave model as:&quot;, &quot;\pUntitled&quot;, &amp;theSFReply);          if (theSFReply.sfGood)          {            err = FSpOpenDF(&amp;theSFReply.sfFile, fsWrPerm, &amp;theRef);            if (err != noErr)            {              err = FSpCreate(&amp;theSFReply.sfFile, '????', '3DMF', theSFReply.sfScript);              if (err == noErr)                err = FSpOpenDF(&amp;theSFReply.sfFile, fsCurPerm, &amp;theRef);            }            if (err == noErr)            {              Q3ViewerWriteFile(theViewer, theRef);              err = FSClose(theRef);            }                        // set up our record of the file location,            // update the structure            theWindow = FrontWindow() ;            myData = (ViewerDataHandle)GetWRefCon( theWindow ) ;            theViewer = (**myData).theViewer ;            (**myData).theFile = theSFReply.sfFile ;            (**myData).isFileValid = true ;                        // reset the window title            SetWTitle( theWindow, theSFReply.sfFile.name );          }          break;                        case iClose:          MyDisposeViewerWindow ( FrontWindow() );          break ;                  case iQuit:          MySendQuitApp();          break;      }      break;                //    //--------------------------------------------------------------------------      //    case mEdit:      // display the contents      theWindow = FrontWindow() ;      myData = (ViewerDataHandle)GetWRefCon( theWindow ) ;      theViewer = (**myData).theViewer ;      switch(menuItem)      {        case iCut:          Q3ViewerCut(theViewer);          break;        case iCopy:          Q3ViewerCopy(theViewer);          break;        case iPaste:          Q3ViewerPaste(theViewer);          break;        case iClear:          Q3ViewerClear(theViewer);          break;        default:          break;      }      break;   }  HiliteMenu(0);    // Unhighlight whatever MenuSelect or MenuKey hilited}//--------------------------------------------------------------------------------------------////void MyAdjustMenus( void ) {  WindowPtr      theWindow ;  ViewerDataHandle  myData ;  MenuHandle      theMenu ;  theWindow = FrontWindow() ;      if( theWindow != nil ) {      theMenu =  GetMenuHandle ( mFile ) ;        EnableItem ( theMenu, iClose );    EnableItem ( theMenu, iSaveAs );             myData = (ViewerDataHandle)GetWRefCon( theWindow ) ;         if(  (**myData).isFileValid) {      EnableItem ( theMenu, iSave );      EnableItem (theMenu, iRevert );     }     else {      DisableItem ( theMenu, iSave );      DisableItem ( theMenu, iRevert );          }          EnableItem ( GetMenuHandle ( mEdit ), 0 );  }  else {    theMenu =  GetMenuHandle ( mFile ) ;    DisableItem ( theMenu, iClose );    DisableItem ( theMenu, iRevert );    DisableItem ( theMenu, iSave );    DisableItem ( theMenu, iSaveAs );        DisableItem ( GetMenuHandle ( mEdit ), 0 );  }    // we don't support undo  DisableItem ( GetMenuHandle ( mEdit ), iUndo );    DrawMenuBar() ;}//--------------------------------------------------------------------------------------------////OSErr  MyDisposeViewerWindow( WindowPtr theWindow ){  TQ3ViewerObject   theViewer ;  ViewerDataHandle  myData ;    if( theWindow == nil)    return paramErr ;  myData = (ViewerDataHandle)GetWRefCon( theWindow ) ;  theViewer = (**myData).theViewer ;    DisposeHandle((Handle)myData);  DisposeWindow(theWindow);    MyAdjustMenus() ;  return   Q3ViewerDispose(theViewer);}//--------------------------------------------------------------------------------------------////CGrafPtr MyCreateViewerWindow(  ){  Rect        theRect ;  GrafPtr        savedPort ;  TQ3ViewerObject    myViewerObj ;  WindowPtr      theWindow ;  ViewerDataHandle  myData = (ViewerDataHandle)NewHandle(sizeof(ViewerData)) ;    GetPort( &amp;savedPort ) ;      // set the new rect up with a stagger for multiple windows  SetRect(  &amp;theRect,         gStaggerPos.h,         gStaggerPos.v,         gStaggerPos.h + kWindowWidth,         gStaggerPos.v + kWindowHeight );  gStaggerPos.h += 16 ;  gStaggerPos.v += 16 ;    // this is not &quot;real staggering code, it don't wrap ;                   theWindow  = NewCWindow(  nil,                 &amp;theRect,                 &quot;\pUntitled&quot;,                 false,                 documentProc,                 (WindowPtr)-1,                 true,                 0L );              SetPort( (GrafPtr)theWindow ) ;    // set up the viewer object here      myViewerObj = Q3ViewerNew ((CGrafPtr)theWindow,  &amp;theWindow-&gt;portRect,  kQ3ViewerDefault) ;     //stuff the reference to the viewer in the RefCon field of the Window  (**myData).theViewer = myViewerObj ;  (**myData).isFileValid = false ;  SetWRefCon( theWindow, (long)myData );    // make sure it is visible  ShowWindow( theWindow ) ;    SetPort( savedPort ) ;    return (CGrafPtr)theWindow ;}//-----------------------------------------------------------------------// returns true if the platform supports appleevents - we won't run// if it doesn'tBoolean SupportsAEVT(void){  OSErr err;  long response;      err = Gestalt(gestaltAppleEventsAttr,&amp;response);  if (err!=noErr)    return false;      return (response &amp;&amp; (response &lt;&lt; gestaltAppleEventsPresent));}//-----------------------------------------------------------------------// called to register our appleevent handlersvoid RegisterMyEvents(void){  OSErr err;    if (!SupportsAEVT())    return;    err = AEInstallEventHandler(kCoreEventClass,kAEOpenApplication,NewAEEventHandlerProc(MyAEHandleOAPP),0L,false);  if (err!=noErr)    return;          err = AEInstallEventHandler(kCoreEventClass,kAEOpenDocuments,NewAEEventHandlerProc(MyAEHandleODOC),0L,false);  if (err!=noErr)    return;          err = AEInstallEventHandler(kCoreEventClass,kAEPrintDocuments,NewAEEventHandlerProc(MyAEHandlePDOC),0L,false);  if (err!=noErr)    return;          err = AEInstallEventHandler(kCoreEventClass,kAEQuitApplication,NewAEEventHandlerProc(MyAEHandleQUIT),0L,false);  if (err!=noErr)    return;}//-----------------------------------------------------------------------// open application event handler for the core event suite, // by default we just want a blank new documentpascal OSErr MyAEHandleOAPP( AppleEvent *theAppleEvent, AppleEvent *reply, long refCon){  // we don't actually do anything on open - you could,  // for example you might want to open a blank untitled   // window    OSErr err = noErr ;  return err;}//-----------------------------------------------------------------------// handler for the open document appleevent handlerpascal OSErr MyAEHandleODOC(AppleEvent *theAppleEvent, AppleEvent *reply, long refCon){  FSSpec     myFSS;  AEDescList  docList;  OSErr    err,        ignoreErr;  long    index,        itemsInList;  Size     actualSize;  AEKeyword  keywd;  DescType  returnedType;    err = AEGetParamDesc(theAppleEvent,keyDirectObject,typeAEList,&amp;docList);  if (err == noErr) {      // see how many descriptor items are in the list    // this is the number of documents we want to open    err = AECountItems(&amp;docList,&amp;itemsInList);    // now get each descriptor record from the list    // coerce the returned data to an FSSpec record, and    // open the asoociated file        for (index=1; index &lt;= itemsInList &amp;&amp; err == noErr; index++) {          err = AEGetNthPtr(  &amp;docList,                 index,                typeFSS,                &amp;keywd,                &amp;returnedType,                (Ptr)&amp;myFSS,                sizeof(myFSS),                &amp;actualSize);        if (err == noErr)  {              FInfo    fndrInfo ;                // we now have a valid FSSpec to reference the file, we need to know         // what type the file is to determine which file open function to call        // we can determine this from the finder info for the file                err = FSpGetFInfo( &amp;myFSS, &amp;fndrInfo );                  // if we got that ok, then we switch on the file          // type (we don't care about the creator type)                      if (err == noErr)  {                  switch( fndrInfo.fdType ) {            case 'TEXT':            case '3DMF':              err =  HandleOpenDoc(&amp;myFSS);              break ;          }        }      }    }    ignoreErr = AEDisposeDesc(&amp;docList);  }  return err ;}//-----------------------------------------------------------------------// handler for the print document event handlerpascal OSErr MyAEHandlePDOC(AppleEvent *theAppleEvent,AppleEvent *reply,long refCon){  FSSpec     myFSS;  AEDescList  docList;  OSErr    err;  long    index,        itemsInList;  Size     actualSize;  AEKeyword  keywd;  DescType  returnedType;    err = AEGetParamDesc(theAppleEvent,keyDirectObject,typeAEList,&amp;docList);  if (err == noErr) {      // see how many descriptor items are in the list    // this is the number of documents we want to open    err = AECountItems(&amp;docList,&amp;itemsInList);    // now get each descriptor record from the list    // coerce the returned data to an FSSpec record, and    // open the asoociated file        for (index=1; index &lt;= itemsInList &amp;&amp; err == noErr; index++) {          err = AEGetNthPtr(  &amp;docList,                 index,                typeFSS,                &amp;keywd,                &amp;returnedType,                (Ptr)&amp;myFSS,                sizeof(myFSS),                &amp;actualSize);        if (err == noErr)  {                  // err = HandlePrintDoc( &amp;myFSS );        err = errAEEventNotHandled ;     // we don't do this yet...      }    }    err = AEDisposeDesc(&amp;docList);  }  return err ;}//-----------------------------------------------------------------------// quit appleevent handlerpascal OSErr MyAEHandleQUIT(AppleEvent *theAppleEvent,AppleEvent *reply,long refCon){  OSErr       err = noErr ;    // used as return value  WindowPtr    theWindow ;  Boolean      quitting = true ;    // close all windows and signal to Quit      // attempt to close all documents  while(( theWindow = FrontWindow()) != nil &amp;&amp; quitting )    quitting = (MyDisposeViewerWindow( theWindow ) == noErr);        // if we closed everything up successfully, we can return noErr, otherwise  // indicate to sender of the 'quit' aevt that we canceled    if (quitting) {    gQuitFlag = true;          // user didn't cancel     AEDisposeDesc(&amp;gSelfAddress);    // Dispose of my self-addressed descriptor.  }  else {    err = userCanceledErr ;  }        return err ;}//----------------------------------------------------------------------------------////  Send a Quit Application Apple Event to myself to terminate this app.    void MySendQuitApp( void ){  AppleEvent  myAppleEvent, reply;    //  Create the Apple Event.  FailIfErr(AECreateAppleEvent( kCoreEventClass,                   kAEQuitApplication,                   &amp;gSelfAddress,                  kAutoGenerateReturnID,                   kAnyTransactionID,                   &amp;myAppleEvent));                    //  Send the Apple Event.    FailIfErr(AESend( &amp;myAppleEvent,               &amp;reply,               kAENoReply+kAENeverInteract,               kAENormalPriority,              kAEDefaultTimeout,               nil,               nil));                  AEDisposeDesc(&amp;myAppleEvent);        // Dispose of the Apple Event.} // MySendQuitApp//----------------------------------------------------------------------------------////  Send a Open Document Application Apple Event to myself to open a document.    void MySendOpenDoc(FSSpec *myFSSpec){   AppleEvent    myAppleEvent;  AppleEvent    defReply;  AEDescList    docList;  OSErr         myErr;  OSErr         ignoreErr;    myAppleEvent.dataHandle = nil;  docList.dataHandle  = nil;  defReply.dataHandle = nil;      // Create empty list and add one file spec  FailIfErr(AECreateList(nil,0,false, &amp;docList));    FailIfErr(AEPutPtr(&amp;docList,1,typeFSS,(Ptr)myFSSpec,sizeof(FSSpec)));      FailIfErr(AECreateAppleEvent(  kCoreEventClass,                  kAEOpenDocuments,                  &amp;gSelfAddress,                  kAutoGenerateReturnID,                  kAnyTransactionID,                  &amp;myAppleEvent));  // Put Params into our event and send it  FailIfErr(AEPutParamDesc( &amp;myAppleEvent,                keyDirectObject,                &amp;docList));  FailIfErr(AESend( &amp;myAppleEvent,            &amp;defReply,            kAENoReply+kAENeverInteract,            kAENormalPriority,            kAEDefaultTimeout,            nil,            nil));          if (myAppleEvent.dataHandle)     ignoreErr = AEDisposeDesc(&amp;myAppleEvent);      if (docList.dataHandle)     ignoreErr = AEDisposeDesc(&amp;docList);      }  // MySendOpenDoc </pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/SimpleViewer/listing1.html%3Fid%3DDTS10000126-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/SimpleViewer/listing1.html%3Fid%3DDTS10000126-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/SimpleViewer/listing1.html%3Fid%3DDTS10000126-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>