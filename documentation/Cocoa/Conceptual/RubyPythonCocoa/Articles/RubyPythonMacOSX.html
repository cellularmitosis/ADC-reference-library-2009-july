<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Ruby and Python Programming Topics for Mac OS X: Ruby and Python on Mac OS X</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Ruby and Python on Mac OS X"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40005423" title="Ruby and Python on Mac OS X"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../DesignGuidelines-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000556" target="_top">Design Guidelines</a> &gt; <a href="../index.html" target="_top">Ruby and Python Programming Topics for Mac OS X</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Introduction/Introduction.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="BuildingRubyCocoaAppl.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>
        
        
        <a name="//apple_ref/doc/uid/TP40005423-SW1" title="Ruby and Python on Mac OS X"></a><hr /><H1>Ruby and Python on Mac OS X</H1><p>Ruby and Python, two immensely popular object-oriented scripting languages, have been installed as part of Mac OS X for many years now. But their relevance to software development, and especially application development,  assumes even greater importance in Mac OS X v10.5. The following sections summarize the capabilities and components of Ruby and Python and describe the bridges being developed and enhanced for Mac OS X to support Cocoa programming and AppleScript-command processing from those scripting languages.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <!-- TopicBook.pm uses this template for its miniTOCs, but needs a different title. -->
    <h4>Contents:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="RubyPythonMacOSX.html#//apple_ref/doc/uid/TP40005423-DontLinkElementID_6">What Are Ruby and Python?</a>
				
			<br/>
			
        
			
			
				<a href="RubyPythonMacOSX.html#//apple_ref/doc/uid/TP40005423-DontLinkElementID_10">Bridges for Cocoa Development</a>
				
			<br/>
			
        
			
			
				<a href="RubyPythonMacOSX.html#//apple_ref/doc/uid/TP40005423-DontLinkElementID_13">Bridges for OSA Automation</a>
				
			<br/>
			
        
			
			
				<a href="RubyPythonMacOSX.html#//apple_ref/doc/uid/TP40005423-DontLinkElementID_17">Multithreading With Ruby on Mac OS X</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40005423-DontLinkElementID_6" title="What Are Ruby and Python?"></a><h2>What Are Ruby and Python?</h2><p>Ruby and Python are interpreted object-oriented scripting languages. As interpreted languages, you can change and run code immediately, without having to wait for the code to compile. Python and Ruby also have all the features one would expect to find in dynamic object-oriented programming languages, such as inheritance, encapsulation, introspection, and subclassing. The syntax of both languages is simple, compact, and consistent, and supports both regular expressions and sophisticated string manipulations. Memory management is built into both languages; garbage collectors automatically free memory occupied by unneeded objects. With both Python and Ruby you can call operating system routines directly. They offer ways to extend their native capabilities, including C-language interfaces.  </p><p>Although their similarities are striking, these scripting languages do have some differences. While Python code can contain both objects and built-in types, in Ruby everything is an object. There are no primitive or built-in types, such as integers. Thus anything in Ruby code can accept messages. And you don’t have to declare variables to be of specific object types. To distinguish variables as global, local, instance, and class, Ruby uses naming conventions.  Ruby also has mix-in by modules and blocks, language features absent in Python.</p><p>Beyond the similarities of languages and interpreters, Python and Ruby share other things in common. Both have extensive standard libraries of classes and modules. Both scripting languages can be used in a wide variety of software projects, including system programming (command-line utilities and daemons), user-interface design, Internet and networking tasks, database programming, component integration, and, of course, rapid prototyping. And both are the products of open-source projects supported by large and enthusiastic developer communities.</p><p>Both languages come with a basic set of command-line utilities. In addition to the interactive interpreter, <code>irb</code>, Ruby includes <code>ri</code> and <code>rdoc</code> (for displaying and generating documentation, respectively), <code>erb</code> (for interpreting files with embedded Ruby code), and <code>testrb</code> (for running test suites on Ruby code). In addition to the language interpreter, <code>python</code>, Python includes <code>pydoc</code> for viewing documentation and <code>pythonw</code> for running Python scripts that display a graphical user interface. All of these utilities are located in <code>/usr/bin</code>. </p><a name="//apple_ref/doc/uid/TP40005423-DontLinkElementID_7" title="The Standard Ruby Package"></a><h3>The Standard Ruby Package</h3><p>On Mac OS X Ruby includes more than the language interpreter and documentation and testing utilities. A standard installation offers the following Ruby-related services, frameworks, and protocols:</p><ul class="spaceabove"><li class="li"><p>RubyGems—A package manager for Ruby</p></li><li class="li"><p>rake—A <code>make</code>-like utility for Ruby scripts</p></li><li class="li"><p>Rails (or Ruby on Rails)—A framework for creating database-backed web applications with designs conforming to the Model-View-Controller pattern </p><p>For more information on Ruby on Rails, go to <span class="content_text"><a href="http://developer.apple.com/tools/rubyonrails.html" target="_top">http://developer.apple.com/tools/rubyonrails.html</a></span>.</p></li><li class="li"><p>Mongrel—A fast HTTP library and server used for hosting Ruby web applications</p></li><li class="li"><p>Capistrano—A framework and utility for executing commands in parallel on multiple remote machines, via SSH, primarily to expedite the deployment of web applications</p></li><li class="li"><p>Ferret—A search engine</p></li><li class="li"><p>OpenID—A service that provides OpenID identification to Ruby programs</p></li><li class="li"><p>sqlite3-ruby—A module that enables Ruby scripts to interact with a SQLite3 database</p></li><li class="li"><p>libxml-ruby—A module for reading and writing XML documents using Ruby </p></li><li class="li"><p>dnssd—Ruby interface for DNS Service Discovery (that is, Bonjour) </p></li><li class="li"><p>net-ssh and net-sftp—Pure Ruby implementations of the SSH and SFTP client protocols</p></li></ul><a name="//apple_ref/doc/uid/TP40005423-DontLinkElementID_8" title="The Standard Python Package"></a><h3>The Standard Python Package</h3><p>The Python modules included in the standard package for Mac OS X are the following: </p><ul class="spaceabove"><li class="li"><p>altgraph — Python graph (network) package</p></li><li class="li"><p>bdist_mpkg — Builds Mac OS X installer packages from distutils</p></li><li class="li"><p>macholib — Mach-O header analysis and editing</p></li><li class="li"><p>modulegraph — Python module dependency analysis tool</p></li><li class="li"><p>numpy (or NumPy) — Array processing for numbers, strings, records, and objects</p></li><li class="li"><p>py2app — Creates standalone Mac OS X applications with Python</p></li><li class="li"><p>setuptools — Downloads, builds, installs, upgrades, and uninstalls Python packages</p></li><li class="li"><p>xattr — A Python wrapper for Darwin’s extended filesystem attributes</p></li></ul><p>Except for <code>numpy</code> and <code>xattr</code>, all of these modules are used by PyObjC.</p><a name="//apple_ref/doc/uid/TP40005423-DontLinkElementID_9" title="On-line Resources"></a><h3>On-line Resources</h3><p>You can find out more about Python from the following websites:</p><ul class="spaceabove"><li class="li"><p>Main Python website:  <span class="content_text"><a href="http://docs.python.org/" target="_blank">http://www.python.org/</a></span></p></li><li class="li"><p>Documentation:  <span class="content_text"><a href="http://docs.python.org/" target="_blank">http://docs.python.org/</a></span></p></li><li class="li"><p>Other developer resources:  <span class="content_text"><a href="http://www.python.org/dev/" target="_blank">http://www.python.org/dev/</a></span></p></li></ul><p>On-line resources for Ruby include the following websites: </p><ul class="spaceabove"><li class="li"><p>Documentation, downloads, and other resources: <span class="content_text"><a href="http://www.ruby-lang.org/" target="_blank">http://www.ruby-lang.org/</a></span></p></li><li class="li"><p>Libraries: <span class="content_text"><a href="http://rubyforge.org/" target="_blank">http://rubyforge.org/</a></span></p></li><li class="li"><p><em>why’s (poignant) guide to Ruby</em> (<span class="content_text"><a href="http://poignantguide.net/ruby/" target="_blank">http://poignantguide.net/ruby/</a></span>), a whimsical, cartoon-illustrated introduction to Ruby </p></li></ul><a name="//apple_ref/doc/uid/TP40005423-DontLinkElementID_10" title="Bridges for Cocoa Development"></a><h2>Bridges for Cocoa Development</h2><p>Both Ruby and Python include bridges to the Objective-C runtime. Although these bridges are open-source projects, some changes have been made the implementation and tool support on Mac OS X v10.5 and later systems.</p><a name="//apple_ref/doc/uid/TP40005423-SW2" title="RubyCocoa"></a><h3>RubyCocoa</h3><p>Because Ruby and Objective C share a common ancestor in Smalltalk, creating a bridge between them was relatively straightforward. RubyCocoa is a bridge that makes it possible for Ruby scripts to access Objective-C objects defined in frameworks and local project code. Consequently, one can do Cocoa programming in a Ruby script. RubyCocoa works by creating—automatically and upon demand—Ruby proxy objects that are bridged to Objective-C classes. It also forwards Ruby messages to the instances of these Objective-C classes. You can have a Cocoa application project that mixes Ruby and Objective-C source files. RubyCocoa supports all important features of Cocoa, such as key-value coding, key-value observing, Core Data, the document architecture, notifications, and undo management.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40005423-DontLinkElementID_31" title="Note"></a><p><strong>Note:</strong>&nbsp;For more information about RubyCocoa, go to <span class="content_text"><a href="http://rubycocoa.sourceforge.net" target="_blank">rubycocoa.sourceforge.net</a></span>. You can find RubyCocoa documentation and coding examples at <span class="content_text"><a href="http://rubycocoa.sourceforge.net/" target="_blank">http://rubycocoa.sourceforge.net/</a></span>.</p></div><p>The following line of code creates a Ruby proxy class that wraps the Cocoa class NSButton:</p><div class="codesample"><table><tr><td scope="row"><pre>OSX::NSButton<span></span></pre></td></tr></table></div><p>A message sent to an instance of this class is forwarded to the Objective-C instance within the proxy object. (If the object doesn’t respond to the message, then RubyCocoa raises a runtime error.) As illustration, consider the following lines of Objective-C code:</p><div class="codesample"><table><tr><td scope="row"><pre>// the NSRect structure (rect) is specified earlier<span></span></pre></td></tr><tr><td scope="row"><pre>NSButton *button = [[NSButton alloc] initWithFrame:rect];<span></span></pre></td></tr><tr><td scope="row"><pre>[button setTarget:self];<span></span></pre></td></tr><tr><td scope="row"><pre>[button setAction:@selector(doGoodThings:)];<span></span></pre></td></tr><tr><td scope="row"><pre>[button setEnabled:YES];<span></span></pre></td></tr><tr><td scope="row"><pre>[view addSubview:button];<span></span></pre></td></tr><tr><td scope="row"><pre>[button release];<span></span></pre></td></tr></table></div><p>In RubyCocoa, the equivalent to these lines would be the following:</p><div class="codesample"><table><tr><td scope="row"><pre>button = NSButton.alloc.initWithFrame_(rect)<span></span></pre></td></tr><tr><td scope="row"><pre>button.setTarget_(self)<span></span></pre></td></tr><tr><td scope="row"><pre>button.setAction_(:doGoodThings)<span></span></pre></td></tr><tr><td scope="row"><pre>button.setEnabled_(true)<span></span></pre></td></tr><tr><td scope="row"><pre>view.addSubview_(button)<span></span></pre></td></tr></table></div><p>As you can see, RubyCocoa uses keypath-style dot notation is used to indicate (potentially nested) message invocations, starting with the object or class initiating the invocations. Note that the <code>release</code> is omitted in the RubyCocoa code snippet because the garbage collector takes care of object disposal.</p><p>The snippet of RubyCocoa code above uses the default messaging syntax, where underscores replace the colons of the Objective-C keywords . But RubyCocoa supports a variant of the default syntax that omits the final underscore. Thus, the two message syntaxes are:</p><div class="codesample"><table><tr><td scope="row"><pre># Default calling syntax<span></span></pre></td></tr><tr><td scope="row"><pre>NSURL.alloc.initWithScheme_host_path_('http', 'localhost', 'sample')<span></span></pre></td></tr><tr><td scope="row"><pre># Same, but no underscore for final keyword<span></span></pre></td></tr><tr><td scope="row"><pre>NSURL.alloc.initWithScheme_host_path('http', 'localhost', 'sample')<span></span></pre></td></tr></table></div><p>In a standard Mac OS X installation, the second syntax is disabled. However, you can enable it by setting the <code>OSX.relaxed_syntax</code> flag to <code>true</code>.</p><p>RubyCocoa takes care of object type conversions for you. When you pass parameters to a Ruby proxy object, RubyCocoa automatically converts the more basic Ruby types to proxies representing their Objective-C counterparts (for example, Ruby strings and <code>NSString</code> objects). It also converts objects returned from the Objective-C side to Ruby objects that act as proxies to those Objective-C objects. On the Ruby side, these proxy objects have more or less the same interfaces as their Ruby equivalents.</p><p>RubyCocoa adds several Xcode templates for building RubyCocoa applications of various types. The templates make it unnecessary for developers to create applications by writing RubyCocoa code using a shell editor (for example, Emacs or <code>vi</code>) and then manually constructing the various pieces of the application bundle. The Xcode templates make sure the application project is properly set up for RubyCocoa and that the application executable and its bundle are properly built. And they let you access the conveniences of a first-class integrated development environment. You can also design your user interfaces using the Interface Builder application. Currently there are four RubyCocoa application templates:</p><ul class="spaceabove"><li class="li"><p>Cocoa-Ruby applications (single window)</p></li><li class="li"><p>Cocoa-Ruby document-based applications</p></li><li class="li"><p>Cocoa-Ruby Core Data applications</p></li><li class="li"><p>Cocoa-Ruby Core Data document-based applications</p></li></ul><p>In addition to the project templates, RubyCocoa adds support for test units. In Xcode you can create a test-unit file by choosing New File from the File menu and then selecting “Ruby test case class” under the Ruby category in the New File Assistant. You can also set up a test-unit target by choosing “New Target” from the Project menu and then selecting “Unit Test Target” option in the New Target Assistant. </p><p>Apple’s implementation of RubyCocoa adds some features and makes some performance improvements, including the following:</p><ul class="spaceabove"><li class="li"><p>Apple has added support for generating metadata about the C-language parts of a framework’s Objective-C API.</p><p>RubyCocoa can extract most of the information it needs about object-oriented symbols (such as classes and methods) from frameworks at runtime. Unfortunately, there is no purely dynamic way to introspect framework data that is C-based, such as constants, enumerations, and functions. To resolve this problem (in a way that avoids generating static code at build time), RubyCocoa reads a per-framework metadata file, which it loads at runtime.  A command-line tool generates most of this metadata XML automatically but the framework developer may have to specify certain items manually, such as pass-by-reference parameters.. See <span class="content_text"><a href="GenerateFrameworkMetadata.html#//apple_ref/doc/uid/TP40005426-SW1">“Generating Framework Metadata”</a></span> for more information on framework metadata and instructions on how to create the metadata description.</p></li><li class="li"><p>Apple has made many performance improvements, involving the following:</p><ul class="nested"><li class="nested li"><p>RubyCocoa uses the <code>libffi</code> library for function calling and message dispatch.</p><p>Instead of a message-dispatch implementation based on <code><a href="../../../Reference/ObjCRuntimeRef/Reference/reference.html#//apple_ref/doc/c_ref/objc_msgSend" target="_top">objc_msgSend</a></code> or <code>NSInvocation</code>, RubyCocoa uses the <code>libffi</code> library from the GCC project. <code>libffi</code> makes it possible to call an arbitrary C function in a processor-agnostic way. It provides more scalability and better performance than the other alternatives. RubyCocoa also uses <code>libffi</code> when overriding or registering an Objective-C method implemented in Ruby, and when converting Ruby closures to C function pointers.</p></li><li class="nested li"><p>RubyCocoa efficiently copies objects as they cross the bridge either way.</p></li><li class="nested li"><p>RubyCocoa efficiently looks up selectors and classes.</p></li></ul></li><li class="li"><p>Apple’s RubyCocoa accurately translates the Objective-C class hierarchy when it creates Ruby proxy objects, taking into account those classes that can be toll-free bridged to the Core Foundation counterparts</p></li></ul><a name="//apple_ref/doc/uid/TP40005423-DontLinkElementID_11" title="PyObjC"></a><h3>PyObjC</h3><p>PyObjC is a bridge that lets you write sophisticated Cocoa applications using the Python scripting language. It enables Python objects to send messages to Objective-C objects and vice versa. With PyObjC you’re not limited to the core Cocoa frameworks, Foundation and Application Kit. You can use any Objective-C framework from Python, and your projects can be a mix of Objective-C, C, and C++ code.  PyObjC also supports full introspection of Objective-C classes and direct invocation of Objective-C APIs from the interactive interpreter. Like RubyCocoa, PyObjC incorporates supports the full range of Cocoa features such as key-value coding, key-value observing, Core Data, document-based applications, notifications, and undo management..</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40005423-DontLinkElementID_32" title="Note"></a><p><strong>Note:</strong>&nbsp;The official PyObjC website is <span class="content_text"><a href="http://pyobjc.sourceforge.net/" target="_blank">http://pyobjc.sourceforge.net/</a></span> and you can also get information on the current version is at <span class="content_text"><a href="http://www.python.org/pypi/pyobjc/1.3.5" target="_blank">http://www.python.org/pypi/pyobjc/1.3.5</a></span>. You can find documentation, coding examples, downloadable installer packages, and other resources at (<span class="content_text"><a href="http://pyobjc.sourceforge.net/documentation/index.html" target="_blank">http://pyobjc.sourceforge.net/documentation/index.html</a></span>) . A description of the standard distribution of PyObjC on Mac OSX is on the ADC website at  <span class="content_text"><a href="http://developer.apple.com/cocoa/pyobjc.html" target="_top">http://developer.apple.com/cocoa/pyobjc.html</a></span>.</p></div><p>PyObjC is useful for more than just Cocoa application (GUI) development. You can also use PyObjC for rapid prototyping of projects, and for writing Foundation-based command-line tools, screen savers, preference panes, and other forms of software.</p><p>PyObjC leaves little that is unbridged between Objective-C and Python. Objective-C classes can inherit from Python classes, and Python classes can inherit from Objective-C classes. You can declare categories on Objective-C classes, with the method definition given in Python. Python classes can implement and define Objective-C protocols, and it's possible to establish a binding between a Python object and an Objective-C object in Interface Builder. </p><p>In PyObjC, Cocoa classes are treated as normal Python classes, but (for Python programmers) with a somewhat different naming scheme for methods . The PyObjC equivalent of the RubyCocoa button code above is:</p><div class="codesample"><table><tr><td scope="row"><pre>button = NSButton.alloc().initWithFrame_(rect)<span></span></pre></td></tr><tr><td scope="row"><pre>button.setTarget_(self)<span></span></pre></td></tr><tr><td scope="row"><pre>button.setAction_('doGoodThings:')<span></span></pre></td></tr><tr><td scope="row"><pre>button.setEnabled_(True)<span></span></pre></td></tr><tr><td scope="row"><pre>view.addSubView_(button)<span></span></pre></td></tr></table></div><p>PyObjC performs a simple translation from Objective-C selector names to Python method names (and vice versa when new methods are defined), replacing all colons by underscores. This is the only messaging syntax supported.</p><p>PyObjC automatically converts Python objects passed to the Objective-C runtime to the correct Objective-C type, and also converts Objective-C objects passed back into Python. For example, Python strings are proxied using an NSString subclass when they are passed to Objective-C code; likewise, an NSString object is proxied using a Python unicode-subclass when the object passes into Python. Unlike RubyCocoa, predicates work without further work on your part; in other words, <code>if button.isEnabled: doSomething()</code>) works as one would expect.</p><p>PyObjC's support for pass-by-reference arguments is similar to that for RubyCocoa, and predates it by many years.  You can learn more about the exact semantics  in the introductionary documentation for PyObjC (<span class="content_text"><a href="http://pyobjc.sourceforge.net/documentation/pyobjc-core/intro.html" target="_blank">http://pyobjc.sourceforge.net/documentation/pyobjc-core/intro.html</a></span>).</p><p>A change in the Leopard version of PyObjC is that it uses the same XML metadata description as does RubyCocoa (see <span class="content_text"><a href="RubyPythonMacOSX.html#//apple_ref/doc/uid/TP40005423-SW2">“RubyCocoa”</a></span> for an overview). Another change is that PyObjC now supports all Core Foundation–based types as well, not only those that can be toll-free bridged to Cocoa classes.</p><p>The open-source version of PyObjC includes a number of Xcode templates that make it easy to create and configure Cocoa-Python application projects. By using the templates, you can have the development environment for your project set up for you; it eliminates the need to code using a shell editor or text processor and then manually construct the various parts of the application bundle. You can compose your user interfaces using Interface Builder and then save them to a nib file. And you have access to a sophisticated integrated development environment with features such as multiple build targets and symbol and documentation look-up. Four PyObjC application templates are offered:</p><ul class="spaceabove"><li class="li"><p>Cocoa-Python applications (single window)</p></li><li class="li"><p>Cocoa-Python document-based applications</p></li><li class="li"><p>Cocoa-Python Core Data applications</p></li><li class="li"><p>Cocoa-Python Core Data document-based applications</p></li></ul><p>The Apple version of PyObjC for Mac OS X version 10.5 includes two additional improvements:</p><ul class="spaceabove"><li class="li"><p>PyObjC uses the same the same XML metadata scheme as RubyCocoa to define the non-object-oriented parts of a framework..</p></li><li class="li"><p>PyObjC supports all Core Foundation opaque types and not only those that can be toll-free bridged to Cocoa classes..</p></li></ul><a name="//apple_ref/doc/uid/TP40005423-DontLinkElementID_12" title="The Advantages of PyObjC and RubyCocoa"></a><h3>The Advantages of PyObjC and RubyCocoa</h3><p>The RubyCocoa and Python bridges bring several advantages to Cocoa development, both for experienced Ruby and Python “scripters” and for Objective-C developers. By letting you mix and match Objective-C, Ruby, and Python, the bridges give you the option of choosing the best language tool for whatever programming goal you have. At the same time, they give your code access to Cocoa technologies such as bindings and Core Data. Moreover, your RubyCocoa and PyObjC projects can use the capable project management of Xcode and the rapid interface development offered by Interface Builder. </p><p>By bridging the Ruby and Python languages to the Objective-C runtime, PyObjC and RubyCocoa open the door to Cocoa application development for thousands of Python and Ruby scripters. But they also offer benefits to experienced Objective-C developers. If you are such a developer, you can take advantage of both scripting languages’ sophisticated regular-expression features for textual processing. You also have access to the extensive libraries for both Python and Ruby. The interpretive nature of RubyCocoa and PyObjC means you can use them for rapid application prototyping to help you locate design problems early in the development cycle. Using the interpreter, you can inject code into your application on the fly and instantly inspect and manipulate objects in your application.</p><p>The bridges’ conjunction of two object-oriented languages—Ruby and Python on one side and Objective-C on the other—enables even more dynamism than any of the languages provides on its own. For example, with PyObjC you can create Cocoa-compatible classes at runtime and even create new methods while your application continues to execute. </p><p>A final advantage of RubyCocoa and PyObjC is that they are extensions of languages that run on a variety of systems, including Linux and Windows. In other words, they are cross-platform. You could thus maintain a cross-platform code base in Ruby or Python—your model objects, as it were—and use the bridged version of the language to control the user interface and manage the application. </p><a name="//apple_ref/doc/uid/TP40005423-DontLinkElementID_13" title="Bridges for OSA Automation"></a><h2>Bridges for OSA Automation</h2><p>You have several options for writing Ruby or Python scripts that can communicate with scriptable applications, enabling them to control those applications and exchange data with them. These technologies are bridges to the Open Scripting Architecture (OSA) infrastructure, which uses Apple events for interprocess communication. The native solution is Scripting Bridge, which is a bridge to the Objective-C runtime and thus can be used in RubyCocoa or PyObjC scripts. You also use open-source Ruby and Python bridges to OSA, and thereby merge the power of Ruby or Python with that of AppleScript and Apple event processing. </p><a name="//apple_ref/doc/uid/TP40005423-DontLinkElementID_14" title="Scripting Bridge"></a><h3>Scripting Bridge</h3><p>Many applications installed on Mac OS X are scriptable. Through the Scripting Bridge technology, RubyCocoa and PyObjC scripts and programs can communicate with these applications, controlling them and exchanging data with them. For example, using Scripting Bridge a RubyCocoa script could select and play music tracks in iTunes; or it could search a mailbox (maintained by the Mail application) for messages with a certain phrase and put those messages into a new TextEdit document.</p><p>Scriptable applications define a interface through which they can respond to Apple events, which are a part of the Open Scripting Architecture (OSA). Apple events frequently originate in AppleScript scripts and make use of the Apple Event Manager of OSA as the mechanism of delivery. Scripting Bridge is a framework that implements an Objective-C bridge to OSA-compliant applications—that is to say, applications having a scripting interface that follows the guidelines described in <span class="content_text"><a href="../../../../../technotes/tn2002/tn2106.html" target="_top">Technical Note T2106</a></span> and <em><a href="../../ScriptableCocoaApplications/index.html#//apple_ref/doc/uid/TP40002164" target="_top">Cocoa Scripting Guide</a></em>. It enables programs written in Objective-C to use the OSA infrastructure to control and communicate with OSA-compliant applications. With Scripting Bridge you can perform the same tasks in Objective-C that you can in AppleScript scripts. </p><p>Scripting Bridge is dynamic. At runtime it retrieves the scripting definition of a given application and generates Objective-C class implementations of the classes it finds in the scripting interface, including objects and methods representing properties, elements, commands, and so on. These objects become part of the Objective-C namespace that PyObjC and RubyCocoa scripts are bridged to, and through them these scripting languages are bridged to OSA-compliant applications. As a result, you can control and obtain data from those applications from RubyCocoa and PyObjC code. And you also have at your disposal all the rich features and capabilities of the native languages, such as regular expressions, string manipulations, and easy access to the native libraries and modules. </p><p>To find out how to use Scripting Bridge in RubyCocoa and PyObjC scripts, see <span class="content_text"><a href="UsingScriptingBridge.html#//apple_ref/doc/uid/TP40005424-SW1">“Using Scripting Bridge in PyObjC and RubyCocoa Code.”</a></span></p><a name="//apple_ref/doc/uid/TP40005423-DontLinkElementID_15" title="RubyOSA"></a><h3>RubyOSA</h3><p>RubyOSA is a open-source bridge that connects Ruby to the Apple Event Manager infrastructure, thereby enabling you to do in Ruby what you can do in AppleScript. It works by retrieving the scriptable definition of a given application (in its <code>sdef</code> file) and using that to populate a new namespace with classes, methods, constants, enumerations, and all other symbols described by the definition. </p><p>Most Mac OS X applications are scriptable, and they define their scriptable interface in the <code>sdef</code> XML format. RubyOSA parses this file and creates Ruby proxy objects with it on the fly. RubyOSA does its work transparently for you to build, send, and receive Apple events.</p><p>To give you an example of how simple and even elegant RubyOSA can be, consider the following code snippet, which gets the name of the current iTunes track:</p><div class="codesample"><table><tr><td scope="row"><pre>require 'rbosa'<span></span></pre></td></tr><tr><td scope="row"><pre>puts OSA.app('iTunes').current_track_name<span></span></pre></td></tr></table></div><p>RubyOSA is an improved alternative to RubyAEOSA. The latter bridge is implemented as a set of Ruby bindings to the Apple event C API, while RubyOSA is a higher level framework that completely hides the Apple event infrastructure. It is simpler and more efficient than RubyAEOSA.</p><p>You can download RubyOSA from <span class="content_text"><a href="http://rubyosa.rubyforge.org/" target="_blank">http://rubyosa.rubyforge.org/</a></span> or, if you already have RubyGems installed, download and install it from the command line. To learn how, and for a practical look at RubyOSA, see <span class="content_text"><a href="UsingScriptingBridge.html#//apple_ref/doc/uid/TP40005424-SW1">“Using Scripting Bridge in PyObjC and RubyCocoa Code.”</a></span>  </p><a name="//apple_ref/doc/uid/TP40005423-DontLinkElementID_16" title="py-appscript"></a><h3>py-appscript</h3><p>py-appscript is an Python-OSA bridge that lets you control scriptable applications from Python scripts. It uses a high-level RPC mechanism for sending commands to applications via Apple events and converts data between common Python and Apple event types. py-appscript features an object-oriented style syntax and a simple embedded query language for identifying objects in an applicaitons object model.</p><p>You can download py-appscript from <span class="content_text"><a href="http://sourceforge.net/projects/appscript" target="_blank">http://sourceforge.net/projects/appscript</a></span>. The package includes installation instructions, examples, and documentation.</p><a name="//apple_ref/doc/uid/TP40005423-DontLinkElementID_17" title="Multithreading With Ruby on Mac OS X"></a><h2>Multithreading With Ruby on Mac OS X</h2><p>Because Ruby in its latest stable version (the 1.8 branch) is not thread-safe, you cannot call the Ruby runtime in a thread other than the main one. When Ruby is bridged to Objective-C this creates problems because Objective-C isn’t able to call back to Ruby in a secondary thread. (If it did, an application would crash.) The version of RubyCocoa on Leopard consequently routes calls from Objective-C to Ruby so that all are on the main thread.</p><p>Ruby 1.8 also implements its threading model using the <code>setjmp</code> and <code>longjmp</code> primitives; this can sometimes cause unexpected behavior when a Ruby thread calls a Cocoa object, especially autorelease pools. Consequently, both the Ruby interpreter and the RubyCocoa bridge have been modified to properly handle these situations by saving and restoring the appropriate context variables during Ruby thread switching.</p><p>Fortunately, the next stable release of Ruby (the 2.0 branch) will be thread-safe and will use native threads. Unfortunately, this is not the version installed on Leopard.</p>

        <br/><br/> 

        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Introduction/Introduction.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="BuildingRubyCocoaAppl.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-10-31<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/RubyPythonCocoa/Articles/RubyPythonMacOSX.html%3Fid%3DTP40004936-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/RubyPythonCocoa/Articles/RubyPythonMacOSX.html%3Fid%3DTP40004936-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/RubyPythonCocoa/Articles/RubyPythonMacOSX.html%3Fid%3DTP40004936-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>
