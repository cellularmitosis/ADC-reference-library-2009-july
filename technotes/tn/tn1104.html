<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 01-05-01 --><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note TN1104: Interrupt-Safe Routines</title><meta name="keywords" content="interrupt safe routines"><meta name="Description" content="Technical Note TN1104: This Technote talks about what routinesare safe to call at interrupt time."><meta name="categories" content="Networking, Hardware, Runtime Architecture, Processes, Devices and Overview"><meta name="week-posted" content="Nov 6, 2000 - Nov 10, 2000"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002944" title="Interrupt-Safe Routines"></a><A NAME="top"></A><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxHardwareDrivers-date.html">Hardware & Drivers</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/HardwareDrivers/idxPerformance-date.html" target="_blank">Hardware & Drivers > Performance</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1104</div>
<div id="pageheadsub">Interrupt-Safe Routines</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"> <!-- begin_header_box --> <table width="600" cellpadding="0" cellspacing="0" border="0">	<tr>		<td width=300 valign="top" align=left scope="row">			<table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>				</tr>				<tr bgcolor="#e6e6e6">					<td background="images/tnmenubody.gif" width=300 align=left>						<span id="menutitle">							CONTENTS 							<br>							<br>						</span>					</td>				</tr>				<tr bgcolor="#e6e6e6">					<td background="images/tnmenubody.gif" width=300 align=left><!-- begin_toc --><p id="menutext"><A HREF="#Introduction">Introduction</A><BR><BR><A HREF="#ExecutionLevels">Execution Levels</A><BR><BR><A HREF="#OtherLevels">Execution Levels in Other Documentation</A><BR><BR><A HREF="#DeterminingExecutionLevel">Determining the Execution Level</A><BR><BR><A HREF="#CanDo">What Interrupt Routines Can't Do</A><BR><BR><A HREF="#InterruptSafeRoutinesByManager">Interrupt-Safe Routines by Manager</A><BR><BR><A HREF="#Summary">Summary of Interrupt-Safe Routines</A><BR><BR><A HREF="#references">References</A><BR><BR><A HREF="#Changes">Change History</A><BR><BR><A HREF="#Downloads">Downloadables</A></p>					 <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left>			<!-- begin_intro_text -->			<p id="introtext">				The                  traditional Mac OS has a badly defined set of                  heterogeneous programming environments. In some of                  these environments, your code can access some                  system services but not others. Furthermore, the                  names given to these environments are often                  overloaded and confusing. This results in a lot of                  programmer confusion.			</p>			<p id="introtext">				This Technote attempts to clear up this                  confusion by assigning each of the execution levels                  a unique name, describing how and why your code                  might find itself running at a particular execution                  level, and outlining the restrictions your code                  might face when running at that level.			</p>			<p id="introtext">				This Technote is important for anyone                  programming any Mac OS code that might run at                  "interrupt time," and vital for anyone doing                  system-level programming under the traditional Mac                  OS. 			</p><!-- end_intro_text --><!-- begin_date --><h3>&nbsp;Updated: [Nov 08 1998]</h3><!-- end_date -->        </td>    </tr></table> <!-- end_header_box --><BR><BR><hr width=500 align=center><BR><BR><!-- begin_content -->         <P><A NAME=Introduction></A></P>                  <H2>Introduction</H2>                  <P>There has been much confusion about which Mac OS routines         can be used at interrupt time and which cannot. This         Technote lists the Mac OS routines which can be used at         interrupt time.</P>                  <P>This Technote list routines which are safe at interrupt         time, rather than those that are unsafe. As the system         evolves, more routines are added, and it may become         necessary to do more work in existing routines. So routines         that just happen to be interrupt safe may become otherwise.         Thus, any list of interrupt-unsafe routines will grow over         time, and consequently is hard to maintain. A list of         routines that are safe is more likely to remain         accurate.</P>                  <P>DTS recommends that you assume all routines absent from         this list are unsafe to call at interrupt time. This is a         general defensive programming guideline, not a definitive         pronouncement. If you know of a routine that you always         considered to be interrupt safe that is not listed here,         please <a href="http://developer.apple.com/contact/feedback.html">let us know</A>. As         an example of how your feedback is valuable to us, the first         version of this technote failed to mention that <A HREF="#QuickDraw"><CODE>SetCursor</CODE></A>         was interrupt safe. This was an obvious omission which has         now been corrected, and it's likely that there are         others.</P>                  <P>A interrupt-safe routine can become unsafe if it is         patched inappropriately. When you patch a routine which is         interrupt safe, you should assume that your patch is running         at interrupt time and avoid doing things that are <A HREF="#CanDo">illegal         at interrupt time</A>.</P>                  <CENTER><TABLE BORDER=0 CELLPADDING=3 WIDTH=550>            <TR>               <td bgcolor="#e6e6e6" align=left>                  <P><B>Note:</B><BR>                  DTS still recommends against patching, as it has                  always has. The above comments reflect the                  pragmatic attitude that, if you're going to patch,                  you should do it correctly.</P>               </TD>            </TR>         </TABLE>         </CENTER>         <BR><BR>         <P>The old <I>Inside Macintosh</I>, volume 6, appendix B had         a list of routines which can be called at interrupt time.         This Technote is an updated list of those routines, along         with comments as appropriate. Do not rely on the list of         interrupt-safe routines in <I>Inside Macintosh</I>, volume         6, appendix B.</P>                  <BR><P><A HREF="#top">Back to top</A></P>         <BR><BR>                           <P><A NAME=ExecutionLevels></A></P>                  <H2>Execution Levels</H2>                  <P>The traditional Mac OS supports the following execution         levels:</P>                  <UL>            <LI>Hardware Interrupt</LI>                        <LI>Deferred Task</LI>                        <LI>System Task</LI>         </UL>                  <P>In addition, the native device driver model defines the         following execution levels:</P>                  <UL>            <LI>Native-Hardware Interrupt</LI>                        <LI>Secondary Interrupt</LI>                        <LI>Task</LI>                        <LI>Software Interrupt</LI>         </UL>                  <P>Since these execution levels are modeled after the         execution levels supported by Copland, their implementation         on the traditional Mac OS is somewhat imprecise. In broad         terms, the following analogies apply:</P>                  <UL>            <LI>native-hardware interrupt <I>is like</I> hardware            interrupt</LI>                        <LI>secondary interrupt <I>is like</I> deferred task</LI>                        <LI>task <I>is like</I> system task</LI>                        <LI>software interrupt <I>is</I> not supported</LI>         </UL>                  <P>However, the distinction between these analogous pairs is         important in certain circumstances, as explained later in         this note.</P>                  <BR>                  <CENTER><TABLE BORDER=0 CELLPADDING=3 WIDTH=550>            <TR>               <td bgcolor="#e6e6e6" align=left>                  <P><B>Note:</B><BR>                  You can read more about native device driver                  execution levels in                   Designing PCI Cards and Drivers for Power Macintosh                  Computers, page 67.</P>               </TD>            </TR>         </TABLE></CENTER>                  <BR><BR>                  <CENTER><TABLE BORDER=0 CELLPADDING=3 WIDTH=550>            <TR>               <td bgcolor="#e6e6e6" align=left>                  <P><B>IMPORTANT:</B><BR>                  This Technote does not discuss the PowerPC hardware                  interrupt mechanism. On PowerPC computers running                  the traditional Mac OS, PowerPC hardware interrupts                  are handled by a nanokernel, which routes the                  interrupt through the 68K emulator. Where this note                  references 68K-specific concepts, you can safely                  assume that this behavior is emulated by the                  low-level PowerPC system software on machines with                  PowerPC processors.</P>               </TD>            </TR>         </TABLE></CENTER>                  <BR><BR>                  <CENTER><TABLE BORDER=0 CELLPADDING=3 WIDTH=550>            <TR>               <td bgcolor="#e6e6e6" align=left>                  <P><B>IMPORTANT:</B><BR>                  The execution level is largely independent of the                  processor interrupt mask, i.e., the value stored in                  the 680x0 SR register. The                  interrupt mask is not a reliable way to detect                  whether you are at "interrupt time." See                  <A HREF="#DeterminingExecutionLevel">Determining                  the Execution                  Level</A> for                  details.</P>               </TD>            </TR>         </TABLE></CENTER>                 <BR><BR>                  <P>This remainder of this section describes each of         the execution levels in detail.</P>                  <BR><BR>         <H3>Hardware Interrupt</H3>         <P>         <B>What is it?</B></P>                  <P>Hardware interrupt-level execution happens as a direct         result of a hardware interrupt request. Software executed at         hardware interrupt level includes installable interrupt         handlers for NuBus and other devices, as well as interrupt         handlers supplied by Apple.</P>         <P>         <B>How do you get there?</B></P>                  <P>You get to hardware interrupt level as the direct result         of a installing a hardware interrupt handler (e.g., a NuBus         handler installed with <CODE>SIntInstall</CODE> or by         changing the interrupt vector tables in low memory) or by         being called by something that is directly invoked by a         hardware interrupt handler (e.g., a SCSI Manager 4.3         completion routine). Note that Time Manager tasks and VBLs         are also executed at hardware interrupt level.</P>         <P>         <B>What can you do there?</B></P>                  <P>Hardware interrupts are considered "interrupt time" as         defined by the toolbox, Virtual Memory Manager, and Open         Transport. The associated restrictions are described         <A HREF="#OtherLevels">later in this document</A>.</P>                  <P>In addition, you should make every attempt to minimize         the amount of time you spend at hardware interrupt level.         Hardware interrupt level requires that all interrupts with         lower interrupt priority be disabled for the duration of the         hardware interrupt handler. The longer you spend in your         hardware interrupt handler, the longer the interrupt latency         of the computer will be. Increased interrupt latency may         result in a poor user experience -- such as sound breakup or         mouse tracking problems -- or worse. If you need to do         extended processing at interrupt time, you should schedule a         deferred task (using <CODE>DTInstall</CODE>) to perform the         operation.</P>         <P>         <B>Is paging safe?</B></P>                  <P>Paging is not safe at hardware interrupt level unless the         interrupt has been deferred using <CODE>DeferUserFn</CODE>.         Some system interrupt handlers (Device Manager completion         routines, VBLs, slot VBLs, Time Manager tasks) automatically         defer their operation until VM-safe time, but other hardware         interrupt handlers must be sure not to cause page faults. If         you need to access memory that might page fault, you should         defer that operation using <CODE>DeferUserFn</CODE>.</P>                  <BR><BR>         <CENTER><TABLE BORDER=0 CELLPADDING=3 WIDTH=550>            <TR>               <td bgcolor="#e6e6e6" align=left>                  <P><B>Note:</B><BR>                  Do not confuse the semantics of                  <CODE>DeferUserFn</CODE>, which defers a hardware                  interrupt until paging is safe, with those of                  <CODE>DTInstall</CODE>, which schedules a deferred                  task to be executed when interrupts are                  re-enabled.</P>               </TD>            </TR>         </TABLE>         </CENTER>         <BR><BR>                           <H3>Deferred Task</H3>         <P>         <B>What is it?</B></P>                  <P>A deferred task is a mechanism whereby hardware         interrupt-level code can schedule a routine to be executed         when interrupts have been re-enabled, but before the return         from the interrupt. Hardware interrupt handlers do this in         order to minimize the amount of time spent in the hardware         interrupt handler, and thereby minimize system interrupt         latency.</P>         <P>         <B>How do you get there?</B></P>                  <P>The most common way to get to deferred task level is to         have your hardware interrupt handler call         <CODE>DTInstall</CODE> to schedule a routine, which the         system calls back at deferred task time. The interrupt         system executes deferred tasks just before returning from         interrupts, but after re-enabling interrupts.</P>                  <P>You can also get to deferred task level by being called         by something that is executing at deferred task level. A         good example of this are Open Transport notifier functions,         which are often called at deferred task level.</P>         <P>         <B>What can you do there?</B></P>                  <P>Deferred tasks are considered "interrupt time" as defined         by the toolbox. The associated restrictions are described         <A HREF="#OtherLevels">later in this document</A>.</P>         <P>         <B>Is paging safe?</B></P>                  <P>Paging is safe at deferred task level.</P>         <P>         <B>Special Considerations</B></P>                  <P>Another useful feature of deferred tasks is that they are         serialized. The system will not interrupt a deferred task in         order to run another deferred task. This makes a really neat         mutual exclusion mechanism.</P>                  <BR><BR>                  <H3>System Task</H3>         <P>         <B>What is it?</B></P>                  <P>System task level is the level at which most application         code runs.</P>                  <P>The name is derived from an obsolete Mac OS system call,         <CODE>SystemTask</CODE>. Prior to the introduction of         MultiFinder (now known as the Process Manager), applications         were required to call <CODE>SystemTask</CODE> at regular         intervals to allow device drivers time to do things that         could not be done at interrupt time.</P>         <BR><BR>         <CENTER><TABLE BORDER=0 CELLPADDING=3 WIDTH=550>            <TR>               <td bgcolor="#e6e6e6" align=left>                  <P><B>Note:</B><BR>                  The <CODE>SystemTask</CODE> routine itself is now                  obsolete because <CODE>WaitNextEvent</CODE>                  automatically calls it for you. However, the name                  lives on as a testament to those hardy Mac OS                  pioneers who actually had to call it.</P>               </TD>            </TR>         </TABLE>         </CENTER>         <BR><BR><P>         <B>How do you get there?</B></P>                  <P>An application's main entry point is called at system         task level. Cooperatively scheduled Thread Manager threads         also run at system task level. For other types of code,         <A HREF="tn1033.html"> Technote 1033: "Interrupts in Need of         (a Good) Time"</A> describes how to get to system task level         from interrupt level.</P>         <P>         <B>What can you do there?</B></P>                  <P>Code running at system task level is not considered         "interrupt time" by anything. You can do virtually anything         at system task level.</P>         <P>         <B>Is paging safe?</B></P>                  <P>By default paging is safe at system task level. The         exceptions occur when your code is accessing some resource         that the system needs to support paging. For example, if you         obtain exclusive access to the SCSI bus using         <CODE>SCSIGet</CODE>, you must not cause a page fault even         at system task level.</P>                  <BR><BR>                  <H3>Native Hardware Interrupt</H3>         <P>         <B>What is it?</B></P>                  <P>Native hardware interrupt level is virtually identical to         normal hardware interrupt level except that it only comes         into play on machines that have the native driver         architecture.</P>                  <BR><BR>         <CENTER><TABLE BORDER=0 CELLPADDING=3 WIDTH=550>            <TR>               <td bgcolor="#e6e6e6" align=left>                  <P><B>Note:</B><BR>                  The native in the name of this level does not imply                  fully native-interrupt processing. Under the                  traditional Mac OS, the nanokernel vectors all                  interrupts through the 68K emulator in order to                  ensure 68K interrupt priorities and instruction                  atomicity. Therefore, even native hardware                  interrupts involve Mixed Mode Manager switches.</P>               </TD>            </TR>         </TABLE>         </CENTER>         <BR><BR>                  <P>         <B>How do you get there?</B></P>                  <P>You get to native hardware interrupt level by installing         a hardware interrupt handler using the native Interrupt         Manager, or by being called by something that is directly         invoked by such a handler.</P>         <P>         <B>What can you do there?</B></P>                  <P>Native hardware interrupts are considered "interrupt         time" as defined by the toolbox, Virtual Memory Manager and         Open Transport. The associated restrictions are described         <A HREF="#OtherLevels">later in this document</A>.</P>                  <P>As with code running at hardware interrupt level, you         should make every attempt to minimize the amount of time you         spend at native hardware interrupt level. If you need to do         extended processing in response to a native hardware         interrupt, you should schedule a secondary interrupt (using         <CODE>QueueSecondaryInterruptHandler</CODE>) to continue the         interrupt processing.</P>         <P>         <B>Is paging safe?</B></P>                  <P>Paging is not safe at native hardware interrupt         level.</P>                  <BR><BR>         <H3>Secondary Interrupt</H3>         <P>         <B>What is it?</B></P>                  <P>The native driver model provides secondary interrupts --         which are much like deferred tasks -- allowing native         drivers to defer complex processing in order to minimize         interrupt latency.</P>         <P>         <B>How do you get there?</B></P>                  <P>You can get to secondary interrupt level by having your         native hardware interrupt handler call         <CODE>QueueSecondaryInterruptHandler</CODE> to schedule a         routine which the system calls back at secondary interrupt         level. The interrupt system executes secondary interrupts         after re-enabling interrupts but before running deferred         tasks and returning from the interrupt handler.</P>                  <P>You can also execute a secondary interrupt handler         directly from task level using         <CODE>CallSecondaryInterruptHandler2</CODE>.</P>         <P>         <B>What can you do there?</B></P>                  <P>Secondary interrupts are considered "interrupt time" as         defined by the toolbox, Virtual Memory Manager and Open         Transport. The associated restrictions are described         <A HREF="#OtherLevels">later in this document</A>.</P>         <P>         <B>Is paging safe?</B></P>                  <P>Paging is not safe at secondary interrupt level.</P>                  <BR><BR>         <H3>Task</H3>         <P>         <B>What is it?</B></P>                  <P>Under the traditional Mac OS, the native driver model         defines task level to be any code that's not at native         hardware interrupt level and not at secondary interrupt         level.</P>         <P>         <B>How do you get there?</B></P>                  <P>The most common source of task level execution is         standard system task level execution, i.e., normal         application code. However, other execution levels that are         traditionally considered to be interrupt levels, such as         non-native hardware interrupts and deferred tasks, are also         considered to be task level. Remember that under the         traditional Mac OS, task level is defined as either non-         native interrupt level or secondary interrupt level.</P>         <P>         <B>What can you do there?</B></P>                  <P>The environment restrictions of task level are defined by         the underlying execution level that's really being         executed.</P>         <P>         <B>Is paging safe?</B></P>                  <P>The native driver model defines that paging is always         safe at task level. However, on the traditional Mac OS,         paging is only safe at task level if the underlying         execution level defines it to be safe.</P>                  <BR><BR><A NAME=SoftwareInterrupt></A>         <H3>Software Interrupt</H3>         <P>         <B>What is it?</B></P>                  <P>The native driver model defines the concept of a software         interrupt, the ability to force a task to immediately         execute a routine in the context of that task. This is         distinct from, but commonly confused with, secondary         interrupt level.</P>         <P>         <B>How do you get there?</B></P>                  <P>Software interrupts are not supported under Mac OS. This         is clearly stated in Designing         PCI Cards and Drivers for Power Macintosh Computers,         page 262:</P>                  <BLOCKQUOTE>Currently, <CODE>SendSoftwareInterrupt</CODE>            calls the user back at the same execution level. In            future versions of Mac OS it can be used to force            execution of code that can't be called at interrupt time.</BLOCKQUOTE>                  <P>This means is that if you call         <CODE>SendSoftwareInterrupt</CODE> at execution level X, the         software interrupt will run at execution level X. This makes         software interrupts effectively useless on the traditional         Mac OS.</P>         <P>         <B>What can you do there?</B></P>                  <P>Software interrupts are defined to run at task level, in         the context of the task to which the software interrupt was         sent.</P>         <P>         <B>Is paging safe?</B></P>                  <P>The native driver model defines that paging is always         safe at software interrupt level.</P>         <BR><BR>         <CENTER><TABLE BORDER=0 CELLPADDING=3 WIDTH=550>            <TR>               <td bgcolor="#e6e6e6" align=left>                  <P><B>Note:</B><BR>                  When the native driver model was designed, it was                  designed with Copland in mind. The goal was that a                  native driver (binary, not source) would run                  without modification on both the traditional Mac OS                  and Copland. A lot of effort was put into both                  operating systems to support this goal.</P>                                    <P>In general, the support for the native driver                  model on the traditional Mac OS is acceptable.                  However, in some cases, it is just not possible to                  support features of Copland under the traditional                  Mac OS. The most obvious of these is software                  interrupts. These require significant microkernel                  support and were not implemented on the traditional                  Mac OS.</P>                                    <P>Given that Copland is dead, software interrupts                  linger on in name only, the vestigial appendix on                  the intestine that is the native driver model.</P>               </TD>            </TR>         </TABLE>         </CENTER>         <BR><BR>                  <BR><P><A HREF="#top">Back to top</A></P>                  <BR><BR>                  <P><A NAME=OtherLevels></A></P>                  <H2>Execution Levels in Other Documentation</H2>                  <P>In general, the following execution levels are considered         to be "interrupt time."</P>                  <UL>            <LI>Hardware Interrupt</LI>                        <LI>Deferred Task</LI>                        <LI>Native Hardware Interrupt</LI>                        <LI>Secondary Interrupt</LI>         </UL>                  <P>However, the use of the term "interrupt time" can vary         from manager to manager. This section documents some of the         more confusing cases.</P>                  <H3>Toolbox</H3>                  <P>Most toolbox routines cannot be called at "interrupt         time," as it is defined above.</P>                  <P>There are many different reasons why toolbox routines         cannot be called at interrupt time. Some routines, like all         of the Memory Manager, rely on global data structures that         are not interrupt safe. Other routines might move or purge         unlocked handles, which is equivalent to calling the Memory         Manager. Still others, like synchronous calls to the File         Manager, are architecturally inaccessible. Finally, some         routines, like <CODE>ReadDateTime</CODE>, rely on interrupts         in order to complete, and hence cannot be called when         interrupts are disabled.</P>                  <P>The fact that a routine doesn't move or purge memory does         not mean it is interrupt safe.</P>                  <H3>Virtual Memory Manager</H3>                  <P>The Virtual Memory Manager documentation (<a href="http://developer.apple.com/documentation/mac/Memory/Memory-151.html">         chapter 3 of <I>Inside Macintosh: Memory</I></A> and         <A HREF="../me/me_09.html">Technote ME 09: "Coping with VM         and Memory Mappings"</A>) says that page faults are not         allowed at "interrupt time." This has caused a lot of         confusion among programmers who have heard that, for         example, Device Manager completion routines are "interrupt         time," and hence assume that paging is unsafe in MacTCP         completion routines. In the light of the above description,         it's easy to clear up that confusion.</P>                  <P>As far as the Virtual Memory is concerned, "interrupt         time" means any hardware interrupt that hasn't been deferred         by VM itself or using <CODE>DeferUserFn</CODE>. So it is         safe to take page faults from Device Manager completion         routines, even though other documentation might refer to         that execution level as "interrupt time."</P>                  <P>For the full story about virtual memory on the         traditional Mac OS, check out <A HREF="tn1094.html">Technote         1094: "Virtual Memory Application Compatibility"</A>.</P>                  <H3>Open Transport</H3>                  <P>The original Open Transport documentation caused much         confusion by saying that Open Transport could not be called         at "interrupt time." This means that you can only call Open         Transport from system task level or deferred task level. So         you can call Open Transport at execution levels that would         normally be considered "interrupt time" (specifically, from         a deferred task) as long as you don't call it from hardware         interrupt level (or native hardware or secondary interrupt         levels).</P>                  <P>This confusion has been cleared up in the latest release         of <a href="http://developer.apple.com/documentation/mac/NetworkingOT/NetworkingWOT-2.html">Inside         Macintosh: Networking with Open Transport</A>, which has an         extensive table of which Open Transport routines can be         called from which execution levels.</P>                  <BR><P><A HREF="#top">Back to top</A></P>                           <P><A NAME=DeterminingExecutionLevel></A></P>                  <H2>Determining the Execution         Level</H2>                  <P>There is no good general purpose         way to determine the current execution level. In general,         your code must know in advance the level at which it is         executing. However, there are a number of mechanisms that         work for specific environments. The following sections         describe those mechanisms and their flaws.</P>                  <H3>Tracking Interrupts         Yourself</H3>                  <P>One solution for determining the         current execution level is to track interrupts yourself. The         code in Listing 1 outlines how you can do this.</P>                   <BR><BR>                   <CENTER><TABLE BORDER=0 CELLPADDING=0 WIDTH=550>            <TR>               <td align="left">                  <P>&nbsp;<B>Listing 1</B>.                  Tracking the interrupt level yourself.</P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>static SInt32 gMyInterruptDepth = 0;static void MyIOCompletion(ParmBlkPtr pb){    (void) AddAtomic(1, &amp;gMyInterruptDepth);    ... your code goes here ...    (void) AddAtomic(-1, &amp;gMyInterruptDepth);}static OSStatus MyCommonCode(void)    // This code may be called at interrupt or non-interrupt time.{    if (gMyInterruptDepth == 0) {        ... run interrupt-safe code ...    } else {        ... run system task code ...    }}</pre></TD></TR></TABLE></CENTER><BR><BR>               </TD>            </TR>         </TABLE></CENTER>                   <BR><BR>                  <CENTER><TABLE BORDER=0 CELLPADDING=3 WIDTH=550>            <TR>               <td bgcolor="#e6e6e6" align=left>                  <P><B>IMPORTANT:</B><BR>                  The code in Listing 1 code adjusts                  <CODE>gMyInterruptCountDepth</CODE> using an atomic                  operation. This ensures that the operation yields                  the correct results even if it's interrupted by                  another nested interrupt.</P>               </TD>            </TR>         </TABLE>          </CENTER>                    <BR><BR>                   <P>This technique works well if you         know the execution level of all entry points to your code.         However, it fails when your code can be called at unknown         execution levels. For example, a disk driver's Prime entry         point can be called at a variety of execution         levels.</P>                  <H3>Testing the Interrupt         Mask</H3>                  <P>A common mistake made by developers         is to assume that a non-zero 68K interrupt mask (bits 8         through 10 of the 680x0 SR register) indicates that the         processor is running at 'interrupt time'. This is an         incorrect assumption. It provides both false negatives and         false positives.</P>                  <UL>            <LI>In some cases, such as when            running a deferred task or a secondary interrupt, the            interrupt mask is 0 while inside an interrupt            context.</LI>                        <LI>In other cases the interrupt            mask is non-zero at system task time. Numerous older            parts of the system, for example the <CODE>Enqueue</CODE>            routine, disable interrupts to guarantee mutual            exclusion.</LI>         </UL>                  <H3>Open Transport</H3>                  <P>Open Transport provides three         routines, <CODE>OTIsAtInterruptLevel</CODE>,         <CODE>OTCanLoadLibraries</CODE>, and         <CODE>OTCanMakeSyncCall</CODE>, that you might think useful         in determining the current execution level. However, these         routines only work correctly within contexts in which it is         legal to call Open Transport. Specifically, you can call         these routines and get meaningful results in the following         situations.</P>                  <UL>            <LI>from system task            level</LI>                        <LI>from a deferred            task</LI>                        <LI>from an OT notifier (these run            at deferred task time, so this is simply a specialization            of the previous point)</LI>                        <LI>from arbitrary 'interrupt            time', if you have follow the OT rule that all interrupt            routines (other than deferred tasks) must call            <CODE>OTEnterInterrupt</CODE> on entry and            <CODE>OTLeaveInterrupt</CODE> on exit</LI>         </UL>                  <P>As an example of where these         routines go wrong, if you call         <CODE>OTCanMakeSyncCall</CODE> from secondary interrupt         level on older systems you will find that it returns         true!</P>                  <P>The upshot of this is that these         Open Transport routines are helpful for OT programmers, but         do not solve the problem in general.</P>                  <H3>CurrentExecutionLevel</H3>                  <P>DriverServicesLib, introduced with         the first PCI Power Macintosh computers, exports a routine         called <CODE>CurrentExecutionLevel</CODE> that purports to         return the execution level of the currently running code.         <CODE>CurrentExecutionLevel</CODE> is accurate within the         contexts supported by the native driver model, but it is not         useful outside of those contexts. </P>                  <P>As originally implemented,         <CODE>CurrentExecutionLevel</CODE> used the algorithm shown         in Listing 2.</P>         <BR><BR>         <CENTER><TABLE BORDER=0 CELLPADDING=0 WIDTH=550>            <TR>               <td align="left">                  <P>&nbsp;<B>Listing 2</B>.                  The original <CODE>CurrentExecutionLevel</CODE>                  algorithm.</P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>if we're in the context of a native hardware interrupt then  return kHardwareInterruptLevelelse if we're in the context of a secondary interrupt then  return kSecondaryInterruptLevelelse  return kTaskLevelend if</pre></TD></TR></TABLE></CENTER><BR><BR>               </TD>            </TR>         </TABLE>          </CENTER>         <BR><BR>         <P>This algorithm works fine within         the execution levels supported by DriverServicesLib, but it         does not account for execution levels outside of the native         driver model. For example, if you call this version of         <CODE>CurrentExecutionLevel</CODE> from a deferred task or a         Time Manager task the result is <CODE>kTaskLevel</CODE>         (unless you happen to have interrupted some native driver         processing). For some background on why this routine doesn't         work properly, see DTS Q&amp;A DV 43 <a href="../../qa/dv/dv43.html">InterfaceLib         and Native         Drivers</A>.</P>                  <P>In recent systems         <CODE>CurrentExecutionLevel</CODE> has changed         [2323165] to more accurately reflect the execution         level of non-DriverServicesLib environments. Modern systems         maintain a count of the number of times an interrupt (any         interrupt, including native hardware interrupts and other,         older, interrupt sources such as the Time Manager) has been         dispatched. The <CODE>CurrentExecutionLevel</CODE> algorithm         was modified to use that count, as shown in Listing         3.</P>         <BR><BR>         <CENTER><TABLE BORDER=0 CELLPADDING=0 WIDTH=550>            <TR>               <td align="left">                  <P>&nbsp;<B>Listing 3</B>.                  The updated  <CODE>CurrentExecutionLevel</CODE>                  algorithm.</P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>if we're in the context of a native hardware interrupt then  return kHardwareInterruptLevelelse if we're in the context of a secondary interrupt then  return kSecondaryInterruptLevelelse  if interrupt depth is zero then    return kTaskLevel  else    return kHardwareInterruptLevel  end ifend if</pre></TD></TR></TABLE></CENTER><BR><BR>               </TD>            </TR>         </TABLE>          </CENTER>         <BR><BR>         <P>Therefore         <CODE>CurrentExecutionLevel</CODE> is an accurate indication         of the current execution level only if uses the new         algorithm. Given that numerous machines still use the old         algorithm (for example, all non-ROM-in-RAM computers),         <CODE>CurrentExecutionLevel</CODE> is not a general purpose         solution to this problem.</P>         <BR><BR>         <CENTER><TABLE BORDER=0 CELLPADDING=3 WIDTH=550>            <TR>               <td bgcolor="#e6e6e6" align=left>                  <P><B>Note:</B><BR>                  This raises the question, how                  do you detect which version of                  <CODE>CurrentExecutionLevel</CODE> is implemented?                  The code for doing this is <A HREF="#Downloads">available                  for download at the end of this                  technote</A>. The code                  is complicated by the fact that the first systems                  to include the new                  <CODE>CurrentExecutionLevel</CODE> algorithm                  shipped as Mac OS version 9.0.4; the change was in                  the Mac OS ROM file (the <a href="tn1167.html">NewWorld</A>                  ROM) not in the System file itself.</P>               </TD>            </TR>         </TABLE>         </CENTER>         <BR><BR>         <H3>TaskLevel</H3>                  <P>Mac OS 9.0 introduced a new system         routine, <CODE>TaskLevel</CODE>, that was intended to assist         in debugging. To emphasize this, <CODE>TaskLevel</CODE> is         declared in "Debugging.h" and exported from DebugLib. The         prototype and result mask constants are shown in Listing         4.</P>                  <P>&nbsp;<B>Listing 4</B>.                  <CODE>TaskLevel</CODE> prototype and                  constants.</P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>enum {    k68kInterruptLevelMask      = 0x00000007,    kInVBLTaskMask              = 0x00000010,    kInDeferredTaskMask         = 0x00000020,    kInSecondaryIntHandlerMask  = 0x00000040};extern pascal UInt32 TaskLevel(void);</pre></TD></TR></TABLE></CENTER><BR><BR>        <BR><BR>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Warning:</B><BR>                  The result from <CODE>TaskLevel</CODE> is only an                  approximate answer to the question of what is the                  current execution level. It is helpful for                  debugging, but you should not use it for making                  non-debugging run-time decisions (such as whether                  to read a file synchronously or                  asynchronously).</P></TD></TR></TABLE></CENTER><BR><BR>                  <P>The idea behind         <CODE>TaskLevel</CODE> is that you can use it to add         debugging code to your software to detect when it has been         called inappropriately. For example, if you're writing a         driver and certain sections allocate memory from the system         heap, and thus only be called at system task level, you can         use <CODE>TaskLevel</CODE> to detect if you've accidentally         called that code at interrupt time. An example of this is         shown in Listing 5.</P>         <BR><BR>                  <P>&nbsp;<B>Listing 5</B>. An                  example of using <CODE>TaskLevel</CODE> for                  debugging.</P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>static DrvQElPtr MyCreateDriveQueueElement(DeviceIdent id){    DrvQElPtr result;    assert(TaskLevel() == 0);    result = (DrvQElPtr) NewPtrSysClear(sizeof(MyDrvQEl));    if (result != nil) {        ... fill out fields ...    }    return result;}</pre></TD></TR></TABLE></CENTER><BR><BR>               <BR><P><A HREF="#top">Back to top</A></P>                  <P><A NAME=CanDo></A></P>                  <H2>What Interrupt Routines Can't Do</H2>                  <P>Code running at "interrupt time" cannot do everything         that system task code can do. The following list summarizes         the operations that interrupt routines should not perform.         An interrupt routine which violates any of these rules may         cause a system crash:</P>                  <UL>            <LI>An interrupt routine must not allocate, move, or            purge memory using the Mac OS Memory Manager.</LI>                        <LI>An interrupt routine cannot rely on the state of any            unlocked handle.</LI>                        <LI>An interrupt routine must not call any Memory Manager            routine which sets the low memory global            <CODE>MemErr</CODE>.</LI>                        <LI>An interrupt routine must not call any Mac OS            routines that violate the above.</LI>                        <LI>An interrupt routine must not do synchronous I/O.            This includes File Manager, Device Manager, PPC Toolbox,            and Open Transport I/O.</LI>                        <LI>For 68K code, an interrupt routine cannot access            application global variables unless it sets up the            application's A5 world properly. This technique is            explained in the <a href="http://developer.apple.com/documentation/mac/Memory/Memory-181.html">Accessing            Application Globals in a VBL Task</A> section of            <a href="http://developer.apple.com/documentation/mac/Memory/Memory-2.html">Inside            Macintosh: Memory</A>.</LI>                        <LI>For 68K code, an interrupt routine cannot call a            routine from another code segment unless the segment is            loaded in memory and linked into the code's jump table.            In addition, the code must established the correct A5            world before calling across segments at interrupt            time.</LI>                        <LI>As a special case of the above, some of the routines            described in <I>Inside Macintosh</I> (for example,            <CODE>BitAnd</CODE>, <CODE>HiWord</CODE>) are actually            implemented as glue that is statically linked to your            program. It's important to remember that this glue may be            in another segment and, even though the routine itself            does not move memory, the act of calling it might.</LI>                        <LI>CFM-68K code must comply with the requirements            outlined in <A HREF="tn1084.html">Technote 1084: "Running            CFM-68K Code at Interrupt Time: Is Your Code at            Risk?"</A></LI>         </UL>                  <BR><P><A HREF="#top">Back to top</A></P>                           <P><A NAME=InterruptSafeRoutinesByManager></A></P>                  <H2>Interrupt-Safe Routines by Manager</H2>                  <P>This section describes various interrupt-safe routines,         grouped by manager.</P>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>                  This list is intended only to document those                  routines which should always be safe to call at                  interrupt time. There may be other routines, not                  documented here, which are safe by virtue of their                  current implementation. You should not rely on such                  routines continuing to be interrupt safe.</P></TD></TR></TABLE></CENTER><BR><BR>         <H3><A NAME=MemoryManager></A>Memory Manager</H3>                  <P>There are very few Memory Manager routines that you can         safely call at interrupt time. The most common exceptions         are <CODE>BlockMove</CODE> (including         <CODE>BlockMoveData</CODE> and other variants) and         <CODE>StripAddress</CODE>; these two routines may be safely         made at all execution levels. At interrupt time, you cannot         allocate, move, or purge memory (either directly or         indirectly). You should never rely on the validity of         handles to unlock blocks.</P>                  <P>There are some routines documented in <a href="http://developer.apple.com/documentation/mac/Memory/Memory-2.html">Inside         Macintosh: Memory</A> that are safe. The entire suite of         debugger routines are interrupt safe. This includes         <CODE>DebuggerEnter</CODE>, <CODE>DebuggerExit</CODE>,         <CODE>DebuggerGetMax</CODE>,         <CODE>DebuggerLockMemory</CODE>, <CODE>DebuggerPoll</CODE>,         <CODE>PageFaultFatal</CODE>,         <CODE>DebuggerUnlockMemory</CODE>, <CODE>SwapMMUMode</CODE>,         and <CODE>Translate24to32</CODE>.</P>                  <P>The Virtual Memory Manager routines         <CODE>GetPageState</CODE>, <CODE>GetPhysical</CODE>,         <CODE>DeferUserFN</CODE>, <CODE>UnholdMemory</CODE>, and         <CODE>UnlockMemory</CODE> are interrupt safe.</P>                  <P>The Virtual Memory Manager routines         <CODE>HoldMemory</CODE>, <CODE>LockMemory</CODE>,         <CODE>LockMemoryContiguous</CODE>, and         <CODE>LockMemoryForOutput</CODE> are interrupt safe if you         guarantee that either page faults are allowed or, if paging         is unsafe, that the routines will not cause a page fault.         For example, it's safe to call <CODE>LockMemory</CODE> on         memory that you can guarantee is held.</P>                  <P>No other Memory Manager routines are interrupt safe, for         one or more of the following reasons:</P>                  <OL>            <LI>They clear the low-memory global <CODE>MemErr</CODE>,            which is returned by the Memory Manager call            <CODE>MemError</CODE>. Applications regularly use            <CODE>MemError</CODE> to examine the result of the            previous Memory Manager operation and may not properly            detect a memory error if <CODE>MemErr</CODE> changes at            interrupt time.</LI>                        <LI>They allocate, move, or purge memory, or rely on the            state of unlocked handles.</LI>                        <LI>They examine data structures that can be in an            inconsistent state at interrupt time.<BR>            </LI>         </OL><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>                  Developers sometimes think "Calling a routine that                  doesn't move memory (like                  <CODE>DisposeHandle</CODE>) should be safe as long                  as I save and restore the value of                  <CODE>MemErr</CODE>." <STRONG>This is not                  true</STRONG> because of point 3 above.</P></TD></TR></TABLE></CENTER><BR><BR>                  <P>Specifically, do not call <CODE>StackSpace</CODE> at         interrupt time. <CODE>StackSpace</CODE> operates by         comparing two low memory globals in the current process low         memory globals. At interrupt time you are not guaranteed         that you are even in a valid process.         <CODE>StackSpace</CODE> also clears the low memory global         <CODE>MemErr</CODE>, which is returned by the Memory Manager         call <CODE>MemError</CODE>. Applications regularly uses         <CODE>MemError</CODE> to examine the result of the previous         Memory Manager operation, and may not properly detect a         memory error if <CODE>MemErr</CODE> changes at interrupt         time.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>                  Unfortunately, there is some shipping software that                  calls <CODE>StackSpace</CODE> at interrupt time. Even                  more unfortunately, Apple has -- in the past --                  shipped software that calls <CODE>StackSpace</CODE> at                  interrupt time.</P>                                    <P>Apple is committed to eliminating bugs like this                  from its system software, and DTS recommends that                  developers continue to rely on the results of                  <CODE>MemError</CODE>. However, the paranoid                  developer may wish to implement a wrapper for                  common Memory Manager routines, as shown below:</P></TD></TR></TABLE></CENTER><BR><BR>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>static OSErr MyNewHandle(Size byteCount, Handle *result){    OSErr err;&nbsp;    Assert(result != nil);    err = noErr;    *result = NewHandle(byteCount);    if (*result == nil) {        err = MemError();        Assert(err != noErr);        if (err == noErr) {            err = memFullErr;        }    }    return err;}</pre></TD></TR></TABLE></CENTER><BR><BR>                       <H3><A NAME=OperatingSystemUtilities></A>Operating System         Utilities</H3>                  <P><CODE>Enqueue</CODE> and <CODE>Dequeue</CODE> are interrupt safe,         and may be used at any time. <CODE>FormatRecToString</CODE>         (formerly <CODE>Format2Str</CODE>), <CODE>StringToExtended</CODE>         (formerly <CODE>FormatX2Str</CODE>), and         <CODE>ExtendedToString</CODE> (formerly <CODE>FormatStr2X</CODE>)         are interrupt safe as well.         </P>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>                  Do not call <CODE>ReadLocation</CODE> at interrupt                  time. <CODE>ReadLocation</CODE> needs to get                  information from the parameter RAM (PRAM), using                  the poorly documented <CODE>ReadXPRAM</CODE> routine.                  Some Mac OS computers communicate with parameter                  RAM via interrupts. If you call <CODE>ReadXPRAM</CODE>,                  or any routine which calls <CODE>ReadXPRAM</CODE>, at                  interrupt time, the call may hang your system.</P></TD></TR></TABLE></CENTER><BR><BR>         <H3><A NAME=DeviceManager></A>Device Manager</H3>                  <P>The core Device Manager traps (<CODE>_Open</CODE>,         <CODE>_Read</CODE>, <CODE>_Write</CODE>,         <CODE>_Control</CODE>, <CODE>_Status</CODE>,         <CODE>_Close</CODE>) are interrupt safe in some cases. Some         of these traps (<CODE>_Open</CODE>, <CODE>_Read</CODE>,         <CODE>_Write</CODE>, <CODE>_Close</CODE>) are shared with         the File Manager and the behavior is slightly different for         Device Manager requests versus File Manager requests. The         following rules summarize the situation:</P>                  <UL>            <LI>Synchronous routines are never interrupt safe.</LI>                        <LI>Asynchronous routines are interrupt safe, if they are            legal at all.</LI>                        <LI>Immediate routines are interrupt safe if the            receiving driver is prepared to handle immediate requests            at interrupt time. Immediate routines are never legal for            files.</LI>                        <LI>You should always open and close device drivers with            <CODE>OpenDriver</CODE> and <CODE>CloseDriver</CODE>,            which must be called at system task time.</LI>                        <LI>You should always open a file with one of the            "OpenDF" routines (<CODE>FSpOpenDF</CODE>,            <CODE>PBOpenDF</CODE>, <CODE>PBHOpenDF</CODE>).            Asynchronous variants of these routines are interrupt            safe.</LI>                        <LI>Asynchronous variants of the other "Open" routines            (<CODE>PBOpen</CODE>, <CODE>PBHOpen</CODE>) are interrupt            safe when applied to files. However, you should avoid            these routines because they might unexpectedly open a            device driver. For example, if you attempt to open a file            called ".Sony", these routines might open the floppy            device driver rather than the file.</LI>         </UL>                  <P>The <A HREF="#FileManager">next section</A> gives details         on File Manager routines that are not shared with Device         Manager.</P>                  <P>If you're patching the Device Manager traps described         above, you must ensure that your patch correctly handles         interrupt-time requests. Your patch should not do         interrupt-unsafe things unless it determines that the         request is synchronous.</P>                  <P>When implementing a device driver, you receive three         types of requests: synchronous, asynchronous, and immediate.         <STRONG>If the driver can be called asynchronously, you must         implement both synchronous and asynchronous requests as if         they were asynchronous</STRONG>, and not do things that are         illegal at interrupt time. [This point is discussed in         great detail in <A HREF="tn1067.html">Technote 1067:         "Traditional Device Drivers: Sync or Swim"</A>. ] On the         other hand, immediate requests always execute at the         execution level at which the request was made, so if you         know that your client made the request at system task time,         you know you are running at system task time.</P>                  <P>As a special case of this last point, a driver is always         sent <CODE>accRun</CODE> control routines as an immediate         request at system task time, so your driver can move or         purge memory in response to an <CODE>accRun</CODE> call.</P>                  <H3><A NAME=FileManager></A>File Manager</H3>                  <P>All asynchronous File Manager routines are interrupt         safe. For example, <CODE>PBOpenDFAsync</CODE> can be called         at interrupt time.</P>                  <H3><A NAME=FileSystemManager></A>File System Manager</H3>                  <P>The File System Manager service routines         <CODE>GetFSInfo</CODE> and <CODE>SetFSInfo</CODE> are         interrupt safe. Other File System Manager service routines         (<CODE>InstallFS</CODE>, <CODE>RemoveFS</CODE>,         <CODE>InformFSM</CODE>, <CODE>InformFFS</CODE> ) are         documented as not being interrupt safe.</P>                  <P>A File System Manager plug-in should assume that it is         running at interrupt time, and not violate the provisions of         this Technote except where noted in the File System Manager         documentation. As a consequence, most File System Manager         utility routines must be interrupt safe. The routines         documented not to be interrupt safe are         <CODE>UTAllocateVCB</CODE> and <CODE>UTDisposeVCB</CODE>.         Other File System Manager utility routines (for example,         <CODE>UTCacheReadIP</CODE>) are interrupt safe but have         other documented environmental restrictions.</P>                  <H3><A NAME=DriverServicesLib></A>Driver Services</H3>                  <P>The native driver support library         (<CODE>DriverServicesLib</CODE>) provides a large number of         routines that are "interrupt- safe." The execution level at         which these routines may be called is defined in Designing         PCI Cards and Drivers for Power Macintosh Computers,         Table 9-2, starting on page 283.</P>                  <P>When reading this table, you should note a number of         important caveats:</P>                  <UL>            <LI>The column labelled "Software interrupt level" should            be labelled "Secondary interrupt level."</LI>                        <LI>To work in the context of this technote, the column            labelled "Hardware interrupt level" should be labelled            "Native Hardware Interrupt Level."</LI>                        <LI>Routines that are labelled as allocating memory must            be called at task level, and the underlying execution            level must be system task level.</LI>                        <LI>Routines callable from native hardware interrupt            level are also callable from hardware interrupt            level.</LI>         </UL>                  <P>In addition, the valid execution levels for         <CODE>PrepareMemoryForIO</CODE> is covered in <a href="../../qa/dv/dv32.html">DTS         Q&amp;A DV 32: "PrepareMemoryForIO and Execution         Levels."</A></P>                  <H3><A NAME=Networking></A>Classic Networking</H3>                  <P>Classic AppleTalk is implemented as a set of device         drivers, and hence may be called at interrupt time as long         as the calls are made asynchronously.</P>                  <P>MacTCP is split into two parts. The core TCP, UDP, and         ICMP support is implemented as a device driver, and hence         may be called at interrupt time as long as the calls are         made asynchronously.</P>                  <P>On the other hand, the Domain Name Resolver (DNR) is         implemented as glue in your application. The         <CODE>StrToAddr</CODE>, <CODE>AddrToName</CODE>,         <CODE>HInfo</CODE>, and <CODE>MXInfo</CODE> routines are         safe at interrupt time under MacTCP. However, these routines         will fail (returning an error code) under Open Transport         TCP/IP if they are first called at interrupt time. For this         reason, DTS recommends that you do not calls these routines         at interrupt time.</P>                  <H3><A NAME=OpenTransport></A>Open Transport</H3>                  <P>The latest release of <a href="http://developer.apple.com/documentation/mac/NetworkingOT/NetworkingWOT-2.html">Inside         Macintosh: Networking with Open Transport</A> has an         extensive table of which Open Transport routines can be         called from which execution levels.</P>                  <H3><A NAME=PowerManager></A>Power Manager</H3>                  <P>Installing and removing a sleep queue entry (using         <CODE>SleepQInstall</CODE> and <CODE>SleepQRemove</CODE>) is safe,         as are <CODE>BatteryStatus</CODE> and <CODE>SetWUTime</CODE>.</P>         <BR><BR><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>                  On some computers, your sleep queue entry may be                  called at a time when you are not in a current                  process. This means that it is unsafe to implement                  any user interaction from a sleep queue entry. For                  example, the sleep switch on the lid of some Duos                  and some PowerBooks gets noticed by a patch to the                  Process Manager when it is in the middle of                  switching processes. If you call a routine such as                  <CODE>ModalDialog</CODE> at this time, the Process                  Manager thinks that there is no current front                  process, so it fails to post any events for the                  dialog. You will hang because your modal dialog                  filter will never receive any events.</P></TD></TR></TABLE></CENTER><BR><BR>         <H3><A NAME=NotificationManager></A>Notification         Manager</H3>                  <P>You may call <CODE>NMInstall</CODE> and         <CODE>NMRemove</CODE> at interrupt time.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>                  A notification response procedure is called at                  system task time and hence it is safe to call most                  Toolbox routines. However, putting up user                  interface is tricky because you are running in the                  context of the front-most process.</P></TD></TR></TABLE></CENTER><BR><BR>         <H3><A NAME=DesktopManager></A>Desktop Manager</H3>                  <P>All asynchronous Desktop Manager routines are interrupt         safe. For example, the <CODE>PBDTAddAPPLAsync</CODE> routine         can be called at interrupt time.</P>                  <H3><A NAME=Gestalt></A><CODE>Gestalt </CODE></H3>                  <P><a href="http://developer.apple.com/documentation/mac/OSUtilities/OSUtilities-18.html">Inside         Macintosh: Operating System Utilities</A> has this to say         about calling <CODE>Gestalt</CODE> at interrupt time:</P>                  <BLOCKQUOTE>When passed one of the Apple-defined selector            codes, the <CODE>Gestalt</CODE> function does not move or            purge memory and therefore may be called at any time,            even at interrupt time. However, selector functions            associated with non-Apple selector codes might move or            purge memory, and third-party software can alter the            Apple-defined selector functions.</BLOCKQUOTE>                  <P>This statement is mostly correct. However, there are two         important caveats:</P>                  <OL>            <LI>Not all Apple-defined <CODE>Gestalt</CODE> selectors            are interrupt safe, and there is no hard-and-fast rules            for determining which are and which aren't.</LI>                        <LI>Prior to Mac OS 8.5, the Gestalt Manager itself has a            small concurrency hole (when it grows the            <CODE>Gestalt</CODE> table) during which it may return            incorrect information. In theory this makes            <CODE>Gestalt</CODE> unsafe to call at interrupt time; in            practice, the <CODE>Gestalt</CODE> table grows very            rarely and Apple has not yet seen a case where this has            caused problems.</LI>         </OL>                  <P>In summary, our advice is that you should:</P>                  <UL>            <LI>avoid using <CODE>Gestalt</CODE> at interrupt time in            new code,</LI>                        <LI>attempt to remove any interrupt-time usage of            <CODE>Gestalt</CODE>, as convenient, when revising old            code.</LI>         </UL>                  <P>We do not believe that it is necessary for you to revise         your code just to address this issue.</P>                  <H3><A NAME=SoundManager></A>Sound Manager</H3>                  <P><CODE>MACEVersion</CODE>, <CODE>SndGetSysBeepState</CODE>,         <CODE>SndManagerStatus</CODE>, <CODE>SndPauseFilePlay</CODE>,         <CODE>SndSetSysBeepState</CODE>, and         <CODE>SndSoundManagerVersion</CODE> are all interrupt safe.</P>                  <P><CODE>SndDoImmediate</CODE> and <CODE>SndDoCommand</CODE>         are interrupt safe if the command issued is interrupt safe.         Specifically, a <CODE>bufferCmd</CODE> is not interrupt safe         if it requires that the sound output channel be         reconfigured. The sound output channel is reconfigured if         the format of the sound changes from one buffer to the next         (i.e., the sound changed from mono to stereo [or the         reverse], 8-bit to 16-bit [or the reverse], or         its compression format changed).</P>                  <P>It is not safe (with one exception) to start playing a         sound at interrupt time, but it is safe to continue playing         a sound at interrupt time. The exception is that you can         start playing a sound at interrupt time, if you have         previously issued a <CODE>soundCmd</CODE> at task level on         the same sound channel to allow the Sound Manager to prepare         the sound channel for the type of sound that you will be         playing at interrupt time.         </P>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>                  <CODE>SysBeep</CODE> is <CITE>not</CITE> on the list.                  <CODE>SysBeep</CODE> can move or allocate memory. Do                  not call <CODE>SysBeep</CODE> at interrupt time.</P></TD></TR></TABLE></CENTER><BR><BR>         <H3><A NAME=ProcessManager></A>Process Manager</H3>                  <P><CODE>GetFrontProcess</CODE>, <CODE>GetCurrentProcess</CODE>,         <CODE>GetNextProcess</CODE>, <CODE>SameProcess</CODE>, and         <CODE>WakeUpProcess</CODE> are interrupt safe.</P>                  <H3><A NAME=MP></A>Multiprocessing Services</H3>                  <P>The existing documentation (<a href="http://developer.apple.com/documentation/Carbon/oss/MultiPServices/multiprocessingservices.html">Adding         Multitasking to Applications Using Multiprocessing         Services</A>, version 2.1) mentions that the following         routines are interrupt safe: <CODE>MPCurrentTaskID</CODE>,         <CODE>MPYield</CODE>, <CODE>UpTime</CODE>,         <CODE>MPSignalSemaphore</CODE>, <CODE>MPSetEvent</CODE>, and         <CODE>MPNotifyQueue</CODE>.</P>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>                  <CODE>MPNotifyQueue</CODE> is only interrupt safe                  if you have reserved space on the queue using                  <CODE>MPSetQueueReserve</CODE>.</P></TD></TR></TABLE></CENTER><BR><BR>         <P>In addition, the routines         <CODE>MPTaskIsPreemptive</CODE>, <CODE>MPBlockCopy</CODE>,         <CODE>MPBlockClear</CODE>, and <CODE>MPDataToCode</CODE> are         interrupt safe, even though the existing documentation does         not say that they are. This change will be rolled into a         future version of the documentation. [2456896]</P>                  <H3><A NAME=TimeManager></A>Time Manager</H3>                  <P><CODE>InsTime</CODE>, <CODE>InsXTime</CODE>, <CODE>PrimeTime</CODE>,         and <CODE>RmvTime</CODE> are interrupt safe.</P>                  <H3><A NAME=PPCToolbox></A>Process to Process Communications         Toolbox</H3>                  <P>All asynchronous PPC Toolbox routines are interrupt         safe.</P>                  <H3><A NAME=CTB></A>Communications Toolbox</H3>                  <P>The Connection Manager routines <CODE>CMRead</CODE>,         <CODE>CMWrite</CODE>, and <CODE>CMStatus</CODE> are         interrupt safe; all other Connection Manager, Terminal         Manager, File Transfer Manager, Communications Resource         Manager, and Communications Toolbox Utilities routines are         not.</P>                  <H3><A NAME=DeferredTaskManager></A>Deferred Task         Manager</H3>                  <P>Deferred task installation via <CODE>DTInstall</CODE> is         interrupt safe. A deferred task runs at interrupt time with         respect to most of the Mac OS toolbox and should follow the         <A HREF="#CanDo">rules for interrupt time code</A>.</P>                  <H3><A NAME=VBL></A>Vertical Retrace Manager</H3>                  <P><CODE>SlotVInstall</CODE>, <CODE>VRemove</CODE>,         <CODE>SlotVRemove</CODE>, <CODE>AttachVBL</CODE>,         <CODE>DoVBLTask</CODE>, and <CODE>GetVBLQHdr</CODE> are all         interrupt safe.</P>                  <H3><A NAME=Libraries></A>Libraries</H3>                  <P><CODE>SetupA5</CODE>, <CODE>SetupA4</CODE>,         <CODE>SetCurrentA5</CODE>, <CODE>SetCurrentA4</CODE>, and so         on are interrupt safe as long as the implementations do not         reside in an unloaded segment. You should check the code         generated by your development environment before using such         routines at interrupt time.</P>                  <P>Anything in <CODE>PLStringFuncs.h</CODE> is safe, as long         as the implementations do not reside in an unloaded         segment.</P>                  <H3><A NAME=Packages></A>Packages</H3>                  <P>Do not call any routine implemented in a package (List         Manager, Disk Initialization, Standard File, SANE,         International Utilities, Apple Event Manager, PPC Browser,         Edition Manager, Color Picker, Database Access Manager, Help         Manager, and the Picture Utilities) at interrupt time.         Package routines are not interrupt safe, since the package         may not be in memory at that time.</P>                  <H3>Component Manager</H3>                  <P>Opening and closing a component is not safe to do at         interrupt time, but many other component routines are         interrupt safe. You should check the specifics of the         component in question to determine exactly which functions         can be called at interrupt time.</P>                  <H3><A NAME=EventManager></A>Event Manager</H3>                  <P>The only interrupt-safe Event Manager routines are         <CODE>PostEvent</CODE> and <CODE>PPostEvent</CODE>. Other         routines, specifically <CODE>OSEventAvail</CODE>,         <CODE>TickCount</CODE> and <CODE>GetKeys</CODE>, are not         interrupt safe.</P>                 <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>                  <CODE>TickCount</CODE> and <CODE>GetKeys</CODE> are                  not interrupt safe. This is because they support                  the Journaling Mechanism, as described in                  <CITE>Inside Macintosh I </CITE>, page 261. While                  the Journaling Mechanism is long obsolete --                  leaving the core implementation of these routines                  interrupt safe -- it is legal for third party                  extensions to patch these routines with                  non-interrupt safe patches.</P>                                    <P><CODE>OSEventAvail</CODE> has not been interrupt                  safe since System 7.0 because of a Help Manager                  patch. This could be considered a bug in Help                  Manager, however, the long standing nature of this                  bug means that it will not be fixed.</P>                                    <P>If you are writing interrupt-time code, you                  should use the alternatives shown in the Table                  1.</P></TD></TR></TABLE></CENTER><BR><BR>                           <P>&nbsp;<B>Table 1</B>. Interrupt-safe                           alternatives to <CODE>TickCount</CODE> and                           <CODE>GetKeys</CODE>.</P>                                                     <TABLE BORDER=1 WIDTH="100%">                              <TR>                                 <TH WIDTH=160>                                    <P ALIGN=left>Routine</P>                                 </TH>                                 <TH WIDTH=130>                                    <P ALIGN=left>Traditional Mac                                    OS</P>                                 </TH>                                 <TH WIDTH=170>                                    <P ALIGN=left>Carbon</P>                                 </TH>                              </TR>                              <TR>                                 <td width=160 align=left>                                    <P><CODE>TickCount</CODE></P>                                 </TD>                                 <td width=130 align=left>                                    <P><CODE>LMGetTicks</CODE></P>                                 </TD>                                 <td width=170 align=left>                                    <P><CODE>TickCount</CODE>                                    [1]</P>                                 </TD>                              </TR>                              <TR>                                 <td width=160 align=left>                                    <P><CODE>GetKeys</CODE>                                    (modifiers only)</P>                                 </TD>                                 <td width=130 align=left>                                    <P><CODE>KeyMap</CODE> ($174)                                    [3]</P>                                 </TD>                                 <td width=170 align=left>                                    <P><CODE>GetCurrentKeyModifiers</CODE></P>                                 </TD>                              </TR>                              <TR>                                 <td width=160 align=left>                                    <P><CODE>GetKeys</CODE> (other                                    keys)</P>                                 </TD>                                 <td width=130 align=left>                                    <P><CODE>KeyMap</CODE> ($174)                                    [3]</P>                                 </TD>                                 <td width=170 align=left>                                    <P>none/<CODE>GetKeys</CODE>                                    [2]</P>                                 </TD>                              </TR>                           </TABLE>                                                               <P>&nbsp;<STRONG>Notes:</STRONG></P>                                    <OL>                     <LI>The Carbon implementation of                     <CODE>TickCount</CODE> on traditional Mac OS                     calls <CODE>LMGetTicks</CODE> and is therefore                     interrupt safe.</LI>                                          <LI><CODE>GetKeys</CODE>                     is interrupt-safe on traditional Mac OS when                     using CarbonLib 1.1 or later. It is always                     interrupt-safe on Mac OS X.</LI>                                          <LI><CODE>KeyMap</CODE> is a low-memory global                     (at location $174) which contains the data                     returned by <CODE>GetKeys</CODE>.</LI>                  </OL>         <H3><A NAME=QuickDraw></A>QuickDraw</H3>                  <P>Virtually none of QuickDraw is interrupt safe. The         exception is <CODE>SetCursor</CODE>, which is documented as         interrupt safe. If you patch <CODE>SetCursor</CODE>, you         should be sure that your patch is interrupt safe because it         can and will be called at interrupt time.         </P>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>                  <CODE>SetCCursor</CODE> is not interrupt safe and                  never will be. <CODE>SetCCursor</CODE> is not                  interrupt safe because, amongst other things, the                  <CODE>CCrsr</CODE> data structure contains unlocked                  handles. Apple cannot just define it to be                  interrupt safe, because on real world systems                  <CODE>SetCCursor</CODE> is patched by                  interrupt-unsafe third party extensions.</P>                                    <P>Apple is aware of the demand for an                  interrupt-safe mechanism for setting color cursors                  and is working on an alternate mechanism.</P></TD></TR></TABLE></CENTER><BR><BR>         <P>Do not be tricked into thinking that trivial QuickDraw         routines -- such as <CODE>SetRect</CODE> or         <CODE>Random</CODE> -- are interrupt safe: they are not!         This is partly by definition and partly because it's         possible for these routines to reside in pageable code         fragments. If you call these routines at any time paging is         unsafe, they could cause a fatal page fault.</P>                  <H3><A NAME=TextUtilities></A>Text Utilities</H3>                  <P><CODE>EqualString</CODE> and <CODE>RelString</CODE> are         interrupt safe, along with any other routines based on the         <CODE>_CmpString</CODE> ($A03C) and <CODE>_RelString</CODE>         ($A050) traps. These routines must be interrupt safe because         they are used by parts of Mac OS (for example, File Manager         and classic AppleTalk) that execute at interrupt time.</P>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>                  These routines are not suitable for comparing                  user-visible text because they do not make use of                  any script or language information. To compare                  user-visible text, you should use one of the other                  (non-interrupt safe) routines declared in                  "StringOrder.h" (for example,                  <CODE>IdenticalString</CODE>,                  <CODE>CompareString</CODE>, and                  <CODE>StringOrder</CODE>).</P></TD></TR></TABLE></CENTER><BR><BR><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>                  <CODE>EqualString</CODE> and <CODE>RelString</CODE>                  <EM>are</EM> suitable for comparing the following                  system entities.</P>                                    <UL>                     <LI>file names, as returned by the File Manager                     in Pascal string format (but only if you want                     the same order as used internally by HFS)</LI>                                          <LI>resource names</LI>                                          <LI>AppleTalk NBP entity names, types and                     zones</LI>                  </UL></TD></TR></TABLE></CENTER><BR><BR>                  <H3><A NAME=UnicodeConverter></A>Unicode Converter</H3>                  <P>It is possible, with some restrictions, to call the         Unicode Converter at interrupt time. If you have a specific         product that needs this ability, please contact <A HREF="mailto:dts@apple.com">DTS</A>         for details.</P>                  <BR><P><A HREF="#top">Back to top</A></P>                           <P><A NAME=Summary></A></P>                  <H2>Summary of Interrupt-Safe Routines</H2>                  <P>Table 1 contains a listing of routines which may be called at         interrupt time. Those routines with an asterisk (*) have         restrictions on their use; see the main body of this         Technote for details:</P>                  	<P><B>Table 1.</B>  Listing of Interrupt-Safe Routines.</P><CENTER><TABLE><TR><td width=275 align=left><CENTER><TABLE BORDER=0 WIDTH=275><TR><td bgcolor="#E6E6E6" align=left><pre>AddrToName *AttachVBLBatteryStatusBlockMovePBControlAsyncCMReadCMStatusCMWriteDebuggerEnterDebuggerExitDebuggerGetMaxDebuggerLockMemoryDebuggerPollDebuggerUnlockMemoryDeferUserFNDequeueDoVBLTaskEnqueueEqualStringExtendedToStringFormat2StrFormatRecToStringFormatStr2XFormatX2StrGetCurrentProcessGetFrontProcessGetFSInfoGetNextProcessGetPageStateGetPhysicalGetVBLQHdrHInfo *HoldMemory *InsTimeInsXTimeLockMemory *LockMemoryContiguous *LockMemoryForOutput *MACEVersionMPBlockClearMPBlockCopyMPCurrentTaskIDMPDataToCodeMPNotifyQueue *MPSetEventMPSignalSemaphoreMPTaskIsPreemptiveMPYieldMXInfo *NMInstallNMRemove         <I>Open Transport routines</I> *PBAllocContigAsyncPBAllocateAsyncPBCatMoveAsyncPBCatSearchAsyncPBCloseAsync *PBCloseWDAsyncPBControlAsyncPBControlImmed *PBCreateAsyncPBCreateFileIDRefAsyncPBDTAddAPPLAsyncPBDTAddIconAsyncPBDTDeleteAsyncPBDTFlushAsyncPBDTGetAPPLAsyncPBDTGetCommentAsyncPBDTGetIconAsyncPBDTGetIconInfoAsyncPBDTGetInfoAsyncPBDTRemoveAPPLAsyncPBDTRemoveCommentAsyncPBDTResetAsyncPBDTSetCommentAsyncPBDeleteAsyncPBDeleteFileIDRefAsyncPBDirCreateAsyncPBExchangeFilesAsyncPBFlushFileAsyncPBFlushVolAsyncPBGetAltAccessAsyncPBGetCatInfoAsyncPBGetEOFAsyncPBGetFCBInfoAsyncPBGetFInfoAsyncPBGetFPosAsyncPBGetForeignPrivsAsyncPBGetUGEntryAsyncPBGetVInfoAsyncPBGetVolAsyncPBGetWDInfoAsyncPBGetXCatInfoAsyncPBHCopyFileAsyncPBHCreateAsyncPBHDeleteAsyncPBHGetDirAccessAsyncPBHGetFInfoAsyncPBHGetLogInInfoAsyncPBHGetVInfoAsyncPBHGetVolAsyncPBHGetVolParmsAsyncPBHMapIDAsyncPBHMapNameAsyncPBHMoveRenameAsyncPBHOpenAsync *PBHOpenDFAsyncPBHOpenDenyAsyncPBHOpenRFAsync</pre></TD></TR></TABLE></CENTER></td>	<td width=275 align=left><CENTER><TABLE BORDER=0 WIDTH=275><TR><td bgcolor="#E6E6E6" align=left><pre>PBHOpenRFDenyAsyncPBHRenameAsyncPBHRstFLockAsyncPBHSetDirAccessAsyncPBHSetFInfoAsyncPBHSetFLockAsyncPBHSetVolAsyncPBLockRangeAsyncPBMakeFSSpecAsyncPBOpenAsync *PBOpenDFAsyncPBOpenRFAsyncPBOpenWDAsyncPBReadAsyncPBReadImmed *PBRenameAsyncPBResolveFileIDRefAsyncPBRstFLockAsyncPBSetAltAccessAsyncPBSetCatInfoAsyncPBSetEOFAsyncPBSetFInfoAsyncPBSetFLockAsyncPBSetFPosAsyncPBSetFVersAsyncPBSetForeignPrivsAsyncPBSetVInfoAsyncPBSetVolAsyncPBStatusAsyncPBStatusImmed *PBShareAsyncPBUnlockRangeAsyncPBUnshareAsyncPBWriteAsyncPBWriteImmed *PBXGetVolInfoAsyncPageFaultFatalPostEventPPostEventPrimeTimeRelStringRmvTimeSameProcessSetCursorSetFSInfoSetWUTimeSleepQInstallSleepQRemoveSlotVInstallSlotVRemoveSndDoCommand *SndGetSysBeepStateSndManagerStatusSndPauseFilePlaySndSetSysBeepStateSndSoundManagerVersionPBStatusAsyncStrToAddr *StringToExtendedStripAddressSwapMMUModeTranslate24to32UnholdMemoryUnlockMemoryUpTimeUTAllocateFCBUTReleaseFCBUTLocateFCBUTLocateNextFCBUTIndexFCBUTResolveFCBUTAddNewVCBUTLocateVCBByRefNumUTLocateVCBByNameUTLocateNextVCBUTAllocateWDCBUTReleaseWDCBUTResolveWDCBUTFindDriveUTAdjustEOFUTSetDefaultVolUTGetDefaultVolUTEjectVolUTCheckWDRefNumUTCheckFileRefNumUTCheckVolRefNumUTCheckPermissionUTCheckVolOfflineUTCheckVolModifiableUTCheckFileModifiableUTCheckDirBusyUTParsePathnameUTGetPathComponentNameUTDetermineVolUTGetBlockUTReleaseBlockUTFlushCacheUTMarkDirtyUTTrashVolBlocksUTTrashFileBlocksUTTrashBlocksUTCacheReadIPUTCacheWriteIPUTBlockInFQHashPUTVolCacheReadIPUTVolCacheWriteIPVRemoveWakeUpProcess</pre></TD></TR></TABLE></CENTER><BR><BR></td></tr></table></CENTER><BR><BR>                           <P><A NAME=references></A></P>                  <H2>References</H2>                  <P><a href="http://developer.apple.com/documentation/mac/Memory/Memory-2.html"><I>Inside         Macintosh: Memory</I></A></P>                  <P><A HREF="http://developer.apple.com/sdk/">File         System Manager SDK</A></P>                  <P>Designing         PCI Cards and Drivers for Power Macintosh Computers</P>                  <P><A HREF="tn1033.html">Technote 1033: "Interrupts in Need         of (a Good) Time"</A></P>                  <P><A HREF="tn1067.html">Technote 1067: "Traditional Device         Drivers: Sync or Swim"</A></P>                  <P><A HREF="tn1084.html">Technote 1084: "Running CFM-68K         Code at Interrupt Time: Is Your Code at Risk"</A></P>                  <P><A HREF="tn1094.html">Technote 1094: "Virtual Memory         Application Compatibility"</A>.</P>                  <P><A HREF="../me/me_09.html">Technote ME 09: "Coping with         VM and Memory Mappings</A></P>                  <BR><P><A HREF="#top">Back to top</A></P>                           <P><A NAME=Changes></A></P>                  <H2>Change History</H2>                      <BR><BR>         <TABLE BORDER=0 CELLPADDING=3 WIDTH=544>            <TR>               <td width=100 valign="top" align=left>                  <p>February 1998</p>               </TD>               <td valign="top" align=left>                  <P>Originally written.</P>               </TD>            </TR>            <TR>               <td width=100 valign="top" align=left>                  <p>July 1998</p>               </TD>               <td valign="top" align=left>                  <P>Updated with new and revised material:</P>                                    <UL>                     <LI>an expanded discussion of <A HREF="#OtherLevels">"interrupt                     time"</A></LI>                                          <LI>a note about <A HREF="#CanDo">CFM-68K</A></LI>                                          <LI>a discussion of <A HREF="#SoftwareInterrupt">software                     interrupt level</A></LI>                                          <LI><A HREF="#OpenTransport">Open Transport                     information</A> is now cross-referenced</LI>                                          <LI>complete rewrite of the <A HREF="#DeviceManager">Device                     Manager</A> section</LI>                                          <LI>a new <A HREF="#FileSystemManager">File                     System Manager</A> section, with completely                     rewritten material</LI>                                          <LI>added <A HREF="#EventManager">Event                     Manager</A> and <A HREF="#QuickDraw">QuickDraw</A>                     sections</LI>                                          <LI>many stylistic improvement</LI>                  </UL>               </TD>            </TR>            <TR>               <td width=100 valign="top" align=left>                  <p>November 1999</p>               </TD>               <td valign="top" align=left>                  <P>Updated with new material in the <A HREF="#EventManager">Event                  Manager</A> section to list                  <CODE>OSEventAvail</CODE> as interrupt safe (which                  was a mistake, see the January 2000 revision) and                  discuss alternatives to non-interrupt safe                  routines.</P>               </TD>            </TR>            <TR>               <td width=100 valign="top" align=left>                  <p>December 1999</p>               </TD>               <td valign="top" align=left>                  <P>Updated to add the <A HREF="#TextUtilities">Text                  Utilities</A> section.</P>               </TD>            </TR>            <TR>               <td width=100 valign="top" align=left>                  <p>January 2000</p>               </TD>               <td valign="top" align=left>                  <P>Updated to add the <A HREF="#UnicodeConverter">Unicode                  Converter</A> section and correct the discussion on                  <A HREF="#EventManager"><CODE>OSEventAvail</CODE></A>                  [2418891].</P>               </TD>            </TR>            <TR>               <td width=100 valign="top" align=left>                  <p>February 2000</p>               </TD>               <td valign="top" align=left>                  <P>Updated to discuss <A HREF="#CTB">Communications                  Toolbox</A>.</P>               </TD>            </TR>            <TR>               <td width=100 valign="top" align=left>                  <p>April 2000</p>               </TD>               <td valign="top" align=left>                  <P>Updated to discuss <A HREF="#MP">Multiprocessing                  Services</A>.</P>               </TD>            </TR>            <TR>               <td width=100 valign="top" align=left>                  <p> October 2000</p>               </TD>               <td valign="top" align=left>                  <P>Updated to discuss                  mechanisms used to <A HREF="#DeterminingExecutionLevel">determine                  the current execution                  level</A>. Updated the                  <A HREF="#EventManager">Event                  Manager</A> section to                  document that <CODE>GetKeys</CODE> is                  interrupt-safe under CarbonLib 1.1 and                  later.</P>               </TD>            </TR>         </TABLE>                           <BR><BR>                  <BR><P><A HREF="#top">Back to top</A></P>                  <BR><BR>                  <P><A NAME=Downloads></A></P>                  <H2>Downloadables</H2>                 <center><TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <CENTER><img src="images/acrobatsmall.gif" alt="Acrobat" width=22 height=23></CENTER>               </TD>               <td align="left">                  <P>Acrobat version of this Note (172K)</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/tn1104.pdf">Download</A></P>               </TD>            </TR>            <TR>               <td width=50 align=left>                  <CENTER><img src="images/bluebook.gif" alt="Bluebook" width=22 height=23></CENTER>               </TD>               <td align="left">                  <P>New CurrentExecutionLevel detection code</P>               </TD>               <td width=60 align=left>                  <P><A HREF="downloads/tn1104_1.hqx">Download</A></P>               </TD>            </TR>         </TABLE></center><BR><P><A HREF="#top">Back to top</A></P>        </td></tr></table></center><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1104.html%3Fid%3DDTS10002944-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1104.html%3Fid%3DDTS10002944-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1104.html%3Fid%3DDTS10002944-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>