<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Supplying Custom Word-Break Tables(IM: Tx)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING552></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Text-551.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Text-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Text-594.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Text-553.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Text-2.html"><B>Text</B></A> / <BR><DD><A HREF="Text-531.html"><B>Appendix B - International Resources</B></A> / <A HREF="Text-547.html"><B>String-Manipulation Resource (Type 'itl2')</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING552-0></A>
<H2><A NAME=MARKER-9-290></A>Supplying Custom Word-Break Tables</H2>
 <A NAME=MARKER-2-291></A>The Text Utilities <CODE>FindWordBreaks</CODE> procedure uses state machines and associated tables in a script's string-manipulation resource to determine word boundaries and <BR>line breaks.<P>
 The <CODE>FindWordBreaks</CODE> procedure examines a block of text to determine the <BR>boundaries of the word that includes a specified character in the block. Usually, <CODE>FindWordBreaks</CODE> uses different state tables to define words for word selection than it does for line breaking.<P>
 To replace the word-selection criteria, you can supply a replacement string-manipulation resource with a modified break table. This section describes the break table and how <CODE>FindWordBreaks</CODE> uses it.<P>
<A NAME=HEADING552-4></A>
<H3><A NAME=MARKER-9-292></A>NBreakTable Format</H3>
 <CODE><A NAME=MARKER-2-293></A>FindWordBreaks</CODE> uses word-break tables of type <CODE>NBreakTable</CODE>, defined for system software version 7.0 and later:<P>
<PRE>
TYPE     NBreakTable = 
   RECORD
      flags1:           SignedByte; {break table format flags}
      flags2:           SignedByte; {break table format flags}
      version:          Integer;    {version no. of break table} 
      classTableOff:    Integer;    {offset to ClassTable array}
      auxCTableOff:     Integer;    {offset to auxCTable array}
      backwdTableOff:   Integer;    {offset to backwdTable array}
      forwdTableOff:    Integer;    {offset to forwdTable array}
      doBackup:         Integer;    {skip backward processing?}
      length:           Integer;    {length of the break table}
      charTypes:        ARRAY[0..255] OF SignedByte;
      tables:           ARRAY[0..0] OF Integer;
                                    {break tables}
END;

TYPE NBreakTablePtr = ^NBreakTable;
</PRE>
<DL>
<H5>Field Description</H5>
<DT><A NAME=MARKER-2-294></A>flags1
<DD> The high-order byte of the break table format flags. If the high-order bit of this byte is set to 1, this break table is in the format used by <CODE>FindWordBreaks</CODE>.
<DT><A NAME=MARKER-2-295></A>flags2
<DD> The low-order byte of the break table format flags. If the value in this byte is 0, the break table belongs to a 1-byte script system; in this case <CODE>FindWordBreaks</CODE> does not check for 2-byte characters.
<DT><CODE>version</CODE>
<DD> The version number of this break table.
<DT><A NAME=MARKER-2-296></A>classTableOff
<DD> The offset in bytes from the beginning of the break table to the beginning of the class table.
<DT><A NAME=MARKER-2-297></A>auxCTableOff
<DD> The offset in bytes from the beginning of the break table to the beginning of the auxiliary class table.
<DT><A NAME=MARKER-2-298></A>backwdTableOff
<DD> The offset in bytes from the beginning of the break table to the beginning of the backward-processing table.
<DT><A NAME=MARKER-2-299></A>forwdTableOff
<DD> The offset in bytes from the beginning of the break table to the beginning of the forward-processing table.
<DT><A NAME=MARKER-2-300></A>doBackup
<DD> The minimum byte offset into the buffer for doing backward processing. If the selected character for <CODE>FindWordBreaks</CODE> has a byte offset less than doBackup, <CODE>FindWordBreaks</CODE> skips backward processsing altogether and starts from the beginning of the buffer.
<DT>length
<DD> The length in bytes of the entire break table, including all the individual tables.
<DT><A NAME=MARKER-2-301></A>charTypes
<DD> The class table. See explanation below.
<DT><A NAME=MARKER-2-302></A>tables
<DD> The data of the auxiliary class table, backward table, and <BR>forward table.
</DL>
 The tables have this format and content:<P>
<UL>
<LI>The class table is an array of 256 signed bytes. Offsets into the table represent byte values; if the entry at a given offset in the table is positive, it means that a byte <BR>whose value equals that offset is a single-byte character, and the entry at that offset is the class number for the character. If the entry is negative, it means that the byte is the first byte of a 2-byte character code, and the auxiliary class table must be used to determine the character class. Odd negative numbers are handled differently from even negative numbers.
<LI>The auxiliary class table assigns character classes to 2-byte characters. It is used when the class table determines that a byte value represents the first byte of a 2-byte character.<P>
<UL>
<LI>Here is how the auxiliary class table handles odd negative values from the class table. If the first word of the auxiliary class table is equal to or greater than zero, it represents the default class number for 2-byte character codes--the class assigned to every odd negative value from the class table. If the first word is less than zero, it is the negative of the offset from the beginning of the auxiliary class table to a first-byte class table (a table of 2-byte character classes that can be determined from just the first byte). The value from the class table is negated, 1 is subtracted from it to obtain an even offset, and the value at that offset into the first-byte class table is the class to be assigned.
<LI>Here is how the auxiliary class table handles even negative values from the class table. The auxiliary class table begins with a variable-length word array. The words that follow the first word are offsets to row tables. Row tables have the same format as the class table, but are used to map the second byte of a 2-byte character code to a class number. If the entry in the class table for a given byte is an even negative number, <CODE>FindWordBreaks</CODE> negates this value to obtain the offset from the beginning of the auxiliary class table to the appropriate word, which in turn contains an offset to the appropriate row table. That row table is then used to map the second byte of the character to a class number.<P>
</UL>
<LI>The backward-processing table is a state table used by <CODE>FindWordBreaks</CODE> for backward searching. Using the backward-processing table, <CODE>FindWordBreaks</CODE> starts at a specified character, moving backward as necessary until it encounters a word boundary.
<LI>The forward-processing table is a state table used by <CODE>FindWordBreaks</CODE> for forward searching. Using the forward-processing table, <CODE>FindWordBreaks</CODE> starts at one word boundary and moves forward until it encounters another word boundary.<P>
</UL>
 The backward-processing table and the forward-processing table have the same format, as shown in <A HREF=#MARKER-9-304>Figure B-9</A>. The table begins with a list of words containing byte offsets from the beginning of the state table to the rows of the state table; this is followed by a <I>c</I>-by-<I>s</I> byte array, where <I>c</I> is the number of classes (columns) and <I>s</I> is the number of states (rows). The bytes in this array are stored with the column index varying most rapidly-- that is, the bytes for the state 1 row precede the bytes for the state 2 row.<P>
<DL>
<DT><B>Note</B>
<DD>There is a maximum of 128 classes and 64 states (including the start and exit states).<EM></EM><A NAME=MARKER-2-303></A>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<B>Figure B-9  <CODE><A NAME=MARKER-9-304></A>NBreakTable</CODE> state table</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/IR_L-08.jpg">
 Each entry in this array is an action code, which specifies<P>
<UL>
<LI>whether to mark the current offset
<LI>the next state, which may be the exit state (state 0)<P>
</UL>
 The format of an action code is shown in <A HREF=#MARKER-9-305>Figure B-10</A>.<P>
<B>Figure B-10  <A NAME=MARKER-9-305></A>Format of an <CODE>NBreakTable</CODE> action code</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/IR_L-09.jpg">
 <A HREF=#MARKER-9-51>Table B-6</A> shows an example of the classes used in a state table. It is taken from the word-selection table of the U.S. localized version of the Roman script system.
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><A NAME=MARKER-9-51></A>Example of classes for an <CODE>NBreakTable</CODE> state table (Continued)</CAPTION>
<TH>Class <BR>number<TH>Class name<BR><TH>Used for<BR><TR>
<TD>0<TD>break<TD>Everything not included below<TR>
<TD>1<TD>nonBreak<TD>Nonbreaking spaces<TR>
<TD>2<TD>letter<TD>Letters, ligatures, and accents<TR>
<TD>3<TD>number<TD>Digits<TR>
<TD>4<TD>midLetter<TD>Hyphen<TR>
<TD>5<TD>midLetNum<TD>Apostrophe (vertical or right single quote)<TR>
<TD>6<TD>preNum<TD>$   \xA7<TR>
<TD>7<TD>postNum<TD>% 0/00 <TR>
<TD>8<TD>midNum<TD>, \xE9<TR>
<TD>9<TD>preMidNum<TD>.<TR>
<TD>10<TD>blank<TD>Space, tab, null<TR>
<TD>11<TD>cr<TD>Return</TABLE>
<P>
 <A HREF=#MARKER-9-52>Table B-7</A> shows an example of the defined states for a state table. It is taken from the forward-processing table of the word-selection table of the U.S. localized version of the Roman script system.
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><A NAME=MARKER-9-52></A>Example of states for an <CODE>NBreakTable</CODE> state table (Continued)</CAPTION>
<TH>State <BR>number<TH>Explanation<BR><TR>
<TD>0<TD>Exit<TR>
<TD>1<TD>Start, or has detected initial <I>nonBreak</I> sequence<TR>
<TD>2<TD>Has detected a <I>letter</I><TR>
<TD>3<TD>Has detected a <I>number</I><TR>
<TD>4<TD>Has detected a non-whitespace character that should stand alone; <BR>now anything but <I>nonBreak</I> generates an exit<TR>
<TD>5<TD>Has detected <I>preMidNum</I> or <I>preNum</I>; <BR>now anything but <I>number</I> or <I>nonBreak</I> generates an exit<TR>
<TD>6<TD>Has detected a <I>blank</I><TR>
<TD>7<TD>Has detected <I>letter</I> followed by <I>midLetter</I>, <I>midLetNum</I>, or <I>preMidNum</I>; now anything but <I>letter</I> generates an exit<TR>
<TD>8<TD>Has detected a non-whitespace character followed by <I>nonBreak</I> <BR>(the <I>nonBreak</I> should be treated as non-whitespace)<TR>
<TD>9<TD>Has detected <I>number</I> followed by <I>midNum</I>, <I>midLetNum</I>, or <I>preMidNum</I>;<BR>now anything but <I>number</I> generates an exit<TR>
<TD>10<TD>Marks current offset, then exits<TR>
<TD>11<TD>Has detected <I>blank</I> followed by <I>nonBreak</I> <BR>(the <I>nonBreak</I> should be treated as a blank)</TABLE>
<P>
<A NAME=HEADING552-37></A>
<H3>How FindWordBreaks Uses the Break Table</H3>
 <CODE><A NAME=MARKER-2-306></A>FindWordBreaks</CODE> uses a state machine to determine the word boundaries on either side of a given character in a text buffer. The state machine must start at a point in the buffer at or before the beginning of the word that includes that character. If the specified character is sufficiently close to the beginning of the text buffer (controlled by the <CODE>doBackupMin</CODE> parameter in the break table), the state machine simply starts from the beginning of the buffer. Otherwise, <CODE>FindWordBreaks</CODE> uses the backward-processing table to work backwards from the specified character, analyzing characters until it encounters a word boundary.<P>
 Once determined, this starting location is saved as an initial word boundary. From this point the <CODE>FindWordBreaks</CODE> state machine moves forward using the forward-processing table until it encounters another word boundary. If that word boundary is still before the specified character, its location is saved as the starting point and the state machine is restarted from that location. This process repeats until the state machine finds a word boundary that is after the specified character. At that point, <CODE>FindWordBreaks</CODE> returns the location of the previously saved word boundary and the current word boundary as the offset pair defining the word.<P>
 The state machine operates in a similar manner whether moving backward or forward; any differences in behavior are determined by the tables. The machine begins in the start state (state 1). It then cycles one character at a time until it finds a boundary break and exits. In each cycle, the current character is mapped to a class number, and the character class and the current state are used as indices into the array of action codes in the state table. Each action code specifies the next state and whether to mark the current offset. When the state machine exits, it has encountered a word boundary. The location of the word boundary is the last character offset that was marked.<P>
 <A HREF=#MARKER-9-310>Figure B-11</A> gives two examples of the forward operation of the state machine for word selection. It shows that an exit may or may not be generated at a hyphen, depending on the character that follows. It also shows that the marked offset on exit may or may not include the last character before the exit was generated.<CODE><A NAME=MARKER-2-307></A></CODE>   <A NAME=MARKER-2-308></A>   <A NAME=MARKER-2-309></A><P>
<B>Figure B-11  <A NAME=MARKER-9-310></A>Forward operation of the state machine for word selection</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/IR_L-06.jpg">
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Text-551.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Text-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Text-594.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Text-553.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Text-3.html">&copy; Apple Computer, Inc.</A><br>6 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
