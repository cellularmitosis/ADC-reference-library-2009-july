<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Image Unit Tutorial: Writing the Objective-C Portion</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Writing the Objective-C Portion"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40004531-CH4" title="Writing the Objective-C Portion"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000424" target="_top">Graphics &amp; Imaging</a> &gt; <a href="../../../Quartz-date.html#//apple_ref/doc/uid/TP30000440-TP30000424-TP30000559" target="_top">Quartz</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP40004531-CH1-SW1">Image Unit Tutorial</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../WritingKernels/WritingKernels.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../PackagingtheFilter/PackagingtheFilter.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40004531-CH4-SW1" title="Writing the Objective-C Portion"></a><h1>Writing the Objective-C Portion</h1><p>The kernel, although it is the heart of an image processing filter, becomes an image unit only after it is properly packaged as a plug-in. Your most important tasks in the packaging process are to copy your <code>kernel</code> routine (or routines) into the kernel skeletal file provided by Xcode and to modify the code in the in the implementation and interface files for the filter. There are a few other housekeeping tasks you’ll need to perform to correctly categorize the filter and to identify your image unit as your product. You’ll also need to describe its input parameters.</p><p>This chapter provides an overview to the image unit template in Xcode and describes the contents of the filter files. Then, it shows how to create these image units:</p><ul class="ul"><li class="li"><p>A  color inversion image unit that uses the <code>kernel</code> routine discussed in <span class="content_text"><a href="../WritingKernels/WritingKernels.html#//apple_ref/doc/uid/TP40004531-CH3-SW18">“Color Inversion.”</a></span> It uses one <code>sampler</code> object and does not require a region-of-interest method.</p></li><li class="li"><p>A pixellate image unit that uses the <code>kernel</code> routine discussed in <span class="content_text"><a href="../WritingKernels/WritingKernels.html#//apple_ref/doc/uid/TP40004531-CH3-SW15">“Pixellate.”</a></span> It uses one <code>sampler</code> object and requires one region-of-interest method.</p></li><li class="li"><p>A detective lens image unit, which uses the two <code>kernel</code> routines discussed in <span class="content_text"><a href="../WritingKernels/WritingKernels.html#//apple_ref/doc/uid/TP40004531-CH3-SW25">“Writing Kernel Routines for a Detective Lens .”</a></span> It uses requires several <code>sampler</code> objects and two a region-of-interest methods.</p></li></ul><p>Before you follow the instructions in this chapter for writing the Objective-C portion of an image unit, you should understand how the <code>kernel</code> routines discussed in  <span class="content_text"><a href="../WritingKernels/WritingKernels.html#//apple_ref/doc/uid/TP40004531-CH3-SW1">“Writing Kernels”</a></span> work.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="WritingtheObjective-CPortion.html#//apple_ref/doc/uid/TP40004531-CH4-SW9">The Image Unit Template in Xcode</a>
				
			<br/>
			
        
			
			
				<a href="WritingtheObjective-CPortion.html#//apple_ref/doc/uid/TP40004531-CH4-SW7">Creating a Color Inversion Image Unit</a>
				
			<br/>
			
        
			
			
				<a href="WritingtheObjective-CPortion.html#//apple_ref/doc/uid/TP40004531-CH4-SW3">Creating a Pixellate Image Unit</a>
				
			<br/>
			
        
			
			
				<a href="WritingtheObjective-CPortion.html#//apple_ref/doc/uid/TP40004531-CH4-SW4">Creating a Detective Lens Image Unit</a>
				
			<br/>
			
        
			
			
				<a href="WritingtheObjective-CPortion.html#//apple_ref/doc/uid/TP40004531-CH4-SW13">Next Steps</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40004531-CH4-SW9" title="The Image Unit Template in Xcode"></a><h2>The Image Unit Template in Xcode</h2><p>Xcode provides a template that facilitates the packaging process. To help you package an image unit as a plug-in, Xcode provides the skeletal files and methods that are needed and names the files appropriately. <span class="content_text"><a href="WritingtheObjective-CPortion.html#//apple_ref/doc/uid/TP40004531-CH4-SW6">Figure 3-1</a></span> shows the files automatically created by Xcode for an image unit project named <code>DetectiveLens</code>. </p><br/><div><a name="//apple_ref/doc/uid/TP40004531-CH4-SW6" title="Figure 3-1The files in an image unit project"></a><p><strong>Figure 3-1&nbsp;&nbsp;</strong>The files in an image unit project</p><img src = "../ART/dl_project_files.jpg" alt = "The files in an image unit project" ></div><br/><p>Xcode automatically names files using the project name that you supply. These are the default files provided by Xcode:</p><ul class="ul"><li class="li"><p><code>&lt;ProjectName>Filter.m</code> is the implementation file for the filter. You will need to modify this file.</p></li><li class="li"><p><code>&lt;ProjectName>Filter.h</code> is the interface file for the filter. You will need to modify this file.</p></li><li class="li"><p><code>&lt;ProjectName>FilterKernel.cikernel</code> is the file that contains the <code>kernel</code> routine (or routines) and any subroutines needed by the kernel. The default code is a <code>funHouse</code> kernel routine and a <code>smoothstep</code> subroutine that’s used by <code>funHouse</code>. (This subroutine is not the same as the one provided by OpenGl Shading Language.) All you need to do is completely replace this code with the <code>kernel</code> routine (or routines) that you’ve written (as well as tested and debugged) and any required subroutines. </p></li><li class="li"><p><code>&lt;ProjectName>PlugInLoader.m</code> is the file that implements the plug-in protocol needed to load an image unit. You do not need to make any modifications to this file unless your product requires custom tasks on loading. This chapter does not provide any information on customizing the loading process. It assumes that you’ll use the file as is.</p></li><li class="li"><p><code>&lt;ProjectName>PlugInLoader.h</code> is the interface file for the plug-in loading protocol.</p></li><li class="li"><p><code>&lt;ProjectName>.plugin</code> is the plug-in that you will distribute. When you create the project, this file name appears in red text to indicate that the file does not yet exist. After you build the project, the file name changes to black text to indicate that the plug-in exists.</p></li><li class="li"><p><code>Description.plist</code> defines several properties of the filter: filter name, filter categories, localized display name, filter class, and information about the input parameters to the filter. Executable image units (which are the only image units you’ll see in this tutorial) may have input parameters of any class, but Core Image does not generate an automatic user interface for custom classes (see <code><a href="../../../Reference/IKFilterUIAddition/IKFIlterUI_Reference.html#//apple_ref/occ/cat/CIFilter(IKFilterUIAddition)" target="_top">CIFilter Image Kit Additions</a></code>). Input parameters for non-executable image units must be one of these classes: <code><a href="../../../Reference/QuartzCoreFramework/Classes/CIColor_Class/Reference/Reference.html#//apple_ref/occ/cl/CIColor" target="_top">CIColor</a></code>, <code><a href="../../../Reference/QuartzCoreFramework/Classes/CIVector_Class/Reference/Reference.html#//apple_ref/occ/cl/CIVector" target="_top">CIVector</a></code>, <code><a href="../../../Reference/QuartzCoreFramework/Classes/CIImage_Class/Reference/Reference.html#//apple_ref/occ/cl/CIImage" target="_top">CIImage</a></code>, or <code><a href="../../../../Cocoa/Reference/Foundation/Classes/NSNumber_Class/Reference/Reference.html#//apple_ref/occ/cl/NSNumber" target="_top">NSNumber</a></code>. (For more information on executable and nonexecutable filters, see <em><a href="../../CoreImaging/index.html#//apple_ref/doc/uid/TP30001185" target="_top">Core Image Programming Guide</a></em>.)</p><p>The default template file is shown in <span class="content_text"><a href="WritingtheObjective-CPortion.html#//apple_ref/doc/uid/TP40004531-CH4-SW10">Figure 3-2</a></span>. Xcode fills in the filter name for you based on the project name that you provide. You need to make changes to the filter categories and localized display name. The filter categories should include all the categories defined by the Core Image API that apply to your filter. For a list of the possible categories, see <em><a href="../../../Reference/QuartzCoreFramework/Classes/CIFilter_Class/index.html#//apple_ref/doc/uid/TP40003960" target="_top">CIFilter Class Reference</a></em>.</p></li><li class="li"><p><code>Info.plist</code> contains properties of the plug-in, such as development region, bundle identifier, principal class, and product name. You’ll want to modify the bundle identifier and make sure that you define the product name variable in Xcode.</p></li></ul><p>The default code is for a filter that mimics the effect of a fun house mirror. You should recognize the kernel routine as the same one discussed in <span class="content_text"><a href="../WritingKernels/WritingKernels.html#//apple_ref/doc/uid/TP40004531-CH3-SW35">Listing 2-6</a></span>. The project  will build as a valid image unit without the need for you to change a single line of code.</p><br/><div><a name="//apple_ref/doc/uid/TP40004531-CH4-SW10" title="Figure 3-2The default property list file"></a><p><strong>Figure 3-2&nbsp;&nbsp;</strong>The default property list file</p><img src = "../ART/project_desc_plist.jpg" alt = "The default property list file" ></div><br/><p>The filter interface and implementation files provided by Xcode are the ones that you need to customize for your <code>kernel</code> routine (or routines). The interface file declares a subclass of <code><a href="../../../Reference/QuartzCoreFramework/Classes/CIFilter_Class/Reference/Reference.html#//apple_ref/occ/cl/CIFilter" target="_top">CIFilter</a></code>. Xcode automatically names the subclass <code>&lt;ProjectName>Filter</code>. For example, if you supply InvertColor as the project name, the interface file uses <code>InvertColorFilter</code> as the subclass name. The default interface file declares four instance variables for the filter: <code>inputImage</code>, <code>inputVector</code>, <code>inputWidth</code>, and <code>inputAmount</code>, which, from the perspective of a filter client, are the input parameters to the filter. You may need to delete one or more of these instance variables and add any that are needed by your image unit. </p><p>The implementation file contains four methods that you’ll need to modify for your purposes:</p><ul class="ul"><li class="li"><p><code>init</code> gets the kernel file from the bundle, and loads the <code>kernel</code> routines. Unless you require customization at initialization time, you may not need to modify this method.</p></li><li class="li"><p><code>regionOf:destRect:userInfo</code> is callback function that defines the region of interest (ROI). If you are writing a filter that does not require an ROI, you can delete this method. If you are unsure of what an ROI is, see <em><a href="../../CoreImaging/index.html#//apple_ref/doc/uid/TP30001185" target="_top">Core Image Programming Guide</a></em> and <span class="content_text"><a href="../Overview/Overview.html#//apple_ref/doc/uid/TP40004531-CH6-SW2">“Region-of-Interest Methods.”</a></span> In general, filters that map one source pixel to one destination pixel do not require an ROI. Just about all other types of filters will require that you provide an ROI method, except certain generator filters.</p></li><li class="li"><p><code>customAttributes</code> is a method that defines the attributes of each input parameter. This is required so that the filter host can query your filter for the input parameters, their data types, and their default, minimum, and maximum values. You can also provide such useful information as slider minimum and maximum values. When a filter host calls the <code><a href="../../../Reference/QuartzCoreFramework/Classes/CIFilter_Class/Reference/Reference.html#//apple_ref/occ/instm/CIFilter/attributes" target="_top">attributes</a></code> method, Core Image actually invokes your <code>customAttributes</code> method. If your filter does not require any input parameters other than an input image, you can delete this method. </p></li><li class="li"><p><code>outputImage</code> creates one or more <code><a href="../../../Reference/QuartzCoreFramework/Classes/CISampler_Class/Reference/Reference.html#//apple_ref/occ/cl/CISampler" target="_top">CISampler</a></code> objects, performs any necessary calculations, calls the <code><a href="../../../Reference/QuartzCoreFramework/Classes/CIFilter_Class/Reference/Reference.html#//apple_ref/occ/instm/CIFilter/apply:" target="_top">apply:</a></code> method of the <code><a href="../../../Reference/QuartzCoreFramework/Classes/CIFilter_Class/Reference/Reference.html#//apple_ref/occ/cl/CIFilter" target="_top">CIFilter</a></code> class and returns a <code><a href="../../../Reference/QuartzCoreFramework/Classes/CIImage_Class/Reference/Reference.html#//apple_ref/occ/cl/CIImage" target="_top">CIImage</a></code> object. The exact nature of this method depends on the complexity of the filter, as you’ll see by reading the rest of this chapter. </p></li></ul><div class="notebox"><a name="//apple_ref/doc/uid/TP40004531-CH4-SW2" title="Note"></a><p><strong>Note:</strong>&nbsp;A <strong>multipass filter</strong> is one that either applies two or more <code>kernel</code> routines or applies the same <code>kernel</code> routine more than once before returning a <code><a href="../../../Reference/QuartzCoreFramework/Classes/CIImage_Class/Reference/Reference.html#//apple_ref/occ/cl/CIImage" target="_top">CIImage</a></code> object from the <code>outputImage</code> method.</p></div><p>The next sections show how to modify the filter files for three types of image units:</p><ul class="ul"><li class="li"><p><span class="content_text"><a href="WritingtheObjective-CPortion.html#//apple_ref/doc/uid/TP40004531-CH4-SW7">“Creating a Color Inversion Image Unit”</a></span> uses one <code>kernel</code> routine but does not need an ROI method.</p></li><li class="li"><p><span class="content_text"><a href="WritingtheObjective-CPortion.html#//apple_ref/doc/uid/TP40004531-CH4-SW3">“Creating a Pixellate Image Unit”</a></span> uses one <code>kernel</code> routine and an ROI method.</p></li><li class="li"><p><span class="content_text"><a href="WritingtheObjective-CPortion.html#//apple_ref/doc/uid/TP40004531-CH4-SW4">“Creating a Detective Lens Image Unit”</a></span>  is a multipass filter that uses two <code>kernel</code> routines and an ROI method for each <code>kernel</code> routine.</p></li></ul><a name="//apple_ref/doc/uid/TP40004531-CH4-SW7" title="Creating a Color Inversion Image Unit"></a><h2>Creating a Color Inversion Image Unit</h2><p>A color inversion filter represents one of the simplest image units that you can write. It uses the <code>kernel</code> routine discussed in  <span class="content_text"><a href="../WritingKernels/WritingKernels.html#//apple_ref/doc/uid/TP40004531-CH3-SW18">“Color Inversion.”</a></span> If you take a look at the <code>kernel</code> routine shown in <span class="content_text"><a href="../WritingKernels/WritingKernels.html#//apple_ref/doc/uid/TP40004531-CH3-SW2">Listing 2-1</a></span> you’ll see that the routine does not use any input parameters other than an input image. So there is no need to supply a <code>customAttributes</code> method. The <code>kernel</code> routine maps one source pixel to a destination pixel that’s at the same coordinates as the source pixel. As a result, there is no need to supply a method that calculates an ROI. You will need to make modifications to the filter interface file and to the <code>outputImage</code> method  in the filter  implementation file. The default <code>init</code> method will work as is, provided that you do not rename any of the files that Xcode automatically names for you.</p><p>To package the color inversion <code>kernel</code> routine as image unit, follow these steps:</p><ol class="ol"><li class="li"><p>Launch Xcode and choose File > New Project.</p></li><li class="li"><p>In the Assistant window, scroll to  to Standard Apple Plug-ins, select <code>Image Unit Plug-in for Objective C</code> and click Next.</p><div class="item_figure"><img src = "../ART/select_template.jpg" alt = "The Xcode template for an image unit" ></div></li><li class="li"><p>Enter <code>InvertColor</code> as the project name and click Finish.</p><div class="item_figure"><img src = "../ART/name_image_unit.jpg" alt = "The project name for an image unit plug-in" ></div></li><li class="li"><p>Open the <code>InvertColorFilterKernel.cikernel</code> file and replace the code with the code from <span class="content_text"><a href="../WritingKernels/WritingKernels.html#//apple_ref/doc/uid/TP40004531-CH3-SW2">Listing 2-1</a></span>. </p></li><li class="li"><p>Open the <code>InvertColor.h</code> file and delete all the instance variables except for <code>inputImage</code>, as this filter doesn’t have any input parameters other than an input image. Then save and close the file.</p></li><li class="li"><p>Open the <code>InvertColor.m</code> file and delete the <code>regionOf:destRect:userInfo:</code> and <code>customAttributes</code> methods.</p></li><li class="li"><p>Modify the <code>outputImage</code> method so that it looks as follows:</p><div class="codesample"><table><tr><td scope="row"><pre>- (CIImage *)outputImage<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CISampler *src;<span></span></pre></td></tr><tr><td scope="row"><pre>   // Create a sampler from the input image because a kernel routine takes<span></span></pre></td></tr><tr><td scope="row"><pre>   // a sampler, not an image, as input<span></span></pre></td></tr><tr><td scope="row"><pre>    src = [CISampler samplerWithImage:inputImage];<span></span></pre></td></tr><tr><td scope="row"><pre>    // Use the apply: method on the CIFilter object<span></span></pre></td></tr><tr><td scope="row"><pre>    return [self apply:_InvertColorFilterKernel, src, nil];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div></li><li class="li"><p>Save and close the <code>InvertColor.m</code> file.</p></li><li class="li"><p>Open the <code>Description.plist</code> file.</p></li><li class="li"><p>Change <code>CICategoryDistortionEffect</code> to <code>CICategoryColorEffect</code>.</p></li><li class="li"><p>Save and close the <code>Description.plist</code> file.</p></li><li class="li"><p>Open the <code>Description.strings</code> file.</p></li><li class="li"><p>Enter the localized display name for the filter by adding the following:</p><p><code>"InvertColorFilter" = "Invert Color Filter";</code></p><p>You’ll want to provide localized display names for all input parameters and for all languages that represent your image unit users. </p></li><li class="li"><p>Save and close the <code>Description.strings</code> file.</p></li><li class="li"><p>Build the project.</p><p>It should succeed unless you’ve introduced some typographical errors.</p></li><li class="li"><p>Quit Xcode.</p></li><li class="li"><p>Find the <code>InvertColor.plugin</code> file in your project. If you want, move it to a convenient location for validation and testing purposes.</p></li><li class="li"><p>Make sure the image unit is valid. (See <span class="content_text"><a href="../PackagingtheFilter/PackagingtheFilter.html#//apple_ref/doc/uid/TP40004531-CH5-SW3">“Validating an Image Unit.”</a></span>)</p></li><li class="li"><p>Install the validated image unit in <code>/Library/Graphics/Image Units/</code>.</p></li><li class="li"><p>Test the image unit. (See <span class="content_text"><a href="../PackagingtheFilter/PackagingtheFilter.html#//apple_ref/doc/uid/TP40004531-CH5-SW5">“Testing an Image Unit.”</a></span>)</p></li></ol><p>That’s all there is to building an image unit for a simple filter! Read the next sections to create image units for more complex filters.</p><a name="//apple_ref/doc/uid/TP40004531-CH4-SW3" title="Creating a Pixellate Image Unit"></a><h2>Creating a Pixellate Image Unit</h2><p>Writing an image unit to package the pixellate <code>kernel</code> routine (see <span class="content_text"><a href="../WritingKernels/WritingKernels.html#//apple_ref/doc/uid/TP40004531-CH3-SW15">“Pixellate”</a></span>) is a bit more challenging than packaging the color inversion <code>kernel</code> routine because you need to supply a region-of-interest method. Recall that the pixellate <code>kernel</code> routine uses many pixels from the source image to compute the value of each destination pixel. The number of pixels is defined by the dot size. For example, if the dot size is 4, then the <code>kernel</code> routine uses 16 pixels from the source image: a 4-pixel-by-4-pixel grid. The calculation works well unless the destination pixel is at the edge, in which case there won’t be enough pixels to fetch. That’s where the region-of-interest method comes to play. If the grid of pixels is always inset by the radius of the dot size, you’ll avoid the problem of not having enough pixels to fetch.</p><p>The code in <span class="content_text">Listing 3-1</span> is a region-of-interest method that calls the Quartz function <code><a href="../../../Reference/CGGeometry/Reference/reference.html#//apple_ref/c/func/CGRectInset" target="_top">CGRectInset</a></code>. This function returns a rectangle that is smaller or larger than the rectangle passed to it. In this case, the ROI method insets the rectangle passed to it by the dot radius.</p><a name="//apple_ref/doc/uid/TP40004531-CH4-SW8" title="Listing 3-1A region-of-interest method for the pixellate image unit"></a><p class="codesample"><strong>Listing 3-1&nbsp;&nbsp;</strong>A region-of-interest method for the pixellate image unit</p><div class="codesample"><table><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (CGRect)regionOf: (int)sampler  destRect: (CGRect)rect  userInfo: (NSNumber *)radius<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return CGRectInset(rect, -[radius floatValue], -[radius floatValue]);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Now that you’ve seen the required region-of-interest method, you are ready to use Xcode to create the pixellate image unit.</p><ol class="ol"><li class="li"><p>Launch Xcode and choose File > New Project.</p></li><li class="li"><p>In the Assistant window, scroll to  to Standard Apple Plug-ins, select <code>Image Unit Plug-in for Objective C</code> and click Next.</p></li><li class="li"><p>Enter <code>Pixellate</code> as the project name and click Finish.</p></li><li class="li"><p>Open the <code>PixellateFilterKernel.cikernel</code> file and replace the code with the code from <span class="content_text"><a href="../WritingKernels/WritingKernels.html#//apple_ref/doc/uid/TP40004531-CH3-SW28">Listing 2-4</a></span>. </p></li><li class="li"><p>Open the <code>Pixellate.h</code> file and modify the interface so that the filter has two instance variables: <code>inputImage</code> and <code>inputScale</code>. Then save and close the file.</p></li><li class="li"><p>Open the <code>Pixellate.m</code> file and modify the <code>regionOf:destRect:userInfo:</code> so that it is the same as the method in <span class="content_text"><a href="WritingtheObjective-CPortion.html#//apple_ref/doc/uid/TP40004531-CH4-SW8">Listing 3-1</a></span>.</p></li><li class="li"><p>Modify the <code>customAttributes</code> methods so that is has only one attribute: <code>inputScale</code>, and set appropriate values for the minimum, slider minimum, slider maximum, default, identity and type attributes. The method should look similar to the following:</p><div class="codesample"><table><tr><td scope="row"><pre>- (NSDictionary *)customAttributes<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return [NSDictionary dictionaryWithObjectsAndKeys:<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        [NSDictionary dictionaryWithObjectsAndKeys:<span></span></pre></td></tr><tr><td scope="row"><pre>            [NSNumber numberWithDouble:  1.00], kCIAttributeMin,<span></span></pre></td></tr><tr><td scope="row"><pre>            [NSNumber numberWithDouble:  1.00], kCIAttributeSliderMin,<span></span></pre></td></tr><tr><td scope="row"><pre>            [NSNumber numberWithDouble:  200.00], kCIAttributeSliderMax,<span></span></pre></td></tr><tr><td scope="row"><pre>            [NSNumber numberWithDouble:  4.00], kCIAttributeDefault,<span></span></pre></td></tr><tr><td scope="row"><pre>            [NSNumber numberWithDouble:  1.00], kCIAttributeIdentity,<span></span></pre></td></tr><tr><td scope="row"><pre>            kCIAttributeTypeScalar,           kCIAttributeType,<span></span></pre></td></tr><tr><td scope="row"><pre>            nil],                               @"inputScale",<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        nil];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div></li><li class="li"><p>Modify the <code>outputImage</code> method so that it looks as follows:</p><div class="codesample"><table><tr><td scope="row"><pre>- (CIImage *)outputImage<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    float radius;<span></span></pre></td></tr><tr><td scope="row"><pre>    CISampler *src;<span></span></pre></td></tr><tr><td scope="row"><pre>    // Set up the sampler to use the input image<span></span></pre></td></tr><tr><td scope="row"><pre>    src = [CISampler samplerWithImage:inputImage];<span></span></pre></td></tr><tr><td scope="row"><pre>    radius = [inputScale floatValue] * 0.5;<span></span></pre></td></tr><tr><td scope="row"><pre>    // Set the region-of-interest method for the kernel routine<span></span></pre></td></tr><tr><td scope="row"><pre>    [_PixellateFilterKernel setROISelector:@selector(regionOf:destRect:userInfo:)];<span></span></pre></td></tr><tr><td scope="row"><pre>    // Apply the filter to the kernel, passing the sampler and scale<span></span></pre></td></tr><tr><td scope="row"><pre>    return [self apply:_PixellateFilterKernel, src,<span></span></pre></td></tr><tr><td scope="row"><pre>        inputScale,<span></span></pre></td></tr><tr><td scope="row"><pre>    // This option specifies the domain of definition of the destination image<span></span></pre></td></tr><tr><td scope="row"><pre>        kCIApplyOptionDefinition, [[src definition] insetByX:-radius Y:-radius],<span></span></pre></td></tr><tr><td scope="row"><pre>    // This option sets up the ROI method to gets radius value<span></span></pre></td></tr><tr><td scope="row"><pre>        kCIApplyOptionUserInfo, [NSNumber numberWithFloat:radius], nil];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Note that you need to set up a domain of definition so that the destination image is inset by the radius of the dot. Otherwise, you’ll get a non-transparent edge around the destination image. (See <span class="content_text"><a href="../Overview/Overview.html#//apple_ref/doc/uid/TP40004531-CH6-SW2">“Region-of-Interest Methods”</a></span> and <em><a href="../../CoreImaging/index.html#//apple_ref/doc/uid/TP30001185" target="_top">Core Image Programming Guide</a></em>.)</p></li><li class="li"><p>Save and close the <code>Pixellate.m</code> file.</p></li><li class="li"><p>Open the <code>Description.plist</code> file.</p></li><li class="li"><p>Change <code>CICategoryDistortionEffect</code> to <code>CICategoryStylizeEffect</code>.</p></li><li class="li"><p>Save and close the <code>Description.plist</code> file.</p></li><li class="li"><p>Build the project.</p><p>It should succeed unless you’ve introduced some typographical errors.</p></li><li class="li"><p>Quit Xcode.</p></li><li class="li"><p>Find the <code>Pixellate.plugin</code> file in your project. If you want, move it to a convenient location for validation and testing purposes.</p></li><li class="li"><p>Make sure the image unit is valid. (See <span class="content_text"><a href="../PackagingtheFilter/PackagingtheFilter.html#//apple_ref/doc/uid/TP40004531-CH5-SW3">“Validating an Image Unit.”</a></span>)</p></li><li class="li"><p>Install the validated image unit in <code>/Library/Graphics/Image Units/</code>.</p><p>You can optionally install the image unit in <code>"User"/Library/Graphics/Image Units/</code> although you may need to create the <code>/Graphics/Image Units/</code> folder because it is not created by default. .</p></li><li class="li"><p>Test the image unit. (See <span class="content_text"><a href="../PackagingtheFilter/PackagingtheFilter.html#//apple_ref/doc/uid/TP40004531-CH5-SW5">“Testing an Image Unit.”</a></span>)</p></li></ol><a name="//apple_ref/doc/uid/TP40004531-CH4-SW4" title="Creating a Detective Lens Image Unit"></a><h2>Creating a Detective Lens Image Unit</h2><p>The detective lens image unit is the most challenging image unit in this chapter because it brings together two <code>kernel</code> routines and uses them along with a Core Image built-in filter. This image unit requires four <code>CISampler</code> objects and two region-of-interest methods (one per <code>kernel</code> routine).</p><p>This section assumes that you’ve read <span class="content_text"><a href="../WritingKernels/WritingKernels.html#//apple_ref/doc/uid/TP40004531-CH3-SW25">“Writing Kernel Routines for a Detective Lens .”</a></span> Make sure that you understand the detective lens definition (see <span class="content_text"><a href="../WritingKernels/WritingKernels.html#//apple_ref/doc/uid/TP40004531-CH3-SW45">“Detective Lens Anatomy”</a></span>) and the <code>kernel</code> routines needed for this image unit (see <span class="content_text"><a href="../WritingKernels/WritingKernels.html#//apple_ref/doc/uid/TP40004531-CH3-SW19">Listing 2-7</a></span> and <span class="content_text"><a href="../WritingKernels/WritingKernels.html#//apple_ref/doc/uid/TP40004531-CH3-SW20">Listing 2-8</a></span>). </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004531-CH4-SW11" title="Note"></a><p><strong>Note:</strong>&nbsp;The detective lens image unit discussed here is the same as the lens image unit provided in the CIAnnotation sample application. (See <code>/Developer/Examples</code>.) The CIAnnotation application passes a downsampled image to the lens image unit. Then, it passes a magnification factor to the lens image unit that allows the downsampled image to be magnified to its full resolution when underneath the lens.</p></div><p>The detective lens filter is a mutlipass filter. You’ll need to first apply the lens <code>kernel</code> routine to the input image. Then you need to apply the lens holder <code>kernel</code> routine. Finally, you’ll need to composite the output images from each <code>kernel</code> routine. For this you’ll use the Core Image filter <code>CISourceOverCompositing</code>. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40004531-CH4-SW12" title="Note"></a><p><strong>Note:</strong>&nbsp;A <strong>multipass filter</strong> is one that either applies more than one <code>kernel</code> routine or that repeatedly applies the same <code>kernel</code> routine.</p></div><p>To create the detective lens image unit, follow these steps:</p><ol class="ol"><li class="li"><p>Launch Xcode and choose File > New Project.</p></li><li class="li"><p>In the Assistant window, scroll to  to Standard Apple Plug-ins, select <code>Image Unit Plug-in for Objective C</code> and click Next.</p></li><li class="li"><p>Enter <code>DetectiveLens</code> as the project name and click Finish.</p></li><li class="li"><p>Open the <code>DetectiveLensFilterKernel.cikernel</code> file and replace the code with the code from <span class="content_text"><a href="../WritingKernels/WritingKernels.html#//apple_ref/doc/uid/TP40004531-CH3-SW19">Listing 2-7</a></span> and <span class="content_text"><a href="../WritingKernels/WritingKernels.html#//apple_ref/doc/uid/TP40004531-CH3-SW20">Listing 2-8</a></span>. </p></li><li class="li"><p>Open the <code>DetectiveLens.h</code> file and modify the input parameters so they match what’s shown in <span class="content_text">Listing 3-2</span>. Then save and close the file.</p><a name="//apple_ref/doc/uid/TP40004531-CH4-SW5" title="Listing 3-2The input parameters to the detective lens filter"></a><br/><br/><p class="codesample"><strong>Listing 3-2&nbsp;&nbsp;</strong>The input parameters to the detective lens filter</p><div class="codesample"><table><tr><td scope="row"><pre>@interface DetectiveLensFilter : CIFilter<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CIImage      *inputImage;<span></span></pre></td></tr><tr><td scope="row"><pre>    CIVector     *inputCenter; // center of the lens<span></span></pre></td></tr><tr><td scope="row"><pre>    NSNumber     *inputLensDiameter; // diameter of the lens<span></span></pre></td></tr><tr><td scope="row"><pre>    NSNumber     *inputRingWidth; // width of the lens holder<span></span></pre></td></tr><tr><td scope="row"><pre>    NSNumber     *inputMagnification; // lens magnification<span></span></pre></td></tr><tr><td scope="row"><pre>    NSNumber     *inputRingFilletRadius; // lens holder fillet radius<span></span></pre></td></tr><tr><td scope="row"><pre>    NSNumber     *inputRoundness;  // roundness of the lens, range is 0...1<span></span></pre></td></tr><tr><td scope="row"><pre>    NSNumber     *inputShineOpacity; // opacity of the lens, range is 0...1<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div></li><li class="li"><p>Open the <code>DetectiveLens.m</code> file. There are many modifications that you’ll need to make to this file.</p></li><li class="li"><p>Add the following static declarations just after the <code>@implementation</code> statement: </p><div class="codesample"><table><tr><td scope="row"><pre>static CIKernel *_lensKernel = nil; // for the lens kernel routine<span></span></pre></td></tr><tr><td scope="row"><pre>static CIKernel *_ringKernel = nil; // for the lens holder kernel routine<span></span></pre></td></tr><tr><td scope="row"><pre>static CIImage *_ringMaterialImage = nil; // for the material map<span></span></pre></td></tr><tr><td scope="row"><pre>static CIImage *_lensShineImage = nil; // for the highlight image<span></span></pre></td></tr></table></div><p>You need one <code>CIKernel</code> object for each <code>kernel</code> routine that the image unit uses.</p><p>You need one <code>CIImage</code> object for each image. Recall that the lens <code>kernel</code> routine uses a highlight image and the lens holder <code>kernel</code> routine uses a material map. The input image is part of the interface declaration for the filter because it’s provided by the filter client. In contrast, the highlight and material images need to be included as part of the image unit.</p></li><li class="li"><p>Modify the <code>init</code> method so that it fetches  both <code>kernel</code> routines, using the static <code>CIKernel</code> objects that you just declared. Replace this statement:</p><p><code>_DectiveLensFilterKernel = [[kernels objectAtIndex:0] retain];</code></p><p>with these two statements:</p><div class="codesample"><table><tr><td scope="row"><pre>// Fetch the lens kernel routine<span></span></pre></td></tr><tr><td scope="row"><pre>_lensKernel = [[kernels objectAtIndex:0] retain];<span></span></pre></td></tr><tr><td scope="row"><pre>// Fetch the lens holder kernel routine<span></span></pre></td></tr><tr><td scope="row"><pre>_ringKernel = [[kernels objectAtIndex:1] retain];<span></span></pre></td></tr></table></div></li><li class="li"><p>Modify the <code>init</code> method so that it opens the files that contain the highlight image needed by the lens <code>kernel</code> routine and the material map needed for the lens holder <code>kernel</code> routine. Add the following lines of code to the <code>init</code> method. </p><p>You need to modify the file names and extensions if they don’t match what’s shown (<code>myMaterial.tiff</code> and <code>myHighlight.tiff</code>).</p><div class="codesample"><table><tr><td scope="row"><pre>NSString    *path = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>NSURL    *url = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>path = [bundle pathForResource:@"myMaterial" ofType:@"tiff"];<span></span></pre></td></tr><tr><td scope="row"><pre>url = [NSURL fileURLWithPath:path];<span></span></pre></td></tr><tr><td scope="row"><pre>_ringMaterialImage = [[CIImage imageWithContentsOfURL:url] retain];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>path = [bundle pathForResource:@"myHighlight" ofType:@"tiff"];<span></span></pre></td></tr><tr><td scope="row"><pre>url = [NSURL fileURLWithPath:path];<span></span></pre></td></tr><tr><td scope="row"><pre> _lensShineImage = [[CIImage imageWithContentsOfURL:url] retain];<span></span></pre></td></tr></table></div><p>For each file, the code gets the string that defines the path to the file. Then it creates an <code><a href="../../../../Cocoa/Reference/Foundation/Classes/NSURL_Class/Reference/Reference.html#//apple_ref/occ/cl/NSURL" target="_top">NSURL</a></code> object from that path name. Finally, the code supplies the <code><a href="../../../../Cocoa/Reference/Foundation/Classes/NSURL_Class/Reference/Reference.html#//apple_ref/occ/cl/NSURL" target="_top">NSURL</a></code> object to the <code><a href="../../../Reference/QuartzCoreFramework/Classes/CIImage_Class/Reference/Reference.html#//apple_ref/occ/clm/CIImage/imageWithContentsOfURL:" target="_top">imageWithContentsOfURL:</a></code> method of the <code><a href="../../../Reference/QuartzCoreFramework/Classes/CIImage_Class/Reference/Reference.html#//apple_ref/occ/cl/CIImage" target="_top">CIImage</a></code> class, and retains the image so that it can be used later.</p></li><li class="li"><p>Modify the <code>customAttributes</code> method so that the <code><a href="../../../../Cocoa/Reference/Foundation/Classes/NSDictionary_Class/Reference/Reference.html#//apple_ref/occ/cl/NSDictionary" target="_top">NSDictionary</a></code> object that it returns contains the relevant information for each of the input parameters. Then, when a filter host calls the attributes method for the filter, Core Image invokes your <code>customAttributes</code> method and returns the default, minimum, maximum, and so on, values for each of the input parameters. After modifying the <code>customAttributes</code> method, it should appear as follows: </p><div class="codesample"><table><tr><td scope="row"><pre>- (NSDictionary *)customAttributes<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return [NSDictionary dictionaryWithObjectsAndKeys:<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        [NSDictionary dictionaryWithObjectsAndKeys:<span></span></pre></td></tr><tr><td scope="row"><pre>            [CIVector vectorWithX:200.0 Y:200.0],  kCIAttributeDefault,<span></span></pre></td></tr><tr><td scope="row"><pre>            kCIAttributeTypePosition,              kCIAttributeType,<span></span></pre></td></tr><tr><td scope="row"><pre>            nil],                                  @"inputCenter",<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        [NSDictionary dictionaryWithObjectsAndKeys:<span></span></pre></td></tr><tr><td scope="row"><pre>            [NSNumber numberWithDouble:  1.00], kCIAttributeMin,<span></span></pre></td></tr><tr><td scope="row"><pre>            [NSNumber numberWithDouble:  1.00], kCIAttributeSliderMin,<span></span></pre></td></tr><tr><td scope="row"><pre>            [NSNumber numberWithDouble:500.00], kCIAttributeSliderMax,<span></span></pre></td></tr><tr><td scope="row"><pre>            [NSNumber numberWithDouble:250.00], kCIAttributeDefault,<span></span></pre></td></tr><tr><td scope="row"><pre>            [NSNumber numberWithDouble:250.00], kCIAttributeIdentity,<span></span></pre></td></tr><tr><td scope="row"><pre>            kCIAttributeTypeDistance,           kCIAttributeType,<span></span></pre></td></tr><tr><td scope="row"><pre>            nil],                               @"inputLensDiameter",<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        [NSDictionary dictionaryWithObjectsAndKeys:<span></span></pre></td></tr><tr><td scope="row"><pre>            [NSNumber numberWithDouble:  1.00], kCIAttributeMin,<span></span></pre></td></tr><tr><td scope="row"><pre>            [NSNumber numberWithDouble:  1.00], kCIAttributeSliderMin,<span></span></pre></td></tr><tr><td scope="row"><pre>            [NSNumber numberWithDouble:500.00], kCIAttributeSliderMax,<span></span></pre></td></tr><tr><td scope="row"><pre>            [NSNumber numberWithDouble: 22.00], kCIAttributeDefault,<span></span></pre></td></tr><tr><td scope="row"><pre>            [NSNumber numberWithDouble:  1.00], kCIAttributeIdentity,<span></span></pre></td></tr><tr><td scope="row"><pre>            kCIAttributeTypeDistance,           kCIAttributeType,<span></span></pre></td></tr><tr><td scope="row"><pre>            nil],                               @"inputRingWidth",<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        [NSDictionary dictionaryWithObjectsAndKeys:<span></span></pre></td></tr><tr><td scope="row"><pre>            [NSNumber numberWithDouble:  1.00], kCIAttributeMin,<span></span></pre></td></tr><tr><td scope="row"><pre>            [NSNumber numberWithDouble:  1.00], kCIAttributeSliderMin,<span></span></pre></td></tr><tr><td scope="row"><pre>            [NSNumber numberWithDouble: 30.00], kCIAttributeSliderMax,<span></span></pre></td></tr><tr><td scope="row"><pre>            [NSNumber numberWithDouble:  9.20], kCIAttributeDefault,<span></span></pre></td></tr><tr><td scope="row"><pre>            [NSNumber numberWithDouble:  7.00], kCIAttributeIdentity,<span></span></pre></td></tr><tr><td scope="row"><pre>            kCIAttributeTypeDistance,           kCIAttributeType,<span></span></pre></td></tr><tr><td scope="row"><pre>            nil],                               @"inputRingFilletRadius",<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        [NSDictionary dictionaryWithObjectsAndKeys:<span></span></pre></td></tr><tr><td scope="row"><pre>            [NSNumber numberWithDouble:  1.00], kCIAttributeMin,<span></span></pre></td></tr><tr><td scope="row"><pre>            [NSNumber numberWithDouble:  1.00], kCIAttributeSliderMin,<span></span></pre></td></tr><tr><td scope="row"><pre>            [NSNumber numberWithDouble: 10.00], kCIAttributeSliderMax,<span></span></pre></td></tr><tr><td scope="row"><pre>            [NSNumber numberWithDouble:  3.00], kCIAttributeDefault,<span></span></pre></td></tr><tr><td scope="row"><pre>            [NSNumber numberWithDouble:  1.00], kCIAttributeIdentity,<span></span></pre></td></tr><tr><td scope="row"><pre>            kCIAttributeTypeScalar,             kCIAttributeType,<span></span></pre></td></tr><tr><td scope="row"><pre>            nil],                               @"inputMagnification",<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        [NSDictionary dictionaryWithObjectsAndKeys:<span></span></pre></td></tr><tr><td scope="row"><pre>            [NSNumber numberWithDouble:  0.00], kCIAttributeMin,<span></span></pre></td></tr><tr><td scope="row"><pre>            [NSNumber numberWithDouble:  0.00], kCIAttributeSliderMin,<span></span></pre></td></tr><tr><td scope="row"><pre>            [NSNumber numberWithDouble:  1.00], kCIAttributeSliderMax,<span></span></pre></td></tr><tr><td scope="row"><pre>            [NSNumber numberWithDouble:  0.86], kCIAttributeDefault,<span></span></pre></td></tr><tr><td scope="row"><pre>            [NSNumber numberWithDouble:  1.00], kCIAttributeIdentity,<span></span></pre></td></tr><tr><td scope="row"><pre>            kCIAttributeTypeScalar,             kCIAttributeType,<span></span></pre></td></tr><tr><td scope="row"><pre>            nil],                               @"inputRoundness",<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        [NSDictionary dictionaryWithObjectsAndKeys:<span></span></pre></td></tr><tr><td scope="row"><pre>            [NSNumber numberWithDouble:  0.00], kCIAttributeMin,<span></span></pre></td></tr><tr><td scope="row"><pre>            [NSNumber numberWithDouble:  0.00], kCIAttributeSliderMin,<span></span></pre></td></tr><tr><td scope="row"><pre>            [NSNumber numberWithDouble:  1.00], kCIAttributeSliderMax,<span></span></pre></td></tr><tr><td scope="row"><pre>            [NSNumber numberWithDouble:  0.50], kCIAttributeDefault,<span></span></pre></td></tr><tr><td scope="row"><pre>            [NSNumber numberWithDouble:  1.00], kCIAttributeIdentity,<span></span></pre></td></tr><tr><td scope="row"><pre>            kCIAttributeTypeScalar,             kCIAttributeType,<span></span></pre></td></tr><tr><td scope="row"><pre>            nil],                               @"inputShineOpacity",<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        nil];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div></li><li class="li"><p>Write a region-of-interest method for the lens holder <code>kernel</code> routine. </p><p>Recall that the region-of-interest method returns the rectangle that specifies the region of the sampler to use for fetching image data for the <code>kernel</code> routine. The region of interest for the lens holder <code>kernel</code> routine is simply the rectangle that specifies the size of the material map.</p><p>The region-of-interest method must have signature compatible with the following:</p><div class="codesample"><table><tr><td scope="row"><pre>- (CGRect) regionOf:(int)samplerIndex destRect:(CGRect)r userInfo:obj;<span></span></pre></td></tr></table></div><p>This method is a callback that’s invoked by Core Image whenever your <code>kernel</code> routine needs a sample for processing. The lens holder <code>kernel</code> routine uses only one sampler, whose sampler index is <code>0</code>. (Sampler indexes for an ROI method start at <code>0</code> and are sequential.) If the sampler index is <code>0</code>, then the ROI method should return the size of the material map. Otherwise, it needs to return the destination rectangle that Core Image passed to the routine.</p><p>The <code>userInfo</code> parameter for any region-of-interest method is what you use to pass any necessary data to the method. This particular region-of-interest method needs to have the sampler for the material map passed to it so that the ROI method can determine the size of the map. The <code><a href="../../../Reference/QuartzCoreFramework/Classes/CISampler_Class/Reference/Reference.html#//apple_ref/occ/instm/CISampler/extent" target="_top">extent</a></code> method of the <code><a href="../../../Reference/QuartzCoreFramework/Classes/CISampler_Class/Reference/Reference.html#//apple_ref/occ/cl/CISampler" target="_top">CISampler</a></code>  class does just that.</p><div class="codesample"><table><tr><td scope="row"><pre>- (CGRect)ringROI:(int)sampler forRect:(CGRect)R userInfo:(CISampler *)material<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if (sampler == 0)<span></span></pre></td></tr><tr><td scope="row"><pre>        return [material extent];<span></span></pre></td></tr><tr><td scope="row"><pre>    return R;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div></li><li class="li"><p>Write a region-of-interest method for the lens  <code>kernel</code> routine. This method is a bit more complex than the one for the lens holder <code>kernel</code> routine.</p><p>This method needs to return  the region of interest for three <code>sampler</code> objects:</p><ul class="ul"><li class="li"><p>Sampler <code>0</code> fetches samples from the downsampled image (that is, what appears as unmagnified—the pixels outside the lens). The region of interest  is simply the rectangle passed to the ROI method.</p></li><li class="li"><p>Sampler <code>1</code> fetches samples from the high resolution image. The region of interest depends on the magnification and width of the lens. The number of pixels needed from the source image is defined by the width of the lens divided by the magnification. The origin of the rectangle that defines this area is the center of the lens minus the number of pixels needed.</p></li><li class="li"><p>Sampler <code>2</code>  fetches samples from the highlight image. The region of interest is a rectangle (<code><a href="../../../Reference/CGGeometry/Reference/reference.html#//apple_ref/c/tdef/CGRect" target="_top">CGRect</a></code> data type) that describes the size of the highlight image. You can obtain the size using the <code><a href="../../../Reference/QuartzCoreFramework/Classes/CISampler_Class/Reference/Reference.html#//apple_ref/occ/instm/CISampler/extent" target="_top">extent</a></code>   method of the <code>CISampler</code> object.</p></li></ul><p>The <code>userInfo</code> needed for this particular region-of-interest method is an array that contains three of the filter input parameters (center of lens, width of lens, magnification factor) and the <code>CISampler</code> object for the highlight image.</p><p>The lens ROI method should look similar to the following:</p><div class="codesample"><table><tr><td scope="row"><pre>- (CGRect)lensROI:(int)sampler forRect:(CGRect)R userInfo:(NSArray *)array<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CIVector *oCenter;<span></span></pre></td></tr><tr><td scope="row"><pre>    NSNumber *oWidth, *oMagnification;<span></span></pre></td></tr><tr><td scope="row"><pre>    CISampler *shine;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Fetch the necessary input parameters from the userInfo parameter<span></span></pre></td></tr><tr><td scope="row"><pre>    oCenter = [array objectAtIndex:0];<span></span></pre></td></tr><tr><td scope="row"><pre>    oWidth = [array objectAtIndex:1];<span></span></pre></td></tr><tr><td scope="row"><pre>    oMagnification = [array objectAtIndex:2];<span></span></pre></td></tr><tr><td scope="row"><pre>    shine = [array objectAtIndex:3];  // shine is a CISampler object<span></span></pre></td></tr><tr><td scope="row"><pre>    if (sampler == 2)<span></span></pre></td></tr><tr><td scope="row"><pre>        return [shine extent];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Determine the area of the original image used with the lens where it is<span></span></pre></td></tr><tr><td scope="row"><pre>    // currently we only need R, because the lens is a magnifier<span></span></pre></td></tr><tr><td scope="row"><pre>    if (sampler == 1)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        float cx, cy, width, mag;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        cx = [oCenter X];<span></span></pre></td></tr><tr><td scope="row"><pre>        cy = [oCenter Y];<span></span></pre></td></tr><tr><td scope="row"><pre>        width = [oWidth floatValue];<span></span></pre></td></tr><tr><td scope="row"><pre>        mag = [oMagnification floatValue];<span></span></pre></td></tr><tr><td scope="row"><pre>        width /= mag; // calculates the actual pixels needed from the source<span></span></pre></td></tr><tr><td scope="row"><pre>        R = CGRectMake(cx - width, cy - width, width*2.0, width*2.0);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return R; // If the sampler is 0, ROI calculation is not needed.<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p> </p></li><li class="li"><p>Write the <code>outputImage</code> method.</p><p>For each <code>kernel</code> routine, this method:</p><ul class="ul"><li class="li"><p>Creates <code>CISampler</code> objects, performing any necessary set up work for them.</p></li><li class="li"><p>Calculates any values needed by the ROI method or by the <code>kernel</code> routine. This includes calculating the rectangle that defines the shape of the destination image (otherwise known as the domain of definition).</p></li><li class="li"><p>Sets up the <code>userInfo</code> data needed by the ROI method so that is can be passed as an option (<code>kCIApplyOptionUserInfo</code>) to the <code>apply:</code> method of the <code>CIFilter</code> object.</p></li><li class="li"><p>Sets the ROI method to use for the <code>kernel</code> routine.</p></li><li class="li"><p>Calls the <code>apply:</code> method of the <code>CIFilter</code> object.</p></li></ul><p>Then the method composites the resulting images into a final image by using the Core Image <code>CISourceOverCompositing</code> filter.</p><p>The method is rather long and performs many tasks, so you’ll want to read the detailed explanation for each lettered line (a, b, c, and so on) that appears following the code. </p><div class="codesample"><table><tr><td scope="row"><pre>- (CIImage *)outputImage<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    float radius, cx, cy, ringwidth, mag;<span></span></pre></td></tr><tr><td scope="row"><pre>    CGRect R, extent;<span></span></pre></td></tr><tr><td scope="row"><pre>    CISampler *src, *shine, *material;<span></span></pre></td></tr><tr><td scope="row"><pre>    CIImage *lensedImage, *ringImage;<span></span></pre></td></tr><tr><td scope="row"><pre>    CIFilter *compositedImage;<span></span></pre></td></tr><tr><td scope="row"><pre>    NSArray *array;<span></span></pre></td></tr><tr><td scope="row"><pre>    CISampler *magsrc;<span></span></pre></td></tr><tr><td scope="row"><pre>    CGAffineTransform CT;<span></span></pre></td></tr><tr><td scope="row"><pre>    CIVector *shineSize, *materialSize;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // ********* Lens *********<span></span></pre></td></tr><tr><td scope="row"><pre>    src = [CISampler samplerWithImage:inputImage]; <span>// 1</span></pre></td></tr><tr><td scope="row"><pre>    shine = [CISampler samplerWithImage:_lensShineImage]; <span>// 2</span></pre></td></tr><tr><td scope="row"><pre>    // Set up work needed for the magnified image sampler<span></span></pre></td></tr><tr><td scope="row"><pre>    cx = [inputCenter X];<span></span></pre></td></tr><tr><td scope="row"><pre>    cy = [inputCenter Y];<span></span></pre></td></tr><tr><td scope="row"><pre>    mag = [inputMagnification floatValue];<span></span></pre></td></tr><tr><td scope="row"><pre>    CT = CGAffineTransformTranslate(CGAffineTransformScale(<span></span></pre></td></tr><tr><td scope="row"><pre>        CGAffineTransformMakeTranslation(cx, cy), mag, mag), -cx, -cy);<span></span></pre></td></tr><tr><td scope="row"><pre>    magsrc = [CISampler samplerWithImage:[inputImage imageByApplyingTransform:CT]]; <span>// 3</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    radius = [inputLensDiameter floatValue] * 0.5; <span>// 4</span></pre></td></tr><tr><td scope="row"><pre>    R.origin.x = cx - radius; <span>// 5</span></pre></td></tr><tr><td scope="row"><pre>    R.origin.y = cy - radius;<span></span></pre></td></tr><tr><td scope="row"><pre>    R.size.width = 2.0 * radius;<span></span></pre></td></tr><tr><td scope="row"><pre>    R.size.height = 2.0 * radius;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    extent = [shine extent]; <span>// 6</span></pre></td></tr><tr><td scope="row"><pre>    shineSize = [CIVector vectorWithX:extent.size.width Y:extent.size.height]; <span>// 7</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    array = [NSArray arrayWithObjects:inputCenter, inputLensDiameter,<span></span></pre></td></tr><tr><td scope="row"><pre>                inputMagnification, shine, nil]; <span>// 8</span></pre></td></tr><tr><td scope="row"><pre>    [_lensKernel setROISelector:@selector(lensROI:forRect:userInfo:)]; <span>// 9</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    lensedImage = [self apply:_lensKernel, src, magsrc, shine, inputCenter,<span></span></pre></td></tr><tr><td scope="row"><pre>            [NSNumber numberWithFloat:radius + 2.0],<span></span></pre></td></tr><tr><td scope="row"><pre>              inputMagnification, inputRoundness,<span></span></pre></td></tr><tr><td scope="row"><pre>              inputShineOpacity, shineSize,<span></span></pre></td></tr><tr><td scope="row"><pre>             kCIApplyOptionDefinition, [[src definition] unionWithRect:R],<span></span></pre></td></tr><tr><td scope="row"><pre>             kCIApplyOptionUserInfo, array, nil];  <span>// 10</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // ********* Lens Holder   *********<span></span></pre></td></tr><tr><td scope="row"><pre>    material = [CISampler samplerWithImage:_ringMaterialImage]; <span>// 11</span></pre></td></tr><tr><td scope="row"><pre>    ringwidth = [inputRingWidth floatValue]; <span>// 12</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    R.origin.x = cx - radius - ringwidth; <span>// 13</span></pre></td></tr><tr><td scope="row"><pre>    R.origin.y = cy - radius - ringwidth;<span></span></pre></td></tr><tr><td scope="row"><pre>    R.size.width = 2.0 * (radius + ringwidth);<span></span></pre></td></tr><tr><td scope="row"><pre>    R.size.height = 2.0 * (radius + ringwidth);<span></span></pre></td></tr><tr><td scope="row"><pre>    extent = [material extent]; <span>// 14</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    materialSize = [CIVector vectorWithX:extent.size.width Y:extent.size.height]; <span>// 15</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [_ringKernel setROISelector:@selector(ringROI:forRect:userInfo:)]; <span>// 16</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    ringImage = [self apply:_ringKernel, material, inputCenter,<span></span></pre></td></tr><tr><td scope="row"><pre>                [NSNumber numberWithFloat:radius],<span></span></pre></td></tr><tr><td scope="row"><pre>                [NSNumber numberWithFloat:radius+ringwidth],<span></span></pre></td></tr><tr><td scope="row"><pre>                inputRingFilletRadius,<span></span></pre></td></tr><tr><td scope="row"><pre>                  materialSize,<span></span></pre></td></tr><tr><td scope="row"><pre>                  kCIApplyOptionDefinition,<span></span></pre></td></tr><tr><td scope="row"><pre>                  [CIFilterShape shapeWithRect:R],<span></span></pre></td></tr><tr><td scope="row"><pre>                  kCIApplyOptionUserInfo, material, nil]; <span>// 17</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // ********* Lens and Lens Holder Composited *********<span></span></pre></td></tr><tr><td scope="row"><pre>    compositedImage = [CIFilter filterWithName:@"CISourceOverCompositing"<span></span></pre></td></tr><tr><td scope="row"><pre>            keysAndValues:@"inputImage", ringImage,<span></span></pre></td></tr><tr><td scope="row"><pre>            @"inputBackgroundImage", lensedImage, nil]; <span>// 18</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return [compositedImage valueForKey:@"outputImage"]; <span>// 19</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here is what the code does:</p><ul class="simple-spaceabove"><li><p> 1. Creates a CISampler object for the source image.</p></li><li><p>2. Creates a CISampler object for the highlight image.</p></li><li><p>3. Creates a CISampler object for the magnified source, using the transform calculated in the previous lines of code.</p></li><li><p>4. Extracts the diameter of the lens as a <code>float</code> value, then calculates the radius.</p></li><li><p>5. Computes, along with the next three lines of code, the rectangle that will be used later to compute  the size of the destination image—the domain of definition.</p></li><li><p>6. Retrieves the size of the highlight image.</p></li><li><p>7. Creates a <code>CIVector</code> object that contains the size of the highlight image.</p></li><li><p>8. Sets up the array that’s passed as the <code>userInput</code> parameter to the region-of-interest method. Recall that the ROI method takes three of the filter input parameters (<code>inputCenter</code>, <code>inputLensDiameter</code>, and <code>inputMagnification</code>) as well as the <code>CISampler</code> object for the highlight image.</p></li><li><p>9. Sets the region-of-interest method for the lens <code>CIKernel</code> object. This is the method that Core Image invokes whenever your lens <code>kernel</code> routine requires a sample.</p></li><li><p>10. Applies the lens <code>kernel</code> routine to the input image, supplying the necessary input variables, the domain of definition, and the array that’s needed by the ROI method. Note that the domain of definition is specified as a <code><a href="../../../Reference/QuartzCoreFramework/Classes/CIFilterShape_Class/Reference/Reference.html#//apple_ref/occ/cl/CIFilterShape" target="_top">CIFilterShape</a></code> object that is the union of the previously calculated rectangle (see e) and the domain of definition of the <code>CISampler</code> object for the source image.</p></li><li><p>11. Creates a <code>CISampler</code> object for the material map needed by the lens holder <code>kernel</code> routine.</p></li><li><p>12. Extracts the width of the lens holder as a <code>float </code>value.</p></li><li><p>13. Calculates, along with the next three lines of code, the rectangle that is used for the domain of definition. Notice that this rectangle encloses the lens holder. Core Image will use this information to restrict calculations. The lens holder <code>kernel</code> routine won’t be called for any pixel that falls outside this rectangle.</p></li><li><p>14. Retrieves the size of the material map.</p></li><li><p>15. Creates a <code>CIVector</code> object that represents the width and height of the material map.</p></li><li><p>16. Sets the region-of-interest method for the lens holder <code>CIKernel</code> object. This is the method that Core Image invokes whenever your lens holder <code>kerne</code>l routine requires a sample.</p></li><li><p>17. Applies the lens holder <code>kernel</code> routine to the material map, supplying the necessary input variables, the rectangle the defines the domain of definition, and the <code>CISampler</code> object for the material map (passed as the <code>userInfo</code> parameter). </p></li><li><p>18. Creates a filter object for the Core Image <code>CISourceOverCompositing</code> filter, supplying the image produced by the len holder <code>kernel</code> routine as the foreground image and the image produced by the lens <code>kernel</code> routine as the background image.</p></li><li><p>19. Returns the value associated with the <code>outputImage</code> key for the filter.</p></li></ul></li><li class="li"><p>Save and close the <code>DetectiveLens.m</code> file.</p></li><li class="li"><p>Select Project > Add to Project to add the highlight image file (<code>myHighlight.tiff</code>) to the project.</p><p>The name and file type must match what you provide in the <code>init</code> method.</p></li><li class="li"><p>Select Project > Add to Project to add the material map file (<code>myMaterialMap.tiff</code>) to the project. </p><p>The name and file type must match what you provide in the <code>init</code> method.</p></li><li class="li"><p>Open the <code>Description.plist</code> file.</p></li><li class="li"><p>Change the display name (look for the key <code>CIAttributeFilterDisplayName</code>) from <code>DetectiveLens</code> to <code>Detective Lens</code>.</p></li><li class="li"><p>Save and close the <code>Description.plist</code> file.</p></li><li class="li"><p>Build the project.</p><p>It should succeed unless you’ve introduced some typographical errors.</p></li><li class="li"><p>Quit Xcode.</p></li><li class="li"><p>Find the <code>DetectiveLens.plugin</code> file in your project. If you want, move it to a convenient location for validation and testing.</p></li><li class="li"><p>Make sure the image unit is valid and works properly by following the instructions in <span class="content_text"><a href="../PackagingtheFilter/PackagingtheFilter.html#//apple_ref/doc/uid/TP40004531-CH5-SW3">“Validating an Image Unit”</a></span> and <span class="content_text"><a href="../PackagingtheFilter/PackagingtheFilter.html#//apple_ref/doc/uid/TP40004531-CH5-SW5">“Testing an Image Unit.”</a></span></p></li></ol><a name="//apple_ref/doc/uid/TP40004531-CH4-SW13" title="Next Steps"></a><h2>Next Steps</h2><p>If you’ve successfully created all the image units in this chapter, you might try modifying the detective lens image unit by adding a handle that’s typical of a detective lens!</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../WritingKernels/WritingKernels.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../PackagingtheFilter/PackagingtheFilter.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-05-06<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/GraphicsImaging/Conceptual/ImageUnitTutorial/WritingtheObjective-CPortion/WritingtheObjective-CPortion.html%3Fid%3DTP40004531-2.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/GraphicsImaging/Conceptual/ImageUnitTutorial/WritingtheObjective-CPortion/WritingtheObjective-CPortion.html%3Fid%3DTP40004531-2.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/GraphicsImaging/Conceptual/ImageUnitTutorial/WritingtheObjective-CPortion/WritingtheObjective-CPortion.html%3Fid%3DTP40004531-2.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>