/*	File:		ExportCMX3600.c	Written by:	Jim Batson	Copyright:	й 1994 by Apple Computer, Inc., all rights reserved.  Change History (most recent first):  <1>	 	12/7/94		khs		changed the format of the file to the new look and feel*/// INCLUDES#include <Resources.h>#include <Files.h>#include <Movies.h>#include <Events.h>#include <Components.h>#include <QuickTimeComponents.h>#include <FixMath.h>#include <Errors.h>#include <Memory.h>#include <Script.h>#include <ToolUtils.h>//#ifndef powerc //#include <A4Stuff.h>//#endif// TYPEDEFStypedef struct {	ComponentInstance		self;		TimeCodeDef 			dstTcdef;		TimeCodeRecord 			dstTcrec;		Str255 					EDLtitle;} ExportCMX3600GlobalsRecord, *ExportCMX3600Globals;// FUNCTION PROTOTYPESpascal ComponentResult ExportCMX3600Open( ExportCMX3600Globals store, ComponentInstance self );pascal ComponentResult ExportCMX3600Close( ExportCMX3600Globals store, ComponentInstance self );pascal ComponentResult ExportCMX3600CanDo( ExportCMX3600Globals store, short ftnNumber );pascal ComponentResult ExportCMX3600Version( ExportCMX3600Globals store );pascal ComponentResult ExportCMX3600ToFile(ExportCMX3600Globals store, 		const FSSpec *theFile, Movie m, Track onlyThisTrack, TimeValue startTime, TimeValue duration);extern pascal ComponentResult ExportCMX3600DoUserDialog(ExportCMX3600Globals store, 		Movie theMovie, Track onlyThisTrack, TimeValue startTime, TimeValue duration, Boolean *canceled);// MAIN// entry point for all Component Manager requests#ifdef THINK_C	#ifndef DEBUG_LINKED		pascal ComponentResult main( ComponentParameters *params, Handle store );		pascal ComponentResult main(ComponentParameters *params, Handle storage)	#else		pascal ComponentResult ExportCMX3600Dispatcher( ComponentParameters *params, Handle store );		pascal ComponentResult ExportCMX3600Dispatcher(ComponentParameters *params, Handle storage)	#endif#else	pascal ComponentResult ExportCMX3600Dispatcher( ComponentParameters *params, Handle store );	pascal ComponentResult ExportCMX3600Dispatcher(ComponentParameters *params, Handle storage)#endif{	OSErr err = badComponentSelector;	ComponentFunctionUPP componentProc = 0;	switch (params->what) {		case kComponentOpenSelect: componentProc = (ComponentFunctionUPP)ExportCMX3600Open; break;		case kComponentCloseSelect: componentProc = (ComponentFunctionUPP)ExportCMX3600Close; break;		case kComponentCanDoSelect: componentProc = (ComponentFunctionUPP)ExportCMX3600CanDo; break;		case kComponentVersionSelect: componentProc = (ComponentFunctionUPP)ExportCMX3600Version; break;		case kMovieExportToFileSelect: componentProc = (ComponentFunctionUPP)ExportCMX3600ToFile; break;		case kMovieExportDoUserDialogSelect: componentProc = (ComponentFunctionUPP)ExportCMX3600DoUserDialog; break;	}	if (componentProc)		err = CallComponentFunctionWithStorage(storage, params, componentProc);	return err;}pascal ComponentResult ExportCMX3600CanDo( ExportCMX3600Globals store, short ftnNumber ){	switch (ftnNumber) {		case kComponentOpenSelect:		case kComponentCloseSelect:		case kComponentCanDoSelect:		case kComponentVersionSelect:		case kMovieExportToFileSelect:		case kMovieExportDoUserDialogSelect:			return true;			break;		default:			return false;			break;	}}pascal ComponentResult ExportCMX3600Version( ExportCMX3600Globals store ){	return 0x00010001;}pascal ComponentResult ExportCMX3600Open(ExportCMX3600Globals store, ComponentInstance self){	OSErr err;	Str63 defTitle = {"\pUntitled"};	#ifdef DEBUG_LINKED	SetComponentInstanceA5(self, GetComponentRefcon((Component)self));#endif	store = (ExportCMX3600Globals)NewPtrClear(sizeof(ExportCMX3600GlobalsRecord));	if (err = MemError()) goto bail;	store->self = self;	BlockMove( &defTitle[0], &store->EDLtitle[0], defTitle[0]+1 );		store->dstTcdef.flags = tc24HourMax | tcDropFrame;	store->dstTcdef.fTimeScale = 2997;	store->dstTcdef.frameDuration = 100;	store->dstTcdef.numFrames = 30;	store->dstTcrec.t.hours = 0;	store->dstTcrec.t.minutes = 1;	store->dstTcrec.t.seconds = 0;	store->dstTcrec.t.frames = 0;		SetComponentInstanceStorage(self, (Handle)store);bail:	return err;}pascal ComponentResult ExportCMX3600Close(ExportCMX3600Globals store, ComponentInstance self){	if (store) DisposPtr((Ptr)store);	return noErr;}// еееееееееееееееееееееееееееееееееееее// The Conversion Code starts herevoid outputChars( short refNum, StringPtr s );void outputChars( short refNum, StringPtr s ){	long count;	long i;	char *sp;	char c;		sp = (char*)s;	count = *sp++;	for (i = 0; i < count; i++, sp++) {		c = *sp;		if ((c >= 'a') && (c <= 'z'))			*sp = c + ('A' - 'a');		else if (c == ';')			*sp = ':';		}	FSWrite( refNum, &count, &s[1] );}void outputCharsLF( short refNum, StringPtr s );void outputCharsLF( short refNum, StringPtr s ){	long count;	char lf[2];		outputChars(refNum,s);		lf[0] = 0xd;	lf[1] = 0xa;	count = 2;	FSWrite( refNum, &count, &lf[0] );}void outputEditNum( short refNum, long editNum );void outputEditNum( short refNum, long editNum ){	char s[6];		s[0] = 5;	s[4] = ' ';	s[5] = ' ';	s[3] = '0' + editNum % 10;	editNum /= 10;	s[2] = '0' + editNum % 10;	editNum /= 10;	s[1] = '0' + editNum % 10;		outputChars( refNum, (StringPtr)s );}void outputRate( short refNum, double rate );void outputRate( short refNum, double rate ){	char s[5];	long intNum;	long fracNum;		s[0] = 4;	intNum = rate;	fracNum = (rate*10.0 - intNum*10);	s[2] = '0' + intNum % 10;	intNum /= 10;	s[1] = '0' + intNum % 10;	s[3] = '.';	s[4] = '0' + fracNum;		outputChars( refNum, (StringPtr)s );}pascal ComponentResult ExportCMX3600ToFile(ExportCMX3600Globals store, const FSSpec *theFile, 				Movie theMovie, Track theTrack, TimeValue startTime, TimeValue duration){	OSErr err = noErr;	short refNum = 0;	long editCnt = 1;	Str63 tapename;	Media theMedia;	TimeScale movieTimeScale;	TimeScale mediaTimeScale;	TimeValue editDur;	TimeValue mediaTime;	MediaHandler mh;	Handle srcNameH = nil;	TimeCodeDef tcdef;	TimeCodeRecord tcrec;	UserData srcRef = nil;	Str63 inTime, outTime;	long dstFrameCnt = 0;	Str63 lastDstTime, newDstTime;	long srcFrameIn, srcFrameOut;	TimeCodeRecord dstTcrec;	Boolean lastGuyWasDropFrame;	Boolean thisGuyIsDropFrame;	Boolean dstIsDropFrame;		if (!theTrack) {		// We currently only handle a single TimeCode track		theTrack = GetMovieIndTrackType( theMovie, 1, TimeCodeMediaType, movieTrackMediaType);		if (!theTrack) return trackIDNotFound;	}	// open up the data fork of the CMX3600 output file (the caller is responsible	//	for creating the file)	err = FSpOpenDF(theFile, fsRdWrPerm, &refNum);	if (err = ResError()) goto bail;	srcNameH = NewHandle(4);		theMedia = GetTrackMedia(theTrack);	theMovie = GetTrackMovie(theTrack);	mh = GetMediaHandler( theMedia );	movieTimeScale = GetMovieTimeScale(theMovie);	mediaTimeScale = GetMediaTimeScale(theMedia);				dstTcrec = store->dstTcrec;		err = TCTimeCodeToFrameNumber(mh, &store->dstTcdef, &dstTcrec, &dstFrameCnt); if (err) goto bail;		err = TCFrameNumberToTimeCode(mh, dstFrameCnt, &store->dstTcdef, &dstTcrec); if (err) goto bail;	err = TCTimeCodeToString(mh, &store->dstTcdef, &dstTcrec, lastDstTime); if (err) goto bail;		// Output destination info	outputCharsLF(refNum,"\p");	outputChars(refNum,"\pTITLE: ");	outputCharsLF(refNum,store->EDLtitle);	outputCharsLF(refNum,"\p");	dstIsDropFrame = lastGuyWasDropFrame = ((store->dstTcdef.flags & tcDropFrame) == tcDropFrame);	if (dstIsDropFrame) 		outputCharsLF(refNum,"\pFCM: DROP FRAME");	else		outputCharsLF(refNum,"\pFCM: NON-DROP FRAME");	outputCharsLF(refNum,"\p");		// iterate through the movie time segment we were given	GetTrackNextInterestingTime( theTrack, nextTimeTrackEdit | nextTimeEdgeOK | nextTimeIgnoreActiveSegment, 						startTime, fixed1, &startTime, &editDur );	while (startTime < duration) {		TimeValue mediaStart;		Fixed trackRate;				trackRate = GetTrackEditRate(theTrack, startTime);		mediaStart = TrackTimeToMediaTime( startTime, theTrack );				if (mediaStart < 0) {  // Empty edit segment			TimeRecord tr;			long numframes;			Str63 inEmpty, outEmpty;			TimeCodeRecord emptyTcrec;						// convert edit duration to destination time code scale			tr.base = nil;			tr.scale = movieTimeScale;			tr.value.lo = editDur;			tr.value.hi = 0;			ConvertTimeScale(&tr, store->dstTcdef.fTimeScale);			// convert to number of frames			numframes = tr.value.lo / store->dstTcdef.frameDuration;						if (numframes) {	// ignore if we fall out due to round off				// Calculate new dst out time				dstFrameCnt += numframes;				err = TCFrameNumberToTimeCode(mh, dstFrameCnt, &store->dstTcdef, &dstTcrec); if (err) goto bail;				err = TCTimeCodeToString(mh, &store->dstTcdef, &dstTcrec, newDstTime); if (err) goto bail;								// Make blank in & out times				err = TCFrameNumberToTimeCode(mh, 0, &store->dstTcdef, &emptyTcrec); if (err) goto bail;				err = TCTimeCodeToString(mh, &store->dstTcdef, &emptyTcrec, inEmpty); if (err) goto bail;				err = TCFrameNumberToTimeCode(mh, numframes, &store->dstTcdef, &emptyTcrec); if (err) goto bail;				err = TCTimeCodeToString(mh, &store->dstTcdef, &emptyTcrec, outEmpty); if (err) goto bail;												// handle drop-frames changing				if (dstIsDropFrame != lastGuyWasDropFrame) {					if (dstIsDropFrame) 						outputCharsLF(refNum,"\pFCM: DROP FRAME");					else						outputCharsLF(refNum,"\pFCM: NON-DROP FRAME");					lastGuyWasDropFrame = dstIsDropFrame;					}								// put out the edit				outputEditNum(refNum, editCnt++);				outputChars(refNum,"\pBL        V    C         ");				outputChars(refNum,inEmpty);				outputChars(refNum,"\p  ");				outputChars(refNum,outEmpty);				outputChars(refNum,"\p  ");				outputChars(refNum,lastDstTime);				outputChars(refNum,"\p  ");				outputCharsLF(refNum,newDstTime);				outputCharsLF(refNum,"\p");								// transfer dst out time to dst in time				BlockMove(&newDstTime[0], &lastDstTime[0], newDstTime[0]+1 );				}			startTime++;	// bump start time so GetTrackNextInteresting moves along		}		else {			TimeRecord tr;			TimeValue mediaNext;			TimeValue mediaStop;			TimeValue mediaDur;			long origSrcFrameIn;			long srcNumFrames;			short i;						// convert edit duration to media time scale			tr.value.hi = 0;			tr.value.lo = editDur;			tr.base = 0;			tr.scale = movieTimeScale;			ConvertTimeScale(&tr,mediaTimeScale);			mediaStop = mediaStart + tr.value.lo;						while (mediaStart < mediaStop) {				// get next sample in media for edit				GetMediaNextInterestingTime( theMedia, nextTimeMediaSample, mediaStart, fixed1, &mediaNext, &mediaDur );								// fix up if we run off end				if ((mediaNext >= mediaStop) || (mediaNext < 0)) {					mediaNext = mediaStop;					}								// make src in time code				err = TCGetTimeCodeAtTime( mh, mediaStart, &srcFrameIn, &tcdef, &tcrec, &srcRef ); if (err) goto bail;				err = TCTimeCodeToString( mh, &tcdef, &tcrec, inTime ); if (err) goto bail;								// make src out time code				err = TCGetTimeCodeAtTime( mh, mediaNext-1, &srcFrameOut, &tcdef, &tcrec, nil ); if (err) goto bail;				err = TCTimeCodeToString( mh, &tcdef, &tcrec, outTime ); if (err) goto bail;								// remember some info for rate != 1x				origSrcFrameIn = srcFrameIn;				srcNumFrames = srcFrameOut - srcFrameIn;								// calculate dst out time code				dstFrameCnt += srcNumFrames;				err = TCFrameNumberToTimeCode(mh, dstFrameCnt, &store->dstTcdef, &dstTcrec); if (err) goto bail;				err = TCTimeCodeToString(mh, &store->dstTcdef, &dstTcrec, newDstTime); if (err) goto bail;								// Get source name, if no source name, make it all blanks				i = 0;				if (srcRef) {		// get source name					err = GetUserDataText( srcRef, srcNameH, 'name', 1, langEnglish );					if (!err) {						long slen;						slen = GetHandleSize(srcNameH);						for (i = 0; (i < 8) && (i < slen); i++) {							tapename[i+1] = (*srcNameH)[i];							// break on illegal chars for tape name							//     (if I only knew what they really where╔)							if (tapename[i+1] == ' ') break;							if (tapename[i+1] == ',') break;							if (tapename[i+1] == ':') break;							}						DisposeUserData( srcRef );					}				}				if (i == 0) {		// let's give the tape a name					// the best thing would be to keep track of the sample descriptions so we could					// name them a,b,c,╔					tapename[++i] = 'A';					}				for (; i < 8; i++) {					tapename[i+1] = ' ';					}				tapename[0] = 8;								// handle drop-frame changing				thisGuyIsDropFrame = ((tcdef.flags & tcDropFrame) == tcDropFrame);				if (thisGuyIsDropFrame != lastGuyWasDropFrame) {					if (thisGuyIsDropFrame) 						outputCharsLF(refNum,"\pFCM: DROP FRAME");					else						outputCharsLF(refNum,"\pFCM: NON-DROP FRAME");					lastGuyWasDropFrame = thisGuyIsDropFrame;					}								// output the edit				outputEditNum(refNum, editCnt++);				outputChars(refNum,tapename);				outputChars(refNum,"\p  AA/V C         ");				outputChars(refNum,inTime);				outputChars(refNum,"\p  ");				outputChars(refNum,outTime);				outputChars(refNum,"\p  ");				outputChars(refNum,lastDstTime);				outputChars(refNum,"\p  ");				outputCharsLF(refNum,newDstTime);								// transfer dst out time to dst in time				BlockMove(&newDstTime[0], &lastDstTime[0], sizeof(newDstTime) );								// handle non 1x playback				if (trackRate != fixed1) {					double editRate = (double)trackRate / fixed1;					long realFrameCnt;					Str63 newTime;										// number of frames in source going to dest					realFrameCnt = FixMul(trackRate,srcNumFrames);										// calculate src out time code					err = TCFrameNumberToTimeCode(mh, origSrcFrameIn+realFrameCnt, &tcdef, &tcrec); if (err) goto bail;					err = TCTimeCodeToString( mh, &tcdef, &tcrec, newTime ); if (err) goto bail;										// output the rate playback					outputChars(refNum, "\pM2   ");					outputChars(refNum,tapename);					editRate *= tcdef.numFrames;					outputChars(refNum,"\p       ");					outputRate(refNum, editRate);					outputChars(refNum,"\p                    ");					outputCharsLF(refNum,newTime);					}				outputCharsLF(refNum,"\p");								mediaStart = mediaNext;				}		}		GetTrackNextInterestingTime( theTrack, nextTimeTrackEdit | nextTimeIgnoreActiveSegment, 			startTime, fixed1, &startTime, &editDur );	}bail:	if (refNum) FSClose(refNum);	return err;}// еееееееееееееееееееееееееееееееееееее// The Options Dialog code starts here#define diDialog 1128#define diEDLName 4#define diTimeScale 6#define diFrameDur 8#define diNumFrames 10#define diDropFrame 11#define diHours (diDropFrame + 2)#define diMinutes (diHours + 1)#define diSeconds (diMinutes + 1)#define diFrames (diSeconds + 1)void setDialogTextNumber(DialogPtr d, short itemNumber, long number);void setDialogTextString(DialogPtr d, short itemNumber, StringPtr str);Boolean validateDialogLong(DialogPtr d, short itemNumber, long *result);ControlHandle getDItemHandle(DialogPtr d, short itemNumber);extern pascal ComponentResult ExportCMX3600DoUserDialog(ExportCMX3600Globals store, Movie theMovie, Track onlyThisTrack, 			TimeValue startTime, TimeValue duration, Boolean *canceled){	OSErr retstat = noErr;	DialogPtr optionsDialog = nil;	short itemHit = cancel;	ControlHandle curCtl;	Boolean newVal;	short i;	Rect negRect;	GrafPtr curPort;		long 	tcTimeScale;	long 	tcFrameDur;	long 	tcNumFrames;	long	tcHours;	long 	tcMinutes;	long 	tcSeconds;	long 	tcFrames;	Str255 	tcSrcName;	Boolean tcDropFrameVal;		short	curResFile;	short	myResFile;		tcTimeScale = store->dstTcdef.fTimeScale;	tcFrameDur = store->dstTcdef.frameDuration;	tcNumFrames = store->dstTcdef.numFrames;	tcDropFrameVal = ((store->dstTcdef.flags & tcDropFrame) != 0);	tcHours = store->dstTcrec.t.hours;	tcMinutes = store->dstTcrec.t.minutes;	tcSeconds = store->dstTcrec.t.seconds;	tcFrames = store->dstTcrec.t.frames;	tcSrcName[0] = 0;		GetPort(&curPort);	#ifndef DEBUG_LINKED	curResFile = CurResFile();	myResFile = OpenComponentResFile( (Component)store->self );	UseResFile( myResFile );#endif	optionsDialog = GetNewDialog( diDialog, nil, (WindowPtr)-1L );	if (!optionsDialog) goto bail;		SetDialogDefaultItem(optionsDialog, 1);	SetDialogCancelItem(optionsDialog, 2);	curCtl = getDItemHandle( optionsDialog, diDropFrame );	SetCtlValue(curCtl,tcDropFrameVal);	setDialogTextNumber(optionsDialog, diTimeScale, tcTimeScale );	setDialogTextNumber(optionsDialog, diFrameDur, tcFrameDur );	setDialogTextNumber(optionsDialog, diNumFrames, tcNumFrames );	setDialogTextNumber(optionsDialog, diHours, tcHours );	setDialogTextNumber(optionsDialog, diMinutes, tcMinutes );	setDialogTextNumber(optionsDialog, diSeconds, tcSeconds );	setDialogTextNumber(optionsDialog, diFrames, tcFrames );	setDialogTextString(optionsDialog, diEDLName, tcSrcName);noGood:	do {			ModalDialog( nil, &itemHit );		switch (itemHit) {			case diDropFrame:				curCtl = getDItemHandle( optionsDialog, diDropFrame );				SetCtlValue(curCtl,!GetCtlValue(curCtl));				break;			}	} while ((itemHit != ok) && (itemHit != cancel));		if (itemHit == ok) {		curCtl = getDItemHandle(optionsDialog, diEDLName);		GetIText((Handle)curCtl, tcSrcName);			curCtl = getDItemHandle( optionsDialog, diDropFrame );		tcDropFrameVal = GetCtlValue(curCtl);		if (!validateDialogLong(optionsDialog, diTimeScale, &tcTimeScale))			goto noGood;		if (!validateDialogLong(optionsDialog, diFrameDur, &tcFrameDur))			goto noGood;		if (!validateDialogLong(optionsDialog, diNumFrames, &tcNumFrames))			goto noGood;		if (!validateDialogLong(optionsDialog, diHours, &tcHours))			goto noGood;		if (!validateDialogLong(optionsDialog, diMinutes, &tcMinutes))			goto noGood;		if (!validateDialogLong(optionsDialog, diSeconds, &tcSeconds))			goto noGood;		if (!validateDialogLong(optionsDialog, diFrames, &tcFrames))			goto noGood;		}		store->dstTcdef.fTimeScale = tcTimeScale;	store->dstTcdef.frameDuration = tcFrameDur;	store->dstTcdef.numFrames = tcNumFrames;	if (tcDropFrameVal) 		store->dstTcdef.flags |= tcDropFrame;	else		store->dstTcdef.flags &= ~(long)tcDropFrame;			store->dstTcrec.t.hours = tcHours;	store->dstTcrec.t.minutes = tcMinutes;	store->dstTcrec.t.seconds = tcSeconds;	store->dstTcrec.t.frames = tcFrames;	BlockMove( &tcSrcName[0], &store->EDLtitle[0], tcSrcName[0]+1 );	DisposeDialog(optionsDialog);bail:	SetPort(curPort);#ifndef DEBUG_LINKED	UseResFile(curResFile);	CloseComponentResFile( myResFile );#endif	*canceled = (itemHit != ok);	return retstat;}void setDialogTextNumber(DialogPtr d, short itemNumber, long number){	Str255 theText;	NumToString(number, theText);	SetIText((Handle)getDItemHandle(d, itemNumber), theText);	SelIText(d, itemNumber, 0, 32767);}void setDialogTextString(DialogPtr d, short itemNumber, StringPtr str){	SetIText((Handle)getDItemHandle(d, itemNumber), str);	SelIText(d, itemNumber, 0, 32767);}Boolean validateDialogLong(DialogPtr d, short itemNumber, long *result){	Str255 theText;	OSErr err;	ControlHandle ch;	Boolean digitFound;	short i;	ch = getDItemHandle(d, itemNumber);	GetIText((Handle)ch, theText);	digitFound = false;	for (i = 1; i < theText[0]; i++) {		if (theText[i] >= '0' && theText[i] <= '9') 			digitFound = true;		else if (digitFound) {			theText[0] = i-1;			break;		}		else if (theText[i] != ' ') {			SelIText(d, itemNumber, 0, 32767);			SysBeep(1);			return false;		}	}	StringToNum( theText, result );	return true;}ControlHandle getDItemHandle(DialogPtr d, short itemNumber){	short kind;	ControlHandle ch;	Rect r;	GetDItem(d, itemNumber, &kind, (Handle *)&ch, &r);	return(ch);}// еееееееееееееееееееееееееееееееееееее// Debugging Code starts here//// Call the following to the exporter into your code#ifdef DEBUG_LINKEDvoid RegisterExportCMX3600(void);void RegisterExportCMX3600(void){	ComponentDescription foo;	EventRecord theEvent;	Component fooc;	Handle nameH;	StringPtr name = {"\pCMX3600 Test"};  	foo.componentType = 'spit';  	foo.componentSubType = 'TEXT';  	foo.componentManufacturer = 'tmcd';  	foo.componentFlags = canMovieExportFiles | hasMovieExportUserInterface;  	foo.componentFlagsMask = 0;	nameH = NewHandle(name[0] + 1);	BlockMove( &name[0], *nameH, name[0]+1 );	fooc = RegisterComponent(&foo, (void *)ExportCMX3600Dispatcher, 0 /* keep it local */, nameH, 0, 0);	DisposeHandle( nameH );}#endif