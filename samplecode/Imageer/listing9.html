<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Imageer - /source/imageFilter.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">Imageer</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Imageer</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/source/imageFilter.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/source/doevent.c</option>
<option value="listing2.html">/source/eventloop.c</option>
<option value="listing3.html">/source/fileCache.c</option>
<option value="listing4.html">/source/fileIO.c</option>
<option value="listing5.html">/source/gxGraphics.c</option>
<option value="listing6.html">/source/Imageer.app.h</option>
<option value="listing7.html">/source/Imageer.protos.h</option>
<option value="listing8.html">/source/Imageer.r</option>
<option value="listing9.html">/source/imageFilter.c</option>
<option value="listing10.html">/source/menu.c</option>
<option value="listing11.html">/source/offscrnGraphics.c</option>
<option value="listing12.html">/source/PreCompiledHeaders.c</option>
<option value="listing13.html">/source/start.c</option>
<option value="listing14.html">/source/windows.c</option></select>
				</p>
				</form>
				<p><strong><a href="Imageer.zip">Download Sample</a></strong> (&#147;Imageer.zip&#148;, 161.4K)<BR>
<strong><a href="Imageer.dmg">Download Sample</a></strong> (&#147;Imageer.dmg&#148;, 243.1K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/****************************************************//*                          *//*  File:    imageFilter.c            *//*                          *//*  Program:  Imageer                *//*                          *//*  By:      Jason Hodges-Harris          *//*                          *//*  Created:  26/10/95  00:00:00 AM        *//*                          *//*  Version:  1.0.0d3                *//*                          *//*  Copyright:  &copy; 1995-96 Apple Computer, Inc.,    */ /*          all rights reserved.      */    /*                          *//****************************************************//**** Macintosh Toolbox Headers *****/#ifndef __CURSORCTL__#include &lt;CursorCtl.h&gt;#endif#ifndef __OSUTILS__#include &lt;OSUtils.h&gt;#endif#ifndef __TOOLUTILS__#include &lt;ToolUtils.h&gt;#endif/****   Application headers and prototypes   ****/#ifndef __IMAGEERAPPHEADER__#include &quot;Imageer.app.h&quot;#endif#ifndef __IMAGEERPROTOSHEADER__#include &quot;Imageer.protos.h&quot;#endif/****  Default RGB Colors  ****/static const RGBColor   kRGBBlack = {0x0000, 0x0000, 0x0000};static const RGBColor  kRGBWhite = {0xFFFF, 0xFFFF, 0xFFFF};/****  Smoothing filter  ****/#pragma segment filtersOSErr ImageSmoothFilter (ImageDocHndl  theDocHndl, WindowPtr theWindow){  PixMapHandle  thePixMapHndl = nil;  CursHandle    watchCrsr;  Ptr        theGWorldBaseAddr = nil,          currentAddr = nil,          lineBufferPtr = nil;  GrafPtr      oldPort;  long      spinCounter = 0,          imageRowSize,          xSize,          ySize,          xCount,          yCount,          xBounds,          yBounds;  unsigned short  smoothValueRed,          smoothValueGreen,          smoothValueBlue,          smoothValue,          currentBufferLine,          counter;  OSErr      error = noErr;    thePixMapHndl = GetGWorldPixMap((*theDocHndl)-&gt;theImageWorld);  if (PixMap32Bit(thePixMapHndl))          // if 32bit mode needed == true    SaveSetMMUMode(true);  if (!LockPixels(thePixMapHndl))    error = kFailedLockPixels;  if (!error)  {    currentAddr = theGWorldBaseAddr = GetPixBaseAddr(thePixMapHndl);    // *GWorld base Addr    xBounds = xSize = (**thePixMapHndl).bounds.right-(**thePixMapHndl).bounds.left;    yBounds = ySize = (**thePixMapHndl).bounds.bottom-(**thePixMapHndl).bounds.top;    xBounds--;  // reduce filter map bounds to stop overflow Using 3*3 matrix    yBounds--;    imageRowSize = (**thePixMapHndl).rowBytes &amp; 0x3FFF;  // get rowbytes size for image    switch ((*(*theDocHndl)-&gt;theImageWorld-&gt;portPixMap)-&gt;pixelSize)    {      case 1:    // B/W 1bit depth      case 2:    // 4 color 2 bit depth      case 4:    // 16 color 4 bit depth        DisplayAlert (rGenWarning,rErrMessages,iNotImplemented);      break;      case 8:    // 256 color 8 bit depth        lineBufferPtr = NewPtr(3*xSize);        if (!lineBufferPtr)          error = kPtrNotCreated;        if (!error)        {          watchCrsr = GetCursor(watchCursor);          SetCursor(*watchCrsr);          currentBufferLine = 0;          counter = 1;          for (yCount=0;yCount&lt;yBounds;yCount++)          {            RotateCursor(spinCounter+=2);            for (xCount=0;xCount&lt;xBounds;xCount++)            {              smoothValue = 0;  // reset smoothing accumulator              // unrolled loop to smooth 3x3 pixel area              smoothValue+=(unsigned char)currentAddr[0];              smoothValue+=(unsigned char)currentAddr[1];              smoothValue+=(unsigned char)currentAddr[2];              smoothValue+=(unsigned char)currentAddr[0+imageRowSize];              smoothValue+=(unsigned char)currentAddr[1+imageRowSize];              smoothValue+=(unsigned char)currentAddr[2+imageRowSize];              smoothValue+=(unsigned char)currentAddr[0+imageRowSize+imageRowSize];              smoothValue+=(unsigned char)currentAddr[1+imageRowSize+imageRowSize];              smoothValue+=(unsigned char)currentAddr[2+imageRowSize+imageRowSize];              // centre pixel of 3x3 grid smoothed Equivalent of smoothValue              lineBufferPtr[counter] = smoothValue * 0.11111111; // same as /9 but faster!              counter++;              currentAddr++;  // new pixel block to smooth            }            counter++;      // correct offset to next line            currentAddr=theGWorldBaseAddr+(imageRowSize*(yCount+1)); // set addr to start next line            currentBufferLine++;            if (currentBufferLine == 3)            {              BlockMoveData(&amp;lineBufferPtr[1],&amp;theGWorldBaseAddr[((yCount-1)*imageRowSize)+1],xBounds-1);              BlockMoveData(&amp;lineBufferPtr[xSize+1],&amp;theGWorldBaseAddr[(yCount*imageRowSize)+1],xBounds-1);              BlockMoveData(&amp;lineBufferPtr[(xSize*2)+1],&amp;lineBufferPtr[1],xBounds-1);              currentBufferLine = 1;              counter = xSize+1;            }                        }          while (currentBufferLine&gt;0)          {            BlockMoveData(&amp;lineBufferPtr[(xSize*currentBufferLine)+1],              &amp;theGWorldBaseAddr[((yCount-(currentBufferLine))*imageRowSize)+1],xBounds-1);            currentBufferLine--;          }          SetCursor(&amp;qd.arrow);          GetPort(&amp;oldPort);          SetPort(theWindow);          InvalRect(&amp;theWindow-&gt;portRect);          SetPort(oldPort);        }      break;      case 16:    // 32k colors 16 bit depth        DisplayAlert (rGenWarning,rErrMessages,iNotImplemented);      break;      case 32:    // 16.7m color 32 bit depth        lineBufferPtr = NewPtr(3*(xSize*4));        if (!lineBufferPtr)          error = kPtrNotCreated;        if (!error)        {          watchCrsr = GetCursor(watchCursor);          SetCursor(*watchCrsr);          currentBufferLine = 0;          counter = 4;          for (yCount=0;yCount&lt;yBounds;yCount++)          {            RotateCursor(spinCounter+=2);            for (xCount=0;xCount&lt;xBounds;xCount++)            {              smoothValueRed = 0;              smoothValueGreen = 0;              smoothValueBlue = 0;  // reset smoothing accumulators              // unrolled loop to smooth 3x3 pixel area              smoothValueRed+=(unsigned char)currentAddr[1];              smoothValueGreen+=(unsigned char)currentAddr[2];              smoothValueBlue+=(unsigned char)currentAddr[3];              smoothValueRed+=(unsigned char)currentAddr[5];              smoothValueGreen+=(unsigned char)currentAddr[6];              smoothValueBlue+=(unsigned char)currentAddr[7];              smoothValueRed+=(unsigned char)currentAddr[9];              smoothValueGreen+=(unsigned char)currentAddr[10];              smoothValueBlue+=(unsigned char)currentAddr[11];              smoothValueRed+=(unsigned char)currentAddr[1+imageRowSize];              smoothValueGreen+=(unsigned char)currentAddr[2+imageRowSize];              smoothValueBlue+=(unsigned char)currentAddr[3+imageRowSize];              smoothValueRed+=(unsigned char)currentAddr[5+imageRowSize];              smoothValueGreen+=(unsigned char)currentAddr[6+imageRowSize];              smoothValueBlue+=(unsigned char)currentAddr[7+imageRowSize];              smoothValueRed+=(unsigned char)currentAddr[9+imageRowSize];              smoothValueGreen+=(unsigned char)currentAddr[10+imageRowSize];              smoothValueBlue+=(unsigned char)currentAddr[11+imageRowSize];              smoothValueRed+=(unsigned char)currentAddr[1+imageRowSize+imageRowSize];              smoothValueGreen+=(unsigned char)currentAddr[2+imageRowSize+imageRowSize];              smoothValueBlue+=(unsigned char)currentAddr[3+imageRowSize+imageRowSize];              smoothValueRed+=(unsigned char)currentAddr[5+imageRowSize+imageRowSize];              smoothValueGreen+=(unsigned char)currentAddr[6+imageRowSize+imageRowSize];              smoothValueBlue+=(unsigned char)currentAddr[7+imageRowSize+imageRowSize];              smoothValueRed+=(unsigned char)currentAddr[9+imageRowSize+imageRowSize];              smoothValueGreen+=(unsigned char)currentAddr[10+imageRowSize+imageRowSize];              smoothValueBlue+=(unsigned char)currentAddr[11+imageRowSize+imageRowSize];              // top left of 3x3 grid smoothed Equivalent of smoothValue              lineBufferPtr[counter+1] = smoothValueRed * 0.11111111;              lineBufferPtr[counter+2] = smoothValueGreen * 0.11111111;              lineBufferPtr[counter+3] = smoothValueBlue * 0.11111111;              counter+=4;              currentAddr+=4; // new pixel block to smooth            }             counter+=4;      // correct offset to next line            currentAddr=theGWorldBaseAddr+(imageRowSize*(yCount+1)); // set addr to start next line            currentBufferLine++;            if (currentBufferLine == 3)            {              BlockMoveData(&amp;lineBufferPtr[4],&amp;theGWorldBaseAddr[((yCount-1)*imageRowSize)+4],(xBounds*4)-4);              BlockMoveData(&amp;lineBufferPtr[(xSize*4)+4],&amp;theGWorldBaseAddr[(yCount*imageRowSize)+4],(xBounds*4)-4);              BlockMoveData(&amp;lineBufferPtr[(xSize*8)+4],&amp;lineBufferPtr[4],(xBounds*4)-4);              currentBufferLine = 1;              counter = (xSize*4)+4;            }          }          while (currentBufferLine&gt;0)          {            BlockMoveData(&amp;lineBufferPtr[(xSize*currentBufferLine*4)+1],              &amp;theGWorldBaseAddr[((yCount-(currentBufferLine))*imageRowSize)+1],xBounds-1);            currentBufferLine--;          }        }        SetCursor(&amp;qd.arrow);        GetPort(&amp;oldPort);        SetPort(theWindow);        InvalRect(&amp;theWindow-&gt;portRect);        SetPort(oldPort);      break;    }  }  UnlockPixels(thePixMapHndl);      // unlock GWorld  SaveSetMMUMode(false);  return error;}/****  Edge Detection / High Pass filter  ****/#pragma segment filtersOSErr ImageHiPassFilter (ImageDocHndl  theDocHndl, WindowPtr theWindow){  PixMapHandle  thePixMapHndl = nil;  CursHandle    watchCrsr;  Ptr        theGWorldBaseAddr = nil,          currentAddr = nil,          lineBufferPtr = nil;  GrafPtr      oldPort;  long      spinCounter = 0,          imageRowSize,          xSize,          ySize,          xCount,          yCount,          xBounds,          yBounds;  short      currentBufferLine,          counter;  signed short  matrixValueRed,          matrixValueGreen,          matrixValueBlue,          matrixValue;  OSErr      error = noErr;  signed char    theAddrMode = true32b;  Boolean      swapModeNeeded = false;    thePixMapHndl = GetGWorldPixMap((*theDocHndl)-&gt;theImageWorld);  if (PixMap32Bit(thePixMapHndl))          // if 32bit mode needed == true    SaveSetMMUMode(true);  if (!LockPixels(thePixMapHndl))    error = kFailedLockPixels;  if (!error)  {    currentAddr = theGWorldBaseAddr = GetPixBaseAddr(thePixMapHndl);    // *GWorld base Addr    xBounds = xSize = (**thePixMapHndl).bounds.right-(**thePixMapHndl).bounds.left;    yBounds = ySize = (**thePixMapHndl).bounds.bottom-(**thePixMapHndl).bounds.top;    xBounds--;  // reduce filter map bounds to stop overflow Using 3*3 matrix    yBounds--;    imageRowSize = (**thePixMapHndl).rowBytes &amp; 0x3FFF;  // get rowbytes size for image    switch ((*(*theDocHndl)-&gt;theImageWorld-&gt;portPixMap)-&gt;pixelSize)    {      case 1:    // B/W 1bit depth      case 2:    // 4 color 2 bit depth      case 4:    // 16 color 4 bit depth        DisplayAlert (rGenWarning,rErrMessages,iNotImplemented);      break;      case 8:    // 256 color 8 bit depth        lineBufferPtr = NewPtr(3*xSize);        if (!lineBufferPtr)          error = kPtrNotCreated;        if (!error)        {          watchCrsr = GetCursor(watchCursor);          SetCursor(*watchCrsr);          currentBufferLine = 0;          counter = 1;          for (yCount=0;yCount&lt;yBounds;yCount++)          {            RotateCursor(spinCounter+=2);            for (xCount=0;xCount&lt;xBounds;xCount++)            {              matrixValue = 0;  // reset smoothing accumulator              // unrolled loop to smooth 3x3 pixel area              // Line 1, 2nd matrix pixel only used              matrixValue-=(unsigned char)currentAddr[1]; // create smoothed pixel              // line 2, all 3 matrix pixels used              matrixValue-=(unsigned char)currentAddr[0+imageRowSize]; // create smoothed pixel              // 2nd pixel rolled out 4 times              matrixValue+=(unsigned char)currentAddr[1+imageRowSize]; // create smoothed pixel              matrixValue+=(unsigned char)currentAddr[1+imageRowSize]; // create smoothed pixel              matrixValue+=(unsigned char)currentAddr[1+imageRowSize]; // create smoothed pixel              matrixValue+=(unsigned char)currentAddr[1+imageRowSize]; // create smoothed pixel              matrixValue-=(unsigned char)currentAddr[2+imageRowSize]; // create smoothed pixel              // Line 3, 2nd pixel only used              matrixValue-=(unsigned char)currentAddr[1+imageRowSize+imageRowSize]; // create smoothed pixel              lineBufferPtr[counter] = matrixValue;              counter++;              currentAddr++;  // new pixel block to smooth            }            counter++;      // correct offset to next line            currentAddr=theGWorldBaseAddr+(imageRowSize*(yCount+1)); // set addr to start next line            currentBufferLine++;            if (currentBufferLine == 3)            {              BlockMoveData(&amp;lineBufferPtr[1],&amp;theGWorldBaseAddr[((yCount-1)*imageRowSize)+1],xBounds-1);              BlockMoveData(&amp;lineBufferPtr[xSize+1],&amp;theGWorldBaseAddr[(yCount*imageRowSize)+1],xBounds-1);              BlockMoveData(&amp;lineBufferPtr[(xSize*2)+1],&amp;lineBufferPtr[1],xBounds-1);              currentBufferLine = 1;              counter = xSize+1;            }                        }          while (currentBufferLine&gt;0)          {            BlockMoveData(&amp;lineBufferPtr[(xSize*currentBufferLine)+1],              &amp;theGWorldBaseAddr[((yCount-(currentBufferLine))*imageRowSize)+1],xBounds-1);            currentBufferLine--;          }          SetCursor(&amp;qd.arrow);          GetPort(&amp;oldPort);          SetPort(theWindow);          InvalRect(&amp;theWindow-&gt;portRect);          SetPort(oldPort);        }      break;      case 16:    // 32k colors 16 bit depth        DisplayAlert (rGenWarning,rErrMessages,iNotImplemented);      break;      case 32:    // 16.7m color 32 bit depth        lineBufferPtr = NewPtr(3*(xSize*4));        if (!lineBufferPtr)          error = kPtrNotCreated;        if (!error)        {          watchCrsr = GetCursor(watchCursor);          SetCursor(*watchCrsr);          currentBufferLine = 0;          counter = 4;          for (yCount=0;yCount&lt;yBounds;yCount++)          {            RotateCursor(spinCounter+=2);            for (xCount=0;xCount&lt;xBounds;xCount++)            {              matrixValueRed = 0;              matrixValueGreen = 0;              matrixValueBlue = 0;  // reset smoothing accumulators              // unrolled loop to smooth 3x3 pixel area              // Line 1, 2nd matrix pixel only used              matrixValueRed-=(unsigned char)currentAddr[5];              matrixValueGreen-=(unsigned char)currentAddr[6];              matrixValueBlue-=(unsigned char)currentAddr[7];              // line 2, all 3 matrix pixels used              matrixValueRed-=(unsigned char)currentAddr[1+imageRowSize];              matrixValueGreen-=(unsigned char)currentAddr[2+imageRowSize];              matrixValueBlue-=(unsigned char)currentAddr[3+imageRowSize];              // 2nd pixel rolled out 4 times              matrixValueRed+=(unsigned char)currentAddr[5+imageRowSize];              matrixValueGreen+=(unsigned char)currentAddr[6+imageRowSize];              matrixValueBlue+=(unsigned char)currentAddr[7+imageRowSize];              matrixValueRed+=(unsigned char)currentAddr[5+imageRowSize];              matrixValueGreen+=(unsigned char)currentAddr[6+imageRowSize];              matrixValueBlue+=(unsigned char)currentAddr[7+imageRowSize];              matrixValueRed+=(unsigned char)currentAddr[5+imageRowSize];              matrixValueGreen+=(unsigned char)currentAddr[6+imageRowSize];              matrixValueBlue+=(unsigned char)currentAddr[7+imageRowSize];              matrixValueRed+=(unsigned char)currentAddr[5+imageRowSize];              matrixValueGreen+=(unsigned char)currentAddr[6+imageRowSize];              matrixValueBlue+=(unsigned char)currentAddr[7+imageRowSize];              matrixValueRed-=(unsigned char)currentAddr[9+imageRowSize];              matrixValueGreen-=(unsigned char)currentAddr[10+imageRowSize];              matrixValueBlue-=(unsigned char)currentAddr[11+imageRowSize];              // Line 3, 2nd pixel only used              matrixValueRed-=(unsigned char)currentAddr[5+imageRowSize+imageRowSize];              matrixValueGreen-=(unsigned char)currentAddr[6+imageRowSize+imageRowSize];              matrixValueBlue-=(unsigned char)currentAddr[7+imageRowSize+imageRowSize];              // top left of 3x3 grid smoothed Equivalent of matrixValue              matrixValueRed = matrixValueRed &gt; 255 ? 255 : matrixValueRed;              matrixValueRed = matrixValueRed &lt; 0 ? 0 : matrixValueRed;              matrixValueGreen = matrixValueGreen &gt; 255 ? 255 : matrixValueGreen;              matrixValueGreen = matrixValueGreen &lt; 0 ? 0 : matrixValueGreen;              matrixValueBlue = matrixValueBlue &gt; 255 ? 255 : matrixValueBlue;              matrixValueBlue = matrixValueBlue &lt; 0 ? 0 : matrixValueBlue;              // top left of 3x3 grid smoothed Equivalent of smoothValue              lineBufferPtr[counter+1] = matrixValueRed;              lineBufferPtr[counter+2] = matrixValueGreen;              lineBufferPtr[counter+3] = matrixValueBlue;              counter+=4;              currentAddr+=4; // new pixel block to smooth            }             counter+=4;      // correct offset to next line            currentAddr=theGWorldBaseAddr+(imageRowSize*(yCount+1)); // set addr to start next line            currentBufferLine++;            if (currentBufferLine == 3)            {              BlockMoveData(&amp;lineBufferPtr[4],&amp;theGWorldBaseAddr[((yCount-1)*imageRowSize)+4],(xBounds*4)-4);              BlockMoveData(&amp;lineBufferPtr[(xSize*4)+4],&amp;theGWorldBaseAddr[(yCount*imageRowSize)+4],(xBounds*4)-4);              BlockMoveData(&amp;lineBufferPtr[(xSize*8)+4],&amp;lineBufferPtr[4],(xBounds*4)-4);              currentBufferLine = 1;              counter = (xSize*4)+4;            }          }          while (currentBufferLine&gt;0)          {            BlockMoveData(&amp;lineBufferPtr[(xSize*currentBufferLine*4)+1],              &amp;theGWorldBaseAddr[((yCount-(currentBufferLine))*imageRowSize)+1],xBounds-1);            currentBufferLine--;          }        }        SetCursor(&amp;qd.arrow);        GetPort(&amp;oldPort);        SetPort(theWindow);        InvalRect(&amp;theWindow-&gt;portRect);        SetPort(oldPort);      break;    }  }  UnlockPixels(thePixMapHndl);  SaveSetMMUMode(false);  return error;}/**** custom color proc to invert direct color image  ****/#pragma segment filterspascal Boolean InvertDirectColor(RGBColor *color,long *position){  color-&gt;red = 0xFFFF - color-&gt;red;  color-&gt;green = 0xFFFF - color-&gt;green;  color-&gt;blue = 0xFFFF - color-&gt;blue;  return false;}/****  directly manipulate index image color table to invert colors  ****/#pragma segment filtersOSErr InvertColorTable (ImageDocHndl  theDocHndl){  CTabPtr    theColorTabPtr;  short    numberColors,        count;  OSErr    error = noErr;    numberColors = 1 &lt;&lt; (*(*theDocHndl)-&gt;theImageWorld-&gt;portPixMap)-&gt;pixelSize;  HLock((Handle)(**(**theDocHndl).theImageWorld-&gt;portPixMap).pmTable);  theColorTabPtr = *(**(**theDocHndl).theImageWorld-&gt;portPixMap).pmTable;  for (count = 0;count &lt; numberColors;count++)  {    theColorTabPtr-&gt;ctTable[count].rgb.red = 0xFFFF - theColorTabPtr-&gt;ctTable[count].rgb.red;    theColorTabPtr-&gt;ctTable[count].rgb.green = 0xFFFF - theColorTabPtr-&gt;ctTable[count].rgb.green;    theColorTabPtr-&gt;ctTable[count].rgb.blue = 0xFFFF - theColorTabPtr-&gt;ctTable[count].rgb.blue;  }  CTabChanged((**(**theDocHndl).theImageWorld-&gt;portPixMap).pmTable);  HUnlock((Handle)(**(**theDocHndl).theImageWorld-&gt;portPixMap).pmTable);  return error;}/****  function to action color inversion  ****/#pragma segment filtersOSErr  ColorImageInverter (ImageDocHndl  theDocHndl, WindowPtr theWindow){  PixMapHandle  thePixMapHndl = nil;  ColorSearchUPP  theInvertColorSearchUPP;  CGrafPtr    oldPort;  GDHandle    oldGDev;  RGBColor    oldForeColor,          oldBackColor;  OSErr      error = noErr;    GetGWorld(&amp;oldPort,&amp;oldGDev);  thePixMapHndl = GetGWorldPixMap((**theDocHndl).theImageWorld);  if (PixMap32Bit(thePixMapHndl))    SaveSetMMUMode(true);  if (!LockPixels(thePixMapHndl))    error = kFailedLockPixels;  if (!error)  {    switch ((*(*theDocHndl)-&gt;theImageWorld-&gt;portPixMap)-&gt;pixelSize)    {      case 1:      case 2:      case 4:      case 8:        SaveTempImageFile(theDocHndl, kColorTableOp);        InvertColorTable(theDocHndl);      break;      case 16:      case 32:        SaveTempImageFile(theDocHndl, kPixMapOp);        SetGWorld((**theDocHndl).theImageWorld,nil);        GetForeColor(&amp;oldForeColor);        GetBackColor(&amp;oldBackColor);        RGBForeColor(&amp;kRGBBlack);        RGBBackColor(&amp;kRGBWhite);        theInvertColorSearchUPP = NewColorSearchProc(InvertDirectColor);        AddSearch((ColorSearchUPP)theInvertColorSearchUPP);        CopyBits((BitMap*)(*thePixMapHndl),           (BitMap*)(*thePixMapHndl),           &amp;(**theDocHndl).theImageWorld-&gt;portRect,           &amp;(**theDocHndl).theImageWorld-&gt;portRect,srcCopy,nil);        DelSearch((ColorSearchUPP)theInvertColorSearchUPP);        DisposeRoutineDescriptor((UniversalProcPtr)theInvertColorSearchUPP);        RGBForeColor(&amp;oldForeColor);        RGBBackColor(&amp;oldBackColor);            break;    }  }  UnlockPixels(thePixMapHndl);  SaveSetMMUMode(false);  SetGWorld((CGrafPtr)theWindow,oldGDev);  InvalRect(&amp;theWindow-&gt;portRect);  // Invalidate current window contents to force update  SetGWorld(oldPort,oldGDev);  return error;}/****  mirror image through the y axis  ****/#pragma segment filtersOSErr MirrorImageVertical(ImageDocHndl  theDocHndl, WindowPtr theWindow){  PixMapHandle  thePixMapHndl = nil;  Ptr        lineBufferPtr = nil,          imageLinePtr;  CGrafPtr    oldPort;  GDHandle    oldGDev;  OSErr      error = noErr;  short      imageRowSize,          thePixMapRowBytes,          xCount,          yCount,          xSize,          ySize,          count;    GetGWorld(&amp;oldPort,&amp;oldGDev);  thePixMapHndl = GetGWorldPixMap((**theDocHndl).theImageWorld);  if (PixMap32Bit(thePixMapHndl))    SaveSetMMUMode(true);  if (!LockPixels(thePixMapHndl))    error = kFailedLockPixels;  else  {    imageRowSize = (**theDocHndl).theImageXSize;    switch ((**theDocHndl).theImageDepth)    {      case 1:        DisplayAlert(rGenAlert,rErrMessages,iNotImplemented);        error = kNotSupported;      break;      case 2:        DisplayAlert(rGenAlert,rErrMessages,iNotImplemented);        error = kNotSupported;      break;      case 4:        DisplayAlert(rGenAlert,rErrMessages,iNotImplemented);        error = kNotSupported;      break;      case 8:        //  1 byte per pixel so no additional calc needed      break;      case 16:        imageRowSize *= 2;      break;      case 32:        imageRowSize *= 4;      break;    }    if (!error)      lineBufferPtr = NewPtr(imageRowSize);    if (!lineBufferPtr)      error = kPtrNotCreated;  }  if (!error)  {    imageLinePtr = GetPixBaseAddr(thePixMapHndl);  // base addr of image GWorld PixMap    thePixMapRowBytes = (**thePixMapHndl).rowBytes &amp; 0x3FFF;    xSize = (**theDocHndl).theImageXSize;    ySize = (**theDocHndl).theImageYSize;    for (yCount = 0;yCount&lt;ySize;yCount++)    {      BlockMoveData(imageLinePtr,lineBufferPtr,imageRowSize);        switch ((**theDocHndl).theImageDepth)      {        case 8:          count = 0;          for (xCount = xSize-1;xCount&gt;=0;xCount--)          {            BlockMoveData(&amp;(lineBufferPtr[xCount]),&amp;imageLinePtr[count++],1);            }        break;        case 16:          count = 0;          for (xCount = (xSize*2)-2;xCount&gt;=0;xCount-=2)          {            BlockMoveData(&amp;(lineBufferPtr[xCount]),&amp;imageLinePtr[count],2);            count+=2;          }        break;        case 32:          count = 0;          for (xCount = (xSize*4)-4;xCount&gt;=0;xCount-=4)          {            BlockMoveData(&amp;(lineBufferPtr[xCount]),&amp;imageLinePtr[count],4);            count+=4;          }        break;      }      imageLinePtr += thePixMapRowBytes;    }  }  UnlockPixels(thePixMapHndl);  SaveSetMMUMode(false);  SetGWorld((CGrafPtr)theWindow,oldGDev);  InvalRect(&amp;theWindow-&gt;portRect);  SetGWorld(oldPort,oldGDev);  DisposePtr(lineBufferPtr);  return error;}/****  mirror image through the x axis  ****/#pragma segment filtersOSErr MirrorImageHorizontal(ImageDocHndl  theDocHndl, WindowPtr theWindow){  PixMapHandle  thePixMapHndl = nil;  Ptr        lineBufferPtr = nil,          basePixMapAddr,          imageLinePtr;  CGrafPtr    oldPort;  GDHandle    oldGDev;  OSErr      error = noErr;  short      imageRowSize,          thePixMapRowBytes,          yCount,          yMidValue,          destinationLine,          xSize,          ySize;    GetGWorld(&amp;oldPort,&amp;oldGDev);  thePixMapHndl = GetGWorldPixMap((**theDocHndl).theImageWorld);  if (PixMap32Bit(thePixMapHndl))    SaveSetMMUMode(true);  if (!LockPixels(thePixMapHndl))    error = kFailedLockPixels;  else  {    imageRowSize = (**theDocHndl).theImageXSize;    switch ((**theDocHndl).theImageDepth)    {      case 1:        DisplayAlert(rGenAlert,rErrMessages,iNotImplemented);        error = kNotSupported;      break;      case 2:        DisplayAlert(rGenAlert,rErrMessages,iNotImplemented);        error = kNotSupported;      break;      case 4:        DisplayAlert(rGenAlert,rErrMessages,iNotImplemented);        error = kNotSupported;      break;      case 8:        //  1 byte per pixel so no additional calc needed      break;      case 16:        imageRowSize *= 2;      break;      case 32:        imageRowSize *= 4;      break;    }    if (!error)      lineBufferPtr = NewPtr(imageRowSize);    if (!lineBufferPtr)      error = kPtrNotCreated;  }  if (!error)  {    basePixMapAddr = imageLinePtr = GetPixBaseAddr(thePixMapHndl);    thePixMapRowBytes = (**thePixMapHndl).rowBytes &amp; 0x3FFF;    xSize = (**theDocHndl).theImageXSize;    ySize = (**theDocHndl).theImageYSize;    yMidValue = ySize * 0.5;    destinationLine = ySize-1;    for (yCount = 0;yCount&lt;yMidValue;yCount++)    {      BlockMoveData(imageLinePtr,lineBufferPtr,imageRowSize);        switch ((**theDocHndl).theImageDepth)      {        case 8:            BlockMoveData(&amp;basePixMapAddr[thePixMapRowBytes*destinationLine],imageLinePtr,imageRowSize);              BlockMoveData(lineBufferPtr,&amp;basePixMapAddr[thePixMapRowBytes*destinationLine],imageRowSize);          break;        case 16:            BlockMoveData(&amp;basePixMapAddr[thePixMapRowBytes*destinationLine],imageLinePtr,imageRowSize);              BlockMoveData(lineBufferPtr,&amp;basePixMapAddr[thePixMapRowBytes*destinationLine],imageRowSize);          break;        case 32:            BlockMoveData(&amp;basePixMapAddr[thePixMapRowBytes*destinationLine],imageLinePtr,imageRowSize);              BlockMoveData(lineBufferPtr,&amp;basePixMapAddr[thePixMapRowBytes*destinationLine],imageRowSize);          break;      }      imageLinePtr += thePixMapRowBytes;      destinationLine--;    }  }  UnlockPixels(thePixMapHndl);  SaveSetMMUMode(false);  SetGWorld((CGrafPtr)theWindow,oldGDev);  InvalRect(&amp;theWindow-&gt;portRect);  SetGWorld(oldPort,oldGDev);  DisposePtr(lineBufferPtr);  return error;}/****  Rotate image through 180\xFB  ****/#pragma segment filtersOSErr RotateImage180(ImageDocHndl  theDocHndl, WindowPtr theWindow){  PixMapHandle  thePixMapHndl = nil;  Ptr        lineBufferPtr = nil,          basePixMapAddr,          imageLinePtr;  CGrafPtr    oldPort;  GDHandle    oldGDev;  OSErr      error = noErr;  short      imageRowSize,          thePixMapRowBytes,          xCount,          yCount,          yMidValue,          destinationLine,          xSize,          ySize,          count;    GetGWorld(&amp;oldPort,&amp;oldGDev);  thePixMapHndl = GetGWorldPixMap((**theDocHndl).theImageWorld);  if (PixMap32Bit(thePixMapHndl))          // if 32bit mode needed == true    SaveSetMMUMode(true);  if (!LockPixels(thePixMapHndl))    error = kFailedLockPixels;  else  {    imageRowSize = (**theDocHndl).theImageXSize;    switch ((**theDocHndl).theImageDepth)    {      case 1:        DisplayAlert(rGenAlert,rErrMessages,iNotImplemented);        error = kNotSupported;      break;      case 2:        DisplayAlert(rGenAlert,rErrMessages,iNotImplemented);        error = kNotSupported;      break;      case 4:        DisplayAlert(rGenAlert,rErrMessages,iNotImplemented);        error = kNotSupported;      break;      case 8:        //  1 byte per pixel so no additional calc needed      break;      case 16:        imageRowSize *= 2;      break;      case 32:        imageRowSize *= 4;      break;    }    if (!error)      lineBufferPtr = NewPtr(imageRowSize);    if (!lineBufferPtr)      error = kPtrNotCreated;  }  if (!error)  {    basePixMapAddr = imageLinePtr = GetPixBaseAddr(thePixMapHndl);  // base addr of image GWorld PixMap    thePixMapRowBytes = (**thePixMapHndl).rowBytes &amp; 0x3FFF;    xSize = (**theDocHndl).theImageXSize;    ySize = (**theDocHndl).theImageYSize;    yMidValue = ySize * 0.5;    destinationLine = ySize-1;    for (yCount = 0;yCount&lt;yMidValue;yCount++)    {      BlockMoveData(imageLinePtr,lineBufferPtr,imageRowSize);        switch ((**theDocHndl).theImageDepth)      {        case 8:          count = 0;          for (xCount = xSize-1;xCount&gt;=0;xCount--)          {            BlockMoveData(&amp;basePixMapAddr[thePixMapRowBytes*destinationLine+xCount],&amp;imageLinePtr[count],1);              BlockMoveData(&amp;lineBufferPtr[count],&amp;basePixMapAddr[thePixMapRowBytes*destinationLine+xCount],1);            count++;          }        break;        case 16:          count = 0;          for (xCount = (xSize*2)-2;xCount&gt;=0;xCount-=2)          {            BlockMoveData(&amp;basePixMapAddr[thePixMapRowBytes*destinationLine+xCount],&amp;imageLinePtr[count],2);              BlockMoveData(&amp;lineBufferPtr[count],&amp;basePixMapAddr[thePixMapRowBytes*destinationLine+xCount],2);            count+=2;          }        break;        case 32:          count = 0;          for (xCount = (xSize*4)-4;xCount&gt;=0;xCount-=4)          {            BlockMoveData(&amp;basePixMapAddr[thePixMapRowBytes*destinationLine+xCount],&amp;imageLinePtr[count],4);              BlockMoveData(&amp;lineBufferPtr[count],&amp;basePixMapAddr[thePixMapRowBytes*destinationLine+xCount],4);            count+=4;          }        break;      }      imageLinePtr += thePixMapRowBytes;      destinationLine--;    }    if (yMidValue*2 != ySize)    {      imageLinePtr = basePixMapAddr+(thePixMapRowBytes*yMidValue);      BlockMoveData(imageLinePtr,lineBufferPtr,imageRowSize);        switch ((**theDocHndl).theImageDepth)      {        case 8:          count = 0;          for (xCount = xSize-1;xCount&gt;=0;xCount--)            BlockMoveData(&amp;lineBufferPtr[count++],&amp;imageLinePtr[xCount],1);        break;        case 16:          count = 0;          for (xCount = (xSize*2)-2;xCount&gt;=0;xCount-=2)          {            BlockMoveData(&amp;lineBufferPtr[count],&amp;imageLinePtr[xCount],2);            count+=2;          }        break;        case 32:          count = 0;          for (xCount = (xSize*4)-4;xCount&gt;=0;xCount-=4)          {            BlockMoveData(&amp;lineBufferPtr[count],&amp;imageLinePtr[xCount],4);            count+=4;          }        break;      }    }  }  UnlockPixels(thePixMapHndl);    // unlock GWorld  SaveSetMMUMode(false);  SetGWorld((CGrafPtr)theWindow,oldGDev);  InvalRect(&amp;theWindow-&gt;portRect);  // Invalidate current window contents to force update  SetGWorld(oldPort,oldGDev);  DisposePtr(lineBufferPtr);  return error;}/****  Image brightness control  ****/#pragma segment filtersOSErr  ImageBrightness(ImageDocHndl theDocHndl, WindowPtr theWindow, Boolean isBrighter){  PixMapHandle  thePixMapHndl = nil;  ColorSearchUPP  theBrightnessColorSearchUPP;  CGrafPtr    oldPort;  GDHandle    oldGDev;  RGBColor    oldForeColor,          oldBackColor;  OSErr      error = noErr;    GetGWorld(&amp;oldPort,&amp;oldGDev);  thePixMapHndl = GetGWorldPixMap((**theDocHndl).theImageWorld);  if (PixMap32Bit(thePixMapHndl))          // if 32bit mode needed == true    SaveSetMMUMode(true);  if (!LockPixels(thePixMapHndl))    error = kFailedLockPixels;  if (!error)  {    switch ((*(*theDocHndl)-&gt;theImageWorld-&gt;portPixMap)-&gt;pixelSize)    {      case 1:    // B/W 1bit depth      case 2:      case 4:      case 8:        SaveTempImageFile(theDocHndl, kColorTableOp);        BrightnessColorTable(theDocHndl, isBrighter);      break;      case 16:      case 32:        SaveTempImageFile(theDocHndl, kPixMapOp);        SetGWorld((**theDocHndl).theImageWorld,nil);        GetForeColor(&amp;oldForeColor);        GetBackColor(&amp;oldBackColor);        RGBForeColor(&amp;kRGBBlack);        RGBBackColor(&amp;kRGBWhite);        if (isBrighter)          theBrightnessColorSearchUPP = NewColorSearchProc(DirectColorBrightenProc); // create routine descriptor        else          theBrightnessColorSearchUPP = NewColorSearchProc(DirectColorDarkenProc); // create routine descriptor        AddSearch((ColorSearchUPP)theBrightnessColorSearchUPP);    // add color search        CopyBits((BitMap*)(*thePixMapHndl),           (BitMap*)(*thePixMapHndl),           &amp;(**theDocHndl).theImageWorld-&gt;portRect,           &amp;(**theDocHndl).theImageWorld-&gt;portRect,srcCopy,nil);        DelSearch((ColorSearchUPP)theBrightnessColorSearchUPP);    // remove search        DisposeRoutineDescriptor((UniversalProcPtr)theBrightnessColorSearchUPP);        RGBForeColor(&amp;oldForeColor);        RGBBackColor(&amp;oldBackColor);            break;    }  }  UnlockPixels(thePixMapHndl);    // unlock GWorld  SaveSetMMUMode(false);  SetGWorld((CGrafPtr)theWindow,oldGDev);  InvalRect(&amp;theWindow-&gt;portRect);  // Invalidate current window contents to force update  SetGWorld(oldPort,oldGDev);  return error;}/****  Image contrast control  ****/#pragma segment filtersOSErr  ImageContrast(ImageDocHndl theDocHndl, WindowPtr theWindow, Boolean isGreater){  PixMapHandle  thePixMapHndl = nil;  ColorSearchUPP  theContrastColorSearchUPP;  CGrafPtr    oldPort;  GDHandle    oldGDev;  RGBColor    oldForeColor,          oldBackColor;  OSErr      error = noErr;    GetGWorld(&amp;oldPort,&amp;oldGDev);  thePixMapHndl = GetGWorldPixMap((**theDocHndl).theImageWorld);  if (PixMap32Bit(thePixMapHndl))          // if 32bit mode needed == true    SaveSetMMUMode(true);  if (!LockPixels(thePixMapHndl))    error = kFailedLockPixels;  if (!error)  {    switch ((*(*theDocHndl)-&gt;theImageWorld-&gt;portPixMap)-&gt;pixelSize)    {      case 1:    // B/W 1bit depth      case 2:      case 4:      case 8:        SaveTempImageFile(theDocHndl, kColorTableOp);        ContrastColorTable(theDocHndl, isGreater);      break;      case 16:      case 32:        SaveTempImageFile(theDocHndl, kPixMapOp);        SetGWorld((**theDocHndl).theImageWorld,nil);        GetForeColor(&amp;oldForeColor);        GetBackColor(&amp;oldBackColor);        RGBForeColor(&amp;kRGBBlack);        RGBBackColor(&amp;kRGBWhite);        if (isGreater)          theContrastColorSearchUPP = NewColorSearchProc(DirectColorIncContrastProc); // create routine descriptor        else          theContrastColorSearchUPP = NewColorSearchProc(DirectColorDecContrastProc); // create routine descriptor        AddSearch((ColorSearchUPP)theContrastColorSearchUPP);    // add color search        CopyBits((BitMap*)(*thePixMapHndl),           (BitMap*)(*thePixMapHndl),           &amp;(**theDocHndl).theImageWorld-&gt;portRect,           &amp;(**theDocHndl).theImageWorld-&gt;portRect,srcCopy,nil);        DelSearch((ColorSearchUPP)theContrastColorSearchUPP);    // remove search        DisposeRoutineDescriptor((UniversalProcPtr)theContrastColorSearchUPP);        RGBForeColor(&amp;oldForeColor);        RGBBackColor(&amp;oldBackColor);            break;    }  }  UnlockPixels(thePixMapHndl);  SaveSetMMUMode(false);  SetGWorld((CGrafPtr)theWindow,oldGDev);  InvalRect(&amp;theWindow-&gt;portRect);  SetGWorld(oldPort,oldGDev);  return error;}/****  Direct color Brighten color search  ****/#pragma segment filterspascal Boolean DirectColorBrightenProc(RGBColor *color,long *position){  long  tempColorRed = color-&gt;red,      tempColorGreen = color-&gt;green,      tempColorBlue = color-&gt;blue;    tempColorRed = (tempColorRed+0x1600) &gt; 0xFFFF ? 0xFFFF : tempColorRed+0x1600;  tempColorGreen = (tempColorGreen+0x1600) &gt; 0xFFFF ? 0xFFFF : tempColorGreen+0x1600;  tempColorBlue = (tempColorBlue+0x1600) &gt; 0xFFFF ? 0xFFFF : tempColorBlue+0x1600;  color-&gt;red = tempColorRed;  color-&gt;green = tempColorGreen;  color-&gt;blue = tempColorBlue;  return false;}/****  Direct color Darken color search  ****/#pragma segment filterspascal Boolean DirectColorDarkenProc(RGBColor *color,long *position){  long  tempColorRed = color-&gt;red,      tempColorGreen = color-&gt;green,      tempColorBlue = color-&gt;blue;    tempColorRed = (tempColorRed-0x1600) &lt; 0x0000 ? 0x0000 : tempColorRed-0x1600;  tempColorGreen = (tempColorGreen-0x1600) &lt; 0x0000 ? 0x0000 : tempColorGreen-0x1600;  tempColorBlue = (tempColorBlue-0x1600) &lt; 0x0000 ? 0x0000 : tempColorBlue-0x1600;  color-&gt;red = tempColorRed;  color-&gt;green = tempColorGreen;  color-&gt;blue = tempColorBlue;  return false;}/****  Indexed color image brightness  ****/#pragma segment filtersvoid  BrightnessColorTable(ImageDocHndl theDocHndl,Boolean isBrighter){  CTabPtr    theColorTabPtr;  long    tempColorRed,        tempColorGreen,        tempColorBlue;  short    numberColors,        count;  OSErr    error = noErr;    numberColors = 1 &lt;&lt; (*(*theDocHndl)-&gt;theImageWorld-&gt;portPixMap)-&gt;pixelSize;  HLock((Handle)(**(**theDocHndl).theImageWorld-&gt;portPixMap).pmTable);  theColorTabPtr = *(**(**theDocHndl).theImageWorld-&gt;portPixMap).pmTable;  for (count = 0;count &lt; numberColors;count++)  {    tempColorRed = theColorTabPtr-&gt;ctTable[count].rgb.red;    tempColorGreen = theColorTabPtr-&gt;ctTable[count].rgb.green;    tempColorBlue = theColorTabPtr-&gt;ctTable[count].rgb.blue;    if (isBrighter)    {      tempColorRed = (tempColorRed+0x1600) &gt; 0xFFFF ? 0xFFFF : tempColorRed+0x1600;      tempColorGreen = (tempColorGreen+0x1600) &gt; 0xFFFF ? 0xFFFF : tempColorGreen+0x1600;      tempColorBlue = (tempColorBlue+0x1600) &gt; 0xFFFF ? 0xFFFF : tempColorBlue+0x1600;    }    else    {      tempColorRed = (tempColorRed-0x1600) &lt; 0x0000 ? 0x0000 : tempColorRed-0x1600;      tempColorGreen = (tempColorGreen-0x1600) &lt; 0x0000 ? 0x0000 : tempColorGreen-0x1600;      tempColorBlue = (tempColorBlue-0x1600) &lt; 0x0000 ? 0x0000 : tempColorBlue-0x1600;    }    theColorTabPtr-&gt;ctTable[count].rgb.red = tempColorRed;    theColorTabPtr-&gt;ctTable[count].rgb.green = tempColorGreen;    theColorTabPtr-&gt;ctTable[count].rgb.blue = tempColorBlue;  }  CTabChanged((**(**theDocHndl).theImageWorld-&gt;portPixMap).pmTable);  HUnlock((Handle)(**(**theDocHndl).theImageWorld-&gt;portPixMap).pmTable);}/****  Direct color increase contrast color search  ****/#pragma segment filterspascal Boolean DirectColorIncContrastProc(RGBColor *color,long *position){  long  tempColorRed = color-&gt;red,      tempColorGreen = color-&gt;green,      tempColorBlue = color-&gt;blue;    tempColorRed = tempColorRed &gt;= 0x8100 ? tempColorRed+0x1600 : tempColorRed;  tempColorRed = tempColorRed &lt;= 0x7F00 ? tempColorRed-0x01600 : tempColorRed;  tempColorRed = tempColorRed &gt; 0xFFFF ? 0xFFFF : tempColorRed;  tempColorRed = tempColorRed &lt; 0x0000 ? 0x0000 : tempColorRed;  tempColorGreen = tempColorGreen &gt;= 0x8100 ? tempColorGreen+0x1600 : tempColorGreen;  tempColorGreen = tempColorGreen &lt;= 0x7F00 ? tempColorGreen-0x1600 : tempColorGreen;  tempColorGreen = tempColorGreen &gt; 0xFFFF ? 0xFFFF : tempColorGreen;  tempColorGreen = tempColorGreen &lt; 0x0000 ? 0x0000 : tempColorGreen;  tempColorBlue = tempColorBlue &gt;= 0x8100 ? tempColorBlue+0x1600 : tempColorBlue;  tempColorBlue = tempColorBlue &lt;= 0x7F00 ? tempColorBlue-0x1600 : tempColorBlue;  tempColorBlue = tempColorBlue &gt; 0xFFFF ? 0xFFFF : tempColorBlue;  tempColorBlue = tempColorBlue &lt; 0x0000 ? 0x0000 : tempColorBlue;  color-&gt;red = tempColorRed;  color-&gt;green = tempColorGreen;  color-&gt;blue = tempColorBlue;  return false;}/****  Direct color reduce Contrast color search  ****/#pragma segment filterspascal Boolean DirectColorDecContrastProc(RGBColor *color,long *position){  long  tempColorRed = color-&gt;red,      tempColorGreen = color-&gt;green,      tempColorBlue = color-&gt;blue;  tempColorRed = (tempColorRed &gt; 0x8000 &amp;&amp; tempColorRed &lt; 0x9600) ? 0x8000 : tempColorRed;  tempColorRed = tempColorRed &gt;= 0x9600 ? tempColorRed-0x1600 : tempColorRed;  tempColorRed = (tempColorRed &gt; 0x6A00 &amp;&amp; tempColorRed &lt; 0x8000) ? 0x8000 : tempColorRed;  tempColorRed = tempColorRed &lt;= 0x6A00 ? tempColorRed+0x1600 : tempColorRed;  tempColorRed = tempColorRed &gt; 0xFFFF ? 0xFFFF : tempColorRed;  tempColorRed = tempColorRed &lt; 0x0000 ? 0x0000 : tempColorRed;  tempColorGreen = (tempColorGreen &gt; 0x8000 &amp;&amp; tempColorGreen &lt; 0x9600) ? 0x8000 : tempColorGreen;  tempColorGreen = tempColorGreen &gt;= 0x9600 ? tempColorGreen-0x1600 : tempColorGreen;  tempColorGreen = (tempColorGreen &gt; 0x6A00 &amp;&amp; tempColorGreen &lt; 0x8000) ? 0x8000 : tempColorGreen;  tempColorGreen = tempColorGreen &lt;= 0x6A00 ? tempColorGreen+0x1600 : tempColorGreen;  tempColorGreen = tempColorGreen &gt; 0xFFFF ? 0xFFFF : tempColorGreen;  tempColorGreen = tempColorGreen &lt; 0x0000 ? 0x0000 : tempColorGreen;  tempColorBlue = (tempColorBlue &gt; 0x8000 &amp;&amp; tempColorBlue &lt; 0x9600) ? 0x8000 : tempColorBlue;  tempColorBlue = tempColorBlue &gt;= 0x9600 ? tempColorBlue-0x1600 : tempColorBlue;  tempColorBlue = (tempColorBlue &gt; 0x6A00 &amp;&amp; tempColorBlue &lt; 0x8000) ? 0x8000 : tempColorBlue;  tempColorBlue = tempColorBlue &lt;= 0x6A00 ? tempColorBlue+0x1600 : tempColorBlue;  tempColorBlue = tempColorBlue &gt; 0xFFFF ? 0xFFFF : tempColorBlue;  tempColorBlue = tempColorBlue &lt; 0x0000 ? 0x0000 : tempColorBlue;  color-&gt;red = tempColorRed;  color-&gt;green = tempColorGreen;  color-&gt;blue = tempColorBlue;  return false;}/****  Indexed color image Contrast  ****/#pragma segment filtersvoid  ContrastColorTable(ImageDocHndl theDocHndl,Boolean isGreater){  CTabPtr    theColorTabPtr;  signed long  tempColorRed,        tempColorGreen,        tempColorBlue;  short    numberColors,        count;  OSErr    error = noErr;    numberColors = 1 &lt;&lt; (*(*theDocHndl)-&gt;theImageWorld-&gt;portPixMap)-&gt;pixelSize;  HLock((Handle)(**(**theDocHndl).theImageWorld-&gt;portPixMap).pmTable);  theColorTabPtr = *(**(**theDocHndl).theImageWorld-&gt;portPixMap).pmTable;  for (count = 0;count &lt; numberColors;count++)  {    tempColorRed = theColorTabPtr-&gt;ctTable[count].rgb.red;    tempColorGreen = theColorTabPtr-&gt;ctTable[count].rgb.green;    tempColorBlue = theColorTabPtr-&gt;ctTable[count].rgb.blue;    if (isGreater)    {      tempColorRed = tempColorRed &gt; 0x8000 ? tempColorRed+0x1600 : tempColorRed;      tempColorRed = tempColorRed &lt; 0x8000 ? tempColorRed-0x1600 : tempColorRed;      tempColorRed = tempColorRed &gt; 0xFFFF ? 0xFFFF : tempColorRed;      tempColorRed = tempColorRed &lt; 0x0000 ? 0x0000 : tempColorRed;      tempColorGreen = tempColorGreen &gt; 0x8000 ? tempColorGreen+0x1600 : tempColorGreen;      tempColorGreen = tempColorGreen &lt; 0x8000 ? tempColorGreen-0x1600 : tempColorGreen;      tempColorGreen = tempColorGreen &gt; 0xFFFF ? 0xFFFF : tempColorGreen;      tempColorGreen = tempColorGreen &lt; 0x0000 ? 0x0000 : tempColorGreen;      tempColorBlue = tempColorBlue &gt; 0x8000 ? tempColorBlue+0x1600 : tempColorBlue;      tempColorBlue = tempColorBlue &lt; 0x8000 ? tempColorBlue-0x1600 : tempColorBlue;      tempColorBlue = tempColorBlue &gt; 0xFFFF ? 0xFFFF : tempColorBlue;      tempColorBlue = tempColorBlue &lt; 0x0000 ? 0x0000 : tempColorBlue;    }    else    {      tempColorRed = (tempColorRed &gt; 0x8000 &amp;&amp; tempColorRed &lt; 0x9600) ? 0x8000 : tempColorRed;      tempColorRed = tempColorRed &gt;= 0x9600 ? tempColorRed-0x1600 : tempColorRed;      tempColorRed = (tempColorRed &gt;= 0x6A00 &amp;&amp; tempColorRed &lt; 0x8000) ? 0x8000 : tempColorRed;      tempColorRed = tempColorRed &lt; 0x6A00 ? tempColorRed+0x1600 : tempColorRed;      tempColorRed = tempColorRed &gt; 0xFFFF ? 0xFFFF : tempColorRed;      tempColorRed = tempColorRed &lt; 0x0000 ? 0x0000 : tempColorRed;      tempColorGreen = (tempColorGreen &gt; 0x8000 &amp;&amp; tempColorGreen &lt; 0x9600) ? 0x8000 : tempColorGreen;      tempColorGreen = tempColorGreen &gt;= 0x9600 ? tempColorGreen-0x1600 : tempColorGreen;      tempColorGreen = (tempColorGreen &gt;= 0x6A00 &amp;&amp; tempColorGreen &lt; 0x8000) ? 0x8000 : tempColorGreen;      tempColorGreen = tempColorGreen &lt; 0x6A00 ? tempColorGreen+0x1600 : tempColorGreen;      tempColorGreen = tempColorGreen &gt; 0xFFFF ? 0xFFFF : tempColorGreen;      tempColorGreen = tempColorGreen &lt; 0x0000 ? 0x0000 : tempColorGreen;      tempColorBlue = (tempColorBlue &gt; 0x8000 &amp;&amp; tempColorBlue &lt; 0x9600) ? 0x8000 : tempColorBlue;      tempColorBlue = tempColorBlue &gt;= 0x9600 ? tempColorBlue-0x1600 : tempColorBlue;      tempColorBlue = (tempColorBlue &gt;= 0x6A00 &amp;&amp; tempColorBlue &lt; 0x8000) ? 0x8000 : tempColorBlue;      tempColorBlue = tempColorBlue &lt; 0x6A00 ? tempColorBlue+0x1600 : tempColorBlue;      tempColorBlue = tempColorBlue &gt; 0xFFFF ? 0xFFFF : tempColorBlue;      tempColorBlue = tempColorBlue &lt; 0x0000 ? 0x0000 : tempColorBlue;    }    theColorTabPtr-&gt;ctTable[count].rgb.red = tempColorRed;    theColorTabPtr-&gt;ctTable[count].rgb.green = tempColorGreen;    theColorTabPtr-&gt;ctTable[count].rgb.blue = tempColorBlue;  }  CTabChanged((**(**theDocHndl).theImageWorld-&gt;portPixMap).pmTable);  HUnlock((Handle)(**(**theDocHndl).theImageWorld-&gt;portPixMap).pmTable);}/****  Remove Color component from image controller  ****/#pragma segment filtersOSErr  RemoveColorComponent(ImageDocHndl theDocHndl, WindowPtr theWindow, short theColorComponent){  PixMapHandle  thePixMapHndl = nil;  ColorSearchUPP  theRemoveColorCompSearchUPP;  CGrafPtr    oldPort;  GDHandle    oldGDev;  RGBColor    oldForeColor,          oldBackColor;  OSErr      error = noErr;    GetGWorld(&amp;oldPort,&amp;oldGDev);  thePixMapHndl = GetGWorldPixMap((**theDocHndl).theImageWorld);  if (PixMap32Bit(thePixMapHndl))    SaveSetMMUMode(true);  if (!LockPixels(thePixMapHndl))    error = kFailedLockPixels;  if (!error)  {    switch ((*(*theDocHndl)-&gt;theImageWorld-&gt;portPixMap)-&gt;pixelSize)    {      case 1:      case 2:      case 4:      case 8:        SaveTempImageFile(theDocHndl, kColorTableOp);        RemoveComponentColorTable(theDocHndl, theColorComponent);      break;      case 16:      case 32:        SaveTempImageFile(theDocHndl, kPixMapOp);        SetGWorld((**theDocHndl).theImageWorld,nil);        GetForeColor(&amp;oldForeColor);        GetBackColor(&amp;oldBackColor);        RGBForeColor(&amp;kRGBBlack);        RGBBackColor(&amp;kRGBWhite);        if (kRedComp == theColorComponent)          theRemoveColorCompSearchUPP = NewColorSearchProc(RemoveRedCompProc);         else if (kGreenComp == theColorComponent)          theRemoveColorCompSearchUPP = NewColorSearchProc(RemoveGreenCompProc);        else if (kBlueComp == theColorComponent)          theRemoveColorCompSearchUPP = NewColorSearchProc(RemoveBlueCompProc);        AddSearch((ColorSearchUPP)theRemoveColorCompSearchUPP);        CopyBits((BitMap*)(*thePixMapHndl),           (BitMap*)(*thePixMapHndl),           &amp;(**theDocHndl).theImageWorld-&gt;portRect,           &amp;(**theDocHndl).theImageWorld-&gt;portRect,srcCopy,nil);        DelSearch((ColorSearchUPP)theRemoveColorCompSearchUPP);        DisposeRoutineDescriptor((UniversalProcPtr)theRemoveColorCompSearchUPP);        RGBForeColor(&amp;oldForeColor);        RGBBackColor(&amp;oldBackColor);            break;    }  }  UnlockPixels(thePixMapHndl);  SaveSetMMUMode(false);  SetGWorld((CGrafPtr)theWindow,oldGDev);  InvalRect(&amp;theWindow-&gt;portRect);  SetGWorld(oldPort,oldGDev);  return error;}/****  Color search to remove Red Color component  ****/#pragma segment filterspascal Boolean RemoveRedCompProc(RGBColor *color,long *position){  color-&gt;red = 0;  return false;}/****  Color search to remove Red Color component  ****/#pragma segment filterspascal Boolean RemoveGreenCompProc(RGBColor *color,long *position){  color-&gt;green = 0;  return false;}/****  Color search to remove Red Color component  ****/#pragma segment filterspascal Boolean RemoveBlueCompProc(RGBColor *color,long *position){  color-&gt;blue = 0;  return false;}/****  Indexed color remove color component  ****/#pragma segment filtersvoid  RemoveComponentColorTable(ImageDocHndl theDocHndl,short theColorComponent){  CTabPtr    theColorTabPtr;  short    numberColors,        count;  OSErr    error = noErr;    numberColors = 1 &lt;&lt; (*(*theDocHndl)-&gt;theImageWorld-&gt;portPixMap)-&gt;pixelSize;  HLock((Handle)(**(**theDocHndl).theImageWorld-&gt;portPixMap).pmTable);  theColorTabPtr = *(**(**theDocHndl).theImageWorld-&gt;portPixMap).pmTable;  for (count = 0;count &lt; numberColors;count++)  {    if (kRedComp == theColorComponent)      theColorTabPtr-&gt;ctTable[count].rgb.red = 0;    else if (kGreenComp == theColorComponent)      theColorTabPtr-&gt;ctTable[count].rgb.green = 0;    else if (kBlueComp == theColorComponent)      theColorTabPtr-&gt;ctTable[count].rgb.blue = 0;  }  CTabChanged((**(**theDocHndl).theImageWorld-&gt;portPixMap).pmTable);  HUnlock((Handle)(**(**theDocHndl).theImageWorld-&gt;portPixMap).pmTable);}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Imageer/listing9.html%3Fid%3DDTS10000150-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Imageer/listing9.html%3Fid%3DDTS10000150-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Imageer/listing9.html%3Fid%3DDTS10000150-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>