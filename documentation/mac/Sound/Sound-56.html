<!-- legacy work start -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<!-- legacy work end -->


<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)

LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Parsing Sound Resources and Sound Files (IM: S)  (deprecated)</Title>

<!-- legacy work start -->
        <META NAME="Generator" CONTENT="manual">
        <META http-equiv="content-type" CONTENT="text/html;charset=utf-8">
        <META NAME = "Copyright" CONTENT="Copyright 2007 Apple Inc. All Rights Reserved.">
        <META NAME="IndexTitle" CONTENT="Inside Macintosh: Sound (Not Recommended)">
        <meta name="xcode-display" content="render">

        <LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css"> <!-- before submitting, globally replace ".." with "developer.apple.com" -->
        <script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
<!-- legacy work end -->

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<A NAME=HEADING56></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Sound-55.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Sound-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Sound-336.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Sound-57.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Sound-2.html"><B>Sound</B></A> / <BR><DD><A HREF="Sound-44.html"><B>Chapter 2 - Sound Manager</B></A> / <A HREF="Sound-50.html"><B>Using the Sound Manager</B></A></DL></FONT><P>
<HR>

<!-- legacy work start -->
<script type="text/javascript"> placeWatermark()</script>
<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
<i>Inside Macintosh: Sound</i> is deprecated as of Mac OS X v10.5. For new audio development in Mac OS X, use Core Audio. See the <a href="../../../referencelibrary/MusicAudio/" target="_top">Audio</a> page in the ADC Reference Library.</p></div></div></div>
<!-- legacy work end -->


<BLOCKQUOTE>
<A NAME=HEADING56-0></A>
<H2><A NAME=MARKER-9-340></A>Parsing Sound Resources and Sound Files</H2>
 This section explains how you can parse sound resources and sound files to find the component of a sound resource or sound file that contains information about the sound. For sound resources, this information is stored in the sound header. In addition to obtaining information about a sound from a sound header, you might need a pointer to a sound header to use any of several low-level sound commands. For sound files, information is stored in the Form and Common Chunks. This section shows how you can find those chunks and extract information from them.<P>
<DL>
<DT><B>Note</B>
<DD>The techniques shown in this section assume that you are familiar with the format of sound resources and sound files. See <A HREF=Sound-59.html#MARKER-9-399>"Sound Storage Formats" beginning on page 2-73</A> for complete information on sound storage formats.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING56-3></A>
<H3><A NAME=MARKER-9-341></A>Obtaining a Pointer to a Sound Header<A NAME=MARKER-2-342></A></H3>
 This section shows how you can obtain a pointer to a sound header stored in a sound resource. You can use this pointer to obtain information about the sound. You also need a pointer to a sound header to install a sampled sound as a voice in a channel (as described in <A HREF=Sound-54.html#MARKER-9-275>"Installing Voices Into Channels" on page 2-43</A>) and to play sounds using low-level sound commands (as described below and in the next section). You can use a technique similar to the one described in this section if you wish to obtain a pointer to wave-table data that is stored in a sound resource.<P>
 Sound Manager versions 3.0 and later include the <CODE>GetSoundHeaderOffset</CODE> function that you can use to locate a sound header embedded in a sound resource. <A HREF=#MARKER-9-344>Listing 2-27</A> shows how to call the <CODE>GetSoundHeaderOffset</CODE> function and then pass the returned offset to the <CODE>bufferCmd</CODE> sound command, to play a sampled sound using low-level Sound Manager routines.<A NAME=MARKER-2-343></A><P>
<B>Listing 2-27  <A NAME=MARKER-9-344></A>Playing a sound resource</B><P>
<PRE>
FUNCTION MyPlaySampledSound (chan: SndChannelPtr; sndHandle: Handle): OSErr;
VAR
   myOffset:      LongInt;
   mySndCmd:      SndCommand;          {a sound command}
   myErr:         OSErr;
BEGIN
   myErr := GetSoundHeaderOffset(sndHandle, myOffset);
   IF myErr = noErr THEN
   BEGIN
      HLock(sndHandle);
      mySndCmd.cmd := bufferCmd;                {command is bufferCmd}
      mySndCmd.param1 := 0;                     {unused with bufferCmd}
      mySndCmd.param2 := LongInt(ORD4(sndHandle^) + myOffset);
      myErr := SndDoImmediate(chan, mySndCmd);
   END;
   MyPlaySampledSound := myErr;
END;
</PRE>
 If the <CODE>GetSoundHeaderOffset</CODE> function is not available but you still need to obtain a pointer to a sound header, you can use the function <CODE>MyGetSoundHeaderOffset</CODE> defined in <A HREF=#MARKER-9-345>Listing 2-28</A>. The function defined there traverses a sound resource until it reaches the sound data. It returns, in the <CODE>offset</CODE> parameter, the offset in bytes from the beginning of a sound resource to the sound header.<P>
<DL>
<DT><B>IMPORTANT</B>
<DD>The <CODE>GetSoundHeaderOffset</CODE> function is available in Sound Manager versions 3.0 and later. As a result, you'll need to use the techniques illustrated in <A HREF=#MARKER-9-345>Listing 2-28</A> only if you want your application to find a sound header when earlier versions of the Sound Manager are available.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<B>Listing 2-28  <A NAME=MARKER-9-345></A>Obtaining the offset in bytes to a sound header</B><P>
<PRE>
FUNCTION MyGetSoundHeaderOffset (sndHdl: Handle; VAR offset: LongInt): OSErr;
TYPE
   Snd1Header =                           {format 1 'snd ' resource header}
   RECORD
      format:     Integer;                {format of resource}
      numSynths:  Integer;                {number of data types}
                                          {synths, init option follow}
   END;
   Snd1HdrPtr = ^Snd1Header;
   Snd2Header =                           {format 2 'snd ' resource header}
   RECORD
      format:     Integer;                {format of resource}
      refCount:   Integer;                {for application use}
   END;
   Snd2HdrPtr = ^Snd2Header;
   IntPtr = ^Integer;                     {for type coercion}
   SndCmdPtr = ^SndCommand;               {for type coercion}
VAR
   myPtr:         Ptr;                    {to navigate resource}
   myOffset:      LongInt;                {offset into resource}
   numSynths:     Integer;                {info about resource}
   numCmds:       Integer;                {info about resource}
   isDone:        Boolean;                {are we done yet?}
   myErr:         OSErr;
BEGIN
   {Initialize variables.}
   myOffset := 0;                         {return 0 if no sound header found}
   myPtr := Ptr(sndHdl^);                 {point to start of resource data}
   isDone := FALSE;                       {haven't yet found sound header}
   myErr := noErr;

   {Skip everything before sound commands.}
   CASE Snd1HdrPtr(myPtr)^.format OF
      firstSoundFormat:                   {format 1 'snd ' resource}
         BEGIN                            {skip header start, synth ID, etc.}
            numSynths := Snd1HdrPtr(myPtr)^.numSynths;
            myPtr := Ptr(ORD4(myPtr) + SizeOf(Snd1Header));
            myPtr := Ptr(ORD4(myPtr) + 
                        numSynths * (SizeOf(Integer) + SizeOf(LongInt)));
         END;
      secondSoundFormat:                  {format 2 'snd ' resource}
         myPtr := Ptr(ORD4(myPtr) + SizeOf(Snd2Header));
      OTHERWISE                           {unrecognized resource format}
         BEGIN
            myErr := badFormat;
            isDone := TRUE;
         END;
      END;

   {Find number of commands and move to start of first command.}
   numCmds := IntPtr(myPtr)^;
   myPtr := Ptr(ORD4(myPtr) + SizeOf(Integer));

   {Search for bufferCmd or soundCmd to obtain sound header.}
   WHILE (numCmds &gt;= 1) AND (NOT isDone) DO
   BEGIN
      IF (IntPtr(myPtr)^ = bufferCmd + dataOffsetFlag) OR
            (IntPtr(myPtr)^ = soundCmd + dataOffsetFlag) THEN
      BEGIN                               {bufferCmd or soundCmd found}
                                          {copy offset from sound command}
         myOffset := SndCmdPtr(myPtr)^.param2;
         isDone := TRUE;                  {get out of loop}
      END
      ELSE
      BEGIN                               {soundCmd or bufferCmd not found}
                                          {move to next command}
         myPtr := Ptr(ORD4(myPtr) + SizeOf(SndCommand));
         numCmds := numCmds - 1;
      END;
   END; {WHILE}

   offset := myOffset;                    {return offset}
   MyGetSoundHeaderOffset := myErr;       {return result code}
END;
</PRE>
 The <CODE>MyGetSoundHeaderOffset</CODE> function defined in <A HREF=#MARKER-9-345>Listing 2-28</A> begins by initializing several variables, including a pointer that it sets to point to the beginning of the data contained in the sound resource. Then, after determining whether the sound resource is format 1 or format 2, the function skips data contained in the format 1 <CODE>'snd '</CODE> resource header or in the format 2 <CODE>'snd '</CODE> resource header, as appropriate.<P>
<DL>
<DT><B>Note</B>
<DD>Do not confuse the format 1 or format 2 <CODE>'snd '</CODE> header with the sound header the <CODE>MyGetSoundHeaderOffset</CODE> function defined in <A HREF=#MARKER-9-345>Listing 2-28</A> is designed to find. A sound header contains information about the sampled-sound data stored in a sound resource; a sound resource header contains information about the format of the sound resource.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 After skipping information in the sound resource header, <CODE>MyGetSoundHeaderOffset</CODE> simply looks through all sound commands in the resource for a <CODE>bufferCmd</CODE> or <CODE>soundCmd</CODE> command, either of which must contain the offset from the beginning of the resource to the sound header in its <CODE>param2</CODE> field. If the given sound resource contains no sound header (and thus no sampled-sound data), the <CODE>MyGetSoundHeaderOffset</CODE> function returns an error and sets the <CODE>offset</CODE> variable parameter to 0.<A NAME=MARKER-2-346></A><P>
 After using the <CODE>MyGetSoundHeaderOffset</CODE> function to obtain an offset to the sound header, you can easily obtain a pointer to a sound header. Note, however, that because a handle to a sound resource is contained in a relocatable block, you must lock the relocatable block before you obtain a pointer to a sound header, and you must not unlock it until you are through using the pointer. <A HREF=#MARKER-9-347>Listing 2-29</A> demonstrates how you can convert an offset to a sound header into a pointer to a sound header after locking a relocatable block.<P>
<B>Listing 2-29  <A NAME=MARKER-9-347></A>Converting an offset to a sound header into a pointer to a sound header</B><P>
<PRE>
FUNCTION MyGetSoundHeader (sndHandle: Handle): SoundHeaderPtr;
VAR
   myOffset:    LongInt;         {offset to sound header}
   myErr:      OSErr;
BEGIN
   HLockHi(sndHandle);           {lock data in high memory}
                                 {compute offset to sound header}
   myErr := MyGetSoundHeaderOffset(sndHandle, myOffset);
   IF myErr &lt;&gt; noErr THEN
      MyGetSoundHeader := NIL    {no sound header in resource}
   ELSE
                                 {compute address of sound header}
      MyGetSoundHeader := SoundHeaderPtr(ORD4(sndHandle^) + myOffset);
END;
</PRE>
 The <CODE>MyGetSoundHeader</CODE> function defined in <A HREF=#MARKER-9-347>Listing 2-29</A> locks the sound handle you pass it in high memory and then attempts to find an offset to the sound header in the sound handle. If the <CODE>MyGetSoundHeaderOffset</CODE> function defined in <A HREF=#MARKER-9-345>Listing 2-28</A> returns an offset of 0, then <CODE>MyGetSoundHeader</CODE> returns a <CODE>NIL</CODE> pointer to a sound header; otherwise, it returns a pointer that remains valid as long as you do not unlock the sound handle.<P>
 The <CODE>MyGetSoundHeader</CODE> function returns a pointer to a sampled sound header even if the sound header is actually an extended sound header or a compressed sound header. Thus, before accessing any other fields of the sound header, you should test the <CODE>encode</CODE> field of the sound header to determine what type of sound header it is. Then, if the sound header is, for example, an extended sound header, cast the sampled sound header to an extended sound header. Then you can access any of the fields of the extended sound header. For an example of this technique, see <A HREF=Sound-54.html#MARKER-9-282>Listing 2-16 on page 2-44</A>.<A NAME=MARKER-2-348></A><A NAME=MARKER-2-349></A><P>
<A NAME=HEADING56-20></A>
<H3><A NAME=MARKER-9-350></A>Playing Sounds Using Low-Level Routines<A NAME=MARKER-2-217></A></H3>
 Once you obtain a pointer to a sampled sound header, you can use the <CODE>bufferCmd</CODE> sound command to play a sound without using the high-level Sound Manager routines. Many sampled-sound resources include <CODE>bufferCmd</CODE> commands, so the high-level Sound Manager routines often issue the <CODE>bufferCmd</CODE> command indirectly. Thus, you might in some cases be able to make your application slightly more efficient by issuing the <CODE>bufferCmd</CODE> command directly. Also, you might issue a <CODE>bufferCmd</CODE> command directly if you want the Sound Manager to ignore other parts of a sound resource.<A NAME=MARKER-2-352></A><A NAME=MARKER-2-353></A><P>
 Finally, you might issue <CODE>bufferCmd</CODE> commands directly if you want your application to be able to play a large sound resource without loading the entire resource at once. By issuing several successive <CODE>bufferCmd</CODE> commands, you can play a large sound resource using a small buffer. In this case, each buffer must contain a sampled sound header. In most cases, the sound will play smoothly, without audible gaps. It's generally easier, however, to play large sampled sounds from disk by using the play-from-disk routines or the <CODE>SndPlayDoubleBuffer</CODE> function. See <A HREF=Sound-121.html#MARKER-9-911>"Managing Double Buffers" on page 2-147</A> for complete details.<A NAME=MARKER-2-58></A><P>
<DL>
<DT><B>Note</B>
<DD>Using the <CODE>bufferCmd</CODE> command to play several consecutive compressed samples on the Macintosh Plus, the Macintosh SE, or the Macintosh Classic is not guaranteed to work without an audible pause or click.<EM></EM> <A NAME=MARKER-2-59></A>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 <A NAME=MARKER-9-21></A>The pointer in the <CODE>param2</CODE> field of a <CODE>bufferCmd</CODE> command is the location of a sampled sound header. A <CODE>bufferCmd</CODE> command is queued in the channel until the preceding commands have been processed. If the <CODE>bufferCmd</CODE> command is contained within an <CODE>'snd '</CODE> resource, the high bit of the command must be set. If the sound was loaded in from an <CODE>'snd '</CODE> resource, your application is expected to unlock this resource and allow it to be purged after using it. <A HREF=#MARKER-9-357>Listing 2-30</A> shows how your application can play a sampled sound stored in a resource using the <CODE>bufferCmd</CODE> command.<P>
<B>Listing 2-30  <A NAME=MARKER-9-357></A>Playing a sound using the <CODE>bufferCmd</CODE> command</B><P>
<PRE>
FUNCTION MyLowLevelSampledSndPlay (chan: SndChannelPtr; sndHandle: Handle): 
                                    OSErr;
CONST
   kWaitIfFull = TRUE;                 {wait for room in queue?}
VAR
   mySndHeader:   SoundHeaderPtr;
   mySndCmd:      SndCommand;          {a sound command}
BEGIN
   mySndHeader := MyGetSoundHeader(sndHandle);
   WITH mySndCmd DO
   BEGIN
      cmd := bufferCmd;                {command is bufferCmd}
      param1 := 0;                     {unused with bufferCmd}
      param2 := LongInt(mySndHeader);  {pointer to sound header}
   END;
   IF mySndHeader &lt;&gt; NIL THEN
      MyLowLevelSampledSndPlay := 
                              SndDoCommand(chan, mySndCmd, NOT kWaitIfFull)
   ELSE
      MyLowLevelSampledSndPlay := badFormat;
END;
</PRE>
 For the <CODE>MyLowLevelSampledSndPlay</CODE> function defined in <A HREF=#MARKER-9-357>Listing 2-30</A> to play a sound, the channel passed to it must already be configured to play sampled-sound data. Otherwise, the function returns a <CODE>badChannel</CODE> result code. Also, because the <CODE>bufferCmd</CODE> command works asynchronously, you might want to associate a callback procedure with the sound channel when you create the channel. For more information on playing sounds asynchronously, see <A HREF=Sound-55.html#MARKER-9-292>"Playing Sounds Asynchronously" on page 2-46</A>.<A NAME=MARKER-2-358></A><A NAME=MARKER-2-359></A><P>
 You can use the <CODE>bufferCmd</CODE> command to handle compressed sound samples in addition to sounds that are not compressed. To expand and play back a buffer of compressed samples, you pass the Sound Manager a <CODE>bufferCmd</CODE> command where <CODE>param2</CODE> points to a compressed sound header.<A NAME=MARKER-2-360></A><P>
 To play sampled sounds that are not compressed, pass <CODE>bufferCmd</CODE> a standard or extended sound header. The extended sound header can be used for stereo sampled sounds. The standard sampled sound header is used for all other noncompressed sampled sounds.<A NAME=MARKER-2-60></A><A NAME=MARKER-2-251></A><P>
<A NAME=HEADING56-30></A>
<H3>Finding a Chunk in a Sound File<A NAME=MARKER-2-363></A><A NAME=MARKER-2-364></A></H3>
 Sound files are not as tightly structured as sound resources. As explained in <A HREF=Sound-61.html#MARKER-9-424>"Sound Files" on page 2-81</A>, the chunks in a sound file can appear in any order, except that the Form Chunk is always first. Most information about a sampled sound stored in a sound file is contained in the Common Chunk. Thus, to be able to access this information, you must be able to find a particular kind of chunk in a sound file. <A HREF=#MARKER-9-365>Listing 2-31</A> defines a procedure that you can use to find the location of the first chunk of a specified type beginning at the chunk you specify.<P>
<DL>
<DT><B>IMPORTANT</B>
<DD>The techniques illustrated in this section are provided primarily to help you understand the structure of sound files. Most sound-producing applications don't need to parse sound files.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<B>Listing 2-31  <A NAME=MARKER-9-365></A>Finding a chunk in a sound file</B><P>
<PRE>
FUNCTION MyFindChunk (myFile: Integer;       {file reference number}
                     myChunkSought: ID;      {ID of chunk sought}
                     startPos: LongInt;      {file position to start at}
                     VAR chunkFPos: LongInt) {file position of found chunk}
                     : OSErr;
VAR
   myLength:         LongInt;                {number of bytes to read}
   myChunkHeader:    ChunkHeader;            {characteristics of chunk}
   found:            Boolean;                {flag variable}
   myErr:            OSErr;                  {error from File Manager calls}
BEGIN
   found := FALSE;                           {initialize flag variable}
                                             {set file mark at start}
   myErr := SetFPos(myFile, fsFromStart, startPos);

   {Search file's chunks for desired chunk ID.}
   WHILE (NOT found) AND (myErr = noErr) DO
   BEGIN                                     {check current chunk}
      myLength := SizeOf(myChunkHeader);
      {Load chunk header.}
      myErr := FSRead(myFile, myLength, @myChunkHeader);
      IF myErr = noErr THEN                  {chunk header loaded okay}
         IF myChunkHeader.ckID = myChunkSought THEN
         BEGIN
            found := TRUE;                   {chunk has been found}
                                             {find position in file}
            myErr := GetFPos(myFile, chunkFPos);
                                             {compute chunk's start position}
            chunkFPos := chunkFPos - SizeOf(myChunkHeader);
         END
         ELSE
         BEGIN                               {move to next chunk}
            IF myChunkHeader.ckID = ID(FormID) THEN
               {Adjust Form Chunk's size to size of formType field.}
               myChunkHeader.ckSize := SizeOf(ID);
            IF myChunkHeader.ckSize MOD 2 = 1 THEN
               {Compensate for pad byte.}
               myChunkHeader.ckSize := myChunkHeader.ckSize + 1;
            myErr := SetFPos(myFile, fsFromMark, myChunkHeader.ckSize);
         END;
   END; {WHILE}
   MyFindChunk := myErr;
END;
</PRE>
 The <CODE>MyFindChunk</CODE> function defined in <A HREF=#MARKER-9-365>Listing 2-31</A> accepts four parameters. The <CODE>myFile</CODE> parameter is the file reference number of an open sound file. (For information on file reference numbers, see <I><A HREF="../Files/Files-2.html">Inside Macintosh: Files</A></I>.) In the <CODE>myChunkSought</CODE> parameter, you pass the ID of the type of chunk you wish to find. For example, you might pass <CODE>ID(FormID)</CODE> to find the Form Chunk. The third parameter, <CODE>startPos</CODE>, is the file position at which <CODE>MyFindChunk</CODE> should start searching for a chunk. This file position must be the beginning of a chunk. To start at the beginning of a file, specify 0. Finally, if the <CODE>MyFindChunk</CODE> function is successful, it returns in the <CODE>chunkFPos</CODE> parameter the file position of the first chunk of the specified type that it found. If the function is unsuccessful, it returns the appropriate File Manager result code (such as an end-of-file error) and the <CODE>chunkFPos</CODE> parameter is undefined.<P>
 The <CODE>MyFindChunk</CODE> function works by looking at each chunk of the sound file, beginning at the file position <CODE>startPos</CODE> and checking to see if the chunk is of the type sought. If a chunk matches, the <CODE>MyFindChunk</CODE> function returns the file position of the start of the chunk; otherwise, the function moves onto the next chunk. For each chunk, the <CODE>MyFindChunk</CODE> function reads in the chunk header, checks for a match, and then moves to the next chunk.<P>
 The <CODE>MyFindChunk</CODE> function moves from one chunk to the next by identifying the size of the current chunk, not including the chunk header, from the <CODE>ckSize</CODE> field of the chunk header. Whenever you parse sound files, you should always use the <CODE>ckSize</CODE> field of the chunk header to determine the size of a chunk if the size of the chunk could vary in size. The <CODE>MyFindChunk</CODE> function adjusts the value in the <CODE>ckSize</CODE> field before advancing to the next chunk in two cases. First, the <CODE>ckSize</CODE> field for the Form Chunk reflects the size of the entire sound file, so this function changes it to the size of the <CODE>formType</CODE> field so that the function does not skip the file's local chunks. Second, if the <CODE>ckSize</CODE> field is odd, 1 byte is added because the number of bytes in a chunk is always even.<A NAME=MARKER-2-366></A><P>
 After using the <CODE>MyFindChunk</CODE> function defined in <A HREF=#MARKER-9-365>Listing 2-31</A>, you might still need to read the data contained in a chunk into memory. For example, you might read in the Form and Common Chunks to obtain information about a sound file. <A HREF=#MARKER-9-367>Listing 2-32</A> uses the <CODE>MyFindChunk</CODE> function to find a chunk in a sound file, allocates an appropriately sized block of memory for that chunk, and reads the chunk into that block.<P>
<B>Listing 2-32  <A NAME=MARKER-9-367></A>Loading a chunk from a sound file</B><P>
<PRE>
FUNCTION MyGetChunkData (myFile: Integer;       {file reference number}
                           myChunkSought: ID;   {ID of chunk sought}
                           startPos: LongInt):  {file position to start at}
                           Ptr;                 {pointer to data or NIL}
VAR
   myFPos:           LongInt;                   {position in file}
   myLength:         LongInt;                   {number of bytes to read}
   myChunkHeader:    ChunkHeader;               {characteristics of a chunk}
   myChunkData:      Ptr;                       {pointer to chunk data}
   myErr:            OSErr;
BEGIN
   myChunkData := NIL;                          {initialize variable}
   myErr := MyFindChunk(myFile, myChunkSought, startPos, myFPos);
   IF myErr = noErr THEN
                                                {move to start of chunk}
      myErr := SetFPos(myFile, fsFromStart, myFPos);
   IF myErr = noErr THEN
   BEGIN                               {determine how much data to copy}
      myLength := SizeOf(ChunkHeader);
      myErr := FSRead(myFile, myLength, @myChunkHeader);
      IF myChunkHeader.ckID = ID(FormID) THEN
         myChunkHeader.ckSize := SizeOf(ID);    {don't return local chunks}
      myLength := myChunkHeader.ckSize + SizeOf(ChunkHeader);
      IF myErr = noErr THEN
                                                {return to chunk's start}
         myErr := SetFPos(myFile, fsFromStart, myFPos);
   END;
   IF myErr = noErr THEN
   BEGIN                                  {read chunk data into RAM}
      myChunkData := NewPtr(myLength);
      IF myChunkData &lt;&gt; NIL THEN
         myErr := FSRead(myFile, myLength, myChunkData);
   END;
   IF myErr &lt;&gt; noErr THEN
      IF myChunkData &lt;&gt; NIL THEN
         DisposePtr(myChunkData);
   MyGetChunkData := myChunkData;
END;
</PRE>
 The <CODE>MyGetChunkData</CODE> function defined in <A HREF=#MARKER-9-367>Listing 2-32</A> attempts to find a chunk in a file. If it finds the chunk, it reads the chunk header to determine the chunk's size, and if the chunk is the Form Chunk, adjusts the chunk size so that the sound file's local chunks are not included in the chunk size. Then the function attempts to allocate memory for the chunk and read the chunk into the memory. If a problem occurs at any time, the function simply returns <CODE>NIL</CODE>.<P>
<DL>
<DT><B>Note</B>
<DD>The format of a sound file might not be the same as its operating-system type. In particular, a file might have an operating-system type <CODE>'AIFC'</CODE> but be formatted as an AIFF file because the sampled-sound data contained in the file is noncompressed.<EM></EM> <A NAME=MARKER-2-369></A><A NAME=MARKER-2-370></A>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Sound-55.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Sound-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Sound-336.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Sound-57.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Sound-3.html">&copy; Apple Computer, Inc.</A><br>2 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
