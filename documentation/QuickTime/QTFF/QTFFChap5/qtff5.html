<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>QuickTime File Format Specification: Some Useful Examples and Scenarios</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Some Useful Examples and Scenarios"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40000939-CH207" title="Some Useful Examples and Scenarios"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> &gt; <a href="../../../../reference/QuickTime/index.html#//apple_ref/doc/uid/TP30001281-TP30000433" target="_top">QuickTime</a> &gt; <a href="../../../../reference/QuickTime/idxFileFormatSpecification-date.html#//apple_ref/doc/uid/TP30001281-TP30000433-TP30000509" target="_top">File Format Specification</a> &gt; <a href="../QTFFPreface/qtffPreface.html#//apple_ref/doc/uid/TP40000939-CH202-TPXREF101">QuickTime File Format Specification</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../QTFFChap4/qtff4.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../QTFFAppenA/QTFFAppenA.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_98" title="Some Useful Examples and Scenarios"></a><h1><a name="//apple_ref/doc/uid/TP40000939-CH207-TPXREF101" title="Some Useful Examples and Scenarios "></a>Some Useful Examples and Scenarios </h1>
<p>This chapter contains a number of examples
that can help you pull together all of the material in this book
by examining the atom structure that results from a number of different
scenarios. </p>
<p>The chapter is divided into the following topics:</p>
<ul class="ul"><li class="li"><p><span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-19277">“Creating, Copying, and Disposing of Atom Containers”</a></span> discusses
the various ways you can work with atom containers, along with illustrations
and sample code that show usage. </p></li>
<li class="li"><p><span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-19281">“Creating an Effect Description”</a></span> discusses how you create an
effect description by creating an atom container, inserting a QT
atom that specifies the effect, and inserting a set of QT atoms
that set its parameters. </p></li>
<li class="li"><p><span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-19285">“Creating Movies With Modifier Tracks”</a></span> provides sample code showing
you how to create a movie with modifier tracks.</p></li>
<li class="li"><p><span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-19289">“Authoring Movies With External Movie Targets”</a></span> discusses how to
author movies with external targets, using two new target atoms
introduced in QuickTime 4. </p></li>
<li class="li"><p><span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-19293">“Adding Wired Actions To a Flash Track”</a></span> explains the steps
you need to follow in order to add wired actions to a Macromedia
Flash track.</p></li>
<li class="li"><p><span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-19297">“Creating Video Tracks at 30 Frames-per-Second”</a></span> discusses creating
30 fps video.</p></li>
<li class="li"><p><span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-19303">“Creating Video Tracks at 29.97 Frames-per-Second”</a></span> describes
creating 29.97 fps video.</p></li>
<li class="li"><p><span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-19307">“Creating Audio Tracks at 44.1 Khz”</a></span> provides an example of creating
an audio track.</p></li>
<li class="li"><p><span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-19311">“Creating a Timecode Track for 29.97 FPS Video”</a></span> presents a timecode
track example.</p></li>
<li class="li"><p><span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-19315">“Playing With Edit Lists”</a></span> discusses how to interpret edit list
data.</p></li>
<li class="li"><p><span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-19319">“Interleaving Movie Data”</a></span> shows how a movie’s tracks are interleaved
in the movie data file.</p></li>
<li class="li"><p><span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-19323">“Referencing Two Data Files With a Single Track”</a></span> shows how track
data may reside in more than one file.</p></li>
<li class="li"><p><span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-19327">“Getting the Name of a QuickTime VR Node”</a></span> discusses how you
can use standard QuickTime atom container functions to retrieve
the information in a QuickTime VR node header atom.</p></li>
<li class="li"><p><span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-19331">“Adding Custom Atoms in a QuickTime VR Movie”</a></span> describes how
to add custom atoms to either the QuickTime VR world or node information
atom containers.</p></li>
<li class="li"><p><span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-19335">“Adding Atom Containers in a QuickTime VR Movie”</a></span> shows the
code you would use to add VR world and node information atom containers
to a QTVR track.</p></li>
<li class="li"><p><span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-19339">“Optimizing QuickTime VR Movies for Web Playback”</a></span> describes how
to use the QTVR Flattener, a movie export component that converts
an existing QuickTime VR single node movie into a new movie that
is optimized for viewing on the Web. </p></li></ul>
<a name="//apple_ref/doc/uid/TP40000939-CH207-19277" title="Creating, Copying, and Disposing of Atom Containers"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCGFGBC" title="Creating, Copying, and Disposing of Atom Containers"></a><h2>Creating, Copying, and Disposing of Atom
Containers</h2>
<p>Before you can <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_800"></a>add atoms to an atom container,
you must first create the container by calling <code>QTNewAtomContainer</code>.
The code sample shown in <span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-24227">Listing 5-1</a></span> calls <code>QTNewAtomContainer</code> to
create an atom container. </p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-24227" title="Listing 5-1Creating a new atom container"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCJJGDA" title="Listing 5-1Creating a new atom container"></a><p class="codesample"><strong>Listing 5-1&nbsp;&nbsp;</strong>Creating a new atom container</p>
<div class="codesample"><table><tr><td scope="row"><pre>QTAtomContainer spriteData;<span></span></pre></td></tr><tr><td scope="row"><pre>OSErr err<span></span></pre></td></tr><tr><td scope="row"><pre>// create an atom container to hold a sprite’s data<span></span></pre></td></tr><tr><td scope="row"><pre>err=QTNewAtomContainer (&amp;spriteData);<span></span></pre></td></tr></table></div>
<p>When you have finished using an atom container, you should
dispose of it by calling the <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_801"></a><code>QTDisposeAtomContainer</code> function.
The sample code shown in <span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-24238">Listing 5-2</a></span> calls <code>QTDisposeAtomContainer</code> to
dispose of the <code>spriteData</code> atom
container.</p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-24238" title="Listing 5-2Disposing of an atom container"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCBAAHE" title="Listing 5-2Disposing of an atom container"></a><p class="codesample"><strong>Listing 5-2&nbsp;&nbsp;</strong>Disposing of an atom container</p><a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_802"></a>
<div class="codesample"><table><tr><td scope="row"><pre>if (spriteData)<span></span></pre></td></tr><tr><td scope="row"><pre>    QTDisposeAtomContainer (spriteData);<span></span></pre></td></tr></table></div>
<a name="//apple_ref/doc/uid/TP40000939-CH207-17052" title="Creating New Atoms"></a><h3>Creating
New Atoms</h3>
<p>You can use the <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_803"></a><code>QTInsertChild</code> function
to create new atoms and insert them in a QT atom container. The <code>QTInsertChild</code> function
creates a new child atom for a parent atom. The caller specifies
an atom type and atom ID for the new <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_804"></a>atom. If you specify a value of 0 for the
atom ID, <code>QTInsertChild</code> assigns
a unique ID to the atom.</p>
<p><code>QTInsertChild</code> inserts
the atom in the parent’s child list at the index specified by
the <code>index</code> parameter;
any existing atoms at the same index or greater are moved toward
the end of the child list. If you specify a value of 0 for the <code>index</code> parameter, <code>QTInsertChild</code> inserts
the atom at the end of the child list.</p>
<p>The code sample in <span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-24253">Listing 5-3</a></span> creates a new QT atom container and calls <code>QTInsertChild</code> to add
an atom. The resulting QT atom container is shown in <span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-19207">Figure 5-1</a></span>. The
offset value 10 is returned in the <code>firstAtom</code> parameter.</p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-24253" title="Listing 5-3Creating a new QT atom container and calling QTInsertChild to add an atom. "></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCEBDBE" title="Listing 5-3Creating a new QT atom container and calling QTInsertChild to add an atom. "></a><p class="codesample"><strong>Listing 5-3&nbsp;&nbsp;</strong>Creating a new QT atom container and
calling <code>QTInsertChild</code> to
add an atom. </p>
<div class="codesample"><table><tr><td scope="row"><pre>QTAtom firstAtom;<span></span></pre></td></tr><tr><td scope="row"><pre>QTAtomContainer container;<span></span></pre></td></tr><tr><td scope="row"><pre>OSErr err<span></span></pre></td></tr><tr><td scope="row"><pre>err = QTNewAtomContainer (&amp;container);<span></span></pre></td></tr><tr><td scope="row"><pre>if (!err)<span></span></pre></td></tr><tr><td scope="row"><pre>    err = QTInsertChild (container, kParentAtomIsContainer, 'abcd',<span></span></pre></td></tr><tr><td scope="row"><pre>        1000, 1, 0, nil, &amp;firstAtom);<span></span></pre></td></tr></table></div>
<br/><div><a name="//apple_ref/doc/uid/TP40000939-CH207-19207" title="Figure 5-1QT atom container after inserting an atom"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCHDAAF" title="Figure 5-1QT atom container after inserting an atom"></a><p><strong>Figure 5-1&nbsp;&nbsp;</strong>QT atom container after inserting
an atom</p><img src = "../art/qtml_07.gif" alt = "QT atom container after inserting an atom" width="134" height="153"></div><br/>
<p>The following code sample calls <code>QTInsertChild</code> to
create a second child atom. Because a value of 1 is specified for
the <code>index</code> parameter,
the second atom is inserted in front of the first atom in the child
list; the index of the first atom is changed to 2. The resulting
QT atom container is shown in <span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-19211">Figure 5-2</a></span>.</p>
<div class="codesample"><table><tr><td scope="row"><pre>QTAtom secondAtom;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>FailOSErr (QTInsertChild (container, kParentAtomIsContainer, 'abcd',<span></span></pre></td></tr><tr><td scope="row"><pre>    2000, 1, 0, nil, &amp;secondAtom));<span></span></pre></td></tr></table></div>
<br/><div><a name="//apple_ref/doc/uid/TP40000939-CH207-19211" title="Figure 5-2QT atom container after inserting a second atom"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCJIBDC" title="Figure 5-2QT atom container after inserting a second atom"></a><p><strong>Figure 5-2&nbsp;&nbsp;</strong>QT atom container after inserting
a second atom</p><img src = "../art/qtml_08.gif" alt = "QT atom container after inserting a second atom" width="309" height="122"></div><br/>
<p>You can call the <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_805"></a><code>QTFindChildByID</code> function
to retrieve the changed offset of the first atom that was inserted,
as shown in the following example. In this example, the <code>QTFindChildByID</code> function
returns an offset of 20.</p>
<div class="codesample"><table><tr><td scope="row"><pre>firstAtom = QTFindChildByID (container, kParentAtomIsContainer,  'abcd',<span></span></pre></td></tr><tr><td scope="row"><pre>    1000, nil);<span></span></pre></td></tr></table></div>
<p><span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-24270">Listing 5-4</a></span> shows how the <code>QTInsertChild</code> function
inserts a leaf atom into the atom container <code>sprite</code>.
The new leaf atom contains a sprite image index as its data.</p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-24270" title="Listing 5-4Inserting a child atom"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCGFEJA" title="Listing 5-4Inserting a child atom"></a><p class="codesample"><strong>Listing 5-4&nbsp;&nbsp;</strong>Inserting a child atom</p>
<div class="codesample"><table><tr><td scope="row"><pre>if ((propertyAtom = QTFindChildByIndex (sprite, kParentAtomIsContainer,<span></span></pre></td></tr><tr><td scope="row"><pre>    kSpritePropertyImageIndex, 1, nil)) == 0)<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    FailOSErr (QTInsertChild (sprite, kParentAtomIsContainer,<span></span></pre></td></tr><tr><td scope="row"><pre>        kSpritePropertyImageIndex, 1, 1, sizeof(short),&amp;imageIndex,<span></span></pre></td></tr><tr><td scope="row"><pre>        nil));<span></span></pre></td></tr></table></div>
<a name="//apple_ref/doc/uid/TP40000939-CH207-17058" title="Copying Existing Atoms"></a><h3>Copying
Existing Atoms</h3>
<p>QuickTime provides several functions for copying existing
atoms within an atom container. The <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_806"></a><code>QTInsertChildren</code> function
inserts a container of atoms as children of a parent atom in another
atom container. <span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-19215">Figure 5-3</a></span> shows two example QT atom containers, A and B.</p>
<br/><div><a name="//apple_ref/doc/uid/TP40000939-CH207-19215" title="Figure 5-3Two QT atom containers, A and B"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCEDBDJ" title="Figure 5-3Two QT atom containers, A and B"></a><p><strong>Figure 5-3&nbsp;&nbsp;</strong>Two QT atom containers, A and B</p>
<img src = "../art/qtml_09.gif" alt = "Two QT atom containers, A and B" width="455" height="174"></div><br/>
<p>The following code sample calls <code>QTFindChildByID</code> to
retrieve the offset of the atom in container A. Then, the code sample
calls the <code>QTInsertChildren</code> function
to insert the atoms in container B as children of the atom in container
A. <span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-19219">Figure 5-4</a></span> shows
what container A looks like after the atoms from container B have
been inserted.</p>
<div class="codesample"><table><tr><td scope="row"><pre>QTAtom targetAtom;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>targetAtom = QTFindChildByID (containerA, kParentAtomIsContainer,  'abcd',<span></span></pre></td></tr><tr><td scope="row"><pre>    1000, nil);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>FailOSErr (QTInsertChildren (containerA, targetAtom, containerB));<span></span></pre></td></tr></table></div>
<br/><div><a name="//apple_ref/doc/uid/TP40000939-CH207-19219" title="Figure 5-4QT atom container after child atoms have been inserted"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCEGBEJ" title="Figure 5-4QT atom container after child atoms have been inserted"></a><p><strong>Figure 5-4&nbsp;&nbsp;</strong>QT atom container after child atoms
have been inserted</p><img src = "../art/qtml_10.gif" alt = "QT atom container after child atoms have been inserted" width="298" height="247"></div><br/>
<p>In <span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-24281">Listing 5-5</a></span>, the <code>QTInsertChild</code> function
inserts a parent atom into the atom container <code>theSample</code>.
Then, the code calls <code>QTInsertChildren</code> to
insert the container <code>theSprite</code> into
the container <code>theSample</code>.
The parent atom is <code>newSpriteAtom</code>.</p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-24281" title="Listing 5-5Inserting a container into another container"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCDHJEI" title="Listing 5-5Inserting a container into another container"></a><p class="codesample"><strong>Listing 5-5&nbsp;&nbsp;</strong>Inserting a container into another container</p>
<div class="codesample"><table><tr><td scope="row"><pre>FailOSErr (QTInsertChild (theSample, kParentAtomIsContainer,<span></span></pre></td></tr><tr><td scope="row"><pre>    kSpriteAtomType, spriteID, 0, 0, nil, &amp;newSpriteAtom));<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>FailOSErr (QTInsertChildren (theSample, newSpriteAtom, theSprite));<span></span></pre></td></tr></table></div>
<p>QuickTime provides three other functions you can use to manipulate
atoms in an atom container. The <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_807"></a><code>QTReplaceAtom</code> function
replaces an atom and its children with a different atom and its
children. You can call the <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_808"></a><code>QTSwapAtoms</code> function
to swap the contents of two atoms in an atom container; after swapping,
the ID and index of each atom remains the same. The <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_809"></a><code>QTCopyAtom</code> function
copies an atom and its children to a new atom container.</p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-17064" title="Retrieving Atoms From an Atom Container"></a><h3>Retrieving
Atoms From an Atom Container</h3>
<p>QuickTime provides functions you can use to retrieve information
about the types of a parent atom’s children, to search for a specific
atom, and to retrieve a leaf atom’s data.</p>
<p>You can use the <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_810"></a><code>QTCountChildrenOfType</code> and <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_811"></a><code>QTGetNextChildType</code> functions
to retrieve information about the types of an atom’s children.
The <code>QTCountChildrenOfType</code> function returns
the number of children of a given atom type for a parent atom. The <code>QTGetNextChildType</code> function
returns the next atom type in the child list of a parent atom.</p>
<p>You can use the <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_812"></a><code>QTFindChildByIndex</code>, <code>QTFindChildByID</code>,
and <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_813"></a><code>QTNextChildAnyType</code> functions to
retrieve an atom. You call the <code>QTFindChildByIndex</code> function
to search for and retrieve a parent atom’s child by its type and
index within that type.</p>
<p><span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-24292">Listing 5-6</a></span> shows the sample code function <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_814"></a><code>SetSpriteData</code>,
which updates an atom container that describes a sprite. (For more
information about sprites and the Sprite Toolbox, refer to the book
Programming With Wired Movies and Sprite Animation, available at <code>http://developer.apple.com/techpubs/quicktime/qtdevdocs/RM/PDF.htm</code>.)
For each property of the sprite that needs to be updated, <code>SetSpriteData</code> calls <code>QTFindChildByIndex</code> to
retrieve the appropriate atom from the atom container. If the atom is
found, <code>SetSpriteData</code> calls <code>QTSetAtomData</code> to
replace the atom’s data with the new value of the property. If
the atom is not found, <code>SetSpriteData</code> calls <code>QTInsertChild</code> to
add a new atom for the property.</p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-24292" title="Listing 5-6Finding a child atom by index"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCGCHFC" title="Listing 5-6Finding a child atom by index"></a><p class="codesample"><strong>Listing 5-6&nbsp;&nbsp;</strong>Finding a child atom
by index</p><a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_815"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_816"></a>
<div class="codesample"><table><tr><td scope="row"><pre>OSErr SetSpriteData (QTAtomContainer sprite, Point *location,<span></span></pre></td></tr><tr><td scope="row"><pre>    short *visible, short *layer, short *imageIndex)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr err = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    QTAtom propertyAtom;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // if the sprite’s visible property has a new value<span></span></pre></td></tr><tr><td scope="row"><pre>    if (visible)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        // retrieve the atom for the visible property --<span></span></pre></td></tr><tr><td scope="row"><pre>        // if none exists, insert one<span></span></pre></td></tr><tr><td scope="row"><pre>        if ((propertyAtom = QTFindChildByIndex (sprite,<span></span></pre></td></tr><tr><td scope="row"><pre>            kParentAtomIsContainer, kSpritePropertyVisible, 1,<span></span></pre></td></tr><tr><td scope="row"><pre>            nil)) == 0)<span></span></pre></td></tr><tr><td scope="row"><pre>            FailOSErr (QTInsertChild (sprite, kParentAtomIsContainer,<span></span></pre></td></tr><tr><td scope="row"><pre>                kSpritePropertyVisible, 1, 1, sizeof(short), visible,<span></span></pre></td></tr><tr><td scope="row"><pre>                nil))<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // if an atom does exist, update its data<span></span></pre></td></tr><tr><td scope="row"><pre>        else<span></span></pre></td></tr><tr><td scope="row"><pre>            FailOSErr (QTSetAtomData (sprite, propertyAtom,<span></span></pre></td></tr><tr><td scope="row"><pre>                sizeof(short), visible));<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // ...<span></span></pre></td></tr><tr><td scope="row"><pre>    // handle other sprite properties<span></span></pre></td></tr><tr><td scope="row"><pre>    // ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<p>You can call the <code>QTFindChildByID</code> function
to search for and retrieve a parent atom’s child by its type and
ID. The sample code function <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_817"></a><code>AddSpriteToSample</code>,
shown in <span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-24307">Listing 5-7</a></span>, adds a sprite, represented by an atom container,
to a key sample, represented by another atom container. <code>AddSpriteToSample</code> calls <code>QTFindChildByID</code> to
determine whether the atom container <code>theSample</code> contains
an atom of type <code>kSpriteAtomType</code> with
the ID <code>spriteID</code>. If not, <code>AddSpriteToSample</code> calls <code>QTInsertChild</code> to
insert an atom with that type and ID. A value of 0 is passed for
the <code>index</code> parameter to
indicate that the atom should be inserted at the end of the child
list. A value of 0 is passed for the <code>dataSize</code> parameter
to indicate that the atom does not have any data. Then, <code>AddSpriteToSample</code> calls <code>QTInsertChildren</code> to
insert the atoms in the container <code>theSprite</code> as
children of the new atom. <code>FailIf</code> and <code>FailOSErr</code> are
macros that exit the current function when an error occurs.</p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-24307" title="Listing 5-7Finding a child atom by ID"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCDICDF" title="Listing 5-7Finding a child atom by ID"></a><p class="codesample"><strong>Listing 5-7&nbsp;&nbsp;</strong>Finding a child atom by ID</p>
<div class="codesample"><table><tr><td scope="row"><pre>OSErr AddSpriteToSample (QTAtomContainer theSample,<span></span></pre></td></tr><tr><td scope="row"><pre>    QTAtomContainer theSprite, short spriteID)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr err = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    QTAtom newSpriteAtom;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    FailIf (QTFindChildByID (theSample, kParentAtomIsContainer,<span></span></pre></td></tr><tr><td scope="row"><pre>        kSpriteAtomType, spriteID, nil), paramErr);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    FailOSErr (QTInsertChild (theSample, kParentAtomIsContainer,<span></span></pre></td></tr><tr><td scope="row"><pre>        kSpriteAtomType, spriteID, 0, 0, nil, &amp;newSpriteAtom));<span></span></pre></td></tr><tr><td scope="row"><pre>    FailOSErr (QTInsertChildren (theSample, newSpriteAtom, theSprite));<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<p>Once you have retrieved a child atom, you can call <code>QTNextChildAnyType</code> function
to retrieve subsequent children of a parent atom. <code>QTNextChildAnyType</code> returns
an offset to the next atom of any type in a parent atom’s child
list. This function is useful for iterating through a parent atom’s
children quickly.</p>
<p>QuickTime also provides functions for retrieving an atom’s
type, ID, and data. You can call <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_818"></a><code>QTGetAtomTypeAndID</code> function
to retrieve an atom’s type and ID. You can access an atom’s data
in one of three ways.</p>
<ul class="spaceabove"><li class="li"><p>To copy an atom’s data to a handle, you can
use the <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_819"></a><code>QTCopyAtomDataToHandle</code> function. </p></li>
<li class="li"><p>To copy an atom’s data to a pointer, you can use the <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_820"></a><code>QTCopyAtomDataToPtr</code> function.</p></li>
<li class="li"><p>To access an atom’s data directly, you should lock the atom
container in memory by calling <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_821"></a><code>QTLockContainer</code>.
Once the container is locked, you can call <code>QTGetAtomDataPtr</code> to retrieve
a pointer to an atom’s data. When you have finished accessing
the atom’s data, you should call the <code>QTUnlockContainer</code> function
to unlock the container in memory.</p></li></ul>
<a name="//apple_ref/doc/uid/TP40000939-CH207-17070" title="Modifying Atoms"></a><h3>Modifying
Atoms</h3>
<p>QuickTime provides functions that you can call to modify attributes
or data associated with an atom in an atom container. To modify
an atom’s ID, you call the function <code>QTSetAtomID</code>.</p>
<p>You use the <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_822"></a><code>QTSetAtomData</code> function
to update the data associated with a leaf atom in an atom container.
The <code>QTSetAtomData</code> function
replaces a leaf atom’s data with new data. The code sample in <span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-24332">Listing 5-8</a></span> calls </p>
<p></p>
<p><code>QTFindChildByIndex</code> to
determine whether an atom container contains a sprite’s visible property.
If so, the sample calls <code>QTSetAtomData</code> to
replace the atom’s data with a new visible property.</p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-24332" title="Listing 5-8Modifying an atom&acirc;&#128;&#153;s data"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCGGIFB" title="Listing 5-8Modifying an atom&acirc;&#128;&#153;s data"></a><p class="codesample"><strong>Listing 5-8&nbsp;&nbsp;</strong>Modifying an atom’s data</p>
<div class="codesample"><table><tr><td scope="row"><pre>QTAtom propertyAtom;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// if the atom isn’t in the container, add it<span></span></pre></td></tr><tr><td scope="row"><pre>if ((propertyAtom = QTFindChildByIndex (sprite, kParentAtomIsContainer,<span></span></pre></td></tr><tr><td scope="row"><pre>    kSpritePropertyVisible, 1, nil)) == 0)<span></span></pre></td></tr><tr><td scope="row"><pre>    FailOSErr (QTInsertChild (sprite, kParentAtomIsContainer,<span></span></pre></td></tr><tr><td scope="row"><pre>        kSpritePropertyVisible, 1, 0, sizeof(short), visible, nil))<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// if the atom is in the container, replace its data<span></span></pre></td></tr><tr><td scope="row"><pre>else<span></span></pre></td></tr><tr><td scope="row"><pre>    FailOSErr (QTSetAtomData (sprite, propertyAtom, sizeof(short),<span></span></pre></td></tr><tr><td scope="row"><pre>        visible));<span></span></pre></td></tr></table></div>
<a name="//apple_ref/doc/uid/TP40000939-CH207-17076" title="Removing Atoms From an Atom Container"></a><h3>Removing
Atoms From an Atom Container</h3>
<p>To remove atoms from an atom container, you can use the <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_823"></a><code>QTRemoveAtom</code> and <code><a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_824"></a>QTRemoveChildren</code> functions.
The <code>QTRemoveAtom</code> function
removes an atom and its children, if any, from a container. The <code>QTRemoveChildren</code> function
removes an atom’s children from a container, but does not remove
the atom itself. You can also use <code>QTRemoveChildren</code> to remove
all the atoms in an atom container. To do so, you should pass the
constant <code>kParentAtomIsContainer</code> for
the <code>atom</code> parameter.</p>
<p>The code sample shown in <span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-24360">Listing 5-9</a></span> adds override samples
to a sprite track to animate the sprites in the sprite track. The <code>sample</code> and <code>spriteData</code> variables
are atom containers. The <code>spriteData</code> atom
container contains atoms that describe a single sprite. The <code>sample</code> atom container
contains atoms that describes an override sample.</p>
<p>Each iteration of the <code>for</code> loop
calls <code>QTRemoveChildren</code> to
remove all atoms from both the <code>sample</code> and
the <code>spriteData</code> containers.
The sample code updates the index of the image to be used for the
sprite and the sprite’s location and calls <code>SetSpriteData</code> (<span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-24292">Listing 5-6</a></span>), which adds
the appropriate atoms to the <code>spriteData</code> atom
container. Then, the sample code calls <code>AddSpriteToSample</code> (<span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-24307">Listing 5-7</a></span>) to
add the <code>spriteData</code> atom
container to the <code>sample</code> atom container.
Finally, when all the sprites have been updated, the sample code
calls <code>AddSpriteSampleToMedia</code> to
add the override sample to the sprite track.</p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-24360" title="Listing 5-9Removing atoms from a container"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCEEJGG" title="Listing 5-9Removing atoms from a container"></a><p class="codesample"><strong>Listing 5-9&nbsp;&nbsp;</strong>Removing atoms from a container</p>
<div class="codesample"><table><tr><td scope="row"><pre>QTAtomContainer sample, spriteData;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// ...<span></span></pre></td></tr><tr><td scope="row"><pre>// add the sprite key sample<span></span></pre></td></tr><tr><td scope="row"><pre>// ...<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// add override samples to make the sprites spin and move<span></span></pre></td></tr><tr><td scope="row"><pre>for (i = 1; i &lt;= kNumOverrideSamples; i++)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    QTRemoveChildren (sample, kParentAtomIsContainer);<span></span></pre></td></tr><tr><td scope="row"><pre>    QTRemoveChildren (spriteData, kParentAtomIsContainer);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // ...<span></span></pre></td></tr><tr><td scope="row"><pre>    // update the sprite:<span></span></pre></td></tr><tr><td scope="row"><pre>    // - update the imageIndex<span></span></pre></td></tr><tr><td scope="row"><pre>    // - update the location<span></span></pre></td></tr><tr><td scope="row"><pre>    // ...<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // add atoms to spriteData atom container<span></span></pre></td></tr><tr><td scope="row"><pre>    SetSpriteData (spriteData, &amp;location, nil, nil, &amp;imageIndex);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // add the spriteData atom container to sample<span></span></pre></td></tr><tr><td scope="row"><pre>    err = AddSpriteToSample (sample, spriteData, 2);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // ...<span></span></pre></td></tr><tr><td scope="row"><pre>    // update other sprites<span></span></pre></td></tr><tr><td scope="row"><pre>    // ...<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // add the sample to the media<span></span></pre></td></tr><tr><td scope="row"><pre>    err = AddSpriteSampleToMedia (newMedia, sample,<span></span></pre></td></tr><tr><td scope="row"><pre>        kSpriteMediaFrameDuration, false);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<a name="//apple_ref/doc/uid/TP40000939-CH207-19281" title="Creating an Effect Description"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCECGJE" title="Creating an Effect Description"></a><h2>Creating an Effect Description</h2>
<p>An effect description tells QuickTime which effect to execute
and contains the parameters that control how the effect behaves
at runtime. You create an effect description by creating an atom
container, inserting a QT atom that specifies the effect, and inserting
a set of QT atoms that set its parameters. </p>
<p>There are support functions you can call to assist you in
this process. <code><a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_825"></a>QTCreateStandardParameterDialog</code> returns
a complete effect description that you can use, including user-selected
settings; you only need to add <code>kEffectSourceName</code> atoms
to the description for effects that require sources. At a lower
level, <code>QTGetEffectsList</code> returns
a list of the available effects and <code>ImageCodecGetParameterList</code> will
return a description of the parameters for an effect, including
the default value for each parameter in the form of a QT atom that
can be inserted directly into an effect description. </p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-17082" title="Structure of an Effect Description"></a><h3>Structure
of an Effect Description</h3>
<p>An <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_826"></a>effect
description is the sole media sample for an effect track. An effect
description is implemented as a <code>QTAtomContainer</code> structure,
the general QuickTime structure for holding a set of QuickTime atoms.
All effect descriptions must contain the set of required atoms, which
specify attributes such as which effect component to use. In addition,
effect descriptions can contain a variable number of parameter atoms,
which hold the values of the parameters for the effect.</p>
<p>Each atom contains either data or a set of child atoms. If
a parameter atom contains data, the data is the value of the parameter,
and this value remains constant while the effect executes. If a
parameter atom contains a set of child atoms, they typically contain
a tween entry so the value of the parameter will be interpolated
for the duration of the effect.</p>
<p>You assemble an effect description by adding the appropriate
set of atoms to a <code>QTAtomContainer</code> structure. </p>
<p>You can find out what the appropriate atoms are by making
an <code>ImageCodecGetParameterList</code> call
to the effect component. This fills an atom container with a set
of parameter description atoms. These atoms contain descriptions
of the effect parameters, such as each parameter’s atom type,
data range, default value, and so on. The default value in each
description atom is itself a <code>QTAtom</code> that
can be inserted directly into your effect description.</p>
<p>You can modify the data in the parameter atoms directly, or
let the user set them by calling <code>QTCreateStandardParameterDialog</code>,
which returns a complete effect description (you need to add <code>kEffectSourceName</code> atoms
for effects that require sources).</p>
<p>You then add the effect description to the media of the effect
track. </p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-17088" title="Required Atoms of an Effects Description"></a><h3>Required
Atoms of an Effects Description</h3>
<p>There are several required atoms that an effect description
must contain. The first is the <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_827"></a><code>kParameterWhatName</code> atom.
The <code>kParameterWhatName</code> atom
contains the name of the effect. This specifies which of the available
effects to use.</p>
<p>The code snippet shown in <span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-24403">Listing 5-10</a></span> adds a <code>kParameterWhatName</code> atom
to the atom container <code>effectDescription</code>.
The constant <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_828"></a><code>kCrossFadeTransitionType</code> contains
the name of the cross-fade effect. </p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-24403" title="Listing 5-10Adding a kParameterWhatName atom to the atom container effectDescription "></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCEEJJG" title="Listing 5-10Adding a kParameterWhatName atom to the atom container effectDescription "></a><p class="codesample"><strong>Listing 5-10&nbsp;&nbsp;</strong>Adding a <code>kParameterWhatName</code> atom
to the atom container <code>effectDescription</code> </p>
<div class="codesample"><table><tr><td scope="row"><pre>effectCode = kCrossFadeTransitionType;<span></span></pre></td></tr><tr><td scope="row"><pre>QTInsertChild(effectDescription, kParentAtomIsContainer,<span></span></pre></td></tr><tr><td scope="row"><pre>                kParameterWhatName, kParameterWhatID, 0,<span></span></pre></td></tr><tr><td scope="row"><pre>                sizeof(effectCode), &amp;effectCode, nil);<span></span></pre></td></tr></table></div>
<p>In addition to the <code>kParameterWhatName</code> atom,
the effect description for an effect that uses sources must contain
one or more <code>kEffectSourceName</code> atoms.
Each of these atoms contains the name of one of the effect’s sources.
An input map is used to map these names to the actual tracks of
the movie that are the sources. <span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-17100">“Creating an Input Map”</a></span> describes
how to create the input map. </p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-17094" title="Parameter Atoms of an Effects Description"></a><h3>Parameter
Atoms of an Effects Description</h3>
<p>In addition to the required atoms, the effects description
contains a variable number of parameter atoms. The number and types
of parameter atoms vary from effect to effect. For example, the
cross fade effect has only one parameter, while the general convolution
filter effect has nine. Some effects have no parameters at all,
and do not require any parameter atoms. </p>
<p>You can obtain the list of parameter atoms for a given effect
by calling the effect component using <code>ImageCodecGetParameterList</code>.
The parameter description atoms it returns include default settings
for each parameter in the form of parameter atoms that you can insert
into your effect description.</p>
<p>The <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_829"></a><code>QTInsertChild</code> function
is used to add these parameters to the effect description, as seen
in the code example in <span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-24403">Listing 5-10</a></span>.</p>
<p>Consider, for instance, the push effect. Its effect description
contains a <code>kParameterWhatName</code> atom,
two <code>kEffectSourceName</code> atoms,
and two parameter atoms, one of which is a tween.</p>
<p>The <code>kParameterWhatName</code> atom
specifies that this is a <code>'push'</code> effect.</p>
<p>The two <code>kEffectSourceName</code> atoms
specify the two sources that this effect will use, in this case <code>'srcA'</code> and <code>'srcB'</code>.
The names correspond to entries in the effect track’s input map.</p>
<p>The <code>'pcnt'</code> parameter
atom defines which frames of the effect are shown. This parameter contains
a tween entry, so that the value of this parameter is interpolated
as the effect runs . The interpolation of the <code>'pcnt'</code> parameter
causes consecutive frames of the effect to be rendered, creating
the push effect.</p>
<p>The <code>'from'</code> parameter
determines the direction of the push. This parameter is set from
an enumeration list, with 2 being defined as the bottom of the screen.</p>
<p>In this example, the source <code>'srcB'</code> will
push in from the bottom, covering the source <code>'srcA'</code>. </p>
<p>The<code> 'pcnt'</code> parameter
is normally tweened from 0 to 100, so that the effect renders completely,
from 0 to 100 percent. In this example, the<code> 'pcnt'</code> parameter
is tweened from 25 to 75, so the effect will start 25% of the way
through (with <code>'srcB'</code> already
partly on screen) and finish 75% of the way through (with part of <code>'srcA'</code> still
visible).</p>
<p><span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-19223">Figure 5-5</a></span> shows the set of atoms that must be added to the
entry description. </p>
<br/><div><a name="//apple_ref/doc/uid/TP40000939-CH207-19223" title="Figure 5-5An example effect description for the Push effect"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCJAAFD" title="Figure 5-5An example effect description for the Push effect"></a><p><strong>Figure 5-5&nbsp;&nbsp;</strong>An example effect description for
the Push effect</p><img src = "../art/qt_l_219.jpg" alt = "An example effect description for the Push effect" ></div><br/>
<p>An important property of effect parameters is that most can
be tweened (and some must be tweened). Tweening is QuickTime’s
general purpose interpolation mechanism (see <span class="content_text"><a href="../QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-69855">“Tween Media”</a></span> for more information).
For many parameters, it is desirable to allow the value of the parameter
to change as the effect executes. In the example shown in <span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-19223">Figure 5-5</a></span>, the<code> <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_830"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_831"></a>'pcnt'</code> parameter
must be a tween. This parameter controls which frame of the effect is
rendered at any given time, so it must change for the effect to
progress. The <code><a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_832"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_833"></a>'from'</code> parameter
is not a tween in the example above, but it could be if we wanted
the direction of the push to change during the course of the effect.</p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-17100" title="Creating an Input Map"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCBDGBI" title="Creating an Input Map"></a><h3>Creating an Input Map</h3>
<p>The <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_834"></a>input
map is another QT atom container that
you attach to the effects track. It describes the sources used in
the effect and gives a name to each source. This name is used to
refer to the source in the effects description.</p>
<p>An input map works in concert with track reference atoms in
the source tracks. A <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_835"></a>track reference atom of type <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_836"></a><code>kTrackModifierReference</code> is
added to each source track, which causes that source track’s output
to be redirected to the effects track. An input map is added to
the effects track to identify the source tracks and give a name
to each source, such as <code>'srcA'</code> and <code>'srcB'</code>.
The effect can then refer to the sources by name, specifying that <code>'srcB'</code> should
slide in over <code>'srcA'</code>,
for example.</p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-17106" title="Structure of an Input Map"></a><h4>Structure
of an Input Map</h4>
<p>The input map contains a set of atoms that refer to the tracks
used as sources for the effect. Each source track is represented
by one track reference atom of type <code><a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_837"></a>kTrackModifierInput</code>.</p>
<p>Each modifier input atom contains two children, one of type <code><a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_838"></a>kEffectDataSourceType</code>,
and one of type <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_839"></a><code>kTrackModifierType</code>,
which hold the name and type of the source. </p>
<p>The name of the source is a unique identifier that you create,
which is used in the effect description to reference the track.
Any four-character name is valid, as long as it is unique in the
set of source names. </p>
<div class="importantbox"><a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_99" title="Important:"></a><p><strong>Important:</strong>&nbsp;

Apple recommends you adopt the standard naming convention <code>'srcX'</code>,
where X is a letter of the alphabet. Thus, your first source would
be named <code>'srcA'</code>, the
second <code>'srcB',</code> and so
forth. This convention is used here in this chapter.</p><p></p></div>
<p>The child atom of type <code>kTrackModifierType</code> indicates
the type of the track being referenced. For a video track the type
is <code>VideoMediaType</code>, for
a sprite track it is <code>SpriteMediaType</code>,
and so forth. Video tracks are the most common track type used as
sources for effects. Only tracks that have a visible output, such
as video and sprite tracks, can be used as sources for an effect.
This means, for example, that sound tracks cannot be sources for
an effect.</p>
<p><span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-19227">Figure 5-6</a></span> shows a completed input map that references two sources.
The first source is a video track and is called <code>'srcA'</code>.
The second source, also a video track, is called <code>'srcB'</code>. </p>
<p>You refer to a <code>kTrackModifierInput</code> atom
by its index number, which is returned by the <code>AddTrackReference</code> function
when you create the atom.</p>
<br/><div><a name="//apple_ref/doc/uid/TP40000939-CH207-19227" title="Figure 5-6An example of an input map referencing two sources"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCDGJAE" title="Figure 5-6An example of an input map referencing two sources"></a><p><strong>Figure 5-6&nbsp;&nbsp;</strong>An example of an input map referencing two
sources</p><img src = "../art/qt_l_220.gif" alt = "An example of an input map referencing two sources" width="378" height="290"></div><br/>
<a name="//apple_ref/doc/uid/TP40000939-CH207-17122" title="Building Input Maps"></a><h4>Building
Input Maps</h4>
<p>The first step in creating an input map is to create a new <code>QTAtomContainer</code> to
hold the map. You use the standard QuickTime container creation
function.</p>
<div class="codesample"><table><tr><td scope="row"><pre>QTNewAtomContainer(&amp;inputMap);<span></span></pre></td></tr></table></div>
<p>For each source you are creating, you need to call the <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_840"></a><code>AddTrackReference</code> function.
The track IDs of the effects track and the source track are passed
as parameters to <code>AddTrackReference</code>,
which creates an atom of type <code><a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_841"></a>kTrackModifierReference</code> and
returns an index number. You use this index as the ID of the atom
when you need to refer to it. You then insert the reference into
the input map as an atom of type <code>kTrackModifierInput</code>.</p>
<p>The code in <span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-24425">Listing 5-11</a></span> creates a reference to the track <code>firstSourceTrack</code>,
and adds it to the input map. </p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-24425" title="Listing 5-11Adding an input reference atom to an input map"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCFIEFH" title="Listing 5-11Adding an input reference atom to an input map"></a><p class="codesample"><strong>Listing 5-11&nbsp;&nbsp;</strong>Adding an input reference atom to an
input map</p>
<div class="codesample"><table><tr><td scope="row"><pre>AddTrackReference(theEffectsTrack, firstSourceTrack,<span></span></pre></td></tr><tr><td scope="row"><pre>                 kTrackModifierReference, &amp;referenceIndex);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>QTInsertChild(inputMap, kParentAtomIsContainer,<span></span></pre></td></tr><tr><td scope="row"><pre>            kTrackModifierInput, referenceIndex, 0, 0, nil, &amp;inputAtom);<span></span></pre></td></tr></table></div>
<p>The <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_842"></a><code>QTInsertChild</code> function
returns the offset of the new modifier input atom in the <code>inputAtom</code> parameter. </p>
<p>You now need to add the name and type of the source track
to the modifier input atom. Again, calling the <code>QTInsertChild</code> function
does this, as shown in the following code snippet:</p>
<div class="codesample"><table><tr><td scope="row"><pre>inputType = VideoMediaType;<span></span></pre></td></tr><tr><td scope="row"><pre>QTInsertChild(inputMap, inputAtom,<span></span></pre></td></tr><tr><td scope="row"><pre>                kTrackModifierType, 1, 0, sizeof(inputType), &amp;inputType,<span></span></pre></td></tr><tr><td scope="row"><pre>                nil);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>aType = 'srcA';<span></span></pre></td></tr><tr><td scope="row"><pre>QTInsertChild(inputMap, inputAtom, kEffectDataSourceType, 1, 0,<span></span></pre></td></tr><tr><td scope="row"><pre>            sizeof(aType), &amp;aType, nil);<span></span></pre></td></tr></table></div>
<p>This process is repeated for each source for the effect.</p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-19285" title="Creating Movies with Modifier Tracks"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCCEDJB" title="Creating Movies with Modifier Tracks"></a><h2>Creating Movies with Modifier Tracks</h2>
<p>QuickTime 2.1 added additional functionality for media handlers.
By way of modifier tracks, a media handler can send its data to
another media handler rather than presenting its media directly.
See <span class="content_text"><a href="../QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-69859">“Modifier Tracks”</a></span> for a complete
discussion of this feature.</p>
<p>To create a movie with <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_843"></a>modifier tracks,
first you create a movie with all the desired tracks, then you create
the modifier track. To link the modifier track to the track that
it modifies, you use the <code>AddTrackReference</code> function
as shown in <span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-24436">Listing 5-12</a></span>.</p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-24436" title="Listing 5-12Linking a modifier track to the track it modifies"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCFCBGD" title="Listing 5-12Linking a modifier track to the track it modifies"></a><p class="codesample"><strong>Listing 5-12&nbsp;&nbsp;</strong>Linking a modifier track to the track
it modifies</p>
<div class="codesample"><table><tr><td scope="row"><pre>long addedIndex;<span></span></pre></td></tr><tr><td scope="row"><pre>AddTrackReference(aVideoTrack, aModifierTrack,<span></span></pre></td></tr><tr><td scope="row"><pre>                    kTrackModifierReference, &amp;addedIndex);<span></span></pre></td></tr></table></div>
<p>The reference doesn’t completely describe the modifier track’s
relationship to the track it modifies. Instead, the reference simply
tells the modifier track to send its data to the specified track.
The receiving track doesn’t “know” what it should do with
that data. A single track may also be receiving data from more than
one modifier track. </p>
<p>To describe how each modifier input should be used, each track’s
media also has an input map. The media’s input map describes how
the data being sent to each input of a track should be interpreted
by the receiving track. After creating the reference, it is necessary
to update the receiving track’s media input map. When <code>AddTrackReference</code> is
called, it returns the index of the reference added. That index
is the index of the input that needs to be described in the media
input map. If the modifier track created above contains regions
to change the shape of the video track, the code shown in <span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-24477">Listing 5-13</a></span> updates
the input map appropriately.</p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-24477" title="Listing 5-13Updating the input map "></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCIHIGD" title="Listing 5-13Updating the input map "></a><p class="codesample"><strong>Listing 5-13&nbsp;&nbsp;</strong>Updating the input map </p><a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_844"></a>
<div class="codesample"><table><tr><td scope="row"><pre>QTAtomContainer inputMap;<span></span></pre></td></tr><tr><td scope="row"><pre>QTAtom inputAtom;<span></span></pre></td></tr><tr><td scope="row"><pre>OSType inputType;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>Media aVideoMedia = GetTrackMedia(aVideoTrack);<span></span></pre></td></tr><tr><td scope="row"><pre>GetMediaInputMap (aVideoMedia, &amp;inputMap);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>QTInsertChild(inputMap, kParentAtomIsContainer, kTrackModifierInput,<span></span></pre></td></tr><tr><td scope="row"><pre>        addedIndex, 0,0, nil, &amp;inputAtom);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>inputType = kTrackModifierTypeClip;<span></span></pre></td></tr><tr><td scope="row"><pre>QTInsertChild (inputMap, inputAtom, kTrackModifierType, 1, 0,<span></span></pre></td></tr><tr><td scope="row"><pre>        sizeof(inputType), &amp;inputType, nil);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>SetMediaInputMap(aVideoMedia, inputMap);<span></span></pre></td></tr><tr><td scope="row"><pre>QTDisposeAtomContainer(inputMap);<span></span></pre></td></tr></table></div>
<p>The media input map allows you to store additional information
for each input. In the preceding example, only the type of the input
is specified. In other types of references, you may need to specify
additional data. </p>
<p>When a modifier track is playing an empty track edit, or is
disabled or deleted, all receiving tracks are notified that the
track input is inactive. When an input becomes inactive, it is reset
to its default value. For example, if a track is receiving data
from a clip modifier track and that input becomes inactive, the
shape of the track reverts to the shape it would have if there were
no clip modifier track.</p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-19289" title="Authoring Movies with External Movie Targets"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCCFHAH" title="Authoring Movies with External Movie Targets"></a><h2>Authoring Movies with External Movie Targets</h2>
<p>QuickTime 4 enables you to author movies with external <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_845"></a>movie targets.
To specify an action that targets an element of an external movie,
you must identify the external movie by either its name or its ID.
Two new target atom types have been introduced for this purpose;
these atoms are used in addition to the existing target atoms, which
you may use to specify that the element is a particular track or
object within a track, such as a sprite.</p>
<div class="notebox"><a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_100" title="Note"></a><p><strong>Note:</strong>&nbsp;A movie ID may
be specified by an expression.</p></div>
<p>These additional target atoms provided in QuickTime 4:</p>
<div class="codesample"><table><tr><td scope="row"><pre>[(ActionTargetAtoms)] =<span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;kActionTarget><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;kTargetMovieName><span></span></pre></td></tr><tr><td scope="row"><pre>            [Pstring MovieName]<span></span></pre></td></tr><tr><td scope="row"><pre>        OR<span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;kTargetMovieID><span></span></pre></td></tr><tr><td scope="row"><pre>            [long MovieID]<span></span></pre></td></tr><tr><td scope="row"><pre>            OR<span></span></pre></td></tr><tr><td scope="row"><pre>            [(kExpressionAtoms)]<span></span></pre></td></tr></table></div>
<p>To tag a movie with a name or ID, you add a user data item
of type '<code>plug</code>' to the
movie’s user data. The index of the user data does not matter.
The data specifies the name or ID. </p>
<p>You add a user data item of type '<code>plug</code>'
to the movie’s user data with its data set to </p>
<div class="codesample"><table><tr><td scope="row"><pre>"Movieid=MovieName"<span></span></pre></td></tr></table></div>
<p>where <code>MovieName</code> is
the name of the movie. </p>
<p>You add a user data item of type<code> </code><a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_846"></a>'<code>plug</code>'
to the movie’s user data with its data set to </p>
<div class="codesample"><table><tr><td scope="row"><pre>"Movieid=MovieID"<span></span></pre></td></tr></table></div>
<p>where the ID is a signed long integer.</p>
<p>The QuickTime plug-in additionally supports <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_847"></a><code>EMBED</code> tag parameters, which allow
you to override a movie’s name or ID within an HTML page. </p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-17133" title="Target Atoms for Embedded Movies"></a><h3>Target
Atoms for Embedded Movies</h3>
<p>QuickTime 4.1 introduced <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_848"></a>target atoms to accommodate the addition
of <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_849"></a>embedded movies.
These target atoms allow for paths to be specified in a hierarchical
movie tree.</p>
<p>Target movies may be an external movie, the default movie,
or any movie embedded within another movie. Targets are specified
by using a movie path that may include parent and child movie relationships,
and may additionally include track and track object target atoms
as needed.</p>
<p>By using embedded <code><a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_850"></a>kActionTarget</code> atoms
along with parent and child movie target atoms, you can build up
paths for movie targets. Note that QuickTime looks for these embedded <code>kActionTarget </code>atoms
only when evaluating a movie target, and any movie target type may contain
a sibling <code>kActionTarget </code>atom.</p>
<p>Paths begin from the current movie, which is the movie containing
the object that is handling an event. You may go up the tree using
a <code><a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_851"></a>kTargetParentMovie</code> atom,
or down the tree using one of five new child movie atoms. You may
use a <code><a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_852"></a>kTargetRootMovie</code> atom
as a shortcut to get to the top of the tree containing an embedded
movie and may use the <code>movieByName</code> and <code>movieByID</code> atoms
to specify a root external movie.</p>
<p>The target atoms are: </p>
<ul class="spaceabove"><li class="li"><p><code><a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_853"></a>kTargetRootMovie</code> (leaf
atom, no data). This is the root movie containing the action handler.</p></li>
<li class="li"><p><code><a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_854"></a>kTargetParentMovie</code> 
(leaf atom, no data). This is the parent movie.</p></li></ul>
<p>Note that there are five ways to specify an embedded child
movie. Three of them specify movie track properties. Two specify
properties of the currently loaded movie in a movie track.</p>
<ul class="spaceabove"><li class="li"><p><code>kTargetChildMovieTrackName.</code> A
child movie track specified by track name. </p></li>
<li class="li"><p><code>kTargetChildMovieTrackID</code>.
A child movie track specified by track ID.</p></li>
<li class="li"><p><code>kTargetChildMovieTrackIndex</code>.
A child movie track specified by track index.</p></li>
<li class="li"><p><code>kTargetChildMovieMovieName</code>.
A child movie specified by the currently loaded movie’s movie
name. The child movie must contain <code>movieName</code> user
data with the specified name.</p></li>
<li class="li"><p><code>kTargetChildMovieMovieID</code>.
A child movie specified by the currently loaded movie’s movie
ID. The child movie must contain <code>movieID</code> user
data with the specified ID.</p></li></ul>
<a name="//apple_ref/doc/uid/TP40000939-CH207-19293" title="Adding Wired Actions To a Flash Track"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCGEJGG" title="Adding Wired Actions To a Flash Track"></a><h2>Adding Wired Actions To a Flash Track</h2>
<p>This section explains the steps you need to follow in order
to add wired actions to a Macromedia Flash track. The <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_855"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_856"></a>Flash
media handler was introduced in QuickTime 4 to enable a SWF 3.0
file to be treated as a track within a QuickTime movie. See <span class="content_text"><a href="../QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-69851">“Flash Media”</a></span> for more information
about the Flash media handler. </p>
<p>Sample code (<code>AddFlashActions</code>)
is provided on the <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_857"></a>QuickTime
SDK, as well as on the QuickTime developer website, that lets you
add wired actions to a Flash track. </p>
<div class="notebox"><a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_101" title="Note"></a><p><strong>Note:</strong>&nbsp;For more detailed
information about working with Flash, you can download the <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_858"></a>Macromedia
SWF File Format Specification at <code>http://www.macromedia.com/software/flash/open/spec/</code>,
along with the SWF File Parser code also at the Macromedia website.</p></div>
<a name="//apple_ref/doc/uid/TP40000939-CH207-17148" title="Extending the SWF Format"></a><h3>Extending
the SWF Format</h3>
<p>QuickTime 4 extends the <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_859"></a>SWF file format to allow the execution
of any of its wired actions, in addition to the much smaller set
of Flash actions. For example, you may use a SWF file as a user
interface element in a QuickTime movie, controlling properties of
the movie and other tracks. QuickTime also allows SWF files to be
compressed using the zlib data compressor. This can significantly
lower the bandwidth required when downloading a SWF file when it
is in a QuickTime movie.</p>
<p>By using wired actions within a Flash track, compressing your
Flash tracks, and combining Flash tracks with other types of QuickTime
media, you can create compact and sophisticated multimedia content.</p>
<p>The SWF File Format Specification consists of a header followed
by a series of tagged data blocks. The types of tagged data blocks
you need to use are the <code>DefineButton2</code> and <code>DoAction</code>.
The <code>DefineButton2</code> block
allows Flash actions to be associated with a mouse state transition. <code>DoAction</code> allows
actions to be executed when the tag is encountered. These are analogous
to mouse-related QT event handlers and the frame loaded event in
wired movies.</p>
<p>Flash actions are stored in an action record. Each Flash action
has its own tag, such as <code>ActionPlay</code> and <code>ActionNextFrame</code>.
QuickTime defines one new tag: <code>QuickTimeActions</code>, which
is 0xAA. The data for
the QuickTime actions tag is simply a QT atom container with the
QuickTime wired actions to execute in it.</p>
<p>There are also fields you need to change in order to add wired
actions to a SWF file. Additionally, there is one tag missing from
the SWF file format that is described below.</p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-17153" title="What You Need to Modify"></a><h4>What
You Need to Modify</h4>
<p>For <code>defineButton2</code>,
you need to modify or add the following fields: file length, action records
offset, the action offset, the condition, the record header size
portion, and add action record. </p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-17159" title="File Length"></a><h5>File
Length</h5>
<p>A 32-bit field in the SWF file header.</p>
<p><code>RecordHeader</code> for
the <code>defineButton2</code></p>
<p><code>RecordHeader</code> contains
the tag ID and length. You need to update the length. Note that
there are short and long formats for record headers, depending on
the size of the record. The tag ID for <code>defineButton2</code> is
34. </p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-17165" title="ActionRecordsOffset"></a><h5>ActionRecordsOffset</h5>
<p>The action records offset, a 16-bit field, is missing from
the SWF File Format Specification. It occurs between the flags and
buttons fields. It is initially set to 0 if there are no actions for
the button. If there are actions for the button, then it must contain
the offset from the point in the SWF file following this 16-bit
value to the beginning of the action offset field.</p>
<div class="codesample"><table><tr><td scope="row"><pre>    DefineButton2 =<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        Header<span></span></pre></td></tr><tr><td scope="row"><pre>        ButtonID<span></span></pre></td></tr><tr><td scope="row"><pre>        Flags<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        ActionRecordsOffset     (this is missing from the spec)<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        Buttons<span></span></pre></td></tr><tr><td scope="row"><pre>        ButtonEndFlag<span></span></pre></td></tr><tr><td scope="row"><pre>        Button2ActionCode<span></span></pre></td></tr><tr><td scope="row"><pre>        ActionOffset<span></span></pre></td></tr><tr><td scope="row"><pre>        Condition<span></span></pre></td></tr><tr><td scope="row"><pre>        Action          [ActionRecords]<span></span></pre></td></tr><tr><td scope="row"><pre>        ActionEndFlag<span></span></pre></td></tr></table></div>
<a name="//apple_ref/doc/uid/TP40000939-CH207-17171" title="ActionOffset"></a><h5>ActionOffset</h5>
<p>There is one action offset per condition (mouse <code>overDownToIdle</code>).
This is the offset used to skip over the condition and the following
actions (the <code>ActionRecord</code>)
for the condition. You need to update this value when adding actions.</p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-17177" title="Condition"></a><h5>Condition</h5>
<p>The condition field is roughly equivalent to a wired movie
event. The actions associated with button state transition condition
are triggered when the transition occurs. You need to add or edit
this field.</p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-17183" title="Actions"></a><h5>Actions</h5>
<p>Flash actions each have their own action tag code. QuickTime
actions use a single QuickTime actions  code: <code>'AA'</code>.
 You may add a list of actions to a single QuickTime actions tag.</p>
<p>The format of the QuickTime actions tag is as follows:</p>
<div class="codesample"><table><tr><td scope="row"><pre>    1 byte:     // Tag = 'AA'<span></span></pre></td></tr><tr><td scope="row"><pre>    2 bytes:    // data length (size of the QTAtomContainer)<span></span></pre></td></tr><tr><td scope="row"><pre>    n bytes     // the data which is the QTAtomContainer holding  the<span></span></pre></td></tr><tr><td scope="row"><pre>                // wired actions<span></span></pre></td></tr></table></div>
<a name="//apple_ref/doc/uid/TP40000939-CH207-17189" title="DoAction"></a><h5>DoAction</h5>
<p>For <code>DoAction</code>, you
need to modify a subset of the <code>defineButton2</code> fields
in the same manner as described above. These fields are file length,
the record header size portion, and the action record.</p>
<p>Note that you need to write the length fields in little-endian
format.</p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-19297" title="Creating Video Tracks at 30 Frames per Second"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCIBEEC" title="Creating Video Tracks at 30 Frames per Second"></a><h2>Creating Video Tracks at 30 Frames per Second</h2><a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_860"></a>
<p>The duration of a video frame is stored in the time-to-sample
atom contained within a sample table atom. This duration cannot
be interpreted without the media’s time scale, which defines the
units-per-second for the duration. In this example, each frame has
the same duration, so the time-to-sample atom has one entry, which
applies to all video frames in the media.</p>
<p>As long as the ratio between frame duration and media time
scale remains 1:30, any combination of values can be used for the
duration and time scale. The larger the time scale the shorter the
maximum duration. Since a movie defaults to a time scale of 600,
this is a good number to use. It is also the least common multiple
for 24, 25, and 30, making it handy for much of the math you are
likely to encounter when making a movie.</p>
<p>The movie time scale is independent of the media time scale.
Since you want to avoid movie edits that don’t land on frame boundaries,
it is a good idea to keep the movie time scale and the media time
scale the same, or the movie time scale should be an even multiple of
the media time scale. The movie time scale is stored in the movie
header atom. </p>
<p>With a time scale of 600 in the media header atom, the time-to-sample
atom would contain the following data values:</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">

<tr>
<td  scope="row"><p>Atom size</p></td>
<td ><p>24</p></td>
</tr>
<tr>
<td  scope="row"><p>Atom type</p></td>
<td ><p><code>'stts'</code></p></td>
</tr>
<tr>
<td  scope="row"><p>Version/Flags</p></td>
<td ><p>0</p></td>
</tr>
<tr>
<td  scope="row"><p>Number of entries</p></td>
<td ><p>1</p></td>
</tr>
<tr>
<td  scope="row"><p>Sample count</p></td>
<td ><p>n</p></td>
</tr>
<tr>
<td  scope="row"><p>Sample duration</p></td>
<td ><p>20</p></td>
</tr>

</table></div>
<a name="//apple_ref/doc/uid/TP40000939-CH207-19303" title="Creating Video Tracks at 29.97 Frames per Second"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCHHHJF" title="Creating Video Tracks at 29.97 Frames per Second"></a><h2>Creating Video Tracks at 29.97 Frames per Second</h2>
<p>NTSC color video is not 30 frames per second (fps), but actually
29.97 fps. The previous example showed how the media time scale
and the duration of the frames specify the video’s frame rate.
By setting the media’s time scale to 2997 units per second and
setting the frame durations to 100 units each, the effective rate
is 29.97 fps exactly.</p>
<p>In this situation, it is also a good idea to set the movie
time scale to 2997 in order to avoid movie edits that don’t land
on frame boundaries. The movie’s time scale is stored in the movie
header atom. </p>
<p>With a time scale of 2997 in the media header atom, the time-to-sample
atom would contain the following data values:</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">

<tr>
<td  scope="row"><p>Atom size</p></td>
<td ><p>24</p></td>
</tr>
<tr>
<td  scope="row"><p>Atom type</p></td>
<td ><p><code>'stts'</code></p></td>
</tr>
<tr>
<td  scope="row"><p>Version/Flags</p></td>
<td ><p>0</p></td>
</tr>
<tr>
<td  scope="row"><p>Number of entries</p></td>
<td ><p>1</p></td>
</tr>
<tr>
<td  scope="row"><p>Sample count</p></td>
<td ><p>n</p></td>
</tr>
<tr>
<td  scope="row"><p>Sample duration</p></td>
<td ><p>100</p></td>
</tr>

</table></div>
<a name="//apple_ref/doc/uid/TP40000939-CH207-19307" title="Creating Audio Tracks at 44.1 kHz"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCJDDEC" title="Creating Audio Tracks at 44.1 kHz"></a><h2>Creating Audio Tracks at 44.1 kHz</h2>
<p>The duration of an <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_861"></a>audio sample is stored in the
time-to-sample atom contained in a sample table atom. This duration
cannot be interpreted without the media’s time scale, which defines
the units per second for the duration. With audio, the duration
of each audio sample is typically 1, so the time-to-sample atom
has one entry, which applies to all audio samples.</p>
<p>With a time scale of 44100 in the media header atom, the time-to-sample
atom would contain the following data values:</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">

<tr>
<td  scope="row"><p>Atom size</p></td>
<td ><p>24</p></td>
</tr>
<tr>
<td  scope="row"><p>Atom type</p></td>
<td ><p><code>'stts'</code></p></td>
</tr>
<tr>
<td  scope="row"><p>Version/Flags</p></td>
<td ><p>0</p></td>
</tr>
<tr>
<td  scope="row"><p>Number of entries</p></td>
<td ><p>1</p></td>
</tr>
<tr>
<td  scope="row"><p>Sample count</p></td>
<td ><p>n</p></td>
</tr>
<tr>
<td  scope="row"><p>Sample duration</p></td>
<td ><p>1</p></td>
</tr>

</table></div>
<p>This atom does not indicate whether the audio is stereo or
mono or whether it contains 8-bit or 16-bit samples. That information
is stored in the sound sample description atom, which is contained
in the sample table atom.</p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-19311" title="Creating a Timecode Track for 29.97 FPS Video"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCHIFID" title="Creating a Timecode Track for 29.97 FPS Video"></a><h2>Creating a Timecode Track for 29.97 FPS
Video</h2>
<p>A <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_862"></a>timecode
track specifies timecode information for other tracks. The timecode
keeps track of the timecodes of the original source of the video
and audio.  After a movie has been edited, the timecode can be extracted
to determine the source tape and the timecodes of the frames.</p>
<p>It is important that the timecode track have the same time
scale as the video track. Otherwise, the timecode will not tick
at the exact same time as the video track.</p>
<p>For each contiguous source tape segment, there is a single
timecode sample that specifies the timecode value corresponding
to the start of the segment.  From this sample, the timecode value
can be determined for any point in the segment.</p>
<p>The sample description for a timecode track specifies the
timecode system being used (for example, a 30-fps drop frame) and
the source information. Each sample is a timecode value.</p>
<p>Since the timecode media handler is a derived from the base
media handler, the media information atom starts with a generic
media header atom. The timecode atoms would contain the following
data values:</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">

<tr>
<td  scope="row"><p>Atom size</p></td>
<td ><p>77</p></td>
<td ><p></p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p>Atom type</p></td>
<td ><p><code>'gmhd'</code></p></td>
<td ><p></p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Atom size</p></td>
<td ><p>69</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Atom type</p></td>
<td ><p><code>'gmin'</code></p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Version/Flags</p></td>
<td ><p>0</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Graphics mode</p></td>
<td ><p>0x0040</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Opcolor (red)</p></td>
<td ><p>0x8000</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Opcolor (green)</p></td>
<td ><p>0x8000</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Opcolor (blue)</p></td>
<td ><p>0x8000</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Balance</p></td>
<td ><p>0</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Reserved</p></td>
<td ><p>0</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Atom size</p></td>
<td ><p>45</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Atom type</p></td>
<td ><p><code>'tmcd'</code></p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p></p></td>
<td ><p>Atom size</p></td>
<td ><p>37</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p></p></td>
<td ><p>Atom type</p></td>
<td ><p><code>'tcmi'</code></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p></p></td>
<td ><p>Version/Flags</p></td>
<td ><p>0</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p></p></td>
<td ><p>Text font</p></td>
<td ><p>0 (system font)</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p></p></td>
<td ><p>Text face</p></td>
<td ><p>0 (plain)</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p></p></td>
<td ><p>Text size</p></td>
<td ><p>12</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p></p></td>
<td ><p>Text color (red)</p></td>
<td ><p>0</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p></p></td>
<td ><p>Text color (green)</p></td>
<td ><p>0</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p></p></td>
<td ><p>Text color (blue)</p></td>
<td ><p>0</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p></p></td>
<td ><p>Background color (red)</p></td>
<td ><p>0</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p></p></td>
<td ><p>Background color (green)</p></td>
<td ><p>0</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p></p></td>
<td ><p>Background color (blue)</p></td>
<td ><p>0</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p></p></td>
<td ><p>Font name</p></td>
<td ><p><code>'\pChicago'</code> 
(Pascal string)</p></td>
</tr>

</table></div>
<p>The sample table atom contains all the standard sample atoms
and has the following data values:</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">

<tr>
<td  scope="row"><p>Atom size</p></td>
<td ><p>174</p></td>
<td ><p></p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p>Atom type</p></td>
<td ><p><code>'stbl'</code> (sample
table)</p></td>
<td ><p></p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Atom size</p></td>
<td ><p>74</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Atom type</p></td>
<td ><p><code>'stsd'</code> (sample description)</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Version/Flags</p></td>
<td ><p>0</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Number of entries</p></td>
<td ><p>1</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Sample description size [1]</p></td>
<td ><p>58</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Data format [1]</p></td>
<td ><p><code>'tmcd'</code></p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Reserved [1]</p></td>
<td ><p>0</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Data reference index [1]</p></td>
<td ><p>1</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Flags[1]</p></td>
<td ><p>0</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Flags (timecode) [1]</p></td>
<td ><p>7 (drop frame + 24 hour + negative times OK)</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Time scale[1]</p></td>
<td ><p>2997</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Frame duration[1]</p></td>
<td ><p>100</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Number of frames [1]</p></td>
<td ><p>20</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p></p></td>
<td ><p>Atom size</p></td>
<td ><p>24</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p></p></td>
<td ><p>Atom type</p></td>
<td ><p><code>'name'</code></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p></p></td>
<td ><p>String length</p></td>
<td ><p>12</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p></p></td>
<td ><p>Language code</p></td>
<td ><p>0 (English)</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p></p></td>
<td ><p>Name</p></td>
<td ><p>“my tape name”</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Atom size</p></td>
<td ><p>24</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Atom type</p></td>
<td ><p><code>'stts'</code> (time
to sample)</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Version/Flags</p></td>
<td ><p>0</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Number of entries</p></td>
<td ><p>1</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Sample count[1]</p></td>
<td ><p>1</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Sample duration[1]</p></td>
<td ><p>1</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Atom size</p></td>
<td ><p>28</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Atom type</p></td>
<td ><p><code>'stsc'</code> (sample
to chunk)</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Version/Flags</p></td>
<td ><p>0</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Number of entries</p></td>
<td ><p>1</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>First chunk[1]</p></td>
<td ><p>1</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Samples per chunk[1]</p></td>
<td ><p>1</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Sample description ID[1]</p></td>
<td ><p>1</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Atom size</p></td>
<td ><p>20</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Atom type</p></td>
<td ><p><code>'stsz'</code> (sample
size)</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Version/Flags</p></td>
<td ><p>0</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Sample size</p></td>
<td ><p>4</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Number of entries</p></td>
<td ><p>1</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Atom size</p></td>
<td ><p>20</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Atom type</p></td>
<td ><p><code>'stco'</code> (chunk
offset)</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Version/Flags</p></td>
<td ><p>0</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Number of entries</p></td>
<td ><p>1</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Offset [1]</p></td>
<td ><p>(offset into file of chunk 1)</p></td>
<td ><p></p></td>
</tr>

</table></div>
<p>In the example, let’s assume that the segment’s beginning
timecode is 1:15:32.4 (1 hour, 15 minutes, 32 seconds, and 4 frames).
The time would be expressed in the data file as 0x010F2004 (0x01
= 1 hour; 0x0F = 15 minutes; 0x20 = 32 seconds; 0x04 = 4 frames).</p>
<p>The video and audio tracks must contain a <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_863"></a>track reference atom to indicate
that they reference this timecode track. The track reference is
the same for both and is contained in the track atom (at the same
level as the track header and media atoms).</p>
<p>This track reference would contain the following data values:</p>
<div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">

<tr>
<td  scope="row"><p>Atom size</p></td>
<td ><p>12</p></td>
</tr>
<tr>
<td  scope="row"><p>Atom type</p></td>
<td ><p><code>'tref'</code></p></td>
</tr>
<tr>
<td  scope="row"><p>Reference type</p></td>
<td ><p><code>'tmcd'</code></p></td>
</tr>
<tr>
<td  scope="row"><p>Track ID of referenced track (timecode track)</p></td>
<td ><p>3</p></td>
</tr>

</table></div>
<p>In this example, the video and sound tracks are tracks 1 and
2. The timecode track is track 3.</p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-19315" title="Playing with Edit Lists"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCBEFGE" title="Playing with Edit Lists"></a><h2>Playing with Edit Lists</h2>
<p>A segment of a movie can be repeated without duplicating media
data by using <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_864"></a>edit
lists. Suppose you have a single-track movie whose media time scale
is 100 and track duration is 1000 (10 seconds). For this example
the movie’s time scale is 600. If there are no edits in the movie,
the edit atom would contain the following data values:</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">

<tr>
<td  scope="row"><p>Atom size</p></td>
<td ><p>36</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p>Atom type</p></td>
<td ><p><code>'edts'</code></p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Atom size</p></td>
<td ><p>28</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Atom type</p></td>
<td ><p><code>'elst'</code></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Version/Flags</p></td>
<td ><p>0</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Number of entries</p></td>
<td ><p>2</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Track duration</p></td>
<td ><p>6000 (10 seconds)</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Media time</p></td>
<td ><p>0</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Media rate</p></td>
<td ><p>1.0</p></td>
</tr>

</table></div>
<p>Because this is a single-track move, the track’s duration
in the track header atom is 6000 and the movie’s duration in the
movie header atom is 6000.</p>
<p>If you change the track to play the media from time 0 to time
2 seconds, and then play the media from time 0 to time 10 seconds,
the edit atom would now contain these data values:</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">

<tr>
<td  scope="row"><p>Atom size</p></td>
<td ><p>48</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p>Atom type</p></td>
<td ><p><code>'edts'</code></p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Atom size</p></td>
<td ><p>40</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Atom type</p></td>
<td ><p><code>'elst'</code></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Version/Flags</p></td>
<td ><p>0</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Number of entries</p></td>
<td ><p>2</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Track duration[1]</p></td>
<td ><p>1200 (2 seconds)</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Media time[1]</p></td>
<td ><p>0</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Media rate[1]</p></td>
<td ><p>1.0</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Track duration[2]</p></td>
<td ><p>6000 (10 seconds)</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Media time[2]</p></td>
<td ><p>0</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Media rate[2]</p></td>
<td ><p>1.0</p></td>
</tr>

</table></div>
<p>Because the track is now 2 seconds longer, the track’s duration
in the track header atom must now be 7200, and the movie’s duration
in the movie header atom must also be 7200.</p>
<p>Currently, the media plays from time 0 to time 2, then plays
from time 0 to time 10. If you take that repeated segment at the
beginning (time 0 to time 2) and play it at double speed to maintain
the original duration, the edit atom would now contain the following
values:</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">

<tr>
<td  scope="row"><p>Atom size</p></td>
<td ><p>60</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p>Atom type</p></td>
<td ><p><code>'edts'</code></p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Atom size</p></td>
<td ><p>52</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Atom type</p></td>
<td ><p><code><a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_865"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_866"></a>'elst'</code></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Version/Flags</p></td>
<td ><p>0</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Number of entries</p></td>
<td ><p>3</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Track duration[1]</p></td>
<td ><p>600 (1 second)</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Media time[1]</p></td>
<td ><p>0</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Media rate[1]</p></td>
<td ><p>2.0</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Track duration[2]</p></td>
<td ><p>600 (1 second)</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Media time[2]</p></td>
<td ><p>0</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Media rate[2]</p></td>
<td ><p>2.0</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Track duration[3]</p></td>
<td ><p>4800 (8 seconds)</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Media time[3]</p></td>
<td ><p>200</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Media rate[3]</p></td>
<td ><p>1.0</p></td>
</tr>

</table></div>
<p>Because the track is now back to its original duration of
10 seconds, its duration in the track header atom is 6000, and the
movie’s duration in the movie header atom is 6000.</p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-19319" title="Interleaving Movie Data"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCEGHGI" title="Interleaving Movie Data"></a><h2>Interleaving Movie Data</h2>
<p>In order to get optimal movie playback, you must create the
movie with <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_867"></a>interleaved
data. Because the data for the movie is placed on disk in time order, the data for a particular time in the movie is close together in
the file. This means that you will have to intersperse the data from
different tracks. To illustrate this, consider a movie with a single
video and a single audio track.</p>
<p><span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-19231">Figure 5-7</a></span> shows how the movie data was collected, and how the
data would need to be played back for proper synchronization. In
this example, the video data is recorded at 10 frames per second
and the audio data is grouped into half-second chunks. </p>
<br/><div><a name="//apple_ref/doc/uid/TP40000939-CH207-19231" title="Figure 5-7Non-interleaved movie data"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCIICCG" title="Figure 5-7Non-interleaved movie data"></a><p><strong>Figure 5-7&nbsp;&nbsp;</strong>Non-interleaved movie data</p>
<img src = "../art/qt_l_211.gif" alt = "Non-interleaved movie data" width="441" height="206"></div><br/>
<p>After the data has been interleaved on the disk, the movie
data atom would contain movie data in the order shown in <span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-19235">Figure 5-8</a></span>.</p>
<br/><div><a name="//apple_ref/doc/uid/TP40000939-CH207-19235" title="Figure 5-8Interleaved movie data"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCEGHEA" title="Figure 5-8Interleaved movie data"></a><p><strong>Figure 5-8&nbsp;&nbsp;</strong>Interleaved movie data</p>
<img src = "../art/qt_l_212.gif" alt = "Interleaved movie data" width="487" height="120"></div><br/>
<p>In this example, the file begins with the movie atom (<code>'moov'</code>),
followed by the movie data atom (<code>'mdat'</code>).
In order to overcome any latencies in sound playback, at least one
second of sound data is placed at the beginning of the interleaved
data. This means that the sound and video data are offset from each
other in the file by one second.</p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-19323" title="Referencing Two Data Files With a Single Track"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCECFHE" title="Referencing Two Data Files With a Single Track"></a><h2>Referencing Two Data Files With a Single
Track</h2>
<p>The data reference index to be used for a given media sample
is stored within that sample’s sample description. Therefore,
a track must contain multiple sample descriptions in order for that
track to reference multiple data files. A different sample description
must be used whenever the data file changes or whenever the format
of the data changes. The sample-to-chunk atom determines which sample
description to use for a sample.</p>
<p>The <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_868"></a>sample description
atom would contain the following data values:</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">

<tr>
<td  scope="row"><p>Atom size</p></td>
<td ><p>…</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p>Atom type</p></td>
<td ><p><code>'stsd'</code></p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p>Version/Flags</p></td>
<td ><p>0</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p>Number of entries</p></td>
<td ><p>2</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Sample description size[1]</p></td>
<td ><p>…</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Data format</p></td>
<td ><p><code>'tmcd'</code></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Reserved</p></td>
<td ><p>0</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Data reference index</p></td>
<td ><p>1</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>(sample data)</p></td>
<td ><p>…</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Sample description size[1]</p></td>
<td ><p>…</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Data format</p></td>
<td ><p><code>'tmcd'</code></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Reserved</p></td>
<td ><p>0</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Data reference index</p></td>
<td ><p>2</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>(sample data)</p></td>
<td ><p>…</p></td>
</tr>

</table></div>
<p>If there is only 1 sample per chunk and the first 10 samples
are extracted from sample description 2 and the next 30 samples
are extracted from sample description 1, the <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_869"></a>sample-to-chunk
atom would contain the following data values:</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">

<tr>
<td  scope="row"><p>Atom size</p></td>
<td ><p>40</p></td>
</tr>
<tr>
<td  scope="row"><p>Atom type</p></td>
<td ><p><code>'stsc'</code></p></td>
</tr>
<tr>
<td  scope="row"><p>Version/Flags</p></td>
<td ><p>0</p></td>
</tr>
<tr>
<td  scope="row"><p>Number of entries</p></td>
<td ><p>2</p></td>
</tr>
<tr>
<td  scope="row"><p>First chunk[1]</p></td>
<td ><p>1</p></td>
</tr>
<tr>
<td  scope="row"><p>Samples per chunk[1]</p></td>
<td ><p>1</p></td>
</tr>
<tr>
<td  scope="row"><p>Sample description ID[1]</p></td>
<td ><p>2</p></td>
</tr>
<tr>
<td  scope="row"><p>First chunk[2]</p></td>
<td ><p>11</p></td>
</tr>
<tr>
<td  scope="row"><p>Samples per chunk[2]</p></td>
<td ><p>1</p></td>
</tr>
<tr>
<td  scope="row"><p>Sample description ID[2]</p></td>
<td ><p>1</p></td>
</tr>

</table></div>
<p>The <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_870"></a>data reference atom
would contain the following data values:</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">

<tr>
<td  scope="row"><p>Atom size</p></td>
<td ><p>…</p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p>Atom type</p></td>
<td ><p><code>'dinf'</code></p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Atom size</p></td>
<td ><p>…</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Atom type</p></td>
<td ><p><code>'dref'</code></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Version/Flags</p></td>
<td ><p>0</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Number of entries</p></td>
<td ><p>2</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Size[1]</p></td>
<td ><p>…</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Type[1]</p></td>
<td ><p><code>'alis'</code></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Version[1]</p></td>
<td ><p>0</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Flags[1]</p></td>
<td ><p>0 (not self referenced)</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Data reference[1]</p></td>
<td ><p>[alias pointing to file #1]</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Size[2]</p></td>
<td ><p>…</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Type[2]</p></td>
<td ><p><code>'rsrc'</code></p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Version[2]</p></td>
<td ><p>0</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Flags[2]</p></td>
<td ><p>0 (not self referenced)</p></td>
</tr>
<tr>
<td  scope="row"><p></p></td>
<td ><p>Data reference[2]</p></td>
<td ><p>[alias pointing to file #2]</p></td>
</tr>

</table></div>
<a name="//apple_ref/doc/uid/TP40000939-CH207-19327" title="Getting the Name of a QuickTime VR Node"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCDGAJD" title="Getting the Name of a QuickTime VR Node"></a><h2>Getting the Name of a QuickTime VR Node</h2>
<p>You can use standard QuickTime atom container functions to
retrieve the information in a QuickTime <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_871"></a>VR node header atom.
For example, the <code><a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_872"></a>MyGetNodeName</code> function
defined in <span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-26774">Listing 5-14</a></span> returns the name of a <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_873"></a>node, given its node ID.</p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-26774" title="Listing 5-14Getting a node&acirc;&#128;&#153;s name"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCJDGDE" title="Listing 5-14Getting a node&acirc;&#128;&#153;s name"></a><p class="codesample"><strong>Listing 5-14&nbsp;&nbsp;</strong>Getting a node’s name</p>
<div class="codesample"><table><tr><td scope="row"><pre>OSErr MyGetNodeName (QTVRInstance theInstance, UInt32 theNodeID,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                                 StringPtr  theStringPtr)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr                   theErr = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    QTAtomContainer         theNodeInfo;<span></span></pre></td></tr><tr><td scope="row"><pre>    QTVRNodeHeaderAtomPtr   theNodeHeader;<span></span></pre></td></tr><tr><td scope="row"><pre>    QTAtom                  theNodeHeaderAtom = 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    //Get the node information atom container.<span></span></pre></td></tr><tr><td scope="row"><pre>    theErr = QTVRGetNodeInfo(theInstance, theNodeID, &amp;theNodeInfo);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    //Get the node header atom.<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!theErr)<span></span></pre></td></tr><tr><td scope="row"><pre>        theNodeHeaderAtom = QTFindChildByID(theNodeInfo, kParentAtomIsContainer,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                    kQTVRNodeHeaderAtomType,  1,  nil);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (theNodeHeaderAtom != 0) {<span></span></pre></td></tr><tr><td scope="row"><pre>        QTLockContainer(theNodeInfo);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        //Get a pointer to the node header atom data.<span></span></pre></td></tr><tr><td scope="row"><pre>        theErr = QTGetAtomDataPtr(theNodeInfo, theNodeHeaderAtom,  nil,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                            (Ptr  *)&amp;theNodeHeader);<span></span></pre></td></tr><tr><td scope="row"><pre>        //See if there is a name atom.<span></span></pre></td></tr><tr><td scope="row"><pre>        if (!theErr &amp;&amp; theNodeHeader->nameAtomID != 0)  {<span></span></pre></td></tr><tr><td scope="row"><pre>            QTAtom theNameAtom;<span></span></pre></td></tr><tr><td scope="row"><pre>            theNameAtom = QTFindChildByID(theNodeInfo, kParentAtomIsContainer,<span></span></pre></td></tr><tr><td scope="row"><pre>                                kQTVRStringAtomType, theNodeHeader->nameAtomID,  nil);<span></span></pre></td></tr><tr><td scope="row"><pre>            if (theNameAtom != 0) {<span></span></pre></td></tr><tr><td scope="row"><pre>                VRStringAtomPtr theStringAtomPtr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                //Get a pointer to the name atom data; copy it into  the string.<span></span></pre></td></tr><tr><td scope="row"><pre>                theErr = QTGetAtomDataPtr(theNodeInfo, theNameAtom,  nil,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                            (Ptr  *)&amp;theStringAtomPtr);<span></span></pre></td></tr><tr><td scope="row"><pre>                if (!theErr) {<span></span></pre></td></tr><tr><td scope="row"><pre>                    short theLen = theStringAtomPtr->stringLength;<span></span></pre></td></tr><tr><td scope="row"><pre>                    if (theLen > 255)<span></span></pre></td></tr><tr><td scope="row"><pre>                        theLen = 255;<span></span></pre></td></tr><tr><td scope="row"><pre>                    BlockMove(theStringAtomPtr->string, &amp;theStringPtr[1],  theLen);<span></span></pre></td></tr><tr><td scope="row"><pre>                    theStringPtr[0] = theLen;<span></span></pre></td></tr><tr><td scope="row"><pre>                }<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        QTUnlockContainer(theNodeInfo);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    QTDisposeAtomContainer(theNodeInfo);<span></span></pre></td></tr><tr><td scope="row"><pre>    return(theErr);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<p>The <code>MyGetNodeName </code>function
defined in <span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-26774">Listing 5-14</a></span> retrieves the node information atom container (by
calling <code>QTVRGetNodeInfo</code>)
and then looks inside that container for the node header atom with
atom ID 1. If it finds one, it locks the container and then gets
a pointer to the node header atom data. The desired information,
the node name, is contained in the string atom whose atom ID is
specified by the <code>nameAtomID </code>field
of the node header structure. Accordingly, the <code>MyGetNodeName </code>function
then calls <code>QTFindChildByID </code>once
again to find that string atom. If the string atom is found, <code>MyGetNodeName </code>calls <code>QTGetAtomDataPtr </code>to
get a pointer to the string atom data. Finally, <code>MyGetNodeName </code>copies
the string data into the appropriate location and cleans up after
itself before returning.</p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-19331" title="Adding Custom Atoms in a QuickTime VR Movie"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCHFCJB" title="Adding Custom Atoms in a QuickTime VR Movie"></a><h2>Adding Custom Atoms in a QuickTime VR Movie</h2>
<p>If you author a QuickTime VR movie, you may choose to add <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_874"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_875"></a>custom
atoms to either the VR world or node information atom containers.
Those atoms can be extracted within an application to provide additional
information that the application may use.</p>
<p>Information that pertains to the entire scene might be stored
in a custom atom within the VR world atom container. Node-specific
information could be stored in the individual node information atom
containers or as sibling atoms to the node location atoms within
the VR world. </p>
<p>Custom hot spot atoms should be stored as siblings to the
hot spot information atoms in the node information atom container.
Generally, its atom type is the same as the custom hot spot type.
You can set up an intercept procedure in your application in order
to process clicks on the custom hot spots. </p>
<p>If you use custom atoms, you should install your <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_876"></a>hot
spot intercept procedure when you open the movie. <span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-26787">Listing 5-15</a></span> is
an example of such an intercept procedure. </p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-26787" title="Listing 5-15Typical hot spot intercept procedure"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCBCGJH" title="Listing 5-15Typical hot spot intercept procedure"></a><p class="codesample"><strong>Listing 5-15&nbsp;&nbsp;</strong>Typical hot spot intercept procedure</p>
<div class="codesample"><table><tr><td scope="row"><pre>QTVRInterceptProc MyProc = NewQTVRInterceptProc (MyHotSpot);<span></span></pre></td></tr><tr><td scope="row"><pre>QTVRInstallInterceptProc (qtvr, kQTVRTriggerHotSpotSelector, myProc,  0, 0);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>pascal void MyHotSpot (QTVRInstance qtvr, QTVRInterceptPtr qtvrMsg,<span></span></pre></td></tr><tr><td scope="row"><pre>                        SInt32 refCon, Boolean *cancel)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 hotSpotID = (UInt32) qtvrMsg->parameter[0];<span></span></pre></td></tr><tr><td scope="row"><pre>    QTAtomContainer nodeInfo =<span></span></pre></td></tr><tr><td scope="row"><pre>            (QTAtomContainer) qtvrMsg->parameter[1];<span></span></pre></td></tr><tr><td scope="row"><pre>    QTAtom hotSpotAtom = (QTAtom) qtvrMsg->parameter[2];<span></span></pre></td></tr><tr><td scope="row"><pre>    OSType hotSpotType;<span></span></pre></td></tr><tr><td scope="row"><pre>    CustomData myCustomData;<span></span></pre></td></tr><tr><td scope="row"><pre>    QTAtom myAtom;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    QTVRGetHotSpotType (qtvr, hotSpotID, &amp;hotSpotType);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (hotSpotType != kMyAtomType) return;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // It's our type of hot spot - don't let anyone else handle  it<span></span></pre></td></tr><tr><td scope="row"><pre>    *cancel = true;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Find our custom atom<span></span></pre></td></tr><tr><td scope="row"><pre>    myAtom = QTFindChildByID (nodeInfo, hotSpotAtom, kMyAtomType,  1, nil);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (myAtom != 0) {<span></span></pre></td></tr><tr><td scope="row"><pre>        OSErr err;<span></span></pre></td></tr><tr><td scope="row"><pre>        // Copy the custom data into our structure<span></span></pre></td></tr><tr><td scope="row"><pre>        err = QTCopyAtomDataToPtr (nodeInfo, myAtom, false,<span></span></pre></td></tr><tr><td scope="row"><pre>                        sizeof(CustomData), &amp;myCustomData, nil);<span></span></pre></td></tr><tr><td scope="row"><pre>        if (err == noErr)<span></span></pre></td></tr><tr><td scope="row"><pre>            // Do something with it<span></span></pre></td></tr><tr><td scope="row"><pre>            DoMyHotSpotStuff (hotSpotID, &amp;myCustomData);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<p>Your intercept procedure is called for clicks on any hot spot.
You should check to see if it is your type of hot spot and, if so,
extract the custom hot spot atom and do whatever is appropriate
for your hot spot type (<code>DoMyHotSpotStuff</code>).</p>
<p>When you no longer need the intercept procedure you should
call <code>QTVRInstallInterceptProc</code> again
with the same selector and a <code>nil</code> procedure
pointer and then call <code>DisposeRoutineDescriptor</code> on <code>myProc</code>. </p>
<p>Apple reserves all hot spot and atom types with lowercase
letters. Your custom hot spot type should contain all uppercase
letters. </p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-19335" title="Adding Atom Containers in a QuickTime VR Movie"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCJFHCE" title="Adding Atom Containers in a QuickTime VR Movie"></a><h2>Adding Atom Containers in a QuickTime VR
Movie</h2>
<p>Assuming you have already created the QuickTime VR world and
node information atom containers, you would use the code (minus error checking) <span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-26798">Listing 5-16</a></span> to add them to the <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_877"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_878"></a>QTVR
track.</p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-26798" title="Listing 5-16Adding atom containers to a track "></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCEBIFG" title="Listing 5-16Adding atom containers to a track "></a><p class="codesample"><strong>Listing 5-16&nbsp;&nbsp;</strong>Adding atom containers to a track </p>
<div class="codesample"><table><tr><td scope="row"><pre>long descSize;<span></span></pre></td></tr><tr><td scope="row"><pre>QTVRSampleDescriptionHandle qtvrSampleDesc;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Create a  QTVR sample description handle<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>descSize = sizeof(QTVRSampleDescription) + GetHandleSize((Handle)  vrWorld) -<span></span></pre></td></tr><tr><td scope="row"><pre>                                        sizeof(UInt32);<span></span></pre></td></tr><tr><td scope="row"><pre>qtvrSampleDesc = (QTVRSampleDescriptionHandle) NewHandleClear (descSize);<span></span></pre></td></tr><tr><td scope="row"><pre>(*qtvrSampleDesc)->size = descSize;<span></span></pre></td></tr><tr><td scope="row"><pre>(*qtvrSampleDesc)->type = kQTVRQTVRType;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Copy the VR world atom container data into the QTVR sample description<span></span></pre></td></tr><tr><td scope="row"><pre>BlockMove (*((Handle) vrWorld), &amp;((*qtvrSampleDesc)->data),<span></span></pre></td></tr><tr><td scope="row"><pre>                            GetHandleSize((Handle) vrWorld));<span></span></pre></td></tr><tr><td scope="row"><pre>// Now add it to the QTVR track's media<span></span></pre></td></tr><tr><td scope="row"><pre>err = BeginMediaEdits (qtvrMedia);<span></span></pre></td></tr><tr><td scope="row"><pre>err = AddMediaSample (qtvrMedia, (Handle) nodeInfo, 0,<span></span></pre></td></tr><tr><td scope="row"><pre>    GetHandleSize((Handle) nodeInfo), duration,<span></span></pre></td></tr><tr><td scope="row"><pre>    (SampleDescriptionHandle) qtvrSampleDesc, 1, 0, &amp;sampleTime);<span></span></pre></td></tr><tr><td scope="row"><pre>err = EndMediaEdits (qtvrMedia);<span></span></pre></td></tr><tr><td scope="row"><pre>InsertMediaIntoTrack (qtvrTrack, trackTime, sampleTime, duration,  1L&lt;&lt;16);<span></span></pre></td></tr></table></div>
<p>The <code>duration</code> value
is computed based on the duration of the corresponding image track samples
for the node. The value of <code>trackTime</code> is
the time for the beginning of the current node (zero for a single
node movie). The values of <code>duration</code> and <code>sampleTime</code> are
in the time base of the media; the value of <code>trackTime</code> is
in the movie’s time base.</p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-19339" title="Optimizing QuickTime VR Movies for Web Playback"></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCBJHFH" title="Optimizing QuickTime VR Movies for Web Playback"></a><h2>Optimizing QuickTime VR Movies for Web
Playback</h2>
<p>Originally, both QuickTime movies and <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_879"></a>QuickTime
VR movies had to be completely downloaded to the user’s local
hard disk before they could be viewed. Starting with QuickTime 2.5,
if the movie data is properly laid out in the file, standard linear
QuickTime movies can be viewed almost immediately. The frames that
have been downloaded so far are shown while subsequent frames continue
to be downloaded. </p>
<p>The important change that took place to allow this to happen
was for QuickTime to place global movie information at the beginning
of the file. Originally, this information was at the end of the file. After that,
the frame data simply needs to be in order in the file. Similarly, QuickTime
VR files also need to be laid out in a certain manner in order to
get some sort of quick feedback when viewing on the web. Roughly
speaking this involves writing out all of the media samples in the
file in a particular order. Apple now provides a movie export component
that does this for you: the <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_880"></a>QTVR Flattener.</p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-17195" title="The QTVR Flattener"></a><h3>The
QTVR Flattener</h3>
<p>The QTVR Flattener is a movie export component that converts
an existing QuickTime VR single node movie into a new movie that
is optimized for the Web. Not only does the flattener reorder the
media samples, but for panoramas it also creates a small preview
of the panorama. When viewed on the Web, this preview appears after
5% to 10% of the movie data has been downloaded, allowing users
to see a lower-resolution version of the panorama. </p>
<p>Using the QTVR flattener from your application is quite easy.
After you have created the <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_881"></a>QuickTime VR movie,
you simply open the QTVR Flattener component and call the <code>MovieExportToFile</code> routine
as shown in <span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-26856">Listing 5-17</a></span>.</p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-26856" title="Listing 5-17Using the flattener "></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCFJEGF" title="Listing 5-17Using the flattener "></a><p class="codesample"><strong>Listing 5-17&nbsp;&nbsp;</strong>Using the flattener </p>
<div class="codesample"><table><tr><td scope="row"><pre>ComponentDescription desc;<span></span></pre></td></tr><tr><td scope="row"><pre>Component flattener;<span></span></pre></td></tr><tr><td scope="row"><pre>ComponentInstance qtvrExport = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>desc.componentType = MovieExportType;<span></span></pre></td></tr><tr><td scope="row"><pre>desc.componentSubType = MovieFileType;<span></span></pre></td></tr><tr><td scope="row"><pre>desc.componentManufacturer = QTVRFlattenerType;<span></span></pre></td></tr><tr><td scope="row"><pre>flattener = FindNextComponent(nil, &amp;desc);<span></span></pre></td></tr><tr><td scope="row"><pre>if (flattener) qtvrExport = OpenComponent (flattener);<span></span></pre></td></tr><tr><td scope="row"><pre>if (qtvrExport)<span></span></pre></td></tr><tr><td scope="row"><pre>    MovieExportToFile (qtvrExport, &amp;myFileSpec, myQTVRMovie,  nil, 0, 0);<span></span></pre></td></tr></table></div>
<p>The code fragment shown in <span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-26856">Listing 5-17</a></span> creates a flattened
movie file specified by the <code>myFileSpec</code> parameter.
If your QuickTime VR movie is a panorama, the flattened movie file includes
a quarter size, blurred JPEG, compressed preview of the panorama
image.</p>
<div class="notebox"><a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_102" title="Note"></a><p><strong>Note:</strong>&nbsp;The constants <code>MovieExportType</code> and <code>MovieFileType</code> used
in <span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-26856">Listing 5-17</a></span> are
defined in header files <code>QuickTimeComponents.h</code> and <code>Movies.h</code> respectively
and are defined as <code>'spit'</code> and <code>'MooV'</code>. </p></div>
<p>You can present users with the QTVR Flattener’s own dialog
box to allow them to choose options such as how to compress the
preview image or to select a separate preview image file. Use the
following code to show the dialog box:</p>
<div class="codesample"><table><tr><td scope="row"><pre>        err = MovieExportDoUserDialog (qtvrExport, myQTVRMovie,  nil, 0, 0,  &amp;cancel);<span></span></pre></td></tr></table></div>
<p>If the user cancels the dialog box, then the Boolean cancel
is set to <code>true</code>.</p>
<p>If you do not want to present the user with the flattener’s
dialog box, you can communicate directly with the component by using
the <code>MovieExportSetSettingsFromAtomContainer</code> routine
as described in the following paragraphs.</p>
<p>If you want to specify a preview image other than the default,
you need to create a special atom container and then call <code>MovieExportSetSettingsFromAtomContainer</code> before
calling <code>MovieExportToFile</code>.
You can specify how to compress the image, what resolution to use, and
you can even specify your own preview image file to be used. The
atom container you pass in can have various atoms that specify certain
export options. These atoms must all be children of a flattener
settings parent atom. </p>
<p>The preview resolution atom is a 16-bit value that allows
you to specify the resolution of the preview image. This value,
which defaults to <code>kQTVRQuarterRes</code>,
indicates how much to reduce the preview image.</p>
<p>The blur preview atom is a Boolean value that indicates whether
to blur the image before compressing. Blurring usually results in
a much more highly compressed image. The default value is <code>true</code>.</p>
<p>The create preview atom is a Boolean value that indicates
whether a preview image should be created. The default value is <code>true</code>.</p>
<p>The import preview atom is a Boolean value that is used to
indicate that the preview image should be imported from an external
file rather than generated from the image in the panorama file itself.
This allows you to have any image you want as the preview for the panorama.
You can specify which file to use by also including the import specification atom,
which is an <code>FSSpec</code> data
structure that identifies the image file. If you do not include this
atom, then the flattener presents the user with a dialog box asking
the user to select a file. The default for import preview is <code>false.</code> If
an import file is used, the image is used at its natural size and
the resolution setting is ignored.</p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-17215" title="Sample Atom Container for the QTVR Flattener"></a><h3>Sample
Atom Container for the QTVR Flattener</h3>
<p>The sample code in <span class="content_text"><a href="qtff5.html#//apple_ref/doc/uid/TP40000939-CH207-26879">Listing 5-18</a></span> creates an <a name="//apple_ref/doc/uid/TP40000939-CH207-DontLinkElementID_882"></a>atom container
and adds atoms to indicate an import preview file for the flattener
to use.</p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-26879" title="Listing 5-18Specifying a preview file for the flattener to use "></a><a name="//apple_ref/doc/uid/TP40000939-CH207-BBCGEBBG" title="Listing 5-18Specifying a preview file for the flattener to use "></a><p class="codesample"><strong>Listing 5-18&nbsp;&nbsp;</strong>Specifying a preview file for the flattener
to use </p>
<div class="codesample"><table><tr><td scope="row"><pre>Boolean yes = true;<span></span></pre></td></tr><tr><td scope="row"><pre>QTAtomContainer exportData;<span></span></pre></td></tr><tr><td scope="row"><pre>QTAtom parent;<span></span></pre></td></tr><tr><td scope="row"><pre>err = QTNewAtomContainer(&amp;exportData);<span></span></pre></td></tr><tr><td scope="row"><pre>// create a parent for the other settings atoms<span></span></pre></td></tr><tr><td scope="row"><pre>err = QTInsertChild (exportData, kParentAtomIsContainer,<span></span></pre></td></tr><tr><td scope="row"><pre>            QTVRFlattenerParentAtomType, 1, 0, 0, nil, &amp;parent);<span></span></pre></td></tr><tr><td scope="row"><pre>// Add child atom to indicate we want to import the preview from  a file<span></span></pre></td></tr><tr><td scope="row"><pre>err = QTInsertChild (exportData, parent, QTVRImportPreviewAtomType,  1, 0,<span></span></pre></td></tr><tr><td scope="row"><pre>            sizeof (yes), &amp;yes, nil);<span></span></pre></td></tr><tr><td scope="row"><pre>// Add child atom to tell which file to import<span></span></pre></td></tr><tr><td scope="row"><pre>err = QTInsertChild (exportData, parent, QTVRImportSpecAtomType,  1, 0,<span></span></pre></td></tr><tr><td scope="row"><pre>            sizeof (previewSpec), &amp;previewSpec, nil);<span></span></pre></td></tr><tr><td scope="row"><pre>// Tell the export component<span></span></pre></td></tr><tr><td scope="row"><pre>MovieExportSetSettingsFromAtomContainer (qtvrExport, exportData);<span></span></pre></td></tr></table></div>
<p>Overriding the compression settings is a bit more complicated.
You need to open a standard image compression dialog component and
make calls to obtain an atom container that you can then pass to
the QTVR Flattener component.</p>
<a name="//apple_ref/doc/uid/TP40000939-CH207-26890" title="Listing 5-19Overriding the compression settings "></a><a name="//apple_ref/doc/uid/TP40000939-CH207-TPXREF102" title="Listing 5-19Overriding the compression settings "></a><p class="codesample"><strong>Listing 5-19&nbsp;&nbsp;</strong>Overriding
the compression settings </p>
<div class="codesample"><table><tr><td scope="row"><pre>ComponentInstance sc;<span></span></pre></td></tr><tr><td scope="row"><pre>QTAtomContainer compressorData;<span></span></pre></td></tr><tr><td scope="row"><pre>SCSpatialSettings ss;<span></span></pre></td></tr><tr><td scope="row"><pre>sc = OpenDefaultComponent(StandardCompressionType,StandardCompressionSubType);<span></span></pre></td></tr><tr><td scope="row"><pre>ss.codecType = kCinepakCodecType;<span></span></pre></td></tr><tr><td scope="row"><pre>ss.codec = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>ss.depth = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>ss.spatialQuality = codecHighQuality<span></span></pre></td></tr><tr><td scope="row"><pre>err = SCSetInfo(sc, scSpatialSettingsType, &amp;ss);<span></span></pre></td></tr><tr><td scope="row"><pre>err = SCGetSettingsAsAtomContainer(sc, &amp;compressorData);<span></span></pre></td></tr><tr><td scope="row"><pre>MovieExportSetSettingsFromAtomContainer (qtvrExport, compressorData);<span></span></pre></td></tr></table></div>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../QTFFChap4/qtff4.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../QTFFAppenA/QTFFAppenA.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2004, 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-09-04<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/QuickTime/QTFF/QTFFChap5/qtff5.html%3Fid%3DTP40000939-3.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/QuickTime/QTFF/QTFFChap5/qtff5.html%3Fid%3DTP40000939-3.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/QuickTime/QTFF/QTFFChap5/qtff5.html%3Fid%3DTP40000939-3.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>