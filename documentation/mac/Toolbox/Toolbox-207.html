<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Handling Events in Windows(IM:Tb)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING207></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Toolbox-206.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Toolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Toolbox-490.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Toolbox-208.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Toolbox-2.html"><B>Macintosh Toolbox Essentials</B></A> / <BR><DD><A HREF="Toolbox-188.html"><B>Chapter 4 - Window Manager</B></A> / <A HREF="Toolbox-201.html"><B>Using the Window Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING207-0></A>
<H2><A NAME=MARKER-9-188></A>Handling Events in Windows</H2>
 <A NAME=MARKER-21-397></A>Your application must be prepared to handle two kinds of window-related events:<P>
<UL>
<LI>mouse and keyboard events in your application's windows, which are reported by the Event Manager in direct response to user actions
<LI>activate and update events, which are generated by the Window Manager and the Event Manager as an indirect result of user actions<P>
</UL>
 In System 7 your application receives mouse-down events if it is the foreground process and the user clicks in the menu bar, a window belonging to your application, or a window belonging to a desk accessory that was launched in your application's partition. (If the user clicks in a window belonging to another application, the Event Manager sends your application a suspend event and performs a major switch to the other application--unless the frontmost window is an alert box or a modal dialog box, in which case the Dialog Manager merely sounds the system alert, and the Process Manager retains your application as the foreground process.) When it receives a mouse-down event, your application first calls the <CODE>FindWindow</CODE> function to map the cursor location to a window region, and then it branches to one of its own routines, as described in the next section, <A HREF=#MARKER-9-192>"Handling Mouse Events in Windows."</A><P>
 The Event Manager sends your application an update event when changes on the desktop or in a window require that part or all of a window's content region be updated. The Window Manager and your application can both trigger update events by adding regions that need updating to the update region, as described in the section <A HREF=#MARKER-9-206>"Handling Update Events" beginning on page 4-42</A>.<P>
 <A NAME=MARKER-2-190></A>Your application receives activate events when an inactive window becomes active or an active window becomes inactive. Activate events are an example of the close cooperation between your application and the Window Manager. When you receive a mouse-down event in one of your application's inactive windows, you can call the <CODE>SelectWindow</CODE> procedure, which removes the highlighting from the previously active window and adds highlighting to the newly active window. It also generates two activate events: one telling your application to deactivate the previously active window and one to activate the newly active window. Your application then activates and deactivates the content regions, as described in the section <A HREF=#MARKER-9-214>"Handling Activate Events" beginning on page 4-44</A>.<P>
 When the user first clicks in an inactive window, most applications do not make a selection or otherwise change the window or document, beyond making the window active. When your application receives a resume event because the user clicked in one of its windows, you might not even want to receive the mouse-down event that caused your application to become the foreground process. You control whether or not you receive this event through the <CODE>'SIZE'</CODE> resource, described in the chapter "Event Manager" earlier in this book.<A NAME=MARKER-9-398></A><P>
<A NAME=HEADING207-8></A>
<H3><A NAME=MARKER-9-192></A><A NAME=MARKER-21-193></A>Handling Mouse Events in Windows</H3>
 <A NAME=MARKER-21-399></A>When your application is active, it receives notice of all keyboard activity and mouse-down events in the menu bar, in one of its windows, or in any windows belonging to desk accessories that were launched in its partition.<P>
 When it receives a mouse-down event, your application calls the <CODE>FindWindow</CODE> function to map the cursor location to a window region.<A NAME=MARKER-2-195></A> <P>
 The function specifies the region by returning one of these constants:<P>
<PRE>
CONST inDesk      = 0;  {none of the following}
      inMenuBar   = 1;  {in menu bar}
      inSysWindow = 2;  {in desk accessory window}
      inContent   = 3;  {anywhere in content region except size }
                        { box if window is active, }
                        { anywhere including size box if window }
                        { is inactive}
      inDrag      = 4;  {in drag (title bar) region}
      inGrow      = 5;  {in size box (active window only)}
      inGoAway    = 6;  {in close box}
      inZoomIn    = 7;  {in zoom box (window in standard state)}
      inZoomOut   = 8;  {in zoom box (window in user state)}
</PRE>
 When the user presses the mouse button while the cursor is in a window, <CODE>FindWindow</CODE> not only returns a constant that identifies the window region but also sets a variable parameter that points to the window.<P>
 In System 7, if <CODE>FindWindow</CODE> returns <CODE>inDesk</CODE>, the cursor is somewhere other than in the menu bar, one of your windows, or a window created by a desk accessory launched in your application's partition. The function may return <CODE>inDesk</CODE> if, for example, the cursor is in the window frame but not in the drag region, close box, or zoom box. <CODE>FindWindow</CODE> seldom returns the value <CODE>inDesk</CODE>, and you can generally ignore the rare instances of this function result.<P>
 If the user presses the mouse button with the cursor in the menu bar (<CODE>inMenuBar</CODE>), <BR>you call your own routines for displaying menus and allowing the user to choose <BR>menu items.<P>
 The <CODE>FindWindow</CODE> function returns the value <CODE>inSysWindow</CODE> only when the user presses the mouse button with the cursor in a window that belongs to a desk accessory launched in your application's partition. You can then call the <CODE>SystemClick</CODE> procedure, passing it the event record and window pointer. The <CODE>SystemClick</CODE> procedure, documented in the chapter "Event Manager" in this book, makes sure that the event is handled by the appropriate desk accessory.<A NAME=MARKER-2-196></A><P>
 The <CODE>FindWindow</CODE> function returns one of the other values when the user presses <BR>the mouse button while the cursor is in one of your application's windows. Your response depends on whether the cursor is in the active window and, if not, what <BR>kind of window is active.<P>
 When you receive a mouse-down event in the active window, you route the event to the appropriate routine for changing the window display or the document contents. When the user presses the mouse button while the cursor is in the zoom box, for example, you call the Window Manager function <CODE>TrackBox</CODE> to highlight the zoom box and track the mouse until the button is released.<A NAME=MARKER-2-318></A><P>
 When you receive a mouse-down event in an inactive window, your response depends on what kind of window is active:<P>
<UL>
<LI>If the active window is a movable modal dialog box, you should sound the system alert and take no other action. (If the active window is a modal dialog box handled by the <CODE>ModalDialog</CODE> procedure, the Dialog Manager doesn't pass the event to your application but sounds the system alert itself.)
<LI>If the active window is a document window or a modeless dialog box, you can call <CODE>SelectWindow</CODE>, passing it the window pointer. The <CODE>SelectWindow</CODE> procedure removes highlighting from the previously active window, brings the newly activated window to the front, highlights it, and generates the activate and update events necessary to tell all affected applications which windows must be redrawn.<A NAME=MARKER-2-198></A><P>
</UL>
 <A HREF=#MARKER-9-200>Listing 4-9</A> illustrates an application-defined procedure that handles mouse-down events.<A NAME=MARKER-2-199></A><P>
<B>Listing 4-9  <A NAME=MARKER-9-200></A>Handling mouse-down events</B><P>
<PRE>
PROCEDURE DoMouseDown (event: EventRecord);
VAR
   part:       Integer;
   thisWindow: WindowPtr;
BEGIN
   part := FindWindow(event.where, thisWindow); {find out where cursor is}
   CASE part OF
   inMenuBar:           {cursor is in menu bar}
      BEGIN
         {make sure menu items are properly enabled/disabled}
         MyAdjustMenus;
         {let user choose a menu command}
         DoMenuCommand(MenuSelect(event.where));
      END;
   inSysWindow:            {cursor is in a desk accessory window}
      SystemClick(event, thisWindow);
   inContent:              {cursor is in the content region of one }
                           { of your application's windows}
      IF thisWindow &lt;&gt; FrontWindow THEN   {cursor is not in front window}
      BEGIN
         IF MyIsMovableModal(FrontWindow) THEN     {front window is }
            SysBeep(30)                            { movable modal}
         ELSE                          {front window is not movable modal}
            SelectWindow(thisWindow);  {make thisWindow active}
      END
      ELSE                 {cursor is in content region of active window}
         DoContentClick(thisWindow, event);  {handle event in content region}
   inDrag:                 {cursor is in drag area}
      {if a movable modal is active, ignore click in an inactive title bar}
      IF (thisWindow &lt;&gt; FrontWindow) AND MyIsMovableModal(FrontWindow) THEN
         SysBeep(30)
      ELSE
         {let Window Manager drag window}
         DragWindow(thisWindow, event.where, GetGrayRgn^^.rgnBBox);
   inGrow:                 {cursor is in size box}
      DoGrowWindow(thisWindow, event);    {change window size}
   inGoAway:               {cursor is in close box}
      {call TrackGoAway to handle mouse until button is released}
      IF TrackGoAway(thisWindow, event.where) THEN
         DoCloseCmd;                      {handle close window}
   inZoomIn, inZoomOut:    {cursor is in zoom box}
      {call TrackBox to handle mouse until button is released}
      IF TrackBox(thisWindow, event.where, part) THEN
         DoZoomWindow(thisWindow, part);  {handle zoom window}
   END;  {end of CASE statement}
END;     {end of DoMouseDownEvent}
</PRE>
 The <CODE>DoMouseDown</CODE> procedure first calls <CODE>FindWindow</CODE> to map the location of the cursor to a part of the screen or a region of a window.<P>
 If the cursor is in the menu bar, <CODE>DoMouseDown</CODE> calls other application-defined procedures for adjusting and displaying menus and accepting menu choices.<P>
 If the cursor is in a window created by a desk accessory, <CODE>DoMouseDown</CODE> calls the <CODE>SystemClick</CODE> procedure, which handles mouse-down events for desk accessories from within applications.<P>
 If the cursor is in the content area of a window, <CODE>DoMouseDown</CODE> first checks to see whether the cursor is in the currently active window by comparing the window pointer returned by <CODE>FindWindow</CODE> with the result returned by the function <CODE>FrontWindow</CODE>. If <BR>the cursor is in an inactive window, <CODE>DoMouseDown</CODE> checks to see if the active window <BR>is a movable modal dialog box. (If the front window is an alert box or a fixed-position modal dialog box, an application does not receive mouse-down events in other windows.) If the active window is a movable modal dialog box and the cursor is in another window, <CODE>DoMouseDown</CODE> simply sounds the system alert and waits for another event. If the active window is not a movable modal dialog box, <CODE>DoMouseDown</CODE> <BR>calls <CODE>SelectWindow</CODE> to activate the window in which the cursor is located. The <CODE>SelectWindow</CODE> procedure relayers the windows as necessary, adjusts the highlighting, and sends the application a pair of activate events to deactivate the previously active window and activate the newly active window. <CODE>DoMouseDown</CODE> merely activates <BR>the window in which the cursor is located; it does not make a selection in the newly activated window in response to the first click in that window.<P>
 If the cursor is in the content area of the active window, the <CODE>DoMouseDown</CODE> procedure calls another application-defined procedure (<CODE>DoContentClick</CODE>) that handles mouse events in the content area.<P>
 If the cursor is in the drag region of a window, <CODE>DoMouseDown</CODE> first checks whether the drag region is in an inactive window while a movable modal dialog box is active. In <BR>that case, <CODE>DoMouseDown</CODE> merely sounds the system alert and waits for another event. In any other case, <CODE>DoMouseDown</CODE> calls the Window Manager procedure <CODE>DragWindow</CODE>, which displays an outline of the window, moves the outline as long as the user continues to drag the window, and calls <CODE>MoveWindow</CODE> to draw the window in its new location when the user releases the mouse button. After the window is drawn in its new location, it is the active window, whether or not it was active before.<P>
 If the cursor is in the size box, <CODE>DoMouseDown</CODE> calls another application-defined routine (<CODE>DoGrowWindow</CODE>, shown in <A HREF=Toolbox-210.html#MARKER-9-237>Listing 4-13</A> on <A HREF=Toolbox-210.html#MARKER-9-237>page 4-51</A>) that resizes the window.<P>
 If the mouse press occurs in the close box, <CODE>DoMouseDown</CODE> calls the <CODE>TrackGoAway</CODE> function, which highlights the close box and tracks all mouse activity until the user releases the mouse button. As long as the user holds down the mouse button and leaves the cursor in the close box, <CODE>TrackGoAway</CODE> leaves the close box highlighted, as illustrated in <A HREF=#MARKER-9-201>Figure 4-19</A>. If the user moves the cursor out of the close box, <CODE>TrackGoAway</CODE> removes the highlighting.<P>
<B>Figure 4-19  <A NAME=MARKER-9-201></A>The close box with and without highlighting</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/WM-LS-12.jpg"><P>
 When the user releases the mouse button, <CODE>TrackGoAway</CODE> returns <CODE>TRUE</CODE> if the <BR>cursor is still in the close box and <CODE>FALSE</CODE> if it is not. If <CODE>TrackGoAway</CODE> returns <CODE>TRUE</CODE>, <CODE>DoMouseDown</CODE> calls the application-defined procedure <CODE>DoCloseCmd</CODE> to close the window. <A HREF=Toolbox-211.html#MARKER-9-245>Listing 4-16 on page 4-54</A> shows the <CODE>DoCloseCmd</CODE> procedure.<P>
 If the mouse press occurs in the zoom box, the <CODE>DoMouseDown</CODE> procedure first calls <CODE>TrackBox</CODE>, which highlights the zoom box and tracks all mouse activity until the user releases the mouse button. As long as the user holds down the mouse button and leaves the cursor in the zoom box, <CODE>TrackBox</CODE> leaves the zoom box highlighted, as illustrated in <A HREF=#MARKER-9-202>Figure 4-20</A>. If the user moves the cursor out of the zoom box, <CODE>TrackBox</CODE> removes the highlighting.<P>
 When the user releases the mouse button, <CODE>TrackBox</CODE> returns <CODE>TRUE</CODE> if the cursor is still in the zoom box and <CODE>FALSE</CODE> if it is not. If <CODE>TrackBox</CODE> returns <CODE>TRUE</CODE>, <CODE>DoMouseDown</CODE> calls the application-defined procedure <CODE>DoZoomWindow</CODE> to zoom the window. <A HREF=Toolbox-209.html#MARKER-9-231>Listing 4-12</A> on <A HREF=Toolbox-209.html#MARKER-9-231>page 4-48</A> shows the <CODE>DoZoomWindow</CODE> procedure.<P>
<B>Figure 4-20  <A NAME=MARKER-9-202></A>The zoom box with and without highlighting</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/WM-LS-11.jpg"><P>
<A NAME=HEADING207-40></A>
<H3><A NAME=MARKER-21-203></A>Handling Keyboard Events in Windows</H3>
 <A NAME=MARKER-2-172></A>Whenever your application is the foreground process, it receives key-down events <BR>for all keyboard activity, except for the three standard Command-Shift-number key sequences and any other Command-Shift-number key combinations the user has installed. (Command-Shift-1 and Command-Shift-2 eject disks, and Command-Shift-3 stores a snapshot of the screen in a TeachText document on the startup volume. Your application never receives these key combinations, which are handled by the Event Manager. For more information, see the chapter "Event Manager" in this book.)<P>
 In general, the active window is the target of keyboard activity.<P>
 When the user presses a key or a combination of keys, your application responds by inserting data into the document, changing the display, or taking other actions as defined by your application. To ensure consistent use of and response to keyboard events, follow the guidelines in <I>Macintosh Human Interface Guidelines</I>. Your application should, for example, allow the user to choose frequently used menu items by pressing a keyboard equivalent--usually a combination of the Command key and another key.<P>
 When you receive a key-down event, you first check whether the user is holding down <BR>a modifier key (Command, Shift, Control, Caps Lock, and Option, on a standard keyboard) and another key at the same time. If the Command key and a character key are held down simultaneously, for example, you adjust your menus, enabling and disabling items as appropriate, and allow the user to choose the menu item associated with the Command-key combination.<P>
 Typically, your application provides feedback for standard keystrokes by drawing the character on the screen. It should also recognize arrow keys for moving the cursor within a text display, and it might add support for function keys or other special keys available on nonstandard keyboards.<P>
 For an example of an application-defined routine for handling keyboard events, see the chapter "Event Manager" in this book.<A NAME=MARKER-2-179></A><P>
<A NAME=HEADING207-47></A>
<H3><A NAME=MARKER-9-206></A><A NAME=MARKER-21-207></A>Handling Update Events</H3>
 <A NAME=MARKER-2-401></A>The Event Manager sends your application an update event when part or all of your window's content region needs to be redrawn. Specifically, the Event Manager checks each window's update region every time your application calls <CODE>WaitNextEvent</CODE> or <CODE>EventAvail</CODE> (or <CODE>GetNextEvent</CODE>) and generates an update event for every window whose update region is not empty.<P>
 The Window Manager typically triggers update events when the moving and relayering of windows on the screen require that one or more windows be redrawn. If the user moves a window that covers part of an inactive window, for example, the Window Manager first calls the window definition function of the inactive window, requesting that it draw the window frame. It then adds the newly exposed area to the window's update region, which triggers an update event asking your application to update the content region. Your application can also trigger update events itself by manipulating the update region.<P>
 Your application can receive update events when it is in either the foreground or <BR>the background.<P>
 The Window Manager ensures that you do not accidentally draw in other windows by clipping all screen drawing to the visible region<B> </B>of a window's graphics port. The <B>visible region</B> is the part of the graphics port that's actually visible on the screen--that is, the part that's not covered by other windows. The Window Manager stores a handle to the visible region in the <CODE>visRgn</CODE> field of the graphics port data structure, which itself is in the window record.<A NAME=MARKER-2-158></A><P>
 In response to an update event, your application calls the <CODE>BeginUpdate</CODE> procedure, draws the window's contents, and then calls the <CODE>EndUpdate</CODE> procedure. As illustrated <BR>in <A HREF=#MARKER-9-210>Figure 4-21</A>, <CODE>BeginUpdate</CODE> limits the visible region to the intersection of the visible region and the update region. Your application can then update either the visible region or the entire content region--because QuickDraw limits drawing to the visible region, only the parts of the window that actually need updating are drawn. The <CODE>BeginUpdate</CODE> procedure also clears the update region. After you've updated the window, you call <CODE>EndUpdate</CODE> to restore the visible region in the graphics port to the full visible region.<P>
 See Inside Macintosh: Imaging for more information about graphics ports and <BR>visible regions.<P>
<B>Figure 4-21  <A NAME=MARKER-9-210></A>The effects of <CODE>BeginUpdate</CODE> and <CODE>EndUpdate</CODE> on the visible region and <BR>update region</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/WM-LS-14.jpg"><P>
 <A HREF=#MARKER-9-212>Listing 4-10</A> illustrates an application-defined procedure, <CODE>DoUpdate</CODE>, that handles <BR>an update event<A NAME=MARKER-2-211></A>.<P>
<B>Listing 4-10  <A NAME=MARKER-9-212></A>Handling update events</B><P>
<PRE>
PROCEDURE DoUpdate (window: WindowPtr);
VAR
   windowType: LongInt;
BEGIN
   {determine type of window as defined by this application}
   windowType := MyGetWindowType(window);
   CASE windowType OF
      kMyDocWindow:           {document window}
         BEGIN
            BeginUpdate(window);
            MyDrawWindow(window);
            EndUpdate(window);
         END;
      OTHERWISE               {alert or dialog box}
         DoUpdateMyDialog(window);
      END; {of CASE}
END;
</PRE>
 The <CODE>DoUpdate</CODE> procedure first determines whether the window being updated is a document window or some other application-defined window by calling the application-defined procedure <CODE>MyGetWindowType</CODE> (shown in <A HREF=Toolbox-202.html#MARKER-9-136>Listing 4-1</A> on <BR><A HREF=Toolbox-202.html#MARKER-9-136>page 4-21</A>). If the window is a document window, <CODE>DoUpdate</CODE> calls <CODE>BeginUpdate</CODE> <BR>to establish the temporary visible region, calls the application-defined procedure <CODE>MyDrawWindow</CODE> (shown in <A HREF=Toolbox-204.html#MARKER-9-177>Listing 4-8</A> on <A HREF=Toolbox-204.html#MARKER-9-177>page 4-35</A>) to redraw the content region, <BR>and then calls <CODE>EndUpdate</CODE> to restore the visible region.<P>
 If the window is an alert box or a dialog box, <CODE>DoUpdate</CODE> calls the application-defined procedure <CODE>DoUpdateMyDialog</CODE>, which is not shown here.<A NAME=MARKER-2-478></A><P>
<A NAME=HEADING207-61></A>
<H3><A NAME=MARKER-9-214></A><A NAME=MARKER-21-215></A>Handling Activate Events</H3>
 <A NAME=MARKER-9-211></A>Your <A NAME=MARKER-2-98></A>application activates and deactivates windows in response to <B>activate events,</B> which are generated by the Window Manager to inform your application that a window is becoming active or inactive. Each activate event specifies the window to be changed and the direction of the change (that is, whether it is to be activated or deactivated).<P>
 Your application often triggers activate events itself by calling the <CODE>SelectWindow</CODE> procedure. When it receives a mouse-down event in an inactive window, for example, your application calls <CODE>SelectWindow</CODE>, which brings the selected window to the front, removes the highlighting from the previously active window, and adds highlighting to the selected window. The <CODE>SelectWindow</CODE> procedure then generates two activate events: the first one tells your application to deactivate the previously active window; the second, to activate the newly active window.<P>
 When you receive the event for the previously active window, you<P>
<UL>
<LI>hide the controls and size box
<LI>remove or alter any highlighting of selections in the window<P>
</UL>
 When you receive the event for the newly active window, you<P>
<UL>
<LI>draw the controls and size box
<LI>restore the content area as necessary, adding the insertion point in its former location or highlighting any previously highlighted selections<P>
</UL>
 If the newly activated window also needs updating, your application also receives an update event, as described in the previous section, <A HREF=#MARKER-9-206>"Handling Update Events."</A><P>
<DL>
<DT><B>Note</B>
<DD>A switch to one of your application's windows from a different application is handled through suspend and resume events, not activate events. See the chapter "Event Manager" in this book for a description of how your application can share processing time.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 <A HREF=#MARKER-9-218>Listing 4-11</A> illustrates the application-defined procedure <CODE>DoActivate</CODE>, which handles activate events.<P>
<B>Listing 4-11  <A NAME=MARKER-9-218></A>Handling activate events</B><P>
<PRE>
PROCEDURE DoActivate (window: WindowPtr; activate: Boolean;
                        event: EventRecord);
VAR
   windowType:                Integer;
   myData:                    MyDocRecHnd;
   growRect:                  Rect;
BEGIN
   {determine type of window as defined by this application}
   windowType := MyGetWindowType(window);
   CASE windowType OF
      kMyFindModelessDialogBox:     {modeless Find dialog box}
         DoActivateFindDBox(window, event);
                           {modeless Check Spelling dialog box}
      kMyCheckSpellingModelessDialogBox:
         DoActivateCheckSpellDBox(window, event);
      kMyDocWindow:                 {document window}
         BEGIN
            myData := MyDocRecHnd(GetWRefCon(window)); {get document record}
            HLock(Handle(myData));  {lock document record}
            WITH myData^^ DO
            IF activate THEN        {window is becoming active}

            BEGIN
               {restore selections and insert caret--if using }
               { TextEdit, for example, call TEActivate}
               TEActivate(editRec);
               MyAdjustMenus;       {adjust menus for window}
                                    {handle the controls}
               docVScroll^^.contrlVis := kControlVisible;
               docHScroll^^.contrlVis := kControlVisible;
               InvalRect(docVScroll^^.contrlRect);
               InvalRect(docHScroll^^.contrlRect);
               growRect := window^.portRect;
               WITH growRect DO     {handle the size box}
                  BEGIN             {adjust for the scroll bars}
                     top := bottom - kScrollbarAdjust;
                     left := right - kScrollbarAdjust;
                  END;
               InvalRect(growRect);
            END
            ELSE           {window is becoming inactive}
            BEGIN
               TEDeactivate(editRec);     {call TextEdit to deactivate data}
               HideControl(docVScroll);   {hide the scroll bars}
               HideControl(docHScroll);
               DrawGrowIcon(window);      {draw the size box}
            END;
         HUnLock(Handle(myData));         {unlock document record}
      END; {of kMyDocWindow statement}
   END; {of CASE statement}
END; 
</PRE>
 The <CODE>DoActivate</CODE> procedure first determines the general type of the window; that is, <BR>it calls an application-defined function that returns a constant identifying the type <BR>of the window: a Find dialog box, a Check Spelling dialog box, or a document window. <A HREF=Toolbox-202.html#MARKER-9-136>Listing 4-1</A> on <A HREF=Toolbox-202.html#MARKER-9-136>page 4-21</A> shows the <CODE>MyGetWindowType</CODE> function.<P>
 If the target of the activate event is a dialog box window, <CODE>DoActivate</CODE> calls other application-defined routines for activating and deactivating those dialog boxes. The DoActivateFindDBox and DoActivateCheckSpellDBox routines are not shown here. (The <CODE>DoActivate</CODE> procedure does not check for alert boxes and modal dialog boxes, because the Dialog Manager's <CODE>ModalDialog</CODE> procedure automatically handles activate events.)<P>
 If the target is a document window and the activate event specifies that the window is becoming active, <CODE>DoActivate</CODE> highlights any user selections in the window and draws the insertion point where appropriate. It then makes the controls visible, adds the area occupied by the scroll bars to the update region, and adds the area occupied by the size box to the update region. (Placing window area in the update region guarantees an update event. When the application receives the update event, it calls the application- defined procedure <CODE>DoUpdate</CODE> to draw the update region, which in this case includes the size box and scroll bars.)<P>
 If the target is a document window, and the activate event specifies that the window <BR>is becoming inactive, the <CODE>DoActivate</CODE> procedure calls the TextEdit procedure <CODE>TEDeactivate</CODE> to remove highlighting from user selections, calls the Control Manager procedure <CODE>HideControl</CODE> to hide the scroll bars, and calls the Window Manager procedure <CODE>DrawGrowIcon</CODE> to draw the size box and the outline of the <A NAME=MARKER-2-292></A>scroll bar<A NAME=MARKER-2-220></A> area.<A NAME=MARKER-9-204></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Toolbox-206.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Toolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Toolbox-490.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Toolbox-208.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Toolbox-3.html">&copy; Apple Computer, Inc.</A><br>11 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
