<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><html><head><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note NW03: AppleTalk Phase 2 on the Macintosh</title><meta name="keywords" content=""><meta name="Description" content="Technical Note NW03: ">                                       <meta name="categories" content="Networking"><meta name="week-posted" content="Jul 31, 1989 - Aug 4, 1989"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF" TEXT="#000000"><a name="//apple_ref/doc/uid/DTS10002545" title="AppleTalk Phase 2 on the Macintosh"></a><a name="top"></a>                                       <!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxNetworking-date.html">Networking</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Networking/index.html" target="_blank">Reference Library > Networking</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note NW03</div>
<div id="pageheadsub">AppleTalk Phase 2 on the Macintosh</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->					<p id="menutext">					<a href="#Introduction">Introduction</a><BR><BR><a href="#Section1">What is AppleTalk Phase 2?</a><BR><BR>	<a href="#Section2">Are AppleTalk Phase 2 Drivers Present?</a><BR><BR><a href="#Section3">Calls to the .ATP Driver</a><BR><BR><a href="#Section4">Name Binding Protocol (NBP) Change:  Wildcard Lookup</a><BR><BR><a href="#Section5">Obtaining Zone Information Using the New .XPP Driver Calls</a><BR><BR><a href="#Section6">Potential Nastiness</a><BR><BR><a href="#Section7">The AppleTalk Transition Queue</a><BR><BR><a href="#Section8">Making a LAP Manager Call</a><BR><BR><a href="#Section9">The AppleTalk Transition Queue LAP Calls</a><BR><BR><a href="#Section10">The Transitions</a><BR><BR><a href="#Section11">Potential Compatibility Problems</a><BR><BR><a href="#References">References</a><BR><BR><a href="#Downloads">Downloadables</a></p>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><P id = "introtext">This Technical Note discusses the new features and calls available withAppleTalk Phase 2.</p> <!-- end_intro_text --><!-- begin_date --><h3 align=center>[Aug 01 1989]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR><!-- begin_content --><a name="Introduction"></a><h2>Introduction</h2><p>AppleTalk Phase 2 is only available on Macintosh Plus or later Macintoshplatforms, and it requires the installation of AppleTalk file V53, or greater.Both EtherTalk 2.0 and TokenTalk 2.0 automatically install this AppleTalk file.Developer Technical Support can supply the Phase 2 drivers for development use;however, if you need to include the Phase 2 drivers in your product, you mustlicense them from Software Licensing.  For more information, contact:</p><p>            Apple Software Licensing<br>            Apple Computer, Inc.,<br>            20525 Mariani Avenue, M/S 38-I<br>            Cupertino, CA, 95014<br>            (408) 974-4667<br>            AppleLink:  SW.LICENSE</p>            <P><A HREF="#top">Back to top</A></P><a name="Section1"></a><h2>What is AppleTalk Phase 2?</h2><p>AppleTalk Phase 2 contains enhancements to the routing and naming services ofAppleTalk.  Among these enhancements is the ability to create AppleTalknetworks which support more than 254 nodes, and to do so in a manner that is,to the greatest extent possible, compatible with current AppleTalkimplementations and applications.  Multiple zones per network are nowsupported, and users can choose their machine's zone.  Benefits includeimproved network traffic and better router selection.  New calls and featureshave been implemented with this enhancement and are documented in this Note.</p><P><A HREF="#top">Back to top</A></P><a name="Section2"></a><h2>Are AppleTalk Phase 2 Drivers Present?</h2><p>So you want to use these new calls and features, but can you?  First, one needsto check to see if the node is running AppleTalk Phase 2.  There are two waysthis can be accomplished.  The easiest way is to make a <code>_SysEnvirons</code>call and check the returned <code>atDrvrVersNum</code> field.  If this byte isgreater than or equal to 53, then AppleTalk Phase 2 drivers are present.  If,for some reason, a <code>_SysEnvirons </code>call is not practical or otherwise notpossible, one can check 7 bytes off the device control entry for the .MPPdriver for a single byte, which is the driver version (actually the low byte ofthe <code>qFlags</code> field of <code>DCtlQHdr</code> in the DCE).  Again, if thisbyte is 53 or greater, AppleTalk Phase 2 is present, and the calls and featuresoutlined in this Note may be used.</p><h3>Calls to the .MPP Driver</h3><p>AppleTalk Phase 2 introduces many new variables, and we highly recommend thatyou use the new <code>GetAppleTalkInfo</code> call instead of looking at MPPglobals directly.  In addition, on a Macintosh running the AppleTalk InternetRouter software, there may be more than one .MPP driver present.  Theseadditional drivers can be found by walking through the unit table(<code>UTableBase</code> $11C) and looking for drivers named .MPP other than atunit slot 9.  Generally, the only port of interest to you is the user port,reflected in this call as <code>PortID</code> 0 with a <code>refnum</code> of -10.</p><h3>GetAppleTalkInfo</h3><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>Parameter Block    --&gt; 26    csCode    word    ; always GetAppleTalkInfo (258)    --&gt; 28    Version    word    ; requested info version    &lt;-- 30    VarsPtr    pointer    ; pointer to well known MPP vars    &lt;-- 34    DCEPtr    pointer    ; pointer to MPP DCE    &lt;-- 38    PortID    word    ; port number [0..7]    &lt;-- 40    Configuration    long    ; 32-bit configuration word    &lt;-- 44    SelfSend    word    ; non zero if SelfSend enabled    &lt;-- 46    NetLo    word    ; low value of network range    &lt;-- 48    NetHi    word    ; high value of network range    &lt;-- 50    OurAddr    long    ; our 24-bit AppleTalk address    &lt;-- 54    RouterAddr    long    ; 24-bit address of (last) router    &lt;-- 58    NumOfPHs    word    ; max. number of protocol handlers    &lt;-- 60    NumOfSkts    word    ; max. number of static sockets    &lt;-- 62    NumNBPEs    word    ; max. concurrent NBP requests    &lt;-- 64    NTQueue    pointer    ; pointer to registered name queue    &lt;-&gt; 68    *LAlength    word    ; length in bytes of data link addr    --&gt; 70    *LinkAddr    pointer    ; data link address returned    --&gt; 74    *ZoneName    pointer    ; zone name returned</pre>	</TD></TR></TABLE></CENTER><P>This call is provided to simplify the task of obtaining details about thecurrent AppleTalk network connection.  The following are the parameters whichthis call returns:</p><p><code>Version</code>    is passed by the caller.  The concept is similar to one used by<code>_SysEnvirons</code>, where a version ID is passed to the function to return arequested level of information.  If the driver cannot respond because thisnumber is too high, <code>paramErr</code> is returned.  The current version numberis 1.</p><p><code>VarsPtr</code>    is the pointer to AppleTalk variables.  This points to the wellknown <code>sysLapAddr</code> and read header area or RHA..  This pointer may notbe equal to $2D8 (<code>ABusVars</code>) for other than port 0.</p><p><code>DCEPtr</code>    is a pointer to the driver's device control entry. See the DeviceManager chapters of <i>Inside Macintosh</i> for details.</p><P><code>PortID</code>    is the port number, and it is always zero, unless a router isactive and a driver <code>refnum</code> other than -10 is used.</p><P><code>Configuration</code>    is a 32-bit word of configuration flags.  Currently only thefollowing bits are returned:</p><P>31 (<code>SrvAdrBit</code>)    is true if server node-ID was requested at open time.Note that even if server address is requested, it may be ignored by those ADEVswhich do not honor it (i.e., EtherTalk, TokenTalk, etc.).</p><P>30 (<code>RouterBit</code>)    is true if an AppleTalk Internet Router was loaded atsystem startup.  Note that a router may be loaded, but not active.</p><P>7 (<code>BadZoneHintBit</code>)    is true if the node's zone name hint is invalid,thus causing a default zone to be selected.</p><P>6 (<code>OneZoneBit</code>)    is true if only one zone is assigned to an extendednetwork.</p><P><code>SelfSend</code>    (the ability for a node to send packets to itself) is non-zero ifthis feature is currently enabled.</p><P><code>NetLo</code>    is the low value of the network range.  Non-extended networks alwayshave a range of exactly one network, if the network number is known.</p><P><code>NetHi</code>    is the high value of the network range.</p><P><code>OurAddr</code>    is the 24-bit AppleTalk network address of the node.  The mostsignificant byte is always zero.</p><P><code>RouterAddr</code>    is the 24-bit AppleTalk address of the router from which welast heard.  Users should always use this address when attempting tocommunicate directly with a router.</p><P><code>NumOfPHs</code>,    are maximum capacities for the driver.  They are number ofprotocol</p><P><code>NumOfSkts</code>, and    handlers, number of static sockets, and number ofconcurrent NBP</p><p><code>NumNBPEs</code>    requests allowed, respectively.</p><P><code>NTQueue</code>    is a pointer to the registered names table queue.  See <i>InsideMacintosh</i>, Volume II, The AppleTalk Manager, for NT Queue details.</p><P><code>LALength</code>    is passed by the caller to indicate how much (if any) of the datalink address is to be copied to a user-supplied buffer (pointed to by<code>LinkAddr</code>).  The actual length is returned by the driver.  If thecaller requests more bytes than the actual number, then data in the bufferafter the address is undefined.  The caller is responsible for providingsufficient buffer space.</p><P><code>LinkAddr</code>    is a pointer to a user-supplied buffer into which the data linkaddress data is copied.  If the pointer is <code>NIL</code>, no data iscopied.</p><P><code>ZoneName</code>    is a pointer to a user-supplied buffer into which the node'sstored zone name is copied.  If the pointer is <code>NIL</code>, no data is copied.The user buffer must be 33 bytes or more in size.</p><P><A HREF="#top">Back to top</A></P><a name="Section3"></a><h2>Calls to the .ATP Driver</h2><h3>KillAllGetReq</h3><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>Parameter Block    --&gt; 26    csCode    word    ; always KillAllGetReq (259)    --&gt; 28    atpSocket    byte    ; socket on which to kill all pending</pre>	</TD></TR></TABLE></CENTER><p><code>KillAllGetReq</code> aborts all outstanding <code>GetRequest</code> calls on thespecified socket and completes them with <code>reqAborted</code> errors (it doesnot close the specified socket, it only kills all pending <code>GetRequest</code>calls on that socket).  To kill all the <code>GetRequest</code> calls, simply passthe desired socket number in the <code>atpSocket</code> field.</p><P><code>cbNotFound</code>    control block not found            (-1102)</p><h3>Setting the TRel Timer in SendRequest Calls</h3><p>It is now possible to set the TRel timer in <code>SendRequest</code> or<code>NSendRequest </code>calls with ATP XO (exactly once) service so as not to belocked into the pre-AppleTalk Phase 2 time of 30 seconds.  This is done bysetting bit 2 in the <code>atpFlags</code> field to indicate to the driver that anextended parameter block is being used.  Make a standard <code>SendRequest</code>call, but add the timeout constant desired in the new <code>TRelTime</code> fieldbyte of the parameter block.  Both nodes must be running AppleTalk Phase 2 forthis feature to be supported.</p><p>The timeout constants are enumerated as follows in the lower three bits of the<code>TRelTime</code> ($32 offset) byte:</p><p>    000    $0    TRel timer set to 30 seconds<br>    001    $1    TRel timer set to one minute<br>    010    $2    TRel timer set to two minutes<br>    011    $3    TRel timer set to four minutes<br>    100    $4    TRel timer set to eight minutes</p><p>All other values are reserved.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    Parameter Block</pre>	</TD></TR></TABLE></CENTER><P><A HREF="#top">Back to top</A></P><a name="Section4"></a><h2>Name Binding Protocol (NBP) Change:  Wildcard Lookup</h2><p>In AppleTalk Phase 2, NBP is enhanced to provide additional wildcard support.The double tilde (~), $C5, is now reserved in the object name and type stringsand used in a lookup to mean a match of zero or more characters.  Thus "~cliff"matches "cliff," "the cliff," "grazing off the cliff," etc., and "123~456"matches "123456," "123zz456," etc.  At most one ~ is allowed in any string.  Asingle ~ has the same meaning as a single =, which also must continue to beaccepted.  The ~ has no special meaning in zone names.  Clients of NBP must beaware that "old" (pre-AppleTalk Phase 2) nodes may not process this newwildcard feature correctly.  This feature should probably only be used when itis known that the responding devices are running Phase 2 drivers as well.</p><P><A HREF="#top">Back to top</A></P><a name="Section5"></a><h2>Obtaining Zone Information Using the New .XPP Driver Calls</h2><p>Previously, Zone Information Protocol (ZIP) functions were accomplished viadirect ATP calls to the local router.  It was rather nasty business, having tomess with the <code>ATPUserData</code> on subsequent calls to retain stateinformation.  We now recommend the use of the following XPP driver calls toaccess ZIP.  Old ATP calls will continue to be supported for compatibility.  Itshould also be noted that with Phase 2 drivers present, the .XPP driver isautomatically opened by MPP.</p><h3>GetZoneList</h3><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>Parameter Block    --&gt; 26    csCode    word    ; always xCall (246)    --&gt; 28    xppSubCode    word    ; always zipGetZoneList (6)    --&gt; 30    xppTimeout    byte    ; retry interval (seconds)    --&gt; 31    xppRetry    byte    ; retry count        32    &lt;unused&gt;    word    ; word space for rent.  see the super.    --&gt; 34    zipBuffPtr    pointer    ; pointer to buffer (must be 578 bytes)    &lt;-- 38    zipNumZones    word    ; no. of zone names in this response    &lt;-- 40    zipLastFlag    byte    ; non-zero if no more zones        41    &lt;unused&gt;    byte    ; filler    --&gt; 42    ziplnfoField    70 bytes    ; on initial call, set first word to zero</pre>	</TD></TR></TABLE></CENTER><p><code>GetZoneList</code><b> </b>is used to obtain a complete list of zones on theinternet.<b>  </b><code>ZipBuffPtr</code> points to a buffer that.must be 578 bytes(<code>ATPMaxData</code>) in length.  The actual number of zone names returned inthe buffer is returned in <code>zipNumZones</code>. The fields <code>xppTimeout</code>and <code>xppRetry</code> contain the ATP retry interval (in seconds) and count,respectively.</p><p>The first time this call is made, the first word of the <code>ziplnfoField</code>should be set to zero.  When the call completes, <code>zipLastFlag</code> isnon-zero if all the zone names fit into the buffer.  If not, the call should bemade again immediately, without changing <code>zipInfoField</code> (it containsstate information needed to get the next part of the list).  The call should berepeated until <code>zipLastFlag</code> is non-zero.  The 70-byte<code>zipInfoField</code> must always be allocated at the end of the parameterblock.</p><p>Result codes    <code>noErr</code>        No Error                    (0)</p><P><code>noBridgeErr</code>    No router is available                (-93)</p><P><code>ReqFailed</code>        SendRequest failed; retry count exceeded    (-1096)</p><p>Following are short examples of using <code>GetZoneList</code>.</p><h3>Pascal</h3><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre> const{ csCodes for new .XPP driver calls }  xCall = 246;{ xppSubCodes }  zipGetLocalZones = 5;  zipGetZoneList = 6;  zipGetMyZone = 7; type{ offsets for xCall queue elements  }   xCallParam = packed record    qLink: QElemPtr;    qType: INTEGER;    ioTrap: INTEGER;    ioCmdAddr: Ptr;    ioCompletion: ProcPtr;    ioResult: OsErr;    ioNamePtr: StringPtr;    ioVRefNum: INTEGER;    ioRefNum: INTEGER;    csCode: INTEGER;    xppSubCode: INTEGER;    xppTimeOut: Byte;    xppRetry: Byte;    filler: INTEGER;    zipBuffPtr: Ptr;    zipNumZones: INTEGER;    zipLastFlag: INTEGER;    zipInfoField: packed array[1..70] of Byte;   end;procedure doGetZoneListPhs2;type   XCallParamPtr = ^XCallParam;var   xpb: XCallParamPtr;   resultCode: OSErr;   zoneBuffer, theBufferPtr: Ptr;   totalZones: integer;begin   xpb := XCallParamPtr(NewPtr(sizeof(XCallParam)));   zoneBuffer := NewPtr(33 * 100);    { size of maxstring * 100 zones }   theBufferPtr := NewPtr(578);    { size of atpMaxData }   xpb^.zipInfoField[1] := 0;    { ALWAYS 0 on first call.  contains state info      on subsequent calls }   xpb^.zipInfoField[2] := 0;    { ALWAYS 0 on first call.  contains state info      on subsequent calls }   xpb^.ioRefNum := XPPRefNum;        { driver refNum -41 }   xpb^.csCode := xCall;   xpb^.xppSubCode := zipGetZoneList;   xpb^.xppTimeOut := 3;   xpb^.xppRetry := 4;   xpb^.zipBuffPtr := Ptr(theBufferPtr);    { this buffer will be filled with }                        (  packed zone names }{ initialization for loop }   xpb^.zipLastFlag := 0;   totalZones := 0;   resultCode := 0;{ loop until zipLastFlag is non-zero or an error occurs }   while ((xpb^.zipLastFlag = 0) and (resultCode = 0)) do   begin   resultCode := PBControl(ParmBlkPtr(xpb), false);   if (resultCode = noErr) then     begin       totalZones := xpb^.zipNumZones + totalZones;       { you can now copy the zone names into the zoneBuffer }     end;   end;   DisposPtr(theBufferPtr);   DisposPtr(zoneBuffer);   DisposPtr(Ptr(xpb));</pre>	</TD></TR></TABLE></CENTER><BR><h3>C</h3><BR><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>/*csCodes for new .XPP driver calls*/#define xCall            246/*xppSubCodes*/#define zipGetLocalZones     5#define zipGetZoneList    6#define zipGetMyZone     7/*offsets for xCall queue elements*/typedef struct    {    QElemPtr            qLink;    short            qType;    short            ioTrap;    Ptr            ioCmdAddr;    ProcPtr            ioCompletion;    OsErr            ioResult;    StringPtr            ioNamePtr;    short            ioVRefNum;    short            ioRefNum;    short            csCode;    short            xppSubCode;    unsigned char        xppTimeOut;    unsigned char        xppRetry;    short            filler;    Ptr            zipBuffPtr;    short            zipNumZones;    short            zipLastFlag;    unsigned char        zipInfoField[70];} xCallParam;doGetZoneListPhs2(){    xCallParam        xpb;    OSErr            resultCode = 0;    Ptr            zoneBuffer, theBufferPtr;    short            totalZones = 0;    zoneBuffer = NewPtr(33*100);        /* size of maxstring * 100 zones */    theBufferPtr = NewPtr(578);        /* size of atpMaxData */    xpb.zipInfoField[0] = 0;        /* ALWAYS 0 on first call.  containsstate info on subsequent calls */    xpb.zipInfoField[1] = 0;        /* ALWAYS 0 on first call.  containsstate info on subsequent calls */    /* initialization for loop */    xpb.zipLastFlag = 0;    xpb.ioCRefNum = XPPRefNum;        /* driver refNum -41 */    xpb.csCode = xCall;    xpb.xppSubCode = zipGetZoneList;    xpb.xppTimeOut = 3;    xpb.xppRetry = 4;    xpb.zipBuffPtr = (Ptr) theBufferPtr;    /* this buffer will be filled with                        the packed zone names */    /* loop until zipLastFlag is non-zero or an error occurs */    while(xpb.zipLastFlag == 0 &amp;&amp; resultCode == 0) {        resultCode = PBControl(&amp;xpb, false);        if(resultCode == noErr) {            totalZones += xpb.zipNumZones;            /* you can now copy the zone names into the zoneBuffer */        }    DisposPtr(theBufferPtr);    DisposPtr(zoneBuffer);    }}</pre>	</TD></TR></TABLE></CENTER><BR><h3>GetLocalZones</h3><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>Parameter Block    --&gt; 26    csCode    word    ; always xCall (246)    --&gt; 28    xppSubCode    word    ; always zipGetLocalZones (5)    --&gt; 30    xppTimeout    byte    ; retry interval (seconds)    --&gt; 31    xppRetry    byte    ; retry count        32    &lt;unused&gt;    word    ; filler    --&gt; 34    zipBuffPtr    pointer    ; pointer to buffer (must be 578 bytes)    &lt;-- 38    zipNumZones    word    ; no. of zone names in this response    &lt;-- 40    zipLastFlag    byte    ; non-zero if no more zones        41    &lt;unused&gt;    byte    ; filler    --&gt; 42    ziplnfoField    70 bytes    ; on initial call, set first word to zero</pre>	</TD></TR></TABLE></CENTER><p>This call has the same format and procedures as <code>GetZoneList</code>, thedifference being that <code>GetLocalZones</code> returns a list of zone namescurrently defined only on the node's network cable rather than the entirenetwork.  The 70-byte <code>zipInfoField</code> must always be allocated at the endof the parameter block.</p><p>Result codes    <code>noErr</code>        No Error                    (0)</p><P><code>noBridgeErr</code>    No router is available                (-93)</p><P><code>ReqFailed</code>        SendRequest failed; retry count exceeded    (-1096)</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The examples for <code>GetZoneList</code> will also work for<code>GetLocalZones</code> if you substitute the <code>xppSubCode</code>.</P></TD></TR></TABLE></CENTER><BR><h3>GetMyZone</h3><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>Parameter Block    --&gt; 26    csCode     word    ; always xCall (246)    --&gt; 28    xppSubCode     word    ; always zipGetMyZone (7)    --&gt; 34    zipBuffPtr     pointer    ; pointer to buffer (must be 33 bytes)    --&gt; 42    ziplnfoField     70 bytes    ; first word must be set to zero on everycall</pre>	</TD></TR></TABLE></CENTER><p><code>GetMyZone</code> returns the node's AppleTalk zone name.  This is the zone inwhich all of the node's network visible entities are registered.<code>ZipBuffPtr</code> points to a buffer that must be 33 bytes in length.  If<code>noBridgeErr</code> is returned by the call, there is no internet, and thezone name is effectively an asterisk (*).  The 70-byte <code>zipInfoField</code>must always be allocated at the end of the parameter block.</p><p>Result codes    <code>noErr</code>        No Error                    (0)</p><P><code>ReqFailed</code>        SendRequest failed; retry count exceeded    (-1096)</p><p>Following are short examples of using <code>GetMyZone</code>.</p><h3>Pascal</h3><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>procedure getMyZonePhs2;var   xpb:xCallParam;   resultCode :OSErr;   myZoneNameBuffer:Ptr;begin   myZoneNameBuffer  := NewPtr(33);   xpb.ioCRefNum := xppRefNum;   xpb.csCode := xCall;   xpb.xppSubCode := zipGetMyZone;   xpb.zipBuffPtr := myZoneNameBuffer;   xpb.zipInfoField[1] := 0;        { ALWAYS 0 }   xpb.zipInfoField[2] := 0;        { ALWAYS 0 }   resultCode := PBControl(@xpb, false);</pre>	</TD></TR></TABLE></CENTER><BR><h3>C</h3><BR><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>getMyZonePhs2(){    xCallParam    xpb;    OSErr        resultCode;    Ptr        myZoneNameBuffer;    myZoneNameBuffer  := NewPtr(33);    xpb.ioCRefNum = xppRefNum;    xpb.csCode = xCall;    xpb.xppSubCode = zipGetMyZone;    xpb.zipBuffPtr = (Ptr) myZoneNameBuffer;    xpb.zipInfoField[0] = 0;        /* ALWAYS 0 */    xpb.zipInfoField[1] = 0;        /* ALWAYS 0 */    resultCode = PBControl(&amp;xpb, false);</pre>	</TD></TR></TABLE></CENTER><P><A HREF="#top">Back to top</A></P><a name="Section6"></a><h2>Potential Nastiness</h2><p>When running on a node with Phase 2 compatible drivers, we always recommendusing the .XPP calls outlined in the previous section.  Care was taken to keepbackward compatibility with the already existing ATP ZIP calls (they are beingtrapped out with the Phase 2 drivers), but there are problems about which youshould be aware.</p><ul type="disc">	<li>Do not rely on checking the TID (transaction ID validity bit) or other bits in the <code>atpFlags</code>, as some of you have been doing.  The <code>atpFlags</code> are not guaranteed to be correct on an ATP ZIP call with a Phase 2 driver present.</li>	<li>Do not repeatedly stuff the router address back into the <code>ATPParamBlock</code> on subsequent ATP ZIP <code>GetZoneList</code> calls.  There exists the possibility of concurrent <code>GetZoneList</code> calls being made by other tasks and wrong router addresses being used (a small possibility yes, but it does exist).</li></ul><P><A HREF="#top">Back to top</A></P><a name="Section7"></a><h2>The AppleTalk Transition Queue</h2><p>To keep applications and other resident processes on the Macintosh informed ofAppleTalk events, such as the opening and closing of AppleTalk drivers, a newtransition queue has been implemented.  Processes can register themselves withthe AppleTalk Transition Queue, and when a significant event occurs, they willbe notified of this fact.  Each transition queue element has the following MPWassembly-language format:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>AeQentry    RECORD        0QLink        DS.L        1    ; link to next recordQType        DS.W        1    ; unusedCallAddr    DS.L        1    ; pointer to task record</pre>	</TD></TR></TABLE></CENTER><p>Three calls have been provided in the LAP Manager to add an entry, remove anentry, and return a pointer to the AppleTalk event queue header.  The methodfor making calls to the LAP Manager is explained in the following section.  Thequeue is maintained by the LAP Manager, so it can be active even when AppleTalk(MPP) is not.</p><P><A HREF="#top">Back to top</A></P><a name="Section8"></a><h2>Making a LAP Manager Call</h2><p>The LAP Manager is installed in the system heap at startup time, before theAppleTalk Manager opens the .MPP driver (hence, the inclusion of the AppleTalkTransition Queue in LAP Manager rather than under .MPP).  Calls are made to theLAP Manager by jumping through a low-memory location, with register <code>D0</code>equal to a dispatch code that identifies the function.  The exact sequenceis:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>              MOVEQ     #Code,D0        ; D0 = ID code of wanted LAP call              MOVE.L    LAPMgrPtr,An    ; An -&gt; start of LAP manager (from $B18)              JSR       LAPMgrCall(An)  ; Call the LAP manager at entry pointLAPMgrPtr     EQU       $B18            ; This points to our start (more                                        ; commonly known as ATalkHk2)LAPMgrCall    EQU       2               ; Offset to make LAP manager</pre>	</TD></TR></TABLE></CENTER><P><A HREF="#top">Back to top</A></P><a name="Section9"></a><h2>The AppleTalk Transition Queue LAP Calls</h2><P><B>LAddAEQ</b> (<code>D0</code>=23)</p><P>Call:        <code>A0--&gt;</code>        Entry to be added to the AppleTalk event queue.</p><p>The <code>LAddAEQ</code> call adds an entry, pointed to by <code>A0</code>, to theAppleTalk event queue.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    MOVEQ    #LAddAEQ,D0    ; D0 = 23 code of LAddAEQ LAP call    MOVE.L    LAPMgrPtr,An    ; An -&gt; start of LAP manager (from $B18)</pre>	</TD></TR></TABLE></CENTER><B>LRmvAEQ</b> (<code>D0</code>=24)<p>Call:        <code>A0--&gt;</code>        Entry to be removed from the AppleTalk event queue.</p><p>The <code>LRmvAEQ</code> call removes an entry, pointed to by <code>A0</code>, from theAppleTalk event queue.</p><p><code>    MOVEQ    #LRmvAEQ,D0    ; D0 = 24 code of LRmvAEQ LAP call    MOVE.L    LAPMgrPtr,An    ; An -&gt; start of LAP manager (from $B18)    JSR    LAPMgrCall(An)    ; Call the LAP manager at entry point</code></p><P><B>LGetAEQ</b> (<code>D0</code>=25)</p><P>Return:    <code>A1--&gt;</code>        Pointer to the AppleTalk event queue header.</p><p>The <code>LGetAEQ</code> call returns a pointer in <code>A1</code> to the AppleTalkevent queue header, previously described.</p><p><code>    MOVEQ    #LGetAEQ,D0    ; D0 = 25 code of LGetAEQ LAP call    MOVE.L    LAPMgrPtr,An    ; An -&gt; start of LAP manager (from $B18)    JSR    LAPMgrCall(An)    ; Call the LAP manager at entry point</code></p><P><A HREF="#top">Back to top</A></P><a name="Section10"></a><h2>The Transitions</h2><p>Each process is called at <code>CallAddr</code> when any significant transitionsoccur.  A value is passed in, which indicates the nature of the event.Additional parameters may also be passed and a pointer to the task's queueelement is also passed.  This is provided so processes may append their owndata structures (e.g., a globals pointer) at the end of the task record, whichcan be referenced when they are called.  Processes should follow the MPW Cregister conventions.  Registers <code>D0</code>, <code>D1</code>, <code>D2</code>,<code>A0</code>, and <code>A1</code> are scratch registers that are not preserved by Cfunctions.  The arguments passed to the process should be left on the stack,since the calling routine removes them.  All other registers should bepreserved.</p><h3>The Open Transition</h3><p>For AppleTalk open transitions, the process has the following interface:</p><p>From assembly language, the stack upon calling looks as follows:</p><p><code>OpenEvent    RECORD        0ReturnAddr    DS.L        1    ; address of caller    theEvent    DS.L        1    ; = 0 ; ID of Open transactionaqe        DS.L        1    ; pointer to task recordSlotDevParam    DS.L        1    ; pointer to Open parameter block        ENDR</code></p><p>This routine is called <b>only</b> when the open routine for .MPP executessuccessfully.  Every entry in the transition queue is called in the same orderthat the entries were added to the queue.  If AppleTalk is already open and an<code>_Open</code> call is made, no process is called.  The process should return afunction result in <code>D0</code>, which is currently ignored.</p><p>A pointer to the open request parameter block is passed to the open eventprocess for information only (i.e., the event process may not prevent AppleTalkopen calls).  Those fields which are of interest are<code>OpenPB-&gt;ioPermssn</code>, passed by the caller, and<code>OpenPB-&gt;ioMix</code>, which is both passed by the caller and updated bythe .MPP open (see <i>Inside Macintosh</i>, Volume V, The AppleTalk Manager).</p><h3>The Close Transition</h3><p>For AppleTalk close transitions, the process has the following interface:</p><p>From assembly language, the stack upon calling looks as follows:</p><p><code>CloseEvent    RECORD        0ReturnAddr    DS.L        1    ; address of callertheEvent    DS.L        1    ; = 2 ; ID of Close transactionaqe        DS.L        1    ; pointer to task record        ENDR</code></p><p>The process is being told that AppleTalk is closing, which gives the process anopportunity to close gracefully.  Every entry in the event queue is called, oneafter the other, in the same order that the entries were added to the queue.The close action cannot be cancelled.  The process should return a functionresult in <code>D0</code>, which is currently ignored.</p><h3>The ClosePrep and CancelClosePrep Transitions</h3><p>The <code>AtalkClosePrep</code> and the <code>CancelAtalkClosePrep</code> control callsare used by various elements of the System, such as the Chooser, to inform orquery AppleTalk clients of the closing of network drivers.  For example, on amachine equipped to go to sleep or to wake up, the <code>_Sleep</code><b> </b>trapis used by such entities as sleeptimer, Finder, and Shutdown to informAppleTalk clients that  it is desirable for the network driver (.MPP) to beclosed.  The <code>_Sleep</code><b> </b>trap may be trying to do any of thefollowing three things: request permission for sleep, alert for impendingsleep, or inform that wake up is underway.  The sleep request calls thefollowing two .MPP control calls; these calls are made before sleep queueprocedures are called.</p><p>The first control call, <code>AtalkClosePrep</code>, is used to inform or queryAppleTalk clients that the network driver might be closed in the very nearfuture.  The call has the following interface:</p><P><b>AtalkClosePrep</b> (<code>csCode = 259</code>)</p><p><code>Parameter Block        --&gt; 26    csCode    word    ;always AtalkClosePrep        &lt;-- 28    clientName    pointer    ;-&gt; name of client using driver</code></p><p>Result codes</p><P>    <code>noErr</code>        The AppleTalk network driver (.MPP) may be closed</p><P><code>closeErr</code>        The AppleTalk network driver (.MPP) may not be closed</p><p><code>clientName</code> is a pointer to an identifying string that is returned only ifthe result is <code>closeErr</code>.  Note that the pointer may be <code>NIL</code> inthis case, while the pointer is always <code>NIL</code> if the return code is<code>noErr</code>.</p><p>All tasks in the AppleTalk Transition Queue are called with the event<code>ClosePrep</code>.  The tasks can prevent driver closure with a negativeresponse to the event call.  Each task is called with the followinginterface:</p><p>From assembly language, the stack upon calling looks as follows:</p><p><code>ClosePrep        RECORD        0    ;top of the stackReturnAddr        DS.L        1    ;addr of callertheEvent        DS.L        1    ;=3aqe            DS.L        1    ;-&gt;task rec.clientName        DS.L        1    ;ptr. to ptr. to name of client            ENDR</code></p><p>For this event, <code>theEvent = 3</code>, and the task is being <b>both</b>informed and asked if closing the network driver is acceptable.  If driverclosure is acceptable, the task need only to reply affirmative (<code>D0 =0</code>), or if not acceptable, deny the request (<code>D0 != 0</code>).  The taskmay use the event as an opportunity to "prepare to die" or may simply respond.For example, a task may prevent further sessions from forming while waiting forthe actual close event.</p><p><code>clientName</code> is a pointer to a field in the .MPP control call parameterblock where the task may optionally store a string address.  This stringidentifies the client who has AppleTalk in use and is denying the request toclose it.  This string may be used in a dialog to inform the user to takeappropriate action or explain why the requested action could not beperformed.</p><p>If any task responds negatively, no subsequent tasks are called.  Any taskscalled prior to the one that denied a query are recalled with another event,<code>CancelClosePrep </code>(described below), enabling them to "undo preparationsto die," and the control call then completes with a <code>closeErr</code> error.</p><p>From assembly language, the stack upon calling looks as follows:</p><p><code>CancelClosePrep    RECORD        0    ;top of the stackReturnAddr        DS.L        1    ;addr of callertheEvent        DS.L        1    ;=4aqe            DS.L        1    ;-&gt;task rec.            ENDR</code></p><p>For this event, <code>theEvent = 4</code>, and the task is being informed thatalthough it has recently approved a request to close the network driver, asubsequent task in the AppleTalk Transition Queue has denied permission.  Thisevent permits the task to undo any processing that may have been performed inanticipation of the network driver being closed.  The process should return afunction result in <code>D0</code>, which is currently ignored.</p><p>The second new control call, <code>CancelAtalkClosePrep</code>, is used to undo theeffects of a successful <code>AtalkClosePrep</code> control call.  Even though allqueried tasks in the AppleTalk Transition Queue approved of network driverclosure, other conditions may exist after making the <code>AtalkClosePrep</code>control call which prohibit network driver closure.  In this case, it isnecessary to recall all tasks to undo any processing that may have beenperformed in anticipation of the network driver being closed.  The control callto do this has the following interface:</p><P><B>CancelAtalkClosePrep</b> (<code>csCode = 260</code>)</p><p><code>Parameter Block    --&gt; 26    csCode    word    ;always CancelAtalkClosePrep</code></p><p>Result codes    <code>noErr</code>        Nothing could possibly go wrong</p><p>All tasks in the AppleTalk Transition Queue are called with the event<code>CancelClosePrep</code> as described above.</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The use of the low-memory global <code>ChooserBits</code> ($946) is nolonger an acceptable means of preventing AppleTalk from closing when AppleTalkPhase 2 is present.  Transitions other than defined above must be ignored andare reserved for future implementation.  In the future transitions may bedefined for notifying processes when a change in zone name occurs.</P></TD></TR></TABLE></CENTER><BR><P><A HREF="#top">Back to top</A></P><a name="Section11"></a><h2>Potential Compatibility Problems</h2><h3>Using DDP and Talking to Routers</h3><p>If, for some reason, you need to talk to any router via DDP, always use the<code>GetAppleTalkInfo</code> call outlined in this Note to get the router's actual24-bit address.</p><p>The <code>WriteLAP</code> function (<code>csCode </code>= 243) to the .MPP driver is nolonger supported, since a node is no longer identified only by its eight-bit(LAP) node ID.</p><p>On a Macintosh running the AppleTalk Internet Router software, the<code>SelfSend</code> flag is always set, so if you try to clear this flag usingthe <code>PSetSelfSend</code> call (Inside Macintosh, Volume V-514), you will getan error.</p><P><A HREF="#top">Back to top</A></P><a name="References"></a><h2>References</h2><P>Inside AppleTalk</p><P>Inside Macintosh, Volume II, The AppleTalk Manager</p><P>Inside Macintosh, Volume V, The AppleTalk Manager</p><P>EtherTalk and Alternate AppleTalk Connections Reference, May 5, 1989--Draft(DTS)</p><P>AppleTalk Phase 2 Protocol Specification (DTS)</p><P>Macintosh Portable Developer Notes (DTS)</p>                         <P><A HREF="#top">Back to top</A></P>                           <a name="Changes"></a> <H2>Change History</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH=544>            <TR>               <td width=100 align=left>                  <P ALIGN=center>01-August-1989</P>               </TD>               <td align="left">                  <P>Incorporated the <code>ClosePrep</code> and<code>CancelClosePrep</code> transitions and the new control calls to the .MPPdriver.</P>               </TD>            </TR>            </table>         <P><A NAME=Downloads></A></P>                  <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (52K)</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/nw_03.pdf">Download</A></P>               </TD>            </TR>                     </TABLE>         <BR>         <P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/nw/nw_03.html%3Fid%3DDTS10002545-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/nw/nw_03.html%3Fid%3DDTS10002545-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/nw/nw_03.html%3Fid%3DDTS10002545-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>