#include <stdio.h>#include <stdlib.h>#include <stddef.h> /* needed for offsetof */#include <string.h>#include <console.h>#include <sioux.h>#include <PLStringFuncs.h>#include "AppleShareRegistry.h"#include "AppleShareFileServerRegistry.h"#define PGP_MACINTOSH 1#include "pgpErrors.h"#include "pgpKeys.h"#include "pgpMemoryMgr.h"#include "pgpUtilities.h"void BuildObjectSpecByShortID(OAMObjectSpec *obj, OAMShortObjectSpec id){	memset(obj, 0, sizeof(OAMObjectSpec));	obj->specType = kOAMObjectSpecByShortID;	obj->u.shortID = id;}void BuildObjectSpecByNameType(OAMObjectSpec *obj, StringPtr name, OAMType type){	short len = 0;		memset(obj, 0, sizeof(OAMObjectSpec));	obj->specType = kOAMObjectSpecByNameType;	obj->objectType = type;	len = *name + 1;	memcpy(obj->u.name, name, len);}void DisplayAttr(OAMAttributeDescriptor *attr){	if (attr && attr->attributeSignature) {		printf("---------------------------------\n");//		printf("attr->status = %d\n",attr->status );//		printf("attr->offset = %d\n",attr->offset );//		printf("attr->actSize = %d\n",attr->actSize );//		printf("attr->bufferDescriptor.bufferLen = %d\n",attr->bufferDescriptor.bufferLen );//		printf("attr->bufferDescriptor.actCount = %d\n",attr->bufferDescriptor.actCount );		if (attr->status == 0)		{		switch (attr->attributeSignature) {			case kOAMBasic:				switch (attr->attributeType) {						case kOAMName:						{							 StringPtr name = (StringPtr)attr->bufferDescriptor.buffer;							p2cstr(name);							printf("Name = %s",name);						}						break;						case kOAMInternetName:						{							StringPtr name = (StringPtr)attr->bufferDescriptor.buffer;							p2cstr(name);							printf("Name = %s",name);						}						break;						case kOAMShortID:							printf("ID = %d",*((UInt32*)attr->bufferDescriptor.buffer));						break;							case kOAMType:							printf("Type = %.4s",(char*)attr->bufferDescriptor.buffer);						break;					};			break;			case kOAMUser:				switch (attr->attributeType) {						case kOAMUserFlags:							printf("userFlags = 0x%x",*((UInt16*)attr->bufferDescriptor.buffer));						break;							case kOAMUserComment:						{							printf("comment = %#s",(StringPtr)attr->bufferDescriptor.buffer);						}						break;						case kOAMPasswordLen:							printf("pwdLen = %d",*((UInt8*)attr->bufferDescriptor.buffer));						break;						case kOAMLastLogin:						{							DateTimeRec	date = {};							SecondsToDate(*(UInt32*)attr->bufferDescriptor.buffer, &date);							printf("kLastLogin: %d/%d/%d", date.month, date.day, date.year);						}						break;				};							break;						case kOAMService:				switch (attr->attributeType) {						case kOAMShortStatus:							printf("shortStatus = 0x%x",*((UInt32*)attr->bufferDescriptor.buffer));						break;						/*						case kOAMDetailedStatus:							printf("detailedStatus = 0x%x",*((UInt32*)attr->bufferDescriptor.buffer));						break;							*/						case kOAMServiceFlags:							printf("kServiceFlags = 0x%x",*((UInt32*)attr->bufferDescriptor.buffer));						break;					};			break;						case kOAMMachine:				switch (attr->attributeType) {						case kOAMGuestProgramLinking:							printf("kGuestProgramLinking = 0x%x",*((UInt8*)attr->bufferDescriptor.buffer));						break;							case kOAMNoGuestAccess:							printf("kNoGuestAccess = 0x%x",*((UInt8*)attr->bufferDescriptor.buffer));						break;							case kOAMProgramLinking:							printf("kProgramLinking = 0x%x",*((UInt8*)attr->bufferDescriptor.buffer));						break;							case kOAMServerName:							printf("name = %#s",(StringPtr)attr->bufferDescriptor.buffer);						break;							case kOAMMultihoming:							printf("kMultihoming = 0x%x",*((UInt8*)attr->bufferDescriptor.buffer));						break;							case kOAMNoSavePassword:							printf("kNoSavePassword = 0x%x",*((UInt8*)attr->bufferDescriptor.buffer));						break;							case kOAMMinPasswordLen:							printf("kMinPasswordLen = 0x%x",*((UInt8*)attr->bufferDescriptor.buffer));						break;							case kOAMMaxBadLogins:							printf("kMaxBadLogins = %d",*((UInt16*)attr->bufferDescriptor.buffer));						break;							case kOAMDefaultShutdown:							printf("kDefaultShutdown = %d",*((UInt16*)attr->bufferDescriptor.buffer));						break;							case kOAMUniqueID:							printf("kUniqueID = %d",*((UInt32*)attr->bufferDescriptor.buffer));												break;				};			break;			case kOAMGestalt:				printf("selector: %.4s response: %X", (char*)&attr->attributeType, *((SInt32*)attr->bufferDescriptor.buffer));			break;								}			printf(" <status, len> = <%d, %d> ",attr->status,attr->bufferDescriptor.actCount );		printf("\n---------------------------------\n");				}		}}void MyListAllUserNames(OAMSessionID sess){		OAMStatus			err = noErr;	OAMIterationSpec	iter;	UInt32				maxToGet	= 15;	OAMType				typeList[2] = {kOAMUser,0};	char				bd_buffer[4096] = {};	char				iter_buffer[512] = {};	OAMBufferDescriptor	bd	= {};	OAMAttributeDescriptor iter_attr[2] = {};	Str31				userName = {};	int 				userCount = 0;		/* set up buffer descriptor */	bd.buffer	= bd_buffer;	bd.bufferLen = sizeof(bd_buffer);	bd.actCount	= 0;		/* set up iter spec */	memset(&iter, 0 , sizeof(iter));	iter.iterationType = kOAMIterObjects;	iter.typeList	= typeList;	iter.iterationFlags = kOAMIterByIndex;	iter.u.startingIndex = 1;	iter.maxToGet = maxToGet;	/* set up iter_attr */	iter_attr[0].attributeSignature = kOAMBasic; 	iter_attr[0].attributeType = kOAMName;  	iter_attr[0].bufferDescriptor.buffer = userName;	iter_attr[0].bufferDescriptor.bufferLen = sizeof(iter_buffer);	iter_attr[0].bufferDescriptor.actCount = 0;	/* null terminate array of attribute descriptors */ 	iter_attr[1].attributeSignature = NULL;		do	{		err = OAMIterate(sess, &iter, iter_attr, &bd, NULL);				if(!err) {			OAMObjectSpec obj = {};			OAMParseInfo parseInfo;			int			attrIndex;						memset(&parseInfo, 0, sizeof(OAMParseInfo));			err = OAMParseAttributeBuffer(&bd, iter_attr, &parseInfo);			 					while(OAMParseGetNextObject(&parseInfo, &obj) != kOAMParseDone) {				printf("id = %d type = %s\n", obj.u.shortID, (char*)&obj.objectType);				for ( attrIndex = 0; ; attrIndex++)				{					if (OAMParseGetNextAttribute(&parseInfo, &iter_attr[attrIndex]) != kOAMParseDone)						DisplayAttr(&iter_attr[attrIndex]);					else						break;				}				userCount++;			}			iter.u.startingIndex += maxToGet;		}	} while (!err && iter.more );	printf("userCount(%d)\n",userCount);}OAMStatus MyGetMachineName(OAMSessionID sess, StringPtr machineName){	OAMStatus		err = noErr;	OAMObjectSpec	machineObj;		OAMAttributeDescriptor myAttrDesc[2] = {};		memset(&myAttrDesc, 0, sizeof(myAttrDesc));		myAttrDesc[0].attributeSignature = kOAMMachine;	myAttrDesc[0].attributeType = kOAMServerName;	myAttrDesc[0].bufferDescriptor.buffer = machineName;	myAttrDesc[0].bufferDescriptor.bufferLen = sizeof(Str31);	myAttrDesc[0].bufferDescriptor.actCount = sizeof(Str31);	/* null terminate array of attribute descriptors */	myAttrDesc[1].attributeSignature = NULL;	BuildObjectSpecByShortID(&machineObj, kOAMMachineShortID);		err = OAMGetAttribute(sess, &machineObj,  myAttrDesc, NULL);	return err;}void MyListRegistryAgents(unsigned char *  name, unsigned char * zone){	UInt32				numInBuffer	= 0;	UInt32				numFound	= 0;	OAMStatus			err			= noErr;	char				buffer[2048];	OAMBufferDescriptor	lookup_bd;	OAMServerLocator*	loc			= NULL;	int					loc_size	= offsetof(OAMServerLocator,protSpecific) + sizeof(Str32);	OAMServerSpec		serverSpec;			int					serverIndex;		/* set up buffer descriptor */	lookup_bd.buffer	= buffer;	lookup_bd.bufferLen	= sizeof(buffer);	lookup_bd.actCount	= 0;		/* Build AppleTalk OAMServerLocator */	loc = (OAMServerLocator *) NewPtr(loc_size);	memset(loc, 0, loc_size);	loc->specSize = loc_size;	loc->protType = kOAMLocatorAppletalk;	memcpy (loc->name, name, sizeof(Str32));				memcpy (loc->protSpecific, zone, sizeof(Str32));		 	err = OAMFindServer(loc, &lookup_bd, &numInBuffer, &numFound, NULL);	printf("Found %d AppleShare Registry Agent(s).\n", numFound);		for (serverIndex = 1; serverIndex<=numInBuffer; serverIndex++)	{		err = OAMFindServerExtract(&lookup_bd, serverIndex,&serverSpec);		p2cstr(serverSpec.name);		printf("%s\n", serverSpec.name);	}} OAMSessionID MyOpenSession(Str31 serverName, Str31 zoneName){	OAMStatus 		err = noErr;	OAMSessionID 	sessID = 0;	UInt32 			numInBuffer = 0;	UInt32 			numFound = 0;	OAMServerLocator *loc;	OAMServerSpec 	server;	UInt32 			loc_size= offsetof(OAMServerLocator,protSpecific) + sizeof(Str32);	/* set up the server locator */	loc = (OAMServerLocator *)new char [loc_size];	/* build the AppleTalk OAMServerLocator */	memset(loc, 0, loc_size);	loc->specSize = loc_size;	loc->protType = kOAMLocatorAppletalk;	memcpy (loc->name, serverName, sizeof(Str32));	memcpy (loc->protSpecific, zoneName, sizeof(Str32));	/* set up buffer descriptor */	char buffer[512]= {};	OAMBufferDescriptor	lookup_bd  = { buffer, sizeof(buffer), 0};	/* set up the server spec */	memset(&server, 0, sizeof(OAMServerSpec));	 	err = OAMFindServer(loc, &lookup_bd, &numInBuffer, &numFound, NULL); 	if(!err && numFound != 0) 	{		err = OAMFindServerExtract(&lookup_bd, 1, &server);		err = OAMOpenSession(&server, &sessID, NULL);		printf("OAMOpenSession: %d \n", err);		if (err == noErr) 		{			printf("sessionID = %d\n", sessID);		}	} else		printf("Server Not Found\n");	return sessID;}OAMStatus MyAuthenticate(OAMSessionID sess, StringPtr name, StringPtr password){		OAMStatus		err = noErr;	OAMObjectSpec	obj;	OAMKey			key;		memset(&key, 0, sizeof(key));	key.keyBufferLen = 8;  	memcpy(&key.keyBuffer, &password[1], password[0]);		BuildObjectSpecByNameType(&obj, name, kOAMUser);		err = OAMAuthenticateSession(sess, &obj, &key, NULL);	return err;}OAMStatus RemoveServerKey(OAMSessionID sessionId){	OAMStatus				err = noErr;	OAMObjectSpec			obj;		OAMAttributeDescriptor 	attr[2] = {};		unsigned char			key[4096];    	 	memset(&attr, 0, sizeof(attr)); 	attr[0].attributeSignature 			= kOAMMachine;	attr[0].attributeType 				= 'PGPs';	attr[0].bufferDescriptor.buffer 	=  key;	attr[0].bufferDescriptor.bufferLen 	=  sizeof(key);  	attr[1].attributeSignature = NULL;	memset(&obj, 0, sizeof(OAMObjectSpec));		obj.specType = kOAMObjectSpecByShortID;	obj.u.shortID = kOAMMachineShortID;    	err = OAMDeleteAttribute(sessionId, &obj,  attr, NULL);  	return err;  	}PGPError GetKeyMaterial(PGPContextRef context, PGPKeySetRef keyset , StringPtr keyName, Boolean privateKey, void** keyBuffer, PGPSize*  keyBufferLen ){	PGPFilterRef	theFilter 		= kInvalidPGPFilterRef;	PGPKeyIterRef	theIterator 	= kInvalidPGPKeyIterRef;	PGPKeyListRef	theKeyListRef 	= kInvalidPGPKeyListRef;	PGPKeyRef		aKey		 	= kInvalidPGPKeyRef;	PGPKeySetRef	newKeySet 		= NULL;	PGPUInt32  		numKeys;	Boolean 		canSign;	char			name[255];	PGPError		err;		*keyBuffer = nil;	// Find key in database	PLstrcpy((StringPtr)name, keyName);	p2cstr((StringPtr)  name);		err =   PGPNewUserIDStringFilter(context, name, kPGPMatchSubString, &theFilter); 	err = 	PGPFilterKeySet(keyset , theFilter, &newKeySet); 	err = 	PGPOrderKeySet(newKeySet,kPGPAnyOrdering, &theKeyListRef);	err = 	PGPNewKeyIter( theKeyListRef, &theIterator );		PGPCountKeys(newKeySet, &numKeys);	if(numKeys > 0) 		while(IsntPGPError (PGPKeyIterNext( theIterator, &aKey ))) 		{ 			PGPGetKeyBoolean (aKey, kPGPKeyPropCanSign,  &canSign); //			if(canSign) 			{ 				PGPKeySetRef	keys 		= NULL;  				PGPKeyListRef	listRef 		= kInvalidPGPKeyListRef;	  			PGPKeyIterRef	iter 			= kInvalidPGPKeyIterRef;				PGPSubKeyRef	theSubKeyRef	= kInvalidPGPSubKeyRef;				PGPUserIDRef	theUserIDRef	= kInvalidPGPUserIDRef;				PGPSigRef		theSigRef		= kInvalidPGPSigRef;   				PGPNewSingletonKeySet(aKey, &keys);  	   			// strip new keyset of sigs and subkeys...  			 	err = 	PGPOrderKeySet(keys, kPGPAnyOrdering, &listRef);   				err = 	PGPNewKeyIter( listRef, &iter );  				while(IsntPGPError (PGPKeyIterNext( iter, &aKey )))  	 			{  	 				PGPUserIDRef primaryUserIDRef = kInvalidPGPUserIDRef;   	 				  	 				PGPGetPrimaryUserID(aKey, &primaryUserIDRef); 					while( IsntPGPError(err = PGPKeyIterNextSubKey(iter, &theSubKeyRef )) && ( theSubKeyRef != NULL) )					{												err = PGPRemoveSubKey(theSubKeyRef); 	 				}		 	 				while( IsntPGPError(err = PGPKeyIterNextUserID(iter, &theUserIDRef )) && ( theUserIDRef != NULL) ) 	 				{						while( IsntPGPError(err = PGPKeyIterNextUIDSig(iter, &theSigRef )) && ( theSigRef != NULL) )						{							err = PGPRemoveSig(theSigRef); 	 					} 	 				 	 					if(theUserIDRef != primaryUserIDRef)  PGPRemoveUserID(theUserIDRef); 	 				} 	 				 	 			} 				err = PGPExportKeySet( keys,									PGPOAllocatedOutputBuffer	(context, keyBuffer, MAX_PGPUInt32, keyBufferLen ),									PGPOArmorOutput	(context, false),									PGPOExportPrivateKeys(context, privateKey), // fix this									PGPOExportFormat(context,  kPGPExportFormat_Basic),									PGPOLastOption(context));				printf("KeySize %d Bytes\n", *keyBufferLen); 				PGPFreeKeySet(keys);  				PGPFreeKeyIter(iter );				PGPFreeKeyList(listRef );  				break;  			}	 	 	}  	PGPFreeFilter(theFilter);    PGPFreeKeyIter(theIterator );	PGPFreeKeyList(theKeyListRef ); 		return err;}OAMStatus SetServerKey(OAMSessionID sessionId, void* key, UInt32 len){	OAMStatus				err = noErr;	OAMObjectSpec			obj;		OAMAttributeDescriptor 	attr[2] = {};   	 	memset(&attr, 0, sizeof(attr)); 	attr[0].attributeSignature 			= kOAMMachine;	attr[0].attributeType 				= 'PGPs';	attr[0].bufferDescriptor.buffer 	=  key;	attr[0].bufferDescriptor.bufferLen 	=  len;  	attr[1].attributeSignature = NULL;	BuildObjectSpecByShortID(&obj, 	kOAMMachineShortID);	    	err = OAMSetAttribute(sessionId, &obj,  attr, NULL);		printf("Server Key set (%d, %d) (%d bytes)\n",	err, attr[0].status, attr[0].bufferDescriptor.bufferLen); 	if(err == noErr) 	{		if( attr[0].status == noErr) 		{	 		printf(" Success\n"); 		}	}	return err;}OAMStatus GetServerKey(PGPContextRef context, OAMSessionID sessionId){	OAMStatus				err = noErr;	OAMObjectSpec			obj;		OAMAttributeDescriptor 	attr[2] = {};		unsigned char			key[4096];    	 	memset(&attr, 0, sizeof(attr)); 	attr[0].attributeSignature 			= kOAMMachine;	attr[0].attributeType 				= 'PGPs';	attr[0].bufferDescriptor.buffer 	=  key;	attr[0].bufferDescriptor.bufferLen 	=  sizeof(key);  	attr[1].attributeSignature = NULL;	memset(&obj, 0, sizeof(OAMObjectSpec));		obj.specType = kOAMObjectSpecByShortID;	obj.u.shortID = kOAMMachineShortID;    	err = OAMGetAttribute(sessionId, &obj,  attr, NULL);	if(err == noErr) 	{		if( attr[0].status == noErr) 		{  			PGPKeySetRef	newKeySet 		= NULL;			PGPUInt32 		numKeys;			PGPKeyListRef	theKeyListRef 	= kInvalidPGPKeyListRef;			PGPKeyIterRef	theIterator 	= kInvalidPGPKeyIterRef;			PGPKeyRef		aKey		 	= kInvalidPGPKeyRef;	 		printf(" GetServer Key,  %d Bytes\n", attr[0].bufferDescriptor.actCount); 	 			 		err = PGPImportKeySet(context, &newKeySet, 				 		PGPOInputBuffer( context, attr[0].bufferDescriptor.buffer, attr[0].bufferDescriptor.actCount ),						PGPOLastOption( context) );						PGPCountKeys(newKeySet, &numKeys);			if(numKeys > 0) 			{				Boolean canSign;				PGPOrderKeySet(newKeySet,kPGPAnyOrdering, &theKeyListRef);				PGPNewKeyIter( theKeyListRef, &theIterator);								while(IsntPGPError (PGPKeyIterNext( theIterator, &aKey )))				{					PGPGetKeyBoolean (aKey, kPGPKeyPropCanSign,  &canSign);										if(canSign)						{							char primaryUsernamebuf[256];							PGPGetPrimaryUserIDNameBuffer(aKey, sizeof primaryUsernamebuf,primaryUsernamebuf, NULL );							printf("KeyName : \"%s\"\n", primaryUsernamebuf); 							break;						}				} 				PGPFreeKeyIter(theIterator );				PGPFreeKeyList(theKeyListRef );				if(PGPKeySetRefIsValid (newKeySet)) PGPFreeKeySet(newKeySet);  			}		}	}	return err; }OAMStatus GetUserKey(PGPContextRef context, OAMSessionID sessionId, unsigned char* userName ){	OAMStatus				err = noErr;	OAMObjectSpec			obj;		OAMAttributeDescriptor 	attr[2] = {};		unsigned char			key[4096];    	 	memset(&attr, 0, sizeof(attr)); 	attr[0].attributeSignature 			= kOAMUser;	attr[0].attributeType 				= 'PGPs';	attr[0].bufferDescriptor.buffer 	=  key;	attr[0].bufferDescriptor.bufferLen 	=  sizeof(key);  	attr[1].attributeSignature = NULL; 	BuildObjectSpecByNameType(&obj,(StringPtr) userName, kOAMUser);   	err = OAMGetAttribute(sessionId, &obj,  attr, NULL);	if (err == noErr) 	{		if( attr[0].status == noErr) 		{  			PGPKeySetRef	newKeySet 		= NULL;			PGPUInt32 		numKeys;			PGPKeyListRef	theKeyListRef 	= kInvalidPGPKeyListRef;			PGPKeyIterRef	theIterator 	= kInvalidPGPKeyIterRef;			PGPKeyRef		aKey		 	= kInvalidPGPKeyRef;	 		printf(" GetUser Key,  %d Bytes\n", attr[0].bufferDescriptor.actCount); 	 			 		err = PGPImportKeySet(context, &newKeySet, 				 		PGPOInputBuffer( context, attr[0].bufferDescriptor.buffer, attr[0].bufferDescriptor.actCount ),						PGPOLastOption( context) );						PGPCountKeys(newKeySet, &numKeys);			if(numKeys > 0) 			{				Boolean canSign;				PGPOrderKeySet(newKeySet,kPGPAnyOrdering, &theKeyListRef);				PGPNewKeyIter( theKeyListRef, &theIterator);								while(IsntPGPError (PGPKeyIterNext( theIterator, &aKey )))				{					PGPGetKeyBoolean (aKey, kPGPKeyPropCanSign,  &canSign);						//				if(canSign)						{							char primaryUsernamebuf[256];							PGPGetPrimaryUserIDNameBuffer(aKey, sizeof primaryUsernamebuf,primaryUsernamebuf, NULL );							printf("KeyName : \"%s\"\n", primaryUsernamebuf); 							break;						}				} 				PGPFreeKeyIter(theIterator );				PGPFreeKeyList(theKeyListRef );				if(PGPKeySetRefIsValid (newKeySet)) PGPFreeKeySet(newKeySet);  			}		}	} 	return err; }OAMStatus SetUserKey(OAMSessionID sessionId, unsigned char* userName, void* key, UInt32 len ){	OAMStatus				err			= noErr;	OAMObjectSpec			obj		= {};	OAMAttributeDescriptor  attr[2] = {};  	memset(&attr, 0, sizeof(attr)); 		attr[0].attributeSignature 			= kOAMUser;	attr[0].attributeType 				= 'PGPs';	attr[0].bufferDescriptor.buffer 	=  key;	attr[0].bufferDescriptor.bufferLen 	=  len; 	attr[1].attributeSignature = NULL; 	BuildObjectSpecByNameType(&obj,(StringPtr) userName, kOAMUser);	err = OAMSetAttribute(sessionId, &obj,  attr, NULL);	printf("User Key set (%d, %d) (%d bytes)\n",	err, attr[0].status, attr[0].bufferDescriptor.bufferLen); 	return err; }int main ( void){	PGPContextRef	theContextRef	= kInvalidPGPContextRef;	PGPKeySetRef 	theKeySetRef	= kInvalidPGPKeySetRef;	void 			*keyBuffer = nil;	PGPSize			keyBufferLen = 0; 	OAMStatus 		err = noErr;	OAMSessionID	sessionID = 0; 	Str31			machineName = {};  #if __MWERKS__	extern tSIOUXSettings	SIOUXSettings;	SIOUXSettings.asktosaveonclose = false;	SIOUXSettings.autocloseonquit	= false;	SIOUXSettings.rows = 40;	#endif 	err = PGPNewContext( kPGPsdkAPIVersion, &theContextRef ); 	err = PGPOpenDefaultKeyRings(theContextRef,   kPGPKeyRingOpenFlags_Mutable /* FALSE*/, &theKeySetRef);   	err = OAMInitialize(4, 0, NULL, NULL);  	// 	MyListRegistryAgents("\p≈", "\p*"); //	MyListRegistryAgents("\pThe President's Humidor", "\p*"); //	MyListRegistryAgents("\p≈" ,"\pDA3 4th - North" );//	sessionID = MyOpenSession("\pPhlex Wannabe" ,"\pDA3 4th - North");   	sessionID = MyOpenSession("\pThe President's Humidor", "\p*"); //	err = OAMOpenSession(NULL, &sessionID, NULL); 	if (sessionID)	{  	err = MyAuthenticate(sessionID, "\pvinnie", "\pbunbun");  	printf("Authenticate = %d\n",err); 	 		err = MyGetMachineName(sessionID, machineName);		printf("%d = MachineName(%#s) \n",err,  machineName); 		MyListAllUserNames(sessionID);/* 		err = RemoveServerKey( sessionID);  		printf("RemoveServerKey = %d\n",err);  		err = GetKeyMaterial(theContextRef, theKeySetRef, machineName, true, &keyBuffer, &keyBufferLen); 		if(keyBuffer)		{  			err = SetServerKey(sessionID, keyBuffer, keyBufferLen );  			PGPFreeData(keyBuffer);	 		}    		err = GetKeyMaterial(theContextRef, theKeySetRef, "\pVinnie Moscaritolo", false, &keyBuffer, &keyBufferLen); 		if(keyBuffer)		{			err = SetUserKey(sessionID, "\pVinnie Moscaritolo",keyBuffer, keyBufferLen );   			PGPFreeData(keyBuffer);	 		}  				err = GetServerKey(theContextRef, sessionID);		err = GetUserKey(theContextRef, sessionID,"\pVinnie Moscaritolo");		err = GetUserKey(theContextRef, sessionID,"\pLeland Wallace");*/				OAMCloseSession(sessionID, NULL);	}	err = OAMDeInitialize();   	if( PGPKeySetRefIsValid( theKeySetRef)) 	PGPFreeKeySet (theKeySetRef ); 	if( PGPContextRefIsValid( theContextRef)) 	PGPFreeContext(theContextRef ); 	return 0;  }