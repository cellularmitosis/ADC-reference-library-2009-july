<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN""http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><HEAD><title>Technical Q&amp;A QA1243: How can I verify that a Movie can actually draw into a non-RGB GWorld?</title><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"><meta name="keywords" content="Verify, Movie, Drawing, non-RGB, GWorld, Pixel Format"><meta name="Description" content="This document describes a couple of techniquest to verify that a Movie can actually draw into a non-RGB GWorld?"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR=WHITE><a name="//apple_ref/doc/uid/DTS10002274" title="How can I verify that a Movie can actually draw into a non-RGB GWorld?"></a><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalqas/index.html">Technical Q&As</a> &gt; <a href="../../technicalqas/QuickTime/index.html">QuickTime</a> &gt; <a href="../../technicalqas/QuickTime/idxCompressionDecompression-date.html">Compression & Decompression</a> &gt; </p><!-- end_header_information --><!-- begin_titles_information --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Q&amp;A QA1243</div>
<div id="pageheadsub">How can I verify that a Movie can actually draw into a non-RGB GWorld?</div>
</h1>
</td></tr></table></CENTER><!-- end_titles_information --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600> <TR> <TD align="left"><hr width=500 align=center><!-- document_end_content --><P id=p2>Q: Is it possible to verify that a movie can actually draw into a non-RGB GWorld? For example, if I create a GWorld with a '2vuy' (<code>k2vuyPixelFormat</code>) pixel format, it appears that only certain movies will render to that format while others just render empty frames.</p><P id=p4>A: There are a couple of different approaches you can take to verify that a movie can be rendered to a non-RGB GWorld.</p>						<p id=p4>Not all image decompressors support non-RGB output. Complicated movies with multiple video tracks, effects, multiple codec types, transformation matrices and so on, require kinds of composition that QuickTime cannot perform in non-RGB colorspaces.</p>						<p id=p4>The first approach checks the simplicity of a movie making sure no composition or complex matrices are involved, the movie contains only one video track with a single image description and the video format supports the specified non-RGB destination pixel format. See Listing 1.</p><!-- note starts here --><CENTER><TABLE BORDER=0 CELLPADDING=3 WIDTH=550><TR><TD BGCOLOR="#E6E6E6"><P><B>Note:</B><BR>This approach may reject some movies which are capable of being rendered to the non-RGB pixel format.</P></TD></TR></TABLE></CENTER><!-- note ends here --><br><!-- listing starts here --><CENTER><TABLE BORDER=0 CELLPADDING=0 WIDTH=550><TR><TD><P><B>Listing 1</B>. Can a movie render to the specified pixel format.</P></TD></TR><TR><TD BGCOLOR="#E6E6E6"><PRE><code>Boolean CanRenderMovieToPixelFormat(Movie  inMovie,                                    OSType inPixelFormat){  Track videoTrack, secondVisualTrack;  ImageDescriptionHandle imageDesc = NULL;  Boolean canRenderNonRGB = false;  MatrixRecord matrix;  Media videoMedia;  OSType codecType;  ComponentDescription cd = { decompressorComponentType, 0, 0, 0,                              cmpIsMissing };  Component decompressor = 0;  // values of 1, 2, 4, 8, 16, 24 and 32 specify standard RGB  // pixel formats while values of 33, 34, 36 and 40 specify  // standard gray-scale pixel formats -- don't use this  // approach for these pixel formats   if (inPixelFormat &lt;= 40) return true;  // check that the Movie matrix is no worse than scale+translate  GetMovieMatrix(inMovie, &amp;matrix);  if (GetMatrixType(&amp;matrix) &gt; scaleTranslateMatrixType) goto nope;  // get the first video track  videoTrack = GetMovieIndTrackType(inMovie, 1, VideoMediaType,                                    movieTrackMediaType);  if (!videoTrack) goto nope;  // make sure there are no other visual tracks  // (video tracks are always visual)  secondVisualTrack = GetMovieIndTrackType(inMovie, 2,                                        VisualMediaCharacteristic,                                        movieTrackCharacteristic);  if (secondVisualTrack) goto nope;  // check that the video track matrix is no worse than  // scale+translate  GetTrackMatrix(videoTrack, &amp;matrix);  if (GetMatrixType(&amp;matrix) &gt; scaleTranslateMatrixType) goto nope;  // check that there's only one sample description  videoMedia = GetTrackMedia(videoTrack);  if (1 != GetMediaSampleDescriptionCount(videoMedia)) goto nope;  // get the codec type out of that sample description  imageDesc = (ImageDescriptionHandle)NewHandle(0);  GetMediaSampleDescription(videoMedia, 1,                            (SampleDescriptionHandle)imageDesc);  if (noErr != GetMoviesError()) goto nope;  codecType = (*imageDesc)-&gt;cType;  // find decompressors for this codec type -- we'll need to find  // at least one that lists a matching pixel format in its  // cpix public resource  cd.componentSubType = codecType;  decompressor = FindNextComponent(0, &amp;cd);  if (!decompressor) goto nope;  do {    Handle cpix = NULL;    // 'cpix' resources are used by codecs to list their    // supported non-RGB pixel formats    if (noErr == GetComponentPublicResource(decompressor,                         FOUR_CHAR_CODE('cpix'), 1, &amp;cpix)) {      int i;      int cpixFormatCount = GetHandleSize(cpix) / sizeof(OSType);      for (i = 0; i &lt; cpixFormatCount; i++) {        if (inPixelformat == (*(OSType**)cpix)[i]) {          canRenderNonRGB = true;        }      }      DisposeHandle( cpix );    }    decompressor = FindNextComponent(decompressor, &amp;cd);  } while (decompressor &amp;&amp; false == canRenderNonRGB);nope:  if (imageDesc) DisposeHandle((Handle)imageDesc);  return canRenderNonRGB;}</code></PRE></TD></TR></TABLE></CENTER><!-- listing ends here --><br><p id=p4>The second approach tries rendering to the specified pixel format and checks to see whether it succeeded. See Listing 2.</p><!-- warning starts here --><CENTER><TABLE BORDER=0 CELLPADDING=3 WIDTH=550><TR><TD BGCOLOR="#E6E6E6"><P><B>WARNING:</B><BR>This approach should not be used before QuickTime 6 as it could fail by crashing.</P></TD></TR></TABLE></CENTER><!-- warning ends here --><br>						<!-- listing starts here -->						<CENTER><TABLE BORDER=0 CELLPADDING=0 WIDTH=550><TR>									<td><B>Listing 2</B>. Try and render a movie to the specified pixel format.</td>								</TR><TR>									<td bgcolor="#E6E6E6">										<pre><code>OSErr TryToRenderMovieToPixelFormat(Movie inMovie,                                     OSType inPixelFormat){  OSErr err;  Rect bounds;  CGrafPtr savePort;  GDHandle saveDevice;  GWorldPtr gworld = NULL;  GetMovieGWorld(inMovie, &amp;savePort, &amp;saveDevice);  GetMovieBox(inMovie, &amp;bounds);  err = QTNewGWorld(&amp;gworld, inPixelFormat, &amp;bounds, NULL, NULL, 0);  if (err) goto bail;  LockPixels(GetGWorldPixMap(gworld));  SetMovieGWorld(inMovie, gworld, NULL);  MoviesTask(inMovie, 0);  err = GetMovieStatus(inMovie, NULL);bail:  SetMovieGWorld(inMovie, savePort, saveDevice);  if (gworld) DisposeGWorld(gworld);  return err;}</code></pre></td></TR></TABLE></CENTER><br><!-- listing ends here -->						<p>Using both techniques together is the recommended approach when trying to verify that a movie can be drawn to a specific non-RGB GWorld. First check to see if the movie is likely to support rendering to the destination pixel format, then actually try to render it. If either step fails, fall back to a 32ARGB (<code>k32ARGBPixelFormat</code>) GWorld.<br><!-- put additional content here --><!-- document_end_content --></p>						<hr width=500 align=center>						<!-- begin_date --><H4 ALIGN=center>[Mar 05, 2003]</H4><!-- end_date --></TD></TR></TABLE></CENTER><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/qa/qa2001/qa1243.html%3Fid%3DDTS10002274-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/qa/qa2001/qa1243.html%3Fid%3DDTS10002274-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/qa/qa2001/qa1243.html%3Fid%3DDTS10002274-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>