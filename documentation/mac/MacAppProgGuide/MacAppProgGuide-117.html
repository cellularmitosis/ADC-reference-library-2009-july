<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Recipes--The Clipboard (MacApp PG)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING117></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="MacAppProgGuide-116.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-118.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="MacAppProgGuide-2.html"><B>Programmer's Guide to MacApp</B></A> / <A HREF="MacAppProgGuide-78.html"><B>Part 2 - Working With MacApp</B></A><BR><DD><A HREF="MacAppProgGuide-115.html"><B>Chapter 22 - Working With the Clipboard</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING117-0></A>
<H1><A NAME=MARKER-2-61></A>Recipes--The Clipboard</H1>
 The recipes and sample code in this section demonstrate how to interact with the Macintosh Clipboard (a general outline), how to create a Clipboard view to display your private scrap types, and how to implement Cut, Copy, Clear, and Paste commands for your data types.<P>
<A NAME=HEADING117-2></A>
<H2><A NAME=MARKER-2-62></A>Interacting With the Macintosh Clipboard--A General Outline</H2>
 This outline describes how a MacApp application interacts with the Clipboard.<P>
<OL>
<LI>An application defines one or more scrap type identifiers, if needed, for its private Clipboard data types. This is described in <A HREF=#MARKER-9-67>"Define a Scrap Type for Your Clipboard Data," beginning on page 509</A>.
<LI><A NAME=MARKER-9-63></A>When the application is first launched, it looks on the desk scrap for data of its own private desk scrap type(s). If it finds any, it extracts the data and creates a view to display it. It may or may not need to create a document object to associate with the view. To perform these actions, you override <CODE>MakeViewForAlienClipboard</CODE> in the <CODE>T<I>YourApplication</I></CODE> method (described in <A HREF=#MARKER-9-68>"Override the MakeViewForAlienClipboard Method," beginning on page 509</A>).
<LI>When a user cuts or copies data to the Clipboard, the application normally creates a command to handle the operation. The command's <CODE>DoIt</CODE> method creates a view to display the cut or copied data, then calls <CODE>ClaimClipboard</CODE> to install the view as the command's current Clipboard view and also as the Clipboard manager's current Clipboard view. If the user chooses to undo or redo the command, MacApp takes care of switching between the current and undo Clipboard views, as appropriate. (See <A HREF=#MARKER-9-70>"Recipe--Supporting the Cut, Copy, and Clear Commands," beginning on page 514</A>.)
<LI>Any application view that allows pasting overrides <CODE>DoSetupMenus</CODE> and, for each private or public data type it can paste, starting with its preferred type, calls the global Clipboard manager's <CODE>CanPaste</CODE> method (as described in <A HREF=#MARKER-9-76>"Override the DoSetupMenus Method in Your View Class," beginning on page 522</A>).
<LI>When a user quits the application or switches to another application, MacApp calls the Clipboard manager's <CODE>AboutToLoseControl</CODE> method. That method calls the current Clipboard view's <CODE>WriteToDeskScrap</CODE> method. Any view you install as a Clipboard view should override <CODE>WriteToDeskScrap</CODE> to write its private data types and possibly write some of the standard scrap types as well. Your view should also override <CODE>GivePasteData</CODE> to provide its available data in handle format based on the requested data type. (These two steps are described in the recipe that follows.)
<LI>When the application is switched back in, MacApp calls the Clipboard manager's <CODE>RegainControl</CODE> method. If the data on the desk scrap has changed, <CODE>RegainControl</CODE> generates a call to <CODE>MakeViewForAlienClipboard</CODE>, which functions as described in step <A HREF=#MARKER-9-63>2.</A><A NAME=MARKER-2-64></A><P>
</OL>
<A NAME=HEADING117-10></A>
<H2><A NAME=MARKER-2-65></A><A NAME=MARKER-9-66></A>Recipe--Creating a Clipboard View for Your Private Data Type</H2>
 When your application is first launched, and again whenever your application is switched in and there is new data on the desk scrap, MacApp calls the <CODE>MakeViewForAlienClipboard</CODE> method of your application object. This method looks on the desk scrap for data in your application's private desk scrap type. If it finds any, it extracts the data and creates a view to display it. It may or may not need to create a document object to associate with the view.<P>
 If <CODE>MakeViewForAlienClipboard</CODE> doesn't find your private scrap type on the desk scrap, it calls <CODE>Inherited</CODE> to let MacApp's default Clipboard support handle the standard data types. <P>
 To create a Clipboard view for your private scrap type, you perform these steps:<P>
<OL>
<LI>Define a scrap type for your Clipboard data.
<LI>Override the <CODE>MakeViewForAlienClipboard</CODE> method in your application class.<P>
<UL>
<LI> If the application's private scrap type is available: load the data from the desk scrap; create a view object to display the data for the Clipboard view; if necessary, create a document object to associate with the view.
<LI>If the application's private scrap type is <I>not</I> available, call <CODE>Inherited</CODE> to let the <CODE>MakeViewForAlienClipboard</CODE> method of <CODE>TApplication</CODE> supply a Clipboard view.<P>
</UL>
<LI>Include the Show Clipboard command in your resource definition file. 
<LI>Override the <CODE>WriteToDeskScrap</CODE> method of your view class.
<LI>Override the <CODE>ContainsClipType</CODE> method of your view class.
<LI>Override the <CODE>GivePasteData</CODE> method of your view class.<P>
</OL>
 The sample code shown in this recipe is from the IconEdit application.<P>
<A NAME=HEADING117-23></A>
<H3><A NAME=MARKER-9-67></A>Define a Scrap Type for Your Clipboard Data</H3>
 The scrap type is a resource type specified by a four-character string. Unless you are sharing Clipboard data types with other applications, you should define a unique string for your data type. For example, the IconEdit sample program defines this constant:<P>
<PRE>
const ResType kIconClipType = 'ICON'; // Your private Clipboard data type.
</PRE>
  It is a good idea to register your scrap type identifiers with Apple Computer's Developer Technical Services to avoid conflict with identifiers used by other applications (for details on how to do so, see the note on <A HREF=MacAppProgGuide-116.html#MARKER-9-27>page 501</A>).<P>
<A NAME=HEADING117-27></A>
<H3><A NAME=MARKER-9-68></A>Override the MakeViewForAlienClipboard Method</H3>
 MacApp calls the <CODE>MakeViewForAlienClipboard</CODE> method of the application object to give your application a chance to look for its private data types on the desk scrap.  If a private scrap type is available, <CODE>MakeViewForAlienClipboard</CODE> loads the data from the desk scrap, creates a view object to display the data for the Clipboard view, and, if necessary, creates a document object to associate with the view.<P>
 The display view is usually the same type as the view that would display similar data in the application. This makes it convenient to retrieve and display Clipboard data in your application's private format. For example, if icon data is present on the desk scrap, the <CODE>MakeViewForAlienClipboard</CODE> method of the <CODE>TIconEditApplication</CODE> class, shown next, creates a <CODE>TIconDocument</CODE> object to load and store the icon data and a <CODE>TIconEditView</CODE> object to display the data.<P>
 When there is no icon data present, the <CODE>MakeViewForAlienClipboard</CODE> method calls <CODE>Inherited</CODE> to let the <CODE>TApplication</CODE> class supply a Clipboard view.<P>
<PRE>
TView* TIconEditApplication::MakeViewForAlienClipboard()
{
   long     offset;

   // Does the scrap contain icon data?
   if (GetScrap(NULL, kIconClipType, &amp;offset) &gt; 0)
   {
      // Create a document object to load and store the data.
      TIconDocument*clipDocument = NULL;
      TIconEditView* clipView = NULL;

      clipDocument = new TIconDocument;
      clipDocument-&gt;IIconDocument(NULL);

      // Install failure handler to free the document object in
      // case an error occurs.
      FailInfo fi;
      Try(fi)
      {
         // Call a method of the document to get the icon data.
         clipDocument-&gt;ReturnBitMap()-&gt;LoadFromScrap();

         // Create a view to display the icon in the Clipboard view.
         clipView = new TIconEditView;
         clipView-&gt;IIconEditView(clipDocument, NULL, gZeroVPt, 1);
         
         // No error occurred, so we're done with the error handler.
         fi.Success();
      }
      else
      {
         // An error occurred, so free the document object and pass
         // the failure handler on for any other necessary cleanup.
         clipDocument = (TIconDocument*)FreeIfObject(clipDocument);
         fi.ReSignal();
      }

      // If no error, return the view created to serve as
      // the Clipboard view.
      return clipView;
   }
   else
   {
      // The desk scrap didn't contain icon data, so use MacApp's
      // default method in the TApplication class to supply a view.
      return Inherited::MakeViewForAlienClipboard();
   }

}  // TIconEditApplication::MakeViewForAlienClipboard
</PRE>
 The <CODE>TIconDocument</CODE> class ReturnBitMap method returns the document's <CODE>fIconBitMap</CODE> field. The <CODE>TIconBitMap::LoadFromScrap</CODE> method reads data from the desk scrap as follows:<P>
<PRE>
void TIconBitMap::LoadFromScrap()
{
   long offset;
   long err;

   // Load the icon data. (It's always there if this method is called.)
   err = GetScrap(fDataHandle, kIconClipType, &amp;offset);

   // If we could not read data, cause a failure and display the error.
   if (err &lt; 0)
      FailOSErr((short) err);
}
</PRE>
 The code in the LoadFromScrap method is simple for two reasons:<P>
<UL>
<LI>The MakeViewForAlienClipboard method has already determined that there is icon data on the desk scrap.
<LI>Icon bitmap data is always the same length.<P>
</UL>
<A NAME=HEADING117-37></A>
<H3>Include the Show Clipboard Command in Your Resource File</H3>
 Since your application is supplying a view to display and manipulate Clipboard data, you might as well let the user show that view. To do so, your application needs a Show Clipboard menu item. MacApp's default Edit menu contains the Show Clipboard menu item and can be included in your resource definition file with the following line:<P>
<PRE>
include &quot;Defaults.rsrc&quot; 'CMNU' (mEdit);
</PRE>
 MacApp defines the <CODE>cShowClipboard</CODE> command constant and automatically handles this command when the user chooses it from the Edit menu.<P>
<A NAME=HEADING117-41></A>
<H3>Override the WriteToDeskScrap Method of Your View Class</H3>
 When the user chooses to quit your application or switches to another application, your application should convert its private scrap type to a standard data type that other applications can use. The view class you use for displaying Clipboard data should override the <CODE>WriteToDeskScrap</CODE> method so that when it serves as a Clipboard view, it can write both your application's private data and whatever standard data types the application supports.<P>
 In the IconEdit application, the <CODE>WriteToDeskScrap</CODE> method of the <CODE>TIconEditView</CODE> class calls the <CODE>WriteToScrap</CODE> method of the icon document's bitmap. It then calls <CODE>Inherited</CODE> to write the view as a picture (for display by other applications, which can't be expected to understand icon data).<P>
<PRE>
void TIconEditView::WriteToDeskScrap()
{
   // Write the icon data to the Clipboard, then call Inherited to
   // write the view in 'PICT' format.
   fIconDocument-&gt;ReturnBitMap()-&gt;WriteToScrap();
   Inherited::WriteToDeskScrap();
}
</PRE>
 The <CODE>TIconBitMap::WriteToScrap</CODE> method writes its data as follows:<P>
<PRE>
void TIconBitMap::WriteToScrap()
{
   // Write the handle to the desk scrap, failing if an error occurs.
   FailOSErr(gClipboardMgr-&gt;PutDeskScrapData(kIconClipType,
                                    fDataHandle)); 
}
</PRE>
 The <CODE>PutDeskScrapData</CODE> method calls the Toolbox routine <CODE>PutScrap</CODE> to write the passed data to the desk scrap.<P>
<A NAME=HEADING117-48></A>
<H3> Override the ContainsClipType Method of Your View Class</H3>
 When you supply a view to display Clipboard data, that view should override the <CODE>ContainsClipType</CODE> method. MacApp calls <CODE>ContainsClipType</CODE> to determine whether the view contains a specific type of Clipboard data. This is the ContainsClipType method from the TIconEditView class:<P>
<PRE>
Boolean TIconEditView::ContainsClipType(ResType aType)
{
    return (aType == kIconClipType);
}
</PRE>
 When a TIconEditView object is used for the Clipboard view, it <I>always</I> contains icon data and it <I>only</I> contains icon data. Therefore ContainsClipType returns <CODE>TRUE</CODE> when asked if it contains icon data and <CODE>FALSE</CODE> for any other data type. If your view class can contain multiple data types, your version of ContainsClipType should return <CODE>TRUE</CODE> for any currently available data type.<P>
<A NAME=HEADING117-52></A>
<H3>Override the GivePasteData Method of Your View Class</H3>
 Because the IconEdit application works with simple views containing a fixed-size icon bitmap, the TIconEditView class does not need to override <CODE>GivePasteData</CODE>. In addition, the <CODE>TView::GivePasteData</CODE> method will retrieve requested data types from the desk scrap, a practice that may be sufficient for some applications. However, you may wish to override the <CODE>GivePasteData</CODE> method in your view class to provide the view's private data type in an efficient manner. Your version of <CODE>GivePasteData</CODE> would look something like the following:<P>
<PRE>
long TYourView::GivePasteData (Handle aDataHandle, ResType dataType)
{
   long returnErr = noErr;
   // If the passed data type matches one of your private types, call
   // a utility method to put the data in the passed handle.
   if (dataType == kMyPreferredClipType)
      returnErr = this-&gt;GetDataHandle(aDataHandle, dataType);
   else
   {
      // The data may be available on the desk scrap.
      returnErr = Inherited::GivePasteData(aDataHandle, dataType);
   }
   return returnErr;
}
</PRE>
 The implementation of GetDataHandle is specific to your application. For another example of the <CODE>GivePasteData</CODE> method, see MacApp's <CODE>TTEView</CODE> class.<A NAME=MARKER-2-69></A><P>
<A NAME=HEADING117-56></A>
<H2><A NAME=MARKER-9-70></A><A NAME=MARKER-2-71></A>Recipe--Supporting the Cut, Copy, and Clear Commands</H2>
 The Cut, Copy, and Clear commands work as follows:<P>
<UL>
<LI>The Cut command removes the selected information from a view (and generally also from its document) and places the information in the Clipboard.
<LI>The Copy command copies the selected information to the Clipboard but does not remove the original from the view or document.
<LI>The Clear command removes the original but does not copy the selected information to the Clipboard.<P>
</UL>
 A closely related command, Paste, copies the current contents of the Clipboard into a view (and its document).<P>
 Because there is some similarity in the operations performed by the Cut, Copy, and Clear menu commands, you may be able to handle them with a single command class. For example, the IconEdit application defines one command class to handle Cut, Copy, and Clear, and a separate class to handle the Paste command. (The Paste command is described in <A HREF=#MARKER-9-75>"Recipe--Implementing a Paste Command," beginning on page 521</A>.)<P>
 As with other menu commands, your application handles Cut, Copy, and Clear by defining a command class and overriding the <CODE>DoIt</CODE>, <CODE>RedoIt</CODE>, and <CODE>UndoIt</CODE> methods. When the user chooses one of these commands, MacApp calls the <CODE>DoMenuCommand</CODE> method of the current target object, passing the <CODE>cCut</CODE>, <CODE>cCopy</CODE>, or <CODE>cClear</CODE> command constant. You override the <CODE>DoMenuCommand</CODE> method in an event-handling class to respond to each of these messages by creating and initializing a command object. The command class also enables the menu items in its <CODE>DoSetupMenus</CODE> method. Recipes that show the basics of working with menus and commands are located in <A HREF=MacAppProgGuide-85.html#MARKER-9-27>Chapter 12, "Working With Menus,"</A> and <A HREF=MacAppProgGuide-88.html#MARKER-9-19>Chapter 13, "Working With Events and Commands."</A><P>
 To support the Cut, Copy, and Clear menu commands for your data types, you perform these steps:<P>
<OL>
<LI>Override the <CODE>DoSetupMenus</CODE> method in your view class to enable the Cut, Copy, and Clear menu items, when appropriate.
<LI>Override the <CODE>DoMenuCommand</CODE> method in your view class to create, initialize, and post a command object to handle Cut, Copy, or Clear.
<LI>Define a command class to handle Cut, Copy, and Clear.
<LI>Implement constructor and destructor methods.
<LI>Implement an initialization method.
<LI>Implement a <CODE>DoIt</CODE> method.<P>
<UL>
<LI>For Cut or Copy, create a view to display the cut or copied data in the Clipboard.
<LI>Copy or delete the data from your view's document object.
<LI>For Cut or Copy, call the <CODE>ClaimClipboard</CODE> method of the global Clipboard manager object to install the view in the Clipboard.<P>
</UL>
<LI>Implement <CODE>UndoIt</CODE> and <CODE>RedoIt</CODE> methods to make Clipboard operations undoable.<P>
</OL>
 The sample code shown in this recipe is from the IconEdit application.<P>
<A NAME=HEADING117-76></A>
<H3><A NAME=MARKER-9-72></A>Override DoSetupMenus in Your View Class</H3>
 The following is the DoSetupMenus method for the TIconEditView class:<P>
<PRE>
void TIconEditView::DoSetupMenus()
{
   Inherited::DoSetupMenus();// Set up inherited menus.

   // Enable Zoom Out if not at smallest size.
   Enable(cZoomOut, fMagnification &gt; 1);
   Enable(cZoomIn, TRUE);// Can always zoom in.
   Enable(cSetColor, TRUE);// Can always set the color.
   Enable(cCut, TRUE);  // Always enable the Cut command.
   Enable(cCopy, TRUE); // Always enable the Copy command.
   Enable(cClear, TRUE);// Always enable the Clear command.

   // This view can paste 'ICON' data.
   gClipboardMgr-&gt;CanPaste(kIconClipType);
}
</PRE>
 In the IconEdit application, the current icon can always be cut, copied, or cleared. For more complicated views that may contain more than one item, you normally enable these menu items only if there is at least one selected item in the view that can be cut, copied, or cleared.<P>
 Your view may also be able to paste more than one data type. If so, your DoSetupMenus method can call CanPaste more than once.<P>
<DL>
<DT><B>IMPORTANT</B>
<DD>If your DoSetupMenus method calls CanPaste more than once, you should pass your preferred data type first, then your next most preferred type, and so on, down to your least preferred type.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING117-82></A>
<H3><A NAME=MARKER-9-73></A>Override DoMenuCommand in Your View Class</H3>
 The following is the <CODE>DoMenuCommand</CODE> method for the TIconEditView class:<P>
<PRE>
void TIconEditView::DoMenuCommand(CommandNumber aCommandNumber)
{
   TIconEditCommand*anIconEditCommand;
   TIconPasteCommand*anIconPasteCommand;

   // Look for command numbers we can handle.
   switch (aCommandNumber)
   {
      case cCut:
      case cCopy:
      case cClear:
         {  // Use TIconEditCommand object for cut, copy, or clear.
            anIconEditCommand = new TIconEditCommand;
            anIconEditCommand-&gt;IIconEditCommand(aCommandNumber, this,
                                       fIconDocument);
            this-&gt;PostCommand(anIconEditCommand);
            break;
         }

      case cPaste:
         {  // Post a TIconPasteCommand object to handle paste.
            anIconPasteCommand = new TIconPasteCommand;
            anIconPasteCommand-&gt;IIconPasteCommand(this,
                                          fIconDocument);
            this-&gt;PostCommand(anIconPasteCommand);
            break;
         }

      default:
         // If we can't handle the command, pass it on.
         Inherited::DoMenuCommand(aCommandNumber);
         break;
   }
}  // TIconEditView::DoMenuCommand
</PRE>
 This method creates, initializes, and posts a TIconEditCommand command object to handle the command numbers <CODE>cCut</CODE>, <CODE>cCopy</CODE>, and <CODE>cClear</CODE>. When the command object is initialized, it stores the command number in its <CODE>fIdentifier</CODE> field; during execution, it uses <CODE>fIdentifier</CODE> to determine which operation to perform.<P>
<A NAME=HEADING117-86></A>
<H3>Define a Command Class to Handle Cut, Copy, and Clear</H3>
 The IconEdit application uses a single command class, <CODE>TIconEditCommand</CODE>, to handle the Cut, Copy, and Clear menu commands. The <CODE>TIconEditCommand</CODE> class is defined as follows:<P>
<PRE>
class TIconEditCommand : public TCommand
{
   MA_DECLARE_CLASS;

  protected:
   TIconDocument*fIconDocument;// Document affected by command.
   TIconEditView*fIconEditView;// View in which editing happens.
   TIconBitMap*fSavedBitMap;// Saved state for undo/redo.
   
  public:
   TIconEditCommand();     // Constructor.
   virtual ~TIconEditCommand();// Destructor.

   virtual void IIconEditCommand(CommandNumberitsCommandNumber, 
                           TIconEditView*itsIconEditView,
                           TIconDocument*itsIconDocument);

   virtual void DoIt();    // Override.
   virtual void RedoIt();  // Override.
   virtual void UndoIt();  // Override.
};
</PRE>
 If your application has more complicated data types than the IconEdit application (a likely scenario), you may require more than one command class to handle the Cut, Copy, and Clear commands.<P>
<A NAME=HEADING117-90></A>
<H3>Implement Constructor and Destructor Methods</H3>
 The constructor method for TIconEditCommand sets its fields to safe values:<P>
<PRE>
TIconEditCommand::TIconEditCommand() 
{
   fIconDocument = NULL;
   fIconEditView = NULL;
   fSavedBitMap = NULL;       
}
</PRE>
 The TIconEditCommand destructor method frees the saved bitmap (used for undoing and redoing):<P>
<PRE>
TIconEditCommand::~TIconEditCommand()
{
   // Free the saved bitmap.
   fSavedBitMap = (TIconBitMap*)FreeIfObject(fSavedBitMap);
}
</PRE>
<A NAME=HEADING117-95></A>
<H3>Implement an Initialization Method</H3>
 The IIconEditCommand initialization method for the TIconEditCommand class is defined as follows:<P>
<PRE>
void TIconEditCommand::IIconEditCommand (
                           CommandNumberitsCommandNumber, 
                           TIconEditView*itsIconEditView,
                           TIconDocument*itsIconDocument)
{
   // Initialize the parent command class.
   this-&gt;ICommand(itsCommandNumber, itsIconDocument, kCanUndo,
               kCausesChange, itsIconDocument);
   // Set other fields based on command number:
   //    Cut or Copy (anything but Clear) changes the Clipboard.
   //    Cut or Clear (anything but Copy) changes the document.
   fChangesClipboard = (itsCommandNumber != cClear);
    fCausesChange = (itsCommandNumber != cCopy);

   // Set references and save a copy of the current icon bitmap.
   fIconEditView = itsIconEditView;
   fIconDocument = itsIconDocument;
   fSavedBitMap = fIconDocument-&gt;ReturnBitMap()-&gt;Copy();
}  // TIconEditCommand::IIconEditCommand
</PRE>
 This method sets the fChangesClipboard and fCausesChange fields based on the command number, because only the Cut and Copy commands put something on the Clipboard, and only the Cut and Clear commands change the view and document by deleting data.<P>
<A NAME=HEADING117-99></A>
<H3>Implement a DoIt Method</H3>
 The <CODE>DoIt</CODE> method of the command object performs different steps, depending on the command's <CODE>fIdentifier</CODE> field. For <CODE>cCut</CODE> or <CODE>cCopy</CODE> it performs these steps:<P>
<UL>
<LI>It creates a view to display the cut or copied data in the Clipboard.
<LI>It calls the <CODE>ClaimClipboard</CODE> method of the global Clipboard manager object to install the view in the Clipboard.
<LI>It copies the data to the Clipboard view.<P>
</UL>
 For <CODE>cCut</CODE>, it performs this additional step; for <CODE>cClear</CODE>, it performs <I>only</I> this step:<P>
<UL>
<LI>It deletes the data from the view's document object. (The document object should update the view to remove the cut or copied data from its display.)<P>
</UL>
 The <CODE>DoIt</CODE> method for the TIconEditCommand class is shown on the following page.<P>
<PRE>
void TIconEditCommand::DoIt()
{
   // Need Clipboard view only if command is Cut or Copy.
   if (fIdentifier != cClear)
   {
      TIconDocument*clipDocument = NULL;
      TIconEditView*clipView = NULL;

      // Create a document to store data on the Clipboard.
      // If IIconDocument fails, it will free the document.
      clipDocument = new TIconDocument;
      clipDocument-&gt;IIconDocument(NULL);
   
      // If IIconEditView fails, it will free the view, but you
      // need to install a failure handler to free the document.
      FailInfo fi;
      Try(fi)
      {
         clipView = new TIconEditView;
         clipView-&gt;IIconEditView(clipDocument, NULL, gZeroVPt,
                           fIconEditView-&gt;GetMagnification());
         fi.Success();// Pop the failure handler.
      }
      else // Recover.
      {
         clipDocument = (TIconDocument*)FreeIfObject(clipDocument);
         fi.ReSignal();// Let other failure handlers also respond.
      }
      // Copy data to document icon.
      fSavedBitMap-&gt;CopyDataTo(clipDocument-&gt;ReturnBitMap());

      // Tell the Clipboard manager we have a new Clipboard.
      this-&gt;ClaimClipboard(clipView);
   }

   // For a Cut or Clear command, clear the icon.
   if (fIdentifier != cCopy)
      fIconDocument-&gt;ClearIcon();
}  // TIconEditCommand::DoIt
</PRE>
<A NAME=HEADING117-108></A>
<H3>Implement UndoIt and RedoIt Methods</H3>
 An advantage of MacApp's Clipboard support is that when a user chooses to undo or redo a command that affects the Clipboard, MacApp automatically changes between the do and undo Clipboard views. Your application deals only with its own view and document.<P>
 The following is the UndoIt method for the TIconEditCommand class:<P>
<PRE>
void TIconEditCommand::UndoIt()
{
   // If the command was Cut or Clear, undo must restore the icon.
   if (fIdentifier != cCopy)
   {  
      fSavedBitMap-&gt;CopyDataTo(fIconDocument-&gt;ReturnBitMap());
      // Make sure all views get redrawn.
      fIconDocument-&gt;RedrawViews();
   }
}
</PRE>
 This method examines the <CODE>fIdentifier</CODE> field to determine whether the current command is a Cut, Copy, or Clear command. For Copy, there is no change to the document or view--only to the Clipboard, and that is handled automatically by MacApp. For Cut or Clear, the saved icon bitmap is restored.<P>
 The <CODE>RedoIt</CODE> method is even simpler. For a Copy command, no change is required. For a Cut or Clear command, because the command already has a copy of the cleared icon in its fSavedBitMap field, RedoIt has only to clear the icon:<P>
<PRE>
void TIconEditCommand::RedoIt()
{
   // If the command was Cut or Clear, clear the icon.
   if (fIdentifier != cCopy)
      fIconDocument-&gt;ClearIcon();
}
</PRE>
<A NAME=HEADING117-115></A>
<H2><A NAME=MARKER-2-74></A><A NAME=MARKER-9-75></A>Recipe--Implementing a Paste Command</H2>
 The Paste command pastes data from the Clipboard into a view (and typically into the view's document). The Clipboard may contain data cut or copied from your application or from another application. The data may be available in your private format or in one of the standard formats (text and picture).<P>
 To implement a Paste command for your data types, you perform these steps:<P>
<OL>
<LI>Override the <CODE>DoSetupMenus</CODE> method in your view class to enable the Paste command.
<LI>Override the <CODE>DoMenuCommand</CODE> method in your view class to create, initialize, and post a Paste command object.
<LI>Define a command class to handle the paste operation.
<LI>Implement constructor and destructor methods.
<LI>Implement an initialization method.
<LI>Implement a <CODE>DoIt</CODE> method that<P>
<UL>
<LI>saves the current state of the view
<LI>pastes the Clipboard data into the view<P>
</UL>
<LI>Implement <CODE>UndoIt</CODE> and <CODE>RedoIt</CODE> methods to make the paste operation undoable.<P>
</OL>
 The sample code shown in this recipe is from the IconEdit application.<P>
<A NAME=HEADING117-128></A>
<H3><A NAME=MARKER-9-76></A>Override the DoSetupMenus Method in Your View Class</H3>
 To enable the Paste command, you override the <CODE>DoSetupMenus</CODE> method in your view class. Your version of <CODE>DoSetupMenus</CODE> calls the global Clipboard manager's <CODE>CanPaste</CODE> method to specify the types of data it can accept. If the current Clipboard view (or the desk scrap) contains data matching one of the specified types, <CODE>CanPaste</CODE> enables the Paste command. <P>
 The <CODE>DoSetupMenus</CODE> method of the <CODE>TIconEditView</CODE> class is described in the previous recipe, in the section beginning on <A HREF=#MARKER-9-72>page 515</A>. It shows how to call <CODE>CanPaste</CODE>, specifying the icon data type.<P>
<A NAME=HEADING117-131></A>
<H3>Override the DoMenuCommand Method in Your View Class</H3>
 You override the <CODE>DoMenuCommand</CODE> method in your view class to create, initialize, and post a command object to perform the paste operation. The <CODE>DoMenuCommand</CODE> method of the <CODE>TIconEditView</CODE> class is described in the previous recipe, in the section beginning on <A HREF=#MARKER-9-73>page 516</A>. It shows how to create, initialize, and post a <CODE>TIconPasteCommand</CODE> command object.<P>
<A NAME=HEADING117-133></A>
<H3>Define a Command Class to Handle Paste</H3>
 The IconEdit application defines the TIconPasteCommand command class to handle the Paste menu command:<P>
<PRE>
class TIconPasteCommand : public TCommand
{
   MA_DECLARE_CLASS;

protected:
   TIconDocument*fIconDocument;// Document affected by command.
   TIconEditView*fIconEditView;// View in which pasting happens.
   TIconBitMap*fSavedIcon; // Saved state for undo/redo.

  public:
   TIconPasteCommand();    // Constructor.
   virtual ~TIconPasteCommand();// Destructor.

   virtual void IIconPasteCommand(TIconEditView* itsIconEditView,
                           TIconDocument* itsIconDocument);
   
   virtual void DoIt();    // Override.
   virtual void UndoIt();  // Override.
};
</PRE>
<A NAME=HEADING117-136></A>
<H3>Implement Constructor and Destructor Methods</H3>
 The constructor method for TIconPasteCommand sets its fields to safe values:<P>
<PRE>
TIconPasteCommand::TIconPasteCommand() 
{
   fIconDocument = NULL;
   fIconEditView = NULL;
   fSavedIcon = NULL;         
}
</PRE>
 The TIconPasteCommand destructor method frees the saved icon bitmap (used for undoing and redoing):<P>
<PRE>
TIconPasteCommand::~TIconPasteCommand()
{
   // Free the saved bitmap.
   fSavedIcon = (TIconBitMap*)FreeIfObject(fSavedIcon);
}
</PRE>
<A NAME=HEADING117-141></A>
<H3>Implement an Initialization Method</H3>
 The IIconPasteCommand initialization method for the TIconPasteCommand class is defined as follows:<P>
<PRE>
void TIconPasteCommand::IIconPasteCommand(TIconEditView* itsIconEditView,
                              TIconDocument* itsIconDocument)
{
   // Initialize the parent command.
   this-&gt;ICommand(cPaste, itsIconDocument, kCanUndo, 
               kCausesChange, itsIconDocument);

   fIconEditView = itsIconEditView;
   fIconDocument = itsIconDocument;
   
   TIconDocument* clipDoc =
               (TIconDocument*)gClipboardMgr-&gt;fClipView-&gt;fDocument;

   fSavedIcon = clipDoc-&gt;ReturnBitMap()-&gt;Copy();
}  // TIconPasteCommand::IIconPasteCommand
</PRE>
 Note that unlike the initialization method for the <CODE>TIconEditCommand</CODE> class shown in the previous recipe, the IIconPasteCommand method does not set <CODE>fChangesClipboard</CODE> to <CODE>TRUE</CODE>. That's because a TIconPasteCommand object extracts information from the Clipboard but doesn't change it.<P>
 For a <CODE>TIconEditView</CODE> object, the Paste menu command is enabled only if there is icon data on the Clipboard. If there is icon data on the Clipboard, there must be a current Clipboard view and it must be a <CODE>TIconEditView</CODE> object. Therefore the IIconPasteCommand method can access the Clipboard view, get its document, and copy the document's bitmap. This is accomplished by the following lines:<P>
<PRE>
TIconDocument* clipDoc =
               (TIconDocument*)gClipboardMgr-&gt;fClipView-&gt;fDocument;
fSavedIcon = clipDoc-&gt;ReturnBitMap()-&gt;Copy();
</PRE>
<DL>
<DT><B>Note</B>
<DD>A more careful programming style would suggest testing the various object references before dereferencing their fields and methods.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING117-148></A>
<H3>Implement a DoIt Method</H3>
 The <CODE>DoIt</CODE> method for the TIconPasteCommand class is implemented as follows:<P>
<PRE>
void TIconPasteCommand::DoIt()
{
   TIconBitMap* tempIcon = fIconDocument-&gt;ReturnBitMap()-&gt;Copy();
   fIconDocument-&gt;SetIcon(fSavedIcon);
   fSavedIcon = tempIcon;
}
</PRE>
 This code performs three tasks:<P>
<UL>
<LI>It gets a copy of the current icon from the view's document.
<LI>It sets the document's icon bitmap to the saved bitmap, which was stored by the initialization method. (In this case, the "saved" bitmap is actually the pasted bitmap from the Clipboard.) The call to <CODE>SetIcon</CODE> both sets the icon and causes the view to be redrawn.
<LI>It sets the saved icon bitmap to the one from the document.<P>
</UL>
 As a result, the document's current icon bitmap is replaced by the pasted bitmap, but a copy is saved in the fSavedIcon field for undo and redo.<P>
<A NAME=HEADING117-156></A>
<H3>Implement UndoIt and RedoIt Methods</H3>
 The <CODE>UndoIt</CODE> method for the TIconPasteCommand command just calls the <CODE>DoIt</CODE> method. As mentioned in the previous section, the <CODE>DoIt</CODE> method simply switches the document's current icon bitmap with the one stored by the command, then causes the view to be redrawn.<P>
 The TIconPasteCommand class doesn't override <CODE>RedoIt</CODE>, because the version of <CODE>RedoIt</CODE> defined in <CODE>TCommand</CODE> already calls <CODE>DoIt</CODE>, which for the TIconPasteCommand class switches the bitmaps and redraws the view.<A NAME=MARKER-2-77></A><A NAME=MARKER-2-78></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="MacAppProgGuide-116.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-118.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="MacAppProgGuide-3.html">&copy; Apple Computer, Inc.</A><br>25 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
