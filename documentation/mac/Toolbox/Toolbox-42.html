<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Handling High-Level Events (IM:Tb)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING42></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Toolbox-41.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Toolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Toolbox-490.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Toolbox-43.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Toolbox-2.html"><B>Macintosh Toolbox Essentials</B></A> / <BR><DD><A HREF="Toolbox-28.html"><B>Chapter 2 - Event Manager</B></A> / <A HREF="Toolbox-36.html"><B>Using the Event Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING42-0></A>
<H2>Handling High-Level Events </H2>
 <A NAME=MARKER-2-562></A>High-level events provide a means of communication between applications. Apple events are high-level events that follow the Apple Event Interprocess Messaging Protocol (AEIMP). In most cases, you should use Apple events rather than define your own high-level events if you wish to communicate with other applications. If you plan to use Apple events, see <I><A HREF="../IAC/IAC-2.html">Inside Macintosh: Interapplication Communication</A></I> for specific information on Apple events, and refer to this section for specific details about how the Event Manager reports high-level events. <A NAME=MARKER-2-556></A><A NAME=MARKER-2-511></A><A NAME=MARKER-2-274></A><P>
 To receive high-level events, you must set the appropriate flags in your application's <CODE>'SIZE'</CODE> resource. You must set the <CODE>isHighLevelEventAware</CODE> flag if your application <BR>is to receive any high-level events. You must set the <CODE>localAndRemoteHLEvents</CODE> <BR>flag for your application to receive high-level events sent from another computer on <BR>the network. In addition, to receive high-level events from another computer, your application must be shared and Program Linking must be enabled. The user shares your application by selecting your application in the Finder and choosing Sharing from the File menu and enables Program Linking from the Sharing Setup control panel. <A NAME=MARKER-2-557></A><A NAME=MARKER-2-426></A><P>
 If you set the <CODE>isHighLevelEventAware</CODE> flag in your application's <CODE>'SIZE'</CODE> resource, your application receives the Finder information in the form of Apple events. The Finder information is the information your application can use to determine which files to open or print. Your application must respond to the required Apple events (Open Application, Open Documents, Print Documents, and Quit Application) that are sent by the Finder if your application sends or receives high-level events.<P>
 The <CODE>what</CODE> field in the event record of a high-level event contains the kHighLevelEvent constant. <A NAME=MARKER-9-70></A> <P>
 To determine the type of high-level event received, your application needs to examine the <CODE>message</CODE> and <CODE>where</CODE> fields of the event record. For high-level events, these two fields of the event record have special meanings.<P>
 The <CODE>message</CODE> field and the <CODE>where</CODE> field of the event record together define the specific type of high-level event received. Your application should interpret these fields as having the data type <CODE>OSType</CODE>, not <CODE>LongInt</CODE> or <CODE>Point</CODE>. <P>
 The <CODE>message</CODE> field contains the event class of the high-level event. For example, Apple events sent by the Edition Manager have the event class '<CODE>sect</CODE>'. You can define your own group of events that are specific to your application. If you have registered your application signature with Apple Computer, Inc., then you can use your signature to define the class of events that belong to your application. Note, however, that Apple reserves the use of all event classes whose names contain only lowercase letters and nonalphabetic characters. <A NAME=MARKER-21-650></A><P>
 For high-level events, the <CODE>where</CODE> field in the event record contains a second message specifier, called the <I>event ID</I>. The event ID defines the particular type of event (or message) within the class of events defined by the event class. For example, the Section Read event sent by the Edition Manager has event class '<CODE>sect</CODE>' and event ID '<CODE>read</CODE>'. The Open Documents event sent by the Finder has event class '<CODE>aevt</CODE>' and event ID '<CODE>odoc</CODE>'. You can define your own set of event IDs corresponding to your own event class. For example, if the <CODE>message</CODE> field contains '<CODE>biff</CODE>' and the <CODE>where</CODE> field contains '<CODE>cmd1</CODE>', then the high-level event indicates the type of event defined by '<CODE>cmd1</CODE>' within the class of events defined by the application with the signature '<CODE>biff</CODE>'. <A NAME=MARKER-2-558></A><P>
<DL>
<DT><B>Note</B>
<DD>If your application supports Apple events, you can call the <CODE>AEProcessAppleEvent</CODE> function to determine the type of Apple event received, rather than examining the <CODE>message</CODE> and <CODE>where</CODE> fields. <A NAME=MARKER-2-292></A><EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 Note that because the <CODE>where</CODE> field of an event record for a high-level event is used to select a specific kind of event (within the class determined by the <CODE>message</CODE> field), high-level event records do not contain the mouse location at the time of the event. You should not interpret the <CODE>where</CODE> field before interpreting the <CODE>what</CODE> field because different event classes can contain overlapping sets of event IDs. <A NAME=MARKER-2-348></A> <P>
 Unlike low-level events and operating-system events, high-level events may not be completely determined by the event record returned to your application when it calls <CODE>WaitNextEvent</CODE>. For example, you might still need to know which other application sent you the high-level event or what additional data that application wants to send you. Your application can obtain this further information about the high-level event by calling the <CODE>AcceptHighLevelEvent</CODE> function. The additional information associated with a high-level event includes<A NAME=MARKER-2-209></A><A NAME=MARKER-9-161></A><P>
<UL>
<LI>the identity of the sender of the event
<LI>a unique number that identifies the request associated with the event or associates the particular event with a request from a previous event
<LI>the address and length of a data buffer that can contain optional data<P>
</UL>
 To obtain this additional information, your application must call <CODE>AcceptHighLevelEvent</CODE> before calling <CODE>WaitNextEvent</CODE> again. By convention, <BR>calling <CODE>AcceptHighLevelEvent</CODE> indicates that your application intends to process <BR>the high-level event.<P>
 <A NAME=MARKER-9-427></A>To accept an Apple event, call the <CODE>AEProcessAppleEvent</CODE> function instead of <BR>the <CODE>AcceptHighLevelEvent</CODE> function. The Apple Event Manager also extracts <BR>any additional information associated with the Apple event at your application's request. This chapter discusses how to accept high-level events using the <CODE>AcceptHighLevelEvent</CODE> function; for information on the <CODE>AEProcessAppleEvent</CODE> function, see <I><A HREF="../IAC/IAC-2.html">Inside Macintosh: Interapplication Communication</A></I>.<P>
<A NAME=HEADING42-17></A>
<H3><A NAME=MARKER-9-285></A>Responding to Events From Other Applications</H3>
 <A NAME=MARKER-2-496></A>You can identify high-level events by the value in the <CODE>what</CODE> field of the event record. The <CODE>message</CODE> and <CODE>where</CODE> fields further classify the type of high-level event. Your application can choose to recognize as many events as are appropriate. Some high-level events may be fully specified by their event record only, while others may include additional information in an optional buffer. To get that additional information or to find the sender of the event, use the <CODE>AcceptHighLevelEvent</CODE> function.<P>
<DL>
<DT><B>Note</B>
<DD>To respond to an Apple event, use the Apple Event Manager, as described in <I><A HREF="../IAC/IAC-2.html">Inside Macintosh: Interapplication Communication</A></I>.<EM> u</EM>   <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 <A HREF=#MARKER-9-289>Listing 2-16</A> on the next page illustrates how to respond to a high-level event.<P>
 The <CODE>DoHighLevelEvent</CODE> procedure in <A HREF=#MARKER-9-289>Listing 2-16</A> first determines the type of high- level event received by checking the <CODE>message</CODE> and <CODE>where</CODE> fields of the event record. It then uses <CODE>AcceptHighLevelEvent</CODE> to get any additional data associated with the event. This particular application recognizes only one type of high-level event. If the event is not of this type, the code assumes that the event is an Apple event and calls <CODE>AEProcessAppleEvent</CODE> to handle the event.<P>
 In general, you cannot know in advance how big the optional data buffer is, so you can allocate a zero-length buffer and then resize it if the call to <CODE>AcceptHighLevelEvent</CODE> returns the <CODE>bufferIsSmall</CODE> result code.<A NAME=MARKER-2-187></A><A NAME=MARKER-2-188></A><P>
<B>Listing 2-16  <A NAME=MARKER-9-289></A>Accepting a high-level event <A NAME=MARKER-2-196></A><A NAME=MARKER-2-236></A></B><P>
<PRE>
PROCEDURE DoHighLevelEvent (event: EventRecord);
VAR
   myTarg:     TargetID;      {target ID record}
   myRefCon:   LongInt;
   myBuff:     Ptr;
   myLen:      LongInt;
   myErr:      OSErr;
BEGIN
   IF (event.message = LongInt(kMySpecialHLEventClass)) AND
      (LongInt(event.where) = LongInt(kMySpecialHLEventID)) THEN
   BEGIN
      {it's a high-level event that doesn't use AEIMP}
      myLen := 0;                {start with a 0-byte buffer}
      myBuff := NIL;
      myErr:=AcceptHighLevelEvent(myTarg,myRefCon, myBuff, myLen);
      IF myErr = bufferIsSmall THEN
      BEGIN
         myBuff := NewPtr(myLen);{allocate needed storage}
         myErr := AcceptHighLevelEvent(myTarg, myRefCon, myBuff,
                                       myLen);
         IF myErr = noErr THEN
            ;  {perform any action requested by the event}
      END;
      IF myErr &lt;&gt; noErr THEN
         DoError(myErr);{perform the necessary error handling}
   END
   ELSE
   BEGIN {otherwise, assume that the event is an Apple event}
      myErr := AEProcessAppleEvent(event);
      IF myErr &lt;&gt; noErr THEN
         DoError(myErr);{perform the necessary error handling}
   END;
END;
</PRE>
 The <CODE>AcceptHighLevelEvent</CODE> function returns additional information and data associated with the event. The ID of the sender of the event is returned in the first parameter, which is a target ID record. You can inspect the fields of that record to determine which application sent the event. The target ID record contains the session reference number that identifies the connection with the other application as well as the port name and location name of the sender. If the high-level event requires that you return information, you can use the information returned in the target ID record to <BR>send an event back to the requesting application. See <A HREF=#MARKER-9-299>"Determining the Sender of a High-Level Event"</A> on <A HREF=#MARKER-9-299>page 2-72</A> and <A HREF=#MARKER-9-303>"Sending High-Level Events" on page 2-73</A> for specific information on the target ID record.<P>
 The second parameter to <CODE>AcceptHighLevelEvent</CODE>, the reference constant parameter, is a unique number that identifies the request associated with the event or identifies that the particular event is related to a request from a previous event. If you send a response to this event, you should use the same value for the reference constant so that the sender of the event can associate the reply with the original request.<P>
 The third parameter points to any additional data associated with the event. Any data <BR>in this additional buffer is defined by the particular high-level event. On input, the fourth parameter to <CODE>AcceptHighLevelEvent</CODE>, the length parameter, contains the <BR>size of the buffer. If no error occurs, on output the length parameter contains the size <BR>of the message accepted. If the <CODE>AcceptHighLevelEvent</CODE> function returns the result code <CODE>bufferIsSmall</CODE>, the length parameter contains the size of the message yet to <BR>be received. <A NAME=MARKER-2-497></A><P>
<A NAME=HEADING42-28></A>
<H3>Searching for a Specific High-Level Event</H3>
 <A NAME=MARKER-2-585></A>Sometimes you do not want to accept the next available high-level event pending for your application. Instead, you might want to select one event from among all the high-level events in your application's high-level event queue. For example, you might want to look for a return receipt for a high-level event you previously posted before processing other high-level events.<P>
 You can select a specific high-level event by calling the <CODE>GetSpecificHighLevelEvent</CODE> function. One of the parameters you pass to this function is a filter function that you provide. Your filter function should examine an event in your application's high-level event queue and determine whether it is the kind of event you wish to receive. If it is, your filter function returns <CODE>TRUE</CODE>. This indicates that your filter function does not want to inspect any more events. If the filter function finds an event of the desired type, it should call <CODE>AcceptHighLevelEvent</CODE> to retrieve the event. When your function returns <CODE>TRUE</CODE>, the <CODE>GetSpecificHighLevelEvent</CODE> function itself returns <CODE>TRUE</CODE>.<A NAME=MARKER-2-194></A><P>
 If your filter function returns <CODE>FALSE</CODE> for an event in the high-level event queue, then <CODE>GetSpecificHighLevelEvent</CODE> looks at the next event in the high-level event queue and executes your filter function. If the filter function returns <CODE>FALSE</CODE> for all the high-<BR>level events in the queue, then <CODE>GetSpecificHighLevelEvent</CODE> itself returns <CODE>FALSE</CODE> to your application.<P>
 Here's how you declare the filter function whose address you pass to the <CODE>GetSpecificHighLevelEvent</CODE> function: <A NAME=MARKER-21-639></A><P>
<PRE>
FUNCTION MyFilter (yourDataPtr: Ptr; 
                   msgBuff: HighLevelEventMsgPtr;
                   sender: TargetID): Boolean;
</PRE>
 When your application calls <CODE>GetSpecificHighLevelEvent</CODE>, you pass it a parameter that indicates the criteria your filter function should use to search for a specific event. The <CODE>GetSpecificHighLevelEvent</CODE> function passes this information to your filter function in the <CODE>yourDataPtr</CODE> parameter. The <CODE>GetSpecificHighLevelEvent</CODE> function also provides your filter function with information about the event record of the high-level event in the <CODE>msgBuff</CODE> parameter as well as information about the sender of the high-level event in the <CODE>sender</CODE> parameter.<P>
 The <CODE>msgBuff</CODE> parameter contains a pointer to a high-level event message record that has this structure:<A NAME=MARKER-2-297></A><P>
<PRE>
TYPE  HighLevelEventMsg =
      RECORD
         HighLevelEventMsgHeaderLength:      Integer;
         version:                            Integer;
         reserved1:                          LongInt;
         theMsgEvent:                        EventRecord;
         userRefCon:                         LongInt;
         postingOptions:                     LongInt;
         msgLength:                          LongInt;
      END;

      HighLevelEventMsgPtr= ^HighLevelEventMsg;
</PRE>
 When you call <CODE>GetSpecificHighLevelEvent</CODE> and it executes your filter function for a high-level event waiting in the high-level event queue, the fields of the high-level event message record are filled in by the Event Manager. You can then compare the fields of this record to the information in the <CODE>yourDataPtr</CODE> parameter to determine whether that event suits your needs. For example, the <CODE>yourDataPtr</CODE> parameter might contain the signature of a return receipt. You can test its value against the event class of the event record contained in the <CODE>theMsgEvent</CODE> field of the high-level event message record.<A NAME=MARKER-2-546></A><P>
<A NAME=HEADING42-38></A>
<H3><A NAME=MARKER-9-299></A>Determining the Sender of a High-Level Event</H3>
 <A NAME=MARKER-2-535></A>When you receive a high-level event, part of the information returned by <CODE>AcceptHighLevelEvent</CODE> is the identity of the sender of the event. You can use that information to respond selectively to requests made by other applications or to find which application to send any replies to. The information about the sender is provided in the form of a target ID record, defined as follows:<P>
<PRE>
TYPE  TargetID = 
      RECORD
         sessionID:  LongInt;          {session reference number}
         name:       PPCPortRec;       {sender's port name}
         location:   LocationNameRec;  {sender's location name}
         recvrName:  PPCPortRec;       {reserved}
      END;
</PRE>
 The <CODE>sessionID</CODE> field corresponds to the session reference number created by the PPC Toolbox. This is a 32-bit number that uniquely identifies a PPC Toolbox session (or connection) with another application. The <CODE>name</CODE> and <CODE>location</CODE> fields contain the sender's port name and location name. If the sending application is on the same computer as the receiving application, you can determine the sending application's process serial number by calling the <CODE>GetProcessSerialNumberFromPortName</CODE> function.<A NAME=MARKER-2-236></A><A NAME=MARKER-2-295></A><P>
<A NAME=HEADING42-42></A>
<H3><A NAME=MARKER-9-303></A>Sending High-Level Events</H3>
 <A NAME=MARKER-9-640></A>You use the <CODE>PostHighLevelEvent</CODE> function to send a high-level event to another application. When doing so, you need to provide six pieces of information:<A NAME=MARKER-9-99></A><P>
<UL>
<LI>an event record with the event class and event ID assigned appropriately
<LI>the identity of the recipient of the event
<LI>a unique number that identifies the communication associated with this <BR>particular event
<LI>a data buffer that can contain optional data
<LI>the length of the data buffer
<LI>options determining how the event is posted<P>
</UL>
<DL>
<DT><B>Note</B>
<DD>To send an Apple event, use the Apple Event Manager function <BR><CODE>AESend</CODE>. The Apple Event Manager uses the Event Manager to post Apple events. For information on posting Apple events, see <I><A HREF="../IAC/IAC-2.html">Inside Macintosh: Interapplication Communication</A></I>.<A NAME=MARKER-2-509></A><EM> u</EM>   <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 When you post a high-level event to an application on the same computer, you can specify its recipient in one of four ways:<P>
<UL>
<LI>by port name and location name (specified in a target ID record)
<LI>by a session reference number
<LI>by the application's creator signature
<LI>by a process serial number<P>
</UL>
 To specify the recipient of a high-level event sent across a network, you can use only <BR>the receiving application's port name and location name or its session reference number. You can use any of the four ways when sending high-level events to applications on the local computer.<P>
 You specify the recipient of a high-level event in the <CODE>receiverID</CODE> parameter when you use the <CODE>PostHighLevelEvent</CODE> function. To specify a port name and location name, provide the address of a target ID record in the <CODE>receiverID</CODE> parameter. To specify a process serial number, provide its address in the <CODE>receiverID</CODE> parameter. To specify a session reference number, or signature, provide the data in the <CODE>receiverID</CODE> parameter.<P>
 When you are replying to a high-level event, it is easy to identify the recipient because you can use the target ID record that you receive from <CODE>AcceptHighLevelEvent</CODE>, the session reference number contained in that target ID record, or the process serial number (if the receiving process is local). Note that replying by session reference number is always the fastest way to respond to a high-level event.<P>
 <A NAME=MARKER-2-52></A>When you are not replying to a previous event, you need to determine the identity of <BR>the target application yourself. You can use one of several methods to do this. If the target application is on the local computer, you can search for that application's creator signature or its process serial number by calling the <CODE>GetProcessInformation</CODE> function. See the chapter "Process Manager" in <I><A HREF="../Processes/Processes-2.html">Inside Macintosh: Processes</A></I> for a detailed explanation of the <CODE>GetProcessInformation</CODE> function and for examples of how to use it to generate a list of process serial numbers of all open processes on the local computer.<A NAME=MARKER-2-28></A><P>
 If the application to which you want to send a high-level event is located on a remote computer, you need to identify it either by its session reference number or by its port name and location name. You can call the <CODE>PPCBrowser</CODE> function to let the user browse for a specific port. You can call the <CODE>IPCListPorts</CODE> function to obtain a list of all ports registered with the target PPC Toolbox. See the chapter "Program-to-Program Communications Toolbox" in <I><A HREF="../IAC/IAC-2.html">Inside Macintosh: Interapplication Communication</A></I> for an explanation of both of these functions.<A NAME=MARKER-2-308></A><P>
 As just described, you can identify the recipient of the high-level event in one of four ways. <A HREF=#MARKER-9-310>Listing 2-17</A> illustrates how to send a high-level event to an application on the local computer using the application's creator signature. In this example, an application is sending a high-level event to the application with the creator signature of <CODE>'boff'</CODE>. The specific high-level event being sent is identified by the event class<DFN> <CODE>'boff'</CODE></DFN> and the event ID <CODE>'cmd1'</CODE>.<P>
<B>Listing 2-17  <A NAME=MARKER-9-310></A>Posting a high-level event by application signature<A NAME=MARKER-2-247></A></B><P>
<PRE>
PROCEDURE MyPostTest;
VAR
   myEvent:    EventRecord;   {an event record}
   myRecvID:   OSType;        {receiver ID}
   myOpts:     LongInt;       {posting options}
   myErr:      OSErr;
BEGIN
   myEvent.what := kHighLevelEvent;
   myEvent.message := LongInt('boff');       {event class}
   myEvent.where := Point(LongInt('cmd1'));  {event ID}
   {the receiver is identified by its signature and }
   { a return receipt is requested}
   myOpts := receiverIDisSignature + nReturnReceipt;
   myRecvID := 'boff';                    {receiver's signature}
   myErr := PostHighLevelEvent(myEvent, Ptr(myRecvID), 0, NIL, 0, 
                                 myOpts);
   IF myErr &lt;&gt; noErr THEN
      DoError(myErr);
END;
</PRE>
 In this example of using the PostHighLevelEvent function, there is no additional data to transmit, so the sending application provides <CODE>NIL</CODE> as the pointer to the data buffer and sets the buffer length to 0. The <CODE>myOpts</CODE> variable specifies posting options.<P>
 Posting options are of two types: delivery options and options associated with the <CODE>receiverID</CODE> parameter. You can specify one or more delivery options to indicate if you want the other application to receive the event at the next opportunity and to indicate if you want acknowledgment that the other application received the event. You use the options associated with the <CODE>receiverID</CODE> parameter to indicate how you are specifying the recipient of the event. To set the various posting options, use these constants:<A NAME=MARKER-2-244></A><A NAME=MARKER-2-245></A><P>
<PRE>
CONST nAttnMsg                = $00000001;{give this message priority}
      nReturnReceipt          = $00000200;{return receipt requested}
      receiverIDisTargetID    = $00005000;{ID is port name and location name}
      receiverIDisSessionID   = $00006000;{ID is PPC session ref number}
      receiverIDisSignature   = $00007000;{ID is creator signature}
      receiverIDisPSN         = $00008000;{ID is process serial number}
</PRE>
 When you specify the receiving application in the <CODE>receiverID</CODE> parameter, you can use these constants to specify the receiver of the event by port name and location name, session reference number, process serial number, or signature. Any of these specifications allows you to send an event to another application on the local computer. For example, in <A HREF=#MARKER-9-310>Listing 2-17</A> the <CODE>myOpts</CODE> variable indicates that the receiver is identified by its creator signature, and the <CODE>myRecvID</CODE> variable contains the receiver's creator signature. To send events to an application on a remote computer, you can specify the recipient only by the session reference number or by the port name and location name.<P>
 When you specify the receiver of the event by port name and location name, use the <CODE>receiverIDisTargetID</CODE> constant in the posting options parameter and specify the address of a target ID record in the <CODE>receiverID</CODE> parameter. <A NAME=MARKER-2-77></A><P>
<PRE>
TYPE  TargetID = 
      RECORD
         sessionID:  LongInt;       {unused for posting}
         name:       PPCPortRec;    {recipient's port name}
         location:   LocationNameRec;{recipient's port loc}
         recvrName:  PPCPortRec;    {unused for posting}
      END;
</PRE>
 When you pass a target ID record, you need to specify only the <CODE>name</CODE> and <CODE>location</CODE> fields. You can use the <CODE>IPCListPorts</CODE> function to list all of the existing port names along with information on whether the port will accept authenticated service on the computer specified by the location name. For information on how to use the <CODE>IPCListPorts</CODE> function, see the chapter "Program-to-Program Communications Toolbox" in <I><A HREF="../IAC/IAC-2.html">Inside Macintosh: Interapplication Communication</A></I>. <A NAME=MARKER-2-84></A><P>
 You can also use the <CODE>PPCBrowser</CODE> function to fill in a target ID record. <A HREF=#MARKER-9-318>Listing 2-18</A> on the next page illustrates how to use the <CODE>PPCBrowser</CODE> function to post a high-level event. In this example, the sending application wants to locate a dictionary application and have the dictionary return the definition of a word to it.<A NAME=MARKER-2-255></A><A NAME=MARKER-2-256></A><P>
<B>Listing 2-18  <A NAME=MARKER-9-318></A>Using the <CODE>PPCBrowser</CODE> function to post a high-level event <A NAME=MARKER-2-319></A></B><P>
<PRE>
FUNCTION MyPostWithPPCBrowser (aTextPtr: Ptr; textlength: LongInt): OSErr;
VAR
   myHLEvent:     EventRecord;
   myErr:         OSErr;
   myNumTries:    Integer;
   myPortInfo:    PortInfoRec;
   myTarget:      TargetID;
BEGIN
   {use PPCBrowser to get the target}
   myErr := PPCBrowser('Select an Application', 'Application', FALSE,
                       myTarget.location, myPortInfo, NIL, '');
   IF myErr = NoErr THEN
   BEGIN
      {copy port name into myTarget.name}
      myTarget.name := myPortInfo.name;
      
      myHLEvent.what := kHighLevelEvent;
      myHLEvent.message := LongInt('Dict');
      myHLEvent.where := Point(LongInt('Defn'));

      {if a connection is broken, then sessClosedErr is returned to }
      { PostHighLevelEvent; to reestablish the connection, just post }
      { the event one more time}
      myNumTries := 0;
      REPEAT
         myErr := PostHighLevelEvent(myHLEvent, @myTarget, 0, aTextPtr,
                                     textlength, receiverIDisTargetID);
         myNumTries := myNumTries + 1;
      UNTIL (myErr &lt;&gt; sessClosedErr) OR (myNumTries &gt; 1);
   END;
   MyPostWithPPCBrowser := myErr;   {return any error}
END;
</PRE>
 The application-defined function in <A HREF=#MARKER-9-318>Listing 2-18</A> uses the <CODE>PPCBrowser</CODE> function to display a dialog box asking the user to select a dictionary. (For additional information <BR>on the <CODE>PPCBrowser</CODE> function, see <I><A HREF="../IAC/IAC-2.html">Inside Macintosh: Interapplication Communication</A></I>.) If <BR>the user selects a dictionary, this code posts a high-level event to that dictionary application asking for the definition of the selected text. Note that the sending application and the receiving application must both agree that definition queries are to be of event class '<CODE>Dict</CODE>' and event ID '<CODE>Defn</CODE>'. It is necessary to define a private protocol only in cases in which no suitable Apple event exists.<P>
<DL>
<DT><B>Note</B>
<DD>You should avoid passing handles to the receiving application in an attempt to share a block of data. It is better to put the relevant data into a buffer (as illustrated in <A HREF=#MARKER-9-318>Listing 2-18</A>) and pass the address of the buffer. If you absolutely must share data by passing a handle, make sure that the block of data is located in the system heap.<EM> u</EM>   <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 If a high-level event is posted successfully, <CODE>PostHighLevelEvent</CODE> returns the result code <CODE>noErr</CODE>, which indicates only that the event was successfully passed to the PPC Toolbox. Your application needs to call another Event Manager routine (<CODE>EventAvail</CODE>, <CODE>GetNextEvent</CODE>, or <CODE>WaitNextEvent</CODE>) to give the other application an opportunity to receive the event.<A NAME=MARKER-2-303></A><P>
 <A NAME=MARKER-2-321></A>The event you send might require the other application to return some information to your application by sending a high-level event back to your application. You can scan for the response by using <CODE>GetSpecificHighLevelEvent</CODE>. If your application must wait for this event, you might want to display a wristwatch cursor or take other action as appropriate to your application. You also might want to implement a timeout mechanism in case your application never receives a response to the event. <A NAME=MARKER-2-551></A><P>
<A NAME=HEADING42-78></A>
<H3>Requesting Return Receipts</H3>
 <A NAME=MARKER-2-315></A>When you post a high-level event, you can request a return receipt by including the <CODE>nReturnReceipt</CODE> constant as one of the posting options. This requests that the Event Manager send your application a high-level event that tells you whether the other application accepted your event. Note that this does not necessarily mean that the other application performed any action you might have requested from it.<A NAME=MARKER-2-257></A><A NAME=MARKER-2-258></A><P>
 A<B> return receipt</B> is a high-level event having an event class and an event ID indicated by these two constants:<P>
<PRE>
CONST HighLevelEventMsgClass  = 'jaym';
      rtrnReceiptMsgID        = 'rtrn';
</PRE>
 Return receipts are posted by the Event Manager on the computer of the receiving application (and not by the receiving application itself). No data buffer is associated with a return receipt. However, the posting Event Manager sets the <CODE>modifiers</CODE> field of the high-level event record to one of the following values:<P>
<PRE>
CONST msgWasNotAccepted       = 0;
      msgWasFullyAccepted     = 1;
      msgWasPartiallyAccepted = 2;
</PRE>
 The <CODE>msgWasNotAccepted</CODE> constant indicates that your event was not accepted by <BR>the receiving application. This means that the receiving application was notified <BR>of the arrival of your event (through <CODE>WaitNextEvent</CODE>) but did not call <CODE>AcceptHighLevelEvent</CODE> to accept the event. The <CODE>msgWasFullyAccepted</CODE> constant indicates that the receiving application did call <CODE>AcceptHighLevelEvent</CODE> and retrieved all the data in the optional data buffer. The <CODE>msgWasPartiallyAccepted</CODE> constant indicates that the receiving application called <CODE>AcceptHighLevelEvent</CODE>, but the application's data buffer was too small to hold the data sent with your application, and the receiving application called <CODE>WaitNextEvent</CODE> before retrieving the rest of the buffer.<P>
 Note that a return receipt does not indicate the identity of the receiving application. To determine on whose behalf the Event Manager has sent you a particular return receipt, you need to call <CODE>AcceptHighLevelEvent</CODE>. When <CODE>AcceptHighLevelEvent</CODE> returns successfully, the <CODE>sender</CODE> parameter contains a target ID record with the fields filled in for the receiving application. With return receipts, the <CODE>msgLen</CODE> parameter is 0, the <CODE>msgBuff</CODE> parameter is <CODE>NIL</CODE>, and the <CODE>msgRefCon</CODE> parameter contains the unique number of the <CODE>refCon</CODE> parameter of the original high-level event sender (that is, your application).<P>
<A NAME=HEADING42-86></A>
<H3>Handling Apple Events</H3>
 <A NAME=MARKER-2-317></A>If your application uses high-level events, your application must respond to the <BR>required Apple events sent by the Finder. The four required Apple events are Open Application, Open Documents, Print Documents, and Quit Application. See <I><A HREF="../IAC/IAC-2.html">Inside Macintosh: Interapplication Communication</A></I> for information on how to handle the required Apple events.<P>
 When your application receives a high-level event (as indicated by the <CODE>kHighLevelEvent</CODE> constant in the <CODE>what</CODE> field of the event record), and if your application supports Apple events, call the <CODE>AEProcessAppleEvent</CODE> function. The <CODE>AEProcessAppleEvent</CODE> function provides an easy way for your application to identify the event class and event ID of the Apple event and to direct the Apple Event Manager to call the code in your program that handles the Apple event.<A NAME=MARKER-2-294></A><P>
 To send Apple events to other applications, use the <CODE>AESend</CODE> function.<A NAME=MARKER-2-508></A><P>
 To ensure compatibility and smooth interaction with other Macintosh applications, you should use the Apple event protocol for high-level events whenever possible. By implementing the capabilities to send Apple events to and receive Apple events from other applications, you allow other applications to interact with your application and provide enhanced capabilities to your users.<P>
 See <I><A HREF="../IAC/IAC-2.html">Inside Macintosh: Interapplication Communication</A></I> for complete information on how to send and receive Apple events. <A NAME=MARKER-2-555></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Toolbox-41.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Toolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Toolbox-490.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Toolbox-43.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Toolbox-3.html">&copy; Apple Computer, Inc.</A><br>11 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
