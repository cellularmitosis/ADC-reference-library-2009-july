/****************************//*   	QD3D SUPPORT.C	    *//* (c)1996 Pangea Software  *//* By Brian Greenstone      *//****************************//****************************//*    EXTERNALS             *//****************************/#include <QD3D.h>#include <QD3DGroup.h>#include <QD3DLight.h>#include <QD3DPick.h>#include <QD3DTransform.h>#include <QD3DStorage.h>#include <QD3DMath.h>#include <QD3DErrors.h>#include <Rave.h>#include <timer.h>#include "myglobals.h"#include "misc.h"#include "qd3d_support.h"#include "mywindows.h"extern	EventRecord			gTheEvent;extern	short				gHtab;extern	long	gTotalNumVertecies,gTotalNumFaces,gTotalMeshes;extern	WindowPtr			gModelWindow;/****************************//*    PROTOTYPES            *//****************************/static void CreateDrawContext(QD3DViewDefType *viewDefPtr);static void SetStyles(QD3DStyleDefType *styleDefPtr);static void CreateCamera(QD3DCameraDefType *cameraDefPtr);static void CreateLights(QD3DLightDefType *lightDefPtr);static void CreateView(QD3DSetupInputType *setupDefPtr);static void CreateTexturePixmap(PicHandle pict,unsigned long mapSizeX,							 unsigned long mapSizeY, TQ3StoragePixmap *bMap);static void DrawPICTIntoPixmap(PicHandle pict,unsigned long mapSizeX,				 unsigned long mapSizeY, TQ3StoragePixmap *bMap);static void GWorldToBMap(GWorldPtr pGWorld, TQ3StoragePixmap *bMap);static void TraverseDisplayGroupInfo(TQ3Object theGroup);static void ShowMeshInfo(TQ3Object theMesh);static void ShowAttributeInfo(TQ3AttributeSet theAttribute);static void ShowTriMeshInfo(TQ3Object theTriMesh);/****************************//*    CONSTANTS             *//****************************//*********************//*    VARIABLES      *//*********************/static TQ3CameraObject			gQD3D_CameraObject;static TQ3GroupObject			gQD3D_LightGroup;static TQ3ViewObject			gQD3D_ViewObject;static TQ3DrawContextObject		gQD3D_DrawContext;static TQ3RendererObject		gQD3D_RendererObject;static TQ3ShaderObject			gQD3D_ShaderObject;static	TQ3StyleObject			gQD3D_BackfacingStyle;static	TQ3StyleObject			gQD3D_FillStyle;static	TQ3StyleObject			gQD3D_InterpolationStyle;float	gFramesPerSecond = DEFAULT_FPS;				// this is used to maintain a constant timing velocity as frame rates differ//=======================================================================================================//=============================== VIEW WINDOW SETUP STUFF ===============================================//=======================================================================================================/************** SETUP QD3D WINDOW *******************/void QD3D_SetupWindow(QD3DSetupInputType *setupDefPtr, QD3DSetupOutputType *outputPtr){	CreateView(setupDefPtr);	Q3InteractiveRenderer_SetDoubleBufferBypass(gQD3D_RendererObject,kQ3True);		// let hardware go fast		CreateCamera(&setupDefPtr->camera);										// create new CAMERA object	CreateLights(&setupDefPtr->lights);	SetStyles(&setupDefPtr->styles);						/* DISPOSE OF EXTRA REFERENCES */					Q3Object_Dispose(gQD3D_RendererObject);				// (is contained w/in gQD3D_ViewObject)					/* PASS BACK INFO */					outputPtr->viewObject = gQD3D_ViewObject;	outputPtr->interpolationStyle = gQD3D_InterpolationStyle;	outputPtr->fillStyle = gQD3D_FillStyle;	outputPtr->backfacingStyle = gQD3D_BackfacingStyle;	outputPtr->shaderObject = gQD3D_ShaderObject;	outputPtr->cameraObject = gQD3D_CameraObject;	outputPtr->lightGroup = gQD3D_LightGroup;	outputPtr->drawContext = gQD3D_DrawContext;	outputPtr->window = setupDefPtr->view.displayWindow;		// remember which window	outputPtr->paneClip = setupDefPtr->view.paneClip;}/***************** QD3D_DisposeWindowSetup ***********************///// Disposes of all data created by QD3D_SetupWindow//void QD3D_DisposeWindowSetup(QD3DSetupOutputType *data){	Q3Object_Dispose(data->viewObject);	Q3Object_Dispose(data->interpolationStyle);	Q3Object_Dispose(data->backfacingStyle);	Q3Object_Dispose(data->fillStyle);	Q3Object_Dispose(data->cameraObject);	Q3Object_Dispose(data->lightGroup);	Q3Object_Dispose(data->drawContext);	Q3Object_Dispose(data->shaderObject);}/******************* CREATE GAME VIEW *************************/static void CreateView(QD3DSetupInputType *setupDefPtr){TQ3Status	myErr;unsigned long	hints;				/* CREATE NEW VIEW OBJECT */					gQD3D_ViewObject = Q3View_New();	if (gQD3D_ViewObject == nil)		DoFatalAlert("\pQ3View_New failed!");			/* CREATE & SET DRAW CONTEXT */		CreateDrawContext(&setupDefPtr->view); 								// init draw context		myErr = Q3View_SetDrawContext(gQD3D_ViewObject, gQD3D_DrawContext);			// assign context to view	if (myErr == kQ3Failure)		DoFatalAlert("\pQ3View_SetDrawContext Failed!");			/* CREATE & SET RENDERER */	gQD3D_RendererObject = Q3Renderer_NewFromType(setupDefPtr->view.rendererType);	// create new RENDERER object	if (gQD3D_RendererObject == nil)	{		QD3D_ShowError("\pQ3Renderer_NewFromType Failed!", true);		CleanQuit();	}	myErr = Q3View_SetRenderer(gQD3D_ViewObject, gQD3D_RendererObject);				// assign renderer to view	if (myErr == kQ3Failure)		DoFatalAlert("\pQ3View_SetRenderer Failed!");		/* SET RENDERER FEATURES */			Q3InteractiveRenderer_GetRAVEContextHints(gQD3D_RendererObject, &hints);	hints &= ~kQAContext_NoZBuffer; 				// Z buffer is on 	hints &= ~kQAContext_DeepZ; 					// Z buffer is not deep, ergo it's shallow 	hints |= kQAContext_NoDither; 					// No Dither 	Q3InteractiveRenderer_SetRAVEContextHints(gQD3D_RendererObject, hints);			Q3InteractiveRenderer_SetRAVETextureFilter(gQD3D_RendererObject,kQATextureFilter_Mid);	// fast texturing	Q3InteractiveRenderer_SetDoubleBufferBypass(gQD3D_RendererObject,kQ3True);}/**************** CREATE SKELETON DRAW CONTEXT *********************/static void CreateDrawContext(QD3DViewDefType *viewDefPtr){TQ3DrawContextData		drawContexData;TQ3MacDrawContextData	myMacDrawContextData;Rect					r;	r = viewDefPtr->displayWindow->portRect;			/* FILL IN DRAW CONTEXT DATA */	drawContexData.clearImageMethod = kQ3ClearMethodWithColor;				// how to clear	drawContexData.clearImageColor = viewDefPtr->clearColor;				// color to clear to	drawContexData.pane.min.x = r.left+viewDefPtr->paneClip.left;			// set bounds?	drawContexData.pane.max.x = r.right-viewDefPtr->paneClip.right;	drawContexData.pane.min.y = r.top+viewDefPtr->paneClip.top;	drawContexData.pane.max.y = r.bottom-viewDefPtr->paneClip.bottom;	drawContexData.paneState = kQ3True;										// use bounds?	drawContexData.maskState = kQ3False;									// no mask	drawContexData.doubleBufferState = kQ3True;								// double buffering	myMacDrawContextData.drawContextData = drawContexData;					// set MAC specifics	myMacDrawContextData.window = (CWindowPtr)viewDefPtr->displayWindow;	// assign window to draw to	myMacDrawContextData.library = kQ3Mac2DLibraryNone;						// use standard QD libraries (no GX crap!)	myMacDrawContextData.viewPort = nil;									// (for GX only)	myMacDrawContextData.grafPort = (CWindowPtr)viewDefPtr->displayWindow;	// assign grafport			/* CREATE DRAW CONTEXT */	gQD3D_DrawContext = Q3MacDrawContext_New(&myMacDrawContextData);	if (gQD3D_DrawContext == nil)		DoFatalAlert("\pQ3MacDrawContext_New Failed!");}/**************** SET STYLES ****************///// Creates style objects which define how the scene is to be rendered.// It also sets the shader object.//static void SetStyles(QD3DStyleDefType *styleDefPtr){				/* SET INTERPOLATION (FOR SHADING) */						gQD3D_InterpolationStyle = Q3InterpolationStyle_New(styleDefPtr->interpolation);	if (gQD3D_InterpolationStyle == nil)		DoFatalAlert("\pQ3InterpolationStyle_New Failed!");					/* SET BACKFACING */	gQD3D_BackfacingStyle = Q3BackfacingStyle_New(styleDefPtr->backfacing);	if (gQD3D_BackfacingStyle == nil )		DoFatalAlert("\pQ3BackfacingStyle_New Failed!");				/* SET POLYGON FILL STYLE */							gQD3D_FillStyle = Q3FillStyle_New(styleDefPtr->fill);	if ( gQD3D_FillStyle == nil )		DoFatalAlert("\p Q3FillStyle_New Failed!");					/* SET THE SHADER TO USE */	switch(styleDefPtr->illuminationType)	{		case	kQ3IlluminationTypePhong:				gQD3D_ShaderObject = Q3PhongIllumination_New();				if ( gQD3D_ShaderObject == nil )					DoFatalAlert("\p Q3PhongIllumination_New Failed!");				break;						case	kQ3IlluminationTypeLambert:				gQD3D_ShaderObject = Q3LambertIllumination_New();				if ( gQD3D_ShaderObject == nil )					DoFatalAlert("\p Q3LambertIllumination_New Failed!");				break;						case	kQ3IlluminationTypeNULL:				gQD3D_ShaderObject = Q3NULLIllumination_New();				if ( gQD3D_ShaderObject == nil )					DoFatalAlert("\p Q3NullIllumination_New Failed!");				break;	}	}/****************** CREATE CAMERA *********************/static void CreateCamera(QD3DCameraDefType *cameraDefPtr){TQ3CameraData					myCameraData;TQ3ViewAngleAspectCameraData	myViewAngleCameraData;TQ3Area							pane;TQ3Status						status;TQ3Status	myErr;	status = Q3DrawContext_GetPane(gQD3D_DrawContext,&pane);				// get window pane info	if (status == kQ3Failure)		DoFatalAlert("\pQ3DrawContext_GetPane Failed!");				/* FILL IN CAMERA DATA */					myCameraData.placement.cameraLocation = cameraDefPtr->from;			// set camera coords	myCameraData.placement.pointOfInterest = cameraDefPtr->to;			// set target coords	myCameraData.placement.upVector = cameraDefPtr->up;					// set a vector that's "up"	myCameraData.range.hither = cameraDefPtr->hither;					// set frontmost Z dist	myCameraData.range.yon = cameraDefPtr->yon;							// set farthest Z dist	myCameraData.viewPort.origin.x = -1.0;								// set view origins?	myCameraData.viewPort.origin.y = 1.0;	myCameraData.viewPort.width = 2.0;	myCameraData.viewPort.height = 2.0;	myViewAngleCameraData.cameraData = myCameraData;	myViewAngleCameraData.fov = cameraDefPtr->fov;						// larger = more fisheyed	myViewAngleCameraData.aspectRatioXToY =				(pane.max.x-pane.min.x)/(pane.max.y-pane.min.y);	gQD3D_CameraObject = Q3ViewAngleAspectCamera_New(&myViewAngleCameraData);	 // create new camera	if (gQD3D_CameraObject == nil)		DoFatalAlert("\pQ3ViewAngleAspectCamera_New failed!");			myErr = Q3View_SetCamera(gQD3D_ViewObject, gQD3D_CameraObject);		// assign camera to view	if (myErr == kQ3Failure)		DoFatalAlert("\pQ3View_SetCamera Failed!");}/********************* CREATE LIGHTS ************************/static void CreateLights(QD3DLightDefType *lightDefPtr){TQ3GroupPosition		myGroupPosition;TQ3LightData			myLightData;TQ3DirectionalLightData	myDirectionalLightData;TQ3LightObject			myLight;short					i;TQ3Status	myErr;			/* CREATE NEW LIGHT GROUP */				gQD3D_LightGroup = Q3LightGroup_New();						// make new light group	if ( gQD3D_LightGroup == nil )		DoFatalAlert("\p Q3LightGroup_New Failed!");	myLightData.isOn = kQ3True;									// light is ON				/************************/			/* CREATE AMBIENT LIGHT */			/************************/	if (lightDefPtr->ambientBrightness != 0)						// see if ambient exists	{		myLightData.color = lightDefPtr->ambientColor;				// set color of light		myLightData.brightness = lightDefPtr->ambientBrightness;	// set brightness value		myLight = Q3AmbientLight_New(&myLightData);					// make it		if ( myLight == nil )			DoFatalAlert("\pQ3AmbientLight_New Failed!");		myGroupPosition = Q3Group_AddObject(gQD3D_LightGroup, myLight);	// add to group		if ( myGroupPosition == 0 )			DoFatalAlert("\p Q3Group_AddObject Failed!");		Q3Object_Dispose(myLight);									// dispose of light	}			/**********************/			/* CREATE FILL LIGHTS */			/**********************/				for (i=0; i < lightDefPtr->numFillLights; i++)	{				myLightData.color = lightDefPtr->fillColor[i];						// set color of light		myLightData.brightness = lightDefPtr->fillBrightness[i];			// set brightness		myDirectionalLightData.lightData = myLightData;						// refer to general light info		myDirectionalLightData.castsShadows = kQ3False;						// no shadows		myDirectionalLightData.direction =  lightDefPtr->fillDirection[i];	// set fill vector		myLight = Q3DirectionalLight_New(&myDirectionalLightData);			// make it		if ( myLight == nil )			DoFatalAlert("\p Q3DirectionalLight_New Failed!");		myGroupPosition = Q3Group_AddObject(gQD3D_LightGroup, myLight);		// add to group		if ( myGroupPosition == 0 )			DoFatalAlert("\p Q3Group_AddObject Failed!");		Q3Object_Dispose(myLight);											// dispose of light	}				/* ASSIGN LIGHT GROUP TO VIEW */				myErr = Q3View_SetLightGroup(gQD3D_ViewObject, gQD3D_LightGroup);		// assign light group to view	if (myErr == kQ3Failure)		DoFatalAlert("\pQ3View_SetLightGroup Failed!");		}/******************** QD3D CHANGE DRAW SIZE *********************///// Changes size of stuff to fit new window size.//void QD3D_ChangeDrawSize(QD3DSetupOutputType *setupInfo){Rect			r;TQ3Area			pane;TQ3ViewAngleAspectCameraData	cameraData;			/* CHANGE DRAW CONTEXT PANE SIZE */				r = setupInfo->window->portRect;							// get size of window	pane.min.x = r.left+setupInfo->paneClip.left;										// set pane size	pane.max.x = r.right-setupInfo->paneClip.right;	pane.min.y = r.top+setupInfo->paneClip.top;	pane.max.y = r.bottom-setupInfo->paneClip.bottom;	Q3DrawContext_SetPane(setupInfo->drawContext,&pane);		// update pane in draw context				/* CHANGE CAMERA ASPECT RATIO */					Q3ViewAngleAspectCamera_GetData(setupInfo->cameraObject,&cameraData);			// get camera data	cameraData.aspectRatioXToY = (pane.max.x-pane.min.x)/(pane.max.y-pane.min.y);	// set new aspect ratio	Q3ViewAngleAspectCamera_SetData(setupInfo->cameraObject,&cameraData);			// set new camera data}/******************* QD3D DRAW SCENE *********************/void QD3D_DrawScene(QD3DSetupOutputType *setupInfo, void (*drawRoutine)(QD3DSetupOutputType *)){TQ3Status				myStatus;TQ3ViewStatus			myViewStatus;			/* START RENDERING *///startTrace("test.tt6");	myStatus = Q3View_StartRendering(setupInfo->viewObject);				if ( myStatus == kQ3Failure )	{		DoFatalAlert("\p Q3View_StartRendering Failed!");	}				/***************/			/* RENDER LOOP */			/***************/	do	{				/* DRAW STYLES */						myStatus = Q3Style_Submit(setupInfo->interpolationStyle,setupInfo->viewObject);		if ( myStatus == kQ3Failure )			DoFatalAlert("\p Q3Style_Submit Failed!");					myStatus = Q3Style_Submit(setupInfo->backfacingStyle,setupInfo->viewObject);		if ( myStatus == kQ3Failure )			DoFatalAlert("\p Q3Style_Submit Failed!");					myStatus = Q3Style_Submit(setupInfo->fillStyle, setupInfo->viewObject);		if ( myStatus == kQ3Failure )			DoFatalAlert("\p Q3Style_Submit Failed!");		myStatus = Q3Shader_Submit(setupInfo->shaderObject, setupInfo->viewObject);		if ( myStatus == kQ3Failure )			DoFatalAlert("\p Q3Shader_Submit Failed!");			/* CALL INPUT DRAW FUNCTION */		drawRoutine(setupInfo);		myViewStatus = Q3View_EndRendering(setupInfo->viewObject);			} while ( myViewStatus == kQ3ViewStatusRetraverse );	//stopTrace();//CleanQuit();}//=======================================================================================================//=============================== MISC ==================================================================//=======================================================================================================/************** QD3D CALC FRAMES PER SECOND *****************/float	QD3D_CalcFramesPerSecond(void){UnsignedWide	wide;unsigned long	now;static	unsigned long then = 0;Str255			s;	Microseconds(&wide);	now = wide.lo;	if (then != 0)	{		gFramesPerSecond = (float)1000000.0/(float)(now-then);		if (gFramesPerSecond < DEFAULT_FPS)			// (avoid divide by 0's later)			gFramesPerSecond = DEFAULT_FPS;			if (gTheEvent.modifiers & shiftKey)		{			SetPort(gModelWindow);			NumToString((long)(gFramesPerSecond+0.5),s);	// print # rounded up to nearest integer			MoveTo(29,12);			DrawString(s);			DrawString("\p  ");		}	}	else		gFramesPerSecond = DEFAULT_FPS;			then = now;								// remember time			return(gFramesPerSecond);}//=======================================================================================================//=============================== CAMERA STUFF ==========================================================//=======================================================================================================/*************** QD3D_UpdateCameraFromTo ***************/void QD3D_UpdateCameraFromTo(QD3DSetupOutputType *setupInfo, TQ3Point3D *from, TQ3Point3D *to){TQ3Status	status;TQ3CameraPlacement	placement;			/* GET CURRENT CAMERA INFO */				status = Q3Camera_GetPlacement(setupInfo->cameraObject, &placement);	if (status == kQ3Failure)		DoFatalAlert("\pQ3Camera_GetPlacement failed!");			/* SET CAMERA LOOK AT */				placement.pointOfInterest = *to;			/* SET CAMERA COORDS */				placement.cameraLocation = *from;				/* UPDATE CAMERA INFO */				status = Q3Camera_SetPlacement(setupInfo->cameraObject, &placement);	if (status == kQ3Failure)		DoFatalAlert("\pQ3Camera_SetPlacement failed!");}/*************** QD3D_UpdateCameraFrom ***************/void QD3D_UpdateCameraFrom(QD3DSetupOutputType *setupInfo, TQ3Point3D *from){TQ3Status	status;TQ3CameraPlacement	placement;			/* GET CURRENT CAMERA INFO */				status = Q3Camera_GetPlacement(setupInfo->cameraObject, &placement);	if (status == kQ3Failure)		DoFatalAlert("\pQ3Camera_GetPlacement failed!");			/* SET CAMERA COORDS */				placement.cameraLocation = *from;				/* UPDATE CAMERA INFO */				status = Q3Camera_SetPlacement(setupInfo->cameraObject, &placement);	if (status == kQ3Failure)		DoFatalAlert("\pQ3Camera_SetPlacement failed!");}/*************** QD3D_MoveCameraFrom ***************/void QD3D_MoveCameraFrom(QD3DSetupOutputType *setupInfo, TQ3Vector3D *moveVector){TQ3Status	status;TQ3CameraPlacement	placement;			/* GET CURRENT CAMERA INFO */				status = Q3Camera_GetPlacement(setupInfo->cameraObject, &placement);	if (status == kQ3Failure)		DoFatalAlert("\pQ3Camera_GetPlacement failed!");			/* SET CAMERA COORDS */				placement.cameraLocation.x += moveVector->x;	placement.cameraLocation.y += moveVector->y;	placement.cameraLocation.z += moveVector->z;				/* UPDATE CAMERA INFO */				status = Q3Camera_SetPlacement(setupInfo->cameraObject, &placement);	if (status == kQ3Failure)		DoFatalAlert("\pQ3Camera_SetPlacement failed!");}//=======================================================================================================//=============================== MATHMATICAL STUFF =====================================================//=======================================================================================================/***************** QD3D:  CALC FACE NORMAL *********************///// Returns the normal vector off the face defined by 3 points.//void QD3D_CalcFaceNormal(TQ3Point3D *p1, TQ3Point3D *p2, TQ3Point3D *p3, TQ3Vector3D *normal){TQ3Vector3D	v1,v2;	v1.x = (p1->x - p3->x);	v1.y = (p1->y - p3->y);	v1.z = (p1->z - p3->z);	v2.x = (p2->x - p3->x);	v2.y = (p2->y - p3->y);	v2.z = (p2->z - p3->z);	Q3Vector3D_Cross(&v1, &v2, normal);				// cross product == vector perpendicular to 2 other vectors	Q3Vector3D_Normalize(normal,normal);}/**************** ANGLE BETWEEN VECTORS ******************///// OUTPUT: the angle in radians between 2 3D vectors//float	QD3D_AngleBetweenVectors3D(TQ3Vector3D *v1, TQ3Vector3D *v2){float	dot,angle;	Q3Vector3D_Normalize(v1,v1);	// make sure they're normalized	Q3Vector3D_Normalize(v2,v2);	dot = Q3Vector3D_Dot(v1,v2);	// the dot product is the cosine of the angle between the 2 vectors	angle = acos(dot);				// get arc-cosine to get the angle out of it	return(angle);}/**************** X ANGLE BETWEEN VECTORS 3D ******************///// OUTPUT: the x-axis angle in radians between 2 3D vectors//float	QD3D_XAngleBetweenVectors3D(TQ3Vector3D *v1, TQ3Vector3D *v2){float	dot,angle;	v1->x = v2->x;	Q3Vector3D_Normalize(v1,v1);	// make sure they're normalized	Q3Vector3D_Normalize(v2,v2);	dot = Q3Vector3D_Dot(v1,v2);	// the dot product is the cosine of the angle between the 2 vectors	angle = acos(dot);				// get arc-cosine to get the angle out of it	return(-angle);}//=======================================================================================================//=============================== LIGHTS STUFF ==========================================================//=======================================================================================================/********************* QD3D ADD POINT LIGHT ************************/TQ3GroupPosition QD3D_AddPointLight(QD3DSetupOutputType *setupInfo,TQ3Point3D *point, TQ3ColorRGB *color, float brightness){TQ3GroupPosition		myGroupPosition;TQ3LightData			myLightData;TQ3PointLightData		myPointLightData;TQ3LightObject			myLight;	myLightData.isOn = kQ3True;											// light is ON		myLightData.color = *color;											// set color of light	myLightData.brightness = brightness;								// set brightness	myPointLightData.lightData = myLightData;							// refer to general light info	myPointLightData.castsShadows = kQ3False;							// no shadows	myPointLightData.location = *point;									// set coords		myPointLightData.attenuation =  kQ3AttenuationTypeInverseDistance;	// set attenuation	myLight = Q3PointLight_New(&myPointLightData);				// make it	if ( myLight == nil )		DoFatalAlert("\p Q3DirectionalLight_New Failed!");	myGroupPosition = Q3Group_AddObject(setupInfo->lightGroup, myLight);		// add to light group	if ( myGroupPosition == 0 )		DoFatalAlert("\p Q3Group_AddObject Failed!");	Q3Object_Dispose(myLight);											// dispose of light	return(myGroupPosition);}/****************** QD3D SET POINT LIGHT COORDS ********************/void QD3D_SetPointLightCoords(QD3DSetupOutputType *setupInfo, TQ3GroupPosition lightPosition, TQ3Point3D *point){TQ3PointLightData	pointLightData;TQ3LightObject		light;TQ3Status			status;	status = Q3Group_GetPositionObject(setupInfo->lightGroup, lightPosition, &light);	// get point light object from light group	if (status == kQ3Failure)		DoFatalAlert("\pQ3Group_GetPositionObject Failed!");	status =  Q3PointLight_GetData(light, &pointLightData);				// get light data	if (status == kQ3Failure)		DoFatalAlert("\pQ3PointLight_GetData Failed!");	pointLightData.location = *point;									// set coords	status = Q3PointLight_SetData(light, &pointLightData);				// update light data	if (status == kQ3Failure)		DoFatalAlert("\pQ3PointLight_SetData Failed!");}/****************** QD3D DELETE LIGHT ********************/void QD3D_DeleteLight(QD3DSetupOutputType *setupInfo, TQ3GroupPosition lightPosition){TQ3LightObject		light;	light = Q3Group_RemovePosition(setupInfo->lightGroup, lightPosition);	if (light == nil)		DoFatalAlert("\pQ3Group_RemovePosition Failed!");	Q3Object_Dispose(light);}//=======================================================================================================//=============================== TEXTURE MAP STUFF =====================================================//=======================================================================================================/************ QD3D CHANGE TEXTUREMAP ************///// INPUT:	textureShader = texture shader object to change//void QD3D_ChangeTextureMap(TQ3ShaderObject textureShader,long rezID){TQ3TextureObject	texture;TQ3StoragePixmap	pixmap;PicHandle			pict;			/* GET PIXMAP FROM SHADER */						Q3TextureShader_GetTexture(textureShader,&texture);		// get texture object	Q3PixmapTexture_GetPixmap(texture, &pixmap);			// get pixmap			/* LOAD NEW PICT */	pict = GetPicture(rezID);								// get picture from resource	if (pict == nil)		DoFatalAlert("\pUnable to load texture PICT resource");		/* DRAW PICT INTO PIXMAP */		DrawPICTIntoPixmap(pict, pixmap.width, pixmap.height, &pixmap);	ReleaseResource((Handle)pict);		Q3Object_Dispose(texture);	Q3Object_Dispose(pixmap.image);	}/**************** QD3D GET TEXTURE MAP ***********************///// Loads a PICT resource and returns a shader object which is// based on the PICT converted to a texture map.//// INPUT: textureRezID = resource ID of texture PICT to get.//			myFSSpec != nil if want to load PICT from file instead//// OUTPUT: TQ3ShaderObject = shader object for texture map.//TQ3SurfaceShaderObject	QD3D_GetTextureMap(long	textureRezID, FSSpec *myFSSpec){PicHandle			picture;TQ3SurfaceShaderObject		shader;long				pictSize,headerSize;OSErr				iErr;short				fRefNum;char				pictHeader[PICT_HEADER_SIZE];	if (myFSSpec == nil)	{					/* LOAD PICT REZ */				picture = GetPicture (textureRezID);		if (picture == nil)			DoFatalAlert("\pUnable to load texture PICT resource");	}	else	{				/* LOAD PICT FROM FILE */			iErr = FSpOpenDF(myFSSpec,fsCurPerm,&fRefNum);		if (iErr)			DoFatalAlert("\pError reading PICT file!");		if	(GetEOF(fRefNum,&pictSize) != noErr)		// get size of file					DoFatalAlert("\pError reading PICT file!");						headerSize = PICT_HEADER_SIZE;					// check the header							if (FSRead(fRefNum,&headerSize,pictHeader) != noErr)			DoFatalAlert("\pError reading PICT file!");		if ((pictSize -= PICT_HEADER_SIZE) <= 0)			DoFatalAlert("\pError reading PICT file!");					if ((picture = (PicHandle)NewHandle(pictSize)) == NIL_POINTER)			DoFatalAlert("\pNot enough memory to read PICT file!");		HLock((Handle)picture);					if (FSRead(fRefNum,&pictSize,*picture) != noErr)			DoFatalAlert("\pError reading PICT file!");					FSClose(fRefNum);			}			shader = QD3D_PICTToTexture(picture);			if (myFSSpec == nil)		ReleaseResource ((Handle) picture);	else		DisposeHandle((Handle)picture);	return(shader);	}/**************** QD3D PICT TO TEXTURE ***********************/////// INPUT: picture = handle to PICT.//// OUTPUT: TQ3ShaderObject = shader object for texture map.//TQ3SurfaceShaderObject	QD3D_PICTToTexture(PicHandle picture){TQ3StoragePixmap 	pixmap;TQ3TextureObject	texture;TQ3SurfaceShaderObject		shader;			/* MAKE INTO STORAGE PIXMAP */		pixmap.image = nil;	CreateTexturePixmap (picture,				(**picture).picFrame.right  - (**picture).picFrame.left,				(**picture).picFrame.bottom - (**picture).picFrame.top,				&pixmap);				/* MAKE NEW PIXMAP TEXTURE */				texture = Q3PixmapTexture_New (&pixmap);	if (texture == nil)		DoFatalAlert("\pError calling Q3PixmapTexture_New!");			shader = Q3TextureShader_New (texture);	if (shader == nil)		DoFatalAlert("\pError calling Q3TextureShader_New!");	Q3Object_Dispose (texture);	Q3Object_Dispose (pixmap.image);			// disposes of extra reference to storage obj from CreateTexturePixmap	return(shader);	}/**************** QD3D GWORLD TO TEXTURE ***********************///// INPUT: picture = handle to PICT.//// OUTPUT: TQ3ShaderObject = shader object for texture map.//TQ3SurfaceShaderObject	QD3D_GWorldToTexture(GWorldPtr theGWorld){TQ3StoragePixmap 			pixmap;TQ3TextureObject			texture;TQ3SurfaceShaderObject		shader;	GWorldToBMap(theGWorld,&pixmap);			/* MAKE NEW PIXMAP TEXTURE */				texture = Q3PixmapTexture_New (&pixmap);	if (texture == nil)		DoFatalAlert("\pError calling Q3PixmapTexture_New!");	shader = Q3TextureShader_New(texture);	if (shader == nil)		DoFatalAlert("\pError calling Q3TextureShader_New!");	Q3Object_Dispose (texture);	Q3Object_Dispose (pixmap.image);			// possible memory leak if dont call this?!?!	return(shader);	}/******************** CREATE TEXTURE PIXMAP ********************/static void CreateTexturePixmap(PicHandle pict,unsigned long mapSizeX,							 unsigned long mapSizeY, TQ3StoragePixmap *bMap){	bMap->image = NULL;		if (mapSizeY > 512)		mapSizeY = 512;	if (mapSizeX > 512)		mapSizeX = 512;		DrawPICTIntoPixmap (pict, mapSizeX, mapSizeY, bMap);}/******************** DRAW PICT INTO PIXMAP ********************///// OUTPUT: bMap = new bitmap holding texture image//static void DrawPICTIntoPixmap(PicHandle pict,unsigned long width, unsigned long height, TQ3StoragePixmap *bMap){	#define	k80K		(80000)Rect 					rectGW;GWorldPtr 				pGWorld;PixMapHandle 			hPixMap;OSErr					myErr;GDHandle				oldGD;GWorldPtr				oldGW;long					bytesNeeded;	GetGWorld(&oldGW, &oldGD);										// save current port				/* CREATE A GWORLD TO DRAW INTO */	SetRect(&rectGW, 0, 0, width, height);						// set dimensions	bytesNeeded = (width * height * 4) + k80K;	if (bytesNeeded < MaxBlock())		myErr = NewGWorld(&pGWorld, 32, &rectGW, 0, 0, 0L);			// make gworld	else		myErr = -43;	if (myErr)		DoFatalAlert("\pError making texture GWorld!");		hPixMap = GetGWorldPixMap(pGWorld);							// calc addr & rowbytes			/* DRAW PICTURE INTO GWORLD */				SetGWorld(pGWorld, nil);		LockPixels(hPixMap);	EraseRect(&rectGW);	DrawPicture(pict, &rectGW);			/* MAKE A PIXMAP FROM GWORLD */				GWorldToBMap(pGWorld,bMap);		SetGWorld (oldGW, oldGD);	UnlockPixels (hPixMap);	DisposeGWorld (pGWorld);}/******************** GWORLD TO BMAP ********************///// Creates a TQ3StoragePixmap from an existing GWorld//// NOTE: Assumes that GWorld is 32bit!!!!//// OUTPUT: bMap = new bitmap holding texture image//static void GWorldToBMap(GWorldPtr pGWorld, TQ3StoragePixmap *bMap){unsigned long 			pictMapAddr;PixMapHandle 			hPixMap;unsigned long 			pictRowBytes;long					width, height;TQ3Status				status;		hPixMap = GetGWorldPixMap(pGWorld);								// calc addr & rowbytes		if ((**hPixMap).pixelSize != 32)									// verify bitdepth		DoFatalAlert("\pGworlds must be 32bit when converting to textures!");		pictMapAddr = (unsigned long )GetPixBaseAddr(hPixMap);	pictRowBytes = (unsigned long)(**hPixMap).rowBytes & 0x3fff;	width = ((**hPixMap).bounds.right - (**hPixMap).bounds.left);	height = ((**hPixMap).bounds.bottom - (**hPixMap).bounds.top);				/* SET MORE PIXELMAP INFO */	if (bMap->image != NULL)	{		DoAlert("\pReplacing PixelMap : (remove this Alert if I want this");		status = Q3MemoryStorage_Set (bMap->image, (unsigned char *) pictMapAddr,							 pictRowBytes * height);		if (status == kQ3Failure)			DoFatalAlert("\pQ3MemoryStorage_Set Failed!");	}	else	{		bMap->image = Q3MemoryStorage_New ((unsigned char *) pictMapAddr, pictRowBytes * height);		if (bMap->image == nil)			DoFatalAlert("\pQ3MemoryStorage_New Failed!");	}	bMap->width 	= width;	bMap->height	= height;	bMap->rowBytes 	= pictRowBytes;	bMap->pixelSize = 32;	bMap->pixelType	= kQ3PixelTypeRGB32;	bMap->bitOrder	= kQ3EndianBig;	bMap->byteOrder	= kQ3EndianBig;	}//=======================================================================================================//=============================== STYLE STUFF =====================================================//=======================================================================================================/****************** QD3D:  SET BACKFACE STYLE ***********************/void SetBackFaceStyle(QD3DSetupOutputType *setupInfo, TQ3BackfacingStyle style){TQ3Status status;TQ3BackfacingStyle	backfacingStyle;	status = Q3BackfacingStyle_Get(setupInfo->backfacingStyle, &backfacingStyle);	if (status == kQ3Failure)		DoFatalAlert("\pQ3BackfacingStyle_Get Failed!");	if (style == backfacingStyle)							// see if already set to that		return;			status = Q3BackfacingStyle_Set(setupInfo->backfacingStyle, style);	if (status == kQ3Failure)		DoFatalAlert("\pQ3BackfacingStyle_Set Failed!");}/****************** QD3D:  SET FILL STYLE ***********************/void SetFillStyle(QD3DSetupOutputType *setupInfo, TQ3FillStyle style){TQ3Status 		status;TQ3FillStyle	fillStyle;	status = Q3FillStyle_Get(setupInfo->fillStyle, &fillStyle);	if (status == kQ3Failure)		DoFatalAlert("\pQ3FillStyle_Get Failed!");	if (style == fillStyle)							// see if already set to that		return;			status = Q3FillStyle_Set(setupInfo->fillStyle, style);	if (status == kQ3Failure)		DoFatalAlert("\pQ3FillStyle_Set Failed!");}//=======================================================================================================//=============================== INFO STUFF =====================================================//=======================================================================================================/********************** DISPLAY OBJECT INFO **************************///// NOTE: assumes that current grafport is already set to window we want to display info into//void QD3D_DisplayObjectInfo(TQ3Object myObject){TQ3ObjectType	oType;TQ3BackfacingStyle	backfacingStyle;	TextSize(9);	ForeColor(blackColor);	oType = Q3Object_GetType(myObject);	switch(oType)	{		case	kQ3ObjectTypeElement:				WriteString("\pElement: ");				ForeColor(greenColor);				oType = Q3Object_GetLeafType(myObject);						// read kind of element				switch(oType)				{					case	kQ3ElementTypeAttribute:							WriteString("\p    Attribute");							DoCR();							break;				}				break;			case	kQ3ObjectTypePick:				WriteString("\pPick: ");				ForeColor(greenColor);				oType = Q3Object_GetLeafType(myObject);						// read kind of pick				switch(oType)				{					case	kQ3PickTypeWindowPoint:							WriteString("\p    Window Point");							DoCR();							break;					case	kQ3PickTypeWindowRect:							WriteString("\p    Window Rect");							DoCR();							break;				}				break;			case	kQ3ObjectTypeShared://				WriteString("\pShared: ");				ForeColor(greenColor);								oType = Q3Shared_GetType(myObject);							// get kind of shared								switch(oType)				{					case	kQ3SharedTypeShape:							WriteString("\pSHAPE: ");							oType = Q3Shape_GetType(myObject);				// get kind of shape							switch(oType)							{								case	kQ3ShapeTypeGeometry:										WriteString("\pGeometry: ");										oType = Q3Geometry_GetType(myObject);					// get geometry type										switch(oType)										{											case	kQ3GeometryTypeBox:													WriteString("\pBox");																								break;											case	kQ3GeometryTypeGeneralPolygon:													WriteString("\pGeneral Polygon");																								break;											case	kQ3GeometryTypeLine:													WriteString("\pLine");																								break;											case	kQ3GeometryTypeMarker:													WriteString("\pMarker");																								break;											case	kQ3GeometryTypeMesh:													WriteString("\pMesh");													ShowMeshInfo(myObject);																						break;											case	kQ3GeometryTypeTriMesh:													WriteString("\pTri-Mesh");													ShowTriMeshInfo(myObject);																						break;											case	kQ3GeometryTypeNURBCurve:													WriteString("\pNURB Curve");																								break;											case	kQ3GeometryTypeNURBPatch:													WriteString("\pNURB Patch");																								break;											case	kQ3GeometryTypePoint:													WriteString("\pPoint");																								break;											case	kQ3GeometryTypePolygon:													WriteString("\pPolygon");																								break;											case	kQ3GeometryTypeTriangle:													WriteString("\pTriangle");																								break;											case	kQ3GeometryTypeTriGrid:													WriteString("\pTri-Grid");																								break;											default:													WriteString("\pUnknown Geometry");																																}										DoCR();										break;								case	kQ3ShapeTypeShader:										WriteString("\pShader: ");										oType = Q3Shader_GetType(myObject);				// get kind of shader										switch(oType)										{											case	kQ3ShaderTypeSurface:													WriteString("\pSurface");																								break;											case	kQ3ShaderTypeIllumination:													WriteString("\pIllumination");																								break;										}										DoCR();										break;								case	kQ3ShapeTypeStyle:										WriteString("\pStyle: ");										oType = Q3Style_GetType(myObject);				// get kind of style										switch(oType)										{											case	kQ3StyleTypeBackfacing:													WriteString("\pBackfacing-");														Q3BackfacingStyle_Get(myObject, &backfacingStyle);	// get state of backfacing													switch(backfacingStyle)													{														case	kQ3BackfacingStyleBoth:																WriteString("\pboth");																break;														case	kQ3BackfacingStyleFlip:																WriteString("\pflip");																break;														case	kQ3BackfacingStyleRemove:																WriteString("\premove");																break;																										}																						break;											case	kQ3StyleTypeInterpolation:													WriteString("\pInterpolation");																								break;											case	kQ3StyleTypeFill:													WriteString("\pFill");																								break;											case	kQ3StyleTypePickID:													WriteString("\pPick ID");																								break;											case	kQ3StyleTypeReceiveShadows:													WriteString("\pReceive shadow");																								break;											case	kQ3StyleTypeHighlight:													WriteString("\pHilight");																								break;											case	kQ3StyleTypeSubdivision:													WriteString("\pSubdivision");																								break;											case	kQ3StyleTypeOrientation:													WriteString("\pOrientation");																								break;											case	kQ3StyleTypePickParts:													WriteString("\pPickParts");																								break;										}										DoCR();										break;								case	kQ3ShapeTypeTransform:										WriteString("\pTransform");										DoCR();										break;								case	kQ3ShapeTypeLight:										WriteString("\pLight");										DoCR();										break;								case	kQ3ShapeTypeCamera:										WriteString("\pCamera");										DoCR();										break;								case	kQ3ShapeTypeGroup:										WriteString("\pGroup: ");																					oType = Q3Group_GetType(myObject);				// get kind of group										switch(oType)										{											case	kQ3GroupTypeDisplay:													WriteString("\pDisplay");													TraverseDisplayGroupInfo(myObject);		// recursive scan of group																								break;											case	kQ3GroupTypeLight:													WriteString("\pLight");																								break;											case	kQ3GroupTypeInfo:													WriteString("\pInfo");																								break;										}										DoCR();										break;								case	kQ3ShapeTypeUnknown:										WriteString("\pUNKNOWN");										DoCR();										break;								case	kQ3SetTypeAttribute:										WriteString("\pAttribute");										ShowAttributeInfo(myObject);										DoCR();										break;								default:										WriteString("\p(unImplemented or ERROR):");										WriteChar((oType&0xff000000)>>24);										WriteChar((oType&0xff0000)>>16);										WriteChar((oType&0xff00)>>8);										WriteChar(oType&0xff);										DoCR();										break;																		}												break;					case	kQ3SharedTypeRenderer:							WriteString("\p    RENDERER");							DoCR();							break;					case	kQ3SharedTypeSet:							WriteString("\p    SET");							DoCR();							break;					case	kQ3SharedTypeTexture:							WriteString("\p    TEXTURE");							DoCR();							break;					case	kQ3SharedTypeFile:							WriteString("\p    FILE");							DoCR();							break;					case	kQ3SharedTypeStorage:							WriteString("\p    STORAGE");							DoCR();							break;					case	kQ3SharedTypeShapePart:							WriteString("\p    SHAPE PART");							DoCR();							break;					case	kQ3SharedTypeControllerState:							WriteString("\p    CONTROLLER STATE");							DoCR();							break;					case	kQ3SharedTypeTracker:							WriteString("\p    TRACKER");							DoCR();							break;					case	kQ3SharedTypeViewHints:							WriteString("\p    VIEW HINTS");							DoCR();							break;								}				break;						case	kQ3ObjectTypeView:				WriteString("\pView");				DoCR();				break;	}}/****************** TRAVERSE DISPLAY GROUP INFO **********************/static void TraverseDisplayGroupInfo(TQ3Object theGroup){TQ3GroupPosition			position;			TQ3Object					object;				TQ3Status					status;					// a result codeunsigned long				numObjects;	status = Q3Group_CountObjects(theGroup, &numObjects);								// get # objects in group	gHtab += 40;	DoCR();	ForeColor(blueColor);	WriteString("\p--------START GROUP----------");	DoCR();	if (numObjects > 0)	{				status = Q3Group_GetFirstPosition(theGroup, &position);								// get position of 1st object in group			do		{			status = Q3Group_GetPositionObject(theGroup, position, &object);				// get ref to object from group			QD3D_DisplayObjectInfo(object);			Q3Object_Dispose(object);														// zap reference			Q3Group_GetNextPosition(theGroup, &position);									// get next position		}while(position != nil);	}		ForeColor(blueColor);	WriteString("\p--------END GROUP -----------");	DoCR();	gHtab -= 40;}/******************** SHOW TRIMESH INFO **************************/static void ShowTriMeshInfo(TQ3Object theTriMesh){TQ3TriMeshData	triMeshData;TQ3Status			status;Str255				s;	status = Q3TriMesh_GetData(theTriMesh,&triMeshData);	gHtab += 40;	DoCR();	WriteString("\p# Triangles = ");	NumToString(triMeshData.numTriangles,s);	WriteString(s);	DoCR();	WriteString("\p# Points = ");	NumToString(triMeshData.numPoints,s);	WriteString(s);	DoCR();	gHtab -= 40;		gTotalNumVertecies += triMeshData.numPoints;	gTotalNumFaces += triMeshData.numTriangles;	gTotalMeshes++;					Q3TriMesh_EmptyData(&triMeshData);	}/****************** SHOW MESH INFO **********************/static void ShowMeshInfo(TQ3Object theMesh){TQ3Status			status;unsigned long		n,numFaces;Str255				s;TQ3MeshFace			meshFace;TQ3MeshIterator		iterator;TQ3AttributeSet		attributeSet;TQ3AttributeType	type;TQ3SurfaceShaderObject	surfaceShaderObject;TQ3SurfaceShaderObject	surfaceShaders[1000];short				numSurfaceShaders = 0,i;Boolean				isNew;RGBColor			color;TQ3TextureObject	texture;TQ3TextureObject	textures[1000];short				numTextures = 0;TQ3StoragePixmap	pixmap;TQ3StorageObject	pixmaps[1000];short				numPixmaps = 0;	GetForeColor(&color);	ForeColor(magentaColor);	gHtab += 40;	DoCR();//	WriteString("\p--------------------- MESH -----------------------");//	DoCR();	status = Q3Mesh_GetNumVertices(theMesh, &n);						// show # vertices	WriteString("\p# Vertices = ");	NumToString(n,s);	WriteString(s);	DoCR();	status = Q3Mesh_GetNumFaces(theMesh, &numFaces);					// show # faces	WriteString("\p# Faces = ");	NumToString(numFaces,s);	WriteString(s);	DoCR();					/* INC GLOBAL COUNTERS */					gTotalNumVertecies += n;	gTotalNumFaces += numFaces;	gTotalMeshes++;										/* SCAN FACES */					if (numFaces > 0)	{		meshFace = Q3Mesh_FirstMeshFace(theMesh, &iterator);			// get 1st face in mesh		do		{						/*****************/						/* CHECK ATTRIBS */						/*****************/									status = Q3Mesh_GetFaceAttributeSet(theMesh, meshFace, &attributeSet);		// get ref to attribs (if any)			if ((status == kQ3Success) && (attributeSet != nil))			{				type = kQ3AttributeTypeNone;											// get 1st attrib type				status = Q3AttributeSet_GetNextAttributeType(attributeSet, &type);				if ((status == kQ3Success) && (type != kQ3AttributeTypeNone))				{					do					{						switch(type)						{							case	kQ3AttributeTypeSurfaceShader:									status = Q3AttributeSet_Get(attributeSet, type, &surfaceShaderObject);		// get ref to surface shader object									status = Q3TextureShader_GetTexture(surfaceShaderObject, &texture);			// get ref to texture object											status = Q3PixmapTexture_GetPixmap(texture, &pixmap);						// get ref to pixmap object																											/* SEE IF SHADER IS UNIQUE */																				isNew = true;									for (i = 0; i < numSurfaceShaders; i++)						// see if this surfaceShaderObject already accounted for										if (surfaceShaderObject == surfaceShaders[i])										{											isNew = false;											break;										}									if (isNew)										surfaceShaders[numSurfaceShaders++] = surfaceShaderObject;												/* SEE IF TEXTURE IS UNIQUE */																				isNew = true;									for (i = 0; i < numTextures; i++)						// see if this texture already accounted for										if (texture == textures[i])										{											isNew = false;											break;										}									if (isNew)										textures[numTextures++] = texture;											/* SEE IF PIXMAP IMAGE IS UNIQUE */																				isNew = true;									for (i = 0; i < numPixmaps; i++)						// see if this pixmap storage obj already accounted for										if (pixmap.image == pixmaps[i])										{											isNew = false;											break;										}									if (isNew)										pixmaps[numPixmaps++] = pixmap.image;											Q3Object_Dispose(surfaceShaderObject);						// dispose ref to shader									Q3Object_Dispose(texture);									// dispose ref to texture									Q3Object_Dispose(pixmap.image);								// dispose ref to pixmap image (storage obj)									break;													}						status = Q3AttributeSet_GetNextAttributeType(attributeSet, &type);	// get next attrib type						if (status != kQ3Success)							goto next_face;					}while(type != kQ3AttributeTypeNone);				}				Q3Object_Dispose(attributeSet);							// dispose ref to attribs			}next_face:				meshFace = Q3Mesh_NextMeshFace(&iterator);					// get next face		}while(meshFace != nil);		WriteString("\p# Surface Shaders = ");							// print # different shaders		NumToString(numSurfaceShaders,s);		WriteString(s);		DoCR();					/* SEE IF NEED TO TELL MORE ABOUT SURFACE SHADERS */							if (numSurfaceShaders > 0)		{			WriteString("\p    # Textures = ");								// print # different textures			NumToString(numTextures,s);			WriteString(s);			DoCR();				WriteString("\p        # Pixmaps = ");							// print # different pixmaps			NumToString(numPixmaps,s);			WriteString(s);			DoCR();		}	}		//	DoCR();//	WriteString("\p+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");//	DoCR();	gHtab -= 40;	RGBForeColor(&color);}/****************** SHOW ATTRIBUTE INFO **********************/static void ShowAttributeInfo(TQ3AttributeSet theAttribute){TQ3Status			status;TQ3AttributeType	attribType;RGBColor			color;float				f;Str255				s;TQ3ColorRGB			c;	GetForeColor(&color);	ForeColor(magentaColor);	gHtab += 40;	DoCR();//	WriteString("\p--------------- ATTRIB --------------------");//	DoCR();				/* GET 1ST ATTRIBUTE TYPE */					attribType = kQ3AttributeTypeNone;	status = Q3AttributeSet_GetNextAttributeType(theAttribute, &attribType);				/* ITERATE THRU ALL ATTRIBS */					if ((status == kQ3Success) && (attribType != kQ3AttributeTypeNone))	{		do		{			switch(attribType)			{				case	kQ3AttributeTypeSurfaceShader:						WriteString("\pSurface Shader");						DoCR();						break;											case	kQ3AttributeTypeSurfaceUV:						WriteString("\pSurface UV");						DoCR();						break;					case	kQ3AttributeTypeShadingUV:						WriteString("\pShading UV");						DoCR();						break;					case	kQ3AttributeTypeNormal:						WriteString("\pNormal");						DoCR();						break;					case	kQ3AttributeTypeAmbientCoefficient:						WriteString("\pAmbient Coefficient: ");						Q3AttributeSet_Get(theAttribute, attribType, &f);												FloatToString(f,s);						WriteString(s);						DoCR();						break;					case	kQ3AttributeTypeDiffuseColor:						WriteString("\pDiffuse Color: r=");						Q3AttributeSet_Get(theAttribute, attribType, &c);												FloatToString(c.r,s);						WriteString(s);						WriteString("\p g=");						FloatToString(c.g,s);						WriteString(s);						WriteString("\p b=");						FloatToString(c.b,s);						WriteString(s);						DoCR();						break;					case	kQ3AttributeTypeSpecularColor:						WriteString("\pSpecular Color: r=");						Q3AttributeSet_Get(theAttribute, attribType, &c);												FloatToString(c.r,s);						WriteString(s);						WriteString("\p g=");						FloatToString(c.g,s);						WriteString(s);						WriteString("\p b=");						FloatToString(c.b,s);						WriteString(s);						DoCR();						break;											case	kQ3AttributeTypeSpecularControl:						WriteString("\pSpecular Control: ");						Q3AttributeSet_Get(theAttribute, attribType, &f);												FloatToString(f,s);						WriteString(s);						DoCR();						break;											case	kQ3AttributeTypeHighlightState:						WriteString("\pHighlight State");						DoCR();						break;											case	kQ3AttributeTypeTransparencyColor:						WriteString("\pTransparency Color: r=");						Q3AttributeSet_Get(theAttribute, attribType, &c);												FloatToString(c.r,s);						WriteString(s);						WriteString("\p g=");						FloatToString(c.g,s);						WriteString(s);						WriteString("\p b=");						FloatToString(c.b,s);						WriteString(s);						DoCR();						break;											case	kQ3AttributeTypeSurfaceTangent:						WriteString("\pSurface Tangent");						DoCR();						break;																						}			status = Q3AttributeSet_GetNextAttributeType(theAttribute, &attribType);	// get next attrib type			if (status != kQ3Success)				break;		}while(attribType != kQ3AttributeTypeNone);	}//	WriteString("\p++++++++++++++++++++ ATTRIB END +++++++++++++++++++++++++++++");//	DoCR();	gHtab -= 40;	RGBForeColor(&color);}/**************** CALC SCALE TO MAKE FIT ***********************/float CalcScaleToMakeFit(QD3DSetupOutputType *setupInfo,TQ3Object theObject, float targetSize){TQ3BoundingSphere	boundingSphere;	Q3View_StartBoundingSphere(setupInfo->viewObject, kQ3ComputeBoundsApproximate);	do	{		Q3Object_Submit(theObject,setupInfo->viewObject);	}while(Q3View_EndBoundingSphere(setupInfo->viewObject, &boundingSphere) == kQ3ViewStatusRetraverse);	return((targetSize/2)/boundingSphere.radius);}/******************** QD3D: REPLACE OBJECT IN GROUP **********************///// OUTPUT: new position in group//TQ3GroupPosition QD3D_ReplaceObjectInGroup(TQ3Object theGroup, TQ3GroupPosition position, TQ3Object newObj){			TQ3GroupPosition	newPos;TQ3Object			removedObj;	newPos = Q3Group_AddObjectBefore(theGroup, position, newObj);		// add newObj to group	if (newPos == nil)		DoFatalAlert("\pQ3Group_AddObjectBefore failed!");			removedObj = Q3Group_RemovePosition(theGroup, position);				// remove old from group	if (removedObj == nil)		DoFatalAlert("\pQ3Group_RemovePosition Failed!");	Q3Object_Dispose(removedObj);	return(newPos);}/*************** QD3D: CALC OBJECT BOUNDING BOX ************************/void QD3D_CalcObjectBoundingBox(QD3DSetupOutputType *setupInfo, TQ3Object theObject, TQ3BoundingBox	*boundingBox){	Q3View_StartBoundingBox(setupInfo->viewObject, kQ3ComputeBoundsExact);	do	{		Q3Object_Submit(theObject,setupInfo->viewObject);	}while(Q3View_EndBoundingBox(setupInfo->viewObject, boundingBox) == kQ3ViewStatusRetraverse);}/********************* QD3D: MAKE DUPLICATE ATTRIBUTE SET *********************///// This makes a copy of an attribute set, but does NOT duplicate any attached objects// such as surface shaders.  Q3Object_Duplicate appears to duplicate the attrib and all // included objects.//TQ3AttributeSet QD3D_MakeDuplicateAttributeSet(TQ3AttributeSet sourceSet){TQ3AttributeSet	newSet;	newSet = Q3AttributeSet_New();	Q3AttributeSet_Inherit(newSet, sourceSet, newSet);	return(newSet);}/**************** QD3D PIXMAP TO GWORLD ***********************///// OUTPUT: r = rect of gworld//GWorldPtr QD3D_PixmapToGWorld(TQ3StoragePixmap *pixmap, Rect *r){GWorldPtr		gworld;PixMapHandle	gworldPixmap;long			gworldRowBytes,x,y,pixmapRowbytes;Ptr				gworldPixelPtr;TQ3Status		status;unsigned long	size,sizeRead,*pix32Src,*pix32Dest;unsigned char	*buffer;unsigned short	*pix16Src,*pix16Dest;OSErr			iErr;			/* CREATE GWORLD TO DRAW INTO */		SetRect(r,0,0,pixmap->width,pixmap->height);	iErr = NewGWorld(&gworld, pixmap->pixelSize, r, nil, nil, 0);	if (iErr)		DoFatalAlert("\pQD3D_PixmapToGWorld: NewGWorld failed!");	DoLockPixels(gworld);	gworldPixmap = GetGWorldPixMap(gworld);	gworldRowBytes = (**gworldPixmap).rowBytes & 0x3fff;					// get GWorld's rowbytes	gworldPixelPtr = GetPixBaseAddr(gworldPixmap);							// get ptr to pixels		/* GET QD3D PIXMAP DATA INFO */	status = Q3Storage_GetSize(pixmap->image, &size);						// get size of data	if (status == kQ3Failure)		DoFatalAlert("\pQD3D_PixmapToGWorld: Q3Storage_GetSize failed!");	buffer = (unsigned char *)AllocPtr(size);								// alloc buffer for pixel data	if (buffer == nil)		DoFatalAlert("\pQD3D_PixmapToGWorld: AllocPtr failed!");			status = Q3Storage_GetData(pixmap->image, 0, size, buffer, &sizeRead);	// get pixel data	if (status == kQ3Failure)		DoFatalAlert("\pQD3D_PixmapToGWorld: Q3Storage_GetData failed!");	pixmapRowbytes = pixmap->rowBytes;				/* WRITE PIXMAP DATA INTO GWORLD */			//	if ((pixmap->bitOrder != kQ3EndianBig) || (pixmap->byteOrder != kQ3EndianBig))//		DoFatalAlert("\pQD3D_PixmapToGWorld: only kQ3EndianBig is supported!");				switch(pixmap->pixelSize)	{		case	32:				pixmap->pixelType = kQ3PixelTypeRGB32;						// (fix this for formZ)				pix32Src = (unsigned long *)buffer;							// get 32bit pointers				pix32Dest = (unsigned long *)gworldPixelPtr;				for (y = 0; y <  pixmap->height; y++)				{					for (x = 0; x < pixmap->width; x++)						pix32Dest[x] = pix32Src[x];									pix32Dest += gworldRowBytes/4;							// next dest row					pix32Src += pixmapRowbytes/4;				}				break;		case	16:				pixmap->pixelType = kQ3PixelTypeRGB16;						// (fix this for formZ)				pix16Src = (unsigned short *)buffer;						// get 16bit pointers				pix16Dest = (unsigned short *)gworldPixelPtr;				for (y = 0; y <  pixmap->height; y++)				{					for (x = 0; x < pixmap->width; x++)						pix16Dest[x] = pix16Src[x];									pix16Dest += gworldRowBytes/2;							// next dest row					pix16Src += pixmapRowbytes/2;				}				break;										default:				DoFatalAlert("\pQD3D_PixmapToGWorld: Only 32/16 bit textures supported right now.");	}	DisposePtr((Ptr)buffer);												return(gworld);	}/**************** QD3D MIPMAP TO GWORLD ***********************///// OUTPUT: r = rect of gworld//GWorldPtr QD3D_MipmapToGWorld(TQ3Mipmap *mipmap, Rect *r){GWorldPtr		gworld;PixMapHandle	gworldPixmap;long			gworldRowBytes,x,y,pixmapRowbytes;Ptr				gworldPixelPtr;TQ3Status		status;unsigned long	size,sizeRead,*pix32Src,*pix32Dest;unsigned char	*buffer;unsigned short	*pix16Src,*pix16Dest;OSErr			iErr;long			pixelSize;long			height,width;			/* CREATE GWORLD TO DRAW INTO */		switch(mipmap->pixelType)	{		case	kQ3PixelTypeRGB16:		case	kQ3PixelTypeARGB16:				pixelSize = 16;				break;						case	kQ3PixelTypeRGB32:		case	kQ3PixelTypeARGB32:				pixelSize = 32;				break;	}		height = mipmap->mipmaps[0].height;	width = mipmap->mipmaps[0].width;	SetRect(r,0,0,width,height);	iErr = NewGWorld(&gworld,pixelSize, r, nil, nil, 0);	if (iErr)		DoFatalAlert("\pQD3D_MipmapToGWorld: NewGWorld failed!");	DoLockPixels(gworld);	gworldPixmap = GetGWorldPixMap(gworld);	gworldRowBytes = (**gworldPixmap).rowBytes & 0x3fff;					// get GWorld's rowbytes	gworldPixelPtr = GetPixBaseAddr(gworldPixmap);							// get ptr to pixels		/* GET QD3D PIXMAP DATA INFO */	status = Q3Storage_GetSize(mipmap->image, &size);						// get size of data	if (status == kQ3Failure)		DoFatalAlert("\pQD3D_MipmapToGWorld: Q3Storage_GetSize failed!");	buffer = (unsigned char *)AllocPtr(size);								// alloc buffer for pixel data	if (buffer == nil)		DoFatalAlert("\pQD3D_MipmapToGWorld: AllocPtr failed!");			status = Q3Storage_GetData(mipmap->image, 0, size, buffer, &sizeRead);	// get pixel data	if (status == kQ3Failure)		DoFatalAlert("\pQD3D_MipmapToGWorld: Q3Storage_GetData failed!");	pixmapRowbytes = mipmap->mipmaps[0].rowBytes;				/* WRITE MIPMAP DATA INTO GWORLD */			//	if ((mipmap->bitOrder != kQ3EndianBig) || (mipmap->byteOrder != kQ3EndianBig))//		DoFatalAlert("\pQD3D_MipmapToGWorld: only kQ3EndianBig is supported!");				switch(pixelSize)	{		case	32:				pix32Src = (unsigned long *)buffer;							// get 32bit pointers				pix32Dest = (unsigned long *)gworldPixelPtr;				for (y = 0; y <  height; y++)				{					for (x = 0; x < width; x++)						pix32Dest[x] = pix32Src[x];									pix32Dest += gworldRowBytes/4;							// next dest row					pix32Src += pixmapRowbytes/4;				}				break;		case	16:				pix16Src = (unsigned short *)buffer;						// get 16bit pointers				pix16Dest = (unsigned short *)gworldPixelPtr;				for (y = 0; y <  height; y++)				{					for (x = 0; x < width; x++)						pix16Dest[x] = pix16Src[x];									pix16Dest += gworldRowBytes/2;							// next dest row					pix16Src += pixmapRowbytes/2;				}				break;										default:				DoFatalAlert("\pQD3D_MipmapToGWorld: Only 32/16 bit textures supported right now.");	}	DisposePtr((Ptr)buffer);												return(gworld);	}/******************* QD3D: SHOW ERROR *************************///// Returns true if Error, false if just a warning.//Boolean QD3D_ShowError(Str255 errString, Boolean showWarnings){TQ3Error	err;TQ3Warning	warning;Str255		numStr;		/* DO ERRORS */			err = Q3Error_Get(nil);	if (err != 0)	{		DoAlert(errString);		switch(err)		{			case	kQ3ErrorViewNotStarted:					DoFatalAlert("\pError:kQ3ErrorViewNotStarted");					break;								case	kQ3ErrorOutOfMemory:					DoFatalAlert("\pError:kQ3ErrorOutOfMemory");					break;								default:					ShowSystemErr(err);		}		return(true);	}			/* DO WARNINGS */	else	{		if (!showWarnings)			return(false);				DoAlert(errString);		warning = Q3Warning_Get(nil);		switch(warning)		{			case	kQ3WarningFunctionalityNotSupported:					DoAlert("\pWarning: kQ3WarningFunctionalityNotSupported");					break;								default:					NumToString(err, numStr);					DoAlert (numStr);		}		return(false);	}		}/************ QD3D: SHOW RECENT ERROR *******************/void QD3D_ShowRecentError(void){TQ3Error	q3Err;Str255		s;		q3Err = Q3Error_Get(nil);	if (q3Err == kQ3ErrorOutOfMemory)		QD3D_DoMemoryError();	else	if (q3Err == kQ3ErrorMacintoshError)		DoFatalAlert("\pkQ3ErrorMacintoshError");	else	if (q3Err != 0)	{		NumToString(q3Err,s);		DoFatalAlert(s);	}}/***************** QD3D: DO MEMORY ERROR **********************/void QD3D_DoMemoryError(void){	InitCursor();	NoteAlert(129,nil);	CleanQuit();}