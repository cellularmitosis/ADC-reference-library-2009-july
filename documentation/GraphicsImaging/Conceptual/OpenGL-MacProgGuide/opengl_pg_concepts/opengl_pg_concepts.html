<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>OpenGL Programming Guide for Mac OS X: OpenGL on the Mac Platform</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="OpenGL on the Mac Platform"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40001987-CH208" title="OpenGL on the Mac Platform"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000424" target="_top">Graphics &amp; Imaging</a> &gt; <a href="../../../OpenGL-date.html#//apple_ref/doc/uid/TP30000440-TP30000424-TP30000549" target="_top">OpenGL</a> &gt; <a href="../opengl_intro/opengl_intro.html#//apple_ref/doc/uid/TP40001987-CH207-TP9">OpenGL Programming Guide for Mac OS X</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../opengl_intro/opengl_intro.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../opengl_drawing/opengl_drawing.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40001987-CH208-SW1" title="OpenGL on the Mac Platform"></a><h1>OpenGL on the Mac Platform</h1><p>You can tell that Apple has an implementation of OpenGL on its platform just by looking at the user interface for many of the applications that are installed with Mac OS X. The reflections built into iChat (<span class="content_text">Figure 1-1</span>) provide one of the more notable examples. The responsiveness of the windows, the instant results of applying an effect in iPhoto, and many, many other operations in Mac OS X v10.4 are due to the use of OpenGL. OpenGL isn't restricted to just the operating system and Apple applications. Any Mac developer can use OpenGL. In fact, Apple's implementation is available to every Macintosh user as part of Mac OS X. </p><p>OpenGL for Mac OS X is implemented as a set of frameworks that contain the OpenGL runtime engine and its drawing software. These frameworks use platform-neutral virtual resources to free your programming as much as possible from hardware considerations. Mac OS X provides a set of application programming interfaces (APIs) that Cocoa and Carbon applications can use to support OpenGL drawing.</p><br/><div><a name="//apple_ref/doc/uid/TP40001987-CH208-SW18" title="Figure 1-1OpenGL provides the reflections in iChat"></a><p><strong>Figure 1-1&nbsp;&nbsp;</strong>OpenGL provides the reflections in iChat</p><img src = "../art/reflection.jpg" alt = "OpenGL provides the reflections in iChat" ></div><br/><p>This chapter describes the OpenGL frameworks and the associated APIs, defines the terminology that is Apple-specific, describes how data flows through OpenGL, and provides an overview of the tasks necessary for a Cocoa or Carbon application to tap into that pipeline.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="opengl_pg_concepts.html#//apple_ref/doc/uid/TP40001987-CH208-SW5">Structure of OpenGL in Mac OS X</a>
				
			<br/>
			
        
			
			
				<a href="opengl_pg_concepts.html#//apple_ref/doc/uid/TP40001987-CH208-SW19">Programming Interfaces</a>
				
			<br/>
			
        
			
			
				<a href="opengl_pg_concepts.html#//apple_ref/doc/uid/TP40001987-CH208-SW21">Terminology</a>
				
			<br/>
			
        
			
			
				<a href="opengl_pg_concepts.html#//apple_ref/doc/uid/TP40001987-CH208-SW17">Running an OpenGL Program in Mac OS X</a>
				
			<br/>
			
        
			
			
				<a href="opengl_pg_concepts.html#//apple_ref/doc/uid/TP40001987-CH208-SW24">See Also</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40001987-CH208-SW5" title="Structure of OpenGL in Mac OS X"></a><h2>Structure of OpenGL in Mac OS X</h2><p>Mac OS X supports a display space that can consist of multiple dissimilar displays, each driven by different graphics cards with different capabilities. In addition, multiple OpenGL renderers can drive each graphics card. To accommodate this versatility, OpenGL for Mac OS X is segmented into three well-defined layers: a window system layer, a framework layer, and a driver layer, as shown in <span class="content_text">Figure 1-2</span>. This segmentation allows for plug-in interfaces to both the window system layer and the framework layer. Plug-in interfaces offer flexibility in software and hardware configuration without violating the OpenGL standard.</p><br/><div><a name="//apple_ref/doc/uid/TP40001987-CH208-SW2" title="Figure 1-2Layers of OpenGL for Mac OS X"></a><p><strong>Figure 1-2&nbsp;&nbsp;</strong>Layers of OpenGL for Mac OS X</p><img src = "../art/opengl_layers.jpg" alt = "Layers of OpenGL for Mac OS X" ></div><br/><p>The <strong>window system layer</strong> is what allows your OpenGL program to become a reality onscreen. You'll use the Apple-specific OpenGL APIs provided in this layer—the NSOpenGL classes and the AGL and CGL APIs—to direct where OpenGL drawing takes place and control a variety of aspects of rendering. These APIs contain functions and methods specific to the Mac OS X windowing system. (See <span class="content_text"><a href="opengl_pg_concepts.html#//apple_ref/doc/uid/TP40001987-CH208-SW4">“OpenGL APIs Specific to Mac OS X”</a></span> for more information.) This layer also includes the OpenGL libraries—GL, GLU, and GLUT. (See <span class="content_text"><a href="opengl_pg_concepts.html#//apple_ref/doc/uid/TP40001987-CH208-SW3">“Apple-Implemented OpenGL Libraries”</a></span> for details.)</p><p>The <strong>common OpenGL framework layer</strong> is the software interface to the graphics hardware. This layer contains Apple's implementation of the OpenGL specification.</p><p>The <strong>driver layer</strong> contains the optional GLD plug-in interface and one or more GLD plug-in drivers, which may have different software and hardware support capabilities. The GLD plug-in interface supports third-party plug-in drivers, allowing third-party hardware vendors to take advantage of newer driver technology.</p><a name="//apple_ref/doc/uid/TP40001987-CH208-SW19" title="Programming Interfaces"></a><h2>Programming Interfaces</h2><p>The programming interfaces that you'll use fall into two categories—those specific to the Macintosh platform and those defined by the OpenGL Architecture Review Board. The Apple-specific programming interfaces are what Cocoa and Carbon applications use to communicate with the Mac OS X windowing system. These APIs don't create OpenGL content, they simply manage content, direct it to a drawing destination (onscreen or offscreen), and control various aspects of the rendering operation. The OpenGL APIs actually create content. OpenGL routines accept vertex, pixel, and texture data and assemble the data to create content that has the illusion of being three-dimensional. The final content resides in a framebuffer, where it will languish unseen by the user unless your application uses a windowing-system specific API to direct the content onscreen.</p><br/><div><a name="//apple_ref/doc/uid/TP40001987-CH208-SW20" title="Figure 1-3The programing interfaces used for OpenGL content"></a><p><strong>Figure 1-3&nbsp;&nbsp;</strong>The programing interfaces used for OpenGL content</p><img src = "../art/opengl_architecture.jpg" alt = "The programing interfaces used for OpenGL content" ></div><br/><a name="//apple_ref/doc/uid/TP40001987-CH208-SW4" title="OpenGL APIs Specific to Mac OS X"></a><h3>OpenGL APIs Specific to Mac OS X</h3><p>Mac OS X offers three easy-to-use application programming interfaces (APIs) that are specific to the Macintosh platform: the NSOpenGL classes, the AGL API, and the CGL API. Throughout this document, these three APIs are referred to as the Apple-specific OpenGL APIs.</p><p>Cocoa provides four classes specifically for OpenGL—<code>NSOpenGLView</code>, <code>NSOpenGLContext</code>, <code>NSOpenGLPixelFormat</code>, and <code>NSOpenGLPixelBuffer</code>. The <code>NSOpenGLView</code> class provides easy access to a basic OpenGL context that can be set up in Interface Builder. <code>NSOpenGLView</code> is a subclass of <code>NSView</code> and has the expected facilities to display OpenGL content in a view. <code>NSOpenGLContext</code> and <code>NSOpenGLPixelFormat</code>, along with <code>NSView</code>, are the building blocks for the <code>NSOpenGLView</code> class. Applications that subclass <code>NSOpenGLView</code> do not need to directly subclass <code>NSOpenGLPixelFormat</code> or <code>NSOpenGLContext</code>. Applications that need  customization or flexibility, can subclass <code>NSView</code>. The <code>NSOpenGLPixelBuffer</code> class provides hardware-accelerated offscreen drawing. Using the NSOpenGL classes, you can also draw to the full screen. </p><p>For detailed information on the NSOpenGL classes, see the following reference documentation: </p><ul class="spaceabove"><li class="li"><p><em><a href="../../../../Cocoa/Reference/ApplicationKit/Classes/NSOpenGLView_Class/index.html#//apple_ref/doc/uid/TP40004077" target="_top">NSOpenGLView Class Reference</a></em></p></li><li class="li"><p><em><a href="../../../../Cocoa/Reference/ApplicationKit/Classes/NSOpenGLContext_Class/index.html#//apple_ref/doc/uid/TP40004074" target="_top">NSOpenGLContext Class Reference</a></em></p></li><li class="li"><p><em><a href="../../../../Cocoa/Reference/ApplicationKit/Classes/NSOpenGLPixelBuffer_Class/index.html#//apple_ref/doc/uid/TP40004075" target="_top">NSOpenGLPixelBuffer Class Reference</a></em></p></li><li class="li"><p><em><a href="../../../../Cocoa/Reference/ApplicationKit/Classes/NSOpenGLPixelFormat_Class/index.html#//apple_ref/doc/uid/TP40004076" target="_top">NSOpenGLPixelFormat Class Reference</a></em></p></li></ul><p>Apple Graphics Library (<strong>AGL</strong>) is the Apple interface to OpenGL for Carbon applications. It can be used by both Mach-O and CFM binaries, although  CFM binaries are not recommended in Mac OS X because it's not possible to generate a universal binary with them. (A <strong>universal binary</strong> runs natively on both PowerPC and Intel-based Macintosh computers.) AGL supports drawing to the full screen as well as to Carbon windows and offscreen locations. In addition to the standard functionality, AGL provides full support for hardware-accelerated offscreen drawing, bitmap font rendering, and the ability to render content directly to a texture (also called <strong>render-to-texture</strong> functionality). The AGL API resides in the AGL framework.  Applications must include the <code>AGL.h</code> header file (<code>System/Library/Frameworks/AGL.framework/AGL.h</code>) to access AGL functionality. <em><a href="../../../Reference/AGL_OpenGL/index.html#//apple_ref/doc/uid/TP30001068" target="_top">AGL Reference</a></em> provides a complete description of this API.</p><p>The Core OpenGL API (<strong>CGL</strong>) is the basis for the NSOpenGL classes and AGL. CGL offers the most direct access to system functionality and provides the highest level of graphics performance and control for drawing to the full screen. CGL is windowing-system agnostic but is accessible from both Cocoa and Carbon applications. The CGL API resides in the  OpenGL framework. Applications must include the <code>OpenGL.h</code> header file (<code>System/Library/Frameworks/OpenGL.framework/OpenGL.h</code>) to access CGL functionality. <em><a href="../../../Reference/CGL_OpenGL/index.html#//apple_ref/doc/uid/TP40001186" target="_top">CGL Reference</a></em> provides a complete description of this API.</p><a name="//apple_ref/doc/uid/TP40001987-CH208-SW3" title="Apple-Implemented OpenGL Libraries"></a><h3>Apple-Implemented OpenGL Libraries</h3><p>Mac OS X also provides the full suite of graphics libraries that are part of every implementation of OpenGL: GL, GLU, GLUT, and GLX. Two of these—GL and GLU—provide low-level drawing support. The other two—GLUT and GLX—support drawing to the screen. </p><p>Your application typically interfaces directly with the core OpenGL library (GL), the OpenGL Utility library (GLU), and the OpenGL Utility Toolkit (GLUT). The <strong>GL library</strong> provides a low-level modular API that allows you to define graphical objects. It supports the core functions that are common to all OpenGL implementations, as mandated by the OpenGL specification. It provides support for two fundamental types of graphics primitives: objects defined by sets of vertices, such as line segments and simple polygons, and objects that are pixel-based images, such as filled rectangles and bitmaps. The GL API does not handle complex custom graphical objects; your application must decompose them into simpler geometries.</p><p>The <strong>GLU library</strong> combines functions from the GL library to support  more advanced graphics features. It runs on all conforming implementations of OpenGL. GLU is capable of creating and handling complex polygons (including quartic equations),  processing nonuniform rational b-spline curves (NURBs), scaling images, and decomposing a surface to a series of polygons (tessellation).</p><p>The <strong>GLUT library</strong> provides a cross-platform API for performing operations associated with the user windowing environment—displaying and redrawing content, handling events, and so on. It is implemented on most UNIX, Linux, and Windows platforms. As such, any code that you write with GLUT can be reused across multiple platforms. However, such code is constrained by a generic set of user interface elements and event-handling options. This book does not show how to use GLUT. If you are interested in GLUT, see the sample code in the <span class="content_text"><a href="http://developer.apple.com/referencelibrary/" target="_top">ADC Reference Library</a></span>. GLUT Basics is a simple example that will get you started.</p><p><strong>GLX</strong> is an OpenGL extension that supports using OpenGL within a window provided by the X Window system. X11 for Mac OS X is available as an optional installation using the Mac OS X installation DVD. (It's not shown in <span class="content_text"><a href="opengl_pg_concepts.html#//apple_ref/doc/uid/TP40001987-CH208-SW20">Figure 1-3</a></span>.) See <em>OpenGL Programming for the X Window System</em>, published by Addison Wesley for more information.</p><p>This document does not show how to use these libraries. For detailed information, either go to the OpenGL Foundation website <span class="content_text"><a href="http://www.opengl.org" target="_blank">http://www.opengl.org</a></span>, or see the most recent version of "The Redbook"—<span class="content_text"><a href="http://www.opengl.org/documentation/red_book/" target="_blank">OpenGL Programming Guide</a></span>, published by Addison Wesley.</p><a name="//apple_ref/doc/uid/TP40001987-CH208-SW21" title="Terminology"></a><h2>Terminology</h2><p>There are a number of terms that you’ll want to understand so that you can write code effectively using OpenGL: renderer, renderer attributes, buffer attributes, pixel format objects, rendering contexts, drawable objects, and virtual screens. As an OpenGL programmer  some of these may seem familiar to you. However, understanding the Apple-specific nuances of these terms will help you get the most out of OpenGL on the Macintosh platform.</p><a name="//apple_ref/doc/uid/TP40001987-CH208-SW22" title="Renderer"></a><h3>Renderer</h3><p>A <strong>renderer</strong> is the combination of the hardware and software that OpenGL uses to create an image from a view and a model. (A software renderer is an exception; it does not use graphics hardware and is typically used as a fallback.) The characteristics of the final image depends on the capabilities of the graphics hardware associated with the renderer and the device used to display the image. A particular renderer supports specific capabilities—for example, the ability to produce environmental effects such as fog.</p><p>Mac OS X supports graphics accelerator cards with varying capabilities as well as systems without graphics acceleration hardware. It is possible for multiple renderers, each with different capabilities or features, to drive a single set of graphics hardware. </p><a name="//apple_ref/doc/uid/TP40001987-CH208-SW14" title="Renderer and Buffer Attributes"></a><h3>Renderer and Buffer Attributes</h3><p>Renderer and buffer attributes are operating system-dependent extensions that communicate to OpenGL the renderer and buffer requirements for your application. The Apple implementation of OpenGL  dynamically selects the best renderer for the current rendering task and does so transparently to your application. But, if your application has very specific rendering requirements and wants to control renderer selection, it can do so by supplying the appropriate renderer attributes. Buffer attributes describe such things as color and depth buffer sizes, and whether the data is stereoscopic or monoscopic. </p><p>Renderer and buffer attributes are represented by constants defined in the Apple-specific OpenGL APIs. OpenGL uses the attributes you supply to perform the setup work needed prior to drawing content. <span class="content_text"><a href="../opengl_drawing/opengl_drawing.html#//apple_ref/doc/uid/TP40001987-CH404-SW8">“Drawing to a Window or View”</a></span> provides simple example that show  how to use renderer and buffer attributes. <span class="content_text"><a href="../opengl_pixelformats/opengl_pixelformats.html#//apple_ref/doc/uid/TP40001987-CH214-SW9">“Techniques for Choosing Attributes”</a></span> provides tips on choosing renderer and buffer attributes to achieve specific rendering goals. </p><a name="//apple_ref/doc/uid/TP40001987-CH208-SW15" title="Pixel Format Objects"></a><h3>Pixel Format Objects</h3><p>A <strong>pixel format</strong> describes pixel data storage in memory. The description includes the pixel components (that is, red, blue, green, alpha), the number and order of components, and other relevant information, such as whether a pixel contains stencil and depth values. A  <strong>pixel format object</strong> is an opaque data type designed to hold a pixel format along with a list of renderers and display devices that satisfy the requirements specified by an application. </p><p>Each of the Apple-specific OpenGL APIs defines a pixel format data type and accessor routines that you can use to obtain the information referenced by this object. See <span class="content_text"><a href="opengl_pg_concepts.html#//apple_ref/doc/uid/TP40001987-CH208-SW16">“Virtual Screens”</a></span> for more information on renderer  and display devices.</p><a name="//apple_ref/doc/uid/TP40001987-CH208-SW12" title="Rendering Contexts"></a><h3>Rendering Contexts</h3><p>A <strong>rendering context</strong>, or simply context, contains state information for the rendering target of your application. The context affects the rendered result much in the same way that the characteristics of a drawing pen (ink color, point size, type of ink, and so forth) affect what's drawn on a piece of paper. State variables are set per context. Once set, a value remains as such until you change it. State variables include such things as drawing color, the viewing and projection transformations, lighting characteristics, and material properties.</p><p>Although your application can maintain more than one context, only one context can be the <strong>current context</strong> in a thread. The current context is the rendering context that receives OpenGL commands issued by your application. The system initializes the context  to the default OpenGL state. The context then tracks all state changes made while it is the current context.</p><a name="//apple_ref/doc/uid/TP40001987-CH208-SW13" title="Drawable Objects"></a><h3>Drawable Objects</h3><p>A <strong>drawable object</strong> refers to an object allocated outside of OpenGL, but that can serve as an OpenGL framebuffer. A drawable object can be the target of OpenGL drawing operations. The behavior of drawable objects is not part of the OpenGL specification. Rather, a drawable object is a platform-specific construct provided by the Mac OS X windowing system.</p><p>A drawable object can be any of the following: a Carbon window, a Cocoa view,  offscreen memory, a full-screen graphics device, or a pixel buffer (available starting in Mac OS X v10.3). </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40001987-CH208-SW23" title="Note"></a><p><strong>Note:</strong>&nbsp;A <strong>pixel buffer</strong> (pbuffer)  is an OpenGL buffer designed for hardware-accelerated offscreen drawing and as a source for texturing. An application can render an image into a pixel buffer once and then use the buffer contents multiple times to texture a variety of surfaces without copying the image data.</p></div><p>Before OpenGL can draw to a drawable object, the object must be attached to a rendering context. The characteristics of the drawable object narrow the selection of hardware and software specified by the rendering context. OpenGL automatically allocates buffers, creates surfaces, and specifies which renderer is the current renderer.  </p><p>The logical flow of data from an application through OpenGL to a drawable object is shown in <span class="content_text">Figure 1-4</span>. The application issues OpenGL commands that are sent to the current rendering context. The current context, which contains state information, constrains how the commands are interpreted  by the appropriate renderer. The renderer converts the OpenGL primitives to an image in the framebuffer. (See also <span class="content_text"><a href="opengl_pg_concepts.html#//apple_ref/doc/uid/TP40001987-CH208-SW17">“Running an OpenGL Program in Mac OS X .”</a></span>)</p><br/><div><a name="//apple_ref/doc/uid/TP40001987-CH208-SW6" title="Figure 1-4Data flow through OpenGL"></a><p><strong>Figure 1-4&nbsp;&nbsp;</strong>Data flow through OpenGL</p><img src = "../art/dataflow.jpg" alt = "Data flow through OpenGL" ></div><br/><a name="//apple_ref/doc/uid/TP40001987-CH208-SW16" title="Virtual Screens"></a><h3>Virtual Screens</h3><p>The characteristics and quality of the OpenGL content that the user sees depends on both the renderer and the physical display used to view the content. The combination of renderer and physical display is called a <strong>virtual screen</strong>. This important concept has implications for any application that might run on a system that has more than one renderer or more than one display.</p><p>A simple system, with one graphics card and one physical display, typically has two virtual screens. One virtual screen consists of a hardware-based renderer and the physical display and the other virtual screen consists of a software-based renderer and the physical display. Mac OS X provides a software-based renderer as a fallback. It's possible for your application to decline the use of this fallback. You'll see how in <span class="content_text"><a href="../opengl_pixelformats/opengl_pixelformats.html#//apple_ref/doc/uid/TP40001987-CH214-SW9">“Techniques for Choosing Attributes.”</a></span></p><p>The green rectangle around the OpenGL image in <span class="content_text">Figure 1-5</span> surrounds a virtual screen for a system with one graphics card and one display. Note that a virtual screen is not the physical display, which is why the green rectangle is drawn around the application window that shows the OpenGL content. In this case, it is the renderer provided by the graphics card combined with the characteristics of the display. </p><br/><div><a name="//apple_ref/doc/uid/TP40001987-CH208-SW10" title="Figure 1-5A virtual screen displays what the user sees"></a><p><strong>Figure 1-5&nbsp;&nbsp;</strong>A virtual screen displays what the user sees</p><img src = "../art/one_card_one_vscreen.jpg" alt = "A virtual screen displays what the user sees" ></div><br/><p>Because a virtual screen is not simply the physical display, a system with one display can use more than one virtual screen at a time, as shown in <span class="content_text">Figure 1-6</span>. The green rectangles are drawn to point out each virtual screen. Imagine that the virtual screen on the right side uses a software-only renderer and that the one on the left uses a hardware-dependent renderer. Although this is a contrived example, it illustrates the point.</p><br/><div><a name="//apple_ref/doc/uid/TP40001987-CH208-SW8" title="Figure 1-6Two virtual screens"></a><p><strong>Figure 1-6&nbsp;&nbsp;</strong>Two virtual screens</p><img src = "../art/one_card_two_vscreens.jpg" alt = "Two virtual screens" ></div><br/><p>It's also possible to have a virtual screen that can represent more than one physical display. The green rectangle in <span class="content_text">Figure 1-7</span> is drawn around a virtual screen that spans two physical displays. In this case, the same graphics hardware drives a pair of identical displays. This is also true when mirroring is enabled.</p><br/><div><a name="//apple_ref/doc/uid/TP40001987-CH208-SW7" title="Figure 1-7A virtual screen can represent more than one physical screen"></a><p><strong>Figure 1-7&nbsp;&nbsp;</strong>A virtual screen can represent more than one physical screen</p><img src = "../art/dual_headed_cards.jpg" alt = "A virtual screen can represent more than one physical screen" ></div><br/><p>The concept of a virtual screen is particularly important when the user drags an image from one physical screen to another. When this happens, the virtual screen may change, and with it, a number of attributes of the imaging process, such as the current renderer, may change. With the dual-headed graphics card shown in <span class="content_text"><a href="opengl_pg_concepts.html#//apple_ref/doc/uid/TP40001987-CH208-SW7">Figure 1-7</a></span>, dragging between displays preserves the same virtual screen. However, <span class="content_text">Figure 1-8</span> shows the case for which two displays represent  two unique virtual screens. Not only are the two graphics cards different, but it's possible that the renderer, buffer attributes, and pixel characteristics are different. A change in any of these three items can result in a change in the virtual screen.</p><p>When the user drags an image from one display to another, and the virtual screen is the same for both displays, the image quality should appear similar. However, for the case shown in <span class="content_text">Figure 1-8</span>, the image quality can be quite different.</p><br/><div><a name="//apple_ref/doc/uid/TP40001987-CH208-SW9" title="Figure 1-8Two virtual screens and two graphics cards"></a><p><strong>Figure 1-8&nbsp;&nbsp;</strong>Two virtual screens and two graphics cards</p><img src = "../art/two_cards_two_vscreens.jpg" alt = "Two virtual screens and two graphics cards" ></div><br/><p>OpenGL for Mac OS X transparently manages rendering across multiple monitors. A user can drag a window from one monitor to another, even though their display capabilities may be different or they may be driven by dissimilar graphics cards with dissimilar resolutions and color depths.</p><p>OpenGL dynamically switches renderers when the virtual screen that contains the majority of the pixels in an OpenGL window changes. When a window is split between multiple virtual screens, the framebuffer is rasterized entirely by the renderer driving the screen that contains the largest segment of the window. The regions of the window on the other virtual screens are drawn by copying the rasterized image. When the entire OpenGL drawable object is displayed on one virtual screen, there is no performance impact from multiple monitor support.</p><p>Applications need to track virtual screen changes and, if appropriate, update the current application state to reflect changes in renderer capabilities. See <span class="content_text"><a href="../opengl_contexts/opengl_contexts.html#//apple_ref/doc/uid/TP40001987-CH216-SW12">“Techniques for Working with Rendering Contexts.”</a></span></p><a name="//apple_ref/doc/uid/TP40001987-CH208-SW17" title="Running an OpenGL Program in Mac OS X "></a><h2>Running an OpenGL Program in Mac OS X </h2><p><span class="content_text">Figure 1-9</span> shows the flow of data in an OpenGL program, regardless of the platform that the program runs on. Pixel data and vertex data can be sent to OpenGL for processing in two ways. The first is by issuing OpenGL commands that are executed immediately, either to assemble a model from vertex data or a texture from pixel data. When an application issues OpenGL commands that are executed immediately, OpenGL is said to be operating in <strong>immediate mode</strong>.  There are two immediate mode paths in the figure: one from vertex data to per-vertex operations  and the other from pixel data to per-pixel operations.</p><p>The "display lists" rectangle in the figure represents the second way that an application can send data to OpenGL. A <strong>display list</strong> is a set of OpenGL commands that is assembled and named by an application. The display list is then stored on the OpenGL server. The application can refer to the list by its assigned name when the data defined by the list is needed. Display lists are ideal for computing-intensive operations because at the time you need to use the data, it is already uploaded to the GPU and is usually preprocessed. There are two display list paths in the figure, one for vertex data and one for pixel data.</p><br/><div><a name="//apple_ref/doc/uid/TP40001987-CH208-SW11" title="Figure 1-9 The flow of data through OpenGL"></a><p><strong>Figure 1-9&nbsp;&nbsp;</strong> The flow of data through OpenGL</p><img src = "../art/opengl_pipeline.jpg" alt = "The OpenGL pipeline" ></div><br/><p>Per-vertex operations include such things as applying transformation matrices to add perspective or to clip and applying lighting effects. Per-pixel operations include such things as color conversion and applying blur and distortion effects. Pixels destined for textures are sent to texture assembly where OpenGL stores textures until it needs to apply them onto an object.</p><p>OpenGL rasterizes the processed vertex and pixel data, meaning that the data are converged to create fragments. A fragment encapsulates all the values for a pixel, including color, depth, and sometimes texture values. These values are used during anti-aliasing and any other calculations needed to fill shapes and to connect vertices.</p><p>Per-fragment operations include applying environment effects, depth and stencil testing, and performing other operations such as blending and dithering. Some operations—such as hidden-surface removal—end the processing of a fragment. OpenGL draws fully processed fragments into the appropriate location in the framebuffer.</p><p>The dashed arrows in <span class="content_text">Figure 1-9</span> indicate reading pixel data back from the framebuffer. They represent operations performed by OpenGL functions such as <code>glReadPixels</code>, <code>glCopyPixels</code>, and <code>glCopyTexImage2D</code>.</p><p>So far you've seen how OpenGL operates on any platform. But how do Cocoa and Carbon applications provide data to the OpenGL for processing? Regardless of the application environment (Cocoa or Carbon), a Mac OS X application must perform these tasks:</p><ul class="ul"><li class="li"><p>Set up a list of buffer and renderer attributes that define the sort of drawing you want to perform. (See <span class="content_text"><a href="opengl_pg_concepts.html#//apple_ref/doc/uid/TP40001987-CH208-SW14">“Renderer and Buffer Attributes.”</a></span>)</p></li><li class="li"><p>Request the system to create a pixel format object that contains a pixel format that meets the constraints of the buffer and render attributes and a list of all suitable combinations of displays and renderers. (See <span class="content_text"><a href="opengl_pg_concepts.html#//apple_ref/doc/uid/TP40001987-CH208-SW15">“Pixel Format Objects”</a></span> and <span class="content_text"><a href="opengl_pg_concepts.html#//apple_ref/doc/uid/TP40001987-CH208-SW16">“Virtual Screens.”</a></span>)</p></li><li class="li"><p>Create a rendering context to hold state information that controls such things as drawing color, view and projection matrices, characteristics of light, and conventions used to pack pixels. When you set up this context, you must provide a pixel format object because the rendering context needs to know the set of virtual screens that can be used for drawing. (See <span class="content_text"><a href="opengl_pg_concepts.html#//apple_ref/doc/uid/TP40001987-CH208-SW12">“Rendering Contexts.”</a></span>)</p></li><li class="li"><p>Bind a drawable object to the rendering context. The drawable object is what captures the OpenGL drawing sent to that rendering context. (See <span class="content_text"><a href="opengl_pg_concepts.html#//apple_ref/doc/uid/TP40001987-CH208-SW13">“Drawable Objects.”</a></span>)</p></li><li class="li"><p>Make the rendering context the current context. OpenGL automatically targets the current context. Although your application might have several rendering contexts set up, only the current one is the active one for drawing purposes.</p></li><li class="li"><p>Issue OpenGL drawing commands. If you've completed the previous tasks, the contents of the framebuffer shown in <span class="content_text">Figure 1-9</span> are drawn to the drawable object that's attached to the current rendering context.</p></li></ul><p>The tasks described in the first five bullet items are platform-specific. <span class="content_text"><a href="../opengl_drawing/opengl_drawing.html#//apple_ref/doc/uid/TP40001987-CH404-SW8">“Drawing to a Window or View”</a></span> provides simple examples of how to perform them. As you read other parts of this document, you'll see there are a number of other tasks that, although not mandatory for drawing, are really quite necessary for any application that wants to use OpenGL to perform complex 3D drawing efficiently on a wide variety of Macintosh systems. </p><a name="//apple_ref/doc/uid/TP40001987-CH208-SW24" title="See Also"></a><h2>See Also</h2><p>Reference documentation for the Apple-specific OpenGL programming interfaces:</p><ul class="ul"><li class="li"><p><em><a href="../../../Reference/AGL_OpenGL/index.html#//apple_ref/doc/uid/TP30001068" target="_top">AGL Reference</a></em></p></li><li class="li"><p><em><a href="../../../Reference/CGL_OpenGL/index.html#//apple_ref/doc/uid/TP40001186" target="_top">CGL Reference</a></em></p></li><li class="li"><p><em><a href="../../../../Cocoa/Reference/ApplicationKit/Classes/NSOpenGLContext_Class/index.html#//apple_ref/doc/uid/TP40004074" target="_top">NSOpenGLContext Class Reference</a></em></p></li><li class="li"><p><em><a href="../../../../Cocoa/Reference/ApplicationKit/Classes/NSOpenGLPixelBuffer_Class/index.html#//apple_ref/doc/uid/TP40004075" target="_top">NSOpenGLPixelBuffer Class Reference</a></em></p></li><li class="li"><p><em><a href="../../../../Cocoa/Reference/ApplicationKit/Classes/NSOpenGLPixelFormat_Class/index.html#//apple_ref/doc/uid/TP40004076" target="_top">NSOpenGLPixelFormat Class Reference</a></em></p></li><li class="li"><p><em><a href="../../../../Cocoa/Reference/ApplicationKit/Classes/NSOpenGLView_Class/index.html#//apple_ref/doc/uid/TP40004077" target="_top">NSOpenGLView Class Reference</a></em></p></li></ul><p>The <span class="content_text"><a href="http://developer.apple.com/graphicsimaging/opengl/" target="_top">Apple Developer Connection OpenGL technology page</a></span> links to high-level technical articles on OpenGL and Mac OS X.</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../opengl_intro/opengl_intro.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../opengl_drawing/opengl_drawing.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2004, 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-06-09<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/GraphicsImaging/Conceptual/OpenGL-MacProgGuide/opengl_pg_concepts/opengl_pg_concepts.html%3Fid%3DTP40001987-3.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/GraphicsImaging/Conceptual/OpenGL-MacProgGuide/opengl_pg_concepts/opengl_pg_concepts.html%3Fid%3DTP40001987-3.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/GraphicsImaging/Conceptual/OpenGL-MacProgGuide/opengl_pg_concepts/opengl_pg_concepts.html%3Fid%3DTP40001987-3.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>