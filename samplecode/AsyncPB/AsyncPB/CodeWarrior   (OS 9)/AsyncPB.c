/*	File:		AsyncPB.c		Description:AsyncPB is an example of how File System calls can be made 				in a chain from an interrupt handler like the Time Manager.				Once you select DoIt from the menu give it a little time to actually				process the input file.	Author:		JB	Copyright: 	Copyright: © 1984-1999 by Apple Computer, Inc.				all rights reserved.		Disclaimer:	You may incorporate this sample code into your applications without				restriction, though the sample code has been provided "AS IS" and the				responsibility for its operation is 100% yours.  However, what you are				not permitted to do is to redistribute the source as "DSC Sample Code"				after having made changes. If you're going to re-distribute the source,				we require that you make it clear in the source that the code was				descended from Apple Sample Code, but that you've made changes.		Change History (most recent first):				6/24/99	Updated for Metrowerks Codewarror Pro 2.1(KG)*/#include	<Aliases.h>#include	<AppleEvents.h>#include	<Balloons.h>#include	<Controls.h>#include	<Desk.h>#include	<Dialogs.h>#include	<Events.h>#include	<Errors.h>#include	<Files.h>#include	<Folders.h>#include	<Fonts.h>#include	<GestaltEqu.h>#include	<Icons.h>#include	<Memory.h>#include	<Menus.h>#include 	<OSUtils.h>#include	<Packages.h>#include	<Printing.h>#include	<Quickdraw.h>#include	<Resources.h>#include	<Script.h>#include	<StandardFile.h>#include	<String.h>#include	<Strings.h>#include 	<LowMem.h>#include	<TextEdit.h>#include	<Timer.h>#include 	<ToolUtils.h>#include	<Traps.h>#include	<Types.h>#include	<Windows.h>#include 	"AsyncPB.h"Boolean				gInForeGround			= true;Boolean				gProcessing				= true;unsigned long		gSleep					= 0;#ifdef powercQDGlobals qd;#endif#ifndef powercMyParamBlockPtr		GetParmBlockPtr()		= { 0x2008 }; 	// move.l a0, d0 ;move the pointer to where MPW C places function resultsMyTaskPtr			GetTMTaskPtr()			= { 0x2009 };	// move.l a1, d0 ;move the pointer to where MPW C places function results#endif#ifdef powercpascal void PBWriteIOCompletion(ParmBlkPtr parmblkptr)#elsepascal void PBWriteIOCompletion()#endif{    MyParamBlockPtr		pb;		#ifdef powerc    pb = (MyParamBlockPtr)parmblkptr;    #else	pb = GetParmBlockPtr();	#endif		if (noErr == (*pb).ioParam.ioResult)	{		PrimeTime((QElemPtr) (*pb).tm, 1000 * 1);	}}#ifdef powercpascal void PBReadIOCompletion(ParmBlkPtr parmblkptr)#elsepascal void PBReadIOCompletion()#endif{	    MyParamBlockPtr		pb;	#ifdef powerc	pb = (MyParamBlockPtr)parmblkptr;	#else	pb = GetParmBlockPtr();	#endif		if (noErr == (*pb).ioParam.ioResult)	{		(*pb).ioParam.ioCompletion	= (*pb).writeIOCompletion;		(*pb).ioParam.ioRefNum		= (*pb).writeFileRefNum;		(*pb).ioParam.ioReqCount	= (*pb).ioParam.ioActCount;		(*pb).ioParam.ioPosMode		= fsAtMark;		(*pb).ioParam.ioPosOffset	= 0;		PBWriteAsync((ParmBlkPtr) pb);	}}#ifdef powercpascal void PBSetFPosIOCompletion(ParmBlkPtr parmblkptr)#elsepascal void PBSetFPosIOCompletion()#endif{     	MyParamBlockPtr		pb;		#ifdef powerc	pb = (MyParamBlockPtr)parmblkptr;	#else	pb = GetParmBlockPtr();	#endif	if (noErr == (*pb).ioParam.ioResult)	{		(*pb).ioParam.ioCompletion	= (*pb).readIOCompletion;		(*pb).ioParam.ioRefNum		= (*pb).readFileRefNum;		(*pb).ioParam.ioReqCount	= 1;		(*pb).ioParam.ioPosMode		= fsAtMark;		(*pb).ioParam.ioPosOffset	= 0;		PBReadAsync((ParmBlkPtr) pb);	}}#ifdef powercpascal void TMTaskProc(MyTaskPtr tm)#elsepascal void TMTaskProc()#endif{      /* on the PowerPC, the task record ptr is passed as a parameter */	/* in 68K we have to get it from A1 */	    #ifndef powerc  	  MyTaskPtr    tm; 	  tm = GetTMTaskPtr(); 	#endif		(*(*tm).pb).ioParam.ioCompletion	= (*(*tm).pb).setFPosIOCompletion;	(*(*tm).pb).ioParam.ioRefNum		= (*(*tm).pb).readFileRefNum;	(*(*tm).pb).ioParam.ioPosMode		= fsFromMark;	(*(*tm).pb).ioParam.ioPosOffset		= 2;	PBSetFPosAsync((ParmBlkPtr) (*tm).pb);}void DoMenu(short menu, short item){	OSErr				error		= noErr;	Str255				daName;	short				daRefNum;	Point				where		= { 30, 10 };	switch (menu)	{		case AppleMenu :		{			switch (item)			{				case AboutItem :				{					Alert(AboutAlert, nil);				}				break;								default :				{					GetMenuItemText(GetMenuHandle(AppleMenu), item, daName);					daRefNum = OpenDeskAcc(daName); 				}				break;			}		}		break;				case FileMenu :		{						switch (item)			{				case DoIt :				{					DisableItem(GetMenuHandle(FileMenu), DoIt);					error = FSOpen("\pinData", 0, &gPB.readFileRefNum);											error = FSDelete("\pOutData", 0);					error = Create("\pOutData", 0, 'CWIE', 'TEXT');					error = FSOpen("\pOutData", 0, &gPB.writeFileRefNum);										gPB.ioParam.ioBuffer		= &gBuffer;					gPB.tm						= (TMTaskPtr) &gTM;					gPB.setFPosIOCompletion		= NewIOCompletionProc (PBSetFPosIOCompletion);							gPB.readIOCompletion		= NewIOCompletionProc (PBReadIOCompletion);							gPB.writeIOCompletion		= NewIOCompletionProc (PBWriteIOCompletion);											#if false					gPB.ioParam.ioCompletion	= gPB.setFPosIOCompletion;					gPB.ioParam.ioRefNum		= gPB.readFileRefNum;					gPB.ioParam.ioPosMode		= fsFromMark;					gPB.ioParam.ioPosOffset		= 3;					PBSetFPosAsync((ParmBlkPtr) &gPB);				#else					gTM.theTMTask.qType	= 0;					gTM.theTMTask.tmCount	= 0;					gTM.theTMTask.tmAddr	= NewTimerProc(TMTaskProc);					gTM.pb		= &gPB;					InsTime((QElemPtr) &gTM);										PrimeTime((QElemPtr) &gTM, 30 * 1);				#endif								}				break;												case QuitItem :				{					RmvTime((QElemPtr)&gTM);					gProcessing = false;				}				break;			}		}		break;				default :		{		}		break;			}}		void EventLoop(){	OSErr				error		 = noErr;	EventRecord			event;	Boolean				gotEvent;	WindowPtr			window;	DialogPtr			dialog;	short				itemHit;	short				part;	long				menuItem;	short				menu;	short				item;	gotEvent = WaitNextEvent(everyEvent, &event, gSleep, nil);		if (IsDialogEvent(&event))	{		if (! ((keyDown == event.what || autoKey == event.what) && (event.modifiers & cmdKey)))		{			if (DialogSelect(&event, &dialog, &itemHit))			{			}		}	}	else	{		switch (event.what)		{			case nullEvent:			{			}			break;									case mouseDown:			{				switch (part = FindWindow(event.where, &window))				{					case inMenuBar:					{						menuItem = MenuSelect(event.where);						menu = HiWord(menuItem);						item = LoWord(menuItem);						DoMenu(menu, item);						HiliteMenu(0);					}					break;						case inContent :					{						if (! (*(WindowPeek)window).hilited)						{							SelectWindow(window);						}						else						if (kWindowKind == (*(WindowPeek)window).windowKind)						{						}					}					break;										case inGrow :					{						#define		kMinWidth		128						#define		kMinWeight		64						auto		Rect			limitRect;						auto		long			newSize;												if (kWindowKind == (*(WindowPeek)window).windowKind)						{							limitRect = qd.screenBits.bounds;							InsetRect(&limitRect, 8, 8);							limitRect.top	= kMinWeight;							limitRect.left	= kMinWidth;							newSize = GrowWindow(window, event.where, &limitRect);							if (0 != newSize)							{								SizeWindow(window, LoWord(newSize), HiWord(newSize), true);							}						}					}					break;										case inDrag:					{						DragWindow(window, event.where, &qd.screenBits.bounds);					}					break;										case inGoAway :					{						if (TrackGoAway(window, event.where))						{						}					}					break;									case inZoomIn :					case inZoomOut :					{						if (kWindowKind == (*(WindowPeek)window).windowKind)						{							if ( TrackBox(window, event.where, part) )							{								SetPort(window);								EraseRect(&window->portRect);								ZoomWindow(window, part, true);								InvalRect(&window->portRect);							}						}					}					break;									}			}			break;						case updateEvt:			{				window = (WindowPtr) event.message;				if (kWindowKind == (*(WindowPeek)window).windowKind)				{					SetPort(window);					BeginUpdate(window);					{					}					EndUpdate(window);				}			}			break;						case activateEvt:			{				window = (WindowPtr) event.message;						if (kWindowKind == (*(WindowPeek)window).windowKind)				{				}			}			break;						case autoKey:					case keyDown:			{				auto	char	key;								key = event.message & charCodeMask;				if (event.modifiers & cmdKey)				{					menuItem = MenuKey(key);					menu = HiWord(menuItem);					item = LoWord(menuItem);					DoMenu(menu, item);				}				else				{					window = FrontWindow();					if (kWindowKind == (*(WindowPeek)window).windowKind)					{					}				}			}			break;						case osEvt:			{				switch ((event.message >> 24) & 0x0FF)				{					case suspendResumeMessage:					{						gInForeGround = 0 != (event.message & resumeFlag);					}					break;				}			}			break;						case kHighLevelEvent:			{				error = AEProcessAppleEvent(&event);			}			break;		}	}}main (){				OSErr				error		 = noErr;	Handle				menuBar;		InitGraf(&qd.thePort);	InitFonts();	InitWindows();	InitMenus();	TEInit();	InitDialogs(nil);	InitCursor();	menuBar = GetNewMBar(ApplicationMenuBar);	if (nil == menuBar)	{		error = ResError();		if (noErr == error)		{			error = resNotFound;						ExitToShell();		}	}	else	{		SetMenuBar(menuBar);		DisposeHandle(menuBar);		AppendResMenu(GetMenuHandle(AppleMenu), 'DRVR');		DrawMenuBar();	}				while (gProcessing)		EventLoop();	return 0;}