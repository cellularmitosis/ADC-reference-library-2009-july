<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><html><head><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note NW14: AppleTalk Timers Explained</title><meta name="keywords" content=""><meta name="Description" content="Technical Note NW14: ">                                           <meta name="categories" content="Networking"><meta name="week-posted" content="Mar 26, 1990 - Apr 6, 1990"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF" TEXT="#000000"><a name="//apple_ref/doc/uid/DTS10002556" title="AppleTalk Timers Explained"></a><a name="top"></a><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxNetworking-date.html">Networking</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Networking/index.html" target="_blank">Reference Library > Networking</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note NW14</div>
<div id="pageheadsub">AppleTalk Timers Explained</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->					<p id="menutext"><a href="#Introduction">Introduction</a><BR><BR><a href="#Section1">Selecting ATP Retry Time and Retry Count</a><BR><BR><a href="#Section2">NBP Retry Counts</a><BR><BR><a href="#Section3">Setting TRel Timer in SendRequest</a><BR><BR><a href="#Section4">xppTimeout and xppRetry</a><BR><BR><a href="#References">References</a><BR><BR><a href="#Downloads">Downloadables</a></p>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><P id = "introtext">This Technical Note explains how to effectively use timers and retry mechanismsof the various AppleTalk protocols to achieve maximum performance on aninternet.</p><!-- end_intro_text --><!-- begin_date --><h3 align=center>[Apr 01 1990]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR><!-- begin_content --><h2>Introduction</h2><a name="Introduction"></a><p>The most fundamental service in an AppleTalk internet is the Datagram DeliveryProtocol (DDP), which provides a best-effort, connectionless, packet deliverysystem.  A sequence of packets sent using DDP on an AppleTalk internet betweena pair of machines may traverse a single high-speed Ethernet network or it maywind across multiple intermediate data links such as LocalTalk, TokenRing,etc., which are connected by routers.  Some packet loss is always inevitablebecause of the loosely coupled nature of the underlying networks.  Even on asingle high-speed Ethernet network, packets can be lost due to collisions or abusy destination node.  The AppleTalk Transaction Protocol (ATP), the AppleTalkData Stream Protocol (ADSP), and other high-level protocols protect againstpacket loss and ensure reliability by using positive acknowledgement withpacket retransmission mechanism.</p><p>The basic transaction process in ATP consists of a client in a requesting nodesending a Transaction Request (TReq) packet to a client in a responding node.The client in the responding node is expected to service the request andgenerate a series of Transaction Response (TResp) packets, which also serves asan acknowledgement.  The ATP process in the requesting node also starts a timerwhen it sends a packet and retransmits a packet if the timer expires before acomplete response arrives.  In a large internet with multiple gateways, it isimpossible to know how quickly acknowledgements may return to the requestor.If you set the retry time to be too small, you may be retransmitting a requestwhile a delayed response is <i>en route</i>, but if you wait too long toretransmit a request, application performance may suffer.  More importantly,the delay at each gateway depends upon the traffic, so the time required totransmit a packet and receive an acknowledgement varies from one instant toanother.  To further complicate matters, two packets sent back to back couldtake completely different routes to the destination.</p><P><A HREF="#top">Back to top</A></P><a name="Section1"></a><h2>Selecting ATP Retry Time and Retry Count</h2><p>You can use the round trip time for a transaction as a heuristic for settingthe retry time and retry count.  The round trip time between two nodes in aparticular internet at a particular time is usually deterministic.</p><p>The easiest way to set the retry time is to assign a static value based on theround trip time for a transaction.  The AppleTalk Echo Protocol (AEP) can beused to obtain the round trip time in a given moment between two nodes.  AEP isimplemented in each node as a DDP client residing on statically assigned socketnumber four.  You should use DDP to send AEP requests through any socket thatis available, and you should use the maximum packet size that you plan on usingin your application.  You can listen for AEP responses by implementing a socketlistener.  The following code is an example AEP socket listener.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>;_________________________________________________________________________;_________________________________________________________________________;; EchoDude;; 3/90 pvh - MacDTS;; (c)1990 Apple Computer, Inc.;; The following MPW Asm code is a socket listener for reading in returned Echo; (DDP type 4) packets.;; The target device was shipped a packet with a '1' in the first byte of the data; area by way of a DDPWrite.  It was sent to socket 4, the Echoer socket.  If the; target device has an Echoer, it will send a return packet to us of equal size; except it will have replaced the '1' in the first byte with the value '2'.  This; indicates an EchoReply packet.;; The listener itself (RcvEcho) is added with a POpenSkt (Inside Mac V-513) call by; passing the address of the listener in the listener field of the parameter block.;; All we really are trying to accomplish here is to set up a notification for; returned packets from the target Echoer.  A time (Ticks) is stuffed into a; location our app can find (actually back into the packet buffer) and will be used; to calculate round trips times.  We'll also save off the hop count from the packet; header for fun too since I have nothing better to do with my time on weekends.;; More could be done with this listener as far as making sure that we are only; receiving back a packet from the node we sent it to etc.... but we can't; encompass everything in a sample.  Okay, well we could... but we have to leave; something for you guys to do.;; It should be noted that careful preservation of register A5 is necessary.; LAP requires that A5 be preserved AFTER the call to ReadRest. i.e. you; cannot save A5 onto the stack when your socket listener is entered, call ReadRest; and then restore A5 from the stack and exit.  Wah.  LAP requires that the address; placed in A5 during ReadRest be there when your socket listener is exited.; So... if you need a different A5 after the call to ReadRest make sure you restore; it before RTS-ing back the caller.;;;    Called:;         A0,A1,D1 : Preserve until after ReadRest;         A2 -&gt; MPP local variables;         A3 -&gt; RHA after DDP header;         A4 -&gt; ReadPacket, 2(A4) -&gt; ReadRest;         A5 Useable until ReadRest;         A6,D4-D7 : Preserve across call;;__________________________________________________________________________EchoSkt    EQU    4        ; Echo socket numberEP         EQU    4        ; EP DDP protocol typeEPReq      EQU    1        ; Code for echo requestEPReply    EQU    2        ; Code for echo reply;; Read the packet into the echo buffer;RcvEcho    PROC    EXPORT                   EXPORT    our_A5 : CODE                   EXPORT    our_Buff : CODE                   IMPORT    GBOB:DATA        BRA.S     checkEchoour_A5        DC.L      0our_Buff        DC.L      0our_Hops        DC.W      0our_Ticks        DC.L      0checkEcho        CMP.B     #EP,-(A3)            ; Make sure it's an echo packet        BNE.S     RcvEIgnore           ; Ignore it if not        LEA       toRHA(A2), A3        ; top of RHA        CLR.L     D2                   ; clean up D2        MOVE.B    lapType(A3), D2      ; lap type        CMP.B     #longDDP, D2         ; check for long header (Type #2 packet)        BNE.S     noHops               ; wah... no hops if short packet        MOVE.B    lapType+1(A3), D2    ; this is the hop count byte, 1st byte in DDP                       ; header        AND.B     #$3C, D2             ; mask to middle 4 bits of byte for hop count                                       ;     | x | x | H | O | P | S | x | x |        ASR.B     #2, D2               ; shift 2 bits to right        LEA       our_Hops, A3         ; address of our storage        MOVE.B    D2, (A3)             ; move # of hops into our storagenoHops        MOVE.W    #DDPMaxData, D3      ; our buffer is #DDPMaxData in size        LEA       our_Buff, A3         ; address of buffer to read packet into        MOVE.L    (A3), A3             ; set buffer        JSR       2(A4)                ; ReadRest of packet into buffer        BEQ.S     RcvEchoReply         ; If no error, continue        BRA.S     RcvEchoFail          ; dang...RcvEIgnore        CLR       D3                   ; Set to ignore packet        JMP       2(A4)                ; Ignore it, ReadRest and return        BRA.S     RcvEchoFailRcvEchoReply        CMP.B     #EPReply, -DDPMaxData(A3)    ; make sure it's our reply packet                                       ; it shouldn't be anything else, but check                                       ; just in case        BNE.S     RcvEchoFail          ; if not our reply then blow        MOVE.L    A5, D2               ; save dude in D2        LEA       our_A5, A5           ; address of our A5 local storage        MOVE.L    (A5), A5             ; make A5 our A5 for application global use        MOVE.B    #1, GBOB(A5)         ; set flag confirming reception of                                       ; echo reply packet        LEA       our_Buff, A3         ; address of our local buffer storage into A3        MOVE.L    (A3), A3             ; get saved pointer and set buffer.        LEA       our_Hops, A5         ; address of hops local storage... notice we                                       ; are TRASHING A5 with this!!!!!        MOVE.W    (A5), (A3)+          ; copy in hop count to buffer        MOVE.L    Ticks, (A3)          ; next copy in Ticks        MOVE.L    D2, A5               ; restore dude        RTS                            ; return to callerRcvEchoFail        RTS                            ; return to caller        ENDPsetUpSktListener    PROC    EXPORT                            IMPORT    our_A5 : CODE                            IMPORT    our_Buff : CODE        LEA       our_A5, A0           ; this copies        MOVE.L    CurrentA5, (A0)      ; this copies CurrentA5 into our local                                       ; storage for global use in the listener        MOVE.W    #DDPMaxData, D0      ; max size of data in a packet        _NewPtr   CLEAR        BNE.S     setUpFailed          ; if NIL then forget it        LEA       our_Buff, A1         ; we need to save the pointer reference        MOVE.L    A0, (A1)             ;  in a place the listener can find it        MOVE.L    A0, D0               ; return value to caller        RTSsetUpFailed        CLR.L     D0                   ; tell caller we failed by returning nil                                       ; (caller expecting valid ptr returned)        RTS        ENDP</pre>	</TD></TR></TABLE></CENTER><p>We now resume our regular programming...</p><p>You should typically get an AEP response packet within a few milliseconds.  Ifthere is no response for a period of time, typically about 10 seconds, youshould resend your AEP request to account for a lost request or lost packets.To be really safe, you should resend your AEP request with different data totake into account the response to the first packet coming back later.  Theretry time could then be simply set to <code>k*Round_Trip_Time</code>, where thevalue of <code>k </code>depends upon the request semantics, like total data size.</p><p>This technique of statically setting the retry time is not always adequate toaccommodate the varying delays encountered in a internet environment atdifferent times.  You could dynamically adjust the retry time based on anadaptive retransmission algorithm that continuously monitors round trip timesand adjusts its timeout parameter accordingly.  To implement an adaptivealgorithm, you can record the round trip time for each transaction.  One commontechnique is to keep the average round trip time as a weighted average and usenew round trip times from transactions to change the average slowly.  Forexample, one averaging technique** uses a constant weighingfactor, <code>q</code>, where <code>0 &lt;= q &lt; 1</code>, to weigh the oldestaverage against the latest round trip time:</p><p>Choosing a value for <code>q</code> close to 1 makes the weighted average immune tochanges that last a short time.  Choosing a value for <code>q</code> close to 0makes the weighted average respond to changes in the delay very quickly.</p><p>The total time (i.e., <code>retry time * retry count)</code> before a request isconcluded as failed could be anywhere from 10 seconds to a couple of minutes,depending on the type of the client application and the relative distancebetween the source and the destination.</p><ul type="disc">	<li>**Douglass_Corner, InterNetworking with TCP/IP. KARN, P. and C. PARTRIDGE [August 1987], "Improving Round-Trip Time Estimates in Reliable Transport Protocols", <i>Proceedings of ACM SIGCOMM 1987</i>.</li></ul><P><A HREF="#top">Back to top</A></P><a name="Section2"></a><h2>NBP Retry Counts</h2><p>You cannot really use the AEP to estimate round trip times for NBP packetsbecause you need to use NBP to determine the internet address of the node fromwhich an echo is being sought.  In this case, you have to use the type ofdevice that you are looking for as a heuristic for setting the retry count.The LaserWriter, for example, may be busy and not respond to a LkUp packet.  Insuch a case, you might want to do a quick lookup to return a partial list tothe user like the Chooser.  You could then do a longer lookup to get a morecomplete list of mappings.  You should use a "back off" algorithm to make thesubsequent lookups further apart to generate progressively less traffic.  Namelookups are expensive and produce a lot of network traffic, and nameconfirmation is the recommended call to use when confirming mappings obtainedthrough early bindings.  Because Name lookups are expensive, you should avoidsearching all the zones in the internet.</p><P><A HREF="#top">Back to top</A></P><a name="Section3"></a><h2>Setting TRel Timer in SendRequest</h2><p>AppleTalk Phase 2 drivers allow you to set the TRel timer in<code>SendRequest</code> or <code>NSendRequest </code>calls with ATP XO (exactly once)service so as not to be locked into the pre-AppleTalk Phase 2 time of 30seconds.  You should set this timer based on the round trip time.  Generally,if the round trip time is less than one second, the default TRel time settingof 30 seconds is adequate.  If the round trip time is more, you can increasethe TRel time proportionately.</p><P><A HREF="#top">Back to top</A></P><a name="Section4"></a><h2>xppTimeout and xppRetry</h2><p>The two ZIP calls, <code>GetZoneList</code> and <code>GetLocalZones</code>, made on the.XPP driver contain the ATP retry interval (in seconds) and count, in the<code>xppTimeout</code> and <code>xppRetry</code> parameters.  Both these functions areATP request-response transactions between a node and a router on the network towhich the requesting node is attached.  The round trip is relatively short forthis transaction, and you should have very small values of <code>xppTimeout</code>and <code>xppRetry,</code> typically two and three, respectively.</p><P><A HREF="#top">Back to top</A></P><a name="References"></a><h2>References</h2><P>Inside AppleTalk</p><P>Inside Macintosh, Volumes II &amp; V, The AppleTalk Manager</p><P><A HREF = "nw_18.html">M.NW.Internets</a></p><P>M.NW.AppleTalk2Mac</p>                                    <P><A HREF="#top">Back to top</A></P><P><A NAME=Downloads></A></P>                  <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (60K)</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/nw_14.pdf">Download</A></P>               </TD>            </TR>                     </TABLE>         <BR>         <P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/nw/nw_14.html%3Fid%3DDTS10002556-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/nw/nw_14.html%3Fid%3DDTS10002556-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/nw/nw_14.html%3Fid%3DDTS10002556-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>