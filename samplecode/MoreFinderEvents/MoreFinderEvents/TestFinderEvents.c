	//	//	Complaints and kudos to:	//	//		Pete Gontier	//		Apple Macintosh Developer Technical Support	//		<gurgle@apple.com>	//#define OLDROUTINELOCATIONS		0#define OLDROUTINENAMES			0#define SystemSevenOrLater		1#ifndef __FONTS__#	include <Fonts.h>#endif#ifndef __DIALOGS__#	include <Dialogs.h>#endif#ifndef __RESOURCES__#	include <Resources.h>#endif#ifndef __STANDARDFILE__#	include <StandardFile.h>#endif#ifndef __APPLEEVENTS__#	include <AppleEvents.h>#endif#include "MoreFinderEvents.h"static Boolean gQuitting;static pascal OSErr QuitAppleEventHandler (const AppleEvent *, AppleEvent *, long){	gQuitting = true;	return noErr;}static pascal OSErr InitMac (void){	MaxApplZone ( );	InitGraf (&(qd.thePort));	InitFonts ( );	InitWindows ( );	InitMenus ( );	TEInit ( );	InitDialogs (nil);	return noErr;}static pascal void AppleMenuCommand (short){}static pascal short DlgHookYDProc (short item, DialogRef dRef, void *ydP){	if (GetWRefCon (dRef) == sfMainDialogRefCon)	{		if (item == sfHookFirstCall)		{			Handle messageDitlH = Get1Resource ('DITL',*(short*)ydP);			if (!ResError ( ) && messageDitlH)			{				DetachResource (messageDitlH);				if (ResError ( ))					ReleaseResource (messageDitlH);				else				{					AppendDITL (dRef,messageDitlH,appendDITLBottom);					DisposeHandle (messageDitlH);				}			}		}	}	return item;}static pascal OSErr SelectAndAct (pascal OSErr (*actor) (const AliasRecord **), Boolean useParent){	OSErr err = noErr;	StandardFileReply *replyP = (StandardFileReply *) NewPtr (sizeof (StandardFileReply));	if (!(err = MemError ( )))	{		Point sfPoint = { -1, -1 };		short msgDitlResID = useParent ? 129 : 128;		CustomGetFile (nil,-1,nil,replyP,sfGetDialogID,sfPoint,DlgHookYDProc,nil,nil,nil,&msgDitlResID);		if (replyP->sfGood)		{			if (!useParent || !(err = FSMakeFSSpec (replyP->sfFile.vRefNum,replyP->sfFile.parID,nil,&(replyP->sfFile))))			{				AliasHandle aliasH = nil;						if (!(err = NewAliasMinimal (&(replyP->sfFile), &aliasH)))				{					err = actor (aliasH);					DisposeHandle ((Handle) aliasH);					if (!err) err = MemError ( );				}			}		}		DisposePtr ((Ptr) replyP);		if (!err) err = MemError ( );	}	return err;}static pascal Boolean VolFileFilterYDProc (CInfoPBPtr, void *){	return true;}static pascal short VolDlgHookYDProc (short item, DialogRef, void *){	switch (item)	{		case sfHookFirstCall		:			item = sfHookGoToDesktop;			break;		case sfHookGoToAliasTarget	:		case sfHookGoToPrevDrive	:		case sfHookGoToNextDrive	:		case sfHookChangeSelection	:			SysBeep (10);			item = sfHookNullEvent;			break;		case sfHookOpenFolder		:			item = sfItemOpenButton;			break;	}	return item;}static pascal OSErr ChooseAndUnmount (void){	OSErr err = noErr;	StandardFileReply reply;	Point sfWhere = {-1,-1};	CustomGetFile (VolFileFilterYDProc,-1,nil,&reply,sfGetDialogID,sfWhere,VolDlgHookYDProc,nil,nil,nil,nil);	if (reply.sfGood)		err = MFE_UnmountVolume (reply.sfFile.vRefNum);	return err;}static pascal OSErr PageSetupAndPrint (const AliasRecord **aliasH){	OSErr err = MFE_PageSetup (aliasH);	if (!err) err = MFE_PrintWindow (aliasH);	return err;}static const AliasRecord **gAliasToDrag;static pascal OSErr MoveFile2 (const AliasRecord **destAlias){	return MFE_Move (gAliasToDrag,destAlias);}static pascal OSErr CopyFile2 (const AliasRecord **destAlias){	return MFE_Copy (gAliasToDrag,destAlias);}static pascal OSErr CopyFile (const AliasRecord **aliasToDrag){	gAliasToDrag = aliasToDrag;	return SelectAndAct (CopyFile2,true);}static pascal OSErr MoveFile (const AliasRecord **aliasToDrag){	gAliasToDrag = aliasToDrag;	return SelectAndAct (MoveFile2,true);}static pascal OSErr FinderMenuCommand (short menuItem){	OSErr err = unimpErr;	enum	{		kMenuItem_Title,		kMoveFile,		kCopyFile,		kMenuItem_Divider2,		kMenuItem_Reveal,		kMenuItem_OpenParent,		kMenuItem_CloseParent,		kMenuItem_Divider3,		kMenuItem_PageSetupParent,		kMenuItem_PrintParent,		kMenuItem_Divider4,		kMenuItem_MakeAlias,		kMenuItem_Duplicate,		kMenuItem_OpenSelection,		kMenuItem_PrintSelection,		kMenuItem_Divider5,		kMenuItem_PutAway,		kMenuItem_UnmountVol,		kMenuItem_Divider6,		kMenuItem_GetInfo,		kMenuItem_CloseGetInfo,		kMenuItem_Divider7,		kMenuItem_Sharing,		kMenuItem_CloseSharing,		kMenuItem_Divider8,		kMenuItem_Sleep,		kMenuItem_Restart,		kMenuItem_ShutDown,		kMenuItem_Divider9,		kMenuItem_EmptyTrash,		kMenuItem_Divider10,		kMenuItem_ShowAbout,		kMenuItem_HideAbout,		kMenuItem_Divider11,		kMenuItem_ShowClip,		kMenuItem_HideClip	};	switch (menuItem)	{		case kCopyFile :			err = SelectAndAct (CopyFile,false);			break;		case kMoveFile :			err = SelectAndAct (MoveFile,false);			break;		case kMenuItem_PutAway :			err = SelectAndAct (MFE_PutAway,false);			break;		case kMenuItem_MakeAlias :			err = SelectAndAct (MFE_MakeAlias,false);			break;		case kMenuItem_Duplicate :			err = SelectAndAct (MFE_Duplicate,false);			break;		case kMenuItem_OpenSelection :			err = SelectAndAct (MFE_OpenSelection,false);			break;		case kMenuItem_PrintSelection :			err = SelectAndAct (MFE_PrintSelection,false);			break;		case kMenuItem_PageSetupParent :			err = SelectAndAct (MFE_PageSetup,true);			break;		case kMenuItem_PrintParent :			err = SelectAndAct (PageSetupAndPrint,true);			break;		case kMenuItem_OpenParent :			err = SelectAndAct (MFE_OpenSelection,true);			break;		case kMenuItem_CloseParent :			err = SelectAndAct (MFE_CloseWindow,true);			break;		case kMenuItem_CloseGetInfo :			err = SelectAndAct (MFE_CloseGetInfo,false);			break;		case kMenuItem_GetInfo :			err = SelectAndAct (MFE_OpenGetInfo,false);			break;		case kMenuItem_CloseSharing :			err = SelectAndAct (MFE_CloseSharing,true);			break;		case kMenuItem_Sharing :			err = SelectAndAct (MFE_OpenSharing,true);			break;		case kMenuItem_EmptyTrash :			err = MFE_EmptyTrash ( );			break;		case kMenuItem_ShowAbout :			err = MFE_ShowAbout ( );			break;		case kMenuItem_HideAbout :			err = MFE_HideAbout ( );			break;		case kMenuItem_ShowClip :			err = MFE_ShowClipboard ( );			break;		case kMenuItem_HideClip :			err = MFE_HideClipboard ( );			break;		case kMenuItem_Reveal :			err = SelectAndAct (MFE_Reveal,false);			break;		case kMenuItem_UnmountVol :			err = ChooseAndUnmount ( );			break;		case kMenuItem_Sleep :			err = MFE_Sleep ( );			break;		case kMenuItem_Restart :			err = MFE_Restart ( );			break;		case kMenuItem_ShutDown :			err = MFE_ShutDown ( );			break;	}	return err;}static pascal void EditMenuCommand (short){}static pascal OSErr Command (long ms){	OSErr err = noErr;	short	menuID = ms >> 16,			menuItem = ms;	enum	{		kMenuID_File = 129,		kMenuID_Apple,		kMenuID_Finder,		kMenuID_Edit	};	switch (menuID)	{		case kMenuID_File :			gQuitting = true;			break;		case kMenuID_Apple :			AppleMenuCommand (menuItem);			break;		case kMenuID_Finder :			err = FinderMenuCommand (menuItem);			break;		case kMenuID_Edit :			EditMenuCommand (menuItem);			break;	}	return err;}static pascal OSErr HandleEvent (const EventRecord *eventP){	OSErr err = noErr;	if (eventP->what == kHighLevelEvent)		AEProcessAppleEvent (eventP);	else if (eventP->what == mouseDown)	{		WindowRef whichWindow;		short partCode = FindWindow (eventP->where, &whichWindow);		if (partCode == inMenuBar)		{			long ms = MenuSelect (eventP->where);			if (ms)				err = Command (ms);			HiliteMenu (0);		}	}	return err;}static pascal Boolean SetUpMenuBar (void){	Boolean result = false;	Handle mBar = GetNewMBar (128);	if (!ResError ( ) && mBar)	{		SetMenuBar (mBar);		AppendResMenu (GetMenuHandle (130), 'DRVR');		DrawMenuBar ( );		result = true;		ReleaseResource (mBar);	}	return result;}void main (void){	if (!InitMac ( ))	{		if (SetUpMenuBar ( ))		{			if (!(AEInstallEventHandler (kCoreEventClass, kAEQuitApplication,				NewAEEventHandlerProc (QuitAppleEventHandler), 0, false)))			{				do				{					OSErr err = noErr;					EventRecord event;					InitCursor ( );					WaitNextEvent (everyEvent, &event, -1, nil);					err = HandleEvent (&event);					if (err) SysBeep (10);				}				while (!gQuitting);			}		}	}}