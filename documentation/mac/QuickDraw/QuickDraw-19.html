<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>About Basic QuickDraw (IM: Im)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING19></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!--end of header -->

<center>
<A HREF="QuickDraw-18.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="QuickDraw-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="QuickDraw-476.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="QuickDraw-20.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="QuickDraw-2.html"><B>Imaging With QuickDraw</B></A> / <BR><DD><A HREF="QuickDraw-18.html"><B>Chapter 2 - Basic QuickDraw</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING19-0></A>
<H1>About Basic QuickDraw</H1>
 <B>Basic QuickDraw, </B>designed for the earliest Macintosh models with their built-in black-and-white screens, is a collection of system software routines that your application can use to manipulate images on all Macintosh computers. <P>
<DL>
<DT><A NAME=MARKER-9-14><B>Note</B>
<DD></A>All Macintosh computers support basic QuickDraw. Only those computers based on the Motorola 68000 processor, such as the Macintosh Classic and PowerBook 100 computers, provide no support for Color QuickDraw.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 Basic QuickDraw performs its operations in a graphics port based on a data structure of types <CODE>GrafPort</CODE>. (Color QuickDraw, described in the chapter "Color QuickDraw," can work with data structures of type <CODE>GrafPort</CODE> or <CODE>CGrafPort</CODE>, the latter offering extensive color and grayscale facilities.)<P>
 As described in the chapter "Introduction to QuickDraw," each graphics port has its own local coordinate system. All fields in a graphics port are expressed in these coordinates, and all calculations and actions that QuickDraw performs use the local coordinate system of the current graphics port. The mathematical constructs of this coordinate system are described next. <P>
<A NAME=HEADING19-5></A>
<H2>The Mathematical Foundations of QuickDraw</H2>
 <A NAME=MARKER-2-198></A>QuickDraw defines some mathematical constructs that are widely used in its procedures, functions, and data types:\xDDthe coordinate plane, the point, the rectangle, and the region. Points are defined in terms of the coordinate plane. Points in turn are used to define a rectangle. Rectangles assign coordinates to boundaries and images, and rectangles frame graphic objects such as regions and ovals. Regions define arbitrary areas on the coordinate plane.<P>
 For example, each graphics port has its own local coordinate system on the coordinate plane; the location of the graphics pen used for drawing into a graphics port is expressed as a point; a commonly used rectangle is the <B>port rectangle,</B> which in a graphics port for a window represents the window's content area; and a commonly used region in QuickDraw is the <B>visible region,</B> which in a graphics port for a window represents the portion of the window that's actually visible on the screen--that is, the part that's not covered by other windows.<P>
<A NAME=HEADING19-8></A>
<H3>The Coordinate Plane</H3>
 As described in the chapter "Introduction to QuickDraw," all information about location or movement is specified to QuickDraw in terms of coordinates on a plane. The plane is a two-dimensional grid whose coordinates range from -32768 to 32767. On a user's computer, there is one <B>global coordinate system</B> that represents all potential QuickDraw drawing space. The origin of the global coordinate system--that is, the point with a horizontal coordinate of 0 and a vertical coordinate of 0--is at the upper-left corner of the user's main screen. Each graphics port on that user's computer has its own<B> local coordinate system,</B> which is defined relative to the port rectangle of the graphics port. Typically, the upper-left corner of a port rectangle is assigned a local horizontal coordinate of 0 and a local vertical coordinate of 0, although you can use the <CODE>SetOrigin</CODE> procedure to change the coordinates of this corner.<P>
<DL>
<DT><A NAME=MARKER-9-274></A><B>IMPORTANT</B>
<DD>QuickDraw stores points and rectangles in its own data structures of types <CODE>Point</CODE> and <CODE>Rect</CODE>. In these structures, the vertical coordinate (<CODE>v</CODE>) appears first, followed by the horizontal coordinate (<CODE>h</CODE>). However, in parameters to all QuickDraw routines, you specify the horizontal coordinate first and the vertical coordinate second.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 So that the user can select onscreen objects across this coordinate plane, QuickDraw predefines several cursors, described in the chapter "Cursor Utilities" in this book, that the user manipulates with the mouse.<P>
<A NAME=HEADING19-12></A>
<H3>Points</H3>
 <A NAME=MARKER-2-107></A>A point is located by the combination of a vertical coordinate and a horizontal coordinate. Points themselves are dimensionless; if a visible pixel is located at a point, the pixel hangs down and to the right of the point. You can store the coordinates of a point into a variable of type <CODE>Point</CODE>, which QuickDraw defines as a record of two integers.<P>
<PRE>
TYPE VHSelect =   (v,h); 
Point = 
RECORD 
   CASE Integer OF
         0: (v:\xDD\xDD Integer:    {vertical coordinate}
             h:\xDD\xDD Integer);   {horizontal coordinate}
         1: (vh:\xDD\xDDARRAY[VHSelect] OF Integer);
END;
</PRE>
 The third field of this record lets you access the vertical and horizontal coordinates of a point either individually or as an array. For example, the following code fragment illustrates how to assign values to the coordinates of points:<P>
<PRE>
VAR 
   westPt, eastPt: Point;

westPt.v := 40; westPt.h := 60;
eastPt.vh[v] := 90; eastPt.vh[h] := 110;
</PRE>
 <A HREF=QuickDraw-48.html#MARKER-9-295>"Manipulating Points in Graphics Ports" beginning on page 2-47</A> describes several QuickDraw routines you can use to change and calculate points.<A NAME=MARKER-2-110></A><P>
<A NAME=HEADING19-18></A>
<H3>Rectangles</H3>
 <A NAME=MARKER-2-108></A>Any two points can define the upper-left and lower-right corners of a rectangle. Just as points are infinitely small, the borders of the rectangle are infinitely thin.<P>
 The data type for rectangles is <CODE>Rect</CODE>, and the data structure consists of either four integers or two points:<P>
<PRE>
TYPE Rect = 
RECORD 
   CASE Integer OF               {cases: four sides or two points}
      0: (top:       Integer;    {upper boundary of rectangle}
          left:      Integer;    {left boundary of rectangle}
          bottom:    Integer;    {lower boundary of rectangle}
          right:     Integer);   {right boundary of rectangle}
      1: (topLeft:   Point;      {upper-left corner of rectangle}
          botRight:  Point);     {lower-right corner of rectangle}
END;
</PRE>
 You can access a variable of type <CODE>Rect</CODE> either as four boundary coordinates or as two diagonally opposite corner points. All of the following coordinates to the rectangle named <CODE>shipRect</CODE> are permissible:<P>
<PRE>
VAR
   shipRect: Rect;

{specify rectangle with boundary coordinates}
shipRect.top := 20; shipRect.left := 20; shipRect.bottom := 70; 
   shipRect.right := 70;

{specify rectangle with upper-left and bottom-right points}
shipRect.topLeft := (20,20); shipRect.botRight := (70,70);

{specify individual coordinates for rectangle's upper-left }
{ and bottom-right points}
shipRect.topLeft.v := 20; shipRect.topLeft.h :=20; 
   shipRect.botRight.v := 70; shipRect.botRight.h :70;

{specify individual coordinates for rectangle's upper-left }
{ and bottom-right points, where the points are arrays}
shipRect.topLeft.vh[v] := 20; shipRect.topLeft.vh[h] := 20;
   shipRect.botRight.vh[v] := 70; shipRect.botRight.vh[h] := 70;
</PRE>
 As described in the chapter "QuickDraw Drawing" in this book, many calculations and graphics operations can be performed on rectangles.<P>
<DL>
<DT><B>Note</B>
<DD>If the bottom coordinate of a rectangle is equal to or less than the top, or the right coordinate is equal to or less than the left, the rectangle is an empty rectangle, one that contains no data.<EM></EM><A NAME=MARKER-2-109></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING19-26></A>
<H3>Regions</H3>
 The data structure for a region consists of two fixed-length fields followed by a variable-length field:<P>
<PRE>
TYPE Region =
   RECORD
      rgnSize:\xDD\xDDInteger;{size in bytes}
      rgnBBox:\xDD\xDDRect;   {enclosing rectangle}
      {more data if region is not rectangular}
   END;
</PRE>
 The <CODE>rgnSize</CODE> field contains the size, in bytes, of the region. The maximum size is 32 KB when using basic QuickDraw (and 64 KB when using Color QuickDraw). The <CODE>rgnBBox</CODE> field is a rectangle that completely encloses the region.<P>
 The simplest region is a rectangle. In this case, the <CODE>rgnBBox</CODE> field defines the entire region, and there's no optional region data. For rectangular regions (or empty regions), the <CODE>rgnSize</CODE> field contains 10. The data for more complex regions is stored in a proprietary format.<P>
 As described in the chapter "QuickDraw Drawing" in this book, you can gather an arbitrary set of spatially coherent points into a region and rapidly perform complex manipulations and calculations on them.<A NAME=MARKER-2-199></A><P>
<A NAME=HEADING19-32></A>
<H2><A NAME=MARKER-9-22></A>The Black-and-White Drawing Environment: Basic Graphics Ports</H2>
 A graphics port is a complete drawing environment that defines where and how graphics operations take place. You can have many graphics ports open at once; each one has its own local coordinate system, drawing pattern, background pattern, pen size and location, font and font style, and bitmap or pixel map (for a color graphics port). You can quickly switch from one graphics port to another. <P>
 As described in the chapter "Window Manager" in <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I>, the Window Manager incorporates a graphics port in each window record it creates. Similarly, the Printing Manager (described in the chapter "Printing Manager" in this book) incorporates a graphics port in each print record it creates. You can also use the <CODE>NewGWorld</CODE> function to create graphics ports that are not in a window, and hence not visible on a screen. As described in the chapter "Offscreen Graphics Worlds" in this book, such offscreen graphics worlds are useful for preparing images for display; when the image is ready, you can quickly copy it to an onscreen graphics port.<P>
 There are two kinds of graphics ports: the black-and-white, basic graphics port based on the data structure of type <CODE>GrafPort</CODE>, and the color graphics port based on the data structure of type <CODE>CGrafPort</CODE> (used only with Color QuickDraw). The basic graphics port is discussed here; the color graphics port is discussed in the chapter "Color QuickDraw." (Using the basic eight-color system described in the chapter "QuickDraw Drawing," you can also use a basic graphics port to display eight predefined colors.)<P>
 The <CODE>GrafPort</CODE> record is diagrammed in <A HREF=#MARKER-9-23>Figure 2-1</A>. Some aspects of its contents are discussed after the figure; see <A HREF=QuickDraw-27.html#MARKER-9-138>page 2-27</A> for a complete description of the record fields. Your application should not directly set any fields of a <CODE>GrafPort</CODE> record; instead you should use QuickDraw routines to manipulate them.<P>
<B>Figure 2-1  <A NAME=MARKER-9-23></A>The <CODE>GrafPort</CODE> record and the <CODE>BitMap</CODE> record</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/BASIC-L-01.jpg"><BR>
<A NAME=HEADING19-39></A>
<H3>Bitmaps</H3>
 <A NAME=MARKER-2-146></A><A NAME=MARKER-2-116></A>The <CODE>portBits</CODE> field of a <CODE>GrafPort</CODE> record contains the <B>bitmap,</B> a data structure of type <CODE>BitMap</CODE> that defines a black-and-white physical bit image in terms of the QuickDraw coordinate plane. The structure of a bitmap is illustrated in <A HREF=#MARKER-9-23>Figure 2-1</A>.<P>
 <A NAME=MARKER-2-115></A>The <CODE>baseAddr</CODE> field of the <CODE>BitMap</CODE> record contains a pointer to the beginning of the bit image. (There can be several bitmaps pointing to the same bit image, each imposing its own coordinate system on it.) A <B>bit image</B> is a collection of bits in memory that form a grid. To visualize the relationship between the bits in memory and the bits in an image, take a sequence of words in memory and lay them end to end so that bit 15 of the lowest-numbered word is on the left and bit 0 of the highest-numbered word is on the far right. Then take this line of bits and divide it, on word boundaries, into a number of equal-size rows. Stack these rows vertically so that the first row is on the top and the last row is on the bottom. The result is a matrix like the one shown in <A HREF=#MARKER-9-27>Figure 2-2</A>--rows and columns of bits, with each row containing the same number of bytes. A bit image can be any length that's a multiple of the row's width in bytes.<P>
<B>Figure 2-2  <A NAME=MARKER-9-27></A>A bit image</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/BASIC-L-10.jpg"><BR>
 The screen itself is one large visible bit image. On a Macintosh Classic, for example, the screen is a 342-by-512 bit image, with a row width of 64 bytes. These 21,888 bytes of memory are displayed as a matrix of 175,104 pixels on the screen; each bit corresponds to one screen pixel. If a bit's value is 0, its screen pixel is white; if the bit's value is 1, it is black. (Color QuickDraw can work with images that store more than 1 bit for each screen pixel. Such images are called <I>pixel images</I>; they are described in the chapter "Color QuickDraw" in this book.)<P>
 The <CODE>rowBytes</CODE> field of the bitmap contains the width of a row of the image in bytes. A bitmap must always begin on a word boundary and contain an integral number of words in each row. The value of the <CODE>rowBytes</CODE> field must be less than $4000.<P>
 <A NAME=MARKER-2-208></A>The <CODE>bounds</CODE> field is the bitmap's <B>boundary rectangle,</B> which serves two purposes. First, it links the local coordinate system of a graphics port to QuickDraw's global coordinate system. Second, it defines the area of an image into which QuickDraw can draw. <P>
 The coordinates of the upper-left corner of the boundary rectangle define the distance from the origin of the graphics port's local coordinate system to the origin of QuickDraw's global coordinate system. In this way, the boundary rectangle links the local coordinate system of a graphics port to QuickDraw's global coordinate system. For example, by subtracting the vertical and horizontal coordinates of the upper-left corner of the boundary rectangle from any other point local to the graphics port, you convert that point into global coordinates. By comparing the origin of a window to the origin of the main screen, <A HREF=#MARKER-9-29>Figure 2-3</A> illustrates the relationship of the boundary rectangle's local coordinate system to QuickDraw's global coordinate system.<P>
<B>Figure 2-3  <A NAME=MARKER-9-29></A>Relationship of the boundary rectangle and the port rectangle to the global coordinate system</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/BASIC-L-11.jpg"><BR>
 The origin of the local coordinate system is defined by the upper-left corner of the port rectangle for the graphics port. (The port rectangle, as described in <A HREF=#MARKER-9-34>"The Graphics Port Drawing Area" on page 2-10</A>, is specified in the <CODE>portRect</CODE> field of the <CODE>GrafPort</CODE> record.) In a graphics port for a window, this point is called the <B>window origin,</B> and it marks the upper-left corner of a window's content region. As shown in <A HREF=#MARKER-9-29>Figure 2-3</A>, this point usually has horizontal and vertical coordinates of 0 in the local coordinate system. <P>
 The origin for the global coordinate system has horizontal and vertical coordinates of 0 in the global coordinate system, and, as shown in <A HREF=#MARKER-9-29>Figure 2-3</A>, this point lies at the upper-left corner of the main screen. <P>
 By default, QuickDraw assigns the entire main screen as the boundary rectangle for a bitmap. Therefore, the local coordinates of the upper-left corner of the boundary rectangle reflect the distance from the window origin to the screen origin. In <A HREF=#MARKER-9-29>Figure 2-3</A>, for example, the upper-left corner of the boundary rectangle has a horizontal coordinate of -60 and a vertical coordinate of -90 in the local coordinate system because the window origin has a horizontal coordinate of 60 and a vertical coordinate of 90 in the global coordinate system. <P>
 The boundary rectangle defines the area of an image into which QuickDraw can draw. The upper-left corner of the boundary rectangle is aligned around the first bit in the bit image. The width of the boundary rectangle determines how many bits of one row are logically owned by the bitmap. This width must not exceed the number of bits in each row of the bit image (although the width may be smaller than the number of bits in each row). <P>
 The height of the boundary rectangle determines how many rows of the bit image are logically owned by the bitmap. The number of rows enclosed by the boundary rectangle must not exceed the number of rows in the bit image (although the number of rows enclosed by the boundary rectangle may be fewer than those in the bit image).<P>
 Normally, the boundary rectangle exactly encloses the bit image. If the rectangle is smaller than either dimension of the image, the rightmost bits in each row, or the last rows in the image, or both, are not considered part of the bitmap. All drawing that QuickDraw does in a bitmap is clipped to the edges of the boundary rectangle--bits (and their corresponding pixels) that lie outside the rectangle are unaffected by drawing operations. <A NAME=MARKER-2-114></A><A NAME=MARKER-2-113></A><P>
 The bitmap may be changed to point to a different bit image in memory. All graphics routines work in exactly the same way regardless of whether their effects are visible on the screen. Your application can, for example, prepare an image to be printed on a printer without ever displaying the image on the screen (as described in the chapter "Printing Manager" in this book), or it can prepare an image in an offscreen graphics world before transferring it to the screen (as described in the chapter "Offscreen Graphics Worlds" in this book).<A NAME=MARKER-2-147></A> <A NAME=MARKER-2-205></A><P>
<A NAME=HEADING19-57></A>
<H3><A NAME=MARKER-9-34></A>The Graphics Port Drawing Area</H3>
 Several fields in the <CODE>GrafPort</CODE> record define your application's drawing area. <A NAME=MARKER-2-211></A><P>
 The <CODE>portRect</CODE> field denotes the port rectangle that defines a subset of the bitmap to be used for drawing.\xDDAll drawing done by your application occurs inside the port rectangle. As explained in the previous section, the boundary rectangle defines the local coordinate system used by the port rectangle. The port rectangle usually falls within the bitmap's boundary rectangle, but it's not required to do so.<A NAME=MARKER-2-213></A><P>
 The <CODE>visRgn</CODE> field designates the visible region of the graphics port. The visible region is the region of the graphics port that's actually visible on the screen. The visible region is manipulated by the Window Manager. For example, if the user moves one window in front of another, the Window Manager logically removes the area of overlap from the visible region of the window in back. When you draw into the back window, whatever's being drawn is clipped to the visible region so that it doesn't run over onto the front window. <A NAME=MARKER-2-214></A><P>
 The <CODE>clipRgn</CODE> field specifies the graphics port's <B>clipping region,</B> which you can use to limit drawing to any region within the port rectangle. The initial clipping region of a graphics port is an arbitrarily large rectangle: one that covers the entire QuickDraw coordinate plane. You can set the clipping region to any arbitrary region, to aid you in drawing inside the graphics port. If, for example, you want to draw a half-circle on the screen, you can set the clipping region to half of the square that would enclose the whole circle, and then draw the whole circle. Only the half within the clipping region is actually drawn in the graphics port. <A NAME=MARKER-2-121></A><A NAME=MARKER-2-213></A><P>
 All drawing in a graphics port occurs in the intersection of the graphics port's boundary rectangle and its port rectangle, and, within that intersection, all drawing is cropped to the graphics port's visible region and its clipping region. No drawing occurs outside the intersection of the port rectangle, the visible region, and the clipping region. <A HREF=#MARKER-9-41>Figure 2-4</A> illustrates several of the previously described fields of the <CODE>GrafPort</CODE> record.<P>
<B>Figure 2-4  <A NAME=MARKER-9-41></A>Comparing the boundary rectangle, port rectangle, visible region, and clipping region</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/BASIC-L-05.jpg"><BR>
 As shown in this figure, QuickDraw assigns the entire screen as the boundary rectangle for window A. This boundary rectangle shares the same local coordinate system as the port rectangle for window A. Although not shown in this figure, the upper-left corner--that is, the window origin--of this port rectangle has a horizontal coordinate of 0 and a vertical coordinate of 0, whereas the upper-left corner for window A's boundary rectangle has a horizontal coordinate of -40 and a vertical coordinate of -40.<A NAME=MARKER-2-21></A><P>
 In this figure, to avoid drawing over scroll bars when drawing into window B, the application that created that window has defined a clipping region that excludes the scroll bars.<A NAME=MARKER-2-227></A><A NAME=MARKER-2-212></A><A NAME=MARKER-2-216></A><P>
<A NAME=HEADING19-67></A>
<H3>Graphics Port Bit Patterns</H3>
 <A NAME=MARKER-2-152></A><A NAME=MARKER-2-122></A><A NAME=MARKER-2-134></A>The <CODE>bkPat</CODE> and <CODE>fillPat</CODE> fields of a <CODE>GrafPort</CODE> record contain patterns used by certain QuickDraw routines. The <CODE>bkPat</CODE> field contains the background pattern that's used when an area is erased or when bits are scrolled out of it. When asked to fill an area with a specified pattern, QuickDraw stores the given pattern in the <CODE>fillPat</CODE> field and then calls a low-level drawing routine that gets the pattern from that field. <P>
 <I>Bit patterns</I>--which are usually black and white, although any two colors can be used on a color screen--are described in the chapter "QuickDraw Drawing" in this book; patterns with colors at any pixel depth, called <I>pixel patterns</I>, are described in the chapter "Color QuickDraw" in this book.<A NAME=MARKER-2-49></A><A NAME=MARKER-2-124></A><P>
<A NAME=HEADING19-70></A>
<H3>The Graphics Pen</H3>
 The <CODE>pnLoc</CODE>, <CODE>pnSize</CODE>, <CODE>pnMode</CODE>, <CODE>pnPat</CODE>, and <CODE>pnVis</CODE> fields of a graphics port deal with the graphics pen. Each graphics port has one and only one such pen, which is used for drawing lines, shapes, and text. The pen has four characteristics:\xDDa location, a size (height and width), a drawing mode, and a drawing pattern. The routines for determining and changing these four characteristics are described in the chapter "QuickDraw Drawing."<A NAME=MARKER-2-146></A><P>
<A NAME=HEADING19-72></A>
<H3>Text in a Graphics Port</H3>
 The <CODE>txFont</CODE>, <CODE>txFace</CODE>, <CODE>txMode</CODE>, <CODE>txSize</CODE>, and <CODE>spExtra</CODE> fields of a graphics port determine how text is drawn--the typeface, font style, and font size of characters and how they are placed in the bit image. QuickDraw can draw characters as quickly and easily as it draws lines and shapes, and in many prepared typefaces. The characters may be drawn in any size and font style (that is, with stylistic variations such as bold, italic, and underline). Text is drawn with the base line positioned at the pen location.<A NAME=MARKER-2-126></A><P>
 For information on using text in your application, including how to use the QuickDraw routines that manipulate text characteristics stored in a graphics port, see <I>Inside Macintosh: Text.</I><P>
<A NAME=HEADING19-75></A>
<H3>The Limited Colors of a Basic Graphics Port</H3>
 The <CODE>fgColor</CODE>, <CODE>bkColor</CODE>, and <CODE>colrBit</CODE> fields contain values for drawing in the <B>eight-color system</B> available with basic QuickDraw. Although limited to eight predefined colors, this system has the advantage of being compatible across all Macintosh platforms. The <CODE>fgColor</CODE> field contains the graphics port's foreground color, and <CODE>bkColor</CODE> contains its background color. The <CODE>colrBit</CODE> field tells the color imaging software which plane of the color picture to draw into. <P>
 These colors are recorded when drawing into a QuickDraw picture (described in the chapter "Pictures" in this book)--for example, drawing a line with a red foreground color stores a red line in the picture--but these colors cannot be stored in a bitmap. The basic graphics port's color drawing capabilities are discussed in the chapter "QuickDraw Drawing."<A NAME=MARKER-2-127></A><P>
<A NAME=HEADING19-78></A>
<H3>Other Fields</H3>
 The <CODE>patStretch</CODE> field is used during printing to expand patterns if necessary. Your application should not change the value of this field.<P>
 The <CODE>picSave</CODE>, <CODE>rgnSave</CODE>, and <CODE>polySave</CODE> fields reflect the states of picture, region, and polygon definitions, respectively. To define a region, for example, you open it, call routines that draw it, and then close it. The chapter "QuickDraw Drawing" describes in detail how to use pictures, regions, and polygons to draw into a graphics port.<P>
 Finally, the <CODE>grafProcs</CODE> field may point to a special data structure that your application can store into if you want to customize QuickDraw drawing routines or use QuickDraw in other specialized ways, as described in the chapter "QuickDraw Drawing."<P>

</BLOCKQUOTE>
<HR>
<center>
<A HREF="QuickDraw-18.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="QuickDraw-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="QuickDraw-476.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="QuickDraw-20.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="QuickDraw-3.html">&copy; Apple Computer, Inc.</A><br>7 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
