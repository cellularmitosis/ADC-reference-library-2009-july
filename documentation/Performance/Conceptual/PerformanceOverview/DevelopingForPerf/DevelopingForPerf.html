<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Performance Overview: Developing for Performance</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Developing for Performance"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40001410-CH203" title="Developing for Performance"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000430" target="_top">Performance</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP40001410-CH202-DontLinkElementID_32">Performance Overview</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Introduction/Introduction.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../BasicTips/BasicTips.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40001410-CH203-CJBEFGHG" title="Developing for Performance"></a><h1>Developing for Performance</h1><p>Performance is an aspect of software design that is often overlooked until it becomes a serious problem. If you wait until the end of your development cycle to do performance tuning, it may be too late to achieve any significant improvements. Performance is something to include early in the design phase and continue improving all throughout the development cycle.</p><p>Of course, in order to design for performance, it helps to understand what performance is. The sections in this chapter provide background information about the factors that influence performance, how those factors manifest themselves in Mac OS X, and how you can approach the monitoring of those factors. </p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="DevelopingForPerf.html#//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_5">What Is Performance?</a>
				
			<br/>
			
        
			
			
				<a href="DevelopingForPerf.html#//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_11">Tracking Performance</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_5" title="What Is Performance?"></a><h2>What Is Performance?</h2><p><a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_87"></a>The term “performance” may mean different things to different people. So before embarking on a quest to improve the performance of your application, now is a good time to consider what this term means. </p><p>Many people equate performance with speed. Indeed, if a program performs a complex operation in one second, you might think the program has good performance. Taken by itself, though, speed can be a misleading measurement. In complex software systems, the speed of an operation is not a fixed value. If you perform the same operation several times under different conditions, the time it takes to complete that operation could vary widely. That is because the program is only one of many processes sharing resources on the local system, and the use (or abuse) of those resources affects all other processes.</p><p>The following sections explain performance in terms of two different concepts: efficient resource usage and user perception. Both of these concepts have an important impact on how you design and implement your application, and understanding how to use both can lead to better overall performance. </p><a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_6" title="The Efficient Use of Resources"></a><h3>The Efficient Use of Resources</h3><p>A computer shares a limited number of resources among all the running processes. At the lowest level, these resources break down to the following categories:</p><ul class="spaceabove"><li class="li"><p>CPU time</p></li><li class="li"><p>Memory space</p></li><li class="li"><p>Mass storage space</p></li></ul><p>All of your data resides either in memory or on some sort of mass storage device and must be operated on by the CPU. An efficient application uses all of these resources carefully. The following sections provide more detail about each type of resource and its effects on your programs. </p><a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_7" title="CPU Time"></a><h4>CPU Time</h4><a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_88"></a><a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_89"></a><p>CPU time is doled out by the system so you must make the best possible use of what time you have. Because Mac OS X implements symmetric multiprocessing, each thread on the system is assigned a slice of time (maximum of 10 milliseconds) in which to run. At the end of that time (or before in many cases) the system takes back control of the CPU and gives it to a different thread. </p><p>On a typical Mac OS X system (with more than 100 concurrently running threads), if every thread used its full allotment of time, performance would be terrible. This leads to one of the most important goals for writing an application:</p><p><strong>Goal:</strong><em>If your program has nothing to do, it should not consume CPU time</em>. </p><p>The best way to accomplish this goal is to use an event-based model. Using modern event-handling systems, such as the Carbon Event Manager, means your program’s threads are run only when there is work to be done.</p><p>When your application does have work to do, it should use CPU time as effectively as it can. This means choosing algorithms that are appropriate for the amount of data you expect to handle. It also means using other system resources, such as an available vector unit (Velocity Engine or SSE) or the graphics processor, to perform specialized operations, which leads to the following goal:</p><p><strong>Goal:</strong><em>Move work out of the CPU whenever you can</em>.</p><p>For basic information about how to use CPU time effectively, see <span class="content_text"><a href="../BasicTips/BasicTips.html#//apple_ref/doc/uid/TP40001410-CH204-BBCIFICC">“Fundamental Optimization Tips.”</a></span> For tips specifically related to improving the speed of drawing operations, see <span class="content_text"><a href="../BasicTips/BasicTips.html#//apple_ref/doc/uid/TP40001410-CH204-BBCGCFAB">“Drawing Code.”</a></span> </p><a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_8" title="Memory  Space"></a><h4>Memory  Space</h4><a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_90"></a><a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_91"></a><p>Memory on modern computing hardware is typically composed of progressively slower (but larger) types of memory. The fastest memory available to the CPU is the CPU’s own registers. The next fastest is the L1 cache, followed by the L2 and L3 caches when they are available. The next fastest memory is the main memory. The slowest memory of all consists of virtual memory pages that reside on disk and must be paged in before they can be used.</p><p>In an ideal world, every application would be small enough to fit into the system’s fastest cache memory. Unfortunately, most of an application’s code and data resides either in main memory or paged out to disk. Therefore, it is important that the application’s code and data is organized in a way that minimizes the time spent in these slower media, which leads to the following goal:</p><p><strong>Goal:</strong><em>Reduce the memory footprint of your program</em>.</p><p>Reducing the memory footprint<a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_92"></a> of your program can significantly improve its performance. A small memory footprint usually has two advantages. First, the smaller your program, the fewer memory pages it occupies. Fewer memory pages, typically means less paging. Second, code is usually smaller as a result of being more heavily optimized and better organized. Thus, fewer instructions are needed to perform a given task and all of the code for that task is gathered on the same set of memory pages.</p><p>In addition to reducing your application’s memory footprint, you should also try to reduce the footprint of writable memory pages<a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_93"></a> in your application. Writable memory pages store global<a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_94"></a> or allocated data for your application. If a page fault<a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_95"></a> occurs in a low-memory situation, the virtual memory system may need to reclaim some of your application’s memory pages to make room for another process. If a page has not been modified, the system can reclaim it and immediately overwrite it with new data. However, if the page has been modified, the system must first write the modifications to disk. Writing data to disk adds a significant amount of time to the processing time of a page fault. </p><p>For basic information about how to reduce the footprint of your program, see <span class="content_text"><a href="../BasicTips/BasicTips.html#//apple_ref/doc/uid/TP40001410-CH204-BBCJHDJH">“Application Footprint.”</a></span> For tips specifically related to using memory more efficiently, see <span class="content_text"><a href="../BasicTips/BasicTips.html#//apple_ref/doc/uid/TP40001410-CH204-BBCFHEGA">“Memory Allocation Code.”</a></span> </p><a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_9" title="Mass Storage Space"></a><h4>Mass Storage Space</h4><a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_96"></a><p>File-system<a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_97"></a> performance on any computer is important because nearly everything resides in a file somewhere. Your applications, data, and even the operating system itself all reside in files that must be loaded into memory from a device that is incredibly slow compared to other parts of the system. File systems, whether they are local or network-based, are one of the biggest bottlenecks to performance. This leads to yet another goal:</p><p><strong>Goal:</strong><em>Eliminate unnecessary file operations and delay others until the information is actually needed</em>. </p><p>Removing this bottleneck, by eliminating or delaying your file operations, is important to improving the overall performance of your application. Tens of millions of CPU cycles can pass between the time you request data from a file and the time your program actually sees that data. If your program accesses a large number of files, it may wait many seconds before it receives all of the requested data.</p><p>Another important thing to remember in Mac OS X is that your application and any files it creates may be on the network<a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_98"></a> instead of on a local hard disk. Mac OS X makes the network as invisible as possible, so you should never make any assumptions about the locality of files. </p><p>For basic information about how to improve the file-based performance of your program, see <span class="content_text"><a href="../BasicTips/BasicTips.html#//apple_ref/doc/uid/TP40001410-CH204-BBCEGGIH">“File Access Code.”</a></span> </p><a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_10" title="The Perception of Speed"></a><h3>The Perception of Speed</h3><a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_99"></a><p>Even if you tune your application for optimal performance, it’s entirely possible that your application still appears slow to the user. The problem is unavoidable: if you have a lot of work to do, you need the CPU time and resources to do that work. In this situation, you need to give your application the appearance of speed. You can do that with the following goal:</p><p><strong>Goal:</strong><em>Make your program responsive to the user</em>. </p><p>Responsiveness is usually a more important factor to users than raw speed. As long as a program responds to commands in a timely manner, the user is often willing to accept the fact that some tasks take longer to perform. Thus, the perception of speed is achieved by letting the user continue to work while your program processes data in the background. Threading your application is a good way to make it responsive to the user. While your main thread responds to the user, worker threads perform calculations or handle other time-consuming tasks.</p><p>Another common way to make your application appears fast is to improve its launch time. An application that takes more than a few seconds to launch is probably doing too much. Not only is it unresponsive to the user during that time but it may also be loading resources that are not needed right away or might not be used at all, which is wasteful. </p><p>For information about how to improve launch times, see <span class="content_text"><a href="../BasicTips/BasicTips.html#//apple_ref/doc/uid/TP40001410-CH204-BBCCHDAF">“Launch Time Initialization Code.”</a></span> For information about improving the perceived performance of your program, see <span class="content_text"><a href="../BasicTips/BasicTips.html#//apple_ref/doc/uid/TP40001410-CH204-BCIFDFAA">“Take Advantage of Perceived Performance.”</a></span> <a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_100"></a></p><a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_11" title="Tracking Performance"></a><h2>Tracking Performance</h2><a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_101"></a><p>The only way to ensure high performance is to include performance goals in your product design and measure your product against those goals throughout the development process. High performance is not a feature that you can graft onto your code at the end of the development cycle; it is intimately tied to that cycle. As code is written, it is important to know the impact it has on your program’s overall performance. If you detect performance problems early, you have a good chance to fix them before it is too late. </p><p>The way to determine if you are meeting or exceeding a specific goal is to gather metrics. Apple provides several tools for monitoring and analyzing the performance of a program. You can also build measurement tools directly into your code to help automate the process of gathering data. Whichever approach you choose, you need to exercise those tools regularly and analyze the results. </p><a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_12" title="Establish Your Baseline Metrics "></a><h3>Establish Your Baseline Metrics </h3><a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_102"></a><p>The first thing you need to do is decide on a set of baseline metrics you want to measure. Choose the tasks you think are most important to your users and identify a set of constraints for performing those tasks. For example, you might want a document to load in less than 1 second or cause no more than 100 kilobytes of memory to be allocated.</p><p>The tasks you choose to measure should reflect the needs of your users. Your marketing department should be able to help you choose a set of tasks that users will find relevant. If you have an established product, talk to you users and find out what features they consider slow and consider adding those features to your list of tasks. </p><p>Once you have a list of tasks you want to track, you need to determine the performance targets for each task. For existing products, you might simply be trying to improve on the performance of the previous version. You might also try to measure the performance of competing products and set goals that meet or exceed their performance. If you have a new product, you might have to experiment with numbers to find reasonable values. Alternatively, you might want to establish aggressive baseline values and try to come as close to them as possible. </p><p>As with any performance measurement, consistency is important. Your process for establishing baseline metrics should include information about the system on which you are gathering those metrics. Record the hardware and software configuration of your system in some detail and always run your tests against the same configuration. Try to use the slowest possible hardware configuration for establishing your baselines. Measurements on a fast machine might lead you to believe that your software performs well, but many users will be running computers with slower processors or less memory. </p><a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_13" title="Measure Early, Measure Often"></a><h3>Measure Early, Measure Often</h3><p>Performance data<a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_103"></a> is not something you can gather once and hope to find all of the performance bottlenecks in your program. It’s easier to find problems if you maintain a history of your program’s performance. Maintaining a history makes it easy to see whether your application’s performance is improving or declining. If it’s declining, you can take action to correct the problem before your product ships. </p><p>Another reason for measuring performance regularly is that you can correlate those results with code checkins<a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_104"></a><a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_105"></a>. If performance at a particular milestone declines, you can review the code checked in during that period and try to find out why. Similarly, if performance improves, you can use the recent code checkins as a model for good programming practices and encourage your team to use similar techniques. </p><p>You should start making performance measurements as soon as you have a partially functional program. As new features are added, you can add measurements for those features. Incorporating a set of automated diagnostic routines directly into your program makes it easier for the members of your team to see the results immediately. Having this information readily available makes it easier for them to fix performance problems before checking in their code. </p><a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_14" title="Analyze Your Results"></a><h3>Analyze Your Results</h3><a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_106"></a><p><a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_107"></a>Gathering data is the most important step in identifying performance bottlenecks. But once you have the data, it’s also important that you use it to find problems. Analyzing performance data is not as simple as looking at the output and seeing the problem right away. You might get lucky and see the problem quickly, but some problems are subtler and require more careful analysis. </p><p>One way to help analyze results is to plot them graphically. Visualizing performance data can help you see trends much more quickly than if they were in a spreadsheet or other text-based medium. For example, you could plot the time to complete an operation against a particular build to determine if performance is improving or declining from build to build. </p><a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_15" title="Analyze Higher-Level Algorithms"></a><h4>Analyze Higher-Level Algorithms</h4><a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_108"></a><p>As you analyze performance data, keep an open mind towards the abstraction level at which the problem resides. Suppose the data you have indicates that a lot of time is spent inside a particular function. It may be that the code in the function itself can be optimized so that it performs faster, but is that the real cause of the problem? Run your program again but this time sample on calls to that function. Look at how many times the function is called and see if there are any patterns there. If the function is called one million times, the problem might be in the higher-level algorithm that is calling it in the first place. If the function is called once, the body of the function is likely the problem. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_28" title="Note"></a><p><strong>Note:</strong>&nbsp;Shark is one of the more powerful tools you can use to analyze your program. The data mining capabilities of Shark are an excellent way to detect problems in higher-level algorithms. For more information about Shark and the other Apple-provided tools, see <span class="content_text"><a href="../PerformanceTools/PerformanceTools.html#//apple_ref/doc/uid/TP40001410-CH205-BCIIHAAJ">“Performance Tools.”</a></span> </p></div><p>The performance tools themselves have limitations<a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_109"></a> that you need to understand and take into account when analyzing data. For example, sampling programs may point out places where your application is spending a lot of time, but you should understand how Shark and other tools gather their data before drawing too many conclusions. These tools do not track every function call. Instead, they offer a statistical analysis of your program based on samples taken at fixed intervals. Use the output from these tools as a guide, but be sure to correlate it with other data you record.</p><a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_16" title="Other Analysis Techniques"></a><h4>Other Analysis Techniques</h4><p>If you are ever in doubt as to the true cause of a performance problem, avoid making assumptions about the cause of the problem. Instead, refine your analysis by focusing your data gathering efforts on the relevant code. Try using different tools to gather new types of information. A different tool might provide a unique perspective that reveals more about the actual problem. </p><p>Some additional ways you can analyze your program include the following:</p><ul class="spaceabove"><li class="li"><p>Watch the code in the debugger. Walking through code in the debugger might reveal logic errors that are slowing the code down. </p></li><li class="li"><p>Add checkpoints<a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_110"></a> to the code to log information about when that code was executed. For an example of using checkpoints to track initialization code, see the <em><a href="../../LaunchTime/index.html#//apple_ref/doc/uid/10000148i" target="_top">Launch Time Performance Guidelines</a></em>.</p></li><li class="li"><p>Try coding alternate solutions to the problem and see if they run into similar problems. <a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_111"></a><a name="//apple_ref/doc/uid/TP40001410-CH203-DontLinkElementID_112"></a></p></li></ul>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Introduction/Introduction.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../BasicTips/BasicTips.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2004, 2006 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2006-10-03<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Performance/Conceptual/PerformanceOverview/DevelopingForPerf/DevelopingForPerf.html%3Fid%3DTP40001410-1.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Performance/Conceptual/PerformanceOverview/DevelopingForPerf/DevelopingForPerf.html%3Fid%3DTP40001410-1.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Performance/Conceptual/PerformanceOverview/DevelopingForPerf/DevelopingForPerf.html%3Fid%3DTP40001410-1.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>