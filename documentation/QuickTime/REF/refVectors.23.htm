<HTML><HEAD><META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter"><script language="JavaScript" src="frametest.js"></script><TITLE> Transfer Mode Types</TITLE></HEAD><BODY BGCOLOR="#ffffff"><!-- start of header --><!--#include virtual="/includes/framesetheader" --><!-- end of header --><!-- path goes here --><!-- QTnavbar start --><P><I>Inside Macintosh: QuickTime Reference</I><P>| <A HREF="refVectors.22.htm">Previous</A> | <A HREF="refVectors.1.htm">Chapter Contents</A> | <A HREF="refVectors.htm">Chapter Top</A> | <A HREF="refVectors.24.htm">Next</A> | <!-- QTnavbar end --><H1 CLASS="H3.Heading3"><A NAME="pgfId=8543"> </A><A NAME="30273"> </A>Transfer Mode Types</H1><P CLASS="T1.Text1"><A NAME="pgfId=8546"> </A><A NAME="marker=8544"> </A>Transfer modes can be specified by type, also called <A NAME="marker=8545"> </A><B CLASS="bold">component mode.</B> Transfer mode types in QuickDraw GX are called component modes because QuickDraw GX allows each color component to have its own transfer mode type. In RGB color space, for example, the red component of the color may be drawn with a different transfer mode type than the blue component.</P><P CLASS="T1.Text1"><A NAME="pgfId=8547"> </A>QuickDraw GX supports several conceptual categories of component modes:</P><UL><LI CLASS="B1.Bullet1"><A NAME="pgfId=8548"> </A>arithmetic</LI><LI CLASS="B1.Bullet1"><A NAME="pgfId=8549"> </A>Boolean</LI><LI CLASS="B1.Bullet1"><A NAME="pgfId=8550"> </A>pseudo-Boolean</LI><LI CLASS="B1.Bullet1"><A NAME="pgfId=8551"> </A>highlight</LI><LI CLASS="B1.Bullet1"><A NAME="pgfId=8552"> </A>alpha-channel</LI></UL><P CLASS="T1.Text1"><A NAME="pgfId=8553"> </A>The characteristics of and most typical uses for the component modes within each category are summarized in the following subsections.</P><P><B>Note</B><BR><A NAME="pgfId=8556"> </A><A NAME="marker=8555"> </A>Even though QuickDraw GX supports 18 different component modes, most applications in most situations need only one, an arithmetic mode called <B CLASS="bold">copy mode.</B> In copy mode, the source color completely replaces the destination color. Copy mode is the default transfer mode in QuickDraw GX; therefore, you need information about other transfer modes only if you want them for special effects. </P><DIV><A NAME="refVec38"></A><!--RM--><H2 CLASS="H4.Heading4"><A NAME="pgfId=8561"> </A><A NAME="40410"> </A>Arithmetic Transfer Modes</H2><P CLASS="T1.Text1"><A NAME="pgfId=8563"> </A><A NAME="marker=8562"> </A>In arithmetic transfer modes, the numerical values of source and destination for a color&nbsp;component are combined arithmetically to determine the result value for that color component. In most color spaces, a color component value can vary from 0 (no intensity) to 0xFFFF (maximum intensity). You can also use the constant <TT CLASS="cv">gxColorValue1</TT> to represent maximum intensity (0xFFFF).</P><P CLASS="T1.Text1"><A NAME="pgfId=8567"> </A><A HREF="refVectors.23.htm#37685" CLASS="XRef">Figure&nbsp;39</A> shows examples of drawing with the arithmetic transfer modes. In each case, the source image (left) combines with the destination image (center) to produce the result image (right). You can think of the images either as two bitmaps, or as two source shapes (cloud and background) that are drawn over two destination shapes (letter and background).</P><P CLASS="T1.Text1"><A NAME="pgfId=8568"> </A>Each example shows how transfer mode affects drawing within a single color component (reflected as shades of gray in the figure, where black equals 0 and white equals 0xFFFF). The constant that specifies the transfer mode type is shown to the right of each example. Note also that two of the arithmetic transfer modes use an <A NAME="marker=8569"> </A><B CLASS="bold">operand,</B> a numerical value that affects the outcome of the transfer-mode operation. </P><P CLASS="Fg.Figure"><A NAME="pgfId=8574"> </A>Figure&nbsp;39 <A NAME="37685"> </A>Arithmetic transfer modes</P><DIV><IMG SRC="INKL-02A.gif"></DIV><P CLASS="T1.Text1"><A NAME="pgfId=8575"> </A>The constants that define transfer mode type are defined in the <TT CLASS="cv">gxComponentModes</TT> enumeration. The arithmetic modes have the following values and meanings:</P><TABLE border=1 cellpadding=2><TR><TH ROWSPAN="1" COLSPAN="1"><P CLASS="MH.ColsHd"><A NAME="pgfId=8578"> </A>Constant</P></TH><TH ROWSPAN="1" COLSPAN="1"><P CLASS="MH.ColsHd"><A NAME="pgfId=8580"> </A>Value</P></TH><TH ROWSPAN="1" COLSPAN="1"><P CLASS="MH.ColsHd"><A NAME="pgfId=8582"> </A>Explanation</P></TH></TR><TR><TD ROWSPAN="1" COLSPAN="1"><P CLASS="MLCv.MLCode"><A NAME="pgfId=8585"> </A><TT CLASS="cv">gxNoMode</TT><A NAME="marker=8584"> </A></P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="MLR.RtAlign"><A NAME="pgfId=8587"> </A>0</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="ML.ColsList"><A NAME="pgfId=8590"> </A><A NAME="marker=8589"> </A>No mode. No transfer occurs. For this component of the color, the destination is left as it was. This mode is useful for suppressing drawing when certain logical conditions are met, or for not drawing one color component while allowing other components to be drawn.</P></TD></TR><TR><TD ROWSPAN="1" COLSPAN="1"><P CLASS="MLCv.MLCode"><A NAME="pgfId=8593"> </A><TT CLASS="cv">gxCopyMode</TT><A NAME="marker=8592"> </A></P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="MLR.RtAlign"><A NAME="pgfId=8595"> </A>1</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="ML.ColsList"><A NAME="pgfId=8598"> </A><A NAME="marker=8597"> </A>Copy mode. The source color component is copied to the destination. The destination component is ignored. This is the most common transfer mode, and is the default for QuickDraw GX.</P></TD></TR><TR><TD ROWSPAN="1" COLSPAN="1"><P CLASS="MLCv.MLCode"><A NAME="pgfId=8601"> </A><TT CLASS="cv">gxAddMode</TT><A NAME="marker=8600"> </A></P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="MLR.RtAlign"><A NAME="pgfId=8603"> </A>2</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="ML.ColsList"><A NAME="pgfId=8606"> </A><A NAME="marker=8605"> </A>Add mode. The source color component is added to the destination component, but the result is not allowed to exceed the maximum value (<TT CLASS="cv">0xFFFF</TT> or <TT CLASS="cv">gxColorValue1</TT>; white in <A HREF="refVectors.23.htm#37685" CLASS="XRef">Figure&nbsp;39</A>).</P></TD></TR><TR><TD ROWSPAN="1" COLSPAN="1"><P CLASS="MLCv.MLCode"><A NAME="pgfId=8612"> </A><TT CLASS="cv">gxBlendMode</TT><A NAME="marker=8611"> </A></P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="MLR.RtAlign"><A NAME="pgfId=8614"> </A>3</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="ML.ColsList"><A NAME="pgfId=8617"> </A><A NAME="marker=8616"> </A>Blend mode. The result is the average of the source <BR>and destination color components, weighted by a ratio specified by the operand component (0.5 in <A HREF="refVectors.23.htm#37685" CLASS="XRef">Figure&nbsp;39</A>). The operand varies from 0 (all destination) to <TT CLASS="cv">0xFFFF</TT> or <TT CLASS="cv">gxColorValue1</TT> (all source), although it is customary to interpret it as varying between <TT CLASS="cv">0</TT> and <TT CLASS="cv">1</TT>. </P></TD></TR><TR><TD ROWSPAN="1" COLSPAN="1"><P CLASS="MLCv.MLCode"><A NAME="pgfId=8623"> </A><TT CLASS="cv">gxMigrateMode</TT><A NAME="marker=8622"> </A></P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="MLR.RtAlign"><A NAME="pgfId=8625"> </A>4</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="ML.ColsList"><A NAME="pgfId=8628"> </A><A NAME="marker=8627"> </A>Migrate mode. The destination color component is moved toward the source component by the value of the step specified in the operand component (0.25, or <TT CLASS="cv">0x4000</TT> in <A HREF="refVectors.23.htm#37685" CLASS="XRef">Figure&nbsp;39</A>). Migrate mode is similar to blend mode, except that the change in destination component is an absolute amount, rather than a proportion of the difference between it and the source component. If the source has a greater color component value than the destination, the migration is positive; if the destination has a greater value than the source, the migration is negative. In either case, the amount of migration cannot be greater than the difference between the destination and the source values.</P></TD></TR><TR><TD ROWSPAN="1" COLSPAN="1"><P CLASS="MLCv.MLCode"><A NAME="pgfId=8634"> </A><TT CLASS="cv">gxMinimumMode</TT><A NAME="marker=8633"> </A></P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="MLR.RtAlign"><A NAME="pgfId=8636"> </A>5</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="ML.ColsList"><A NAME="pgfId=8639"> </A><A NAME="marker=8638"> </A>Minimum mode. The source component replaces the destination component only if the source component has a smaller value. (In <A HREF="refVectors.23.htm#37685" CLASS="XRef">Figure&nbsp;39</A>, drawing occurs only within the area occupied by the cloud.)</P></TD></TR><TR><TD ROWSPAN="1" COLSPAN="1"><P CLASS="MLCv.MLCode"><A NAME="pgfId=8645"> </A><TT CLASS="cv">gxMaximumMode</TT><A NAME="marker=8644"> </A></P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="MLR.RtAlign"><A NAME="pgfId=8647"> </A>6</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="ML.ColsList"><A NAME="pgfId=8650"> </A><A NAME="marker=8649"> </A>Maximum mode. The source component replaces the destination component only if the source component has a larger value. (In <A HREF="refVectors.23.htm#37685" CLASS="XRef">Figure&nbsp;39</A>, drawing occurs only outside of the area occupied by the cloud.)</P></TD></TR></TABLE><P CLASS="T1.Text1"><A NAME="pgfId=8654"> </A>The <TT CLASS="cv">operand</TT> parameter is used by blend mode to specify the ratio of source and destination component. It is used by migrate mode to specify the step size by which the&nbsp;destination component moves toward the source component. <A HREF="refVectors.23.htm#35042" CLASS="XRef">Figure&nbsp;40</A> shows examples of the result of drawing with blend mode, using several different values for the operand.</P><P CLASS="Fg.Figure"><A NAME="pgfId=8664"> </A>Figure&nbsp;40 <A NAME="35042"> </A>Blend <A NAME="marker=8659"> </A>example with <A NAME="marker=8660"> </A>different operand values</P><DIV><IMG SRC="INKL-08.gif"></DIV></DIV><DIV><A NAME="refVec39"></A><!--RM--><H2 CLASS="H4.Heading4"><A NAME="pgfId=8666"> </A><A NAME="33062"> </A>Highlight Transfer Mode</H2><P CLASS="T1.Text1"><A NAME="pgfId=8668"> </A><A NAME="marker=8667"> </A>The highlight transfer mode is used for highlighting in color applications. It is most commonly used to draw (and clear) a colored rectangle around a selection, without altering the color of the item or items selected. In text, it gives the effect of drawing over the letters with a highlighting pen.</P><P CLASS="T1.Text1"><A NAME="pgfId=8669"> </A>Like some of the arithmetic transfer modes, highlight mode uses an operand to control the outcome of the highlighting operation. Highlight mode operates by replacing the source color with the operand color, and the operand color with the source color, in the destination.</P><P CLASS="T1.Text1"><A NAME="pgfId=8673"> </A>The upper row of images in <A HREF="refVectors.23.htm#27630" CLASS="XRef">Figure&nbsp;41</A> shows a simple example of the application of highlight mode. The operand value is represented with shading rather than as a number, to illustrate how its color affects colors in the image. The source shape is a white rectangle that is drawn over the two middle letters in the destination image. (The gray letters in the line of text in the destination image represent the same color-component value as the operand, and the white area around the letters in the destination represents the same color-component value as the source.) </P><P CLASS="Fg.Figure"><A NAME="pgfId=8678"> </A>Figure&nbsp;41 <A NAME="27630"> </A>Highlight transfer mode</P><DIV><IMG SRC="INKL-18.gif"></DIV><P CLASS="T1.Text1"><A NAME="pgfId=8679"> </A>Note that black in the destination is unaffected, whereas white becomes gray and gray becomes white. A single constant specifies highlight mode, with the following value and meaning: </P><TABLE border=1 cellpadding=2><TR><TH ROWSPAN="1" COLSPAN="1"><P CLASS="MH.ColsHd"><A NAME="pgfId=8682"> </A>Constant</P></TH><TH ROWSPAN="1" COLSPAN="1"><P CLASS="MH.ColsHd"><A NAME="pgfId=8684"> </A>Value</P></TH><TH ROWSPAN="1" COLSPAN="1"><P CLASS="MH.ColsHd"><A NAME="pgfId=8686"> </A>Explanation</P></TH></TR><TR><TD ROWSPAN="1" COLSPAN="1"><P CLASS="MLCv.MLCode"><A NAME="pgfId=8689"> </A><TT CLASS="cv">gxHighlightMode</TT><A NAME="marker=8688"> </A></P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="MLR.RtAlign"><A NAME="pgfId=8691"> </A>7</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="ML.ColsList"><A NAME="pgfId=8694"> </A><A NAME="marker=8693"> </A>Highlight mode. The source component and operand component are swapped in the destination. Other components in the destination are ignored. </P></TD></TR></TABLE><P CLASS="T1.Text1"><A NAME="pgfId=8695"> </A>In highlight mode, the source color can be thought of as the &quot;background&quot; color that is to be highlighted, and the operand color is the color of the highlighting pen. As the lower set of images in <A HREF="refVectors.23.htm#27630" CLASS="XRef">Figure&nbsp;41</A> shows, redrawing a highlighted selection causes the source and operand colors to swap once more, effectively removing the highlighting.</P><P CLASS="T1.Text1"><A NAME="pgfId=8699"> </A>The operand for highlight mode is a normal color component value that varies from 0 (no intensity) to the maximum intensity permitted for that component (normally <TT CLASS="cv">0xFFFF</TT>, or <TT CLASS="cv">gxColorValue1</TT>).</P><P CLASS="T1.Text1"><A NAME="pgfId=8700"> </A>QuickDraw GX applies highlight mode only if all components in the color space specify it. An error occurs if some components specify highlight mode and others do not. <A NAME="marker=8701"> </A></P></DIV><DIV><A NAME="refVec40"></A><!--RM--><H2 CLASS="H4.Heading4"><A NAME="pgfId=8702"> </A>Boolean Transfer Modes</H2><P CLASS="T1.Text1"><A NAME="pgfId=8704"> </A><A NAME="marker=8703"> </A>In Boolean transfer modes, the result value for a color component is determined by bit operations performed on the source and destination component values. Boolean transfer modes are most common in black-and-white drawing; in any bit depth other than 1, they yield results that can be difficult to predict because they depend on the states of the individual bits in each color-component value.</P><P CLASS="T1.Text1"><A NAME="pgfId=8708"> </A><A HREF="refVectors.23.htm#24439" CLASS="XRef">Figure&nbsp;42</A> shows examples of drawing with the Boolean transfer modes at a bit depth of&nbsp;1. In each case, the source image combines with the destination image to produce the result image. In these examples, black represents a bit value of 0 (clear), and white represents a bit value of 1 (set). The constant that specifies the transfer mode type is shown to the right of each example.</P><P CLASS="Fg.Figure"><A NAME="pgfId=8713"> </A>Figure&nbsp;42 <A NAME="24439"> </A>Boolean transfer modes (1-bit depth)</P><DIV><IMG SRC="INKL-02C.gif"></DIV><P CLASS="T1.Text1"><A NAME="pgfId=8745"> </A>The Boolean modes have the following values and meanings: </P><TABLE border=1 cellpadding=2><TR><TH ROWSPAN="1" COLSPAN="1"><P CLASS="MH.ColsHd"><A NAME="pgfId=8716"> </A>Constant</P></TH><TH ROWSPAN="1" COLSPAN="1"><P CLASS="MH.ColsHd"><A NAME="pgfId=8718"> </A>Value</P></TH><TH ROWSPAN="1" COLSPAN="1"><P CLASS="MH.ColsHd"><A NAME="pgfId=8720"> </A>Explanation</P></TH></TR><TR><TD ROWSPAN="1" COLSPAN="1"><P CLASS="MLCv.MLCode"><A NAME="pgfId=8723"> </A><TT CLASS="cv">gxAndMode</TT><A NAME="marker=8722"> </A></P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="MLR.RtAlign"><A NAME="pgfId=8725"> </A>8</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="ML.ColsList"><A NAME="pgfId=8728"> </A><A NAME="marker=8727"> </A>AND mode. The bits of the source color and destination color are combined using an AND operation. Only bits that are set in both source and destination remain set in the result.</P></TD></TR><TR><TD ROWSPAN="1" COLSPAN="1"><P CLASS="MLCv.MLCode"><A NAME="pgfId=8731"> </A><TT CLASS="cv">gxOrMode</TT><A NAME="marker=8730"> </A></P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="MLR.RtAlign"><A NAME="pgfId=8733"> </A>9</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="ML.ColsList"><A NAME="pgfId=8736"> </A><A NAME="marker=8735"> </A>OR mode. The bits of the source color and destination color are combined using an OR operation. Bits that are set in either the source or the destination or in both are set in the result.</P></TD></TR><TR><TD ROWSPAN="1" COLSPAN="1"><P CLASS="MLCv.MLCode"><A NAME="pgfId=8739"> </A><TT CLASS="cv">gxXorMode</TT><A NAME="marker=8738"> </A></P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="MLR.RtAlign"><A NAME="pgfId=8741"> </A>10</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="ML.ColsList"><A NAME="pgfId=8744"> </A><A NAME="marker=8743"> </A>XOR mode. The bits of the source color and destination color are combined using an exclusive-OR (XOR) operation. Bits that are set in the source but not the destination, and bits that are set in the destination but not the source, are set in the result. All other bits are cleared in the result.</P></TD></TR></TABLE><P CLASS="T1.Text1"><A NAME="pgfId=8746"> </A>Even though they are most easily explained in terms of single-bit depths, Boolean modes are not restricted to 1-bit drawing. They can be used with any kind of color values. <A NAME="marker=8747"> </A></P></DIV><DIV><A NAME="refVec41"></A><!--RM--><H2 CLASS="H4.Heading4"><A NAME="pgfId=8748"> </A>Pseudo-Boolean Transfer Modes</H2><P CLASS="T1.Text1"><A NAME="pgfId=8750"> </A><A NAME="marker=8749"> </A>In pseudo-Boolean transfer modes, the result value for a color component is determined by normalizing the source and destination values and performing a simple arithmetic operation, to achieve consistent and predictable results analogous to 1-bit Boolean operations.</P><P CLASS="T1.Text1"><A NAME="pgfId=8754"> </A><A HREF="refVectors.23.htm#31090" CLASS="XRef">Figure&nbsp;43</A> shows examples of drawing with the pseudo-Boolean transfer modes. In each case, the source image combines with the destination image to produce the result image. The constant that specifies the transfer mode type is shown to the right of each example.</P><P CLASS="Fg.Figure"><A NAME="pgfId=8759"> </A>Figure&nbsp;43 <A NAME="31090"> </A>Pseudo-Boolean transfer modes</P><DIV><IMG SRC="INKL-02D.gif"></DIV><P CLASS="T1.Text1"><A NAME="pgfId=8760"> </A>The constants for the pseudo-Boolean component modes have the following values and meanings:</P><TABLE border=1 cellpadding=2><TR><TH ROWSPAN="1" COLSPAN="1"><P CLASS="MH.ColsHd"><A NAME="pgfId=8763"> </A>Constant</P></TH><TH ROWSPAN="1" COLSPAN="1"><P CLASS="MH.ColsHd"><A NAME="pgfId=8765"> </A>Value</P></TH><TH ROWSPAN="1" COLSPAN="1"><P CLASS="MH.ColsHd"><A NAME="pgfId=8767"> </A>Explanation</P></TH></TR><TR><TD ROWSPAN="1" COLSPAN="1"><P CLASS="MLCv.MLCode"><A NAME="pgfId=8770"> </A><TT CLASS="cv">gxRampAndMode</TT><A NAME="marker=8769"> </A></P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="MLR.RtAlign"><A NAME="pgfId=8772"> </A>11</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="ML.ColsList"><A NAME="pgfId=8775"> </A><A NAME="marker=8774"> </A>Ramp-AND mode. The source and destination color components are treated as ranging from 0 to 1; their product (source&nbsp;&#165;&nbsp;destination) is returned.</P></TD></TR><TR><TD ROWSPAN="1" COLSPAN="1"><P CLASS="MLCv.MLCode"><A NAME="pgfId=8779"> </A><TT CLASS="cv">gxRampOrMode</TT><A NAME="11308"> </A><A NAME="marker=8778"> </A></P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="MLR.RtAlign"><A NAME="pgfId=8781"> </A>12</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="ML.ColsList"><A NAME="pgfId=8784"> </A><A NAME="marker=8783"> </A>Ramp-OR mode. The source and destination color components are treated as ranging from 0 to 1; the <BR>result of (source&nbsp;+ destination&nbsp;- source&nbsp;&#165;&nbsp; destination) is returned.</P></TD></TR><TR><TD ROWSPAN="1" COLSPAN="1"><P CLASS="MLCv.MLCode"><A NAME="pgfId=8787"> </A><TT CLASS="cv">gxRampXorMode</TT><A NAME="marker=8786"> </A></P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="MLR.RtAlign"><A NAME="pgfId=8789"> </A>13</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="ML.ColsList"><A NAME="pgfId=8792"> </A><A NAME="marker=8791"> </A>Ramp-XOR mode. The source and destination color components are treated as ranging from 0 to 1; the result of (source + destination - 2&nbsp;&#165;&nbsp;source&nbsp;&#165;&nbsp;destination) is returned.</P></TD></TR></TABLE><P CLASS="T1.Text1"><A NAME="pgfId=8793"> </A>Note that the pseudo-Boolean and Boolean modes are similar in several ways:</P><UL><LI CLASS="B1.Bullet1"><A NAME="pgfId=8794"> </A>The mode <TT CLASS="cv">gxRampAndMode</TT> is similar to <TT CLASS="cv">gxAndMode</TT> in that nonzero values occur in the result only where both source and destination are nonzero. </LI><LI CLASS="B1.Bullet1"><A NAME="pgfId=8795"> </A>The mode <TT CLASS="cv">gxRampOrMode</TT> is similar to <TT CLASS="cv">gxOrMode</TT> in that nonzero values occur in the result wherever either the source or the destination is nonzero.</LI><LI CLASS="B1.Bullet1"><A NAME="pgfId=8796"> </A>The mode <TT CLASS="cv">gxRampXorMode</TT> is similar to <TT CLASS="cv">gxXorMode</TT> in that the result is close to zero wherever the source and destination are close to each other in value.</LI></UL><P CLASS="T1.Text1"><A NAME="pgfId=8797"> </A>The difference between the pseudo-Boolean and Boolean modes is that, for multi-bit pixel depths, the results for <TT CLASS="cv">gxRampAndMode</TT>, <TT CLASS="cv">gxRampOrMode</TT>, and <TT CLASS="cv">gxRampXorMode</TT> are predictable and vary smoothly and continuously with component intensity. For 1-bit depths, these modes are identical to their Boolean equivalents.</P><P CLASS="T1.Text1"><A NAME="pgfId=8798"> </A>The pseudo-Boolean modes are commonly used as component modes for alpha channels in color spaces that have an alpha channel. For more information, see <A HREF="refVectors.23.htm#37035" CLASS="XRef">&quot;Alpha-Channel Transfer Modes&quot;</A>. <A NAME="marker=8802"> </A></P></DIV><DIV><A NAME="refVec42"></A><!--RM--><H2 CLASS="H4.Heading4"><A NAME="pgfId=8804"> </A><A NAME="37035"> </A>Alpha-Channel Transfer Modes</H2><P CLASS="T1.Text1"><A NAME="pgfId=8806"> </A><A NAME="marker=8805"> </A>Several QuickDraw GX color spaces (<TT CLASS="cv">gxRGBASpace</TT>, <TT CLASS="cv">gxARGB32Space</TT> and <TT CLASS="cv">gxGrayASpace</TT>) have an <A NAME="marker=8807"> </A><B CLASS="bold">alpha channel.</B> This is an additional color component that controls the opacity or transparency of a color. For example, a red pixel in a source image can be completely opaque, in which case it typically retains its red color when drawn over a blue pixel in the destination image. Or, the pixel can be completely transparent, in which case it typically loses all its color and turns totally blue when drawn over a blue pixel. Or, it can have an opacity of, say, <TT CLASS="cv">0x7FFF</TT> (50%), in which case it typically turns magenta when drawn over a blue pixel.</P><P CLASS="T1.Text1"><A NAME="pgfId=8808"> </A>Alpha channel values can be used to allow parts of one image to show through &quot;holes&quot; in another, to show translucency in objects that are drawn over other objects, and to perform anti-aliasing (smoothing of jagged edges) by giving feathered, semi-transparent borders to opaque objects. </P><P CLASS="T1.Text1"><A NAME="pgfId=8809"> </A>When assigning transfer modes to colors with an alpha channel, you typically use two different kinds of modes:</P><UL><LI CLASS="B1.Bullet1"><A NAME="pgfId=8810"> </A>To get the proper result color for each color component, you use an alpha-channel transfer mode. These modes take alpha-channel values into account when calculating result values for the color components.</LI><LI CLASS="B1.Bullet1"><A NAME="pgfId=8811"> </A>To get the proper result opacity for the alpha channel itself, you typically use an arithmetic or pseudo-Boolean transfer mode.</LI></UL><P CLASS="T1.Text1"><A NAME="pgfId=8812"> </A>This section describes how the different modes within each category work to give you the results you want.</P></DIV><DIV><A NAME="refVec43"></A><!--RM--><H2 CLASS="H4.Heading4"><A NAME="pgfId=8813"> </A>Modes for the Color Components</H2><P CLASS="T1.Text1"><A NAME="pgfId=8817"> </A><A HREF="refVectors.23.htm#38580" CLASS="XRef">Figure&nbsp;44</A> shows examples of how values for a color component might be calculated, given a source image and a destination image consisting of objects (or pixels) that differ in opacity. In each example, the source image (an opaque, light gray cloud against a transparent black background) combines with the destination image (an opaque, dark gray &quot;A&quot; on a transparent black background), to form the result image. The constant that specifies the transfer mode type is shown to the right of each example.</P><P CLASS="T1.Text1"><A NAME="pgfId=8818"> </A>Each example shows how the alpha-channel transfer mode affects drawing within a single color component. The mode takes into account not only the source and destination color components, but the source and destination opacities as well. </P><P CLASS="Fg.Figure"><A NAME="pgfId=8823"> </A>Figure&nbsp;44 <A NAME="38580"> </A>Alpha-channel transfer modes</P><DIV><IMG SRC="INKL-14.gif"></DIV><P CLASS="T1.Text1"><A NAME="pgfId=8824"> </A>The constants for the alpha-channel component modes have the following values and meanings: </P><TABLE border=1 cellpadding=2><TR><TH ROWSPAN="1" COLSPAN="1"><P CLASS="MH.ColsHd"><A NAME="pgfId=8827"> </A>Constant</P></TH><TH ROWSPAN="1" COLSPAN="1"><P CLASS="MH.ColsHd"><A NAME="pgfId=8829"> </A>Value</P></TH><TH ROWSPAN="1" COLSPAN="1"><P CLASS="MH.ColsHd"><A NAME="pgfId=8831"> </A>Explanation</P></TH></TR><TR><TD ROWSPAN="1" COLSPAN="1"><P CLASS="MLCv.MLCode"><A NAME="pgfId=8834"> </A><TT CLASS="cv">gxOverMode</TT><A NAME="marker=8833"> </A></P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="MLR.RtAlign"><A NAME="pgfId=8836"> </A>14</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="ML.ColsList"><A NAME="pgfId=8839"> </A><A NAME="marker=8838"> </A>Over mode. The source color is copied to the destination, and the source transparency controls where the destination color shows through. Where both are transparent, no drawing occurs (result equals destination).</P></TD></TR><TR><TD ROWSPAN="1" COLSPAN="1"><P CLASS="MLCv.MLCode"><A NAME="pgfId=8842"> </A><TT CLASS="cv">gxAtopMode</TT><A NAME="marker=8841"> </A></P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="MLR.RtAlign"><A NAME="pgfId=8844"> </A>15</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="ML.ColsList"><A NAME="pgfId=8847"> </A><A NAME="marker=8846"> </A>Atop mode. The source color is placed over the destination, but the resulting destination retains the original destination's transparency. The effect is that opaque parts of the source are clipped to cover only opaque parts of the destination. </P></TD></TR><TR><TD ROWSPAN="1" COLSPAN="1"><P CLASS="MLCv.MLCode"><A NAME="pgfId=8850"> </A><TT CLASS="cv">gxExcludeMode</TT><A NAME="marker=8849"> </A></P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="MLR.RtAlign"><A NAME="pgfId=8852"> </A>16</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="ML.ColsList"><A NAME="pgfId=8855"> </A><A NAME="marker=8854"> </A>Exclude mode. The destination color remains visible only where the source is transparent, and the source color is copied anywhere the destination is transparent. Where both are transparent, no drawing occurs (result equals destination); where both are opaque, the result color is 0 (no intensity).</P></TD></TR><TR><TD ROWSPAN="1" COLSPAN="1"><P CLASS="MLCv.MLCode"><A NAME="pgfId=8858"> </A><TT CLASS="cv">gxFadeMode</TT><A NAME="marker=8857"> </A></P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="MLR.RtAlign"><A NAME="pgfId=8860"> </A>17</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="ML.ColsList"><A NAME="pgfId=8863"> </A><A NAME="marker=8862"> </A>Fade mode. The source is blended with the destination, using the relative alpha values as the ratio for the blend. Where both are transparent, the result is the average of the source and the destination).</P></TD></TR></TABLE><P CLASS="T1.Text1"><A NAME="pgfId=8867"> </A>As <A HREF="refVectors.23.htm#38580" CLASS="XRef">Figure&nbsp;44</A> shows, the <TT CLASS="cv">gxOverMode</TT> mode is similar to the arithmetic transfer mode <TT CLASS="cv">gxCopyMode</TT>, except that it allows for transparency in the source image. Likewise, the <TT CLASS="cv">gxAtopMode</TT> mode is similar to <TT CLASS="cv">gxCopyMode</TT>, but it preserves the transparency of the destination image by clipping the opaque source to the destination image. The <TT CLASS="cv">gxExcludeMode</TT> mode is somewhat like the Boolean transfer mode <TT CLASS="cv">gxXorMode</TT>, in that opaque parts of each image appear only where the other is not opaque. The <TT CLASS="cv">gxFadeMode</TT> mode is like the arithmetic <TT CLASS="cv">gxBlendMode</TT>, except that the operand that controls the blend ratio is determined by the relative opacities.</P><P CLASS="T1.Text1"><A NAME="pgfId=8871"> </A>Note that the images shown in <A HREF="refVectors.23.htm#38580" CLASS="XRef">Figure&nbsp;44</A> are very simple and their opacities are either 0 (completely transparent) or <TT CLASS="cv">gxColorValue1</TT> (completely opaque). Because an alpha component can have a wide range of partial opacities, very sophisticated translucency and color-blending effects are possible, as well as the simple masking effects shown here.</P><P CLASS="T1.Text1"><A NAME="pgfId=8872"> </A>The exact formulas for determining result color are the following. In these formulas, <TT CLASS="cv">sA</TT> = source alpha-channel value; <TT CLASS="cv">dA</TT> = destination alpha-channel value; <TT CLASS="cv">sC</TT> = source color-component value; <TT CLASS="cv">dC</TT> = destination color-component value; and <TT CLASS="cv">rC</TT> = result color-component value. </P><UL><LI CLASS="B1.Bullet1"><A NAME="pgfId=8873"> </A> <P>For <TT CLASS="cv">gxOverMode</TT>:<BR><CODE CLASS="TuCv.TutCode"><A NAME="pgfId=43538"> </A>rC = (sA x (sC - dA x dC) + dA x dC) / (sA + dA - sA x dA)<BR></CODE></li><P><LI CLASS="B1.Bullet1"><A NAME="pgfId=8875"> </A>For <TT CLASS="cv">gxAtopMode</TT>:<BR><CODE CLASS="TuCv.TutCode"><A NAME="pgfId=43542"> </A>rC = dC + sA x (sC - dC)<BR></CODE></li><P><LI CLASS="B1.Bullet1"><A NAME="pgfId=8877"> </A>For <TT CLASS="cv">gxExcludeMode</TT>:<BR><CODE CLASS="TuCv.TutCode"><A NAME="pgfId=43546"> </A>rC =&nbsp;&nbsp;&nbsp;&nbsp;(sA x sC + dA x dC- sA x dA x (sC + dC)) / <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sA + dA - sA x dA)<BR></CODE></li><P><LI CLASS="B1.Bullet1"><A NAME="pgfId=8879"> </A>For <TT CLASS="cv">gxFadeMode</TT>:<BR><CODE CLASS="TuCv.TutCode"><A NAME="pgfId=43550"> </A>rC = sA x sC + dA x dC / (sA + dA) <BR></CODE></UL></DIV><DIV><A NAME="refVec44"></A><!--RM--><H2 CLASS="H4.Heading4"><A NAME="pgfId=8881"> </A>Modes for the Alpha Channel</H2><P CLASS="T1.Text1"><A NAME="pgfId=8882"> </A>For calculating the result value for the alpha channel itself, you typically use one of the arithmetic or pseudo-Boolean transfer modes presented in the previous sections--one that takes into account only the source and destination opacities. <A HREF="refVectors.23.htm#31211" CLASS="XRef">Figure&nbsp;45</A> shows typical modes used and their effects on opacity, using the same images is those presented in <A HREF="refVectors.23.htm#38580" CLASS="XRef">Figure&nbsp;44</A>. In this figure, black represents complete transparency and white represents complete opacity. (If alpha-channel values between the two extremes existed in these examples, they would be shown in shades of gray.)</P><P CLASS="Fg.Figure"><A NAME="pgfId=8893"> </A>Figure&nbsp;45 <A NAME="31211"> </A>Typical modes used to determine result opacity for the alpha channel</P><DIV><IMG SRC="INKL-15.gif"></DIV><P CLASS="T1.Text1"><A NAME="pgfId=8897"> </A>Note from <A HREF="refVectors.23.htm#31211" CLASS="XRef">Figure&nbsp;45</A> that the mode you use to determine the result opacity of the alpha channel usually depends on what alpha-channel mode you use to get color-component values:</P><UL><LI CLASS="B1.Bullet1"><A NAME="pgfId=8899"> </A><A NAME="marker=8898"> </A>Use <TT CLASS="cv">gxRampOrMode</TT> to calculate result alpha-channel values if you want the opacities of both source and destination summed proportionally (in a pseudo-Boolean manner; see the description of <TT CLASS="cv">gxRampOrMode</TT> to achieve a result opacity. Thus, if you use <TT CLASS="cv">gxOverMode</TT> for the color-components, you would typically use <TT CLASS="cv">gxRampOrMode</TT> for the alpha channel.</LI><LI CLASS="B1.Bullet1"><A NAME="pgfId=8904"> </A><A NAME="marker=8903"> </A>Use <TT CLASS="cv">gxNoMode</TT> to calculate result alpha-channel values if you want the opacity of the destination to remain unchanged. Thus, if you use <TT CLASS="cv">gxAtopMode</TT> for the color-components, you would typically use <TT CLASS="cv">gxNoMode</TT> for the alpha channel.</LI><LI CLASS="B1.Bullet1"><A NAME="pgfId=8906"> </A><A NAME="marker=8905"> </A>Use <TT CLASS="cv">gxRampXorMode</TT> to calculate result alpha-channel values if you want a maximum result opacity where there is a maximum difference in opacities between source and destination. Thus, if you use <TT CLASS="cv">gxExcludeMode</TT> for the color-components, you would typically use <TT CLASS="cv">gxRampXorMode</TT> for the alpha channel.</LI><LI CLASS="B1.Bullet1"><A NAME="pgfId=8908"> </A><A NAME="marker=8907"> </A>Use <TT CLASS="cv">gxAddMode</TT> to calculate result alpha-channel values if you want the result opacity to reflect the sum of the opacities of the source and destination (pinned to the maximum permitted value). Thus, if you use <TT CLASS="cv">gxFadeMode</TT> for the color-components, you would typically use <TT CLASS="cv">gxAddMode</TT> for the alpha channel.</LI></UL><P><B>Note</B><BR><A NAME="pgfId=8909"> </A>When converting a color from a color space that does not have an alpha channel to one that does, QuickDraw GX sets the alpha channel intensity to maximum (opaque). When a color is converted from a color space that does have an alpha channel to one that does not, the alpha channel is lost. </P></DIV><DIV><A NAME="refVec45"></A><!--RM--><H2 CLASS="H4.Heading4"><A NAME="pgfId=8913"> </A>Transparency Ramps and Anti-Aliasing</H2><P CLASS="T1.Text1"><A NAME="pgfId=8914"> </A>Two common applications for alpha-channel colors involve making objects or images partially opaque to give a translucent effect, and smoothing jagged edges on objects drawn at low resolution.</P><P CLASS="T1.Text1"><A NAME="pgfId=8915"> </A>You can create a bitmap in which the alpha-channel values of the pixels vary smoothly in one or more directions, thus creating a transparency ramp that allows the destination image to show through the source image to varying degrees across the bitmap. Color Plate 2 at the front of this book, for example, shows the kind of effect that can be achieved with a simple alpha-channel ramp.</P><P CLASS="T1.Text1"><A NAME="pgfId=8917"> </A><A NAME="marker=8916"> </A>The smoothing of jagged edges on displayed objects is called <B CLASS="bold">anti-aliasing.</B> You can perform anti-aliasing by modifying the alpha-channel values of the pixels surrounding the edges of an opaque object. You make an individual pixel more or less opaque, based on the proportion of that pixel that the object is computed to cover. </P><P CLASS="T1.Text1"><A NAME="pgfId=8921"> </A>In <A HREF="refVectors.23.htm#20531" CLASS="XRef">Figure&nbsp;46</A>, for example, the left image shows the computed position of the edge of a shape in a bitmap. The center image shows how that edge is displayed normally, given the resolution of the bitmap. The right image shows that edge as it might be displayed with anti-aliasing applied. The apparent jaggedness is decreased because pixels near the edge allow the background to show through to varying degrees.</P><P CLASS="Fg.Figure"><A NAME="pgfId=8929"> </A>Figure&nbsp;46 <A NAME="20531"> </A>Anti-<A NAME="marker=8923"> </A>ali<A NAME="marker=8924"></A>as<A NAME="marker=8925"></A>ing</P><DIV><IMG SRC="INKL-16.gif"></DIV></DIV><hr>&#169; 1999 Apple Computer, Inc.<!-- QTnavbar start --><P><I>Inside Macintosh: QuickTime Reference</I><P>| <A HREF="refVectors.22.htm">Previous</A> | <A HREF="refVectors.1.htm">Chapter Contents</A> | <A HREF="refVectors.htm">Chapter Top</A> | <A HREF="refVectors.24.htm">Next</A> | <!-- QTnavbar end --></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV><!-- start of footer --><!--#include virtual="/includes/framesetfooter" --><!-- end of footer --></BODY></HTML>