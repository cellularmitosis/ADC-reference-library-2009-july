<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><head><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css">   <title>Technical Note TN1196: Cursor Components</title>       <meta name="keywords" content="Cursor, Big Cursor, Color Cursor, Flicker">    <meta name="Description" content="Technical Note TN1196: Describes the building and use ofcursor components.  Cursor components allow you to buildcustom color cursor completely under your control. For example,they could extra large, thousands or  millions of colors,transparent, situationally intelligent, and/or  animated."><meta name="categories" content="QuickDraw and Human Interface Toolbox"><meta name="week-posted" content="Mar 27, 2000 - Apr 7, 2000"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10003035" title="Cursor Components"></a><A NAME="top"></A><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/Carbon/idxHumanInterfaceToolbox-date.html" target="_blank">Carbon > Human Interface Toolbox</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1196</div>
<div id="pageheadsub">Cursor Components</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"> <!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">     <tr><td width=300 valign="top" align=left scope="row">    <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td></tr><tr bgcolor="#e6e6e6">   <td background="images/tnmenubody.gif" width=300 align=left>       <span id="menutitle">CONTENTS   <br>  <br>       </span>   </td></tr><tr bgcolor="#e6e6e6">   <td background="images/tnmenubody.gif" width=300 align=left>       <!-- begin_toc -->         <P id="menutext">         <A HREF = "#Section1">Prerequisites and Resources</A><BR><BR>                  <A HREF = "#Section2">Limitations</A><BR><BR>                  <A HREF = "#Section3">Building Components</A></p>          <P id = "Menutext2">             <A HREF = "#Section3.1">CursorInitialize</A><BR>             <A HREF = "#Section3.2">GetCursorInfo</A><BR>             <A HREF = "#Section3.3">SetCursorData</A><BR>             <A HREF = "#Section3.4">CursorReconfigure</A><BR>             <A HREF = "#Section3.5">CursorDraw</A><BR>             <A HREF = "#Section3.6">CursorErase</A><BR>             <A HREF = "#Section3.7">CursorMove</A><BR>             <A HREF = "#Section3.8">CursorAnimate</A><BR>             <A HREF = "#Section3.9">Resources</A></p>         <P id="menutext">         <A HREF = "#Section4">Using Components</A></p>           <P id="menutext2">             <A HREF = "#Section4.1">Registering Components</A><BR>         <A HREF = "#Summary">Summary</A><BR><BR><A HREF = "#References">References</A><BR><BR>         <A HREF = "#Downloads">Downloadables</a></p>       </td></tr><tr>   <td width=300 align=left scope="row">       <img src="images/tnmenubottom.gif" alt="" width=300 height=16>   </td></tr>    </table></td><td width=300 valign="top" align=left><!-- begin_intro_text -->             <A HREF = "#Section4.2">Opening the Cursor</A><BR>             <A HREF = "#Section4.3">Setting the Cursor</A><BR>             <A HREF = "#Section4.4">Closing the Cursor</A><BR>             <A HREF = "#Section4.5">Modifying the Cursor</A><BR>             <A HREF = "#Section4.6">Miscellaneous</A></p>         <P id="menutext">         <A HREF = "#Section5">Fighting Flicker</A><BR><BR><P id ="introtext">This Technote describes the building and use of cursor components.  Cursor components allow you to build custom color cursors completely under your control. Unlike previous color cursors on the Macintosh, these components allow much more flexibility.</p><P id ="introtext">Cursors created utilizing this component are pretty unlimited.  They could be extra large, thousands or millions of colors, transparent, situationally intelligent, and/or animated.  The design is constrained only by your imagination.</P>          <P id ="introtext">Cursor components are built in two parts.  The main part is the component itself, which can be built by expanding on the sample code sections provided in this Technote.  The second part is the application that instantiates and controls the cursor.  The second half of this technote will provide guidance on ways to do this. The last section of this technote will address cursor flicker and present a solution to the problem.</p><!-- end_intro_text --><!-- begin_date --><h3>&nbsp;Updated: [Apr 17 2000]</h3><!-- end_date --></TD>     </TR>  </TABLE> <!-- end_header_box --><BR><BR><hr width=500 align=center><BR><BR><!-- begin_content --><A NAME="Section1"></A><H2>Prerequisites and Resources</H2>         <P>The <a href="http://developer.apple.com/sdk/index.html">Cursor Component SDK</A> provides a sample application from which most of this Technotes code samples are taken.  You should study this application and its cursor components carefully.  These are very good starting points.</P><P>When building an application, there will be two parts (at least): the application itself and the cursor component(s).  The simplest way to put together the components is as code resources.  To this end, the SDK sample projects provide a good starting point.  (Duplicating the cursor component projects and working from there would seem to be the simplest approach.) The application is much simpler.  A short study of the cursor code shows that it is very portable, and can be worked into almost any existing application.</P><P>Developers will need <a href="http://developer.apple.com/sdk/index.html">Universal Interfaces 3.3</A> to develop cursor components.  This is due to new functionality that has been added to QuickDraw headers and interfaces to support cursor components.        </P><P>One last note: cursor components are available only with Mac OS 9.0 and later; therefore, you should always have a fallback if you plan deployment on systems prior to Mac OS 9.0.  Additionally, currently cursor components are not supported under Mac OS X and Carbon.  This may change in the future, and this Note will be updated as necessary.</P><p><A HREF = "#top">Back to top</a></p><BR>         <H2>Limitations</H2>         <P>Currently, on Mac OS 9, Cursor Components have a few limitations.  Due to ATI RAGE 128 video hardware architecture the cursor can exhibit flicker.  This flicker varies with different monitor settings and from system to system.  See the <A HREF = "#Section5">Fighting Flicker</A> for more information of preventing this problem.</p>          <P>Additionally, Cursor Components do not function with PowerBooks due to adverse interactions with the "mouse trails" feature.  There is no workaround, although this may be fixed in the future.</p> <P>Finally, all cursor drawing and erasing happens at interrupt time.  (This will be discussed later in this Technote.) Thus, you should use particular care in designing the drawing and erasing portion of the component, relying only  on interrupt-safe functions for these sections.  The <A HREF = "tn1104.html">Interrupt-Safe Routines Technote</A> is a good source for this information.</p><p><A HREF = "#top">Back to top</a></p><BR><A NAME="Section3"></A>         <H2>Building Components</H2>         <P>The component is built as a code resource.  The main parts are the actual cursor code file and the resource data.  In most cases, image data is stored in the resource, while behavior is defined by the code file.</P>         <P>The cursor component API consists two basic sections.  The first section, the component manager, can be adopted straight from the code below and provides one main and four basic functions.  This section handles the main function, dispatching, opening and closing the component, and responding to version information requests.   The code provided will suit most needs.  Be sure to look at the allocation of the <CODE>CursorGlobalsRecord</CODE>.  It should be adapted to the specific needs of your cursor component.  Normally, you can keep the standard return of <CODE>TRUE</CODE> for all the cases in the <CODE>ComponentCanDo</CODE> functions, but if you do not support all cases you should return <CODE>FALSE</CODE> for those that you do not.  An example implementation of the component manager section is shown below.  As stated previously, this section is fairly straightforward and the code below can be utilized with very little modification.</P>            <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>struct CursorGlobalsRecord{    ComponentInstance       self;    Rect                    bounds;    Point                   hotSpot;    UInt32                  animIndex;    UInt32                  deviceCount;    CursorDeviceRecord      deviceList[12]; // fixed 12 displays max};typedef struct CursorGlobalsRecord      CursorGlobalsRecord;typedef CursorGlobalsRecord *           CursorGlobalsPtr;typedef CursorGlobalsPtr *              CursorGlobalsHnd;// -------------------------------------------------------------------// Routine descriptorsRoutineDescriptor   ComponentCanDoRD =    BUILD_ROUTINE_DESCRIPTOR (uppCallComponentCanDoProcInfo,                              (ProcPtr)ComponentCanDo);RoutineDescriptor   ComponentGetVersionRD =    BUILD_ROUTINE_DESCRIPTOR (uppCallComponentVersionProcInfo,                              (ProcPtr)ComponentGetVersion);// Describe the main entryRoutineDescriptor   mainRD =    BUILD_ROUTINE_DESCRIPTOR (uppComponentRoutineProcInfo, main);pascal ComponentResultmain(ComponentParameters *params,char **storage){    ComponentResult result = noErr;    // If the selector is less than zero, it's a Component manager selector.    if (params-&#62;what &#60; 0)    {        switch (params-&#62;what)        {            case kComponentOpenSelect:                return CallWithStoragePI(storage,                                         params,                                         ComponentOpen,                                         uppCallComponentOpenProcInfo);            case kComponentCloseSelect:                return CallWithStoragePI(storage,                                         params,                                         ComponentClose,                                         uppCallComponentCloseProcInfo);            case kComponentCanDoSelect:                return CallComponentFunction(params,                                             &#38;ComponentCanDoRD);            case kComponentVersionSelect:                return CallComponentFunction(params,                                             &#38;ComponentGetVersionRD);            default:                return noErr;        }    }    switch (params-&#62;what)    {        case kCursorComponentInit:            return CallWithStoragePI(storage,                                     params,                                     CursorInitialize,                                     uppCursorInitProcInfo);        case kCursorComponentGetInfo:            return CallWithStoragePI(storage,                                     params,                                     GetCursorInfo,                                     uppGetCursorInfoProcInfo);        case kCursorComponentSetData:            return CallWithStoragePI(storage,                                     params,                                     SetCursorData,                                     uppSetCursorDataProcInfo);        case kCursorComponentReconfigure:            return CallWithStoragePI(storage,                                     params,                                     CursorReconfigure,                                     uppCursorReconfigureProcInfo);        case kCursorComponentDraw:            return CallWithStoragePI(storage,                                     params,                                     CursorDraw,                                     uppCursorDrawProcInfo);        case kCursorComponentErase:            return CallWithStoragePI(storage,                                     params,                                     CursorErase,                                     uppCursorEraseProcInfo);        case kCursorComponentMove:            return CallWithStoragePI(storage,                                     params,                                     CursorMove,                                     uppCursorMoveProcInfo);        case kCursorComponentAnimate:            return CallWithStoragePI(storage,                                     params,                                     CursorAnimate,                                                uppCursorAnimateProcInfo);        default:            result = unimpErr;            break;    }    return result;}pascal ComponentResultComponentOpen(CursorGlobalsHnd storage, ComponentInstance self){#pragma unused (storage)    ComponentResult result = noErr;    storage =        (CursorGlobalsHnd)NewHandleClear(sizeof(CursorGlobalsRecord));    if (storage != nil )    {        SetComponentInstanceStorage(self, (Handle)storage);        // keep an instance of ourself        (*storage)-&#62;self = self;    }    else        result = MemError();    return result;}pascal ComponentResultComponentClose(CursorGlobalsHnd storage, ComponentInstance self){    if (storage != nil)    {        DisposeDeviceRecords(storage);        DisposeHandle((Handle)storage);    }    return(noErr);}pascal ComponentResultComponentCanDo(short selector){    switch (selector)    {        case kComponentOpenSelect:        case kComponentCloseSelect:        case kComponentCanDoSelect:        case kComponentVersionSelect:        case kCursorComponentInit:        case kCursorComponentGetInfo:        case kCursorComponentSetData:        case kCursorComponentReconfigure:        case kCursorComponentDraw:        case kCursorComponentErase:        case kCursorComponentMove:            return true;        default:            return false;    }}/* Version information */#define CURSOR_COMPONENT_REV       1#define kCursorComponentVersion    1pascal ComponentResultComponentGetVersion(void){    // Cursor Component interface version in hi word,    // code rev in lo word    return ((kCursorComponentVersion &#60;&#60; 16) | CURSOR_COMPONENT_REV);}</pre></TD></TR></TABLE></CENTER><BR><BR> <P>The second section of the component is the cursor component functions.  This consists of eight basic functions that handle the main processing, drawing and erasing of your cursor.  We will cover each functional area in detail, but you are advised to look closely at the examples provided for basic structure and functionality.</p>         <A NAME="Section3.1"></A>         <H3>CursorInitialize</H3>         <P>This function should create a cursor image, mask and save under buffers, and other info for each device.  It will be called once when the component is opened and again when display devices are reconfigured or removed.  The function <CODE>CreateDeviceRecords</CODE>, included in the sample and shown below, shows an example of handling the tasks of creating the image, mask and save under buffers for each device.  This is important since cursors can span multiple devices, and devices can have different color depths resulting in different buffer pixel formats.  If the buffers are successfully allocated, <CODE>CreateDeviceRecords</CODE> calls back to <CODE>SetCursorData</CODE> to set up the new cursors.  Notice also the call to <CODE>InitializeCursorFlush</CODE>.  This is designed to correct a flicker condition that may occur in some system configurations.  See the <A HREF = "#Section5">Fighting Flicker</A> for more information.  Below is an example of a basic implementation of <CODE>CursorInitialize</CODE> and <CODE>CreateDeviceRecords</CODE>.</p>            <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>pascal ComponentResultCursorInitialize(CursorGlobalsHnd storage){    ComponentResult result;    Rect            theRect = {0, 0, 16, 16};    Point           hotSpot = {0, 0};    if (storage != nil)    {        result = InitializeCursorFlush();        if (result == noErr)        {            (*storage)-&#62;bounds          = theRect;            (*storage)-&#62;hotSpot         = hotSpot;            (*storage)-&#62;deviceCount     = 0;            result = CreateDeviceRecords(storage);        }    }    return result;}static OSErrCreateDeviceRecords(CursorGlobalsHnd cursorGlobals){    OSErr               err;    GDHandle            theDevice;    GWorldPtr           theWorld;    PrivateCursorData   data;    UInt32              counter;    SInt16              depth;    Rect                bounds;    short               index;    bounds = (*cursorGlobals)-&#62;bounds;    // start with the first device    theDevice = DMGetFirstScreenDevice(true);    while (theDevice != nil)    {        counter = (*cursorGlobals)-&#62;deviceCount;        depth = (*(*theDevice)-&#62;gdPMap)-&#62;pixelSize;        (*cursorGlobals)-&#62;deviceList[counter].device = nil;        (*cursorGlobals)-&#62;deviceList[counter].saveUnder = nil;        for (index = 0; index &#60; kNumberOfAnimations; index++)        {            (*cursorGlobals)-&#62;deviceList[counter].cursorImage[index] = nil;            // create GWorlds to hold images of cursor expanded to the bitdepth            // of this device            err = CreateImageWorld(&#38;theWorld, depth, &#38;bounds, theDevice);            if (err == noErr)               (*cursorGlobals)-&#62;deviceList[counter].cursorImage[index]=                    theWorld;        }        if (err == noErr)        {            // create a GWorld to hold mask            err = CreateImageWorld(&#38;theWorld, depth, &#38;bounds, theDevice);            if (err == noErr &#38;&#38; theWorld != nil)            {                (*cursorGlobals)-&#62;deviceList[counter].maskImage = theWorld;                // create a GWorld to hold saved screen image                err = CreateImageWorld(&#38;theWorld, depth, &#38;bounds, theDevice);                if (err == noErr &#38;&#38; theWorld != nil)                {                    (*cursorGlobals)-&#62;deviceList[counter].saveUnder = theWorld;                    (*cursorGlobals)-&#62;deviceList[counter].device = theDevice;                    // increment number of instances counter                    (*cursorGlobals)-&#62;deviceCount++;                }            }        }        theDevice = DMGetNextScreenDevice(theDevice, true);    }    if (err != noErr)    {        for (index = 0; index &#60; kNumberOfAnimations; index++)        {            if ((*cursorGlobals)-&#62;deviceList[counter].cursorImage[index] != nil)                DisposeGWorld                    ((*cursorGlobals)-&#62;deviceList[counter].cursorImage[index]);        }        if ((*cursorGlobals)-&#62;deviceList[counter].maskImage != nil)            DisposeGWorld((*cursorGlobals)-&#62;deviceList[counter].maskImage);        if ((*cursorGlobals)-&#62;deviceList[counter].saveUnder != nil)            DisposeGWorld((*cursorGlobals)-&#62;deviceList[counter].saveUnder);    }    else    {        // fill out the cursor data        err = SetCursorData(cursorGlobals, &#38;data);    }    return err;}</pre></TD></TR></TABLE></CENTER><BR><BR><BR><A NAME="Section3.2"></A>         <H3>GetCursorInfo</H3><P>This function fills out the <CODE>CursorInfo</CODE> structure passed in.  The structure pointer should be checked for validity and filled with the appropriate information.  The version will be <CODE>kCursorComponentsVersion</CODE>.  The capabilities field can either be 0 for minimal capabilities or <CODE>cursorDoesAnimate</CODE> to indicate that the cursor will be animating (i.e., changing image data on per-frame basis).  <CODE>animateDuration</CODE> should be set to the number of ticks between frames.  At this time only constant-rate animation is supported (i.e., each frame has the same duration).  The last two fields, <CODE>bounds</CODE> and <CODE>hotspot</CODE>, should be appropriate for the cursor and must be zero based.  Remember that you will be drawing the entire bounds at interrupt time.  Cursors that are too large will cause slow overall machine performance while they are displayed.  An example of <CODE>GetCursorInfo</CODE> is shown below.</p>            <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>pascal ComponentResultGetCursorInfo(CursorGlobalsHnd storage, CursorInfo *info){    OSErr       err = noErr;    if (info != nil)    {        info-&#62;version               = kCursorComponentsVersion;        // use zero for minimal capabilities        info-&#62;capabilities          = cursorDoesAnimate        // number of ticks between animations (zero for none)        info-&#62;animateDuration       = 15;        info-&#62;bounds                = (*storage)-&#62;bounds;        info-&#62;hotspot               = (*storage)-&#62;hotSpot;    }    else        err = paramErr;    return err;}</pre></TD></TR></TABLE></CENTER><BR><BR><A NAME="Section3.3"></A>         <H3>SetCursorData</H3>         <P>This function enables an application to pass data to the cursor component.  The first parameter is a handle to the <CODE>CursorGlobalsRecord</CODE>.  The second parameter is a pointer to private data that is passed in by the application.  This function's implementation can range from nothing to as complex as needed.  The following example implementation shows using <CODE>SetCursorData</CODE> to change the cursor image via pictures from a resource file.</p>            <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>pascal ComponentResultSetCursorData(CursorGlobalsHnd storage, PrivateCursorPtr data){    ComponentResult     result = -1;    PicHandle           cursorPict;    PicHandle           maskPict;    GWorldPtr           imageWorld;    GWorldPtr           oldPort;    GDHandle            oldGD;    Rect                theRect;    short               resFile;    short               c;    short               index;    // hide the cursor since we are going to change it    HideCursor();    // wack the values to those known by cursor so demo app works    data-&#62;pictureID = kCursorPictureID;    data-&#62;hotSpot.h = (short)(((*storage)-&#62;bounds.right -                            (*storage)-&#62;bounds.left) / 2);    data-&#62;hotSpot.v = (short)(((*storage)-&#62;bounds.bottom -                            (*storage)-&#62;bounds.top) / 2);    resFile = OpenComponentResFile((Component)(*storage)-&#62;self);    if (resFile != -1)    {        cursorPict = GetPicture((short)data-&#62;pictureID);        maskPict = GetPicture((short)(data-&#62;pictureID + kNumberOfAnimations));        if (cursorPict != nil &#38;&#38; maskPict != nil)        {            theRect = (*storage)-&#62;bounds;            GetGWorld(&#38;oldPort, &#38;oldGD);            for (c = 0; c &#60; (*storage)-&#62;deviceCount; c++)            {                for (index = 0; index &#60; kNumberOfAnimations; index++)                {                    imageWorld = (*storage)-&#62;deviceList[c].cursorImage[index];                    cursorPict = GetPicture((short)(data-&#62;pictureID + index));                    if (imageWorld != nil &#38;&#38; cursorPict != nil)                    {                        SetGWorld(imageWorld, nil);                        DrawPicture(cursorPict, &#38;theRect);                    }                }                imageWorld = (*storage)-&#62;deviceList[c].maskImage;                if (imageWorld != nil)                {                    SetGWorld(imageWorld, nil);                    DrawPicture(maskPict, &#38;theRect);                }            }            SetPort((GrafPtr)oldPort);            SetGDevice(oldGD);            (*storage)-&#62;hotSpot = data-&#62;hotSpot;            // Now tell Quickdraw we changed            result = CursorComponentChanged((*storage)-&#62;self);        }        CloseComponentResFile(resFile);    }    // show the new cursor    ShowCursor();    return result;}</pre></TD></TR></TABLE></CENTER><BR><BR><A NAME="Section3.4"></A>         <H3>CursorReconfigure</H3>         <P>This function is called when the graphics environment has changed.  The component should now rebuild its cursors (if required) to correspond to the new environment. A simple example implementation is below. This example calls <CODE>DisposeDeviceRecords</CODE>, also shown below, which is the de-allocation function for <CODE>CreateDeviceRecords</CODE> (shown above).</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>pascal ComponentResultCursorReconfigure(CursorGlobalsHnd storage){    ComponentResult     result;    if (storage != nil)    {        // dispose of old device records if they exist        if ((*storage)-&#62;deviceCount &#62; 0)            DisposeDeviceRecords(storage);        result = CreateDeviceRecords(storage);    }    return result;}static voidDisposeDeviceRecords(CursorGlobalsHnd cursorGlobals){    SInt16          index;    SInt16          cursorIndex;    for (index = 0; index &#60; (*cursorGlobals)-&#62;deviceCount; index++)    {        (*cursorGlobals)-&#62;deviceList[index].device = nil;        for (cursorIndex = 0; cursorIndex &#60; kNumberOfAnimations; cursorIndex++)        {        if ((*cursorGlobals)-&#62;deviceList[index].cursorImage[cursorIndex] != nil)                DisposeGWorld                    ((*cursorGlobals)-&#62;deviceList[index].cursorImage[cursorIndex]);        }        if ((*cursorGlobals)-&#62;deviceList[index].saveUnder != nil)        {            DisposeGWorld((*cursorGlobals)-&#62;deviceList[index].saveUnder);            (*cursorGlobals)-&#62;deviceList[index].saveUnder = nil;        }    }    (*cursorGlobals)-&#62;deviceCount = 0;}</pre></TD></TR></TABLE></CENTER><BR><BR><A NAME="Section3.5"></A><H3>CursorDraw</H3>         <P>This is the core of the cursor component, and it will be called every time the cursor is drawn for every display that the cursor spans.  Additionally, since cursors are drawn at interrupt time, this function must not move memory (call Memory Manager routines).  The first parameter, as usual, is a handle to <CODE>CursorGlobalsRecord</CODE>.  Following this is a <CODE>GDHandle</CODE> for the <CODE>GDevice</CODE> on which to draw the cursor.  The component should use this information to find the correct cursor images to draw.  This is handled in the example by the <CODE>FindDeviceRecordIndex</CODE> function.  This function, like the others in this example, works together with <CODE>FindDeviceRecordIndex</CODE> locating the specific index that corresponds to the cursor image data for the device passed in.  The component developer is free to implement this functionality any way you prefer.  The last parameter is the point at which to draw the cursor (in locate coordinates).  This can be negative if the origin of the cursor is on an adjacent display.</p><P>Once the cursor data is found and you have the display and point, the cursor needs to be drawn.  It is key to note that this entire drawing sequence occurs at interrupt time; it should be quick and use only interrupt-safe routines.  Additionally, the plotted cursor must be clipped to the appropriate device.  Lastly, the plotting code absolutely must save the data underneath the cursor image prior to plotting the new one.  This can be done all at once, or pixel-by-pixel, as shown in the example.  <CODE>PlotMaskedImageWithSave</CODE> is shown below as an example of how to plot and save the cursor data.  The last call in this routine, <CODE>CursorFlush</CODE>, is required to previously mentioned flicker condition that can occur in cursor components.  See the <A HREF = "#Section5">Fighting Flicker</A> section for a full explanation.</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>pascal ComponentResultCursorDraw(CursorGlobalsHnd storage, GDHandle device, Point *position){    SInt16      index;    index = FindDeviceRecordIndex(storage, device);    if (index != -1)    {        PlotMaskedImageWithSave (device, *position,            (*storage)-&#62;deviceList[index].cursorImage                [(*storage)-&#62;animIndex]-&#62;portPixMap,            (*storage)-&#62;deviceList[index].maskImage-&#62;portPixMap,            (*storage)-&#62;deviceList[index].saveUnder-&#62;portPixMap);    }    return noErr;}static SInt16FindDeviceRecordIndex(CursorGlobalsHnd cursorGlobals, GDHandle findDevice){    UInt16          index;    for (index = 0; index &#60; (*cursorGlobals)-&#62;deviceCount; index++)    {        if ((*cursorGlobals)-&#62;deviceList[index].device == findDevice)            return index;    }    // didn't find device    return -1;}static voidPlotMaskedImageWithSave(GDHandle device, Point mouse, PixMapHandle srcPix,          PixMapHandle mskPix, PixMapHandle savePix){    Rect            theRect;    UInt32          h;    UInt32          v;    UInt32          srcHStart;    UInt32          srcVStart;    UInt32          offRowBytes;    UInt32          dstRowBytes;    SInt32          srcHeight;    SInt32          srcWidth;    UInt32          deviceHeight;    UInt32          deviceWidth;    UInt32          offOffset;    SInt32          xOffset;    SInt32          yOffset;    UInt16          depth;    Ptr             srcBase;    Ptr             mskBase;    Ptr             dstBase;    Ptr             saveBase;    Ptr             srcData;    Ptr             mskData;    Ptr             dstData;    Ptr             saveData;    // get base of src, msk, and save    srcBase = (*srcPix)-&#62;baseAddr;    mskBase = (*mskPix)-&#62;baseAddr;    saveBase = (*savePix)-&#62;baseAddr;    offRowBytes = (*srcPix)-&#62;rowBytes &#38; 0x7FFF;    // get base and rowbytes of destination    dstBase = (*(*device)-&#62;gdPMap)-&#62;baseAddr;    dstRowBytes = (*(*device)-&#62;gdPMap)-&#62;rowBytes &#38; 0x7FFF;    depth = (*(*device)-&#62;gdPMap)-&#62;pixelSize;    theRect = (*device)-&#62;gdRect;    deviceWidth = theRect.right - theRect.left;    deviceHeight = theRect.bottom - theRect.top;    theRect = (*srcPix)-&#62;bounds;    srcWidth = theRect.right - theRect.left;    srcHeight = theRect.bottom - theRect.top;    xOffset = mouse.h;    yOffset = mouse.v;    srcHStart = 0;    srcVStart = 0;    // trim h    if (xOffset &#60; 0)    {        srcWidth -= -xOffset;        srcHStart = -xOffset;        xOffset = 0;    }    else    {        if ((xOffset + srcWidth) &#62; deviceWidth)            srcWidth = deviceWidth - xOffset;    }    // trim y    if (yOffset &#60; 0)    {        srcHeight -= -yOffset;        srcVStart = -yOffset;        yOffset = 0;    }    else    {        if ((yOffset + srcHeight) &#62; deviceHeight)            srcHeight = deviceHeight - yOffset;    }    switch (depth)    {        case 1:        case 2:        case 4:        case 8:            DebugStr("\pDon't handle indexed yet");            break;        case 16:            // need to align this stuff            {                UInt16          *srcPixel;                UInt16          *mskPixel;                UInt16          *dstPixel;                UInt16          *savePixel;                offOffset = (srcVStart * offRowBytes) + (srcHStart &#60;&#60; 1);                srcData = srcBase + offOffset;                mskData = mskBase + offOffset;                saveData = saveBase + offOffset;                dstData = dstBase + (yOffset * dstRowBytes) + (xOffset &#60;&#60; 1);                for (v = 0; v &#60; srcHeight; v++)                {                    srcPixel = (UInt16 *)srcData;                    mskPixel = (UInt16 *)mskData;                    dstPixel = (UInt16 *)dstData;                    savePixel = (UInt16 *)saveData;                    for (h = 0; h &#60; srcWidth; h++)                    {                        if (*mskPixel++ == 0x00)                        {                            *savePixel = *dstPixel;                            *dstPixel = *srcPixel;                        }                        dstPixel++;                        srcPixel++;                        savePixel++;                    }                    srcData += offRowBytes;                    mskData += offRowBytes;                    dstData += dstRowBytes;                    saveData += offRowBytes;                }            }            break;        case 32:            {                UInt32          *srcPixel;                UInt32          *mskPixel;                UInt32          *dstPixel;                UInt32          *savePixel;                offOffset = (srcVStart * offRowBytes) + (srcHStart &#60;&#60; 2);                srcData = srcBase + offOffset;                mskData = mskBase + offOffset;                saveData = saveBase + offOffset;                dstData = dstBase + (yOffset * dstRowBytes) + (xOffset &#60;&#60; 2);                for (v = 0; v &#60; srcHeight; v++)                {                    srcPixel = (UInt32 *)srcData;                    mskPixel = (UInt32 *)mskData;                    dstPixel = (UInt32 *)dstData;                    savePixel = (UInt32 *)saveData;                    for (h = 0; h &#60; srcWidth; h++)                    {                        if (*mskPixel++ == 0x00)                        {                            *savePixel = *dstPixel;                            *dstPixel = *srcPixel;                        }                        srcPixel++;                        dstPixel++;                        savePixel++;                    }                    srcData += offRowBytes;                    mskData += offRowBytes;                    saveData += offRowBytes;                    dstData += dstRowBytes;                }            }            break;        default:            break;    }    CursorFlush(device);}</pre></TD></TR></TABLE></CENTER><BR><BR><A NAME="Section3.6"></A><H3>CursorErase</H3>         <P>This function really is a drawing function.  It just undoes the work done by <CODE>CursorDraw</CODE> by restoring the save screen image data.  The parameters are the same as for <CODE>CursorDraw</CODE> and have the same caveats.  The applicable save data must be found based on the <CODE>GDHandle</CODE> parameter.  <CODE>RestoreMaskedImage</CODE> (as shown below) restores the clipped data back to the screen.  As with other component functions, this must be interrupt safe.</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>pascal ComponentResultCursorErase(CursorGlobalsHnd storage, GDHandle device, Point *position){    SInt16          index;    index = FindDeviceRecordIndex(storage, device);    if (index != -1)    {        RestoreMaskedImage(device, *position,            (*storage)-&#62;deviceList[index].saveUnder-&#62;portPixMap,            (*storage)-&#62;deviceList[index].maskImage-&#62;portPixMap);    }    return noErr;}static voidRestoreMaskedImage(GDHandle device, Point mouse, PixMapHandle srcPix, PixMapHandle mskPix){    Rect            theRect;    UInt32          h;    UInt32          v;    UInt32          srcHStart;    UInt32          srcVStart;    UInt32          offRowBytes;    UInt32          dstRowBytes;    UInt32          offOffset;    SInt32          srcHeight;    SInt32          srcWidth;    UInt32          deviceHeight;    UInt32          deviceWidth;    SInt32          xOffset;    SInt32          yOffset;    UInt16          depth;    Ptr             srcBase;    Ptr             dstBase;    Ptr             mskBase;    Ptr             srcData;    Ptr             dstData;    Ptr             mskData;    // get base of src and mask    srcBase = (*srcPix)-&#62;baseAddr;    mskBase = (*mskPix)-&#62;baseAddr;    offRowBytes = (*srcPix)-&#62;rowBytes &#38; 0x7FFF;    // get base and rowbytes of destination    dstBase = (*(*device)-&#62;gdPMap)-&#62;baseAddr;    dstRowBytes = (*(*device)-&#62;gdPMap)-&#62;rowBytes &#38; 0x7FFF;    depth = (*(*device)-&#62;gdPMap)-&#62;pixelSize;    theRect = (*device)-&#62;gdRect;    deviceWidth = theRect.right - theRect.left;    deviceHeight = theRect.bottom - theRect.top;    theRect = (*srcPix)-&#62;bounds;    srcWidth = theRect.right - theRect.left;    srcHeight = theRect.bottom - theRect.top;    xOffset = mouse.h;    yOffset = mouse.v;    srcHStart = 0;    srcVStart = 0;    // trim h    if (xOffset &#60; 0)    {        srcWidth -= -xOffset;        srcHStart = -xOffset;        xOffset = 0;    }    if ((xOffset + srcWidth) &#62; deviceWidth)        srcWidth = deviceWidth - xOffset;    // trim y    if (yOffset &#60; 0)    {        srcHeight -= -yOffset;        srcVStart = -yOffset;        yOffset = 0;    }    if ((yOffset + srcHeight) &#62; deviceHeight)        srcHeight = deviceHeight - yOffset;    switch (depth)    {        case 1:        case 2:        case 4:        case 8:            DebugStr("\pDon't handle indexed yet");            break;        case 16:            // need to align this stuff            {                UInt16          *srcPixel;                UInt16          *dstPixel;                UInt16          *mskPixel;                offOffset = (srcVStart * offRowBytes) + (srcHStart &#60;&#60; 1);                srcData = srcBase + offOffset;                mskData = mskBase + offOffset;                dstData = dstBase + (yOffset * dstRowBytes) + (xOffset &#60;&#60; 1);                for (v = 0; v &#60; srcHeight; v++)                {                    srcPixel = (UInt16 *)srcData;                    dstPixel = (UInt16 *)dstData;                    mskPixel = (UInt16 *)mskData;                    for (h = 0; h &#60; srcWidth; h++)                    {                        if (*mskPixel == 0x00)                        {                            *dstPixel = *srcPixel;                        }                        dstPixel++;                        mskPixel++;                        srcPixel++;                    }                    srcData += offRowBytes;                    mskData += offRowBytes;                    dstData += dstRowBytes;                }            }            break;        case 32:            {                UInt32          *srcPixel;                UInt32          *dstPixel;                UInt32          *mskPixel;                offOffset = (srcVStart * offRowBytes) + (srcHStart &#60;&#60; 2);                srcData = srcBase + offOffset;                mskData = mskBase + offOffset;                dstData = dstBase + (yOffset * dstRowBytes) + (xOffset &#60;&#60; 2);                for (v = 0; v &#60; srcHeight; v++)                {                    srcPixel = (UInt32 *)srcData;                    dstPixel = (UInt32 *)dstData;                    mskPixel = (UInt32 *)mskData;                    for (h = 0; h &#60; srcWidth; h++)                    {                        if (*mskPixel == 0x00)                        {                            *dstPixel = *srcPixel;                        }                        dstPixel++;                        mskPixel++;                        srcPixel++;                    }                    srcData += offRowBytes;                    mskData += offRowBytes;                    dstData += dstRowBytes;                }            }            break;        default:            break;    }}</pre></TD></TR></TABLE></CENTER><BR><BR><A NAME="Section3.7"></A>         <H3>CursorMove</H3>         <P>This function must both erase and restore the last image, and draw a new image.  To this end, both the old position and new position are provided.  Again, this all happens at interrupt time; the <CODE>GDHandle</CODE> must be used to determine the cursor data to restore and draw the screen and cursor image. All the caveats for the previously described plotting functions apply.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>pascal ComponentResultCursorMove(CursorGlobalsHnd storage, GDHandle device, Point *lastPosition, Point *newPosition){    SInt16          index;    index = FindDeviceRecordIndex(storage, device);    if (index != -1)    {        RestoreMaskedImage(device, *lastPosition,            (*storage)-&#62;deviceList[index].saveUnder-&#62;portPixMap,            (*storage)-&#62;deviceList[index].maskImage-&#62;portPixMap);        PlotMaskedImageWithSave(device, *newPosition,            (*storage)-&#62;deviceList[index].cursorImage                    [(*storage)-&#62;animIndex]-&#62;portPixMap,            (*storage)-&#62;deviceList[index].maskImage-&#62;portPixMap,            (*storage)-&#62;deviceList[index].saveUnder-&#62;portPixMap);    }    return noErr;}</pre></TD></TR></TABLE></CENTER><BR><BR><A NAME="Section3.8"></A>         <H3>CursorAnimate</H3>         <P>The last function in the component API is <CODE>CursorAnimate</CODE>.  It is responsible for indexing through the cursor's various images. You will only need to provide this function if your component handles animation. The animate function is called once for each display. In the example case, we simply index through pre-rendered images so we care only about the first display. If your component renders each frame on the fly, you will most likely require notifications for each display. Once again, the specifics of the animate function are completely defined by your cursor implementation. Below is a simple example of a rotating animation.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>pascal ComponentResultCursorAnimate(CursorGlobalsHnd storage, GDHandle device, Point *lastPosition){#pragma unused (device, lastPosition)    UInt32          index;    if (device == GetMainDevice())    {        index = (*storage)-&#62;animIndex;        index++;        if (index &#62; kNumberOfAnimations - 1)            index = 0;        (*storage)-&#62;animIndex = index;    }    return noErr;}</pre></TD></TR></TABLE></CENTER><BR><BR><A NAME="Section3.9"></A>         <H3>Resources</H3>         <P>The cursor component compiled as a code resource needs a <CODE>'thng'</CODE> resource, which allows the application to identify the specific component it is accessing.  Below is a simple example of a beach ball cursor's <CODE>'thng'</CODE> resource.  Note the <CODE>kCursorSubType</CODE>: this will be used later to identify this particular cursor code resource.  Beyond this, you are free to use resources to store any data required to build the cursor.</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>#define kCursorResID            129#define kCursorName             "Beachball Cursor"#define kCursorType             'curs'#define kCursorSubType          'bbcc'#define kCursorManufacturer     'appl'resource 'thng' (kCursorResID, kCursorName, purgeable){    kCursorType,    kCursorSubType,    kCursorManufacturer,    0x80000020,    kAnyComponentFlagsMask,    'crco',    kCursorResID,    'STR ',    kCursorResID + 5000,    'STR ',    kCursorResID + 5050,    'ICON',    kCursorResID,    0x0,    8,    0,    {   /* array ComponentPlatformInfo: 1 elements */        /* [1] */        0x80000000, 'crco', kCursorResID, platformPowerPC    }};</pre></TD></TR></TABLE></CENTER><BR><BR>     <p><A HREF = "#top">Back to top</a></p><BR><A NAME="Section4"></A>         <H2>Using Components</H2>         <P>Once the cursor component is created, an application must be created to instantiate it.  The application interface for the component is fairly simple.  The basic requirements are that the code resource is loaded, the cursor is instantiated by opening it, and then it is set.  Once this occurs the application can pass data directly to the cursor.  Finally, when it is done with it, close and unload it.</p>         <A NAME="Section4.1"></A>         <H3>Registering Components</H3>         <P>First, we look at handling the code resource.  The code below registers the cursors code resource, allowing it to be opened.</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErrRegisterCursorComponents(void){    OSErr       err = -1;    if (RegisterComponentResourceFile (CurResFile(), 0))        err = noErr;    return err;}</pre></TD></TR></TABLE></CENTER><BR><BR><A NAME="Section4.2"></A><H3>Opening the Cursor</H3>         <P>Once the component is registered, we can open the cursor.  This is achieved by setting up a <CODE>ComponentDescription</CODE> to look for the cursor component.  The keys here are the subtype and the manufacturer: ensure that these match your cursor's <CODE>'thng'</CODE> resource.  Once this it completed, call <CODE>FindNextComponent</CODE> to find the next component that fits the description.  If this returns without error, the component found can be used in the new QuickDraw function <CODE>OpenCursorComponent</CODE> to actually open the cursor.  <CODE>OpenCursorComponent</CODE> is defined as follows:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre> OSErr OpenCursorComponent (Component c, ComponentInstance * ci); </pre></TD></TR></TABLE></CENTER><BR><BR><P>The <CODE>ComponentInstance</CODE> parameter should be set on return to a specific instance the cursor that can used with the other cursor component functions.  This functionality can be seen in the example below, which takes a component subtype and attempts to open it, in turn setting the global <CODE>ComponentInstance</CODE> as applicable.</p>            <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>voidOpenTheCursor(OSType subType){    OSErr                       err;    ComponentDescription        theDesc;    Component                   comp = nil;    Point                       hotspot;    // set up the descriptor    theDesc.componentType           = 'curs';    theDesc.componentSubType        = subType;    theDesc.componentManufacturer   = 'appl';    theDesc.componentFlags          = 0L;    theDesc.componentFlagsMask      = 0L;    comp = FindNextComponent(0L, &#38;theDesc);    if (comp != nil)    {        err = OpenCursorComponent(comp, &#38;gComp);        if (err == noErr)            gCurrentSubType = subType;        else            gComp = nil;        if (err != noErr)            HandleError(err, false);    }}</pre></TD></TR></TABLE></CENTER><BR><BR><A NAME="Section4.3"></A><H3>Setting the Cursor</H3>         <P>After the cursor is opened it can be set.  This should be done when the application wants to display the particular cursor.  To achieve this <CODE>SetCursorComponent</CODE> is call.  The function is defined in QuickDraw.h as:</p>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre> OSErr SetCursorComponent (ComponentInstance ci); </pre></TD></TR></TABLE></CENTER><BR><BR>                                    <P>This can be accomplished in the following simple manner.</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>voidSetTheCursor(void){    SetCursorComponent(gComp);}</pre></TD></TR></TABLE></CENTER><BR><BR><A NAME="Section4.4"></A>         <H3>Closing the Cursor</H3>         <P>Once the application is done with a particular cursor (and absolutely before exit), it should be close with <CODE>CloseCursorComponent</CODE> defined as:</p>                 <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre> OSErr CloseCursorComponent (ComponentInstance ci); </pre></TD></TR></TABLE></CENTER><BR><BR><P>Again, this is simply implemented in the sample by just checking for <CODE>NIL</CODE> and passing the global <CODE>ComponentInstance</CODE> to the function as shown below.</p>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>voidCloseTheCursor(void){    if (gComp != nil)    {        CloseCursorComponent(gComp);        gComp = nil;    }}</pre></TD></TR></TABLE></CENTER><BR><BR><A NAME="Section4.5"></A>         <H3>Modifying the Cursor</H3>         <P>Cursor components possess the <CODE>CursorComponentSetData</CODE> function, which allows modification of the cursor.  This can be used to change frame data, set a state, or just about anything else you can imagine.  The set data function is defined as:</p>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre> OSErr CursorComponentSetData (ComponentInstance ci, long data); </pre></TD></TR></TABLE></CENTER><BR><BR><P>This allows passing either direct data or a pointer to the cursor itself.  An example of utilizing can also be found in the example application's <CODE>SetCursorPictureID</CODE> function that sets the bitmap for the current cursor.</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErrSetCursorPictureID(short pictureID, Point *hotspot){    OSErr                       err = noErr;    PrivateCursorData           data;    static  short               lastID = -99;    // return if image is already set    if (lastID == pictureID) return err;    // only set image if cursor is bitmap cursor...    if (gCurrentSubType == kBitMapSubType)    {        data.pictureID = (long)pictureID;        data.hotSpot = *hotspot;        err = CursorComponentSetData((ComponentInstance)gComp, (long)&#38;data);        if (err == noErr)            lastID = pictureID;    }    return err;}</pre></TD></TR></TABLE></CENTER><BR><BR><P>Basically <CODE>CursorComponentSetData</CODE> provides an application-defined conduit to the cursor component, but does not alter any outside characteristics. It is worthwhile to note if the call to <CODE>CursorComponentSetData</CODE> modifies that appearance of the cursor, <CODE>CursorComponentSetData</CODE> should call <CODE>CursorComponentChanged</CODE>. This will notify QuickDraw that the appearance and/or other info about the cursor has changed. QuickDraw will re-interrogate the cursor for hotspot, bounds, etc., and redraw it. </p><A NAME="Section4.6"></A>         <H3>Miscellaneous</H3>         <P>If you are changing cursors (not just changing images) you should ensure that you open the new cursor before closing the old one. This will prevent the cursor from reverting to the arrow during the change.  Here's some example code to do this:</p>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>voidOpenNewCloseOld(OSType subType){    ComponentInstance   oldCursor;    // save the current cursor    oldCursor = gComp;    // open the new one    OpenTheCursor(subType);    if (oldCursor != nil)    {        CloseCursorComponent(oldCursor);    }}</pre></TD></TR></TABLE></CENTER><BR><BR><BR><p><A HREF = "#top">Back to top</a></p><BR><A NAME="Section5"></A>         <H2>Fighting Flicker</H2>         <P>Cursor flicker can occur when using color cursors under some circumstances.  RAGE 128-based systems may not flush their internal cache on every cursor redraw,  causing some or all of the cursor to flicker.  This problem can be corrected by utilizing the included CursorFlush library.  The CursorFlush header file defines two routines, <CODE>InitializeCursorFlush</CODE> and <CODE>CursorFlush</CODE>.  The former should be called in the <CODE>CursorInitialize</CODE> function to set up the flush library.  The later should be called when drawing is complete to ensure the video card correctly displays the cursor image without flicker.</p>      <p><A HREF = "#top">Back to top</a></p><BR>         <A NAME="Summary"></A>         <H2>Summary</H2>         <P>Obviously, Cursor Components provide a useful and greatly expanded human interface element.  At first, they may seem difficult to implement.  By reading this Technote and studying the code provided in the SDK, you can see the implementation is straightforward, and the resources in the SDK provide a good start.  Freeform color cursors are here today on the Mac OS; it is only your imagination that limits their implementation.  Go forth and build some awesome cursors.</P><a name="References"></a><H2>References</H2>            <p><a href="http://developer.apple.com/sdk/index.html">Cursor Component SDK</A></p>            <p><A HREF = "tn1104.html">Technote 1104: Interrupt-Safe Routines</A></p>            <p><a href="../../documentation/mac/QuickDraw/QuickDraw-2.html">Inside Macintosh: Imaging With QuickDraw</A></p>            <p><a href="../index.html">Technote web site</A></p>        <BR><P><A HREF = "#top">Back to top</a></p><BR>      <A NAME="Downloads"></A> <h2>Downloadables</h2><center><TABLE BORDER=0 CELLPADDING=3 WIDTH="600"> <TR>     <td width=50 align=left>       <P ALIGN=center><img src="images/acrobatsmall.gif" align=middle alt="Acrobat" width=22 height=23></P>    </TD>    <td align="left">       <p>Acrobat version of this Note (92K).</P>    </TD>    <td width=60 align=left>       <p><A HREF="pdf/tn1196.pdf">Download</A></P>    </TD>  </TR> </table></center><BR><BR><BR><P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1196.html%3Fid%3DDTS10003035-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1196.html%3Fid%3DDTS10003035-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1196.html%3Fid%3DDTS10003035-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>