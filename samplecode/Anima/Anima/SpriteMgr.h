/*	© Copyright 1991 Ricardo Batista,  All Rights Reserved.			Prototypes for the Color Sprite Manager			04/20/91			HISTORY:  (Most Recent first)			04/23/91	rb	Finished first functional spec and prototypes.	04/20/91	rb	New today			SOME ELEMENTS FROM THIS FILE WILL BE MOVED INTO A PRIVATE INTERFACE.	*/// #include <Types.h>// #include <QuickDraw.h>// #include <QDOffscreen.h>typedef struct {	QElemPtr qLink;	short qType;	ProcPtr vblAddr;	short vblCount;	short vblPhase;	short inVBL;} taskRecord;#define		kMaxUR			20typedef struct {		Ptr					nextSprite;			// pointer to next SpriteInfoRec		short				id;					// sprite unique id		short				drawOrder;			// drawing order, 1 being first		short				copyMode;			// usually transparent, srcCopy or blend		short				pictID;				// the PICT id where this sprite was copied from		short				currentFace;		// current face we are displaying 1 based		short				faces;				// total number of faces for this sprite		Rect				animationRect;		// location of sprite in animation screen or 0's		Rect				collisionRect;		// animation origin collison rectangle		Rect				spriteRect;			// rectangle wich encloses the sprite (local coord)		Rect				oldAnimationRect;	// area that needs to be updated in animation		GWorldPtr			spriteWorld;		// graphics world which contains sprite and faces		unsigned long		tickWait;			// tick count before calling tickProc or changing face		unsigned long		lastTick;			// last time we tickled this sprite		ProcPtr				tickProc;			// proc to call on ticks or nil for auto face change		ProcPtr				collisionProc;		// proc to call on collisions or nil		Boolean				sharedWorld;		// true if this gworld is actually shared with others		Boolean				changed;			// true if the face of the sprite has changed, needs update		Boolean				canCollide;			// used to enable/disable collisions		Boolean				hidden;				// used to show/hide the sprite		Ptr					userPtr;			// for app owned extra information		Ptr					reserved;			// who knows what the future might bring		} SpriteInfoRec, *SpriteInfoRecPtr;typedef struct {		Ptr					nextScenery;		// pointer to next SceneryInfoRec		short				id;					// unique id number of this scenery		short				pictID;				// PICT resource where scenery was copied from		short				drawOrder;			// order in which sceneries are drawn 1 = first		short				copyMode;			// srcCopy for 1'st back, transparent for most		GWorldPtr			sceneryWorld;		// graphics world which contains scenery		Rect				animationRect;		// rect in animation world occupied by this scenery		Rect				sceneryRect;		// gworld based rectangle ready for copybits		Point				scrollOffset;		// offset used for scrolling scenery		Point				autoScrollAmount;	// for the autoscrolling		long				scrollTicks;		// tick count for automatic scrolling if not zero		long				nextTickCount;		// when this tick arrives is time to autoscroll		Boolean				hidden;				// so we can "hide" backgrounds		Boolean				changed;			// marks that needs to be updated in animation		Boolean				shared;				// are we sharing gWorlds ?		} SceneryInfoRec, *SceneryInfoRecPtr;typedef struct {	SpriteInfoRecPtr		backSprites;		// linked list of background sprites	SpriteInfoRecPtr		normSprites;		// linked list of sprites	SpriteInfoRecPtr		foreSprites;		// linked list of foreground sprites	SceneryInfoRecPtr		backgrounds;		// linked list of backgrounds;	SceneryInfoRecPtr		foregrounds;		// linked list of foregrounds;	CWindowPtr				animationWindow;	// our window, where animation goes	GWorldPtr				animationGWorld;	// graphics world for end animation	Rect					animationRect;		// rectangle of animation window which belongs to us	CTabHandle				originalCTable;		// the original color table, must be restored later	CTabHandle				currCTable;			// the current color table	short					originalDepth;		// original pixel depth of device, to be restored	taskRecord				task;				// vbl task for smooth animation	GDHandle				deviceUsed;			// the graphics device of preference	Boolean					active;				// is our animation active ?	Boolean					redoCheck;			// redo update check if nessesary	Boolean					changed;			// true if animation has changed	Rect					changedRect[kMaxUR];	// update rectangles (for speed)	short					updateRects;		// how many are in use ?} SpriteMgrRec, *SpriteMgrRecPtr;short InitSpriteMgr(CTabHandle cTable);	void CloseSpriteMgr(void);short NewBackground(short pictID, short drawOrder, short copyMode, Rect *animationRect,					short id);short NewForeground(short pictID, short drawOrder, short copyMode, Rect *animationRect,					short id);void ScrollBackground(short id, short vOffset, short hOffset);void ScrollForeground(short id, short vOffset, short hOffset);void AutoScrollBackground(short id, short vOffset, short hOffset, long scrollTicks);void AutoScrollForeground(short id, short vOffset, short hOffset, long scrollTicks);void KillBackground(short id);void KillForeground(short id);short NewBackgroundSprite(short pictID, short totalPicts, short copyMode,						ProcPtr spriteProc, long ProcTicks, short drawOrder,						ProcPtr collisionProc, Boolean canColide, short id);short NewSprite(short pictID, short totalPicts, short copyMode,						ProcPtr spriteProc, long ProcTicks, short drawOrder,						ProcPtr collisionProc, Boolean canColide, short id);short NewForegroundSprite(short pictID, short totalPicts, short copyMode,						ProcPtr spriteProc, long ProcTicks, short drawOrder,						ProcPtr collisionProc, Boolean canColide, short id);CWindowPtr NewAnimation(Rect *animationRect, short windowH, short windowV, Str255 wTitle);void SetCurrentSpriteIndex(short id, short index);	void PutSprite(short id, short top, short left);void RemoveSprite(short id);	void MoveSprite(short id, short h, short v, short newIndex);void MoveSpriteTo(short id, short h, short v, short newIndex);	void ShowSprite(short id, Boolean show);	void GetSpriteLocation(short id, Rect *location);void EnableSpriteCollisions(short id, Boolean enable);		void ValidateOldSpriteLocation(short id);	void SetSpriteCollisionRect(short id, Rect *colRect);	SpriteInfoRecPtr GetSpriteInfo(short id);	void KillSprite(short id);	void ActivateAnimation(void);	void DeactivateAnimation(void);void DoAnimation(Boolean update);void SetNewAnimationPallete(CTabHandle cTable);/*******************************************************************************************	P R I V A T E      R O U T I N E S		*******************************************************************************************/extern void VTASK(void);short NewScenery(short pictID, short drawOrder, short copyMode, Rect *animationRect,				short id, Boolean back);short SMgrNewSprite(short pictID, short totalPicts, short copyMode,						ProcPtr spriteProc, long ProcTicks, short drawOrder,						ProcPtr collisionProc, Boolean canCollide, short id, short sType);SpriteInfoRecPtr FindSprite(short id);SpriteInfoRecPtr FindTwinSprite(short pictID);SceneryInfoRecPtr FindTwinScenery(short pictID);void CheckChangedScenery(SceneryInfoRecPtr scenery);void CheckChangedSprite(SpriteInfoRecPtr sprite);void UpdateScenery(SceneryInfoRecPtr scenery);void UpdateSprite(SpriteInfoRecPtr sprite);void MarkSceneryInRect(Rect *box, SceneryInfoRecPtr scenery);void MarkSpriteInRect(Rect *box, SpriteInfoRecPtr sprite);void CopyGToScreen(void);Boolean SMgrPtInRect(Point pixel, Rect *box);Boolean RectIntersect(Rect *r, Rect *box);