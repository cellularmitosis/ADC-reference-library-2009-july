<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>vrscript - /Feature Files/VR3DObjects.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/QuickTime/index.html">QuickTime</a> &gt; <a href="../../samplecode/QuickTime/idxVirtualReality-date.html">Virtual Reality</a> &gt; <A HREF="javascript:location.replace('index.html');">vrscript</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">vrscript</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Feature Files/VR3DObjects.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Application Files/ComApplication.c</option>
<option value="listing2.html">/Application Files/ComApplication.h</option>
<option value="listing3.html">/Application Files/ComResource.h</option>
<option value="listing4.html">/Common Files/ComFramework.c</option>
<option value="listing5.html">/Common Files/ComFramework.h</option>
<option value="listing6.html">/Common Files/FileUtilities.c</option>
<option value="listing7.html">/Common Files/FileUtilities.h</option>
<option value="listing8.html">/Common Files/MacFramework.c</option>
<option value="listing9.html">/Common Files/MacFramework.h</option>
<option value="listing10.html">/Common Files/MacPrefix.h</option>
<option value="listing11.html">/Common Files/QTUtilities.c</option>
<option value="listing12.html">/Common Files/QTUtilities.h</option>
<option value="listing13.html">/Common Files/QTVRUtilities.c</option>
<option value="listing14.html">/Common Files/QTVRUtilities.h</option>
<option value="listing15.html">/Common Files/URLUtilities.c</option>
<option value="listing16.html">/Common Files/URLUtilities.h</option>
<option value="listing17.html">/Common Files/WinFramework.c</option>
<option value="listing18.html">/Common Files/WinFramework.h</option>
<option value="listing19.html">/Common Files/WinPrefix.h</option>
<option value="listing20.html">/Feature Files/VR3DObjects.c</option>
<option value="listing21.html">/Feature Files/VR3DObjects.h</option>
<option value="listing22.html">/Feature Files/VR3DTexture.c</option>
<option value="listing23.html">/Feature Files/VR3DTexture.h</option>
<option value="listing24.html">/Feature Files/VRActions.c</option>
<option value="listing25.html">/Feature Files/VRActions.h</option>
<option value="listing26.html">/Feature Files/VREffects.c</option>
<option value="listing27.html">/Feature Files/VREffects.h</option>
<option value="listing28.html">/Feature Files/VRHash.c</option>
<option value="listing29.html">/Feature Files/VRHash.h</option>
<option value="listing30.html">/Feature Files/VRMovies.c</option>
<option value="listing31.html">/Feature Files/VRMovies.h</option>
<option value="listing32.html">/Feature Files/VRPicture.c</option>
<option value="listing33.html">/Feature Files/VRPicture.h</option>
<option value="listing34.html">/Feature Files/VRPreferences.c</option>
<option value="listing35.html">/Feature Files/VRPreferences.h</option>
<option value="listing36.html">/Feature Files/VRSound.c</option>
<option value="listing37.html">/Feature Files/VRSound.h</option>
<option value="listing38.html">/Feature Files/VRSprites.c</option>
<option value="listing39.html">/Feature Files/VRSprites.h</option>
<option value="listing40.html">/VRScript.c</option>
<option value="listing41.html">/VRScript.h</option></select>
				</p>
				</form>
				<p><strong><a href="vrscript.zip">Download Sample</a></strong> (&#147;vrscript.zip&#148;, 340.3K)<BR>
<strong><a href="vrscript.dmg">Download Sample</a></strong> (&#147;vrscript.dmg&#148;, 443.4K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">//////////////  File:    VR3DObjects.c////  Contains:  QuickDraw 3D support for QuickTime VR movies.////  Written by:  Tim Monroe//        Parts modeled on BoxMoov code by Nick Thompson, Rick Evans, and Robert Dierkes//        and on code in QD3D book (by yours truly!).////  Copyright:  &copy; 1996-1999 by Apple Computer, Inc., all rights reserved.////  Change History (most recent first):////     &lt;37&gt;     03/28/00  rtm    changed ((**myPixMap).rowBytes &amp; 0x3fff) to QTGetPixMapHandleRowBytes(myPixMap)//     &lt;36&gt;     07/29/99  rtm    set polyhedronAttributeSet to NULL in VR3DObjects_EnlistRectangle; now//                  the Set3DObjColor command works on rectangles as well as other objects//     &lt;35&gt;     09/28/98  rtm    added Q3InteractiveRenderer_ calls to VR3DObjects_CreateView//     &lt;34&gt;     04/22/98  rtm    used GetGWorldPixMap instead of gw-&gt;portPixMap in VR3DObjects_PrescreenRoutine//     &lt;33&gt;     03/18/98  rtm    minor cleanup to make things a little more structured//     &lt;32&gt;     03/09/98  rtm    removed VR3DObjects_GetEmbeddedPicture; moved code into VR3DTexture.c from//                  VR3DObjects_LoadEmbeddedMovie and VR3DObjects_LoopEmbeddedMovie//     &lt;31&gt;     02/19/98  rtm    changed default chroma key color to prevent transparency problems//     &lt;30&gt;     01/28/98  rtm    changed NewGWorld calls to QTNewGWorld//     &lt;29&gt;     01/27/98  rtm    fixed pixel depth problems: QD3D's GWorlds should all be 32-bit//     &lt;28&gt;     10/13/97  rtm    added VR3DObjects_CreateDefaultGroup call to VR3DObjects_GetModelFromFile//                  to provide default lighting for 3DMF files//     &lt;27&gt;     10/03/97  rtm    removed UPDATE_GWORLD_BROKEN symbol//     &lt;26&gt;     09/23/97  rtm    added endian adjustment to VR3DObjects_GetEmbeddedPicture//     &lt;25&gt;     09/15/97  rtm    added UPDATE_GWORLD_BROKEN symbol; should be removed later//                  when UpdateGWorld is fixed//     &lt;24&gt;     09/12/97  rtm    added Windows support to VR3DObjects_GetModelFromFile//     &lt;23&gt;     07/17/97  rtm    added VR3DObjects_DoIdle//     &lt;22&gt;     05/05/97  rtm    more work on geometry specifications;//                  added Set calls for styles, colors, etc.//     &lt;21&gt;     05/04/97  rtm    reworked geometry specifications; added Enlist_ functions//     &lt;20&gt;     05/02/97  rtm    made sound in texture movies directional//     &lt;19&gt;     04/10/97  rtm    added call to Q3View_Sync to prevent tearing//     &lt;18&gt;     04/02/97  rtm    copied file for integration with VRScript; removed support for object nodes//     &lt;17&gt;     02/21/97  rtm    added support for multi-node, mixed-type movies;//                  fixed window resizing for object nodes//     &lt;16&gt;     02/10/97  rtm    fixed up-vector; fixed pan/tilt granularity in object nodes//                  (now QD3D camera doesn't update until object view changes)//     &lt;15&gt;     02/04/97  rtm    begun implementing support for object nodes//     &lt;14&gt;     01/24/97  rtm    slight adjustment to camera-setting algorithm//     &lt;13&gt;     01/23/97  rtm    reworked camera-setting algorithm; now it works fine!//                  (replaced VR3DObjects_RotateCamera[XY] with VR3DObjects_SetCamera)//     &lt;12&gt;     01/20/97  rtm    various small tweaks; nothing major //     &lt;11&gt;     01/17/97  rtm    further work on tilting; still unable to fix it entirely //     &lt;10&gt;     01/16/97  rtm    added VR3DObjects_SetCameraAspectRatio //                  and VR3DObjects_UpdateDrawContext to handle window resizing//     &lt;9&gt;     01/14/97  rtm    added polyhedron object to VR3DObjects_CreateModel; added static texture support//     &lt;8&gt;     01/13/97  rtm    added some object types to VR3DObjects_CreateModel//     &lt;7&gt;     01/10/97  rtm    added VR3DObjects_MCActionFilterProc (later merged into ApplicationMCActionFilterProc)//     &lt;6&gt;     01/09/97  rtm    fixed jittering on pan/tilt/zoom; fixed VR3DObjects_RotateCameraX for correct tilting//     &lt;5&gt;     01/03/97  rtm    added animation (that is, rotation) support for 3D objects//     &lt;4&gt;     12/23/96  rtm    further work on 3D overlay; fixed some jitters//     &lt;3&gt;     12/20/96  rtm    added zooming support; implemented 3D overlay instead of 3D test window//     &lt;2&gt;     12/16/96  rtm    added 3D test window, intercept procedure//                  added QuickTime movie texture mapping support//     &lt;1&gt;     12/13/96  rtm    first file//     //// This file provides functions to display 3D objects at specific locations in a panorama.//// Our strategy: QuickDraw 3D is a &quot;slave&quot; to VR: whenever the VR environment changes,// we change the QuickDraw 3D camera accordingly and render a new image to our view.// All this occurs in the prescreen buffer imaging complete procedure.////////////// TODO://  + add lighting calls (create new light, move light, set light color/intensity etc.)#if QD3D_AVAIL////////////// header files//     //////////#include &quot;VR3DObjects.h&quot;////////////// global variables//     //////////extern Boolean      gHasQuickDraw3D;              // is QuickDraw 3D available?extern Boolean      gHasQuickDraw3D15;              // is QuickDraw 3D version 1.5 (or greater) available?////////////// constants//     //////////const TQ3Point3D    kCameraOrigin = {0.0, 0.0, 0.0};const TQ3Point3D    kPointOfInterest = {0.0, 0.0, -1000.0};const TQ3ColorRGB    k3DObjColor = {0.5, 0.5, 0.5};        // default 3D object colorconst RGBColor      k3DChromaColor = {0x1111, 0x2222, 0x3333};  // the default chroma key color////////////// VR3DObjects_Init// Initialize for QuickDraw 3D.////////////void VR3DObjects_Init (void){  // make sure that QuickDraw 3D is available  gHasQuickDraw3D = VR3DObjects_IsQD3DAvailable() ? true : false;    // now perform any initialization  if (gHasQuickDraw3D) {    unsigned long    myMajor, myMinor;        Q3Initialize();        // see which version of QD3D is installed; version 1.5 provides some useful new geometries    Q3GetVersion(&amp;myMajor, &amp;myMinor);    gHasQuickDraw3D15 = ((myMajor &gt;= 0x0001) &amp;&amp; (myMinor &gt;= 0x0005));  }}////////////// VR3DObjects_Stop// Clean up for QuickDraw 3D.////////////void VR3DObjects_Stop (void){  // perform any QD3D-related shutdown operations  if (gHasQuickDraw3D)    Q3Exit();}////////////// VR3DObjects_IsQD3DAvailable// Is QuickDraw 3D available in the present operating environment?////////////Boolean VR3DObjects_IsQD3DAvailable (void){#if TARGET_OS_MAC  return((Ptr)Q3Initialize != (Ptr)kUnresolvedCFragSymbolAddress);#endif#if TARGET_OS_WIN32  return(true);#endif  // the following code should work cross-platform, but currently it returns -5551 (gestaltUndefSelectorErr) on Windows//  Boolean   myQD3DAvail = false;//  long    myAttrs;//  OSErr     myErr = noErr;////  myErr = Gestalt(gestaltQD3D, &amp;myAttrs);//  if (myErr == noErr)//    if (myAttrs &amp; (1L &lt;&lt; gestaltQD3DPresent))//      myQD3DAvail = true;////  return(myQD3DAvail);}////////////// VR3DObjects_InitWindowData// Initialize the window-specific 3D data.////////////void VR3DObjects_InitWindowData (WindowObject theWindowObject){  ApplicationDataHdl  myAppData;  Rect        myRect;  OSErr        myErr = noErr;    myAppData = (ApplicationDataHdl)QTFrame_GetAppDataFromWindowObject(theWindowObject);  if (myAppData != NULL) {      // lock the application data handle    HLock((Handle)myAppData);        // get the size of the destination window    if ((**theWindowObject).fMovie != NULL)      GetMovieBox((**theWindowObject).fMovie, &amp;myRect);            // create an offscreen GWorld that is the size of the window area    // (this GWorld is our draw context buffer)    myErr = QTNewGWorld(&amp;(**myAppData).fQD3DDCGWorld, kOffscreenPixelType, &amp;myRect, NULL, NULL, kICMTempThenAppMemory);    if (myErr != noErr)      goto bail;    // create a new view attached to the offscreen GWorld    (**myAppData).fView = VR3DObjects_CreateView((**myAppData).fQD3DDCGWorld);        // set the FOV vertical orientation flag to ON    (**myAppData).fQD3DFOVIsVert = true;    // set the default 3D chroma key color    (**myAppData).fQD3DKeyColor = k3DChromaColor;    // initialize QD3D camera's aspect ratio                     VR3DObjects_SetCameraAspectRatio(theWindowObject);                     // initialize QD3D camera's point-of-interest and FOV    VR3DObjects_SetCamera(theWindowObject);    bail:    // unlock the application data handle    HUnlock((Handle)myAppData);  }}////////////// VR3DObjects_DumpWindowData// Dump the window-specific 3D data.////////////void VR3DObjects_DumpWindowData (WindowObject theWindowObject){  ApplicationDataHdl  myAppData;    myAppData = (ApplicationDataHdl)QTFrame_GetAppDataFromWindowObject(theWindowObject);  if (myAppData != NULL) {      // dispose of the view object    if ((**myAppData).fView)      Q3Object_Dispose((**myAppData).fView);    // dispose of GWorld used by this window object    if ((**myAppData).fQD3DDCGWorld != NULL)      DisposeGWorld((**myAppData).fQD3DDCGWorld);  }}////////////// VR3DObjects_DoIdle// Do any 3D-related processing that can or should occur at idle time.// Returns true if the caller should call QTVRUpdate, false otherwise.////////////Boolean VR3DObjects_DoIdle (WindowObject theWindowObject){  ApplicationDataHdl    myAppData;  VRScript3DObjPtr    myPointer;  Boolean          myNeedUpdate = false;  myAppData = (ApplicationDataHdl)QTFrame_GetAppDataFromWindowObject(theWindowObject);  if (myAppData == NULL)    return(myNeedUpdate);    // if any currently visible 3D object is animated or has a movie texture,  // we need to update window  myPointer = (VRScript3DObjPtr)(**myAppData).fListArray[kVREntry_QD3DObject];  while ((myPointer != NULL) &amp;&amp; !myNeedUpdate) {    if (myPointer-&gt;fModelIsVisible)      if ((myPointer-&gt;fModelIsAnimated) || (myPointer-&gt;fTextureIsMovie))        myNeedUpdate = true;        myPointer = myPointer-&gt;fNextEntry;  }  return(myNeedUpdate);}            ////////////// VR3DObjects_EnlistBox// Add a box to the list of 3D objects.////////////void VR3DObjects_EnlistBox (WindowObject theWindowObject, UInt32 theEntryID, float theX, float theY, float theZ, float theXSize, float theYSize, float theZSize, UInt32 theOptions){  TQ3BoxData        myBoxData;  TQ3GeometryObject    myObject;  TQ3GroupObject      myGroup;    myBoxData.boxAttributeSet = NULL;  myBoxData.faceAttributeSet = NULL;  Q3Point3D_Set(&amp;myBoxData.origin, theXSize / -2.0, theYSize / -2.0, theZSize / -2.0);  Q3Vector3D_Set(&amp;myBoxData.orientation, 0.0, theYSize, 0.0);  Q3Vector3D_Set(&amp;myBoxData.majorAxis, 0.0, 0.0, theZSize);    Q3Vector3D_Set(&amp;myBoxData.minorAxis, theXSize, 0.0, 0.0);    myObject = Q3Box_New(&amp;myBoxData);    if (myObject != NULL) {    myGroup = VR3DObjects_CreateDefaultGroup(myObject);    if (myGroup != NULL)      VRScript_Enlist3DObject(theWindowObject, myGroup, theEntryID, theX, theY, theZ, theOptions);  }}////////////// VR3DObjects_EnlistCone// Add a cone to the list of 3D objects.////////////void VR3DObjects_EnlistCone (WindowObject theWindowObject, UInt32 theEntryID, float theX, float theY, float theZ, float theMajRad, float theMinRad, float theHeight, UInt32 theOptions){  TQ3ConeData        myConeData;  TQ3GeometryObject    myObject;  TQ3GroupObject      myGroup;    myConeData.coneAttributeSet = NULL;  myConeData.interiorAttributeSet = NULL;  myConeData.faceAttributeSet = NULL;  myConeData.bottomAttributeSet = NULL;  myConeData.caps = kQ3EndCapMaskBottom;  Q3Point3D_Set(&amp;myConeData.origin, 0.0, theHeight / -2.0, 0.0);  Q3Vector3D_Set(&amp;myConeData.orientation, 0.0, theHeight, 0.0);  Q3Vector3D_Set(&amp;myConeData.majorRadius, 0.0, 0.0, theMajRad);    Q3Vector3D_Set(&amp;myConeData.minorRadius, theMinRad, 0.0, 0.0);    myObject = Q3Cone_New(&amp;myConeData);  if (myObject != NULL) {    myGroup = VR3DObjects_CreateDefaultGroup(myObject);    if (myGroup != NULL) {      VR3DObjects_SetSubdivisionStyle(myGroup, 20);  // set a finer subdivision style      VRScript_Enlist3DObject(theWindowObject, myGroup, theEntryID, theX, theY, theZ, theOptions);    }  }}////////////// VR3DObjects_EnlistCylinder// Add a cylinder to the list of 3D objects.////////////void VR3DObjects_EnlistCylinder (WindowObject theWindowObject, UInt32 theEntryID, float theX, float theY, float theZ, float theMajRad, float theMinRad, float theHeight, UInt32 theOptions){  TQ3CylinderData      myCylinderData;  TQ3GeometryObject    myObject;  TQ3GroupObject      myGroup;    myCylinderData.cylinderAttributeSet = NULL;  myCylinderData.interiorAttributeSet = NULL;  myCylinderData.topAttributeSet = NULL;  myCylinderData.faceAttributeSet = NULL;  myCylinderData.bottomAttributeSet = NULL;  myCylinderData.caps = kQ3EndCapMaskTop | kQ3EndCapMaskBottom;  Q3Point3D_Set(&amp;myCylinderData.origin, 0.0, theHeight / -2.0, 0.0);  Q3Vector3D_Set(&amp;myCylinderData.orientation, 0.0, theHeight, 0.0);  Q3Vector3D_Set(&amp;myCylinderData.majorRadius, 0.0, 0.0, theMajRad);    Q3Vector3D_Set(&amp;myCylinderData.minorRadius, theMinRad, 0.0, 0.0);    myObject = Q3Cylinder_New(&amp;myCylinderData);    if (myObject != NULL) {    myGroup = VR3DObjects_CreateDefaultGroup(myObject);    if (myGroup != NULL) {      VR3DObjects_SetSubdivisionStyle(myGroup, 20);  // set a finer subdivision style      VRScript_Enlist3DObject(theWindowObject, myGroup, theEntryID, theX, theY, theZ, theOptions);    }  }}////////////// VR3DObjects_EnlistEllipsoid// Add an ellipsoid to the list of 3D objects.////////////void VR3DObjects_EnlistEllipsoid (WindowObject theWindowObject, UInt32 theEntryID, float theX, float theY, float theZ, float theMajRad, float theMinRad, float theHeight, UInt32 theOptions){  TQ3EllipsoidData    myEllipsoidData;  TQ3GeometryObject    myObject;  TQ3GroupObject      myGroup;    myEllipsoidData.ellipsoidAttributeSet = NULL;  myEllipsoidData.interiorAttributeSet = NULL;  myEllipsoidData.caps = 0L;  Q3Point3D_Set(&amp;myEllipsoidData.origin, 0.0, 0.0, 0.0);  Q3Vector3D_Set(&amp;myEllipsoidData.orientation, 0.0, theHeight, 0.0);  Q3Vector3D_Set(&amp;myEllipsoidData.majorRadius, 0.0, 0.0, theMajRad);    Q3Vector3D_Set(&amp;myEllipsoidData.minorRadius, theMinRad, 0.0, 0.0);    myObject = Q3Ellipsoid_New(&amp;myEllipsoidData);  if (myObject != NULL) {    myGroup = VR3DObjects_CreateDefaultGroup(myObject);    if (myGroup != NULL) {      VR3DObjects_SetSubdivisionStyle(myGroup, 20);  // set a finer subdivision style      VRScript_Enlist3DObject(theWindowObject, myGroup, theEntryID, theX, theY, theZ, theOptions);    }  }}////////////// VR3DObjects_EnlistTorus// Add a torus to the list of 3D objects.////////////void VR3DObjects_EnlistTorus (WindowObject theWindowObject, UInt32 theEntryID, float theX, float theY, float theZ, float theMajRad, float theMinRad, float theHeight, float theRatio, UInt32 theOptions){  TQ3TorusData      myTorusData;  TQ3GeometryObject    myObject;  TQ3GroupObject      myGroup;    myTorusData.torusAttributeSet = NULL;  myTorusData.interiorAttributeSet = NULL;  myTorusData.caps = 0L;  myTorusData.ratio = theRatio;  Q3Point3D_Set(&amp;myTorusData.origin, 0.0, 0.0, 0.0);  Q3Vector3D_Set(&amp;myTorusData.orientation, 0.0, theHeight, 0.0);  Q3Vector3D_Set(&amp;myTorusData.majorRadius, 0.0, 0.0, theMajRad);    Q3Vector3D_Set(&amp;myTorusData.minorRadius, theMinRad, 0.0, 0.0);    myObject = Q3Torus_New(&amp;myTorusData);  if (myObject != NULL) {    myGroup = VR3DObjects_CreateDefaultGroup(myObject);    if (myGroup != NULL) {      VR3DObjects_SetSubdivisionStyle(myGroup, 20);  // set a finer subdivision style      VRScript_Enlist3DObject(theWindowObject, myGroup, theEntryID, theX, theY, theZ, theOptions);    }  }}////////////// VR3DObjects_EnlistRectangle// Add a rectangle to the list of 3D objects.// This is intended to serve as a &quot;screen&quot; for texture-mapped movies or pictures.////////////void VR3DObjects_EnlistRectangle (WindowObject theWindowObject, UInt32 theEntryID, float theX, float theY, float theZ,                  float theX1, float theY1, float theZ1,                   float theX2, float theY2, float theZ2,                   float theX3, float theY3, float theZ3,                   float theX4, float theY4, float theZ4, UInt32 theOptions){  TQ3PolyhedronData      myPolyData;  static TQ3Vertex3D      myVertices[4];  static TQ3Param2D      myUVParams[4] = {                  {0.0, 0.0},                  {0.0, 1.0},                  {1.0, 1.0},                  {1.0, 0.0}                };    TQ3PolyhedronTriangleData  myTriangles[2] = {                  { { 0, 1, 3 }, kQ3PolyhedronEdge01 | kQ3PolyhedronEdge20, NULL },                  { { 1, 2, 3 }, kQ3PolyhedronEdge01 | kQ3PolyhedronEdge12, NULL }                };  unsigned long        myIndex;  TQ3GeometryObject      myObject;  TQ3GroupObject        myGroup;    // set up vertices, edges, and triangular faces  Q3Point3D_Set(&amp;myVertices[0].point, theX1, theY1, theZ1);  Q3Point3D_Set(&amp;myVertices[1].point, theX2, theY2, theZ2);  Q3Point3D_Set(&amp;myVertices[2].point, theX3, theY3, theZ3);  Q3Point3D_Set(&amp;myVertices[3].point, theX4, theY4, theZ4);  myVertices[0].attributeSet = NULL;  myVertices[1].attributeSet = NULL;  myVertices[2].attributeSet = NULL;  myVertices[3].attributeSet = NULL;  myPolyData.numVertices = 4;  myPolyData.vertices = myVertices;    myPolyData.numEdges = 0;  myPolyData.edges = NULL;  myPolyData.numTriangles  = 2;  myPolyData.triangles = myTriangles;    // add uv parameterization to the polyhedron  for (myIndex = 0; myIndex &lt; myPolyData.numVertices; myIndex++) {              myVertices[myIndex].attributeSet = Q3AttributeSet_New();    Q3AttributeSet_Add(myVertices[myIndex].attributeSet, kQ3AttributeTypeSurfaceUV, &amp;myUVParams[myIndex]);  }    myPolyData.polyhedronAttributeSet = NULL;    // inherit the attribute set from the current state  myObject = Q3Polyhedron_New(&amp;myPolyData);  if (myObject != NULL) {    myGroup = VR3DObjects_CreateDefaultGroup(myObject);    if (myGroup != NULL)      VRScript_Enlist3DObject(theWindowObject, myGroup, theEntryID, theX, theY, theZ, theOptions);  }}////////////// VR3DObjects_Enlist3DMFFile// Open a 3DMF file and add it to the list of 3D objects.////////////void VR3DObjects_Enlist3DMFFile (WindowObject theWindowObject, UInt32 theEntryID, float theX, float theY, float theZ, UInt32 theOptions, char *thePathName){  TQ3GroupObject      myGroup;    myGroup = VR3DObjects_GetModelFromFile(thePathName);  if (myGroup != NULL)     VRScript_Enlist3DObject(theWindowObject, myGroup, theEntryID, theX, theY, theZ, theOptions);}////////////// VR3DObjects_CreateDefaultGroup// Return a default model containing the specified object.////////////TQ3GroupObject VR3DObjects_CreateDefaultGroup (TQ3GeometryObject theObject){  TQ3GroupObject      myGroup;    // create a new display group  myGroup = Q3DisplayGroup_New();  if (myGroup != NULL) {    TQ3ShaderObject      myIlluminationShader;        // create an illumination shader      myIlluminationShader = Q3PhongIllumination_New();    if (myIlluminationShader != NULL) {      TQ3AttributeSet      myAttributeSet;      // add the illumination shader to our display group        Q3Group_AddObject(myGroup, myIlluminationShader);            // add the default diffuse color to the group      myAttributeSet = Q3AttributeSet_New();      Q3AttributeSet_Add(myAttributeSet, kQ3AttributeTypeDiffuseColor, &amp;k3DObjColor);      Q3Group_AddObject(myGroup, myAttributeSet);      // add the geometry object to the group      Q3Group_AddObject(myGroup, theObject);            // dispose of the objects we've added to the group      if (myIlluminationShader != NULL)         Q3Object_Dispose(myIlluminationShader);      }  }    if (theObject != NULL)     Q3Object_Dispose(theObject);    return(myGroup);}////////////// VR3DObjects_CreateView// Return a view object for the QD3D objects in our model.////////////TQ3ViewObject VR3DObjects_CreateView (GWorldPtr theGWorld){  TQ3Status        myStatus;  TQ3ViewObject      myView;  TQ3DrawContextObject  myDrawContext;  TQ3RendererObject    myRenderer;  TQ3CameraObject      myCamera;  TQ3GroupObject      myLights;    // create a new view object  myView = Q3View_New();  if (myView == NULL)    goto bail;    // create and set draw context  myDrawContext = VR3DObjects_CreateDrawContext(theGWorld);  if (myDrawContext == NULL)    goto bail;      myStatus = Q3View_SetDrawContext(myView, myDrawContext);  if (myStatus == kQ3Failure)    goto bail;  Q3Object_Dispose(myDrawContext);    // create and set renderer  myRenderer = Q3Renderer_NewFromType(kQ3RendererTypeInteractive);  if (myRenderer == NULL) {    myRenderer = Q3Renderer_NewFromType(kQ3RendererTypeWireFrame);  } else {    // these two lines allow us to use the best possible renderer,    // including hardware if it is installed.    Q3InteractiveRenderer_SetDoubleBufferBypass(myRenderer, kQ3True);                Q3InteractiveRenderer_SetPreferences(myRenderer, kQAVendor_BestChoice, 0);  }      if (myRenderer == NULL)     goto bail;    myStatus = Q3View_SetRenderer(myView, myRenderer);  if (myStatus == kQ3Failure)    goto bail;      Q3Object_Dispose(myRenderer);    // create and set camera  myCamera = VR3DObjects_CreateCamera(theGWorld);  if (myCamera == NULL)    goto bail;      myStatus = Q3View_SetCamera(myView, myCamera);  if (myStatus == kQ3Failure)    goto bail;  Q3Object_Dispose(myCamera);    // create and set lights  myLights = VR3DObjects_CreateLights();  if (myLights == NULL)    goto bail;      myStatus = Q3View_SetLightGroup(myView, myLights);  if (myStatus == kQ3Failure)    goto bail;  Q3Object_Dispose(myLights);      return(myView);  bail:  // if any of the above creations failed, don't return a view  return(NULL);}////////////// VR3DObjects_CreateLights// Return a light group object for the QD3D objects in our model.// For displaying embedded movies, we need just the ambient light.////////////TQ3GroupObject VR3DObjects_CreateLights (void){  TQ3GroupPosition      myGroupPosition;  TQ3GroupObject        myLightList;  TQ3LightData        myLightData;  TQ3PointLightData      myPointLightData;  TQ3DirectionalLightData    myDirectionalLightData;  TQ3LightObject        myAmbientLight, myPointLight, myFillLight;  TQ3Point3D          myPointLocation =  {-10.0, 0.0, 10.0};  TQ3Vector3D          myFillDirection =  {10.0, 0.0, 10.0};  TQ3ColorRGB          myWhiteLight =    {1.0F, 1.0F, 1.0F};    // create the ambient light  myLightData.isOn = kQ3True;  myLightData.color = myWhiteLight;  myLightData.brightness = 1.0F;  myAmbientLight = Q3AmbientLight_New(&amp;myLightData);  if (myAmbientLight == NULL)    goto bail;    // create a point light  myLightData.brightness = 1.0F;  myPointLightData.lightData = myLightData;  myPointLightData.castsShadows = kQ3False;  myPointLightData.attenuation = kQ3AttenuationTypeNone;  myPointLightData.location = myPointLocation;  myPointLight = Q3PointLight_New(&amp;myPointLightData);  if (myPointLight == NULL)    goto bail;  // create a directional light for fill  myLightData.brightness = 0.2F;  myDirectionalLightData.lightData = myLightData;  myDirectionalLightData.castsShadows = kQ3False;  myDirectionalLightData.direction = myFillDirection;  myFillLight = Q3DirectionalLight_New(&amp;myDirectionalLightData);  if (myFillLight == NULL)    goto bail;  // create a light group and add each of the lights to the group  myLightList = Q3LightGroup_New();  if (myLightList == NULL)    goto bail;  myGroupPosition = Q3Group_AddObject(myLightList, myAmbientLight);  if (myGroupPosition == 0)    goto bail;  myGroupPosition = Q3Group_AddObject(myLightList, myPointLight);  if (myGroupPosition == 0)    goto bail;  myGroupPosition = Q3Group_AddObject(myLightList, myFillLight);  if (myGroupPosition == 0)    goto bail;  Q3Object_Dispose(myAmbientLight);  Q3Object_Dispose(myPointLight);  Q3Object_Dispose(myFillLight);  return(myLightList);  bail:  // if any of the above creations failed, don't return a light group  return(NULL);}////////////// VR3DObjects_CreateDrawContext// Return a draw context object for the QD3D objects in our model.////////////TQ3DrawContextObject VR3DObjects_CreateDrawContext (GWorldPtr theGWorld){  TQ3DrawContextObject    myDrawContext;  TQ3PixmapDrawContextData  myPixMapDrawContextData;  TQ3DrawContextData      myDrawContextData;  PixMapHandle         myPixMap;  Rect            myRect;  TQ3ColorARGB        myClearColor;  float            myFactor = 0xffff;    if (theGWorld == NULL)    goto bail;      // set the background color;  // note that RGBColor is defined in the range 0-65535,  // while TQ3ColorARGB is defined in the range 0.0-1.0; hence the division....  myClearColor.a = 0.0;  myClearColor.r = k3DChromaColor.red / myFactor;  myClearColor.g = k3DChromaColor.green / myFactor;  myClearColor.b = k3DChromaColor.blue / myFactor;    // fill in draw context data  myDrawContextData.clearImageMethod = kQ3ClearMethodWithColor;  myDrawContextData.clearImageColor = myClearColor;  myDrawContextData.paneState = kQ3False;  myDrawContextData.maskState = kQ3False;  myDrawContextData.doubleBufferState = kQ3False;   myPixMapDrawContextData.drawContextData = myDrawContextData;    // the pixmap must remain locked in memory for as long as it exists  myPixMap = GetGWorldPixMap(theGWorld);  LockPixels(myPixMap);  myRect = theGWorld-&gt;portRect;    myPixMapDrawContextData.pixmap.width = myRect.right - myRect.left;  myPixMapDrawContextData.pixmap.height = myRect.bottom - myRect.top;  myPixMapDrawContextData.pixmap.rowBytes = (unsigned long)QTGetPixMapHandleRowBytes(myPixMap)  myPixMapDrawContextData.pixmap.pixelType = kQ3PixelTypeRGB32;  myPixMapDrawContextData.pixmap.pixelSize = 32;  myPixMapDrawContextData.pixmap.bitOrder = kQ3EndianBig;  myPixMapDrawContextData.pixmap.byteOrder = kQ3EndianBig;  myPixMapDrawContextData.pixmap.image = GetPixBaseAddr(myPixMap);    // create draw context and return it  myDrawContext = Q3PixmapDrawContext_New(&amp;myPixMapDrawContextData);bail:  return(myDrawContext);}////////////// VR3DObjects_CreateCamera// Return a camera object for the QD3D objects in our model.// Note that some of the initial values are wrong and will soon be reset (in InitApplicationWindowObject).////////////TQ3CameraObject VR3DObjects_CreateCamera (CGrafPtr thePort){  TQ3CameraObject          myCamera;  TQ3ViewAngleAspectCameraData  myCameraData;    TQ3Point3D             myFrom     = kCameraOrigin;  TQ3Point3D             myTo     = kPointOfInterest;  TQ3Vector3D           myUp     = {0.0, 1.0, 0.0};  float               myFOV    = 1.00;        // initial FOV really depends on QTVR instance, so we reset this later  float               myHither  = (float)0.01;  float               myYon     = 1000.0;    myCameraData.cameraData.placement.cameraLocation = myFrom;  myCameraData.cameraData.placement.pointOfInterest = myTo;  myCameraData.cameraData.placement.upVector = myUp;  myCameraData.cameraData.range.hither = myHither;  myCameraData.cameraData.range.yon = myYon;  // the default camera view port  myCameraData.cameraData.viewPort.origin.x = -1.0F;  myCameraData.cameraData.viewPort.origin.y = 1.0F;  myCameraData.cameraData.viewPort.width = 2.0F;  myCameraData.cameraData.viewPort.height = 2.0F;    // some default FOV and aspect ratio values  myCameraData.fov = myFOV;  myCameraData.aspectRatioXToY =    (float)(thePort-&gt;portRect.right - thePort-&gt;portRect.left) /     (float)(thePort-&gt;portRect.bottom - thePort-&gt;portRect.top);      myCamera = Q3ViewAngleAspectCamera_New(&amp;myCameraData);  return(myCamera);}////////////// VR3DObjects_GetModelAttributeSet// Get the attribute set of a 3D model.////////////TQ3AttributeSet VR3DObjects_GetModelAttributeSet (VRScript3DObjPtr thePointer){  TQ3AttributeSet    myAttributeSet = NULL;    if ((thePointer != NULL) &amp;&amp; (thePointer-&gt;fModel != NULL)) {    TQ3GroupPosition  myPosition;        // get the position of the attribute set in the group    Q3Group_GetFirstPositionOfType(thePointer-&gt;fModel, kQ3SetTypeAttribute, &amp;myPosition);    if (myPosition != 0)    // get the attribute set      Q3Group_GetPositionObject(thePointer-&gt;fModel, myPosition, &amp;myAttributeSet);  }    return(myAttributeSet);}////////////// VR3DObjects_SetSubdivisionStyle// Create a subdivision style and add it to the specified group.////////////void VR3DObjects_SetSubdivisionStyle (TQ3GroupObject theGroup, short theNumDivisions){  TQ3SubdivisionStyleData    myStyleData;  TQ3StyleObject        myStyleObject;  TQ3GroupPosition      myPosition;    // get the position of the geometry object in the group  Q3Group_GetFirstPositionOfType(theGroup, kQ3ShapeTypeGeometry, &amp;myPosition);    // set a subdivision style  myStyleData.method = kQ3SubdivisionMethodConstant;  myStyleData.c1 = theNumDivisions;  myStyleData.c2 = theNumDivisions;  myStyleObject = Q3SubdivisionStyle_New(&amp;myStyleData);  Q3Group_AddObjectBefore(theGroup, myPosition, myStyleObject);  Q3Object_Dispose(myStyleObject);}////////////// VR3DObjects_SetColor// Set the diffuse color of a 3D object.////////////void VR3DObjects_SetColor (WindowObject theWindowObject, UInt32 theEntryID, float theRed, float theGreen, float theBlue, UInt32 theOptions){#pragma unused(theOptions)  VRScript3DObjPtr  myPointer;  TQ3AttributeSet    myAttributeSet;    myPointer = (VRScript3DObjPtr)VRScript_GetObjectByEntryID(theWindowObject, kVREntry_QD3DObject, theEntryID);  if (myPointer != NULL) {      myAttributeSet = VR3DObjects_GetModelAttributeSet(myPointer);    if (myAttributeSet != NULL) {      TQ3ColorRGB        myColor;            // remove the existing diffuse color attribute      Q3AttributeSet_Clear(myAttributeSet, kQ3AttributeTypeDiffuseColor);      Q3ColorRGB_Set(&amp;myColor, theRed, theGreen, theBlue);      Q3AttributeSet_Add(myAttributeSet, kQ3AttributeTypeDiffuseColor, &amp;myColor);    }        Q3Object_Dispose(myAttributeSet);  }}////////////// VR3DObjects_SetTransparency// Set the transparency level of a 3D object.////////////void VR3DObjects_SetTransparency (WindowObject theWindowObject, UInt32 theEntryID, float theRed, float theGreen, float theBlue, UInt32 theOptions){#pragma unused(theOptions)  VRScript3DObjPtr  myPointer;  TQ3AttributeSet    myAttributeSet;    myPointer = (VRScript3DObjPtr)VRScript_GetObjectByEntryID(theWindowObject, kVREntry_QD3DObject, theEntryID);  if (myPointer != NULL) {      myAttributeSet = VR3DObjects_GetModelAttributeSet(myPointer);    if (myAttributeSet != NULL) {      TQ3ColorRGB        myColor;            // remove the existing transparency color attribute      Q3AttributeSet_Clear(myAttributeSet, kQ3AttributeTypeTransparencyColor);      Q3ColorRGB_Set(&amp;myColor, theRed, theGreen, theBlue);      Q3AttributeSet_Add(myAttributeSet, kQ3AttributeTypeTransparencyColor, &amp;myColor);    }        Q3Object_Dispose(myAttributeSet);  }}////////////// VR3DObjects_SetInterpolation// Set the interpolation style of a 3D object.////////////void VR3DObjects_SetInterpolation (WindowObject theWindowObject, UInt32 theEntryID, UInt32 theStyle, UInt32 theOptions){#pragma unused(theOptions)  VRScript3DObjPtr  myPointer;  myPointer = (VRScript3DObjPtr)VRScript_GetObjectByEntryID(theWindowObject, kVREntry_QD3DObject, theEntryID);  if (myPointer != NULL)     Q3InterpolationStyle_Set(myPointer-&gt;fInterpolation, (TQ3InterpolationStyle)theStyle);}////////////// VR3DObjects_SetBackfacing// Set the backfacing style of a 3D object.////////////void VR3DObjects_SetBackfacing (WindowObject theWindowObject, UInt32 theEntryID, UInt32 theStyle, UInt32 theOptions){#pragma unused(theOptions)  VRScript3DObjPtr  myPointer;  myPointer = (VRScript3DObjPtr)VRScript_GetObjectByEntryID(theWindowObject, kVREntry_QD3DObject, theEntryID);  if (myPointer != NULL)     Q3BackfacingStyle_Set(myPointer-&gt;fBackFacing, (TQ3BackfacingStyle)theStyle);}////////////// VR3DObjects_SetFill// Set the fill style of a 3D object.////////////void VR3DObjects_SetFill (WindowObject theWindowObject, UInt32 theEntryID, UInt32 theStyle, UInt32 theOptions){#pragma unused(theOptions)  VRScript3DObjPtr  myPointer;  myPointer = (VRScript3DObjPtr)VRScript_GetObjectByEntryID(theWindowObject, kVREntry_QD3DObject, theEntryID);  if (myPointer != NULL)     Q3FillStyle_Set(myPointer-&gt;fFillStyle, (TQ3FillStyle)theStyle);}////////////// VR3DObjects_SetLocation// Set the location of a 3D object.////////////void VR3DObjects_SetLocation (WindowObject theWindowObject, UInt32 theEntryID, float theX, float theY, float theZ, UInt32 theOptions){  VRScript3DObjPtr  myPointer;  myPointer = (VRScript3DObjPtr)VRScript_GetObjectByEntryID(theWindowObject, kVREntry_QD3DObject, theEntryID);  if (myPointer != NULL) {    if (theOptions == kVRValue_Relative) {      myPointer-&gt;fGroupCenter.x -= theX;      myPointer-&gt;fGroupCenter.y += theY;      myPointer-&gt;fGroupCenter.z -= theZ;    } else {      myPointer-&gt;fGroupCenter.x = -1 * theX;      myPointer-&gt;fGroupCenter.y = theY;      myPointer-&gt;fGroupCenter.z = -1 * theZ;    }  }}////////////// VR3DObjects_SetRotation// Set the rotation factors of a 3D object.////////////void VR3DObjects_SetRotation (WindowObject theWindowObject, UInt32 theEntryID, float theX, float theY, float theZ, UInt32 theOptions){  VRScript3DObjPtr  myPointer;  myPointer = (VRScript3DObjPtr)VRScript_GetObjectByEntryID(theWindowObject, kVREntry_QD3DObject, theEntryID);  if (myPointer != NULL) {    if (theOptions == kVRValue_Relative) {      myPointer-&gt;fRotateFactors.x += theX;      myPointer-&gt;fRotateFactors.y += theY;      myPointer-&gt;fRotateFactors.z += theZ;    } else {      myPointer-&gt;fRotateFactors.x = theX;      myPointer-&gt;fRotateFactors.y = theY;      myPointer-&gt;fRotateFactors.z = theZ;    }  }}////////////// VR3DObjects_SetRotationState// Set the rotation state (on or off) of a 3D object.////////////void VR3DObjects_SetRotationState (WindowObject theWindowObject, UInt32 theEntryID, Boolean theState, UInt32 theOptions){#pragma unused(theOptions)  VRScript3DObjPtr  myPointer;  myPointer = (VRScript3DObjPtr)VRScript_GetObjectByEntryID(theWindowObject, kVREntry_QD3DObject, theEntryID);  if (myPointer != NULL) {    if (theState == kVRState_Toggle)      theState = !(myPointer-&gt;fModelIsAnimated);    myPointer-&gt;fModelIsAnimated = theState;  }}////////////// VR3DObjects_SetVisibleState// Set the visibility state (on or off) of a 3D object.////////////void VR3DObjects_SetVisibleState (WindowObject theWindowObject, UInt32 theEntryID, Boolean theState, UInt32 theOptions){#pragma unused(theOptions)  VRScript3DObjPtr  myPointer;  myPointer = (VRScript3DObjPtr)VRScript_GetObjectByEntryID(theWindowObject, kVREntry_QD3DObject, theEntryID);  if (myPointer != NULL) {    if (theState == kVRState_Toggle)      theState = !(myPointer-&gt;fModelIsVisible);    myPointer-&gt;fModelIsVisible = theState;  }}////////////// VR3DObjects_SetTexture// Set the texture of a 3D object.////////////void VR3DObjects_SetTexture (WindowObject theWindowObject, UInt32 theEntryID, Boolean isMovie, UInt32 theOptions, char *thePathName){#pragma unused(theOptions)  VRScript3DObjPtr  myPointer;  myPointer = (VRScript3DObjPtr)VRScript_GetObjectByEntryID(theWindowObject, kVREntry_QD3DObject, theEntryID);  if (myPointer != NULL) {      // delete any existing texture structure, since we'll soon create another one      if (myPointer-&gt;fTexture != NULL) {      VR3DTexture_Delete(myPointer-&gt;fTexture);      myPointer-&gt;fTexture = NULL;    }          myPointer-&gt;fTextureIsMovie = isMovie;    myPointer-&gt;fTexture = VR3DTexture_New(thePathName, isMovie);        if (myPointer-&gt;fTexture != NULL)      VR3DTexture_AddToGroup(myPointer-&gt;fTexture, myPointer-&gt;fModel);  }}////////////// VR3DObjects_AnimateModel// Animate the QuickDraw 3D model.////////////void VR3DObjects_AnimateModel (VRScript3DObjPtr thePointer){  TQ3Matrix4x4    myMatrix;  TQ3Vector3D      myVector;    if (thePointer != NULL) {        // rotate the object around the local x axis    Q3Vector3D_Set(&amp;myVector, 1.0, 0.0, 0.0);    Q3Matrix4x4_SetRotateAboutAxis(&amp;myMatrix, &amp;(thePointer-&gt;fGroupCenter), &amp;myVector, thePointer-&gt;fRotateFactors.x);    Q3Matrix4x4_Multiply(&amp;(thePointer-&gt;fRotation), &amp;myMatrix, &amp;(thePointer-&gt;fRotation));        // rotate the object around the local y axis    Q3Vector3D_Set(&amp;myVector, 0.0, 1.0, 0.0);    Q3Matrix4x4_SetRotateAboutAxis(&amp;myMatrix, &amp;(thePointer-&gt;fGroupCenter), &amp;myVector, thePointer-&gt;fRotateFactors.y);    Q3Matrix4x4_Multiply(&amp;(thePointer-&gt;fRotation), &amp;myMatrix, &amp;(thePointer-&gt;fRotation));        // rotate the object around the local z axis    Q3Vector3D_Set(&amp;myVector, 0.0, 0.0, 1.0);    Q3Matrix4x4_SetRotateAboutAxis(&amp;myMatrix, &amp;(thePointer-&gt;fGroupCenter), &amp;myVector, thePointer-&gt;fRotateFactors.z);    Q3Matrix4x4_Multiply(&amp;(thePointer-&gt;fRotation), &amp;myMatrix, &amp;(thePointer-&gt;fRotation));  }}////////////// VR3DObjects_DrawModel// Draw any QuickDraw 3D models into the (offscreen GWorld) pixmap draw context.// This routine is called only in the prescreen buffer imaging complete procedure.////////////TQ3Status VR3DObjects_DrawModel (WindowObject theWindowObject){  ApplicationDataHdl  myAppData;  TQ3Status      myStatus = kQ3Failure;  TQ3ViewObject    myView;  VRScript3DObjPtr  myPointer;    myAppData = (ApplicationDataHdl)QTFrame_GetAppDataFromWindowObject(theWindowObject);    if (myAppData == NULL)    return(myStatus);    myView = (**myAppData).fView;  if (myView == NULL)    return(myStatus);    // if the camera needs to be updated, do so now  if ((**myAppData).fViewHasChanged)    VR3DObjects_SetCamera(theWindowObject);  // our rendering loop  myStatus = Q3View_StartRendering(myView);  if (myStatus != kQ3Failure)    do {      // walk our linked list of 3D objects and render any visible objects,      // after updating any object-specific properties       myPointer = (VRScript3DObjPtr)(**myAppData).fListArray[kVREntry_QD3DObject];      while (myPointer != NULL) {        if (myPointer-&gt;fModelIsVisible) {          // if there is an active movie texture, advance the movie to the next frame          if (myPointer-&gt;fTexture)            if (myPointer-&gt;fTextureIsMovie)              VR3DTexture_NextFrame(myPointer-&gt;fTexture);                    // if animation is active, animate the model          if (myPointer-&gt;fModelIsAnimated)            VR3DObjects_AnimateModel(myPointer);                      // submit the model          Q3Push_Submit(myView);          VR3DObjects_SubmitModel(myPointer, myView);          Q3Pop_Submit(myView);        }                myPointer = myPointer-&gt;fNextEntry;      }        } while (Q3View_EndRendering(myView) == kQ3ViewStatusRetraverse);      // wait until the rendering is completed...  Q3View_Sync(myView);    return(myStatus);}////////////// VR3DObjects_SubmitModel// Submit a QuickDraw 3D model for rendering, picking, bounding, or writing.////////////TQ3Status VR3DObjects_SubmitModel (VRScript3DObjPtr thePointer, TQ3ViewObject theView){  TQ3Vector3D    myTranslate;  TQ3Vector3D    myScale;  if (thePointer != NULL) {    myTranslate = *(TQ3Vector3D *) &amp;(thePointer-&gt;fGroupCenter);    myScale.x = myScale.y = myScale.z = thePointer-&gt;fGroupScale;    Q3Style_Submit(thePointer-&gt;fInterpolation, theView);    Q3Style_Submit(thePointer-&gt;fBackFacing, theView);    Q3Style_Submit(thePointer-&gt;fFillStyle, theView);    Q3MatrixTransform_Submit(&amp;(thePointer-&gt;fRotation), theView);    Q3TranslateTransform_Submit(&amp;myTranslate, theView);    Q3ScaleTransform_Submit(&amp;myScale, theView);    Q3DisplayGroup_Submit(thePointer-&gt;fModel, theView);    return(kQ3Success);  }    return(kQ3Failure);}////////////// VR3DObjects_GetModelFromFile// Open a model contained in a 3DMF file.////////////TQ3GroupObject VR3DObjects_GetModelFromFile (char *thePathName){  TQ3StorageObject  myStorage;  TQ3GroupObject     myModel;  OSErr        myErr = noErr;  #if TARGET_OS_MAC  FSSpec        myFSSpec;  short        myRefNum;  // for Macintosh, open the file and create a Mac storage object  FSMakeFSSpec(0, 0L, c2pstr(thePathName), &amp;myFSSpec);  myErr = FSpOpenDF(&amp;myFSSpec, fsRdPerm, &amp;myRefNum);  if (myErr == noErr)    myStorage = Q3MacintoshStorage_New(myRefNum);#endif#if TARGET_OS_WIN32  // for Windows, create a UNIX pathname storage object (Q3UnixPathStorage_New calls fopen internally)  myStorage = Q3UnixPathStorage_New(thePathName);#endif      if (myStorage != NULL) {    TQ3FileObject    myFile;    TQ3Status      myStatus;    TQ3Object      myObject;    TQ3Boolean      isEOF;        // create a file object    myFile = Q3File_New();    if (myFile == NULL)      return(NULL);        // associate the storage with the file    Q3File_SetStorage(myFile, myStorage);    Q3Object_Dispose(myStorage);      // read the drawable objects from the file object into a new group    myModel = Q3DisplayGroup_New();    if (myModel != NULL) {      myStatus = Q3File_OpenRead(myFile, NULL);      if (myStatus == kQ3Success) {              do {          myObject = Q3File_ReadObject(myFile);                    // if object read is not NULL, then process object          if (myObject != NULL) {            if (Q3Object_IsDrawable(myObject))              Q3Group_AddObject(myModel, myObject);                        Q3Object_Dispose(myObject);          }                    // check to see whether we've reached the end of file yet          isEOF = Q3File_IsEndOfFile(myFile);        } while (isEOF == kQ3False);              }    }        // close the file object    Q3File_Close(myFile);  }    // apply illumination shader to model  myModel = VR3DObjects_CreateDefaultGroup(myModel);#if TARGET_OS_MAC  // close the file, since we've got the data we need  FSClose(myRefNum);#endif#if TARGET_OS_WIN32  // no action required for UNIX pathname storage#endif  return(myModel);}/////////////// VR3DObjects_PrescreenRoutine// Draw the 3D objects into the current graphics world.////////////void VR3DObjects_PrescreenRoutine (QTVRInstance theInstance, WindowObject theWindowObject){#pragma unused(theInstance)  ApplicationDataHdl  myAppData;  CGrafPtr      myGWorld;  GDHandle      myGDevice;  PixMapHandle    mySrcPixMap;  PixMapHandle    myDstPixMap;          myAppData = (ApplicationDataHdl)QTFrame_GetAppDataFromWindowObject(theWindowObject);  if (myAppData == NULL)    return;  // render any objects into the pixmap draw context  VR3DObjects_DrawModel(theWindowObject);        // get the current graphics world  // (on entry, the current graphics world is set to the prescreen buffer)  GetGWorld(&amp;myGWorld, &amp;myGDevice);    RGBBackColor(&amp;(**myAppData).fQD3DKeyColor);  OpColor(&amp;(**myAppData).fQD3DKeyColor);    mySrcPixMap = GetGWorldPixMap((**myAppData).fQD3DDCGWorld);  myDstPixMap = GetGWorldPixMap(myGWorld);  // we don't need to lock the source pixel map, since it was locked when the draw context was created  LockPixels(myDstPixMap);    // copy the rendered image to the current graphics world  CopyBits((BitMapPtr)(*mySrcPixMap),       (BitMapPtr)(*myDstPixMap),       &amp;(**myAppData).fQD3DDCGWorld-&gt;portRect,        &amp;myGWorld-&gt;portRect,       srcCopy | transparent,        NULL);         UnlockPixels(myDstPixMap);}////////////// VR3DObjects_SetCamera// Set the FOV of the 3D camera associated with the specified window object;// then set the point-of-interest and the location of the 3D camera.////////////void VR3DObjects_SetCamera (WindowObject theWindowObject){  ApplicationDataHdl    myAppData;  TQ3ViewObject      myView;  TQ3CameraObject      myCamera;  TQ3CameraPlacement    myCameraPos;  QTVRInstance      myInstance;    if (theWindowObject == NULL)    return;    // get the QTVR instance associated with the specified window  myInstance = (**theWindowObject).fInstance;  if (myInstance == NULL)    return;      // get the view object associated with the specified window  myAppData = (ApplicationDataHdl)QTFrame_GetAppDataFromWindowObject(theWindowObject);    if (myAppData == NULL)    return;  myView = (**myAppData).fView;  // get the camera associated with the view object  Q3View_GetCamera(myView, &amp;myCamera);    if (myCamera != NULL) {    float        myFOV, myPan, myTilt;    TQ3Point3D      myPoint;    TQ3Vector3D      myUpVector;        // set the camera's field of view    myFOV = QTVRGetFieldOfView(myInstance);        if ((**myAppData).fQD3DFOVIsVert) {      Q3ViewAngleAspectCamera_SetFOV(myCamera, myFOV);    } else {      float      myRatio;            Q3ViewAngleAspectCamera_GetAspectRatio(myCamera, &amp;myRatio);      Q3ViewAngleAspectCamera_SetFOV(myCamera, myFOV * myRatio);    }    // get the camera's current pan and tilt angles    myPan = QTVRGetPanAngle(myInstance);    myTilt = QTVRGetTiltAngle(myInstance);    // calculate the new point-of-interest    myPoint.x = sin(myPan) * cos(myTilt) * k3DObjectDistance;    myPoint.y = sin(myTilt) * k3DObjectDistance;    myPoint.z = cos(myPan) * cos(myTilt) * k3DObjectDistance;        // calculate the new up vector of the camera    myUpVector.x = -sin(myTilt) * sin(myPan);    myUpVector.y = +cos(myTilt);    myUpVector.z = -sin(myTilt) * cos(myPan);    Q3Vector3D_Normalize(&amp;myUpVector, &amp;myUpVector);        Q3Camera_GetPlacement(myCamera, &amp;myCameraPos);    myCameraPos.upVector = myUpVector;        myCameraPos.pointOfInterest = myPoint;    myCameraPos.cameraLocation = kCameraOrigin;    Q3Camera_SetPlacement(myCamera, &amp;myCameraPos);        // update the QD3D camera    Q3View_SetCamera(myView, myCamera);    Q3Object_Dispose(myCamera);  }}////////////// VR3DObjects_SetCameraAspectRatio// Adjust the aspect ratio of the QuickDraw 3D camera based on current window shape.////////////void VR3DObjects_SetCameraAspectRatio (WindowObject theWindowObject){  ApplicationDataHdl        myAppData;  TQ3ViewObject          myView;  TQ3CameraObject          myCamera;  myAppData = (ApplicationDataHdl)QTFrame_GetAppDataFromWindowObject(theWindowObject);    if (myAppData == NULL)    return;      // get the window's view and camera objects  myView = (**myAppData).fView;  Q3View_GetCamera(myView, &amp;myCamera);  // adjust the aspect ratio of the camera  if (myCamera != NULL) {    Rect            myRect;    float            myRatio;      // get the size of the specified window    if ((**theWindowObject).fMovie != NULL)      GetMovieBox((**theWindowObject).fMovie, &amp;myRect);      // calculate the aspect ratio of the movie rectangle    myRatio = (float)(myRect.right - myRect.left) / (float)(myRect.bottom - myRect.top);    // determine whether QD3D FOV is horizontal or vertical    (**myAppData).fQD3DFOVIsVert = (myRatio &gt;= 1.0);            // adjust camera's aspect ratio    Q3ViewAngleAspectCamera_SetAspectRatio(myCamera, myRatio);    Q3Object_Dispose(myCamera);  }}////////////// VR3DObjects_UpdateDrawContext// Delete current QD3D draw context and create a new one based on current window size.////////////void VR3DObjects_UpdateDrawContext (WindowObject theWindowObject){  ApplicationDataHdl        myAppData;  TQ3ViewObject          myView;  TQ3DrawContextObject      myDrawContext;  CGrafPtr            mySavedPort;  GDHandle            mySavedDevice;  Rect              myRect;  OSErr              myErr = noErr;  myAppData = (ApplicationDataHdl)QTFrame_GetAppDataFromWindowObject(theWindowObject);    if (myAppData == NULL)    return;      // lock the application data handle  HLock((Handle)myAppData);    // get the size of the movie in the specified window  if ((**theWindowObject).fMovie != NULL)    GetMovieBox((**theWindowObject).fMovie, &amp;myRect);    // get the current drawing environment  GetGWorld(&amp;mySavedPort, &amp;mySavedDevice);  // update the pixmap draw context GWorld: dispose of the existing one and then allocate a new one  DisposeGWorld((**myAppData).fQD3DDCGWorld);  (**myAppData).fQD3DDCGWorld = NULL;    myErr = QTNewGWorld(&amp;(**myAppData).fQD3DDCGWorld, kOffscreenPixelType, &amp;myRect, NULL, NULL, kICMTempThenAppMemory);  if (myErr != noErr)    goto bail;  // get the window's view and draw context objects  myView = (**myAppData).fView;  Q3View_GetDrawContext(myView, &amp;myDrawContext);  // associate the new GWorld with the QD3D draw context  if (myDrawContext != NULL) {    // get rid of existing draw context      Q3Object_Dispose(myDrawContext);          // create and set new draw context    myDrawContext = VR3DObjects_CreateDrawContext((**myAppData).fQD3DDCGWorld);    Q3View_SetDrawContext(myView, myDrawContext);    Q3Object_Dispose(myDrawContext);  }  bail:  // restore the original drawing environment  SetGWorld(mySavedPort, mySavedDevice);  HUnlock((Handle)myAppData);}////////////// VR3DObjects_DumpEntryMem// Release any memory associated with the specified list entry.////////////void VR3DObjects_DumpEntryMem (VRScript3DObjPtr theEntry){    if (theEntry != NULL) {    if (theEntry-&gt;fModel)      Q3Object_Dispose(theEntry-&gt;fModel);    if (theEntry-&gt;fInterpolation)      Q3Object_Dispose(theEntry-&gt;fInterpolation);    if (theEntry-&gt;fBackFacing)      Q3Object_Dispose(theEntry-&gt;fBackFacing);    if (theEntry-&gt;fFillStyle)      Q3Object_Dispose(theEntry-&gt;fFillStyle);    VR3DTexture_Delete(theEntry-&gt;fTexture);  }}#endif  // QD3D_AVAIL</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/vrscript/listing20.html%3Fid%3DDTS10001032-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/vrscript/listing20.html%3Fid%3DDTS10001032-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/vrscript/listing20.html%3Fid%3DDTS10001032-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>