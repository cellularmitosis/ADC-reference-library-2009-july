<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>SoundLevel - /SoundLevel.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">SoundLevel</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/index.html" target="_blank">Reference Library</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">SoundLevel</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/SoundLevel.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/SoundLevel.c</option></select>
				</p>
				</form>
				<p><strong><a href="SoundLevel.zip">Download Sample</a></strong> (&#147;SoundLevel.zip&#148;, 21.2K)<BR>
<strong><a href="SoundLevel.dmg">Download Sample</a></strong> (&#147;SoundLevel.dmg&#148;, 83.2K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    SoundLevel.c  Contains:  A simple application that echos the sound input level on the microphone using        a display much like a VCR peak-hold bar meter.          Its a fun app, to use up those wasted background cycles and seems to amuse        people to no end. At 40k, its not a major memory hog so pop it in your Startup        Items folder and enjoy.          The About Box introduces a new power user short cut. Clap hard enough to raise        the sound threshold about \xC5 95% and the dialog will dismiss. No need to reach        and strain for that enter key anymore!          Caveats:          * Not much error checking.          * Too many globals.          * Saves the window position back to the app resource fork.          * Requires a Sound Input Device (MacRecorder will do just fine)          * It keeps the sound input device open with r/w so you won't be able              to use other sound input apps unless you quit.          Have fun and let me know what you think.  Written by: Ken Bereskin    Copyright:  Copyright &copy; 1992-1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        8/2/1999  Karl Groethe  Updated for Metrowerks Codewarror Pro 2.1        *//*  ---------------------------------------------------------------------------------  ToolBox header files*/#include &lt;Types.h&gt;#include &lt;QuickDraw.h&gt;#include &lt;Resources.h&gt;#include &lt;Windows.h&gt;#include &lt;Fonts.h&gt;#include &lt;Events.h&gt;#include &lt;TextEdit.h&gt;#include &lt;Dialogs.h&gt;#include &lt;Menus.h&gt;#include &lt;Memory.h&gt;#include &lt;Desk.h&gt;#include &lt;ToolUtils.h&gt;#include &lt;OSUtils.h&gt;#include &lt;Errors.h&gt;#include &lt;Folders.h&gt;#include &lt;OSEvents.h&gt;#include &lt;SegLoad.h&gt;#include &lt;Traps.h&gt;#include &lt;SoundInput.h&gt;#include &lt;GestaltEqu.h&gt;/*  ---------------------------------------------------------------------------------  Forward reference prototypes*/void  Initialize(void);void  SetupEnvironment(void);void  SetupMemory(void);void  SetupMenus(void);void  DoEvents(void);void  DoMouseDown (EventRecord *event);void  DoKeyDown (EventRecord *event);void  DoUpdateWindow (WindowPtr window);void  DoActivateWindow (Boolean activate, WindowPtr window);void  DoMenuCommand(short theMenu, short theItem);void  DoContentClick(EventRecord *event, WindowPtr window);void  DoSuspend(EventRecord *event);void  DoResume(EventRecord *event);void  DoIdle(void);void  DoDeskAccessory(short whichMenu, short whichItem);void  NewLevelWindow(void);void  CleanUp(void);void  DoAbout(void);Boolean  OptionTest(void);Boolean CmdTest(void);Boolean ShiftTest(void);Boolean  ColourQDExists (void);Boolean ColourQDIsOn (void);short  ColourDepth (void);void   TwitchToFinder(void);void  DrawTheMeter(Rect *meterRect, short numElements, short *peakLevel, short *lastLevel, long *peakTimeout, short meterLevel, short redZone, RGBColor *blueRGB, RGBColor *redRGB, RGBColor *blackRGB, Boolean useColour);void   GetBarRect(Rect *meterRect, short whichBar, Rect *barRect);void   InitLevelMeter (void);void  CloseLevelMeter (void);OSErr   OpenTheSoundDevice(void);void   DrawOneBar(Rect *meterRect, short whichBar, Boolean useColour);pascal  Boolean AboutFilterProc(DialogPtr dialog, EventRecord *event, short *item);void   HiliteItem(DialogPtr dialog, short theitem);void  UpdateAboutDialog(WindowPtr window);void  MakeCursor(short cursorID);/*  ---------------------------------------------------------------------------------  Constants*/#define kMaxVolume        255#define kPeakTimeoutTicks    60      // number of ticks needed to timeout peak#define kMenuBarID  128#define kAppleMenu    128#define kAboutItem    1#define kFileMenu    129#define kQuitItem    1#define kGestaltLevelMeter  'SnLv'/*  ---------------------------------------------------------------------------------  Global variables*/Boolean    WNEIsImplemented;        // is WaitNextEvent avaiableBoolean   gQuitFlag = false;        // set to force a quitWindowPtr   gLevelWindow;          // sound level window pointerRGBColor  blueRGB, redRGB, blackRGB;    // rgb colours used for drawing metershort    gNumElements;          // number of elements in the meterlong    gPeakTimeOut;short    gPeakLevel;short     gLastLevel;short    gRedZone;Rect    gMeterRect;long    gSoundInputRefNum;Boolean    gUseColour;#ifdef powerc   QDGlobals  qd;#endif/*  ---------------------------------------------------------------------------------  Main    Application main entry point*/void main(){  Initialize();          // do application initialization      NewLevelWindow();        // create the level window  InitLevelMeter();        // start up the level meter  DoUpdateWindow(gLevelWindow);    while (!gQuitFlag)        // handle events until quit    DoEvents();  CleanUp();            // clean up before quitting}/*  ---------------------------------------------------------------------------------  Intialize    First time application initialization*/#pragma segment Initializestatic voidInitialize(){  InitGraf(&amp;qd.thePort);  InitFonts();  InitWindows();  InitMenus();  TEInit();  InitDialogs(nil);  InitCursor();    FlushEvents(everyEvent, 0);      SetupMemory();  SetupEnvironment();  SetupMenus();    gUseColour = ColourDepth() &gt;= 4;  }/*  ---------------------------------------------------------------------------------  SetupEnvironment    This routine will determine the hardware and software operating environment*/#define RequestedVersion  1static voidSetupEnvironment(){  WNEIsImplemented = true;}/*  --- SetupMemory ------------------------------------------------------------------------------------  This routine will allocate some master pointers, grow the heap,  and set up a grow zone function.*/static voidSetupMemory(){  MaxApplZone();  MoreMasters();  MoreMasters();}/*  --- SetupMenus ------------------------------------------------------------------------------------  This routine will set up the LeadSheet menus.*/static voidSetupMenus(){  Handle menuBarHndl;    // load up the apple and file menu  menuBarHndl = GetNewMBar(kMenuBarID);    // read menus into menu bar  SetMenuBar(menuBarHndl);          // install menus  DisposeHandle(menuBarHndl);    AppendResMenu(GetMenuHandle(kAppleMenu), 'DRVR');    // add DA names to Apple menu    DrawMenuBar();}#pragma segment Main/*  ---------------------------------------------------------------------------------  DoEvents    This is the LaunchPad Main Event Loop. We fetch events from the event queue,   and call the proper handlers for the given event class. */#define kSleepTicks  0static voidDoEvents(){  Boolean newEvent;        // is there an event in the queue  EventRecord event;        // the event record    /*    Look for an event in the event queue.  */  if (WNEIsImplemented) {    newEvent = WaitNextEvent(everyEvent, &amp;event, kSleepTicks, nil);  } else {    SystemTask();    newEvent = GetNextEvent(everyEvent, &amp;event);  }      DoIdle();      // idle processing    /*  Dispatch on the type of event */    switch(event.what) {    case mouseDown:      DoMouseDown(&amp;event);      break;    case keyDown:    case autoKey:      DoKeyDown(&amp;event);      break;    case updateEvt:      DoUpdateWindow((WindowPtr)event.message);      break;    case activateEvt:      DoActivateWindow(event.modifiers &amp; activeFlag, (WindowPtr)event.message);      break;    case diskEvt:      break;    case osEvt:      /*        Check for suspend or resume events (the only ones now defined)      */      if ((event.message &gt;&gt; 24) == suspendResumeMessage) {        if (event.message &amp; resumeFlag)          DoResume(&amp;event);        else          DoSuspend(&amp;event);      }      break;    case highLevelEventMask:      break;  }    DoIdle();      // more idle processing}/*  --- DoMouseDown ----------------------------------------------------------------------------------  This routine handles mouseDown events.*/static voidDoMouseDown(event)EventRecord *event;{  short whichPart;  WindowPtr window;  Rect dragBounds;  long selection;  short theMenu, theItem;    /*    Determine where the mouseDown event occurred  */  whichPart = FindWindow(event-&gt;where, &amp;window);    switch(whichPart) {    case inMenuBar:      selection = MenuSelect(event-&gt;where);      theMenu = HiWord(selection);      theItem = LoWord(selection);      DoMenuCommand(theMenu, theItem);      break;    case inSysWindow:      SystemClick(event, window);      break;    case inContent:      DoContentClick(event, window);      break;    case inDrag:      dragBounds = qd.screenBits.bounds;      DragWindow(window, event-&gt;where, &amp;dragBounds);      break;    case inGrow:      break;    case inGoAway:      break;    case inZoomIn:    case inZoomOut:      break;    case inDesk:    // a click in the desktop will deselect the current selection      break;  }}/*  ---------------------------------------------------------------------------------  DoKeyDown    This routine handles keyDown events.*/static voidDoKeyDown (EventRecord *event){#pragma unused(event)  gQuitFlag = true;}/*  ---------------------------------------------------------------------------------  DoUpdateWindow  This routine handles update events for the given window*/static voidDoUpdateWindow (window)WindowPtr window;{  GrafPtr savePort;  Rect boundsRect;  short i;    GetPort(&amp;savePort);    BeginUpdate(window);    // set up the clipRgn and visRgn    SetPort(window);    RGBForeColor(&amp;blackRGB);  EraseRect(&amp;window-&gt;portRect);  boundsRect = window-&gt;portRect;  InsetRect(&amp;boundsRect, 2, 2);  PaintRect(&amp;boundsRect);    // redraw the bar graph frames up to the current level  for (i = 1; i &lt;= gLastLevel; i++) {    DrawOneBar(&amp;gMeterRect, i, gUseColour);  }    EndUpdate(window);      // restore window regions    SetPort(savePort);}/*  --- DoActivateWindow ----------------------------------------------------------------------------------  This routine handles activate events for the given window*/static voidDoActivateWindow (Boolean activate,WindowPtr window){#pragma unused(activate, window)}/*  ---------------------------------------------------------------------------------  DoMenuCommand    This routine handles menu selection dispatching*/static voidDoMenuCommand(short theMenu, short theItem){  switch (theMenu) {    case kAppleMenu:      if (theItem == kAboutItem) {        DoAbout();      } else {        DoDeskAccessory(theMenu, theItem);      }      break;    case kFileMenu:      if (theItem == kQuitItem) {        ExitToShell();      }      break;    default:      break;  }    HiliteMenu(0);}/*  --- DoContentClick ------------------------------------------------------------------------------  This routine handles clicks in the content area of a window. If the option key is down,  drag the launch window to another location on the screen.*/static voidDoContentClick(event, window)EventRecord *event;WindowPtr window;{#pragma unused(event)  GrafPtr savePort;  Point clickPt;    /*    If the clicked window isn't frontmost, simply select it  */  if (window != FrontWindow()) {    SelectWindow(window);    return;  }    GetPort(&amp;savePort);          // save the current port  SetPort(window);          // set the port to the clicked window      clickPt = event-&gt;where;        // convert point to local coordindates  GlobalToLocal(&amp;clickPt);    DragWindow(window, event-&gt;where, &amp;qd.screenBits.bounds);      SetPort(savePort);          // restore the saved port}/*  ---------------------------------------------------------------------------------  DoSuspend  This routine handles multifinder suspend events.*/static voidDoSuspend(event)EventRecord *event;{#pragma unused(event)  DoActivateWindow(false, gLevelWindow);}/*  ---------------------------------------------------------------------------------  DoResume    This routine handles multifinder resume events.*/static voidDoResume(event)EventRecord *event;{#pragma unused(event)  InitCursor();  DoActivateWindow(true, gLevelWindow);}/*  ---------------------------------------------------------------------------------  DoDeskAccessory    Handle desk accessory selections from the apple menu*/static voidDoDeskAccessory(short whichMenu,short whichItem){  Str255 daName;    GetMenuItemText(GetMenuHandle(whichMenu), whichItem, daName);      (void) OpenDeskAcc(daName);}/*  ---------------------------------------------------------------------------------  NewLevelWindow  This routine will create the sound level window.*/static voidNewLevelWindow(){  Point **userOffsetPtHndl;  Rect screenRect;  Rect globalRect;    if (ColourQDExists())    gLevelWindow = GetNewCWindow(128, nil, (WindowPtr)-1);  else    gLevelWindow = GetNewWindow(128, nil, (WindowPtr)-1);      SetPort(gLevelWindow);    // load the offset resource that tells us if the user has dragged  // the window somewhere else. make sure the window remains visible  // and eventually put this in a pref file where it belongs    userOffsetPtHndl = (Point **)GetResource('WPos', 128);  if (userOffsetPtHndl != nil) {    screenRect = qd.screenBits.bounds;    InsetRect(&amp;screenRect, 5, 5);    // a little bit of a margin        // the port is set for our window, so convert (0,0) to global for the    // global topLeft of the window    globalRect.left = (**userOffsetPtHndl).h;    globalRect.top = (**userOffsetPtHndl).v;    globalRect.right = globalRect.left + (gLevelWindow-&gt;portRect.right - gLevelWindow-&gt;portRect.left);    globalRect.bottom = globalRect.top + (gLevelWindow-&gt;portRect.bottom - gLevelWindow-&gt;portRect.top);    if (SectRect(&amp;screenRect, &amp;globalRect, &amp;globalRect)) {      MoveWindow(gLevelWindow, globalRect.left, globalRect.top, true);    }         ReleaseResource((Handle)userOffsetPtHndl);  }    ShowWindow(gLevelWindow);      // make it visible}/*  ---------------------------------------------------------------------------------  CleanUp  This routine will clean up before exiting to the Finder*/static voidCleanUp(){  Point **userOffsetPtHndl;  Point globalPt;    CloseLevelMeter();        // close up the level meter  // save the position of the top/left corner of the window in case the user  // has moved it. For now, back to the WPos resource in the app will have to do  userOffsetPtHndl = (Point **)GetResource('WPos', 128);  if (userOffsetPtHndl != nil) {    SetPort(gLevelWindow);    globalPt.h = globalPt.v = 0;    LocalToGlobal(&amp;globalPt);        **userOffsetPtHndl = globalPt;    ChangedResource((Handle)userOffsetPtHndl);    WriteResource((Handle)userOffsetPtHndl);  }  if (gLevelWindow != nil)    DisposeWindow(gLevelWindow);}/*  ---------------------------------------------------------------------------------  MakeCursor    This routine will set the cursor to the 'CURS' resource whose id is given.*/voidMakeCursor(short cursorID){#pragma unused(cursorID)}/*  ---------------------------------------------------------------------------------  DoIdle  */static voidDoIdle(){  OSErr err;  short recordingStatus = 0;            // status of recording session  short meterLevel = 0;              // current meter level  unsigned long totalSamplesToRecord = 0;      // total number of samples  unsigned long numberOfSamplesRecorded = 0;    // number of samples recorded  unsigned long totalMsecsToRecord;  unsigned long numberOfMsecsRecorded;  GrafPtr savePort;    GetPort(&amp;savePort);  SetPort(gLevelWindow);    /* get the sound input status  */  err = SPBGetRecordingStatus(gSoundInputRefNum,                &amp;recordingStatus,                &amp;meterLevel,                &amp;totalSamplesToRecord,                &amp;numberOfSamplesRecorded,                &amp;totalMsecsToRecord,                &amp;numberOfMsecsRecorded);         DrawTheMeter(&amp;gMeterRect,            gNumElements,            &amp;gPeakLevel,            &amp;gLastLevel,            &amp;gPeakTimeOut,            meterLevel,           gRedZone,           &amp;blueRGB,           &amp;redRGB,           &amp;blackRGB,           gUseColour);             SetPort(savePort);}/*  ---------------------------------------------------------------------------------  OptionTest    Returns whether the option key is being pressed*/static BooleanOptionTest(){  KeyMap theKeys;    GetKeys(theKeys);    if (theKeys[1] &amp; 4)    return(true);  else    return(false);}/*  ---------------------------------------------------------------------------------  CmdTest    Returns whether the command (apple) key is being pressed*/static BooleanCmdTest(){  KeyMap theKeys;    GetKeys(theKeys);    if (theKeys[1] &amp; 0x8000)    return(true);  else    return(false);}/*  ---------------------------------------------------------------------------------  ShiftTest    Returns whether the shift key is being pressed*/static BooleanShiftTest(){  KeyMap theKeys;    GetKeys(theKeys);    if (theKeys[1] &amp; 1)    return(true);  else    return(false);}#define ROM85      (*(short *)0x28e)#define TWOHIGHMASK    0xc000#define COLOURQDEXISTS  !(ROM85 &amp; TWOHIGHMASK)/*  ---------------------------------------------------------------------------------  ColourQDExists    This routine is called to determine whether or not color quickdraw  exists in the current roms. It checks the lom memory global just  like Apple usually does\xC9*/BooleanColourQDExists(){  return(COLOURQDEXISTS);}/*  ---------------------------------------------------------------------------------  ColourQDIsOn    This routine is called to determine if colour quickdraw exists  in the current roms and if the main screen is displaying color.*/#define QD_MIN_FOR_COLOUR  4BooleanColourQDIsOn(){  GDHandle maindevice;  PixMapHandle mainpix;  short depth;  /*    First confirm that color is available in the roms  */  if (COLOURQDEXISTS) {    /*      Determine if the main device is displaying color    */    maindevice = GetMainDevice();    mainpix = (*maindevice)-&gt;gdPMap;        /*      Check the depth of the pixel map    */    depth = (*mainpix)-&gt;pixelSize;        if (depth &lt; QD_MIN_FOR_COLOUR)      return(false);    else      return(true);  } else    return(false);}shortColourDepth(){  GDHandle maindevice;  PixMapHandle mainpix;  /*    First confirm that color is available in the roms  */  if (COLOURQDEXISTS) {    /*      Determine if the main device is displaying color    */    maindevice = GetMainDevice();    mainpix = (*maindevice)-&gt;gdPMap;        /*      Check the depth of the pixel map    */    return (*mainpix)-&gt;pixelSize;  } else    return 1;}/*  ---------------------------------------------------------------------------------  TwitchToFinder    Switch back to Finder. Use the System 7.0 process manager if present*/static voidTwitchToFinder(){}/*  ---------------------------------------------------------------------------------  DrawTheMeter    This routine is called to draw the volume meter during sound input.*/voidDrawTheMeter(Rect *meterRect, short numElements, short *peakLevel, short *lastLevel, long *peakTimeout, short meterLevel, short redZone, RGBColor *blueRGB, RGBColor *redRGB, RGBColor *blackRGB, Boolean useColour){  Rect barRect;  short i;    PenNormal();    // quantize the meterLevel based on number of elements  // in our bar chart  if (meterLevel &gt; kMaxVolume)    meterLevel = kMaxVolume;      meterLevel = (meterLevel * numElements) / kMaxVolume;    // determine if this is a new peak value and erase the  // peak bar if it has timed out  if (meterLevel &gt;= *peakLevel) {    *peakLevel = meterLevel;    *peakTimeout = TickCount() + kPeakTimeoutTicks;   } else {    // has the current peak timed out?    if (*peakLevel &gt; 0 &amp;&amp; *peakTimeout &lt;= TickCount()) {      if (*peakLevel &gt;= *lastLevel) {              if (useColour)          RGBForeColor(blackRGB);        GetBarRect(meterRect, *peakLevel, &amp;barRect);        PaintRect(&amp;barRect);                // erase the previous element (peak is two elements wide)        if (*peakLevel &gt; 1) {      // don't erase a non-element          GetBarRect(meterRect, *peakLevel - 1, &amp;barRect);          PaintRect(&amp;barRect);        }      }      *peakLevel = 0;    }  }      // check whether the signal is now stronger than last time  if (meterLevel &gt; *lastLevel) {    for (i = *lastLevel + 1; i &lt;= meterLevel; i++) {      GetBarRect(meterRect, i, &amp;barRect);          // get the rect for this bar            if (useColour) {                  // watch out for colour        if (i &gt;= redZone)                // are we beyond the clipping point?          RGBForeColor(redRGB);            // draw in red to show distortion        else          RGBForeColor(blueRGB);            // draw in blue for normal signal        PaintRect(&amp;barRect);              // fill the element in              } else        EraseRect(&amp;barRect);              // no colour so white will have to do    }    *lastLevel = meterLevel;                // remember for next time  }      // check whether the signal level is now weaker than last time  // and if it is remove the rightmost two level bar currently on  if (meterLevel &lt; *lastLevel) {    if (*peakLevel != 0) {      if (*lastLevel == *peakLevel)        // don't erase the peak!        *lastLevel -= 2;      if (*lastLevel == *peakLevel -1)        *lastLevel -= 1;    }        if (useColour)      RGBForeColor(blackRGB);    for (i = 0; i &lt; 2; i++) {      if (*lastLevel &gt; 0) {        GetBarRect(meterRect, *lastLevel, &amp;barRect);        PaintRect(&amp;barRect);        *lastLevel -= 1;      }            if (*lastLevel &lt; 0 )        *lastLevel = 0;    }      }  if (useColour)    RGBForeColor(blackRGB);}/*  ---------------------------------------------------------------------------------  GetBarRect*/voidGetBarRect(Rect *meterRect, short whichBar, Rect *barRect){  if (whichBar == 0) {    return;  }    SetRect(barRect, meterRect-&gt;left + 2,            meterRect-&gt;top + 1,            meterRect-&gt;left + 4,            meterRect-&gt;bottom - 1);             OffsetRect(barRect, (whichBar - 1)* 3, 0);}/*  -------------------------------------------------------------------------------  InitLevelMeter*/voidInitLevelMeter(){  RGBColor **colorRsrcHndl;  OSErr err;    // load the colours used for the bar chart  colorRsrcHndl = (RGBColor **)GetResource(128, 'RGBv');  if (colorRsrcHndl) {    blueRGB = **colorRsrcHndl;    ReleaseResource((Handle)colorRsrcHndl);  } else {    blueRGB.red = 39321;    // flourescant blue    blueRGB.green = 65535;    blueRGB.blue = 65535;  }    colorRsrcHndl = (RGBColor **)GetResource(129, 'RGBv');  if (colorRsrcHndl) {    redRGB = **colorRsrcHndl;    ReleaseResource((Handle)colorRsrcHndl);  } else {    redRGB.red = 65535;      // peak level red    redRGB.green = 0;    redRGB.blue = 0;  }    blackRGB.red = 0;  blackRGB.green = 0;  blackRGB.blue = 0;    gMeterRect = gLevelWindow-&gt;portRect;  InsetRect(&amp;gMeterRect, 2, 2);    gNumElements = (gMeterRect.right - gMeterRect.left - 2) / 3;  if (gNumElements &gt; 255)    gNumElements = 255;  gPeakTimeOut = 0;  gPeakLevel = 0;  gLastLevel = 0;  gRedZone = (gNumElements * 2) / 3;  // open the sound input device  err = OpenTheSoundDevice();}// watch out for other usages of the soundInputRefNumstatic voidCloseLevelMeter(){  OSErr err;    err = SPBCloseDevice(gSoundInputRefNum);  gSoundInputRefNum = 0;}#define kAboutDLOG      128#define kAboutMeterItem    4short  gAboutPeakLevel;short  gAboutLastLevel;long  gAboutPeakTimeOut;voidDoAbout(){  DialogPtr dialog;  short itemHit;  GrafPtr savePort;  ModalFilterUPP aboutFilterProcUPP;    /* create a UPP for our modal dialog filter */  aboutFilterProcUPP = NewModalFilterProc(AboutFilterProc);    GetPort(&amp;savePort);  dialog = GetNewDialog(kAboutDLOG, nil, (WindowPtr)-1);  SetPort(dialog);    // *** force an update event first  UpdateAboutDialog((WindowPtr)dialog);    gAboutPeakLevel = 0;  gAboutLastLevel = 0;  gAboutPeakTimeOut = 0;    do {    ModalDialog(aboutFilterProcUPP, &amp;itemHit);  } while (itemHit != ok);    SetPort(savePort);  DisposeDialog(dialog);    DisposeRoutineDescriptor(aboutFilterProcUPP);}OSErr OpenTheSoundDevice(){  OSErr err;  short meterState;    // set the default zone to the system heap so that the SI manager will  // possibly get fooled into allocating there instead of my heap    SetZone(SystemZone());  err = SPBOpenDevice(nil, siWritePermission, &amp;gSoundInputRefNum);  if (err != noErr)     goto BailOut;      // turn on sound metering  meterState = 1;        // turn it on  err = SPBSetDeviceInfo(gSoundInputRefNum, siLevelMeterOnOff, (char *)&amp;meterState);BailOut:  SetZone(ApplicationZone());    return err;}voidDrawOneBar(Rect *meterRect, short whichBar, Boolean useColour){  Rect barRect;    GetBarRect(meterRect, whichBar, &amp;barRect);      // get the rect for this bar    if (useColour) {                  // watch out for colour    if (whichBar &gt;= gRedZone)            // are we beyond the clipping point?      RGBForeColor(&amp;redRGB);            // draw in red to show distortion    else      RGBForeColor(&amp;blueRGB);            // draw in blue for normal signal    PaintRect(&amp;barRect);              // fill the element in      } else    EraseRect(&amp;barRect);              // no colour so white will have to do}/*  ---------------------------------------------------------------------------------  AboutFilterProc  */#define CRKey      0x0d#define EnterKey     0x03#define EscapeKey    0x1bpascal BooleanAboutFilterProc(DialogPtr dialog, EventRecord *event, short *item){  unsigned char theKey;  WindowPtr window;  short itemType;  Handle itemHndl;  Rect itemRect;  OSErr err;  short recordingStatus = 0;            // status of recording session  short meterLevel = 0;              // current meter level  unsigned long totalSamplesToRecord = 0;      // total number of samples  unsigned long numberOfSamplesRecorded = 0;    // number of samples recorded  unsigned long totalMsecsToRecord;  unsigned long numberOfMsecsRecorded;      /* get the sound input status  */  if (event-&gt;what != updateEvt) {    err = SPBGetRecordingStatus(gSoundInputRefNum,                  &amp;recordingStatus,                  &amp;meterLevel,                  &amp;totalSamplesToRecord,                  &amp;numberOfSamplesRecorded,                  &amp;totalMsecsToRecord,                  &amp;numberOfMsecsRecorded);             GetDialogItem(dialog, kAboutMeterItem, &amp;itemType, &amp;itemHndl, &amp;itemRect);    InsetRect(&amp;itemRect, 2, 2);        SetPort(dialog);        DrawTheMeter(&amp;itemRect,              gNumElements,              &amp;gAboutPeakLevel,              &amp;gAboutLastLevel,              &amp;gAboutPeakTimeOut,              meterLevel,             gRedZone,             &amp;blueRGB,             &amp;redRGB,             &amp;blackRGB,             gUseColour);                 // check for nearly maximum volume to dismiss dialog;    if (meterLevel &gt; 250) {      HiliteItem(dialog, ok);      *item = ok;      return true;    }      }    switch(event-&gt;what) {    case mouseDown:      break;    case keyDown:    case autoKey:      theKey = event-&gt;message &amp; charCodeMask;            if (theKey == CRKey || theKey == EnterKey || theKey == EscapeKey) {        HiliteItem(dialog, ok);        *item = ok;        return true;      }                  break;    case updateEvt:      window = (WindowPtr)event-&gt;message;      if (window == (WindowPtr)dialog) {        UpdateAboutDialog(window);      }      break;    default:      break;  }  return false;}voidUpdateAboutDialog(WindowPtr window){  GrafPtr savePort;  short itemType;  Handle itemHndl;  Rect itemRect;    BeginUpdate(window);  GetPort(&amp;savePort);  SetPort(window);    UpdateDialog((DialogPtr)window, window-&gt;visRgn);    PenNormal();  GetDialogItem((DialogPtr)window, kAboutMeterItem, &amp;itemType, &amp;itemHndl, &amp;itemRect);  FrameRect(&amp;itemRect);  InsetRect(&amp;itemRect, 2, 2);  PaintRect(&amp;itemRect);    SetPort(savePort);  EndUpdate(window);}/*  ---------------------------------------------------------------------------------  HiliteItem    This routine will hilite the given item control so the user knows  which item has been activated by the  key equivalent*/#define ButtonInvertState  10    // inverted state for push buttons#define CheckRadioState    11    // inverted state for checks and radios#define NormalState      0    // non-inverted state#define SleepDuration    10    // pause for 10 ticksvoidHiliteItem(DialogPtr dialog, short theitem){  Handle thehndl;  short thetype;  Rect thebox;  unsigned long junkTicks;  short hiliteState;    /*    Get Handle to the item  */  GetDialogItem(dialog, theitem, &amp;thetype, &amp;thehndl, &amp;thebox);    switch (thetype) {    case btnCtrl + ctrlItem:      hiliteState = ButtonInvertState;      break;    case chkCtrl + ctrlItem:    case radCtrl + ctrlItem:      hiliteState = CheckRadioState;      break;    default:      return;      break;  }  /*    Invert the control for a little while  */  HiliteControl((ControlHandle)thehndl, hiliteState);  Delay(SleepDuration, &amp;junkTicks);  HiliteControl((ControlHandle)thehndl, NormalState);}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/SoundLevel/listing1.html%3Fid%3DDTS10000373-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/SoundLevel/listing1.html%3Fid%3DDTS10000373-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/SoundLevel/listing1.html%3Fid%3DDTS10000373-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>