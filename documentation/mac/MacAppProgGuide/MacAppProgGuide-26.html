<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Dependencies (MacApp PG)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING26></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="MacAppProgGuide-25.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-27.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="MacAppProgGuide-2.html"><B>Programmer's Guide to MacApp</B></A> / <A HREF="MacAppProgGuide-21.html"><B>Part 1 - MacApp Theory and Architecture</B></A><BR><DD><A HREF="MacAppProgGuide-25.html"><B>Chapter 3 - Core Technologies</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING26-0></A>
<H1><A NAME=MARKER-9-22></A><A NAME=MARKER-2-23></A><A NAME=MARKER-9-24></A><A NAME=MARKER-2-25></A>Dependencies</H1>
 MacApp provides a dependency mechanism that allows objects to be registered as dependents of other objects and to be notified of changes in the objects on which they depend. Dependency management can be useful in many situations, including synchronization of multiple views of the same data and handling of complicated interactions between the controls in a dialog box.<P>
 An object that has one or more dependent objects is called a <B><A NAME=MARKER-2-26></A>notifier.</B> When a notifier changes, it informs its dependent object(s) of the change. An object that has been registered as depending on another object is called a <B><A NAME=MARKER-2-27></A>dependent.</B> A dependent is notified of changes in the object on which it depends.<P>
 An object can have multiple dependents and multiple notifiers, and one object can be both a notifier and a dependent.<P>
 The following sections describe<P>
<UL>
<LI>how to perform basic operations on dependencies
<LI>how to store dependency relationships
<LI>how to establish and remove dependencies
<LI>how to iterate over an object's dependents and notifiers
<LI>how command objects perform change notification
<LI>how MacApp's dependency-updating algorithm works<P>
</UL>
 <A HREF=MacAppProgGuide-131.html#MARKER-9-22>Figure 26-1 on page 587</A> shows some of the classes and methods that provide dependency support in MacApp. <P>
<A NAME=HEADING26-12></A>
<H2><A NAME=MARKER-9-28></A>Basic Operations on Dependencies</H2>
 As a user of the dependency system, your application only needs to know about four basic dependency operations, each of which is supported by a method of the <CODE>TObject</CODE> class:<P>
<UL>
<LI><B>Adding a dependent.</B> You call <CODE>objectOne-&gt;AddDependent(objectTwo)</CODE> to establish a dependency relationship between <CODE>objectOne</CODE> and <CODE>objectTwo</CODE>. After the call, <CODE>objectTwo</CODE> becomes a dependent of <CODE>objectOne</CODE> and <CODE>objectOne</CODE> becomes a notifier with regard to <CODE>objectTwo</CODE>.<P>
For example, a view class may call <CODE>AddDependent</CODE> in its <CODE>DoPostCreate</CODE> method to make the view a dependent of its document object:<P>
<pre>fDocument-&gt;AddDependent(this);</pre>
<LI><B>Removing a dependent.</B> You call <CODE>objectOne-&gt;RemoveDependent(objectTwo)</CODE> to remove the dependency relationship between <CODE>objectOne</CODE> and <CODE>objectTwo</CODE>.
<LI><B>Informing an object it has changed.</B> You call <CODE>objectOne-&gt;Changed(...)</CODE> to tell <CODE>objectOne</CODE> that it has changed and should notify its dependents. When the <CODE>Changed</CODE> method of an object is called, its dependents are notified by having their <CODE>DoUpdate</CODE> method called.
<LI><B>Responding to a change notification.</B> You define an override method <I>TYourClass<CODE>::DoUpdate</CODE></I> to respond to changes in a notifier. (As a result, <CODE>objectTwo::DoUpdate</CODE> responds to notification by <CODE>objectOne</CODE>.)<P>
</UL>
 For more information on the dependency-related methods of the <CODE>TObject</CODE> class, see <A HREF=MacAppProgGuide-24.html#MARKER-9-72>"Dependency Relationships," beginning on page 38</A>.<P>
<A NAME=HEADING26-21></A>
<H2><A NAME=MARKER-9-29></A>Storing Dependency Relationships</H2>
 A <B><A NAME=MARKER-2-30></A>dependency space</B> stores dependency relationships between objects and encapsulates a mechanism for notifying dependent objects when an object changes. MacApp defines <CODE>TDependencySpace</CODE> as an abstract superclass for dependency spaces and defines two subclasses, <CODE>TSimpleDependencySpace</CODE> and <CODE>TStandardDependencySpace.</CODE> These classes are discussed in more detail in <A HREF=#MARKER-9-39>"Updating Algorithms," beginning on page 47</A>.<P>
 <A NAME=MARKER-2-31></A>By default, a MacApp application has one dependency space, referenced by the global variable <CODE><A NAME=MARKER-2-32></A>gMacAppDependencies</CODE>. This instance is created in the <CODE>TApplication</CODE> method <CODE>DoMakeDependencySpace</CODE> and defaults to an object of type <CODE>TStandardDependencySpace</CODE>. The default dependency space can be accessed using the method<A NAME=MARKER-2-33></A> <CODE>TObject::GetDependencySpace</CODE>.<P>
<A NAME=HEADING26-24></A>
<H2><A NAME=MARKER-9-34></A>Establishing and Removing Dependencies</H2>
 A dependency can be established between two objects by calling the <CODE>AddDependent</CODE> method of the object that is to be the notifier or by directly calling the <CODE>AddDependency</CODE> method of the dependency space (normally <CODE>gMacAppDependencies</CODE>).<P>
 A dependency between two objects can be removed by calling the <CODE>RemoveDependent</CODE> method of the object that is the notifier or by directly calling the <CODE>RemoveDependency</CODE> method of the appropriate dependency space (normally <CODE>gMacAppDependencies</CODE>).<P>
 The <CODE>TObject</CODE> class supplies methods for removing all dependencies involving a given object as either a notifier or a dependent. For example, the <CODE>Free</CODE> method of <CODE>TObject</CODE> calls the <CODE><A NAME=MARKER-2-35></A>RemoveDependenciesOnFree</CODE> method and, if that method returns <CODE>TRUE</CODE>, calls <A NAME=MARKER-2-36></A><CODE>RemoveAllDependencies</CODE>. The <CODE>RemoveAllDependencies</CODE> method removes all dependency relationships that involve the freed object, either as a notifier or as a dependent, from the object's default dependency space.<P>
 As a performance optimization, <CODE>RemoveDependenciesOnFree</CODE> can be overridden to return <CODE>FALSE</CODE> for objects that are never involved in dependency relationships. MacApp does this for its frequently allocated <CODE>TToolboxEvent</CODE> objects.<P>
<A NAME=HEADING26-29></A>
<H2><A NAME=MARKER-9-37></A>Iterating Over Dependents and Notifiers</H2>
 MacApp provides the iterator classes <CODE>CDependentIterator</CODE> and <CODE>CNotifierIterator</CODE> for iterating over the dependents or notifiers of a given object. The constructors of these iterators take a dependency space as an argument. For an example of how iterators are used, see <A HREF=MacAppProgGuide-127.html#MARKER-9-19>Chapter 25, "Working With Lists and Iteration."</A><P>
<A NAME=HEADING26-31></A>
<H2><A NAME=MARKER-9-38></A>Change Notification and Command Objects</H2>
 MacApp uses its dependency notification mechanism when performing commands. A command-handler object's <CODE>DoPerformCommand</CODE> method calls the command's <CODE>DoIt</CODE> method, then calls the command's <CODE>DoNotification</CODE> method.<CODE> </CODE>The <CODE>TUndoRedoCommand::DoIt</CODE> method also calls the command's <CODE>DoNotification</CODE> method, so notification takes place for undo and redo as well.<P>
 When you initialize a command object, you pass it a reference to an object to notify and the <CODE>fObjectToNotify</CODE> field is set to this reference. The <CODE>DoNotification</CODE> method of the <CODE>TCommand</CODE> class calls <CODE>fObjectToNotify-&gt;Changed</CODE>, passing a change ID obtained from the command object. This process gives the command the opportunity to notify its dependents. The default change ID passed is either the command number or <CODE>cUndo</CODE>.<CODE></CODE><P>
 For example, when the object to be notified by the command is a document object, the <CODE>Changed</CODE> method of the <CODE>TDocument</CODE> class adjusts the document object's change count, and calls <CODE>Inherited::Changed</CODE> to notify dependents.<P>
<A NAME=HEADING26-35></A>
<H2><A NAME=MARKER-9-39></A>Updating Algorithms</H2>
 Your application informs an object that it has changed by calling its <CODE>Changed</CODE> method or by calling the <CODE>NotifierChanged</CODE> method of a dependency space. The <CODE>Changed</CODE> method of <CODE>TObject</CODE> calls the <CODE>NotifierChanged</CODE> method of the object's default dependency space. <P>
 The updating algorithm for MacApp's dependency mechanism is encapsulated in the <CODE>NotifierChanged</CODE> method of a dependency space. The key to this algorithm is that the <CODE>DoUpdate</CODE> method of each dependent object is called.<P>
 Your application can control the updating algorithm by specifying the type of dependency space used: <CODE>TSimpleDependencySpace</CODE>, <CODE>TStandardDependencySpace</CODE>, or a subclass of your own. MacApp's default dependency space is an object of type <CODE>TStandardDependencySpace</CODE>. To change the dependency space, you override the <CODE>TApplication</CODE> method <CODE>DoMakeDependencySpace</CODE>.<P>
<A NAME=HEADING26-39></A>
<H3><A NAME=MARKER-2-40></A>TSimpleDependencySpace</H3>
 The simplest approach to notifying dependents of changes in their notifiers is to call the <CODE>DoUpdate</CODE> method of each immediate dependent of an object that changes. To propagate the update notification to dependents of dependents, objects would have to explicitly call <CODE>Changed</CODE> in their overrides of <CODE>DoUpdate</CODE>. Suppose object A has dependents B and C, which each have object D as a dependent, as shown in <A HREF=#MARKER-9-41>Figure 3-1</A>.<P>
<B>Figure 3-1  <A NAME=MARKER-9-41></A>Dependency relationship</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/MacApp_PG-L-015.gif"><P>
 Calling the <CODE>Changed</CODE> method of object A results in a call to the <CODE>DoUpdate</CODE> method of each of its dependents, object B and object C. Object B and object C must in turn call <CODE>this-&gt;Changed</CODE> to notify object D.<P>
 An advantage of this approach is that the algorithm is reentrant--you can call <CODE>Changed</CODE> from code that is called by <CODE>DoUpdate</CODE>. However, a disadvantage is that it can be inefficient: since there are multiple paths from object A to object D, object D gets two <CODE>DoUpdate</CODE> calls. In more complicated dependency graphs, numerous unnecessary updates of the same object can occur. Another disadvantage of this approach is that a cycle in the dependency relationship (for example, object A depends on object B, B depends on C, and C depends on A) will lead to an infinite loop of <CODE>DoUpdate</CODE> calls.<P>
<A NAME=HEADING26-45></A>
<H3><A NAME=MARKER-2-42></A>TStandardDependencySpace</H3>
 In the <CODE>TStandardDependencySpace</CODE> class, MacApp uses a "mark and sweep" algorithm that avoids the multiple-update problem and also works well with dependency graphs that contain cycles.<P>
 The <CODE>TStandardDependencySpace</CODE> algorithm has two phases, as can be seen by examining the <CODE>TStandardDependencySpace</CODE> implementation of <CODE>NotifierChanged</CODE>. The first phase recursively marks both direct and indirect dependents of the changed object as needing updating. In our example, objects B, C, and D would all be marked when A changes. In the second phase, each object with notifiers is examined. If an object is marked as needing updating, its <CODE>DoUpdate</CODE> method will be called after the algorithm has ensured that the <CODE>DoUpdate</CODE> method of all notifiers has been called. Once an object is updated it is unmarked, so that <CODE>DoUpdate</CODE> is never called more than once for each object.<P>
 This algorithm may add unnecessary overhead if your dependency space is a simple one with few multiple paths and no danger of cycles. However, it can be more efficient for complicated dependency spaces with many multiple paths.<P>
<A NAME=HEADING26-49></A>
<H3><A NAME=MARKER-2-43></A><A NAME=MARKER-9-44></A>Marking Objects</H3>
 Some updating algorithms, like that of <CODE>TStandardDependencySpace</CODE>, require the ability to mark objects that need updating. The <CODE>TStandardDependencySpace</CODE> class has its own storage and methods for marking objects during updating. These should be adequate in most cases.<P>
 Your application can associate a label with a dependency and use that label for its own purposes. The <CODE>TStandardDependencySpace</CODE> class doesn't interpret your label but does flip the sign to mark the object during updating. Use the constant <CODE>kNoLabel</CODE> if you don't need to use the label.<P>
<A NAME=HEADING26-52></A>
<H3>Dependency Space Data Structures</H3>
 For a dependency system to have acceptable performance, an object must be able to iterate quickly over its dependents and notifiers. And while it is useful to have dependency methods in <CODE>TObject</CODE>, it is preferable to avoid any storage overhead in <CODE>TObject</CODE> itself.<P>
 To achieve these goals, dependency relationships are stored as fields of <CODE>TSimpleDependencySpace</CODE> in two sorted dynamic arrays. (These same arrays are used by <CODE>TStandardDependencySpace</CODE>, a subclass of <CODE>TSimpleDependencySpace</CODE>.) Each element in each of these arrays stores a notifier/dependent relationship. One array is sorted by notifier, and the other by dependent. For the dependency relationship shown in <A HREF=#MARKER-9-41>Figure 3-1</A>, the two arrays would appear as shown in <A HREF=#MARKER-9-2>Table 3-1</A> and <A HREF=#MARKER-9-1>Table 3-2</A>. Note that the label fields are not currently used by MacApp.
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><A NAME=MARKER-9-2></A><B>Table 3-1 Notifier/dependent array</B></CAPTION>
<TH>Notifier<TH>Dependent<TH>Label<TR>
<TD>A<TD>B<TD>--<TR>
<TD>B <TD>D<TD>--<TR>
<TD>C <TD>D<TD>--</TABLE>

<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><A NAME=MARKER-9-1></A><B>Table 3-2 Dependent/notifier array</B></CAPTION>
<TH>Dependent<TH>Notifier<TH>Label<TR>
<TD>B<TD>A<TD>--<TR>
<TD>C<TD>A<TD>--<TR>
<TD>D<TD>B<TD>--<TR>
<TD>D<TD>C<TD>--</TABLE>
<P>
 To iterate over the dependents of an object, MacApp does a binary search for the object in the notifier/dependent array. This finds the location of an entry somewhere in the cluster of entries with the given object as notifier. MacApp then iterates backward to find the beginning of the cluster, then iterates forward from there (these are linear searches). To iterate over the notifiers of a given object, MacApp does the same thing with the dependent/notifier array. <P>
 Each entry in the arrays includes a long integer label field. It's conceivable that <CODE>TSimpleDependencySpace</CODE> could be used more generally for graph structures, with the label field used as an edge type. MacApp currently makes no use of the labels, except for <CODE>TStandardDependencySpace</CODE>, where the label's sign is flipped to indicate marking.<P>
 Although there is redundant storage of information in these tables, each dependency relationship takes only 24 bytes, so it should be possible to conveniently store hundreds of dependencies.<A NAME=MARKER-2-45></A><P>

</BLOCKQUOTE>
<HR>
<center>
<A HREF="MacAppProgGuide-25.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-27.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="MacAppProgGuide-3.html">&copy; Apple Computer, Inc.</A><br>25 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
