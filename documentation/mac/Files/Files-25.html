<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Writing File Data (IM: F)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING25></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Files-24.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Files-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Files-390.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Files-26.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Files-2.html"><B>Files</B></A> / <BR><DD><A HREF="Files-12.html"><B>Chapter 1 - Introduction to File Management</B></A> / <A HREF="Files-19.html"><B>Using Files</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING25-0></A>
<H2>Writing File Data</H2>
 <A NAME=MARKER-2-159></A>Generally your application writes data to a file in response to the File menu commands Save or Save As. However, your application might also incorporate a scheme that automatically saves all open documents to disk every few minutes. It therefore makes sense to isolate the routines that handle the menu commands from the routines that handle the actual writing of data to disk. This section shows how to write the data stored in a TextEdit record to a file. See <A HREF=Files-26.html#MARKER-9-169>"Saving a File" on page 1-26</A> for instructions on handling the Save and Save As menu commands.<P>
 It is very easy to write data from a specified buffer into a specified file. You simply position the file mark at the beginning of the file (using <CODE>SetFPos</CODE>), write the data into the file (using <CODE>FSWrite</CODE>), and then resize the file to the number of bytes actually written (using <CODE>SetEOF</CODE>). <A HREF=#MARKER-9-160>Listing 1-9</A> illustrates this sequence.<P>
<B>Listing 1-9  <A NAME=MARKER-9-160></A>Writing data into a file</B><P>
<PRE>
FUNCTION DoWriteData (myWindow: WindowPtr; myTemp: Integer): OSErr;
VAR
   myData:     MyDocRecHnd;            {handle to a document record}
   myLength:   LongInt;                {number of bytes to write to file}
   myText:     TEHandle;               {handle to TextEdit record}
   myBuffer:   Handle;                 {handle to actual text in TERec}
   myVol:      Integer;                {volume reference number of myFile}
   myErr:      OSErr;
BEGIN
   myData := MyDocRecHnd(GetWRefCon(myWindow)); {get window's data record}
   myText := myData^^.editRec;                  {get TERec}
   myBuffer := myText^^.hText;                  {get text buffer}
   myLength := myText^^.teLength;               {get text buffer size}

   myErr := SetFPos(myTemp, fsFromStart, 0);    {set file mark at start}
   IF myErr = noErr THEN                        {write buffer into file}
      myErr := FSWrite(myTemp, myLength, myBuffer^);
   IF myErr = noErr THEN                        {adjust file size}
      myErr := SetEOF(myTemp, myLength);
   IF myErr = noErr THEN                        {find volume file is on}
      myErr := GetVRefNum(myTemp, myVol);
   IF myErr = noErr THEN                        {flush volume}
      myErr := FlushVol(NIL, myVol);
   IF myErr = noErr THEN                        {show file is up to date}
      myData^^.windowDirty := FALSE;
   DoWriteData := myErr;
END;
</PRE>
 The <CODE>DoWriteData</CODE> function first retrieves the TextEdit record attached to the specified window and extracts the address and length of the actual text buffer from that record. Then it calls <CODE>SetFPos</CODE>, <CODE>FSWrite</CODE>, and <CODE>SetEOF</CODE> as just explained. Finally, <CODE>DoWriteData</CODE> determines the volume containing the file (using the <CODE>GetVRefNum</CODE> function) and flushes that volume (using the <CODE>FlushVol</CODE> function). This is necessary to ensure that both the file's data and the file's catalog entry are updated.<P>
 Notice that the <CODE>DoWriteData</CODE> function takes a second parameter, <CODE>myTemp</CODE>, which should be the file reference number of a temporary file, not the file reference number of the file associated with the window whose data you want to write. If you pass the reference number of the file associated with the window, you risk corrupting the file, because the existing file data is overwritten when you position the file mark at the beginning of the file and call <CODE>FSWrite</CODE>. If <CODE>FSWrite</CODE> does not complete successfully, it is very likely that the file on disk does not contain the correct document data.<P>
 To avoid corrupting the file containing the saved version of a document, always call <CODE>DoWriteData</CODE> specifying the file reference number of some new, temporary file. Then, when <CODE>DoWriteData</CODE> completes successfully, you can call the <CODE>FSpExchangeFiles</CODE> function to swap the contents of the temporary file and the existing file. <A HREF=#MARKER-9-163>Listing 1-10</A> illustrates how to update a file on disk safely; it shows a sequence of updating, renaming, saving, and deleting files that preserves the contents of the existing file until the new version is safely recorded. <P>
<B>Listing 1-10  <A NAME=MARKER-9-163></A>Updating a file safely</B><P>
<PRE>
FUNCTION DoWriteFile (myWindow): OSErr;
VAR
   myData:     MyDocRecHnd;   {handle to window's document record}
   myFSpec:    FSSpec;        {FSSpec for file to update}
   myTSpec:    FSSpec;        {FSSpec for temporary file}
   myTime:     LongInt;       {current time; for temporary filename}
   myName:     Str255;        {name of temporary file}
   myTemp:     Integer;       {file reference number of temporary file}
   myVRef:     Integer;       {volume reference number of temporary file}
   myDirID:    LongInt;       {directory ID of temporary file}
   myErr:      OSErr;
BEGIN
   myData := MyDocRecHnd(GetWRefCon(myWindow));{get that window's data}
   myFSpec := myData^^.fileFSSpec;           {get FSSpec for existing file}

   GetDateTime(myTime);                      {create a temporary filename}
   NumToString(myTime, myName);

   {Find the temporary folder on file's volume; create it if necessary.}
   myErr := FindFolder(myFSpec.vRefNum, kTemporaryFolderType,
                        kCreateFolder, myVRef, myDirID);
   IF myErr = noErr THEN                     {make an FSSpec for temp file}
      myErr := FSMakeFSSpec(myVRef, myDirID, myName, myTSpec);
   IF (myErr = noErr) OR (myErr = fnfErr) THEN{create a temporary file}
      myErr := FSpCreate(myTSpec, 'trsh', 'trsh', smSystemScript);
   IF myErr = noErr THEN                     {open the newly created file}
      myErr := FSpOpenDF(myTSpec, fsRdWrPerm, myTemp);
   IF myErr = noErr THEN                     {write data to the data fork}
      myErr := DoWriteData(myWindow, myTemp);
   IF myErr = noErr THEN                     {close the temporary file}
      myErr := FSClose(myTemp);
   IF myErr = noErr THEN                     {swap data in the two files}
      myErr := FSpExchangeFiles(myTSpec, myFSpec);
   IF myErr = noErr THEN                     {delete the temporary file}
      myErr := FSpDelete(myTSpec);
   DoWriteFile := myErr;
END;
</PRE>
 The essential idea behind this "safe-save" process is to save the data in memory into a new file and then to exchange the contents of the new file and the old version of the file by calling <CODE>FSpExchangeFiles</CODE>. The <CODE>FSpExchangeFiles</CODE> function does not move the data on the volume; it merely changes the information in the volume's catalog file and, if the files are open, in their file control blocks (FCBs). The catalog entry for a file contains<P>
<UL>
<LI>fields that describe the physical data, such as the first allocation block, physical end, and logical end of both the resource and data forks
<LI>fields that describe the file within the file system, such as file ID and parent <BR>directory ID<P>
</UL>
 Fields that describe the data remain with the data; fields that describe the file remain with the file. The creation date remains with the file; the modification date remains with the data. (For a more complete description of the <CODE>FSpExchangeFiles</CODE> function, see the chapter "File Manager" in this book.)<A NAME=MARKER-2-164></A><A NAME=MARKER-2-165></A><A NAME=MARKER-2-166></A><A NAME=MARKER-2-167></A><A NAME=MARKER-2-168></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Files-24.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Files-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Files-390.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Files-26.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Files-3.html">&copy; Apple Computer, Inc.</A><br>2 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
