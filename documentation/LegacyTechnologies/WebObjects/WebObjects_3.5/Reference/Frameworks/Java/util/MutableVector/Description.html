<html>

<body bgcolor="#FFFFFF">

<CENTER><H1>Class next.util.MutableVector</H1></CENTER>

<a name="description"></a><CENTER><H2>CLASS DESCRIPTION</H2></CENTER>

<!-- extends:next.util.ImmutableVector -->

<DL>

<DT><B>Extends:</B></DT><DD>next.util.ImmutableVector</DD>

</DL>

<P>

The MutableVector class declares the programmatic interface to objects that manage a modifiable array of objects. This class adds insertion and deletion operations to the basic array-handling behavior inherited from ImmutableVector. 
MutableVector methods are conceptually based on these primitive methods:
<UL>
addElement<BR>
replaceRange
</UL>
The other methods in its interface provide convenient ways of inserting an object into a specific slot in the array and removing an object based on its identity or position in the array.
<H3>
A Note for Those Creating Subclasses of MutableVector
</H3>
Although conceptually the MutableVector class has three primitive methods, two others also access the array's data directly. These methods are:
<UL>
insertElementAt<BR>
removeElementAt
</UL>
These methods could be implemented using the primitives listed above but doing so would incur unnecessary overhead. For instance, objects would receive retain and release messages as they were shifted to accommodate the insertion or deletion of an element. 
<hr>

</body>

</html><html>

<body bgcolor="#FFFFFF"><!-- constructors -->

<a name="constructors"><CENTER><H2>CONSTRUCTORS</H2></CENTER></a>

<!-- consKey:MutableVector(public) cons:MutableVector descr:<TT>public  <B>MutableVector</B>(java.lang.Object[] <I>objects</I>)</TT>:<TT>public  <B>MutableVector</B>(java.util.Vector <I>aVector</I>)</TT>:<TT>public  <B>MutableVector</B>()</TT> -->

<H3><a name="MutableVector(public)">MutableVector</a></H3>

<TT>public  <B>MutableVector</B>()</TT><br>

<TT>public  <B>MutableVector</B>(java.lang.Object[] <I>objects</I>)</TT><br>

<TT>public  <B>MutableVector</B>(java.util.Vector <I>aVector</I>)</TT>

<P>

Initializes a newly allocated vector. After an immutable vector has been initialized, it can't be modified.
<P>
If <I>objects</I> are supplied, the vector is initialized by placing in it the objects contained in <I>objects</I>.
<P>
If <I>aVector</I> is supplied, the vector is initialized by placing in it the objects contained in the Java vector specified by <I>aVector</I>.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

</body>

</html><html>

<body bgcolor="#FFFFFF"><!-- methods -->

<a name="methods"><CENTER><H2>METHODS</H2></CENTER></a>

<!-- methKey:addElement(public) meth:addElement descr:<TT>public void <B>addElement</B>(java.lang.Object <I>anObject</I>)</TT> -->

<H3><a name="addElement(public)">addElement</a></H3>

<TT>public void <B>addElement</B>(java.lang.Object <I>anObject</I>)</TT>

<P>

Inserts <I>anObject</I> at the end of the receiver. If <I>anObject</I> is <B>nil</B>, an exception is raised.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:addElements(public) meth:addElements descr:<TT>public void <B>addElements</B>(next.util.ImmutableVector <I>anImmutableVector</I>)</TT> -->

<H3><a name="addElements(public)">addElements</a></H3>

<TT>public void <B>addElements</B>(next.util.ImmutableVector <I>anImmutableVector</I>)</TT>

<P>

Adds the objects contained in <I>anImmutableVector</I> to the end of the receiver's array of objects.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:ensureCapacity(public) meth:ensureCapacity descr:<TT>public void <B>ensureCapacity</B>(int <I>anInt</I>)</TT> -->

<H3><a name="ensureCapacity(public)">ensureCapacity</a></H3>

<TT>public void <B>ensureCapacity</B>(int <I>count</I>)</TT>

<P>

Ensures that the receiver is large enough to contain the number of elements specified by <I>count</I>.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:insertElementAt(public) meth:insertElementAt descr:<TT>public void <B>insertElementAt</B>(java.lang.Object <I>anObject</I>, int <I>anInt</I>)</TT> -->

<H3><a name="insertElementAt(public)">insertElementAt</a></H3>

<TT>public void <B>insertElementAt</B>(java.lang.Object <I>anObject</I>, int <I>index</I>)</TT>

<P>

Inserts <I>anObject</I> into the receiver at <I>index</I>. If <I>index</I> is already occupied, the objects at <I>index</I> and beyond are shifted down one slot to make room. <I>index</I> cannot be greater than the number of elements in the vector. This method raises an exception if <I>anObject</I> is <B>nil</B> and raises an exception if <I>index</I> is greater than the number of elements in the vector.
<P>
Note that MutableVectors are not like C arrays. That is, even though you do an "ensureCapacity," the specified capacity is regarded as a "hint"; the actual size of the vector is still 0. Because of this, you can only insert new objects in ascending order-with no gaps. Once you add two objects, the vector's size is 2, so you can add objects at indexes 0, 1, or 2. Index 3 is illegal and out of bounds; if you try to add an object at index 3 (when the size of the vector is 2), MutableVector raises an exception.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:removeAllElements(public) meth:removeAllElements descr:<TT>public void <B>removeAllElements</B>()</TT> -->

<H3><a name="removeAllElements(public)">removeAllElements</a></H3>

<TT>public void <B>removeAllElements</B>()</TT>

<P>

Empties the receiver of all its elements.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:removeElement(public) meth:removeElement descr:<TT>public boolean <B>removeElement</B>(java.lang.Object <I>anObject</I>)</TT> -->

<H3><a name="removeElement(public)">removeElement</a></H3>

<TT>public boolean <B>removeElement</B>(java.lang.Object <I>anObject</I>)</TT>

<P>

Removes the first occurrence of <I>anObject</I> in the vector. This method uses <B>indexOf</B> to locate a match, and then removes it by using <B>removeElementAt</B>.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:removeElementAt(public) meth:removeElementAt descr:<TT>public void <B>removeElementAt</B>(int <I>anInt</I>)</TT> -->

<H3><a name="removeElementAt(public)">removeElementAt</a></H3>

<TT>public void <B>removeElementAt</B>(int <I>index</I>)</TT>

<P>

Removes the object at <I>index</I> and moves all elements beyond <I>index</I> up one slot to fill the gap. This method raises an exception if <I>index</I> is beyond the end of the vector.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:removeElements(public) meth:removeElements descr:<TT>public void <B>removeElements</B>(next.util.ImmutableVector <I>anImmutableVector</I>)</TT> -->

<H3><a name="removeElements(public)">removeElements</a></H3>

<TT>public void <B>removeElements</B>(next.util.ImmutableVector <I>anImmutableVector</I>)</TT>

<P>

This method is similar to <B>removeElement</B>, but allows you to efficiently remove large sets of objects with a single operation.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:replaceRange(protected) meth:replaceRange descr:<TT>protected void <B>replaceRange</B>(int <I>anInt</I>, int <I>anInt</I>, java.lang.Object <I>anObject</I>)</TT> -->

<H3><a name="replaceRange(protected)">replaceRange</a></H3>

<TT>protected void <B>replaceRange</B>(int <I>start</I>, int <I>length</I>, java.lang.Object <I>anObject</I>)</TT>

<P>

Removes <I>length</I> objects from the receiver (beginning with the object at index <I>start</I>) and inserts a single copy of <I>anObject</I> in their place.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:setSize(public) meth:setSize descr:<TT>public void <B>setSize</B>(int <I>anInt</I>)</TT> -->

<H3><a name="setSize(public)">setSize</a></H3>

<TT>public void <B>setSize</B>(int <I>size</I>)</TT>

<P>

If <I>size</I> is less than the number of elements in the receiver, a sufficient number of objects is removed from the end of the vector so that the size of the vector is equal to <I>size</I>. This method does nothing if the vector already has fewer elements than are specified by <I>size</I>.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:sortUsingMethod(public) meth:sortUsingMethod descr:<TT>public void <B>sortUsingMethod</B>(java.lang.String <I>aString</I>)</TT> -->

<H3><a name="sortUsingMethod(public)">sortUsingMethod</a></H3>

<TT>public void <B>sortUsingMethod</B>(java.lang.String <I>comparator</I>)</TT>

<P>

Sorts the receiver's elements in ascending order, as determined by the comparison method named by <I>comparator</I>. The <I>comparator</I> message is sent to each object in the vector, and has as its single argument another object in the vector. The <I>comparator</I> method is used to compare two elements at a time and should return -1 if the receiver is smaller than the argument, 1 if the receiver is larger than the argument, and 0 if they are equal.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:trimToSize(public) meth:trimToSize descr:<TT>public void <B>trimToSize</B>()</TT> -->

<H3><a name="trimToSize(public)">trimToSize</a></H3>

<TT>public void <B>trimToSize</B>()</TT>

<P>

Sends a "hint" to the receiver that it should reduce adjust it's capacity to match the actual contents of the receiving vector.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

</body>

</html>