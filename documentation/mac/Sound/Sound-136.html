<!-- legacy work start -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<!-- legacy work end -->


<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)

LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Summary of the Sound Manager (IM: S)  (deprecated)</Title>

<!-- legacy work start -->
        <META NAME="Generator" CONTENT="manual">
        <META http-equiv="content-type" CONTENT="text/html;charset=utf-8">
        <META NAME = "Copyright" CONTENT="Copyright 2007 Apple Inc. All Rights Reserved.">
        <META NAME="IndexTitle" CONTENT="Inside Macintosh: Sound (Not Recommended)">
        <meta name="xcode-display" content="render">

        <LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css"> <!-- before submitting, globally replace ".." with "developer.apple.com" -->
        <script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
<!-- legacy work end -->

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<A NAME=HEADING136></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Sound-135.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Sound-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Sound-336.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Sound-137.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Sound-2.html"><B>Sound</B></A> / <BR><DD><A HREF="Sound-44.html"><B>Chapter 2 - Sound Manager</B></A></DL></FONT><P>
<HR>

<!-- legacy work start -->
<script type="text/javascript"> placeWatermark()</script>
<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
<i>Inside Macintosh: Sound</i> is deprecated as of Mac OS X v10.5. For new audio development in Mac OS X, use Core Audio. See the <a href="../../../referencelibrary/MusicAudio/" target="_top">Audio</a> page in the ADC Reference Library.</p></div></div></div>
<!-- legacy work end -->


<BLOCKQUOTE>
<A NAME=HEADING136-0></A>
<H1><A NAME=MARKER-9-957></A>Summary of the Sound Manager</H1>
<A NAME=HEADING136-1></A>
<H2>Pascal Summary</H2>
<A NAME=HEADING136-2></A>
<H3>Constants</H3>
<PRE>
CONST
   {Gestalt sound attributes selector and response bits}
   gestaltSoundAttr           = 'snd ';{sound attributes selector}
   gestaltStereoCapability    = 0;     {built-in hw can play stereo sounds}
   gestaltStereoMixing        = 1;     {built-in hw mixes stereo to mono}
   gestaltSoundIOMgrPresent   = 3;     {sound input routines available}
   gestaltBuiltInSoundInput   = 4;     {built-in input hw available}
   gestaltHasSoundInputDevice = 5;     {sound input device available}
   gestaltPlayAndRecord       = 6;     {built-in hw can play while recording}
   gestalt16BitSoundIO        = 7;     {built-in hw can handle 16-bit data}
   gestaltStereoInput         = 8;     {built-in hw can record stereo sounds}
   gestaltLineLevelInput      = 9;     {built-in input hw needs line level}
   gestaltSndPlayDoubleBuffer = 10;    {play from disk routines available}
   gestaltMultiChannels       = 11;    {multiple channels of sound supported}
   gestalt16BitAudioSupport   = 12;    {16-bit audio data supported}
   
   {channel initialization parameters}
   initChanLeft               = $0002; {left stereo channel}
   initChanRight              = $0003; {right stereo channel}
   waveInitChannel0           = $0004; {wave-table channel 0}
   waveInitChannel1           = $0005; {wave-table channel 1}
   waveInitChanne12           = $0006; {wave-table channel 2}
   waveInitChannel3           = $0007; {wave-table channel 3}
   initMono                   = $0080; {monophonic channel}
   initStereo                 = $00C0; {stereo channel}
   initMACE3                  = $0300; {3:1 compression}
   initMACE6                  = $0400; {6:1 compression}
   initNoInterp               = $0004; {no linear interpolation}
   initNoDrop                 = $0008; {no drop-sample conversion}
   
   {masks for channel attributes}
   initPanMask             = $0003;    {mask for right/left pan values}
   initSRateMask           = $0030;    {mask for sample rate values}
   initStereoMask          = $00C0;    {mask for mono/stereo values}
   initCompMask            = $FF00;    {mask for compression IDs}
   {sound data types}
   squareWaveSynth         = 1;        {square-wave data}
   waveTableSynth          = 3;        {wave-table data}
   sampledSynth            = 5;        {sampled-sound data}
   
   {sound command numbers}
   nullCmd                 = 0;        {do nothing}
   quietCmd                = 3;        {stop a sound that is playing}
   flushCmd                = 4;        {flush a sound channel}
   reInitCmd               = 5;        {reinitialize a sound channel}
   waitCmd                 = 10;       {suspend processing in a channel}
   pauseCmd                = 11;       {pause processing in a channel}
   resumeCmd               = 12;       {resume processing in a channel}
   callBackCmd             = 13;       {execute a callback procedure}
   syncCmd                 = 14;       {synchronize channels}
   availableCmd            = 24;       {see if initialization options }
                                       { are supported}
   versionCmd              = 25;       {determine version}
   totalLoadCmd            = 26;       {report total CPU load}
   loadCmd                 = 27;       {report CPU load for a new channel}
   freqDurationCmd         = 40;       {play a note for a duration}
   restCmd                 = 41;       {rest a channel for a duration}
   freqCmd                 = 42;       {change the pitch of a sound
   ampCmd                  = 43;       {change the amplitude of a sound}
   timbreCmd               = 44;       {change the timbre of a sound}
   getAmpCmd               = 45;       {get the amplitude of a sound}
   volumeCmd               = 46;       {set volume}
   getVolumeCmd            = 47;       {get volume}
   waveTableCmd            = 60;       {install a wave table as a voice}
   soundCmd                = 80;       {install a sampled sound as a voice}
   bufferCmd               = 81;       {play a sampled sound}
   rateCmd                 = 82;       {set the pitch of a sampled sound}
   getRateCmd              = 85;       {get the pitch of a sampled sound}
   
   {sampled sound header encoding options}
   stdSH                   = $00;      {standard sound header}
   extSH                   = $FF;      {extended sound header}
   cmpSH                   = $FE;      {compressed sound header}
   
   {size of data structures}
   stdQLength              = 128;      {default size of standard sound }
                                       { channel}
   
   {sound resource formats}
   firstSoundFormat        = $0001;    {format 1 'snd ' resource}
   secondSoundFormat       = $0002;    {format 2 'snd ' resource}
   {sound command mask}
   dataOffsetFlag          = $8000;    {sound command data offset bit}
   {system beep states}
   sysBeepDisable          = $0000;    {system alert sound disabled}
   sysBeepEnable           = $0001;    {system alert sound enabled}
   {values for the unitType field in AudioSelection}
   unitTypeSeconds         = $0000;    {seconds}
   unitTypeNoSelection     = $FFFF;    {no selection}
   
   {double buffer status flags}
   dbBufferReady           = $00000001;{double buffer is filled}
   dbLastBuffer            = $00000004;{last double buffer to play}
   {values for the compressionID field of CmpSoundHeader}
   variableCompression     = -2;       {variable-ratio compression}
   fixedCompression        = -1;       {fixed-ratio compression}
   notCompressed           = 0;        {noncompressed samples}
   threeToOne              = 3;        {3:1 compressed samples}
   sixToOne                = 4;        {6:1 compressed samples}
   
   {values for the packetSize field of CmpSoundHeader}
   sixToOnePacketSize      = 8;        {packet size in bits for 6:1}
   threeToOnePacketSize    = 16;       {packet size in bits for 3:1}
   
   {compression names and types}
   NoneName                = 'not compressed';
   ACE2to1Name             = 'ACE 2-to-1';
   ACE8to3Name             = 'ACE 8-to-3';
   MACE3to1Name            = 'MACE 3-to-1';
   MACE6to1Name            = 'MACE 6-to-1';
   NoneType                = 'NONE';
   ACE2Type                = 'ACE2';
   ACE8Type                = 'ACE8';
   MACE3Type               = 'MAC3';
   MACE6Type               = 'MAC6'
   
   {IDs for AIFF and AIFF-C files}
   AIFFID                  = 'AIFF';   {AIFF file}
   AIFCID                  = 'AIFC';   {AIFF-C file}
   
   {IDs for AIFF and AIFF-C file chunks}
   FormID                  = 'FORM';   {ID for Form Chunk}
   FormatVersionID         = 'FVER';   {ID for Format Version Chunk}
   CommonID                = 'COMM';   {ID for Common Chunk}
   SoundDataID             = 'SSND';   {ID for Sound Data Chunk}
   MarkerID                = 'MARK';   {ID for Marker Chunk}
   InstrumentID            = 'INST';   {ID for Instrument Chunk}
   MIDIDataID              = 'MIDI';   {ID for MIDI Data Chunk}
   AudioRecordingID        = 'AESD';   {ID for Recording Chunk}
   ApplicationSpecificID   = 'APPL';   {ID for Application Chunk}
   CommentID               = 'COMT';   {ID for Comment Chunk}
   NameID                  = 'NAME';   {ID for Name Chunk}
   AuthorID                = 'AUTH';   {ID for Author Chunk}
   CopyrightID             = '(c) ';   {ID for Copyright Chunk}
   AnnotationID            = 'ANNO';   {ID for Annotation Chunk}
   
   {version of AIFC format specification}
   AIFCVersion1            = $A2805140;{date of version creation}
   
   {MIDI note value for middle C}
   kMiddleC                = 60;
   
   {ratio between frequencies of MIDI note values}
   twelfthRootTwo          = 1.05946309434;
   
   {standard sampling rates}
   rate44khz               = $AC440000;   {44100.00000 in fixed-point}
   rate22khz               = $56EE8BA3;   {22254.54545 in fixed-point}
   rate22050hz             = $56220000;   {22050.00000 in fixed-point}
   rate11khz               = $2B7745D1;   {11127.27273 in fixed-point}
   rate11025hz             = $2B110000;   {11025.00000 in fixed-point}
   
   {constant for synth parameter of SndNewChannel}
   kUseOptionalOutputDevice      = -1;
   
   {volumes}
   kFullVolume                   = $0100;
   kNoVolume                     = 0;
   
   {development stages}
   developStage            = $20;         {prealpha release}
   alphaStage              = $40;         {alpha release}
   betaStage               = $60;         {beta release}
   finalStage              = $80;         {final release}
   
   {sizes of data buffers}
   stateBlockSize          = 64;          {size of state block buffer}
   leftOverBlockSize       = 32;          {size of leftover block buffer}
</PRE>
<A NAME=HEADING136-28></A>
<H3>Data Types</H3>
<A NAME=HEADING136-29></A>
<H4>Unsigned Fixed-Point Numbers</H4>
<PRE>
TYPE
   UnsignedFixed = LongInt;            {unsigned fixed-point number}
</PRE>
<A NAME=HEADING136-31></A>
<H4>Times</H4>
<PRE>
TYPE
   Time = LongInt;                     {in half-milliseconds}
</PRE>
<A NAME=HEADING136-33></A>
<H4>Sound Command Record</H4>
<PRE>
   SndCommand =
   PACKED RECORD
      cmd:              Integer;       {command number}
      param1:           Integer;       {first parameter}
      param2:           LongInt;       {second parameter}
   END;
</PRE>
<A NAME=HEADING136-35></A>
<H4>Audio Selection Record</H4>
<PRE>
   AudioSelection = 
   PACKED RECORD
      unitType:         LongInt;       {type of time unit}
      selStart:         Fixed;         {starting point of selection}
      selEnd:           Fixed;         {ending point of selection}
   END;
   AudioSelectionPtr = ^AudioSelection;
</PRE>
<A NAME=HEADING136-37></A>
<H4>Sound Channel Status Record</H4>
<PRE>
   SCStatus =
   RECORD
      scStartTime:         Fixed;      {starting time for play from disk}
      scEndTime:           Fixed;      {ending time for play from disk}
      scCurrentTime:       Fixed;      {current time for play from disk}
      scChannelBusy:       Boolean;    {TRUE if channel is processing cmds}
      scChannelDisposed:   Boolean;    {reserved}
      scChannelPaused:     Boolean;    {TRUE if play from disk is paused}
      scUnused:            Boolean;    {unused}
      scChannelAttributes: LongInt;    {attributes of this channel}
      scCPULoad:           LongInt;    {CPU load for this channel}
   END;
   SCStatusPtr = ^SCStatus;
</PRE>
<A NAME=HEADING136-39></A>
<H4>Sound Manager Status Record</H4>
<PRE>
   SMStatus =
   PACKED RECORD
      smMaxCPULoad:     Integer;       {maximum load on all channels}
      smNumChannels:    Integer;       {number of allocated channels}
      smCurCPULoad:     Integer;       {current load on all channels}
   END;
   SMStatusPtr = ^SMStatus;
</PRE>
<A NAME=HEADING136-41></A>
<H4>Sound Channel Record</H4>
<PRE>
   SndChannel =
   PACKED RECORD
      nextChan:         SndChannelPtr; {pointer to next channel}
      firstMod:         Ptr;           {used internally}
      callBack:         ProcPtr;       {pointer to callback procedure}
      userInfo:         LongInt;       {free for application's use}
      wait:             LongInt;       {used internally}
      cmdInProgress:    SndCommand;    {used internally}
      flags:            Integer;       {used internally}
      qLength:          Integer;       {used internally}
      qHead:            Integer;       {used internally}
      qTail:            Integer;       {used internally}
      queue:            ARRAY[0..stdQLength-1] OF SndCommand;
   END;
   SndChannelPtr = ^SndChannel;
</PRE>
<A NAME=HEADING136-43></A>
<H4>Sound Header Record</H4>
<PRE>
   SoundHeader =
   PACKED RECORD
      samplePtr:        Ptr;           {if NIL, samples in sampleArea}
      length:           LongInt;       {number of samples in array}
      sampleRate:       Fixed;         {sample rate}
      loopStart:        LongInt;       {loop point beginning}
      loopEnd:          LongInt;       {loop point ending}
      encode:           Byte;          {sample's encoding option}
      baseFrequency:    Byte;          {base frequency of sample}
      sampleArea:       PACKED ARRAY[0..0] OF Byte;
   END;
   SoundHeaderPtr = ^SoundHeader;
</PRE>
<A NAME=HEADING136-45></A>
<H4>Extended Sound Header Record</H4>
<PRE>
   ExtSoundHeader =
   PACKED RECORD
      samplePtr:        Ptr;           {if NIL, samples in sampleArea}
      numChannels:      LongInt;       {number of channels in sample}
      sampleRate:       Fixed;         {rate of original sample}
      loopStart:        LongInt;       {loop point beginning}
      loopEnd:          LongInt;       {loop point ending}
      encode:           Byte;          {sample's encoding option}
      baseFrequency:    Byte;          {base frequency of sample}
      numFrames:        LongInt;       {total number of frames}
      AIFFSampleRate:   Extended80;    {rate of original sample}
      markerChunk:      Ptr;           {reserved}
      instrumentChunks: Ptr;           {pointer to instrument info}
      AESRecording:     Ptr;           {pointer to audio info}
      sampleSize:       Integer;       {number of bits per sample}
      futureUse1:       Integer;       {reserved}
      futureUse2:       LongInt;       {reserved}
      futureUse3:       LongInt;       {reserved}
      futureUse4:       LongInt;       {reserved}
      sampleArea:       PACKED ARRAY[0..0] OF Byte;
   END;
   ExtSoundHeaderPtr = ^ExtSoundHeader;
</PRE>
<A NAME=HEADING136-47></A>
<H4>Compressed Sound Header Record</H4>
<PRE>
   CmpSoundHeader =
   PACKED RECORD
      samplePtr:        Ptr;           {if NIL, samples in sampleArea}
      numChannels:      LongInt;       {number of channels in sample}
      sampleRate:       Fixed;         {rate of original sample}
      loopStart:        LongInt;       {loop point beginning}
      loopEnd:          LongInt;       {loop point ending}
      encode:           Byte;          {sample's encoding option}
      baseFrequency:    Byte;          {base freq. of original sample}
      numFrames:        LongInt;       {length of sample in frames}
      AIFFSampleRate:   Extended80;    {rate of original sample}
      markerChunk:      Ptr;           {reserved}
      format:           OSType;        {data format type}
      futureUse2:       LongInt;       {reserved}
      stateVars:        StateBlockPtr; {pointer to StateBlock}
      leftOverSamples:  LeftOverBlockPtr; 
                                       {pointer to LeftOverBlock}
      compressionID:    Integer;       {ID of compression algorithm}
      packetSize:       Integer;       {number of bits per packet}
      snthID:           Integer;       {unused}
      sampleSize:       Integer;       {bits in each sample point}
      sampleArea:       PACKED ARRAY[0..0] OF Byte;
   END;
   CmpSoundHeaderPtr = ^CmpSoundHeader;
</PRE>
<A NAME=HEADING136-49></A>
<H4>Sound Double Buffer Header Record</H4>
<PRE>
   SndDoubleBufferHeader =
   PACKED RECORD
      dbhNumChannels:   Integer;       {number of sound channels}
      dbhSampleSize:    Integer;       {sample size, if noncompressed}
      dbhCompressionID: Integer;       {ID of compression algorithm}
      dbhPacketSize:    Integer;       {number of bits per packet}
      dbhSampleRate:    Fixed;         {sample rate}
      dbhBufferPtr:     ARRAY[0..1] OF SndDoubleBufferPtr;
                                       {pointers to SndDoubleBuffer}
      dbhDoubleBack:    ProcPtr;       {pointer to doubleback procedure}
   END;
   SndDoubleBufferHeaderPtr = ^SndDoubleBufferHeader;
   SndDoubleBufferHeader2 =
   PACKED RECORD
      dbhNumChannels:   Integer;       {number of sound channels}
      dbhSampleSize:    Integer;       {sample size, if noncompressed}
      dbhCompressionID: Integer;       {ID of compression algorithm}
      dbhPacketSize:    Integer;       {number of bits per packet}
      dbhSampleRate:    Fixed;         {sample rate}
      dbhBufferPtr:     ARRAY[0..1] OF SndDoubleBufferPtr;
                                       {pointers to SndDoubleBuffer}
      dbhDoubleBack:    ProcPtr;       {pointer to doubleback procedure}
      dbhFormat:        OSType;        {signature of codec}
   END;
   SndDoubleBufferHeaderPtr2 = ^SndDoubleBufferHeader2;
</PRE>
<A NAME=HEADING136-52></A>
<H4>Sound Double Buffer Record</H4>
<PRE>
   SndDoubleBuffer =
   PACKED RECORD
      dbNumFrames:      LongInt;       {number of frames in buffer}
      dbFlags:          LongInt;       {buffer status flags}
      dbUserInfo:       ARRAY[0..1] OF LongInt;
                                       {for application's use}
      dbSoundData:      PACKED ARRAY[0..0] OF Byte;
                                       {array of data}
   END;
   SndDoubleBufferPtr = ^SndDoubleBuffer;
</PRE>
<A NAME=HEADING136-54></A>
<H4>Chunk Header</H4>
<PRE>
   ID = LongInt;                       {chunk ID type}
   ChunkHeader =
   RECORD
      ckID:             ID;            {chunk type ID}
      ckSize:           LongInt;       {number of bytes of data}
   END;
</PRE>
<A NAME=HEADING136-57></A>
<H4>Form Chunk</H4>
<PRE>
   ContainerChunk =
   RECORD
      ckID:             ID;            {'FORM'}
      ckSize:           LongInt;       {number of bytes of data}
      formType:         ID;            {type of file}
   END;
</PRE>
<A NAME=HEADING136-59></A>
<H4>Format Version Chunk</H4>
<PRE>
   FormatVersionChunk =
   RECORD
      ckID:             ID;            {'FVER'}
      ckSize:           LongInt;       {4 bytes}
      timestamp:        LongInt;       {date of format version}
   END;
</PRE>
<A NAME=HEADING136-61></A>
<H4>Common Chunk</H4>
<PRE>
   CommonChunk =
   RECORD
      ckID:             ID;            {'COMM'}
      ckSize:           LongInt;       {18 bytes}
      numChannels:      Integer;       {number of channels}
      numSampleFrames:  LongInt;       {number of sample frames}
      sampleSize:       Integer;       {number of bits per sample}
      sampleRate:       Extended;      {number of frames per second}
   END;
</PRE>
<A NAME=HEADING136-63></A>
<H4>Extended Common Chunk</H4>
<PRE>
   ExtCommonChunk =
   RECORD
      ckID:             ID;            {'COMM'}
      ckSize:           LongInt;       {22 bytes + compression name}
      numChannels:      Integer;       {number of channels}
      numSampleFrames:  LongInt;       {number of sample frames}
      sampleSize:       Integer;       {number of bits per sample}
      sampleRate:       Extended;      {number of frames per second}
      compressionType:  ID;            {compression type ID}
      compressionName:  PACKED ARRAY[0..0] OF Byte;
                                       {compression type name}
   END;
</PRE>
<A NAME=HEADING136-65></A>
<H4>Sound Data Chunk</H4>
<PRE>
   SoundDataChunk =
   RECORD
      ckID:       ID;         {'SSND'}
      ckSize:     LongInt;    {size of chunk data}
      offset:     LongInt;    {offset to sound data}
      blockSize:  LongInt;    {size of alignment blocks}
   END;
</PRE>
<A NAME=HEADING136-67></A>
<H4>Version Record</H4>
<PRE>
   NumVersion = 
   PACKED RECORD
   CASE INTEGER OF
    0:
      (majorRev:        SignedByte;    {major revision level in BCD}
      minorAndBugRev:   SignedByte;    {minor revision level}
      stage:            SignedByte;    {development stage}
      nonRelRev:        SignedByte);   {nonreleased revision level}
    1:
      (version:         LongInt);      {all 4 fields together}
   END;
</PRE>
<A NAME=HEADING136-69></A>
<H4>Leftover Block</H4>
<PRE>
   LeftOverBlock = 
   RECORD
      count:         LongInt;
      sampleArea:    PACKED ARRAY[0..leftOverBlockSize - 1] OF Byte;
   END;
   LeftOverBlockPtr = ^LeftOverBlock;
</PRE>
<A NAME=HEADING136-71></A>
<H4>State Block</H4>
<PRE>
   StateBlock = 
   RECORD
      stateVar:      ARRAY[0..stateBlockSize - 1] OF Integer;
   END;
   StateBlockPtr = ^StateBlock;
</PRE>
<A NAME=HEADING136-73></A>
<H3>Sound Manager Routines</H3>
<A NAME=HEADING136-74></A>
<H4>Playing Sound Resources</H4>
<PRE>
PROCEDURE	SysBeep		(duration: Integer);
FUNCTION	SndPlay		(chan: SndChannelPtr; sndHdl: Handle; 
				async: Boolean): OSErr;
</PRE>
<A NAME=HEADING136-77></A>
<H4>Playing From Disk</H4>
<PRE>
FUNCTION    SndStartFilePlay    (chan: SndChannelPtr; fRefNum: Integer; 
                                resNum: Integer; bufferSize: LongInt; 
                                theBuffer: Ptr; 
                                theSelection: AudioSelectionPtr; 
                                theCompletion: ProcPtr; async: Boolean): OSErr;
FUNCTION    SndPauseFilePlay    (chan: SndChannelPtr): OSErr;
FUNCTION    SndStopFilePlay     (chan: SndChannelPtr; quietNow: Boolean): OSErr;
</PRE>
<A NAME=HEADING136-81></A>
<H4>Allocating and Releasing Sound Channels</H4>
<PRE>
FUNCTION    SndNewChannel       (VAR chan: SndChannelPtr; synth: Integer; 
                                init: LongInt; userRoutine: ProcPtr): OSErr;
FUNCTION    SndDisposeChannel   (chan: SndChannelPtr; quietNow: Boolean): OSErr;
</PRE>
<A NAME=HEADING136-84></A>
<H4>Sending Commands to a Sound Channel</H4>
<PRE>
FUNCTION    SndDoCommand    (chan: SndChannelPtr; cmd: SndCommand; 
                            noWait: Boolean): OSErr;
FUNCTION    SndDoImmediate  (chan: SndChannelPtr; cmd: SndCommand): OSErr;
</PRE>
<A NAME=HEADING136-87></A>
<H4>Obtaining Information</H4>
<PRE>
FUNCTION    SndSoundManagerVersion
                              : NumVersion;
FUNCTION    MACEVersion       : NumVersion;
FUNCTION    SndControl        (id: Integer; VAR cmd: SndCommand): OSErr;
FUNCTION    SndChannelStatus  (chan: SndChannelPtr; theLength: Integer; 
                              theStatus: SCStatusPtr): OSErr;
FUNCTION    SndManagerStatus  (theLength: Integer; theStatus: SMStatusPtr): 
                    OSErr;
PROCEDURE   SndGetSysBeepState
                              (VAR sysBeepState: Integer);
FUNCTION    SndSetSysBeepState
                              (sysBeepState: Integer): OSErr;
FUNCTION    GetSoundHeaderOffset
                              (sndHdl: Handle; VAR offset: LongInt): OSErr;
</PRE>
<A NAME=HEADING136-100></A>
<H4>Controlling Volume Levels</H4>
<PRE>
FUNCTION    GetSysBeepVolume  (VAR level: LongInt): OSErr;
FUNCTION    SetSysBeepVolume  (level: LongInt): OSErr;
FUNCTION    GetDefaultOutputVolume
                              (VAR level: LongInt): OSErr;
FUNCTION    SetDefaultOutputVolume
                              (level: LongInt): OSErr;
</PRE>
<A NAME=HEADING136-107></A>
<H4>Compressing and Expanding Audio Data</H4>
<PRE>
PROCEDURE   Comp3to1        (inBuffer: Ptr; outBuffer: Ptr; cnt: LongInt; 
                            inState: Ptr; outState: Ptr; 
                            numChannels: LongInt; whichChannel: LongInt);
PROCEDURE   Comp6to1        (inBuffer: Ptr; outBuffer: Ptr; cnt: LongInt; 
                            inState: Ptr; outState: Ptr; 
                            numChannels: LongInt; whichChannel: LongInt);
PROCEDURE   Exp1to3         (inBuffer: Ptr; outBuffer: Ptr; cnt: LongInt; 
                            inState: Ptr; outState: Ptr; 
                            numChannels: LongInt; whichChannel: LongInt);
PROCEDURE   Exp1to6         (inBuffer: Ptr; outBuffer: Ptr; cnt: LongInt; 
                            inState: Ptr; outState: Ptr; 
                            numChannels: LongInt; whichChannel: LongInt);
</PRE>
<A NAME=HEADING136-112></A>
<H4>Managing Double Buffers</H4>
<PRE>
FUNCTION    SndPlayDoubleBuffer
                    (chan: SndChannelPtr; 
                    theParams: SndDoubleBufferHeaderPtr): OSErr;
</PRE>
<A NAME=HEADING136-115></A>
<H4>Performing Unsigned Fixed-Point Arithmetic</H4>
<PRE>
FUNCTION    UnsignedFixMulDiv  (value: UnsignedFixed; 
                               multiplier: UnsignedFixed; 
                               divisor: UnsignedFixed): UnsignedFixed;
</PRE>
<A NAME=HEADING136-117></A>
<H4>Linking Modifiers to Sound Channels</H4>
<PRE>
FUNCTION    SndAddModifier  (chan: SndChannelPtr; modifier: ProcPtr; 
                            id: Integer; init: LongInt): OSErr;
</PRE>
<A NAME=HEADING136-119></A>
<H3>Application-Defined Routines</H3>
<PRE>
PROCEDURE   MyFilePlayCompletionRoutine
                                  (chan: SndChannelPtr);
PROCEDURE   MyCallback            (chan: SndChannelPtr; cmd: SndCommand);
PROCEDURE   MyDoubleBackProc      (chan: SndChannelPtr; 
                                  doubleBufferPtr: SndDoubleBufferPtr);
</PRE>
<A NAME=HEADING136-124></A>
<H2>C Summary</H2>
<A NAME=HEADING136-125></A>
<H3>Constants</H3>
<PRE>
/*Gestalt sound attributes selector and response bits*/
#define gestaltSoundAttr    'snd '  /*sound attributes selector*/
enum {
   gestaltStereoCapability    = 0,  /*built-in hw can play stereo sounds*/
   gestaltStereoMixing        = 1,  /*built-in hw mixes stereo to mono*/
   gestaltSoundIOMgrPresent   = 3,  /*sound input routines available*/
   gestaltBuiltInSoundInput   = 4,  /*built-in input hw available*/
   gestaltHasSoundInputDevice = 5,  /*sound input device available*/
   gestaltPlayAndRecord       = 6,  /*built-in hw can play while recording*/
   gestalt16BitSoundIO        = 7,  /*built-in hw can handle 16-bit data*/
   gestaltStereoInput         = 8,  /*built-in hw can record stereo sounds*/
   gestaltLineLevelInput      = 9,  /*built-in input hw needs line level*/
   gestaltSndPlayDoubleBuffer = 10, /*play from disk routines available*/
   gestaltMultiChannels       = 11, /*multiple channels of sound supported*/
   gestalt16BitAudioSupport   = 12  /*16-bit audio data supported*/
};
/*channel initialization parameters*/
enum {
   initChanLeft            = 0x0002,   /*left stereo channel*/
   initChanRight           = 0x0003,   /*right stereo channel*/
   initMono                = 0x0080,   /*monophonic channel*/
   initStereo              = 0x00C0,   /*stereo channel*/
   initMACE3               = 0x0300,   /*3:1 compression*/
   initMACE6               = 0x0400,   /*6:1 compression*/
   initNoInterp            = 0x0004,   /*no linear interpolation*/
   initNoDrop              = 0x0008    /*no drop-sample conversion*/
};
/*wave channel initialization parameters*/
enum {
   waveInitChannel0        = 0x04,     /*wave-table channel 0*/
   waveInitChannel1        = 0x05,     /*wave-table channel 1*/
   waveInitChannel2        = 0x06,     /*wave-table channel 2*/
   waveInitChannel3        = 0x07,     /*wave-table channel 3*/
   waveInitChannelMask     = 0x07      /*mask for wave-table parameters*/
};
/*masks for channel attributes*/
enum {
   initPanMask             = 0x0003,   /*mask for left/right pan values*/
   initSRateMask           = 0x0030,   /*mask for sample rate values*/
   initStereoMask          = 0x00C0,   /*mask for mono/stereo values*/
   initCompMask            = 0xFF00    /*mask for compression IDs*/
};
/*sound data types*/
enum {
   squareWaveSynth         = 1,        /*square-wave data*/
   waveTableSynth          = 3,        /*wave-table data*/
   sampledSynth            = 5         /*sampled-sound data*/
};
/*sound command numbers*/
enum {
   nullCmd                 = 0,        /*do nothing*/
   quietCmd                = 3,        /*stop a sound that is playing*/
   flushCmd                = 4,        /*flush a sound channel*/
   reInitCmd               = 5,        /*reinitialize a sound channel*/
   waitCmd                 = 10,       /*suspend processing in a channel*/
   pauseCmd                = 11,       /*pause processing in a channel*/
   resumeCmd               = 12,       /*resume processing in a channel*/
   callBackCmd             = 13,       /*execute a callback procedure*/
   syncCmd                 = 14,       /*synchronize channels*/
   availableCmd            = 24,       /*see if initialization options */
                                       /* are supported*/
   versionCmd              = 25,       /*determine version*/
   totalLoadCmd            = 26,       /*report total CPU load*/
   loadCmd                 = 27,       /*report CPU load for a new channel*/
   freqDurationCmd         = 40,       /*play a note for a duration*/
   restCmd                 = 41,       /*rest a channel for a duration*/
   freqCmd                 = 42,       /*change the pitch of a sound*/
   ampCmd                  = 43,       /*change the amplitude of a sound*/
   timbreCmd               = 44,       /*change the timbre of a sound*/
   getAmpCmd               = 45,       /*get the amplitude of a sound*/
   volumeCmd               = 46,       /*set volume*/
   getVolumeCmd            = 47,       /*get volume*/
   waveTableCmd            = 60,       /*install a wave table as a voice*/
   soundCmd                = 80,       /*install a sampled sound as a voice*/
   bufferCmd               = 81,       /*play a sampled sound*/
   rateCmd                 = 82,       /*set the pitch of a sampled sound*/
   getRateCmd              = 85        /*get the pitch of a sampled sound*/
};
/*sampled sound header encoding options*/
enum {
   stdSH                   = 0x00,     /*standard sound header*/
   extSH                   = 0xFF,     /*extended sound header*/
   cmpSH                   = 0xFE      /*compressed sound header*/
};
/*size of data structures*/
enum {
   stdQLength              = 128       /*default size of sound channel*/
};
/*sound resource formats*/
enum {
   firstSoundFormat        = 0x0001,   /*format 1 'snd ' resource*/
   secondSoundFormat       = 0x0002    /*format 2 'snd ' resource*/
};
/*sound command mask*/
enum {
   dataOffsetFlag          = 0x8000    /*sound command data offset bit*/
};
/*system beep states*/
enum {
   sysBeepDisable          = 0x0000,   /*system alert sound disabled*/
   sysBeepEnable           = 0x0001    /*system alert sound enabled*/
};
/*values for the unitType field in AudioSelection*/
enum {
   unitTypeSeconds         = 0x0000,   /*seconds*/
   unitTypeNoSelection     = 0xFFFF    /*no selection*/
};
/*double buffer status flags*/
enum {
   dbBufferReady           = 0x00000001,  /*double buffer is filled*/
   dbLastBuffer            = 0x00000004   /*last double buffer to play*/
};
/*values for the compressionID field of CmpSoundHeader*/
enum {
   variableCompression     = -2,       /*variable-ratio compression*/
   fixedCompression        = -1,       /*fixed-ratio compression*/
   notCompressed           = 0,        /*noncompressed samples*/
   threeToOne              = 3,        /*3:1 compressed samples*/
   sixToOne                = 4         /*6:1 compressed samples*/
};
/*values for the packetSize field of CmpSoundHeader*/
enum {
   sixToOnePacketSize      = 8,        /*packet size in bits for 6:1*/
   threeToOnePacketSize    = 16        /*packet size in bits for 3:1*/
};
/*compression names and types*/
#define NoneName              &quot;\pnot compressed&quot;
#define ACE2to1Name           &quot;\pACE 2-to-1&quot;
#define ACE8to3Name           &quot;\pACE 8-to-3&quot;
#define MACE3to1Name          &quot;\pMACE 3-to-1&quot;
#define MACE6to1Name          &quot;\pMACE 6-to-1&quot;
#define NoneType              'NONE'
#define ACE2Type              'ACE2'
#define ACE8Type              'ACE8'
#define MACE3Type             'MAC3'
#define MACE6Type             'MAC6'
/*IDs for AIFF and AIFF-C files*/
#define AIFFID                'AIFF'   /*AIFF file*/
#define AIFCID                'AIFC'   /*AIFF-C file*/
/*IDs for AIFF and AIFF-C file chunks*/
#define FORMID                'FORM'   /*ID for Form Chunk*/
#define FormatVersionID       'FVER'   /*ID for Format Version Chunk*/
#define CommonID              'COMM'   /*ID for Common Chunk*/
#define SoundDataID           'SSND'   /*ID for Sound Data Chunk*/
#define MarkerID              'MARK'   /*ID for Marker Chunk*/
#define InstrumentID          'INST'   /*ID for Instrument Chunk*/
#define MIDIDataID            'MIDI'   /*ID for MIDI Data Chunk*/
#define AudioRecordingID      'AESD'   /*ID for Recording Chunk*/
#define ApplicationSpecificID 'APPL'   /*ID for Application Chunk*/
#define CommentID             'COMT'   /*ID for Comment Chunk*/
#define NameID                'NAME'   /*ID for Name Chunk*/
#define AuthorID              'AUTH'   /*ID for Author Chunk*/
#define CopyrightID           '(c) '   /*ID for Copyright Chunk*/
#define AnnotationID          'ANNO'   /*ID for Annotation Chunk*/
/*version of AIFC format specification*/
#define AIFCVersion1          0xA2805140
                                       /*date of version creation*/
/*MIDI note value for middle C*/
enum {
   kMiddleC                = 60
};
/*ratio between frequencies of MIDI note values*/
#define twelfthRootTwo        1.05946309434
/*standard sampling rates*/
#define rate44khz          0xAC440000     /*44100.00000 in fixed-point*/
#define rate22khz          0x56EE8BA3     /*22254.54545 in fixed-point*/
#define rate22050hz        0x56220000     /*22050.00000 in fixed-point*/
#define rate11khz          0x2B7745D1     /*11127.27273 in fixed-point*/
#define rate11025hz        0x2B110000     /*11025.00000 in fixed-point*/
/*constant for synth parameter of SndNewChannel*/
enum {
   kUseOptionalOutputDevice      = -1
};
/*volumes*/
enum {
   kFullVolume                   = 0x0100,
   kNoVolume                     = 0
};
/*development stages*/
enum {
   developStage         = 0x20,        /*prealpha release*/
   alphaStage           = 0x40,        /*alpha release*/
   betaStage            = 0x60,        /*beta release*/
   finalStage           = 0x80         /*final release*/
};
/*sizes of data buffers*/
enum {
   stateBlockSize       = 64,          /*size of state block buffer*/
   leftOverBlockSize    = 32           /*size of leftover block buffer*/
};
</PRE>
<A NAME=HEADING136-153></A>
<H3>Data Types</H3>
<A NAME=HEADING136-154></A>
<H4>Unsigned Fixed-Point Numbers</H4>
<PRE>
typedef unsigned long UnsignedFixed;   /*unsigned fixed-point number*/
</PRE>
<A NAME=HEADING136-156></A>
<H4>Times</H4>
<PRE>
typedef long Time;                     /*in half-milliseconds*/
</PRE>
<A NAME=HEADING136-158></A>
<H4>Sound Command Record</H4>
<PRE>
struct SndCommand {
   unsigned short       cmd;           /*command number*/
   short                param1;        /*first parameter*/
   long                 param2;        /*second parameter*/
};
typedef struct SndCommand SndCommand;
</PRE>
<A NAME=HEADING136-160></A>
<H4>Audio Selection Record</H4>
<PRE>
struct AudioSelection {
   long                 unitType;      /*type of time unit*/
   Fixed                selStart;      /*starting point of selection*/
   Fixed                selEnd;        /*ending point of selection/*
};
typedef struct AudioSelection AudioSelection;
typedef AudioSelection *AudioSelectionPtr;
</PRE>
<A NAME=HEADING136-162></A>
<H4>Sound Channel Status Record</H4>
<PRE>
struct SCStatus {
   Fixed                scStartTime;   /*starting time for play from disk*/
   Fixed                scEndTime;     /*ending time for play from disk*/
   Fixed                scCurrentTime; /*current time for play from disk*/
   Boolean              scChannelBusy; /*TRUE if channel is processing cmds*/
   Boolean              scChannelDisposed;
                                       /*reserved*/
   Boolean              scChannelPaused;
                                       /*TRUE if play from disk is paused*/
   Boolean              scUnused;      /*unused*/
   unsigned long        scChannelAttributes;
                                       /*attributes of this channel*/
   long                 scCPULoad;     /*CPU load for this channel*/
};
typedef struct SCStatus SCStatus;
typedef SCStatus *SCStatusPtr;
</PRE>
<A NAME=HEADING136-164></A>
<H4>Sound Manager Status Record</H4>
<PRE>
struct SMStatus {
   short                smMaxCPULoad;  /*maximum load on all channels*/
   short                smNumChannels; /*number of allocated channels*/
   short                smCurCPULoad;  /*current load on all channels*/
};
typedef struct SMStatus SMStatus;
typedef SMStatus *SMStatusPtr;
</PRE>
<A NAME=HEADING136-166></A>
<H4>Sound Channel Record</H4>
<PRE>
struct SndChannel {
   struct SndChannel    *nextChan;     /*pointer to next channel*/
   Ptr                  firstMod;      /*used internally*/
   SndCallBackProcPtr   callBack;      /*pointer to callback procedure*/
   long                 userInfo;      /*free for application's use*/
   long                 wait;          /*used internally*/
   SndCommand           cmdInProgress; /*used internally*/
   short                flags;         /*used internally*/
   short                qLength;       /*used internally*/
   short                qHead;         /*used internally*/
   short                qTail;         /*used internally*/
   SndCommand           queue[stdQLength];
};
typedef struct SndChannel SndChannel;
typedef SndChannel *SndChannelPtr;
</PRE>
<A NAME=HEADING136-168></A>
<H4>Sound Header Record</H4>
<PRE>
struct SoundHeader {
   Ptr                  samplePtr;     /*if NIL, samples in sampleArea*/
   unsigned long        length;        /*number of samples in array*/
   Fixed                sampleRate;    /*sample rate for this sound*/
   unsigned long        loopStart;     /*loop point beginning*/
   unsigned long        loopEnd;       /*loop point ending*/
   unsigned char        encode;        /*sample's encoding option*/
   unsigned char        baseFrequency; /*base frequency of sample*/
   unsigned char        sampleArea[1];
};
typedef struct SoundHeader SoundHeader;
typedef SoundHeader *SoundHeaderPtr;
</PRE>
<A NAME=HEADING136-170></A>
<H4>Extended Sound Header Record</H4>
<PRE>
struct ExtSoundHeader {
   Ptr                  samplePtr;     /*if NIL, samples in sampleArea*/
   unsigned long        numChannels;   /*number of channels in sample*/
   Fixed                sampleRate;    /*rate of original sample*/
   unsigned long        loopStart;     /*loop point beginning*/
   unsigned long        loopEnd;       /*loop point ending*/
   unsigned char        encode;        /*sample's encoding option*/
   unsigned char        baseFrequency; /*base frequency of sample*/
   unsigned long        numFrames;     /*total number of frames*/
   extended80           AIFFSampleRate;/*rate of original sample*/
   Ptr                  markerChunk;   /*reserved*/
   Ptr                  instrumentChunks;
                                       /*pointer to instrument info*/
   Ptr                  AESRecording;  /*pointer to audio info*/
   unsigned short       sampleSize;    /*number of bits per sample*/
   unsigned short       futureUse1;    /*reserved*/
   unsigned long        futureUse2;    /*reserved*/
   unsigned long        futureUse3;    /*reserved*/
   unsigned long        futureUse4;    /*reserved*/
   unsigned char        sampleArea[1];
};
typedef struct ExtSoundHeader ExtSoundHeader;
typedef ExtSoundHeader *ExtSoundHeaderPtr;
</PRE>
<A NAME=HEADING136-172></A>
<H4>Compressed Sound Header Record</H4>
<PRE>
struct CmpSoundHeader {
   Ptr                  samplePtr;     /*if NIL, samples in sampleArea*/
   unsigned long        numChannels;   /*number of channels in sample*/
   Fixed                sampleRate;    /*rate of original sample*/
   unsigned long        loopStart;     /*loop point beginning*/
   unsigned long        loopEnd;       /*loop point ending*/
   unsigned char        encode;        /*sample's encoding option*/
   unsigned char        baseFrequency; /*base frequency of original sample*/
   unsigned long        numFrames;     /*length of sample in frames*/
   extended80           AIFFSampleRate;/*rate of original sample*/
   Ptr                  markerChunk;   /*reserved*/
   OSType               format;        /*data format type*/
   unsigned long        futureUse2;    /*reserved*/
   StateBlockPtr        stateVars;     /*pointer to StateBlock*/
   LeftOverBlockPtr     leftOverSamples;
                                       /*pointer to LeftOverBlock*/
   unsigned short       compressionID; /*ID of compression algorithm*/
   unsigned short       packetSize;    /*number of bits per packet*/
   unsigned short       snthID;        /*unused*/
   unsigned short       sampleSize;    /*bits in each sample point*/
   unsigned char        sampleArea[1];
};
typedef struct CmpSoundHeader CmpSoundHeader;
typedef CmpSoundHeader *CmpSoundHeaderPtr;
</PRE>
<A NAME=HEADING136-174></A>
<H4>Sound Double Buffer Header Record</H4>
<PRE>
struct SndDoubleBufferHeader {
   short                dbhNumChannels;/*number of sound channels*/
   short                dbhSampleSize; /*sample size, if noncompressed*/
   short                dbhCompressionID;
                                       /*ID of compression algorithm*/
   short                dbhPacketSize; /*number of bits per packet*/
   Fixed                dbhSampleRate; /*sample rate*/
   SndDoubleBufferPtr   dbhBufferPtr[2];
                                       /*pointers to SndDoubleBuffer*/
   SndDoubleBackProcPtr dbhDoubleBack; /*pointer to doubleback procedure*/
};
typedef struct SndDoubleBufferHeader SndDoubleBufferHeader;
typedef SndDoubleBufferHeader *SndDoubleBufferHeaderPtr;
struct SndDoubleBufferHeader2 {
   short                dbhNumChannels;/*number of sound channels*/
   short                dbhSampleSize; /*sample size, if noncompressed*/
   short                dbhCompressionID;
                                       /*ID of compression algorithm*/
   short                dbhPacketSize; /*number of bits per packet*/
   Fixed                dbhSampleRate; /*sample rate*/
   SndDoubleBufferPtr   dbhBufferPtr[2];
                                       /*pointers to SndDoubleBuffer*/
   SndDoubleBackProcPtr dbhDoubleBack; /*pointer to doubleback procedure*/
   OSType               dbhFormat;     /*signature of codec*/
};
typedef struct SndDoubleBufferHeader2 SndDoubleBufferHeader2;
typedef SndDoubleBufferHeader2 *SndDoubleBufferHeaderPtr2;
</PRE>
<A NAME=HEADING136-177></A>
<H4>Sound Double Buffer Record</H4>
<PRE>
struct SndDoubleBuffer {
   long                 dbNumFrames;   /*number of frames in buffer*/
   long                 dbFlags;       /*buffer status flags*/
   long                 dbUserInfo[2]; /*for application's use*/
   char                 dbSoundData[1];/*array of data*/
};
typedef struct SndDoubleBuffer SndDoubleBuffer;
typedef SndDoubleBuffer *SndDoubleBufferPtr;
</PRE>
<A NAME=HEADING136-179></A>
<H4>Chunk Headers</H4>
<PRE>
typedef unsigned long ID;              /*chunk ID type*/

struct ChunkHeader {
   ID                   ckID;          /*chunk type ID*/
   long                 ckSize;        /*number of bytes of data*/
};
typedef struct ChunkHeader ChunkHeader;
</PRE>
<A NAME=HEADING136-181></A>
<H4>Form Chunk</H4>
<PRE>
struct ContainerChunk {
   ID                   ckID;          /*'FORM'*/
   long                 ckSize;        /*number of bytes of data*/
   ID                   formType;      /*type of file*/
};
typedef struct ContainerChunk ContainerChunk;
</PRE>
<A NAME=HEADING136-183></A>
<H4>Format Version Chunk</H4>
<PRE>
struct FormatVersionChunk {
   ID                   ckID;          /*'FVER'*/
   long                 ckSize;        /*4 bytes*/
   unsigned long        timestamp;     /*date of format version*/
};
typedef struct FormatVersionChunk FormatVersionChunk;
</PRE>
<A NAME=HEADING136-185></A>
<H4>Common Chunk</H4>
<PRE>
struct CommonChunk {
   ID                   ckID;          /*'COMM'*/
   long                 ckSize;        /*18 bytes*/
   short                numChannels;   /*number of channels*/
   unsigned long        numSampleFrames;
                                       /*number of sample frames*/
   short                sampleSize;    /*number of bits per sample*/
   extended80           sampleRate;    /*number of frames per second*/
};

typedef struct CommonChunk CommonChunk;
</PRE>
<A NAME=HEADING136-187></A>
<H4>Extended Common Chunk</H4>
<PRE>
struct ExtCommonChunk {
   ID                   ckID;          /*'COMM'*/
   long                 ckSize;        /*22 bytes + compression name*/
   short                numChannels;   /*number of channels*/
   unsigned long        numSampleFrames;  
                                       /*number of sample frames*/
   short                sampleSize;    /*number of bits per sample*/
   extended80           sampleRate;    /*number of frames per second*/
   ID                   compressionType;  
                                       /*compression type ID*/
   char                 compressionName[1];
                                       /*compression type name*/
};
typedef struct ExtCommonChunk ExtCommonChunk;
</PRE>
<A NAME=HEADING136-189></A>
<H4>Sound Data Chunk</H4>
<PRE>
struct SoundDataChunk {
   ID                   ckID;          /*'SSND'*/
   long                 ckSize;        /*size of chunk data*/
   unsigned long        offset;        /*offset to sound data*/
   unsigned long        blockSize;     /*size of alignment blocks*/
};
typedef struct SoundDataChunk SoundDataChunk;
</PRE>
<A NAME=HEADING136-191></A>
<H4>Version Record</H4>
<PRE>
struct NumVersion {
   unsigned char        majorRev;      /*major revision level in BCD*/
   unsigned char        minorAndBugRev;/*minor revision level*/
   unsigned char        stage;         /*development stage*/
   unsigned char        nonRelRev;     /*nonreleased version revision level*/
};
typedef struct NumVersion NumVersion;
</PRE>
<A NAME=HEADING136-193></A>
<H4>Leftover Block</H4>
<PRE>
struct LeftOverBlock {
   unsigned long        count;
   char                 sampleArea[leftOverBlockSize];
};
typedef struct LeftOverBlock LeftOverBlock;
typedef LeftOverBlock *LeftOverBlockPtr;
</PRE>
<A NAME=HEADING136-195></A>
<H4>State Block</H4>
<PRE>
struct StateBlock {
   short                stateVar[stateBlockSize];
};
typedef struct StateBlock StateBlock;
typedef StateBlock *StateBlockPtr;
</PRE>
<A NAME=HEADING136-197></A>
<H4>Procedure Types</H4>
<PRE>
typedef pascal void (*FilePlayCompletionProcPtr)
                    (SndChannelPtr chan);
typedef pascal void (*SndCallBackProcPtr)
                    (SndChannelPtr chan, SndCommand *cmd);
typedef pascal void (*SndDoubleBackProcPtr)
                    (SndChannelPtr chan,
                    SndDoubleBufferPtr doubleBufferPtr);
</PRE>
<A NAME=HEADING136-204></A>
<H3>Sound Manager Routines</H3>
<A NAME=HEADING136-205></A>
<H4>Playing Sound Resources</H4>
<PRE>
pascal void SysBeep     (short duration);
pascal OSErr SndPlay    (SndChannelPtr chan, Handle sndHdl, 
                         Boolean async);
</PRE>
<A NAME=HEADING136-208></A>
<H4>Playing From Disk</H4>
<PRE>
pascal OSErr SndStartFilePlay
                (SndChannelPtr chan, short fRefNum,
                 short resNum, long bufferSize, void *theBuffer,
                 AudioSelectionPtr theSelection,
                 FilePlayCompletionProcPtr theCompletion, Boolean async);
pascal OSErr SndPauseFilePlay
                (SndChannelPtr chan);
pascal OSErr SndStopFilePlay
                (SndChannelPtr chan, Boolean quietNow);
</PRE>
<A NAME=HEADING136-215></A>
<H4>Allocating and Releasing Sound Channels</H4>
<PRE>
pascal OSErr SndNewChannel  (SndChannelPtr *chan, short synth, long init,
                             SndCallBackProcPtr userRoutine);
pascal OSErr SndDisposeChannel
                            (SndChannelPtr chan, Boolean quietNow);
</PRE>
<A NAME=HEADING136-219></A>
<H4>Sending Commands to a Sound Channel</H4>
<PRE>
pascal OSErr SndDoCommand   (SndChannelPtr chan, const SndCommand *cmd,
                             Boolean noWait);
pascal OSErr SndDoImmediate
                            (SndChannelPtr chan, const SndCommand *cmd);
</PRE>
<A NAME=HEADING136-223></A>
<H4>Obtaining Information</H4>
<PRE>
pascal NumVersion SndSoundManagerVersion
                            (void);
pascal NumVersion MACEVersion
                            (void);
pascal OSErr SndControl     (short id, SndCommand *cmd);
pascal OSErr SndChannelStatus
                            (SndChannelPtr chan, short theLength,
                             SCStatusPtr theStatus);
pascal OSErr SndManagerStatus
                            (short theLength, SMStatusPtr theStatus);
pascal void SndGetSysBeepState
                            (short *sysBeepState);
pascal OSErr SndSetSysBeepState
                            (short sysBeepState);
pascal OSErr GetSoundHeaderOffset
                            (Handle sndHandle, long *offset);
</PRE>
<A NAME=HEADING136-239></A>
<H4>Controlling Volume Levels</H4>
<PRE>
pascal OSErr GetSysBeepVolume
                    (long *level);
pascal OSErr SetSysBeepVolume
                    (long level);
pascal OSErr GetDefaultOutputVolume
                    (long *level);
pascal OSErr SetDefaultOutputVolume
                    (long level);
</PRE>
<A NAME=HEADING136-248></A>
<H4>Compressing and Expanding Audio Data</H4>
<PRE>
pascal void Comp3to1   (const void *inBuffer, void *outBuffer, 
                        unsigned long cnt, const void *inState, 
                        void *outState, unsigned long numChannels, 
                        unsigned long whichChannel);
pascal void Comp6to1   (const void *inBuffer, void *outBuffer, 
                        unsigned long cnt, const void *inState, 
                        void *outState, unsigned long numChannels, 
                        unsigned long whichChannel);
pascal void Exp1to3    (const void *inBuffer, void *outBuffer, 
                        unsigned long cnt, const void *inState, 
                        void *outState, unsigned long numChannels, 
                        unsigned long whichChannel);
pascal void Exp1to6    (const void *inBuffer, void *outBuffer, 
                        unsigned long cnt, const void *inState, 
                        void *outState, unsigned long numChannels, 
                        unsigned long whichChannel);
</PRE>
<A NAME=HEADING136-253></A>
<H4>Managing Double Buffers</H4>
<PRE>
pascal OSErr SndPlayDoubleBuffer
                    (SndChannelPtr chan, 
                     SndDoubleBufferHeaderPtr theParams);
</PRE>
<A NAME=HEADING136-256></A>
<H4>Performing Unsigned Fixed-Point Arithmetic</H4>
<PRE>
pascal UnsignedFixed UnsignedFixMulDiv
                    (UnsignedFixed value, UnsignedFixed multiplier, UnsignedFixed divisor);
</PRE>
<A NAME=HEADING136-259></A>
<H4>Linking Modifiers to Sound Channels</H4>
<PRE>
pascal OSErr SndAddModifier
                    (SndChannelPtr chan, Ptr modifier, short id, long init);
</PRE>
<A NAME=HEADING136-262></A>
<H3>Application-Defined Routines</H3>
<PRE>
pascal void MyFilePlayCompletionRoutine
                            (SndChannelPtr chan);
pascal void MyCallback      (SndChannelPtr chan, SndCommand *cmd);
pascal void MyDoubleBackProc
                            (SndChannelPtr chan, 
                             SndDoubleBufferPtr doubleBufferPtr);
</PRE>
<A NAME=HEADING136-268></A>
<H2>Assembly-Language Summary</H2>
<A NAME=HEADING136-269></A>
<H3>Data Structures</H3>
<A NAME=HEADING136-270></A>
<H4>SndCommand Data Structure
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>cmd<TD>word<TD>command number<TR>
<TD>2<TD>param1<TD>word<TD>first parameter<TR>
<TD>4<TD>param2<TD>long<TD>second parameter</TABLE>
</H4>
<A NAME=HEADING136-271></A>
<H4>AudioSelection Data Structure
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>0<TH><CODE>unitType</CODE><TH>long<TH>type of time unit<TR>
<TD>4<TD>selStart<TD>4 bytes<TD>starting point of selection (Fixed)<TR>
<TD>8<TD>selEnd<TD>4 bytes<TD>ending point of selection (Fixed)</TABLE>
</H4>
<A NAME=HEADING136-272></A>
<H4>SCStatus Data Structure
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>0<TH>scStartTime<TH>4 bytes<TH>starting time for play from disk (Fixed)<TR>
<TD>4<TD>scEndTime<TD>4 bytes<TD>ending time for play from disk (Fixed)<TR>
<TD>8<TD>scCurrentTime<TD>4 bytes<TD>current time for play from disk (Fixed)<TR>
<TD>12<TD>scChannelBusy<TD>byte<TD>channel playing sampled sound flag<TR>
<TD>13<TD>scChannelDisposed<TD>byte<TD>reserved<TR>
<TD>14<TD>scChannelPaused<TD>byte<TD>play from disk is paused flag<TR>
<TD>15<TD>scUnused<TD>byte<TD>unused<TR>
<TD>16<TD>scChannelAttributes<TD>long<TD>attributes of channel<TR>
<TD>20<TD>scCPULoad<TD>long<TD>CPU load for channel</TABLE>
</H4>
<A NAME=HEADING136-273></A>
<H4>SMStatus Data Structure
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>smMaxCPULoad<TD>word<TD>maximum load on all channels<TR>
<TD>2<TD>smNumChannels<TD>word<TD>number of allocated channels<TR>
<TD>4<TD>smCurCPULoad<TD>word<TD>current load on all channels</TABLE>
</H4>
<A NAME=HEADING136-274></A>
<H4>SndChannel Data Structure
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>nextChan<TD>long<TD>pointer to next channel<TR>
<TD>4<TD>firstMod<TD>long<TD>used internally<TR>
<TD>8<TD>callBack<TD>long<TD>pointer to callback procedure<TR>
<TD>12<TD>userInfo<TD>long<TD>free for application's use<TR>
<TD>16<TD>wait<TD>long<TD>used internally<TR>
<TD>20<TD>cmdInProgress<TD>8 bytes<TD>used internally<TR>
<TD>28<TD>flags<TD>word<TD>used internally<TR>
<TD>30<TD>qLength<TD>word<TD>used internally<TR>
<TD>32<TD>qHead<TD>word<TD>used internally<TR>
<TD>34<TD>qTail<TD>word<TD>used internally<TR>
<TD>36<TD>queue<TD>variable<TD>queue of sound commands</TABLE>
</H4>
<A NAME=HEADING136-275></A>
<H4>SoundHeader Data Structure
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>samplePtr<TD>long<TD>pointer to samples (or <CODE>NIL</CODE> if samples follow data structure)<TR>
<TD>4<TD>length<TD>long<TD>number of samples in array<TR>
<TD>8<TD>sampleRate<TD>4 bytes<TD>sample rate (Fixed)<TR>
<TD>12<TD>loopStart<TD>long<TD>loop point beginning<TR>
<TD>16<TD>loopEnd<TD>long<TD>loop point ending<TR>
<TD>20<TD>encode<TD>byte<TD>sample's encoding option<TR>
<TD>21<TD>baseFrequency<TD>byte<TD>base frequency of sample<TR>
<TD>22<TD>sampleArea<TD>variable<TD>sampled-sound data</TABLE>
</H4>
<A NAME=HEADING136-276></A>
<H4>ExtSoundHeader Data Structure
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>samplePtr<TD>long<TD>pointer to samples (or <CODE>NIL</CODE> if samples follow data structure)<TR>
<TD>4<TD>numChannels<TD>long<TD>number of channels in sample<TR>
<TD>8<TD>sampleRate<TD>4 bytes<TD>sample rate (Fixed)<TR>
<TD>12<TD>loopStart<TD>long<TD>loop point beginning<TR>
<TD>16<TD>loopEnd<TD>long<TD>loop point ending<TR>
<TD>20<TD>encode<TD>byte<TD>sample's encoding option<TR>
<TD>21<TD>baseFrequency<TD>byte<TD>base frequency of sample<TR>
<TD>22<TD>numFrames<TD>long<TD>total number of frames<TR>
<TD>26<TD>AIFFSampleRate<TD>10 bytes<TD>rate of original sample (Extended80)<TR>
<TD>36<TD>markerChunk<TD>long<TD>reserved<TR>
<TD>40<TD>instrumentChunks<TD>long<TD>pointer to instrument info<TR>
<TD>44<TD>AESRecording<TD>long<TD>pointer to audio info<TR>
<TD>48<TD>sampleSize<TD>word<TD>number of bits per sample<TR>
<TD>50<TD>futureUse1<TD>word<TD>reserved<TR>
<TD>52<TD>futureUse2<TD>long<TD>reserved<TR>
<TD>56<TD>futureUse3<TD>long<TD>reserved<TR>
<TD>60<TD>futureUse4<TD>long<TD>reserved<TR>
<TD>64<TD>sampleArea<TD>variable<TD>sampled-sound data</TABLE>
</H4>
<A NAME=HEADING136-277></A>
<H4>CmpSoundHeader Data Structure
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>samplePtr<TD>long<TD>pointer to samples (or <CODE>NIL</CODE> if samples follow data structure)<TR>
<TD>4<TD>numChannels<TD>long<TD>number of channels in sample<TR>
<TD>8<TD>sampleRate<TD>4 bytes<TD>sample rate (Fixed)<TR>
<TD>12<TD>loopStart<TD>long<TD>loop point beginning<TR>
<TD>16<TD>loopEnd<TD>long<TD>loop point ending<TR>
<TD>20<TD>encode<TD>byte<TD>sample's encoding option<TR>
<TD>21<TD>baseFrequency<TD>byte<TD>base frequency of original sample<TR>
<TD>22<TD>numFrames<TD>long<TD>length of sample in frames<TR>
<TD>26<TD>AIFFSampleRate<TD>10 bytes<TD>rate of original sample (Extended80)<TR>
<TD>36<TD>markerChunk<TD>long<TD>reserved<TR>
<TD>40<TD>format<TD>OSType<TD>data format type<TR>
<TD>44<TD>futureUse2<TD>long<TD>reserved<TR>
<TD>48<TD>stateVars<TD>long<TD>pointer to <CODE>StateBlock</CODE><TR>
<TD>52<TD>leftOverSamples<TD>long<TD>pointer to <CODE>LeftOverBlock</CODE><TR>
<TD>56<TD>compressionID<TD>word<TD>ID of compression algorithm<TR>
<TD>58<TD>packetSize<TD>word<TD>number of bits per packet<TR>
<TD>60<TD>snthID<TD>word<TD>unused<TR>
<TD>62<TD>sampleSize<TD>word<TD>bits in each sample point<TR>
<TD>64<TD>sampleArea<TD>variable<TD>compressed sound data</TABLE>
</H4>
<A NAME=HEADING136-278></A>
<H4>SndDoubleBufferHeader Data Structure
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>dbhNumChannels<TD>word<TD>number of sound channels<TR>
<TD>2<TD>dbhSampleSize<TD>word<TD>sample size, if noncompressed<TR>
<TD>4<TD>dbhCompressionID<TD>word<TD>ID of compression algorithm<TR>
<TD>6<TD>dbhPacketSize<TD>word<TD>number of bits per packet<TR>
<TD>8<TD>dbhSampleRate<TD>4 bytes<TD>sample rate (Fixed)<TR>
<TD>12<TD>dbhBufferPtr<TD>2 longs<TD>pointers to <CODE>SndDoubleBuffer</CODE> data structures<TR>
<TD>20<TD>dbhDoubleBack<TD>long<TD>pointer to doubleback procedure</TABLE>
</H4>
<A NAME=HEADING136-279></A>
<H4>SndDoubleBuffer Data Structure
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>dbNumFrames<TD>long<TD>number of frames in buffer<TR>
<TD>4<TD>dbFlags<TD>long<TD>buffer status flags<TR>
<TD>8<TD>dbUserInfo<TD>2 longs<TD>for application's use<TR>
<TD>16<TD>dbSoundData<TD>variable<TD>array of data</TABLE>
</H4>
<A NAME=HEADING136-280></A>
<H4>ChunkHeader Data Structure
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>0<TH>ckID<TH>long<TH>chunk type ID<TR>
<TD>4<TD>ckSize<TD>long<TD>number of bytes of data</TABLE>
</H4>
<A NAME=HEADING136-281></A>
<H4>ContainerChunk Data Structure
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>0<TH>ckID<TH>long<TH>chunk type ID (<CODE>'FORM'</CODE>)<TR>
<TD>4<TD>ckSize<TD>long<TD>number of bytes of data<TR>
<TD>8<TD>formType<TD>long<TD>type of file</TABLE>
</H4>
<A NAME=HEADING136-282></A>
<H4>FormatVersionChunk Data Structure
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>ckID<TD>long<TD>chunk type ID (<CODE>'FVER'</CODE>)<TR>
<TD>4<TD>ckSize<TD>long<TD>number of bytes of data (4)<TR>
<TD>8<TD>timestamp<TD>long<TD>date of format version</TABLE>
</H4>
<A NAME=HEADING136-283></A>
<H4>CommonChunk Data Structure
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>ckID<TD>long<TD>chunk type ID (<CODE>'COMM'</CODE>)<TR>
<TD>4<TD>ckSize<TD>long<TD>number of bytes of data (18)<TR>
<TD>8<TD>numChannels<TD>word<TD>number of channels<TR>
<TD>10<TD>numSampleFrames<TD>long<TD>number of sample frames<TR>
<TD>14<TD>sampleSize<TD>word<TD>number of bits per sample<TR>
<TD>16<TD>sampleRate<TD>10 bytes<TD>number of frames per second (Extended80)</TABLE>
</H4>
<A NAME=HEADING136-284></A>
<H4>ExtCommonChunk Data Structure
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>ckID<TD>long<TD>chunk type ID (<CODE>'COMM'</CODE>)<TR>
<TD>4<TD>ckSize<TD>long<TD>number of bytes of data (22 + length of compression name)<TR>
<TD>8<TD>numChannels<TD>word<TD>number of channels<TR>
<TD>10<TD>numSampleFrames<TD>long<TD>number of sample frames<TR>
<TD>14<TD>sampleSize<TD>word<TD>number of bits per sample<TR>
<TD>16<TD>sampleRate<TD>10 bytes<TD>number of frames per second (Extended80)<TR>
<TD>26<TD>compressionType<TD>long<TD>compression type ID<TR>
<TD>30<TD>compressionName<TD>variable<TD>compression type name</TABLE>
</H4>
<A NAME=HEADING136-285></A>
<H4>SoundDataChunk
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>ckID<TD>long<TD>chunk type ID (<CODE>'SSND'</CODE>)<TR>
<TD>4<TD>ckSize<TD>long<TD>number of bytes of data<TR>
<TD>8<TD>offset<TD>long<TD>offset to sound data<TR>
<TD>12<TD>blockSize<TD>long<TD>size of alignment blocks</TABLE>
</H4>
<A NAME=HEADING136-286></A>
<H3>Trap Macros</H3>
<A NAME=HEADING136-287></A>
<H4>Trap Macro Requiring Routine Selectors</H4>
<PRE>
<CODE>_SoundDispatch</CODE></PRE>
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Selector<TH>Routine<TR>
<TD>$00000010<TD>MACEVersion<TR>
<TD>$00040010<TD>Comp3to1<TR>
<TD>$00080010<TD>Exp1to3<TR>
<TD>$000C0008<TD>SndSoundManagerVersion<TR>
<TD>$000C0010<TD>Comp6to1<TR>
<TD>$00100008<TD>SndChannelStatus<TR>
<TD>$00100010<TD>Exp1to6<TR>
<TD>$00140008<TD>SndManagerStatus<TR>
<TD>$00180008<TD>SndGetSysBeepState<TR>
<TD>$001C0008<TD>SndSetSysBeepState<TR>
<TD>$00200008<TD>SndPlayDoubleBuffer<TR>
<TD>$02040008<TD>SndPauseFilePlay<TR>
<TD>$02240024<TD><CODE>GetSysBeepVolume</CODE><TR>
<TD>$02280024<TD><CODE>SetSysBeepVolume</CODE><TR>
<TD>$022C0024<TD><CODE>GetDefaultOutputVolume</CODE><TR>
<TD>$02300024<TD><CODE>SetDefaultOutputVolume</CODE><TR>
<TD>$03080008<TD>SndStopFilePlay<TR>
<TD>$0D000008<TD>SndStartFilePlay<TR>
<TD>$04040024<TD>GetSoundHeaderOffset</TABLE>

</PRE>
<A NAME=HEADING136-289></A>
<H2>Result Codes
<TABLE BORDER="0" CELLPADDING=3><TD>noErr<TD>0<TD>No error<TR>
<TD>paramErr<TD>-50<TD>A parameter is incorrect<TR>
<TD>noHardwareErr<TD>-200<TD>Required sound hardware not available<TR>
<TD>notEnoughHardwareErr<TD>-201<TD>Insufficient hardware available<TR>
<TD>queueFull<TD>-203<TD>No room in the queue<TR>
<TD>resProblem<TD>-204<TD>Problem loading the resource<TR>
<TD>badChannel<TD>-205<TD>Channel is corrupt or unusable<TR>
<TD>badFormat<TD>-206<TD>Resource is corrupt or unusable<TR>
<TD>notEnoughBufferSpace<TD>-207<TD>Insufficient memory available<TR>
<TD>badFileFormat<TD>-208<TD>File is corrupt or unusable, or not AIFF or AIFF-C<TR>
<TD>channelBusy<TD>-209<TD>Channel is busy<TR>
<TD>buffersTooSmall<TD>-210<TD>Buffer is too small<TR>
<TD>channelNotBusy<TD>-211<TD>Channel not currently used<TR>
<TD>noMoreRealTime<TD>-212<TD>Not enough CPU time available<TR>
<TD>siInvalidCompression<TD>-223<TD>Invalid compression type</TABLE>
</H2>
 <A NAME=MARKER-2-958></A><P>
</BLOCKQUOTE><P>
</DL>
</DL>
</B>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Sound-135.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Sound-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Sound-336.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Sound-137.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Sound-3.html">&copy; Apple Computer, Inc.</A><br>2 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
