<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Instruments User Guide: Creating Custom Instruments with DTrace</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Creating Custom Instruments with DTrace"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40004652-CH4" title="Creating Custom Instruments with DTrace"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000436" target="_top">Tools</a> &gt; <a href="../../../Performance-date.html#//apple_ref/doc/uid/TP30000440-TP30000436-TP30000901" target="_top">Performance</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP40004652-CH1-SW1">Instruments User Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../SavingTraceTemplates/SavingTraceTemplates.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../Built-InInstruments/Built-InInstruments.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40004652-CH4-SW1" title="Creating Custom Instruments with DTrace"></a><a name="//apple_ref/doc/writerid/xrpt_Creating_Custom_Instruments" title="Creating Custom Instruments with DTrace"></a><h1>Creating Custom Instruments with DTrace</h1><p>The built-in instruments of the Instruments application can provide a great deal of information about the inner workings of your program. Sometimes, though, you may want to tailor the information being gathered more closely to your own code. For example, instead of gathering data every time a function is called, you might want to set conditions on when data is gathered. Alternatively, you might want to dig deeper into your own code than the built-in instruments allow. For these situations, Instruments lets you create custom instruments. </p><p>Custom instruments use DTrace for their implementation. DTrace is a dynamic tracing facility originally created by Sun and ported to Mac OS X v10.5. Because DTrace taps into the operating system kernel, you have access to low-level operation about the kernel itself and about the user processes running on your computer. Many of the built-in instruments are already based on DTrace. And even though DTrace is itself a very powerful and complex tool, Instruments provides a simple interface that gives you access to the power of DTrace without the complexity.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40004652-CH4-DontLinkElementID_3" title="Important:"></a><p><strong>Important:</strong>&nbsp;Although the custom instrument builder simplifies the process of creating DTrace probes, you should still be familiar with DTrace and how it works before creating new instruments. Many of the more powerful debugging and data gathering actions require you to write DTrace scripts. To learn about DTrace and the D scripting language, see the <em>Solaris Dynamic Tracing Guide</em>, available from the <span class="content_text"><a href="http://www.opensolaris.org/os/downloads/docs/" target="_blank">OpenSolaris website</a></span>. For information about the <code>dtrace</code> command-line tool, see <code><a href="../../../../Darwin/Reference/ManPages/man1/dtrace.1.html#//apple_ref/doc/man/1/dtrace" target="_top">dtrace</a></code> man page.  </p><p></p></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40004652-CH4-SW15" title="Note"></a><p><strong>Note:</strong>&nbsp;Several Apple applications—namely iTunes, DVD Player, and Front Row, and applications that use QuickTime—prevent the collection of data through DTrace (either temporarily or permanently) in order to protect sensitive data. Therefore, you should not run those applications when performing systemwide data collection.</p></div><p>The following sections show you how to create a custom instrument and how to use that instrument both with the Instruments application and the <code>dtrace</code> command-line tool. </p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="CreatingaCustomInstrument.html#//apple_ref/doc/uid/TP40004652-CH4-SW16">About Custom Instruments</a>
				
			<br/>
			
        
			
			
				<a href="CreatingaCustomInstrument.html#//apple_ref/doc/uid/TP40004652-CH4-SW17">Creating a Custom Instrument</a>
				
			<br/>
			
        
			
			
				<a href="CreatingaCustomInstrument.html#//apple_ref/doc/uid/TP40004652-CH4-SW7">Tips for Writing Custom Scripts</a>
				
			<br/>
			
        
			
			
				<a href="CreatingaCustomInstrument.html#//apple_ref/doc/uid/TP40004652-CH4-SW13">Exporting DTrace Scripts</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40004652-CH4-SW16" title="About Custom Instruments"></a><h2>About Custom Instruments</h2><p>Custom instruments are built using DTrace probes. A <strong>probe</strong> is like a sensor that you place in your code. It corresponds to a location or event, such as a function entry point, to which DTrace can bind. When the function executes or the event is generated, the associated probe fires and DTrace runs whatever <strong>actions</strong> are associated with the probe. Most DTrace actions simply collect data about the operating system and user program behavior at that moment. It is possible, however, to run custom scripts as part of an action. Scripts let you use the features of DTrace to fine tune the data you gather. </p><p>Probes fire each time they are encountered, but the action associated with the probe need not be run every time the probe fires. A <strong>predicate</strong> is a conditional statement that lets you restrict when the probe’s action is run. For example, you can restrict a probe to a specific process or user, or you can run the action when a specific condition in your instrument is true. By default, probes do not have any predicates, meaning that the associated action runs every time the probe fires. You can add any number of predicates to a probe, however, and link them together using AND and OR operators to create complex decision trees.</p><p>An instrument consists of the following blocks: </p><ul class="ul"><li class="li"><p>A description block, which contains the name, category, and description of the instrument</p></li><li class="li"><p>One or more probes, each containing its associated actions and predicates</p></li><li class="li"><p>A DATA declaration area, which you use to declare global variables shared by all probes </p></li><li class="li"><p>A BEGIN script, which initializes any global variables and performs any startup tasks required by the instrument</p></li><li class="li"><p>An END script, which performs any final clean up actions</p></li></ul><p>All instruments must have at least one probe with its associated actions. Similarly, all instruments should have an appropriate name and description to identify them to Instruments users. Instruments displays your instrument’s descriptive information in the library window. Providing good information makes it easier to remember what the instrument does and how it should be used. </p><p>Probes are not required to have global data or begin and end scripts. Those elements are used in advanced instrument design when you want to share data among probes or provide some sort of initial configuration for your instrument. The creation of DATA, BEGIN, and END blocks is described in <span class="content_text"><a href="CreatingaCustomInstrument.html#//apple_ref/doc/uid/TP40004652-CH4-SW7">“Tips for Writing Custom Scripts.”</a></span>  </p><a name="//apple_ref/doc/uid/TP40004652-CH4-SW17" title="Creating a Custom Instrument"></a><h2>Creating a Custom Instrument</h2><p>To create a custom DTrace instrument, select Instrument > Build New Instrument. (You can also choose Add Instrument > DTrace Instrument from the action menu of your trace document to perform the same action.) This command displays the instrument configuration sheet, which is shown in <span class="content_text">Figure 7-1</span>. You use this sheet to specify your instrument information, including any probes and custom scripts. </p><br/><div><a name="//apple_ref/doc/uid/TP40004652-CH4-SW3" title="Figure 7-1The instrument configuration sheet"></a><p><strong>Figure 7-1&nbsp;&nbsp;</strong>The instrument configuration sheet</p><img src = "../Art/custom_instrument_editor.jpg" alt = "The instrument configuration sheet" ></div><br/><p>At a minimum, you should provide the following information for every instrument you create: </p><ul class="ul"><li class="li"><p>Name. The name associated with your custom instrument in the library.</p></li><li class="li"><p>Category. The category in which your instrument appears in the library. You can specify the name of an existing category—such as Memory—or create your own.</p></li><li class="li"><p>Description. The instrument description and is used in both the library window and in the instrument’s help tag. </p></li><li class="li"><p>Probe provider. The probe type and the details of when it should fire. Typically, this involves specifying the method or function to which the probe applies. For more information, see <span class="content_text"><a href="CreatingaCustomInstrument.html#//apple_ref/doc/uid/TP40004652-CH4-SW5">“Specifying the Probe Provider”</a></span></p></li><li class="li"><p>Probe action. The data to record or the script to execute when your probe fires; see <span class="content_text"><a href="CreatingaCustomInstrument.html#//apple_ref/doc/uid/TP40004652-CH4-SW12">“Adding Actions to a Probe.”</a></span> </p></li></ul><p>An instrument should contain at least one probe and may contain more than one. The probe definition consists of the provider information, predicate information, and action. All probes must specify the provider information at a minimum, and nearly all probes define some sort of action. The predicate portion of a probe definition is optional but can be a very useful tool for focusing your instrument on the correct data. </p><a name="//apple_ref/doc/uid/TP40004652-CH4-SW18" title="Adding and Deleting Probes"></a><h3>Adding and Deleting Probes</h3><p>Every new instrument comes with one probe that you can configure. To add more probes, click the plus (+) button at the bottom of the instrument configuration sheet. </p><p>To remove a probe from your instrument, click the probe to select it and press the minus (-) button.  </p><p>When adding probes, it is a good idea to provide a descriptive name for the probe. By default, Instruments enumerates probes with names like “Probe 1” and “Probe 2”. </p><a name="//apple_ref/doc/uid/TP40004652-CH4-SW5" title="Specifying the Probe Provider"></a><h3>Specifying the Probe Provider</h3><p>To specify the location point or event that triggers a probe, you must associate the appropriate provider with the probe. <strong>Providers</strong> are kernel modules that act as agents for DTrace, providing the instrumentation necessary to create probes. You do not need to know how providers operate to create an instrument, but you do need to know the basic capabilities of each provider. <span class="content_text">Table 7-1</span> lists the providers that are supported by the Instruments application and available for use in your custom instruments. The Provider column lists the name displayed in the instrument configuration sheet while the DTrace provider column lists the actual name of the provider used in the corresponding DTrace script. </p><a name="//apple_ref/doc/uid/TP40004652-CH4-SW8" title="Table 7-1DTrace providers"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 7-1&nbsp;&nbsp;</strong>DTrace providers</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Provider</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>DTrace provider</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p>User Process</p></td><td ><p><code>pid</code></p></td><td ><p>The probe fires on entry (or return) of the specified function in your code. You must provide the function name and the name of the library that contains it. </p></td></tr><tr><td  scope="row"><p>Objective-C</p></td><td ><p><code>objc</code></p></td><td ><p>The probe fires on entry (or return) of the specified Objective-C method. You must provide the method name and the class to which it belongs.</p></td></tr><tr><td  scope="row"><p>System Call</p></td><td ><p><code>syscall</code></p></td><td ><p>The probe fires on entry (or return) of the specified system library function.</p></td></tr><tr><td  scope="row"><p>DTrace</p></td><td ><p><code>DTrace</code></p></td><td ><p>The probe fires when DTrace itself enters a BEGIN, END, or ERROR block.</p></td></tr><tr><td  scope="row"><p>Kernel Function Boundaries</p></td><td ><p><code>fbt</code></p></td><td ><p>The probe fires on entry (or return) of the specified kernel function in your code. You must provide the kernel function name and the name of the library that contains it. </p></td></tr><tr><td  scope="row"><p>Mach</p></td><td ><p><code>mach_trap</code></p></td><td ><p>The probe fires on entry (or return) of the specified Mach library function.</p></td></tr><tr><td  scope="row"><p>Profile</p></td><td ><p><code>profile</code></p></td><td ><p>The probe fires regularly at the specified time interval on each core of the machine. Profile probes can fire with a granularity that ranges from microseconds to days.  </p></td></tr><tr><td  scope="row"><p>Tick</p></td><td ><p><code>tick</code></p></td><td ><p>The probe fires at periodic intervals on one core of the machine. Tick probes can fire with a granularity that ranges from microseconds to days. You might use this provider to perform periodic tasks that are not required to be on a particular core.</p></td></tr><tr><td  scope="row"><p>I/O</p></td><td ><p><code>io</code></p></td><td ><p>The probe fires at the start of the specified kernel routine. For a list of functions monitored by this probe, use the <code>dtrace -l</code> command from Terminal to get a list of probe points. You can then search this list for probes monitored by the <code>io</code> module. </p></td></tr><tr><td  scope="row"><p>Kernel Process</p></td><td ><p><code>proc</code></p></td><td ><p>The probe fires on the initiation of one of several kernel-level routines. For a list of functions monitored by this probe, use the <code>dtrace -l</code> command from Terminal to get a list of probe points. You can then search this list for functions monitored by the <code>proc</code> module. </p></td></tr><tr><td  scope="row"><p>User-Level Synchronization</p></td><td ><p><code>plockstat</code></p></td><td ><p>The probe fires at one of several synchronization points. You can use this provider to monitor mutex and read-write lock events. </p></td></tr><tr><td  scope="row"><p>Core Data</p></td><td ><p><code>CoreData</code></p></td><td ><p>The probe fires at one of several Core Data–specific events. For a list of methods monitored by this probe, use the <code>dtrace -l</code> command from Terminal to get a list of probe points. You can then search this list for methods monitored by the <code>CoreData</code> module.</p></td></tr><tr><td  scope="row"><p>Ruby</p></td><td ><p><code>ruby</code></p></td><td ><p>The probe fires at one of several Ruby-specific events. </p></td></tr></table></div><p>After selecting the provider for your probe, you need to specify the information needed by the probe. For function-level probes, this may require entering function or method name along with the code module or class containing it. Some providers may simply involve selecting the appropriate events from a pop-up menu. </p><p>After you have configured a probe, you can proceed to add additional predicates to it (to determine when it should fire) or you can go ahead and define the action for that probe.</p><a name="//apple_ref/doc/uid/TP40004652-CH4-SW2" title="Adding Predicates to a Probe"></a><h3>Adding Predicates to a Probe</h3><p>Predicates let you control when a probe’s action is executed by Instruments. You can use them to prevent Instruments from gathering data in situations you do not care about or that might provide erroneous information. For example, if your code exhibits unusual behavior only when the stack reaches a certain depth, you could use a predicate to specify the minimum target stack depth. Every time a probe fires, Instruments evaluates the associated predicates. Only if they evaluate to true does DTrace perform the associated actions. </p><p>To add a predicate to a probe, click the plus (+) button at the end of the Probe line. Instruments adds a new predicate to the probe, as shown in <span class="content_text">Figure 7-2</span>. You can add subsequent predicates using the plus (+) buttons of either the probe or the predicate. To remove a predicate, click the minus (-) button next to the predicate. To rearrange predicates, click the handle along the left side of the predicate line and drag it to a new location. </p><br/><div><a name="//apple_ref/doc/uid/TP40004652-CH4-SW4" title="Figure 7-2Adding a predicate"></a><p><strong>Figure 7-2&nbsp;&nbsp;</strong>Adding a predicate</p><img src = "../Art/custom_instrument_predicate.jpg" alt = "Adding a predicate" ></div><br/><p>Instruments evaluates predicates from top to bottom in the order they appear. You can link predicates using the AND and OR operators but you cannot group them to create nested condition blocks. Instead, you must order your predicates carefully to ensure all of the appropriate conditions are checked. </p><p>The first pop-up menu in a predicate line lets you choose the data to inspect as part of the condition. <span class="content_text">Table 7-2</span> lists the standard variables defined by DTrace that you can use in your predicates or script code. The Variable column lists the name as it appears in the instrument configuration panel, while the DTrace variable column lists the actual name of the variable used in corresponding DTrace scripts. In addition to the standard variables, you can test against custom variables and constants from your script code by specifying the Custom variable type in the predicate field. </p><a name="//apple_ref/doc/uid/TP40004652-CH4-SW9" title="Table 7-2DTrace variables"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 7-2&nbsp;&nbsp;</strong>DTrace variables</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Variable</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>DTrace variable</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p>Caller</p></td><td ><p><code>caller</code></p></td><td ><p>The value of the current thread’s program counter just before entering the probe. This variable contains an integer value. </p></td></tr><tr><td  scope="row"><p>Chip</p></td><td ><p><code>chip</code></p></td><td ><p>The identifier for the physical chip executing the probe. This is a 0-based integer indicating the index of the current core. For example, a four core machine has cores 0 through 3. </p></td></tr><tr><td  scope="row"><p>CPU</p></td><td ><p><code>cpu</code></p></td><td ><p>The identifier for the CPU executing the probe. This is a 0-based integer indicating the index of the current core. For example, a four core machine has cores 0 through 3.</p></td></tr><tr><td  scope="row"><p>Current Working Directory</p></td><td ><p><code>cwd</code></p></td><td ><p>The current working directory of the current process. This variable contains a string value. </p></td></tr><tr><td  scope="row"><p>Last Error #</p></td><td ><p><code>errno</code></p></td><td ><p>The error value returned by the last system call made on the current thread. This variable contains an integer value.</p></td></tr><tr><td  scope="row"><p>Executable</p></td><td ><p><code>execname</code></p></td><td ><p>The name that was passed to <code>exec</code> to execute the current process. This variable contains a string value.</p></td></tr><tr><td  scope="row"><p>User ID</p></td><td ><p><code>uid</code></p></td><td ><p>The real user ID of the current process. This variable contains an integer value.</p></td></tr><tr><td  scope="row"><p>Group ID</p></td><td ><p><code>gid</code></p></td><td ><p>The real group ID of the current process. This variable contains an integer value.</p></td></tr><tr><td  scope="row"><p>Process ID</p></td><td ><p><code>pid</code></p></td><td ><p>The process ID of the current process. This variable contains an integer value.</p></td></tr><tr><td  scope="row"><p>Parent ID</p></td><td ><p><code>ppid</code></p></td><td ><p>The process ID of the parent process. This variable contains an integer value.</p></td></tr><tr><td  scope="row"><p>Thread ID</p></td><td ><p><code>tid</code></p></td><td ><p>The thread ID of the current thread. This is the same value returned by the <code><a href="../../../../Darwin/Reference/ManPages/man3/pthread_self.3.html#//apple_ref/doc/man/3/pthread_self" target="_top">pthread_self</a></code> function. </p></td></tr><tr><td  scope="row"><p>Interrupt Priority Level</p></td><td ><p><code>ipl</code></p></td><td ><p>The interrupt priority level on the current CPU at the time the probe fired. This variable contains an unsigned integer value.</p></td></tr><tr><td  scope="row"><p>Function</p></td><td ><p><code>probefunc</code></p></td><td ><p>The function name part of the probe’s description. This variable contains a string value. </p></td></tr><tr><td  scope="row"><p>Module</p></td><td ><p><code>probemod</code></p></td><td ><p>The module name part of the probe’s description. This variable contains a string value.</p></td></tr><tr><td  scope="row"><p>Name</p></td><td ><p><code>probename</code></p></td><td ><p>The name portion of the probe’s description. This variable contains a string value.</p></td></tr><tr><td  scope="row"><p>Provider</p></td><td ><p><code>probeprov</code></p></td><td ><p>The provider name part of the probe’s description. This variable contains a string value.</p></td></tr><tr><td  scope="row"><p>Root Directory</p></td><td ><p><code>root</code></p></td><td ><p>The root directory of the process. This variable contains a string value.</p></td></tr><tr><td  scope="row"><p>Stack Depth</p></td><td ><p><code>stackdepth</code></p></td><td ><p>The stack frame depth of the current thread at the time the thread fired. This variable contains an unsigned integer value.</p></td></tr><tr><td  scope="row"><p>Relative Timestamp</p></td><td ><p><code>timestamp</code></p></td><td ><p>The current value of the system’s timestamp counter, measured in nanoseconds. Because this counter increments from an arbitrary point in the past, you should use it to calculate only relative time differences. This variable contains an unsigned 64-bit integer value.</p></td></tr><tr><td  scope="row"><p>Virtual Timestamp</p></td><td ><p><code>vtimestamp</code></p></td><td ><p>The amount of time the current thread has been running, measured in nanoseconds. This value does not include time spent in DTrace predicates and actions. This variable contains an unsigned 64-bit integer value.</p></td></tr><tr><td  scope="row"><p>Timestamp</p></td><td ><p><code>walltimestamp/1000</code></p></td><td ><p>The current number of nanoseconds that have elapsed since 00:00 Universal coordinated Time, January 1, 1970. This variable contains an unsigned 64-bit integer value.</p></td></tr><tr><td  scope="row"><p><code>arg0</code> through <code>arg9</code></p></td><td ><p><code>arg0</code> through <code>arg9</code></p></td><td ><p>The first 10 arguments to the probe represented as raw 64-bit integers. If fewer than ten arguments were passed to the probe, the remaining variables contain the value 0.</p></td></tr><tr><td  scope="row"><p>Custom</p></td><td ><p>The name of your variable</p></td><td ><p>Use this option to specify a variable or constant from one of your scripts.</p></td></tr></table></div><p>In addition to the condition variable, you must specify the comparison operator and the target value. </p><a name="//apple_ref/doc/uid/TP40004652-CH4-SW12" title="Adding Actions to a Probe"></a><h3>Adding Actions to a Probe</h3><p>When a probe point defined by your instrument is hit, and the probe’s predicate conditions evaluate to true, DTrace runs the actions associated with the probe. You use your probe’s actions to gather data or to perform some additional processing. For example, if your probe monitors a specific function or method, you could have it return the caller of that function and any stack trace information to Instruments. If you wanted a slightly more advanced action, you could use a script variable to track the number of times the function was called and report that information as well. And if you wanted an even more advanced action, you could write a script that uses kernel-level DTrace functions to determine the status of a lock used by your function. In this latter case, your script code might also return the current owner of the lock (if there is one) to help you determine the interactions among your code’s different threads. </p><p><span class="content_text">Figure 7-3</span> shows the portion of the instrument configuration sheet where you specify your probe’s actions. The script portion simply contains a text field for you to type in your script code. (Instruments does not validate your code before passing it to DTrace, so check your code carefully.) The bottom section contains controls for specifying the data you want DTrace to return to Instruments. You can use the pop-up menus to configure the built-in DTrace variables you want to return. You can also select Custom from this pop-up menu and return one of your script variables. </p><br/><div><a name="//apple_ref/doc/uid/TP40004652-CH4-SW10" title="Figure 7-3Configuring a probe&acirc;&#128;&#153;s action"></a><p><strong>Figure 7-3&nbsp;&nbsp;</strong>Configuring a probe’s action</p><img src = "../Art/custom_instrument_editor_bottom.jpg" alt = "Configuring a probe’s action" ></div><br/><p>When you configure your instrument to return a custom variable, Instruments asks you to provide the following information:</p><ul class="spaceabove"><li class="li"><p>The script variable containing the data</p></li><li class="li"><p>The name to apply to the variable in your instrument interface</p></li><li class="li"><p>The type of the variable</p></li></ul><p>Any data your probe returns to Instruments is collected and displayed in your instrument’s Detail pane. The Detail pane displays all data variables regardless of type. If stack trace information is available for a specific probe, Instruments displays that information in your instrument’s Extended Detail pane. In addition, Instruments automatically looks for integer data types returned by your instrument and adds those types to the list of statistics your instrument can display in the track pane.</p><p>Because DTrace scripts run in kernel space and the Instruments application runs in user space, if you want to return the value of a custom pointer-based script variable to Instruments, you must create a buffer to hold the variable’s data. The simplest way to create a buffer is to use the <code>copyin</code> or <code>copyinstr</code> subroutines found in DTrace. The <code>copyinstr</code> subroutine takes a pointer to a C string and returns the contents of the string in a form you can return to Instruments. Similarly, the <code>copyin</code> subroutine takes a pointer and size value and returns a buffer to the data, which you can later format into a string using the <code>stringof</code> keyword. Both of these subroutines are part of the DTrace environment and can be used from any part of your probe’s action definition. For example, to return the string from a C-style string pointer, you would simply wrap the variable name with the <code>copyinstr</code> subroutine as shown in <span class="content_text">Figure 7-4</span>.  </p><br/><div><a name="//apple_ref/doc/uid/TP40004652-CH4-SW11" title="Figure 7-4Returning a string pointer"></a><p><strong>Figure 7-4&nbsp;&nbsp;</strong>Returning a string pointer</p><img src = "../Art/print_strings.jpg" alt = "Returning a string pointer" ></div><br/><div class="importantbox"><a name="//apple_ref/doc/uid/TP40004652-CH4-DontLinkElementID_4" title="Important:"></a><p><strong>Important:</strong>&nbsp;Instruments automatically wraps built-in variables (such as the <code>arg0</code> through <code>arg9</code> function arguments) with a call to <code>copyinstr</code> if the variable type is set to string. It does not do this with your script’s custom variables, however. You are responsible for ensuring that the data in a custom variable actually matches the type specified for that variable. </p><p></p></div><p>For a list of the built-in variables supported by Instruments, see <span class="content_text"><a href="CreatingaCustomInstrument.html#//apple_ref/doc/uid/TP40004652-CH4-SW9">Table 7-2</a></span>. For more information on scripts and script variables, see <span class="content_text"><a href="CreatingaCustomInstrument.html#//apple_ref/doc/uid/TP40004652-CH4-SW7">“Tips for Writing Custom Scripts.”</a></span> For more information on DTrace subroutines, including the <code>copyin</code> and <code>copyinstr</code> subroutines, see the <em>Solaris Dynamic Tracing Guide</em> available from the <span class="content_text"><a href="http://www.opensolaris.org/os/downloads/docs/" target="_blank">OpenSolaris website</a></span>.</p><a name="//apple_ref/doc/uid/TP40004652-CH4-SW7" title="Tips for Writing Custom Scripts"></a><h2>Tips for Writing Custom Scripts</h2><p>You write DTrace scripts using the D scripting language, whose syntax is derived from a large subset of the C programming language. The D language combines the programming constructs of the C language with a special set of functions and variables to help you trace information in your program. </p><p>The following sections describe some of the common ways to use scripts in your custom instruments. These sections do not provide a comprehensive overview of the D language or the process for writing DTrace scripts, however. For information about scripting and the D language, see the <em>Solaris Dynamic Tracing Guide</em>, available on the <span class="content_text"><a href="http://www.opensolaris.org/os/downloads/docs/" target="_blank">OpenSolaris website</a></span>.</p><a name="//apple_ref/doc/uid/TP40004652-CH4-SW19" title="Writing BEGIN and END Scripts"></a><h3>Writing BEGIN and END Scripts</h3><p>If you want to do more than return the information in DTrace’s built-in variables to Instruments whenever your action fires, you need to write custom scripts. Scripts interact directly with DTrace at the kernel level, providing access to low-level information about the kernel and the active process. Most instruments use scripts to gather information not readily available from DTrace. You can also use scripts to manipulate raw data before returning it to Instruments. For example, you could use a script to normalize a data value to a specific range if you wanted to make it easier to compare that value graphically with other values in your instrument’s track pane.</p><p>In Instruments, the custom instrument configuration sheet provides several areas where you can write DTrace scripts: </p><ul class="spaceabove"><li class="li"><p>The DATA section contains definitions of any global variables you want to use in your instrument.</p></li><li class="li"><p>The BEGIN section contains any initialization code for your instrument. </p></li><li class="li"><p>Each probe contains script code as part of its action.</p></li><li class="li"><p>The END section contains any clean up code for your instrument. </p></li></ul><p>All script sections are optional. You are not required to have initialization scripts or clean up scripts if your instrument does not need them. If your instrument defines global variables in its DATA section, however, it is recommended that you also provide an initialization script to set those variables to a known value. The D language does not allow you to assign values inline with your global variable declarations, so you must put those assignments in your BEGIN section. For example, a simple DATA section might consist of a single variable declaration, such as the following:</p><div class="codesample"><table><tr><td scope="row"><pre>int myVariable;<span></span></pre></td></tr></table></div><p>The corresponding BEGIN section would then contain the following code to initialize that variable:</p><div class="codesample"><table><tr><td scope="row"><pre>myVariable = 0;<span></span></pre></td></tr></table></div><p>If your corresponding probe actions change the value of <code>myVariable</code>, you might use the END section of your probe to format and print out the final value of the variable.</p><p>Most of your script code is likely to be associated with individual probes. Each probe can have a script associated with its action. When it comes time to execute a probe’s action, DTrace runs your script code first and then returns any requested data back to Instruments. Because passing data back to Instruments involves copying data from the kernel space back to the Instruments program space, you should always pass data back to Instruments by configuring the appropriate entries in the “Record the following data:“ section of the instrument configuration sheet. Variables returned manually from your script code may not be returned correctly to Instruments. </p><a name="//apple_ref/doc/uid/TP40004652-CH4-SW20" title="Accessing Kernel Data from Custom Scripts"></a><h3>Accessing Kernel Data from Custom Scripts</h3><p>Because DTrace scripts execute inside the system kernel, they have access to kernel symbols. If you want to look at global kernel variables and data structures from your custom instruments, you can do so in your DTrace scripts. To access a kernel variable, you must precede the name of the variable with a single back quote character (<code>`</code>). The back quote character tells DTrace to look for the specified variable outside of the current script.</p><p><span class="content_text">Listing 7-1</span> shows a sample action script that retrieves the current load information from the <code>avenrun</code> kernel variable and uses that variable to calculate one-minute average load of the system. If you were to create a probe using the Profile provider, you could have this script gather load data periodically and then graph that information in Instruments.</p><a name="//apple_ref/doc/uid/TP40004652-CH4-SW14" title="Listing 7-1Accessing kernel variables from a DTrace script"></a><p class="codesample"><strong>Listing 7-1&nbsp;&nbsp;</strong>Accessing kernel variables from a DTrace script</p><div class="codesample"><table><tr><td scope="row"><pre>this->load1a = `avenrun[0]/1000;<span></span></pre></td></tr><tr><td scope="row"><pre>this->load1b = ((`avenrun[0] % 1000) * 100) / 1000;<span></span></pre></td></tr><tr><td scope="row"><pre>this->load1 = (100 * this->load1a) + this->load1b;<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40004652-CH4-SW21" title="Scoping Variables Appropriately"></a><h3>Scoping Variables Appropriately</h3><p>DTrace scripts have an essentially flat structure, due to a lack of flow control statements and the desire to keep probe execution time to a minimum. Variables in DTrace scripts, however, can be scoped to different levels depending on your need. <span class="content_text">Table 7-3</span> lists the scoping levels for variables and the syntax for using variables at each level. </p><a name="//apple_ref/doc/uid/TP40004652-CH4-SW6" title="Table 7-3Variable scope in DTrace scripts"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 7-3&nbsp;&nbsp;</strong>Variable scope in DTrace scripts</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Scope</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Syntax example</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p>Global</p></td><td ><p><code>myGlobal = 1;</code></p></td><td ><p>Global variables are identified simply using the variable name. All probe actions on all system threads have access to variables in this space. </p></td></tr><tr><td  scope="row"><p>Thread</p></td><td ><p><code>self->myThreadVar = 1;</code></p></td><td ><p>Thread-local variables are dereferenced from the <code>self</code> keyword. All probe actions running on the same thread have access to variables in this space. You might use this scope to collect data over the course of several runs of a probe’s action on the current thread.</p></td></tr><tr><td  scope="row"><p>Probe</p></td><td ><p><code>this->myLocalVar = 1;</code></p></td><td ><p>Probe-local variables are dereferenced using the <code>this</code> keyword. Only the current running probe has access to variables in this space. Typically, you use this scope to define temporary variables that you want the kernel to clean up when the current action ends.  </p></td></tr></table></div><a name="//apple_ref/doc/uid/TP40004652-CH4-SW22" title="Finding Script Errors"></a><h3>Finding Script Errors</h3><p>If the script code for one of your custom instruments contains an error, Instruments displays an error message in the track pane when the script is compiled by DTrace. Instruments reports the error after you press the Record button in your trace document but before tracing actually begins. Inside the error message bubble is an Edit button. Clicking this button opens the instrument configuration sheet, which now identifies the probe with the error. </p><a name="//apple_ref/doc/uid/TP40004652-CH4-SW13" title="Exporting DTrace Scripts"></a><h2>Exporting DTrace Scripts</h2><p>Although Instruments provides a convenient interface for gathering trace data, there are still times when it is move convenient to gather trace data directly using DTrace. If you are a system administrator or are writing automated test scripts, for example, you might prefer to use the DTrace command-line interface to launch a process and gather the data. Using the command-line tool requires you to write your own DTrace scripts, however, which can be time consuming and can lead to errors. If you already have a trace document with one or more DTrace-based instruments, you can use the Instruments application to generate a DTrace script that provides the same behavior as the instruments in your trace document. </p><p>Instruments supports exporting DTrace scripts only for documents where all of the instruments are based on DTrace. This means that your document can include custom instruments and a handful of the built-in instruments, such as the instruments in the File System and CoreData groups in the Library window. Information about whether an instrument is DTrace-based is included with the instrument description in <span class="content_text"><a href="../Built-InInstruments/Built-InInstruments.html#//apple_ref/doc/uid/TP40004652-CH6-SW1">“Built-in Instruments.”</a></span> </p><p>To export a DTrace script, select the trace document containing the instruments and choose File > DTrace Script Export. This command places the script commands for your instruments in a text file that you can then pass to the <code>dtrace</code> command-line tool using the <code>-s</code> option. For example, if you exported a script named MyInstrumentsScript.d, you would run it from Terminal using the following command:</p><div class="codesample"><table><tr><td scope="row"><pre>sudo dtrace -s MyInstrumentsScript.d<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40004652-CH4-SW23" title="Note"></a><p><strong>Note:</strong>&nbsp;You must have superuser privileges to run <code>dtrace</code> in most instances, which is why the <code>sudo</code> command is used to run <code>dtrace</code> in the preceding example. </p></div><p>Another advantage of exporting your scripts from Instruments (as opposed to writing it manually) is that after running the script, you can import the resulting data back into Instruments and review it there. Scripts exported from Instruments print a start marker (with the text <code>&lt;dtrace_output_begin></code>) at the beginning of the dtrace output. To gather the data, simply copy all of the DTrace output (including the start marker) from Terminal and paste it into a text file, or just redirect the output from the <code>dtrace</code> tool directly to a file. To import the data in Instruments, select the trace document from which you generated the original script and choose File > DTrace Data Import.  </p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../SavingTraceTemplates/SavingTraceTemplates.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../Built-InInstruments/Built-InInstruments.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-10-15<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/CreatingaCustomInstrument/CreatingaCustomInstrument.html%3Fid%3DTP40004652-1.3&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/CreatingaCustomInstrument/CreatingaCustomInstrument.html%3Fid%3DTP40004652-1.3&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/CreatingaCustomInstrument/CreatingaCustomInstrument.html%3Fid%3DTP40004652-1.3&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>