<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Restore Screen Cluts - /MenuHandler.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">Restore Screen Cluts</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Restore Screen Cluts</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/MenuHandler.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/ColorReset.c</option>
<option value="listing2.html">/ColorReset.h</option>
<option value="listing3.html">/EmergMem.c</option>
<option value="listing4.html">/EmergMem.h</option>
<option value="listing5.html">/MenuHandler.c</option>
<option value="listing6.html">/MenuHandler.h</option>
<option value="listing7.html">/PictDocument.c</option>
<option value="listing8.html">/PictDocument.h</option>
<option value="listing9.html">/WindowPositioner.c</option>
<option value="listing10.html">/WindowPositioner.h</option></select>
				</p>
				</form>
				<p><strong><a href="Restore_Screen_Cluts.zip">Download Sample</a></strong> (&#147;Restore_Screen_Cluts.zip&#148;, 122.2K)<BR>
<strong><a href="Restore_Screen_Cluts.dmg">Download Sample</a></strong> (&#147;Restore_Screen_Cluts.dmg&#148;, 191.5K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    MenuHandler.c  Contains:  Menu-handling routines  Written by: Forrest Tanaka    Copyright:  Copyright &copy; 1988-1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        7/13/1999  Karl Groethe  Updated for Metrowerks Codewarror Pro 2.1        *//******************************************************************************\* Header Files\******************************************************************************/#ifndef THINK_C#include &lt;Desk.h&gt;#include &lt;Errors.h&gt;#include &lt;Memory.h&gt;#include &lt;Menus.h&gt;#include &lt;Resources.h&gt;#endif#include &quot;ColorReset.h&quot;#include &quot;MenuHandler.h&quot;#include &quot;PictDocument.h&quot;/******************************************************************************\* Constants\******************************************************************************/#define rMenuBar 128 /* Resource ID of this application's MBAR resource */#define kNumMenuGuides (mLastMenu - mApple + 1) /* Number of menu guide recs *//******************************************************************************\* Types\******************************************************************************/typedef struct{  MenuHandle theMenu; /* Handle to this guide's menu */  long       enables; /* Current enable flags */} MenuGuide;/******************************************************************************\* Prototypes\******************************************************************************/void DoAppleMenu(  short menuItem);void DoFileMenu(  short menuItem);void DoEditMenu(  short menuItem);void DoDisplayMenu(  short menuItem);void ResetMenuItems(void);void FixDAMenus(void);/******************************************************************************\* Variables\******************************************************************************/MenuGuide gMenuGuides[kNumMenuGuides]; /* Application's menu guide records *//******************************************************************************\* Public: StartMenus** The menu guide array is initialized with the menu handles and enable flags of* all menus.** If GetNewMBar couldn't load the MBAR resource, then it returns nil and the* error code is in ResError, and I can deal with the error elegantly.  But, if* the GetNewMBar couldn't load the menus themselves, then it'll probably crash.\******************************************************************************/OSErr StartMenus(){  Handle menuBar;   /* Handle to the menu bar from the MBAR resource */  short  menuIndex; /* Index into menu guide records */  OSErr  error;  /* Load in the menu bar */  menuBar = GetNewMBar( rMenuBar );  if (menuBar != nil)  {    /* Set it, then dispose of it because SetMenuBar makes a copy */    SetMenuBar( menuBar );    DisposeHandle( menuBar );    /* Add the desk accessories to the Apple menu */    AppendResMenu( GetMenuHandle( mApple ), 'DRVR' );    /* Initialize the menu guide array */    for (menuIndex = 0; menuIndex &lt; kNumMenuGuides; menuIndex++)    {      gMenuGuides[menuIndex].theMenu = GetMenuHandle( menuIndex + mApple );      gMenuGuides[menuIndex].enables = (**gMenuGuides[menuIndex].          theMenu).enableFlags;    }    /* Draw the menu bar */    DrawMenuBar();    error = noErr;  }  else  {    error = ResError();    if (error == noErr)      error = resNotFound;    if (error != resNotFound &amp;&amp; error != memFullErr)      error = dsSysErr;  }  return error;}/******************************************************************************\* Public: DoMenuChoice** This routine should be self-explanatory.\******************************************************************************/void DoMenuChoice(  long menuChoice) /* Return value from MenuSelect or MenuKey */{  short menuNum;  /* Menu number of chosen menu */  short menuItem; /* Item number of chosen menu item */  if (menuChoice != 0)  {    /* Get the chosen menu item and menu number */    menuNum = hiWord( menuChoice );    menuItem = loWord( menuChoice );    /* Dispatch the appropriate menu-handling routine */    if (menuNum == mApple)      DoAppleMenu( menuItem );    else if (menuNum == mFile)      DoFileMenu( menuItem );    else if (menuNum == mEdit)      DoEditMenu( menuItem );    else if (menuNum == mDisplay)      DoDisplayMenu( menuItem );    HiliteMenu( 0 );  }}/******************************************************************************\* Private: DoAppleMenu - Handle an Apple menu item choice** This routine is called whenever it's determined that the chosen menu item was* in the Apple menu.  If the chosen menu item that's passed in the menuItem* parameter wasn't the About item, the name of the menu item is retrieved and* then OpenDeskAcc is called with this name so that the desk accessory by that* name is opened.  The Process Manager can launch desk accessories, but* OpenDeskAcc should still be used if the user chooses any item in the Apple* menu.\******************************************************************************/static void DoAppleMenu(  short menuItem) /* Chosen menu item */{  Str255 daName; /* Name of the chosen DA */  short  refNum; /* Reference number of the DA, ignored */  if (menuItem != iAbout)  {    GetMenuItemText( GetMenuHandle( mApple ), menuItem, /*&lt;*/daName );    refNum = OpenDeskAcc( daName );  }}/******************************************************************************\* Private: DoFileMenu - Handle a File menu item choice** This routine is called whenever it's determined that the chosen menu item was* in the File menu.  The item number of the chosen menu item is passed in the* menuItem parameter.\******************************************************************************/static void DoFileMenu(  short menuItem) /* Chosen menu item */{  if (menuItem == iOpen)    (void)DoOpenPictDoc();  else if (menuItem == iClose)  {    if (IsPictDocWindow( FrontWindow() ))      DoClosePictDoc( FrontWindow() );  }  else if (menuItem == iSaveAs)  {    if (IsPictDocWindow( FrontWindow() ))      DoSaveAsPictDoc( FrontWindow() );  }  else if (menuItem == iQuit)    DoQuit();}/******************************************************************************\* Private: DoEditMenu - Handle a Edit menu item choice** This routine is called whenever it's determined that the chosen menu item was* in the Edit menu.  The item number of the chosen menu item is passed in the* menuItem parameter.\******************************************************************************/static void DoEditMenu(  short menuItem) /* Chosen menu item */{  SystemEdit( menuItem - 1 );}/******************************************************************************\* Private: DoEditMenu - Handle a Edit menu item choice** This routine is called whenever it's determined that the chosen menu item was* in the Edit menu.  The item number of the chosen menu item is passed in the* menuItem parameter.\******************************************************************************/static void DoDisplayMenu(  short menuItem) /* Chosen menu item */{  if (menuItem == 1)    RestoreColorsPalette();  else if (menuItem == 2)    RestoreColorsSlam();}/******************************************************************************\* Public: FixMenus** FixMenus first disables every available menu item.  Then the most basic menu* items are enabled.  The windowKind field of the front window is then checked.* If there is a window open, FixMenus calls a routine that's responsible for* that kind of window to enable any menu items that are relevant to that kind of* window.** If the front window is a modal dialog, then the basic set of menu items are* ! enabled, and the entire Apple menu is disabled.** After this is done, the menu bar might have to be redrawn to reflect the new* conditions.  So, FixMenus go through every menu to determine if the state of* the entire menu has changed.  The MenuGuide records are used to help determine* this.  If the state of any many has changed, then the menu bar is redrawn.\******************************************************************************/void FixMenus(){  WindowPtr  currWindow; /* Pointer to the front-most window */  MenuHandle aMenu;      /* Handle to menu being enabled */  long       oldEnables; /* True if 1+ items enabled when FixMenus called */  long       newEnables; /* True if 1+ items enabled after menus fixed */  Boolean    mustRedraw; /* True if menu bar has to be redrawn */  short      numItems;   /* Number of items in a menu */  short      menuIndex;  /* Index into menu guide array */  /* Start by disabling all menus */  ResetMenuItems();  /* Front-most window determines most menu enabling/disabling */  currWindow = FrontWindow();  /* Depending on the type of the front window, enable appropriate items */  if (IsDAWindow( currWindow ))    FixDAMenus();  else if (IsPictDocWindow( currWindow ))    FixPictDocMenus( currWindow );  /* Enable some menus */  aMenu = GetMenuHandle( mFile );  EnableItem( aMenu, iOpen );  /* Assume we don't have to redraw the menu bar */  mustRedraw = false;  /* Check through every menu to see if there are any enabled items in it */  for (menuIndex = 0; menuIndex &lt; kNumMenuGuides; menuIndex++)  {    /* Grab the old and new enable flags excluding flag for entire menu */    oldEnables = gMenuGuides[menuIndex].enables &amp; 0xFFFFFFFE;    newEnables = (**gMenuGuides[menuIndex].theMenu).enableFlags &amp;        0xFFFFFFFE;    /* Shift left so that we only see flags for existing items */    numItems = CountMItems(gMenuGuides [menuIndex].theMenu);    oldEnables = oldEnables &lt;&lt; (31 - numItems);    newEnables = newEnables &lt;&lt; (31 - numItems);    /* Determine if the menu bar must be redrawn */    if (((oldEnables != 0) &amp;&amp; (newEnables == 0)) || numItems == 0)    {      /* Had some items enabled, now has no items enabled, redraw */      DisableItem( gMenuGuides[menuIndex].theMenu, 0 );      mustRedraw = true;    }    else if ((oldEnables == 0) &amp;&amp; (newEnables != 0))    {      /* Had no items enabled, now has some items enabled, redraw */      EnableItem( gMenuGuides[menuIndex].theMenu, 0) ;      mustRedraw = true;    }    /* Update our copy of the enable flags */    gMenuGuides[menuIndex].enables = (**gMenuGuides[menuIndex].theMenu).        enableFlags;  }  /* If at least one menu has changed state, must redraw the menu bar */  if (mustRedraw)    DrawMenuBar();}/******************************************************************************\* Private: ResetMenuItems - Disable any disableable items and clear marks** Disabling all the menu items is done bruteforcedly.  It could easily be done* by looping through each menu and disabling every item that comes up (disabling* the Font menu is done this way), but I thought doing it using the brute-force* method was clearer.  Then again. . .\******************************************************************************/static void ResetMenuItems (){  MenuHandle aMenu; /* Handle to each menu we're disabling */  /* Disable items in the File menu */  aMenu = GetMenuHandle( mFile );  DisableItem( aMenu, iOpen );  DisableItem( aMenu, iClose );  DisableItem( aMenu, iSaveAs );  /* Disable items in the Edit menu */  aMenu = GetMenuHandle( mEdit );  DisableItem( aMenu, iUndo );  DisableItem( aMenu, iCut );  DisableItem( aMenu, iCopy );  DisableItem( aMenu, iPaste );  DisableItem( aMenu, iClear );}/******************************************************************************\* Private: FixDAMenus - Enable any menu items relevant for desk accessories** Desk accessories can use the Edit menu, so the standard Edit menu items are* enabled.\******************************************************************************/static void FixDAMenus(){  MenuHandle aMenu; /* Handle to each menu we're enabling */  /* Disable items in the Process menu */  aMenu = GetMenuHandle( mEdit );  EnableItem( aMenu, iUndo );  EnableItem( aMenu, iCut );  EnableItem( aMenu, iCopy );  EnableItem( aMenu, iPaste );  EnableItem( aMenu, iClear );}/******************************************************************************\* Public: DisableAllMenus** \******************************************************************************/void DisableAllMenus(){  short menuIndex; /* Index into menu guide array */  /* Check through every menu to see if there are any enabled items in it */  for (menuIndex = 0; menuIndex &lt; kNumMenuGuides; menuIndex++)    DisableItem( gMenuGuides[menuIndex].theMenu, 0 );}/******************************************************************************\* Public: RestoreAllMenus** \******************************************************************************/void ReenableAllMenus(){  short menuIndex; /* Index into menu guide array */  /* Check through every menu to see if there are any enabled items in it */  for (menuIndex = 0; menuIndex &lt; kNumMenuGuides; menuIndex++)    if ( gMenuGuides[menuIndex].enables &amp; 1 )      EnableItem( gMenuGuides[menuIndex].theMenu, 0 );}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Restore_Screen_Cluts/listing5.html%3Fid%3DDTS10000159-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Restore_Screen_Cluts/listing5.html%3Fid%3DDTS10000159-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Restore_Screen_Cluts/listing5.html%3Fid%3DDTS10000159-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>