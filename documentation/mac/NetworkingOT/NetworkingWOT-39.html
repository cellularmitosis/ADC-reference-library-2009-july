<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Using Options</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING39></A>
<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->

<!-- Main Body -->

<CENTER>
<P>
<A HREF="NetworkingWOT-38.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="NetworkingWOT-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="NetworkingWOT-491.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A>  <A HREF="NetworkingWOT-40.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html"><B>Inside Macintosh:</B></A> <A HREF="NetworkingWOT-2.html"><B>Networking With Open Transport </B></A> / <A HREF="NetworkingWOT-10.html"><B>Part 1 - Open Transport Essentials</B></A><BR><DD><A HREF="NetworkingWOT-37.html"><B>Chapter 7 - Option Management</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING39-0></A>
<H1>Using Options</H1>
 <A NAME=MARKER-13-37></A>This section explains how you use endpoint functions to set and retrieve option values and how you use Open Transport utility functions to construct an options buffer and parse through an options buffer.<P>
<A NAME=HEADING39-2></A>
<H2>Determining Which Function to Use to Negotiate Options</H2>
 You can negotiate options using the <CODE>OTOptionManagement</CODE> function or using any one of the endpoint functions used to transfer data or establish a connection. The basic distinction between setting option values using the <CODE>OTOptionManagement</CODE> function and using any of the other endpoint functions is that options negotiated with the <CODE>OTOptionManagement</CODE> function affect all functions called by an endpoint, whereas options negotiated using any other function affect only the connection, transaction, or datagram for which they are set. For more detailed information about these differences, see <A HREF=NetworkingWOT-485.html#MARKER-9-7>"XTI Option Summary"</A>.<P>
<A NAME=HEADING39-4></A>
<H2><A NAME=MARKER-9-38></A><A NAME=MARKER-9-39></A>Obtaining the Maximum Size of an Options Buffer</H2>
 <A NAME=MARKER-13-40></A>Different types of endpoints support different numbers of options. For example, an ATP endpoint might support more options than a DDP endpoint and might need a larger buffer to hold the options. When you call the <CODE>OTOptionManagement</CODE> function to change option values, the function returns in the <CODE>ret</CODE> parameter a pointer to the buffer containing the negotiated option values. You must have allocated the buffer used to store these options before calling the function. Likewise, when you call the <CODE>OTListen</CODE>, <CODE>OTRcvUData</CODE>, <CODE>OTRcvURequest,</CODE> or <CODE>OTRcvConnect</CODE> functions, you can allocate a buffer in which current option values are to be placed when these functions return. In either case, you must specify the size of the buffer, and the buffer must be large enough to hold all of the endpoint's options. Otherwise, the function fails with a <CODE>kOTBufferOverflow</CODE> result. You can obtain the maximum size of a buffer used to store options for your endpoint by examining the <CODE>options</CODE> field of the <CODE>TEndpointInfo</CODE> structure for the endpoint. You can get a pointer to this structure when you open the endpoint, when you bind the endpoint, or when you call the <CODE>OTGetEndpointInfo</CODE> function. <P>
<A NAME=HEADING39-6></A>
<H2><A NAME=MARKER-9-41></A>Setting Option Values</H2>
 You can use the <CODE>OTOptionManagement</CODE>, <CODE>OTAccept</CODE>, <CODE>OTSndUData</CODE>, <CODE>OTSndURequest</CODE>, and <CODE>OTConnect</CODE> functions to set option values. Setting option values results in a negotiation process between you (the client application) and the endpoint provider or, in the case of association-related options, between local and remote clients and their endpoint providers. Appendix D describes the rules that govern an option negotiation that you have initiated using the <CODE>OTOptionManagement</CODE>, <CODE>OTConnect</CODE>, <CODE>OTSndUData</CODE>, or <CODE>OTSndURequest</CODE> functions. The section <A HREF=NetworkingWOT-489.html#MARKER-9-29>"Retrieving Values for Connection-Oriented Endpoints"</A> describes the negotiation rules that hold when you use the <CODE>OTOptionManagement</CODE> or <CODE>OTAccept</CODE> functions to respond to a negotiation. This section describes ways in which you can build the options buffer used to specify the options you want to change.<P>
<A NAME=HEADING39-8></A>
<H3><A NAME=MARKER-9-42></A>Specifying Option Values </H3>
 No matter which function you use to set option values, you must allocate a buffer that contains the option value or values you want to change. The options in this buffer are described by <A NAME=MARKER-13-76></A><CODE>TOption</CODE> structures; the format of this structure is illustrated in <A HREF=NetworkingWOT-38.html#MARKER-9-29>Figure 7-1 </A>. You can concatenate several structures in the buffer, as shown by <A HREF=NetworkingWOT-38.html#MARKER-9-32>Figure 7-2 </A>, so long as each structure begins on a long-word boundary. The buffer itself is described by a <CODE>TNetbuf</CODE> structure that specifies the location of the buffer and its size. <P>
 You can create a buffer that contains the option values you want to set in one of two ways: manually or by using the <CODE>OTCreateOptions</CODE> function. If you construct the buffer manually, you must do the following:<A NAME=MARKER-13-44></A><P>
<OL>
<P><LI>Allocate the buffer.
<P><LI>Create a <CODE>TOption</CODE> structure for each option you want to change.
<P><LI>Initialize each field of the <CODE>TOption</CODE> structure except for the <CODE>status</CODE> field.
<P><LI>Place the <CODE>TOption</CODE> structures in the buffer, making sure that each begins on a long-word boundary. This enables Open Transport to parse the buffer.<P>
</OL>
 To have Open Transport create a buffer for you, you must call the <CODE>OTCreateOptions</CODE> function and pass it a string containing one or more option values. This method saves time and trouble, but you can only use it if all the options in the buffer are for the same level and that level is the same as the top-level protocol for the endpoint provider. That is to say, you could not use this method to construct a buffer that contains DDP-level options for an ATP endpoint. In addition, this method is only guaranteed to work if you are building an options buffer for the <CODE>OTOptionManagement</CODE> function.<P>
 <A HREF=#MARKER-9-46>Listing 7-1</A> shows how you construct an options buffer by using the <CODE>OTCreateOptions</CODE> function. The code initializes a string array, <CODE>myStr</CODE>, to hold option values. It then creates a <CODE>TOptMgmt</CODE> structure, which would later be passed to the <CODE>OTOptionManagement</CODE> function to request the option values specified in the string. Finally, it calls the <CODE>OTCreateOptions</CODE> function to create the options buffer. The <A NAME=MARKER-11-98></A><CODE>OTCreateOptions</CODE> function creates the <CODE>TOption</CODE> structures and places them in the buffer, making sure that the structures are properly aligned. <P>
<B>Listing 7-1  <A NAME=MARKER-9-46></A>Constructing an options buffer using the <CODE>OTCreateOptions</CODE> function</B><P>
<PRE>
<A NAME=MARKER-0-95></A>char* myStr = &quot;BaudRate = 9650 DataBits = 8 Parity = 0 
                     StopBits = 10&quot;;
UInt8 buffer[512];
TOptMgmt cmd;
cmd.opt.len = 0;
cmd.opt.maxlen = sizeof(buffer);
cmd.opt.buf = buffer;
cmd.flags = T_NEGOTIATE
err = OTCreateOptions(&quot;SerialA&quot;, &amp;myStr, &amp;cmd.opt)
</PRE>
 In this case, the initial value of <CODE>cmd.opt.len</CODE>, which is 0, tells the <CODE>OTCreateOptions</CODE> function at what offset it should begin to append option information in the buffer. When the function returns, this field specifies the actual length of the buffer. <A NAME=MARKER-13-48></A><P>
<A NAME=HEADING39-20></A>
<H3><A NAME=MARKER-9-49></A>Setting Default Values</H3>
 To set all of an endpoint's options to their default values, call the <CODE>OTOptionManagement</CODE> function, specifying <CODE>T_NEGOTIATE</CODE> for the <CODE>flags</CODE> field and allocating a buffer containing only one option named <A NAME=MARKER-13-60></A><CODE>T_ALLOPT</CODE>. Doing this saves you the trouble of constructing a <CODE>TOption</CODE> structure for every option the endpoint supports. However, there is no guarantee that the provider can honor your request simply because you request default values. Therefore, you must allocate a buffer that is large enough to hold the option values returned in the <CODE>ret</CODE> parameter. <A NAME=MARKER-13-90></A><P>
<A NAME=HEADING39-22></A>
<H2><A NAME=MARKER-13-52></A>Retrieving Option Values</H2>
 This section describes how you can retrieve information about options, including obtaining current and default option values for an endpoint and obtaining current option values related to a connection, transaction, or datagram. <P>
 When retrieving option values, you must allocate a buffer that is large enough to contain the options when the function returns. The section <A HREF=#MARKER-9-39>"Obtaining the Maximum Size of an Options Buffer"</A> explains how you do this.<P>
<A NAME=HEADING39-25></A>
<H3><A NAME=MARKER-9-53></A>Obtaining Current and Default Values </H3>
 To obtain some of an endpoint's default or current option values, you call the <CODE>OTOptionManagement</CODE> function. You specify <CODE>T_DEFAULT</CODE> or <CODE>T_CURRENT</CODE> for the <CODE>flags</CODE> field of the <CODE>req</CODE> parameter, and you use the <CODE>option.buf</CODE> field to specify the option names in which you are interested. When the function returns, it places <CODE>TOption</CODE> structures, describing the default or current option values, in the buffer referenced by the <CODE>opt.buf</CODE> field of the <CODE>ret</CODE> parameter. <A NAME=MARKER-13-54></A><P>
 If you are interested in obtaining all of an endpoint's default or current values, you can use the following methods:<P>
<UL>
<P><LI>To obtain an endpoint's default values, call the <CODE>OTOptionManagement</CODE> function, specifying <A NAME=MARKER-13-59></A><CODE>T_DEFAULT</CODE> for the flags field and <A NAME=MARKER-13-60></A><CODE>T_ALLOPT</CODE> for the option name.<BR>
<P><LI>To obtain an endpoint's current option values, call the <CODE>OTOptionManagement</CODE> function, specifying <A NAME=MARKER-13-61></A><CODE>T_CURRENT </CODE>for the <CODE>flags</CODE> field and <CODE>T_ALLOPT</CODE> for the option name.<P>
</UL>
 Using <CODE>T_ALLOPT</CODE> for the option name allows you to construct an input buffer that contains only one option. Remember, however, that you must allocate an output buffer that is large enough to hold all of an endpoint's option values when the function returns. <P>
<A NAME=HEADING39-31></A>
<H3><A NAME=MARKER-9-58></A>Parsing an Options Buffer</H3>
 If you use the <CODE>OTOptionManagement</CODE> function to set, verify, or retrieve values, the function returns in the <CODE>ret</CODE> parameter a pointer to a buffer containing option information. You can use the <CODE>OTCreateOptionString</CODE> function to parse this buffer and create a string that lists all options and their current values. <A NAME=MARKER-13-59></A><P>
 The code fragment shown in <A HREF=NetworkingWOT-68.html#MARKER-9-27>Listing 7-2</A> calls the <CODE>OTOptionManagement</CODE> function to retrieve the option values currently effective for an endpoint. On return, the <CODE>OTOptionManagement</CODE> function stores these in the <CODE>cmd</CODE> structure. Next, the code calls the <CODE>OTCreateOptionString</CODE> function. The first input parameter, <CODE>"SerialA"</CODE>, specifies the name of the protocol. The next input parameter, <CODE>opts</CODE>, is a pointer to the buffer containing the option values returned by the <CODE>OTOptionManagement</CODE> function. The expression <CODE>cmd.opt.buf + cmd.opt.len</CODE>, which provides the next input parameter, specifies the length of the buffer. Using this information, the <CODE>OTCreateOptionString</CODE> function returns a string containing each option name and its respective value. The final parameter to the <CODE>OTCreateOptionString</CODE> function specifies the length of the string. <P>
<B>Listing 7-2  <A NAME=MARKER-9-27></A>Using the <CODE>OTCreateOptionString</CODE> function to parse through a buffer</B><P>
<PRE>
<A NAME=MARKER-0-95></A>TOptMgmt    cmd;
UINt8       myBuffer[512];
char        myString[256];

cmd.opt.len = sizeof(TOption);
cmd.opt.maxlen = sizeof(myBuffer);
cmd.opt.buf = myBuffer;
((TOption*) buffer)-&gt;len = sizeof(TOption);
((TOption*) buffer)-&gt;level = COM_SERIAL;
((TOption*) buffer)-&gt;name = T_ALLOPT;
((TOption*) buffer)-&gt;status = 0;
cmd.flags = T_CURRENT;

OTOptionManagement(theEndpt, &amp;cmd, &amp;cmd);

TOption* opts = (TOption*)cmd.opt.buf;
err = OTCreateOptionString(&quot;SerialA&quot;, &amp;opts, 
      cmd.opt.buf + cmd.opt.len, string, sizeof(string));
printf(&quot;Options = \&quot;%s\&quot;&quot;, string);
</PRE>
<DL>
<DT><B>Note</B>
<DD>The <CODE>OTCreateOptionString</CODE> function is supplied solely as a debugging aid. You should not include the function in a production version of your application because there is no provision made for localizing string information. <A NAME=MARKER-13-62></A>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING39-37></A>
<H2>Verifying Option Values</H2>
 In addition to obtaining default or current values and negotiating new values, you can use the <CODE>OTOptionManagement</CODE> function to verify whether an endpoint supports one or more options. To do this, you construct a buffer containing <CODE>TOption</CODE> structures describing the options you are interested in and pass this buffer in the <CODE>req</CODE> parameter to the <CODE>OTOptionManagement</CODE> function, specifying <CODE>T_CHECK</CODE> for the action flag. When the function returns, you can examine the <CODE>status</CODE> field of the <CODE>TOption</CODE> structures for the options passed back to you in the <CODE>ret</CODE> parameter to determine whether the specified options are supported.<A NAME=MARKER-13-63></A><P>
<A NAME=HEADING39-39></A>
<H2><A NAME=MARKER-9-64></A>Sample Code: Getting and Setting Options</H2>
 The code listings discussed in this section furnish examples of how you can use the Open Transport API to get, set, and display the values of options.<P>
 <A HREF=#MARKER-9-63>Listing 7-3</A> shows a main function that calls a number of other functions (defined in subsequent listings) to set, get, and display option values.<P>
<B>Listing 7-3  <A NAME=MARKER-9-63></A>Calling functions that get, set, and display options</B><P>
<PRE>
<A NAME=MARKER-0-95></A>#ifndef qDebug / *OT debugging macros need this var */
#define qDebug 1
#endif
#include &lt;OpenTransport.h&gt;

#include &lt;OpenTptInternet.h&gt; /* for TCP/IP */

#include &lt;OpenTptSerial.h&gt;/* for serial endpoints */

#include &lt;OTDebug.h&gt;/* Need OTDebugBreak and OTAssert macros */
#include &lt;stdio.h&gt;/* Standard C prototypes */

/* OTDebugStr is not defined in any OT header files, but it is
exported by the libraries, so we define the prototype here. */

extern pascal void OTDebugStr(const char* str);

void main(void) {
   OSStatus err;
   OSStatus junk;
   EndpointRef ep;
   UInt32 value;
   
   printf(&quot;HelloWorld!\n&quot;);
   
   err = InitOpenTransport();
   
   if (err == noErr) {
         ep = OTOpenEndpoint(OTCreateConfiguration(kTCPName), 0, nil,
                                             &amp;err);
      if (err == noErr) {
         printf(&quot;\nGetting and Setting IP_REUSEADDR.\n&quot;);
         err = GetFourByteOption(ep, INET_IP, IP_REUSEADDR, &amp;value);
         if (err == noErr) 
            printf(&quot;Default value = %d\n&quot;, value);
         if (err == noErr) 
            err = SetFourByteOption(ep, INET_IP, IP_REUSEADDR, true);
         if (err == noErr){
            err = GetFourByteOption(ep, INET_IP, IP_REUSEADDR,
                                          &amp;value);
            if (err == noErr) 
               printf(&quot;New value = %d\n&quot;, value)
         }
         if (err == noErr) {
            printf(&quot;\nPrinting Options Piecemeal at Level
                                          INET_IP.\n&quot;);
            err = PrintAllOptionsAtLevel(ep, INET_IP);
         }
         if (err == noErr){
            printf(&quot;\nPrinting Formatted Options at Level
                                       COM_SERIAL.\n&quot;);
            err = PrintOptionsForConfiguration(kSerialName,
                                          COM_SERIAL);
         }
         if (err == noErr) {
            printf(&quot;\nBuilding Options for COM_SERIAL.\n&quot;);
            err = BuildAndPrintOptions(kSerialName, &quot;BaudRate=9600,
                                 DataBits=7, StopBits=15&quot;);
         }
         junk = OTCloseProvider(ep);
         OTAssert(&quot;GetSetOptions: Closing the endpoint failed&quot;, 
                                    junk == noErr);
      }
      CloseOpenTransport();
   }
   if (err == noErr) 
      printf(&quot;Success.\n&quot;);
    else 
      printf(&quot;Failed with error %d.\n&quot;, err);
   printf(&quot;Done.  Press command-Q to Quit.\n&quot;);
}
</PRE>
 This main function initializes Open Transport and then creates a TCP endpoint. Then, it calls the function <CODE>GetFourByteOption</CODE> to obtain the value of the <CODE>IP_REUSEADDR</CODE> option, which governs whether you can bind multiple endpoints to addresses with the same port number. <A HREF=#MARKER-9-67>Listing 7-4</A> contains the definition of the <CODE>GetFourByteOption</CODE> function.<P>
<B>Listing 7-4  <A NAME=MARKER-9-67></A>Getting an option value</B><P>
<PRE>
<A NAME=MARKER-0-95></A>static OTResult GetFourByteOption(EndpointRef ep,
                           OTXTILevel level,
                           OTXTIName  name,
                           UInt32   *value)
{
   OTResult err;
   TOption  option;
   TOptMgmt request;
   TOptMgmt result;
   
   /* Set up the option buffer */
   option.len  = kOTFourByteOptionSize;
   option.level= level;
   option.name = name;
   option.status = 0;
   option.value[0] = 0;// Ignored because we're getting the value.

   /* Set up the request parameter for OTOptionManagement to point
    to the option buffer we just filled out */

   request.opt.buf= (UInt8 *) &amp;option;
   request.opt.len= sizeof(option);
   request.flags= T_CURRENT;

   /* Set up the reply parameter for OTOptionManagement. */
   result.opt.buf  = (UInt8 *) &amp;option;
   result.opt.maxlen = sizeof(option);
   
   err = OTOptionManagement(ep, &amp;request, &amp;result);

   if (err == noErr) {
      switch (option.status) 
      {
         case T_SUCCESS:
         case T_READONLY:
            *value = option.value[0];
            break;
         default:
            err = option.status;
            break;
      }
   }
            
   return (err);
}
</PRE>
 The function <CODE>GetFourByteOption</CODE> gets the current option setting and assigns it to the location referenced by <CODE>value</CODE>. The endpoint is assumed to be in synchronous mode. If an error occurs, the function returns a negative result. If the option could not be read, a positive result (either <CODE>T_FAILURE, T_PARTSUCCESS</CODE>, or <CODE>T_NOTSUPPORT</CODE>) is returned.<P>
 Within the body of the function, the fields of the option buffer are set up to specify the option and value we want to get. The <CODE>TOption</CODE> structure is used to represent the option buffer. This structure is defined to allow easy construction of 4-byte options. <P>
 Next, the <CODE>request</CODE> parameter for the <CODE>OTOptionManagement</CODE> function is defined to reference the option buffer that was just initialized. The <CODE>request.flags</CODE> field is initialized to <CODE>T_CURRENT</CODE>, specifying that we want to get the current value of the option. The <CODE>reply</CODE> parameter for the <CODE>OTOptionManagement</CODE> function is then initialized. This is where the function stores the result of the negotiation. Finally, the <CODE>OTOptionManagement</CODE> function is called, and its result is checked to see that the option value was read successfully. Any status other than <CODE>T_SUCCESS</CODE> or <CODE>T_READONLY</CODE> is stored in the <CODE>err</CODE> variable.<P>
 The next function called by <CODE>main</CODE> is <CODE>SetFourByteOption</CODE>, shown in <A HREF=NetworkingWOT-56.html#MARKER-9-65>Listing 7-5</A>. This routine sets an option and assigns it to the location referenced by <CODE>value</CODE>. The endpoint is assumed to be in synchronous mode. If an error occurs, the function returns a negative result. If the option could not be read, a positive result ( <CODE>T_FAILURE</CODE>,<CODE> T_PARTSUCCESS</CODE>, <CODE>TREADONLY</CODE>, or <CODE>T_NOTSUPPORT</CODE>) is returned.<P>
<B>Listing 7-5  <A NAME=MARKER-9-65></A>Setting an option value</B><P>
<PRE>
<A NAME=MARKER-0-95></A>static OTResult SetFourByteOption(EndpointRef ep,
                           OTXTILevel level,
                           OTXTIName  name,
                           UInt32   value)
{
   OTResult err;
   TOption  option;
   TOptMgmt request;
   TOptMgmt result;
   
   /* Set up the option buffer to specify the option and value to
         set. */
   option.len  = kOTFourByteOptionSize;
   option.level= level;
   option.name = name;
   option.status = 0;
   option.value[0] = value;

   /* Set up request parameter for OTOptionManagement */
   request.opt.buf= (UInt8 *) &amp;option;
   request.opt.len= sizeof(option);
   request.flags  = T_NEGOTIATE;

   /* Set up reply parameter for OTOptionManagement. */
   result.opt.buf  = (UInt8 *) &amp;option;
   result.opt.maxlen  = sizeof(option);

   
   err = OTOptionManagement(ep, &amp;request, &amp;result);

   if (err == noErr) {
      if (option.status != T_SUCCESS) 
         err = option.status;
   }
            
   return (err);
}
</PRE>
 The <CODE>SetFourByteOption</CODE> function is very similar in structure to the <CODE>GetFourByteOption</CODE> function, shown in the previous listing. Once again, we use a <CODE>TOption</CODE> structure to represent the option buffer and initialize its fields to specify the option and value we want to set. Next, we initialize the <CODE>request</CODE> parameter of the <CODE>OTOptionManagement</CODE> function to reference the option buffer we just initialized. The <CODE>length</CODE> field is set to the size of the option buffer and the <CODE>flags</CODE> field is set to <CODE>T_NEGOTIATE</CODE> to specify that we want to set the option value specified in the option buffer.<P>
 The <CODE>reply</CODE> parameter for the <CODE>OTOptionManagement</CODE> function is then set up. This is where the function will store the negotiated value of the option when it returns. Finally, the <CODE>OTOptionManagement</CODE> function is invoked and its result is checked to make sure the option was successfully negotiated. <P>
 After calling the <CODE>SetFourByteOption</CODE> function, <CODE>main</CODE> calls the <CODE>GetFourByteOption</CODE> function again to check the newly set value. The next three functions, <CODE>PrintAllOptionsAtLevel</CODE>, <CODE>PrintOptionsForConfig</CODE>, and <CODE>BuildAndPrintOptions</CODE> demonstrate various ways of displaying option values for an endpoint. Two of those functions call the function <CODE>PrintOptionBuffer</CODE> shown in <A HREF=#MARKER-9-71>Listing 7-6</A>. This function calls the Open Transport function <CODE>OTNextOption</CODE> to parse through an options buffer and then uses <CODE>printf</CODE> statements to display the results.<P>
<B>Listing 7-6  <A NAME=MARKER-9-71></A>Parsing an options buffer</B><P>
<PRE>
<A NAME=MARKER-0-95></A>static OSStatus PrintOptionBuffer(const TNetbuf *optionBuffer)
{
   OSStatus     err;
   TOption     *currentOption;

   currentOption = nil;
   do 
   {err = OTNextOption(optionBuffer-&gt;buf, optionBuffer-&gt;len,
                                    &amp;currentOption);
      if (err == noErr &amp;&amp; currentOption != nil) 
          printf(&quot;Level = $%08x, Name = $%08x, Data Length = %d,
                     Status = $%08x\n&quot;,
                     currentOption-&gt;level, 
                     currentOption-&gt;name, 
                     currentOption-&gt;len - kOTOptionHeaderSize,
                     currentOption-&gt;status);
   } while (err == noErr &amp;&amp; currentOption != nil);
      return (err);
}
</PRE>
 The PrintOptionBuffer function displays the level, name, size, and status for each option in the option buffer. The <CODE>PrintAllOptionsAtLevel</CODE> function, which <CODE>main</CODE> calls next, uses this function to display all the options for an endpoint that are set at a specified level.<P>
<A NAME=MARKER-9-72></A><B>Listing 7-7  Obtaining options for a specific level</B><P>
<PRE>
<A NAME=MARKER-0-95></A>static OSStatus PrintAllOptionsAtLevel(EndpointRef ep, OTXTILevel level)
{
   OSStatus    err;
   TEndpointInfoepInfo;
   TOptionHeaderrequestOption;
   void        *resultOptionBuffer;
   TOptMgmt    request;
   TOptMgmt    result;

   resultOptionBuffer = nil;

   /* Find max size of options of endpoint and allocate buffer */

   err = OTGetEndpointInfo(ep, &amp;epInfo);
   if (err == noErr) {
      resultOptionBuffer = OTAllocMem(epInfo.options);
      if (resultOptionBuffer == nil) 
         err = kENOMEMErr;
      }
   
   /* Call OTOptionManagement to get current option values */
   if (err == noErr) {
      requestOption.len= kOTOptionHeaderSize;
      requestOption.level= level;
      requestOption.name= T_ALLOPT;
      requestOption.status = 0;

      request.opt.buf= (UInt8 *) &amp;requestOption;
      request.opt.len= sizeof(requestOption);
      request.flags  = T_CURRENT;
      
      result.opt.buf = resultOptionBuffer;
      result.opt.maxlen = epInfo.options;
      
      err = OTOptionManagement(ep, &amp;request, &amp;result);
   }
   /* Print options to stdout. */
   
   if (err == noErr) {
      err = PrintOptionBuffer(&amp;result.opt);
      printf(&quot;\n&quot;);
   }
   if (resultOptionBuffer != nil) 
      OTFreeMem(resultOptionBuffer);
   return (err);
}
</PRE>
 The function <CODE>PrintAllOptionsAtLevel</CODE> takes two parameters, an endpoint reference and a level value. The function first calls <CODE>OTGetEndpointInfo</CODE> to determine the maximum size of options for the endpoint and then allocates a buffer to hold the options after they are read. Next, the <CODE>OTOptionManagement</CODE> function is called to get the current value (<CODE>T_CURRENT</CODE>) of all the options (<CODE>T_ALLOPT</CODE>) set for the endpoint. The option values that are returned are stored in the buffer referenced by the <CODE>result</CODE> parameter. A pointer to the result parameter is passed to the function <CODE>PrintOptionsBuffer</CODE> <A HREF=#MARKER-9-71></A>, which displays option values. After the values are displayed, the memory allocated for the result options buffer is freed.<P>
 The next function called by <CODE>main</CODE> is <CODE>PrintOptionsForConfiguration</CODE>, shown in <A HREF=#MARKER-9-74>Listing 7-8</A>. This function gets all the options associated with a level of a provider, converts those options to a formatted string, and then displays that string. The function demonstrates one common use of the function <CODE>OTCreateOptionString</CODE>.<P>
<B>Listing 7-8  <A NAME=MARKER-9-74></A>Using the <CODE>OTCreateOptionString</CODE> function</B><P>
<PRE>
<A NAME=MARKER-0-95></A>static OSStatus PrintOptionsForConfiguration(const char *configStr,
                                    OTXTILevel level)
{
   OSStatus    err;
   OSStatus    junk;
   EndpointRef ep;
   TEndpointInfoepInfo;
   TOptionHeaderrequestOption;
   void        *resultOptionBuffer;
   TOptMgmt    request;
   TOptMgmt    result;
   TOption     *resultOption;
   char        optionsString[1024];

   resultOptionBuffer = nil;
   ep             = kOTInvalidEndpointRef;
   
   /* Create an endpoint using the specified configuration. */
   ep = OTOpenEndpoint(OTCreateConfiguration(configStr), 0, &amp;epInfo,
                                             &amp;err);

   /* Allocate a buffer to store option info */
   
   if (err == noErr) {
      resultOptionBuffer = OTAllocMem(epInfo.options);
      if (resultOptionBuffer == nil) 
         err = kENOMEMErr;
      }

   /* Get the current value of all options at the specified level. */
   if (err == noErr) {
      requestOption.len = kOTOptionHeaderSize;
      requestOption.level= level;
      requestOption.name= T_ALLOPT;
      requestOption.status = 0;
      request.opt.buf   = (UInt8 *) &amp;requestOption;
      request.opt.len   = sizeof(requestOption);
      request.flags     = T_CURRENT;
      
      result.opt.buf    = resultOptionBuffer;
      result.opt.maxlen = epInfo.options;
      
      err = OTOptionManagement(ep, &amp;request, &amp;result);
   }
   
   /* Convert the options bufferinto a formatted string, and display */
   if (err == noErr) 
   {
      resultOption = (TOption *) result.opt.buf;
      err = OTCreateOptionString(configStr, &amp;resultOption,
            result.opt.buf + result.opt.len, optionsString, 1024);
      if (err == noErr) 
         printf(&quot;Formatted Options = "%s"\n\n&quot;, optionsString);
   }
   
   /* Clean up. */
   
   if (resultOptionBuffer != nil) 
      OTFreeMem(resultOptionBuffer);
   if (ep != kOTInvalidEndpointRef) {
      junk = OTCloseProvider(ep);
      OTAssert(&quot;PrintOptionsForConfiguration: Closing the endpoint
               failed&quot;, junk == noErr);
   }
   return (err);
}
</PRE>
 The <CODE>PrintOptionsForConfiguration</CODE> function takes two parameters, a configuration string that describes a specific endpoint provider and a level for which we are interested in getting option information. The function first opens an endpoint using the configuration information passed in. Note that the address of a buffer to hold endpoint information (<CODE>&amp;epInfo</CODE>) is also specified in the call. We need the endpoint information structure in order to determine the maximum size of the options buffer for the endpoint.<P>
 Next, the function allocates a buffer to hold option values passed back by the <CODE>OTOptionManagement</CODE> function. The value of <CODE>T_ALLOPT</CODE> for the <CODE>name</CODE> field and <CODE>T_CURRENT</CODE> for the <CODE>flags</CODE> field specify that we are interested in getting currently set values for all options set for the endpoint. After the buffer is allocated, the <CODE>OTOptionManagement</CODE> function is invoked. Finally, the <CODE>OTCreateOptionString</CODE> function is invoked; this function converts the option buffer passed back by the <CODE>OTOptionManagement</CODE> function into a formatted string, which is then displayed using a <CODE>printf</CODE> statement.<P>
 The last function called by <CODE>main</CODE>, <CODE>BuildAndPrintOptions</CODE>, accomplishes the reverse of the <CODE>PrintOptionsForConfiguration</CODE> function: it takes a configuration string and a set of formatted options, converts the options to their binary format (that is, an options buffer), and then displays the contents of that buffer. The <CODE>BuildAndPrintOptions</CODE> function is shown in <A HREF=#MARKER-9-76>Listing 7-9</A>.<P>
<B>Listing 7-9  <A NAME=MARKER-9-76></A>Building an options buffer from a configuration string</B><P>
<PRE>
<A NAME=MARKER-0-95></A>static OSStatus BuildAndPrintOptions(const char *configStr, 
                     const char *optionsString)
{  OSStatus     err;
   OSStatus     junk;
   void         *resultOptionBuffer;
   EndpointRef  ep;
   TEndpointInfo epInfo;
   TNetbuf      optionsNetbuf;
   
   resultOptionBuffer = nil;
   ep = kOTInvalidEndpointRef;
   
   /* Create an endpoint using the specified configuration. */
   
   ep = OTOpenEndpoint(OTCreateConfiguration(configStr), 0,
                                    &amp;epInfo, &amp;err);
   
   /* Allocate a buffer of the maximum option buffer size. */
   if (err == noErr) {
      resultOptionBuffer = OTAllocMem(epInfo.options);
      if (resultOptionBuffer == nil) 
         err = kENOMEMErr;
   }

   /* Parse formatted optionsString into the binary format */
   if (err == noErr) {
      optionsNetbuf.buf = resultOptionBuffer;
      optionsNetbuf.len = 0;
      optionsNetbuf.maxlen = epInfo.options;
      err = OTCreateOptions(configStr, (char **) &amp;optionsString,
                                       &amp;optionsNetbuf);
      if (err == noErr) {
         err = PrintOptionBuffer(&amp;optionsNetbuf);
         printf(&quot;\n&quot;);
      }
   }
   /* Clean up. */
   if (resultOptionBuffer != nil)
      OTFreeMem(resultOptionBuffer);
   if (ep != kOTInvalidEndpointRef) {
      junk = OTCloseProvider(ep);
      OTAssert(&quot;BuildAndPrintOptions: Closing the endpoint failed&quot;,
                                       junk == noErr);
   }
   return (err);
}
</PRE>
 The function <CODE>BuildAndPrintOptions</CODE> creates an endpoint using the specified configuration. When opening the endpoint, the address of an endpoint information structure (<CODE>&amp;epInfo</CODE>) is passed in; the endpoint provider fills in this structure with information about the endpoint, including its maximum option buffer size. The function then allocates a buffer that is large enough to contain option information for the endpoint.<P>
 Next the function <CODE>BuildAndPrintOptions</CODE> calls the <CODE>OTCreateOptions</CODE> function to parse the formatted <CODE>optionsString</CODE> into the binary format (<CODE>optionsNetbuf</CODE>). Then the function calls <CODE>PrintOptionBuffer</CODE> <A HREF=#MARKER-9-71></A> to display the contents of the options buffer. Finally, the function frees memory allocated for the options buffer and returns.<P>
<HR>
<B>Subtopics</B>
<B><!-- TOC --><DL>
<DT><A HREF="NetworkingWOT-39.html#HEADING39-2">Determining Which Function to Use to Negotiate Options</A>
<DD>
<DT><A HREF="NetworkingWOT-39.html#HEADING39-4">Obtaining the Maximum Size of an Options Buffer</A>
<DD>
<DT><A HREF="NetworkingWOT-39.html#HEADING39-6">Setting Option Values</A>
<DD>
<DT><A HREF="NetworkingWOT-39.html#HEADING39-8">Specifying Option Values </A>
<DD>
<DT><A HREF="NetworkingWOT-39.html#HEADING39-20">Setting Default Values</A>
<DD>
<DT><A HREF="NetworkingWOT-39.html#HEADING39-22">Retrieving Option Values</A>
<DD>
<DT><A HREF="NetworkingWOT-39.html#HEADING39-25">Obtaining Current and Default Values </A>
<DD>
<DT><A HREF="NetworkingWOT-39.html#HEADING39-31">Parsing an Options Buffer</A>
<DD>
<DT><A HREF="NetworkingWOT-39.html#HEADING39-37">Verifying Option Values</A>
<DD>
<DT><A HREF="NetworkingWOT-39.html#HEADING39-39">Sample Code: Getting and Setting Options</A>
<DD>
</DL>
</B>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="NetworkingWOT-38.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="NetworkingWOT-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="NetworkingWOT-491.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A>  <A HREF="NetworkingWOT-40.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="NetworkingWOT-4.html">&copy; Apple Computer, Inc.</A><br>15 JAN 1998<P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML> 
