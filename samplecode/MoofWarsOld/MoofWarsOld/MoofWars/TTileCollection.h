/*	File:		TTileCollection.h	Contains:	A TileCollection is a set of tiles that can be used to draw a grid.  Essentially,				this class performs the same function that the TGraphicCollection class does, but				it is designed just to draw 32x32x8 tiles.  By making this code as specific as				possible, this code is more than twice as fast as using TGraphics to draw the tiles.	Written by: Timothy Carroll		Copyright:	Copyright © 1996-1999 by Apple Computer, Inc., All Rights Reserved.				You may incorporate this Apple sample source code into your program(s) without				restriction. This Apple sample source code has been provided "AS IS" and the				responsibility for its operation is yours. You are not permitted to redistribute				this Apple sample source code as "Apple sample source code" after having made				changes. If you're going to re-distribute the source, we require that you make				it clear in the source that the code was descended from Apple sample source				code, but that you've made changes.	Change History (most recent first):				7/2/1999	Karl Groethe	Updated for Metrowerks Codewarror Pro 2.1								8/15/96		Timothy Carroll	Initial Release				*/#ifndef _TTILECOLLECTION_#define _TTILECOLLECTION_#pragma once#if PRAGMA_STRUCT_ALIGN#pragma options align=power#endif// To provide an smaller, simpler interface, we'll define a couple of macros here.#define NewTileCollection(resID) TTileCollection::NewCollection((resID))#define DisposeTileCollection(collection) (collection)->DisposeReference()class TTileCollection{	public:/*************************************************************************************	Static Creator and Reference Counting		These are the routines that handle the actual creation of the objects, along with reference	counting and so on.  You shouldn't need to call the reference counting routines yourself --	instead, call the macros to create and destroy collections and they'll do the right thing.		Note that DisposeReference is the routine actually responsible for destroying a collection	when we're through.		A TTileCollection is loaded from a resource of type 'TILE'.*************************************************************************************/	static TTileCollection 	*NewCollection (SInt16 resID);	void	AddReference (void);	void	DisposeReference (void);		/*************************************************************************************	Locking and Unlocking		You are never required to lock a collection -- the routines run fine either way.	The functions are provided because we mainly use these functions to draw grids for	games, where all of the graphics are loaded ahead of time and stick around until	the game ends.  By locking the collections, we ensure that they won't be moving around	while the game is actually running.*************************************************************************************/	OSErr	LockCollection (void);	OSErr	UnlockCollection (void);		/*************************************************************************************	Creating and destroying the collection		The actual work to create and destroy the collection is done by the following two routines.	CreateCollection loads the resource and sets up all the required data, destroy collection	disposes of any memory allocated by the object.*************************************************************************************/	OSErr	CreateCollection (void);	OSErr	DestroyCollection (void);		/*************************************************************************************	Accessor Functions		We define only one accessor function, which is used to return the resource ID of the loaded	collection.	*************************************************************************************/	SInt16			GetResID(void) {return fResID;}		/*************************************************************************************	Utility Functions		The main routines that TTile is known for.  I won't explain them in detail here, check out	the TTile class for details.*************************************************************************************/	void			CopyImageClipped (UInt32 index, SInt32 top, SInt32 left);		// The actual class makes 8 copies of the tile data, once for each tile alignment.  If you are	// going to call any of these routines, make sure you call the one for the destination's 	// alignment.  If you don't call the correct routine, it will probably draw okay, just much	// slower -- check out the blitter implementation for details.	void 			CopyImageUnclipped0 (UInt32 index, unsigned char *destPtr);	void 			CopyImageUnclipped1 (UInt32 index, unsigned char *destPtr);	void 			CopyImageUnclipped2 (UInt32 index, unsigned char *destPtr);	void 			CopyImageUnclipped3 (UInt32 index, unsigned char *destPtr);	void 			CopyImageUnclipped4 (UInt32 index, unsigned char *destPtr);	void 			CopyImageUnclipped5 (UInt32 index, unsigned char *destPtr);	void 			CopyImageUnclipped6 (UInt32 index, unsigned char *destPtr);	void 			CopyImageUnclipped7 (UInt32 index, unsigned char *destPtr);								   protected:	/*************************************************************************************	Constructor/Destructor		Because the constructor and destructor should never be called except internally by the class,	I've made them protected.  You should call the macro functions instead.*************************************************************************************//*************************************************************************************	Data Structures		The actual data used to hold the TTileCollection.  We always align them to power alignment,	but the alignment is actually the same for 68K alignment anyway....*************************************************************************************/	TTileCollection (SInt16 resID);	~TTileCollection (void);			SInt16			fResID; 			// 2 bytes		UInt16			fReferenceCount;	// 2 bytes, # of owners of this collection;		UInt32			fNumberOfTiles;		// 4 bytes		Handle			fTiles;		   		// 4 bytes, holds all of the Tile data.		UInt32			fTileOffset;};#if PRAGMA_STRUCT_ALIGN#pragma options align=reset#endif#endif /* _TTILECOLLECTION_ */