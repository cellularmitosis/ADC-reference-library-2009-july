<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>SGDataProcSample - /Munggrab.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/QuickTime/index.html">QuickTime</a> &gt; <a href="../../samplecode/QuickTime/idxCompressionDecompression-date.html">Compression & Decompression</a> &gt; <A HREF="javascript:location.replace('index.html');">SGDataProcSample</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">SGDataProcSample</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Munggrab.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Minimung.c</option>
<option value="listing2.html">/Minimung.r</option>
<option value="listing3.html">/Munggrab.c</option>
<option value="listing4.html">/Munggrab.r</option>
<option value="listing5.html">/SonOfMungGrab.c</option>
<option value="listing6.html">/SonOfMunggrab.r</option>
<option value="listing7.html">/SonOfMunggrabPrefix.r</option></select>
				</p>
				</form>
				<p><strong><a href="SGDataProcSample.zip">Download Sample</a></strong> (&#147;SGDataProcSample.zip&#148;, 89.3K)<BR>
<strong><a href="SGDataProcSample.dmg">Download Sample</a></strong> (&#147;SGDataProcSample.dmg&#148;, 159.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    Munggrab.c    Description: This example shows how to run the Sequence Grabber in record mode and use         a DataProc to get and modify the captured data. Munggrab calculates the         frame rate using the time value stamp passed to the data proc then draws this         rate onto the frame. This technique provides optimal performance, far better         than using preview mode or bottlenecks. This code will help a lot when         capturing from DV and should allow 30fps playthrough using DV capture on a G3.  Author:    km, era  Copyright:   &copy; Copyright 2000 - 2002 Apple Computer, Inc. All rights reserved.    Disclaimer:  IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc.        (&quot;Apple&quot;) in consideration of your agreement to the following terms, and your        use, installation, modification or redistribution of this Apple software        constitutes acceptance of these terms.  If you do not agree with these terms,        please do not use, install, modify or redistribute this Apple software.        In consideration of your agreement to abide by the following terms, and subject        to these terms, Apple grants you a personal, non-exclusive license, under Apple's        copyrights in this original Apple software (the &quot;Apple Software&quot;), to use,        reproduce, modify and redistribute the Apple Software, with or without        modifications, in source and/or binary forms; provided that if you redistribute        the Apple Software in its entirety and without modifications, you must retain        this notice and the following text and disclaimers in all such redistributions of        the Apple Software.  Neither the name, trademarks, service marks or logos of        Apple Computer, Inc. may be used to endorse or promote products derived from the        Apple Software without specific prior written permission from Apple.  Except as        expressly stated in this notice, no other rights or licenses, express or implied,        are granted by Apple herein, including but not limited to any patent rights that        may be infringed by your derivative works or by other works in which the Apple        Software may be incorporated.        The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE MAKES NO        WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED        WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR        PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN        COMBINATION WITH YOUR PRODUCTS.        IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR        CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE        GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)        ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION        OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT        (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN        ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.          Change History (most recent first): &lt;3&gt; 3/28/02 DV source rect bug fix in DataProc                    &lt;2&gt; 7/08/01 carbonized                    &lt;1&gt; 1/13/00 initial release*/// NOTE:// this sample uses carbon accessesors and will not// build if you have not specified a carbon target// build for carbon#define TARGET_API_MAC_CARBON 1#if __APPLE_CC__  #include &lt;Carbon/Carbon.h&gt;  #include &lt;QuickTime/QuickTime.h&gt;#else   #include &lt;ConditionalMacros.h&gt;  #include &lt;Carbon.h&gt;  #include &lt;QuickTimeComponents.h&gt;  #include &lt;stdio.h&gt;#endif// defines#define BailErr(x) {err = x; if(err != noErr) goto bail;}// mung data structtypedef struct {    WindowRef          pWindow;  // window    Rect         boundsRect;  // bounds rect    GWorldPtr        pGWorld;  // offscreen    SeqGrabComponent   seqGrab;  // sequence grabber    ImageSequence      decomSeq;  // unique identifier for our decompression sequence    ImageSequence      drawSeq;  // unique identifier for our draw sequence    long          drawSize;    TimeValue        lastTime;    TimeScale        timeScale;    long          frameCount;} MungDataRecord, *MungDataPtr;// globalsstatic BitMap gScreenbits;static MungDataPtr gMungData = NULL;static Boolean gDone = false,         gIsCollapsed = false,         gIsGrabbing = false;         void Initialize(void);OSErr InitializeMungData(Rect inBounds, WindowRef inWindow);OSErr MakeAWindow(WindowRef *outWindow);SeqGrabComponent MakeSequenceGrabber(WindowRef pWindow);OSErr MakeSequenceGrabChannel(SeqGrabComponent seqGrab, SGChannel *sgchanVideo, Rect const *rect);void DoUpdate(void);OSErr MakeImageSequenceForGWorld(GWorldPtr pGWorld, GWorldPtr pDest, long *imageSize, ImageSequence *seq);pascal OSErr MungGrabDataProc(SGChannel c, Ptr p, long len, long *offset, long chRefCon, TimeValue time, short writeType, long refCon);// --------------------// Initialize for Carbon &amp; QuickTime//void Initialize(void){    InitCursor();    EnterMovies();    GetQDGlobalsScreenBits(&amp;gScreenbits);} // --------------------// InitializeMungData//OSErr InitializeMungData(Rect inBounds, WindowRef inWindow){    CGrafPtr theOldPort;    GDHandle theOldDevice;        OSErr err = noErr;        // allocate memory for the data    gMungData = (MungDataPtr)NewPtrClear(sizeof(MungDataRecord));    if (MemError() || NULL == gMungData ) return NULL;        // create a GWorld    err = QTNewGWorld(&amp;(gMungData-&gt;pGWorld),  // returned GWorld              k32ARGBPixelFormat,    // pixel format              &amp;inBounds,        // bounds              0,            // color table              NULL,          // GDHandle              0);            // flags  BailErr(err);        // lock the pixmap and make sure it's locked because    // we can't decompress into an unlocked pixmap    if(!LockPixels(GetGWorldPixMap(gMungData-&gt;pGWorld)))    goto bail;        GetGWorld(&amp;theOldPort, &amp;theOldDevice);        SetGWorld(gMungData-&gt;pGWorld, NULL);    BackColor(blackColor);    ForeColor(whiteColor);    EraseRect(&amp;inBounds);        SetGWorld(theOldPort, theOldDevice);  gMungData-&gt;boundsRect = inBounds;  gMungData-&gt;pWindow = inWindow;bail:  return err;}// --------------------// MakeImageSequenceForGWorld//OSErr MakeImageSequenceForGWorld(GWorldPtr pGWorld, GWorldPtr pDest, long *imageSize, ImageSequence *seq){    ImageDescriptionHandle desc = NULL;    PixMapHandle hPixMap = GetGWorldPixMap(pGWorld);    Rect bounds;        OSErr err = noErr;        GetPixBounds(hPixMap, &amp;bounds);    *seq = NULL;        // returns an image description for the GWorlds PixMap  // on entry the imageDesc is NULL, on return it is correctly filled out  // you are responsible for disposing it    err = MakeImageDescriptionForPixMap(hPixMap, &amp;desc);    BailErr(err);        *imageSize = (GetPixRowBytes(hPixMap) * (*desc)-&gt;height); // ((**hPixMap).rowBytes &amp; 0x3fff) * (*desc)-&gt;height;  // begin the process of decompressing a sequence of frames  // the destination is the onscreen window    err = DecompressSequenceBegin(seq,          // pointer to field to receive unique ID for sequence                    desc,          // handle to image description structure                    pDest,        // port for the DESTINATION image                    NULL,          // graphics device handle, if port is set, set to NULL                                  &amp;bounds,        // source rectangle defining the portion of the image to decompress                                  NULL,          // transformation matrix                                  ditherCopy,      // transfer mode specifier                                  (RgnHandle)NULL,    // clipping region in dest. coordinate system to use as a mask                                    0,          // flags                                  codecNormalQuality,  // accuracy in decompression                                  anyCodec);      // compressor identifier or special identifiers ie. bestSpeedCodecbail:    if (desc)      DisposeHandle((Handle)desc);        return err;}/* ---------------------------------------------------------------------- *//* sequence grabber data procedure - this is where the work is done/* ---------------------------------------------------------------------- *//* MungGrabDataProc - the sequence grabber calls the data function whenever   any of the grabber's channels write digitized data to the destination movie file.      NOTE: We really mean any, if you have an audio and video channel then the DataProc will        be called for either channel whenever data has been captured. Be sure to check which        channel is being passed in. In this example we never create an audio channel so we know        we're always dealing with video.      This data function does two things, it first decompresses captured video   data into an offscreen GWorld, draws some status information onto the frame then   transfers the frame to an onscreen window.      For more information refer to Inside Macintosh: QuickTime Components, page 5-120   c - the channel component that is writing the digitized data.   p - a pointer to the digitized data.   len - the number of bytes of digitized data.   offset - a pointer to a field that may specify where you are to write the digitized data,         and that is to receive a value indicating where you wrote the data.   chRefCon - per channel reference constant specified using SGSetChannelRefCon.   time  - the starting time of the data, in the channel's time scale.   writeType - the type of write operation being performed.       seqGrabWriteAppend - Append new data.       seqGrabWriteReserve - Do not write data. Instead, reserve space for the amount of data                   specified in the len parameter.       seqGrabWriteFill - Write data into the location specified by offset. Used to fill the space                  previously reserved with seqGrabWriteReserve. The Sequence Grabber may                  call the DataProc several times to fill a single reserved location.   refCon - the reference constant you specified when you assigned your data function to the sequence grabber.*/pascal OSErr MungGrabDataProc(SGChannel c, Ptr p, long len, long *offset, long chRefCon, TimeValue time, short writeType, long refCon){#pragma unused(offset,chRefCon,writeType,refCon)    CGrafPtr  theSavedPort;    GDHandle    theSavedDevice;    CodecFlags  ignore;    float    fps = 0,             averagefps = 0;    char    status[64];  Str255    theString;         ComponentResult err = noErr;    // reset frame and time counters after a stop/start  if (gMungData-&gt;lastTime &gt; time) {    gMungData-&gt;lastTime = 0;    gMungData-&gt;frameCount = 0;  }        gMungData-&gt;frameCount++;            if (gMungData-&gt;timeScale == 0) {      // first time here so set the time scale      err = SGGetChannelTimeScale(c, &amp;gMungData-&gt;timeScale);      BailErr(err);    }      if (gMungData-&gt;pGWorld) {      if (gMungData-&gt;decomSeq == 0) {        // Set up getting grabbed data into the GWorld                Rect           sourceRect = { 0, 0 };      MatrixRecord       scaleMatrix;      ImageDescriptionHandle imageDesc = (ImageDescriptionHandle)NewHandle(0);                        // retrieve a channel's current sample description, the channel returns a sample description that is            // appropriate to the type of data being captured            err = SGGetChannelSampleDescription(c, (Handle)imageDesc);            BailErr(err);                        /***** IMPORTANT NOTE *****                   Previous versions of this sample code made an incorrect decompression       request.  Intending to draw the DV frame at quarter-size into a quarter-size       offscreen GWorld, it made the call           err = DecompressSequenceBegin(..., &amp;rect, nil, ...);       passing a quarter-size rectangle as the source rectangle.  The correct       interpretation of this request is to draw the top-left corner of the DV       frame cropped at normal size.  Unfortunately, a DV-specific bug in QuickTime       5 caused it to misinterpret this request and scale the frame to fit.       This bug will be fixed in QuickTime 6.  If your code behaves as intended       because of the bug, you should fix your code to pass a matrix scaling the       frame to fit the offscreen gworld:        RectMatrix( &amp; scaleMatrix, &amp;dvFrameRect, &amp;gworldBounds );         err = DecompressSequenceBegin(..., nil, &amp;scaleMatrix, ...);             This approach will work in all versions of QuickTime.                   **************************/                        // make a scaling matrix for the sequence      sourceRect.right = (**imageDesc).width;      sourceRect.bottom = (**imageDesc).height;      RectMatrix(&amp;scaleMatrix, &amp;sourceRect, &amp;gMungData-&gt;boundsRect);                  // begin the process of decompressing a sequence of frames            // this is a set-up call and is only called once for the sequence - the ICM will interrogate different codecs            // and construct a suitable decompression chain, as this is a time consuming process we don't want to do this            // once per frame (eg. by using DecompressImage)            // for more information see Ice Floe #8 http://developer.apple.com/quicktime/icefloe/dispatch008.html            // the destination is specified as the GWorld      err = DecompressSequenceBegin(&amp;gMungData-&gt;decomSeq,  // pointer to field to receive unique ID for sequence                      imageDesc,      // handle to image description structure                      gMungData-&gt;pGWorld,   // port for the DESTINATION image                      NULL,          // graphics device handle, if port is set, set to NULL                      NULL,          // source rectangle defining the portion of the image to decompress                                           &amp;scaleMatrix,      // transformation matrix                                          srcCopy,        // transfer mode specifier                                          (RgnHandle)NULL,    // clipping region in dest. coordinate system to use as a mask                                          NULL,          // flags                                          codecNormalQuality,   // accuracy in decompression                                          bestSpeedCodec);    // compressor identifier or special identifiers ie. bestSpeedCodec            BailErr(err);                        DisposeHandle((Handle)imageDesc);                                 // Set up getting grabbed data into the Window                        // create the image sequence for the offscreen            err = MakeImageSequenceForGWorld(gMungData-&gt;pGWorld,                             GetWindowPort(gMungData-&gt;pWindow),                             &amp;gMungData-&gt;drawSize,                             &amp;gMungData-&gt;drawSeq);        BailErr(err);        }                // decompress a frame into the GWorld - can queue a frame for async decompression when passed in a completion proc        err = DecompressSequenceFrameS(gMungData-&gt;decomSeq,  // sequence ID returned by DecompressSequenceBegin                         p,          // pointer to compressed image data                         len,          // size of the buffer                         0,          // in flags                         &amp;ignore,        // out flags                         NULL);        // async completion proc    if (err) {          // show the error            TextSize(10);            TextMode(srcXor);            MoveTo(gMungData-&gt;boundsRect.left + 10, gMungData-&gt;boundsRect.top + 80);            sprintf(status,&quot;DecompressSequenceFrameS gave error %ld (%lx)&quot;,err,err);            CopyCStringToPascal(status, theString);            DrawString(theString);            err = noErr;    } else {        // write status information onto the frame                   GetGWorld(&amp;theSavedPort, &amp;theSavedDevice);           SetGWorld(gMungData-&gt;pGWorld, NULL);                    TextSize(12);           TextMode(srcCopy);           MoveTo(gMungData-&gt;boundsRect.left +10, gMungData-&gt;boundsRect.bottom - 14);           fps = (float)gMungData-&gt;timeScale / (float)(time - gMungData-&gt;lastTime);           averagefps = ((float)gMungData-&gt;frameCount * (float)gMungData-&gt;timeScale) / (float)time;           sprintf(status, &quot;time stamp: %ld, fps:%5.1f average fps:%5.1f&quot;, time, fps, averagefps);           CopyCStringToPascal(status, theString);           DrawString(theString);          SetGWorld(theSavedPort, theSavedDevice);                    // draw the frame to the destination, in this case the onscreen window            err = DecompressSequenceFrameS(gMungData-&gt;drawSeq,                  // sequence ID                               GetPixBaseAddr(GetGWorldPixMap(gMungData-&gt;pGWorld)),  // pointer image data                               gMungData-&gt;drawSize,                  // size of the buffer                               0,                          // in flags                               &amp;ignore,                        // out flags                               NULL);                         // can async help us?    }  }            bail:    gMungData-&gt;lastTime = time;    return err;}// --------------------// DoUpdate//void DoUpdate(void){  CodecFlags  ignore;  // draw the last frame captured     DecompressSequenceFrameS(gMungData-&gt;drawSeq,               GetPixBaseAddr(GetGWorldPixMap(gMungData-&gt;pGWorld)),                         gMungData-&gt;drawSize,                         0,                         &amp;ignore,                         NULL);     }// --------------------// MakeSequenceGrabber//SeqGrabComponent MakeSequenceGrabber(WindowRef pWindow){  SeqGrabComponent seqGrab = NULL;  OSErr       err = noErr;    // open the default sequence grabber    seqGrab = OpenDefaultComponent(SeqGrabComponentType, 0);    if (seqGrab != NULL) {       // initialize the default sequence grabber component      err = SGInitialize(seqGrab);      if (err == noErr)          // set its graphics world to the specified window          err = SGSetGWorld(seqGrab, GetWindowPort(pWindow), NULL );            if (err == noErr)        // specify the destination data reference for a record operation        // tell it we're not making a movie        // if the flag seqGrabDontMakeMovie is used, the sequence grabber still calls        // your data function, but does not write any data to the movie file        // writeType will always be set to seqGrabWriteAppend        err = SGSetDataRef(seqGrab,                   0,                   0,                   seqGrabDontMakeMovie);    }    if (err &amp;&amp; (seqGrab != NULL)) { // clean up on failure      CloseComponent(seqGrab);        seqGrab = NULL;    }      return seqGrab;}// --------------------// MakeSequenceGrabChannel//OSErr MakeSequenceGrabChannel(SeqGrabComponent seqGrab, SGChannel *sgchanVideo, Rect const *rect){    long  flags = 0;        OSErr err = noErr;        err = SGNewChannel(seqGrab, VideoMediaType, sgchanVideo);    if (err == noErr) {      err = SGSetChannelBounds(*sgchanVideo, rect);      if (err == noErr)        // set usage for new video channel to avoid playthrough         // note we don't set seqGrabPlayDuringRecord        err = SGSetChannelUsage(*sgchanVideo, flags | seqGrabRecord );            if (err != noErr) {          // clean up on failure          SGDisposeChannel(seqGrab, *sgchanVideo);          *sgchanVideo = NULL;      }    }  return err;}// --------------------// MakeAWindow//OSErr MakeAWindow(WindowRef *outWindow){    Rect        windowRect = {0, 0, 240, 320};    Rect        bestRect;        OSErr  err = noErr;    // figure out the best monitor for the window    GetBestDeviceRect(NULL, &amp;bestRect);    // put the window in the top left corner of that monitor    OffsetRect(&amp;windowRect, bestRect.left + 10, bestRect.top + 50);      err = CreateNewWindow(kDocumentWindowClass, kWindowCloseBoxAttribute, &amp;windowRect, outWindow);  BailErr(err);    SetWTitle(*outWindow, &quot;\pMunggrab&quot;);    // set the port to the new window    SetPortWindowPort(*outWindow);    ShowWindow(*outWindow);bail:      return err;}int main(void){    WindowRef      pMainWindow = NULL;    SeqGrabComponent  seqGrab;    SGChannel      sgchanVideo;  Rect         portRect;        OSErr        err = noErr;        Initialize();        // create the window    err = MakeAWindow(&amp;pMainWindow);    BailErr(err);        GetPortBounds(GetWindowPort(pMainWindow), &amp;portRect);          // initialize our data    err = InitializeMungData(portRect, pMainWindow);    BailErr(err);        // create and initialize the sequence grabber    seqGrab = MakeSequenceGrabber(pMainWindow);    BailErr(NULL == seqGrab);        // create the channel    err = MakeSequenceGrabChannel(seqGrab, &amp;sgchanVideo, &amp;portRect);    BailErr(err);        // specify a data function  err = SGSetDataProc(seqGrab, NewSGDataUPP(MungGrabDataProc), NULL);  BailErr(err);    // lights...camera...  err = SGPrepare(seqGrab, false, true);  BailErr(err);         // ...action  err = SGStartRecord(seqGrab);  BailErr(err);  gIsGrabbing = true;        while (!gDone) {        EventRecord  theEvent;        WindowRef theWindow;            GetNextEvent(everyEvent, &amp;theEvent);                if (IsWindowCollapsed(pMainWindow)) {          // checking this here avoids codecNothingToBlitErr later          SGStop(seqGrab);          gIsGrabbing = false;          gIsCollapsed = true;                  }        switch (theEvent.what) {        case nullEvent:                    // give the sequence grabber time to do it's thing          if (gIsGrabbing) {        err = SGIdle(seqGrab);        if (err) {          char errMsg[32];                    // if there is an error, display the result in the window title          // if it's a cDepthErr we don't pause; the sequence grabber          // would return cDepthErr if the window was moved or depth changed on          // QT 4.1.2, it does it less on QT 5 because Kevin made it smarter          // all other errors cause a pause - errors set in the DataProc show up          // here as well as others generated by the vDig - different vDigs can          // generate different errors in different situations          if (err == cDepthErr) {                      sprintf(errMsg, &quot;cDepthErr &quot;, err);            c2pstrcpy((unsigned char *)&amp;errMsg, errMsg);            SetWTitle(pMainWindow, (unsigned char *)errMsg);            SGStop(seqGrab);            SGStartRecord(seqGrab);            break;          } else {            KeyMap  theKeys;            #define ISESCKEYDOWN() ((theKeys[1] &amp; 0x00002000) == 0x00002000)                        SGStop(seqGrab);                        sprintf(errMsg, &quot;Stopped, esc to continue %d&quot;, err);            c2pstrcpy((unsigned char *)&amp;errMsg, errMsg);            SetWTitle(pMainWindow, (unsigned char *)errMsg);            // wait for esc             do {              GetKeys(theKeys);            } while  (!ISESCKEYDOWN());                        SetWTitle(pMainWindow, &quot;\pMunggrab&quot;);            SGStartRecord(seqGrab);          }        }      }          break;        case updateEvt:          theWindow = (WindowRef)theEvent.message;            if (theWindow == pMainWindow) {              if (gIsGrabbing) {                // inform the sequence grabber of the update                RgnHandle theUpdateRgn = NewRgn();                                GetWindowRegion(theWindow, kWindowUpdateRgn, theUpdateRgn);                 SGUpdate(seqGrab, theUpdateRgn);                DisposeRgn(theUpdateRgn);            } else {              if (!IsWindowCollapsed(pMainWindow) &amp;&amp; gIsCollapsed) {                // window was just un-collapsed, start grabbing again                SGStartRecord(seqGrab);                gIsGrabbing = true;                gIsCollapsed = false;              } else {                // update the still image                DoUpdate();              }              }                            // swallow the update event              BeginUpdate(theWindow);              EndUpdate(theWindow);            }            break;        case mouseDown:          short nPart;      nPart = FindWindow(theEvent.where, &amp;theWindow);                    if (pMainWindow != theWindow)            break;          switch (nPart) {            case inGoAway:              gDone = TrackGoAway(theWindow, theEvent.where);                break;            case inDrag:              ICMAlignmentProcRecord apr;                            SGGetAlignmentProc(seqGrab, &amp;apr);                              DragAlignedWindow(theWindow, theEvent.where, &amp;gScreenbits.bounds, NULL, &amp;apr);                              break;            }          break;                case osEvt:      if ((theEvent.message &amp; (suspendResumeMessage &lt;&lt; 24)) != 0 ) {        if ((theEvent.message &amp; resumeFlag) != 0 ) {          if (!gIsGrabbing) {            // switched in, start grabbin'            SGStartRecord(seqGrab);            gIsGrabbing = true;          }        } else {          if (gIsGrabbing) {            // switched out, stop grabbin'            SGStop(seqGrab);            gIsGrabbing = false;          }        }      }      break;                  default:          break;        } // switch    }    bail:  // clean up  if (seqGrab) {    SGStop(seqGrab);    CloseComponent(seqGrab);  }      if (pMainWindow)      DisposeWindow(pMainWindow);    return 0;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/SGDataProcSample/listing3.html%3Fid%3DDTS10000807-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/SGDataProcSample/listing3.html%3Fid%3DDTS10000807-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/SGDataProcSample/listing3.html%3Fid%3DDTS10000807-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>