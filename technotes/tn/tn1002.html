<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"        "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd"><HTML><!-- Template 03-24-01 --><!--Includes revisions to code listings--><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css">    <title>Technical Note TN1002: On Launching an App with a Document</title>                        <meta name="keywords" content="Mac OS 8 launching            applications open document Apple Events AECreateDesc">            <meta name="Description" content="Technical Note TN1002: This Technical Note             addressesthe issue of how to launch another application            from inside your app and then open a document using thatapp. Thus this TechNote details, with the use of code snippets,how to write a creator mapping function, how to send an open documents event to an application, how to serach desktop files and local volumes for an application,and how to launch an application with a coerced Apple Event. 0ctober 1995"><meta name="categories" content="Interapplication Communication"><meta name="week-posted" content="Jun 26, 2000 - Jul 7, 2000"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002845" title="On Launching an App with a Document"></a><A NAME="top"></A><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/Carbon/index.html">Carbon</a> &gt; <a href="../../technicalnotes/Carbon/idxInterapplicationCommunication-date.html">Interapplication Communication</a> &gt; </p><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1002</div>
<div id="pageheadsub">On Launching an App with a Document</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left">         <!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                        <span id="menutitle">                            CONTENTS                             <BR>                            <BR>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->					<p id="menutext"><A HREF = "#RTFToC1">About Launching an                  Application with a Document</A><BR>                  <BR>                  <A HREF = "#RTFToC2">Collected Fragments in a Code                  Snippet</A><BR>                  <BR>                  <A HREF = "#fndrask">Asking the Finder to open a                  document</A><BR>                  <BR>                  <A HREF="#Summary">Summary</A><BR>                  <BR>                  <A HREF="#References">References</A><BR>                  <BR><A HREF="#Changes">Change History</A><BR>                  <BR>                  <A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                 <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left>            <!-- begin_intro_text --><p id="introtext">This                  Technote describes how to launch another                  application from inside your app and then open a                  document using that app. Preferably, developers                  would like to utilize the signature information                  from the document to find the application.</P>                                   <p id="introtext">Developers writing applications that sub-launch                  other applications will find the material contained                  herein lets them easily extend the functionality of                  their applications to include the ability to launch                  applications with the specific documents they want                  to be opened.</P>                                    <p id="introtext">This Note combines information found in the                  chapter "Creating and Sending Apple Events" in                  <I>Inside Macintosh: Interapplication                  Communications</I> and the chapter "Desktop                  Manager" in <I>Inside Macintosh: More Macintosh                  Toolbox</I>. The format of the Open Documents event                  is described in the section "Handling the Required                  Apple Events" (4-11) in <I>Inside Macintosh:                  Interapplication Communication</I>.</P>              <!-- end_intro_text --><!-- begin_date --><h3 align=center>&nbsp;[Jul 24 2000]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR>                   <!-- begin_content -->         <A NAME=RTFToC1></A>                  <H2 ALIGN=left>About Launching an Application with a         Document</H2>                  <P>To launch an application with a document, the         following steps are required:</P>                  <OL type=1 start=1>            <LI><P>Find the appropriate            application for opening the document</P></LI>                        <LI><P>Try sending the open            documents event to the running application, and</P></LI>                        <LI><P>If Step 2 fails, launch            the application with the appropriate parameters.</P></LI>         </OL>                  <P><BR>         <BR>         </P>                  <H3 ALIGN=left>Finding the Right Application for the         Document</H3>                  <P>Every document has type and creator bytes         associated with it. The first step, therefore, in finding         what application to use is to take a look at the creator         bytes. You can find this value by using the         <CODE>FSpGetFInfo</CODE> call:</P>                                    <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>err = FSpGetFInfo(&amp;spec, &amp;fndrInfo);</pre>	</TD></TR></TABLE></CENTER>                                                   <P><CODE>fndrInfo.fdCreator</CODE> contains the         creator bytes for the document.</P>                  <P>When specifying the destination address for         the open document Apple Event, the creator bytes are used to         create a descriptor containing a         <CODE>typeApplSignature</CODE> record. If the         <CODE>AESend</CODE> indicates that no such application with         that creator is running, then the creator bytes can be used         to search the desktop files on attached volumes for the         correct application to launch.</P>                                    <H3 ALIGN=left>Using a Preferred Application to Open the         Document</H3>                  <P>Sometimes, you may want to open a document         using an application other than the one referred to by its         creator bytes. For example, you may want to open every text         document you encounter using a program such as AppleWorks.         In that case, you need to provide some internal means of         mapping file types to creator types inside of your         application that overrides the creator bytes returned by         <CODE>FSpGetFInfo</CODE>. The code snippet in this Technote         provides a means for doing this by allowing you to define a         mapping function for re-mapping the creator type used to         open a document.</P>                  <P>Here is how you would define a simple mapping         function that will work with         <CODE>LaunchTheDocument</CODE>:</P>                                    <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>   void MyMapCreator(FSSpec *document, OSType type,        OSType *creator) {                /* open all text files with                AppleWorks, creator = 'BOBO' */        if (type == 'TEXT')            *creator = 'BOBO';    }</pre>	</TD></TR></TABLE></CENTER>                                    <P>Mapping functions receive three parameters: a         <CODE>FSSpec</CODE> record referring to the document itself         &nbsp;--&nbsp;in case you want to look at the document's         data or name to establish its type&nbsp;--&nbsp;and the         document's type and creator bytes. Mapping functions provide         a simple way for your application to change the creator         bytes that will be used to find the appropriate application         before the search for the application begins. In this         example, all documents of type <CODE>'TEXT'</CODE> are         re-mapped to the creator bytes for AppleWorks, telling         <CODE>LaunchTheDocument</CODE> to ask AppleWorks to open all         text documents. The collected fragments in a code snippet         provided later in this Technote give you an example of how         to define a creator mapping function.</P>                                    <H3 ALIGN=left>Sending the Open Documents Event</H3>                  <P>As described in <CITE>Inside Macintosh:         Interapplication Communication</CITE> (4-13), the open         documents event contains one list of alias records referring         to documents to be opened by the target application. The         following description takes you through the step-by-step         construction of such an event.</P>                  <P>First, create an address descriptor record         (<CODE>appAddr</CODE>), using the creator bytes         (<CODE>fndrInfo.fdCreator</CODE>):</P>                                                      <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>   err = AECreateDesc(typeApplSignature,        (Ptr) &amp;fndrInfo.fdCreator,        sizeof(OSType), &amp;appAddr);</pre>	</TD></TR></TABLE></CENTER>                                    <P>Then you use this address record to specify         the target application when you create the Apple Event         (<CODE>theEvent</CODE>):</P>                                                      <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>   err = AECreateAppleEvent(kCoreEventClass,        kAEOpenDocuments, &amp;appAddr,        kAutoGenerateReturnID, kAnyTransactionID,        &amp;theEvent);</pre>	</TD></TR></TABLE></CENTER>                                    <P>Because you are opening a single document, you         need to create a list containing an alias record referring         to the file you want to open. Even though you're only asking         the target application to open one document, you still         create a list containing only one alias record to conform to         the definition of an open documents Apple Event.</P>                  <P>First, you create a list         (<CODE>fileList</CODE>):</P>                                                      <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>   err = AECreateList(NULL, 0, false, &amp;fileList);</pre>	</TD></TR></TABLE></CENTER>                                    <P>and a descriptor record         (<CODE>fileListElt</CODE>) containing an alias to our         document (<CODE>the_file</CODE>):</P>                                                      <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>   err = NewAlias(NULL, &amp;the_file, &amp;docAlias);    HLock((Handle) docAlias);    err = AECreateDesc(typeAlias, (Ptr) (*docAlias),        GetHandleSize((Handle) docAlias), &amp;fileListElt);    HUnlock((Handle) docAlias);</pre>	</TD></TR></TABLE></CENTER>                                    <P>Then, you add the descriptor record         (<CODE>fileListElt</CODE>) containing the alias to the list         (<CODE>fileList</CODE>):</P>                                                      <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>   err = AEPutDesc(&amp;fileList, 0, &amp;fileListElt);</pre>	</TD></TR></TABLE></CENTER>                                    <P>Now that you have the Apple Event         (<CODE>theEvent</CODE>), and the list         (<CODE>fileList</CODE>), containing an alias record         referring to the file you want opened, you can take the list         and put it into the Apple Event (<CODE>theEvent</CODE>) as         an Apple Event parameter:</P>                                                      <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>   err = AEPutParamDesc(&amp;theEvent,        keyDirectObject, &amp;fileList);</pre>	</TD></TR></TABLE></CENTER>                                    <P>At this point the open documents event         (<CODE>theEvent</CODE>) has been set up correctly and you         can send it to the application:</P>                                                      <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>   err = AESend(&amp;theEvent, &amp;eventReply,        kAENoReply, kAENormalPriority, kNoTimeOut,        NULL, NULL);</pre>	</TD></TR></TABLE></CENTER>                                    <H3 ALIGN=left>When the application is not running</H3>                  <P>When <CODE>AESend</CODE> returns an error         result of <CODE>connectionInvalid</CODE>, this means the         application with the specified creator bytes is not         currently registered with the Process Manager. In this case,         the correct application must be launched before it can be         sent the open document event. The first thing to do here is         search through the desktop files on connected volumes using         the <CODE>PBDTGetAPPL</CODE> routine to find the application         with the correct creator bytes for the document.</P>                  <P>The following code fragment illustrates how         this can be done.</P>                                    <P>&nbsp;&nbsp;</P>                  <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>   /* IsRemoteVolume can be used to find out if the    volume referred to by vRefNum is a remote volume    located somewhere on a network. the volume's attribute    flags (copied from the GetVolParmsInfoBuffer structure)    are returned in the longword pointed to by vMAttrib. */OSErr IsRemoteVolume(short vRefNum, Boolean *isRemote, long *vMAttrib) {    HParamBlockRec volPB;    GetVolParmsInfoBuffer volinfo;    OSErr err;    volPB.ioParam.ioVRefNum = vRefNum;    volPB.ioParam.ioNamePtr = NULL;    volPB.ioParam.ioBuffer = (Ptr) &amp;volinfo;    volPB.ioParam.ioReqCount = sizeof(volinfo);    err = PBHGetVolParmsSync(&amp;volPB);    if (err == noErr) {        *isRemote = (volinfo.vMServerAdr != 0);        *vMAttrib = volinfo.vMAttrib;    }    return err;}    /* BuildVolumeList fills the array pointed to by vols with    a list of the currently mounted volumes.  If includeRemote    is true, then remote server volumes will be included in    the list.  When remote server volumes are included in the    list, they will be added to the end of the list.  On entry,    *count should contain the size of the array pointed to by    vols.  On exit, *count will be set to the number of id numbers    placed in the array. If vMAttribMask is non-zero, then    only volumes with matching attributes are added to the    list of volumes. bits in the vMAttribMask should use the    same encoding as bits in the vMAttrib field of    the GetVolParmsInfoBuffer structure. */OSErr BuildVolumeList(Boolean includeRemote, short *vols,        long *count, long vMAttribMask) {    HParamBlockRec volPB;    Boolean isRemote;    OSErr err;    long nlocal, nremote;        /* set up and check parameters */    volPB.volumeParam.ioNamePtr = NULL;    nlocal = nremote = 0;    if (*count == 0) return noErr;        /* iterate through volumes */    for (volPB.volumeParam.ioVolIndex = 1;        PBHGetVInfoSync(&amp;volPB) == noErr;        volPB.volumeParam.ioVolIndex++) {                /* skip remote volumes, if necessary */        err = IsRemoteVolume(volPB.volumeParam.ioVRefNum, &amp;isRemote);        if (err != noErr) goto bail;        if ( ( includeRemote || ! isRemote )        &amp;&amp; (vMAttrib &amp; vMAttribMask) == vMAttribMask ) {                /* add local volumes at the front, remote                volumes at the end */            if (isRemote)                vols[nlocal + nremote++] = volPB.volumeParam.ioVRefNum;            else {                if (nremote &gt; 0)                    BlockMoveData(vols+nlocal, vols+nlocal+1,                        nremote*sizeof(short));                vols[nlocal++] = volPB.volumeParam.ioVRefNum;            }                /* list full? */            if ((nlocal + nremote) &gt;= *count) break;        }    }bail:    *count = (nlocal + nremote);    return err;}    /* FindApplication iterates through mounted volumes    searching for an application with the given creator    type.  If includeRemote is true, then remote volumes    will be searched (after local ones) for an application    with the creator type. */#define kMaxVols 20OSErr FindApplication(OSType appCreator, Boolean includeRemote,        FSSpec *appSpec) {    short rRefNums[kMaxVols];    long i, volCount;    DTPBRec desktopPB;    Str255 appName;    OSErr err;        /* get a list of volumes - with desktop files */    volCount = kMaxVols;    err = BuildVolumeList(includeRemote, rRefNums, &amp;volCount,        (1&lt;&lt;bHasDesktopMgr) );    if (err != noErr) return err;        /* iterate through the list */    for (i=0; i&lt;volCount; i++) {            /* has a desktop file? */        desktopPB.ioCompletion = NULL;        desktopPB.ioVRefNum = rRefNums[i];        desktopPB.ioNamePtr = NULL;        desktopPB.ioIndex = 0;        err = PBDTGetPath(&amp;desktopPB);        if (err != noErr) continue;            /* has the correct app?? */        desktopPB.ioFileCreator = appCreator;        desktopPB.ioNamePtr = appName;        err = PBDTGetAPPLSync(&amp;desktopPB);        if (err != noErr) continue;            /* make a file spec referring to it */        err = FSMakeFSSpec(rRefNums[i],              desktopPB.ioAPPLParID, appName,              appSpec);        if (err != noErr) continue;           /* found it! */        return noErr;    }    return fnfErr;}</pre>	</TD></TR></TABLE></CENTER><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>        This is a fairly simple search method. For your                  purposes, you may want to modify it so it does                  special things, such as not bothering with ejected                  disks that are still mounted, or searching                  particular disks before others. The code fragment                  searches local volumes only by checking to see if                  they are local using the                  <CODE>PBHGetVolParms</CODE> routine. In the code                  snippet in this Technote, local volumes are                  searched before an optional search of remote                  volumes takes place.</P>              </TD></TR></TABLE></CENTER><BR>         <H3 ALIGN=left>Launching the App</H3>                  <P>Once you find the correct application, the         next step is to coerce the Apple Event that         <CODE>AESend</CODE> failed to send into the correct format         so a pointer to the parameters can be stored in the launch         parameter block. This can be achieved with a call to         <CODE>AECoerceDesc</CODE> specifying         <CODE>typeAppParameters</CODE> as the destination type:</P>                                                      <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>       /* ask the Apple Event Manager to coerce the Apple        event into a launch application parameter block        record. */    err = AECoerceDesc(&amp;theEvent, typeAppParameters,          &amp;paraDesc);        /* copy the record's data into our own memory        location so it can be incorporated into the        LaunchApplication parameter block.  Here, the new        location is referenced using the variable paraData. */#if TARGET_API_MAC_CARBON    paraSize = AEGetDescDataSize(&amp;paraDesc);    paraData = (AppParametersPtr) NewPtr(paraSize);    if (paraData == NULL) { err = memFullErr; goto bail; }    err = AEGetDescData(&amp;paraDesc, paraData, paraSize );    if (err != noErr) goto bail;#else    paraSize = GetHandleSize((Handle) paraDesc.dataHandle);    paraData = (AppParametersPtr) NewPtr(paraSize);    if (paraData == NULL) { err = memFullErr; goto bail; }    BlockMoveData(*paraDesc.dataHandle, paraData, paraSize);#endif</pre>	</TD></TR></TABLE></CENTER>                                    <P>Once this coercion has been performed,         everything required for setting up the launch parameter         block is available so the application can be launched:</P>                                                      <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>   launchPB.launchBlockID = extendedBlock;    launchPB.launchEPBLength = extendedBlockLen;    launchPB.launchFileFlags = 0;    launchPB.launchControlFlags =        launchContinue + launchNoFileFlags;    launchPB.launchAppSpec = &amp;appSpec;    launchPB.launchAppParameters = paraData;    err = LaunchApplication(&amp;launchPB);</pre>	</TD></TR></TABLE></CENTER>                                    <H3 ALIGN=left>If the Target Application is Not Apple Event         Aware</H3>                  <P>If the target application is not high-level         event aware (pre-System 7), the Apple Event Manager will         automatically coerce the event into the old-style launch         parameters when the program is being launched. The old-style         '<CODE>mstr</CODE>' and '<CODE>mst#</CODE>' resources used         by MultiFinder in System 6 are no longer supported;         therefore, you can't use the routines described herein to         open the document if the application is already running.</P>                  <P><A HREF = "#top">Back to top</A></P>                  <BR>                  <P><A NAME=RTFToC2></A></P>                  <H2 ALIGN=left>Collected Fragments in a Code Snippet</H2>                  <P>The following code snippet combines all of the         concepts previously explained.</P>                                    <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>   /* Code snippet illustrating how to launch an application    and send it an open document Apple Event.    Copyright (C) 1995,2000 by Apple Computer, Inc.    All Rights Reserved.*/#include &lt;Types.h&gt;#include &lt;Fonts.h&gt;#include &lt;Files.h&gt;#include &lt;Errors.h&gt;#include &lt;Aliases.h&gt;#include &lt;AppleEvents.h&gt;#include &lt;AEDataModel.h&gt;    /* IsRemoteVolume can be used to find out if the    volume referred to by vRefNum is a remote volume    located somewhere on a network. the volume's attribute    flags (copied from the GetVolParmsInfoBuffer structure)    are returned in the longword pointed to by vMAttrib. */OSErr IsRemoteVolume(short vRefNum, Boolean *isRemote, long *vMAttrib) {    HParamBlockRec volPB;    GetVolParmsInfoBuffer volinfo;    OSErr err;    volPB.ioParam.ioVRefNum = vRefNum;    volPB.ioParam.ioNamePtr = NULL;    volPB.ioParam.ioBuffer = (Ptr) &amp;volinfo;    volPB.ioParam.ioReqCount = sizeof(volinfo);    err = PBHGetVolParmsSync(&amp;volPB);    if (err == noErr) {        *isRemote = (volinfo.vMServerAdr != 0);        *vMAttrib = volinfo.vMAttrib;    }    return err;}    /* BuildVolumeList fills the array pointed to by vols with    a list of the currently mounted volumes.  If includeRemote    is true, then remote server volumes will be included in    the list.  When remote server volumes are included in the    list, they will be added to the end of the list.  On entry,    *count should contain the size of the array pointed to by    vols.  On exit, *count will be set to the number of id numbers    placed in the array. If vMAttribMask is non-zero, then    only volumes with matching attributes are added to the    list of volumes. bits in the vMAttribMask should use the    same encoding as bits in the vMAttrib field of    the GetVolParmsInfoBuffer structure. */OSErr BuildVolumeList(Boolean includeRemote, short *vols,        long *count, long vMAttribMask) {    HParamBlockRec volPB;    Boolean isRemote;    OSErr err;    long nlocal, nremote;        /* set up and check parameters */    volPB.volumeParam.ioNamePtr = NULL;    nlocal = nremote = 0;    if (*count == 0) return noErr;        /* iterate through volumes */    for (volPB.volumeParam.ioVolIndex = 1;        PBHGetVInfoSync(&amp;volPB) == noErr;        volPB.volumeParam.ioVolIndex++) {                /* skip remote volumes, if necessary */        err = IsRemoteVolume(volPB.volumeParam.ioVRefNum, &amp;isRemote);        if (err != noErr) goto bail;        if ( ( includeRemote || ! isRemote )        &amp;&amp; (vMAttrib &amp; vMAttribMask) == vMAttribMask ) {                /* add local volumes at the front, remote                volumes at the end */            if (isRemote)                vols[nlocal + nremote++] = volPB.volumeParam.ioVRefNum;            else {                if (nremote &gt; 0)                    BlockMoveData(vols+nlocal, vols+nlocal+1,                        nremote*sizeof(short));                vols[nlocal++] = volPB.volumeParam.ioVRefNum;            }                /* list full? */            if ((nlocal + nremote) &gt;= *count) break;        }    }bail:    *count = (nlocal + nremote);    return err;}    /* FindApplication iterates through mounted volumes    searching for an application with the given creator    type.  If includeRemote is true, then remote volumes    will be searched (after local ones) for an application    with the creator type. */#define kMaxVols 20OSErr FindApplication(OSType appCreator, Boolean includeRemote,        FSSpec *appSpec) {    short rRefNums[kMaxVols];    long i, volCount;    DTPBRec desktopPB;    Str255 appName;    OSErr err;        /* get a list of volumes - with desktop files */    volCount = kMaxVols;    err = BuildVolumeList(includeRemote, rRefNums, &amp;volCount,        (1&lt;&lt;bHasDesktopMgr) );    if (err != noErr) return err;        /* iterate through the list */    for (i=0; i&lt;volCount; i++) {            /* has a desktop file? */        desktopPB.ioCompletion = NULL;        desktopPB.ioVRefNum = rRefNums[i];        desktopPB.ioNamePtr = NULL;        desktopPB.ioIndex = 0;        err = PBDTGetPath(&amp;desktopPB);        if (err != noErr) continue;            /* has the correct app?? */        desktopPB.ioFileCreator = appCreator;        desktopPB.ioNamePtr = appName;        err = PBDTGetAPPLSync(&amp;desktopPB);        if (err != noErr) continue;            /* make a file spec referring to it */        err = FSMakeFSSpec(rRefNums[i],              desktopPB.ioAPPLParID, appName,              appSpec);        if (err != noErr) continue;           /* found it! */        return noErr;    }    return fnfErr;}    /* MapCreatorProcs, when provided as a parameter    to LaunchTheDocument, will be called to allow    your app to re-map the creator type for a file    to a different creator type. Your function    should either modify *creator to refer to a    preferred application by replacing its value    with the value of the preferred application's    creator bytes, or leave *creator untouched if    you want the creator bytes from the document to    be used. */typedef void (*MapCreatorProc)(FSSpec *document,    OSType type, OSType *creator);    /* LaunchTheDocument attempts to open the    document with either an application that is    already loaded in memory and running, or by    finding and launching the appropriate    application with the document as a parameter.    If no application can be found with the creator    bytes found in the document, fnfErr is returned.    Local Volumes are searched before remote server    volumes. Remote server volumes are only searched    if allowRemoteApps is true. If the optional    creator remapping procedure is provided    (remap != NULL), then it will be called to    allow the caller to re-map the creator bytes    to a preferred application for the document's    type.. */OSErr LaunchTheDocument(FSSpec *document, Boolean allowRemoteApps,        MapCreatorProc remap) {    OSErr err, sresult;    AEAddressDesc appAddr;    AEDescList fileList;    AEDesc fileListElt, paraDesc;    AppleEvent theEvent;    AppleEvent eventReply;    AliasHandle docAlias;    FInfo fndrInfo;    OSType appCreator;    FSSpec appSpec;    LaunchParamBlockRec launchPB;    Size paraSize;    AppParametersPtr paraData;        /* initialize our records to NULL        descriptors */    AECreateDesc(typeNull, NULL, 0, &amp;appAddr);    AECreateDesc(typeNull, NULL, 0, &amp;fileList);    AECreateDesc(typeNull, NULL, 0, &amp;fileListElt);    AECreateDesc(typeNull, NULL, 0, &amp;theEvent);    AECreateDesc(typeNull, NULL, 0, &amp;eventReply);    AECreateDesc(typeNull, NULL, 0, &amp;paraDesc);    docAlias = NULL;    paraData = NULL;        /* get the target application's creator */    err = FSpGetFInfo(document, &amp;fndrInfo);    if (err != noErr) goto bail;        /* call the remap function if applicable */    appCreator = fndrInfo.fdCreator;    if (remap != NULL)        remap(document, fndrInfo.fdType,            &amp;appCreator);        /* create an open documents Apple Event */    err = AECreateDesc(typeApplSignature,          (Ptr)&amp;appCreator, sizeof(OSType), &amp;appAddr);    if (err != noErr) goto bail;    err = AECreateAppleEvent(kCoreEventClass, kAEOpenDocuments,          &amp;appAddr, kAutoGenerateReturnID, kAnyTransactionID,          &amp;theEvent);    if (err != noErr) goto bail;        /* create a one element list of files to send in the        event */    err = AECreateList(NULL, 0, false, &amp;fileList);    if (err != noErr) goto bail;    err = NewAlias(NULL, document, &amp;docAlias);    if (err != noErr) goto bail;    HLock((Handle) docAlias);    err = AECreateDesc(typeAlias, (Ptr) (*docAlias),          GetHandleSize((Handle) docAlias), &amp;fileListElt);    HUnlock((Handle) docAlias);    if (err != noErr) goto bail;    err = AEPutDesc(&amp;fileList, 0, &amp;fileListElt);    if (err != noErr) goto bail;        /* add the file list to the open documents event */    err = AEPutParamDesc(&amp;theEvent, keyDirectObject, &amp;fileList);    if (err != noErr) goto bail;        /* send the Apple Event */    err = AESend(&amp;theEvent, &amp;eventReply, kAENoReply,          kAENormalPriority, kNoTimeOut, NULL, NULL);        /* if the target could not be found...        no such app running? */    if (err == connectionInvalid) {            /* find an application to launch */        err = FindApplication(appCreator, allowRemoteApps, &amp;appSpec )        if (err != noErr) goto bail;            /* ask the Apple Event Manager to coerce the Apple            event into a launch application parameter block            record. */        err = AECoerceDesc(&amp;theEvent, typeAppParameters,              &amp;paraDesc);        if (err != noErr) goto bail;            /* copy the record's data into our own memory            location so it can be incorporated into the            LaunchApplication parameter block.  Here, the new            location is referenced using the variable paraData. */#if TARGET_API_MAC_CARBON        paraSize = AEGetDescDataSize(&amp;paraDesc);        paraData = (AppParametersPtr) NewPtr(paraSize);        if (paraData == NULL) { err = memFullErr; goto bail; }        err = AEGetDescData(&amp;paraDesc, paraData, paraSize );        if (err != noErr) goto bail;#else        paraSize = GetHandleSize((Handle) paraDesc.dataHandle);        paraData = (AppParametersPtr) NewPtr(paraSize);        if (paraData == NULL) { err = memFullErr; goto bail; }        BlockMoveData(*paraDesc.dataHandle, paraData, paraSize);#endif            /* launch the application */        launchPB.launchBlockID = extendedBlock;        launchPB.launchEPBLength = extendedBlockLen;        launchPB.launchFileFlags = 0;        launchPB.launchControlFlags =            launchContinue + launchNoFileFlags;        launchPB.launchAppSpec = &amp;appSpec;        launchPB.launchAppParameters = paraData;        err = LaunchApplication(&amp;launchPB);    }bail:        /* clean up, and go.. */    if (docAlias != NULL) DisposeHandle((Handle) docAlias);    if (paraData != NULL) DisposePtr((Ptr) paraData);    AEDisposeDesc(&amp;paraDesc);    AEDisposeDesc(&amp;appAddr);    AEDisposeDesc(&amp;fileListElt);    AEDisposeDesc(&amp;fileList);    AEDisposeDesc(&amp;theEvent);    AEDisposeDesc(&amp;eventReply);    return err;}    /* sample creator mapping function. The    function simply tells LaunchTheDocument    that every document of type 'TEXT' should    be opened using MPW Shell */void MyMapCreator(FSSpec *document, OSType type, OSType *creator) {        /* open all text files with AppleWorks,        creator = 'BOBO' */    if (type == 'TEXT')        *creator = 'BOBO';}void DoTestWithMyDocument(void) {    FSSpec spec;    if (FSMakeFSSpec(0, 0, "\pMy Document", &amp;spec) == noErr)        LaunchTheDocument(&amp;spec, false, MyMapCreator);}</pre>	</TD></TR></TABLE></CENTER>                                    <P>File <CODE>SendOpen.r</CODE> containing Rez         source for the <CODE>'SIZE'</CODE> resource. Because you're         working with Apple Events, you must include a         <CODE>'SIZE'</CODE> resource with the         <CODE>isHighLevelEventAware</CODE> bit set so your         application can send and receive Apple Events. Here is a Rez         description of a <CODE>'SIZE'</CODE> resource with this bit         turned on:</P>                                                      <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>   resource 'SIZE' (-1, purgeable) {        reserved,        acceptSuspendResumeEvents,        reserved,        canBackground,        multiFinderAware,        backgroundAndForeground,        dontGetFrontClicks,        ignoreChildDiedEvents,        is32BitCompatible,        isHighLevelEventAware,        localAndRemoteHLEvents,        isStationeryAware,        dontUseTextEditServices,        reserved,        reserved,        reserved,        524288,        524288    };</pre>	</TD></TR></TABLE></CENTER>                                    <P><A HREF = "#top">Back to top</A></P>                  <BR>                  <P><A NAME=fndrask></A></P>                  <H2 ALIGN=left>Asking the Finder to open a document</H2>                  <P>It is also possible to ask the Finder to find         the correct application to open a document. To do this, an         application must create an open-documents Apple Event and         sent it to the Finder. The following routine illustrates how         this can be done.</P>                                                      <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>#include &lt;Types.h&gt;#include &lt;Files.h&gt;#include &lt;AppleEvents.h&gt;#include &lt;Errors.h&gt;#include &lt;AERegistry.h&gt;#include &lt;Aliases.h&gt;    /* FinderLaunch converts a list of nTargets FSSpec records    pointed to by the targetList parameter and converts the    list to an Apple Event.  It then sends that event to the    Finder.  The array of FSSpec records pointed to by the    targetList parameter may contain references to files,    folders, or applications.  The net effect of this command    is equivalent to the user selecting an icon in one of the    Finder's windows and then choosing the open command from    the Finder's file menu. */OSErr FinderLaunch(long nTargets, FSSpec *targetList) {    OSErr err;    AppleEvent theAEvent, theReply;    AEAddressDesc fndrAddress;    AEDescList targetListDesc;    OSType fndrCreator;    Boolean wasChanged;    AliasHandle targetAlias;    long index;        /* set up locals  */    AECreateDesc(typeNull, NULL, 0, &amp;theAEvent);    AECreateDesc(typeNull, NULL, 0, &amp;fndrAddress);    AECreateDesc(typeNull, NULL, 0, &amp;theReply);    AECreateDesc(typeNull, NULL, 0, &amp;targetListDesc);    targetAlias = NULL;    fndrCreator = 'MACS';        /* verify parameters */    if ((nTargets == 0) || (targetList == NULL)) {        err = paramErr;        goto bail;    }        /* create an open documents event targeting the        finder */    err = AECreateDesc(typeApplSignature, (Ptr) &amp;fndrCreator,        sizeof(fndrCreator), &amp;fndrAddress);    if (err != noErr) goto bail;    err = AECreateAppleEvent(kCoreEventClass, kAEOpenDocuments,        &amp;fndrAddress, kAutoGenerateReturnID,        kAnyTransactionID, &amp;theAEvent);    if (err != noErr) goto bail;        /* create the list of files to open */    err = AECreateList(NULL, 0, false, &amp;targetListDesc);    if (err != noErr) goto bail;    for ( index=0; index &lt; nTargets; index++) {        if (targetAlias == NULL)            err = NewAlias(NULL, (targetList + index),                  &amp;targetAlias);        else err = UpdateAlias(NULL, (targetList + index),                   targetAlias, &amp;wasChanged);        if (err != noErr) goto bail;        HLock((Handle) targetAlias);        err = AEPutPtr(&amp;targetListDesc, (index + 1),              typeAlias, *targetAlias,              GetHandleSize((Handle) targetAlias));        HUnlock((Handle) targetAlias);        if (err != noErr) goto bail;    }        /* add the file list to the Apple Event */    err = AEPutParamDesc(&amp;theAEvent, keyDirectObject,          &amp;targetListDesc);    if (err != noErr) goto bail;        /* send the event to the Finder */    err = AESend(&amp;theAEvent, &amp;theReply, kAENoReply,        kAENormalPriority, kAEDefaultTimeout, NULL, NULL);        /* clean up and leave */bail:    if (targetAlias != NULL) DisposeHandle((Handle) targetAlias);    AEDisposeDesc(&amp;targetListDesc);    AEDisposeDesc(&amp;theAEvent);    AEDisposeDesc(&amp;fndrAddress);    AEDisposeDesc(&amp;theReply);    return err;}void DoTestWithMyDocument(void) {    FSSpec spec;    if (FSMakeFSSpec(0, 0, "\pMy Document", &amp;spec) == noErr)        FinderLaunch(1, &amp;spec );}</pre>	</TD></TR></TABLE></CENTER>                                    <P>Asking the Finder to open an a document for         you is obviously far more convenient than finding an         launching the application yourself. However, it does not         allow your application to have the same amount of control         over the application selection process as the method         described at the beginning of this technote.</P>           <BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>                 Interestingly enough, if an application sends an                  open documents event to the Finder that references                  one or more folders (instead of files), then the                  Finder will open windows to display the contents of                  those folders.</P></TD></TR></TABLE></CENTER><BR>                                 <P><A HREF = "#top">Back to top</A></P>                  <BR>                  <P><A NAME=RTFToC3></A></P>                  <a name="Summary"></a><H2 ALIGN=left>Summary</H2>                  <P>Launching an application with a document under         System 7 requires the use of the Apple Event Manager to         either directly send an open document event to an existing         application or indirectly send an open document event to an         application as part of its launch sequence. This Technote         describes how you can do this in your applications and         provides a simple example of how you can use the         technique.</P>                  <P><A HREF = "#top">Back to top</A></P>                  <a name="References"></a><H2 ALIGN=left>References</H2>                                    <P>Apple Computer, Inc. (1993) <a href="../../documentation/mac/IAC/IAC-195.html">"Creating                  And Sending Apple Events"</A> (Chapter 5), Inside                  Macintosh: Interapplication Communication. Addison                  Wesley.</P>                                    <P>Apple Computer, Inc. (1993) <a href="../../documentation/mac/IAC/IAC-119.html">"Handling                  the Required Apple Events"</A> (4-11), Inside                  Macintosh: Interapplication Communication. Addison                  Wesley.</P>                                    <P>Apple Computer, Inc. (1993) <a href="../../documentation/mac/MoreToolbox/MoreToolbox-483.html">"Desktop                  Manager"</A> (Chapter 9), Inside Macintosh: More                  Macintosh Toolbox. Addison Wesley.</P>                                    <P>Apple Computer, Inc. (1993) <a href="../../documentation/mac/Files/Files-166.html">"Obtaining                  Volume Information"</A> (2-145), Inside Macintosh:                  Files. Addison Wesley.</P>                                    <P>Apple Computer, Inc. (1993) <a href="../../documentation/mac/Files/Files-340.html">"Alias                  Manager"</A> (Chapter 4), Inside Macintosh: Files.                  Addison Wesley.</P>                                 <P><A HREF = "#top">Back to top</A></P>                  <BR>                  <P><A NAME=Changes></A></P>                  <H2 ALIGN=left>Change History</H2>                          <TABLE BORDER=0 CELLPADDING=3 WIDTH=544>            <TR>               <td width=100 align=left>                  <P ALIGN=center>October-15-1995</P>               </TD>               <td align="left">                  <P>Created.</P>               </TD>            </TR>            <TR>               <td width=100 align=left>                  <P ALIGN=center>July-24-2000</P>               </TD>               <td align="left">                  <P>Added Finder section.</P>               </TD>            </TR>         </TABLE>         <BR>                   <P><A HREF="#top">Back to top</A></P>                                    <P>&nbsp;<A NAME=Downloads></A></P>                  <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (68K)</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/tn1002.pdf">Download</A></P>               </TD>            </TR>         </TABLE>         <BR><BR><P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1002.html%3Fid%3DDTS10002845-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1002.html%3Fid%3DDTS10002845-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1002.html%3Fid%3DDTS10002845-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>