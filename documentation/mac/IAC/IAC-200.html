<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Sending an Apple Event(IM:IC)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING200></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="IAC-199.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="IAC-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="IAC-529.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="IAC-201.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="IAC-2.html"><B>Interapplication Communication</B></A> / <BR><DD><A HREF="IAC-195.html"><B>Chapter 5 - Creating and Sending Apple Events</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING200-0></A>
<H1><A NAME=MARKER-9-87></A><A NAME=MARKER-21-88></A>Sending an Apple Event</H1>
 <A NAME=MARKER-2-330></A><A NAME=MARKER-2-72></A>To send an Apple event, you first create an Apple event, add parameters and attributes to it, and then use the <CODE>AESend</CODE> function to send it. <P>
 When you send an Apple event, you specify various options to indicate how the server should handle the Apple event. You request a user interaction level from the server and specify whether the server can switch directly to the foreground if user interaction is needed, whether your application is willing to wait for a reply Apple event, whether reconnection is allowed, and whether your application wants a return receipt for the Apple event. <P>
 You specify these options by setting flags in the <CODE>sendMode</CODE> parameter for <CODE>AESend</CODE>. Here are the constants that represent these flags<A NAME=MARKER-2-65></A><A NAME=MARKER-2-315></A><A NAME=MARKER-2-368></A><A NAME=MARKER-2-351></A><A NAME=MARKER-9-24></A>:<A NAME=MARKER-21-320></A><P>
<PRE>
CONST kAENoReply        = $00000001;{client doesn't want reply}
      kAEQueueReply     = $00000002;{client wants Apple Event } 
                                    { Manager to return }
                                    { reply in event queue}
      kAEWaitReply      = $00000003;{client wants a reply and }
                                    { will give up processor}

      kAENeverInteract  = $00000010;{server application }
                                    { should not interact }
                                    { with user for this }
                                    { Apple event}
      kAECanInteract    = $00000020;{server may interact with }
                                    { user for this Apple }
                                    { event to supply } 
                                    { information}
      kAEAlwaysInteract = $00000030;{server may interact with }
                                    { user for this Apple }
                                    { event even if no }
                                    { information is required}

      kAECanSwitchLayer = $00000040;{server should come }
                                    { directly to foreground }
                                    { when appropriate}
      kAEDontReconnect  = $00000080;{don't reconnect if there }
                                    { is a PPC session closed }
                                    { error}
      kAEWantReceipt    = nReturnReceipt;{client wants return }
                                         { receipt}
      kAEDontRecord     = $00001000;{don't record this event}
      kAEDontExecute    = $00002000;{don't execute this event}
</PRE>
 If you want your application to receive a reply Apple event, specify the <CODE>kAEQueueReply</CODE> or <CODE>kAEWaitReply</CODE> flag. If you want your application to receive the reply Apple event in its event queue, use <CODE>kAEQueueReply</CODE>. If you want your application to receive the reply Apple event in the <CODE>reply</CODE> parameter for <CODE>AESend</CODE> and you are willing to give up the processor while it is waiting for the reply, use <CODE>kAEWaitReply</CODE>. If you don't want your application to receive a reply Apple event and your application doesn't need to wait for the server to handle the Apple event, specify <CODE>kAENoReply</CODE>. <P>
<DL>
<DT><B>Note</B>
<DD>Before the Apple Event Manager sends a reply event back to the client application, the <CODE>keyAddressAttr</CODE> attribute contains the address of the client application. After the client receives the reply event, the <CODE>keyAddressAttr</CODE> attribute contains the address of the server application.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 If you specify <CODE>kAENoReply</CODE> or <CODE>kAEQueueReply</CODE>, the <CODE>AESend</CODE> function returns immediately after using the Event Manager to send the event. In this case, a <CODE>noErr</CODE> result code from <CODE>AESend</CODE> indicates that the Event Manager sent the Apple event; it does not mean that the server accepted or handled the Apple event. <P>
 When <CODE>AESend</CODE> returns, the <CODE>reply</CODE> parameter does not contain valid data if your application specifies <CODE>kAENoReply</CODE> or <CODE>kAEQueueReply</CODE>. The <CODE>kAENoReply</CODE> flag indicates that the Apple Event Manager will not return the reply Apple event to your application. The <CODE>kAEQueueReply</CODE> flag indicates that you want your application to receive the reply via its event queue rather than the <CODE>reply</CODE> parameter of <CODE>AESend</CODE>. If you specify <CODE>kAEQueueReply</CODE>, you must install a handler for the reply Apple event (event class <CODE>kCoreEventClass</CODE> and event ID <CODE>kAEAnswer</CODE>). <P>
 If you specify <CODE>kAEWaitReply</CODE>, the Apple Event Manager uses the Event Manager to send the event. The Apple Event Manager then calls the <CODE>WaitNextEvent</CODE> function on behalf of your application, causing your application to yield the processor and giving the server application a chance to receive and handle the Apple event. Your application continues to yield the processor until the server handles the Apple event or the request times out. <A NAME=MARKER-2-322></A><P>
 If you specify <CODE>kAEWaitReply</CODE>, you must provide an idle function. This function should process any update events, null events, operating-system events, or activate events that occur while your application is waiting for a reply. See <A HREF=IAC-202.html#MARKER-9-123>"Writing an Idle Function,"</A> which begins on <A HREF=IAC-202.html#MARKER-9-123>page 5-22</A>, for sample code that shows an idle function. <P>
 You use one of the three flags--<CODE>kAENeverInteract</CODE>, <CODE>kAECanInteract</CODE>, and <CODE>kAEAlwaysInteract</CODE>--to specify whether the server should interact with the user when handling the Apple event. Specify <CODE>kAENeverInteract</CODE> if the server should not interact with the user when handling the Apple event. You might specify this constant if you don't want the user to be interrupted while the server is handling the Apple event.<A NAME=MARKER-2-295></A><A NAME=MARKER-2-321></A><A NAME=MARKER-2-325></A><A NAME=MARKER-2-269></A><A NAME=MARKER-2-102></A><A NAME=MARKER-9-31></A><P>
 Use the <CODE>kAECanInteract</CODE> flag if the server should interact with the user when the user needs to supply information to the server. Use the <CODE>kAEAlwaysInteract</CODE> flag if the server should interact with the user whenever the server normally asks a user to confirm a decision or interact in any other way, even if no additional information is needed from the user. Note that it is the responsibility of the server and client applications to agree on how to interpret the <CODE>kAEAlwaysInteract</CODE> flag. <P>
 If the client application does not set any one of the user interaction flags, the Apple Event Manager sets a default, depending on the location of the target of the Apple event. If the server application is on a remote computer, the Apple Event Manager sets the <CODE>kAENeverInteract</CODE> flag as the default. If the target of the Apple event is on the local computer, the Apple Event Manager sets the <CODE>kAECanInteract</CODE> flag as the default.<P>
 The server application should call <CODE>AEInteractWithUser</CODE> if it needs to interact with the user. If both the client and the server allow user interaction, the Apple Event Manager attempts to bring the server to the foreground if it is not already the foreground process. If both the <CODE>kAECanSwitchLayer</CODE> and the <CODE>kAEWaitReply</CODE> flags are set, and if the client application is the active application on the local computer, the Apple Event Manager brings the server application directly to the front. Otherwise, the Apple Event Manager posts a notification request asking the user to bring the server application to the front, regardless of whether the <CODE>kAECanSwitchLayer</CODE> flag is set. This ensures that the user will not be interrupted by an unexpected application switch. <P>
 You should specify the <CODE>kAECanSwitchLayer</CODE> flag only when the client and server applications reside on the same computer. In general, you should not set this flag if it would be confusing or inconvenient to the user for the server application to come to the front unexpectedly. This flag is ignored if you are sending an Apple event to a remote computer.<P>
 Specify the <CODE>kAEDontReconnect</CODE> flag if the Apple Event Manager should not reconnect if it receives a session closed error from the PPC Toolbox. If you don't set this flag, the Apple Event Manager automatically attempts to reconnect and reestablish the session.<A NAME=MARKER-2-68></A><A NAME=MARKER-9-69></A><P>
 Specify the <CODE>kAEWantReceipt</CODE> flag if your application wants notification that the server application has accepted the Apple event. If you specify this flag, your application receives a return receipt as a high-level event.<P>
 If you specify the <CODE>kAEWantReceipt</CODE> flag and the server application does not accept the Apple event within the time specified by the <CODE>timeOutInTicks</CODE> parameter to <CODE>AESend</CODE>, the <CODE>AESend</CODE> function returns a timeout error. Note that <CODE>AESend</CODE> also returns a timeout error if your application sets the <CODE>kAEWaitReply</CODE> flag and does not receive the reply Apple event within the time specified by the <CODE>timeOutInTicks</CODE> parameter.<A NAME=MARKER-9-34></A><P>
 Specify the <CODE>kAEDontRecord</CODE> flag if your application is sending an Apple event to itself that you don't want to be recorded. When Apple event recording has been turned on, every event that your application sends to itself will be automatically recorded by the Apple Event Manager except those sent with the <CODE>kAEDontRecord</CODE> flag set.<P>
 Specify the <CODE>kAEDontExecute</CODE> flag if your application is sending an Apple event to itself for recording purposes only--that is, if you want the Apple Event Manager to send a copy of the event to the recording process but you do not want your application actually to receive the event. (For more information about when to use the <CODE>kAEDontExecute</CODE> flag, see the chapter "Recording Apple Events" in this book.)<P>
 <A HREF=#MARKER-9-107>Listing 5-4</A> illustrates how to send a Multiply event (an imaginary Apple event for multiplying two long integers). It first creates an Apple event, adds parameters containing the numbers to multiply, then sends it, specifying various options. It also illustrates how to handle the reply Apple event that contains the result.<P>
<DL>
<DT><B>Note</B>
<DD>If you want to send Apple events, your application must set flags in its <CODE>'SIZE'</CODE> resource indicating that it can handle high-level events, and it must provide handlers for the required Apple events. See <A HREF=IAC-117.html#MARKER-9-210>"Accepting an Apple Event" on page 4-5</A> for information on setting the appropriate flags in the <CODE>'SIZE'</CODE> resource and <A HREF=IAC-119.html#MARKER-9-262>"Handling the Required Apple Events" on page 4-11</A> for information on supporting the required Apple events.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<B>Listing 5-4  <A NAME=MARKER-9-107></A><A NAME=MARKER-21-108></A>Sending an Apple event<A NAME=MARKER-9-165></A></B><P>
<PRE>
FUNCTION MySendMultiplyEvent (serverAddress: AEAddressDesc;
                              firstOperand: LongInt; secondOperand: LongInt;
                              VAR replyResultLongInt: LongInt): OSErr;
CONST
   kArithmeticClass  =  'ARTH';  {event class for arithmetic }
                                 { Apple events}
   kMultiplyEventID  =  'MULT';  {event ID for Multiply event}
   keyMultOperand1   =  'OPN1';  {keyword for first parameter}
   keyMultOperand2   =  'OPN2';  {keyword for second parameter}
VAR
   theAppleEvent:    AppleEvent;
   reply:            AppleEvent;
   returnedType:     DescType;
   actualSize:       LongInt;
   myErr:            OSErr;
   ignoreErr:        OSErr; 
   errStr:           Str255;
   errNumber:        LongInt;
BEGIN
   myErr := AECreateAppleEvent(kArithmeticClass, kMultiplyEventID, 
                               serverAddress, kAutoGenerateReturnID,
                               kAnyTransactionID, theAppleEvent);
   IF myErr = noErr THEN 
      {add the first operand}
      myErr := AEPutParamPtr(theAppleEvent, keyMultOperand1, 
                             typeLongInteger, @firstOperand, 
                             SizeOf(firstOperand));
   {add the second operand with the proper keyword}
   IF myErr = noErr THEN
      myErr := AEPutParamPtr(theAppleEvent, keyMultOperand2, 
                             typeLongInteger, @secondOperand, 
                             SizeOf(secondOperand));

   IF myErr = noErr THEN
      myErr := AESend(theAppleEvent, reply, kAEWaitReply + kAENeverInteract,
                    kAENormalPriority, 120, @MyIdleFunction, NIL);
   IF myErr = noErr THEN {Apple event successfully sent}
   BEGIN    {Check whether it was successfully handled-- }
            { get result code returned by the server's handler}
      myErr := AEGetParamPtr(reply, keyErrorNumber, typeLongInteger, 
                             returnedType, @errNumber, SizeOf(errNumber), 
                             actualSize);

      IF (myErr = errAEDescNotFound) OR (errNumber = noErr) THEN
      {if keyErrorNumber doesn't exist or server returned noErr }
      { then the Apple event was successfully handled--the reply Apple }
      { event contains the result in the direct parameter}
         myErr := AEGetParamPtr(reply, keyDirectObject, typeLongInteger, 
                                returnedType, @replyResultLongInt,
                                SizeOf(replyResultLongInt), actualSize)
      ELSE
      BEGIN    {server returned an error, so get error string}
         myErr := AEGetParamPtr(reply, keyErrorString, typeChar, 
                                returnedType, @errStr[1], SizeOf(errStr)-1, 
                                actualSize);
         IF myErr = noErr THEN
         BEGIN
            IF actualSize &gt; 255 THEN
               actualSize := 255;
            errStr[0] := chr(actualSize);
            MyDisplayError(errStr);
         END;
      END;
   ignoreErr := AEDisposeDesc(reply);
   END
   ELSE
   BEGIN
      {the Apple event wasn't successfully dispatched, }
      { the request timed out, the user canceled, or other error} 
   END;
   ignoreErr := AEDisposeDesc(theAppleEvent);
   MySendMultiplyEvent := myErr;
END;
</PRE>
 The code in <A HREF=#MARKER-9-107>Listing 5-4</A> first creates an Apple event with <CODE>kArithmeticClass</CODE> as the event class and <CODE>kMultiplyEventID</CODE> as the event ID. It also specifies the server of the Apple event. See <A HREF=IAC-199.html#MARKER-9-51>"Specifying a Target Address" on page 5-10</A> for information on specifying a target address and <A HREF=IAC-196.html#MARKER-9-24>"Creating an Apple Event,"</A> which begins on <A HREF=IAC-196.html#MARKER-9-24>page 5-3</A>, for more information on creating an Apple event.<P>
 The Multiply event shown in <A HREF=#MARKER-9-107>Listing 5-4</A> contains two parameters, each specifying a number to multiply. See <A HREF=IAC-197.html#MARKER-9-31>"Adding Parameters to an Apple Event" on page 5-5</A> for examples of how to specify the parameters for the <CODE>AEPutParamPtr</CODE> function. <P>
 After adding the parameters to the event, the code uses <CODE>AESend</CODE> to send the event. The first parameter to <CODE>AESend</CODE> specifies the Apple event to send--in this example, the Multiply event. The next parameter specifies the reply Apple event. <P>
 This example specifies <CODE>kAEWaitReply</CODE> in the third parameter, indicating that the client is willing to yield the processor for the specified timeout value (120 ticks, or 2 seconds). The <CODE>kAENeverInteract</CODE> flag indicates that the server should not interact with the user when processing the Apple event. The fourth parameter specifies that the Multiply event is to be sent using normal priority (that is, placed at the end of the event queue). You can specify the <CODE>kAEHighPriority</CODE> flag to place the event in the front of the event queue, but this is not usually recommended.<P>
 The next to last parameter specifies the address of an idle function. If you specify <CODE>kAEWaitReply</CODE>, you must provide an idle function. This function should process any update events, null events, operating-system events, or activate events that occur while your application is waiting for a reply. See <A HREF=IAC-202.html#MARKER-9-123>"Writing an Idle Function,"</A> which begins on <A HREF=IAC-202.html#MARKER-9-123>page 5-22</A>, for sample code that shows an idle function. <P>
 The last parameter to <CODE>AESend</CODE> specifies a filter function. You can supply a filter function to filter high-level events that your application may receive while waiting for a reply Apple event. You can specify <CODE>NIL</CODE> for this parameter if you do not need to filter high-level events while waiting for a reply. See <A HREF=IAC-203.html#MARKER-9-130>"Writing a Reply Filter Function" on page 5-24</A> for more information. <P>
 If you specify <CODE>kAEWaitReply</CODE>, a <CODE>noErr</CODE> result code from <CODE>AESend</CODE> indicates that the Apple event was sent successfully, not that the server has completed the requested action successfully. Therefore, you should find out whether a result code was returned from the handler by checking the reply Apple event for the existence of either the <CODE>keyErrorNumber</CODE> or <CODE>keyErrorString</CODE> parameter. If the <CODE>keyErrorNumber</CODE> parameter does not exist or contains the <CODE>noErr</CODE> result code, you can use <CODE>AEGetParamPtr</CODE> to get the parameter you're interested in from the reply Apple event. <P>
 The <CODE>MySendMultiplyEvent</CODE> function in <A HREF=#MARKER-9-107>Listing 5-4</A> checks the function result of <CODE>AESend</CODE>. If it is <CODE>noErr</CODE>, <CODE>MySendMultiplyEvent</CODE> checks the <CODE>keyErrorNumber</CODE> parameter of the reply Apple event to determine whether the server successfully handled the Apple event. If this parameter exists and indicates that an error occurred, <CODE>MySendMultiplyEvent</CODE> gets the error string out of the <CODE>keyErrorString</CODE> parameter. Otherwise, the server performed the request, and the reply Apple event contains the answer to the multiplication request.<P>
 When you have finished using the Apple event specified in the <CODE>AESend</CODE> function and no longer need the reply Apple event, you must dispose of both the original event and the reply by calling the <CODE>AEDisposeDesc</CODE> function.<A NAME=MARKER-2-375></A><P>
<DL>
<DT><B>IMPORTANT</B>
<DD>If your application sends Apple events to itself using a <CODE>typeProcessSerialNumber</CODE> address descriptor record with the <CODE>lowLongOfPSN</CODE> field set to <CODE>kCurrentProcess</CODE>, the Apple Event Manager jumps directly to the appropriate Apple event handler without going through the normal event-processing sequence. For this reason, your application will not appear to run more slowly when it sends Apple events to itself. For more information, see <A HREF=IAC-199.html#MARKER-9-74>"Addressing an Apple Event for Direct Dispatching" on page 5-13</A>.<EM></EM><A NAME=MARKER-2-113></A>   <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<HR>
<B>Subtopics</B>
<B><!-- TOC --><DL>
<DL>
<DT><A HREF="IAC-201.html#HEADING201-0">Dealing With Timeouts</A>
<DD>
<DT><A HREF="IAC-202.html#HEADING202-0">Writing an Idle Function</A>
<DD>
<DT><A HREF="IAC-203.html#HEADING203-0">Writing a Reply Filter Function</A>
<DD>
</DL>
</DL>
</B>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="IAC-199.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="IAC-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="IAC-529.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="IAC-201.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="IAC-3.html">&copy; Apple Computer, Inc.</A><br>7 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
