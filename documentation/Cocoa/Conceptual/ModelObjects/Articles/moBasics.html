<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Model Object Implementation Guide: Checklist and Design Considerations</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Checklist and Design Considerations"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40002134" title="Checklist and Design Considerations"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../DesignGuidelines-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000556" target="_top">Design Guidelines</a> &gt; <a href="../index.html" target="_top">Model Object Implementation Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Introduction.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="moAccessorMethods.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>
        
        
        <a name="//apple_ref/doc/uid/TP40002134-SW1" title="Checklist and Design Considerations"></a><hr /><H1>Checklist and Design Considerations</H1><p>The fundamental role of model objects is to encapsulate data, and to provide access to that data. Model classes can add value in the form of custom behavior. The following checklist enumerates the additional features a model object might have to fully integrate into the Cocoa environment. It provides links to sections that discuss the design considerations you should bear in mind when you decide whether or not to use the feature, and links to sections that describe the implementation details.</p><ul class="ul"><li class="li"><p>Representation of instance variables</p><p>For design considerations, see <span class="content_text"><a href="moBasics.html#//apple_ref/doc/uid/TP40002134-SW8">“Instance Variable Types”</a></span> below.</p><p>For implementation details, see <span class="content_text"><a href="moAccessorMethods.html#//apple_ref/doc/uid/TP40002132-SW1">“Basic Accessor Methods.”</a></span></p></li><li class="li"><p>Accessor methods</p><p>For design considerations, see <span class="content_text"><a href="moBasics.html#//apple_ref/doc/uid/TP40002134-SW2">“Accessor Methods”</a></span> below.</p><p>For implementation details, see <span class="content_text"><a href="moAccessorMethods.html#//apple_ref/doc/uid/TP40002132-SW1">“Basic Accessor Methods,”</a></span> and for Core Data see <span class="content_text"><a href="../cdAccessorMethods.html#//apple_ref/doc/uid/TP40002154-SW1" target="_self">Managed Object Accessor Methods</a></span>.</p></li><li class="li"><p>Key-value coding and key-value observing compliance</p><p>For design considerations, see: <span class="content_text"><a href="moBasics.html#//apple_ref/doc/uid/TP40002134-SW2">“Accessor Methods”</a></span> and <span class="content_text"><a href="moBasics.html#//apple_ref/doc/uid/TP40002134-SW4">“Key-Value Coding and Key-Value Observing”</a></span> below.</p><p>For implementation details, see <span class="content_text"><a href="moAccessorMethods.html#//apple_ref/doc/uid/TP40002132-SW1">“Basic Accessor Methods,”</a></span> <span class="content_text"><a href="../cdAccessorMethods.html#//apple_ref/doc/uid/TP40002154-SW1" target="_self">Managed Object Accessor Methods</a></span>, and <span class="content_text"><a href="moIntegrating.html#//apple_ref/doc/uid/TP40002138-SW2">“Key-Value Technology Compliance.”</a></span></p></li><li class="li"><p>Copying</p><p>For design considerations, see <span class="content_text"><a href="moBasics.html#//apple_ref/doc/uid/TP40002134-SW5">“Copying”</a></span> below.</p><p>For implementation details, see <span class="content_text"><a href="moCopying.html#//apple_ref/doc/uid/TP40002137-SW2">“Copying.”</a></span></p></li><li class="li"><p>Archiving</p><p>For design considerations, see <span class="content_text"><a href="moBasics.html#//apple_ref/doc/uid/TP40002134-SW6">“Archiving”</a></span> below.</p><p>For implementation details, see <span class="content_text"><a href="moArchiving.html#//apple_ref/doc/uid/TP40002133-SW1">“Archiving.”</a></span></p></li><li class="li"><p>Key-value observing notifications for dependent values</p><p>For design considerations, see <span class="content_text"><a href="moBasics.html#//apple_ref/doc/uid/TP40002134-SW7">“Business Logic”</a></span> below.</p><p>For implementation details, see <span class="content_text"><a href="moIntegrating.html#//apple_ref/doc/uid/TP40002138-SW4">“Dependent Values.”</a></span></p></li><li class="li"><p>Initialization</p><p>For design considerations, see <span class="content_text"><a href="moBasics.html#//apple_ref/doc/uid/TP40002134-SW7">“Business Logic”</a></span> below.</p><p>For implementation details, see <span class="content_text"><a href="moInitialization.html#//apple_ref/doc/uid/TP40006844-SW1">“Initialization.”</a></span></p></li><li class="li"><p>Validation</p><p>For design considerations, see <span class="content_text"><a href="moBasics.html#//apple_ref/doc/uid/TP40002134-SW7">“Business Logic”</a></span> below.</p><p>For implementation details, see <span class="content_text"><a href="moValidation.html#//apple_ref/doc/uid/TP40002185-SW1">“Model Object Validation.”</a></span></p></li></ul><a name="//apple_ref/doc/uid/TP40002134-SW9" title="Design Considerations"></a><h2>Design Considerations</h2><p>As general design and implementation principles, you should ensure that you follow usual Cocoa standards such as naming conventions and so on as described in <span class="content_text"><a href="../../../../CoreFoundation/Conceptual/CFDesignConcepts/Concepts/NamingConventions.html#//apple_ref/doc/uid/20001110" target="_top">Naming Conventions</a></span> and "Defining a Class" in <em><a href="../../ObjectiveC/index.html#//apple_ref/doc/uid/TP30001163" target="_top">The Objective-C 2.0 Programming Language</a></em>. For example, class names should start with a capital letter; instance variable names should start with a lowercase letter; instance variables should not be public, and so on. In implementing a model object, you should adhere to the Model View Controller (MVC) design pattern as described in <span class="content_text"><!--a target="_top" -->The Model-View-Controller Design Pattern<!--/a--></span>) in <em><a href="../../AppArchitecture/index.html#//apple_ref/doc/uid/10000005i" target="_top">Application Architecture Overview</a></em>.</p><p>If you are creating a traditional Cocoa application, you typically subclass <code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/cl/NSObject" target="_top">NSObject</a></code>. If you are creating an application that uses Core Data, then for classes that represent persistent entities, you subclass <code><a href="../../../Reference/CoreDataFramework/Classes/NSManagedObject_Class/Reference/NSManagedObject.html#//apple_ref/occ/cl/NSManagedObject" target="_top">NSManagedObject</a></code>. Most of the principles described in this document apply to subclasses of both <code>NSObject</code> and <code>NSManagedObject</code>. Where there are differences, they are either called out inline, or a separate section is included that addresses Core Data–specific issues.</p><a name="//apple_ref/doc/uid/TP40002134-SW8" title="Instance Variable Types"></a><h2>Instance Variable Types</h2><p>You can represent attribute values with an object or with a scalar or a C structure (a <code>struct</code> such as <code>NSRect</code>). There are different considerations to bear in mind when using either type. If you use an object, you must ensure correct data encapsulation (see <span class="content_text"><a href="moBasics.html#//apple_ref/doc/uid/TP40002134-SW3">“Encapsulation”</a></span>). If you represent an attribute as a scalar value (such as <code>int</code> , <code>float</code> , or <code>double</code>) or as a <code>struct</code>, it may be easier for you to perform arithmetic calculations (you do not have to convert from an object representation to a scalar value) and there are no memory management issues.</p><p>The basic scalar types and a limited set of common structures (<code>NSRect</code>, <code>NSPoint</code>, <code>NSSize</code>, and <code>NSRange</code>) integrate transparently with key-value coding and key-value observing (see <span class="content_text"><a href="moIntegrating.html#//apple_ref/doc/uid/TP40002138-SW2">“Key-Value Technology Compliance”</a></span>)—that is, the key-value technologies automatically convert between the scalar or <code>struct</code> representation and a corresponding object representation, such as an instance of <code>NSNumber</code> or <code>NSValue</code>.</p><p>The main disadvantage of using non-object types is that non-object types cannot unambiguously represent a nil value. In addition, integration with other technologies (notably key-value coding and key-value observing) may require conversion of an attribute's value to an object representation anyway, which incurs some overhead. Depending on the pattern of usage of your application, it may be that any savings made by using non-object representations are outweighed by the overhead of conversion to and from object form (at least in terms of runtime efficiency—programmer effort is also a consideration). Finally, note that the granularity of representation for some types may be insufficiently fine. In a financial application it may be inappropriate to represent numeric data using, for example, a <code>float</code> due to the inherent inaccuracy of the <code>float</code> type. It may be more appropriate to use an <code>NSNumber</code> representation, as <code>NSNumber</code> provides both greater accuracy and a rich set of rounding behaviors.</p><p>If you are using Core Data, then there are additional constraints on the types you can use to represent a <em>persistent</em> attribute. Core Data natively supports only strings, numbers, dates, and binary data. You can, however, use transformable or transient values to work around this restriction, as described in <span class="content_text"><a href="../../CoreData/Articles/cdNSAttributes.html#//apple_ref/doc/uid/TP40001919" target="_top">Non-Standard Attributes</a></span>.</p><a name="//apple_ref/doc/uid/TP40002134-SW2" title="Accessor Methods"></a><h2>Accessor Methods</h2><p>The primary goal of accessor methods is to provide access to property values. There are two basic forms of accessor—get accessors and set accessors, used (predictably) to get and and set a property value respectively. You should implement accessors to preserve encapsulation. </p><p>You can also use accessor methods to simplify and streamline memory management, and to facilitate integration with other Cocoa technologies (in particular key-value coding and key-value observing, and through them, Cocoa bindings—see <span class="content_text"><a href="moBasics.html#//apple_ref/doc/uid/TP40002134-SW4">“Key-Value Coding and Key-Value Observing”</a></span>). The key-value coding protocol defines patterns for <strong>collection accessors</strong> for sets and arrays which further extend the concept of encapsulation and provide additional functionality. </p><p>The same principles that apply to "standard" model classes also apply to <code>NSManagedObject</code> subclasses used with Core Data, in order to provide additional functionality Core Data requires a different set of implementations for accessor methods. These are described in <span class="content_text"><a href="../cdAccessorMethods.html#//apple_ref/doc/uid/TP40002154-SW1" target="_self">Managed Object Accessor Methods</a></span>.</p><p>If you use the Objective-C declared properties feature (see “Properties” in <em><a href="../../ObjectiveC/index.html#//apple_ref/doc/uid/TP30001163" target="_top">The Objective-C 2.0 Programming Language</a></em>), most of these considerations are taken care of for you.</p><a name="//apple_ref/doc/uid/TP40002134-SW3" title="Encapsulation"></a><h3>Encapsulation</h3><p>If an attribute is represented by an object, that object may be accessible by other parts of your application. To ensure proper encapsulation of data, you should ensure that model objects maintain their own copies of attribute values, and that get accessors advertise the attribute value as being immutable. For example, an employee's <code>firstName</code> attribute may be declared as an <code>NSString</code>, but it is possible that at some point the value passed to the set accessor may be an instance of <code>NSMutableString</code>. If you simply set the model object's instance variable to that string, this would leave open the possibility that the contents of the string could be altered externally without the employee instance being aware of the change (thus violating the principle of encapsulation). In the set accessor, you should therefore copy the new attribute value (or if the property should be mutable, you make a mutable copy).</p><p>If there are mutable and immutable versions of a class you use to represent a property—such as <code>NSArray</code> and <code>NSMutableArray</code>—you should typically declare the return value of the get accessor as an immutable object even if internally the model uses a mutable object. Declaring the return value as an immutable object signals that the value should not be modified externally.</p><a name="//apple_ref/doc/uid/TP40002134-SW10" title="Memory Management"></a><h3>Memory Management</h3><p>You should implement your accessor methods such that they take care of memory management, as described in<span class="content_text"><a href="moAccessorMethods.html#//apple_ref/doc/uid/TP40002132-SW1">“Basic Accessor Methods.”</a></span> If your accessors provide a clean API for modifying property values, and if you use the accessors pervasively when modifying values, then you will avoid most memory management issues that arise in Cocoa. </p><a name="//apple_ref/doc/uid/TP40002134-SW11" title="Collection Accessors"></a><h3>Collection Accessors</h3><p>The key-value coding protocol defines patterns for collection accessors for sets and arrays. By implementing accessor methods that follow these patterns you derive a number of benefits.</p><ul class="spaceabove"><li class="li"><p>These accessor methods are key-value observing compliant (see <span class="content_text"><a href="moIntegrating.html#//apple_ref/doc/uid/TP40002138-SW2">“Key-Value Technology Compliance”</a></span> for more details). That is, if you invoke any of the mutator methods (such as <code>insertObject…</code>, <code>removeObject…</code>, or <code>replaceObject…</code>), then suitable key-value observing notifications are sent. This typically makes it easier to modify a collection directly than by using the proxy returned by <code>mutableArrayValueForKey:</code> or <code>mutableSetValueForKey:</code>.</p></li><li class="li"><p>If you do use <code>mutableArrayValueForKey:</code> or <code>mutableSetValueForKey:</code>, the collection accessors are invoked automatically when you make modifications to the collection proxy. If you do not implement these accessors, the collection proxy must replace the whole collection (using the simple set accessor) for each modification, which can incur unnecessary overhead.</p></li><li class="li"><p>You can use the collection accessors to hide underlying implementation details. There is no need for a collection to be implemented using the corresponding collection object—that is, for example, an array relationship need not actually be represented using an array. All that is required is that the accessor methods get and set values appropriately.</p></li></ul><a name="//apple_ref/doc/uid/TP40002134-SW4" title="Key-Value Coding and Key-Value Observing"></a><h2>Key-Value Coding and Key-Value Observing</h2><p>Key-value coding (KVC) and key-value observing (KVO) are fundamental technologies that are required for integration with Cocoa bindings and with Core Data's change management mechanism. </p><ul class="ul"><li class="li"><p>You can use key-value coding to access an object's property using the property name as a key. Key-value coding includes a consistent API for property value validation which is described in <span class="content_text"><a href="moValidation.html#//apple_ref/doc/uid/TP40002185-SW1">“Model Object Validation.”</a></span></p></li></ul><ul class="ul"><li class="li"><p>You can use key-value observing to detect changes to property values. You can also use it as a means of registering dependencies between keys to denote that a change in the value of one key will result in a change in the value of another dependent key. For example, a <code>fullName</code> key may depend on the values of <code>firstName</code> and <code>lastName</code>. This latter feature is described in <span class="content_text"><a href="moIntegrating.html#//apple_ref/doc/uid/TP40002138-SW2">“Key-Value Technology Compliance.”</a></span></p></li></ul><p>See <em><a href="../../KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i" target="_top">Key-Value Coding Programming Guide</a></em> and <em><a href="../../KeyValueObserving/index.html#//apple_ref/doc/uid/10000177i" target="_top">Key-Value Observing Programming Guide</a></em> for detailed information on these two technologies.</p><p>To complete the picture, you must also of course use the KVO-compliant methods. You can also use key-value coding methods such as <code>setValue:forKey:</code>, <code>mutableArrayValueForKey:</code>, and <code>mutableSetValueForKey:</code>.</p><a name="//apple_ref/doc/uid/TP40002134-SW5" title="Copying"></a><h2>Copying</h2><p>In some simple situations it is clear what "copy" means. In many cases, however, you must decide what it actually means to "copy" an object, and in particular what are the limits you want to impose on the copied object graph. You must also decide whether it is appropriate to copy all an object's attributes—for example, should an employee ID be copied? You must pay particular attention to relationships. If you "copy" an employee object, does this imply that a related department object is also copied? If you copy a department object, does that imply that related employees are also copied? If the answer to both of these questions is "yes," then copying a single employee implies copying (as a minimum) also the department to which they belong, and the other employees in that department… These issues are described in more detail in <span class="content_text"><!--a target="_top" -->Deciding How to Implement Object Copy<!--/a--></span>.</p><a name="//apple_ref/doc/uid/TP40002134-SW6" title="Archiving"></a><h2>Archiving</h2><p>You can use archiving as a mechanism for data serialization to save your model objects to a persistent store or to send to other processes. The role of archiving as a means to save your objects to a persistent store is largely superseded by Core Data, which manages object persistence for you. You may also, however, use archiving to support copy and paste operations and the transfer of data between applications. For more about archiving and serialization in general, see <em><a href="../../Archiving/index.html#//apple_ref/doc/uid/10000047i" target="_top">Archives and Serializations Programming Guide for Cocoa</a></em>.</p><p>When archiving model objects you must decide what properties to add to the archive. Typically you should archive all an object's non-derived attributes (that is, the attributes that cannot be calculated or derived from other attributes). If you are using archiving to serialize an object graph to save to a file, then you should also add related objects to the archive so that when the archive is unarchived, those relationships are restored.</p><a name="//apple_ref/doc/uid/TP40002134-SW12" title="Archiving and Copying"></a><h3>Archiving and Copying</h3><p>A common use of archiving is to support copy and paste operations (or to transfer data to other applications). If—especially in the context of Core Data—you use archiving for these purposes, you must decide what it actually means to copy, and what are the limits you want to impose on the copied object graph. A requirement for archiving in these situations is likely to be semantically different from archiving in the context of object graph serialization. When you create an archive for data serialization to a persistent store, you typically want to record all aspects of an object, including its relationships to other objects. When you use archiving to support copy and paste, you typically do not want to traverse relationships.</p><p>Rather than using archiving per se, therefore, it is often more appropriate to define a custom method that returns a representation of the object either in property list form or encapsulated in an <code>NSData</code> object, and then to initialize a copy object using that representation.</p><p>Note that in some situations, you may not actually want to copy an object. If you want to support drag and drop of objects at the destination of a relationship (for example, if you want to use drag and drop to transfer employees from one department to another) or if you support cross-store relationships, you should probably use managed object IDs or URI representations of managed object IDs. </p><a name="//apple_ref/doc/uid/TP40002134-SW13" title="Classic and Keyed Archiving"></a><h3>Classic and Keyed Archiving</h3><p>There are two forms of archiving, classic archiving and keyed archiving. Using classic archiving you must add instance variables directly to an archive and extract them in the same order. Using keyed archiving you encode and decode values as key-value pairs. This approach gives you more flexibility than with the classic technique. First, the order in which variables are encoded and decoded does not matter. Second, the archive is more robust against schema changes—the decoder does not fail if a value is not present in an archive, and it ignores any extra values in the archive. Finally, the output file may be human-readable, which may aid in any debugging process.</p><p>You can combine archiving techniques to ensure that your model objects can be archived using either classic or keyed archiving. Typically (since it offers a richer and more robust approach) you should choose keyed archiving over classic archiving.</p><a name="//apple_ref/doc/uid/TP40002134-SW14" title="Versioning"></a><h3>Versioning</h3><p>Version handling is typically easier with keyed archives, especially if you make only minor modifications to the schema (adding, removing, or renaming attributes). Old versions can still read keyed archives—keys present in the archive that are not present in the old schema are simply ignored. Problems may still arise, however, if the old version depends on the presence of a key that is absent in the new schema. For more details, see <span class="content_text"><a href="../../Archiving/Tasks/compatibility.html#//apple_ref/doc/uid/20001055" target="_top">Forward and Backward Compatibility for Keyed Archives</a></span> in <em><a href="../../Archiving/index.html#//apple_ref/doc/uid/10000047i" target="_top">Archives and Serializations Programming Guide for Cocoa</a></em>.</p><a name="//apple_ref/doc/uid/TP40002134-SW7" title="Business Logic"></a><h2>Business Logic</h2><p>Business logic is a broad term that encompasses actions performed on or using model objects. You are free to implement whatever methods you wish to support your application. You can provide methods to calculate values ranging from simple examples—such as the full name of an employee represented by a concatenation of first and last names—to complex—such as salary overhead for a department.</p><p>Cocoa provides a special API to formalize logic for validation, initialization, and dependent values. In an initialization method you can specify default values for an object's attributes. In validation methods, you can ensure that property values meet various constraints. To integrate with key-value observing, you may also need to notify observers if a change is made to a property on which a derived value depends.</p><p>There are many situations in which the value of one property depends on that of one or more other properties. If the value of one attribute changes, then the value of the derived property should also be flagged for change—for example, if the <code>lastName</code> property of an employee changes, the <code>fullName</code> also changes. </p><p>You use validation methods to ensure that data values meet various criteria that you specify. There are two types of validation—property-level and inter-property. You use property-level validation methods to ensure the correctness of individual values; you use inter-property validation methods to ensure the correctness of combinations of values where individual values may be valid but a combination may not be. For example, a person object may have attributes <code>age</code> and <code>hasDriversLicense</code>, with corresponding values <code>14</code> and <code>YES</code>. The individual values may be valid, the combination of values is invalid.</p>

        <br/><br/> 

        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Introduction.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="moAccessorMethods.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-02-08<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/ModelObjects/Articles/moBasics.html%3Fid%3DTP40001931-2.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/ModelObjects/Articles/moBasics.html%3Fid%3DTP40001931-2.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/ModelObjects/Articles/moBasics.html%3Fid%3DTP40001931-2.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>
