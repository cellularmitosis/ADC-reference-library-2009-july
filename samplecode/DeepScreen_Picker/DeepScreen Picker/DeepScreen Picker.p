{------------------------------------------------------------------------------##	Macintosh Developer Technical Support##	DeepScreen Picker Sample Application##	DeepScreen Picker   -   Make file name.#	DeepScreen Picker.p	-	MPW 3.2 Pascal Source#	DeepScreen Picker.r	-	MPW 3.2 Rez Source##	Purpose:##	This is a very simple sample program that demonstrates how to force the #	Color Picker dialog onto the deepest device available.  It does nothing#	more than save the current GDevice, find the deepest GDevice, make it#	current and activate (and center) the Color Picker dialog.  It's not a#	*real* app by a long shot.##	Dave Hersey, MacDTS, 3/21/91#------------------------------------------------------------------------------}Program DeepScreen;USES	QuickDraw, ToolIntf, Picker, Packages;CONST	cpDLOG	= -5760;	(* The resource number of the Color Picker Dialog. *)		{ Initialize everything for the program, make sure we can run. }Procedure Initialize;VAR	err			: OSErr;	theWorld	: SysEnvRec;	BEGIN{	Test the computer to be sure we can do color.  If not we would crash,	which would be bad.  If we can’t run, just beep and exit. }	err := SysEnvirons(1, theWorld);	IF NOT (theWorld.hasColorQD) THEN	BEGIN		SysBeep(3);		ExitToShell;	END;	{	Initialize all the needed managers. }	InitGraf(@thePort);	InitFonts;	InitWindows;	InitMenus;	TEInit;	InitDialogs(NIL);	InitCursor;END;	{ Initialize }{	Display the Color Picker dialog on the deepest device.  Note that this	procedure does not distinguish between color and grayscale devices, it	only returns the deepest device it finds.  If that makes a difference,	or if the color device should win if we have a tie for deepest GDevice,	you will need to alter the code.  In this case, you should call	GetDeviceList then look at each device in the list rather than call	GetMaxDevice.  You can check for color capability by looking at the	gdDevType bit of gdFlags with TestDeviceAttribute.  If this bit is set,	color is supported.  You can use that and the pixelSize of the GDevice's	gdPMap to make your own GDevice selection.}Procedure DeepPick;VAR	deepGDH					: GDHandle;	inColor, outColor		: RGBColor;	where					: Point;	cpWidth, cpHeight		: Integer;	scWidth, scHeight		: Integer;	deepRect				: Rect;	cPickDLOG				: DialogTHndl;	bounds					: Rect;	BEGIN{	Find the bounds of the deepest device.  Passing the maximum enclosing	rectangle to GetMaxDevice assures that we find the deepest device	available. }	SetRect(bounds, -32767, -32767, 32767, 32767);	deepGDH := GetMaxDevice(bounds);	deepRect := deepGDH^^.gdRect;{	If the device we found is the main GDevice, its top-left corner will be at	(0, 0).  Passing this value to GetColor will neatly place the Color Picker	dialog on the screen.  If the top-left corner is not (0, 0), the deepest	screen is not the main GDevice.  In this case, we'll have to calculate the	dialog's position ourselves. }	IF (deepGDH <> GetMainDevice) THEN	BEGIN{	Not the main GDevice.  Load the Color Picker dialog's resource so we can	get its dimensions.  Do the calculations necessary to center the dialog	horizontally and align it so that 1/3 of the remaining vertical whitespace	is above the dialog.  This will position the dialog the way the Color	Picker would have if this were the main GDevice and we set 'where' to	(0, 0).  When done, release the resource. }		cPickDLOG := DialogTHndl (GetResource('DLOG', cpDLOG));		IF (cPickDLOG <> nil) THEN		BEGIN			cpWidth := cPickDLOG^^.boundsRect.right - cPickDLOG^^.boundsRect.left;			cpHeight := cPickDLOG^^.boundsRect.bottom - cPickDLOG^^.boundsRect.top;			scWidth := deepRect.right - deepRect.left;			scHeight := deepRect.bottom - deepRect.top;			deepRect.left := deepRect.left + (scWidth - cpWidth) DIV 2;			deepRect.top := deepRect.top + (scHeight - cpHeight) DIV 3;			ReleaseResource(Handle(cPickDLOG));		END;	END;{	Set 'where' to the appropriate value to neatly place the dialog.  For our	initial color selection, I've picked fushia.  When all set, call GetColor. }	SetPt(where, deepRect.left, deepRect.top);		inColor.red := 65535;	inColor.green := 0;	inColor.blue := 65535;	IF GetColor(where, 'Pick a color, any color:', inColor, outColor) THEN	  (* whatever. *);END;	{ DeepPick }{	Main body of program DeepScreen.  Initialize, then display the Color Picker dialog	on the deepest device. }BEGIN 	Initialize;	DeepPick;END.	{ DeepScreen Picker }