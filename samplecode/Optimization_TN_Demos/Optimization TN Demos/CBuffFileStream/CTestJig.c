/*	File:		CTestJig.c	Contains:	Test Jig.	Written by:	Steve Bollinger	Copyright:	Copyright (c) 1999 Apple Computer, Inc., All Rights Reserved.				You may incorporate this Apple sample source code into your program(s) without				restriction. This Apple sample source code has been provided "AS IS" and the				responsibility for its operation is yours. You are not permitted to redistribute				this Apple sample source code as "Apple sample source code" after having made				changes. If you're going to re-distribute the source, we require that you make				it clear in the source that the code was descended from Apple sample source				code, but that you've made changes.*/#include <Types.h>#include <Files.h>#include <Errors.h>#include <Script.h>#include <LowMem.h>#include <stdio.h>#include "CBuffFileStream.h"#include "CTestJig.h"// Changing BUFFERED from 1 to 0 will use the file system directly// to test speedups.#define BUFFERED 1// Setting CHECKCONTENTS to 1 will do some rudimentary verification// of the data actually read.#define CHECKCONTENTS	0unsigned long DoWriteTest(void){	unsigned long			startTicks;	unsigned long			endTicks;	unsigned long			*writeamts;	unsigned long			numwriteamts;	FILE					*rdfile;	unsigned long			iter;	OSErr					ckErr;#if BUFFERED	CBuffFileStreamData		*newdata;#else	short					filenum;#endif	FSSpec					fileLoc;	unsigned long			largestrandvalue = 100000;	unsigned long			*wrSpace;	rdfile = fopen("sizelist","r");	fscanf(rdfile,"%lu\n",&numwriteamts);	writeamts = (unsigned long *) NewPtr(sizeof(unsigned long) * numwriteamts);	for (iter = 0; iter < numwriteamts; iter++)	{		fscanf(rdfile,"%lu\n",&(writeamts[iter]));	}	fclose(rdfile);// now we have the data we need// make a buffer to write from	wrSpace = (unsigned long *) NewPtrClear(largestrandvalue);	if (0 == wrSpace)		return 0;// create a spec to the file to open	ckErr = FSMakeFSSpec(0,0,"\ptestfile",&fileLoc);	if (fnfErr == ckErr)		(void) FSpCreate(&fileLoc,0,0,smSystemScript);	startTicks = LMGetTicks();	#if BUFFERED	ckErr = BFSOpenFile(&newdata,&fileLoc,fsRdWrPerm);	if (noErr != ckErr)		return 0;	for (iter = 0; iter < numwriteamts; iter++)	{		long			wrAmt = (long) writeamts[iter];		*wrSpace = (unsigned long) wrAmt;		ckErr = BFSWrite(newdata,&wrAmt,wrSpace);		if (noErr != ckErr)			return 0;	}	ckErr = BFSCloseFile(newdata);	if (noErr != ckErr)		return 0;#else	ckErr = FSpOpenDF(&fileLoc,fsRdWrPerm,&filenum);	if (noErr != ckErr)		return 0;	for (iter = 0; iter < numwriteamts; iter++)	{		long			wrAmt = (long) writeamts[iter];		*wrSpace = (unsigned long) wrAmt;		ckErr = FSWrite(filenum,&wrAmt,wrSpace);		if (noErr != ckErr)			return 0;	}	ckErr = FSClose(filenum);	if (noErr != ckErr)		return 0;#endif	endTicks = LMGetTicks();	DisposePtr((Ptr) wrSpace);	DisposePtr((Ptr) writeamts);	return endTicks - startTicks;}unsigned long DoReadTest(void){	unsigned long			startTicks;	unsigned long			endTicks;	unsigned long			*readamts;	unsigned long			numreadamts;	FILE					*rdfile;	unsigned long			iter;	OSErr					ckErr;#if BUFFERED	CBuffFileStreamData		*newdata;#else	short					filenum;#endif	FSSpec					fileLoc;	unsigned long			largestrandvalue = 100000;	unsigned long			*rdSpace;	rdfile = fopen("sizelist","r");	fscanf(rdfile,"%lu\n",&numreadamts);	readamts = (unsigned long *) NewPtr(sizeof(unsigned long) * numreadamts);	for (iter = 0; iter < numreadamts; iter++)	{		fscanf(rdfile,"%lu\n",&(readamts[iter]));	}	fclose(rdfile);// now we have the data we need// make a buffer to read to	rdSpace = (unsigned long *) NewPtrClear(largestrandvalue);	if (0 == rdSpace)		return 0;// create a spec to the file to open	ckErr = FSMakeFSSpec(0,0,"\ptestfile",&fileLoc);	if (noErr != ckErr)		return 0;	startTicks = LMGetTicks();	#if BUFFERED	ckErr = BFSOpenFile(&newdata,&fileLoc,fsRdPerm);	if (noErr != ckErr)		return 0;	for (iter = 0; iter < numreadamts; iter++)	{		long			rdAmt = (long) readamts[iter];//		*rdSpace = (unsigned long) rdAmt;		ckErr = BFSRead(newdata,&rdAmt,rdSpace);		if (noErr != ckErr)			return 0;#if CHECKCONTENTS		if (readamts[iter] != *rdSpace)		{			DebugStr("\pread back not correct");		}#endif	}	ckErr = BFSCloseFile(newdata);	if (noErr != ckErr)		return 0;#else	ckErr = FSpOpenDF(&fileLoc,fsRdPerm,&filenum);	if (noErr != ckErr)		return 0;	for (iter = 0; iter < numreadamts; iter++)	{		long			rdAmt = (long) readamts[iter];//		*rdSpace = (unsigned long) rdAmt;		ckErr = FSRead(filenum,&rdAmt,rdSpace);		if (noErr != ckErr)			return 0;#if CHECKCONTENTS		if (readamts[iter] != *rdSpace)		{			DebugStr("\pread back not correct");		}#endif	}	ckErr = FSClose(filenum);	if (noErr != ckErr)		return 0;#endif	endTicks = LMGetTicks();	DisposePtr((Ptr) rdSpace);	DisposePtr((Ptr) readamts);	return endTicks - startTicks;}