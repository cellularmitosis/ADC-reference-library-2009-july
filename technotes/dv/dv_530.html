<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 01-August-01 --><!-- Includes revisions to graphics tags --><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note DV530: Graphics Devices Manager Q&amp;As</title><meta name="keywords" content="Mac OS 8 Graphics Devices Manager UpdateGWorld dithering NewGWorld -151"><meta name="Description" content="Technical Note DV530: This Technical Note contains a collectionof archived Q&amp;As relating to the Graphics Devices Manager--questionssent the Developer Support Center (DSC) along with answersfrom the DSC engineers. Archived Q&amp;As include: How to changethe monitor depth from an application, NewGWorld error code-151, GWorld direct access and graphics cards with cachedGWorlds, Drawing the gray dimmed outline across screens withdifferent depths, Drawing into a GWorld after using UpdateGWorld,UpdateGWorld dithering bug workaround, how the Device Managerhandles queuing and asynchronous calls, and LCSInstall andSlot IRQ Interrupt handling.">                                       <meta name="categories" content="Devices"><meta name="week-posted" content="Oct 1, 1990 - Oct 5, 1990"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002421" title="Graphics Devices Manager Q&As"></a><A NAME="top"></A><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/Games/idxGraphicsImaging-date.html" target="_blank">Games > Graphics & Imaging</a></li>
		<li><a href="../../referencelibrary/GraphicsImaging/idxHardwareDrivers-date.html" target="_blank">Graphics & Imaging > Hardware & Drivers</a></li>
		<li><a href="../../referencelibrary/HardwareDrivers/idxAccessibility-date.html" target="_blank">Hardware & Drivers > Accessibility</a></li>
		<li><a href="../../referencelibrary/HardwareDrivers/idxHumanInterfaceDeviceForceFeedback-date.html" target="_blank">Hardware & Drivers > Human Interface Device & Force Feedback</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note DV530</div>
<div id="pageheadsub">Graphics Devices Manager Q&amp;As</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc --><p id="menutext"> <A HREF="#Section1">Changing monitor depth from an application</A><br><br>  <A HREF="#Section2">NewGWorld error code -151</A><br><br>    <A HREF="#Section3">GWorld direct access and graphics cards with cached GWorlds</A><br><br>      <A HREF="#Section4">Drawing dimmed outline across screens with different depths</A><br><br>        <A HREF="#Section5">Drawing into GWorld after using UpdateGWorld</A><br><br>  <A HREF="#Section6">UpdateGWorld dithering bug workaround</A><br><br>    <A HREF="#Section7">Determining if a file is read from CD-ROM or hard disk</A><br><br>      <A HREF="#Section8">Accessing a Macintosh driver resource fork at accRun time</A><br><br> <A HREF="#Section9">DAs in background under System 7.0 lack UnitTable entries</A><br><br>  <A HREF="#Section10">Macintosh LC SIntInstall &amp; SLOTIRQ Interrupt Handling</A><br><br>  <A HREF="#Section11">JMP or JSR When Calling IODone</A><br><br>  <A HREF="#Section12">New info on Macintosh Device Manager calls</A><br><br>   <A HREF="#Section13">Macintosh Device Manager handles queuing and <br>asynchronous calls</A><br><br><A HREF="#Section14">Given a Macintosh gdRefNum, how can I find the <br>associated slot?</A><br><br><A HREF="#Section15">Macintosh journaling mechanism</A><br><br><A HREF="#Section16">How do I support locked and ejectable SCSI devices?</A><br><br> <A HREF="#downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><p id = "introtext">This Technical Note contains a collection of archived Q&amp;As relating to a specifictopic--questions sent the Developer Support Center (DSC) along with answers from the DSC engineers. Current Q&amp;As can be found on the <a href="../../qa/index.html">Macintosh Technical Q&amp;As web site</a>.</p><!-- end_intro_text --><!-- begin_date --><h3 align=center>[Oct 01 1990]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR>          <!-- begin_content --><A NAME=Section1></A><h2>Changing monitor depth from an application</h2><p>Date Written:  3/10/93</p><p>Last reviewed: 6/24/93</p><p>If an application performs best at a specific screen depth, which of thefollowing options do you recommend at launch time, both in terms of humaninterface and with respect to all GDevices?</p><p>1.    Put up a dialog if the monitors aren't in a good depth and let the user deal with it.</p><p>2.    Put up a dialog, and ask the user whether the application should change thedepth automatically.</p><p>3.    Do nothing, and let the user deal with it.</p><p>Option 2 seems nicest for the user, but how do I change the depth on the fly,and what about multiple monitors and various maximum screen depths?</p><p>___</p><p>We recommend the second option because it's definitely the most user friendly.Even though it's expected that applications run independently of monitordepths, your users will be disappointed if the monitor can't be set to thedepth they want. If an application can't run in any other monitor depth, itshould allow the user to change the depth in a alert rather than force the userto quit, change the monitor depth, and then relaunch. In your case, you canallow the user the choice of changing the depth, running under the currentdepth with performance penalty, or to exit.</p><p>To change multiple monitor depths, you simply have to cycle through thedifferent gDevices. SetDepth is documented in Inside Macintosh Volume VI, page 21-23.</p><a name="Section2"></a><h2>NewGWorld error code -151</h2><p>Date Written: 1/8/93</p><p>Last reviewed: 7/2/93</p><p>I received an error code of -151 from NewGWorld when creating a very largeoff-screen bitmap. Does this mean not enough memory? If so, can I count on itnot to change in future versions of the system? It's not listed as one of thepossible errors in <i>Inside Macintosh</i> Volume VI.</p><p>___</p><p>The error -151 is cTempMemErr, "failed to allocate memory for temporarystructures," or in other words, there wasn't enough temporary memory availablefor NewGWorld. NewGWorld returns this error after it receives a memFullErr fromTempNewHandle. (See <i>Inside Macintosh: Memory</i> or the Memory Managementchapter of <i>Inside Macintosh</i> Volume VI for more information abouttemporary memory.) This was inadvertently left out of <i>Inside Macintosh</i>Volume V rI, but does appear in the MPW interface files. You can count on this error codein future versions of system software.</p><a name="Section3"></a><h2>GWorld direct access and graphics cards with cached GWorlds</h2><p>Date Written:  12/1/92</p><p>Last reviewed:  3/1/93</p><p>Our application draws directly to off-screen GWorlds using our own line-drawingroutines and then using CopyBits to get the result to the screen. Since werequire direct access to our off-screen GWorld's buffer, is it safe for us tocontinue to not use the keepLocal flag in our NewGWorld calls? I'm worried thatsome graphics cards, due to their implementation, assume that the only way thatan application will draw to a cached GWorld is by making QuickDraw calls.</p><p>___</p><p>There's no problem with not using the keepLocal flag. However, keep in mindthat you should call GetPixBaseAddr to get the base address of the off-screenGWorld. This ensures that you get the correct base address even if the GWorldis cached. In addition, since the accelerator may be drawing asynchronously,you should make sure there are no operations currently pending. Otherwise, youmay get garbage if your drawing conflicts with the asynchronous drawing. Youcan call QDDone to determine whether pending QuickDraw operations arecompleted. Both routines are documented in <i>Inside Macintosh</i> Volume VI.</p><a name="Section4"></a><h2>Drawing dimmed outline across screens with different depths</h2><p>Date Written:  12/9/91</p><p>Last reviewed:  1/27/92</p><p>When the OK button is disabled in the System 7 Standard File dialog box, it'sdrawn in gray. I was looking for sample code on how to do this in a way that'sappropriate for multiple screens at various color depths. For example, howshould you draw the outline if you have an OK button in a movable modal dialogbox with half the OK button on an 8-bit color screen and the other half on a1-bit monochrome screen?</p><p>___</p><p>There are two ways to draw the gray (dimmed) outline across several screens indifferent depths: one uses MakeRGBPat <i>(Inside Macintosh</i> Volume V, page73), the other uses DeviceLoop <i>(Inside Macintosh</i> Volume VI, page 21-23).Look for GrayishOutline.p in the Snippets folder on the <i>Developer CDSeries</i> disc for a code sample that demonstrates both ways.</p><a name="Section5"></a><h2>Drawing into GWorld after using UpdateGWorld</h2><p>Date Written:  11/21/91</p><p>Last reviewed:  12/11/91</p><p>When I resize my real-time animation window in System 6, I call UpdateGWorldwith the new size, and after that any drawing into the GWorld has no effect.This same code works perfectly in System 7. What could cause this?</p><p>___</p><p>You probably can't draw anything into your GWorld after using UpdateGWorld toresize it because of the clipping region of your GWorld. In system softwareversions before 7.0, UpdateGWorld always resizes the GWorld's clipping regionproportional to the amount that the GWorld itself is resized. Unfortunately,NewGWorld initializes the clipping region of the GWorld to the entire QuickDrawcoordinate plane, [T:-32767 L:-32767 B:32767 R:32767]. If UpdateGWorld resizesany of these coordinates so that they fall outside this range, the coordinateswrap around to the other end of the signed integer space, and that makes theclipping region empty. Empty clipping regions stop any drawing fromhappening.</p><p>The change in System 7 is that UpdateGWorld explicitly checks for the clippingregion [T:-32767 L:-32767 B:32767 R:32767]. If it finds this, it doesn't resizethe clipping region. Otherwise, UpdateGWorld acts the same way that it didbefore System 7.</p><p>One of our mottos is, "Never give QuickDraw a chance to do the wrong thing." Inkeeping with that, we always explicitly set the clipping region of a GWorldwhenever we change the size of the GWorld. So after calling NewGWorld, set itsclipping region to be coincident with its portRect. After calling UpdateGWorldto resize the GWorld, set its clipping region to be coincident with its newportRect. That way, you'll always have a known environment and you won't haveto worry about the change that was made in System 7--and you'll be lesssusceptible to bugs in this area in the future.</p><a name="Section6"></a><h2>UpdateGWorld dithering bug workaround</h2><p>Date Written:  11/14/91</p><p>Last reviewed:  12/12/91</p><p>UpdateGWorld doesn't seem to respond to the ditherPix flag unless color depthchanges. The return flag after changing my color table is 0x10000, indicatingthat color mapping happened but not dithering. Is this a bug?</p><p>___</p><p>Yes, this is a bug. UpdateGWorld ignores dithering if no depth change is made.It probably won't be changed in the near future. The workaround is asfollows:</p><p>1. Create a new pixMap with the new color table.</p><p>2. Call CopyBits to transfer your image to the newly created pixMap withdithering from the original GWorld's pixMap.</p><p>3. Update the GWorld with the new color table without using ditherPix.</p><p>4. Use CopyBits from the newly created pixMap without dithering back to theGWorld.</p><p>This will give you the same effect as UpdateGWorld with ditherPix.</p><a name="Section7"></a><h2>Determining if a file is read from CD-ROM or hard disk</h2><p>Date Written:  8/23/91</p><p>Last reviewed:  9/24/91</p><p>How can we tell whether a particular Macintosh file is being read from a CD-ROMor a hard disk?</p><p>___</p><p>You can call the Device Manager routine OpenDriver using the ".AppleCD" stringto find a driver reference number of the AppleCD SC drive. If there is morethan one AppleCD SC drive hooked up, then additional ".AppleCD" driverreference numbers can be obtained by using the PBControl call with a csCode =97 (WhoIsThere). This command returns a mask of which SCSI devices are beingserviced by the ".AppleCD" driver (that is, which other drives are AppleCD SCs).</p><p>The following code returns the driver reference number for an ".AppleCD" driverinstance. The input parameter CDDrive specifies which logical AppleCD SC drivein the SCSI chain to open.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>#define csWhoIsThere    97typedef unsigned short    Word;typedef    unsigned long    Long;typedef struct WhoIsThereRec {    ParamBlockHeader    short        ioRefNum;    short        csCode;    struct {        Byte    fill;        Byte    SCSIMask;    } csParam;} WhoIsThereRec;pascal    OSErr OpenCD(Byte CDDrive, short *ioRefNum) {    auto    OSErr            osErr;    auto    short            ioRefNumTemp,                            CDDriveCount,                            SCSIID;    auto    WhoIsThereRec    *pb;    pb = (WhoIsThereRec *) NewPtrClear(sizeof (*pb));    osErr = MemError();    if (0 != pb &amp;&amp; noErr == osErr) {        osErr = OpenDriver("\p.AppleCD", &amp;ioRefNumTemp);        if (noErr == osErr) {            (*pb).ioRefNum        = ioRefNumTemp;            (*pb).csCode        = csWhoIsThere;            osErr = PBStatus((ParmBlkPtr)pb, false);            if (noErr == osErr) {                CDDriveCount = 0;                for (SCSIID = 0; SCSIID &lt; 7; ++SCSIID) {                    if (BitTst(&amp;(*pb).csParam.SCSIMask, 7 - SCSIID)) {                        ++CDDriveCount;                        if (CDDrive == CDDriveCount) {                            *ioRefNum = -(32 + SCSIID) - 1;                            DisposPtr((Ptr) pb);                            return noErr;                        }                    }                }                osErr = paramErr;            }        }        DisposPtr((Ptr) pb);    }    return osErr;}</pre>	</TD></TR></TABLE></CENTER><p>You can modify OpenCD to do exactly what it is you need it to do. Or, you mightuse it to iterate over the logical CD drive numbers from 0 to 6 until OpenCDreturns something other than noErr. If you modify the OpenCD routine, you'llneed the "AppleCD SC Developers Guide, Revised Edition" to be successful. Note also that all unused fields of a parameter block used with the ".AppleCD" driver must be set to zero before calling PBControl.</p><p>Iterating over the seven possibilities will result in a table of known".AppleCD" drive entries--perhaps something like the following structure:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    struct {     int count;     short cdDRefNum[7];    } knownCDDRefNum;</pre>	</TD></TR></TABLE></CENTER>    <p>With this table in hand, you can match the driver reference number for thevolume of any file. In most cases you know which volume the file was on whenyou opened it. Also, the routines PBGetFCBInfo and PBGetCatInfo both return thevolume reference number for a file.</p><p>Once you determine the volume reference numbers, either traverse the VCB tableor call PBGetVInfo to get the driver reference number. This driver referencenumber is the driver handling all requests made by the File System for yourfile!</p><p>If that driver reference number for the file is in our "knownCDDRefNum" table,then that file resides on an AppleCD SC drive. This technique works only forApple or Apple-compatible drivers. An alternate approach to the problem isstepping through the driver table and locating all entries with the name".AppleCD," noting their driver reference numbers, and then following theprocedure outlined above to determine if a file is on a volume owned by thatdriver.</p><p>The csCode method is far clearer than this one, and should be used wheneverpossible. The bottom line is that there is no guaranteed method of locating aCD-ROM drive due to the lack of a standardized driver model.</p><p>X-Ref:</p><p>Device Manager chapters of <i>Inside Macintosh</i> Volumes II, IV, and V</p><p>"Finding a Slot for a Driver" note on latest <i>Developer CD Series</i> disc</p><a name="Section8"></a><h2>Accessing a Macintosh driver resource fork at accRun time</h2><p>Date Written:  6/20/91</p><p>Last reviewed:  8/13/91</p><p>How do I get Macintosh resources from a driver Init file at accRun time? Ican't think of a way other that getting the full path name, which is discouraged.</p><p>___</p><p>Basically, you need to call PBGetFCBInfo at INIT time to grab the filename,directory ID and volume reference number for the INIT's resource fork. You canthen store these in your INIT and pull them out at accRun time. At accRun, justcall HOpenResFile to get to your resources. This method is _much_ better thanusing a full pathname, since this still works in the case where the userre-names the folder containing your INIT.</p><p>Here's some sample code that does what you need:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>OSErr GetCurResLocn(short *saveVRefNum,long *saveDirID,StringPtr saveFName){    FCBPBRec pb;    OSErr err;    short theFile;    Str255 fName;    theFile = CurResFile();    pb.ioFCBIndx = 0;    pb.ioVRefNum = 0;    pb.ioRefNum = theFile;    pb.ioNamePtr = saveFName;    err = PBGetFCBInfo (&amp;pb,false);    *saveVRefNum = pb.ioFCBVRefNum;    *saveDirID = pb.ioFCBParID;    return err;}OSErr SetCurResLocn(short saveVRefNum,long saveDirID,StringPtr saveFName,                    short *newResFile){    short resRef;    OSErr err;    HOpenResFile(saveVRefNum,saveDirID,saveFName,fsRdWrPerm);    err = ResError();    if (err!=noErr)        return err;    UseResFile(resRef); /* &lt;-- needed in case the res. file was prev. open */    *newResFile = resRef;    return ResError();}void main(){    OSErr err;    short saveVRefNum;    long saveDirID;    Str255 saveFName;    short newResFile;    err = GetCurResLocn(&amp;saveVRefNum,&amp;saveDirID,saveFName);    if (err!=noErr)        return;    /* ... pass control off to computer here (we're an app, so we fake it) ... */    err = SetCurResLocn(saveVRefNum,saveDirID,saveFName,&amp;newResFile);    if (err!=noErr)        DebugStr("\pfailed");}</pre>	</TD></TR></TABLE></CENTER><p>As you can see, this is an application, so you'll have to do some minormodifications (possibly convert to 680x0). It's pretty straightforward, and theHOpenResFile call is included in MPW glue for MPW 3.0 and is a built-in callfor System 7.</p><a name="Section9"></a><h2>DAs in background under System 7.0 lack UnitTable entries</h2><p>Date Written:  3/14/91</p><p>Last reviewed:  6/17/91</p><p>Under System 6 my driver, which runs all the time, can send a control call tomy open DA (because it too is a driver). Under System 7.0 I get badUnitErrerrors (-21) because evidently my DA resides in a different process that isinaccessible to my system-resident driver. How can I get around this?</p><p>___</p><p>DAs in System 7.0 do not actually have UnitEntries unless they are currentlyrunning, so your driver cannot call your DA unless the DA is frontmost. Whatyou might consider instead is having the DA periodically issue a call to thedriver, asking if there is anything for it at the moment. If you have an entitythat hands data to your resident driver, and the DA then requests the data fromthe resident driver from time to time, you should have a very robust mechanism,albeit a slightly slower one with greater latency.</p><a name="Section10"></a><h2>Macintosh LC SIntInstall &amp; SLOTIRQ Interrupt Handling</h2><p>Date Written:  1/4/91</p><p>Last reviewed:  1/4/91</p><p>How can we get our Macintosh driver to talk with hardware using the SLOTIRQprovided on the bus?</p><p>___</p><p>To get SLOTIRQ to work correctly you need to use SIntInstall to add a slotinterrupt queue element for slot $E. The interrupt service routine pointed toby the slot interrupt queue element must clear the interrupt line beforereturning. The slot interrupt enable bit in the V8 chip referred to by theMacintosh LC developer note (page 26 in the /SLOTIRQ signal description) isenabled during the boot process, so you don't need to worry about it.</p><p>SIntInstall is described in <i>Inside Macintosh</i> Volume V on pages V-426through V-428 and in Designing Cards and Drivers for the Macintosh Family onpages 161 through 163. Designing Cards and Drivers for the Macintosh Familyalso includes an example of a driver on pages 178 through 202.</p><a name="Section11"></a><h2>JMP or JSR When Calling IODone</h2><p>Date Written:  12/12/90</p><p>Last reviewed:  1/16/91</p><p>After an I/O call to a Macintosh slot device driver, shouldn't the IODoneroutine be called by a JSR instead of a JMP instruction in order for a slotdevice to return to it with D0 set to an appropriate value depending on whetherthe interrupt was serviced?</p><p>___</p><p>You only call IODone when the queued up I/O request has been fully completed.If the interrupt handler is completing an asynchronous call, then you need tocall IODone. IODone returns via an RTS, and preserves D0. Therefore, what youshould do is have your interrupt service routine set D0 and then jump to IODone(via JIODone*). IODone will do its thing return via an RTS instruction. Thesequence would be something like:</p><p>0. A program is running</p><p>1. The interrupt occurs</p><p>2. The Device Manager does a JSR to your Interrupt Service Routine (ISR)</p><p>3. The I/O request is complete, so your ISR sets D0 and jumps through JIODone</p><p>4. IODone does an RTS, which will be back to the Device Manager</p><p>5. The Device Manager does an RTE back to the program</p><p>6. The program continues</p><p>*The J (in JIODone) stands for Jump, so the ISR pushes JIODone onto the stack,which puts the address of what's in JIODone ($8FC) on the stack. This isfollowed by an RTS instruction which executes it. So JIODone can be thought ofas a vector to IODone.</p><p>If you are just handling a hardware interrupt or the I/O is not yet complete,don't call IODone. Do an RTS like the example in Designing Cards and Driversfor the Macintosh Family (Chapter 9 source example, starting with the BeginIH label).</p><a name="Section12"></a><h2>New info on Macintosh Device Manager calls</h2><p>Date Written:  12/5/90</p><p>Last reviewed:  1/16/91</p><p>Are Macintosh Device Manager status calls with csCode=1 calls filtered out?Also, are all high-level Device Manager routines always executed synchronously?If all the calls are synchronous, why is there a high level KillIO routine (toterminate current and pending processes)?</p><p>___</p><p>Yes, a Status call made with a csCode of 1 never calls your driver. Instead, itreturns (in the csParam field) the handle to your driver's Device Control Entryfrom the Unit Table.</p><p>High-level Device Manager calls are executed synchronously. Only the low-levelcalls can be specified to execute asynchronously. The high-level KillIO routineis useful for terminating I/O pending from a low-level call, which may havebeen initiated by someone else.</p><p>X-Refs: <i>Inside Macintosh</i> Volume II, Chapter 6</p><a name="Section13"></a><h2>Macintosh Device Manager handles queuing and asynchronous calls</h2><p>Date Written:  5/3/89</p><p>Last reviewed:  12/17/90</p><p>How can the Macintosh Device Manager help my driver handle things likeasynchronous calls, queueing, and so on?</p><p>___</p><p>The Device Manager will handle all the queueing and asynchronous niceties foryou with the jFetch, jStash, and jIODone calls. jIODone handles queueing andcalling completion routines for asynchronous calls. jFetch, and jStash are forthe interrupt handlers, and provide the mechanism for knowing how far along youare in a particular request.</p><p>When you call jIODone, the entry that was being handled will be removed fromthe queue, its completion routine is called, and then if there is another entryin the queue, your driver will be called to handle it.</p><p>If you return via an RTS rather than jIODone (you haven't yet completed theoperation requested--that is, waiting for more bytes), the queue entry willremain in the queue, and others behind it will not execute until the nextjIODone is called. Queued entries are always executed in sequence. If yourdriver is not asynchronous, you still need to call jIODOne to clear the queuefor the next entry (unless the IMMED bit is set in the ioTrap field).</p><p>jFetch and jStash are two calls provided to assist an interrupt drivenasynchronous driver. From within your interrupt routine, you can call jFetch toget the next byte from the caller's buffer, or jStash to place the next byte inthe caller's buffer. In addition to dealing with the caller's buffer, these twocalls also handle the ioActCount and let you know when you have completed thecurrent request (see <i>Inside Macintosh</i> Volume II, pages 194-195).</p><p>A good example of this is the serial drivers. In the case of the output driver,if the calling application makes a pbWrite call to the serial output driver,and specifies a buffer of 200 characters, the Device Manager places the requestin the queue for the Serial Driver and calls the prime routine. The primeroutine gets the first character from the buffer by using the jFetch call, andplaces it in the transmit buffer of the SCC chip and simply does an RTS. TheSCC chip has the ability to generate an interrupt when the transmit buffer isempty, so when that happens, the interrupt handler gets the next character fromjFetch, and sticks it in the transmit buffer. When jFetch finally gets the lastcharacter, the interrupt routine places it in the transmit buffer, and callsjIODone, which then removes that request from the queue, calls the completionroutine, if any, and executes the next queued request, if any.</p><p>If your driver is supporting non-interrupt driven hardware, you can justreceive the prime call, and use jFetch (for example) to get the requested bytesfrom the buffer, send them to your hardware, and repeat until jFetch returnsbuffer empty, then return via jIODone. This is an example of synchronousoperation that still uses the queueing mechanism, except that no new requestswill ever have a chance to get queued until the previous request is completed.</p><p>X-Ref:</p><p>"Device Manager," <i>Inside Macintosh</i> Volumes II and IV</p><a name="Section14"></a><h2>Given a Macintosh gdRefNum, how can I find the associated slot?</h2><p>Date Written:  3/9/90</p><p>Last reviewed:  12/17/90</p><p>Given a Macintosh gdRefNum, how can I find the associated slot?</p><p>___</p><p>Get the slot number from the auxiliary DCE. The following code snippet indexesthrough the GDevices (it's assumed the check showed the presence of ColorQuickDraw), and pulls the slot number from each GDevice record:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>  gGDHandle := GetDeviceList; {get the first GDevice list handle}  repeat    if gGDHandle &lt;&gt; nil then      begin        gAuxDCEHandle := AuxDCEHandle(GetDCtlEntry(gGDHandle^^.gdRefNum));        { do whatever slot specific work is desired, now that the slot }        { number is known }        gGDHandle := GetNextDevice(gGDHandle);        { pass in present GDHandle; the next one is returned }      end;    until gGDHandle = nil;    </pre>	</TD></TR></TABLE></CENTER><p>X-Refs:</p><p>"Device Manager," <i>Inside Macintosh</i> Volumes II and IV</p><p>"Graphics Devices," <i>Inside Macintosh</i> Volume V</p><a name="Section15"></a><h2>Macintosh journaling mechanism</h2><p>Date Written:  5/3/89</p><p>Last reviewed:  12/17/90</p><p>How can I use the journaling mechanism described in <i>Inside Macintosh?</i></p><p>___</p><p>The old journaling mechanism isn't supported any more. It is no longernecessary because of MacroMaker and similar products. MacroMaker now "owns" theolder driver, and any future journaling will be done through MacroMaker.Currently there is no technical documentation available for MacroMaker. Thecurrent abilities of MacroMaker may not support what some developers will wantto do with journaling. Future versions of MacroMaker may add more features.</p><a name="Section16"></a><h2>How do I support locked and ejectable SCSI devices?</h2><p>Date Written:  5/14/90</p><p>Last reviewed:  12/17/90</p><p>How do I support locked and ejectable SCSI devices?</p><p>___</p><p>The only things you should have to support are the _DriveStatus call and modifythe DrvQEl record. The rest will be handled by the Macintosh system. The _DriveStatus call gives the information for srvStsCode. This is how the system will know what your disk can support. It is typically only used by floppy (or removable)  disk drives. The sample SCSI driver from Apple doesn't need to support it, because it doesn't support any of the information in the _DriveStatus call.</p><p>The DrvSts record contains some information of no concern here. ThediskInPlace, twoSideFmt, and needsFlush are probably ignored for your device.It's best to zero them out. The DrvSts information is pretty much just the sameinformation returned in the DrvQEl record.</p><p>Also, people sometimes get into trouble while developing a driver becausecurrent File Manager documentation about the drive queue element is vague.There are 4 bytes in front of a DrvQEl record. These determine the device'sabilities, but THESE BYTES ARE NOT ALLOCATED BY THE SYSTEM. When creating theDrvQEl record, you need to add these four bytes in front of the recordyourself. The pointer to a DrvQEl will be the actual record, which is AFTERthese 4 bytes. To read these bytes yourself, you'll have to subtract 4 bytesfrom the DrvQEl pointer.</p><p>It is important to note that the Disk Switch error dialog is not an actualdialog, but the system error. It is handled by the same code as SysError whichshows the system bomb alert. While this window is present, _SystemTask is notbeing called. This means the driver will not get an accRun call. To work aroundthis, you will need a VBL task. When the VBL is called it checks the SCSI busfor being free and if so, tests for a new cartridge. Once found, posts adiskInsertEvt. This will be received by the driver.</p><p>While the media is inserted, the VBL should not be running until after thecartridge is ejected. Otherwise, the SCSI bus will continue to be accessedunnecessarily, which slows the bus. The VBL task could also slow the systemwhile virtual memory is running.</p><P><A HREF="#top">Back to top</A></P>         <a name="downloads"></a>         <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center>                                    <img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (K)</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/dv_530.pdf">Download</A></P>               </TD>            </TR>         </TABLE>         <BR><P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/dv/dv_530.html%3Fid%3DDTS10002421-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/dv/dv_530.html%3Fid%3DDTS10002421-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/dv/dv_530.html%3Fid%3DDTS10002421-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>