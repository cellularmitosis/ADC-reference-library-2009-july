<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>SMARTQuery - /windowSMARTs.m</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/HardwareDrivers/index.html">Hardware & Drivers</a> &gt; <a href="../../samplecode/HardwareDrivers/idxMassStorageDevices-date.html">Storage</a> &gt; <A HREF="javascript:location.replace('index.html');">SMARTQuery</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->


	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">SMARTQuery</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/windowSMARTs.m</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/main.m</option>
<option value="listing2.html">/windowSMARTs.h</option>
<option value="listing3.html">/windowSMARTs.m</option></select>
				</p>
				</form>
				<p><strong><a href="SMARTQuery.zip">Download Sample</a></strong> (&#147;SMARTQuery.zip&#148;, 35.0K)<BR>
<strong><a href="SMARTQuery.dmg">Download Sample</a></strong> (&#147;SMARTQuery.dmg&#148;, 92.0K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox"> /*

File:&lt;windowSMARTs.m&gt;

Abstract: &lt;A demonstration of how to use S.M.A.R.T. monitoring&gt;

Version: &lt;1.0&gt;

Disclaimer: IMPORTANT:  This Apple software is supplied to you by 
Apple Inc. (&quot;Apple&quot;) in consideration of your agreement to the
following terms, and your use, installation, modification or
redistribution of this Apple software constitutes acceptance of these
terms.  If you do not agree with these terms, please do not use,
install, modify or redistribute this Apple software.

In consideration of your agreement to abide by the following terms, and
subject to these terms, Apple grants you a personal, non-exclusive
license, under Apple's copyrights in this original Apple software (the
&quot;Apple Software&quot;), to use, reproduce, modify and redistribute the Apple
Software, with or without modifications, in source and/or binary forms;
provided that if you redistribute the Apple Software in its entirety and
without modifications, you must retain this notice and the following
text and disclaimers in all such redistributions of the Apple Software. 
Neither the name, trademarks, service marks or logos of Apple Inc. 
may be used to endorse or promote products derived from the Apple
Software without specific prior written permission from Apple.  Except
as expressly stated in this notice, no other rights or licenses, express
or implied, are granted by Apple herein, including but not limited to
any patent rights that may be infringed by your derivative works or by
other works in which the Apple Software may be incorporated.

The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE
MAKES NO WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION
THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND
OPERATION ALONE OR IN COMBINATION WITH YOUR PRODUCTS.

IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL
OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION,
MODIFICATION AND/OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED
AND WHETHER UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE),
STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

Copyright (C) 2007 Apple Inc. All Rights Reserved.

*/

#import &quot;windowSMARTs.h&quot;

#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/param.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;mach/mach.h&gt;
#include &lt;mach/mach_error.h&gt;
#include &lt;mach/mach_init.h&gt;
#include &lt;IOKit/IOCFPlugIn.h&gt;
#include &lt;IOKit/IOKitLib.h&gt;
#include &lt;IOKit/IOReturn.h&gt;
#include &lt;IOKit/storage/ata/ATASMARTLib.h&gt;
#include &lt;IOKit/storage/IOStorageDeviceCharacteristics.h&gt;
#include &lt;CoreFoundation/CoreFoundation.h&gt;

#define kATADefaultSectorSize                             512

@implementation windowSMARTs

#if defined(__BIG_ENDIAN__)
#define    SwapASCIIHostToBig(x,y)
#elif defined(__LITTLE_ENDIAN__)
#define    SwapASCIIHostToBig(x,y)        SwapASCIIString( ( UInt16 * ) x,y)
#else
#error Unknown endianness.
#endif

// This constant comes from the SMART specification.  Only 30 values are allowed in any of the structures.
#define kSMARTAttributeCount  30


typedef struct IOATASmartAttribute
{
    UInt8       attributeId;
    UInt16      flag;  
    UInt8       current;
    UInt8       worst;
    UInt8       rawvalue[6];
    UInt8       reserv;
}  __attribute__ ((packed)) IOATASmartAttribute;

typedef struct IOATASmartVendorSpecificData
{
    UInt16           revisonNumber;
    IOATASmartAttribute    vendorAttributes [kSMARTAttributeCount];
} __attribute__ ((packed)) IOATASmartVendorSpecificData;

/* Vendor attribute of SMART Threshold */
typedef struct IOATASmartThresholdAttribute
{
    UInt8       attributeId;
    UInt8       ThresholdValue;
    UInt8       Reserved[10];
} __attribute__ ((packed)) IOATASmartThresholdAttribute;

typedef struct IOATASmartVendorSpecificDataThresholds
{
    UInt16              revisonNumber;
    IOATASmartThresholdAttribute   ThresholdEntries [kSMARTAttributeCount];
} __attribute__ ((packed)) IOATASmartVendorSpecificDataThresholds;


void SwapASCIIString(UInt16 *buffer, UInt16 length)
{
  int  index;
  
  for ( index = 0; index &lt; length / 2; index ++ ) {
    buffer[index] = OSSwapInt16 ( buffer[index] );
  }  
}


-(int) VerifyIdentifyData: (UInt16 *) buffer
{
  UInt8    checkSum    = -1;
  UInt32    index      = 0;
  UInt8 *    ptr        = ( UInt8 * ) buffer;
  
  require_string(((buffer[255] &amp; 0x00FF) == kChecksumValidCookie), ErrorExit, &quot;WARNING: Identify data checksum cookie not found&quot;);

  checkSum = 0;
    
  for (index = 0; index &lt; 512; index++)
    checkSum += ptr[index];
  
ErrorExit:
  return checkSum;
}


- (BOOL) PrintIdentifyData: ( IOATASMARTInterface **) smartInterface withResultsDict:(NSMutableDictionary *) smartResultsDict
{
  IOReturn  error        = kIOReturnSuccess;
  UInt8 *    buffer        = NULL;
  UInt32    length        = kATADefaultSectorSize;
  
  UInt16 *  words        = NULL;
  int      checksum      = 0;
  
  BOOL    isSMARTSupported  = NO;
  
  buffer = (UInt8 *) malloc(kATADefaultSectorSize);
  require_string((buffer != NULL), ErrorExit, &quot;malloc(kATADefaultSectorSize) failed&quot;);
  
  bzero(buffer, kATADefaultSectorSize);
  
  error = (*smartInterface)-&gt;GetATAIdentifyData(  smartInterface,
                          buffer,
                          kATADefaultSectorSize,
                          &amp;length );
  
  require_string((error == kIOReturnSuccess), ErrorExit, &quot;GetATAIdentifyData failed&quot;);

  checksum = [self VerifyIdentifyData:( UInt16 * ) buffer];
  require_string((checksum == 0), ErrorExit, &quot;Identify data verified. Checksum is NOT correct&quot;);
  
  // Terminate the strings with 0's
  // This changes the identify data, so we MUST do this part last.
  buffer[94] = 0;
  buffer[40] = 0;
  
  // Model number runs from byte 54 to 93 inclusive - byte 94 is set to 
  // zero to terminate that string.
  SwapASCIIHostToBig (&amp;buffer[54], 40);
  [smartResultsDict setObject:[NSString stringWithCString:(char *)&amp;buffer[54] encoding:NSUTF8StringEncoding] forKey:kWindowSMARTsModelKeyString];
  
  // Now that we have made a deep copy of the model string, poke a 0 into byte 54 
  // in order to terminate the fw-vers string which runs from bytes 46 to 53 inclusive.
  buffer[54] = 0;
  
  SwapASCIIHostToBig (&amp;buffer[46], 8);
  [smartResultsDict setObject:[NSString stringWithCString:(char *)&amp;buffer[46] encoding:NSUTF8StringEncoding] forKey:kWindowSMARTsFirmwareKeyString];

  SwapASCIIHostToBig (&amp;buffer[20], 20);
  [smartResultsDict setObject:[NSString stringWithCString:(char *)&amp;buffer[20] encoding:NSUTF8StringEncoding] forKey:kWindowSMARTsSerialNumberKeyString];
  
  words = (UInt16 *) buffer;
  
  isSMARTSupported = words[kATAIdentifyCommandSetSupported] &amp; kATASupportsSMARTMask;
    
  [smartResultsDict setObject:[NSNumber numberWithBool:words[kATAIdentifyCommandSetSupported] &amp; kATASupportsSMARTMask] forKey:kWindowSMARTsSMARTSupportKeyString];
  [smartResultsDict setObject:[NSNumber numberWithBool:words[kATAIdentifyCommandSetSupported] &amp; kATASupportsWriteCacheMask] forKey:kWindowSMARTsWriteCacheSupportKeyString];
  [smartResultsDict setObject:[NSNumber numberWithBool:words[kATAIdentifyCommandSetSupported] &amp; kATASupportsPowerManagementMask] forKey:kWindowSMARTsPMSupportKeyString];
  [smartResultsDict setObject:[NSNumber numberWithBool:words[kATAIdentifyCommandSetSupported] &amp; kATASupportsCompactFlashMask] forKey:kWindowSMARTsCFSupportKeyString];
  [smartResultsDict setObject:[NSNumber numberWithBool:words[kATAIdentifyCommandSetSupported] &amp; kATASupportsAdvancedPowerManagementMask] forKey:kWindowSMARTsAPMSupportKeyString];
  [smartResultsDict setObject:[NSNumber numberWithBool:words[kATAIdentifyCommandSetSupported] &amp; kATASupports48BitAddressingMask] forKey:kWindowSMARTs48BitAddressingSupportKeyString];
  [smartResultsDict setObject:[NSNumber numberWithBool:words[kATAIdentifyCommandSetSupported] &amp; kATASupportsFlushCacheMask] forKey:kWindowSMARTsFlushCacheCommandSupportKeyString];
  [smartResultsDict setObject:[NSNumber numberWithBool:words[kATAIdentifyCommandSetSupported] &amp; kATASupportsFlushCacheExtendedMask] forKey:kWindowSMARTsFlushCacheExtCommandSupportKeyString];
  [smartResultsDict setObject:[NSNumber numberWithInt:(words[kATAIdentifyQueueDepth] &amp; 0x001F) + 1] forKey:kWindowSMARTsQueueDepthKeyString];
    
  if ((words[76] != 0) &amp;&amp; (words[76] != 0xFFFF)) {
    [smartResultsDict setObject:[NSNumber numberWithBool:words[76] &amp; (1 &lt;&lt; 8)] forKey:kWindowSMARTsNCQSupportKeyString];
    [smartResultsDict setObject:[NSNumber numberWithBool:words[78] &amp; (1 &lt;&lt; 3)] forKey:kWindowSMARTsDeviceInitiatedPMKeyString];
    [smartResultsDict setObject:[NSNumber numberWithBool:words[76] &amp; (1 &lt;&lt; 9)] forKey:kWindowSMARTsHostInitiatedPMKeyString];
    [smartResultsDict setObject:[NSNumber numberWithFloat:( words[76] &amp; (1 &lt;&lt; 2) ) ? 3.0 : 1.5] forKey:kWindowSMARTsInterfaceSpeedKeyString];
  }
    
  if (((words[kATAIdentifyCommandSetSupported2] &amp; (1 &lt;&lt; 1)) == 0) &amp;&amp; ((words[76] &amp; (1 &lt;&lt; 8)) == 0)) {
    require_string((words[kATAIdentifyQueueDepth] != 0), ErrorExit, &quot;\n WARNING! Found inconsistency with queue depth!\n\n&quot;);
  }
  
ErrorExit:
  if (buffer)
    free(buffer);

  return isSMARTSupported;
}

-(void) PrintSMARTData:(IOATASMARTInterface **) smartInterface withResultsDict:(NSMutableDictionary *) smartResultsDict
{
  
  IOReturn                  error        = kIOReturnSuccess;
  Boolean                    conditionExceeded  = false;
  ATASMARTData                smartData;
  IOATASmartVendorSpecificData        smartDataVendorSpecifics;
  ATASMARTDataThresholds            smartThresholds;
  IOATASmartVendorSpecificDataThresholds    smartThresholdVendorSpecifics;
  ATASMARTLogDirectory            smartLogDirectory;

  bzero(&amp;smartData, sizeof(smartData));
  bzero(&amp;smartDataVendorSpecifics, sizeof(smartDataVendorSpecifics));
  bzero(&amp;smartThresholds, sizeof(smartThresholds));
  bzero(&amp;smartThresholdVendorSpecifics, sizeof(smartThresholdVendorSpecifics));
  bzero(&amp;smartLogDirectory, sizeof(smartLogDirectory));

  // Default the results for safety.
  [smartResultsDict setObject:[NSNumber numberWithBool:NO] forKey:kWindowSMARTsDeviceOkKeyString];


  // Start by enabling S.M.A.R.T. reporting for this disk.
  error = (*smartInterface)-&gt;SMARTEnableDisableOperations(smartInterface, true);
  require_string((error == kIOReturnSuccess), ErrorExit, &quot;SMARTEnableDisableOperations failed&quot;);
  
  error = (*smartInterface)-&gt;SMARTEnableDisableAutosave(smartInterface, true);
  require_string((error == kIOReturnSuccess), ErrorExit, &quot;SMARTEnableDisableAutosave failed&quot;);


  // In most cases, this value will be all that you require.  As most of the
  // S.M.A.R.T reporting attributes are vendor-specific, the only part you can
  // always count on being implemented and accurate is the overall T.E.C
  // (Threshold Exceeded Condition) status report.
  error = (*smartInterface)-&gt;SMARTReturnStatus(smartInterface, &amp;conditionExceeded);
  require_string((error == kIOReturnSuccess), ErrorExit, &quot;SMARTReturnStatus failed&quot; );
  
  if (!conditionExceeded)
    [smartResultsDict setObject:[NSNumber numberWithBool:YES] forKey:kWindowSMARTsDeviceOkKeyString];


  // NOTE:
  // The rest of the diagnostics gathering involves using portions of the API that is considered
  // optional for a drive vendor to implement.  Most vendors now do, but be warned not to rely
  // on it.  In particular, the attribute codes are usually considered vendor specific and
  // proprietary, although some codes (ie. drive temperature) are almost always present.


  // Ask the device to start collecting S.M.A.R.T. data immediately.  We are not asking
  // for an extended test to be performed at this point
  error = (*smartInterface)-&gt;SMARTExecuteOffLineImmediate (smartInterface, false);
  if (error != kIOReturnSuccess)
    printf(&quot;SMARTExecuteOffLineImmediate failed: %s(%x)\n&quot;, mach_error_string(error), error);


  // Next, a demonstration of how to extract the raw S.M.A.R.T. data attributes.
  // A drive can report up to 30 of these, but all are optional.  Normal values
  // vary by vendor, although the property used for this demonstration always
  // reports in degrees celcius
  error = (*smartInterface)-&gt;SMARTReadData(smartInterface, &amp;smartData);
  if (error != kIOReturnSuccess) {
    printf(&quot;SMARTReadData failed: %s(%x)\n&quot;, mach_error_string(error), error);
  } else {
    error = (*smartInterface)-&gt;SMARTValidateReadData(smartInterface, &amp;smartData);
    if (error != kIOReturnSuccess) {
      printf(&quot;SMARTValidateReadData failed for attributes: %s(%x)\n&quot;, mach_error_string(error), error);
    } else {
      smartDataVendorSpecifics = *((IOATASmartVendorSpecificData *)&amp;(smartData.vendorSpecific1));

      int currentAttributeIndex = 0;
      for (currentAttributeIndex = 0; currentAttributeIndex &lt; kSMARTAttributeCount; currentAttributeIndex++) {
        IOATASmartAttribute currentAttribute = smartDataVendorSpecifics.vendorAttributes[currentAttributeIndex];
      
        // Grab and use the drive temperature if it's present.  Don't freak out if it isn't, as
        // this is an optional behaviour although most drives do support this.
        if (currentAttribute.attributeId == kWindowSMARTsDriveTempAttribute) {
          UInt8 temp = currentAttribute.rawvalue[0];
          [smartResultsDict setObject:[NSNumber numberWithUnsignedInt:temp] forKey:kWindowSMARTsDeviceTempKeyString];
          break;
        }
      }
    }
  }


  // Now, grab the corresponding threshold value(s) for the data attributes we have.  A
  // threshold of zero for temperature indicates that this is not used as part of the
  // T.E.C. calculations.
  error = (*smartInterface)-&gt;SMARTReadDataThresholds(smartInterface, &amp;smartThresholds);
  if (error != kIOReturnSuccess) {
    printf(&quot;SMARTReadDataThresholds failed for threshold data: %s(%x)\n&quot;, mach_error_string(error), error);
  } else {
    // The validation scheme used by S.M.A.R.T. is a checksum byte added to the end to make
    // the entire block add to 0x00.  This validation works for both the attribute data and
    // the threshold data, although the prototype for SMARTValidateReadData takes a pointer
    // to a ATASMARTData structure.  As a result, we can safely call it here with a typecast.
    error = (*smartInterface)-&gt;SMARTValidateReadData(smartInterface, (ATASMARTData *)&amp;smartThresholds);
    if (error != kIOReturnSuccess) {
      printf(&quot;SMARTValidateReadData failed for threshold data: %s(%x)\n&quot;, mach_error_string(error), error);
    } else {
      smartThresholdVendorSpecifics = *((IOATASmartVendorSpecificDataThresholds *)&amp;(smartThresholds.vendorSpecific1));

      int currentAttributeIndex = 0;
      for (currentAttributeIndex = 0; currentAttributeIndex &lt; kSMARTAttributeCount; currentAttributeIndex++) {
        IOATASmartThresholdAttribute currentAttribute = smartThresholdVendorSpecifics.ThresholdEntries[currentAttributeIndex];
      
        // Grab and use the drive temperature if it's present.  Don't freak out if it isn't, as
        // this is an optional behaviour although most drives do support this
        if (currentAttribute.attributeId == kWindowSMARTsDriveTempAttribute) {
          UInt8 temp = currentAttribute.ThresholdValue;
          [smartResultsDict setObject:[NSNumber numberWithUnsignedInt:temp] forKey:kWindowSMARTsDeviceTempThresholdKeyString];
        }
      }
    }
  }


ErrorExit:
  // Now that we're done, shut down the S.M.A.R.T.  If we don't, storage takes a big performance hit.
  // We should be able to ignore any error conditions here safely
  error = (*smartInterface)-&gt;SMARTEnableDisableAutosave(smartInterface, false);
  error = (*smartInterface)-&gt;SMARTEnableDisableOperations(smartInterface, false);
}

- (io_service_t) GetDeviceObject: (io_service_t) object
{
  
  io_service_t      service   = IO_OBJECT_NULL;
  io_service_t      temp    = IO_OBJECT_NULL;
  io_service_t      parent     = IO_OBJECT_NULL;
  IOReturn        status    = kIOReturnSuccess;
  NSMutableDictionary    *property  = nil;
  
  property = (NSMutableDictionary *) IORegistryEntrySearchCFProperty (
          object,
          kIOServicePlane,
          CFSTR(kIOPropertySMARTCapableKey),
          kCFAllocatorDefault,
          kNilOptions );
  
  if (property) {
    IOObjectRetain(object);
    service = object;
    [property release];
    goto Exit;
  }
  
  status = IORegistryEntryGetParentEntry (object, kIOServicePlane, &amp;parent);
  require_string((status == kIOReturnSuccess), Exit, &quot;IORegistryGetParentEntry failed&quot;);
  
  while (true) {
    temp = parent;
    
    property = (NSMutableDictionary *) IORegistryEntrySearchCFProperty (
        temp,
        kIOServicePlane,
        CFSTR(kIOPropertySMARTCapableKey),
        kCFAllocatorDefault,
        kNilOptions );
    
    if (property) {
      service = temp;
      [property release];
      break;
    }
    
    status = IORegistryEntryGetParentEntry(temp, kIOServicePlane, &amp;parent);
    IOObjectRelease(temp);
    
    if (status != kIOReturnSuccess)
      break;
  }
  
Exit:
  return service;
}

- (IOReturn) PerformSMARTUnitTest:(io_service_t) object
{
  io_service_t        service        = IO_OBJECT_NULL;      
  IOCFPlugInInterface **    cfPlugInInterface  = NULL;
  IOATASMARTInterface **    smartInterface    = NULL;
  SInt32            score        = 0;
  HRESULT            herr        = S_OK;
  IOReturn          err          = kIOReturnSuccess;
  NSMutableDictionary *    smartResultsDict  = [[NSMutableDictionary alloc] initWithCapacity:16];
  
  // Under 10.4.8 and higher, we can use the presence of the &quot;SMART Capable&quot; key to find the top-most entry
  // in the registry for each device and query that.
  service = [self GetDeviceObject: object];
  
#if 0
  // If you know you're going to be running only on 10.4.8 or higher, you could do this
  require_string((service != IO_OBJECT_NULL), ErrorExit, &quot;unable to obtain service using [self GetDeviceObject]&quot;);
#else
  // As a fall-back, this will help you work on pre-10.4.8 systems as well.
  if (!service)
    service = object;
#endif
  
  err = IOCreatePlugInInterfaceForService (  service,
                        kIOATASMARTUserClientTypeID,
                        kIOCFPlugInInterfaceID,
                        &amp;cfPlugInInterface,
                        &amp;score );
  
  require_string ( ( err == kIOReturnSuccess ), ErrorExit,
           &quot;IOCreatePlugInInterfaceForService failed&quot; );
  
  herr = ( *cfPlugInInterface )-&gt;QueryInterface (
                    cfPlugInInterface,
                    CFUUIDGetUUIDBytes ( kIOATASMARTInterfaceID ),
                    ( LPVOID ) &amp;smartInterface );
  
  require_string ( ( herr == S_OK ), DestroyPlugIn,
           &quot;QueryInterface failed&quot; );
  
  // Grab any identifying data we can on this device and then, if it supports S.M.A.R.T.,
  // qurey the S.M.A.R.T. monitoring subsystem for status information
  if ([self PrintIdentifyData:smartInterface withResultsDict:smartResultsDict])
    [self PrintSMARTData:smartInterface withResultsDict:smartResultsDict];

  [foundDevices addObject:smartResultsDict];
  [smartResultsDict release];
  
  ( *smartInterface )-&gt;Release ( smartInterface );
  smartInterface = NULL;

DestroyPlugIn:
  IODestroyPlugInInterface ( cfPlugInInterface );
  cfPlugInInterface = NULL;

ErrorExit:
  return err;
  
}

- (id) init
{
  self = [super init];
  if (self) {
    foundDevices = [[NSMutableArray alloc] initWithCapacity:64];
    
    if (!foundDevices) {
      [self dealloc];
      self = nil;
    }
  }
  
  return self;
}

-(void) awakeFromNib
{
  IOReturn        error       = kIOReturnSuccess;
  NSMutableDictionary    *matchingDict  = [[NSMutableDictionary alloc] initWithCapacity:8];
  NSMutableDictionary   *subDict    = [[NSMutableDictionary alloc] initWithCapacity:8];
  io_iterator_t      iter      = IO_OBJECT_NULL;
  io_object_t        obj        = IO_OBJECT_NULL;
  
  //
  //  Note: We are setting up a matching dictionary which looks like the following:
  //
  //  &lt;dict&gt;
  //    &lt;key&gt;IOPropertyMatch&lt;/key&gt;
  //    &lt;dict&gt;
  //      &lt;key&gt;SMART Capable&lt;/key&gt;
  //      &lt;true/&gt;
  //    &lt;/dict&gt;
  // &lt;/dict&gt;
  //
  
  // Create a dictionary with the &quot;SMART Capable&quot; key = true
  [subDict setObject:[NSNumber numberWithBool:YES] forKey:[NSString stringWithCString:kIOPropertySMARTCapableKey]];
  
  // Add the dictionary to the main dictionary with the key &quot;IOPropertyMatch&quot; to
  // narrow the search to the above dictionary.
  [matchingDict setObject:subDict forKey:[NSString stringWithCString:kIOPropertyMatchKey]];
  
  [subDict release];
  subDict = NULL;

  // Remember - this call eats one reference to the matching dictionary.  In this case, removing the need to release it later
  error = IOServiceGetMatchingServices (kIOMasterPortDefault, (CFDictionaryRef)matchingDict, &amp;iter);
  if (error != kIOReturnSuccess) {
    printf(&quot;Error finding SMART Capable disks: %s(%x)\n&quot;, mach_error_string(error), error);
  } else {
    while ((obj = IOIteratorNext(iter)) != IO_OBJECT_NULL) {    
      error = [self PerformSMARTUnitTest:obj];
      IOObjectRelease(obj);
    }
  }

  // OK, now if that search was unable to locate any devices, then either we don't have any or
  // we're running on a system older than 10.4.8.  This method will work for older installs
  // NOTE: This will locate all ATA storage devices, including ones that do not support S.M.A.R.T.
  // You will need to check the indentification data for the ATA Supports SMART bit.  This is
  // Done above in PrintIdentifyData and the result stored in the dicitonary for this device as
  // &quot;SMART Supported&quot;
  if ([foundDevices count] == 0) {
    iter      = IO_OBJECT_NULL;
    matchingDict  = (NSMutableDictionary *)IOServiceMatching(&quot;IOATABlockStorageDevice&quot;);

    // Remember - this call eats one reference to the matching dictionary.  In this case, removing the need to release it later
    error = IOServiceGetMatchingServices (kIOMasterPortDefault, (CFDictionaryRef)matchingDict, &amp;iter);
    if (error != kIOReturnSuccess) {
      printf(&quot;Error finding SMART Capable disks the old way: %s(%x)\n&quot;, mach_error_string(error), error);
    } else {
      while ((obj = IOIteratorNext(iter)) != IO_OBJECT_NULL) {    
        error = [self PerformSMARTUnitTest:obj];
        IOObjectRelease(obj);
      }
    }
  }
  
  IOObjectRelease(iter);
  iter = IO_OBJECT_NULL;
  
  [deviceArrayController setContent:foundDevices];
}

- (void) dealloc
{
  [foundDevices release];
  [super dealloc];
}

@end
</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/SMARTQuery/listing3.html%3Fid%3DDTS10004291-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/SMARTQuery/listing3.html%3Fid%3DDTS10004291-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/SMARTQuery/listing3.html%3Fid%3DDTS10004291-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>