<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>usher - /sources/AppSupport.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxQuickTime-date.html">QuickTime</a> &gt; <A HREF="javascript:location.replace('index.html');">usher</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/QuickTime/index.html" target="_blank">Reference Library > QuickTime</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">usher</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/sources/AppSupport.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/notes/usingusher.htm</option>
<option value="listing2.html">/sources/AppSupport.c</option>
<option value="listing3.html">/sources/AppSupport.h</option>
<option value="listing4.html">/sources/MovieSourcing.c</option>
<option value="listing5.html">/sources/MovieSourcing.h</option>
<option value="listing6.html">/sources/PresInfoWindow.c</option>
<option value="listing7.html">/sources/PresInfoWindow.h</option>
<option value="listing8.html">/sources/PresinfoWindow.r</option>
<option value="listing9.html">/sources/QTSSampleCodeUtils.c</option>
<option value="listing10.html">/sources/QTSSampleCodeUtils.h</option>
<option value="listing11.html">/sources/SimplePres.c</option>
<option value="listing12.html">/sources/SimplePres.h</option>
<option value="listing13.html">/sources/SourcingSupport.c</option>
<option value="listing14.html">/sources/SourcingSupport.h</option>
<option value="listing15.html">/sources/usher.r</option>
<option value="listing16.html">/sources/UsherBroadcast.c</option>
<option value="listing17.html">/sources/UsherBroadcast.h</option>
<option value="listing18.html">/sources/UsherCarbon.r</option>
<option value="listing19.html">/sources/UsherCommands.h</option>
<option value="listing20.html">/sources/UsherMinWindow.c</option>
<option value="listing21.html">/sources/UsherMinWindow.h</option>
<option value="listing22.html">/sources/UsherMinWindow.r</option>
<option value="listing23.html">/sources/UsherNew.c</option>
<option value="listing24.html">/sources/UsherNew.h</option>
<option value="listing25.html">/sources/usherRezDefines.h</option>
<option value="listing26.html">/sources/WindowSupport.c</option>
<option value="listing27.html">/sources/WindowSupport.h</option>
<option value="listing28.html">/UsherReleaseNotes.txt</option></select>
				</p>
				</form>
				<p><strong><a href="usher.zip">Download Sample</a></strong> (&#147;usher.zip&#148;, 212.3K)<BR>
<strong><a href="usher.dmg">Download Sample</a></strong> (&#147;usher.dmg&#148;, 293.2K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    AppSupport.c  Copyright:  &copy; 2000-2001 by Apple Computer, Inc., all rights reserved.*/#include &lt;Devices.h&gt;#include &lt;FixMath.h&gt;#include &lt;Fonts.h&gt;#include &lt;Gestalt.h&gt;#include &lt;LowMem.h&gt;#include &lt;Menus.h&gt;#include &lt;Quickdraw.h&gt;#include &lt;TextUtils.h&gt;#include &lt;stdarg.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;QuickTimeStreaming.h&gt;#include &lt;QTStreamingComponents.h&gt;#include &quot;AppSupport.h&quot;#include &quot;QTSSampleCodeUtils.h&quot;#include &quot;UsherBroadcast.h&quot;#include &quot;UsherCommands.h&quot;#include &quot;UsherNew.h&quot;#include &quot;usherrezdefines.h&quot;#include &quot;WindowSupport.h&quot;// ---------------------------------------------------------------------------//    D E F I N I T I O N S// ---------------------------------------------------------------------------// min qt version#define kMinQTVersion      0x05018000#define kMinQTSVersion      0x05018000#define kGMVersionMask      0xFFFF0000#if TARGET_RT_MAC_MACHO  #define kAppDefaultSleepTime    6#else  #define kAppDefaultSleepTime    60#endifAppGlobals gGlobals;// ---------------------------------------------------------------------------//    P R O T O T Y P E S// ---------------------------------------------------------------------------static OSErr Initialize(void);static OSErr AppGlobals_Initialize(void);static void InitToolbox(void);static OSErr InstallMenus(void);static OSErr CheckConfig(void);static void CleanUp(void);static void AppGlobals_CleanUp(void);// ----- eventsstatic void EventLoop(void);static void DoEvent(EventRecord *event);static void AdjustCursor(Point inMouse, RgnHandle inRegion);static void AdjustMenus(void);static void DoMenuCommand(long inMenuResult);static long GetMenuCommand(long inMenuResult, void **outCommandParams);static void DoKeyDown(EventRecord *inEvent);static long GetKeyDownCommand(EventRecord *inEvent);static void DoCommand(long inCommand, void *inCommandParams);static void DoOpen(void);static void DoIdle(void);static void DoQuit(void);static void DoAbout(void);static void DoCloseWindow(WindowPtr inWindow, Boolean inAdjustMenus);static void DoCloseAllWindows(void);static void ShowLog(void);#if TARGET_OS_MAC// ----- apple eventsstatic void InitAppleEvents(void);static void DoAppleEvent(EventRecord *inEvent);static pascal OSErr DoAEOpenApp(const AppleEvent *message, AppleEvent *reply, UInt32 refcon);static pascal OSErr DoAEOpenDocument(const AppleEvent *message, AppleEvent *reply, UInt32 refcon);static pascal OSErr DoAEQuit(const AppleEvent *message, AppleEvent *reply, UInt32 refcon);      static OSErr OpenWindowsForAEDescItems(AEDescList descList);#endif /* TARGET_OS_MAC */// ----- utils#define OptionDown()    ( (*(char*)0x17b) &amp; 0x04 )static void SetArrowCursor(void);static void MyGetGlobalMouse(Point *outMouse);static Boolean ShiftKeyDown(void);static Boolean CapsLockDown(void);static Boolean OptionKeyDown(void);static Boolean ControlKeyDown(void);#define kUsherStandardLogDelimiterString      &quot;--------------------------------------------&quot;// ---------------------------------------------------------------------------//    main// ---------------------------------------------------------------------------void main(void){  if (noErr == Initialize())  {    /* initialize the program */    EventLoop();        /* call the main event loop */  }  //DoCloseAllWindows();}// ---------------------------------------------------------------------------//    Initialize// ---------------------------------------------------------------------------static OSErr Initialize(void){  OSErr      err = noErr;  InitToolbox();  EXITIFERR( err = AppGlobals_Initialize() );  AppGlobals_SetInBackground(false);  EXITIFERR( err = CheckConfig() );  EXITIFERR( err = InstallMenus() );    AppGlobals_SetDefaultOffset(20, 12)  InitAppleEvents();  SetArrowCursor();exit:  if (err != noErr)  {    short     index = err;    if ((err &lt; 1)  ||  (err &gt; rAppError_MaxHandledStrings))  {      index = rAppError_GeneralStartup;    }    GenericAlertUser(rStringList_AppErrors, index, err);  }  return err;}// ---------------------------------------------------------------------------//    InitToolbox// ---------------------------------------------------------------------------static void InitToolbox(void){#if TARGET_OS_MAC  MoreMasters();  MoreMasters();#if !TARGET_API_MAC_CARBON  InitGraf(&amp;qd.thePort);  InitFonts();  FlushEvents(0xffff,0);  InitWindows();  InitMenus();  InitDialogs(0);  TEInit();  MaxApplZone();#endif /* not TARGET_API_MAC_CARBON */  InitCursor();#endif  }// ---------------------------------------------------------------------------//    AppGlobals_Initialize// ---------------------------------------------------------------------------static OSErr AppGlobals_Initialize(void){  FSSpec    logSpec;  OSErr    err = noErr;  memset(&amp;gGlobals, 0, sizeof(gGlobals));  AppGlobals_SetSleepTime(kAppDefaultSleepTime);  // Make a backup port to use for safety purposes.#if TARGET_API_MAC_CARBON  //@@@ do I need to check the error?  gGlobals.safetyPort = CreateNewPort();  if (gGlobals.safetyPort == NULL)  {    EXITERR( err = -333 );  }#else  GetWMgrPort( &amp;gGlobals.safetyPort );#endif  GetAppRelativeFolderSpec(NULL, &amp;logSpec);  pstrcpy(logSpec.name, &quot;\pusherlog.txt&quot;);#define kLogFileCreator    'CWIE'#define kLogFileType    'TEXT'  EXITIFERR( err = Logger_New(&amp;logSpec, 0, kLogFileCreator, kLogFileType, &amp;gGlobals.log) );  {    //SInt32    flags = kDebugFlag_WriteToLog | kDebugFlag_DebugStr;    SInt32    flags = kDebugFlag_WriteToLog;    SetDebugLog(gGlobals.log);    SetDebugFlags(flags, flags);     Logger_Printf(gGlobals.log, kLoggerWriteFlag_AddDateTime | kLoggerWriteFlag_AddEOL,            kUsherStandardLogDelimiterString);    Logger_Printf(gGlobals.log, kLoggerWriteFlag_AddDateTime | kLoggerWriteFlag_AddEOL,            &quot;usher started&quot;);  }  exit:  return err;}// ---------------------------------------------------------------------------//    CheckConfig// ---------------------------------------------------------------------------static OSErr CheckConfig(void){  OSErr    err = noErr;  long    result;  // check quicktime version  err = Gestalt( gestaltQuickTimeVersion, &amp;result );  if ( (noErr != err) || ((result &lt; kMinQTVersion)  &amp;&amp;  (result != (kMinQTVersion &amp; kGMVersionMask))) )  {    EXITERR( err = rAppError_QTVersion );  }    // check quicktime streaming version  err = Gestalt(gestaltQuickTimeStreamingVersion, &amp;result);  if ( (noErr != err) || ((result &lt; kMinQTSVersion)  &amp;&amp;  (result != (kMinQTSVersion &amp; kGMVersionMask))) )  {    EXITERR( err = rAppError_QTSVersion );  }  #if TARGET_API_MAC_CARBON  //  work around initialization bugs in Carbon.  {    GrafPtr dummyPort;    CurResFile();      // forces CarbonCore to load.    GetPort(&amp;dummyPort);  // forces Quickdraw to load.    FrontWindow();      // forces HLTB to load.  }#endif    EXITIFERR( err = EnterMovies() );#if TARGET_OS_MAC  if ((noErr == Gestalt(gestaltAppearanceAttr, &amp;result))  &amp;&amp;     (result &amp; (1L &lt;&lt; gestaltAppearanceExists)) )  {    AppGlobals_SetUseAppearance( (result &amp; (1L &lt;&lt; gestaltAppearanceCompatMode)) == 0 );  }  else  {    AppGlobals_SetUseAppearance(false);  }#endifexit:  return err;}// ---------------------------------------------------------------------------//    InstallMenus// ---------------------------------------------------------------------------static OSErr InstallMenus(void){  Handle      menuBar;  OSErr      err = noErr;  /* read menus into menu bar */  menuBar = GetNewMBar(rMenuBar_Main);  if (menuBar == NULL)  {    EXITERR( err = memFullErr );  }  SetMenuBar(menuBar);          /* install menus */  DisposeHandle(menuBar);#if TARGET_API_MAC_CARBON{  OSErr      tempErr;  long      result = 0;  tempErr = Gestalt( gestaltMenuMgrAttr, &amp;result );  if( (noErr == tempErr) &amp;&amp; (result &amp; gestaltMenuMgrAquaLayoutMask)) {    // Delete Quit item from the File menu.    DeleteMenuItem( GetMenuHandle(rMenu_File), rMenuItem_Quit );    DeleteMenuItem( GetMenuHandle(rMenu_File), rMenuItem_Quit-1 );  }}#else // not TARGET_API_MAC_CARBON  AppendResMenu(GetMenuHandle(rMenu_Apple), 'DRVR');  /* add DA names to Apple menu */#endif  AdjustMenus();  // calls MacDrawMenuBarexit:  return err;}// ---------------------------------------------------------------------------//    CleanUp// ---------------------------------------------------------------------------static void CleanUp(void){  UsherBroadcast_CleanUp();  AppGlobals_CleanUp();}// ---------------------------------------------------------------------------//    AppGlobals_CleanUp// ---------------------------------------------------------------------------static void AppGlobals_CleanUp(void){  if (gGlobals.log != NULL)  {    Logger_Printf(gGlobals.log, kLoggerWriteFlag_AddDateTime | kLoggerWriteFlag_AddEOL,            &quot;usher stopped&quot;);     Logger_Dispose(gGlobals.log);    gGlobals.log = NULL;  }}#pragma mark -#pragma mark .----- events -----// ---------------------------------------------------------------------------//    EventLoop// ---------------------------------------------------------------------------static void EventLoop(void){  Boolean    gotEvent;  EventRecord  event;  do {    gotEvent = WaitNextEvent(everyEvent, &amp;event, AppGlobals_GetSleepTime(), NULL);    if (gotEvent)  {      /* make sure we have the right cursor before handling the event */      AdjustCursor(event.where, nil);      DoEvent(&amp;event);    }  else  {      DoIdle();        /* perform idle tasks when it's not our event */    }  } while (!AppGlobals_GetExitNow());    CleanUp();  } /*EventLoop*/// ---------------------------------------------------------------------------//    DoEvent// ---------------------------------------------------------------------------static void DoEvent(EventRecord *event)  {  short    part;  WindowPtr  window;  short    key;  switch (event-&gt;what) {    case nullEvent:      DoIdle();      break;    case mouseDown:      part = MacFindWindow(event-&gt;where, &amp;window);      switch ( part ) {        case inMenuBar:           AdjustMenus();          DoMenuCommand(MenuSelect(event-&gt;where));          break;#if TARGET_OS_MAC &amp;&amp; !TARGET_API_MAC_CARBON        case inSysWindow:           /* let the system handle the mouseDown */          SystemClick(event, window);          break;#endif        case inContent:          if ( window != FrontWindow() ) {            SelectWindow(window);          } else  {            WindowSupport_DoContentClick(window, event);          }          break;        case inDrag:                /* pass screenBits.bounds to get all gDevices */#if TARGET_API_MAC_CARBON          DragWindow(window, event-&gt;where, nil);#else          DragWindow(window, event-&gt;where, &amp;qd.screenBits.bounds);#endif          break;        case inGoAway:          if ( TrackGoAway(window, event-&gt;where) ) {#if TARGET_OS_MAC            if ( event-&gt;modifiers &amp; optionKey )  {              DoCommand(kCommand_CloseAll, NULL);            }  else#endif              DoCommand(kCommand_Close, window);          }          break;#if TARGET_OS_MAC        case inGrow:          WindowSupport_GrowWindow(window, event);          break;        case inZoomIn:        case inZoomOut:          break;#endif      }      break;    case keyDown:    case autoKey:              /* check for menukey equivalents */      key = (short)(event-&gt;message &amp; charCodeMask);      if (event-&gt;modifiers &amp; cmdKey) {  /* Command key down */        if (event-&gt;what == keyDown) {          AdjustMenus();        /* enable/disable/check menu items properly */#if TARGET_OS_MAC          if (AppGlobals_GetUseAppearance())            DoMenuCommand(MenuEvent(event));          else#endif            DoMenuCommand(MenuKey(key));        }      } else  {        DoKeyDown(event);      }      break;    case activateEvt:      WindowSupport_ActivateWindow((WindowPtr) event-&gt;message, (event-&gt;modifiers &amp; activeFlag) != 0);      break;    case updateEvt:      WindowSupport_DoUpdate((WindowPtr)event-&gt;message);      break;    case osEvt:      switch ((event-&gt;message &amp; osEvtMessageMask) &gt;&gt; 24) {    /* high byte of message */        case mouseMovedMessage:          DoIdle();          break;        case suspendResumeMessage:    /* suspend/resume is also an activate/deactivate */          AppGlobals_SetInBackground((event-&gt;message &amp; resumeFlag) == 0);          WindowSupport_ActivateWindow(FrontWindow(), !AppGlobals_GetInBackground());          break;      }      break;#if TARGET_OS_MAC    case kHighLevelEvent:       DoAppleEvent(event);      break;#endif    default:      break;  }}// ---------------------------------------------------------------------------//    AdjustCursor// ---------------------------------------------------------------------------static void AdjustCursor(Point inMouse, RgnHandle inRegion){#pragma unused(inMouse, inRegion)  WindowPtr  window;  window = FrontWindow();  /* we only adjust the cursor when we are in front */  if ( !AppGlobals_GetInBackground() &amp;&amp; !WindowSupport_IsDAWindow(window) ) {    SetArrowCursor();  }}// ---------------------------------------------------------------------------//    AdjustMenus// ---------------------------------------------------------------------------static void AdjustMenus(void){//@@@  MacDrawMenuBar();}// ---------------------------------------------------------------------------//    DoMenuCommand// ---------------------------------------------------------------------------static void DoMenuCommand(long inMenuResult){  long    command;  void    *commandParams = NULL;  command = GetMenuCommand(inMenuResult, &amp;commandParams);  if (command != kCommand_Nothing)  {    DoCommand(command, commandParams);  }  else  {    if (MYLOWORD(inMenuResult) != 0)  {      SysBeep(0);    }  }}// ---------------------------------------------------------------------------//    GetMenuCommand// ---------------------------------------------------------------------------static long GetMenuCommand(long inMenuResult, void **outCommandParams){  short    menuID, menuItem;  SInt32    command = kCommand_Nothing;  Boolean    commandFound = true;  menuID = (short)MYHIWORD(inMenuResult);  menuItem = (short)MYLOWORD(inMenuResult);  switch (menuID)  {    case rMenu_Apple:      switch  (menuItem) {        case rMenuItem_About:    /* bring up alert for About */          command = kCommand_About;          break;        default:      /* all non-About items in this menu are DAs et al */          command = kCommand_OpenDeskAcc;          *outCommandParams = (void*)menuItem;          break;      }      break;    case rMenu_File:      switch (menuItem) {        case rMenuItem_Open:          command = kCommand_Open;          break;        case rMenuItem_Close:#if TARGET_OS_MAC          if (OptionKeyDown())  {            command = kCommand_CloseAll;          }  else#endif          {              command = kCommand_Close;            *outCommandParams = FrontWindow();          }          break;#if !TARGET_API_MAC_CARBON        case rMenuItem_Quit:          command = kCommand_Quit;          //DoCommand(kCommand_Quit, NULL);          break;#endif        default:          commandFound = false;          break;      }      break;    case rMenu_Edit:      /* call SystemEdit for DA editing &amp; MultiFinder */#if !TARGET_API_MAC_CARBON      if (!SystemEdit((short)(menuItem-1)))#endif      {        switch (menuItem)  {          default:            break;        }      }      break;      case rMenu_Presentation:      switch (menuItem)  {        case rMenuItem_ShowLog:          command = kCommand_ShowLog;          break;        default:          commandFound = false;          break;      }              default:      commandFound = false;      break;  }  if (!commandFound)  {    WindowPtr    window = FrontWindow();        if (window != NULL)  {      command = WindowSupport_GetMenuCommand(window, inMenuResult, outCommandParams);    }  }  HiliteMenu(0);          /* unhighlight what MenuSelect (or MenuKey) hilited */  return command;}// ---------------------------------------------------------------------------//    DoKeyDown// ---------------------------------------------------------------------------static void DoKeyDown(EventRecord *inEvent){  long    command = kCommand_Nothing;    command = GetKeyDownCommand(inEvent);  if (command != kCommand_Nothing)  {    DoCommand(command, NULL);  }}// ---------------------------------------------------------------------------//    GetKeyDownCommand// ---------------------------------------------------------------------------static long GetKeyDownCommand(EventRecord *inEvent){#if TARGET_OS_MAC  long    command = kCommand_Nothing;  if ((inEvent-&gt;message &amp; charCodeMask) == 0x09)  { // tab    if (inEvent-&gt;modifiers &amp; shiftKey)  {      command = kCommand_SelectPrevWindow;    }  else  {      command = kCommand_SelectPrevWindow;    }  }  return command;#else  return kCommand_Nothing;#endif}#pragma mark -#pragma mark .----- commands -----// ---------------------------------------------------------------------------//    DoCommand// ---------------------------------------------------------------------------static void DoCommand(long inCommand, void *inCommandParams){  OSErr      err = noErr;  Boolean      handled = true;  switch (inCommand)  {    case kCommand_About:      DoAbout();      break;      #if TARGET_OS_MAC &amp;&amp; !TARGET_API_MAC_CARBON //@@QTML    case kCommand_OpenDeskAcc:    {      GrafPtr    savePort;      Str255    daName;                    GetPort(&amp;savePort);      GetMenuItemText(GetMenuHandle(rMenu_Apple), (short)inCommandParams, daName);      OpenDeskAcc(daName);      MacSetPort(savePort);      break;    }#endif    case kCommand_Open:      DoOpen();      break;          case kCommand_OpenFromFSSpec:    {      long    numbroadcasts;            numbroadcasts = UsherBroadcast_GetNumBroadcasts();      if (OptionDown()  ||  (numbroadcasts &lt; 1))  {        err = Usher_NewBroadcastFromFile((const FSSpec*)inCommandParams, 0);      }  else  {        SysBeep(0);            }      break;    }    case kCommand_Close:      DoCloseWindow((WindowPtr)inCommandParams, true);      break;          case kCommand_CloseAll:      DoCloseAllWindows();      break;          case kCommand_Quit:      DoQuit();      break;          case kCommand_ShowLog:      ShowLog();      break;    default:      handled = false;      break;    }  if (!handled)  {    WindowPtr    window = FrontWindow();        err = WindowSupport_DoCommand(window, inCommand, inCommandParams);  }    if (err == kErr_AppUnhandledCommand)  {    DEBUGF((&quot;DoCommand %ld - no one handled it&quot;, inCommand));  }  else if (err != noErr)  {    DEBUGF((&quot;DoCommand %ld - err %ld params $%.8x&quot;, inCommand, err, inCommandParams));  }}// ---------------------------------------------------------------------------//    DoAbout// ---------------------------------------------------------------------------static void DoAbout(void){  Handle       versHandle = NULL;  unsigned char  *stringPtr;  char      oldState;    versHandle = GetResource('vers', 2);  if (versHandle != NULL)  {    oldState = HGetState(versHandle);    HLock(versHandle);    stringPtr = (unsigned char*)((*versHandle) + 7 + ((*versHandle)[6]));    }  else  {    stringPtr = EMPTY_PSTR;  }  ParamText(stringPtr, EMPTY_PSTR, EMPTY_PSTR, EMPTY_PSTR);  if (versHandle != NULL)  {    HSetState(versHandle, oldState);  }  Alert(rAlert_AboutBox, NULL);}// ---------------------------------------------------------------------------//    DoOpen// ---------------------------------------------------------------------------static void DoOpen(void){#if TARGET_API_MAC_CARBON  OSType movieTypeList[1] = {'sdp '};  StandardFileReply reply;  OSErr    err = noErr;  FSSpec    myFSSpec;  //@@@ need to change this to use Nav  // -1 means allow all files  StandardGetFilePreview( nil, -1, movieTypeList, &amp;reply );  if (reply.sfGood) {    myFSSpec = reply.sfFile;    DoCommand(kCommand_OpenFromFSSpec, &amp;myFSSpec);  }#else  StandardFileReply reply;  SFTypeList  typeList;  OSErr    err = noErr;  typeList[0] = 'sdp ';  typeList[1] = 'atom';  typeList[2] = 'TEXT';  StandardGetFilePreview( NULL, 3, typeList, &amp;reply );  if (reply.sfGood)  {    DoCommand(kCommand_OpenFromFSSpec, &amp;reply.sfFile);  }  if (err != noErr)  {    DEBUGF((&quot;DoOpen err %ld&quot;, err));  }  return;#endif}// ---------------------------------------------------------------------------//    DoIdle// ---------------------------------------------------------------------------static void DoIdle(void){  UsherBroadcast_IdleAll();}// ---------------------------------------------------------------------------//    DoQuit// ---------------------------------------------------------------------------static void DoQuit(void){  AppGlobals_SetExitNow(true);}// ---------------------------------------------------------------------------//    DoSelectWindow// ---------------------------------------------------------------------------static void DoSelectWindow(long inCommand){  WindowPtr    window;    window = FrontWindow();  if (window != NULL)  {    if (inCommand == kCommand_SelectNextWindow)  {      while(MacGetNextWindow(window) != NULL)  {        window = MacGetNextWindow(window);      }      SelectWindow(window);    }  else if (inCommand == kCommand_SelectPrevWindow)  {#if !TARGET_API_MAC_CARBON      SInt16    savePaintWhite = LMGetPaintWhite();#endif      if (MacGetNextWindow(window) != NULL)  {        SelectWindow(MacGetNextWindow(window));      }#if !TARGET_API_MAC_CARBON      LMSetPaintWhite(0);#endif      SendBehind(window, NULL);#if !TARGET_API_MAC_CARBON      LMSetPaintWhite(savePaintWhite);#endif    }  else  {      DEBUGF((&quot;DoSelectWindow-bad command %ld&quot;, inCommand));    }  }}// ---------------------------------------------------------------------------//    DoCloseWindow// ---------------------------------------------------------------------------/* Close a window. This handles desk accessory and application windows. */static void DoCloseWindow(WindowPtr inWindow, Boolean inAdjustMenus){#if TARGET_OS_MAC &amp;&amp; ! TARGET_API_MAC_CARBON  if ( WindowSupport_IsDAWindow(inWindow) ) {    CloseDeskAcc(GetWindowKind(inWindow));  }  else #endif  {    WindowSupport_CloseWindow(inWindow);  }    /* SetPort to a valid port for safety */  if (FrontWindow() != NULL)  {    SetPortWindowPort(FrontWindow());  }  else  {    MacSetPort( gGlobals.safetyPort );  }    if (inAdjustMenus)  {    // Adjust the menus because we may now have no frontmost window.    AdjustMenus();  }}// ---------------------------------------------------------------------------//    DoCloseAllWindows// ---------------------------------------------------------------------------static void DoCloseAllWindows(void){  WindowPtr window, nextWindow = FrontWindow();  while (nextWindow != NULL)  {    window = nextWindow;    nextWindow = MacGetNextWindow( window );    DoCloseWindow(window, false);  }  AdjustMenus();}// ---------------------------------------------------------------------------//    ShowLog// ---------------------------------------------------------------------------static void ShowLog(void){}#pragma mark -#pragma mark .----- alerts -----// ---------------------------------------------------------------------------//    GenericAlertUser// ---------------------------------------------------------------------------void GenericAlertUser(short inStringList, short inStringIndex, short inErrorCode){  short    itemHit;  Str255    message;  Str255    codeString;  SetArrowCursor();  GetIndString(message, inStringList, inStringIndex);  NumToString(inErrorCode, codeString);  ParamText(message, codeString, EMPTY_PSTR, EMPTY_PSTR);  itemHit = Alert(rAlert_Generic, NULL);}// ---------------------------------------------------------------------------//    GenericAlertUserString// ---------------------------------------------------------------------------void GenericAlertUserString(Str255 inMessage, short inErrorCode){  short    itemHit;  Str255    codeString;  SetArrowCursor();  NumToString(inErrorCode, codeString);  ParamText(inMessage, codeString, EMPTY_PSTR, EMPTY_PSTR);  itemHit = Alert(rAlert_Generic, NULL);}// ---------------------------------------------------------------------------//    GenericErrorAlert// ---------------------------------------------------------------------------void GenericErrorAlert(OSErr inErrorCode){  short    itemHit;  Str255    codeString;  SetArrowCursor();  NumToString(inErrorCode, codeString);  ParamText(codeString, EMPTY_PSTR, EMPTY_PSTR, EMPTY_PSTR);  itemHit = Alert(rAlert_Error, NULL);}// ---------------------------------------------------------------------------//    ProcessUserMessage// ---------------------------------------------------------------------------void ProcessUserMessage(SInt32 inFlags, const char* format, ...){#define kMaxDebugFBufferSize    512  unsigned char buffer[kMaxDebugFBufferSize];  va_list   ptr;    va_start(ptr, format);  buffer[0] = (unsigned char)vsprintf((char*)buffer + 1, format, ptr);  va_end(ptr);  if (inFlags &amp; kProcessMessageFlag_Log)  {    Logger    log = AppGlobals_GetLog();        if (log != 0)  {      Logger_Write(log, kLoggerWriteFlag_AddDateTime | kLoggerWriteFlag_AddEOL,          (const char*)&amp;(buffer[1]), buffer[0] );    }  }  if (inFlags &amp; kProcessMessageFlag_ShowDialog)  {    GenericAlertUserString(buffer, noErr);  }}#pragma mark -#pragma mark .----- apple events -----#if TARGET_OS_MAC// ---------------------------------------------------------------------------//    InitAppleEvents// ---------------------------------------------------------------------------static void InitAppleEvents(void){  const long  noRefCon = 0;  OSErr    aevtErr;    aevtErr = AEInstallEventHandler( kCoreEventClass, kAEOpenApplication, NewAEEventHandlerProc(DoAEOpenApp), noRefCon, false) ;  aevtErr = AEInstallEventHandler( kCoreEventClass, kAEOpenDocuments,   NewAEEventHandlerProc(DoAEOpenDocument), noRefCon, false) ;  aevtErr = AEInstallEventHandler( kCoreEventClass, kAEQuitApplication, NewAEEventHandlerProc(DoAEQuit), noRefCon, false) ;}// ---------------------------------------------------------------------------//    DoAppleEvent// ---------------------------------------------------------------------------static void DoAppleEvent(EventRecord *inEvent){  OSErr    err;  // should check for your own event message types here - if you have any  err = AEProcessAppleEvent(inEvent);}// ---------------------------------------------------------------------------//    DoAEOpenApp// ---------------------------------------------------------------------------static pascal OSErr DoAEOpenApp(const AppleEvent *message, AppleEvent *reply, UInt32 refcon){#pragma unused(message, reply, refcon)  return noErr;}// ---------------------------------------------------------------------------//    DoAEOpenDocument// ---------------------------------------------------------------------------static pascal OSErr DoAEOpenDocument(const AppleEvent *message, AppleEvent *reply, UInt32 refcon){#pragma unused(reply, refcon)  OSErr       err;  OSErr       ignoreErr;  AEDescList  docList;  /*open the specified documents*/  docList.dataHandle = nil;  err = AEGetParamDesc(message, keyDirectObject, typeAEList, &amp;docList);  if (err == noErr)  {    err = OpenWindowsForAEDescItems( docList );  }    ignoreErr = AEDisposeDesc(&amp;docList);    return err;}// ---------------------------------------------------------------------------//    OpenWindowsForAEDescItems// ---------------------------------------------------------------------------static OSErr OpenWindowsForAEDescItems(AEDescList descList){  OSErr err = noErr;  FSSpec fileSpec;  long index;  long itemsInList = 0;  AEKeyword keyword;  DescType actualType;  Size actualSize;  Boolean isLastItem;    EXITIFERR( err = AECountItems( &amp;descList, &amp;itemsInList ) );    for( index = 1; index &lt;= itemsInList; index++ ) {    EXITIFERR( err = AEGetNthPtr( &amp;descList, index, typeFSS, &amp;keyword, &amp;actualType, &amp;fileSpec,                sizeof(fileSpec), &amp;actualSize ) );        isLastItem = (index == itemsInList);//@@@ should stop if there's an error from docommand    DoCommand(kCommand_OpenFromFSSpec, &amp;fileSpec);  }  exit:  return err;}// ---------------------------------------------------------------------------//    DoAEQuit// ---------------------------------------------------------------------------static pascal OSErr DoAEQuit(const AppleEvent *message, AppleEvent *reply, UInt32 refcon )      {#pragma unused(message, reply, refcon)  DoCommand(kCommand_Quit, NULL);  return noErr;}#endif /* TARGET_OS_MAC */#pragma mark -#pragma mark .----- utils -----// ---------------------------------------------------------------------------//    SetArrowCursor// ---------------------------------------------------------------------------static void SetArrowCursor(void){#if TARGET_API_MAC_CARBON  Cursor arrow;  GetQDGlobalsArrow(&amp;arrow);  SetCursor(&amp;arrow);#else  MacSetCursor(&amp;qd.arrow);#endif}// ---------------------------------------------------------------------------//    MyGetGlobalMouse// ---------------------------------------------------------------------------static void MyGetGlobalMouse(Point *outMouse){  EventRecord  event;//@@@ use GetGlobalMouse in carbon?  #if TARGET_API_MAC_CARBON    EventAvail(0, &amp;event);#else  OSEventAvail(nullEvent, &amp;event);  /* we aren't interested in any events */#endif  *outMouse = event.where;      /* just the mouse position */}// ---------------------------------------------------------------------------//    ShiftKeyDown// ---------------------------------------------------------------------------static Boolean ShiftKeyDown(void){#if TARGET_OS_MAC &amp;&amp; !TARGET_API_MAC_CARBON  return (*(char *)0x17b &amp; 1) ? true : false;#else  MacKeyMap  keys;  GetKeys(keys);  return (keys[7] &amp; 1) ? true : false;#endif}// ---------------------------------------------------------------------------//    CapsLockDown// ---------------------------------------------------------------------------static Boolean CapsLockDown(void){#if TARGET_OS_MAC &amp;&amp; !TARGET_API_MAC_CARBON  return (*(char *)0x17b &amp; 2) ? true : false;#else  MacKeyMap  keys;  GetKeys(keys);  return (keys[7] &amp; 2) ? true : false;#endif}// ---------------------------------------------------------------------------//    OptionKeyDown// ---------------------------------------------------------------------------static Boolean OptionKeyDown(void){#if TARGET_OS_MAC &amp;&amp; !TARGET_API_MAC_CARBON  return (*(char *)0x17b &amp; 4) ? true : false;#else  MacKeyMap  keys;  GetKeys(keys);  return (keys[7] &amp; 4) ? true : false;#endif}// ---------------------------------------------------------------------------//    ControlKeyDown// ---------------------------------------------------------------------------static Boolean ControlKeyDown(void){#if TARGET_OS_MAC &amp;&amp; !TARGET_API_MAC_CARBON  return (*(char *)0x17b &amp; 8) ? true : false;#else  MacKeyMap  keys;  GetKeys(keys);  return (keys[7] &amp; 8) ? true : false;#endif}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/usher/listing2.html%3Fid%3DDTS10001057-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/usher/listing2.html%3Fid%3DDTS10001057-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/usher/listing2.html%3Fid%3DDTS10001057-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>