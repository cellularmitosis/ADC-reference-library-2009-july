<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Make QTVR Panorama - /CUtils.cp</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxQuickTime-date.html">QuickTime</a> &gt; <A HREF="javascript:location.replace('index.html');">Make QTVR Panorama</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/QuickTime/index.html" target="_blank">Reference Library > QuickTime</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Make QTVR Panorama</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/CUtils.cp</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/CApp.cp</option>
<option value="listing2.html">/CApp.h</option>
<option value="listing3.html">/CBeachBall.cp</option>
<option value="listing4.html">/CBeachBall.h</option>
<option value="listing5.html">/CKeyFilters.cp</option>
<option value="listing6.html">/CKeyFilters.h</option>
<option value="listing7.html">/CLogConsole.cp</option>
<option value="listing8.html">/CMovieMaker.cp</option>
<option value="listing9.html">/CMovieMaker.h</option>
<option value="listing10.html">/CPict2VRWindow.cp</option>
<option value="listing11.html">/CPict2VRWindow.h</option>
<option value="listing12.html">/CPreferences.cp</option>
<option value="listing13.html">/CPreferences.h</option>
<option value="listing14.html">/CPrefsWindow.cp</option>
<option value="listing15.html">/CPrefsWindow.h</option>
<option value="listing16.html">/CUtils.cp</option>
<option value="listing17.html">/CUtils.h</option>
<option value="listing18.html">/QTVRPanoAuthoring.h</option>
<option value="listing19.html">/ToDoHistory.h</option></select>
				</p>
				</form>
				<p><strong><a href="Make_QTVR_Panorama.zip">Download Sample</a></strong> (&#147;Make_QTVR_Panorama.zip&#148;, 233.0K)<BR>
<strong><a href="Make_QTVR_Panorama.dmg">Download Sample</a></strong> (&#147;Make_QTVR_Panorama.dmg&#148;, 312.5K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  Random and sundry error, file and path name utilities    Created 29 Jan 1996 by EGH    Copyright &copy; 1996, Apple Computer, Inc. All rights reserved.*/#include &lt;FixMath.h&gt;#include &lt;fp.h&gt;#include &lt;stdio.h&gt;#include &lt;String_Utils.h&gt;#include &quot;CApp.h&quot;#include &quot;CUtils.h&quot;/* GetFullPathName  Get the full path name of the passed file, but force its length to fit into maxSize.  It is obviously more desirable to not restrict its length, but in this case we desire  this and &quot;elipsize&quot; the string by removing characters from the center.*/void GetFullPathName(  const FSSpec *fileSpec,  Str255 outPathName,  short maxSize){    // force an upper limit to what will fit in a Str255  if (maxSize &gt; sizeof (Str255) - 1)    maxSize = sizeof (Str255) - 1;    Int16 pathLen;  Handle pathH;  OSErr err = FSpGetFullPath(fileSpec, &amp;pathLen, &amp;pathH);  if (err == noErr)  {    ElipsedPathNameH(pathH, maxSize, outPathName, '\xC9');    ::DisposeHandle(pathH);  }  else  {      // no memory (?!) so just copy the file's name    CopyPStr(fileSpec-&gt;name, outPathName);  }}/* FSpGetFullPath  Grok the full the path name of the passed file.  Nabbed from More Files 1.4.1 from my colleagues at Apple Developer Technical Support.*/OSErr FSpGetFullPath(  const FSSpec *spec,  short *fullPathLength,  Handle *fullPath){  OSErr    result;  FSSpec    tempSpec;  CInfoPBRec  pb;    /* Make a copy of the input FSSpec that can be modified */  BlockMoveData(spec, &amp;tempSpec, sizeof(FSSpec));    if ( tempSpec.parID == fsRtParID )  {    /* The object is a volume */        /* Add a colon to make it a full pathname */    ++tempSpec.name[0];    tempSpec.name[tempSpec.name[0]] = ':';        /* We're done */    result = PtrToHand(&amp;tempSpec.name[1], fullPath, tempSpec.name[0]);  }  else  {    /* The object isn't a volume */        /* Put the object name in first */    result = PtrToHand(&amp;tempSpec.name[1], fullPath, tempSpec.name[0]);    if ( result == noErr )    {      /* Get the ancestor directory names */      pb.dirInfo.ioNamePtr = tempSpec.name;      pb.dirInfo.ioVRefNum = tempSpec.vRefNum;      pb.dirInfo.ioDrParID = tempSpec.parID;      do  /* loop until we have an error or find the root directory */      {        pb.dirInfo.ioFDirIndex = -1;        pb.dirInfo.ioDrDirID = pb.dirInfo.ioDrParID;        result = PBGetCatInfoSync(&amp;pb);        if ( result == noErr )        {          /* Append colon to directory name */          ++tempSpec.name[0];          tempSpec.name[tempSpec.name[0]] = ':';                    /* Add directory name to beginning of fullPath */          (void) Munger(*fullPath, 0, NULL, 0, &amp;tempSpec.name[1], tempSpec.name[0]);          result = MemError();        }      } while ( (result == noErr) &amp;&amp; (pb.dirInfo.ioDrDirID != fsRtDirID) );    }  }  if ( result == noErr )  {    /* Return the length */    *fullPathLength = GetHandleSize(*fullPath);  }  else  {    /* Dispose of the handle and return NULL and zero length */    DisposeHandle(*fullPath);    *fullPath = NULL;    *fullPathLength = 0;  }    return result;}/* ElipsedPathNameH    Gracefully degrade the passed string by removing characters from the center  until it fits into the passed maximum width. Inserts an elipsis character to indicate this.*/void ElipsedPathNameH(  Handle pathNameH,  short maxWidth,  Str255 elipsedName,  char elipsis){  long pNameLen = GetHandleSize(pathNameH);  char saveState = HGetState(pathNameH);  Ptr pathNameP = *pathNameH;  HLock(pathNameH);  if ((pNameLen &lt;= 255) &amp;&amp; (TextWidth(pathNameP, 0, (short)pNameLen) &lt;= maxWidth))  {    BlockMove(pathNameP, (Ptr)(elipsedName + 1), pNameLen);    *elipsedName = (char)pNameLen;  }  else  {    long i, j, width = CharWidth(elipsis);    char rightChars[128];    maxWidth /= 2;    for (i = 1; (i &lt; pNameLen) &amp;&amp; (i &lt; 128); i++)    {      char nextChar = pathNameP[i - 1];      width += CharWidth(nextChar);      if (width &gt;= maxWidth) break;      elipsedName[i] = nextChar;    }    width = 0;    for (j = pNameLen - 1, *rightChars = 0; (j &gt; i) &amp;&amp; (*rightChars &lt; 128); j--)    {      char nextChar = pathNameP[j];      width += CharWidth(nextChar);      if (width &gt;= maxWidth) break;      rightChars[++*rightChars] = nextChar;    }    elipsedName[(*elipsedName = (char)i)] = elipsis;    while (*rightChars)    {      elipsedName[++*elipsedName] = rightChars[(*rightChars)--];    }  }  HSetState(pathNameH, saveState);}/* ElipsedPathName  Same as ElipsedPathNameH except uses Str255's rather than a handle.*/void ElipsedPathName(  Str255 pathName,  short maxWidth,  Str255 elipsedName,  char elipsis){  Int16 pNameLen = pathName[0];  UInt8 *pathNameP = &amp;pathName[1];  Int16 textWidth;    textWidth = ::StringWidth(pathName);  if ((pNameLen &lt;= 255) &amp;&amp; (textWidth &lt;= maxWidth))  {    BlockMove(pathNameP, (Ptr)(elipsedName + 1), pNameLen);    *elipsedName = (char)pNameLen;  }  else  {    long i, j, width = CharWidth(elipsis);    char rightChars[128];    maxWidth /= 2;    for (i = 1; (i &lt; pNameLen) &amp;&amp; (i &lt; 128); i++)    {      char nextChar = pathNameP[i - 1];      width += CharWidth(nextChar);      if (width &gt;= maxWidth) break;      elipsedName[i] = nextChar;    }    width = 0;    for (j = pNameLen - 1, *rightChars = 0; (j &gt; i) &amp;&amp; (*rightChars &lt; 128); j--)    {      char nextChar = pathNameP[j];      width += CharWidth(nextChar);      if (width &gt;= maxWidth) break;      rightChars[++*rightChars] = nextChar;    }    elipsedName[(*elipsedName = (char)i)] = elipsis;    while (*rightChars)    {      elipsedName[++*elipsedName] = rightChars[(*rightChars)--];    }  }}/* SetSizedDescriptor    Set the descriptor of the passed pane, but gracefully degrade the  length of the string to physically fit into the pane's frame.*/void SetSizedDescriptor(  LWindow *parent,  PaneIDT inPaneID,  StringPtr inDescStr){  LCaption *pane = (LCaption *)parent-&gt;FindPaneByID(inPaneID);  pane-&gt;FocusDraw(); // just to be in a valid port  ResIDT texttraitsID = pane-&gt;GetTextTraitsID();  UTextTraits::SetPortTextTraits(texttraitsID);  SDimension16 panesize;  pane-&gt;GetFrameSize(panesize);  Str255 elipStr;  ::ElipsedPathName(inDescStr, panesize.width, elipStr, '\xC9');  pane-&gt;SetDescriptor(elipStr);}/* ReportError  Report an error to the user.*/void ReportError(  ExceptionCode inErr,  Int16 inStrIndex){  Str255    errStr = &quot;\pAn error occurred.&quot;,    errNumStr,    errDescStr;  Int16 descIndex;    gApp-&gt;BugUserTilSwitchedIn();      // make some attempt to provide a description of the error  switch (inErr)  {    case iMemFullErr:      descIndex = err_NotEnufMemory;      break;          case notEnoughMemoryErr:      descIndex = err_NotEnufPhysicalMemory;      break;        case dirFulErr:    case dskFulErr:      descIndex = err_DiskFull;      break;        case ioErr:    case fnOpnErr:    case eofErr:    case fnfErr:    case nsvErr:      descIndex = err_DiskError;      break;        case resNotFound:      descIndex = err_NoResource;        default:      descIndex = err_NoDescription;  }  ::GetIndString(errDescStr, STRx_ErrorDescs, descIndex);    ::SetCursor(&amp;qd.arrow);    ::GetIndString(errStr, STRx_Errors, inStrIndex);  ::NumToString(inErr, errNumStr);  ::ParamText(errStr, errNumStr, errDescStr, &quot;\p&quot;);  ::StopAlert(ALRT_Error, nil);}OSErr GetFileParent(  FSSpec *fileSpec,  FSSpec *parentSpec){  CInfoPBRec pBlock;  OSErr result;    pBlock.dirInfo.ioVRefNum = fileSpec-&gt; vRefNum;  pBlock.dirInfo.ioDrDirID = fileSpec-&gt; parID;  pBlock.dirInfo.ioNamePtr = parentSpec-&gt; name;  parentSpec-&gt; name[0] = 0;  pBlock.dirInfo.ioFDirIndex = -1;     result = PBGetCatInfoSync(&amp;pBlock);    if (result == noErr)  {    parentSpec-&gt; vRefNum = fileSpec-&gt; vRefNum;    parentSpec-&gt; parID = pBlock.dirInfo.ioDrParID;  }    return result;}const Int32 kPictFileHeaderSize = 512;#pragma options align=mac68ktypedef struct PICT2Xheader {  short  version;  short  reserved;  Fixed  hRes;  Fixed  vRes;  Rect  srcRect;  long   reserved2;} PICT2Xheader;#pragma options align=reset/* ReadPictFrame  Read a pict's rectangle.*/void ReadPictFrame(  const FSSpec &amp;inPictSpec,  Rect &amp;outPictRect){  LFile pictFile(inPictSpec);    pictFile.OpenDataFork(fsRdPerm); // LFile will close the file upon failure      // picture begins past the header  OSErr result = ::SetFPos(pictFile.GetDataForkRefNum(), fsFromStart, kPictFileHeaderSize);  ThrowIfOSErr_(result);      // read a PICT2Xheader structure at 16 bytes into the pict  char pict[sizeof (PICT2Xheader) + 16];  Int32 count = sizeof (PICT2Xheader) + 16;  result = ::FSRead(pictFile.GetDataForkRefNum(), &amp;count, &amp;pict);  ThrowIfOSErr_(result);    PICT2Xheader *pic2XHeader;  pic2XHeader = (PICT2Xheader *)&amp;(((Ptr)(pict))[16]);  if (pic2XHeader-&gt;version == -2)  { // extended type 2    outPictRect = pic2XHeader-&gt;srcRect;  }  else    outPictRect = ((Picture *)pict)-&gt;picFrame;    pictFile.CloseDataFork();}void FixedToStr(  Fixed inFixValue,  Str255 outStr){    // convert to double_t, then use the dec routines  double_t value = Fix2X(inFixValue);  decform f;  f.style = FIXEDDECIMAL;  f.digits = 1;  decimal dec;  num2dec(&amp;f, value, &amp;dec);  dec2str(&amp;f, &amp;dec, (char *)outStr);  c2pstr((char *)outStr);      // alternate method using the std C lib  //sprintf((char *)outStr, &quot;%.1lf&quot;, value);  //c2pstr((char *)outStr);}Fixed StrToFixed(  StringPtr str){  Fixed theNum;  long lower,upper;  short len,i,j, decPoint;  float fraction;  Boolean  neg;    len = str[0];    for (i=1; i&lt;= len; i++)    if (str[i] == '.')      break;    // No decimal point  if (i &gt;= len)  {    StringToNum(str, &amp;theNum);    return (theNum &lt;&lt; 16);  }      // Make into two strings  decPoint = i;  str[0] = i-1;  str[decPoint] = len-i;    StringToNum((StringPtr) str, &amp;upper);  if ((neg = (int)(upper &lt; 0)) != 0)    upper = - upper;  StringToNum((StringPtr) str+decPoint, &amp;lower);    fraction = lower;  for (j = 1; j &lt;= (len-i) ; j++)    fraction = fraction / 10;    lower = fraction * 0x10000;      // Restore orig string  str[0] = len;  str[decPoint] = '.';  return ((neg?-1:1)*((upper &lt;&lt; 16) + lower));}/* FindCodecName  Search the list of codecs for a name describing the passed codec.*/Boolean FindCodecName(  StringPtr outName,  CodecType inCodec){  Boolean found = false;    CodecNameSpecListPtr cnsp;  OSErr result = ::GetCodecNameList(&amp;cnsp, 1);  if (result == noErr)  {    for (Int32 i = 0; i &lt; cnsp-&gt;count; i++)    {      if (cnsp-&gt;list[i].cType == inCodec)      {        found = true; // yay        CopyPStr(cnsp-&gt;list[i].typeName, outName);        break;      }    }        ::DisposeCodecNameList(cnsp);  }    return found;}/* SetCompressionText  Set the passed pane's descriptor to text describing the passed image compression  settings.*/void SetCompressionText(  LPane *inPane,  CodecType inCodec,  CodecQ inSpatialQuality){  if (inPane != nil)  {      // attempt to find a name for the current codec    Str255 str;    if (!FindCodecName(str, inCodec))    {        // put something in the string, however cryptic      str[0] = 7;      str[1] = '\'';      *(OSType *)&amp;str[2] = inCodec;      str[6] = '\'';      str[7] = ' ';    }    else      str[++str[0]] = ' ';          // create a description of the compression quality    Str255 qstr;    if (inSpatialQuality &gt;= codecLosslessQuality)      CopyPStr(&quot;\pLossless&quot;, qstr);    else if (inSpatialQuality &gt;= codecMaxQuality)      CopyPStr(&quot;\pMaximum&quot;, qstr);    else if (inSpatialQuality &gt;= codecHighQuality)      CopyPStr(&quot;\pHigh&quot;, qstr);    else if (inSpatialQuality &gt;= codecNormalQuality)      CopyPStr(&quot;\pNormal&quot;, qstr);    else if (inSpatialQuality &gt; codecMinQuality)      CopyPStr(&quot;\pLow&quot;, qstr);    else      CopyPStr(&quot;\pMinimum&quot;, qstr);    ConcatPStr(str, qstr);    ConcatPStr(str, &quot;\p (&quot;);    ::NumToString((((((float)inSpatialQuality)+.5) / 1024.0) * 100), qstr);    ConcatPStr(str, qstr);    ConcatPStr(str, &quot;\p)&quot;);        inPane-&gt;SetDescriptor(str);  }}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Make_QTVR_Panorama/listing16.html%3Fid%3DDTS10000339-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Make_QTVR_Panorama/listing16.html%3Fid%3DDTS10000339-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Make_QTVR_Panorama/listing16.html%3Fid%3DDTS10000339-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>