<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>MoreSCF - /MoreSCF/MoreSCFDigest.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/Networking/index.html">Networking</a> &gt; <a href="../../samplecode/Networking/idxDarwin-date.html">Darwin</a> &gt; <A HREF="javascript:location.replace('index.html');">MoreSCF</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->


	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">MoreSCF</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/MoreSCF/MoreSCFDigest.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/MoreCFQ/MoreCFQ.c</option>
<option value="listing2.html">/MoreCFQ/MoreCFQ.h</option>
<option value="listing3.html">/MoreSCF/MoreSCF.c</option>
<option value="listing4.html">/MoreSCF/MoreSCF.h</option>
<option value="listing5.html">/MoreSCF/MoreSCFCCLScanner.c</option>
<option value="listing6.html">/MoreSCF/MoreSCFCCLScanner.h</option>
<option value="listing7.html">/MoreSCF/MoreSCFDigest.c</option>
<option value="listing8.html">/MoreSCF/MoreSCFDigest.h</option>
<option value="listing9.html">/MoreSCF/MoreSCFHelpers.c</option>
<option value="listing10.html">/MoreSCF/MoreSCFHelpers.h</option>
<option value="listing11.html">/MoreSCF/MoreSCFPortScanner.c</option>
<option value="listing12.html">/MoreSCF/MoreSCFPortScanner.h</option>
<option value="listing13.html">/MoreSCF/MoreSCFTest/MoreSCFTest.c</option>
<option value="listing14.html">/MoreSCF/Read Me About MoreSCF.txt</option>
<option value="listing15.html">/Read Me.txt</option></select>
				</p>
				</form>
				<p><strong><a href="MoreSCF.zip">Download Sample</a></strong> (&#147;MoreSCF.zip&#148;, 126.7K)<BR>
<strong><a href="MoreSCF.dmg">Download Sample</a></strong> (&#147;MoreSCF.dmg&#148;, 191.8K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*
  File:    MoreSCFDigest.c

  Contains:  Routines for working with SC entities.

  Written by:  DTS

  Copyright:  Copyright (c) 2007 by Apple Inc., All Rights Reserved.

  Disclaimer:  IMPORTANT:  This Apple software is supplied to you by Apple Inc.
        (&quot;Apple&quot;) in consideration of your agreement to the following terms, and your
        use, installation, modification or redistribution of this Apple software
        constitutes acceptance of these terms.  If you do not agree with these terms,
        please do not use, install, modify or redistribute this Apple software.

        In consideration of your agreement to abide by the following terms, and subject
        to these terms, Apple grants you a personal, non-exclusive license, under Apple's
        copyrights in this original Apple software (the &quot;Apple Software&quot;), to use,
        reproduce, modify and redistribute the Apple Software, with or without
        modifications, in source and/or binary forms; provided that if you redistribute
        the Apple Software in its entirety and without modifications, you must retain
        this notice and the following text and disclaimers in all such redistributions of
        the Apple Software.  Neither the name, trademarks, service marks or logos of
        Apple Inc. may be used to endorse or promote products derived from the
        Apple Software without specific prior written permission from Apple.  Except as
        expressly stated in this notice, no other rights or licenses, express or implied,
        are granted by Apple herein, including but not limited to any patent rights that
        may be infringed by your derivative works or by other works in which the Apple
        Software may be incorporated.

        The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE MAKES NO
        WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED
        WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR
        PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN
        COMBINATION WITH YOUR PRODUCTS.

        IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR
        CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
        GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
        ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION
        OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT
        (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN
        ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  Change History (most recent first):

$Log: MoreSCFDigest.c,v $
Revision 1.13  2006/03/27 14:42:20         
Eliminate high-bit set characters.

Revision 1.12  2006/03/24 15:44:26         
Updated copyright.

Revision 1.11  2006/03/24 12:38:34         
Eliminate &quot;pascal&quot; keyword.

Revision 1.10  2006/03/24 11:29:58         
Eliminated &quot;MoreSetup.h&quot; to make it easier for folks to copy MIB source into their projects.

Revision 1.9  2003/04/14 15:51:21         
Use CFQAllocate/Deallocate to prevent &quot;malloc(0) returns NULL&quot; problems.

Revision 1.8  2003/02/26 20:51:59         
&lt;rdar://problem/3183087&gt; Added support for V.92 modem hold.

Revision 1.7  2003/02/26 12:14:28         
In MoreSCCreateIPv4Entity, digest-&gt;configMethod can't be NULL, so let's assert that.

Revision 1.6  2002/11/25 16:49:41         
Changes to build in Project Builder without warnings.

Revision 1.5  2002/11/14 20:16:31         
Tidy up the debug checking in MoreSCCreateIPv4Entity and add a way to disable it for the benefit of MoreSCNewSet.

Revision 1.4  2002/11/09 00:01:55         
Include our prototype early to flush out any missing dependencies. Convert nil to NULL. Convert MoreAssertQ to assert.

Revision 1.3  2002/08/14 16:33:50         
Added support for v 1.3 interfaces changes.  Certain hardwired defaults now get different values on 10.2 and later.  Changed some asserts to fprintfs in MoreSCCreateIPv4Entity because changes for post 10.1 compatibility trigger them.

Revision 1.2  2002/01/22 06:19:42         
Changes to support variant field in MoreSCInterfaceDigest. Also adapted to minor CFQ changes.

Revision 1.1  2002/01/16 22:52:28         
First checked in.


*/

/////////////////////////////////////////////////////////////////

// Our prototypes

#include &quot;MoreSCFDigest.h&quot;

// System interfaces

#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;string.h&gt;

// MIB Interfaces

#include &quot;MoreCFQ.h&quot;
#include &quot;MoreSCFPortScanner.h&quot;
#include &quot;MoreSCF.h&quot;

/////////////////////////////////////////////////////////////////

#if MAC_OS_X_VERSION_MIN_REQUIRED &gt;= MAC_OS_X_VERSION_10_4 &amp;&amp; ! MORE_SCF_NO_DEPRECATION_WARNINGS
    #warning MoreSCF is deprecated if you are building for 10.4 or later.
#endif

/////////////////////////////////////////////////////////////////
#pragma mark ***** Utilities

extern OSStatus MoreSCFCreateStringWithMacAddress(const UInt8 *macAddr, CFStringRef *result)
  // See comment in header.
  //
  // This code was stolen from Robert's code (CreateMACFromData in &quot;MoreSCFPortScanner.c&quot;.  
  // I should unify these eventually.
{
  OSStatus err;
    const UInt8 *p;
    char s [19];        // mac addresses are 6 bytes long, which translates to 18 chars.
    char *cp = &amp;s[0];
    int len = 6;
    
    assert(macAddr != NULL);
  assert( result != NULL);
  assert(*result == NULL);

    // add digits in pairs with colon separators

  p = macAddr;
    while ( len-- )
        cp += sprintf( cp, &quot;%2.2x:&quot;, *p++ );

    // terminate string

    s[17] = '\0';

  err = noErr;
    *result = CFStringCreateWithCString(NULL, s, kCFStringEncodingASCII);
    if (*result == NULL) {
      err = coreFoundationUnknownErr;
    }

  assert( (err == noErr) == (*result != NULL) );

    return err;
}

extern OSStatus MoreSCFStringToMacAddress(CFStringRef cfStr, UInt8 *macAddr)
  // See comment in header.
{
  OSStatus err;
  char buf[ (6 * 2) + 5 + 1 ];    // 6 hex bytes (2 chars each) + 5 separators + null
  int macAsInts[6];
  
  assert(cfStr   != NULL);
  assert(macAddr != NULL);
  
  err = noErr;
  if ( ! CFStringGetCString(cfStr, buf, sizeof(buf), kCFStringEncodingASCII) ) {
    err = coreFoundationUnknownErr;
  }
  if (err == noErr) {
    if ( sscanf(buf, &quot;%02x:%02x:%02x:%02x:%02x:%02x&quot;, 
              &amp;macAsInts[0], &amp;macAsInts[1], &amp;macAsInts[2], 
              &amp;macAsInts[3], &amp;macAsInts[4], &amp;macAsInts[5]) != 6 ) {
      err = -1;
    }
  }
  if (err == noErr) {
    int i;
    
    for (i = 0; i &lt; 6; i++) {
      assert((macAsInts[i] &gt;= 0) &amp;&amp; (macAsInts[i] &lt; 256));
      macAddr[i] = (UInt8) macAsInts[i];
    }
  }

  return err;
}

extern OSStatus MoreSCFCreateStringWithInetAddress(in_addr addr, CFStringRef *result)
  // See comment in header.
{
  OSStatus   err;
  const char *addrStr;

  assert( result != NULL);
  assert(*result == NULL);

  err = noErr;  
  addrStr = inet_ntoa(addr);
  *result = CFStringCreateWithCString(NULL, addrStr, kCFStringEncodingASCII);
  if (*result == NULL) {
    err = coreFoundationUnknownErr;
  }

  assert( (err == noErr) == (*result != NULL) );

  return err;
}

extern OSStatus MoreSCFCreateArrayWithInetAddresses(ItemCount addrCount, const in_addr *addresses, CFArrayRef *result)
  // See comment in header.
{
  OSStatus       err;
  ItemCount       index;
  CFMutableArrayRef   addressesArray;
  
  assert( (addrCount == 0) || (addresses != NULL) );
  assert( result != NULL);
  assert(*result == NULL);
  
  addressesArray = NULL;
  err = CFQArrayCreateMutable(&amp;addressesArray);
  if (err == noErr) {
    for (index = 0; index &lt; addrCount; index++) {
      CFStringRef value;
      
      value = NULL;
      err = MoreSCFCreateStringWithInetAddress(addresses[index], &amp;value);
      if (err == noErr) {
        CFArrayAppendValue(addressesArray, value);
      }
      CFQRelease(value);
      if (err != noErr) {
        break;
      }
    }
  }

  if (err != noErr) {
    CFQRelease(addressesArray);
    addressesArray = NULL;
  }
  *result = addressesArray;

  assert( (err == noErr) == (*result != NULL) );
  
  return err;
}

extern OSStatus MoreSCFCopyEncodedPPPPassword(CFStringRef password, CFDataRef *encodedPassword)
  // See comment in header.
{
  OSStatus err;
  CFIndex  numUniChars;
  UniChar *uniChars;
  
  assert(password != NULL);
  assert( encodedPassword != NULL);
  assert(*encodedPassword == NULL);

  uniChars = NULL;
  
  // Can't use CFStringCreateExternalRepresentation because, according to the 
  // documentation, it always includes a byte order mark (BOM) character.
  
  numUniChars = CFStringGetLength(password);
  err = CFQAllocate(numUniChars * sizeof(UniChar), (void **) &amp;uniChars);
  if (err == noErr) {
    CFStringGetCharacters(password, CFRangeMake(0, numUniChars), uniChars);
    
    *encodedPassword = CFDataCreate(NULL, (UInt8 *) uniChars, numUniChars * (CFIndex) sizeof(UniChar));
    if (*encodedPassword == NULL) {
      err = coreFoundationUnknownErr;
    }
  }
  
  CFQDeallocate(uniChars);
  
  assert( (err == noErr) == (*encodedPassword != NULL) );
  return err;
}

/////////////////////////////////////////////////////////////////
#pragma mark ***** Global Entities

extern OSStatus MoreSCCreateIPv4GlobalEntity(const MoreSCIPv4GlobalDigest *digest, CFDictionaryRef *entity)
  // See comment in header.
{
    #pragma unused(digest)
  OSStatus err;
  CFMutableDictionaryRef result;
  
  assert( digest != NULL);
  assert( entity != NULL);
  assert(*entity == NULL);
  
  result = NULL;
  err = CFQDictionaryCreateMutable(&amp;result);
  if ( (err == noErr) &amp;&amp; (MoreSCGetSystemVersion() &lt; 0x01050) ) {
    err = CFQDictionarySetNumber(result, kSCPropNetPPPOverridePrimary, 0);
  }
  if (err == noErr) {
    CFArrayRef serviceOrder;
    
    serviceOrder = CFArrayCreate(NULL, NULL, 0, &amp;kCFTypeArrayCallBacks);
    if (serviceOrder == NULL) {
      err = coreFoundationUnknownErr;
    }
    CFDictionaryAddValue(result, kSCPropNetServiceOrder, serviceOrder);
    CFQRelease(serviceOrder);
  }
  
  if (err != noErr) {
    CFQRelease(result);
    result = NULL;
  }
  *entity = result;
  
  return err;
}

extern OSStatus MoreSCCreateNetInfoGlobalEntity(const MoreSCNetInfoGlobalDigest *digest, CFDictionaryRef *entity)
  // See comment in header.
{
    #pragma unused(digest)
  OSStatus err;
  CFMutableDictionaryRef result;
  
  assert( digest != NULL);
  assert( entity != NULL);
  assert(*entity == NULL);
  
  result = NULL;
  err = CFQDictionaryCreateMutable(&amp;result);
  // No useful values in MoreSCNetInfoGlobalDigest, something 
  // that I should probably address in the future.
  
  *entity = result;
  
  return err;
}

extern OSStatus MoreSCCreateGlobalEntity(CFStringRef protocol, const MoreSCGlobalDigest *digest, CFDictionaryRef *entity)
  // See comment in header.
{
  OSStatus err;
  
  assert(protocol != NULL);
  assert(digest != NULL);
  assert( entity != NULL);
  assert(*entity == NULL);
  
  // Call the appropriate protocol-specific routine based on the 
  // protocol type supplied.

  if (        CFEqual(protocol, kSCEntNetIPv4) ) {
    err = MoreSCCreateIPv4GlobalEntity(&amp;digest-&gt;ipv4, entity);
  } else if ( CFEqual(protocol, kSCEntNetNetInfo) ) {
    err = MoreSCCreateNetInfoGlobalEntity(&amp;digest-&gt;netInfo, entity);
  } else {
    assert(false);
    err = -1;
  }
  return err;
}

/////////////////////////////////////////////////////////////////
#pragma mark ***** Service Entities

extern OSStatus MoreSCCreateInterfaceEntity(const MoreSCInterfaceDigest *digest, CFDictionaryRef *entity)
  // See comment in header.
{
  OSStatus err;
  CFMutableDictionaryRef result;
  
  assert( digest != NULL);
  assert( entity != NULL);
  assert(*entity == NULL);
  
  result = NULL;
  err = CFQDictionaryCreateMutable(&amp;result);
  if (err == noErr) {
    assert(digest-&gt;deviceName != NULL);
    assert(digest-&gt;userDefinedName != NULL);
    CFDictionaryAddValue(result, kSCPropNetInterfaceDeviceName, digest-&gt;deviceName);
    CFDictionaryAddValue(result, kSCPropUserDefinedName, digest-&gt;userDefinedName);
    assert(
               CFEqual(digest-&gt;hardware, kSCEntNetAirPort) 
            || CFEqual(digest-&gt;hardware, kSCEntNetEthernet) 
            || CFEqual(digest-&gt;hardware, kSCEntNetModem) 
            || CFEqual(digest-&gt;hardware, kSCEntNetFireWire) 
        );
    CFDictionaryAddValue(result, kSCPropNetInterfaceHardware, digest-&gt;hardware);
    if ( CFEqual(digest-&gt;hardware, kSCEntNetModem) ) {
      if (digest-&gt;supportsHold) {
        err = CFQDictionarySetNumber(result, kSCPropNetInterfaceSupportsModemOnHold, 1);
      }
    }
  }
  if (err == noErr) {
    assert( CFEqual(digest-&gt;type, kSCValNetInterfaceTypeEthernet) 
            ||   CFEqual(digest-&gt;type, kSCValNetInterfaceTypePPP) 
            ||   CFEqual(digest-&gt;type, kSCValNetInterfaceTypeFireWire) 
        );
    CFDictionaryAddValue(result, kSCPropNetInterfaceType, digest-&gt;type);
    if (digest-&gt;subType != NULL) {
      assert( CFEqual(digest-&gt;type, kSCValNetInterfaceTypePPP) );
      assert(   CFEqual(digest-&gt;subType, kSCValNetInterfaceSubTypePPPSerial) 
            ||   CFEqual(digest-&gt;subType, kSCValNetInterfaceSubTypePPPoE) );
      CFDictionaryAddValue(result, kSCPropNetInterfaceSubType, digest-&gt;subType);
    }
    if (digest-&gt;variant != NULL) {
      assert( CFEqual(digest-&gt;hardware, kSCEntNetModem) );
      CFDictionaryAddValue(result, kMoreSCPropNetInterfaceHardwareVariant, digest-&gt;variant);
    }
  }
  
  if (err != noErr) {
    CFQRelease(result);
    result = NULL;
  }
  *entity = result;
  
  assert( (err == noErr) == (*entity != NULL) );
  
  return err;
}

static OSStatus AddProxy(CFMutableDictionaryRef dict, 
                            CFStringRef enableKey, CFStringRef proxyKey,   CFStringRef portKey, 
              Boolean enableValue,   CFStringRef proxyValue, UInt16 portValue)
  // Adds a proxy entry to dict.  The entry consists of up to three 
  // key/value pairs.  The enable property is a number that 
  // indicates whether the proxy is to be used.  It is always 
  // added.  The other two properties, proxy and port, are optional 
  // (controlled by whether their values are NULL or 0).
{
  OSStatus err;
  
  assert(dict        != NULL);
  assert(enableKey   != NULL);
  
    // On 10.4 and later, we only set proxy keys if they're a non-default value.
    
    err = 0;
    if ( (MoreSCGetSystemVersion() &lt; 0x01030) || enableValue || (proxyValue != NULL) || (portValue != 0) ) {
        err = CFQDictionarySetNumber(dict, enableKey, enableValue);
        if (err == noErr &amp;&amp; proxyValue != NULL) {
            CFDictionaryAddValue(dict, proxyKey, proxyValue);
        }
        if (err == noErr &amp;&amp; portValue != 0) {
            err = CFQDictionarySetNumber(dict, portKey, portValue);
        }
    }
  
  return err;
}

extern OSStatus MoreSCCreateProxiesEntity(const MoreSCProxiesDigest *digest, CFDictionaryRef *entity)
  // See comment in header.
{
  OSStatus err;
  CFMutableDictionaryRef result;
  
  assert( digest != NULL);
  assert( entity != NULL);
  assert(*entity == NULL);

  result = NULL;
  err = CFQDictionaryCreateMutable(&amp;result);
  
  // Add the &quot;ExceptionsList&quot; property, if supplied.
  
  if (err == noErr) {
    if (digest-&gt;exceptionsList != NULL) {
      CFDictionaryAddValue(result, kSCPropNetProxiesExceptionsList, digest-&gt;exceptionsList);
    }
    err = CFQDictionarySetNumber(result, kSCPropNetProxiesFTPPassive, digest-&gt;ftpPassive);
  }
  
  // Add properties for each of the 6 possible proxies, if supplied.
  
  if (err == noErr) {
    err = AddProxy(result, kSCPropNetProxiesFTPEnable, kSCPropNetProxiesFTPProxy, kSCPropNetProxiesFTPPort, 
            digest-&gt;ftpEnable, digest-&gt;ftpProxy, digest-&gt;ftpPort);
  }
  if (err == noErr) {
    err = AddProxy(result, kSCPropNetProxiesGopherEnable, kSCPropNetProxiesGopherProxy, kSCPropNetProxiesGopherPort, 
            digest-&gt;gopherEnable, digest-&gt;gopherProxy, digest-&gt;gopherPort);
  }
  if (err == noErr) {
    err = AddProxy(result, kSCPropNetProxiesHTTPEnable, kSCPropNetProxiesHTTPProxy, kSCPropNetProxiesHTTPPort, 
            digest-&gt;httpEnable, digest-&gt;httpProxy, digest-&gt;httpPort);
  }
  if (err == noErr) {
    err = AddProxy(result, kSCPropNetProxiesHTTPSEnable, kSCPropNetProxiesHTTPSProxy, kSCPropNetProxiesHTTPSPort, 
            digest-&gt;httpsEnable, digest-&gt;httpsProxy, digest-&gt;httpsPort);
  }
  if (err == noErr) {
    err = AddProxy(result, kSCPropNetProxiesRTSPEnable, kSCPropNetProxiesRTSPProxy, kSCPropNetProxiesRTSPPort, 
            digest-&gt;rtspEnable, digest-&gt;rtspProxy, digest-&gt;rtspPort);
  }
  if (err == noErr) {
    err = AddProxy(result, kSCPropNetProxiesSOCKSEnable, kSCPropNetProxiesSOCKSProxy, kSCPropNetProxiesSOCKSPort, 
            digest-&gt;socksEnable, digest-&gt;socksProxy, digest-&gt;socksPort);
  }
    
    // Misc stuff
    
    if ( (err == noErr) &amp;&amp; (MoreSCGetSystemVersion() &gt;= 0x01040) ) {
    err = CFQDictionarySetNumber(result, kSCPropNetProxiesExcludeSimpleHostnames, digest-&gt;excludeSimpleHostnames);
        if (err == noErr) {
            err = CFQDictionarySetNumber(result, kSCPropNetProxiesProxyAutoDiscoveryEnable, digest-&gt;autoDiscoveryEnable);
        }
    }
  
  if (err != noErr) {
    CFQRelease(result);
    result = NULL;
  }
  *entity = result;
  
  return err;
}

extern OSStatus MoreSCCreateAppleTalkEntity(const MoreSCAppleTalkDigest *digest, CFDictionaryRef *entity)
  // See comment in header.
{
  OSStatus err;
  CFMutableDictionaryRef result;
  
  assert( digest != NULL);
  assert( entity != NULL);
  assert(*entity == NULL);

  result    = NULL;
  
  err = CFQDictionaryCreateMutable(&amp;result);
  if (err == noErr) {
    assert( CFEqual(digest-&gt;configMethod, kSCValNetAppleTalkConfigMethodNode) );
    CFDictionaryAddValue(result, kSCPropNetAppleTalkConfigMethod, digest-&gt;configMethod);

    if (digest-&gt;defaultZone != NULL) {
      CFDictionaryAddValue(result, kSCPropNetAppleTalkDefaultZone, digest-&gt;defaultZone);
    }

    if (digest-&gt;manual) {
      err = CFQDictionarySetNumber(result, kSCPropNetAppleTalkNetworkID, digest-&gt;networkID);
      if (err == noErr) {
        err = CFQDictionarySetNumber(result, kSCPropNetAppleTalkNodeID, digest-&gt;nodeID);
      }
    }
  }
  if (err == noErr &amp;&amp; ! digest-&gt;active ) {
    err = CFQDictionarySetNumber(result, kSCResvInactive, 1);
  }
  
  if (err != noErr) {
    CFQRelease(result);
    result = NULL;
  }
  *entity = result;
  
  return err;
}

extern OSStatus MoreSCCreateDNSEntity(const MoreSCDNSDigest *digest, CFDictionaryRef *entity)
  // See comment in header.
{
  OSStatus err;
  CFMutableDictionaryRef result;
  ItemCount index;
  
  assert( digest != NULL);
  assert( entity != NULL);
  assert(*entity == NULL);

  result = NULL;
  
  err = CFQDictionaryCreateMutable(&amp;result);
  
  // If the caller supplied a DNS server addresses, add them 
  // to the entity.
  
  if (err == noErr &amp;&amp; digest-&gt;serverAddressesCount &gt; 0) {
    CFArrayRef       addresses;
    
    assert(digest-&gt;serverAddresses != NULL);

    addresses = NULL;
    err = MoreSCFCreateArrayWithInetAddresses(digest-&gt;serverAddressesCount, 
                           digest-&gt;serverAddresses, 
                           &amp;addresses);
    CFDictionaryAddValue(result, kSCPropNetDNSServerAddresses, addresses);

    CFQRelease(addresses);  
  }
  
  // If the caller support a DNS search domains, add each to the entity.
  
  if (err == noErr &amp;&amp; digest-&gt;searchDomainsCount &gt; 0) {
    CFMutableArrayRef   domains;
    
    assert(digest-&gt;searchDomains != NULL);

    domains = NULL;
    
    // I could have used CFArrayCreate here but I wanted to loop through 
    // each element so that I can check for NULL.
    
    err = CFQArrayCreateMutable(&amp;domains);
    if (err == noErr) {
      for (index = 0; index &lt; digest-&gt;searchDomainsCount; index++) {
        assert(digest-&gt;searchDomains[index] != NULL);
        
        CFArrayAppendValue(domains, digest-&gt;searchDomains[index]);
      }
    }
    CFDictionaryAddValue(result, kSCPropNetDNSSearchDomains, domains);

    CFQRelease(domains);  
  }

  if (err != noErr) {
    CFQRelease(result);
    result = NULL;
  }
  *entity = result;
  
  return err;
}

#if !defined(NDEBUG)

  Boolean gMoreSCCreateIPv4EntityDontCheck;

#endif

extern OSStatus MoreSCCreateIPv4Entity(const MoreSCIPv4Digest *digest, CFDictionaryRef *entity)
  // See comment in header.
{
  OSStatus err;
  CFMutableDictionaryRef result;
  
  assert( digest != NULL);
  assert( digest-&gt;configMethod != NULL);
  assert( entity != NULL);
  assert(*entity == NULL);

  result = NULL;
  err = CFQDictionaryCreateMutable(&amp;result);
  if (err == noErr) {
  
    // If we're debugging, make sure that the configMethod is one of 
    // the supported options, and that other fields match the 
    // config method (for example, you can't supply a client ID if 
    // you're not using DHCP).
    
    #if !defined(NDEBUG)
      if ( ! gMoreSCCreateIPv4EntityDontCheck ) {
        OSType  method;
        Boolean printed;
        
        printed = false;
        
        if (CFEqual(digest-&gt;configMethod, kSCValNetIPv4ConfigMethodBOOTP)) {
          method = 'boot';
        } else if (CFEqual(digest-&gt;configMethod, kSCValNetIPv4ConfigMethodDHCP)) {
          method = 'dhcp';
        } else if (CFEqual(digest-&gt;configMethod, kSCValNetIPv4ConfigMethodINFORM)) {
          method = 'info';
        } else if (CFEqual(digest-&gt;configMethod, kSCValNetIPv4ConfigMethodManual)) {
          method = 'manu';
        } else if (CFEqual(digest-&gt;configMethod, kSCValNetIPv4ConfigMethodPPP)) {
          method = 'ppp ';
        } else {
          method = 'bad!';
        }
        assert(method != 'bad!');

        // These used to be asserts but they are now triggered by 
        // some of our test cases on Mac OS X 10.2, where the default 
        // setup for an Ethernet port is Manual with IP address 0.
        
        if ( (digest-&gt;address.s_addr == 0) !=
                (     (method == 'boot')
                || (method == 'dhcp')
                || (method == 'ppp ')  ) ) {
          fprintf(stderr, &quot;MoreSCCreateIPv4Entity: IP address zero makes sense for BOOTP, DHCP, and PPP config methods only\n&quot;);
          printed = true;
        }
        if ( ( digest-&gt;subnetMask.s_addr != 0) != (method == 'manu') ) {
          fprintf(stderr, &quot;MoreSCCreateIPv4Entity: Subnet mask non-zero makes sense for Manual config method only\n&quot;);
          printed = true;
        }
        if ( ( digest-&gt;router.s_addr != 0) != (method == 'manu') ) {
          fprintf(stderr, &quot;MoreSCCreateIPv4Entity: Router address non-zero makes sense for Manual config method only\n&quot;);
          printed = true;
        }
        if (printed) {
          fprintf(stderr, &quot;  address      = %08x\n&quot;, digest-&gt;address.s_addr);
          fprintf(stderr, &quot;  subnetMask   = %08x\n&quot;, digest-&gt;subnetMask.s_addr);
          fprintf(stderr, &quot;  router       = %08x\n&quot;, digest-&gt;router.s_addr);
          fprintf(stderr, &quot;  method       = %4.4s\n&quot;, (char *) &amp;method);
          fprintf(stderr, &quot;  configMethod = &quot;);
          CFShow(digest-&gt;configMethod);
        }
        assert( (digest-&gt;clientID == NULL) || (method == 'dhcp') );
      }
    #endif
    
    // Add the config method and client ID (if supplied).
    
    CFDictionaryAddValue(result, kSCPropNetIPv4ConfigMethod, digest-&gt;configMethod);
    if (digest-&gt;clientID != NULL) {
      CFDictionaryAddValue(result, kSCPropNetIPv4DHCPClientID, digest-&gt;clientID);
    }

    // If the caller supplied an address, add it.
    
    if (digest-&gt;address.s_addr != 0) {
      CFArrayRef addresses;
      
      addresses = NULL;
      err = MoreSCFCreateArrayWithInetAddresses(1, &amp;digest-&gt;address, &amp;addresses);
      
      CFDictionaryAddValue(result, kSCPropNetIPv4Addresses, addresses);
      CFQRelease(addresses);
    }
    
    // If the caller supplied a subnet mask, add it.
    
    if (err == noErr &amp;&amp; digest-&gt;subnetMask.s_addr != 0) {
      CFArrayRef subnetMasks;
      
      subnetMasks = NULL;
      err = MoreSCFCreateArrayWithInetAddresses(1, &amp;digest-&gt;subnetMask, &amp;subnetMasks);
      
      CFDictionaryAddValue(result, kSCPropNetIPv4SubnetMasks, subnetMasks);
      CFQRelease(subnetMasks);
    }

    // If the caller supplied a router mask, add it.
    
    if (err == noErr &amp;&amp; digest-&gt;router.s_addr != 0) {
      CFStringRef router;
      
      router = NULL;
      err = MoreSCFCreateStringWithInetAddress(digest-&gt;router, &amp;router);
      CFDictionaryAddValue(result, kSCPropNetIPv4Router, router);
      CFQRelease(router);
    }
  }
  
  if (err != noErr) {
    CFQRelease(result);
    result = NULL;
  }
  *entity = result;
  
  return err;
}

// This structure is the default options for PPP if the caller doesn't supply 
// an options structure.

const MoreSCPPPOptions kMoreSCPPPOptionsDefaultTenOne =
{
  false,    // dialOnDemand
  false,    // idleReminder
  1800,    // idleReminderTimer
  true,    // disconnectOnIdle
  900,    // disconnectOnIdleTimer
  true,    // disconnectOnLogout
  true,    // commRedialEnabled
  1,      // commRedialCount
  30,      // commRedialInterval
  true,    // lcpEchoEnabled
  true,    // ipcpCompressionVJ
  false,    // commDisplayTerminalWindow
  false    // verboseLogging
};

const MoreSCPPPOptions kMoreSCPPPOptionsDefaultTenTwoAndLater =
{
  false,    // dialOnDemand
  false,    // idleReminder
  1800,    // idleReminderTimer
  true,    // disconnectOnIdle
  600,    // disconnectOnIdleTimer
  true,    // disconnectOnLogout
  true,    // commRedialEnabled
  1,      // commRedialCount
  5,      // commRedialInterval
  true,    // lcpEchoEnabled
  true,    // ipcpCompressionVJ
  false,    // commDisplayTerminalWindow
  false    // verboseLogging
};

const MoreSCPPPOptions kMoreSCPPPoEOptionsDefaultTenTwoAndLater =
{
  false,    // dialOnDemand
  false,    // idleReminder
  1800,    // idleReminderTimer
  false,    // disconnectOnIdle
  1800,    // disconnectOnIdleTimer
  true,    // disconnectOnLogout
  true,    // commRedialEnabled
  1,      // commRedialCount
  5,      // commRedialInterval
  true,    // lcpEchoEnabled
  true,    // ipcpCompressionVJ
  false,    // commDisplayTerminalWindow
  false    // verboseLogging
};

static Boolean gTenTwoOrLater;
static Boolean gTenThreeOrLater;
static Boolean gTenThreeFiveOrLater;
static Boolean gTenFourOrLater;

extern const MoreSCPPPOptions *MoreSCGetDefaultPPPOptions(Boolean isPPPoE)
{
  const MoreSCPPPOptions *result;
  
  gTenTwoOrLater       = (MoreSCGetSystemVersion() &gt;= 0x01020);
  gTenThreeOrLater     = (MoreSCGetSystemVersion() &gt;= 0x01030);
  gTenThreeFiveOrLater = (MoreSCGetSystemVersion() &gt;= 0x01035);
  gTenFourOrLater      = (MoreSCGetSystemVersion() &gt;= 0x01040);
  if (gTenTwoOrLater) {
    if (isPPPoE) {
      result = &amp;kMoreSCPPPoEOptionsDefaultTenTwoAndLater;
    } else {
      result = &amp;kMoreSCPPPOptionsDefaultTenTwoAndLater;
    }
  } else {
    result = &amp;kMoreSCPPPOptionsDefaultTenOne;
  }
  return result;
}

// This trickery allows us to build with either 10.1 or 10.2 headers.

#if !defined(kSCPropNetPPPCommUseTerminalScript)
  #define kSCPropNetPPPCommUseTerminalScript       SCSTR(&quot;CommUseTerminalScript&quot;)           /* CFNumber (0 or 1) */
#endif

extern OSStatus MoreSCCreatePPPEntity(const MoreSCPPPDigest *digest, CFDictionaryRef *entity)
  // See comment in header.
{
  OSStatus err;
  CFMutableDictionaryRef result;
  const MoreSCPPPOptions *options;
  
  assert( digest != NULL);
  assert( entity != NULL);
  assert(*entity == NULL);

  // If the caller supplied options, use them, otherwise use the defaults.
  // Note that we always call MoreSCGetDefaultPPPOptions to guarantee that 
  // gTenTwoOrLater has been set up, which we need below.
  
  options = MoreSCGetDefaultPPPOptions(false);
  if (digest-&gt;options != NULL) {
    options = digest-&gt;options;
  }
  result = NULL;
  err = CFQDictionaryCreateMutable(&amp;result);
  
  if (err == noErr) {
  
    // Set the user-visible name, if supplied.
    
    if (digest-&gt;userDefinedName != NULL) {
      CFDictionaryAddValue(result, kSCPropUserDefinedName, digest-&gt;userDefinedName);
    }    
    
    // If the entity isn't active, record that.
    
    if (! digest-&gt;active ) {
      err = CFQDictionarySetNumber(result, kSCResvInactive, 1);
    }
  }
  
  // Identifiers listed in comments are included in &quot;SCSchemaDefinitions.h&quot;
  // but aren't created by the Network preferences panel by default (and 
  // not created by us (or it) by default).
  
  // PPP-level properties
  
  if (err == noErr) {
    err = CFQDictionarySetNumber(result, kSCPropNetPPPDialOnDemand, options-&gt;dialOnDemand);
  }
  if (err == noErr) {
    err = CFQDictionarySetNumber(result, kSCPropNetPPPDisconnectOnIdle, options-&gt;disconnectOnIdle);
  }
  if (err == noErr) {
    err = CFQDictionarySetNumber(result, kSCPropNetPPPDisconnectOnIdleTimer, options-&gt;disconnectOnIdleTimer);
  }
  if (err == noErr) {
    err = CFQDictionarySetNumber(result, kSCPropNetPPPDisconnectOnLogout, options-&gt;disconnectOnLogout);
  }
  if (err == noErr) {
    err = CFQDictionarySetNumber(result, kSCPropNetPPPIdleReminder, options-&gt;idleReminder);
  }
  if (err == noErr) {
    err = CFQDictionarySetNumber(result, kSCPropNetPPPIdleReminderTimer, options-&gt;idleReminderTimer);
  }
  if (err == noErr) {
        // For security reasons, the location of the PPP log file changed in 
        // Mac OS X 10.3.5 &lt;rdar://problem/3740180&gt;.
        if (gTenThreeFiveOrLater) {
            CFDictionaryAddValue(result, kSCPropNetPPPLogfile, CFSTR(&quot;/var/log/ppp.log&quot;));
        } else {
            CFDictionaryAddValue(result, kSCPropNetPPPLogfile, CFSTR(&quot;/tmp/ppp.log&quot;));
        }
  }
  // kSCPropNetPPPSessionTimer
  if (err == noErr) {
    err = CFQDictionarySetNumber(result, kSCPropNetPPPVerboseLogging, options-&gt;verboseLogging);
  }

  // Authentication properties

  if (err == noErr &amp;&amp; digest-&gt;authName != NULL) {
    CFDictionaryAddValue(result, kSCPropNetPPPAuthName, digest-&gt;authName);
  }
  if (err == noErr &amp;&amp; digest-&gt;authPassword != NULL) {
    CFDataRef encodedPassword;
    
    encodedPassword = NULL;
    err = MoreSCFCopyEncodedPPPPassword(digest-&gt;authPassword, &amp;encodedPassword);
    if (err == noErr) {
      CFDictionaryAddValue(result, kSCPropNetPPPAuthPassword, encodedPassword);
    }
    
    CFQRelease(encodedPassword);
  }
  // kSCPropNetPPPAuthPasswordEncryption
  // kSCPropNetPPPAuthProtocol
    
  // Communications-level properties
  
  if (err == noErr &amp;&amp; digest-&gt;commAlternateRemoteAddress != NULL) {
    CFDictionaryAddValue(result, kSCPropNetPPPCommAlternateRemoteAddress, digest-&gt;commAlternateRemoteAddress);
  }
  // kSCPropNetPPPCommConnectDelay
  if (err == noErr) {
    err = CFQDictionarySetNumber(result, kSCPropNetPPPCommDisplayTerminalWindow, options-&gt;commDisplayTerminalWindow);
  }
  if (err == noErr) {
    err = CFQDictionarySetNumber(result, kSCPropNetPPPCommRedialCount, options-&gt;commRedialCount);
  }
  if (err == noErr) {
    err = CFQDictionarySetNumber(result, kSCPropNetPPPCommRedialEnabled, options-&gt;commRedialEnabled);
  }
  if (err == noErr) {
    err = CFQDictionarySetNumber(result, kSCPropNetPPPCommRedialInterval, options-&gt;commRedialInterval);
  }
  if (err == noErr &amp;&amp; digest-&gt;commRemoteAddress != NULL) {
    CFDictionaryAddValue(result, kSCPropNetPPPCommRemoteAddress, digest-&gt;commRemoteAddress);
  }
  // kSCPropNetPPPCommTerminalScript
  if (err == noErr) {
    if (gTenTwoOrLater) {
      err = CFQDictionarySetNumber(result, kSCPropNetPPPCommUseTerminalScript, 0);
    }
  }

  // IPCP-level properties
  
  if (err == noErr) {
    err = CFQDictionarySetNumber(result, kSCPropNetPPPIPCPCompressionVJ, options-&gt;ipcpCompressionVJ);
  }

  // LCP-level properties
  
  if (err == noErr) {
    err = CFQDictionarySetNumber(result, kSCPropNetPPPLCPEchoEnabled, options-&gt;lcpEchoEnabled);
  }
  if (err == noErr) {
    if (gTenTwoOrLater) {
      err = CFQDictionarySetNumber(result, kSCPropNetPPPLCPEchoFailure, 4);
    } else {
      err = CFQDictionarySetNumber(result, kSCPropNetPPPLCPEchoFailure, 3);
    }
  }
  if (err == noErr) {
    err = CFQDictionarySetNumber(result, kSCPropNetPPPLCPEchoInterval, 10);
  }
  // kSCPropNetPPPLCPCompressionACField
  // kSCPropNetPPPLCPCompressionPField
  // kSCPropNetPPPLCPMRU
  // kSCPropNetPPPLCPMTU
  // kSCPropNetPPPLCPReceiveACCM
  // kSCPropNetPPPLCPTransmitACCM
    
    // Stuff that doesn't fit neatly into the above categories.
    
    if ( (err == noErr) &amp;&amp; gTenThreeOrLater ) {
        err = CFQDictionarySetNumber(result, kSCPropNetPPPACSPEnabled, 0);
    }
    if ( (err == noErr) &amp;&amp; gTenTwoOrLater ) {
        err = CFQDictionarySetNumber(result, kSCPropNetPPPDisconnectOnSleep, 1);
    }
    if ( (err == noErr) &amp;&amp; gTenFourOrLater ) {
        err = CFQDictionarySetNumber(result, kSCPropNetPPPDisconnectOnFastUserSwitch, 1);
    }
  
  if (err != noErr) {
    CFQRelease(result);
    result = NULL;
  }
  *entity = result;
  
  return err;
}

extern OSStatus MoreSCCreateAirPortEntity(const MoreSCAirPortDigest *digest, CFDictionaryRef *entity)
  // See comment in header.
{
  OSStatus err;
  CFMutableDictionaryRef result;
  
  assert( digest != NULL);
  assert( entity != NULL);
  assert(*entity == NULL);

  result = NULL;
  err = CFQDictionaryCreateMutable(&amp;result);
    
    // 10.4 and later don't record the MAC address in the prefs.
    
  if ( (err == noErr) &amp;&amp; (MoreSCGetSystemVersion() &lt; 0x01040) ) {
    CFStringRef mac;
    
    mac = NULL;
    err = MoreSCFCreateStringWithMacAddress(digest-&gt;macAddress, &amp;mac);
    CFDictionaryAddValue(result, kSCPropMACAddress, mac);
    CFQRelease(mac);
  }
    
  if (err == noErr &amp;&amp; digest-&gt;preferredNetwork != NULL) {
    CFDictionaryAddValue(result, kSCPropNetAirPortPreferredNetwork, digest-&gt;preferredNetwork);
  }
  
  // *** &quot;SCSchemaDefinitions.h&quot; defines the following.  Not sure 
  // what to do with them right now.
  
  // kSCPropNetAirPortPowerEnabled
  // kSCPropNetAirPortAuthPassword
  // kSCPropNetAirPortAuthPasswordEncryption
  
  if (err != noErr) {
    CFQRelease(result);
    result = NULL;
  }
  *entity = result;
  
  return err;
}

extern OSStatus MoreSCCreateEthernetEntity(const MoreSCEthernetDigest *digest, CFDictionaryRef *entity)
  // See comment in header.
{
  OSStatus err;
  CFMutableDictionaryRef result;
  
  assert( digest != NULL);
  assert( entity != NULL);
  assert(*entity == NULL);

  result = NULL;
  err = CFQDictionaryCreateMutable(&amp;result);
  if (err == noErr) {
    CFStringRef mac;
    
    mac = NULL;
    err = MoreSCFCreateStringWithMacAddress(digest-&gt;macAddress, &amp;mac);
    CFDictionaryAddValue(result, kSCPropMACAddress, mac);
    CFQRelease(mac);
  }
  
  if (err != noErr) {
    CFQRelease(result);
    result = NULL;
  }
  *entity = result;
  
  return err;
}

// This structure contains the default options for modem.  It's 
// exported to clients but isn't referenced by this module itself.

const MoreSCModemDigest kMoreSCModemDigestDefault =
{
  NULL,      // connectionScript
  true,      // dataCompressionErrorCorrection
  true,      // speaker
  false,      // pulseDial
  true,      // waitForDialTone
  false,      // supportsHold
};

extern OSStatus MoreSCCreateModemEntity(const MoreSCModemDigest *digest, CFDictionaryRef *entity)
  // See comment in header.
  //
  // Note that the dataCompressionErrorCorrection digest field controls 
  // both kSCPropNetModemConnectionScript and kSCPropNetModemErrorCorrection.  
  // This is inline with the current user interface, which has a single 
  // checkbox that controls both of these parameters.
{
  OSStatus err;
  CFMutableDictionaryRef result;
  
  assert( digest != NULL);
  assert( entity != NULL);
  assert(*entity == NULL);

  result = NULL;
  err = CFQDictionaryCreateMutable(&amp;result);
  if (err == noErr) {
    assert(digest-&gt;connectionScript != NULL);
        
        CFDictionaryAddValue(result, kSCPropNetModemConnectionScript, digest-&gt;connectionScript);
  }
  if (err == noErr) {
    err = CFQDictionarySetNumber(result, kSCPropNetModemDataCompression, digest-&gt;dataCompressionErrorCorrection);
  }
  if (err == noErr) {
    if (digest-&gt;waitForDialTone) {
      CFDictionaryAddValue(result, kSCPropNetModemDialMode, kSCValNetModemDialModeWaitForDialTone);
    } else {
      CFDictionaryAddValue(result, kSCPropNetModemDialMode, kSCValNetModemDialModeIgnoreDialTone);
    }
  }
  if (err == noErr) {
    err = CFQDictionarySetNumber(result, kSCPropNetModemErrorCorrection, digest-&gt;dataCompressionErrorCorrection);
  }
  if (err == noErr) {
    err = CFQDictionarySetNumber(result, kSCPropNetModemPulseDial, digest-&gt;pulseDial);
  }
  if (err == noErr) {
    err = CFQDictionarySetNumber(result, kSCPropNetModemSpeaker, digest-&gt;speaker);
  }

  // kSCPropNetModemSpeed is listed in &quot;SCSchemaDefinitions.h&quot; but I don't 
  // think it's ever stored in preferences; it more likely to be found in 
  // the dynamic store.

  if (err == noErr &amp;&amp; digest-&gt;supportsHold) {
    err = CFQDictionarySetNumber(result, kSCPropNetModemHoldCallWaitingAudibleAlert, 1);
    if (err == noErr) {
      err = CFQDictionarySetNumber(result, kSCPropNetModemHoldDisconnectOnAnswer, 0);
    }
    if (err == noErr) {
      err = CFQDictionarySetNumber(result, kSCPropNetModemHoldEnabled, 0);
    }
    if (err == noErr) {
      err = CFQDictionarySetNumber(result, kSCPropNetModemHoldReminder, 1);
    }
    if (err == noErr) {
      err = CFQDictionarySetNumber(result, kSCPropNetModemHoldReminderTime, 10);
    }
  }
  
  if (err != noErr) {
    CFQRelease(result);
    result = NULL;
  }
  *entity = result;
  
  return err;
}

extern OSStatus MoreSCCreateEntity(CFStringRef protocol, const MoreSCDigest *digest, CFDictionaryRef *entity)
  // See comment in header.
{
  OSStatus err;
  
  assert(protocol != NULL);
  assert(digest != NULL);
  assert( entity != NULL);
  assert(*entity == NULL);
  
  // Call the appropriate protocol-specific routine based on the 
  // protocol type supplied.
  
  if (        CFEqual(protocol, kSCEntNetInterface) ) {
    err = MoreSCCreateInterfaceEntity(&amp;digest-&gt;interface, entity);
  } else if ( CFEqual(protocol, kSCEntNetProxies) ) {
    err = MoreSCCreateProxiesEntity(&amp;digest-&gt;proxies, entity);
  } else if ( CFEqual(protocol, kSCEntNetAppleTalk) ) {
    err = MoreSCCreateAppleTalkEntity(&amp;digest-&gt;appleTalk, entity);
  } else if ( CFEqual(protocol, kSCEntNetDNS) ) {
    err = MoreSCCreateDNSEntity(&amp;digest-&gt;dns, entity);
  } else if ( CFEqual(protocol, kSCEntNetIPv4) ) {
    err = MoreSCCreateIPv4Entity(&amp;digest-&gt;ipv4, entity);
  } else if ( CFEqual(protocol, kSCEntNetPPP) ) {
    err = MoreSCCreatePPPEntity(&amp;digest-&gt;ppp, entity);
  } else if ( CFEqual(protocol, kSCEntNetAirPort) ) {
    err = MoreSCCreateAirPortEntity(&amp;digest-&gt;airPort, entity);
  } else if ( CFEqual(protocol, kSCEntNetEthernet) ) {
    err = MoreSCCreateEthernetEntity(&amp;digest-&gt;ethernet, entity);
  } else if ( CFEqual(protocol, kSCEntNetModem) ) {
    err = MoreSCCreateModemEntity(&amp;digest-&gt;modem, entity);
  } else {
    assert(false);
    err = -1;
  }
  return err;
}

</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/MoreSCF/listing7.html%3Fid%3DDTS10000702-2.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/MoreSCF/listing7.html%3Fid%3DDTS10000702-2.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/MoreSCF/listing7.html%3Fid%3DDTS10000702-2.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>