<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Speech Synthesis Programming Guide: Speech Synthesis in Mac OS X</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Speech Synthesis in Mac OS X"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40004365-CH3" title="Speech Synthesis in Mac OS X"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000437" target="_top">User Experience</a> &gt; <a href="../../../SpeechTechnologies-date.html#//apple_ref/doc/uid/TP30000440-TP30000437-TP30000576" target="_top">Speech Technologies</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP40004365-CH1-DontLinkElementID_41">Speech Synthesis Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Introduction/Introduction.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../UsingSpeech/UsingSpeech.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40004365-CH3-SW6" title="Speech Synthesis in Mac OS X"></a><h1>Speech Synthesis in Mac OS X</h1><p>Mac OS X includes an advanced speech synthesizer that provides high-quality synthesized speech and comprehensive speech synthesis APIs that allow developers to create and customize spoken output.</p><p>This chapter discusses some of the benefits of using speech synthesis in your application and describes the components of the Mac OS X Speech Synthesis framework. In addition, this chapter provides an overview of the ways in which you can customize the speech your application generates. You should read this chapter if you’re unfamiliar with the concepts of speech synthesis or if you’re wondering how to take advantage of synthesized speech in your application.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="SpeechOverview.html#//apple_ref/doc/uid/TP40004365-CH3-SW10">Why Use Synthesized Speech?</a>
				
			<br/>
			
        
			
			
				<a href="SpeechOverview.html#//apple_ref/doc/uid/TP40004365-CH3-SW2">Spoken Output and Accessibility</a>
				
			<br/>
			
        
			
			
				<a href="SpeechOverview.html#//apple_ref/doc/uid/TP40004365-CH3-DontLinkElementID_10">Speech Synthesis Concepts and Components</a>
				
			<br/>
			
        
			
			
				<a href="SpeechOverview.html#//apple_ref/doc/uid/TP40004365-CH3-SW3">Opportunities for the Customization of Synthesized Speech</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40004365-CH3-SW10" title="Why Use Synthesized Speech?"></a><h2>Why Use Synthesized Speech?</h2><p>Although people have learned to communicate with computers and applications using display screens and various input devices, these methods represent an effort on the part of users to conform to the computer’s communication paradigm, not vice versa. When an application produces synthesized speech, however, it communicates with users in human terms, in a natural and efficient way. Using speech, an application can communicate an almost infinite range of information to the user. Because it is not limited to producing a small set of sounds users must learn to associate with specific conditions or actions, an application that generates speech can give users precise information about complex subjects and conditions. </p><p>Consider, for example, a home accounting application in which users enter data about their expenditures for the month. If the application speaks each number as it is entered, users know immediately when they’ve entered an incorrect number without ever having to look at the display screen. Another example is an email program that tells users not only when a new message arrives but also from whom.</p><p>Applications can also customize spoken output to meet specific requirements. For example, a language-learning application can customize speech to produce accurately pronounced words and phrases users can mimic. Games and other entertainment applications can use speech customization to emphasize the individuality of different onscreen characters.</p><p>Of course, an application that generates speech might also benefit from allowing users to speak to it, using a technology called speech recognition. However, this document focuses on the speech synthesis side of the computer-user conversation. You can find reference documentation on the Mac OS X speech recognition APIs in <em><a href="../../../../Carbon/Reference/Speech_Recognition_Manager/index.html#//apple_ref/doc/uid/TP30000209" target="_top">Speech Recognition Manager Reference</a></em>.</p><a name="//apple_ref/doc/uid/TP40004365-CH3-SW2" title="Spoken Output and Accessibility"></a><h2>Spoken Output and Accessibility</h2><p>It’s important to understand that adding synthesized speech to an application and making an application accessible to all users (a process called access enabling) are different processes with different goals.  In particular, adding support for synthesized speech to your application is not the same as meeting accessibility requirements, such as those set by section 508 of the United States Rehabilitation Act of 1973.</p><p>Although both application-generated speech and the speech produced by a screen reader or other assistive application might sound the same (and use much of the same underlying technology), they perform different functions. Synthesized speech enhances an application’s user interface and helps accomplish application-specific tasks, such as describing error conditions or providing verbal feedback on users’s actions. In contrast, speech generated by an assistive application enables users to access all parts of the operating system and drive the user interfaces of other applications without using the mouse or display screen. Because an assistive application must be able to help users access all applications they might run, it focuses on providing access to the features all applications have in common, such as menus, buttons, and text-input fields.</p><p>To illustrate the difference between the roles of an application’s spoken output and the speech generated by an assistive application, consider an access-enabled chess application. For the purposes of this dicussion, assume that this chess application produces spoken output that describes the moves taken by both the user and the application. Using an assistive application, visually impaired users can run this chess application and activate all the buttons and other controls in its user interface. However, an assistive application cannot describe the move the chess application makes in its turn, because that information arises from a change in the internal state of the chess application, not from a button click or menu-item selection. If the chess application did not produce its own spoken output, visually impaired users would be able to move their own chess pieces but would not be able to find out how the application responded.</p><p>In Mac OS X v10.3 Apple introduced VoiceOver, an alternative way of interacting with the Macintosh that allows visually impaired users to use applications and Mac OS X itself using only the keyboard. Because VoiceOver and many other assistive applications generate spoken output, they use the same Mac OS X speech synthesizer your application uses when it generates spoken output. While VoiceOver is running, therefore, users may experience interruptions in your application's speech or cross-talk (overlapping speech). To find out how VoiceOver interacts with your application’s spoken output and how to avoid interrupting the spoken output of other applications, see <span class="content_text"><a href="../FineTuning/FineTuning.html#//apple_ref/doc/uid/TP40004365-CH5-SW1">“Avoid Cross-Talk.”</a></span></p><a name="//apple_ref/doc/uid/TP40004365-CH3-DontLinkElementID_10" title="Speech Synthesis Concepts and Components"></a><h2>Speech Synthesis Concepts and Components</h2><p>In Mac OS X, the Speech Synthesis framework supports the conversion of text into speech, using a common API for managing voices and synthesizers. This architecture supports multiple, plug-in synthesizers and languages from different vendors, as well as multiple voices for each synthesizer. Application developers interact with the Speech Synthesis framework using the C-based API defined in the Application Services framework, the Objective-C API defined in the Application Kit, or the AppleScript <code>say</code> command. Developers of command-line tools and other processes can link with the Application Services framework to produce spoken output, because there is no graphical user interface inherent in synthesized speech. Even if you don’t plan to offer any customized speech features, your application or process benefits from the systemwide feature that allows users to hear spoken aloud nearly any text they can select.</p><p>The Speech Synthesis framework includes:</p><ul class="ul"><li class="li"><p>The Carbon speech synthesis API (also called the Speech Synthesis Manager), which is defined in the Speech Synthesis subframework in the Application Services framework. The Carbon speech synthesis API provides extensive control over speech synthesis to applications that can link with the Application Services framework.</p></li><li class="li"><p>The <code>NSSpeechSynthesizer</code> class, which is defined in the Application Kit framework. The <code>NSSpeechSynthesizer</code> class provides basic speech-synthesis functionality to Cocoa applications.</p></li><li class="li"><p>Speech synthesizers, which are contained in loadable bundles and which reside in <code>/System/Library/Speech/Synthesizers</code>. Synthesizers perform the conversion of text to speech and contain code that performs lexical analysis and determines pronunciations. Apple’s built-in synthesizer is the MacinTalk synthesizer, which is described in <span class="content_text"><a href="SpeechOverview.html#//apple_ref/doc/uid/TP40004365-CH3-SW7">“The MacinTalk Synthesizer.”</a></span></p></li><li class="li"><p>Speech voices, which are bundles that contain individual voice characteristics and, sometimes, code. Apple provides more than 20 built-in voices, which reside in <code>/System/Library/Speech/Voices</code>. For more information about voices and their relationship to synthesizers, see <span class="content_text"><a href="SpeechOverview.html#//apple_ref/doc/uid/TP40004365-CH3-SW8">“Voices.”</a></span></p></li></ul><p>The following sections outline the Mac OS X speech generation process and describe components of the Speech Synthesis framework and concepts of speech generation. The information in these sections is applicable to any application or process that produces synthesized speech, regardless of the speech synthesis API it uses.</p><a name="//apple_ref/doc/uid/TP40004365-CH3-SW9" title="The Speech Generation Process"></a><h3>The Speech Generation Process</h3><p>Essentially, the Speech Synthesis framework is a dispatch mechanism that allows your application to take advantage of the capabilities of whatever speech synthesizers, voices, and hardware are installed on a user’s computer. The Speech Synthesis framework provides a convenient programming interface that manages access to the speech synthesizers and, indirectly, to the sound hardware. <span class="content_text">Figure 1-1</span> illustrates the speech generation process at a high level.</p><br/><div><a name="//apple_ref/doc/uid/TP40004365-CH3-SW14" title="Figure 1-1The speech generation process"></a><p><strong>Figure 1-1&nbsp;&nbsp;</strong>The speech generation process</p><img src = "../art/speechsynth_speechprocess.gif" alt = "" width="533" height="291"></div><br/><p>As outlined in <span class="content_text">Figure 1-1</span>, your application initiates speech generation by passing a string or buffer of text to the Speech Synthesis framework, via the appropriate API. The Speech Synthesis framework is responsible for sending the text to a <strong>speech synthesizer</strong>, a component containing executable code that manages all communication between the Speech Synthesis framework and Core Audio.</p><p>A synthesizer contains a set of built-in dictionaries and pronunciation rules that it uses to determine how to pronounce text. The synthesizer receives text from an application and converts it to phonemes (described in <span class="content_text"><a href="SpeechOverview.html#//apple_ref/doc/uid/TP40004365-CH3-SW1">“Representations of Speech”</a></span>), and sends the result, including optional pronunciation directives, to a voice. Each synthesizer can work with only those voices that are designed for it; it cannot use voices designed for other synthesizers, even if the voices are installed in the computer.</p><p>As shown in <span class="content_text">Figure 1-1</span>, Core Audio receives digital sound-wave input from the synthesizer and sends this data to the current sound output device or to a file. Because all communication between the Speech Synthesis framework and Core Audio is transparent to your application, you do not need to be concerned with potential changes to the underlying technology or implementations in this area.</p><p>An application can participate in the speech generation process at different levels, ranging from simple to complex. At one end of the spectrum, an application can be completely passive, allowing users to use system-supplied speech features to choose when to hear the application’s text spoken aloud and with which voice. At the other end, an application can supply the Speech Synthesis framework with precise information about how the speech should be produced and with which voice it should be spoken. For more on the ways you can use synthesized speech in your application, see <span class="content_text"><a href="SpeechOverview.html#//apple_ref/doc/uid/TP40004365-CH3-SW3">“Opportunities for the Customization of Synthesized Speech.”</a></span></p><a name="//apple_ref/doc/uid/TP40004365-CH3-SW1" title="Representations of Speech"></a><h3>Representations of Speech</h3><p>There are two ways your application can represent speech: textually and phonemically. Textual representation consists of a sequence of standard, human-readable words in a string or buffer. Phonemic representation is text converted into <strong>phonemes</strong>, which are distinct units that distinguish one word from another. Different languages have different sets of phonemes. For example, in English, the words “pad” and “bad” are distinguished by the phonemes “p” and “b.” Each phoneme is represented by a unique symbol, which consists of single or paired upper-case or lower-case letters (for a complete list of North American English phoneme symbols recognized by the MacinTalk synthesizer, see <span class="content_text"><a href="../Phonemes/Phonemes.html#//apple_ref/doc/uid/TP40004365-CH9-SW1">“Phonemes”</a></span>). For example, the phonemic representation of the word “pad" is “pAEd,” where the phoneme symbols “p,” “AE,“ and “d” stand for “p,“ the short “a” sound, and “d,“ respectively.</p><p>A speech synthesizer always converts text to phonemes before sending it to a voice because the phonemic representation allows it to encode the precise pronunciation of each word. The Speech Synthesis framework provides a function that allows your application to convert text into phonemes before it is sent to the synthesizer. In applications that speak only text that users enter this feature is of limited usefulness, because you can’t anticipate what a user might type. However, if your application speaks a finite set of words or phrases that you create, it can be useful to represent at least some of that text phonemically to ensure its desired pronunciation.</p><p>Performing your own text-to-phoneme conversion has the following advantages:</p><ul class="spaceabove"><li class="li"><p>You can use a text-to-phoneme conversion process that might be of higher quality than that provided by the available synthesizer. You can then use the phonemic data you generate in this way with any speech synthesizer to produce better speech.</p></li><li class="li"><p>You can use phoneme modifiers to adjust the pronunciation of words, giving you a very high degree of control over the spoken output. For example, you can change the placement of the primary stress within a word.</p></li><li class="li"><p>You can use the TUNE format to shape the overall melody and timing of an utterance. The TUNE format (described in <span class="content_text"><a href="../FineTuning/FineTuning.html#//apple_ref/doc/uid/TP40004365-CH5-SW7">“Use the TUNE Format to Supply Complex Pitch Contours”</a></span>) allows you to create a template of pitch and rate changes and apply it to the phonemic representation of a word or phrase. For example, you can use the TUNE format to make an utterance sound as if it is spoken with emotion.</p></li></ul><p>The Speech Synthesis framework also allows you to intersperse phonemic representations of specific words and phrases in a buffer of text. This is useful if the text that your application needs to speak contains words with nonstandard pronunciations, such as proper names, or words you want to be spoken in a particular way. To combine textual and phonemic representations of speech in this way, you must use embedded speech commands (described in <span class="content_text"><a href="SpeechOverview.html#//apple_ref/doc/uid/TP40004365-CH3-SW5">“Control Speech Quality Using Embedded Commands”</a></span>).</p><a name="//apple_ref/doc/uid/TP40004365-CH3-SW8" title="Voices"></a><h3>Voices</h3><p>A <strong>voice</strong> is a set of characteristics that exhibit particular qualities of speech, such as pitch and tone. Just as each person’s voice has unique tonal qualities, so too does each synthesized voice. A synthesized voice might sound male or female and might sound like an adult or a child. Some synthesized voices sound distinctively synthetic, while others sound more natural. To explore the range of voices that come installed in Mac OS X, go to the Speech pane of System Preferences, click the Text to Speech tab, and listen to the voices listed in the System Voice menu. Your application can use the default system voice to generate speech, or it can use the speech synthesis API to select (or allow users to select) one of the other voices available on the user’s system. </p><p> Although a single voice supports only one language and region, a synthesizer may contain any number of voices, each of which can support a different language. <span class="content_text">Figure 1-2</span> shows how different synthesizers and their voices can coexist on a computer.</p><br/><div><a name="//apple_ref/doc/uid/TP40004365-CH3-SW15" title="Figure 1-2Multiple synthesizers and their voices"></a><p><strong>Figure 1-2&nbsp;&nbsp;</strong>Multiple synthesizers and their voices</p><img src = "../art/speechsynth_multivoices.gif" alt = "" width="419" height="246"></div><br/><p></p><p></p><p></p><p>The Speech Synthesis framework defines a data structure, called a voice description record, that holds information about a voice, such as its name, gender, age, language, and the synthesizer with which it’s associated. The framework provides functions that allow you to identify how many voices are currently available in the user’s system and to get the information in a voice description record for a specific voice. Although most of the information in voice description records should not be exposed to users, you can display some of it, such as the voice name, to help users make informed choices. </p><p>Note that, in general, your application does not need to know which speech synthesizer it is using or with which speech synthesizer a given voice is associated. However, some speech synthesizers provide special capabilities in addition to those provided by the Speech Synthesis framework. For example, a speech synthesizer might allow you to select an option to speak all numbers in a nonstandard way, such as digit-by-digit. For these circumstances, the Speech Synthesis framework provides APIs that allow you to determine which synthesizer is associated with a voice and provides hooks that allow your application to take advantage of synthesizer-specific capabilities.</p><p>As speech technology continues to develop, it’s likely that the voices your application can access will sound increasingly human. When you use the Mac OS X speech synthesis APIs, you automatically benefit from any improvements made to the voices built into users’s sytems. Regardless of the voice used to speak the output, however, you can customize the way it speaks your text, using techniques outlined in <span class="content_text"><a href="SpeechOverview.html#//apple_ref/doc/uid/TP40004365-CH3-SW11">“Adjust Speech Attributes Using the Speech Synthesis API”</a></span> and <span class="content_text"><a href="SpeechOverview.html#//apple_ref/doc/uid/TP40004365-CH3-SW5">“Control Speech Quality Using Embedded Commands.”</a></span> </p><a name="//apple_ref/doc/uid/TP40004365-CH3-SW12" title="Speech Channels"></a><h3>Speech Channels</h3><p>To send text to a synthesizer and to specify which voice or attributes you would like it to use, your application uses a speech channel. Conceptually, a  <strong>speech channel</strong> is the conduit between your application and the Speech Synthesis framework. Your application acquires a speech channel, sends through it the text to be spoken, and, optionally, sets speech-channel attributes that affect the synthesized speech.</p><p>Precisely how your application interacts with a speech channel is defined by the API it uses. The Carbon speech synthesis API includes functions you use to create and manage speech channels, as well as functions that allow you to get and set speech-channel attributes. On the other hand, in the Cocoa speech synthesis API, speech-channel management is transparent to you. When you use the Cocoa API to generate spoken output, the necessary speech channels are created, used, and destroyed automatically. Similarly, the AppleScript <code>say</code> command does not expose the use of speech channels. Whichever API you use, however, it’s useful to understand the role of speech channels in the speech generation process. The remainder of this section describes this role and how some applications might need to create multiple speech channels.</p><p>At any point in time, a speech channel is associated with a particular voice and specific speech attributes. However, multiple speech channels can coexist in a single application, which allows your application to create more than one vocal environment to, for example, simulate a dialogue among different characters in a game. Alternatively, you can use a single speech channel and switch to different voices when necessary, but this approach can be inefficient. An example of an application that requires multiple speech channels is one that needs to generate speech in more than one language. As mentioned in <span class="content_text"><a href="SpeechOverview.html#//apple_ref/doc/uid/TP40004365-CH3-SW8">“Voices,”</a></span> a voice is associated with only one language and region, so an application that needs to produce spoken output in a bilingual or multilingual environment would need a separate speech channel for each language. </p><p></p><p>Separate speech channels in a single application can generate speech simultaneously, subject to processor capabilities. However, this capability should be used with restraint, because it is very difficult for users to make sense of  speech when more than one channel is generating speech at the same time. Of course, different speech channels created by different applications may also produce speech simultaneously; for this reason, it’s a good idea to implement an arbitration scheme in your application (for more information on how to do this, see <span class="content_text"><a href="../FineTuning/FineTuning.html#//apple_ref/doc/uid/TP40004365-CH5-SW1">“Avoid Cross-Talk”</a></span>). </p><a name="//apple_ref/doc/uid/TP40004365-CH3-SW13" title="Notifications, Callbacks, and Speech Synchronization"></a><h3>Notifications, Callbacks, and Speech Synchronization</h3><p>The Speech Synthesis framework allows you to receive notifications of certain events during the speech generation process. Using these notifications, you can synchronize speech with actions in your application, such as highlighting the word being spoken or animating a character’s mouth to correspond to the phoneme being pronounced.</p><p>Not surprisingly, the Cocoa and Carbon speech synthesis APIs support different sets of notifications and implement them differently (AppleScript does not support synchronization of speech with application actions). The Cocoa API defines delegate methods you can implement; the Carbon API defines a large number of callbacks for which you can provide handler functions.</p><p>Some of the notifications you can receive tell you when:</p><ul class="spaceabove"><li class="li"><p>A word is about to be spoken</p></li><li class="li"><p>A phoneme is about to be spoken</p></li><li class="li"><p>Speaking has finished</p></li><li class="li"><p>The text has been processed, but not necessarily spoken yet (available only in the Carbon API)</p></li><li class="li"><p>A <code>sync</code> embedded speech command is encountered (available only in the Carbon API). For more information about this command, see <span class="content_text"><a href="../FineTuning/FineTuning.html#//apple_ref/doc/uid/TP40004365-CH5-SW11">“The Mac OS X Embedded Speech Commands.”</a></span></p></li></ul><p>For more information about the specific notifications available and how to use them in your application, see <span class="content_text"><a href="../FineTuning/FineTuning.html#//apple_ref/doc/uid/TP40004365-CH5-SW9">“Synchronize Speech With Application-Specific Actions.”</a></span></p><a name="//apple_ref/doc/uid/TP40004365-CH3-SW7" title="The MacinTalk Synthesizer"></a><h3>The MacinTalk Synthesizer</h3><p>The <strong>MacinTalk synthesizer</strong> is the built-in synthesizer in Mac OS X. It generates North American English from unrestricted text, and supports the addition of a number of text-embedded commands to control pronunciation and intonation. The output of the MacinTalk synthesizer can be played through the computer’s speakers or saved to a file.</p><p>In general, a synthesizer produces the most natural-sounding speech when it combines its built-in text processing rules with pronunciation hints provided by the author of the text. The MacinTalk synthesizer contains a sophisticated lexical analyzer that allows it to make a “best guess” at how a human might speak a given sample of text. But the MacinTalk synthesizer (like all synthesizers) does a better job when you provide precise pronunciation information. Whether synthesized speech is an optional feature or constitutes the centerpiece of your application’s functionality, you should consider using the customization strategies described in <span class="content_text"><a href="SpeechOverview.html#//apple_ref/doc/uid/TP40004365-CH3-SW3">“Opportunities for the Customization of Synthesized Speech”</a></span> to ensure the production of high-quality speech that meets your specifications.</p><p></p><a name="//apple_ref/doc/uid/TP40004365-CH3-SW4" title="Attributes of Synthesized Speech"></a><h3>Attributes of Synthesized Speech</h3><p>Any given person has only one voice, but can significantly alter the characteristics and meaning of his or her speech by varying the pitch, volume, and speed of delivery. People instinctively respond to these vocal attributes and rely on them to provide layers of meaning in addition to the semantic meaning of the words they hear. The Speech Synthesis framework supplies functions that allow you to manipulate speech attributes, such as pitch and speed, to achieve the  effects you want.</p><p>A <strong>speech attribute</strong> is a setting defined on a speech channel that affects the quality of the spoken output for a specific subset of voices, or for all voices associated with a particular synthesizer. At any single point in time, there is a one-to-one correspondence between a voice and a speech channel, so you can think of a speech attribute as applying to either a voice or to a speech channel. Using functions in the Carbon speech synthesis API, you can alter four speech attributes: rate, pitch, pitch modulation, and volume. Alternatively, you can use embedded speech commands to set these four attributes, plus the prosody attribute, on a per-word basis, regardless of the programming language you’re using. For more information on how to use embedded commands, see <span class="content_text"><a href="../FineTuning/FineTuning.html#//apple_ref/doc/uid/TP40004365-CH5-SW10">“Use Embedded Speech Commands to Fine-Tune Pronunciation.”</a></span></p><a name="//apple_ref/doc/uid/TP40004365-CH3-DontLinkElementID_11" title="Speech Rate"></a><h4>Speech Rate</h4><p>The <strong>speech rate</strong> of a speech channel is the approximate number of words of text that the synthesizer speaks in one minute. Although a slower speech rate can make the speech easier to understand, listening to words that are spoken too slowly can be tedious. Be sure to test your application to determine the optimum speech rate for your target audience, so you can ship your application with a reasonable default setting. Visually impaired users, for example, are often comfortable listening to much faster speech rates than sighted users.</p><p>Speech rates are expressed as real values. For example, typical, conversational speech is at a rate of about 180 words per minute, whereas some visually impaired users can comfortably listen to VoiceOver at rates of up to 500 words per minute. Each speech synthesizer determines its own range of speech rates that can be applied to the voices it uses. The Carbon speech synthesis API includes functions that allow you to get and change the current speech rate on a speech channel (for more information on how to do this, see <span class="content_text"><a href="../FineTuning/FineTuning.html#//apple_ref/doc/uid/TP40004365-CH5-SW13">“Adjust Speech Attributes Using Carbon Speech Synthesis Functions”</a></span>).</p><a name="//apple_ref/doc/uid/TP40004365-CH3-DontLinkElementID_12" title="Speech Pitch, Frequency, and Pitch Modulation"></a><h4>Speech Pitch, Frequency, and Pitch Modulation</h4><p>Pitch is a combination of the average speaking frequency and its variations around that average. When you listen to a voice speaking, you’re aware of variations in pitch that create a sort of melody. Often, you’re more aware of this musical quality when you listen to conversations in a language you don’t speak, because you’re not focused on the semantic meaning of what you’re hearing. To produce human-like speech, therefore, a synthesizer must try to replicate these pitch variations in its voices.</p><p>The <strong>speech pitch</strong> of a speech channel represents the middle pitch of a voice, from which the actual pitches of the speech can vary with rising and falling tunes. You can think of speech pitch as roughly corresponding to the key in which a song is played. A speech pitch is expressed as a real value in the range of 0.000 through 127.000, where 60.000 corresponds to middle C on a conventional piano. Each 1.000-unit change in a speech-pitch value corresponds to a musical half-step. You may notice that this is the same scale that is used to specify MIDI note values. Although the scale is the same, however, speech-pitch values differ from MIDI note values in two fundamental ways: speech-pitch values do not have to be integral and they occupy a narrower range than MIDI note values.</p><p>On this scale, a change of +12 units corresponds to a doubling of frequency (an increase of one octave) and a change of -12 units corresponds to a halving of frequency (a decrease of one octave). A <strong>frequency</strong> is a precise indication of the number of hertz (Hz) of a sound wave at any instant. Typical voice frequencies might range from about 75 Hz for a low-pitched male voice to about 300 Hz for a high-pitched child’s voice. These frequencies correspond to approximate speech-pitch values in the ranges of 30.000 to 40.000 and 55.000 to 65.000, respectively. If you need to convert between speech pitches and hertz, note that a speech pitch of 60.000 corresponds to 261.625 Hz.</p><p>The Carbon speech synthesis API includes functions to determine the current speech pitch on a speech channel and to change the speech pitch (see <span class="content_text"><a href="../FineTuning/FineTuning.html#//apple_ref/doc/uid/TP40004365-CH5-SW13">“Adjust Speech Attributes Using Carbon Speech Synthesis Functions”</a></span> for more information on how to do this).</p><p>To simulate the variability in frequency in human speech, the Speech Synthesis framework defines a speech attribute called pitch modulation. The <strong>pitch modulation</strong> of a speech channel is the maximum amount by which the actual frequency of generated speech may deviate from the speech pitch.</p><br/><div><a name="//apple_ref/doc/uid/TP40004365-CH3-DontLinkElementID_44" title="Figure 1-3Pitch variations in the phrase &acirc;&#128;&#156;Hello, world&acirc;&#128;&#157;"></a><p><strong>Figure 1-3&nbsp;&nbsp;</strong>Pitch variations in the phrase “Hello, world”</p><img src = "../art/speechsynth_graph.gif" alt = "" width="357" height="327"></div><br/><p>Pitch modulation is expressed as a real value in the range of 0.000 through 100.000. A pitch modulation value of 0.000 corresponds to a monotone in which all speech is generated at the frequency corresponding to the speech pitch. Speech generated at this pitch modulation sounds unnaturally robotic.</p><a name="//apple_ref/doc/uid/TP40004365-CH3-DontLinkElementID_13" title="Speech Volume"></a><h4>Speech Volume</h4><p>The <strong>speech volume</strong> of a speech channel is the average amplitude at which the channel generates speech. Speech volumes are expressed as real values ranging from 0.0 through 1.0. A value of 0.0 corresponds to silence and a value of 1.0 corresponds to the maximum volume that can be produced by the available audio hardware. Volume units lie on a scale that is linear with amplitude or voltage; therefore, a doubling of the speech-volume value corresponds to a doubling of perceived loudness.</p><p>Just as a synthesizer does not usually generate speech at a constant frequency, it does not generate speech at a constant amplitude. Even when the speech rate is high, brief occurrences of silence (such as pauses between phrases) break up a steady stream of speech. The speech volume, like speech pitch, is an indicator of an average. The Carbon speech synthesis API provides a function you can use to set the volume of the current speech channel (see <span class="content_text"><a href="../FineTuning/FineTuning.html#//apple_ref/doc/uid/TP40004365-CH5-SW13">“Adjust Speech Channel Settings Using the Carbon Speech Synthesis API”</a></span> to find out how to do this).</p><a name="//apple_ref/doc/uid/TP40004365-CH3-DontLinkElementID_14" title="Prosody"></a><h4>Prosody</h4><p>The most complex speech attribute is prosody. The <strong>prosody</strong> speech attribute describes the rhythm, modulation, and emphasis patterns of speech, such as word and syllable stress and the pitch at the end of a sentence. Although there is no simple mechanism for your application to determine what rhythmic patterns a speech synthesizer automatically applies to speech, you can exert some control over this aspect of spoken output by using the <code>emph</code> embedded speech command (described in <span class="content_text"><a href="../FineTuning/FineTuning.html#//apple_ref/doc/uid/TP40004365-CH5-SW11">“The Mac OS X Embedded Speech Commands”</a></span>). In addition, you can use functions in the Carbon speech synthesis API to enable or disable ending prosody, which is the pitch modulation that a speech synthesizer applies to the end of a sentence.</p><p>The primary way you can affect the prosody of your application’s spoken output is by using the TUNE format to supply pitch and rate specifications for individual words or phrases. For more information on how to do this, see <span class="content_text"><a href="../FineTuning/FineTuning.html#//apple_ref/doc/uid/TP40004365-CH5-SW7">“Use the TUNE Format to Supply Complex Pitch Contours.”</a></span> </p><p>Perhaps more than with other speech attributes, you can spend a lot of time fine-tuning the prosody of the speech your application generates. If you have a limited set of strings your application needs to speak, however, it’s well worth the effort to adjust the prosody (along with the other speech attributes) to achieve your goal. For some other ways to produce better-sounding speech, see <span class="content_text"><a href="../FineTuning/FineTuning.html#//apple_ref/doc/uid/TP40004365-CH5-SW2">“Four Ways to Improve Spoken Output.”</a></span></p><a name="//apple_ref/doc/uid/TP40004365-CH3-SW3" title="Opportunities for the Customization of Synthesized Speech"></a><h2>Opportunities for the Customization of Synthesized Speech</h2><p>The Speech Synthesis framework supports many techniques for customizing the speech your application generates, ranging from simple to complex. This section outlines the various options available to you. </p><p>When you’re ready to begin designing your application to include some or all of the customizations described in this section, you should read <span class="content_text"><a href="../UsingSpeech/UsingSpeech.html#//apple_ref/doc/uid/TP40004365-CH4-SW2">“Designing and Implementing an Application That Speaks”</a></span> for a survey of the available APIs, guidance on design considerations, and information on implementing basic speech synthesis tasks. Then, read <span class="content_text"><a href="../FineTuning/FineTuning.html#//apple_ref/doc/uid/TP40004365-CH5-SW3">“Techniques for Customizing Synthesized Speech”</a></span> for in-depth customization information.</p><a name="//apple_ref/doc/uid/TP40004365-CH3-DontLinkElementID_15" title="Use Different Voices"></a><h3>Use Different Voices</h3><p>One of the first things users notice about the speech your application produces is the voice that speaks it. Consequently, using a specific voice is an easy way to customize the spoken output of your application.</p><p>If the voice itself is not an important feature in your application, you can simply use the system default voice (note that users can set the default voice in the Speech System Preferences). However, you may want to designate a specific voice (or voices) or give your users the ability to choose a voice. For example, if you’re developing a game that displays more than one distinct character, you need to be able to give each character its own voice. If, on the other hand, you’re developing an interactive application for children, you might want to give them a selection of entertaining voices from which to choose.</p><p>Designating a specific voice or set of voices requires you to find out which voices are available on the user’s system, examine individual voice descriptions to determine which ones you want, and tell the synthesizer which voice to use. Both the Cocoa and Carbon speech synthesis APIs provide programmatic ways to do this (see the code listings in <span class="content_text"><a href="../UsingSpeech/UsingSpeech.html#//apple_ref/doc/uid/TP40004365-CH4-SW8">“Implementing Basic Speech Synthesis Tasks Using Cocoa and Carbon”</a></span> for some examples). </p><p> </p><a name="//apple_ref/doc/uid/TP40004365-CH3-SW11" title="Adjust Speech Attributes and Control Speech Production Using the Speech Synthesis APIs"></a><h3>Adjust Speech Attributes and Control Speech Production Using the Speech Synthesis APIs</h3><p>As described in <span class="content_text"><a href="SpeechOverview.html#//apple_ref/doc/uid/TP40004365-CH3-SW4">“Attributes of Synthesized Speech,”</a></span> the Speech Synthesis framework defines several attributes that describe aspects of speech, such as volume and pitch. The Speech Synthesis framework provides functions that allow you to adjust rate and pitch. Note that these functions act on speech channels, not on the text itself. This means that, for example, changing the speech rate of a speech channel effectively changes the rate of all speech that channel produces. In addition, you cannot assume that such a change will persist if you change the voice on the channel. This is because telling a channel to use a different voice can cause all the channel’s parameters to be reset to default values. In addition, the new voice may not support some of the attribute settings. However, there may be cases in which it makes sense for your application to change the speech rate or pitch, such as in response to a user request. For an example of how to do this, see <span class="content_text"><a href="../FineTuning/FineTuning.html#//apple_ref/doc/uid/TP40004365-CH5-SW13">“Adjust Speech Attributes Using Carbon Speech Synthesis Functions.”</a></span></p><p>You can exert control over the production of spoken output by using speech synthesis functions to stop, pause, and continue speech. For example, you might allow users to select a Stop Speaking menu item or click a Pause button to control the spoken output. For more information on the functions and methods you can use to control the flow of speech and examples of how to use them, see <span class="content_text"><a href="../UsingSpeech/UsingSpeech.html#//apple_ref/doc/uid/TP40004365-CH4-SW8">“Implementing Basic Speech Synthesis Tasks.”</a></span> </p><p>Although you can use speech synthesis functions to adjust speech attributes, such as volume and pitch, you cannot use them to successfully adjust the pronunciation of words. To fine-tune the pronunciation or prosody of individual words and phrases, you need to use embedded speech commands (described in <span class="content_text">“Control Speech Quality Using Embedded Speech Commands”</span>).</p><p></p><a name="//apple_ref/doc/uid/TP40004365-CH3-SW5" title="Control Speech Quality Using Embedded Speech Commands"></a><h3>Control Speech Quality Using Embedded Speech Commands</h3><p>An <strong>embedded speech command</strong> allows you to control the quality of spoken output with great precision, because you associate it with an individual word or phrase you want to affect. Embedded commands can be used in buffers (or strings) of both textual and phonemic representations of speech. In fact, you can combine phonemic representations of specific words or phrases with textual representations in the same string or buffer. </p><p>Embedded commands allow you to make precise adjustments to the pronunciation of words, the way words are emphasized in a sentence, and the overall cadence of the speech. You can use embedded commands to make speech easier to understand and more human-sounding or to mimic particular pronunciations and intonations. In addition, using this technique confers a significant advantage: you do not need to make any changes to the API your application calls to generate speech, because the embedded commands are contained in the text your application passes to the synthesizer. Your application need only call the standard functions or methods that begin the speech generation process, such as <code><a href="../../../../Carbon/Reference/Speech_Synthesis_Manager/Reference/reference.html#//apple_ref/c/func/SpeakString" target="_top">SpeakString</a></code> or <code><a href="../../../../Cocoa/Reference/ApplicationKit/Classes/NSSpeechSynthesizer_Class/Reference/Reference.html#//apple_ref/occ/instm/NSSpeechSynthesizer/startSpeakingString:" target="_top">startSpeakingString:</a></code> (for more information on these, see the examples in <span class="content_text"><a href="../UsingSpeech/UsingSpeech.html#//apple_ref/doc/uid/TP40004365-CH4-SW8">“Implementing Basic Speech Synthesis Tasks”</a></span>).</p><p>Although embedded commands are most useful for controlling the speech you create, you can also add embedded commands to control the speech generated from text users enter. For example, a word processing application might embed commands that tell the synthesizer to emphasize the pronunciation of words the user has boldfaced or underlined. For a description of the available embedded commands and examples of how to use them, see <span class="content_text"><a href="../FineTuning/FineTuning.html#//apple_ref/doc/uid/TP40004365-CH5-SW10">“Use Embedded Speech Commands to Fine-Tune Pronunciation.”</a></span></p><p>One embedded command, the <code><!--a-->[[inpt &lt;mode>]]<!--/a--></code> command, tells the synthesizer to interpret the content following the command in the mode designated by the value of the <code>&lt;mode></code> parameter, until it reaches another <code><!--a-->[[inpt &lt;mode>]]<!--/a--></code> command. For example, to supply a precise, phonemic representation of a word that appears in a buffer of text, you precede the word with the <code><!--a-->[[inpt PHON]]<!--/a--></code> command, which tells the synthesizer to interpret the following content phonemically, and insert the <code><!--a-->[[inpt TEXT]]<!--/a--></code> command after the word to signal the return to textual representation.</p><p>The <code><!--a-->[[inpt &lt;mode>]]<!--/a--></code> command also includes a mode that allows you to take advantage of the TUNE format, which is an input format that encodes a precise intonation for a word or phrase. You can use the TUNE format to replicate the intonation and timing of a particular utterance. For more information on this format and how to use it, see <span class="content_text"><a href="../FineTuning/FineTuning.html#//apple_ref/doc/uid/TP40004365-CH5-SW7">“Use the TUNE Format to Supply Complex Pitch Contours.”</a></span></p><p></p><p></p><p></p><p></p><p></p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Introduction/Introduction.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../UsingSpeech/UsingSpeech.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2006 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2006-09-05<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/UserExperience/Conceptual/SpeechSynthesisProgrammingGuide/SpeechOverview/SpeechOverview.html%3Fid%3DTP40004365-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/UserExperience/Conceptual/SpeechSynthesisProgrammingGuide/SpeechOverview/SpeechOverview.html%3Fid%3DTP40004365-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/UserExperience/Conceptual/SpeechSynthesisProgrammingGuide/SpeechOverview/SpeechOverview.html%3Fid%3DTP40004365-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>