<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Obtaining Information(IM: Tx)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING362></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Text-361.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Text-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Text-594.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Text-363.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Text-2.html"><B>Text</B></A> / <BR><DD><A HREF="Text-354.html"><B>Chapter 6 - Script Manager</B></A> / <A HREF="Text-359.html"><B>Using the Script Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING362-0></A>
<H2>Obtaining Information</H2>
 The second principal use for the Script Manager is in obtaining script-specific information. Many of the routines described in this section are of general interest and are used by most text applications. You can use these Script Manager routines to<P>
<UL>
<LI>determine script codes for the current script system or any other available script system, based on font information
<LI>analyze characters in your text for size (in bytes) or other properties
<LI>directly access the contents of a script system's international resources, to pass that information to other text-handling calls or to inspect or modify the information<P>
</UL>
 Most text-processing applications need script-code information and character-type information, and may need to pass specific tables from international resources to some script-aware text routines. If you format currencies, you need access to the numeric-format resource. If you use special symbols or if you format numbers, you <BR>need access to the untoken table and perhaps the number parts table of the tokens resource. If your needs are more specialized, you can obtain the contents of other tables and other resources.<P>
<A NAME=HEADING362-6></A>
<H3><A NAME=MARKER-9-678></A>Determining Script Codes From Font Information</H3>
 <A NAME=MARKER-2-44></A>The script management system asssociates a script system with a sequence of text by examining the font of that text. Your application may also need the same information--to test for the presence of a particular script system, to load its resources, to pass its code as a parameter to a script-aware routine, or to execute script-specific conditional code. You may need to determine what script system is currently active for displaying text, what script system is being used to sort and format text, or what script system would be used if text of a particular font were to be displayed or formatted. The Script Manager provides three routines for that purpose: <CODE>FontScript</CODE>, <CODE>FontToScript</CODE>, and <CODE>IntlScript</CODE>.<P>
 <A NAME=MARKER-2-11></A>The <CODE>FontScript</CODE> function tells you which script system the font of the current graphics port belongs to. The <CODE>FontToScript</CODE> function tells you which (available) script system a font of any ID number belongs to. The <CODE>IntlScript</CODE> function tells you which script system is used by the Text Utilities to determine the number, date, time, currency, and sorting formats.<P>
 The <CODE>FontToScript</CODE> function returns a script code for a specified font family ID, but the <CODE>FontScript</CODE> and <CODE>IntlScript</CODE> functions return the code for the <A NAME=MARKER-2-681></A><B>current script,</B> the presently active script system for text manipulation. Many script-aware routines in QuickDraw, Text Utilities, the Script Manager, and other parts of the Macintosh script management system need not take an explicit script code or international resource handle as a parameter; in that case they use the current script as the script system under which they are to function.<P>
 The current script for text display is normally the font script. The current script for date and time formatting and string sorting is by default the system script. However, the settings of two flags--the font force flag and the international resources selection flag--can affect which script system is considered current at any one moment. Furthermore, if the mapping from font to script results in a request for a script system that is not available, the result defaults to the system script.<P>
 The next subsection lists the steps taken by <CODE>FontScript</CODE>, <CODE>FontToScrip</CODE>t, and <CODE>IntlScript</CODE> to determine the script codes they return, and the following subsections discuss the font force flag and the international resources selection flag in more detail.<P>
<A NAME=HEADING362-12></A>
<H4>How a Script Code Is Determined</H4>
 <A NAME=MARKER-2-682></A>The <CODE>FontScript</CODE>, <CODE>FontToScrip</CODE>t, and <CODE>IntlScript</CODE> functions all use a font family ID to determine the script code they return. The formula they use is presented in the discussion of resource ID numbers and script codes in the appendix "International Resources" in this book. Fonts with IDs below 16384 ($4000) are all Roman; starting with 16384 each non-Roman script system has a range of 512 ($200) font IDs available.<P>
 Nevertheless, you should always call the functions instead of hardcoding any formula, because it may change in the future. Furthermore, the function results are influenced by the states of the font force flag and the international resources selection flag, and by the availability of the determined script. <A HREF=#MARKER-9-684>Figure 6-1</A> shows the method the functions follow:<P>
<OL>
<LI>The three functions initialize two result flags, the<B> script-forced result flag</B> and the <B>script-defaulted result flag,</B> to <CODE>FALSE</CODE>. These flags are Script Manager variables, accessed through the <CODE>GetScriptManagerVariable</CODE> function selectors <CODE>smForced</CODE> and <CODE>smDefault</CODE>.<A NAME=MARKER-9-111></A>
<LI>The three functions map the two special font designations 0 and 1, meaning the system and application fonts, to their true font family ID numbers.
<LI><CODE>FontScript</CODE> and <CODE>IntlScript</CODE> calculate the script code from the font family ID of the current font of the active port; <CODE>FontToScript</CODE> calculates the script code from the supplied font family ID. If the ID is in the range $4000 to $BFFF, it is a non-Roman font; otherwise, it is Roman.
<LI>Once the initial determination of the script code has been made, the three functions diverge: <P>
<UL>
<LI>If the font is Roman, <CODE>FontScript</CODE> and <CODE>FontToScript</CODE> examine the font force flag, which can be accessed through the <CODE>GetScriptManagerVariable</CODE> function selector <CODE>smFontForce</CODE>. If the flag is <CODE>TRUE</CODE>, the two functions substitute the system script for the font script, and set the script-forced result flag to <CODE>TRUE</CODE>. If the font is non-Roman, <CODE>FontScript</CODE> and <CODE>FontToScript</CODE> ignore the state of the font <BR>force flag.
<LI>Regardless of the font type (Roman or non-Roman), <CODE>IntlScript</CODE> examines the international resources selection flag, which can be accessed through the <CODE>GetScriptManagerVariable</CODE> function selector <CODE>smIntlForce</CODE>. If the flag is <CODE>TRUE</CODE> and the font script does not equal the system script, <CODE>IntlScript</CODE> substitutes the system script for the font script and sets the script-forced result flag to <CODE>TRUE</CODE>.<P>
</UL>
</OL>
<B>Figure 6-1  <A NAME=MARKER-9-684></A>Determining script code from font family ID</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/SM_L-07.jpg">
<OL>
<LI>A final check is made to be sure that the resulting script is installed and enabled. If it is not, the three functions substitute the system script for the script code previously determined, set the script-forced result flag to <CODE>FALSE</CODE>, and set the script-defaulted result flag to <CODE>TRUE</CODE>.
<LI>The functions return the resulting script code in their function results.<P>
</OL>
 Call <CODE>FontScript</CODE> when you want to know which script system will be used for text layout and display. The script code returned by <CODE>FontScript</CODE> tells you which script system controls the functioning of such calls as <CODE>CharToPixel</CODE>, <CODE>CharacterType</CODE>, <CODE>FindWordBreaks</CODE>, <CODE>DrawText</CODE>, and <CODE>DrawJustified</CODE>. Typically, <CODE>FontScript</CODE> returns the script code for the font script; in most situations the font force flag is <CODE>FALSE</CODE>, <BR>because applications usually expect to format and draw text according to the rules of the <BR>font script.<P>
 Call <CODE>FontToScript</CODE> when you want to know whether the script system for text of a particular font is available, or when you wish to manipulate text of a certain script system without setting the current font to that font's ID.<P>
<DL>
<DT><B>Note</B>
<DD>Because a user can set the value of the font force flag from the Text control panel, the result returned from the <CODE>FontToScript</CODE> or <CODE>FontScript</CODE> function for a font whose ID number is in the Roman range can vary from call to call.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 Call <CODE>IntlScript</CODE> when you want to know which script system will be used for formatting dates and numbers, and for sorting strings. The script code returned by <CODE>IntlScript</CODE> tells you which script system controls the functioning of such calls as <CODE>DateString</CODE>, <CODE>LongTimeString</CODE>, and <CODE>CompareText</CODE>, when no explicit script code or resource handle is supplied to those calls. In many localized versions of sysem software, <CODE>IntlScript</CODE> by default returns the script code for the system script, because the international resources selection flag is by default <CODE>TRUE</CODE>. The Finder and other parts of system software usually expect to present dates, times, and lists of files according to the rules of the system script.<P>
 Because the two flags are independent of each other, two different meanings for current script can exist simultaneously. For example, your application might be sorting a set of strings by one script's rules, but displaying them by another's. If that is not appropriate, set the flags as needed before formatting or drawing. See the following discussion.<A NAME=MARKER-2-57></A><P>
<A NAME=HEADING362-30></A>
<H4><A NAME=MARKER-9-686></A>Using the Font Force Flag</H4>
 <A NAME=MARKER-2-687></A>You access and control the font force flag through the <CODE>GetScriptManagerVariable</CODE> and <CODE>SetScriptManagerVariable</CODE> functions, with the selector <CODE>smfontForce</CODE>. This flag directly affects the results of the <CODE>FontScript</CODE> and <CODE>FontToScript</CODE> functions, and indirectly affects the operation of script-aware text measuring and drawing routines.<P>
 At startup, the Script Manager sets the font force flag to the value specified in the system script's international configuration (<CODE>'itlc'</CODE>) resource. Typically, that value is <CODE>FALSE</CODE>.<P>
 When the font force flag is set to <CODE>TRUE</CODE> and the system script is non-Roman, the script management system interprets font family ID numbers in the range of the Roman script system ($0002 to $3FFF) as belonging to the system script instead. Character codes representing non-Roman characters in the system script are drawn using the system font instead of in the specified Roman font. This feature exists to allow users to enter and read non-Roman text in those few applications that have hardcoded font numbers.<P>
 For example, an application may hardcode Geneva as its font; it may force the <CODE>txFont</CODE> field of its graphics ports to always have a value of 3. (Note that this is a violation of good programming practice.) If the application is running on a system with Hebrew as the system script, it would normally be impossible to write properly in Hebrew because the hardcoded font ID would require the font script to be Roman. However, if the font force flag is set to <CODE>TRUE</CODE>, the script management system notes that the current font has an ID number in the Roman range and draws glyphs from the Hebrew system font for any character codes that represent valid Hebrew characters.<P>
 Thus to enter or read non-Roman text in these applications, the user can set the font force flag to <CODE>TRUE</CODE> from the Text control panel. Setting the font force flag is only partially effective, because it cannot give users full control over fonts. The user cannot choose, for example, which font belonging to the system script is to be substituted for Roman.<P>
 The font force flag has no effect on non-Roman fonts and has no effect if the system script is Roman. It affects only Roman fonts when the system script is non-Roman.<P>
 You can determine the status of font forcing by inspecting the script-forced result flag and the script-defaulted result flag immediately after calling <CODE>FontScript</CODE> or <CODE>FontToScript</CODE>; see <A HREF=#MARKER-9-684>Figure 6-1</A>.<P>
 Although the font force flag exists primarily to accommodate restrictions in certain existing applications, it is a user-changeable setting that your application should be aware of and accommodate. For example:<P>
<UL>
<LI>If you are writing any application in which the user has control over fonts, you should always set the font force flag to <CODE>FALSE</CODE>. There is no need to force fonts if the user can choose them.
<LI>If the user sets the font force flag to <CODE>TRUE</CODE>, you will get the system script when you call <CODE>FontScript</CODE> or <CODE>FontToScript</CODE> for fonts in the Roman range, even if your application allows mixed text. To preserve Roman text, you can change the setting of the font force flag before calling <CODE>FontScript</CODE> or <CODE>FontToScript</CODE>, or before calling any other script-aware text routine. If you do that, be sure to save the previous value and restore it when your application exits or becomes inactive.<A NAME=MARKER-2-41></A><P>
</UL>
<A NAME=HEADING362-41></A>
<H4><A NAME=MARKER-9-689></A>Using the International Resources Selection Flag</H4>
 <A NAME=MARKER-2-690></A>You access and control the international resources selection flag through the <CODE>GetScriptManagerVariable</CODE> and <CODE>SetScriptManagerVariable</CODE> functions, with the selector <CODE>smIntlForce</CODE>. This flag directly affects the results of the <CODE>IntlScript</CODE> function, and indirectly affects the operation of the <CODE>GetIntlResource</CODE> function and the script-aware Text Utilities sorting and formatting routines.<P>
 At startup, the Script Manager sets the international resources selection flag to the value specified in the system script's international configuration (<CODE>'itlc'</CODE>) resource. Typically, that value is <CODE>TRUE</CODE>.<P>
 The international resources selection flag affects the results of the <CODE>GetIntlResource</CODE> function (see <A HREF=Text-397.html#MARKER-9-971>page 6-90</A>). <CODE>GetIntlResource</CODE> returns a handle to certain international resources, and the state of the international resources selection flag controls whether it is the system script or the font script whose international resources are loaded. When the flag is set to <CODE>TRUE</CODE>, <CODE>GetIntlResource</CODE> fetches the resources for the system script. When the flag is set to <CODE>FALSE</CODE>, <CODE>GetIntlResource</CODE> uses the current font in the active port to determine the script system whose resources will be fetched.<P>
 You can use the international resources selection flag to make sure that date formats, sorting, and so forth reflect the appropriate script in your application. Whenever you change the setting of the international resources selection flag, be sure to save the previous value and restore it when your application exits or becomes inactive.<A NAME=MARKER-2-5></A>  <A NAME=MARKER-2-390></A><P>
<A NAME=HEADING362-46></A>
<H3>Analyzing Characters</H3>
 <A NAME=MARKER-2-693></A>The Script Manager provides routines that let you analyze the size and type of individual characters. For example, with script systems that use 2-byte characters, <BR>you may need to determine what part of a character a single byte represents. In either 1-byte or 2-byte script systems, you may need to know whether a particular character is a letter or a punctuation mark, whether or not it is uppercase, or whether it is part of a subscript (Roman within Cyrillic, Hiragana within Japanese, and so on).<P>
<A NAME=HEADING362-48></A>
<H4>Searching Text With Mixed Character Sizes</H4>
 <A NAME=MARKER-2-225></A>When searching for a single 1-byte character in text that may contain 2-byte characters, your application must not mistake part of a 2-byte character for the character you are seeking. The <CODE>CharacterByteType</CODE> and <CODE>FillParseTable</CODE> functions tell you whether a given character is 1-byte or whether it is the first or second byte of a 2-byte character.<P>
 These functions use the fact that, in a 2-byte script system, only a restricted set of values within the high-ASCII range are used as the first bytes of 2-byte characters, and those values are never used for 1-byte characters in that script system. All other byte values represent single-byte characters, control characters, or the second bytes of 2-byte characters. The ranges reserved for initial bytes of 2-byte characters vary from script system to script system, but every font has a table that gives that information, and <CODE>CharacterByteType</CODE> and <CODE>FillParseTable</CODE> use those tables to perform their calculations. For an illustration of this concept, see the discussion of character encoding in the chapter "Introduction to Text on the Macintosh" in this book.<P>
 <A HREF=#MARKER-9-695>Listing 6-6</A> shows a search procedure that accounts for 2-byte characters. This routine uses the Text Utilities <CODE>Munger</CODE> function to find a match to a key string. Because <CODE>Munger</CODE> might find a match beginning at the second byte of a 2-byte character, the routine checks for this case (using the <CODE>CharacterByteType</CODE> function) and continues searching if <BR>it occurs.<P>
 The sample assumes two application global variables: <CODE>gMainTextHandle</CODE>, which is a handle to the application's text buffer, and <CODE>gNewLocation</CODE>, a long-integer offset into the buffer at which to start searching. The parameters <CODE>keyPtr</CODE> and <CODE>keySize</CODE> specify the string to be matched in the text buffer; <CODE>scriptNum</CODE> is an explicit script code. On return, the routine updates <CODE>gNewLocation</CODE> to point to the location at which the search string was found, or sets it to -1 if no match was found.<P>
<B>Listing 6-6  <A NAME=MARKER-9-695></A>Handling 2-byte characters in a search procedure</B><P>
<PRE>
PROCEDURE MySearch (keyPtr: Ptr; keySize: LongInt; scriptNum: 
Integer);
VAR
   byteType: Integer;
BEGIN
   HLock(gMainTextHandle);    {CharacterByteType can move memory}
   REPEAT BEGIN
      gNewLocation := Munger(gMainTextHandle, gNewLocation,
                              keyPtr, keySize, NIL, 0);
                              {if we matched second byte of }
                              { 2-byte char in text, continue}
      IF (gNewLocation &gt;= 0) AND (scriptNum &gt; 0) THEN
         byteType := CharacterByteType(gMainTextHandle^, 
                                       gNewLocation, scriptNum)
      ELSE
         byteType := smSingleByte;
   END UNTIL byteType &lt;&gt; smLastByte;
   HUnlock(gMainTextHandle);
   IF (gNewLocation &gt;= 0) AND {range-check, update global}
      (gNewLocation + keySize &gt; GetHandleSize(gMainTextHandle)) 
THEN
      gNewLocation := -1;
END;
</PRE>
 The <CODE>FillParseTable</CODE> function is similar to <CODE>CharacterByteType</CODE>, in that it helps you find 2-byte characters. However, you don't send <CODE>FillParseTable</CODE> the character code to be analyzed. Instead, <CODE>FillParseTable</CODE> fills in an entire 256-byte table of information for you, showing every byte value that is the first byte of a 2-byte character for the current font. You can use the table filled out by <CODE>FillParseTable</CODE> to find 2-byte characters in a large body of text much more rapidly than you could by calling <CODE>CharacterByteType</CODE> for each byte value in the text.<A NAME=MARKER-2-697></A><P>
<A NAME=HEADING362-56></A>
<H4><A NAME=MARKER-9-698></A>Getting Character-Type Information</H4>
 <A NAME=MARKER-2-699></A>You may want to know more about a byte than whether it is part of a 2-byte character. If you are simply searching for sequences of Roman text in a buffer, or if you wish to divide a run of Japanese into Kanji, Katakana, Hiragana, and Romaji components, you can use the <CODE>FindScriptRun</CODE> function described in the chapter "Text Utilities" in this book. But if you have other reasons to isolate specific types of characters, you can use <CODE>CharacterType</CODE>.<P>
 The <CODE>CharacterType</CODE> function is similar to <CODE>CharacterByteType</CODE>, in that it tells you what kind of character occurs at a given offset in a text buffer. But the kind of information it returns is different. <CODE>CharacterType</CODE> tells you what the character's line direction is, whether it's uppercase, whether it belongs to a subscript within its script, whether it's a 2-byte character, and what the character's specific type and class are--letter or punctuation, low-ASCII or high-ASCII Roman letter, Katakana or Hiragana, Jamo or Hangul, and so on.<P>
 <A NAME=MARKER-2-700></A>When you call the <CODE>CharacterType</CODE> function, you pass it a byte offset; it returns a <BR>value that is an integer bit field giving information about the character at that offset. See <A HREF=#MARKER-9-702>Figure 6-2</A>.<A NAME=MARKER-2-701></A> The paragraphs following the figure describe the fields.<P>
<B>Figure 6-2  <A NAME=MARKER-9-702></A>Fields in the <CODE>CharacterType</CODE> return value</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/SM_L-05.jpg">
 <A NAME=MARKER-9-703></A>Bits 0-3 of the <CODE>CharacterType</CODE> function result describe the <A NAME=MARKER-2-704></A><B>character type</B> of the character in question.<P>
<UL>
<LI>The Roman script system recognizes three basic character types, defined by the following constants:
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>&nbsp;<TH>Character type<TH>Hex. value<TH>Explanation<TR>
<TD>&nbsp;<TD><A NAME=MARKER-2-604></A>smCharPunct<TD>$0000<TD>Punctuation (anything but a letter)<TR>
<TD>&nbsp;<TD><A NAME=MARKER-2-605></A>smCharAscii<TD>$0001<TD>ASCII letter (not a number or symbol, <BR>character code &lt;= $7F)<TR>
<TD>&nbsp;<TD><A NAME=MARKER-2-606></A>smCharExtAscii<TD>$0007<TD>High-ASCII Roman letter (not a number or symbol, character code &gt;= $80)</TABLE>

<LI>Additional character-type constants are provided for Japanese Katakana and Hiragana; the ideographic subscripts such as Hanzi, Kanji, and Hanja; 2-byte Cyrillic and Greek in 2-byte systems; bidirectional script systems such as Arabic and Hebrew; and Korean Hangul and Jamo subscripts:
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>&nbsp;<TH>Character type<TH>Hex. value<TH>Explanation<TR>
<TD>&nbsp;<TD><A NAME=MARKER-2-588></A>smCharKatakana<TD>$0002<TD>Japanese Katakana<TR>
<TD>&nbsp;<TD><A NAME=MARKER-2-589></A>smCharHiragana<TD>$0003<TD>Japanese Hiragana<TR>
<TD>&nbsp;<TD><A NAME=MARKER-2-590></A>smCharIdeographic<TD>$0004<TD>Hanzi, Kanji, Hanja<TR>
<TD>&nbsp;<TD><A NAME=MARKER-2-591></A>smCharTwoByteGreek<TD>$0005<TD>2-byte Greek in 2-byte scripts<TR>
<TD>&nbsp;<TD><A NAME=MARKER-2-592></A>smCharTwoByteRussian<TD>$0006<TD>2-byte Cyrillic in 2-byte scripts<TR>
<TD>&nbsp;<TD><A NAME=MARKER-2-593></A>smCharBidirect<TD>$0008<TD>Arabic, Hebrew<TR>
<TD>&nbsp;<TD><A NAME=MARKER-2-594></A>smCharContextualLR<TD>$0009<TD>Thai, Indic, etc.<EM></EM><TR>
<TD>&nbsp;<TD><A NAME=MARKER-2-595></A>smCharNonContextualLR<TD>$000A<TD>Cyrillic, Greek, etc.<EM></EM><TR>
<TD>&nbsp;<TD><A NAME=MARKER-2-596></A>smCharHangul<TD>$000C<TD>Korean Hangul<TR>
<TD>&nbsp;<TD><A NAME=MARKER-2-597></A>smCharJamo<TD>$000D<TD>Korean Jamo<TR>
<TD>&nbsp;<TD><A NAME=MARKER-2-598></A>smCharBopomofo<TD>$000E<TD>Chinese Bopomofo (Zhuyinfuhao)</TABLE>
<P>
</UL>
 <A NAME=MARKER-9-705></A>Bits 8-11 of the <CODE>CharacterType</CODE> function result describe the <A NAME=MARKER-2-706></A><B>character class</B> of the character in question. Character classes can be considered as subtypes of character types; a given character type can have several classes that belong to it.<P>
<UL>
<LI>If the character type is <CODE>smCharPunct</CODE>, the following character classes are defined that include punctuation for both 1-byte and 2-byte script systems:<B>
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>&nbsp;<TH>Character class<TH>Hex. value<TH>Explanation<TR>
<TD>&nbsp;<TD><A NAME=MARKER-2-607></A>smPunctNormal<TD>$0000<TD>Normal punctuation (such as ! , . ;?)<TR>
<TD>&nbsp;<TD><A NAME=MARKER-2-608></A>smPunctNumber<TD>$0100<TD>Number character (such as 0-9)<TR>
<TD>&nbsp;<TD><A NAME=MARKER-2-609></A>smPunctSymbol<TD>$0200<TD>Nonpunctuation symbol (such as # $ &amp;)<TR>
<TD>&nbsp;<TD><A NAME=MARKER-2-610></A>smPunctBlank<TD>$0300<TD>Blank character (such as ASCII $00, $0D, $20)<TR>
<TD>&nbsp;<TD><A NAME=MARKER-2-611></A>smPunctRepeat<TD>$0400<TD>Repeat marker in 2-byte script<TR>
<TD>&nbsp;<TD><A NAME=MARKER-2-612></A>smPunctGraphic<TD>$0500<TD>Line graphics in 2-byte script</TABLE>
</B>
<LI>In the Korean script system, if the character type is <CODE>smCharJamo</CODE>, the following character classes are defined. They determine whether a given byte contains a simple or complex consonant or a simple or complex vowel:<B>
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>&nbsp;<TH>Character class<TH>Hex. value<TH>Explanation<TR>
<TD>&nbsp;<TD><A NAME=MARKER-2-613></A>smJamoJaeum<TD>$0000<TD>Simple consonant character<TR>
<TD>&nbsp;<TD><A NAME=MARKER-2-614></A>smJamoBogJaeum<TD>$0100<TD>Complex consonant character<TR>
<TD>&nbsp;<TD><A NAME=MARKER-2-615></A>smJamoMoeum<TD>$0200<TD>Simple vowel character<TR>
<TD>&nbsp;<TD><A NAME=MARKER-2-616></A>smJamoBogMoeum<TD>$0300<TD>Complex vowel character</TABLE>
</B><P>
The Jamo and Hangul subscripts of Korean are discussed briefly along with input methods in the chapter "Introduction to Text on the Macintosh" in this book.
<LI>In the Japanese script system, if the character type is <CODE>smCharKatakana</CODE> or <CODE>smCharHiragana</CODE>, the following character classes are defined:
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>&nbsp;<TH>Character class<TH>Hex. value<TH>Explanation<TR>
<TD>&nbsp;<TD>&nbsp;<TD>$0000<TD>(none of the following defined classes)<TR>
<TD>&nbsp;<TD><A NAME=MARKER-2-617></A>smKanaSmall<TD>$0001<TD>Small Kana character<TR>
<TD>&nbsp;<TD><A NAME=MARKER-2-618></A>smKanaHardOK<TD>$0002<TD>Can have dakuten<TR>
<TD>&nbsp;<TD><A NAME=MARKER-2-619></A>smKanaSoftOK<TD>$0003<TD>Can have dakuten or han-dakuten</TABLE>
<P>
A small Kana character is a special form of <A NAME=MARKER-2-707></A>Kana used to modify the pronunciation of a previous (full-sized) Kana character. <A NAME=MARKER-2-708></A>Dakuten and <A NAME=MARKER-2-709></A>han-dakuten are pronunciation marks that soften consonant sounds in Kana.<EM></EM>
<LI>In 2-byte script systems, if the character type is <CODE>smCharIdeographic</CODE>, the following character classes are defined:
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>&nbsp;<TH>Character class<TH>Hex. value<TH>Explanation<TR>
<TD>&nbsp;<TD><A NAME=MARKER-2-620></A>smIdeographicLevel1<TD>$0000<TD>Level 1 characters<TR>
<TD>&nbsp;<TD><A NAME=MARKER-2-621></A>smIdeographicLevel2<TD>$0100<TD>Level 2 characters<TR>
<TD>&nbsp;<TD><A NAME=MARKER-2-622></A>smIdeographicUser<TD>$0200<TD>User characters</TABLE>
<P>
The characters specified by the <CODE>smIdeographicLevel1</CODE> constant are part of the <BR>level 1 Han character set specified by Japanese, Chinese, and Korean government standards. Approximately 90 percent of normal text consists of characters from the level 1 set.<P>
The characters specified by the smIdeographicLevel2 constant are part of the <BR>level 2 Han character set, which includes obscure characters. The level 1 and level 2 character sets combined contain 98 percent of the character set used in the Kanji subscript.<P>
The characters specified by smIdeographicUser represent custom characters created by the user.<P>
</UL>
 Bits 12-15 of the <CODE>CharacterType</CODE> function result are the <A NAME=MARKER-2-710></A><I>character modifiers</I> of the character in question. One bit describes each modifier.<P>
<UL>
<LI>Bit 12 specifies the <I>orientation</I> of the character: whether it is intended for horizontal or vertical writing.
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>&nbsp;<TH>Character orientation<TH>Hex. value<TH>Explanation<TR>
<TD>&nbsp;<TD><A NAME=MARKER-2-623></A>smCharHorizontal<TD>$0000<TD>Character form is for horizontal writing, or for both horizontal and vertical<TR>
<TD>&nbsp;<TD><A NAME=MARKER-2-624></A>smCharVertical<TD>$1000<TD>Character form is for vertical writing only</TABLE>

<LI>Bit 13 specifies the <I><A NAME=MARKER-8-151></A>direction</I> of the character: whether its line direction is left-to-right or right-to-left.
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>&nbsp;<TH>Character direction<TH>Hex. value<TH>Explanation<TR>
<TD>&nbsp;<TD><A NAME=MARKER-2-625></A>smCharLeft<TD>$0000<TD>Character with left-to-right line direction<TR>
<TD>&nbsp;<TD><A NAME=MARKER-2-626></A>smCharRight<TD>$2000<TD>Character with right-to-left line direction</TABLE>

<LI>Bit 14 specifies the<B> <I><A NAME=MARKER-2-50></A>case</I></B> of the character: whether it is lowercase or uppercase.
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>&nbsp;<TH>Character case<TH>Hex. value<TH>Explanation<TR>
<TD>&nbsp;<TD><A NAME=MARKER-2-550></A>smCharLower<TD>$0000<TD>Lowercase character<TR>
<TD>&nbsp;<TD><A NAME=MARKER-2-551></A>smCharUpper<TD>$4000<TD>Uppercase character</TABLE>

<LI>Bit 15 specifies the<B> <I>size</I></B> of the character: whether it is 1 or 2 bytes long.
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>&nbsp;<TH>Character size<TH>Hex. value<TH>Explanation<TR>
<TD>&nbsp;<TD><A NAME=MARKER-2-552></A>smChar1byte<TD>$0000<TD>1-byte character<TR>
<TD>&nbsp;<TD><A NAME=MARKER-2-553></A>smChar2byte<TD>$8000<TD>2-byte character</TABLE>
<P>
</UL>
 You can describe individual characters with combinations of these constants. For example, if the byte being examined by <CODE>CharacterType</CODE> is a 1-byte English uppercase "A", then the value of the result could be expressed as <CODE>smChar1Byte</CODE> + <CODE>smCharUpper</CODE> + <CODE>smCharLeft</CODE> + <CODE>smCharASCII</CODE>. <CODE>CharacterType</CODE> indicates blank characters by a type <CODE>smCharPunct</CODE> and a class <CODE>smCharBlank</CODE>.<P>
 Some values are meaningful only in certain subscripts or script systems. The value <CODE>smCharUpper</CODE> is meaningless in a subscript that has no uppercase characters, for example; the value smIdeographicLevel is meaningless in 1-byte script systems.<P>
 You can use <CODE>CharacterType</CODE> for a variety of purposes--to validate input in numeric fields, to filter non-phonetic characters in an input method, or to search for punctuation, uppercase letters, and symbols. If you are breaking lines of text and are not using the Text Utilities <CODE>StyledLineBreak</CODE> function, you can use <CODE>CharacterType</CODE> to locate and skip whitespace characters at the ends of lines; see the description of text drawing in the chapter "QuickDraw Text" in this book.<P>
 The <CODE>CharacterType</CODE> function is described further on <A HREF=Text-393.html#MARKER-9-954>page 6-85</A>.<A NAME=MARKER-2-715></A>  <A NAME=MARKER-2-716></A>   <A NAME=MARKER-2-372></A><P>
<A NAME=HEADING362-84></A>
<H3>Directly Accessing International Resources</H3>
 <A NAME=MARKER-2-45></A>This section shows how you can directly access the international resources of a script system. Such direct access can help you be more efficient in creating bilingual applications, formatting numbers in different scripts, accessing character information, and using tokens. Several script-aware Text Utilities calls can take a handle to an international resource as an input parameter; you can use the calls in this section to obtain those handles.<P>
 Your application can examine the international resources that determine numeric formats, date formats, string sorting, conversion to tokens, and character encoding or rendering by making the calls described here. You can also retrieve individual tables from some of the resources.<P>
 This access also helps you to provide your own versions or regional variations of certain international resources. See <A HREF=Text-364.html#MARKER-9-776>"Replacing a Script System's Default International Resources" beginning on page 6-48</A> for more information.<P>
<DL>
<DT><B>Note</B>
<DD>Although you can access the international resources independently through the Resource Manager function <CODE>GetResource</CODE> and related calls, you can be sure to get the preferred resource of the current script system by using the calls described here.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 <A NAME=MARKER-2-135></A>The calls you make to access the international resources are <CODE>ClearIntlResourceCache</CODE>, <CODE>GetIntlResource</CODE>, and <CODE>GetIntlResourceTable</CODE>. With them, you have access to the contents of a script system's numeric-format (<CODE>'itl0'</CODE>), long-date-format (<CODE>'itl1'</CODE>), string-manipulation (<CODE>'itl2'</CODE>), tokens (<CODE>'itl4'</CODE>), and encoding/rendering (<CODE>'itl5'</CODE>) resources.<P>
 To access one of these resources for the current script, follow these steps:<P>
<OL>
<LI>Make sure the current script is the script system containing the international resource you want to access. See <A HREF=#MARKER-9-678>"Determining Script Codes From Font Information" on page 6-21</A>. You may need to verify the settings of the font script, the system script, and the international resources selection flag. See <A HREF=#MARKER-9-689>"Using the International Resources Selection Flag" on page 6-25</A>.
<LI>If you need access to any version of the current script's string-manipulation or tokens resources other than its default version, call <CODE>ClearIntlResourceCache</CODE> first. See <A HREF=Text-364.html#MARKER-9-776>"Replacing a Script System's Default International Resources" on page 6-48</A>.
<LI>Call <CODE>GetIntlResource</CODE>, specifying the type of resource you need. <CODE>GetIntlResource</CODE> returns a handle to the resource.<P>
</OL>
 For an example of using <CODE>GetIntlResource</CODE> to extract information from an international resource, see the next section, <A HREF=#MARKER-9-722>"Using Currency, Number, and Date Formats."</A><P>
 <A NAME=MARKER-2-720></A>To access a specific table within a string-manipulation or tokens resource, follow <BR>these steps:<P>
<OL>
<LI>If you don't already have it, determine the script code of the script system containing the international resource you want to access. See <A HREF=#MARKER-9-678>"Determining Script Codes From Font Information" on page 6-21</A>.
<LI>If you need access to any other than the script's default version of that resource, call <CODE>ClearIntlResourceCache</CODE> first. See <A HREF=Text-364.html#MARKER-9-776>"Replacing a Script System's Default International Resources" on page 6-48</A>.
<LI>Call <CODE>GetIntlResourceTable</CODE> to get the specified table within the specified resource belonging to the specified script system. Depending on the resource, you can get its number-parts, untoken, word-selection, line-break, or whitespace table.<P>
</OL>
 For more information about these tables, see the following sections: <A HREF=#MARKER-9-727>"Using Number Parts,"</A> <A HREF=#MARKER-9-730>"Retrieving Text From Tokens,"</A> <A HREF=#MARKER-9-735>"Using Word-Break Tables,"</A> and <A HREF=#MARKER-9-738>"Using Whitespace Information."</A><P>
<DL>
<DT><B>IMPORTANT</B>
<DD>Any time you replace the default international resources for a script system, whether or not you subsequently call <CODE>GetIntlResource</CODE> or <CODE>GetIntlResourceTable</CODE>, you need to call <CODE>ClearIntlResourceCache</CODE>, to make sure that the replacements are used by all script-aware calls. See <A HREF=Text-364.html#MARKER-9-776>"Replacing a Script System's Default International Resources" beginning on page 6-48</A>.<A NAME=MARKER-2-721></A><EM></EM><B></B>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING362-101></A>
<H3><A NAME=MARKER-9-722></A>Using Currency, Number, and Date Formats</H3>
 <A NAME=MARKER-9-173></A>In general, you should use the Text Utilities routines for date, time, and number formatting. See the chapter "Text Utilities" in this book. If, however, you need to directly access fields in the numeric-format (<CODE>'itl0'</CODE>) and long-date-format (<CODE>'itl1'</CODE>) resources to find the characters, separators, strings, and orders for formatting numbers, dates, and times, you can do so with <CODE>GetIntlResource</CODE>.<P>
 <A HREF=#MARKER-9-724>Listing 6-7</A> shows how to determine the decimal, thousands, and list separators for number formatting in the current script. To access the numeric-format resource, the routine specifies a resource selector of 0 (for <CODE>'itl0'</CODE>) in the parameter <CODE>theID</CODE> of the <CODE>GetIntlResource</CODE> function. It then extracts the values it wants from the decimalPt, <CODE>thousSep</CODE>, and <CODE>listSep</CODE> fields.<P>
<B>Listing 6-7  <A NAME=MARKER-9-724></A>Determining the number separators for the current script</B><P>
<PRE>
PROCEDURE MyGetNumberSeparators (VAR myDecimal:Char; 
                                 VAR myThousands:Char; 
                                 VAR myListSep:Char);
VAR
   myHandle:      Intl0Hndl;
                           {make sure the desired script is set }
                           { before calling this routine}
BEGIN
   myHandle := Intl0Hndl(GetIntlResource(0));{Get 'itl0' resource}
   myDecimal := myHandle^^.decimalPt;  {for example, 1.234}
   myThousands := myHandle^^.thousSep; {for example, 1,234,567}
   myListSep := myHandle^^.listSep;    {for example, 1;2;3}
END;
</PRE>
<DL>
<DT><B>IMPORTANT</B>
<DD>Do not assume that the components of dates and times are always ordered in a left-to-right direction when displayed. If you are drawing individual time components, be careful not to simply draw them from left to right in all cases. For instance, the AM/PM characters in an English time string are on the right, whereas in an Arabic time string the equivalent characters may be on the left or right, depending on the primary line direction--even though in both cases these characters are at the end of the time string in memory.<EM></EM><A NAME=MARKER-2-725></A>   <A NAME=MARKER-8-153></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING362-107></A>
<H3><A NAME=MARKER-9-727></A>Using Number Parts</H3>
 <A NAME=MARKER-2-252></A>You can access information on how separators and other parts of formatted numbers are represented in a particular script system by examining the<B> number parts table</B> in the script's tokens (<CODE>'itl4'</CODE>) resource. Unlike the numeric-format resource, the number parts table supports 2-byte characters; it also contains more information, especially for complicated number formats such as scientific notation.<P>
 Your most common reason for obtaining the number parts table may be to pass it as a parameter to the Text Utilities functions <CODE>StringToFormatRec</CODE>, <CODE>FormatRecToString</CODE>, <CODE>StringToExtended</CODE>, and <CODE>ExtendedToString</CODE>. But you can also examine its contents. <A HREF=#MARKER-9-729>Listing 6-8</A> shows how to call the <CODE>GetIntlResourceTable</CODE> procedure, with a table selector of smNumberPartsTable, to obtain the number parts table associated with a given script. The routine obtains the character associated with the number part specified by <CODE>thePart</CODE> and saves it as a wide character, which is a character of either 1 or 2 bytes. (See the discussion of the tokens resource in the appendix "International Resources" for a definition of the <CODE>WideChar</CODE> data type.) To specify the system script, the parameter <CODE>theScript</CODE> would have the value <CODE>smSystemScript</CODE>. The parameter <CODE>thePart</CODE> can have such values as <CODE>tokDecPoint</CODE> and <CODE>tokThousands</CODE>. For a complete list of number-parts constants, see the description of the tokens resource in the appendix "International Resources" in this book.<P>
<B>Listing 6-8  <A NAME=MARKER-9-729></A>Getting number parts from a script system's number parts table</B><P>
<PRE>
PROCEDURE MyMapNumPartToWideChar(theScript: ScriptCode; 
                                 thePart: Integer; 
                                 VAR theWChar: WideChar);
VAR
   itlHandle: Handle;
   numpartsOffset: Longint;
   numpartsLength: LongInt;
   numpartsPtr: NumberPartsPtr;

BEGIN
   GetIntlResourceTable(theScript, smNumberPartsTable, 
                        itlHandle, numpartsOffset, 
                        numpartsLength);
   
   IF itlHandle = NIL THEN    {handle errors, }
      theWChar.b := 0         { return null WideChar}
   ELSE BEGIN                 {make numpartsPtr point to }
                              { beginning of number parts table}

      numpartsPtr := NumberPartsPtr(LongInt(itlHandle^) + 
                     numpartsOffset);
      IF thePart &gt; tokMaxSymbols THEN  {invalid number part-- }
                                       { handle  error, }
         theWChar.b := 0               { return null WideChar}
      ELSE BEGIN
         theWChar := numpartsPtr^.data[thePart];
      END;
   END;
END;
</PRE>
<A NAME=HEADING362-113></A>
<H3><A NAME=MARKER-9-730></A>Retrieving Text From Tokens</H3>
 <A NAME=MARKER-2-66></A>Tokens are abstract entities that stand for classes of text items such as alphanumeric strings, various symbols, and quoted literals. The Script Manager <CODE>IntlTokenize</CODE> function converts programming-language text into script-independent tokens useful to compilers or interpreters. See <A HREF=Text-363.html#MARKER-9-741>"Tokenization" on page 6-38</A>. The<B> untoken table</B> in a script system's tokens (<CODE>'itl4'</CODE>) resource has the opposite purpose; it helps you convert script-independent tokens into the text of a given script system.<P>
 The untoken table lists the characters associated with each fixed (invariant) token defined by that script. (An invariant token is one that, like <CODE>tokenColon</CODE>, represents a unique symbol. Other types of tokens, like <CODE>tokenAlpha</CODE>, represent an arbitrary sequence of characters.) If you need to find out, for example, how a given script system represents the "less than or equal to" symbol (is it the 1-byte character "\xE6", a 2-byte encoding of the character "\xE6", the 2-byte, 2-character sequence "&lt;=", or something else altogether?), you can look up the values of <CODE>tokenLessEqual1</CODE> and <CODE>tokenLessEqual2</CODE> in that script's untoken table.<P>
 The untoken table is most useful for obtaining script-specific forms for individual common symbols, such as the ellipsis or center dot. If you truncate strings with the ellipsis character (...) or use the center dot () such as AppleShare does for echoing passwords, don't hardcode their character codes; they may not be valid in some script systems. Instead, specify <CODE>tokenEllipsis</CODE> or <CODE>tokenCenterDot</CODE>, and use the untoken table of the current script system to obtain the proper text for those tokens.<P>
<DL>
<DT><B>Note</B>
<DD>If a script system has no defined character or string that corresponds to a particular token, the untoken table contains either a null string or the string "??" for that token.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 You access the untoken table by calling the <CODE>GetIntlResourceTable</CODE> procedure with a table selector of <CODE>smNumberPartsTable</CODE>. <A HREF=#MARKER-9-733>Listing 6-9</A> provides an example of how to access the untoken table in the tokens resource. This code sample extracts the <A NAME=MARKER-2-175></A>canonical string associated with a token. It sets the parameter <CODE>theString</CODE> to the string that corresponds to the token <CODE>theToken</CODE>. (Usually, this string is 4 bytes or less.) To specify the system script, the parameter <CODE>theScript</CODE> would have the value <CODE>smSystemScript</CODE>. The parameter <CODE>theToken</CODE> can have such values as <CODE>tokenNoBreakSpace</CODE>, <CODE>tokenEllipsis</CODE>, and <CODE>tokenCenterDot</CODE>. For a complete list of defined constants for tokens, see <A HREF=Text-370.html#MARKER-9-796>"Token Codes" beginning on page 6-58</A>.<P>
<B>Listing 6-9  <A NAME=MARKER-9-733></A>Getting a token string from the untoken table</B><P>
<PRE>
PROCEDURE MyMapTokenToString(theScript: ScriptCode; theToken: 
Integer; VAR theString: Str255);

VAR
   itlHandle:        Handle;
   untokenOffset:    LongInt;
   untokenLength:    LongInt;
   untokenPtr:       UntokenTablePtr;
   untokenStringPtr: StringPtr;

BEGIN
   GetIntlResourceTable(theScript, smUnTokenTable, itlHandle, 
                        untokenOffset, untokenLength);
   
   IF itlHandle = NIL THEN    {handle errors, return null string}
      theString := ''
   ELSE BEGIN                 {make untokenPtr point to the }
                              { beginning of the untoken table}
      untokenPtr := UntokenTablePtr(LongInt(itlHandle^) + 
                     untokenOffset);
      IF theToken &gt; untokenPtr^.lastToken THEN  {this token is }
                                             { not in table-- } 
         theString := ''                     { return null string}
      ELSE BEGIN              {index[theToken] is the offset }
                              { of the desired string from the }
                              { beginning of the untoken table}
         untokenStringPtr := StringPtr(LongInt(untokenPtr) +
untokenPtr^.index[theToken]);
         theString := untokenStringPtr^;
      END;
   END;
END;
</PRE>
 Even though using the untoken table is conceptually the converse of calling the <CODE>IntlTokenize</CODE> function, their purposes are different. <CODE>IntlTokenize</CODE> is used as a first step toward compiling or interpreting programming-language source text, and its results are rarely returned or reconverted to source text. The untoken table is most commonly used to supply localized text for individual common tokens.<A NAME=MARKER-2-288></A><B></B><P>
<A NAME=HEADING362-123></A>
<H3><A NAME=MARKER-9-735></A>Using Word-Break Tables</H3>
 <A NAME=MARKER-2-736></A>If you use the Text Utilities <CODE>FindWordBreaks</CODE> procedure to determine the boundaries of a word, you normally do not need to pass it an explicit pointer to a word-break table. However, if you want to use a custom word-break table you can pass <CODE>FindWordBreaks</CODE> a pointer to that table. Word-break tables are in a script system's string-manipulation (<CODE>'itl2'</CODE>) resource; you can gain access to them by calling the <CODE>GetIntlResourceTable</CODE> procedure with a table selector of <CODE>smWordSelectTable</CODE> or <CODE>smWordWrapTable</CODE>.<P>
 There are two possible table selectors because a script system may have different word breaks for word selection than it does for line breaking. If you are using <CODE>FindWordBreaks</CODE> to select an individual word, use <CODE>smWordSelectTable</CODE> when you call <CODE>GetIntlResourceTable</CODE> to obtain the word-break table. If you are using <CODE>FindWordBreaks</CODE> to find line breaks, use <CODE>smWordWrapTable</CODE> when you call <CODE>GetIntlResourceTable</CODE>.<A NAME=MARKER-2-737></A><P>
<A NAME=HEADING362-126></A>
<H3><A NAME=MARKER-9-738></A>Using Whitespace Information</H3>
 <A NAME=MARKER-2-739></A>Most applications that need whitespace information, such as when eliminating extra spaces in text or searching for non-space characters, can get it by calling the <CODE>CharacterType</CODE> function. However, if your application needs a listing of all valid whitespace characters in a script system, you can call <CODE>GetIntlResourceTable</CODE> with a table selector of <CODE>smWhiteSpaceList</CODE>. <CODE>GetIntlResourceTable</CODE> returns the whitespace table from the script system's tokens resource.<A NAME=MARKER-2-740></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Text-361.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Text-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Text-594.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Text-363.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Text-3.html">&copy; Apple Computer, Inc.</A><br>6 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
