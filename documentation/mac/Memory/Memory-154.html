<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Virtual Memory and Debuggers (IM: M)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING154></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Memory-153.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Memory-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Memory-202.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Memory-155.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Memory-2.html"><B>Memory</B></A> / <BR><DD><A HREF="Memory-151.html"><B>Chapter 3 - Virtual Memory Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING154-0></A>
<H1><A NAME=MARKER-9-140></A>Virtual Memory and Debuggers</H1>
<DL>
<DT><B>Note</B>
<DD>You need the information in this section only if you are writing a debugger that is to operate under virtual memory.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 <A NAME=MARKER-2-141></A><A NAME=MARKER-2-142></A>Debuggers running under virtual memory can use any of the virtual memory routines discussed in the previous sections. For example, if a debugger is in a situation where page faulting would be fatal, it can use <CODE>DeferUserFn</CODE> to defer the debugging until paging is safe. However, debuggers running under virtual memory might require a few routines that differ from those available to other applications. In addition, debuggers might depend on some specific features of virtual memory that other applications should not depend on.<P>
 For example, because debugger code might be entered at a time when paging would be unsafe, you should lock (and not just hold) the debugger and all of its data and buffer space in memory. Normally, the locking operation is used to allow NuBus masters or other DMA devices to transfer data directly into physical memory. This requires that data caching be disabled on the locked page. You might, however, want your debugger to benefit from the performance of the data cache on pages belonging solely to the debugger. The <CODE>DebuggerLockMemory</CODE> function does exactly what <CODE>LockMemory</CODE> does, except that it leaves data caching enabled on the affected pages. You can call the <CODE>DebuggerUnlockMemory</CODE> function to reverse the effects of <CODE>DebuggerLockMemory</CODE>.<A NAME=MARKER-2-309></A><A NAME=MARKER-2-346></A><A NAME=MARKER-2-145></A><A NAME=MARKER-2-42></A><P>
 Other special debugger support functions<P>
<UL>
<LI>determine whether paging is safe
<LI>allow the debugger to enter supervisor mode
<LI>enter and exit the debugging state
<LI>obtain keyboard input while in the debugging state
<LI>determine the state of a page of logical memory<P>
</UL>
 All of these functions are implemented as extensions of <CODE>_DebugUtil</CODE>, a trap intended for use by debuggers to allow greater machine independence. This trap is not present in the Macintosh II, Macintosh IIx, Macintosh IIcx, or Macintosh SE/30 models, but it is present in all later models. The Virtual Memory Manager implements this trap for all machines that it supports, so a debugger can use <CODE>_DebugUtil</CODE> (and functions defined in terms of <CODE>_DebugUtil</CODE>) if <CODE>Gestalt</CODE> reports that virtual memory is present.<A NAME=MARKER-2-316></A><P>
 When the virtual memory extensions to <CODE>_DebugUtil</CODE> are not present (that is, when the computer supports virtual memory but is <I>not</I> a Macintosh II, Macintosh IIx, Macintosh IIcx, or Macintosh SE/30), <CODE>_DebugUtil</CODE> provides functions that can determine the highest <CODE>_DebugUtil</CODE> function supported, enter the debugging state, poll the keyboard for input, and exit the debugging state.<P>
<A NAME=HEADING154-12></A>
<H2>Bus-Error Vectors</H2>
 The Operating System needs to intercept page faults and do the necessary paging. In addition, various applications and pieces of system software need to handle other kinds of bus errors. Virtual memory takes care of the complications of bus-error handling by providing two bus-error vectors. The vector that applications and other system software see is the one in low memory (at address $8). The vector that virtual memory uses (the one actually used by the processor) is in virtual memory's private storage and is pointed to by the Vector Base Register (VBR). Virtual memory's bus-error handler handles page faults and passes other bus errors to the vector in low memory at address $8.<A NAME=MARKER-2-148></A><A NAME=MARKER-2-149></A><A NAME=MARKER-2-150></A><A NAME=MARKER-2-41></A><P>
 When a debugger wants the contents of a page to be loaded into memory, it can read a byte from that page. The Operating System detects the page fault and loads the appropriate page (perhaps swapping another page to disk).<P>
 Note that a debugger will probably temporarily replace one or both of the bus-error vectors while it is executing. A debugger that wants virtual memory to continue paging while the debugger runs can put a handler only in the low-memory bus-error vector. A debugger that displays memory without allowing virtual memory to continue paging can put a handler in the virtual memory's bus-error vector (at VBR + $8).<P>
 Because the current version of virtual memory is not reentrant, there are times when trying to load a page into memory would be fatal. To allow for this, you can use the <CODE>PageFaultFatal</CODE> function to determine whether a page fault would be fatal at that time. If this function returns <CODE>TRUE</CODE>, the debugger should not allow the virtual memory's bus-error handler to detect any page faults. Thus, you should always replace the virtual memory's bus-error vector if the <CODE>PageFaultFatal</CODE> function returns <CODE>TRUE</CODE>.<A NAME=MARKER-2-326></A><P>
<A NAME=HEADING154-17></A>
<H2>Special Nonmaskable Interrupt Needs</H2>
 Because a debugger can be triggered with a nonmaskable interrupt (level 7, triggered by the interrupt switch), it has special needs that other code in the system does not. For example, because a nonmaskable interrupt might occur while virtual memory is moving pages (to make them contiguous, for example), debugger code must be locked (instead of held, like most other code that must run at a time when page faults would be fatal). Unfortunately, the <CODE>LockMemory</CODE> function is intended for use by device drivers and automatically disables data caching for the locked pages. Because this is not desirable for the debugger, the functions <CODE>DebuggerLockMemory</CODE> and <CODE>DebuggerUnlockMemory</CODE> lock pages without inhibiting the caching of those pages. Note that both stack, code, and other storage used by the debugger might need to be locked in this way.<A NAME=MARKER-9-153></A><A NAME=MARKER-9-139></A><A NAME=MARKER-2-155></A><A NAME=MARKER-2-156></A><P>
<A NAME=HEADING154-19></A>
<H2>Supervisor Mode</H2>
 Because a debugger is typically activated through one of the processor vectors, it usually executes in supervisor mode, allowing it access to all of memory and all processor registers. When the debugger is entered in another way--for example, through <BR>the <CODE>_Debugger</CODE> or <CODE>_DebugStr</CODE> trap or when it is first loaded--it is necessary to enter supervisor mode. You can accomplish this with the following assembly-language instructions:<A NAME=MARKER-2-163></A><P>
<PRE>
MOVEQ #EnterSupervisorMode,D0
_DebugUtil                    ;OS trap to DebugUtils
                              ;on exit, D0 still holds old SR
</PRE>
 The code switches the caller into supervisor mode, and the previous status register is returned in register D0. Thus, when the debugger returns to the interrupted code, you can restore the previous interrupt level, condition codes, and so forth. When the debugger is ready to return to user mode, it simply loads the status register with the result returned in D0. Entering supervisor mode also switches the stack pointer from the user stack pointer (USP) to the interrupt stack pointer (ISP); reentering user mode changes the stack pointer back to the user stack pointer.<A NAME=MARKER-2-76></A><A NAME=MARKER-2-94></A><A NAME=MARKER-2-160></A><A NAME=MARKER-2-161></A><P>
<A NAME=HEADING154-23></A>
<H2>The Debugging State</H2>
 When activated by an exception, <CODE>_Debug</CODE> or <CODE>_DebugStr</CODE> trap, or any other means, the debugger should call the <CODE>DebuggerEnter</CODE> procedure to notify <CODE>_DebugUtil</CODE> that the debugger is entering the debugging state. Then <CODE>_DebugUtil</CODE> can place hardware in a quiescent state and prepare for subsequent <CODE>_DebugUtil</CODE> calls.<A NAME=MARKER-2-162></A><P>
 Before returning to the interrupted application code, the debugger must call <BR>the <CODE>DebuggerExit</CODE> procedure to allow <CODE>_DebugUtil</CODE> to return hardware affected by <CODE>DebuggerEnter</CODE> to its previous state.<A NAME=MARKER-2-163></A><P>
<A NAME=HEADING154-26></A>
<H2>Keyboard Input</H2>
 A debugger can obtain the user's keyboard input by calling the <CODE>DebuggerPoll</CODE> procedure. This routine can obtain keyboard input even when interrupts are disabled. After you call this service, you must then obtain keyboard events through the normal event-queue mechanism.<A NAME=MARKER-2-164></A><P>
<A NAME=HEADING154-28></A>
<H2>Page States</H2>
 Debuggers need a way to display the contents of memory without paging or to display the contents of pages currently on disk. The <CODE>GetPageState</CODE> function returns one of these values to specify the state of a page containing a virtual address:<A NAME=MARKER-2-164></A><P>
<PRE>
TYPE PageState = Integer;
CONST
   kPageInMemory     = 0;           {page is in RAM}
   kPageOnDisk       = 1;           {page is on disk}
   kNotPaged         = 2;           {address is not paged}
</PRE>
 A debugger can use this information to determine whether certain memory addresses should be referenced. Note that ROM and I/O space are not pageable and therefore are considered not paged.<A NAME=MARKER-2-166></A><A NAME=MARKER-2-224></A><P>

</BLOCKQUOTE>
<HR>
<center>
<A HREF="Memory-153.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Memory-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Memory-202.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Memory-155.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Memory-3.html">&copy; Apple Computer, Inc.</A><br>3 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
