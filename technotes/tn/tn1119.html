<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 01-05-01 --><head><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note TN1119: Serial Port Apocrypha</title>   <meta name="keywords" content="Mac OS 8 serial port opening API Open Transport arbitrators"><meta name="Description" content="Technical Note TN1119: This Technical Note describes a numberof problems often encountered by developers when dealingwith serial ports under Mac OS. Specifically, this Note describesthe correct techniques for finding, opening, closing, andyielding serial ports under the classic serial API and theOpen Transport serial API. In addition, this Note describesthe theory and practice of the original and Open Transportserial port arbitrators."><meta name="categories" content="Devices and Networking"><meta name="week-posted" content="Mar 30, 1998 - Apr 3, 1998"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002959" title="Serial Port Apocrypha"></a><A NAME="top"></A><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxHardwareDrivers-date.html">Hardware & Drivers</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/HardwareDrivers/idxSerial-date.html" target="_blank">Hardware & Drivers > Serial</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1119</div>
<div id="pageheadsub">Serial Port Apocrypha</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><center><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left">          <!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                        <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left><!-- begin_toc --><p id="menutext"><A HREF = "#NotesforBothAPIs">Notes for         Both APIs</A><BR>                  <BR><A HREF = "#JustTheFactsClassicSerial">Just TheFacts: Classic Serial</A><BR><BR>         <A HREF = "#JustTheFactsOTSerial">Just The Facts: OT Serial</A><BR><BR>         <A HREF = "#ATaleofTwoArbitrators">A         Tale of Two Arbitrators</A><BR><BR><A HREF="#Summary">Summary</A><BR><BR><A HREF="#References">References</a><BR><BR><A HREF="#Downloads">Downloadables</A></p>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left>            			<!-- begin_intro_text --><p id="introtext">This Technote         describes a number of problems often encountered by         developers when dealing with serial ports under Mac OS. Most         of this information is available from other sources, but         those sources are obscure and commonly overlooked.</P>         <p id="introtext">Specifically, this Note describes the correct techniques         for finding, opening, closing, and yielding serial ports         under the classic serial API and the Open Transport serial         API. In addition, this Note describes the theory and         practice of the original and Open Transport serial port         arbitrators.</P>         <p id="introtext">This Technote is directed at all Mac OS developers who         use serial ports.</P>               <!-- end_intro_text --><!-- begin_date --><h3>&nbsp;Updated: [Apr 23 1998]</h3><!-- end_date -->        </td>    </tr></table> <!-- end_header_box --><BR><BR><hr width=500 align=center><BR><BR><!-- begin_content --><A NAME="NotesforBothAPIs"></A>                  <H2>Notes for Both APIs</H2>                  <P>Mac OS provides two APIs for accessing the serial port:         the classic serial API based on Device Manager         <CODE>'DRVR's</CODE>, described in         <I><a href="../../documentation/mac/Devices/Devices-2.html">Inside         Macintosh:Devices</A></I>, and the Open Transport serial         API, described in         <I><a href="../../documentation/mac/OpenTransport/OpenTransport-2.html">Inside         Macintosh: Open Transport</A></I>. This section contains         notes which are relevant to both serial APIs.</P>                  <H3>Open and Close on Demand         </H3>                  <P>A serial port is a non-sharable resource. If your         application has the port open, no other application can open         it. For this reason, you should always open and close the         serial port on demand.</P>                  <P>For example, if your application only uses the serial         port as part of its registration process, you open the port         when you commence the registration and close the port         immediately after you are done.</P>                  <H3>Yielding</H3>                  <P>Yielding is the process by which a passive serial program         can yield the serial port to an active serial program, and         regain the serial port after the active serial program is         done.</P>                  <P>For example, if you set Apple Remote Access (version 2.1         and lower) to wait for an incoming call, you can still make         outgoing PPP connections using FreePPP. This is because the         passive serial program (ARA) yields the serial port to the         active serial program (FreePPP). When FreePPP closes the         serial port, ARA will resume ownership and continue waiting         for an incoming call.</p><BR><P><A HREF="#top">Back to top</A></P><P><A NAME="JustTheFactsClassicSerial"></A></P><H2>Just The Facts: Classic Serial</H2><P>The classic serial architecture is based on Device Manager<CODE>'DRVR's</CODE>, as described in<I><a href="../../documentation/mac/Devices/Devices-2.html">InsideMacintosh:Devices</A></I>. This section describes the correct way tofind, open, close, and yield serial ports under the classic serialarchitecture.</P><H3>Finding All Serial Ports</H3><P>The correct way to find all the serial ports under Mac OS is touse the Communications Resource Manager (CRM) routine<CODE>CRMSearch</CODE> (part of the Communications Toolbox).Unfortunately, the book that documents the Communications ResourceManager (<I><A HREF = "#FurtherReferences">Inside the MacintoshCommunications Toolbox</A></I>) is not available in electronic form,so it can be hard to find documentation for <CODE>CRMSearch</CODE>.The following sample is included to make up for this deficiency:</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>static void PrintInfoAboutAllSerialPorts(void)    // Prints a list of all the serial ports on the    // machine, along with their corresponding input    // and output driver names, to stdout.  Typically    // you would use a routine like this to populate a    // popup menu of the available serial ports.{    CRMRec          commRecord;    CRMRecPtr       thisCommRecord;    CRMSerialPtr    serialPtr;    (void) InitCRM();    // First set up commRecord to specify that    // we're interested in serial devices.    commRecord.crmDeviceType = crmSerialDevice;    commRecord.crmDeviceID   = 0;&nbsp;    // Now repeatedly call CRMSearch to iterate    // through all the serial ports.&nbsp;    thisCommRecord = &amp;commRecord;    do {        thisCommRecord = (CRMRecPtr) CRMSearch( (CRMRecPtr) thisCommRecord );        if ( thisCommRecord != nil ) {            // Once we a have a CRMRec for the serial port,            // we must cast the crmAttributes field to            // a CRMSerialPtr to access to serial-specific            // fields about the port.&nbsp;            serialPtr = (CRMSerialPtr) thisCommRecord-&gt;crmAttributes;&nbsp;            // Print the information about the port.            printf("We have a port called: '%#s'\n", *(serialPtr-&gt;name));            printf("   input driver named: '%#s'\n", *(serialPtr-&gt;inputDriverName));            printf("  output driver named: '%#s'\n", *(serialPtr-&gt;outputDriverName));            printf("\n");&nbsp;            // Now ensure that CRMSearch finds the next device.            commRecord.crmDeviceID = thisCommRecord-&gt;crmDeviceID;        }    } while ( thisCommRecord != nil );}&nbsp;</pre></TD></TR></TABLE></CENTER><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>                  The CRM is available in System 7.0 and later. It is an         installable option under System 6. If your product runs         under System 6, you should check for the presence of the CRM         by calling <CODE> Gestalt</CODE> with the <CODE>         gestaltCRMAttr</CODE> selector and checking that the <CODE>         gestaltCRMPresent</CODE> bit is set in the response.</P></TD></TR></TABLE></CENTER><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>                  Ports registered with the CRM are supposed to "work         like" the standard built-in serial ports. However, in some         cases (both Apple and third party), it's just not possible         to implement the API of the built-in serial ports exactly.         When dealing with CRM-registered ports, your application         should handle cases where this emulation breaks down. For         example, if your application uses the externally clocked         quasi-MIDI mode (csCode 15), it should gracefully fail if         a serial driver returns an error when asked to engage this         mode.</P></TD></TR></TABLE></CENTER><BR><BR><H3>Opening a Serial Port</H3><P>The correct way to open a serial port has been documented for manyyears as part of the <A HREF = "#FurtherReferences">ARA API</A>document, currently available on the Mac OS SDK Developer CDs.However, this source is somewhat obscure (and the enclosed samplecode is somewhat out of date), so the information is repeated herefor your convenience.</P><P>The process is very easy to describe in English:</P><BLOCKQUOTE><P><A NAME="NewRule"></A>If a serial port arbitrator isinstalled, always call <CODE>OpenDriver</CODE> to open the serialport; otherwise, walk the unit table to determine whether the driveris already open, and open it only if it isn't.</P></BLOCKQUOTE><P>This high-level algorithm is captured in the following routinesfor opening both the input and output serial drivers:</P>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>static OSErr OpenOneSerialDriver(ConstStr255Param driverName, short *refNum)    // The one true way of opening a serial driver.  This routine    // tests whether a serial port arbitrator exists.  If it does,    // it relies on the SPA to do the right thing when OpenDriver is called.    // If not, it uses the old mechanism, which is to walk the unit table    // to see whether the driver is already in use by another program.{    OSErr err;    if ( SerialArbitrationExists() ) {        err = OpenDriver(driverName, refNum);    } else {        if ( DriverIsOpen(driverName) ) {            err = portInUse;        } else {            err = OpenDriver(driverName, refNum);        }    }    return err;}&nbsp;static OSErr OpenSerialDrivers(ConstStr255Param inName, ConstStr255Param outName,                                SInt16 *inRefNum, SInt16 *outRefNum)    // Opens both the input and output serial drivers, and returns their    // refNums.  Both refNums come back as an illegal value (0) if we    // can't open either of the drivers.{    OSErr err;    err = OpenOneSerialDriver(outName, outRefNum);    if (err == noErr) {        err = OpenOneSerialDriver(inName, inRefNum);        if (err != noErr) {            (void) CloseDriver(*outRefNum);        }    }    if (err != noErr) {        *inRefNum = 0;        *outRefNum = 0;    }    return err;}</pre></TD></TR></TABLE></CENTER><BR><BR><P>The above code opens the output serial driver before opening theinput serial driver. This is the recommended order for the built-inserial drivers, and consequently for other CRM-registered serialdrivers. This is because the output driver is the one that reservessystem resources and actually checks for the availability of theport. For the built-in serial ports, if you successfully open theoutput driver, you should always be able to open the input driver.Not all CRM-registered serial drivers work this way, however, so yourcode should always check the error result from both opens.</P><P>The code for determining whether a serial port arbitrator isinstalled is shown below:</P>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>enum {    gestaltSerialPortArbitratorAttr = 'arb ',        gestaltSerialPortArbitratorExists = 0};&nbsp;static Boolean SerialArbitrationExists(void)    // Test Gestalt to see if serial arbitration exists    // on this machine.{    Boolean result;    long    response;    result = ( Gestalt(gestaltSerialPortArbitratorAttr, &amp;response) == noErr &amp;&amp;                (response &amp; (1 &lt;&lt; gestaltSerialPortArbitratorExists) != 0)  != 0)                );    return result;}</pre></TD></TR></TABLE></CENTER><BR><BR><P>The final part of the puzzle is the routine<CODE>DriverIsOpen</CODE>, which walks the unit table to see if thedriver serial driver is present and open. Remember that this routine-- which is inherently evil because it accesses low memory globals --is only used if a serial port arbitrator is not installed.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>static Boolean DriverIsOpen(ConstStr255Param driverName)    // Walks the unit table to determine whether the    // given driver is marked as open in the table.    // Returns false if the driver is closed, or does    // not exist.{    Boolean     found;    Boolean     isOpen;    short       unit;    DCtlHandle  dceHandle;    StringPtr   namePtr;    found = false;    isOpen = false;    unit = 0;    while ( ! found &amp;&amp; ( unit &lt; LMGetUnitTableEntryCount() ) ) {        // Get handle to a device control entry.  GetDCtlEntry        // takes a driver refNum, but we can convert between        // a unit number and a driver refNum using bitwise not.        dceHandle = GetDCtlEntry( ~unit );        if ( dceHandle != nil &amp;&amp; (**dceHandle).dCtlDriver != nil ) {            // If the driver is RAM based, dCtlDriver is a handle,            // otherwise it's a pointer.  We have to do some fancy            // casting to handle each case.  This would be so much            // easier to read in Pascal )-:            if ( ((**dceHandle).dCtlFlags &amp; dRAMBasedMask) != 0 ) {                namePtr = &amp; (**((DRVRHeaderHandle) (**dceHandle).dCtlDriver)).drvrName[0];            } else {                namePtr = &amp; (*((DRVRHeaderPtr) (**dceHandle).dCtlDriver)).drvrName[0];            }            // Now that we have a pointer to the driver name, compare            // it to the name we're looking for.  If we find it,            // then we can test the flags to see whether it's open or            // not.            if ( EqualString(driverName, namePtr, false, true) ) {                found = true;                isOpen = ((**dceHandle).dCtlFlags &amp; dOpenedMask) != 0;            }        }        unit += 1;    }    return isOpen;}</pre></TD></TR></TABLE></CENTER><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>                  The low memory accessor routine <CODE>         LMGetUnitTableEntryCount</CODE> is defined in "LowMem.h" but         is not exported by <CODE>InterfaceLib</CODE>. If you call         this routine from CFM code built with Universal Interfaces         2.x, you will get a link error. To work around this, either         write your own version of the function which accesses low         memory directly, or upgrade to Universal Interfaces 3.x,         which defines a C macro to cover this case.</P></TD></TR></TABLE></CENTER><BR><BR><H3>Closing a Serial Port</H3><P>If you successfully open a serial port, you should make sure toclose it again when you're done. You should always use<CODE>CloseDriver</CODE> to close a serial port. Remember to closeboth the input and output drivers. The following code illustrates thecorrect way to close the serial driver:</P>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>static OSErr CloseSerialDrivers(SInt16 inRefNum, SInt16 outRefNum){    OSErr err;&nbsp;    (void) KillIO(inRefNum);    err = CloseDriver(inRefNum);    if (err == noErr) {        (void) KillIO(outRefNum);        (void) CloseDriver(outRefNum);    }    return err;}</pre></TD></TR></TABLE></CENTER><BR><BR>            <P>It's important that you close the serial driver, even if yourapplication quits abnormally. If you fail to close the serial driverwhen you quit, it will be unavailable for other applications untilthe computer is restarted.</P><P>The following techniques are ways to ensure that you close theserial driver even if your application quits abnormally:</P><UL>   <LI>If you're a CFM application, use your CFM fragment's terminate   procedure. See   <I><a href="../../documentation/mac/PPCSoftware/PPCSoftware-2.html">Inside   Macintosh:PowerPC System Software</A></I> for details.</li>      <LI>If the Thread Manager is available, set a terminate procedure   for your main thread using <CODE>SetThreadTerminator</CODE>.</li>      <LI>If neither of the above apply, patch <CODE>ExitToShell</CODE>.</li></UL><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>                  Inside Macintosh II pp. 247-250 discusses the differences         between the ROM and RAM serial drivers and the routines         <CODE> RAMSDOpen</CODE> and <CODE> RAMSDClose</CODE> . This         information is obsolete and should be ignored.</P></TD></TR></TABLE></CENTER><BR><BR><H3>Yielding</H3><P>The classic serial architecture has very limited support foryielding the serial port. Apple Remote Access does this using aprivate API exported by the Link Tool Manager (part of ARA). This APIwas never published by Apple, and is not available to third parties.</P><P>If your application requires serial port yielding, you might wantto investigate using the OT serial API.</P><BR><P><A HREF="#top">Back to top</A></P><P><A NAME="JustTheFactsOTSerial"></A></P><H2>Just The Facts: Open TransportSerial</H2><P>Open Transport provides a second API for serial on Mac OS, onethat has much in common with the network APIs provided by OT. In thecurrent implementation of OT (version 1.3 at the time of writing),the OT serial API is implemented as a shim layered on top of theclassic serial drivers. This fact is important because the way youuse the OT serial API affects the availability of serial ports to theclassic API, and vice versa.</P><P><I><a href="../../documentation/mac/NetworkingOT/NetworkingWOT-2.html">InsideMacintosh: Open Transport</A></I> contains a lot of backgroundmaterial that you might find useful.</P><H3>Finding All Serial Ports</H3><P>If you are using the OT serial API, the correct way to find allthe installed serial ports is to repeatedly call<CODE>OTGetIndexedPort</CODE> looking for all ports of type<CODE>kOTSerialDevice</CODE>. The following sample demonstrates thistechnique:</P>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>static OSStatus PrintSerialPortInfo(const OTPortRecord *portRecord)    // Prints information about the port with the given portRecord.{    Str255 userVisibleName;    // OTGetUserPortNameFromPortRef is a little known routine    // from &lt;OpenTptConfig.h&gt; that allows you to get a user    // visible name for an Open Transport port.    OTGetUserPortNameFromPortRef(portRecord-&gt;fRef, userVisibleName);    printf("Found a serial port with port reference $%08lx:\n", portRecord-&gt;fRef);    printf("  User visible name is                       '%#s'.\n", userVisibleName);    printf("  String to pass to OTCreateConfiguration is '%s'.\n",  portRecord-&gt;fPortName);    printf("  Name of provider module is                 '%s'.\n",  portRecord-&gt;fModuleName);    printf("\n");    return kOTNoError;}&nbsp;static OSStatus OTFindSerialPorts(void)    // Lists all of the serial ports on the machine using Open Transport.{    OSStatus err;    Boolean portValid;    SInt32 portIndex;    OTPortRecord portRecord;    UInt16 deviceType;&nbsp;    // Start portIndex at 0 and call OTGetIndexedPort until    // we find there are no more ports.    portIndex = 0;    err = kOTNoError;    do {        portValid = OTGetIndexedPort(&amp;portRecord, portIndex);        if (portValid) {            // For each valid port, get the deviceType and, if            // it's a serial port and not an alias, call PrintSerialPort            // to dump out its information.  Note that you don't want            // to include aliases to the serial ports in the list, otherwise            // a standard machine will have 3 serial ports, "serialA", "serialB"            // and "serial".            deviceType = OTGetDeviceTypeFromPortRef(portRecord.fRef);            if (deviceType == kOTSerialDevice &amp;&amp;                        (portRecord.fInfoFlags &amp; kOTPortIsAlias) == 0) {                err = PrintSerialPortInfo(&amp;portRecord);            }        }        portIndex += 1;    } while ( portValid &amp;&amp; err == kOTNoError);&nbsp;    return err;}</pre></TD></TR></TABLE></CENTER><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>                                    The <CODE>OTGetUserPortNameFromPortRef</CODE>                  routine is not available to 68K programs running on                  PowerPC computers. See Technical Q&amp;A                  <a href="../../qa/nw/nw48.html">NW 48 "68K Open Transport                  Code on Power Macintoshes"</A> for details.</P></TD></TR></TABLE></CENTER><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>                                    The routine                  <CODE>OTGetUserPortNameFromPortRef</CODE> is                  defined in the"OpenTptConfig.h" header file. This                  file is not in Universal Interfaces, but it is                  included in the full OT SDK. Look for it in the                  "Open Tpt Protocol Developer" folder.</P></TD></TR></TABLE></CENTER><BR><BR>                           <P>OT 1.1.1 (and later) will automatically register                  any CRM serial port as an OT serial port, so this                  technique will see built-in and third party serial                  ports. You can determine the currently installed                  version of OT using Gestalt, as described in                  <a href="../../qa/nw/nw41.html">Q&amp;A NW 41 "Gestalt                  Selectors for Mac Networking</A>."</P>                                    <H3>Opening the Serial                  Port</H3>                                    <P>Once you know which serial port to use, you can                  call <CODE>OTOpenEndpoint</CODE> to create an                  endpoint to that serial port. However, OT does not                  actually open the underlying serial driver until                  you use that endpoint to make an active or passive                  connection.</P>                                    <P>You make an active connection by first calling                  <CODE>OTBind</CODE> with a <CODE>qlen</CODE> of 0                  and then calling <CODE>OTConnect</CODE>. The serial                  port is not actually opened until you do the                  <CODE>OTConnect</CODE>.</P>                                    <P>You make a passive connection by calling                  <CODE>OTBind</CODE> with a <CODE>qlen</CODE> of 1.                  The serial port is opened as part of the binding                  process. Your notifier will receive a                  <CODE>T_LISTEN</CODE> event when the first                  characters arrive at the serial port.</P>                                    <P>Your program should be sure to register itself                  as an OT client (using                  <CODE>OTRegisterAsClient</CODE>) so that it                  receives important notifications about the serial                  port it is using. Specifically, you should be                  prepared to handle the                  <CODE>kOTYieldPortRequest</CODE> notification, as                  described in the <A HREF = "#OTYielding">section on                  yielding</A>. Also, your endpoint's notifier should                  be prepared to handle the                  <CODE>kOTProviderIsDisconnected</CODE> and                  <CODE>kOTProviderIsReconnected</CODE>                  notifications.</P>                                    <H3>Closing the Serial                  Port</H3>                                    <P>Once you're done with the serial port, you                  should be sure to close it. The exact point at                  which the underlying serial port is closed depends                  on how you opened it.</P>                                    <P>If you made an active connection, you can close                  the serial port by disconnecting (taking the                  endpoint to state <CODE>T_IDLE</CODE>), typically                  using the <CODE>OTSndDisconnect</CODE> routine.                  </P>                                    <P>If you made a passive connection, you can close                  the serial port by using <CODE>OTUnbind</CODE> to                  unbind the endpoint.</P>                                    <P>Of course, if you close the endpoint (using                  <CODE>OTCloseProvider</CODE>), the serial port will                  always be closed.</P>                                    <P>Unlike classic serial, Open Transport does keep                  track of which applications are using which serial                  ports. If your application unexpectedly quits, OT                  will automatically close all of its endpoints and                  thereby close any serial ports it had open.                  However, non-application code (like code resources                  and shared libraries) must take care to always call                  <CODE>CloseOpenTransport</CODE> before they are                  unloaded from memory.</p>                  <H3><A NAME="OTYielding"></A>Yielding         </H3>         <CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>                                    This section describes how the OT serial port                  yielding process <EM>should</EM> work. Open                  Transport (version 1.3 at the time of writing) has                  bugs which prevent this from working in practice.                  From the application perspective, these bugs result                  in <CODE>OTYieldPortRequest</CODE> always returning                  <CODE>kEBUSYErr</CODE> even if the passive program                  allows the request.</P></TD></TR></TABLE></CENTER><BR><BR>                  <P>Unlike classic serial, Open Transport does have                  a public API for yielding serial ports. The basic                  sequence of events runs:</P>                                    <OL>                     <LI>The passive program opens the serial port by                     binding with a <CODE>qlen</CODE> of 1. The                     passive program will receive any incoming                     connections on the serial port.</li>                                          <LI>The active program tries to open the serial                     port by calling <CODE>OTConnect</CODE>. Because                     the passive program already has the serial port                     open, <CODE>OTConnect</CODE> fails with an                     error, <CODE>kEBUSYErr</CODE>.</li>                                          <LI>The active program notices this error and                     calls <CODE>OTYieldPortRequest</CODE> for that                     port.</li>                                          <LI>OT sends a <CODE>kOTYieldPortRequest</CODE>                     notification to any program which has is                     registered with OT (using                     <CODE>OTRegisterAsClient</CODE>) and has an                     endpoint using that port.</li>                                          <LI>The passive program's notification can                     choose to yield the port, or return an error                     saying why the request was denied.</li>                                          <LI>If any registered client denies the request,                     the <CODE>OTYieldPortRequest</CODE> function                     returns an error and the active program cannot                     use the serial port. The                     <CODE>OTYieldPortRequest</CODE> also returns a                     list of clients that refused the request and the                     reasons why. The active program can use this                     information in its "port in use" error dialog.</li>                                          <LI>If all registered clients agree to yield the                     port, the port is handed over to the active                     program. The active program has a short period                     of time (approximately 10 seconds) to open the                     port (by binding with a <CODE>qlen</CODE> of 1                     or by calling <CODE>OTConnect</CODE>) before the                     port reverts back to the original passive                     program.</li>                                          <LI>When the active program opens the port, the                     passive program receives a                     <CODE>kOTProviderIsDisconnected</CODE>                     notification.</li>                                          <LI>When the active program is done with the                     serial port and closes it, the passive program                     receives a                     <CODE>kOTProviderIsReconnected</CODE>.</li>                  </OL>                                    <P>This somewhat convoluted process is described in                  more detail in                  <I><a href="../../documentation/mac/NetworkingOT/NetworkingWOT-10.html">Inside                  Macintosh: Open Transport</A></I>.</p><BR><P><A HREF="#top">Back to top</A></P>         <P><A NAME="ATaleofTwoArbitrators"></A></P>                  <H2>A Tale of Two Arbitrators         </H2>                  <P>The Serial Port Arbitrator is one of the least understood         components of the Mac OS, partly because it is installed by         Apple Remote Access and is not a core component of the         system. This section explains why serial port arbitration is         necessary, and the features of the two serial port         arbitrators.</P>                  <H3>The Original Problem</H3>                  <P>The original Mac OS Device Manager architecture has an         interesting 'quirk' in that, once a driver is opened, any         further calls to <CODE>OpenDriver</CODE> just return the         driver's reference number without calling the driver at all.         For most types of drivers (e.g. the floppy disk driver) this         is a non-issue, but serial drivers can only support one         client at a time and serial port ownership is an important         user-level concept.</P>                  <P>On pre-MultiFinder Macintoshes, this was never a problem         because only one program could be running at a time, and         presumably it had control of the serial ports. However, with         the advent of MultiFinder, multiple applications could be         running simultaneously, and so the serial port ownership         became an issue.</P>                  <H3>The Original Solution</H3>                  <P>The original solution was fairly easy: if the serial port         is already open, it must be in use by another application,         and hence you should not try to use it. While this requires         serial applications to poke around in the unit table, it was         a perfectly serviceable solution.</P>                  <H3>The New Problem</H3>                  <P>The new problem arose with the advent of Apple Remote         Access. ARA has a mode in which it will passively sit in the         background waiting for calls. However, users were annoyed by         the fact that ARA was permanently using their serial port         (and, more specifically, their modem), so they could not         make outgoing calls without first turning off ARA's answer         mode.</P>                  <P>This problem was hard to get around because of the         original solution. A well-behaved application looked in the         unit table, noticed that the serial driver was in use, and         did not even attempt to call <CODE>OpenDriver</CODE>. So         there was no way that ARA could shut down its answer mode         when another application wanted the serial port.</P>                  <H3>The New Solution</H3>                  <P>The solution to this new problem was twofold. First, the         rules were changed for developers. The new rule is the one         <A HREF = "#NewRule">described above</A>: if a serial port         arbitrator is installed, applications should ignore the unit         table and always call <CODE>OpenDriver</CODE> when they want         the serial port.</P>                  <P>Second, ARA shipped with the Serial Port Arbitrator . The         Serial Port Arbitrator patches <CODE>_Open</CODE> and         <CODE>_Close</CODE> looking for applications opening and         closing the serial port. When an application opened the         serial port, Serial Port Arbitrator would tag the serial         port as belonging to that application. If another         application attempts to open the same serial port, the         Serial Port Arbitrator would fail the second open request         with a <CODE>portInUse</CODE> error.</P>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>                                    The <CODE>portInUse</CODE> error returned by                  the Serial Port Arbitrator is the same error code                  that the built-in serial driver returns when the                  serial hardware is being used by some other type of                  driver, for example by the LocalTalk driver.                  Although it's the same error code, it's not exactly                  the same error condition. Serial Port Arbitrator                  returns <CODE>portInUse</CODE> when the serial port                  is being used for serial by some other process. The                  serial driver returns <CODE>portInUse</CODE> when                  the serial hardware is being used by some other                  driver.</p>               </TD></TR>         </TABLE></center><BR>                  <P>The original Serial Port Arbitrator shipped as part of ARA         1.0. Its operation was intimately tied with the ARA Link         Tool Manager. The Link Tool Manager API, which ARA uses to         open a serial port in passive mode, was never publicly         documented.</P>                  <H3>The Newer Solution</H3>                  <P>Unfortunately, in computers, stability is death, and this         is as true for ARA as it is for any other part of Mac OS.         Part of the plan for ARA 3.0 was to get rid of the Link Tool         Manager, and its associated Serial Port Arbitrator. However,         by the time ARA 3.0 became a reality, developers were used         to the Serial Port Arbitrator and were happily calling         <CODE>OpenDriver</CODE> to open the serial port. If the ARA         Serial Port Arbitrator went away, they would no longer         receive an error when other application were using the         serial port, with potentially disastrous consequences.</P>                  <P>So ARA 3.0 includes a new serial port arbitrator, the         OpenTpt Serial Arbitrator, which includes the serial port         arbitration functionality of the original Serial Port         Arbitrator. Like the original Serial Port Arbitrator, the         OpenTpt Serial Arbitrator patches <CODE>_Open</CODE> and         <CODE>_Close</CODE> and remembers which applications opened         which serial ports. So <A HREF = "#NewRule">the rule</A> for         how to open serial ports still stands.</P>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>                                    Actually, the OpenTpt Serial Arbitrator first                  made its appearance with OT/PPP 1.0. However,                  OT/PPP is really just a cut down version of ARA                  3.0, so I will consider them the same in this                  discussion.</P></TD></TR></TABLE></CENTER><BR><BR>         <CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>                                    What happens when both serial port arbitrators                  are installed? It's easy to get into this situation                  with the standard Mac OS 8.0 installer, by                  installing both the OT/PPP and ARA Client 2.1                  software. The answer is that the Serial Port                  Arbitrator takes precedence over the OpenTpt Serial                  Arbitrator.</P></TD></TR></TABLE></CENTER><BR><BR>         <CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>                                    Early versions of the Serial Port Arbitrator                  and OpenTpt Serial Arbitrator would call the                  Process Manager from their <CODE> _Open</CODE>                  patch without first checking whether the Process                  Manager was available. The upshot of this is that                  system extensions that attempted to open the serial                  driver at startup would crash the system with an                  Unimplement Trap system error. This bug has been                  fixed in the latest version of both products.</P></TD></TR></TABLE></CENTER><BR><BR>                                    <H3>The Latest Problems</H3>                  <P>Alas, Mac OS has still to achieve serial port arbitration         nirvana. A number of serious deficiencies remain in the         OpenTpt Serial Arbitrator:</P>                  <UL>            <LI>Serial port ownership is tagged by            <CODE>ProcessSerialNumber</CODE> (see            <I><a href="../../documentation/mac/Processes/Processes-2.html">Inside            Macintosh: Processes</A></I> for details) -- This is a            problem if you write a serial program that is not an            application. For example, say you have a patch on            <CODE>SystemTask</CODE> that opens the serial port, uses            it for a few minutes, and then closes it. When you open            it, you might be running in application A's context, but            when you close it, you might be running in application            B's context. This confuses the serial port arbitrator and            is generally a problem for system extension authors.</li>                        <LI>There is no tie in between classic serial port            arbitration (the Serial Port Arbitrator and the OpenTpt            Serial Arbitrator) and the OT serial port arbitration API            -- This means that if an OT program opens a passive            serial connection and a classic client attempts to use            the serial port (ie calls <CODE>OpenDriver</CODE>), the            OT program will not be notified to yield the port.</li>                        <LI>For the above reason, if you have ARA 3.0 waiting for            an incoming call, you can not use Z-Term to make an            outgoing connection to a dial-up service.</li>                        <LI>The OT arbitration API is currently            <A HREF = "#OTYielding">broken</A>. The good news is that            calling the API is safe, so OT developers can still use            the API on the assumption that it will eventually be            fixed.</li>         </UL>                  <P>This note will be revised as these problems are         addressed.</P><BR><P><A HREF="#top">Back to top</A></P>         <A NAME="Summary"></A>                  <H2>Summary</H2>                  <P>The Mac OS serial port is a shared resource, and the true         owner of this resource -- the user -- gets upset when their         serial programs do not play well together. By following the         guidelines outlined in this note, your program will         correctly find all the serial ports on the machine, use         those serial ports in the most co-operative way, and be         adored by Macintosh users around the world!</p><BR><P><A HREF="#top">Back to top</A></P><A NAME="References"></A><H2>References</H2>            <p><CITE>Inside the Macintosh Communications            Toolbox</CITE>, Apple Computer, Inc., Addison-Wesley,            1991, ISBN 0201577755</p>                        <p><I><a href="../../documentation/mac/Devices/Devices-2.html">Inside            Macintosh: Devices</A></I></p>                        <p><I><a href="../../documentation/mac/NetworkingOT/NetworkingOpenTransport.pdf">Inside            Macintosh: Networking with Open Transport</A></I></p>                        <p><CITE>ARA API</CITE>, available on the Mac OS SDK            Developer CD at the path "MacOS SDK-1:Development Kits            (Disc 1):Apple Remote Access API:Documentation:ARA API"</p>                        <p><A HREF = "tn1018.html">Technote 1018 "Understanding            the SerialDMA Driver"</A></p>                        <p><a href="../../qa/dv/dv25.html">DV 25 - Setting Port Speed            on a Modem Port</A></p>                        <p><a href="../dv/dv_555.html">DV 555 - Serial Driver            Q&amp;A</A></p>                        <p><A HREF = "../hw/hw_28.html">HW 28 - PowerBook Miscellanea            (Cold Serial in the Morning)</A></p>                        <p>SerDemo sample code</p>                        <p><a href="http://developer.apple.com/dev/opentransport/">Open            Transport web page</A></p><BR><P><A HREF="#top">Back to top</A></P>        <A NAME="Downloads"></A>         <br><h2>Downloadables</h2>        <center><TABLE BORDER=0 CELLPADDING=3 WIDTH="600">          <TR>             <td width=50 align=left>               <P ALIGN=center><img src="images/acrobatsmall.gif" align=middle alt="Acrobat" width=22 height=23></P>            </TD>            <td align="left">               <p>Acrobat version of this Note (68K).</P>            </TD>            <td width=60 align=left>               <p><A HREF="pdf/tn1119.pdf">Download</A></P>            </TD>          </TR>        </TABLE></center><BR><BR>        </td></tr></table></center><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1119.html%3Fid%3DDTS10002959-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1119.html%3Fid%3DDTS10002959-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1119.html%3Fid%3DDTS10002959-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>