<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Accelerated and Fat Resources</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING88></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="RTArch-87.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="RTArch-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="RTArch-147.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="RTArch-89.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="RTArch-2.html"><B>Mac OS Runtime Architectures</B></A> / <BR><DD><A HREF="RTArch-86.html"><B>Chapter 7 - Fat Binary Programs</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING88-0></A>
<H1><A NAME=MARKER-9-27></A>Accelerated and Fat Resources</H1>
 <A NAME=MARKER-2-28></A>In some cases you may want to put an executable CFM-based code fragment into a resource to obtain a CFM-based version of a classic 68K stand-alone code module. For example, you might recompile an existing Hypercard XCMD (eXternal CoMmanD) procedure (which is stored in a resource of type <CODE>'XCMD'</CODE>) into PowerPC code. However, because the Hypercard application that calls your XCMD procedure could be classic 68K code, a mode switch to the PowerPC environment might be required before your definition procedure can be executed.<A NAME=MARKER-2-29></A> As a result, you need to add a routine descriptor at the beginning of the resource, as shown in <A HREF=#MARKER-9-31>Figure 7-1</A>. These kinds of resources are called<A NAME=MARKER-2-30></A> <B>accelerated resources</B> because they are faster implementations of their classic 68K counterparts. You can transparently replace classic 68K code resources with accelerated PowerPC code resources without having to change the software (for example, an application) that uses them.<P>
<B>Figure 7-1  <A NAME=MARKER-9-31></A>The structure of an accelerated resource</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/RUN-78.jpg"> <P>
<DL>
<DT><B>IMPORTANT</B>
<DD>Storing CFM-based code in resources is generally not recommended and should be done only in cases where you have no control over the code that calls it. If you are designing a plug-in interface, the plug-ins should be stored in the data fork.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 The routine descriptor is necessary for the Mixed Mode Manager to know whether it needs to change modes in order to execute the code. The routine descriptor also lets the Mixed Mode Manager know whether it needs to call the Code Fragment Manager to prepare the fragment. <P>
 The <CODE>procDescriptor</CODE> field of the routine record--contained in the <CODE>routineRecords</CODE> field of the routine descriptor--should contain the offset from the beginning of the resource (that is, the beginning of the routine descriptor) to the beginning of the executable code fragment. In addition, the routine flags for the specified code should have the <CODE>kProcDescriptorIsRelative</CODE> bit set, indicating that the address is relative, not absolute. If the code contained in the resource is CFM-based code, you should also set the <CODE>kFragmentNeedsPreparing</CODE> bit.<P>
 <A NAME=MARKER-2-32></A>You can also create fat resources, that is, resources containing both classic 68K and PowerPC versions of some routine. <A HREF=#MARKER-9-33>Figure 7-2</A> shows the general structure of such a resource.<P>
<B>Figure 7-2  <A NAME=MARKER-9-33></A>The structure of a fat resource</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/RUN-79.jpg"> <P>
 In this case, the routine descriptor contains two routine records in its <CODE>routineRecords</CODE> field, one describing the classic 68K code and one describing the PowerPC code. As with any code-bearing resource, the <CODE>procDescriptor</CODE> field of each routine record should contain the offset from the beginning of the resource to the beginning of the appropriate code. The flags for both routine records should have the <CODE>kProcDescriptorIsRelative</CODE> flag set, and the routine flags for the PowerPC routine record should have the <CODE>kFragmentNeedsPreparing</CODE> flag set.<P>
<DL>
<DT><B>Note</B>
<DD>You can also create a fat resource that contains CFM-68K code and classic 68K code, although there are no obvious advantages. However, doing so may simplify static data access or code compatibility in some cases.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 <A NAME=MARKER-2-34></A>Since a fat resource contains a routine descriptor at its entry point, it assumes that the host system contains the Mixed Mode Manager. If this is not the case, a problem can arise when the Mixed Mode trap is invoked. A solution is to create a variant called a safe fat resource<B>,</B> which begins with extra classic 68K code to check for the presence of the Mixed Mode Manager. If the Mixed Mode Manager is present, the code should move a routine descriptor to the beginning of the resource. If the Mixed Mode Manager is not present, it should add a branch instruction at the beginning to jump directly to the classic 68K portion of the resource. Thus the first call to the resource uses a few extra instruction cycles, but subsequent calls are faster. <P>
<DL>
<DT><B>Note</B>
<DD>In MPW, the interface file <CODE>MixedMode.r</CODE> provides Rez templates that you can use to create the accelerated resource shown in <A HREF=#MARKER-9-31>Figure 7-1</A> or the fat resource shown in <A HREF=#MARKER-9-33>Figure 7-2</A>. The file also contains sample code for creating a safe fat resource.<EM></EM> <A NAME=MARKER-2-35></A><EM><A NAME=MARKER-9-50></A></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
<DT><B>WARNING</B>
<DD>Do not call accelerated resources at interrupt time. If the resource containing the code has not been prepared, the Code Fragment Manager will be called to do so, and the Code Fragment Manager cannot run at interrupt time.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 Sometimes it's useful to keep the executable code of a definition function in some location other than a resource. To do this, you need to create a stub definition resource that is of the type expected by the system software and that simply jumps to your code. For example, <A HREF=#MARKER-9-37>Listing 7-1</A> shows the Rez input for a stub list definition resource.<P>
<B>Listing 7-1  <A NAME=MARKER-9-37></A>Rez input for a stub list definition resource</B><P>
<PRE>
data 'LDEF' (128, &quot;MyCustomLDEF&quot;, preload, locked) {
   /*need to fill in destination address before using this stub*/
   $&quot;41FA 0006&quot;/*LEA PC+8, A0;A0 &lt;- ptr to destination address*/
   $&quot;2050&quot;     /*MOVEA.L (A0), A0;AO &lt;- destination address*/
   $&quot;4ED0&quot;        /*JMP (A0)  ;jump to destination address*/
   $&quot;00000000&quot;    /*destination address*/
};
</PRE>
 Your application (or other software) is responsible for filling in the destination address before the list definition procedure is called by the List Manager. For classic 68K code, the destination address should be the address of the list definition procedure itself. For PowerPC-based code, the destination address should be a universal procedure pointer (that is, the address of a routine descriptor for the list definition procedure).<P>
 <A NAME=MARKER-2-38></A>It's important to understand the distinction between accelerated resources and a normal resource-based fragment (sometimes called a <B>private resource</B>), so that you know when to create them and how to load and execute the code they contain. An accelerated resource is any resource containing PowerPC code that has a single entry point at the top (the routine descriptor) and that models the traditional behavior of a classic 68K stand-alone code resource. There are many examples, including menu definition procedures (stored in resources of type <CODE>'MDEF'</CODE>), control definition functions (stored in resources of type <CODE>'CDEF'</CODE>), window definition functions (stored in resources of type <CODE>'WDEF'</CODE>), list definition procedures (stored in resources of type <CODE>'LDEF'</CODE>), HyperCard extensions (stored in resources of type <CODE>'XCMD'</CODE>), and so forth. A private resource is any other kind of executable resource whose code is called directly by your application.<EM></EM><P>
 In most cases, you don't need to do anything special to get the system software to recognize your accelerated resource and to call it at the appropriate time. For example, the Menu Manager automatically loads a custom menu definition procedure into memory when you call <CODE>GetMenu</CODE> for a menu whose <CODE>'MENU'</CODE> resource specifies that menu definition procedure. Similarly, HyperCard calls code like that shown in <A HREF=#MARKER-9-39>Listing 7-2</A> to load a resource of type <CODE>'XCMD'</CODE> into memory and execute the code it contains.<P>
<B>Listing 7-2  <A NAME=MARKER-9-39></A>Using an accelerated resource</B><P>
<PRE>
Handle      myHandle;
XCmdBlock   myParamBlock;

myHandle = Get1NamedResource('XCMD', '\pMyXCMD');
HLock(myHandle);

/*Fill in the fields of myParamBlock here.*/

CallXCMD(&amp;myParamBlock, myHandle);
HUnlock(myHandle);
</PRE>
 The caller of an accelerated resource executes the code either by jumping to the code (if the caller is classic 68K code) or by calling the Mixed Mode Manager <CODE>CallUniversalProc</CODE> function (if the caller is PowerPC code). In either case, the Mixed Mode Manager calls the Code Fragment Manager to prepare the fragment, which is already loaded into memory. With accelerated resources, you don't need to call the Code Fragment Manager yourself. In fact, you don't need to do anything special at all for the system software to recognize and use your accelerated resource if you've built it correctly. This is because the system software is designed to look for, load, and execute those resources in the appropriate circumstances. In many cases, your application passes to the system software just a resource type and resource ID. The resource must begin with a routine descriptor, so that the dereferenced handle to the resource is a universal procedure pointer.<P>
 The code shown in <A HREF=#MARKER-9-39>Listing 7-2</A> (or similar code for any other accelerated resource) can be executed multiple times with no appreciable performance loss. If the code resource remains in memory, the only overhead incurred by <A HREF=#MARKER-9-39>Listing 7-2</A> is to lock the code, fill in the parameter block, jump to the code, and then unlock it. <A NAME=MARKER-2-56></A>However, because of the way in which the system software manages your accelerated resources, there are several important restrictions on their operation:<P>
<UL>
<LI>An accelerated resource cannot contain a termination routine, largely because the Code Fragment Manager does not know when the resource is released. The Code Fragment Manager effectively forgets about the connection to your resource as soon as it has prepared the resource for execution.
<LI>An accelerated resource must contain a main symbol, which must be a procedure. For example, in an accelerated <CODE>'MDEF'</CODE> resource, the main procedure must be the menu definition procedure itself (which typically dispatches to other routines contained in the resource).
<LI>You cannot call the Code Fragment Manager routine <CODE>FindSymbol</CODE> to get information about the exported symbols in an accelerated resource. More generally, you cannot call any Code Fragment Manager routine that requires a connection ID as a parameter. 
<LI>The fragment's data section is instantiated in place (that is, within the block of memory into which the resource itself is loaded). For in-place instantiation, you need to build an accelerated resource using an option that specifies that the data section of the fragment not be compressed. See the documentation for your software development system to determine how to specify uncompressed data sections.
<LI>Accelerated resources can move in memory or be purged like classic 68K resources (note that the code in <A HREF=#MARKER-9-39>Listing 7-2</A> unlocks the <CODE>'XCMD'</CODE> resource after executing it). If the resource moves between calls, some of the global data in the resource might become invalid. For example, a global pointer may end up dangling if the code or data it points to has moved. <P>
</UL>
 To allow accelerated PowerPC resources to be manipulated just like classic 68K code resources, the Mixed Mode Manager and the Code Fragment Manager cooperate to make sure that the code is ready to be executed when it is called. If the resource code hasn't been moved since it was prepared for execution, then no further action is necessary. If, however, the code resource has moved or been reloaded elsewhere in memory, some of the global data in the resource might have become invalid. To help avoid dangling pointers, the Code Fragment Manager always updates any pointers in the fragment's data section that are initialized at compile time and not modified at runtime. <P>
<DL>
<DT><B>IMPORTANT</B>
<DD>The Code Fragment Manager cannot update all global data references in an accelerated resource that has moved in memory. Therefore, an accelerated resource must not use global pointers (in C code, pointers declared as <CODE>extern</CODE> or <CODE>static</CODE>) that are either initialized at runtime or contained in dynamically allocated data structures to point to code or data contained in the resource itself. An accelerated resource can use uninitialized global data to point to objects in the heap. In addition, an accelerated resource can use global pointers that are initialized at compile time to point to functions, other global data, and literal strings, but these pointers cannot be modified at runtime.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 The best way to avoid the global data restrictions on an accelerated resource is to put the global data used by the accelerated resource into an import library. Since the accelerated resource is a fragment, it can import both code and data from the library. The import library's code and data are fixed in memory, and the library is unloaded only when your application terminates, not when the accelerated resource is purged.<P>
 If you must declare global variables in your accelerated resource, you should check <A HREF=#MARKER-9-41>Listing 7-3</A> for examples of acceptable declarations. Note that these declarations assume the resource code does not change the values of the initialized variables.<P>
<B>Listing 7-3  <A NAME=MARKER-9-41></A>Acceptable global declarations in an accelerated resource</B><P>
<PRE>
int a;      /*uninitialized; not modified if resource moves*/
Ptr myPtr;  /*uninitialized; not modified if resource moves; */
            /* can be assigned at runtime to point to heap object*/
Handle *h;  /*uninitialized; not modified if resource moves; */
            /* can be assigned at runtime to point to heap object*/
int *b = &amp;a;               /*updated each time resource moves*/
char *myStr = &quot;Hello, world!&quot;;/*updated each time resource moves*/
extern int myProcA(), myProcB();
struct {
   int   (*one)();
   int   (*two)();
   char  *str;
} myRec = {myProcA, myProcB, &quot;Hello again!&quot;};
         /*all three pointers are updated each time resource moves*/
</PRE>
 <A HREF=#MARKER-9-42>Listing 7-4</A> shows examples of data declarations and code that do not work in an accelerated resource that is moved or purged.<P>
<B>Listing 7-4  <A NAME=MARKER-9-42></A>Unacceptable global declarations and code in an accelerated resource</B><P>
<PRE>
int a;
int *b;
int *c = &amp;a;
Ptr (*myPtr) (long) = NewPtr;
static Ptr MyNewPtr();
struct myHeapStruct {
   int      *b;
   Ptr      (myPtr) (long);
} *hs;

b = &amp;a;        /*b does not contain &amp;a after resource is moved*/
c = NULL;      /*c does not contain NULL after resource is moved*/
c = (int *) NewPtr(4);/*dangling pointer after resource is moved*/
myPtr = MyNewPtr;    /*dangling pointer after resource is moved*/
hs = NewPtr(sizeof(myHeapStruct));
         /*hs still points to nonrelocatable heap block after move*/
hs-&gt;b = &amp;a;    /*hs-&gt;b will not point to global a after move*/
hs-&gt;myPtr = MyNewPtr;
               /*hs-&gt;myPtr will not point to MyNewPtr after move*/
</PRE>
 <A NAME=MARKER-2-43></A><P>
 <A NAME=MARKER-2-44></A><P>
<HR>
<center>
<A HREF="RTArch-87.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="RTArch-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="RTArch-147.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="RTArch-89.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="RTArch-3.html">&copy; Apple Computer, Inc.</A><br>11 MARCH 1997<P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML> 
