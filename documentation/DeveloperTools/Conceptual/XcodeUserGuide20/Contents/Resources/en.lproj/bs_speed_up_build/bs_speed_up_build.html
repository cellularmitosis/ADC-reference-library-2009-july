<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Xcode 2.0 User Guide (Legacy): Optimizing the Edit-Build-Debug Cycle</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Optimizing the Edit-Build-Debug Cycle"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../../../../Resources" />
	<meta name="ROBOTS" content="NOINDEX"/>
	<link rel="stylesheet" type="text/css" href="../../../../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40001440-CH234" title="Optimizing the Edit-Build-Debug Cycle"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../../../../LegacyTechnologies/index.html#//apple_ref/doc/uid/TP30000440-TP30000470" target="_top">Legacy Documents</a> &gt; <a href="../../../../../../../LegacyTechnologies/Tools-date.html#//apple_ref/doc/uid/TP30000440-TP30000470-TP30000463" target="_top">Tools</a> &gt; <a href="../intro/intro.html#//apple_ref/doc/uid/TP40001440-CH276-DontLinkElementID_339">Xcode 2.0 User Guide (Legacy)</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../bs_linking/bs_linking.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../bs_cross_development/bs_cross_development.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        <script type="text/javascript" language="JavaScript">placeWatermark()</script>
<div id="legacyOuterWrapper"><div align="center" id="watermark">
<div class="legacybox">
<h1>Legacy Document<span class="closebutton"><a href="javascript:closeWatermark()"><img src="../../../../../../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>
        <a name="//apple_ref/doc/uid/TP40001440-CH234-DontLinkElementID_268" title="Optimizing the Edit-Build-Debug Cycle"></a><h1><a name="//apple_ref/doc/uid/TP40001440-CH234-CBHBEIJJ" title="Optimizing the Edit-Build-Debug Cycle"></a>Optimizing the
Edit-Build-Debug Cycle</h1><p>Xcode offers a number of features you can take
advantage of to decrease build time for your project. For example,
you can use distributed builds to shorten the time it takes to build
your whole project or multiple projects. ZeroLink and predictive
compilation, on the other hand, improve turnaround time for single
file changes, thereby speeding up the edit&#8211;build&#8211;debug cycle. All
of these features reduce the amount of time you spend idle while
waiting for your project to build. </p>
<p>This chapter describes the following features:</p>
<ul class="ul"><li class="li"><p>Precompiled
prefix headers let you decrease the amount of time spent building compiling
each source file in a target by specifying a single header file
that includes all of the headers commonly used by the target&#8217;s
files and compiling this header a single time.</p></li>
<li class="li"><p>Predictive compilation reduces the time required to compile
single file changes by beginning to compile a file while you are
still editing it.</p></li>
<li class="li"><p>Distributed builds can dramatically reduce build time for
large projects by distributing compiles to available machines on
the network.</p></li></ul>
<p>Other features that you can use to optimize the edit-build-debug
cycle include:</p>
<ul class="ul"><li class="li"><p>Fix and Continue,
described in <span class="content_text"><a href="../db_fix_and_continue/db_fix_and_continue.html#//apple_ref/doc/uid/TP40001440-CH244-CACIGJII">“Using Fix and Continue,”</a></span> improves
your debugging efficiency by allowing you to make changes to your
application and see the results of your modification without stopping
your debugging session.</p></li>
<li class="li"><p>	ZeroLink, described in <span class="content_text"><a href="../bs_linking/bs_linking.html#//apple_ref/doc/uid/TP40001440-CH233-CHDCEHDD">“Using ZeroLink,”</a></span> shortens build
time by eliminating the linking step for development builds.</p></li></ul>


<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="bs_speed_up_build.html#//apple_ref/doc/uid/TP40001440-CH234-DontLinkElementID_60">Using a Precompiled Prefix Header</a>
				
			<br/>
			
        
			
			
				<a href="bs_speed_up_build.html#//apple_ref/doc/uid/TP40001440-CH234-CBHEHCHA">Distributing Builds Among Multiple Computers</a>
				
			<br/>
			
        
			
			
				<a href="bs_speed_up_build.html#//apple_ref/doc/uid/TP40001440-CH234-CBHJCIIF">Predictive Compilation</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40001440-CH234-DontLinkElementID_60" title="Using a Precompiled Prefix Header"></a><h2>Using a Precompiled Prefix
Header</h2>
<p>A precompiled header is a file in the intermediate form used
by the compiler to compile a source file. Using precompiled headers,
you can significantly reduce the amount of time spent building your
product. Often, many of the source code files in a target include
a subset of common system and project headers. For example, each
source file in a Cocoa application typically includes the <code>Cocoa.h</code> system
header, which in turn includes a number of other headers. When you
build a target, the compiler spends a great deal of time repeatedly
processing the same headers.</p>
<p>You can significantly reduce build time by providing a prefix
header that includes the set of common headers used by all or most
of the source code files in your target and having Xcode precompile
that prefix header. </p>
<p>If you have indicated that Xcode should do so, Xcode precompiles
the prefix header when you build the target. Xcode then includes
that precompiled header file for each of the target's source files.
The contents of the prefix header are compiled only once, resulting
in faster compilation of each source file. Furthermore, subsequent
builds of the target can use that same precompiled header, provided
that nothing in the prefix header or any of the files on which it
depends has changed. Each target can have only one prefix header. </p>
<p>When Xcode compiles your prefix header, it generates a variant
for each C language dialect used by your source files; it stores
these in a folder in your project&#8217;s build directory. It also generates&#8212;as
needed&#8212;a variant for each combination of source header and compiler
flags. For example, you may have per-file compiler flags set for
some of the files in your target. Xcode will create a variant of
the precompiled header by precompiling the prefix header with the
set of compiler flags derived from the target and the individual source
file. As Xcode invokes the compiler to process each source file
in your target, the compiler searches this directory for a precompiled
header variant matching the language and compiler flags for the
current compile. The first precompiled header variant that is valid
for the compilation is used. </p>
<p>Xcode automatically regenerates the precompiled header whenever
the prefix header, or any of the files it depends on are changed,
so you don't need to manually maintain the precompiled header.</p>
<a name="//apple_ref/doc/uid/TP40001440-CH234-DontLinkElementID_61" title="Creating the Prefix Header"></a><h3>Creating the Prefix Header</h3>
<p>To take advantage of precompiled headers in Xcode, you must
first create a prefix header. Create a header file containing any
common <code>#include</code> and <code>#define</code> statements
used by the files in your target.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40001440-CH234-DontLinkElementID_269" title="Note"></a><p><strong>Note:</strong>&nbsp; You
can use a prefix header to include a common set of header files
for each source file in your target without precompiling the prefix
header.</p></div>
<p>Do not include anything that changes frequently in the prefix
header. Xcode recompiles your precompiled header file when the prefix
header, or any of the headers it includes, change. Each time the
precompiled header changes, all of the files in the target must
be recompiled. This can be an expensive operation for large projects.</p>
<p>Because the compiler includes the prefix header file before
compiling each source file in the target, the contents of the prefix
header must be compatible with each of the C language dialects used
in the target. For example, if your target uses Cocoa and contains
both Objective-C and C source files, the prefix header needs to
include the appropriate guard macros to make it compatible with
both language dialects, similar to the example shown here:</p>
<div class="codesample"><table><tr><td scope="row"><pre>    #ifdef __OBJC__<span></span></pre></td></tr><tr><td scope="row"><pre>    #import &lt;Cocoa/Cocoa.h&gt;<span></span></pre></td></tr><tr><td scope="row"><pre>    #endif<span></span></pre></td></tr><tr><td scope="row"><pre>    #define MY_CUSTOM_MACRO 1<span></span></pre></td></tr><tr><td scope="row"><pre>    #include &quot;MyCommonHeaderContainingPlainC.h&quot;<span></span></pre></td></tr></table></div>
<a name="//apple_ref/doc/uid/TP40001440-CH234-DontLinkElementID_62" title="Configuring Your Target To Use the Precompiled Header"></a><h3>Configuring Your Target To
Use the Precompiled Header</h3>
<p>Once you have created the prefix header, you need to set up
your target to precompile that header. To do this, you must provide
values for the two build settings described here. You can edit these
build settings in the Build pane of the target inspector or Info
window. The settings you need to change are:</p>
<ul class="spaceabove"><li class="li"><p>Prefix Header
(GCC_PREFIX_HEADER). Change the value of this build setting to the project-relative
path of the prefix header file. If you have a precompiled header
file from an existing project, set the prefix header path to the
path to that file. </p></li>
<li class="li"><p>Precompile Prefix Header (GCC_PRECOMPILE_PREFIX_HEADER). Make
sure that this option is turned on. A checkmark is present in the
Value column if this option is enabled.</p></li></ul>
<p>You must provide values for these settings in each target
that uses a precompiled prefix header, even if those targets use
the same prefix header.</p>
<p>By default, Xcode precompiles a version of the header for
each C-like language used by the target (C, C++, Objective-C, or
Objective-C++). The C Dialects to Precompile (GCC_PFE_FILE_C_DIALECTS)
build setting lets you explicitly specify the C dialects for which
Xcode should produce versions of the precompiled header. </p>
<a name="//apple_ref/doc/uid/TP40001440-CH234-DontLinkElementID_63" title="Sharing Precompiled Header Binaries"></a><h3>Sharing Precompiled Header
Binaries</h3>
<p>It is possible to share a precompiled header binary across
multiple targets, provided that those targets use the same prefix
header and compiler options. In order to share a precompiled header
binary, each individual target must have the same prefix header specified.
To use the same prefix header for multiple targets, set the value
of the Prefix Header build setting for each target to the path to
the header.</p>
<p>The PRECOMP_DESTINATION_DIR build setting specifies the location
of the directory to which Xcode writes the precompiled header binary.
For each target, set this location to a common directory. When Xcode
invokes GCC to compile each source file in a target, GCC searches
this common directory for the appropriate header binary. For any
targets that use the same prefix header and compiler options, GCC
uses the same precompiled header binary when it builds those targets.</p>
<p>This build setting is not exposed in the Xcode user interface.
To change the value of this build setting, add a new entry in the
build settings table that appears in the Build pane of the target
inspector. Enter PRECOMP_DESTINATION_DIR as the name of the build setting
and enter the path to the directory you want to use for precompiled
binaries in the Value column for the build setting.</p>
<p>If you specify the same prefix header for multiple targets,
but do not specify a common location for the precompiled binary,
Xcode precompiles the prefix header once for each target as it is
built.</p>
<a name="//apple_ref/doc/uid/TP40001440-CH234-DontLinkElementID_64" title="Controlling the Cache Size Used for Precompiled Headers"></a><h3>Controlling the Cache Size
Used for Precompiled Headers</h3>
<p>Xcode caches the precompiled header files that it generates.
To control the size of the cache devoted to storing those files,
use the <code>BuildSystemCacheSizeInMegabytes</code> user
default. In the Terminal application, type:</p>
<p><code>defaults write com.apple.xcode BuildSystemCacheSizeInMegabytes </code><em>defaultCacheSize</em></p>
<p>Specifying 0 for the cache size gives you an unlimited cache.
200 MB is the default cache size set by Xcode. If the cache increases
beyond the default size, Xcode removes as many precompiled headers
as is necessary to reduce the cache to its default size when Xcode
is next launched. Xcode removes the oldest files first.</p>
<a name="//apple_ref/doc/uid/TP40001440-CH234-DontLinkElementID_65" title="Restrictions"></a><h3>Restrictions</h3>
<p>To take advantage of Xcode&#8217;s automatic support for precompiled
headers you must:</p>
<ul class="spaceabove"><li class="li"><p>Use GCC 3.3 or
later. Xcode uses GCC 3.3&#8217;s PCH mechanism to create precompiled headers.
PCH is not available with previous versions of GCC.</p></li>
<li class="li"><p>Use a native target. Xcode&#8217;s automatic support for precompiled
prefix headers using PCH is only available for targets that use
Xcode&#8217;s own native build system. Xcode automatically handles many
of the restrictions upon using precompiled headers with GCC. If
you are using an external target to work with another build system&#8212;such
as <code>make</code>&#8212;you can still
use precompiled headers, but you must create and maintain them yourself.
For more information on using precompiled headers with GCC, see <em><a href="../../../../../../gcc-3.3/gcc/index.html#//apple_ref/doc/uid/TP40001011" target="_top">GNU C/C++/Objective-C 3.3 Compiler</a></em>. Jam-based targets can also use precompiled prefix
headers, but they are limited to the PFE (persistent front end)
mechanism introduced with GCC 3.1. PFE is no longer recommended.</p></li>
<li class="li"><p>Use one and only one prefix header per target.</p></li>
<li class="li"><p>Set the Prefix Header and Precompile Prefix Header build settings
for every target that uses precompiled headers.</p></li></ul>
<a name="//apple_ref/doc/uid/TP40001440-CH234-CBHEHCHA" title="Distributing Builds Among Multiple Computers"></a><h2>Distributing Builds Among Multiple
Computers</h2>
<p>Building a product involves many small operations. Many of
these operations&#8212;such as compiling source files&#8212;can be performed
in parallel, decreasing the total amount of time it takes to build
your product. If you have a dual-processor computer, Xcode automatically uses
both processors. However, the greater the number of processors available
to you, the greater the number of build tasks you can run in parallel. Distributed
builds give you the ability to distribute build tasks among multiple
computers on a network. When you use distributed builds, Xcode distributes
as many build operations as possible among the computers available
for that purpose.</p>
<a name="//apple_ref/doc/uid/TP40001440-CH234-DontLinkElementID_66" title="How Distributed Builds Work"></a><h3>How Distributed Builds Work</h3>
<p> Xcode uses <code>distcc</code> to
manage distributed builds. The <code>distcc</code> client
manages the setup and distribution of build tasks. The server process
(<code>distccd</code>) manages communication
with the remote computers hosting the build tasks. The server process
runs on both the local, or client, computer and on the remote computer. </p>
<p>When you initiate a build, Xcode invokes the <code>distcc</code> client
on your local computer. For each source module that needs to be
compiled, the client process connects to the server process running
on the local machine and gives it the information required to distribute that
task. Namely, the client process tells <code>distccd</code> the
operation to perform and gives it any necessary arguments, a list
of files to copy to the remote host (input files) and a list of
files to copy from the remote host (output files). The server process
broadcasts a work request for that operation. When an available
computer responds, <code>distccd</code> sends
the inputs to that computer. When the compile is complete and the
remote computer returns the results, <code>distccd</code> places
the output files in the appropriate locations in the file system
and returns the results to the client process.</p>
<p>On a remote computer accepting build operations, the server
process listens for requests for assistance. When it receives a
request, it creates a connection with the client computer, obtains
the inputs required for the compilation, and invokes <code>gcc</code>.
When the compile is complete, <code>distccd</code> sends
the results&#8212;the generated <code>.o</code> files, <code>stderr</code> and <code>stdout</code>&#8212;back
to the client computer. </p>
<p>If the attempt to distribute a build task fails&#8212;for example,
if communication with the remote host is lost, or the remote host
cannot execute the compile&#8212;the compilation is performed on your
local computer.</p>
<p>Xcode only distributes compilation of individual source modules.
Your local computer still performs all of the build setup, linking,
and product packaging. Preprocessing is also done on your local
computer; this is done to avoid the problem of ensuring that all machines
participating in a build have exactly the same version of all headers
used in the build. For each source file, the <code>distcc</code> client
invokes GCC to generate a <code>.i</code> file
containing the preprocessed source; this is the input file sent
to the remote host. </p>
<p>Computers that are shared respond to requests for assistance
as they are able. Xcode determines how best to use available machines
for a build, based on processing capacity. A computer&#8217;s processing
capacity is determined through a combination of availability and processing
power.</p>
<p>You can use precompiled headers with distributed builds. If
a precompiled header is present, the path to that header is listed
in the preprocessed file generated from each source file. Before
it sends a file to a remote computer, <code>distcc</code> checks
for this path and, if found, sends the precompiled header to the
remote computer. </p>
<a name="//apple_ref/doc/uid/TP40001440-CH234-DontLinkElementID_67" title="Requirements for Using Distributed Builds"></a><h3>Requirements for Using Distributed
Builds</h3>
<p>Use of distributed builds is subject to the following constraints:</p>
<ul class="spaceabove"><li class="li"><p>You must
use GCC 3.3 or later. </p></li>
<li class="li"><p>Machines that tasks are distributed to must be running the
same version of the compiler, operating system, and Xcode.</p></li>
<li class="li"><p>Distributed builds work with native targets. Jam-based targets
or targets using another external build system are not compatible
with distributed builds.</p></li>
<li class="li"><p>Distributed builds support C, C++, Objective-C and Objective-C++.</p></li>
<li class="li"><p>Distributed builds are enabled on a per-user basis, for all
projects and targets built by that user.</p></li></ul>
<a name="//apple_ref/doc/uid/TP40001440-CH234-DontLinkElementID_68" title="Discovering Available Computers"></a><h3>Discovering Available Computers</h3>
<p>To enable distributed builds on your computer, choose Xcode &gt;
Preferences and click Distributed Builds. To use other computers
on the network for your builds, select &#8220;Distribute builds to.&#8221; </p>
<p>Xcode uses Bonjour to automatically discover computers
that are set up to broadcast their availability. The Distributed
Builds preference pane lists the computers currently available for
sharing build tasks. Services discovered through Bonjour display
the Bonjour name of the computer on which <code>distccd</code> is
running.</p>
<p>By default, Xcode will use any computers that are available
when you begin a build. You can restrict which computers are used
by selecting &#8220;trusted computers only&#8221; from the &#8220;Distribute
builds to&#8221; menu. When you choose this option, Xcode distributes
builds only to computers that you explicitly designate as &#8220;trusted.&#8221;
A computer is trusted if the checkbox in the Trusted column next
to its entry is selected.</p>
<p>Each entry in the Distributed Builds preference pane represents
a single computer. However, shared computers with dual processors
run two instances of <code>distccd</code>,
each of which can accept build tasks. The Max Connections column
displays the number of processors of, and therefore the number of
possible connections with, each available computer.</p>
<p>Computers to which tasks are distributed to must be running
the same version of the compiler, operating system, and Xcode. The
Status column shows whether a shared computer is compatible or not.
If a computer goes to sleep, its services disappear from the preference
pane, and that computer is no longer available for performing compilations.</p>
<a name="//apple_ref/doc/uid/TP40001440-CH234-DontLinkElementID_69" title="Sharing a Computer"></a><h3>Sharing a Computer</h3>
<p>To allow other computers to use your computer for their builds, select
the &#8220;Share my computer for building with&#8221; option in the Distributed
Builds pane of the Xcode Preferences window and choose a priority
for sharing your computer from the menu.</p>
<p>Don&#8217;t share your computer if you are using it to host a
distributed build as well. Because precompilation and the distribution
of build tasks are done on your local machine, sharing it for others
to distribute build tasks to can significantly slow down your own
build.</p>
<a name="//apple_ref/doc/uid/TP40001440-CH234-DontLinkElementID_70" title="Distributed Builds and Firewalls"></a><h3>Distributed Builds and Firewalls</h3>
<p>To distribute builds across a firewall, the firewall must
allow traffic on ports <code>3632</code> and <code>7264</code>.
Some firewalls allow Bonjour traffic, making shared computers
behind the firewall visible in the Distributed Builds preference
pane. However, the distributed build will not work. When Xcode attempts
to distribute build tasks and receives no response from the computers
behind the firewall, it times out and builds the project on the
local machine.</p>
<p>To allow traffic on ports <code>3632</code> and <code>7264</code> on
computers with a firewall enabled, use the Firewall pane of Sharing
Preferences.</p>
<a name="//apple_ref/doc/uid/TP40001440-CH234-DontLinkElementID_71" title="Getting the Most Out of Distributed Builds"></a><h3>Getting the Most Out of Distributed
Builds</h3>
<p>Using Xcode to distribute builds across multiple computers
can greatly decrease the time it takes to build your product. To
get the most benefit from using distributed builds, you should consider
the following:</p>
<ul class="spaceabove"><li class="li"><p>Networking
speed. The distributed build system sends files to be built on other computers;
those machines, in turn, send back the resulting object files. To
see a significant reduction in build time, your network must be
fast enough that the cost of transferring files between machines
is minimal. This occurs around 100 Mbit/s (megabits per second).
For this reason, using distributed builds over a wireless network does
not show any build speed benefits.</p></li>
<li class="li"><p>Number of available computers. As stated at the beginning
of this article, the more processors you have available to you,
the more build tasks can be performed in parallel and the more significant
the reduction in build time that you see. If you have a limited number
of computers available for sharing&#8212;especially if those computers
do not have significant processing capacity, whether due to limited
availability or slow processor speed&#8212;you may not see any noticeable
improvements in build performance. The overhead of managing distribution
of build tasks may overcome the benefit you get from building on
additional machines. You may find that you get better build performance
from utilizing other optimizations, such as precompiled headers
or parallel builds, on your local computer.</p></li>
<li class="li"><p>Differing processing capacity between the computers managing
the build and those hosting the build tasks. If you have a number
of different computers available to you, of varying speed, you will
get better performance if you use the faster computers for building
and the slower computer to manage the build and farm out build tasks.
For example, if you have a G4 and a G5 available, on a fast network,
host the project on the G4 and make the G5 available for shared
builds.</p></li></ul>
<a name="//apple_ref/doc/uid/TP40001440-CH234-CBHJCIIF" title="Predictive Compilation"></a><h2>Predictive Compilation</h2>
<p>Predictive compilation is a feature introduced to reduce the
time required to compile single file changes and speed up the edit-compile-debug
cycle of software development. If you have predictive compilation
enabled for your project, Xcode begins compiling the files required
to build the current target even before you tell Xcode to build.</p>
<p>Predictive compilation uses the information that Xcode maintains
about the build state of targets that use the native build system.
Xcode keeps the graph of all files involved in the build and their
dependencies, as well as a list of files that require updating.
At any point in time, Xcode knows which of the files used in building
a target&#8217;s product are out of date and what actions are required
to bring those files up to date. A file can be updated when all
of the other files on which it depends are up to date. As files
become available for processing, Xcode begins to update them in
the background, even as you edit your project. </p>
<p>Xcode will even begin compiling a source code file as you
are editing it. Xcode begins reading in and parsing headers, making
progress compiling the file even before you initiate a build. When
you do choose to save and build the file, much of the work has already
been done.</p>
<p>Until you explicitly initiate a build, Xcode does not commit
any of the output files to their standard location in the file system.
When you indicate that you are done editing, by invoking one of
the build commands, Xcode decides whether to keep or discard the
output files that it has generated in the background. If none of
the changes made subsequent to its generation affect the content
of a file, Xcode commits the file to its intended location in the file
system. Otherwise, Xcode discards its results and regenerates the
output file.</p>
<p>You can turn on predictive compilation by selecting &#8220;Use
Predictive Compilation&#8221; option in the Building pane of the Xcode
Preferences window. </p>
<p>Predictive compilation works only with GCC 3.3 or later and
native targets. All predictive compilation is done locally on your
computer, regardless of whether you have distributed builds enabled.
On slower machines, enabling predictive compilation may interfere
with Xcode performance during editing.</p>
<p>To conserve battery power, Xcode turns off predictive compilation
on laptop machines running under battery power.</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../bs_linking/bs_linking.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../bs_cross_development/bs_cross_development.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2004, 2006 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2006-11-07<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeveloperTools/Conceptual/XcodeUserGuide20/Contents/Resources/en.lproj/bs_speed_up_build/bs_speed_up_build.html%3Fid%3DTP40001440-1.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeveloperTools/Conceptual/XcodeUserGuide20/Contents/Resources/en.lproj/bs_speed_up_build/bs_speed_up_build.html%3Fid%3DTP40001440-1.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeveloperTools/Conceptual/XcodeUserGuide20/Contents/Resources/en.lproj/bs_speed_up_build/bs_speed_up_build.html%3Fid%3DTP40001440-1.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>