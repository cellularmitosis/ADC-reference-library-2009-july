<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Ruby and Python Programming Topics for Mac OS X: Using Scripting Bridge in PyObjC and RubyCocoa Code</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Using Scripting Bridge in PyObjC and RubyCocoa Code"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40005424" title="Using Scripting Bridge in PyObjC and RubyCocoa Code"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../DesignGuidelines-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000556" target="_top">Design Guidelines</a> &gt; <a href="../index.html" target="_top">Ruby and Python Programming Topics for Mac OS X</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="Using RubyOSA.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="GenerateFrameworkMetadata.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>
        
        
        <a name="//apple_ref/doc/uid/TP40005424-SW1" title="Using Scripting Bridge in PyObjC and RubyCocoa Code"></a><hr /><H1>Using Scripting Bridge in PyObjC and RubyCocoa Code</H1><p>Scripting Bridge is a technology that you can use in PyObjC and RubyCocoa scripts to communicate with scriptable applications—that is, applications with scripting interfaces compliant with the Open Scripting Architecture (OSA). With Scripting Bridge, RubyCocoa and PyObjC scripts can do what AppleScript scripts can do: control scriptable applications and exchange data with them. The Scripting Bridge framework implements a bridge between OSA and the Objective-C runtime. It reads the scripting definition of applications and dynamically populates the Objective-C namespace with objects and methods representing the various items it finds (scripting objects, elements, commands, properties, and so on). RubyCocoa and PyObjC are also bridges to the Objective-C runtime and thus have access to everything in a program’s namespace, including Scripting Bridge–created objects.</p><p>The section on Scripting Bridge in <span class="content_text"><a href="RubyPythonMacOSX.html#//apple_ref/doc/uid/TP40005423-SW1">“Ruby and Python on Mac OS X”</a></span> surveys the technology, describing its capabilities and architecture. The following sections describe how your RubyCocoa and PyObjC scripts and programs can take advantage of Scripting Bridge.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40005424-DontLinkElementID_34" title="Important:"></a><p><strong>Important:</strong>&nbsp;The Ruby and Python bridges to Objective-C use framework metadata to learn about non-introspectable types. However, the classes that Scripting Bridge dynamically generates currently do not include any metadata. This mismatch leads to some limitations when using Scripting Bridge in RubyCocoa and PyObjC code. For example, Scripting Bridge declares enumerated types in its Objective-C headers, but these are not bridged to RubyCocoa and PyObjC as symbolic entities. To use an enumerated value in a script you must specify the corresponding integral value; for instance, the value of iChat’s ‘away’ enumerator would be 0x61776179. Another important mismatch to be aware of are Boolean parameters and return types. Scripting Bridge declares these as <code>BOOL</code>, which is a <code>typedef</code> for <code>signed char</code>. However, Ruby evaluates all numbers, even zero, as logically true because they are Number objects. Consequently when using Scripting Bridge in RubyCocoa you must test Boolean values for equality to zero and not whether they are logically false.</p><p>These limitations apply to the initial version of Scripting Bridge, which was introduced in Mac OS X version 10.5.</p><p></p></div>
<!-- This template is being used for both PDF and HTML. -->

    
    <!-- TopicBook.pm uses this template for its miniTOCs, but needs a different title. -->
    <h4>Contents:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="UsingScriptingBridge.html#//apple_ref/doc/uid/TP40005424-SW2">The Basics</a>
				
			<br/>
			
        
			
			
				<a href="UsingScriptingBridge.html#//apple_ref/doc/uid/TP40005424-SW10">The Scripting Bridge Classes</a>
				
			<br/>
			
        
			
			
				<a href="UsingScriptingBridge.html#//apple_ref/doc/uid/TP40005424-DontLinkElementID_23">Getting Information About an Application’s Scripting Definition</a>
				
			<br/>
			
        
			
			
				<a href="UsingScriptingBridge.html#//apple_ref/doc/uid/TP40005424-SW11">Improving the Performance of Scripting Bridge Code</a>
				
			<br/>
			
        
			
			
				<a href="UsingScriptingBridge.html#//apple_ref/doc/uid/TP40005424-DontLinkElementID_24">Some Examples</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40005424-SW2" title="The Basics"></a><h2>The Basics</h2><p>The essential idea behind using Scripting Bridge is to get an object representing a scriptable application and then send messages to that object. Messages can result in objects being returned from the application object, and you can send messages to those objects—and so on down the object graph. The messages that you can send are described in the application’s scripting interface, or dictionary. Let’s start by looking at a simple example using RubyCocoa (<span class="content_text">Listing 1</span>). </p><a name="//apple_ref/doc/uid/TP40005424-SW3" title="Listing 1The iTunes_inspect.rb script"></a><p class="codesample"><strong>Listing 1&nbsp;&nbsp;</strong>The <code>iTunes_inspect.rb</code> script</p><div class="codesample"><table><tr><td scope="row"><pre>require 'osx/cocoa'<span></span></pre></td></tr><tr><td scope="row"><pre>include OSX<span></span></pre></td></tr><tr><td scope="row"><pre>OSX.require_framework 'ScriptingBridge'<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>iTunes = SBApplication.applicationWithBundleIdentifier_("com.apple.iTunes")<span></span></pre></td></tr><tr><td scope="row"><pre>iTunes.sources.each do |source|<span></span></pre></td></tr><tr><td scope="row"><pre>  puts source.name<span></span></pre></td></tr><tr><td scope="row"><pre>  source.playlists.each do |playlist|<span></span></pre></td></tr><tr><td scope="row"><pre>    puts " -> #{playlist.name}"<span></span></pre></td></tr><tr><td scope="row"><pre>    playlist.tracks.each do |track|<span></span></pre></td></tr><tr><td scope="row"><pre>      puts "      -> #{track.name}" if track.enabled?<span></span></pre></td></tr><tr><td scope="row"><pre>    end<span></span></pre></td></tr><tr><td scope="row"><pre>  end<span></span></pre></td></tr><tr><td scope="row"><pre>end<span></span></pre></td></tr></table></div><p>When you run this script from the command line, it prints information similar to the following lines:</p><div class="codesample"><table><tr><td scope="row"><pre>Library<span></span></pre></td></tr><tr><td scope="row"><pre>-> Classical CD<span></span></pre></td></tr><tr><td scope="row"><pre>     -> Toccata &amp; Fugue in D Minor<span></span></pre></td></tr><tr><td scope="row"><pre>     -> Air on the G String (2nd movement from Orchestral Suite No. 3 in D)<span></span></pre></td></tr><tr><td scope="row"><pre>     -> No.13 Waltz of the Flowers<span></span></pre></td></tr><tr><td scope="row"><pre>     -> Montagues And Capulets<span></span></pre></td></tr><tr><td scope="row"><pre>     -> Egmont Overture, Op 84<span></span></pre></td></tr><tr><td scope="row"><pre>     -> Die Zauberflöte<span></span></pre></td></tr><tr><td scope="row"><pre>     -> Horn concerto 3EFlat, 1. Allegro<span></span></pre></td></tr><tr><td scope="row"><pre>     -> Horn concerto 3EFlat 2. Romance. Larguetto<span></span></pre></td></tr><tr><td scope="row"><pre>     -> Horn concerto 3EFlat, 3. Allegro<span></span></pre></td></tr><tr><td scope="row"><pre>     ........<span></span></pre></td></tr></table></div><p>The first thing to notice about the script in <span class="content_text"><a href="UsingScriptingBridge.html#//apple_ref/doc/uid/TP40005424-SW3">Listing 1</a></span> are the first three lines, which set up the necessary environment. The first statement loads the osx/cocoa library, and the next two statements append the features of the OSX module and import the Scripting Bridge framework from it.. All three statements in the given order are required for RubyCocoa programs that use the Scripting Bridge.</p><p>The next line is particularly interesting:</p><div class="codesample"><table><tr><td scope="row"><pre>iTunes = SBApplication.applicationWithBundleIdentifier_("com.apple.iTunes")<span></span></pre></td></tr></table></div><p>This statement is a message expression that returns an proxy Ruby object representing a scriptable application, in this case iTunes. The message invokes the class method <code><a href="../../../Reference/SBApplication_Class/SBApplication/SBApplication.html#//apple_ref/occ/clm/SBApplication/applicationWithBundleIdentifier:" target="_top">applicationWithBundleIdentifier:</a></code> of the <code>SBApplication</code> class of the Scripting Bridge framework. This method requires that you identify the scriptable application by its bundle identifier. (See <span class="content_text"><a href="UsingScriptingBridge.html#//apple_ref/doc/uid/TP40005424-SW10">“The Scripting Bridge Classes”</a></span> for more about <code>SBApplication</code> and its methods for creating application objects.)</p><p>From this point on, the script sends messages across the bridge to the scriptable-application object and the objects it contains, gets the values of certain properties, and performs Ruby operations on the results. In Scripting Bridge’s internal representation of a scriptable application, a hierarchy of objects descends from the application object; sending a message to the application object may return elements, which are collections of other objects; each object in the element array may have elements containing objects, and so on. You can send appropriate messages to each of these objects. Take these lines as an example: </p><div class="codesample"><table><tr><td scope="row"><pre>iTunes.sources.each do |source|<span></span></pre></td></tr><tr><td scope="row"><pre>    puts source.name<span></span></pre></td></tr><tr><td scope="row"><pre>    source.playlists.each do |playlist|<span></span></pre></td></tr><tr><td scope="row"><pre>        puts " -> #{playlist.name}"<span></span></pre></td></tr></table></div><p>The <code>sources</code> message to the iTunes proxy object returns an object that implements the Ruby Array interface; on the other side of the bridge, this is an <code><a href="../../../Reference/SBElementArray_Class/SBElementArray/SBElementArray.html#//apple_ref/occ/cl/SBElementArray" target="_top">SBElementArray</a></code> object. The script then loops through the array and in a block sends a <code>name</code> message to each fetched object (<code>source</code>, representing a music source) and prints the returned Ruby string. It next sends <code>playlists</code> to <code>source</code> and iterates through the array returned from that call, which represents the playlists associated with that music source. It prints the name of each playlist. And so on until it gets and prints the name of each track.</p><p>Using Scripting Bridge in a PyObjC script is as simple and straightforward as it is for RubyCocoa. Here is a short script that prints (to standard output) the name of the track currently playing on iTunes:</p><div class="codesample"><table><tr><td scope="row"><pre>from Foundation import *<span></span></pre></td></tr><tr><td scope="row"><pre>from ScriptingBridge import *<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>iTunes = SBApplication.applicationWithBundleIdentifier_("com.apple.iTunes")<span></span></pre></td></tr><tr><td scope="row"><pre>print iTunes.currentTrack().name()<span></span></pre></td></tr></table></div><p>In this case, setting up the environment for using Scripting Bridge involves just two import statements, one for the Foundation framework and the other for the Scripting Bridge framework.</p><p>The Scripting Bridge also allows you to add objects to a scriptable application. For this it declares the following <code>SBApplication</code> method, which returns the class object for the scripting class specified in the receiver’s scripting definition:</p><div class="codesample"><table><tr><td scope="row"><pre>+ (Class)classForScriptingClass:(NSString *)className;<span></span></pre></td></tr></table></div><p>Once you have the <code>Class</code> object, you can instantiate a scripting object of the indicated type and add it to the application. If, for example, you wanted to add a playlist to iTunes, in PyObjC code you could similar to the example in <span class="content_text"><a href="UsingScriptingBridge.html#//apple_ref/doc/uid/TP40005424-SW4">Listing 2</a></span>:</p><a name="//apple_ref/doc/uid/TP40005424-SW4" title="Listing 2Adding an object to a scriptable application in PyObjC code"></a><p class="codesample"><strong>Listing 2&nbsp;&nbsp;</strong>Adding an object to a scriptable application in PyObjC code</p><div class="codesample"><table><tr><td scope="row"><pre>from Foundation import *<span></span></pre></td></tr><tr><td scope="row"><pre>from ScriptingBridge import *<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>iTunes = SBApplication.applicationWithBundleIdentifier_("com.apple.iTunes")<span></span></pre></td></tr><tr><td scope="row"><pre>p = {'name':'Testing'}<span></span></pre></td></tr><tr><td scope="row"><pre>playlist = iTunes.classForScriptingClass_("playlist").alloc().initWithProperties_(p)<span></span></pre></td></tr><tr><td scope="row"><pre>iTunes.sources()[0].playlists().insertObject_atIndex_(playlist, 0)<span></span></pre></td></tr></table></div><p>Scripting Bridge does not actually create an object in the target application until you add the allocated and initialized object to an appropriate element array (<code><a href="../../../Reference/SBElementArray_Class/SBElementArray/SBElementArray.html#//apple_ref/occ/cl/SBElementArray" target="_top">SBElementArray</a></code>), such as <code>playlists</code> in the above example.</p><a name="//apple_ref/doc/uid/TP40005424-SW10" title="The Scripting Bridge Classes"></a><h2>The Scripting Bridge Classes</h2><p>The Scripting Bridge framework has three public Objective-C classes:</p><ul class="ul"><li class="li"><p><code><a href="../../../Reference/SBApplication_Class/SBApplication/SBApplication.html#//apple_ref/occ/cl/SBApplication" target="_top">SBApplication</a></code>—A class whose objects represent scriptable applications</p></li><li class="li"><p><code><a href="../../../Reference/SBElementArray_Class/SBElementArray/SBElementArray.html#//apple_ref/occ/cl/SBElementArray" target="_top">SBElementArray</a></code>—A class whose objects represent collections of elements in the scripting definition</p></li><li class="li"><p><code><a href="../../../Reference/SBObject_Class/SBObject/SBObject.html#//apple_ref/occ/cl/SBObject" target="_top">SBObject</a></code>—The base class of scripting objects in a scriptable application</p></li></ul><p>The class factory methods of  <code>SBApplication</code> enable you to obtain an object representing an OSA-compliant application.  The following methods return an <code>SBApplication</code> object representing an application (autoreleased in memory-managed environments):</p><ul class="simple"><li><p><code>+ (id) applicationWithBundleIdentifier:(NSString *)bundleID;</code></p><p>Finds the application using its bundle identifier, for example <code>@"com.apple.iTunes"</code>. This is the recommended approach for most situations, especially when the application is local, because it dynamically locates the application. </p></li><li><p><code>+ (id) applicationWithURL:(NSURL *)url;</code></p><p>Finds the application using an object representing a URL with a <code>file:</code> or <code>eppc:</code> file scheme; the latter scheme is used for locating remote applications. </p></li><li><p><code>+ (id) applicationWithProcessIdentifier:(pid_t)pid;</code></p><p>Finds the application using its BSD process identifier (<code>pid</code>).</p></li></ul><div class="notebox"><a name="//apple_ref/doc/uid/TP40005424-DontLinkElementID_35" title="Note"></a><p><strong>Note:</strong>&nbsp;There are initializers corresponding to the above class factory methods—for example, <code>initWithProcessIdentifier:</code>—which would require you to allocate a generic <code>SBApplication</code> object first. But the recommended usage pattern is to call one of the <code>applicationWith...</code> methods. </p></div><p>When you create an <code>SBApplication</code> object, Scripting Bridge reads the application’s scripting definition and constructs a graph of objects that represents what it finds. It creates an instance representing an application from a dynamically defined and implemented subclass of <code>SBApplication</code> that is specific to the application. This instance is the top-level object of the graph. It populates the subordinate objects of the graph with <code>SBElementArray</code> and <code>SBObject</code> objects. It creates instances of the scripting classes it finds in the application’s <code>sdef</code> file from dynamically defined and implemented subclasses of <code>SBObject</code>. Elements, however, are always represented in Objective-C code by instances of <code>SBElementArray</code>, which is a subclass of <code><a href="../../../Reference/Foundation/Classes/NSMutableArray_Class/Reference/Reference.html#//apple_ref/occ/cl/NSMutableArray" target="_top">NSMutableArray</a></code>. This means that you can invoke on <code>SBElementArray</code> object all the methods of <code>NSMutableArray</code> and its superclass, <code><a href="../../../Reference/Foundation/Classes/NSArray_Class/Reference/Reference.html#//apple_ref/occ/cl/NSArray" target="_top">NSArray</a></code>, </p><p>In addition to creating objects, Scripting Bridge implements various methods in the <code>SBApplication</code> and <code>SBObject</code> subclasses to represent the types of certain items it finds in the application’s <code>sdef</code> file. It implements scriptable properties as Objective-C declared properties (that is, with the <code>@property</code> directive); the declared properties, in turn, synthesize accessor methods to get and (in some cases) set the value of the property. It implements elements as methods that return <code>SBElementArray</code> objects. And it implements commands as parameter-less methods returning no value; where these methods are implemented depends on whether they are of a specific or generic object class:</p><ul class="ul"><li class="li"><p>If it is of a specific object class (such as “document”) it is implemented as a method on that class.</p></li><li class="li"><p>If it is a generic object (such as “specifier”) it is implemented as a method of the the <code>SBApplication</code> subclass.</p></li></ul><p>Each <code>SBObject</code> and <code>SBApplication</code> object is built around an object specifier, a reference that tells Scripting Bridge how to locate the actual object in the target application. To obtain the more specific, canonical form of the reference, you must evaluate the object in an appropriate message expression or send it a <code><a href="../../../Reference/SBObject_Class/SBObject/SBObject.html#//apple_ref/occ/instm/SBObject/get" target="_top">get</a></code> message. See <span class="content_text"><a href="UsingScriptingBridge.html#//apple_ref/doc/uid/TP40005424-SW11">“Improving the Performance of Scripting Bridge Code”</a></span> for more information on this subject.</p><a name="//apple_ref/doc/uid/TP40005424-DontLinkElementID_23" title="Getting Information About an Application&acirc;&#128;&#153;s Scripting Definition"></a><h2>Getting Information About an Application’s Scripting Definition</h2><p>You can find out which messages you can send to a scriptable application by examining a header file containing Objective-C declarations of the application class and the application’s scripting classes. The header file serves as reference documentation for that application. It includes information about the inheritance relationships between classes and the containment relationships between their objects. It declares commands and elements as methods, and declares properties as Objective-C declared properties. Taking the iTunes application as an example, the header file shows the definition of the application class (<code>iTunesApplication</code>), the application’s scripting classes, such as <code>iTunesTrack</code> and <code>iTunesSource</code>, commands (such as the <code>eject</code> method), and properties (such as the <code>artist</code> declared property). A header files also includes comments extracted from the scripting definition, such as the comment added to this declaration for the <code>FinderApplication</code> class: </p><div class="codesample"><table><tr><td scope="row"><pre>- (void)empty;   // Empty the trash<span></span></pre></td></tr></table></div><p>You need to translate Objective-C method declarations into the Ruby or Python equivalent—or example, replacing the colon of each keyword with an underscore.</p><p>To create a header file you need to run two command-line tools—<code>sdef</code> and <code>sdp</code>—together, with the output from one piped to the other. This is the recommended syntax:</p><p><code>sdef </code><em>/path/to/application</em><code>.app | sdp -fh --basename </code><em>applicationName</em><code> --bundleid </code><em>bundleIdentifier</em></p><p>The <code>sdef</code> utility gets the scripting definition from the designated application; if that application does not contain an sdef file, but does instead contain scripting information in an older format (such as the scripting suite and terminology property lists), it translates that information into the sdef format first. The <code>sdp</code> tool run with the above options generates an Objective-C header file for the designated scriptable application. Thus, for iTunes, you would run the following command to produce a header file named <code>iTunes.h</code>:</p><div class="codesample"><table><tr><td scope="row"><pre>sdef /Applications/iTunes.app | sdp -fh --basename iTunes --bundleid com.apple.iTunes<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40005424-SW11" title="Improving the Performance of Scripting Bridge Code"></a><h2>Improving the Performance of Scripting Bridge Code</h2><p>Because fetching data from a scriptable application via Apple events is expensive, the Scripting Bridge is designed to defer the sending of Apple events until it needs to. It does this by using references to objects. When you ask the Scripting Bridge for an object in a scriptable application, it returns a reference to that object, not the object itself. It defers evaluation of the reference into its original canonical form until you actually request data from that object. This technique is called lazy evaluation. For example, if you request an iTunes track, it returns a reference to the track object; but when you request the name of the track, it evaluates the reference and sends an Apple event to fetch the string data (that is, the name). This design of the Scripting Bridge leads to a few recommended programming practices:</p><ul class="ul"><li class="li"><p>Be careful about the order of the statements in your code; do not assume you’ve received the data that was present in an object when you first obtained a reference to it.</p></li><li class="li"><p>To force the evaluation of an object reference, invoke the <code><a href="../../../Reference/SBObject_Class/SBObject/SBObject.html#//apple_ref/occ/instm/SBObject/get" target="_top">get</a></code> method (declared by <code>SBObject</code>) on an object. This call returns the more specific, canonical form of reference to the object.</p><p>Using <code>get</code> to force evaluation is valuable when you want to retain a reference to the current object when the non-canonical form of reference—<code>app.documents[0]</code> (for frontmost document)—could refer to different objects over time. However, because calling <code>get</code> involves the sending of an Apple event, you should use it only when necessary.</p></li><li class="li"><p>Do not force repeated evaluations of an object reference in a loop, such as when comparing the name of an object against a series of string constants. Each such call results in the sending of an Apple event. Instead force evaluation once and store the returned value in a local variable; then use that variable in the loop.</p></li><li class="li"><p>As a corollary to the above guideline, avoid enumerating <code><a href="../../../Reference/SBElementArray_Class/SBElementArray/SBElementArray.html#//apple_ref/occ/cl/SBElementArray" target="_top">SBElementArray</a></code> objects if there are alternatives, which Scripting Bridge and Cocoa provide:  </p><ul class="nested"><li class="nested li"><p>Use the <code><a href="../../../Reference/SBElementArray_Class/SBElementArray/SBElementArray.html#//apple_ref/occ/instm/SBElementArray/arrayByApplyingSelector:" target="_top">arrayByApplyingSelector:</a></code> or <code><a href="../../../Reference/SBElementArray_Class/SBElementArray/SBElementArray.html#//apple_ref/occ/instm/SBElementArray/arrayByApplyingSelector:withObject:" target="_top">arrayByApplyingSelector:withObject:</a></code> method to get a value from each object in the array.</p></li><li class="nested li"><p>Use the <code><a href="../../../Reference/Foundation/Classes/NSArray_Class/Reference/Reference.html#//apple_ref/occ/instm/NSArray/makeObjectsPerformSelector:" target="_top">makeObjectsPerformSelector:</a></code> or <code><a href="../../../Reference/Foundation/Classes/NSArray_Class/Reference/Reference.html#//apple_ref/occ/instm/NSArray/makeObjectsPerformSelector:withObject:" target="_top">makeObjectsPerformSelector:withObject:</a></code> method if you want to make each object in the array do something.</p></li><li class="nested li"><p>Use the <code><a href="../../../Reference/Foundation/Classes/NSArray_Class/Reference/Reference.html#//apple_ref/occ/instm/NSArray/filteredArrayUsingPredicate:" target="_top">filteredArrayUsingPredicate:</a></code> method if you want a specific subset of the original array. </p></li></ul></li></ul><p>Another technique for improving the performance of your code is checking whether an application is launched before trying to communicate with it. When you create an instance of a scriptable application, the Scripting Bridge automatically launches it if it hasn’t already been launched. This is an expensive operation. Sometimes this might be what you want, but in other situations you might be interested in communicating with an application only if it’s currently being used. In such cases, invoke the <code><a href="../../../Reference/SBApplication_Class/SBApplication/SBApplication.html#//apple_ref/occ/instm/SBApplication/isRunning" target="_top">isRunning</a></code> method of <code>SBApplication</code> and check the returned Boolean value before proceeding.</p><p><em><a href="../../../../../releasenotes/ScriptingAutomation/RN-ScriptingBridge/index.html#//apple_ref/doc/uid/TP40004741" target="_top">Scripting Bridge Release Note</a></em> presents detailed information on lazy evaluation, checking for launched applications, and related APIs and programming guidelines. </p><a name="//apple_ref/doc/uid/TP40005424-DontLinkElementID_24" title="Some Examples"></a><h2>Some Examples</h2><p>To better appreciate the varieties of ways in which you might use Scripting Bridge in RubyCocoa or PyObjC code, let’s examine a few examples. The script in <span class="content_text">Listing 3</span> creates a proxy instance of the Finder application and from it requests the current contents of the Desktop. Using Ruby regular expressions and string-manipulation methods, it formats and prints these items.</p><a name="//apple_ref/doc/uid/TP40005424-SW5" title="Listing 3The Finder_show_desktop.rb script"></a><p class="codesample"><strong>Listing 3&nbsp;&nbsp;</strong>The <code>Finder_show_desktop.rb</code> script</p><div class="codesample"><table><tr><td scope="row"><pre># Lists the content of the Finder desktop.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>require 'osx/cocoa'<span></span></pre></td></tr><tr><td scope="row"><pre>include OSX<span></span></pre></td></tr><tr><td scope="row"><pre>OSX.require_framework 'ScriptingBridge'<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>app = SBApplication.applicationWithBundleIdentifier_("com.apple.finder")<span></span></pre></td></tr><tr><td scope="row"><pre>ary = app.desktop.entireContents.get<span></span></pre></td></tr><tr><td scope="row"><pre>ary.each do |x|<span></span></pre></td></tr><tr><td scope="row"><pre>    next unless x.is_a?(OSX::FinderItem)<span></span></pre></td></tr><tr><td scope="row"><pre>    puts "#{x.class.name.sub(/^.+::/, '').sub(/_/, ' ').ljust(25)} #{x.name}"<span></span></pre></td></tr><tr><td scope="row"><pre>end<span></span></pre></td></tr></table></div><p>The script in <span class="content_text">Listing 4</span> exchanges data between proxy instances of two applications, TextEdit and Mail. It gets the selected messages in all current Mail viewers and copies each the content of each message to a TextEdit window. There are a couple things of special note in this script. It shows how to create a scripting class for the current application using <code><a href="../../../Reference/SBApplication_Class/SBApplication/SBApplication.html#//apple_ref/occ/instm/SBApplication/classForScriptingClass:" target="_top">classForScriptingClass:</a></code> to obtain the <code>Class</code> object to use for allocation; it then adds the created document to an <code>SBElementArray</code> object (<code>textedit.documents</code>) <em>before</em> setting its text to that of the email message.</p><a name="//apple_ref/doc/uid/TP40005424-SW7" title="Listing 4The get_selected_mail.rb script"></a><p class="codesample"><strong>Listing 4&nbsp;&nbsp;</strong>The <code>get_selected_mail.rb</code> script</p><div class="codesample"><table><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre># Copy contents of selected Mail messages to a TextEdit window<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>require 'osx/cocoa'<span></span></pre></td></tr><tr><td scope="row"><pre>include OSX<span></span></pre></td></tr><tr><td scope="row"><pre>OSX.require_framework 'ScriptingBridge'<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>textedit = SBApplication.applicationWithBundleIdentifier_("com.apple.TextEdit")<span></span></pre></td></tr><tr><td scope="row"><pre>mailApp = SBApplication.applicationWithBundleIdentifier_("com.apple.mail")<span></span></pre></td></tr><tr><td scope="row"><pre>viewers = mailApp.messageViewers<span></span></pre></td></tr><tr><td scope="row"><pre>viewers.each do |viewer|<span></span></pre></td></tr><tr><td scope="row"><pre>  viewer.selectedMessages.each do |message|<span></span></pre></td></tr><tr><td scope="row"><pre>    doc = textedit.classForScriptingClass_("document").alloc.init<span></span></pre></td></tr><tr><td scope="row"><pre>    textedit.documents.addObject_(doc)<span></span></pre></td></tr><tr><td scope="row"><pre>    doc.setText_(message.content.get)<span></span></pre></td></tr><tr><td scope="row"><pre> end<span></span></pre></td></tr><tr><td scope="row"><pre>end<span></span></pre></td></tr></table></div><p>Finally. the <span class="content_text">Listing 5</span> script updates in the iChat status area the time the system has been running since it was last booted. It is similar to <span class="content_text"><a href="UsingScriptingBridge.html#//apple_ref/doc/uid/TP40005424-SW3">Listing 1</a></span> it that it makes a system call, but instead of calling the <code>system</code> method, it invokes the <code>uptime</code> command simply by enclosing it in single quotes. It then formats the output of the command and assigns this formatted string to the iChat <code>status_message</code> property. All this occurs in a closed loop, which is re-executed after a five-second pause, which causes a periodic update of the system-uptime message.</p><a name="//apple_ref/doc/uid/TP40005424-SW9" title="Listing 5The iChat_uptime.rb script"></a><p class="codesample"><strong>Listing 5&nbsp;&nbsp;</strong>The <code>iChat_uptime.rb</code> script</p><div class="codesample"><table><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre># Periodically set your iChat status to the output of uptime(1).<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>require 'osx/cocoa'<span></span></pre></td></tr><tr><td scope="row"><pre>include OSX<span></span></pre></td></tr><tr><td scope="row"><pre>OSX.require_framework 'ScriptingBridge'<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>app = SBApplication.applicationWithBundleIdentifier_("com.apple.iChat")<span></span></pre></td></tr><tr><td scope="row"><pre>previous_status_message = app.statusMessage<span></span></pre></td></tr><tr><td scope="row"><pre>trap('INT') { app.statusMessage = previous_status_message; exit 0 }<span></span></pre></td></tr><tr><td scope="row"><pre>while true<span></span></pre></td></tr><tr><td scope="row"><pre>    u = `uptime`<span></span></pre></td></tr><tr><td scope="row"><pre>    hours = u.scan(/^\s*(\d+:\d+)\s/).to_s + ' hours'<span></span></pre></td></tr><tr><td scope="row"><pre>    days = u.scan(/\d+\sdays/).to_s<span></span></pre></td></tr><tr><td scope="row"><pre>    app.statusMessage = "OSX up #{days} #{hours}"<span></span></pre></td></tr><tr><td scope="row"><pre>    sleep 5<span></span></pre></td></tr><tr><td scope="row"><pre>end<span></span></pre></td></tr></table></div><p>This script traps interruption of the script (such as happens when the user presses Control-C) and restores the previous value of the iChat status message before exiting.</p>

        <br/><br/> 

        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="Using RubyOSA.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="GenerateFrameworkMetadata.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-10-31<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/RubyPythonCocoa/Articles/UsingScriptingBridge.html%3Fid%3DTP40004936-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/RubyPythonCocoa/Articles/UsingScriptingBridge.html%3Fid%3DTP40004936-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/RubyPythonCocoa/Articles/UsingScriptingBridge.html%3Fid%3DTP40004936-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>
