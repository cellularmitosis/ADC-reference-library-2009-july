#include "SlamPixels.proto.h"typedef struct {	char		*packedImage;	short		*code;} pixiZAM;void CIconToPixiZAM(CIconHandle cicn, pixiZam *pz){	char	*srcImagePtr;	char	*maskImagePtr;	char	*dstImagePtr;	short	*dstCodePtr;	long	imageMemSize;	long	imageCodeSize;		srcImagePtr = (**cicn).iconPMap.baseAddr;	maskImagePtr = (**cicn).iconPMap.maskImagePtr;	imageMemSize = ((**cicn).iconPMap.bounds.bottom - 				(**cicn).iconPMap.bounds.top) * (**cicn).iconPMap.rowBytes;					dstImagePtr = NewPtrClear(imageMemSize);		imageCodeSize = (**cicn).iconPMap.bounds.bottom - 				(**cicn).iconPMap.bounds.top) * (**cicn).iconPMap.rowBytes / 2);					dstCodePtr = NewPtrClear();		}void BlitPixie(PixMapHandle srcPixMapH, PixMapHandle dstPixMapH, Rect *pixRect){	long *srcPixP;										// pointer to video memory	long *dstPixP;										// pointer to video memory	register long numRowsToCopy;			// rows we are going to copy	long srcStripRowBytes;						// to clear high bit of rowbytes	long dstStripRowBytes;						// to clear high bit of rowbytes	register long srcRowLongsOffset;	// rowBytes converted to long	register long dstRowLongsOffset;	// rowBytes converted to long	long numRowLongs;									// number of long words per row	Rect blitRect;										// area to blit	char mmuMode;											// 32-bit mode required		// make a local copy so we can make some adjustments	blitRect = *pixRect;		// long word align the left edge	blitRect.left &= ~3;		// is the right edge long word aligned?	if (blitRect.right & 3)		{			// long word align the right edge		blitRect.right &= ~3;		// we could combine these into one line but THINK C		blitRect.right += 4;		// generates half as many instructions this way		}		// clip off the top so we dont write into random memory	if (blitRect.top < (**dstPixMapH).bounds.top)		{		blitRect.top = (**dstPixMapH).bounds.top;		if (blitRect.top >= blitRect.bottom)			{			return;			}		}		// clip off the left so we dont write into random memory	if (blitRect.left < (**dstPixMapH).bounds.left)		{		blitRect.left = (**dstPixMapH).bounds.left;		if (blitRect.left >= blitRect.right)			{			return;			}		}		// clip off the bottom so we dont write into random memory	if (blitRect.bottom > (**dstPixMapH).bounds.bottom)		{		blitRect.bottom = (**dstPixMapH).bounds.bottom;		if (blitRect.bottom <= blitRect.top)			{			return;			}		}		// clip off the right so we dont write into random memory	if (blitRect.right > (**dstPixMapH).bounds.right)		{		blitRect.right = (**dstPixMapH).bounds.right;		if (blitRect.right <= blitRect.left)			{			return;			}		}		// high bit of pixMap rowBytes must be cleared	srcStripRowBytes = (**srcPixMapH).rowBytes & 0x7FFF;		// high bit of pixMap rowBytes must be cleared	dstStripRowBytes = (**dstPixMapH).rowBytes & 0x7FFF;		// calculate the address of the first byte of the source	srcPixP = (long *)(GetPixBaseAddr(srcPixMapH) + ((long)srcStripRowBytes * blitRect.top) + blitRect.left);		// calculate the address of the first byte of the destination	dstPixP = (long *)(GetPixBaseAddr(dstPixMapH) + ((long)dstStripRowBytes * blitRect.top) + blitRect.left);		// calculate the number of rows to copy	numRowsToCopy = blitRect.bottom - blitRect.top;		// calculate the number of long words in a row	numRowLongs = (blitRect.right - blitRect.left) >> 2;		// calculate the long word offset from the end of one row to the start of the next	srcRowLongsOffset = (srcStripRowBytes >> 2) - numRowLongs;		// calculate the long word offset from the end of one row to the start of the next	dstRowLongsOffset = (dstStripRowBytes >> 2) - numRowLongs;		// change to 32-bit addressing mode to access video memory		// the previous addressing mode is returned in mmuMode for restoring later	mmuMode = true32b;	SwapMMUMode(&mmuMode);		// blit the pixels	do		{		// this is so sick, but it works!	switch (numRowLongs)		{		case 32:			*dstPixP++ = *srcPixP++;		case 31:			*dstPixP++ = *srcPixP++;		case 30:			*dstPixP++ = *srcPixP++;		case 29:			*dstPixP++ = *srcPixP++;		case 28:			*dstPixP++ = *srcPixP++;		case 27:			*dstPixP++ = *srcPixP++;		case 26:			*dstPixP++ = *srcPixP++;		case 25:			*dstPixP++ = *srcPixP++;		case 24:			*dstPixP++ = *srcPixP++;		case 23:			*dstPixP++ = *srcPixP++;		case 22:			*dstPixP++ = *srcPixP++;		case 21:			*dstPixP++ = *srcPixP++;		case 20:			*dstPixP++ = *srcPixP++;		case 19:			*dstPixP++ = *srcPixP++;		case 18:			*dstPixP++ = *srcPixP++;		case 17:			*dstPixP++ = *srcPixP++;		case 16:			*dstPixP++ = *srcPixP++;		case 15:			*dstPixP++ = *srcPixP++;		case 14:			*dstPixP++ = *srcPixP++;		case 13:			*dstPixP++ = *srcPixP++;		case 12:			*dstPixP++ = *srcPixP++;		case 11:			*dstPixP++ = *srcPixP++;		case 10:			*dstPixP++ = *srcPixP++;		case 9:			*dstPixP++ = *srcPixP++;		case 8:			*dstPixP++ = *srcPixP++;		case 7:			*dstPixP++ = *srcPixP++;		case 6:			*dstPixP++ = *srcPixP++;		case 5:			*dstPixP++ = *srcPixP++;		case 4:			*dstPixP++ = *srcPixP++;		case 3:			*dstPixP++ = *srcPixP++;		case 2:			*dstPixP++ = *srcPixP++;		default:			*dstPixP++ = *srcPixP++;		}			// bump to start of next row		srcPixP += srcRowLongsOffset;		dstPixP += dstRowLongsOffset;		} while (--numRowsToCopy);		// restore addressing mode back to what it was	SwapMMUMode(&mmuMode);	}