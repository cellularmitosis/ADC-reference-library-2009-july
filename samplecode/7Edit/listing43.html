<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>7Edit - /Source/SVAESetData.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">7Edit</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxInterapplicationCommunication-date.html" target="_blank">Carbon > Interapplication Communication</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">7Edit</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Source/SVAESetData.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Source/DebugUtils.c</option>
<option value="listing2.html">/Source/DebugUtils.h</option>
<option value="listing3.html">/Source/Offscreen.c</option>
<option value="listing4.html">/Source/Offscreen.h</option>
<option value="listing5.html">/Source/SVAEAccessors.c</option>
<option value="listing6.html">/Source/SVAEAccessors.h</option>
<option value="listing7.html">/Source/SVAEClone.c</option>
<option value="listing8.html">/Source/SVAEClone.h</option>
<option value="listing9.html">/Source/SVAEClose.c</option>
<option value="listing10.html">/Source/SVAEClose.h</option>
<option value="listing11.html">/Source/SVAECoercions.c</option>
<option value="listing12.html">/Source/SVAECoercions.h</option>
<option value="listing13.html">/Source/SVAECompare.c</option>
<option value="listing14.html">/Source/SVAECompare.h</option>
<option value="listing15.html">/Source/SVAECopy.c</option>
<option value="listing16.html">/Source/SVAECopy.h</option>
<option value="listing17.html">/Source/SVAECountElements.c</option>
<option value="listing18.html">/Source/SVAECountElements.h</option>
<option value="listing19.html">/Source/SVAECreate.c</option>
<option value="listing20.html">/Source/SVAECreate.h</option>
<option value="listing21.html">/Source/SVAECut.c</option>
<option value="listing22.html">/Source/SVAECut.h</option>
<option value="listing23.html">/Source/SVAEDelete.c</option>
<option value="listing24.html">/Source/SVAEDelete.h</option>
<option value="listing25.html">/Source/SVAEGetData.c</option>
<option value="listing26.html">/Source/SVAEGetData.h</option>
<option value="listing27.html">/Source/SVAEGetDataSize.c</option>
<option value="listing28.html">/Source/SVAEGetDataSize.h</option>
<option value="listing29.html">/Source/SVAEMove.c</option>
<option value="listing30.html">/Source/SVAEMove.h</option>
<option value="listing31.html">/Source/SVAEObjectsExist.c</option>
<option value="listing32.html">/Source/SVAEObjectsExist.h</option>
<option value="listing33.html">/Source/SVAEPaste.c</option>
<option value="listing34.html">/Source/SVAEPaste.h</option>
<option value="listing35.html">/Source/SVAERecording.c</option>
<option value="listing36.html">/Source/SVAERecording.h</option>
<option value="listing37.html">/Source/SVAERevert.c</option>
<option value="listing38.html">/Source/SVAERevert.h</option>
<option value="listing39.html">/Source/SVAESave.c</option>
<option value="listing40.html">/Source/SVAESave.h</option>
<option value="listing41.html">/Source/SVAESelect.c</option>
<option value="listing42.html">/Source/SVAESelect.h</option>
<option value="listing43.html">/Source/SVAESetData.c</option>
<option value="listing44.html">/Source/SVAESetData.h</option>
<option value="listing45.html">/Source/SVAETextUtils.c</option>
<option value="listing46.html">/Source/SVAETextUtils.h</option>
<option value="listing47.html">/Source/SVAEWindowUtils.c</option>
<option value="listing48.html">/Source/SVAEWindowUtils.h</option>
<option value="listing49.html">/Source/SVAppleEvents.c</option>
<option value="listing50.html">/Source/SVAppleEvents.h</option>
<option value="listing51.html">/Source/SVDrag.c</option>
<option value="listing52.html">/Source/SVDrag.h</option>
<option value="listing53.html">/Source/SVEditAEUtils.c</option>
<option value="listing54.html">/Source/SVEditAEUtils.h</option>
<option value="listing55.html">/Source/SVEditFile.c</option>
<option value="listing56.html">/Source/SVEditFile.h</option>
<option value="listing57.html">/Source/SVEditGlobals.c</option>
<option value="listing58.html">/Source/SVEditGlobals.h</option>
<option value="listing59.html">/Source/SVEditMain.c</option>
<option value="listing60.html">/Source/SVEditMain.h</option>
<option value="listing61.html">/Source/SVEditPrinting.c</option>
<option value="listing62.html">/Source/SVEditPrinting.h</option>
<option value="listing63.html">/Source/SVEditUtils.c</option>
<option value="listing64.html">/Source/SVEditUtils.h</option>
<option value="listing65.html">/Source/SVEditWindow.c</option>
<option value="listing66.html">/Source/SVEditWindow.h</option>
<option value="listing67.html">/Source/SVToken.h</option></select>
				</p>
				</form>
				<p><strong><a href="7Edit.zip">Download Sample</a></strong> (&#147;7Edit.zip&#148;, 205.9K)<BR>
<strong><a href="7Edit.dmg">Download Sample</a></strong> (&#147;7Edit.dmg&#148;, 251.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    SVAESetData.c  Contains:    Written by: Original version by Jon Lansdell and Nigel Humphreys.        3.1 updates by Greg Sutton.  Copyright:  Copyright &copy; 1995-1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        7/20/1999  Karl Groethe  Updated for Metrowerks Codewarror Pro 2.1        */#include &quot;SVAESetData.h&quot;#include &quot;SVEditWindow.h&quot;#include &quot;SVEditGlobals.h&quot;#include &quot;SVEditAEUtils.h&quot;#include &quot;SVAETextUtils.h&quot;#include &quot;SVAppleEvents.h&quot;#include &quot;SVAESelect.h&quot;#include &quot;SVAECreate.h&quot;#include &lt;string.h&gt;#include &lt;TextUtils.h&gt;#include &lt;DriverServices.h&gt;// --------------------------------------------------------------------------//  Name:       DoSetData//  Purpose:    Handles the SetData Apple Event, extracting the direct//          object (which says what to set) and the data (what to set//          it to).// --------------------------------------------------------------------------   pascal OSErr  DoSetData(const AppleEvent  *theAppleEvent,                AppleEvent  *reply,                long    handlerRefCon){#pragma unused (reply, handlerRefCon)    AEDesc   directObj = {typeNull, NULL},      dataDesc = {typeNull, NULL};  OSErr    err;          // pick up the direct object, which is the object whose data is to be set  err = AEGetParamDesc(theAppleEvent,  keyDirectObject,                  typeWildCard, &amp;directObj);  if (noErr != err) goto done;        // now the data to set it to - typeWildCard means get as is    // e.g. this is the name of the font for text  err = AEGetParamDesc(theAppleEvent, keyAEData, typeWildCard, &amp;dataDesc);  if (noErr != err) goto done;      // missing any parameters?  err = GotRequiredParams(theAppleEvent);  if (noErr != err) goto done;      // set the data  err = HandleSetData(&amp;directObj, &amp;dataDesc);done:        if (directObj.dataHandle)    AEDisposeDesc(&amp;directObj);  if (dataDesc.dataHandle)    AEDisposeDesc(&amp;dataDesc);  return(err);}  // DoSetData// ---------------------------------------------------------------------------//    Name:       HandleSetData//    Purpose:    Resolves the object into a token (could be one of //            many) andthe sets the data of that object to dataDesc.// ---------------------------------------------------------------------------   OSErr HandleSetData(const AEDesc *theObj, AEDesc *dataDesc){  TextToken       theTextToken;  Size            tokenSize;  AEDesc          objTokenDesc = {typeNull, NULL},          itemDesc = {typeNull, NULL},          ignoreResult = {typeNull, NULL};  long      index;  DescType    returnedType;  OSErr           err;    //  Coerce theObj into a token which we can use -     //     set the property or data for that token  if (typeObjectSpecifier == theObj-&gt;descriptorType)    err = AEResolve(theObj, kAEIDoMinimum, &amp;objTokenDesc);  else  // Otherwise, just copy it    err = AEDuplicateDesc(theObj, &amp;objTokenDesc);  if (noErr != err) goto done;        switch (objTokenDesc.descriptorType)  {    case typeMyWindowProp:      err = DoSetWindowProperty(&amp;objTokenDesc, dataDesc);      break;        case typeMyTextProp:      err = SetTextProperty(&amp;objTokenDesc, dataDesc);      break;          case typeMyText:      GetRawDataFromDescriptor(&amp;objTokenDesc,  (Ptr)&amp;theTextToken,                      sizeof(theTextToken), &amp;tokenSize);                  // itemDesc is a null descriptor here      err = CreateAtTextToken(cText, dataDesc, &amp;theTextToken,                          &amp;itemDesc, &amp;ignoreResult);      break;    case typeAEList:        // If it's a list then do each item      err = AECountItems(&amp;objTokenDesc, &amp;index);      if (noErr != err) goto done;      for (; index &gt; 0; index--)      {        err = AEGetNthDesc(&amp;objTokenDesc, index, typeWildCard, &amp;returnedType, &amp;itemDesc);        if (noErr == err)    // Get property by calling this function again          err = HandleSetData(&amp;itemDesc, dataDesc);                if (itemDesc.dataHandle)          AEDisposeDesc(&amp;itemDesc);      }      break;          default:      err = errAEWrongDataType;  }done:  if (objTokenDesc.dataHandle)      AEDisposeDesc(&amp;objTokenDesc);  if (itemDesc.dataHandle)      AEDisposeDesc(&amp;itemDesc);  if (ignoreResult.dataHandle)    AEDisposeDesc(&amp;ignoreResult);  return(err);} // HandleSetDataOSErr  SetWindowSelectionProperty(WindowPtr theWindow, const AEDesc *dataDesc){  AEDesc    textDesc = {typeNull, NULL},        ignoreResult = {typeNull, NULL};  TextToken  aTextToken;  Size    actualSize;  short    ignore;  OSErr    err;        // first check to see if we are dealing with a TEXT descriptor or  // an object specifier. Since AECoerceDesc will end up calling  // AEResolve, we don't want to call this if the user entered something    // like 'Set selection of window 1 to &quot;some text '  switch (dataDesc-&gt;descriptorType)  {    case typeChar:    case typeIntlText:    case typeStyledText:      err = GetWindowSelection(theWindow, &amp;aTextToken, &amp;ignore);      if (noErr != err) goto done;            // textDesc is a null descriptor here      err = CreateAtTextToken(cText, dataDesc, &amp;aTextToken,                          &amp;textDesc, &amp;ignoreResult);      break;          default:   // we are dealing with an object specifier      err = AECoerceDesc(dataDesc, typeMyText, &amp;textDesc);      if (noErr != err) goto done;            GetRawDataFromDescriptor(&amp;textDesc, (Ptr)&amp;aTextToken, sizeof(aTextToken),                      &amp;actualSize);                            SelectTextToken(&amp;aTextToken);  }done:  if (textDesc.dataHandle)    AEDisposeDesc(&amp;textDesc);  return(err);}// ------------------------------------------------------------------------//  Name:     SetWindowProperty//  Purpose:  Sets the window property specified in theWindowPropToken to//        be that supplied in dataDesc.// ------------------------------------------------------------------------   OSErr  DoSetWindowProperty(const AEDesc *theWPTokenDesc, const AEDesc *dataDesc){  Str255          theNewName;  DPtr            theDocument;  Rect            thePosnRect;  Boolean         theBoolean;  GrafPtr         oldPort;  Point           thePosn;  THPrint         theTHPrint;  WindowPropToken theWindowPropToken;  TextToken    aTextToken;  AEDesc          aDesc = {typeNull, NULL},          nullDesc = {typeNull, NULL},          ignoreResult = {typeNull, NULL};  Size            tokenSize;  short           hOffset;  short           vOffset;  OSErr           err;  GetPort(&amp;oldPort);  err = AECoerceDesc(theWPTokenDesc, typeMyWindowProp, &amp;aDesc);  if (noErr != err) goto done;  GetRawDataFromDescriptor(&amp;aDesc, (Ptr)&amp;theWindowPropToken,                  sizeof(theWindowPropToken), &amp;tokenSize);  SetPort(theWindowPropToken.tokenWindowToken.tokenWindow);    theDocument = DPtrFromWindowPtr(theWindowPropToken.tokenWindowToken.tokenWindow);    switch (theWindowPropToken.tokenProperty)  {    case pName:      err = GetPStringFromDescriptor(dataDesc, theNewName);      if (noErr != err) goto done;      if (theNewName[0] == 0)         err = errAEWrongDataType;      else      {        SetWTitle(theWindowPropToken.tokenWindowToken.tokenWindow, theNewName);        PStrCopy(theDocument-&gt;theFileName, theNewName); // Should we do this???        theDocument-&gt;dirty = true;      }      break;          case pText:    case pContents:              // Get whole window as place to insert data      err = TextTokenFromWindowToken(&amp;(theWindowPropToken.tokenWindowToken), &amp;aTextToken);      if (noErr != err) goto done;      err = CreateAtTextToken(cText, dataDesc, &amp;aTextToken,                          &amp;nullDesc, &amp;ignoreResult);      break;          case pBounds:      err = GetRectFromDescriptor(dataDesc, &amp;thePosnRect);      // the rectangle is for the structure region, and is in global coordinates      // MoveWindow and SizeWindow apply to the content region, so we have to massage a little      thePosnRect.top    += (**((WindowPeek)theWindowPropToken.tokenWindowToken.tokenWindow)-&gt;contRgn).rgnBBox.top -                            (**((WindowPeek)theWindowPropToken.tokenWindowToken.tokenWindow)-&gt;strucRgn).rgnBBox.top;                                  thePosnRect.left   += (**((WindowPeek)theWindowPropToken.tokenWindowToken.tokenWindow)-&gt;contRgn).rgnBBox.left -                            (**((WindowPeek)theWindowPropToken.tokenWindowToken.tokenWindow)-&gt;strucRgn).rgnBBox.left;                                  thePosnRect.bottom += (**((WindowPeek)theWindowPropToken.tokenWindowToken.tokenWindow)-&gt;contRgn).rgnBBox.bottom -                            (**((WindowPeek)theWindowPropToken.tokenWindowToken.tokenWindow)-&gt;strucRgn).rgnBBox.bottom;                                  thePosnRect.right  += (**((WindowPeek)theWindowPropToken.tokenWindowToken.tokenWindow)-&gt;contRgn).rgnBBox.right -                            (**((WindowPeek)theWindowPropToken.tokenWindowToken.tokenWindow)-&gt;strucRgn).rgnBBox.right;            if (EmptyRect(&amp;thePosnRect))         err = errAECorruptData;      else      {        MoveWindow(theWindowPropToken.tokenWindowToken.tokenWindow,                   thePosnRect.left,                   thePosnRect.top,                   false);        SizeWindow(theWindowPropToken.tokenWindowToken.tokenWindow,                   thePosnRect.right- thePosnRect.left,                   thePosnRect.bottom-thePosnRect.top,                   true);        DoResizeWindow(theDocument);      }      break;          case pPosition:      err = GetPointFromDescriptor(dataDesc, &amp;thePosn);      // the point is for the structure region, and is in global coordinates      // MoveWindow applies to the content region, so we have to massage a little          hOffset = (**((WindowPeek)theWindowPropToken.tokenWindowToken.tokenWindow)-&gt;contRgn).rgnBBox.left -                (**((WindowPeek)theWindowPropToken.tokenWindowToken.tokenWindow)-&gt;strucRgn).rgnBBox.left;                      vOffset = (**((WindowPeek)theWindowPropToken.tokenWindowToken.tokenWindow)-&gt;contRgn).rgnBBox.top -                (**((WindowPeek)theWindowPropToken.tokenWindowToken.tokenWindow)-&gt;strucRgn).rgnBBox.top;                                      thePosn.v  += vOffset;      thePosn.h  += hOffset;            MoveWindow(theWindowPropToken.tokenWindowToken.tokenWindow,                 thePosn.h,                 thePosn.v,                 false);                       DoResizeWindow(theDocument);      break;          case pIsZoomed:      err = GetBooleanFromDescriptor(dataDesc, &amp;theBoolean);      if (theBoolean)        ZoomWindow(qd.thePort, inZoomOut, false);      else        ZoomWindow(qd.thePort, inZoomIn, false);                                 DoResizeWindow(theDocument);      break;          case pVisible:      err = GetBooleanFromDescriptor(dataDesc, &amp;theBoolean);      if (theBoolean)        ShowWindow(theWindowPropToken.tokenWindowToken.tokenWindow);      else        HideWindow(theWindowPropToken.tokenWindowToken.tokenWindow);      break;          case pPageSetup:        err = GetTHPrintFromDescriptor(dataDesc, &amp;theTHPrint);                  if (theTHPrint)         {          if (theDocument-&gt;thePrintSetup)             DisposeHandle((Handle)theDocument-&gt;thePrintSetup);                      theDocument-&gt;thePrintSetup = theTHPrint;                    ResizePageSetupForDocument(theDocument);        }          case pSelection:      err = SetWindowSelectionProperty(theWindowPropToken.tokenWindowToken.tokenWindow, dataDesc);      break;      default:        err = errAEEventNotHandled;  }  done:  if (aDesc.dataHandle)      AEDisposeDesc(&amp;aDesc);  if (nullDesc.dataHandle)    // You'd hope not    AEDisposeDesc(&amp;nullDesc);  if (ignoreResult.dataHandle)      AEDisposeDesc(&amp;ignoreResult);  SetPort(oldPort);    return(err);} // SetWindowPropertyOSErr  GetTHPrintFromDescriptor(const AEDesc *sourceDesc, THPrint *result){  Size    ptSize;  AEDesc  resultDesc;  OSErr   err;    *result = NULL;    err = AECoerceDesc(sourceDesc, typeTPrint, &amp;resultDesc);  if (noErr != err) goto done;    *result = (THPrint)NewHandle(sizeof(TPrint));    PrOpen();  PrintDefault(*result);    HLock((Handle)*result);  GetRawDataFromDescriptor(&amp;resultDesc, (Ptr)**result, sizeof(TPrint), &amp;ptSize);  HUnlock((Handle)*result);    if ((ptSize&lt;sizeof(TPrint)) || (PrValidate(*result)))  {    err = errAECoercionFail;    DisposeHandle((Handle)*result);    *result = NULL;  }    PrClose();done:    if (resultDesc.dataHandle)     AEDisposeDesc(&amp;resultDesc);      return(err);} // GetTHPrintFromDescriptor// ----------------------------------------------------------------------//  Name:     SetTextProperty//  Purpose:  Sets the text property specfied by theTextPropToken to//        that in dataDesc.// ----------------------------------------------------------------------   OSErr  SetTextProperty(const AEDesc *tokenDesc, const AEDesc *dataDesc){  DPtr            theDoc;  Str255          name;  short           theSize;  Style           onStyle;  Style           offStyle;  TextPropToken   theTextPropToken;  AEDesc          newDesc = {typeNull, NULL},          nullDesc = {typeNull, NULL},          ignoreResult = {typeNull, NULL};  Size            tokenSize;  OSErr           err;      err = AECoerceDesc(tokenDesc, typeMyTextProp, &amp;newDesc);    if (noErr != err) goto done;  GetRawDataFromDescriptor(&amp;newDesc, (Ptr)&amp;theTextPropToken,                  sizeof(theTextPropToken), &amp;tokenSize);      theDoc = DPtrFromWindowPtr(theTextPropToken.tokenTextToken.tokenWindow);  theDoc-&gt;dirty = true;    switch (theTextPropToken.tokenProperty)  {    case pText:    case pContents:      err = CreateAtTextToken(cText, dataDesc, &amp;(theTextPropToken.tokenTextToken),                                &amp;nullDesc, &amp;ignoreResult);      break;          case pFont:      err = GetPStringFromDescriptor(dataDesc, name);      if (noErr != err) goto done;      err = SetFontOfTextToken(&amp;theTextPropToken.tokenTextToken, name);      break;          case pPointSize:        err = GetIntegerFromDescriptor(dataDesc, &amp;theSize);      if (noErr != err) goto done;      err = SetSizeOfTextToken(&amp;theTextPropToken.tokenTextToken, theSize);      break;          case pTextStyles:      onStyle  = 0;      offStyle = 0;            err = GetTextStyles(dataDesc, &amp;onStyle, &amp;offStyle);      if (noErr != err) goto done;        if (onStyle &amp; offStyle != 0)        err = errAEEventFailed;      else        err = SetStyleOfTextToken(&amp;theTextPropToken.tokenTextToken, onStyle, offStyle);      break;        default:      err = errAEWrongDataType;  }done:  if (newDesc.dataHandle)    AEDisposeDesc(&amp;newDesc);        return(err);} // SetTextProperty  short ItemForNamedFont(Str255 theName){  Str255  itemName;  short   limit;  limit = CountMItems(myMenus[fontM]);  while (limit&gt;0)  {    GetMenuItemText(myMenus[fontM],limit, itemName);    if (EqualString(theName, itemName,true,false)==0)       return(limit);    else      limit--;  }  return(0);} // ItemForNamedFont// -----------------------------------------------------------------------//  Name:     SetFontOfTextToken//  Purpose:  Sets the font of the text specified by theToken to //        the font in name.// -----------------------------------------------------------------------   OSErr  SetFontOfTextToken(TextToken* theToken, Str255 name){  DPtr    docPtr;  TextToken  oldSelection;  short    theNumber,        theItem;  TextStyle  newStyle;  Boolean    fCurrentSelection;  OSErr    err;  docPtr = DPtrFromWindowPtr(theToken-&gt;tokenWindow);    if (!docPtr) return(errAENoSuchObject);            // ignore theNumber result  err = GetWindowSelection(theToken-&gt;tokenWindow, &amp;oldSelection, &amp;theNumber);  if (noErr != err) goto done;    if (memcmp(theToken, &amp;oldSelection, sizeof(TextToken)))  {    fCurrentSelection = false;    err = SelectTextToken(theToken);  // Only set the selection if it's different    if (noErr != err) goto done;  }  else    fCurrentSelection = true;        GetFNum(name, &amp;theNumber);    theItem = ItemForNamedFont(name); // returns 0 if failed - i.e. SystemFont    if (gFontMItem)    CheckItem(myMenus[fontM], gFontMItem, false);    gFontMItem = theItem;  CheckItem(myMenus[fontM], gFontMItem, true);    docPtr-&gt;theFont = theNumber;      newStyle.tsFont = theNumber;  TESetStyle(doFont, &amp;newStyle, true, docPtr-&gt;theText);     AdjustScrollbars(docPtr, false);  DrawPageExtras(docPtr);  docPtr-&gt;dirty = true;    if (! fCurrentSelection)    err = SelectTextToken(&amp;oldSelection);done:    return(err);} // SetFontOfTextToken  // -----------------------------------------------------------------------//  Name:       SetSizeOfTextToken//  Purpose:    Sets the size of the text specified by theToken to //          the size in theSize.// -----------------------------------------------------------------------   OSErr  SetSizeOfTextToken(TextToken* theToken, short theSize){  DPtr    docPtr;  TextToken  oldSelection;  TextStyle  newStyle;  short    ignore;  Boolean    fCurrentSelection;  OSErr    err;  docPtr = DPtrFromWindowPtr(theToken-&gt;tokenWindow);    if (!docPtr) return(errAENoSuchObject);            // Save the old selection  err = GetWindowSelection(theToken-&gt;tokenWindow, &amp;oldSelection, &amp;ignore);  if (noErr != err) goto done;    if (memcmp(theToken, &amp;oldSelection, sizeof(TextToken)))  {    fCurrentSelection = false;    err = SelectTextToken(theToken);    if (noErr != err) goto done;  }  else    fCurrentSelection = true;                docPtr-&gt;theSize = theSize;    newStyle.tsSize = theSize;  TESetStyle(doSize, &amp;newStyle, true, docPtr-&gt;theText);     AdjustScrollbars(docPtr, false);  DrawPageExtras(docPtr);  docPtr-&gt;dirty = true;    if (! fCurrentSelection)  // If we reset the selection we may loose the    err = SelectTextToken(&amp;oldSelection);  // Size or style just setdone:    return(err);} // SetSizeOfTextToken  // ------------------------------------------------------------------------//  Name:       SetStyleOfTextToken//  Purpose:    Sets the style of the text specified by theToken to //          the style in theStyle.// ------------------------------------------------------------------------   OSErr  SetStyleOfTextToken(TextToken* theToken, Style onStyle, Style offStyle){  DPtr    docPtr;  TextToken  oldSelection;  TextStyle  newStyle;  short    mode;  Boolean    wasContinuous;  short    ignore;  Boolean    fCurrentSelection;  OSErr    err;  docPtr = DPtrFromWindowPtr(theToken-&gt;tokenWindow);    if (!docPtr) return(errAENoSuchObject);            // Save the old selection  err = GetWindowSelection(theToken-&gt;tokenWindow, &amp;oldSelection, &amp;ignore);  if (noErr != err) goto done;    if (memcmp(theToken, &amp;oldSelection, sizeof(TextToken)))  {    fCurrentSelection = false;    err = SelectTextToken(theToken);    if (noErr != err) goto done;  }  else    fCurrentSelection = true;                docPtr-&gt;theStyle = onStyle;      // Check to see if off styles are on for whole selection  mode = doFace;    wasContinuous = TEContinuousStyle(&amp;mode, &amp;newStyle, docPtr-&gt;theText);  if ((newStyle.tsFace &amp; offStyle) != offStyle) // not off styles are on for all  {      // switch on across board so that toggle off will clear all    newStyle.tsFace  = offStyle - (newStyle.tsFace &amp; offStyle);    TESetStyle(doFace+doToggle, &amp;newStyle, false, docPtr-&gt;theText);   }      newStyle.tsFace  = offStyle;  TESetStyle(doFace+doToggle, &amp;newStyle,(onStyle==0), docPtr-&gt;theText); // toggle all to off    mode = doFace;  if (onStyle)  {    wasContinuous = TEContinuousStyle(&amp;mode, &amp;newStyle, docPtr-&gt;theText);    if ((newStyle.tsFace &amp; onStyle) != onStyle) // are they on for only a few chars    {         // Need to make all chars have these characteristics      newStyle.tsFace = onStyle - (newStyle.tsFace &amp; onStyle); // take out those continuous      TESetStyle(doFace+doToggle, &amp;newStyle, true, docPtr-&gt;theText);    }    else      TESetStyle(0, &amp;newStyle, true, docPtr-&gt;theText); // Just Draw it, no changes  }      AdjustScrollbars(docPtr, false);  DrawPageExtras(docPtr);  docPtr-&gt;dirty = true;    if (! fCurrentSelection)    err = SelectTextToken(&amp;oldSelection);done:    return(err);} // SetStyleOfTextToken  OSErr  GetTextStyles(const AEDesc *dataDesc, Style *onStyles, Style *offStyles){  OSErr      myErr;  OSErr      ignoreErr;  AEDescList textSDesc;  AEDescList onDesc;  AEDescList offDesc;  Boolean    hadPlain;      textSDesc.dataHandle = nil;  onDesc.dataHandle    = nil;  offDesc.dataHandle   = nil;    *onStyles  = 0;  *offStyles = 0;    myErr = AECoerceDesc(dataDesc, typeAERecord, &amp;textSDesc);    if (myErr==noErr)    myErr = AEGetKeyDesc(&amp;textSDesc, keyAEOnStyles, typeAEList, &amp;onDesc);    if (myErr==noErr)    myErr = AEGetKeyDesc(&amp;textSDesc, keyAEOffStyles, typeAEList, &amp;offDesc);    if (myErr==noErr)    myErr = MakeStyleFromAEList(&amp;onDesc,  onStyles, &amp;hadPlain);    if (hadPlain)    *offStyles = bold+italic+underline+outline+shadow+condense+extend;  else    {      if (myErr==noErr)        myErr = MakeStyleFromAEList(&amp;offDesc, offStyles, &amp;hadPlain);            if (hadPlain)        myErr = errAEEventFailed;    }      if (textSDesc.dataHandle)    ignoreErr = AEDisposeDesc(&amp;textSDesc);      if (onDesc.dataHandle)    ignoreErr = AEDisposeDesc(&amp;onDesc);      if (offDesc.dataHandle)    ignoreErr = AEDisposeDesc(&amp;offDesc);    return(myErr);} // GetTextStyles// -----------------------------------------------------------------------//  Name:     AddDescStyleItem//  Purpose:  Adds the kAEXXXX style to theStyle.// -----------------------------------------------------------------------   void  AddDescStyleItem(DescType theDesc, Style *theStyle){  if (theDesc == kAEBold)    *theStyle = *theStyle+bold;  else  if (theDesc == kAEItalic)    *theStyle = *theStyle+italic;  else  if (theDesc == kAEUnderline)    *theStyle = *theStyle+underline;  else  if (theDesc == kAEOutline)    *theStyle = *theStyle+outline;  else  if (theDesc == kAEShadow)    *theStyle = *theStyle+shadow;  else  if (theDesc == kAECondensed)    *theStyle = *theStyle+condense;  else  if (theDesc == kAEExpanded)    *theStyle = *theStyle+extend;  else  if (theDesc == kAEPlain)    *theStyle = 0;} // AddDescStyleItem  OSErr  MakeStyleFromAEList(const AEDescList *styleList, Style *theStyle, Boolean *hadPlain){  OSErr     myErr;  DescType  styleDesc;  long      itemsInList;  long      actSize;  AEKeyword keywd;  DescType  typeCode;      *hadPlain = false;  *theStyle = 0;    myErr = AECountItems(styleList, &amp;itemsInList);  while (itemsInList&gt;0)    if (myErr==noErr)      {        myErr  = AEGetNthPtr(styleList,                             itemsInList,                             typeEnumerated,                             &amp;keywd,                             &amp;typeCode,                             (Ptr)&amp;styleDesc,                             sizeof(styleDesc),                             &amp;actSize);                AddDescStyleItem(styleDesc, theStyle);                if (styleDesc == kAEPlain)           {            itemsInList = 0;            *hadPlain    = true;          }        else          itemsInList--;      }        return(myErr);} // MakeStyleFromAEList</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/7Edit/listing43.html%3Fid%3DDTS10000200-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/7Edit/listing43.html%3Fid%3DDTS10000200-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/7Edit/listing43.html%3Fid%3DDTS10000200-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>