/*	File:		Direct Pixel Access.c	Contains:	This snippet shows one example of how to directly							change the pixel values stored in a pixel image.							The original pixel image is obtained from a 'icl8'							resource.  Only the first 20 columns of the first						20 rows of the 'icl8' image is used.		Written by: EL		Copyright:	Copyright © 1992-1999 by Apple Computer, Inc., All Rights Reserved.				You may incorporate this Apple sample source code into your program(s) without				restriction. This Apple sample source code has been provided "AS IS" and the				responsibility for its operation is yours. You are not permitted to redistribute				this Apple sample source code as "Apple sample source code" after having made				changes. If you're going to re-distribute the source, we require that you make				it clear in the source that the code was descended from Apple sample source				code, but that you've made changes.	Change History (most recent first):				08/2000		JM				Carbonized, non-Carbon code is commented out											for demonstration purposes.				7/9/1999	KG				Updated for Metrowerks Codewarror Pro 2.1				*/#include "CarbonPrefix.h"#include <Dialogs.h>#include <Fonts.h>#include <Resources.h>#include <QDOffscreen.h>#include <TextUtils.h>#include <Quickdraw.h>/* Constant Declarations */#define	WWIDTH	600#define	WHEIGHT	400//#define WLEFT	(((qd.screenBits.bounds.right - qd.screenBits.bounds.left) - WWIDTH) / 2)//#define WTOP	(((qd.screenBits.bounds.bottom - qd.screenBits.bounds.top) - WHEIGHT) / 2)/* Global Variable Definitions */WindowPtr		gWindow;PixMapHandle	gPixmap;void initMac();void createWindow();void createOffscreen();void drawPixelImageData();void doEventLoop();void main(void){	initMac();		createWindow();	createOffscreen();		doEventLoop();}void initMac(){	//MaxApplZone();	/*InitGraf( &qd.thePort );	InitFonts();	InitWindows();	InitMenus();	TEInit();	InitDialogs( nil );*/	InitCursor();	FlushEvents( 0, everyEvent );}void createWindow(){	Rect		rect;	BitMap		bitMap;	Rect		tempRect1;	int			top, left;		GetQDGlobalsScreenBits(&bitMap);	tempRect1 = bitMap.bounds;		left = (((tempRect1.right - tempRect1.left) - WWIDTH) / 2);	top = (((tempRect1.bottom - tempRect1.top) - WHEIGHT) / 2);	//SetRect( &rect, WLEFT, WTOP, WLEFT + WWIDTH, WTOP + WHEIGHT );	SetRect( &rect, left, top, left + WWIDTH, top + WHEIGHT );	gWindow = NewCWindow( 0L, &rect, "\pDirect Pixel Access", true, documentProc,							(WindowPtr)-1L, true, 0L );							//SetPort( gWindow );	SetPortWindowPort( gWindow );		TextFont( kFontIDGeneva );	TextSize( 9 );	TextMode( srcXor );}void createOffscreen(){	Rect		rect;	Handle		iclHandle;	char		*image;	int			row, col, index, value;			SetRect( &rect, 0, 0, 32, 32 );		/* Create offscreen pixmap image using an 'icl8' icon resource. */	iclHandle = GetResource( 'icl8', 129 );	HLock( iclHandle );	HNoPurge( iclHandle );		//gPixmap = (PixMapHandle)NewHandle( sizeof( PixMap ) );	gPixmap = NewPixMap();		(**gPixmap).baseAddr = *iclHandle;	(**gPixmap).rowBytes = ((32 * 8) / 8) | 0x8000;	(**gPixmap).bounds = rect;	(**gPixmap).pmVersion = 0;	(**gPixmap).packType = 0;	(**gPixmap).packSize = 0;	(**gPixmap).hRes = 72;	(**gPixmap).vRes = 72;	(**gPixmap).pixelSize = 8;	//(**gPixmap).planeBytes = 0;	//(**gPixmap).pmReserved = 0;	(**gPixmap).pixelType = 0;	(**gPixmap).cmpCount = 1;	(**gPixmap).cmpSize = 8;	(**gPixmap).pmTable = GetCTable( 8 );	(**gPixmap).pixelFormat = 0;		/* Give a unique seed for the pixmap's colortable. */	(**(**gPixmap).pmTable).ctSeed = GetCTSeed();		SetRect( &rect, 0, 0, 20, 20 );		/* Set the pointer to the beginning of the pixel image. */	image = GetPixBaseAddr( gPixmap );		/*****************************************************************/	/* For this example, let's set the pixel values of the left half */	/*   of the image to half their original values.				 */	/*****************************************************************/		for (row = 0; row < rect.bottom; row++)	{		// Loop through the first 10 columns of the pixel image. 		for (index = 0, col = 0; col < rect.right / 2; col++)		{			// Set the value at this index to half its value. 			value = (unsigned char)*(image + index);			*(image + index) = value / 2;						index++;		}				// Increment the pointer to the next row of the pixel image. 		image += ((**gPixmap).rowBytes & 0x7fff);	}}void drawPixelImageData(){	int				row, col;	Rect			rect;	unsigned char	value;	char			*image;	int				index = 0;	Str255			string;	RGBColor		color = { 32000, 32000, 32000 };	//Byte			mode;	Rect			tempRect1;		ForeColor( blackColor );		SetRect( &rect, 0, 0, 20, 20 );		/* For this example, let's just use only the upper left corner of the image. */		// Draw the offscreen image to the screen to see what it looks like.	//CopyBits( (BitMap *)*gPixmap, &gWindow->portBits, &rect,	//		&gWindow->portRect, srcCopy, 0 );	//(**gPixmap).rowBytes ^= 0x8000;	CopyBits( (BitMap *)*gPixmap, GetPortBitMapForCopyBits(GetWindowPort(gWindow)), &rect,			GetPortBounds(GetWindowPort(gWindow), &tempRect1), srcCopy, 0 );	//(**gPixmap).rowBytes ^= 0x8000;		RGBForeColor( &color );		// Again, set the pointer to the beginning of the pixel image.	image = GetPixBaseAddr( gPixmap );		/***************************************************************/	/* Finally let's display the pixel values on top of the image. */	/***************************************************************/		/* Loop through the first 20 rows of the pixel image. */	for (row = 0; row < rect.bottom; row++)	{		// Loop through the first 20 columns of the pixel image. 		for (index = 0, col = 0; col < rect.right; col++)		{			// Get the value at this index into the pixel image. 			value = (unsigned char)*(image + index);						MoveTo( col * 30, row * 20 );			LineTo( col * 30, (row + 1) * 20 );			LineTo( (col + 1) * 30, (row + 1) * 20 );						MoveTo( (col * 30) + 6, (row * 20) + 14 );			NumToString( (long)value, string );			DrawString( string );						index++;		}				// Increment the pointer to the next row of the pixel image. 		image += ((**gPixmap).rowBytes & 0x7fff);	}}void doEventLoop(){	EventRecord event;	WindowPtr   window;	short       clickArea;	Rect        screenRect;	RgnHandle	rgnHandle = NewRgn();	for (;;)	{		if (WaitNextEvent( everyEvent, &event, 0, nil ))		{			if (event.what == mouseDown)			{				clickArea = FindWindow( event.where, &window );								if (clickArea == inDrag)				{					//screenRect = (**GetGrayRgn ()).rgnBBox;					GetRegionBounds(GetGrayRgn(), &screenRect);					DragWindow( window, event.where, &screenRect );				}				else if (clickArea == inContent)				{					if (window != FrontWindow())						SelectWindow( window );				}				else if (clickArea == inGoAway)					if (TrackGoAway( window, event.where ))						return;			}			else if (event.what == updateEvt)			{				window = (WindowPtr)event.message;					//SetPort( window );				SetPortWindowPort( window );								BeginUpdate( window );				drawPixelImageData();				EndUpdate( window );				QDFlushPortBuffer(GetWindowPort(window), GetPortVisibleRegion(GetWindowPort(window), rgnHandle));			}			else if (event.what == activateEvt) 			{				/*if (event.modifiers & activeFlag) {					window = (WindowPtr)event.message;					SetPortWindowPort(window);					drawPixelImageData();					QDFlushPortBuffer(GetWindowPort(window), GetPortVisibleRegion(GetWindowPort(window), rgnHandle));				}*/				/*if (event.modifiers & activeFlag)					PostEvent(updateEvt, (unsigned long)gWindow);*/			}		}	}		DisposeRgn(rgnHandle);}