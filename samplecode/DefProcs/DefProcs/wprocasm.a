;EASE$$$ READ ONLY COPY of file “wprocasm.a”; 1.0	CCH 11/16/1988 Added to EASE.; END EASE MODIFICATION HISTORY ;;File wProcAsm.a;--------------------------------------------------------------------------;;  Window Definition Routine for the;		MacIntosh Window Manager;;  written by Andy Hertzfeld  Aug 4, 1982;;  (c) 1982-1986 by Apple Computer, Inc.  All rights reserved.;;	 This file contains the window definition procedure;  "DocumentProc", the standard Mac window type.  It is;  a rectangular window with a title bar.  It is assembled;  part of the window manager.;;  Modification History:;;	 21-Aug-82	AJH  Made DocumentProc support rectangular windows only;	 30-Aug-82	AJH  Added growIcon hit detection, fixed hit to exclude perimeter drag;	 07-Sep-82	AJH  Added handler for grow message;	 12-Sep-82	AJH  Made it so proc doesn't have to calcRgns when not visible;	 20-Sep-82	AJH  Added go-away button drawing and hit-testing;	 25-Sep-82	AJH  Added cheap dialogBox window definition proc;	 28-Sep-82	AJH  New GoAway button; restructured goAway drawing;	 05-Oct-82	AJH  Removed Init message to save code;	 06-Oct-82	AJH  Fixed dialogBox dragRgn bug;	 10-Oct-82	AJH  Converted to QuickDraw trap interface;	 16-Oct-82	AJH  Fixed GoAway hit-test origin bug;	 17-OCt-82	AJH  Made both windowProcs preserve A1;	 07-Nov-82	AJH  Changed DocumentProc hiliting to Lisa way;	 14-Nov-82	AJH  Improved shape of Grow outline ala Lisa;	 16-Nov-82	AJH  Made branch table offset-based to save space;	 16-Nov-82	AJH  Special-cased hiliting of small windows;	 20-Dec-82	AJH  Changed title bar to 20 pixels tall;	 24-Dec-82	AJH  Made wProcAsm a separate assembly;	 17-Mar-83	AJH  Added third variant -- shadowless dBoxProc;	 27-Apr-83	AJH  only plot, hit-test goAway if window is active;	 25-Jul-83	SC	 Fixed third variant -- frame was incorrect, see DrawDBox;	 06-Aug-83	AJH  changed hiliting to use pattern;	 09-Aug-83	AJH  added draw grow icon message receiver;	 20-Aug-83	AJH  made it only hit-test or draws goAway if window is active;	 29-Oct-83	AJH  new dBox border;	 10-Nov-83	AJH  added variant 4 -- just like variant 0, but no inGrow;	 24-Dec-83	AJH  fixed structRgn calc bug in variant 1;	 24-Feb-84	AJH  fixed hit-testing of go-away -- was off by 2;	 09-Jan-85	JTC  modified for MDS assembly: label DocumentProc changed;					 to DocProc to avoid collision.;	 15-Jan-85	EHB  fixed erase of 3 pixels of content rgn in DrawFrame;;					 prevented erase of top line in DoTitleString.;	 15-Jan-85	EHB  eliminated title flicker in CheckHilite; gnrl cleanup;	 30-Jan-85	EHB  fixed boundary testing of GoAwayBox;	 14-Feb-85	JTC  named rsrc.;	 16-May-85	EHB  For GrowBox hitTesting, changed D4=16 to D4=14;v3  16-May-85	EHB  Check left of window title when no grow box too;	 29-Jul-85	EHB  converted back to porkshop;v4   5-Aug-85	EHB  Allow variable size titles;v5  29-Aug-85	EHB  Variant 8 knows how to zoom;	 18-Sep-85	EHB  Added routine ChkPoint to allow slop on large zoom size;	 09-Oct-85	EHB  Added designer zoom icon, restored old close mask;	 18-Oct-85	EHB  New Zoom positioning (avoid lawsuits). Needs title fixes too;					 Add tempRgn to frame to save clip, to calc window's region;	 18-Oct-85	EHB  Only allow zooming on new ROMs (just in case);	 21-Oct-85	EHB  In HitDoc, use BuildTBarRect to hit-test title bar.  The old;					 way didn't work with null content regions.;	 03-Nov-85	EHB  Zoom was one pixel too far left (fix draw and hit);;-Reno World------------------------------------------------------------------;;	 <C59/30Jun86> DAF  Added color support on nuMac. Dropped Krispee stuff;	 <C117/25Sep86> DAF Updated defproc to use RGBForeColor/RGBBackColor;	 <C203/06Oct86> DAF Updated SetUpColor to look up window part color rather;						than assume part from position.  Changed textMode to;						srcOr for titleString.  Made window rgn square;						conditionally.;	 <A285/28Oct86> DAF	Changed SquareWindows conditional to be true on nuMac only.;	 <C407/16Nov86> DAF	Changed textMode to srcCopy, per Cary's recommendation; 	 <C424/18Nov86> DAF	Added portToMap to correct problems in cWindows.;	 <C491/08Dec86> DAF Locked titleString handle before drawing (OLD BUG!);	 <C666/22Jan87> DAF Universal defproc (version 10).  With the exception of ;						Square window flag, this defproc no longer has conditional ;						build sections (all system determination is dynamic);	 <C700/26Jan87> DAF Square windows now supported dynamically;			BLANKS		ON			STRING		ASIS			PRINT		OFF			LOAD		'inc.sum.d'			LOAD		'nEqu.d'			INCLUDE		'colorEqu.a'			PRINT		ON			WDEF0		PROC		EXPORT;;  FUNCTION   DocProc(selector: INTEGER;;					  window: WindowPtr,;					  message: INTEGER;;					  parameter: LongInt): LongIntLinkSize	EQU		-34IsColor		EQU		-34			; do we have colorQD and toolbox?  [boolean]Align		EQU		-33			; a dead byte for IsColor			SavBkCol	EQU		-32			; saved wmgrCPort RGBBackColor 	(color only)SavFgCol	EQU		-26			; saved wmgrCPort RGBForeColor 	(color only)AuxCPtr		EQU		-20			; pointer to auxCTable			(color only)AuxCTab		EQU		-16			; handle to auxCTable			(color only)TempRgn 	EQU 	-12 		; <18Oct85>WInfoRec	EQU 	-8			; <1Aug85>WAscent 	EQU 	-8			; <1Aug85>WDescent	EQU 	-6			; <1Aug85>WHeight 	EQU 	-4			; <1Aug85>WBoxDelta	EQU 	-2			; <1Aug85>message		EQU		12			;								<C666/22Jan87> DAFHasZoom 	EQU 	3			; bit 3 is zoom bit 			<EHB 29Aug85>hasGrow 	EQU 	2			; bit 2 is grow bit 			<EHB 29Aug85>wZoom		EQU 	wGoAway+1	;								<EHB 29Aug85>DocProc			BRA.S	DP1; standard header			DC.W	0					; flags word			DC.B	'WDEF'				; resource type			DC.W	0					; resource ID			DC.W	10					; version numberDP1			LINK	A6,#LinkSize 		; set up a stack frame to address parameters			MOVEM.L D3-D7/A1-A4,-(SP)	; save work registers			; test if the message is in range			CMP.W	#wGIconMsg,message(A6)	; compare to highest value			<C666/22Jan87> DAF			BGT 	OORange					; skip it, it's too high			<C666/22Jan87> DAF			CMP.W	#wDrawMsg,message(A6)	;  compare to lowest value, too		<C666/22Jan87> DAF			BMI 	OORange					;									<C666/22Jan87> DAF						MOVE.L	(A5),A0 			; get pointer to quickDraw globals			<7Aug85>			MOVE.L	(A0),-(SP)			; save current port on stack				<7Aug85>; Determine type of system.  We need to know if we have color QuickDraw and a color;	window manager port.				CMP.W	#$3FFF,ROM85		; do we have color QD? 			SLS		IsColor(A6)			; set boolean depending on color or B&W system			BHI.S	@BWSys				; no, this system has B&W QD; when using the wmgrCPort, it is the defproc's responsibility to reconcile; 	the wmgrPort and the wmgrCPort.  			BSR 	UpdateCPort			; compare and update wmgrPorts, also set WMgrCPort			BRA.S	@CommonSys			; @BWSys						MOVE.L	WMgrPort,-(SP)		; and set port to window manager port			_SetPort					; @CommonSys; get the font info for this font.	Put the height of the title bar in D7 and wHeight(A6).; put the distance of the top of the goaway box from the top of the bar in WBoxDelta(A6).@1			LEA 	WInfoRec(A6),A3 	; point to our info rec 					<5Aug85>			MOVE.L	A3,-(SP)			; push a pointer							<5Aug85>			_GetFontInfo				; and get the font's info                   <5Aug85>			MOVE.W	(A3)+,D7			; (rect inset by 1 when WAscent used)		<5Aug85>			ADD.W	(A3)+,D7			; add descent								<5Aug85>			ADDQ.W	#4,D7				; get the height							<5Aug85>			BSET	#0,D7				; make height odd for symmetry				<5Aug85>			MOVEQ	#19,D1				; get 19									<26Aug85>			CMP.W	D1,D7				; force height to 19 min					<26Aug85>			BGE.S	@3					; => not a tiny font						<5Aug85>			SUB.W	D7,D1				; how much less than 19 is it?				<26Aug85>			LSR.W	#1,D1				; used for centering tiny fonts 			<26Aug85>			ADD.W	D1,WAscent(A6)		; make the ascent "bigger"					<26Aug85>			MOVEQ	#19,D7				;											<5Aug85>@3			MOVE.W	D7,(A3)+			; WHeight = ascent+descent+2				<5Aug85>			MOVE.W	D7,D0				; get height								<EHB 29Aug85>			SUB.W	#13,D0				; subtract height of box					<5Aug85>			LSR.W	#1,D0				; divide by 2								<5Aug85>			MOVE.W	D0,(A3) 			; save delta to goAway box					<5Aug85>; set up a temp region			CLR.L	-(SP)				; make room for result						<EHB 18Oct85>			_NewRgn 					; get a new region							<EHB 18Oct85>			MOVE.L	(SP)+,TempRgn(A6)	; and save in our frame 					<EHB 18Oct85>; save off the current port fore- & backcolors on color systems. 						TST.B	IsColor(A6)			; is it a color system?			BEQ.S	@NoColor1			; nope, so skip this						PEA		SavFgCol(A6)		; push a pointer to save area			_GetForeColor				; get the current color			PEA		SavBkCol(A6)		; 			_GetBackColor				;; also, find the auxWinRec and lock it down						CLR.L	-(SP)				; here's a space for the var handle			CLR.W	-(SP)				; function return here			MOVE.L	14(A6),-(SP)		; push window ptr 			PEA		6(SP)				; a pointer to the space above			_GetAuxWin					; find the auxrec			ADDQ	#2,SP				; pitch the boolean (it doesn't matter)			MOVE.L	(SP)+,A0			; get the auxRecHandle			MOVE.L	(A0),A0				; handle -> ptr			MOVE.L	winCTable(A0),A0	; get the colortable handle			MOVE.L	A0,AuxCTab(A6)		; save this handle			_HLock						; lock the table down in memory			MOVE.L	(A0),AuxCPtr(A6)	; and get a pointer too!@NoColor1								; END OF A COLOR-ONLY SECTION; fetch the parameters into registers			LEA 	8(A6),A0			; get ptr to first parameter			MOVE.L	(A0)+,D3			; get param in D3			MOVE.W	(A0)+,D0			; get message			MOVE.L	(A0)+,A3			; get the window pointer			MOVE.W	(A0)+,D5			; get the selector integer			MOVE	D5,D6				; keep copy in D6			AND 	#3,D5				; ignore "inGrow" variant			CLR.L	(A0)				; clear out function result; case out on the message number			ADD 	D0,D0				; double for word index			LEA 	GoDocProc,A0		; get jump table address			ADD.W	GODOCPROC(D0),A0	; compute dispatch address			JSR 	(A0); we're done -- restore registers and return to caller			MOVE.L	TempRgn(A6),-(SP)	; dispose of temp region			<EHB 18Oct85>			_DisposRgn					;									<EHB 18Oct85>			TST.B	IsColor(A6)			; are we on a color system?						BEQ.S	@NoColor2			; if on B&W, then skip									MOVE.L	AuxCTab(A6),A0		; get the colortable handle	<DAF 15-Apr-86>			_HUnlock					; release it				<DAF 15-Apr-86>			; restore the fore- and backColors									<C203/08Oct86> DAF			PEA		savBkCol(A6)		; pointer to RGBColor			_RGBBackColor				;			PEA		savFgCol(A6)		; pointer to RGBColor			_RGBForeColor				;@NoColor2								; END OF A COLOR-ONLY SECTION			_SetPort					; the old port is on top of stack	<EHB 7Aug85>OORange									; 'Out Of Range, of course'			<C666/22Jan87> DAF			MOVEM.L (SP)+,D3-D7/A1-A4	; restore work registers			UNLK	A6					; unlink stack frame			MOVE.L	(SP)+,A0			; get return address			ADD 	#12,SP				; strip parameters			JMP 	(A0)				; return to caller; DocumentProc dispatch table -- entries must be long branches!GODOCPROC			DC.W	DrawDoc-GoDocProc	; draw is message #0			DC.W	HitDoc-GoDocProc	; hit test is message #1			DC.W	CalcDoc-GoDocProc	; calc test is message #2			DC.W	InitDoc-GoDocProc	; init is message #3			DC.W	DisposeDoc-GoDocProc   ; dispose is message #4			DC.W	GrowDoc-GoDocProc	; grow message is #5			DC.W	DrawGIcon-GoDocProc ; draw grow icon is #6; utility UpdateCPort ;	This utility compares the pertinent fields of the wmgrPort and the wmgrCPort,;	updating the wmgrCPort as necessary to match the wmgrPort.UpdateCPort								; <C666/22Jan87> DAF				MOVE.L	WmgrCPort,-(SP)		; make the wmgrCPort the current port			_SetPort					; set it			MOVE.L	WmgrPort,A0			; get the wmgrPort addr			MOVE.L	WmgrCPort,A1		; and the wmgrCPort too						PEA		bkPat(A0)			; push pointers to pattern for later			PEA		pnPat(A0)			;; copy all fields from pnLoc to end of grafPort, excluding pnPixPat and fillPixPat			LEA		pnLoc(A0),A0					; point at source			LEA		pnLoc(A1),A1					; point at dest			MOVE.L	(A0)+,(A1)+						; copy pnLoc			MOVE.L	(A0)+,(A1)+						; copy pnSize			MOVE.W	(A0)+,(A1)+						; copy pnMode			ADDQ	#8,A0							; skip pnPat (aka, pnPixPat,fillPixPat)			ADDQ	#8,A1							; 			MOVE.W	#((portRec-pnVis)/2)-1,D0		; set up a counter (long sized)@1			MOVE.W	(A0)+,(A1)+						; copy it			DBRA	D0,@1							; loop			; now set up the patterns in the wmgrCPort (which is thePort);	the parameters were pushed before the copying loop above			_PenPat			_BackPat			RTS							; <C666/22Jan87> DAF; InitDoc is used to initialize our zoom sizeInitDoc 	BTST	#hasZoom,D6 		; does it want a zoom box?		<EHB 29Aug85>			BEQ.S	noZoom				; => nope, no zoom				<EHB 29Aug85>			CLR.B	wZoom(A3)			; assume no zoom box			<EHB 29Aug85>			TST.W	ROM85				; running on new roms?			<EHB 18Oct85>			BMI.S	noZoom				; => no, use default			<EHB 18Oct85>			MOVEQ	#16,D0				; space for 2 rects 			<EHB 29Aug85>			_NewHandle ,CLEAR			; allocate the space			<EHB 29Aug85>			BNE.S	noZoom				; => not able to get space		<EHB 29Aug85>; set default zoom data.  Consists of 2 fields:  SmallSize, BigSize: Rect			ADDQ.B	#1,wZoom(A3)		; set zoom flag to TRUE 		<EHB 29Aug85>			MOVE.L	A0,WDataHandle(A3)	; save handle to data			<EHB 29Aug85>			MOVE.L	(A0),A4 			; point to data 				<EHB 29Aug85>			ADDQ.W	#8,A4				; point to bigSize				<EHB 29Aug85>; get the size of the zoomed out window in global coordinates.	To do this,; pull the screen size from screenbits.bounds and indent a little.			MOVE.L	GrafGlobals(A5),A1	; point to QuickDraw globals	<EHB 29Aug85>			MOVE.L	Screenbits+Bounds(A1),(A4)+ 	; get topLeft		<EHB 29Aug85>			MOVE.L	Screenbits+Bounds+4(A1),(A4)+	; get botRight		<EHB 29Aug85>			MOVEQ	#3,D0							; get indent		<EHB 29Aug85>			SUB.W	D0,-(A4)			; indent right					<EHB 29Aug85>			SUB.W	D0,-(A4)			; indent bottom 				<EHB 29Aug85>			ADD.W	D0,-(A4)			; indent left					<EHB 29Aug85>			ADD.W	D0,-(A4)			; indent top					<EHB 29Aug85>			ADD.W	D7,(A4) 			; past menu bar 				<EHB 29Aug85>			ADD.W	D7,(A4) 			; and past window title 		<EHB 29Aug85>			MOVE.L	(A0),A4 			; A4 = smallsize				<EHB 29Aug85>; get current size into rect in A4GetRect 	MOVE.L	A4,-(SP)			; push address of rect			<EHB 29Aug85>			MOVE.L	PortRect(A3),(A4)	; get topLeft (local)			<EHB 29Aug85>			MOVE.L	PortRect+4(A3),4(A4)	; get botRight (local)		<EHB 29Aug85>			MOVE.L	A3,A0				; copy portPtr for PortToMap	<C424/18Nov86> DAF			BSR		PortToMap			; get the rect pointer			<C424/18Nov86> DAF			MOVE.L	Bounds(A0),-(SP)	; push offset locToGlob 	<EHB 29Aug85>			NEG.W	(SP)					; make offset positive		<EHB 29Aug85>			NEG.W	2(SP)			_OffsetRect 				; convert rect to globalNoZoom		RTS; IsItSmall returns NE if the window has been resized or moved (NE if window "small"); It updates smallsize if it has.  (If tab, only move small window).;			Trashes A0,A1,A4IsItSmall	SUBQ	#8,SP				; make room for a rect			<EHB 29Aug85>			MOVE.L	SP,A4				; point to it					<EHB 29Aug85>			BSR.S	GetRect 			; A4 = curSize					<EHB 29Aug85>			MOVE.L	wDataHandle(A3),A0	; get data handle				<EHB 29Aug85>			MOVE.L	(A0),A2 			; A2 = bigSize					<EHB 29Aug85>			ADDQ	#8,A2; the window is large if all corners are within 7 of their default positions			BSR.S	ChkPoint			; compare topleft				<EHB 18Sep85>			BNE.S	IsSmall 			; => not close enough			<EHB 29Aug85>			BSR.S	ChkPoint			; compare botright				<EHB 18Sep85>			BEQ.S	NotSmall			; => it's close enough          <EHB 29Aug85>IsSmall 	MOVE.L	wDataHandle(A3),A0	; get data handle				<EHB 29Aug85>			MOVE.L	(A0),A4 			; save window's current size    <EHB 29Aug85>			BSR.S	GetRect 			; get current size into A4		<EHB 29Aug85>SaySmall	MOVEQ	#1,D0				; return NE!					<EHB 29Aug85>NotSmall	ADDQ	#8,SP				; strip rect from stack 		<EHB 29Aug85>			RTSChkPoint	MOVE.L	(A2),-(SP)			; make point into a rect		<EHB 18Sep85>			MOVE.L	(A2)+,-(SP) 		; by pushing twice				<EHB 18Sep85>			MOVE.L	SP,-(SP)			; and insetting by 7			<EHB 18Sep85>			MOVE.L	#$FFF9FFF9,-(SP)	;								<EHB 18Sep85>			_InsetRect					;								<EHB 18Sep85>			CLR.W	-(SP)				; is cursize within 7 of		<EHB 18Sep85>			MOVE.L	(A4)+,-(SP) 		; that point?					<EHB 18Sep85>			PEA 	6(SP)				;								<EHB 18Sep85>			_PtInRect					;								<EHB 18Sep85>			SUBQ.B	#1,(SP) 			; reverse sign of result		<EHB 18Sep85>			MOVE.B	(SP)+,D0			;								<EHB 18Sep85>			ADDQ	#8,SP				; strip off the rect			<EHB 18Sep85>			RTS 						; exit w/EQ if "Big"			<EHB 18Sep85>; IsThereZoom returns EQ if zoom not enabledIsThereZoom BTST	#hasZoom,D6 		; zooming variant				<EHB 29Aug85>			BEQ.S 	IsNoZoom			; => no 						<EHB 29Aug85>			TST.B	wZoom(A3)			; did we get the handle?		<EHB 29Aug85>IsNoZoom	RTS 						; EQ if no Zoom 				<EHB 29Aug85>; DisposeDoc is called when the window is being closed.  All we need to do is; give back the handle we borrowed.DisposeDoc	BSR.S	IsThereZoom 		; is there a zoom box?			<EHB 29Aug85>			BEQ.S	InDisposed			; => no, we're done             <EHB 29Aug85>			MOVE.L	wDataHandle(A3),A0	; get handle to our data		<EHB 29Aug85>			_DisposHandle				; release it, ignoring errors	<EHB 29Aug85>InDisposed	RTS; SetUpColor takes a window part identifier in D0, finds the corresponding;	part in the AuxWinTable (the part code is in the .value field) and returns;	a pointer to its RGB on the stack.  If the requested part is not found,;	the first color table element is used (I'd use frameColor, but that might;	not be there!).  Trashes A0/D0.		; rewritten <C177/25Sep86> DAFSetUpColor			MOVE.L	D1,-(SP)			; save a register			MOVE.L	AuxCPtr(A6),A0		; get the color table pointer			MOVE.W	CTSize(A0),D1		; get the color table size			MULU	#8,D1				; convert to color table indexLegalIndex				CMP.W	CTTable+value(A0,D1),D0	; is this the one?			BEQ.S	FoundIt				; if equal, then done			SUB.W	#8,D1				; try the previous one			BGE.S	LegalIndex			; loop while index positive			MOVEQ	#0,D1				; OK, use the first oneFoundIt					LEA		CTTable+rgb(A0,D1),A0 ; get the address of the color to use			MOVE.L	A0,D0				; we'll need A0 in a second			MOVE.L	(SP)+,D1			; restore the register			MOVE.L	(SP)+,A0			; get the return address			MOVE.L	D0,-(SP)			; push the rgb addr on the stack			JMP		(A0)				; return to caller			PORTTOMAP										; <C424/18Nov86> DAF;----------------------------------------------------------;; Given a window pointer in A0, return the bitmap/pixmap pointer in A0			ADDQ	#PORTBITS,A0				;POINT TO BITMAP/PIXMAP HANDLE			TST		ROWBYTES(A0)				;BITMAP OR PIXMAP HANDLE?			BPL.S	GOTBITMAP					;=>JUST A BITMAP			MOVE.L	BASEADDR(A0),A0				;ELSE GET PORT'S PIXMAP HANDLE			MOVE.L	(A0),A0						;GET PIXMAP POINTERGOTBITMAP	RTS									;  DrawDoc -- draw the document window.   The windowPtr is in A3DrawDoc			TST.B	WVISIBLE(A3)		; is it visible?			BEQ 	DoneDoc 			; if not, don't do anything; see if its a EORGoAway call and special case it			CMP 	#wInGoAway,D3		; is it a goAway call?			BGE 	EorStuff			; if so, go handle it				<EHB 29Aug85>			_PenNormal					; we want the normal pen			TST.W	D5					; test dialogBox flag			BNE 	DrawDBox			; dBox window has no title bar; derive the titleBar rectangle from the structRgn and keep it in TempRect			BSR 	BuildTBarRect; draw the title bar			TST.B	IsColor(A6)			; is it color?						BEQ.S	@NoColor3			; no, so skip this						MOVE.W	#wFrameColor,D0		; color to set					<C203/08Oct86> DAF			BSR.S	SetUpColor			; set it up						<C203/08Oct86> DAF			_RGBForeColor				; 								<C203/08Oct86> DAF						MOVE.W	#wTitleBarColor,D0 	;  								<C203/08Oct86> DAF			BSR.S	SetUpColor			; 								<C203/08Oct86> DAF			_RGBBackColor				; 								<C203/08Oct86> DAF			@NoColor3								; END OF A COLOR-ONLY SECTION			PEA 	TEMPRECT			; tempRect bounds the title bar			MOVE.L	(SP),-(SP)			; make another copy of tempRect pointer			MOVE.L	(SP),-(SP)			; and yet another			_FrameRect					; frame the title bar			MOVE.L	OneOne,-(SP)		; push inset factor			_InsetRect			_EraseRect					; clear the inside			BSR 	DoTitleString		;; and draw the centered Title; To prevent title flicker, DoTitleString returns the left edge of the; title in D3 and the right edge in D4.  If the title bar needs to be; highlighted, the highlighting is done in 2 sections, one on each side; of the title.CheckHilite			TST.B	WHILITED(A3)		; is it hilited?			BEQ 	DrawBody			; => go draw the frameDoHilite				TST.B	IsColor(A6)			; is it color?						BEQ.S	@NoColor4			; no, so skip this						MOVE.W	#wTitleBarColor,D0	; set up colors						<C203/08Oct86> DAF			BSR 	SetUpColor			;			_RGBBackColor				;						MOVE.W	#wHiliteColor,D0	;			BSR 	SetUpColor			;			_RGBForeColor				;									<C203/08Oct86> DAF@NoColor4								; END OF A COLOR-ONLY SECTION			PEA 	TEMPRECT			; push the title rect			MOVE.W	#1,-(SP)			; push dh							<5Aug85>			MOVE.W	WBoxDelta(A6),-(SP) ; push dv							<5Aug85>			_InsetRect					; inset it some			MOVE.W	TempRect+Right,-(SP)	; save right of TempRect			MOVE.W	D3,TempRect+Right		; new right = title left; used A4 instead of A0 to save a couple o'bytes (EHB)			MOVE.L	TempRect,D0 		; get topLeft			AND.L	#$00070007,D0		; only use mod 8			MOVE.L	(A5),A4 			; get globals, save in A4			MOVE.L	D0,PatAlign(A4) 	; set up patAlign			PEA 	TempRect			; fill this rect			PEA 	HilitePattern		; push the pattern address			_FillRect					; fill left half with the pattern			BSR  	IsThereZoom 		; is zooming allowed? (was .S)				<EHB 18-Oct-85>			BEQ.S	@1					; => no, use current d4 			<EHB 18-Oct-85>			MOVE.W	(SP),D0 			; else get right edge of box		<EHB 18-Oct-85>			SUB.W	#26,D0				; how much room is there?			<EHB 18-Oct-85>			CMP.W	D4,D0				; need at least 26 pixels			<EHB 18-Oct-85>			BGE.S	@1					; => got 'em, use current d4        <EHB 18-Oct-85>			MOVE.W	D0,D4				; else use right-26 				<EHB 18-Oct-85>@1			MOVE.W	(SP)+,TempRect+Right	; restore right of title box			MOVE.W	D4,TempRect+Left	; set new left of title box			PEA 	TempRect			; fill this rect			PEA 	HilitePattern		; push the pattern address			_FillRect			CLR.L	PatAlign(A4); plot the goAway buttonDoGoAway			TST.B	WGoAway(A3) 		; is there a goaway button?			BEQ.S	DoZoom				; => if not, try for zoom		<EHB 29Aug85>			BSR 	BuildTBarRect			LEA 	GoAwayData,A1		; get the goAway symbol			MOVEQ	#srcCopy,D0 		; plot in srcCopy mode			<EHB 29Aug85>			BSR 	PlotGoAwayDoZoom		BSR 	IsThereZoom 		; is there a zoom box?			<EHB 29Aug85>			BEQ.S	DrawBody			; => no, draw window frame		<EHB 29Aug85>			BSR 	BuildTBarRect		; build a title bar rect		<EHB 29Aug85>			LEA 	ZoomData,A1 		; get the zoom data 			<EHB 29Aug85>			MOVEQ	#srcCopy,D0 		; plot in srcCopy mode			<EHB 29Aug85>			BSR 	PlotZoom			; and plot the symbol			<EHB 29Aug85>DrawBody	MOVE.L	OneOne,D4			; constant for shadowing; frame the body of the windowDrawFrame			TST.B	IsColor(A6)			; is it color?			BEQ.S	@NoColor5			; no, so skip this section						MOVE.L	#wFrameColor,D0		; set up colors <C203/08Oct86> DAF			BSR		SetUpColor			; 				<C203/08Oct86> DAF			_RGBForeColor				; 				<C203/08Oct86> DAF			MOVE.L	#wContentColor,D0	; set up background too for variant 1 	<CXXX/21Jan87> DAF			BSR		SetUpColor			; 										<CXXX/21Jan87> DAF			_RGBBackColor				; 										<CXXX/21Jan87> DAF@NoColor5								; END OF A COLOR-ONLY SECTION			MOVE.L	STRUCTRGN(A3),A0	; get region handle			MOVE.L	(A0),A0 			; get region ptr			LEA 	RGNBBOX(A0),A4		; point A4 at the bounding box			SUB 	D4,Bottom(A4)		; inset the bottom (ignore shadow)			SUB 	D4,Right(A4)		; inset the right to ignore shadow			MOVE.L	A4,-(SP)			; push bounding box			_FrameRect					; frame the body; draw the drop shadow (for variant 0 and 3)			CMP 	#3,D5				; variant 3?			BEQ.S	@3					; if so, paint it			TST.W	D5					; variant 0?			BNE.S	@1					; if not, skip@3			BSR 	PaintDropShadow 	; paint the drop shadow; draw fancy for dialog box ( only for variant 1)@1			CMP 	#1,D5				; dialog box?			BNE.S	@2					; if not, skip			MOVE.L	(A4),TempRect		; copy bounds into tempRect			MOVE.L	4(A4),TempRect+4			PEA 	TempRect			MOVE.L	(SP),-(SP)			; copy it			MOVE.L	(SP),-(SP)			MOVE.L	OneOne,-(SP)			_InsetRect					; inset it			MOVE.L	#$00070007,-(SP)	; erase to edge of content rgn			_PenSize			MOVE.L	(A5),A0			PEA 	White(A0)			_PenPat			_FrameRect			MOVE.L	(A5),A0			PEA 	Black(A0)			_PenPat			MOVE.L	#$00020002,-(SP)	; push inset factor			MOVE.L	(SP),-(SP)			;; push new pen size			_PenSize					; set new pen size			_InsetRect			PEA 	TempRect			_FrameRect					; and frame it			_PenNormal@2						MOVE.L	STRUCTRGN(A3),A4	; get region handle again, for safety	<S369/25Jan88> DAF			MOVE.L	(A4),A4 			; get region ptr						<S369/25Jan88> DAF			LEA 	RGNBBOX(A4),A4		; point A4 at the bounding box			<S369/25Jan88> DAF						ADD 	D4,Bottom(A4)			ADD 	D4,Right(A4)DoneDoc			RTSHilitePattern			DC.W	$FF00,$FF00,$FF00,$FF00; BuildTBarRect builds a rectangle enclosing the titleBar in TempRectBuildTBarRect			LEA 	TEMPRECT,A0 		; get pointer to tempRect			MOVE.L	STRUCTRGN(A3),A1	; get structure region handle			MOVE.L	(A1),A1 			; get strucRgn pointer			ADDQ	#RGNBBOX,A1 		; point A1 at the bounding box			MOVE.L	(A1)+,(A0)			; copy bounding box into tempRect			MOVE.L	(A1),4(A0);  make bottom := top + WHeight			MOVE	Top(A0),D0			; get top			ADD.W	D7,D0				; add precomputed height				<29Aug85>			MOVE	D0,Bottom(A0)		; update bottom			SUBQ	#1,Right(A0)		; inset right			RTS 						; return to caller; decide which icon needs hilitingEORStuff	BEQ.S	EORGoAway			; => it's the goAway                <EHB 29Aug85>			BSR 	IsThereZoom 		; should we do zoom?				<EHB 29Aug85>			BEQ.S	NoGo				; => no 							<EHB 29Aug85>; EORZoom hilites/unhilites the zoom button.  Falls into PlotZoomEORZoom 	BSR.S	BuildTBarRect		; build the bounding rect			<EHB 29Aug85>			LEA 	ZoomData+32,A1		; get the zoom data 			<EHB 29Aug85>			MOVEQ	#srcXOR,D0			; set EOR as the plot mode			<EHB 29Aug85>PlotZoom	LEA 	TempRect,A0 		; start from titlebar rect			<EHB 29Aug85>			MOVE	right(A0),left(A0)	; left := right-22					<EHB 03Nov85>			MOVEQ	#-22,D1 			;									<EHB 03Nov85>			BRA.S	PlotIt				; use common code to plot it		<EHB 29Aug85>; EORGoAway hilites/unhilites the goAway button.  It falls through into PlotGoAwayEorGoAway			BSR.S	BuildTBarRect		; build the bounding rect			LEA 	GoAwayData+32,A1	; get the bitMap			MOVEQ	#srcXOR,D0			; set EOR as the plot mode; PlotGoAway plots the goAway button.  A1 holds the symbol, D1 the plotting modePlotGoAway; make Temprect into a 16x16 square for our little bitmap			LEA 	TempRect,A0 		; point to temprect 					<5Aug85>			MOVEQ	#7,D1				; add margin to left					<5Aug85>PlotIt		ADD.W	D1,left(A0) 		; add offset to left				   <29Aug85>			MOVE.W	WBoxDelta(A6),D1	; get offset from top to GABox			<5Aug85>			ADD.W	D1,(A0) 			; add offset to top 					<5Aug85>			SUBQ.W	#1,(A0) 			; align bitmap							<5Aug85>			MOVE.L	(A0)+,(A0)			; bottom/right = top/left				<5Aug85>			MOVEQ	#16,D1				; get a constant						<5Aug85>			ADD.W	D1,(A0)+			; Bottom = top + 16 					<5Aug85>			ADD.W	D1,(A0) 			; Right = Left + 16 					<5Aug85>			MOVE.L	#$00100010,D1			BSR 	PlotSymbol			; plot it in tempRectNoGo		RTS; DialogBoxes have no title bar and extra shadowDrawDBox			MOVE.L	#$00020002,D4		; get shadow factor			CMP.W	#3,D5				; does it have shadow?			BEQ  	DrawFrame			; if so, we're cool (was .S)			MOVEQ	#0,D4				; otherwise no shadow			BRA 	DrawFrame			; go draw it (was .S); DoTitleString is the common code that draws the title centered in tempRect.  Warning --; it trashes D3.  On exit, the left edge of the title's box is in D3 and; the right edge is in D4.DoTitleString; compute indent factor based on GoAwayButton state@1			MOVE.W	TempRect+Right,D4	; get right into D4 		<EHB 18-Oct-85>			MOVE.W	D4,D3				;							<EHB 18-Oct-85>			SUB.W	TempRect+Left,D3	; compute width			SUB.W	WTITLEWIDTH(A3),D3	; compute extra x			ASR.W	#1,D3				; divide by 2; if the string is too long, position left edge			MOVEQ	#2,D0				; start title at x = 2		<16-May-85 EHB>			TST.B	WGoAway(A3) 		; is there a go away button <16-May-85 EHB>			BEQ.S	@2					; skip if there's not       <16-May-85 EHB>			MOVEQ	#32,D0				; start title at x = 32 	<16-May-85 EHB>@2			CMP.W	D0,D3				; to left of x? 			<16-May-85 EHB>			BGE.S	@3					; => no, D3 is ok			<16-May-85 EHB>			MOVE.W	D0,D3@3			ADD.W	TempRect+Left,D3	; compute x position			MOVE.W	D4,-(SP)			; save right across clip	<EHB 18-Oct-85>			BSR 	IsThereZoom 		; is there a zoom box?		<EHB 18-Oct-85>			BEQ.S	@4					; => no, edge ok			<EHB 18-Oct-85>			SUB.W	#32,D4				; get default right edge	<EHB 18-Oct-85>@4; set clip to d3..d4			MOVE.L	 TempRgn(A6),-(SP)	; get our temp region		<EHB 18-Oct-85>			MOVE.L	 (SP),-(SP) 		; copy for SectRgn			<EHB 18-Oct-85>			_GetClip					; and save for restore		<EHB 18-Oct-85>			MOVE.W	D4,TempRect+Right	; set right for clipping	<EHB 18-Oct-85>			PEA 	TempRect			; point to tempRect 		<EHB 18-Oct-85>			_ClipRect					; set clipping to it		<EHB 18-Oct-85>			MOVE.L	(A5),A0 			; get globals				<EHB 18-Oct-85>			MOVE.L	(A0),A0 			; get port					<EHB 18-Oct-85>			MOVE.L	ClipRgn(A0),-(SP)	; and the rect region		<EHB 18-Oct-85>			MOVE.L	(SP),-(SP)			; and use clip as dest		<EHB 18-Oct-85>			_SectRgn					; get the intersection		<EHB 18-Oct-85>			MOVE.W	(SP)+,TempRect+Right	; restore tempRect		<EHB 18-Oct-85>			MOVE.W	D3,-(SP)			; push left for MoveTo			MOVE.W	TempRect+Top,D0 	; get top						<EHB 5Aug85>			ADD.W	WAscent(A6),D0		; move down to baseline 		<EHB 5Aug85>			ADDQ.W	#1,D0				; leave 2 pixels white space	<EHB 7Aug85>			MOVE.W	D0,-(SP)			; push baseline 				<EHB 5Aug85>			_MoveTo			TST.B	IsColor(A6)			; is it on a color system?				BEQ.S	@NoColor6			MOVE.W	#wTitleBarColor,D0	; set up drawing colors			BSR		SetUpColor			;			_RGBBackColor			MOVE.W	#wTextColor,D0		;					BSR		SetUpColor			; 			_RGBForeColor				;						MOVE.W	#srcOR,-(SP)		; set the mode to source OR		<C407/16Nov86> DAF			_TextMode					;								<C407/16Nov86> DAF			@NoColor6								; END OF A COLOR ONLY SECTION						MOVE.L	WTITLEHANDLE(A3),A0 ; get titleHandle			_HLock						; lock the title down			<C491/08Dec86> DAF			MOVE.L	(A0),-(SP)			; push title pointer			_DrawString 				; draw it			MOVE.L	WTitleHandle(A3),A0	; get the handle again			<C491/08Dec86> DAF			_HUnlock					; release it					<C491/08Dec86> DAF						MOVE.L	TempRgn(A6),-(SP)	; push the old clip 			<EHB 18-Oct-85>			_SetClip					; and restore it				<EHB 18-Oct-85>; now calculate the size of the clear area needed for the title; (only used if the window is highlighted).			MOVE.W	D3,D0				; left in D3, calc right in D0			SUBQ	#6,D3				; indent to the left			ADD.W	WTitleWidth(A3),D0	; add in the length 			<EHB 18-Oct-85>			CMP.W	D4,D0				; was title longer than space?	<EHB 18-Oct-85>			BGE.S	@5					; => yes, use D4				<EHB 18-Oct-85>			MOVE.W	D0,D4				;								<EHB 18-Oct-85>@5			ADD.W	#6,D4				; indent on right				<EHB 18-Oct-85>			RTS 						; Left in D3, right in D4; old arrow zoom data;ZoomData	 .WORD	 $0000,$0000,$0078,$0038;			 .WORD	 $0078,$00E8,$01C0,$0380;			 .WORD	 $0700,$2E00,$3C00,$3800;			 .WORD	 $3C00,$0000,$0000,$0000; mask;			 .WORD	 $0000,$0000,$0078,$0038;			 .WORD	 $0198,$0008,$0020,$0820;			 .WORD	 $0800,$2000,$3300,$3800;			 .WORD	 $3C00,$0000,$0000,$0000; Snazzy new zoom dataZoomData	DC.W	$0000,$0000,$BFFB,$2088			DC.W	$A08B,$2088,$A08B,$2088			DC.W	$BF8B,$2008,$A00B,$2008			DC.W	$BFFB,$0000,$0000,$0000; mask			DC.W	$0000,$0000,$0000,$0180			DC.W	$09A0,$05C0,$0080,$1CF0			DC.W	$1F80,$0540,$0920,$0100			DC.W	$0000,$0000,$0000,$0000; BitMap for default GoAway buttonGoAwayData; This is the real goAway Data			DC.W	$0000,$0000,$BFFB,$2008			DC.W	$A00B,$2008,$A00B,$2008			DC.W	$A00B,$2008,$A00B,$2008			DC.W	$BFFB,$0000,$0000,$0000; starburst mask		   DC.W    $0000,$0000,$0000,$0100		   DC.W    $0920,$0540,$0000,$1C70		   DC.W    $0000,$0540,$0920,$0100		   DC.W    $0000,$0000,$0000,$0000;  Mask for goAway button (concentric squares);			 .WORD	 $0000,$0000,$0000,$0000;			 .WORD	 $0FE0,$0820,$0BA0,$0AA0;			 .WORD	 $0BA0,$0820,$0FE0,$0000;			 .WORD	 $0000,$0000,$0000,$0000; HitDoc -- perform a hit test on the document.  On entry, D3 contains the mousePoint; in global coordinates while A3 holds the window pointerHitDoc			CLR.W	-(SP)				; make room for function result			MOVE.L	D3,-(SP)			; push the mouse point			MOVE.L	CONTRGN(A3),-(SP)	; push content region handle			_PtInRgn					; is the point in the content region?			TST.B	(SP)+				; well, is it?			BEQ.S	NotInContent		; if not, go check out drag region; it's in the content region -- see if its in the grow icon area			TST.W	D5					; is it a dialogBox?			BNE.S	justContent 		; if so, its only in the content			BTST	#hasGrow,D6 			  ; inGrow enabled? 				  <EHB 29Aug85>			BGT.S	justContent 		; if not, skip			TST.B	WHilited(A3)		; is it active?			BEQ.S	justContent 		; if not, it cant be in grow			MOVE.L	ContRgn(A3),A0		; get region handle			MOVE.L	(A0),A0 			; get region ptr			MOVE.L	RgnBBox+botRight(A0),D0 ; get bottom left of content; first consider the x coordinate <16-May-85 EHB>			MOVEQ	#14,D4				; keep 14 in a register to save code			SUB 	D4,D0				; offset x by 14			CMP 	D0,D3				; if <, just in content			BLT.S	justContent; its within range on x so try y			SWAP	D0			SUB 	D4,D0				; check out y dimension			SWAP	D3			CMP 	D0,D3				; compare y coordinates			BLT.S	justContent			MOVEQ	#wInGrow,D0 		; flag in grow Icon			BRA 	DoneHitDoc; the point is in the content region so return a '1'justContent			MOVEQ	#wInContent,D0		; return in content			BRA  	DoneHitDoc			; go store function result and return; its not in the content -- see if its in the dragRgn (content extended by titleBar)NotInContent			TST 	D5					; is it a dialogBox?			BNE   	DoneHit1			; dBoxes have no drag region			BSR 	BuildTBarRect		; get the title bar rect into A0	<EHB 21-Oct-85>			CLR.W	-(SP)				; make room for function result			MOVE.L	D3,-(SP)			; push the mouse point			MOVE.L	A0,-(SP)			; and push the rect 				<EHB 21-Oct-85>			_PtInRect					; is the point in the title bar?			TST.B	(SP)+				; examine result			BEQ.S	DoneHit1			; if not, return 0 (do nothing)			TST.B	WHilited(A3)		; is it hilited?			BEQ.S	ItsInDrag			; if not, can't be in GoAway; test vertical for goAway and Zoom since they're the same			MOVE.L	D3,D0				; check vertical				<EHB 29Aug85>			SWAP	D0					; which is high word of D3		<EHB 29Aug85>			MOVE.L	A3,A0				; convert the pointer if its a pixmap <C424/18Nov86> DAF			BSR		PortToMap			; convert						<C424/18Nov86> DAF			ADD.W	Bounds+Top(A0),D0	; convert to local			<EHB 29Aug85>			SUB.W	PortRect+Top(A3),D0 	; compensate for origin 	<EHB 29Aug85>			ADD.W	WBoxDelta(A6),D0		; below box?				<5Aug85>			BPL.S	ItsInDrag				; => yes					<5Aug85>			ADD.W	#11,D0					; in box?					<5Aug85>			BMI.S	ItsInDrag				; => no 					<5Aug85>			TST.B	WGoAway(A3) 		; is there a goAway button?			BEQ.S	HitZoom 			; => no, hit-test zoom			<EHB 29Aug85>			MOVE.L	D3,D0				; get mousePt			ADD 	Bounds+Left(A0),D0	; convert to local (A0 still valid) <C424/18Nov86> DAF			SUB 	PortRect+Left(A3),D0	; compensate for origin			CMP 	#18,D0				; is it too far right?			BGT.S	HitZoom 			; if so, its in drag			<EHB 29Aug85>			SUBQ.W	#8,D0				; it must be at least 7			BMI.S	ItsInDrag; its in the goAway button so signal it			MOVEQ	#wInGoAway,D0			BRA.S	DoneHitDocHitZoom 	BSR 	IsThereZoom 		; is zooming permitted? 		<EHB 29Aug85>			BEQ.S	ItsInDrag			; => not in these here parts	<EHB 29Aug85>			MOVE.W	D3,D0					; get mousePt				<EHB 29Aug85>			MOVE.L	A3,A0					; convert the pointer if its a pixmap <C424/18Nov86> DAF			BSR		PortToMap				; convert					<C424/18Nov86> DAF			ADD.W	Bounds+Left(A0),D0	; convert to local			<EHB 29Aug85>			SUB.W	PortRect+Right(A3),D0	; make right edge = 0		<EHB 29Aug85>			CMP.W	#-19,D0 				; too far left? 			<EHB 03Nov85>			BLT.S	ItsInDrag				; => if so, it's in drag    <EHB 29Aug85>			CMP.W	#-9,D0					; too far right?			<EHB 03Nov85>			BGT.S	ItsInDrag				; => if so, it's in drag    <EHB 18Oct85>			BSR 	IsItSmall				; is window big?			<EHB 29Aug85>			BEQ.S	@1						; => oh boy, right again	<EHB 29Aug85>			MOVEQ	#wInZoomOut,D0			; say window small			<EHB 29Aug85>			BRA.S	DoneHitDoc				; und scram-muller			<EHB 29Aug85>@1			MOVEQ	#wInZoomIn,D0			; say window big			<EHB 29Aug85>			BRA.S	DoneHitDoc				; and muller out of here	<EHB 29Aug85>ItsInDrag	MOVEQ	#wInDrag,D0 		; flag in drag regionDoneHitDoc	MOVE.L	D0,20(A6)			; update function resultDoneHit1	RTS; CalcDoc  -- calculate the structure and content regions for the window pointed; to by A3.  First update size for zooming if necessaryCalcDoc 	BSR 	IsThereZoom 		; zoom feature enabled? 		<EHB 29Aug85>			BEQ.S	@1					; => no 						<EHB 29Aug85>			BSR 	IsItSmall			; update window size			<EHB 29Aug85>@1			LEA 	TEMPRECT,A0 		; get a pointer to the work rectangle			MOVE.L	A0,-(SP)			; push for later offset			MOVE.L	PORTRECT(A3),(A0)+	; copy topLeft of portRect			MOVE.L	PORTRECT+4(A3),(A0) ; copy botLeft of portRect; offset it to global coordinates			MOVE.L	A3,A0				; convert the pointer if its a pixmap <C424/18Nov86> DAF			BSR		PortToMap			; convert						<C424/18Nov86> DAF			MOVE.L	BOUNDS(A0),-(SP)	; push topLeft of port.portBits.bounds <C424/18Nov86> DAF			NEG 	0(SP)				; negate offset			NEG 	2(SP)				; both words			_OffsetRect 				; offset tempRect to global coordinates;  make the rectangular content region			MOVE.L	CONTRGN(A3),-(SP)	; content region gets the result			PEA 	TempRect			; tempRect is the rectangle			_RectRgn					; go make the region into content region; now do the structure region.	First correct the bounding rectangle (tempRect) for; structure instead of content			MOVE.L	#$00020002,D4		; get the shadow factor for DBox			MOVE.L	STRUCTRGN(A3),-(SP) ; push the structRgn for later			PEA 	TEMPRECT			; push a pointer to the rect			MOVE.L	(SP),-(SP)			; make two copies			MOVE.L	MinusOne,-(SP)		; make 1 pixel bigger, all around			_InsetRect					; make it bigger			TST.W	D5					; is it dBox?			BNE.S	DoDBoxCalc			; skip if it is			MOVE.W	D7,D0				; move up to top of window				<29Aug85>			SUBQ.W	#1,D0				; tweak it								<5Aug85>			SUB.W	D0,TempRect+Top 	; and set top of struct region			<5Aug85>			LSR.L	#1,D4				; adjust shadow factorCalcCommon			_RectRgn					; RectRgn(structRgn,tempRect); now add in the 1 or 2 pixel drop shadow (if necessary)			TST 	D5			BEQ.S	@1					; if so, it has shadow			CMP 	#3,D5				; is it variant 3?			BNE.S	NoDropShadow		; if not, no shadow@1			TST.B	IsColor(A6)			; are we on a multi-bit Mac?			BEQ.S	NormShadow			; if not, then do normal shadows			TST.W	D5					; if it's a dialog box, do a normal shadow also			BNE.S	NormShadow			;						ADD.L	D4,TempRect+botright ; increase rect by shadow size			MOVE.L	StructRgn(A3),-(SP)	; push the regionHandle			PEA		TempRect			; and the rect			_RectRgn					; and set it			BRA.S	CommShadow			; and continueNormShadow			MOVE.L	TempRgn(A6),-(SP)	; get temp region					<EHB 18Oct85>			PEA 	TempRect			; push tempRect			MOVE.L	(SP),-(SP)			; save another copy			MOVE.L	D4,-(SP)			; push shadow factor			_OffsetRect 				; offset it			_RectRgn			MOVE.L	StructRgn(A3),-(SP)			MOVE.L	TempRgn(A6),-(SP)	; get temp region					<EHB 18Oct85>			MOVE.L	StructRgn(A3),-(SP) ; structure gets the result			_UnionRgn					; add it inCommShadow; all done with CalcDocRgnsNoDropShadow			RTSDoDBoxCalc			CMP 	#1,D5				; is it variant 1?			BNE.S	CalcCommon			PEA 	TempRect			; push our rectangle			MOVE.L	#$FFF9FFF9,-(SP)	; push (-7,-7)			_InsetRect					; inset it			BRA.S	CalcCommon			; use common code for the rest; GrowDoc handles the grow message by drawing a grow outline based on the rectangle; passed in D3GrowDoc; first make it one pixel bigger to jibe with the structure			MOVE.L	D3,-(SP)			; push the rect			MOVE.L	MinusOne,-(SP)		; push (-1,-1)			_InsetRect			MOVE.L	D3,A3				; get rect ptr			MOVE.L	Top(A3),-(SP)		; save topleft for below			<5Aug85>			MOVE.W	D7,D0				; adjust for title					<29Aug85>			SUB.W	#1,D0				; and tweak it						<5Aug85>			SUB.W	D0,Top(A3)			; and save it						<5Aug85>			MOVE.L	D3,-(SP)			; push the rectangle			_FrameRect					; frame it;  now that the rectangle is drawn, draw the lower horizontal line			MOVE.W	Left(A3),-(SP)		; push left			MOVE.W	Bottom(A3),-(SP)	; push bottom			SUB 	#16,(SP)			; really 16 pixels above bottom			MOVE.L	(SP),-(SP)			; make a copy of this point			_MoveTo 					; move to it			MOVE.W	Right(A3),2(SP) 	; now go to the right edge			_LineTo 					; draw the horizontal line; draw the upper horizontal line			MOVE.L	(SP),Top(A3)		; restore topLeft, leave on stack	<5Aug85>			MOVE.L	(SP),-(SP)			; make a copy of this point			_MoveTo 					; move to it			MOVE.W	Right(A3),2(SP) 	; now go to the right edge			_LineTo 					; draw the horizontal line; draw the vertical line			MOVE.W	Right(A3),-(SP) 	; push right			SUB 	#16,(SP)			; really want right - 16			MOVE.W	Top(A3),-(SP)		; push top			MOVE.L	(SP),-(SP)			; make a copy of this point			_MoveTo 					; and move to it			MOVE.W	Bottom(A3),(SP) 	; now go to bottom edge			_LineTo 					; draw the vertical line; restore the rect back to how it was when we got it			MOVE.L	D3,-(SP)			; push the rect			MOVE.L	OneOne,-(SP)		; push (1,1)			_InsetRect			RTS 						; all done!;  Utility PaintDropShadow -- drop shadows the rectangle in A4, by the amount in D4PaintDropShadow			MOVE.L	D4,-(SP)			; push shadow factor			_PenSize					; make penSize = shadow factor			MOVE	RIGHT(A4),D0		; get right of menuRect			MOVE	D0,-(SP)			; push right			MOVE	TOP(A4),-(SP)		; push top;+++		IF not SquareWind THEN			; 					<C203/06Oct86> DAF;+++			ADD 	D4,(SP) 			; want top+shadow;+++		ENDIF							; 					<C203/06Oct86> DAF			MOVE	D0,-(SP)			; push right			MOVE	BOTTOM(A4),D0		; get bottom			MOVE	D0,-(SP)			; push bottom			MOVE	LEFT(A4),-(SP)		; push left;+++		IF not SquareWind THEN			; 					<C203/06Oct86> DAF;+++			ADD 	D4,(SP) 			; want left+shadow;+++		ENDIF							; 					<C203/06Oct86> DAF			MOVE	D0,-(SP)			; push bottom			TST.B	IsColor(A6)			; are we on a multi-bit Mac?			BNE.S	NOffSh				; if so, then don't offset shadow			TST.W	D5					; 			BEQ.S	NOffSh				;			; adjust shadow line ends									ADD		D4,2(SP)			; want left+shadow			ADD		D4,8(SP)			; want top+shadow						NOffSh; colors are OK here			_MoveTo 					; MoveTo(left+shadow,bottom)			_LineTo 					; LineTo(right,bottom)			_LineTo 					; LineTo(right,top+shadow)			_PenNormal					; restore normal pen			RTS;  PlotSymbol -- plot the little 16 by 16 symbol bitmap pointed to by A1 into the rectangle;  pointed held in TempRect. D0 holds the mode.PlotSymbol			LEA 	IconBitMap,A0		; get pointer to source bitmap			MOVE.L	A1,(A0)+			; update base address of bitMap			MOVE	#2,(A0)+			; update rowBytes			CLR.L	(A0)+				; topLeft is zero, zero			MOVE.L	D1,(A0) 			; adjust boundsRect; push parameters for CopyBits call to transfer arrow bitMap			PEA 	IconBitMap			; push pointer source bitmap			MOVE.L	(SP),A0 			; remember in A0, too			MOVE.L	GrafGlobals(A5),A1		; get lisaGraf global baseaddress			MOVE.L	THEPORT(A1),A1		; get thePort			PEA 	PORTBITS(A1)		; that's the destination bitmap			PEA 	BOUNDS(A0)			; boundsRect of bitmap is source			PEA 	TempRect			; tempRect is the destination			MOVE.W	D0,-(SP)			; theMode is in D0			CLR.L	-(SP)				; no mask region; the colors should be OK here										<DAF 16-Apr-86>; transfer the bitMap (stretching as necessary...)			_CopyBits					; let Bill stretch those bits			RTS 						; return to caller;  Draw the grow icon.	First make this window the current grafPortDrawGIcon			MOVE.L	GrafGlobals(A5),A0	; get the current port and save it <C203> DAF			MOVE.L	thePort(A0),-(SP)	;								   <C203> DAF						MOVE.L	A3,-(SP)			; push the window's port			_SetPort					; make that the port						; save the foreground and background of the user port & set new colors	<DAF 16-Apr-86>			TST.B	IsColor(A6)			; is this a color system?			BEQ.S	@NoColor7			; nope, so skip this stuff						SUBQ	#6,SP				; make room for rgbColor on stack	<C???/11Jan87> DAF			MOVE.L	SP,-(SP)			; push pointer to placeholder		<C???/11Jan87> DAF			_GetForeColor				; get the window port's foreColor	<C???/11Jan87> DAF						SUBQ	#6,SP				; make room for the backColor too	<C???/11Jan87> DAF			MOVE.L	SP,-(SP)			; push pointer to placeholder		<C???/11Jan87> DAF			_GetBackColor				; get the window port's backColor	<C???/11Jan87> DAF			MOVE.W	#wContentColor,D0	; get the drawing color			BSR		SetUpColor			; 			_RGBBackColor				;									<C117/25Sep86> DAF			MOVE.W	#wFrameColor,D0		;			BSR		SetUpColor			;			_RGBForeColor				;									<C117/25Sep86> DAF@NoColor7								; END OF COLOR-ONLY SECTION;  compute the grow icon rectangle in tempRect			LEA 	TempRect,A4 		; get pointer to tempRect			MOVE.L	PortRect+4(A3),4(A4)	; copy in botRight of tempRect			MOVE.L	4(A4),(A4)			; into the topLeft, too			SUB.W	#15,Top(A4)			SUB.W	#15,Left(A4)		; and left, too; plot the grow icon			TST.B	WHilited(A3)		; is it hilited?			BEQ.S	ClearGoAway 		; if not, go clear it			LEA 	GrowBits,A1 		; get pointer to the bits			MOVEQ	#0,D0				; use srcCopy			MOVE.L	#$00100010,D1			BSR  	PlotSymbol			; plot it; plot the	boundary linesPlotBoundary			MOVE.W	Left(A4),-(SP)		; push tempRect.left			MOVE.W	(SP),-(SP)			; copy it again for later			MOVE	PortRect+Top(A3),-(SP)	; push portRect.top			_MoveTo 					; move to it			MOVE	PortRect+Bottom(A3),-(SP)	; push portRect.bottom			_LineTo 					; draw the vertical line; now draw the horizontal line			MOVE.W	PortRect+Left(A3),-(SP) ; push portRect.left			MOVE.W	Top(A4),-(SP)		; push tempRect.top			_MoveTo			MOVE.W	PortRect+right(A3),-(SP)	; push portRect.right			MOVE.W	Top(A4),-(SP)		; push tempRect.top			_LineTo; all done with DrawDocGrowDoneDDG			TST.B	IsColor(A6)			; is it a color system?			BEQ.S	@NoColor8			; no, so skip this restore						MOVE.L	SP,-(SP)			; push ptr to rgbColor previously saved on top of stack 	<C117/25Sep86> DAF				_RGBBackColor				; 								<C117/25Sep86> DAF				ADDQ	#6,SP				; trash backcolor				<C117/25Sep86> DAF				MOVE.L	SP,-(SP)			; 								<C117/25Sep86> DAF				_RGBForeColor				;								<C117/25Sep86> DAF				ADDQ	#6,SP				;								<C117/25Sep86> DAF	@NoColor8								; END OF A COLOR-ONLY SECTION					_SetPort					; restore the incoming port (saved above) <C203> DAF													RTSClearGoAway			PEA 	TempRect			_EraseRect			BRA.S	PlotBoundary; BitMap for GrowIconGrowBits			DC.W	$0000,$0000,$0000,$1FE0			DC.W	$1020,$103E,$1022,$1022			DC.W	$1022,$1022,$1FE2,$0402			DC.W	$0402,$0402,$07FE,$0000			END ; end of Window DefProc #0