<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 01-05-01 --><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css">   <title>Technical Note TN1169: The Download Manager</title>      <meta name="keywords" content="Mac OS 8 Download Manager API Postscript printer low-level converters">    <meta name="Description" content="Technical Note TN1169: This Technical Note discusses theDownload Manager API that Download Manager clients woulduse to call the Download Manager to cause a file, or otherdata, to be downloaded to a PostScript printer. This Notealso discusses the APIs that the Download Manager uses tocall the low-level converters, which includes a discussionof streams and how low level converters use them."><meta name="categories" content="Printing"><meta name="week-posted" content="May 31, 1999 - Jun 4, 1999"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10003008" title="The Download Manager"></a><A NAME="top"></A><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxPrinting-date.html">Printing</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/Printing/index.html" target="_blank">Reference Library > Printing</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1169</div>
<div id="pageheadsub">The Download Manager</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left">   <!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">     <tr><td width=300 valign="top" align=left scope="row">    <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>            <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>  </tr>  <tr bgcolor="#e6e6e6">   <td background="images/tnmenubody.gif" width=300 align=left> <span id="menutitle">CONTENTS   <br>  <br> </span>   </td>  </tr>  <tr bgcolor="#e6e6e6">   <td background="images/tnmenubody.gif" width=300 align=left> <!-- begin_toc --><P id = "menutext"> <A HREF = "#Introduction">Introduction</A><BR><BR> Section 1: <BR> <A HREF = "#Section1">Download Manager Client APIs</A><BR><BR>     <A HREF = "#section1-1">Downloading Files</A><BR><BR><A HREF = "#section1-2">The Status-Idle Procedure</A><BR><BR><A HREF = "#section1-3">Utility Functions For A Client's Use  of the Download Manager</A><BR><BR><A HREF = "#section1-4">Downloading Streams</A><BR><BR><A HREF = "#section1-5">Additional Utility Functions</A><BR><BR>Section 2 : <BR> <A HREF = "#Section2"> Low-level Converter Interface</A><BR><BR><A HREF = "#section2-1">Streams Information</A><BR><BR><A HREF = "#section2-2">Additional Functions For Random-Access Streams</A><BR><BR><A HREF = "#section2-3">Low-level Converting Routines</A><BR><BR><A HREF = "#section2-4">Getting Information For A Client</A><BR><BR><A HREF = "#section2-5">Peeking At The Data</A><BR><BR><A HREF = "#section2-6">Queries</A><BR><BR><A HREF = "#section2-7">Doing The Conversion</A><BR><BR><A HREF = "#section2-8">Converter Capabilities</A><BR><BR><A HREF = "#section2-9">Utility Functions</A><BR><BR><A HREF = "#section2-10">Errors</A><BR><BR><A HREF = "#section2-11">Logging</A><BR><BR><A HREF = "#References">References</A><br><br><A HREF = "#Changes">Change History</A><br><br><A HREF = "#Downloads">Downloadables</A></p> <!-- end_toc --></td>  </tr>  <tr>   <td width=300 align=left scope="row"> <img src="images/tnmenubottom.gif" alt="" width=300 height=16>   </td>  </tr>    </table></td>  <td width=300 valign="top" align=left><!-- begin_intro_text --><P id = "introtext">This Technote is divided into two sections. Section 1 discusses the Download Manager API that Download Manager clients would use to call the Download Manager to cause a file, or other data, to be downloaded to a PostScript printer. (The Desktop Printing software is an example of a Download Manager client that uses this API.) Writers of low-level converters should read Section 1 to get an overview of the environment in which their converter will operate.</p><P id = "introtext">Section 2 discusses the APIs that the Download Manager uses to call the low-level converters. This material is intended for the writers of the low-level converters which are called by the Download Manager.</p><P id = "introtext">In addition to downloading files to a PostScript output device, it is possible for a client to provide the data from a source other than a file or to obtain the PostScript output data itself rather than have it transmitted to a device. Programmers who wish to create a Download Manager client that supplies the data to convert and/or a client that receives the Download Manager generated PostScript output should read the discussion of streams in Section 2.</P><P id = "introtext">Moreoever, programmers who wish to create a Download Manager client that only downloads files to a PostScript output device need not read Section 2.</p>       <!-- end_intro_text --><!-- begin_date --><h3>&nbsp;Updated: [May 24 1999]</h3><!-- end_date --></TD> </TR>    </TABLE> <!-- end_header_box --><BR><BR><hr width=500 align=center><BR><BR><!-- begin_content --><A NAME="Introduction"></A><H2>Introduction</H2><P>PrintingLib version 8.6, which is included with LaserWriter 8 version 8.6, adds new functionality. One part of this functionality is the Download Manager, which allows clients to print data to PostScript printers without launching a separate application. LaserWriter 8.6 also added the Printing Plug-ins Manager and Custom Hose support. These other features will be described in separate Technotes.</p><P>The Download Manager allows a client, such as Desktop Printing, to print documents directly to a PostScript printer without launching a separate application. There are several benefits to printing the data directly. Since applications tend to be memory intensive and relatively slow to launch, the Download Manager can call a converter plug-in and start the job printing more quickly. Rather than having an application convert the data to QuickDraw and then have the printer driver convert the QuickDraw data to PostScript, the Download Manager allows the image data to be converted directly to PostScript. This lowers the overhead involved with converting a data format to PostScript, and also allows more efficient PostScript code to be generated. An extra benefit to this process is that the user need not necessarily have an application which can open and print the document.</p><P>Here's how it works: the user drags a given file onto a desktop printer. The Desktop Printing software then asks the Download Manager whether it knows how to download this file. If the Download Manager says yes, the Desktop Printing software calls the Download Manager to download the file. If the Download Manager cannot handle the file, Desktop Printing opens the application with a print event as it did before the Download Manager existed and the user can print the document from the application.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The Download Manager is not restricted to use by the Desktop Printing software and can be used by other clients.</p></TD></TR></TABLE></CENTER><BR><BR><P>The design of the Download Manager is intended to be modular, so that it can download new data types without being changed itself. It does this by using converter module plug-ins, referred to here as "low-level converters." These components are the functional units which convert a given data type into PostScript language code appropriate for sending to a PostScript printer. These low-level converters are shared libraries which conform to the interface required by the Download Manager.</P><P>The Download Manager currently provides several built-in converters together with the ability to drop new low-level converters into a special folder so they are available for use with the Download Manager. PrintingLib version 8.6 and later provide converters to handle PostScript and EPS files, PICT data files, and non-progressive JPEG images.</P><P>To provide an idea how this all ties together in Mac OS 8.5, Desktop Printing is a client of the Download Manager. The Download Manager uses the Printing Plug-ins Manager to manage its plug-ins, which include low-level converters and custom hoses. Low-level converters take a file of a given type and convert it directly to PostScript, without going through an application or a driver. The Download Manager then sends the generated PostScript to the printer using a custom hose, which is specified by the Desktop Printer.</P><p align="center"><img src="images/tn1169_001.gif" hspace=0 vspace=0 alt="" width=398 height=356></p> <BR><P><A HREF = "#top">Back to top</a></p><P><A NAME="Section1"></A></P><H2>Section 1</H2><P>This section discusses the calls that a Download Manager client uses to download data through the Download Manager. Most Download Manager clients can ignore Section 2, which discusses the APIs that the Download Manager itself uses to call the low-level converters. The section <A HREF = "#filedownload">File Download Example</A> is an example of using the Download Manager to download a file. This is the approach that the Desktop Printing software uses.</P>    <H2>Download Manager APIs</H2><P>The Download Manager APIs allow a client to determine whether the Download Manager, together with the current set of low-level converter modules available, can convert and download a given piece of data. This data may be the data fork of a file, or it may be supplied by the client via a stream mechanism which is defined below. Once the client has determined if the Download Manager can handle the data, it calls the Download Manager routine to invoke the processes of conversion and downloading.</p><BR><P><A HREF = "#top">Back to top</a></p><A NAME="section1-1"></A><H3>Downloading Files</H3><P>This section of the document describes the high-level APIs that a client of the Download Manager, such as the Desktop Printing software, would call to download <code>files</code>. First, the client calls the <CODE>psCanDownloadFile</CODE> routine:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>psCanDownloadFileOSStatus psCanDownloadFile(const FSSpec *fileSpecP,  Collection hints, Handle papaHandle,  Boolean *canDownloadP,  DownloaderInfo *downloaderInfoP, Str255 errReason);  </pre></TD></TR></TABLE></CENTER><BR><BR> <P><CODE>psCanDownloadFile</CODE> asks the Download Manager whether it can download the file represented by <CODE>fileSpecP</CODE>.</P><P><CODE>fileSpecP</CODE> is a pointer to an <CODE>FSSpec</CODE> corresponding to the file to be downloaded.</P><P><CODE>hints</CODE> is a Collection containing information about the destination output device and possibly user requests for how the data should be converted and downloaded.</P><P><CODE>papaHandle</CODE> is a handle to a <CODE>PAPA</CODE> for the target output destination.</P><P><CODE>canDownloadP</CODE> is a pointer to a Boolean that is set to true or false depending on whether the file can be downloaded by one of the low-level converters available to the Download Manager.</p><P><CODE>downloaderInfoP</CODE> is a pointer to a <CODE>DownloaderInfo</CODE> structure that the client uses to call the <CODE>psDownloadFile</CODE> routine of the Download Manager (described below). The <CODE>DownloaderInfo</CODE> structure is defined as follows:</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>  typedef struct DownloaderInfo{  unsigned char converterID[256]; }DownloaderInfo;</pre></TD></TR></TABLE></CENTER><BR><BR><P>The Download Manager routine <CODE>psCanDownloadFile</CODE> writes information into the <CODE>DownloaderInfo</CODE> structure, which it can later use to select which low-level converter to use for the download.</P><P>The <CODE>errReason</CODE> argument to <CODE>psCanDownloadFile</CODE> is a pointer to a <CODE>Str255</CODE> which may be filled in with a text string message should an error occur during this call. This is supplied to facilitate reporting problems back to clients of the Download Manager.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Even if an error occurs, <code>errReason</code> may contain a zero-length string.</p></TD></TR></TABLE></CENTER><BR><BR><P>Note that whether the Download Manager can handle a given file may be dependent on the <code>hints</code> collection and <code>papaHandle</code> passed to <code>psCanDownloadFile</code>. If the target device changes, <code>psCanDownloadFile</code> should be called again to ensure that indeed the Download Manager can download the file to the new target device. It is possible that this will not be the case, or, the <code>DownloaderInfo</code> returned will differ from that originally obtained. This comment is specifically directed to clients such as the Desktop Printing software, where dragging files from one DTP queue to another must be considered.</P><P>Once a client determines that the document can be downloaded by the Download Manager, it can call the routine <CODE>psGetDownloadDocumentInfo</CODE> to obtain information (such as number of pages) about the document. The structure <CODE>DownloadDocumentInfo</CODE> (described shortly) is filled in by this call with information determined by the Download Manager and the low-level converter.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>psGetDownloadDocumentInfo OSStatus psGetDownloadDocumentInfo(const FSSpec *fileSpecP,  Collection hints,  const DownloaderInfo *downloaderInfoP,  DownloadDocumentInfo *downloadDocInfoP,  Str255 errReason);</pre></TD></TR></TABLE></CENTER><BR><BR><P><CODE>psGetDownloadDocumentInfo</CODE> asks the Download Manager to gather document information about a file.</P><P><CODE>fileSpecP</CODE> is a pointer to an <CODE>FSSpec</CODE> corresponding to the file for which the information is requested.</P><P><CODE>hints</CODE> is a Collection containing information about the destination output device and possibly user requests for how the data should be converted and downloaded.</P><P><CODE>downloaderInfoP</CODE> is a pointer to the data returned by <CODE>psCanDownloadFile</CODE> when it can download the file. This allows the Download Manager to find the converter which it determined can handle the download during the <CODE>psCanDownloadFile</CODE> call.</P><P>Note that the <code>DownloaderInfo</code> data returned by <code>psCanDownloadFile</code> can be stored and reused at a later time. There is nothing in the <code>DownloaderInfo</code> structure that can't be used across reboots. It is possible that the low-level converter referenced in the <code>DownloaderInfo</code> structure may not be available at a later time due to user actions such as deleting the converter. Download Manager clients should be prepared for the error <code>errInvalidDownloaderInfo</code> if a saved <code>DownloaderInfo</code> structure is used. An additional disadvantage of saving the <code>DownloaderInfo</code> structure is that a low-level converter later added to the system will not be used, even if it is better able to handle the data.</P><P><code>downloadDocInfoP</code> is a pointer to a <CODE>DownloadDocumentInfo</CODE> structure. The <CODE>DownloadDocumentInfo</CODE> is a structure to receive the data and is defined shortly.</P><P><CODE>errReason</CODE> is a pointer to a <CODE>Str255</CODE> which may be filled in with a text string message should an error occur during this call. This is supplied to facilitate reporting problems back to clients of the Download Manager.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Even if an error occurs, <code>errReason</code> may contain a zero-length string.</P></TD></TR></TABLE></CENTER><BR><BR><H4>DownloadDocumentInfo structure</H4><P>The <CODE>DownloadDocumentInfo</CODE> structure filled in by <CODE>psGetDownloadDocumentInfo</CODE> is defined as:</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef struct DownloadDocumentInfo{ SInt32 version;        // caller must set to 1 OSType type; Boolean isManualFeed;  //true if job is manual feed,else false. SInt32 pages; // Unknown = -1 SInt32 copies;// Unknown = -1 Str255 creator;        // unknown for most converters use &quot;\p&quot; Str255 title; // unknown for most converters use &quot;\p&quot;}DownloadDocumentInfo;</pre></TD></TR></TABLE></CENTER><BR><BR><P>The <CODE>version</CODE> field should be set to the version of the structure that the caller of <CODE>psGetDownloadDocumentInfo</CODE> supplies. This allows for the ability in the future to supply a pointer to a larger structure that potentially provides additional data. The only version defined at this time is version 1.</P><P>The <CODE>type</CODE> field of this structure is the type of document being downloaded. The type of data may in some cases not be known by the Macintosh Finder <CODE>TYPE</CODE> information, but instead might be only known to a low-level converter that knows how to handle the data. The type returned here is available for a client to use as it wishes; for example, a client could have a special icon for different document types. The list of types which might be returned by this call is unlimited since new converter modules can be added via Plug-Ins. The types which have been defined to date are:</P><UL TYPE=DISC>    <LI>'EPSF': Encapsulated PostScript File</li>    <LI>'PSDC': PostScript file, claims to be DSC 3.0 conformant or greater</li>    <LI>'PSUN': PostScript file, does not claim to be DSC 3.0 conformant or greater</li>    <LI>'JFIF': JPEG data file</li>    <LI>'PICT': Macintosh PICT data file</li>    <LI>'TIFF': TIFF data file</li>    <LI>'TEXT': Plain text file to be treated as unformatted text</li>    <LI>'PDF ': Adobe Systems' PDF document format</li>    <LI>'????': An unknown type of file.</li></UL><P>The <CODE>isManualFeed</CODE> field allows the Download Manager to notify the caller that this download job requests manual feed. This allows a client, such as the Desktop Printing software, to notify the user when a manual feed job begins. Note that it is possible that the print job requests manual feed, but it is a save-to-disk job. In this case, it would be inappropriate to alert the user that a manual feed job is starting since a disk file is being written and is not a print job to a live printer. A routine is available in <CODE>FeatureUtilsLib</CODE> called <CODE>psIsJobPrintToDisk</CODE> which Download Manager clients can call if <CODE>isManualFeed</CODE> is set to true.</P><P>The <CODE>pages</CODE> field of the <CODE>DownloadDocumentInfo</CODE> is the number of pages in the document. For some types of documents handled by the Download Manager it may be unknown and this is indicated by use of the value -1.</P><P>The <CODE>copies</CODE> field of the <CODE>DownloadDocumentInfo</CODE> is the number of copies of the document which will be printed. (This is typically 1, but there are some situations where it might be different. For many low-level converters' handling of features, this reflects the default number of copies that the user has as their saved defaults for the Print Dialog. If the user has a different saved default for the number of copies, many converters respect that and report it here.) Currently there is no straightforward way to know the number of copies for most PostScript files and this is indicated by the value -1 for the number of copies.</P><P>The <CODE>creator</CODE> field of the <CODE>DownloadDocumentInfo</CODE> is a text string indicating the name of the application used to create the original file. This is unknown for many document types, but for PostScript files containing the <CODE>%%Creator</CODE> comment, the application creating the document may be available. If the document creator is not available, the creator field of the <CODE>DownloadDocumentInfo</CODE> is a zero-length string.</P><P>The <CODE>title</CODE> field of the <CODE>DownloadDocumentInfo</CODE> is a text string which indicates what the original file name was when creating this file. This is unknown for many document types, but for PostScript files containing the <CODE>%%Title</CODE> comment, the name of the original document may be available. If the original document title is not available, the title field of the <CODE>DownloadDocumentInfo</CODE> is a zero-length string.</P><H4>psDownloadFile</H4><P>Once the Download Manager client has determined that the file can be handled by the Download Manager, it calls the <CODE>psDownloadFile</CODE> routine to perform the download:</P>        <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus psDownloadFile(const FSSpec *fileSpecP,  Collection hints, Handle papaHandle,  const DownloaderInfo *DownloaderInfoP,  StatusIdleProcUPP idleProc, void *clientIdleParams,  Str255 errReason);</pre></TD></TR></TABLE></CENTER><BR><BR><P><CODE>psDownloadFile</CODE> causes the Download Manager to download the file represented by <CODE>fileSpecP</CODE> using the converter specified in <CODE>downloaderInfoP</CODE>.</P><P><CODE>fileSpecP</CODE> is a pointer to an <CODE>FSSpec</CODE> corresponding to the file to be downloaded by <CODE>psDownloadFile</CODE>.</P><P><CODE>hints</CODE> is a Collection containing information about the destination output device and possibly user requests for how the data should be converted and downloaded.</P><P><CODE>papaHandle</CODE> is a handle to a <CODE>PAPA</CODE> for the target output destination.</P><P><CODE>DownloaderInfoP</CODE> is a pointer to the data returned by <CODE>psCanDownloadFile</CODE> when it can download the file. This allows the Download Manager to find the converter which it determined can handle the download during a prior <CODE>psCanDownloadFile</CODE> call.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR> The <code>DownloaderInfo</code> data returned by <code>psCanDownloadFile</code> can be stored and reused at a later time. There is nothing in the <code>DownloaderInfo</code> structure that can't be used across reboots; however, it is possible that the low-level converter referenced in the <code>DownloaderInfo</code> structure is not available at a later time due to user actions such as deleting the converter. Download Manager clients should be prepared for errors when a saved <code>DownloaderInfo</code> structure is used.</p></TD></TR></TABLE></CENTER><BR><BR><P><CODE>idleProc</CODE> is a Universal Proc Pointer to a routine supplied by the caller of <CODE>psDownloadFile</CODE>, i.e., the Download Manager client. The Download Manager calls this <CODE>idleProc</CODE> routine with status information during the download. The <CODE>idleProc</CODE> routine is responsible for giving time to other applications, reporting status information to the user and handling user interactions with the client as the download proceeds.</P><P><CODE>clientIdleParams</CODE> is a pointer to data supplied by the Download Manager client. This pointer is supplied as part of the data passed to each call of the <CODE>idleProc</CODE> during the download.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The resource chain at the time the <CODE>idleProc</CODE> is called is not guaranteed. The Download Manager and its low-level converters may open resource files and add them to the resource chain during their execution. Clients whose <code>idleProc</code> routines require resources from their resource files should take care to ensure that any additional open resource files are not in the way. The most straightforward way for a client to do this is to have a field in their <code>clientIdleParams</code> structure which is the current resource file at the time they call <CODE>psDownloadFile</CODE>. In addition, an <code>idleProc</code> muse preserve the resource chain. If you change the resource chain in your <code>idleProc</code>, you must save and  restore the resource chain using <code>CurResFile</code> and <code>UseResFile.</code></p></TD></TR></TABLE></CENTER><BR><BR><P>The <CODE>errReason</CODE> argument to <CODE>psDownloadFile</CODE> is a pointer to a <CODE>Str255</CODE> which may be filled in with a text string message should a download fail. This is supplied to facilitate reporting problems back to clients of the Download Manager.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Even if an error occurs, <code>errReason</code> may contain a zero-length string.</p></TD></TR></TABLE></CENTER><BR><BR><P>The error value <CODE>errCantHandleThisDownloadData</CODE> (defined in DownloadMgrLib.h) is a special error value that may be returned by the <CODE>psDownloadFile</CODE> call if a converter module determines that, even though it previously reported that it could download a file, it has now determined that it can't download that file. This should be a rare occurrence.</P><BR><P><A HREF = "#top">Back to top</a></p>   <A NAME="section1-2"></A><H3>The Status-Idle Procedure</H3><P>The <CODE>idleProc</CODE> supplied to the call <CODE>psDownloadFile</CODE> is a Universal Proc Pointer containing a procedure of type <CODE>StatusIdleProc</CODE>. This is defined as follows:</P> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef pascal OSStatus(*StatusIdleProc)(DownloadIdleInfo *param);This procedure is called with a pointer to a DownloadIdleInfo structure.This structure is defined as follows:typedef struct DownloadIdleInfo{ void *clientIdleParams;      /*the client's IdleParam data */ long currentPage;/* -1 means Unknown */ long totalPages; /* -1 means Unknown */ short percentageDownloaded;  /* -1 means Unknown, otherwise /*  ranges from 0 to 100 */ PSSection section;/* one of the PSSection       values from PSSectionInfo.h */ PSSubsection subsection;     /* one of the PSSubsection       values from PSSectionInfo.h */ void *statusInfoP;/* pointer to data appropriate       for this download idle call.       See PSSectionInfo.h for       details.      */}DownloadIdleInfo;</pre></TD></TR></TABLE></CENTER><BR><BR><P>The <CODE>StatusIdleProc</CODE> is supplied by the client and is called by the Download Manager during the download. <CODE>clientIdleParams</CODE> is the data pointer supplied by the client as the <CODE>clientIdleParams</CODE> parameter to the <CODE>psDownloadFile</CODE> call.</P><P>The <CODE>currentPage</CODE> and <CODE>totalPages</CODE> fields are filled in if and when the Download Manager can determine this data.</P><P>The <CODE>percentageDownloaded</CODE> field reflects the progress of the download. The Download Manager uses the percentage of the input data read by the converter during the download as its way of reporting progress.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR> If a low-level converter does not read the file data in a sequential fashion, the Download Manager will set the <code>percentageDownloaded</code> field to "<code>Unknown"</code> and no longer update the <code>percentageDownloaded</code> field during that download. Since this field may be <CODE>"Unknown,"</CODE> a status bar should properly change its indicator to <CODE>"Unknown"</CODE> accordingly.</p></TD></TR></TABLE></CENTER><BR><BR><P>The section field indicates which phase of the download is currently in progress. Currently the possible section values are <CODE>kSectCoverPage</CODE>, <CODE>kSectAnon</CODE>, <CODE>kSectPeek</CODE>, <CODE>kSectQueryJob</CODE>, and <CODE>kSectJob</CODE>.</P><P>The subsection field contains Document Structuring Conventions information or other section information about the PostScript data being downloaded (see the heading <A HREF = "#downloadidleinfo">DownloadIdleInfo Section, Subsection and StatusInfo</A> below).</P><P>The <CODE>statusInfoP</CODE> field contains a pointer to information corresponding to the current subsection. For example, if the subsection is <CODE>kSubStatusSection</CODE>, the information in <CODE>statusInfoP</CODE> is a pointer to a Pascal string containing a status message from the printer and should be treated accordingly. If the subsection is <CODE>kSubBeginFont</CODE>, the <CODE>statusInfoP</CODE> contains a pointer to a <CODE>DSCData</CODE> structure describing the font being downloaded. If the subsection is <CODE>kSubPrinterErrorSection</CODE>, the <CODE>statusInfoP</CODE> contains a pointer to a Pascal string describing a printer error condition, such as out of paper, that requires user intervention.</P><P>The client's <CODE>StatusIdleProc</CODE> is required to give time to other applications, handle user interactions with the client and report status to the user. If <CODE>StatusIdleProc</CODE> returns an error, the Download Manager aborts the download.</P><A NAME="downloadidleinfo"></A><H4>DownloadIdleInfo Section, Subsection, and StatusInfo</H4><P>The <CODE>DownloadIdleInfo</CODE> structure has fields which supply status information about the download to a client's <CODE>StatusIdleProc</CODE>. The first of these fields is the section field which is of type <CODE>PSSection</CODE>. A <CODE>PSSection</CODE> value provides overall information about what part of the download is in progress. <CODE>PSSection</CODE> values consist of <CODE>kSectAnon</CODE>, <CODE>kSectQueryJob</CODE>, <CODE>kSectCoverPage</CODE>, <CODE>kSectJob</CODE>, and <CODE>kSectPeek</CODE>. The definition of <CODE>PSSection</CODE> is in the "PSSectionInfo.h" header file. The Download Manager is responsible for setting the section field of the <CODE>DownloadIdleInfo</CODE> structure and does this as it processes the different sections of the download job.</P><P>The <CODE>PSSection</CODE> field corresponds to the various parts of a download: the query, peeking at the data that a low-level converter can do as part of a download, the cover page (if there is one) and the actual download job itself. A converter doesn't start generating PostScript data until the <CODE>kSectCoverPage</CODE> or <CODE>kSectJob</CODE> PSSection values are seen.</P><P>The subsection field is of type <CODE>PSSubsection</CODE>. A subsection value provides finer granularity in the reporting of progress of the download job. Typically the subsection values correspond to Document Structure Conventions (DSC) comments which have a well-defined meaning. A few subsection values have been added to provide additional information. Each section can contain the same subsection values, although most of the subsections apply only to the <CODE>kSectJob</CODE>, <CODE>kSectCoverPage</CODE>, and <CODE>kSectPeek</CODE> sections.</P><P>The Download Manager generates status and error subsection values. Beyond that, each low-level converter module is responsible for generating subsection values during the download. While any subsection value from the list in "PSSectionInfo.h" is possible, <A HREF = "#Table1">Table 1</A> lists those most likely to be generated by existing low-level converters. No one converter necessarily generates all of these subsection values for each job.</P><P>The <CODE>DownloadIdleInfo</CODE> structure contains a <CODE>statusInfoP</CODE> field which is declared as a <CODE>(void*)</CODE> field. The <CODE>statusInfoP</CODE> field may be <CODE>NULL</CODE> in any subsection, meaning that the subsection value is being reported without any additional information. If the data is <CODE>non-NULL</CODE>, it is a pointer to a data type that depends on the subsection being reported in the <CODE>DownloadIdleInfo</CODE> structure. The complete list of subsections together with their info field structure is listed in "PSSectionInfo.h." <A HREF = "#Table1">Table 1</A> below lists the ones most likely to be seen.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>It is important for an <code>idleProc</code> to check that the <code>statusInfoP</code> field is not NULL before attempting to dereference it.</p></TD></TR></TABLE></CENTER><BR><BR><P>For example, the low-level PostScript converter module (which downloads PostScript and EPS input data) generates the <CODE>kSubPages</CODE> subsection when the section is <CODE>kSectJob</CODE> or <CODE>kSectPeek</CODE> and it encounters the <CODE>%%Pages</CODE> DSC comment in the PostScript data. At that time, it reports the <CODE>kSubPages</CODE> subsection with the <CODE>statusInfoP</CODE> field pointing to an <CODE>SInt32</CODE> value that is the number of pages in the document.</P><A NAME="Table1"></A><H3>Table 1</H3><TABLE BORDER="1"><TR><TH>Subsection</TH><TH>DSC Comment</TH><TH>statusInfo structure</TH></TR><TR>    <td align="left">    kSkSubPSAdobe</td>    <td align="left">    %!PS-Adobe-x.y</td>    <td align="left">    Fixed</td>    <td align="left">    </td></TR><TR>    <td align="left">    kSubPSAdobeEPS</td>    <td align="left">    %!PS-Adobe-x.y EPSF-a.b</td>    <td align="left">    EPSFVersion</td></TR><TR>    <td align="left">    kSubBoundingBox</td>    <td align="left">    %%BoundingBox</td>    <td align="left">    DSCBBox</td></TR><TR>    <td align="left">    kSubDocData</td>    <td align="left">    %%DocumentData</TD>    <td align="left">DSCDocumentDatA</td></TR><TR>    <td align="left">    kSubEndComments</td>    <td align="left">    %%EndComments</td>    <td align="left">    none</td></TR><TR>    <td align="left">    kSubLangLevel</td>    <td align="left">    %%LanguageLevel</td>    <td align="left">    SInt32</td></TR><TR>    <td align="left">    kSubPages</td>    <td align="left">    %%Pages</td>    <td align="left">    SInt32</td></TR><TR>    <td align="left">    kSubContinue</td>    <td align="left">    %%+</td>    <td align="left">    DSCContinuationData</td></TR><TR>    <td align="left">    kSubBeginProlog</td>    <td align="left">    %%BeginProlog</td>    <td align="left">    none</td></TR><TR>    <td align="left">    kSubEndProlog</td>    <td align="left">    %%EndProlog</td>    <td align="left">    none</td></TR><TR>    <td align="left">    kSubBeginSetup</td>    <td align="left">    %%BeginSetup</td>    <td align="left">    none</td></TR><TR>    <td align="left">    kSubEndSetup</td>    <td align="left">    %%EndSetup</td>    <td align="left">    none</td></TR><TR>    <td align="left">    kSubBeginPageSetup</td>    <td align="left">    %%BeginPageSetup</td>    <td align="left">    SInt32 (page #)</td></TR><TR>    <td align="left">    kSubEndPageSetup</td>    <td align="left">    %%EndPageSetup</td>    <td align="left">    SInt32</td></TR><TR>    <td align="left">    kSubPage</td>    <td align="left">    %%Page</td>    <td align="left">    DSCPage</td></TR><TR>    <td align="left">    kSubEOF</td>    <td align="left">    %%EOF</td>    <td align="left">    none</td></TR><TR>    <td align="left">    kSubDocNeededRes</td>    <td align="left">    %%DocumentNeededResources</td>    <td align="left">    DSCData</td></TR><TR>    <td align="left">    kSubDocSuppliedRes</td>    <td align="left">    %%DocumentSuppliedResources</td>    <td align="left">    DSCData</td></TR><TR>    <td align="left">    kSubDocFonts</td>    <td align="left">    %%DocumentFonts</td>    <td align="left">    DSCData</td></TR><TR>    <td align="left">    kSubDocNeededFonts</td>    <td align="left">    %%DocumentNeededFonts</td>    <td align="left">    DSCData</td></TR><TR>    <td align="left">    kSubDocSuppliedFonts</td>    <td align="left">    %%DocumentSuppliedFonts</td>    <td align="left">    DSCData</td></TR><TR>    <td align="left">    kSubBeginFeature</td>    <td align="left">    %%BeginFeature</td>    <td align="left">    DSCFeature</td></TR><TR>    <td align="left">    kSubEndFeature</td>    <td align="left">    %%EndFeature</td>    <td align="left">    none</td></TR><TR>    <td align="left">    kSubIncludeFeature</td>    <td align="left">    %%IncludeFeature</td>    <td align="left">    DSCFeature</td></TR><TR>    <td align="left">    kSubBeginFont</td>    <td align="left">    %%BeginFont</td>    <td align="left">    DSCData</td>    </TR><TR>    <td align="left">    kSubEndFont</td>    <td align="left">    %%EndFont</td>    <td align="left">    none</td></TR><TR>    <td align="left">    kSubBeginBitmapFont</td>    <td align="left">    %RBIBeginBitmapFont</td>    <td align="left">    Str255</td></TR><TR>    <td align="left">    kSubEndBitmapFont</td>    <td align="left">    %RBIEndBitmapFont</td>    <td align="left">    none</td></TR><TR>    <td align="left">    kSubBeginTrueTypeFont</td>    <td align="left">    %RBIBeginTrueTypeFont</td>    <td align="left">    Str255</td></TR><TR>    <td align="left">    kSubEndTrueTypeFont</td>    <td align="left">    %RBIEndTrueTypeFont</td>    <td align="left">    none</td></TR><TR>    <td align="left">    kSubBeginTrueTypeScaler</TD>    <td align="left">%RBIBeginFontRasterizer</TD>    <td align="left">    none</td></TR><TR>    <td align="left">    kSubEndTrueTypeScaler</td>    <td align="left">    %RBIEndFontRasterizer</td>    <td align="left">    none</td></TR><TR>    <td align="left">    kSubIncludeFont</td>    <td align="left">    %%IncludeFont</td>    <td align="left">    DSCData</td>    </TR><TR>    <td align="left">    kSubBeginResource</td>    <td align="left">    %%BeginResource</td>    <td align="left">    DSCData</td></TR><TR>    <td align="left">    kSubEndResource</td>    <td align="left">    %%EndResource</td>    <td align="left">    none</td></TR><TR>    <td align="left">    kSubIncludeResource</td>    <td align="left">    %%IncludeResource</td>    <td align="left">    DSCData</td></TR><TR>    <td align="left">    kSubStatusSection</td>    <td align="left">    (see below)</td>    <td align="left">    Str255</td></TR><TR>    <td align="left">    kSubPrinterErrorSection</td>    <td align="left">    (see below)</td>    <td align="left">    Str255</td></TR><TR>    <td align="left">    kSubFatalPrinterErrorSection</td>    <td align="left">    (see below)</td>    <td align="left">    Str255</td></TR><TR>    <td align="left">    kSubGiveUpTime</td>    <td align="left">    (see below)</td>    <td align="left">    none</td></TR><TR>    <td align="left">    kSubLogWarningData</td>    <td align="left">    (see below)</td>    <td align="left">    DSCLogData</td></TR><TR>    <td align="left">    kSubLogErrorData</td>    <td align="left">    (see below)</td>    <td align="left">    DSCLogData</TD></TR></TABLE><P>A few of the subsections do not correspond to DSC comments but instead are used to convey information to the client such as status data, printer error conditions, and error or warning messages from a converter.</P><P>The <CODE>kSubStatusSection</CODE> subsection contains the normal status during the download as reported from a live printer or the save-to-disk process. This is normally seen as a status narration line in the Download Manager client's downloading dialog.</P><P>The <CODE>kSubPrinterErrorSection</CODE> subsection is used to report a printer error condition that should be reported to the user. Usually a client reports the error through a notification. This subsection is supplied repeatedly until the printer error condition is cleared. These messages are strings such as "out of paper", "cover open", and "paper jam".</P><P>The <CODE>kSubFatalPrinterErrorSection</CODE> subsection is used to report fatal printer errors to the user. The fatal printer error is usually a PostScript error.</P><P>The <CODE>kSubGiveUpTime</CODE> subsection is used by a low-level converter when it has no data to write but wants to give time to the Download Manager and its clients.</P><P>The <CODE>kSubLogWarningData</CODE> subsection is used by a low-level converter to report warning conditions to the client. These are not fatal errors, but rather conditions which might lead to a failure in the download. For example, the PostScript converter supplies a warning if the document being downloaded requires a PostScript language level greater than the target output device supports. This will very likely result in a PostScript error during the download, but the warning itself does not result in an error. A savvy client could warn the user, if it were so configured.</P><P>The <CODE>kSubLogErrorData</CODE> subsection is used by a low-level converter to report an error condition to the client. After reporting this error, the <CODE>psDownloadFile</CODE> call will terminate with an error supplied by the low-level converter. In this case, the <CODE>errReason</CODE> returned by <CODE>psDownloadFile</CODE> is filled in with a text message supplied by the low-level converter.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR> Even if an error occurs, <code>errReason</code> may contain a zero-length string.</p></TD></TR></TABLE></CENTER><BR><BR><P>The <CODE>kSubLogWarningData</CODE> and <CODE>kSubLogErrorData</CODE> subsections can supply a pointer to a <CODE>DSCLogData</CODE> structure as the <CODE>statusInfoP</CODE> structure. This structure is defined as:</P> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre> typedef struct DSCLogData{  PSSubsection  logSubsection;  void   *info;  Str255   logMessage; }DSCLogData;</pre></TD></TR></TABLE></CENTER><BR><BR><P>The <CODE>logSubsection</CODE> field is a <CODE>PSSubsection</CODE> value and it is the subsection to which the warning or error corresponds. It is <CODE>kSubAnon</CODE> if it doesn't correspond to any other <CODE>PSSubsection</CODE>. The info field is a pointer to a structure which corresponds to the <CODE>logSubsection</CODE> value. That is, if the info field in a <CODE>DSCLogData</CODE> structure is <CODE>non-NULL</CODE>, it points to whatever structure is appropriate for the <CODE>PSSubsection</CODE> value of the <CODE>logSubsection</CODE> field, as described in <A HREF = "#Table1">Table 1</A> above. The <CODE>logMessage</CODE> field is a <CODE>Str255</CODE> containing the actual text message.</P><P>For example, when the PostScript converter supplies a warning that the document being downloaded requires a PostScript language level greater than the target output device supports, it supplies a <CODE>DSCLogData</CODE> structure where the <CODE>logSubsection</CODE> value is <CODE>kSubLangLevel</CODE>.The structure pointed to by the info field is an <CODE>SInt32</CODE> with the value of the document's language level requirement (which, in this case, exceeds that of the target output device). It also supplies a warning text message in the <CODE>logMessage</CODE> field.</P><BR><P><A HREF = "#top">Back to top</a></p><A NAME="section1-3"></A><H3>Utility Functions For A Client's Use of the Download Manager</H3><H4>psCreateDMJobCollection</H4><P>The Download Manager makes available a routine called <CODE>psCreateDMJobCollection</CODE>. This call provides one-stop shopping for clients to prepare a collection for use with a given Download Manager job. For example, the Desktop Printing software makes this call with information about the current driver, the <CODE>PAPA</CODE> to use with that driver and a pointer to a <CODE>FSSpec</CODE> representing the file to download. If there is no error, <CODE>psCreateDMJobCollection</CODE> returns a collection to the caller which is appropriate for use with the Download Manager routines <CODE>psCanDownloadFile</CODE> and <CODE>psDownloadFile</CODE>. The collection represents the printer defaults and those collection items appropriate for this particular download.</P><P>Depending on how a client operates, it may be appropriate to call <CODE>psCreateDMJobCollection</CODE> once per download job. It is necessary to call <CODE>psCreateDMJobCollection</CODE> only once to obtain a collection for passing to <CODE>psCanDownloadFile</CODE> and the same collection can be passed to <CODE>psDownloadFile</CODE> if the collection is used immediately. If the collection needs to be stored, the target driver or printer changes, or there is any chance that saved user defaults have changed, a client should call <CODE>psCreateDMJobCollection</CODE> again to obtain a collection for passing to <CODE>psDownloadFile</CODE>.</P> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus psCreateDMJobCollection(const FSSpec *driverFSSpecP,  Handle papaHandle, const FSSpec *theFileP,  Collection *hintsP);</pre></TD></TR></TABLE></CENTER><BR><BR>  <P><CODE>driverFSSpecP</CODE> is a pointer to a <CODE>FSSpec</CODE> corresponding to the driver for the target Desktop Printer (DTP). It does not have to be the current system printer driver. Calling <CODE>psCreateDMJobCollection</CODE> does not change the current system printer driver.</P><P><CODE>papaHandle</CODE> is the <CODE>PAPA</CODE> to use for the target output device. It does not have to be the current <CODE>PAPA</CODE> in the driver corresponding to <CODE>driverFSSpecP</CODE>, nor does this routine change the current <CODE>PAPA</CODE> for the driver pointed to by <CODE>driverFSSpecP</CODE>.</P><P><CODE>theFileP</CODE> is a pointer to an <CODE>FSSpec</CODE> for the file to be downloaded.</P><P>If there is no error, <CODE>psCreateDMJobCollection</CODE> returns a Collection corresponding to the default for the current printer, updated appropriately with hints for a Download Manager job in <CODE>*hintsP</CODE>. This collection is only intended to be passed to the Download Manager and must not be used to update the any saved defaults for a given printer. The caller is responsible for disposing of the collection properly.</P><A NAME="filedownload"></A><H4>File Download Example</H4><P>For a Download Manager client such as the Desktop Printing software, downloading a file is fairly straightforward. The following example illustrates the basics:</P> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>#include &quot;DownloadMgrLib.h&quot;#include &quot;ClientSample.h&quot; // included with Sample codeOSStatus DownloadFile(const FSSpec *driverFSSpecP,     const FSSpec *fsSpecToDownloadP,     Handle papaHandle){/*</pre></TD></TR></TABLE></CENTER><BR><BR><P><CODE>driverFSSpecP</CODE> is a pointer to the <CODE>FSSpec</CODE> for the PostScript driver for the target DTP. It does NOT have to be the current system printer driver.</P><P><CODE>fsSpecToDownloadP</CODE> is a pointer to the <CODE>FSSpec</CODE> for the file to download.</P><P><CODE>papaHandle</CODE> is a handle to the <CODE>PAPA</CODE> for the target output device. It does not have to be the current <CODE>PAPA</CODE> contained in the driver corresponding to <CODE>driverFSSpecP</CODE>, nor will this routine change that driver's current <CODE>PAPA</CODE>.</P> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>*/ OSStatus err = noErr; Str255 errReason; Collection hints = NULL; Boolean canDownload; DownloaderInfo downloaderInfo; DownloadDocumentInfo downloadDocumentInfo; /* We'll get our hints collection for use with this job. */ err = psCreateDMJobCollection(driverFSSpecP, papaHandle,    fsSpecToDownloadP, &amp;hints); // check to see if the Download Manager can download the file if(!err)err = psCanDownloadFile(fsSpecToDownloadP, hints,    papaHandle, &amp;canDownload, &amp;downloaderInfo,    errReason); // get the information about the document if(!err &amp;&amp; canDownload){  downloadDocumentInfo.version = 1; // set the version  err = psGetDownloadDocumentInfo(fsSpecToDownloadP,    hints, &amp;downloaderInfo, &amp;downloadDocumentInfo,    errReason);  if(!err){  // do whatever we need with the document information  // we gathered in psGetDownloadDocumentInfo  } }else  // DM couldn't download the file so we'll set our  // our client's private iDMCantDownloadData error code  // to tell the caller of this routine that the DM  // couldn't handle the data  err = iDMCantDownloadData; if(!err){  // idleProc is a Universal Proc Ptr to our status  // idle routine downloadIdle  StatusIdleProcUPP idleProc = MakeProcPtr(downloadIdle,StatusIdleProcUPP);  DialogPtr dialog = GetNewDialog(STATUSDIALOG_ID, NULL,       (WindowPtr)-1);  if(dialog){   ShowWindow(dialog);   DrawDialog(dialog);  }  else   err = ResError();  if(!err){   ClientParams ourIdleParams;   ourIdleParams.statusDialog = dialog;   err = psDownloadFile(fsSpecToDownloadP,    hints, papaHandle, &amp;downloaderInfo,    idleProc, &amp;ourIdleParams, errReason);  }  if(dialog)DisposeDialog(dialog); } if(hints)DisposeCollection(hints); // if we return the error code iDMCantDownloadData then // the caller will assume that the DM couldn't handle // the data and will take alternative action, i.e. launch // the application with a print event return err;}</pre></TD></TR></TABLE></CENTER><BR><BR><P>The code example assumes that we've defined a routine <CODE>downloadIdle</CODE> to handle the status idle calls and that the routine <CODE>MakeProcPtr</CODE> creates a universal procedure pointer of type <CODE>StatusIdleProcUPP</CODE> to be used by the Download Manager to call the client's downloadable routine.</P><P>The code example uses stack allocation for the <CODE>errReason</CODE>, <CODE>downloaderInfo</CODE>, and <CODE>downloadDocumentInfo</CODE> variables. Developers who are concerned about stack space usage may wish to allocate these variables dynamically.</P><BR><P><A HREF = "#top">Back to top</a></p><A NAME="section1-4"></A><H3>Downloading Streams</H3><P>Some Download Manager clients may have data which is not in a file, but is instead supplied in another fashion. Other clients may want to direct the output to something other than a Desktop Printer and receive the converted PostScript output data directly. In these cases, the client provides an input stream for reading the data to convert and an output stream to which the Download Manager and the low-level converters write.</P><H4>psCanDownloadStream</H4><P>Note that the details of the <CODE>PSStream</CODE> data type are discussed in detail in the section <A HREF = "#section2-1">Streams Information</A> in Section 2.</P> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus psCanDownloadStream(PSStream *stream, OSType type,  Collection hints, Boolean *doDownload,  DownloaderInfo *downloaderInfoP, Str255 errReason);</pre></TD></TR></TABLE></CENTER><BR><BR><P>This function is similar to the <CODE>psCanDownloadFile</CODE> routine except that, instead of supplying an <CODE>FSSpec</CODE>, the caller provides a stream for reading the data and the type of the data. Here, the type of the data is the same as the Finder Type would be if the data were stored in a file. When using this call, the client guarantees that the stream is a stream type that can be positioned by users of the stream (see the section <A HREF = "#section2-1">Streams Information</A> in Section 2 for more information about positioning a stream). That is, the Download Manager and the converter modules it calls are able to rewind or otherwise reposition the stream as necessary.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Even if an error occurs, <code>errReason</code> may contain a zero-length string.</p></TD></TR></TABLE></CENTER><BR><BR><H4>psCanDownloadData</H4><P>If the client has data that allows it to be read only once, the <CODE>psCanDownloadData</CODE> routine must be used instead:</P> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre> OSStatus psCanDownloadData(Str15 firstBytes, OSType type, <BR>  Collection hints, Boolean *doDownload, <BR>  DownloaderInfo *downloaderInfoP, Str255 errReason);<BR></pre></TD></TR></TABLE></CENTER><BR><BR><P>This function is similar to the <CODE>psCanDownloadStream</CODE> routine except that the caller provides the first 15 bytes of the data in the <CODE>firstBytes</CODE> parameter. The Download Manager uses <CODE>firstBytes</CODE> and the type of data to determine which, if any, converter module best handles the download. This routine is provided for clients who cannot provide a stream which can be repositioned. Note that a number of low-level converters may be completely excluded when using this type of stream.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR> Even if an error occurs, <code>errReason</code> may contain a zero-length string.</p></TD></TR></TABLE></CENTER><BR><BR><H4>psDownloadStream</H4> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre> OSStatus psDownloadStream(PSStream *inputStream,  PSStream *outputStream, Collection hints,  const DownloaderInfo *downloaderInfoP,  Str255 errReason);</pre></TD></TR></TABLE></CENTER><BR><BR><P>This function is similar to <CODE>psDownloadFile</CODE> except the client is responsible for providing both the data input stream and the output stream for the converted data. If <CODE>inputStream</CODE> is of a type that can be rewound, the Download Manager calls the <CODE>psLowPeekConvert</CODE> routine of the low-level converter used for the download; otherwise, it does not. The Download Manager queries the output stream using <CODE>outputStream</CODE> only if the hints collection contains the <CODE>kHintDownloaderDoQueryTag</CODE> hint with value true; if it doesn't, the creator of the stream is responsible for handling any queries and supplying their results in the hints collection. If the Download Manager does not perform the queries, a low-level converter does not have the opportunity to specify any queries.</P><P>A careful reader will notice that the <CODE>psCanDownloadStream</CODE> call does not have <CODE>StatusIdleProc</CODE> or <CODE>clientIdleParams</CODE> arguments. Because the Download Manager creates input and output streams for <CODE>psDownloadFile</CODE>, it knows how and when to extract data from those streams for the call to the client's <CODE>idleProc</CODE>. Since the client supplies these streams to the <CODE>psDownloadStream</CODE> call, the client is responsible for ensuring that the stream callback routines allow the client to give itself status information and other applications processing time.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR> Even if an error occurs, <CODE>errReason</CODE> may contain a zero-length string.</p></TD></TR></TABLE></CENTER><BR><BR><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR> The Download Manager and its low-level converters may change the current port and <CODE>gDevice</CODE> at the time of their operation. Therefore the current <CODE>grafPort</CODE> and <CODE>gDevice</CODE> at the time the client's stream routines are called is not guaranteed. Clients which require a specific <CODE>grafPort</CODE> and <CODE>gDevice</CODE> are responsible for setting that port in their stream routine's equivalent of the <code>idleProc</code> code. This also applies to the current resource chain: new resource files may be opened and added to the resource chain by the Download Manager and its low-level converters. In addition, an <code>idleProc</code> must preserve the resource chain. If you change the resource chain in your <code>idleProc</code>, you must save and  restore the resource chain using <code>CurResFile</code> and <code>UseResFile.</code></p></TD></TR></TABLE></CENTER><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR> The streams passed into the <CODE>psCanDownloadStream</CODE>, <CODE>psCanDownloadData</CODE> and <CODE>psDownloadStream</CODE> functions have functions which are called by the Download Manager and the low-level converters. The callers of these functions are doing so using CFM-calling conventions and assume that the code they are calling is of the same architecture as the machine. This forces the following constraint: these functions must be PPC native on PPC machines and 68k code on 68k machines. More unusual is the requirement that these routines must obey CFM-calling conventions on 68k machines, which means they must be contained in a CFM library on both 68k and PPC machines.</p></TD></TR></TABLE></CENTER><BR><BR><BR><P><A HREF = "#top">Back to top</a></p><A NAME="section1-5"></A><H3>Additional Utility Functions</H3><H4>psGetDownloadMgrLibVersion</H4><P>The Download Manager provides an additional call for use by its clients:</P> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre> OSStatus psGetDownloadMgrLibVersion(CFMVersion *version); </pre></TD></TR></TABLE></CENTER><BR><BR> <P>The <CODE>psGetDownloadMgrLibVersion</CODE> routine allows clients and low-level converters to determine CFM version data for the Download Manager library. The <CODE>CFMVersion</CODE> structure is defined as follows:</P> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre> typedef struct CFMVersion{  long definition;  long implementation;  long current; }CFMVersion;</pre></TD></TR></TABLE></CENTER><BR><BR><P>Readers familiar with the Code Fragment Manager will notice that this information mirrors the version information built into a CFM library. Unfortunately, in some versions of the system software, the <CODE>GetDiskFragment</CODE> routine has a bug that won't allow it to load a library unless the definition, implementation, and current version numbers built into the library are all <CODE>0</CODE>. To work around this bug, the Download Manager must all have these version numbers set to zero. To make it possible for a client of the Download Manager to determine the actual version information of the Download Manager, this call returns the version information for the Download Manager.</P><P>The Download Manager API does not contain any information about how to determine the location of the plug-ins folder that it uses for its plug-in converters. See <A HREF = "tn1170.html">Technote 1170: The Printing Plug-ins Manager</A> for more information about calls relating to the "Printing Plug-ins" folder.</P>         <BR><P><A HREF = "#top">Back to top</a></p><A NAME="Section2"></A><H2>Section 2</H2><P>This section describes the public interface to the low-level converters that the Download Manager calls to perform the data conversion portion of the download. Developers writing programs which only invoke the Download Manager to download files to a desktop printer do not need to read this section to understand how to call the Download Manager.</P><H2>Low-level Converter APIs</H2><P>This section describes the APIs that the Download Manager uses to call the low-level converters that it knows about. The Download Manager knows about the built-in converters (a set of shared libraries built into PrintingLib) as well as converter modules in the "Printing Plug-ins" folder in the Extensions folder. Files containing converter module plug-ins must contain a resource of type 'PLGN', ID -8192 with the plug-in type 'down' and subtype '????'. Details of the PLGN resource are described in <A HREF = "tn1170.html">Technote 1170: The Printing Plug-ins Manager</A>.</P><BR><P><A HREF = "#top">Back to top</a></p><A NAME="section2-1"></A><H3>Streams Information</H3><P>Low-level converters don't know where the data they are converting comes from, nor do they know the ultimate destination of their PostScript output data. Instead, they read the data from input procedures and write data to output procedures. These procedures are packed into structures called streams.</P><H4>PSStream structure</H4><P>The low-level converters read and write data from stream structures of type <CODE>PSStream</CODE>. <CODE>PSStream</CODE> is defined as:</P> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef struct PSStream{ PSStreamType type;    // The type of Stream, used to pick      // from the union below. void *reserved;       // For use by the stream implementation. union{  PSReservedStreamType1 null;  PSReservedStreamType2 spool;  PSSerialStream ps;  PSRandomAccessStream file; }u;}PSStream;The PSStreamType is defined as:typedef enum{ kReservedStreamType1, kReservedStreamType2, kPSSerialStream,      //For streams that can not be positioned. kPSRandomAccessStream //For streams that can be positioned.}PSStreamType;The PSSerialStream and PSRandomAccessStream are defined as:typedef struct{ PSOutProc write;      // output proc PSInProc read;        // input proc UInt32 reserved;      // reserved PSPosition pos;       // structural info about where we are      // in the PostScript stream}PSSerialStream;typedef struct{ PSSerialStream serialStream; PSGetPosProc getPos; PSSetPosProc setPos; PSGetEOFProc getEOF;}PSRandomAccessStream;    </pre></TD></TR></TABLE></CENTER><BR><BR><P>The <CODE>PSRandomAccessStream</CODE> stream has the same callbacks and data as the <CODE>PSSerialStream</CODE>, but it also has functions to get the current stream position, set the current stream position and get the size of the file.</P><P>The read and write procedures of the <CODE>PSSerialStream</CODE> and <CODE>PSRandomAccessStream</CODE> types are used to read data from and write data to the stream. They are declared as follows:</P> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef OSStatus (*PSInProc)(PSStream *psStream,    void *data, SInt32 *nBytes);</pre></TD></TR></TABLE></CENTER><BR><BR><P>The read field of the <CODE>PSSerialStream</CODE> structure contains a function of type <CODE>PSInProc</CODE> which is used to read data from the stream. The <CODE>psStream</CODE> parameter is a pointer to the stream being read. The data parameter is a pointer to a client-supplied buffer into which the data is read. The caller sets <CODE>*nBytes</CODE> to the number of bytes to read into the data buffer. It is up to the caller to ensure that the data buffer it supplies has enough room for <CODE>*nBytes</CODE> of data. After the function call, <CODE>*nBytes</CODE> contains the number of bytes actually read.</P> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef OSStatus (*PSOutProc)(PSStream *psStream,    const void *data, SInt32 nBytes);</pre></TD></TR></TABLE></CENTER><BR><BR><P>The <CODE>write</CODE> field of the <CODE>PSSerialStream</CODE> structure contains a function of type <CODE>PSOutProc</CODE> which is used to write data to the stream. The <CODE>psStream</CODE> parameter is a pointer to the stream being written to. The data parameter is a pointer to the data to be written to the stream. The <CODE>nBytes</CODE> parameter specifies the number of bytes to be written.</P><P>The <CODE>PSInProc</CODE> routine of the input stream is used by the low-level converter to read and examine the data to be converted to determine if it can handle this data stream. During the <CODE>psLowPeekConvert</CODE> and <CODE>psLowDoConvert</CODE> calls (described below), the low-level converter calls the <CODE>PSOutProc</CODE> routine of the <code>input</code> stream to give time and status to the client. The <CODE>PSPosition</CODE> structure is used to pass Document Structuring Conventions data and status information back to the client <CODE>idleProc</CODE>.</P><P>When actually converting data, a low-level converter is passed an output stream of type <CODE>kPSSerialStream</CODE> for it to write the converted data. The converter uses the <CODE>PSOutProc</CODE> of the output stream to write its converted data to the output device (or file). It reads data returned from the output device back channel via the <CODE>PSInProc</CODE> of the <code>output</code> stream. It writes the data read from the back channel to the <CODE>PSOutProc</CODE> of the input stream, allowing the Download Manager to report any status information coming from the back channel.</P><P>Note that some output streams have no <CODE>PSInProc</CODE> routine (such as a print to file stream). The <CODE>PSInProc</CODE> routine in an output stream should be tested for <CODE>NULL</CODE> before calling the procedure.</P><BR><P><A HREF = "#top">Back to top</a></p><A NAME="section2-2"></A><H3>Additional functions for random-access streams</H3><P>Streams of type <CODE>kPSRandomAccessStream</CODE> have additional procedures available:</P><P>The <CODE>PSGetPosProc</CODE> procedure determines the current position of the mark in the stream corresponding to the file (or file-like stream). This position is based on the last data read from the stream, not the underlying file since the data may be buffered. The prototype for this function is:</P> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef OSStatus (*PSGetPosProc)(PSStream *psStream,     SInt32 *currentPos);     </pre></TD></TR></TABLE></CENTER><BR><BR> <P>The <CODE>psStream</CODE> parameter points to the stream whose position you want to obtain; the value of <CODE>*currentPos</CODE> returned is the current stream position.</P><P>The position value is zero-based; that is, the value of <CODE>*currentPos</CODE> is 0 if the stream position mark is positioned at the beginning of the stream.</P><P>The <CODE>PSSetPosProc</CODE> procedure sets the position of the stream mark. The next data read from the stream is the first byte after the stream mark.</P> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef OSStatus (*PSSetPosProc)(PSStream *psStream,     SInt32 positionMode, SInt32 posOffset);</pre></TD></TR></TABLE></CENTER><BR><BR> <P>For the <CODE>PSSetPosProc</CODE> call, the <CODE>positionMode</CODE> is the positioning mode and <CODE>posOffset</CODE> is the positioning offset. The <CODE>positionMode</CODE> parameter indicates how to position the mark; it must contain one of the following values:</P> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>enum{ fsFromStart = 1, //set mark relative to beginning of stream fsFromLEOF = 2,  //set mark relative to logical end-of-stream fsFromMark = 3   //set mark relative to current mark};</pre></TD></TR></TABLE></CENTER><BR><BR><P>The <CODE>positionMode</CODE> parameter works like the Macintosh file system call <CODE>SetFPos</CODE>. These supported values of the <CODE>positionMode</CODE> constants are defined in the Macintosh header file "Files.h." These constants let you position the mark relative to either the beginning of the file, the logical end-of-file, or the current mark. You must also pass in <CODE>posOffset</CODE>, a byte offset (either positive or negative) from the specified point. If you specify <CODE>fsFromLEOF</CODE>, the value in <CODE>posOffset</CODE> must be less than or equal to 0.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR> If a low-level converter uses the <CODE>PSSetPosProc</CODE> to reposition the stream to a new position before that of the previous stream position during the call <CODE>psLowDoConvert</CODE>, the Download Manager cannot determine the percentage progress of the download and it will report that the percentage progress is unknown for the remaining duration of the download.</p></TD></TR></TABLE></CENTER><BR><BR><P>The <CODE>PSGetEOFProc</CODE> procedure is used to determine the size of the stream. Not all streams which can be positioned have a procedure which can determine the size. When using a stream of type <CODE>kPSRandomAccessStream</CODE>, it is important for the user of a stream to verify that the <CODE>PSGetEOFProc</CODE> procedure pointer is not <CODE>NULL</CODE> before calling it.</P> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef OSStatus (*PSGetEOFProc)(PSStream *psStream,     SInt32 *streamSize);    </pre></TD></TR></TABLE></CENTER><BR><BR><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR> low-level converters should be prepared to handle input streams that do not allow random access, i.e., are not of type <CODE>kPSRandomAccessStream</CODE>. If a given converter cannot handle such a stream, it should properly advertise itself as unable to download such a stream. See the <A HREF = "#section2-3">discussion for <CODE>psLowCanConvert</CODE> and <CODE>psLowGetConverterInformation</CODE> below</A>.</p></TD></TR></TABLE></CENTER><BR><BR><P>One additional comment about the streams used by the Download Manager and the low-level converters is that they each call stream routines as native code, without using <CODE>CallUniversalProc</CODE>. In addition to requiring the stream functions to be native code, this also means that these functions must obey CFM-calling conventions, even on 68k machines.</P><BR><P><A HREF = "#top">Back to top</a></p><A NAME="section2-3"></A><H3>Low-level Converting Routines</H3><P>When a client such as the Desktop Printing software calls the Download Manager routine <CODE>psCanDownloadFile</CODE>, the Download Manager uses the first 15 bytes of the file and its <CODE>OSType</CODE> to see which low-level converters can potentially handle the download. The Download Manager then calls the <CODE>psLowCanConvert</CODE> routine for each of those converters. This gives each of those converters an opportunity to examine the input data and determine if the converter can handle it.</P> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre> OSStatus psLowCanConvert(PSStream *inputStreamP,  Collection hints, LowConverterInfo *dataInfoP,  Fixed *priority);</pre></TD></TR></TABLE></CENTER><BR><BR><P>The <CODE>*inputStreamP</CODE> parameter is a pointer to a stream of <CODE>PSStreamType</CODE>, <CODE>kPSRandomAccessStream</CODE>, or <CODE>kPSSerialStream</CODE>. The low-level converter calls the <CODE>PSInProc</CODE> of <CODE>inputStreamP</CODE> to obtain the data.</P><P><CODE>hints</CODE> is a collection passed to the low-level converter for use during its attempt to determine if it can download the file. It may contain information about the "job" being downloaded that is useful for the low-level converter. The low-level converter should not add or change any hints in the hints collection during the <CODE>psLowCanConvert</CODE> call since other low-level converters might be affected by such changes.</P><P><CODE>dataInfoP</CODE> is a pointer to a <CODE>LowConverterInfo</CODE> structure. It is used by the low-level converter to help determine if the data/file is a type that it can handle.</P> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre> typedef struct LowConverterInfo{  UInt32 version;  OSType type; }LowConverterInfo;</pre></TD></TR></TABLE></CENTER><BR><BR><P>The version field of the <CODE>LowConverterInfo</CODE> structure is 1 for the first version of the Download Manager. The type field is the <CODE>OSType</CODE> of the data supplied to the low-level converter.</P><P><CODE>*priority</CODE> is a fixed number filled in by the <CODE>psLowCanConvert</CODE> call. Values greater than zero indicate that the converter can handle the stream. The larger the number, the more suitable the converter is for the data. Currently a value of 10 <CODE>(0x000A0000 Fixed)</CODE> indicates the converter is the best converter possible for the given data. Since the Download Manager simply looks for the 'best" result, a new converter could advertise itself as having a larger value to become the favored converter for a given type of data. (Remember that Nigel's amplifier can be set to 11.)</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR> The low-level converters in the "Printing Plug-ins" folder with a given priority are chosen over a converter that is built into PrintingLib which claims the same priority. This allows an external converter in the Printing Plug-in's folder to override a built-in converter.</p></TD></TR></TABLE></CENTER><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR> It is unfortunate that for some downloads we don't always know about the output device when <CODE>psCanDownloadFile</CODE> is called. For example a JPEG converter could always download non-progressive JPEG data to a Level 2 printer, even if QuickTime isn't available on the host. Since we might not know the PostScript level of the output device, we don't know if we need QuickTime. If the client does know the printer is a Level 2 printer, specifying that would let the low-level converter know it doesn't need QuickTime. The best we can do with this design is for the client to supply in the hints collection the best information it has about the output device and let the low-level converter decide what it can do based on that information plus the input stream data.</p></TD></TR></TABLE></CENTER><BR><BR><P>Once the Download Manager establishes the best converter for the job (i.e., the one returning the highest priority), the <CODE>psCanDownloadFile</CODE> routine returns and if the file is downloadable, the Download Manager client calls the Download Manager routine <CODE>psDownloadFile</CODE> to download the file.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR> low-level converters should be prepared to handle input streams that do not allow random access, i.e., are not of type <CODE>kPSRandomAccessStream</CODE>. If a given converter cannot handle such a stream, it should return a priority of 0 if <CODE>psLowCanConvert</CODE> is called with a different stream type.</p></TD></TR></TABLE></CENTER><BR><BR><BR><P><A HREF = "#top">Back to top</a></p><A NAME="section2-4"></A><H3>Getting Information For A Client</H3><P>When a Download Manager client calls the Download Manager routine <CODE>psGetDownloadDocumentInfo</CODE>, the Download Manager asks the low-level converter to obtain the document information by calling the low-level converter's <CODE>psLowGetStreamInfo</CODE> routine.</P> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus psLowGetStreamInfo(PSStream *inputStreamP, Collection hints, DownloadDocumentInfo *downloadDocInfoP);</pre></TD></TR></TABLE></CENTER><BR><BR><P><CODE>*inputStreamP</CODE> represents the stream of data to gather information from. The low-level converter calls the <CODE>PSInProc</CODE> of <CODE>inputStreamP</CODE> to obtain the data.</P><P><CODE>hints</CODE> is a collection passed into the low-level converter for its use during the information gathering. It may contain information about the "job" being downloaded that is useful for the low-level converter during this phase. During a call to <CODE>psLowGetStreamInfo</CODE>, a low-level converter can add or change hints in the hints collection. Collection tag values used by LaserWriter 8/PrintingLib are reserved but can be used by a low-level converter for their normal, intended purpose.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR> If a converter wants to have private hints, it should use the collection tag 'APPL' with a collection ID value identical to its assigned application creator. This ensures that private hints will not collide with other software's hints.</p></TD></TR></TABLE></CENTER><BR><BR><P>The updated hints collection returned from <CODE>psLowGetStreamInfo</CODE> may or may not be passed by the Download Manager and its clients to the other low-level converter calls <CODE>psLowPeekConvert</CODE>, <CODE>psLowAddConverterQueries</CODE>, and <CODE>psLowDoConvert</CODE> (see the description of <CODE>psGetDownloadDocumentInfo</CODE> in Section 1). A low-level converter should not require any data it adds to the hints collection in the <CODE>psLowGetStreamInfo</CODE> routine being available during any other low-level converter call.</P><P><CODE>*downloadDocInfoP</CODE> is a pointer to a <CODE>DownloadDocumentInfo</CODE> structure (described above in Section 1) to be filled in by the low-level converter. This structure is initialized by the Download Manager to correspond to unknown values for each field. If the low-level converter does not know the information corresponding to a given field, it should not fill in that field.</P><BR><P><A HREF = "#top">Back to top</a></p><A NAME="section2-5"></A><H3>Peeking at the Data</H3><P>When a Download Manager client calls the Download Manager routines <CODE>psDownloadFile</CODE> or <CODE>psDownloadStream</CODE>, the Download Manager determines if it can allow the low-level converter the opportunity to peek at the data before doing the conversion. If the stream is of a type that can be repositioned (i.e., type <CODE>kPSRandomAccessStream</CODE>), the Download Manager calls the <CODE>psLowPeekConvert</CODE> routine of the low-level converter. With a stream that cannot be repositioned, the act of peeking would prevent the stream from being converted.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR> If the client adds the hint <CODE>kHintDownloaderPeekTag</CODE> with a value of false, the Download Manager will not call <CODE>psLowPeekConvert</CODE> regardless of whether the stream supports peeking.</p></TD></TR></TABLE></CENTER><BR><BR> <CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre> OSStatus psLowPeekConvert(PSStream *inputStreamP,  Collection hints);  </pre></TD></TR></TABLE></CENTER><BR><BR><P>This routine is called by the Download Manager to allow the low-level converter an opportunity to look at the data to be downloaded and thereby collect useful information. Such information might be collected to provide information back to the Download Manager for reporting to the Download Manager client (such as fonts used in a document, etc). Other information might be collected by the low-level converter for passing back to itself when it is later asked to "convert" and download the document with the <CODE>psLowDoConvert</CODE> call (described in the section Doing the Conversion below). For example, a PostScript converter might read DSC comments to determine what fonts the document requires as part of the download.</P><P><CODE>*inputStreamP</CODE> represents the stream of data to peek at. The low-level converter calls the <CODE>PSInProc</CODE> of <CODE>inputStreamP</CODE> to obtain the data.</P><P><CODE>hints</CODE> is a collection passed into the low-level converter for its use during peeking. It may contain information about the "job" being downloaded that is useful for the low-level converter during the peek phase. During a call to <CODE>psLowPeekConvert</CODE>, a low-level converter can add or change hints in the hints collection. Collection tag values used by LaserWriter 8/PrintingLib are reserved but can be used by a low-level converter for their normal, intended purpose.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR> If a converter wants to have private hints, it should use the collection tag 'APPL' with a collection ID value identical to their assigned application creator. This ensures that private hints will not collide with other software's hints.</p></TD></TR></TABLE></CENTER><BR><BR><P>The updated hints collection returned from <CODE>psLowPeekConvert</CODE> is passed by the Download Manager to the low-level converter calls <CODE>psLowAddConverterQueries</CODE> and <CODE>psLowDoConvert</CODE> (described in the sections Queries and Doing the Conversion respectively). By adding private hints to the collection during the peek phase, a low-level converter can pass itself this information when the Download Manager calls the <CODE>psLowAddConverterQueries</CODE> and <CODE>psLowDoConvert</CODE> routines.</P><P>Examples of data put into the hints during the peek phase by a low-level converter might be:</P><UL TYPE=DISC>    <LI>Font requirement data based on %%DocumentNeededResources comments in a PS file</li>    <LI>DSC information such as "user", "pages", "creator", etc.</li>    <LI>Information about the procedure sets required, such as those required by a PICT converter</li>    <LI>Bounding Box information for handling EPS data</li></UL><P>While a low-level converter should always be prepared to handle the fact that a peek pass may not be made, it may still find it useful to peek at the data when it is given the chance to do so. This means that a low-level converter should be prepared to operate without data it would normally collect during a possible <CODE>psLowPeekConvert</CODE> call.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR> While a low-level converter is required to implement a <CODE>psLowPeekConvert</CODE> routine, the implemented routine can simply return without doing any examination of the data stream.</p></TD></TR></TABLE></CENTER><BR><BR><BR><P><A HREF = "#top">Back to top</a></p><A NAME="section2-6"></A><H3>Queries</H3><P>When a client makes a call to <CODE>psDownloadFile</CODE>, the Download Manager is responsible for querying the printer and providing the results from the queries to the low-level converter. Prior to any queries performed by the Download Manager, the low-level converter gets a chance to add its queries to the set of queries which the Download Manager will make. A low-level converter can add any or all of the queries currently available through <CODE>PSUtilsLib</CODE>.The low-level converter does not do the query itself, but instead the Download Manager calls the routine <CODE>psLowAddConverterQueries</CODE> supplied by a low-level converter to determine the queries the low-level converter needs.</P> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre> OSStatus psLowAddConverterQueries(Collection hints,   Collection query);</pre></TD></TR></TABLE></CENTER><BR><BR><P>This routine is passed the hints collection for the current job. If the low-level converter routine <CODE>psLowPeekConvert</CODE> was called, the hints collection as returned from that call is passed to <CODE>psLowAddConverterQueries</CODE>. The <CODE>psLowAddConverterQueries</CODE> routine is also passed a query collection so that the low-level converter can add query hints for use by the Download Manager. The low-level converter can use the hints collection to decide whether to add any queries to the query collection. When the <CODE>psLowAddConverterQueries</CODE> routine returns, the Download Manager uses the data in the query collection to query the target output device. The Download Manager copies the results of the queries into the hints collection that is used for the call to <CODE>psLowDoConvert</CODE> (see the section <A HREF = "#section2-7">Doing the Conversion</A> below).</P><H4>Basic Queries</H4><P>Most queries fall into the category of basic queries. Examples of these queries are the PostScript language level, PostScript version information, color or black and white device knowledge, and so forth. Such queries are generated by adding the appropriate hints to the query collection, with default values chosen by the converter for its own conservative handling approach. For example, to cause the Download Manager to query for the PostScript language level, the following code is used:</P> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>kHintLanguageLevelVar langlevel = UnknownLevel;err = AddCollectionItem(queryCollection, kHintLanguageLevelTag,  kHintLanguageLevelId, sizeof(langlevel), &amp;langlevel);</pre></TD></TR></TABLE></CENTER><BR><BR><P>Note here that the default value used is <CODE>UnknownLevel</CODE> so that, if the query is not done (see the section <A HREF = "#using">Using Query Results</A> below), getting this collection item later reflects this default.</P><H4>Font Queries</H4><P>The Download Manager can query for a specific list of fonts or obtain the entire list of fonts available in the target output device. Both of these font queries are specified with the hint <CODE>kHintIncludeFontsTag</CODE> with the ID value <CODE>kHintIncludeFontsId</CODE>. The data contained in this hint determines the type of query. The data is a <CODE>PSFontHandling</CODE> structure, defined as:</P> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef struct { long tag; unsigned char name[1]; //packed array of names,       //length 0 indicates end of list}PSFontHandling;</pre></TD></TR></TABLE></CENTER><BR><BR><BR>and the following constants are defined:<BR><BR> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>enum{ kIncludeNoFontsOtherThan, kIncludeAllFontsBut};</pre></TD></TR></TABLE></CENTER><BR><BR><P>If the tag field of the <CODE>PSFontHandling</CODE> structure is <CODE>kIncludeAllFontsBut</CODE>, the query is for the complete list of fonts (the equivalent of the <CODE>*?FontList</CODE> query from the PPD file). For this flavor of the font query, there should be one name specified whose length is zero. Upon return of the query, the name field will be a packed array of Pascal strings corresponding to the fonts built into the output device. This list of names will be terminated with a Pascal string whose length is zero.</P><P>If the tag field of the <CODE>PSFontHandling</CODE> structure is <CODE>kIncludeNoFontsOtherThan</CODE>, the query is for a specified list of fonts (the equivalent of the <CODE>*?FontQuery</CODE> query from the PPD file). For this flavor of the font query, the list of fonts to query for should be in the name field of the structure. The list is a packed array of Pascal strings and is terminated with a Pascal string with a zero-length byte. After the query, the name field is a packed array of Pascal strings corresponding to the fonts from the query list which were not available, i.e., the fonts available in the output device are removed from the list. Again, this list of names is terminated with a Pascal string with a zero-length byte.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR> It is quite possible that a low-level converter might request a query with a tag of <CODE>kIncludeAllFontsBut</CODE> and the query result may contain a query with a tag of <CODE>kIncludeNoFontsOtherThan</CODE> or vice versa.</p></TD></TR></TABLE></CENTER><BR><BR><H4>Communication Channel Queries</H4><P>A second category of special queries is that for the communication channel characteristics. Most low-level converters will generate different output data if the communication pathway to the target output device supports binary data. There are two hints used to query for whether the output device supports binary data and both should be consulted.</P><P>The first is the hint with tag value <CODE>kHintEighthBitTag</CODE> and ID value <CODE>kHintEighthBitId</CODE>. If the hint value is true, the output stream supports the data range <CODE>0x80-0xFF</CODE> inclusive. If the value is false, the PostScript output stream generated by the low-level converter should not contain these byte values.</P><P>The second is the hint with the tag value <CODE>kHintTransparentChannelTag</CODE> and ID value <CODE>kHintTransparentChannelId</CODE>. If the hint value is true, the output stream supports the data range <CODE>0x00-0x1F</CODE> inclusive. If the value is false, the PostScript output stream generated by the low-level converter should not contain these byte values.</P><P>Normally a low-level converter will add both of these hints to the query collection with default values of false to specify that the Download Manager supply the appropriate query for the channel characteristics. The value for these hints after the query determines the channel characteristics.</P><A NAME="using"></A><H4>Using Query Results</H4><P>A low-level converter receives its query results in the hints collection supplied to the call <CODE>psLowDoConvert</CODE> (see the section <A HREF = "#section2-7">Doing the Conversion</A> below).</P><P>A low-level converter should be prepared to operate without results from a query. Query results can be unavailable in at least two ways. If the Download Manager is invoked using the routine <CODE>psDownloadStream</CODE>, the Download Manager only calls <CODE>psLowAddConverterQueries</CODE> and generates queries if the hints collection contains the <CODE>kHintDownloaderDoQueryTag</CODE> hint with value true. If the Download Manager client handles queries, it would set the <CODE>kHintDownloaderDoQueryTag</CODE> hint to false.</P><P>Another case where queries may not be completed is when the download is to a file without a printer involved or with any communication channel that does not support a backchannel, such as LPR. In that case, some of the queries may be satisfied by PPD data, but others return a default value.</P><BR><P><A HREF = "#top">Back to top</a></p><A NAME="section2-7"></A><H3>Doing the Conversion</H3><P>After the query phase, the Download Manager calls the <CODE>psLowDoConvert</CODE> routine of the low-level converter. This routine is defined as follows:</P> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre> OSStatus psLowDoConvert(PSStream *inputStreamP,  PSStream *outputStreamP, Collection hints);</pre></TD></TR></TABLE></CENTER><BR><BR><P>It is the responsibility of the low-level converter to read the data supplied in the stream pointed to by <CODE>inputStreamP</CODE>, "convert" it into appropriate PostScript language output and write that output to the stream pointed to by <CODE>outputStreamP</CODE>.</P><P><CODE>*inputStreamP</CODE> represents the stream of data to "convert" into PostScript output. The low-level converter calls the <CODE>PSInProc</CODE> of <CODE>inputStreamP</CODE> to read the data from the stream to convert.</P><P><CODE>*outputStreamP</CODE> represents the output stream. The "converted" PostScript output data is written to the <CODE>PSOutProc</CODE> of outputStreamP. This may be a stream communicating with a PostScript printer via PAP or USB, a stream communicating using LPR, a stream to send data to a custom Desktop Printer for further processing, or it may be a stream generating a PostScript output file. The kind of stream used for output is determined by the Download Manager client and the Download Manager; the low-level converter simply writes its PostScript output to this stream.</P><P>The <CODE>outputStreamP</CODE> stream may contain a read procedure of type <CODE>PSInProc</CODE> for returning error messages or other data from a PostScript output device. The low-level converter is responsible for reading this returned data during the download and writing it to the <CODE>PSOutProc</CODE> of <CODE>inputStreamP</CODE>. The <CODE>PSOutProc</CODE> of <CODE>inputStreamP</CODE> is responsible for forwarding this data to the client for further processing. This data may be error messages, return results from the PostScript output device, or device status messages returned from the printer back channel instead of the status channel.</P><P><CODE>PSStreams</CODE> of type <CODE>kPSSerialStream</CODE> and <CODE>PSRandomAccessStream</CODE> have a field of type <CODE>PSPosition</CODE>. This structure is defined as:</P> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef struct PSPosition{ PSSection section;       //filled in by DownloadMgr not converters PSSubsection subsection; //for DSC data obtained by converters void *info;  //for DSC data obtained or generated by//converters SInt32 id;// to be updated appropriately by the caller// filling in any of the other fields}PSPosition;</pre></TD></TR></TABLE></CENTER><BR><BR><P>While processing the data to be converted during <CODE>psLowPeekConvert</CODE> and <CODE>psLowDoConvert</CODE>, a low-level converter uses this structure to pass information about the data being written to (or read from) from the stream. The Download Manager uses this data to pass information to the client's <CODE>StatusIdleProc</CODE> so the client can report the status and progress of the download. If the Download Manager client used the Download Manager function <CODE>psDownloadStream</CODE> and therefore supplied the input and output stream, that client is responsible for handling status in its streams' read and write procedures.</P><P>The hints collection passed to <CODE>psLowDoConvert</CODE> contains information which may be useful for a low-level converter. It might contain information about the output stream characteristics (8-bit, ASCII/binary), data stored into this collection by the low-level converter during the peek phase, query results or other data about the download job that is useful for a low-level converter.</P><P>Since calls to <CODE>psLowDoConvert</CODE> may or may not be preceded by calls to <CODE>psLowPeekConvert</CODE> or <CODE>psLowAddConverterQueries</CODE>, the <CODE>psLowDoConvert</CODE> routine should not rely on hint data collected by <CODE>psLowPeekConvert</CODE> or query results to operate successfully. If data collected by a call to <CODE>psLowPeekConvert</CODE> is present in the hints, <CODE>psLowDoConvert</CODE> may work more efficiently or offer better results than if it is not present, but it should work regardless.</P>    <P>The following figure attempts to illustrate the way the input and output streams are used by a low-level converter during the call to <CODE>psLowDoConvert</CODE>:</P><p align="center"><img src="images/tn1169_002.gif" alt="" width=468 height=131></p><BR><P><A HREF = "#top">Back to top</a></p><A NAME="section2-8"></A><H3>Converter Capabilities</H3><P>At various times, the Download Manager determines what low-level converters are available and then determines what file types each low-level converter can potentially handle. It does this by calling the <CODE>psGetConverterInformation</CODE> routine of each low-level converter.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre> OSStatus psLowGetConverterInformation(  const ConverterDescription* *theConverterDescription);</pre></TD></TR></TABLE></CENTER><BR><BR><P>The <CODE>psGetConverterInformation</CODE> routine returns information about the converter. The <CODE>ConverterDescription</CODE> structure is loosely modeled after the <CODE>DriverDescription</CODE> structure used for PCI Drivers. The <CODE>ConverterDescription</CODE> structure is defined as follows:</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef struct ConverterDescription { OSType converterDescSignature; ConverterDescVersion converterDescVersion; ConverterType converterType; ConverterService converterService;}ConverterDescription;</pre></TD></TR></TABLE></CENTER><BR><BR>    <P>The first field in the <CODE>ConverterDescription</CODE> structure is a signature long word designating this to be a converter description structure.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>enum { kTheConverterDescriptionSignature = 'dhwu' /*first long word of ConverterDescription*/};</pre></TD></TR></TABLE></CENTER><BR><BR><P>The second long word of the <CODE>ConverterDescription</CODE> structure indicates the version of the structure being used. This is used to distinguish different versions of converter descriptions which have the same signature but different values. This is defined as follows:</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef UInt32 ConverterDescVersion;enum { kInitialConverterDescriptor = 0  /* the initial version of ConverterDescription   supported by the Download Manager  */};</pre></TD></TR></TABLE></CENTER><BR><BR><P>The next field of the <CODE>ConverterDescription</CODE> is the <CODE>converterType</CODE>. This structure contains name and information string data as well as the converter module version information. It is defined as:</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef struct ConverterType{ Str31  name; Str255 info; NumVersion version;}ConverterType;typedef struct NumVersion{ UInt8 majorRev; /*1st part of version number in BCD*/ UInt8 minorAndBugRev; /*2nd and 3rd part of version number share a byte*/ UInt8 stage; /*stage code: dev, alpha, beta, final*/ UInt8 nonRelRev; /*rev level of nonreleased version*/}NumVersion;</pre></TD></TR></TABLE></CENTER><BR><BR>    <P>The final field in the <CODE>ConverterDescription</CODE> structure is a <CODE>ConverterService</CODE> structure which contains information about what types of data the converter can potentially handle. This is defined as:</P> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef struct ConverterService{ UInt32 nTypes; ConverterTypeInfo typeInfo[1];}ConverterService;typedef struct ConverterTypeInfo{ OSType type; Fixed priority; Str15 matchString;}ConverterTypeInfo;</pre></TD></TR></TABLE></CENTER><BR><BR><P>A given converter may be able to handle a number of different <CODE>OSType</CODE> data and/or different data types. The <CODE>nTypes</CODE> field is the number of different <CODE>ConverterTypeInfo</CODE> structures contained in the <CODE>ConverterService</CODE>.</P><P>The type field of the <CODE>ConverterTypeInfo</CODE> structure is the <CODE>OSType</CODE> of data described by the <CODE>ConverterTypeInfo</CODE>. If the converter can handle any type, it should include the type <CODE>'****'</CODE> (i.e., the wildcard type) with the appropriate <CODE>matchString</CODE>.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR> A given low-level converter may have more than one <CODE>ConverterTypeInfo</CODE> for a given type. This would occur if there was more than one priority, <CODE>matchString</CODE> pair appropriate for a given data type.</p></TD></TR></TABLE></CENTER><BR><BR><P>The <CODE>matchString</CODE> field is a Pascal string of at most 15 bytes (plus a length byte) corresponding to any identification bytes the converter requires at the beginning of the data. For example, a PostScript converter requires the identification data "%!" to be the first 2 bytes of data to be downloaded. If, for a given converter, none of the first (up to 15) bytes are distinctive for the <CODE>OSType</CODE> of the <CODE>ConverterTypeInfo</CODE>, the length of the <CODE>matchstring</CODE> should be set to 0. This indicates to the Download Manager that this <CODE>OSType</CODE> does not have a magic identification string.</P><P>The Download Manager uses the <CODE>ConverterTypeInfo</CODE> data to pare down the list of candidate low-level converters which can be used to download the data. It does this by looking at the first 15 bytes of data and uses the <CODE>ConverterTypeInfo</CODE> data to determine which low-level converters may support the data. After paring down the list with this information, it normally calls the <CODE>psLowCanConvert</CODE> routine of the candidate low-level converters to allow further examination of the data.</P><P>In some cases the <CODE>psLowCanConvert</CODE> routine of the candidate low-level converters cannot be called. This is the case where the data is supplied from a stream which cannot be repositioned or randomly accessed. In these cases, the Download Manager uses the priority field of the <CODE>ConverterTypeInfo</CODE> data to determine whether the low-level converter can handle the data.</P><P>The <CODE>priority</CODE> field in a <CODE>ConverterTypeInfo</CODE> structure is a <CODE>Fixed</CODE> number which is the priority estimate of the converter for handling the type of data described by the type <CODE>field</CODE> and the <CODE>matchString</CODE>. This priority is used by the Download Manager when only the <CODE>matchString</CODE> and type of the data are available for determining whether a converter can handle the download. In all other cases, the Download Manager calls the <CODE>psLowCanConvert</CODE> function with a stream that the low-level converter reads to determine whether it can handle the data. For this reason, the priority returned here should be the priority that the converter can guarantee based only on the <CODE>OSType</CODE> and the <CODE>matchString</CODE> data. If a converter requires more than the 15 bytes <CODE>matchString</CODE> to be certain it can handle the data or a <CODE>matchString</CODE> of 0 is provided, the priority should be <CODE>0x0</CODE> (i.e., can't convert without looking at more data).</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR> If the converter cannot handle a stream which cannot be randomly accessed, it should assign a priority of <CODE>0x0</CODE> for that <CODE>OSType</CODE> in the <CODE>ConverterTypeInfo</CODE>.</p></TD></TR></TABLE></CENTER><BR><BR><P>As an example, here is a sample <CODE>ConverterDescription</CODE> structure for a hypothetical converter module which "converts" a PostScript input stream to a PostScript output stream:</P> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>ConverterDescription TheConverterDescription ={ // signature information kTheConverterDescriptionSignature,     // signature always first kInitialConverterDescriptor,// version // type information {  &quot;\pPostScript Downloader.&quot;, // name  &quot;\pThis converter module sends PostScript code to a&quot;  &quot;PostScript printer.&quot;,      // info string  0x1,0x0,0x40,0x2,    // Rev 1.0.0a2 },<BR> // ConverterServices {  3, //# of ConverterTypeInfo structures  {   {    'TEXT',// file type    0x000A0000,        // priority hint    &quot;\p%!&quot;   // match string   },   {    'EPSF',// file type    0x000A0000,        // priority hint    &quot;\p%!&quot;   // match string   },   {    '????',// file type    0x000A0000,        // priority hint    &quot;\p%!&quot;   // match string   }  } }};</pre></TD></TR></TABLE></CENTER><BR><BR><P>Note that by reporting a non-zero priority hint for each type, this hypothetical converter says that it can operate on a stream that cannot be randomly accessed.</p><P>When the Download Manager calls <CODE>psGetConverterInformation</CODE>, it expects to get back a pointer to a <CODE>ConverterDescription</CODE>. This data is owned by the converter module. If the Download Manager needs to keep any of this data, it must first copy that data before closing the converter module. The pointer returned is declared const indicating that the caller of <CODE>psGetConverterInformation</CODE> must not change the <CODE>ConverterDescription</CODE> data itself since that data is owned by the converter module.</P><P>The converter module is responsible for disposing of any memory it allocates as part of generating the <CODE>ConverterDescription</CODE> returned by <CODE>psGetConverterInformation</CODE>.</P><BR><P><A HREF = "#top">Back to top</a></p><A NAME="section2-9"></A><H3>Utility Functions</H3> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus psLowGetConverterVersion(CFMVersion *version);</pre></TD></TR></TABLE></CENTER><BR><BR><P>The <CODE>psLowGetConverterVersion</CODE> reports the CFM version information for a low-level converter. This information may be used by the Download Manager (or other callers of the low-level converters) to determine version and interface information about a given low-level converter. Though there is no planned usage for this today we have found that it is useful to have this information for other shared libraries used by LaserWriter 8 and PrintingLib.</P><P>Readers familiar with the Code Fragment Manager will notice that this information mirrors the version information built into a CFM library. Unfortunately, in some versions of the system software, the <CODE>GetDiskFragment</CODE> routine has a bug that won't allow it to load a library unless the definition, implementation and current version numbers built into the library are all 0. To work around this bug a low-level converter must all have these version numbers set to zero. To make it possible for a client of a low-level converter to determine the actual version information of that converter, this call returns the version information for that low-level converter.</P><BR><P><A HREF = "#top">Back to top</a></p><A NAME="section2-10"></A><H3>Errors</H3><P><CODE>errInvalidDownloaderInfo</CODE> - This error is returned if the Download Manager is passed a <CODE>DownloaderInfo</CODE> structure that is no longer valid. This can happen if a client obtains a <CODE>DownloaderInfo</CODE> structure from the Download Manager calls <CODE>psCanDownloadFile</CODE>, <CODE>psCanDownloadStream</CODE>, or <CODE>psCanDownloadData</CODE> and later supplies this data to the Download Manager after the set of converter modules in the Printing Plug-ins Folder or PrintingLib itself has changed. This should be rare but could happen if <CODE>DownloaderInfo</CODE> data is persistently stored over a period of time.</P><P><CODE>errCantMakeStreamForDTP</CODE> - This error occurs if the client calls <CODE>psDownloadFile</CODE> with a target <CODE>PAPA</CODE> for which PrintingLib cannot make a stream. This should only happen if the client fails to call <CODE>psCanDownloadFile</CODE> with a <CODE>PAPA</CODE> for the device for which it later calls <CODE>psDownloadFile</CODE>.</P><P><CODE>errCantHandleThisDownloadData</CODE> - This error occurs if at some point in downloading a file or stream, the converter realizes that there is some problem with the data. This might be the situation if the data is corrupt, for example.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR> Other Mac OS errors can also be returned.</p></TD></TR></TABLE></CENTER><BR><BR><BR><P><A HREF = "#top">Back to top</a></p><A NAME="section2-11"></A><H3>Logging</H3><P>The Download Manager can log errors and warnings that might be generated by a low-level converter. The <CODE>PSSubsection</CODE> values of <CODE>kSubLogErrorData</CODE> and <CODE>kSubLogWarningData</CODE> are to be used by a low-level converter (and the Download Manager) to indicate fatal and non-fatal errors which occur during the download process. The Download Manager is responsible for logging this data appropriately. By default, this logging is only turned on in the debug builds of PrintingLib. It can be turned on in a release build by changing the value of the <CODE>doDownloadMgrLogging</CODE> bit in the printing preferences <CODE>PRF2</CODE> resource in PrintingLib.</P><P>The amount of information logged is controlled by the LOGD resource. It is defined by default as:</P> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>resource kDownloadMgrLoggingType (kPreferencesID,#if qNames &quot;Download Manager Logging Preferences&quot;,#endif purgeable) { 32000,    // the maximum file size 4000,     // the maximum amount to preserve// when size is exceeded 'MPS ',   // the log file creator 'TEXT',   // the log file type &quot;Download Manager Log&quot;// the log file name};</pre></TD></TR></TABLE></CENTER><BR><BR><P>When logging is turned on, the log file (default name "Download Manager Log") is created in the user's Printing Prefs folder.</P><BR><P><A HREF = "#top">Back to top</a></p><A NAME="Summary"></A><H2>Summary</H2><P>The Download Manager allows Desktop Printing and other clients to quickly send documents to a PostScript printer. Applications which wish to bypass QuickDraw can call the Download Manager to send data directly to the printer. Also, the types of documents handled by the Download Manager can be extended by third parties creating new "low-level converters." More information on writing low-level converters will be provided in a separate Technote.</P><BR><P><A HREF = "#top">Back to top</a></p><a name="References"></a><H2>References</H2>    <p>Print Hints: The All-New LaserWriter Driver Version 8.4, <I>develop</I> 27</p>    <p><A HREF = "tn1112.html">Technote 1112: Introducing the LaserWriter Driver Version 8.5.1</A></p>    <p><A HREF = "tn1143.html">Technote 1143: Introducing the LaserWriter 8 Driver Version 8.6</A></p>    <p><A HREF = "tn1165.html">Technote 1165: Introducing the LaserWriter 8 Driver Version 8.6.5</A></p>    <p><A HREF = "tn1170.html">Technote 1170: The Printing Plug-ins Manager</A></p>    <p><A HREF = "http://developer.apple.com/documentation/macos8/Utilities/CollectionManager/collectionmanager.html">Inside Macintosh, The Collection Manager</A></p><a name="Changes"></a><H2>Change History</H2><TABLE BORDER=0 CELLPADDING=3 WIDTH=544>            <TR>               <td width=100 align=left>                  <P ALIGN=center>01-April-1998</P>               </TD>               <td align="left">                  <P>Originally written.</P>               </TD>            </TR>            <TR>               <td width=100 align=left>                  <P ALIGN=center>24-May-1999</P>               </TD>               <td align="left">                  <P>Revised.</P>               </TD>            </TR></table>             <BR><P><A HREF = "#top">Back to top</a></p><A NAME="Downloads"></A> <h2>Downloadables</h2><center><TABLE BORDER=0 CELLPADDING=3 WIDTH="600"> <TR> <td width=50 align=left>   <P ALIGN=center><img src="images/acrobatsmall.gif" align=middle alt="Acrobat" width=22 height=23></P></TD><td align="left">   <p>Acrobat version of this Note (252K).</P></TD><td width=60 align=left>   <p><A HREF="pdf/tn1169.pdf">Download</A></P></TD>  </TR>   <TR> <td width=50 align=left>   <P ALIGN=center><img src="images/bluebook.gif" width=22 height=23 align=bottom alt="Bluebook.gif"></P></TD><td align="left">   <p>Binhexed Routine Descriptor Lib (196K).</P></TD><td width=60 align=left>   <p><A HREF = "downloads/tn1169.1.hqx">Download</A></P></TD>  </TR>   </table></center>  <BR><BR><P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1169.html%3Fid%3DDTS10003008-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1169.html%3Fid%3DDTS10003008-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1169.html%3Fid%3DDTS10003008-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>