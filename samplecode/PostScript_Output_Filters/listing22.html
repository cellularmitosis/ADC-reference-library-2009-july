<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>PostScript Output Filters - /SampleFilter/SampleFilterMain.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxPrinting-date.html">Printing</a> &gt; <A HREF="javascript:location.replace('index.html');">PostScript Output Filters</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Printing/index.html" target="_blank">Reference Library > Printing</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">PostScript Output Filters</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/SampleFilter/SampleFilterMain.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Headers and Stub Libraries/Hints.h</option>
<option value="listing2.html">/Headers and Stub Libraries/PrintingPlugins.h</option>
<option value="listing3.html">/Headers and Stub Libraries/PrintingPlugins.r</option>
<option value="listing4.html">/Headers and Stub Libraries/PSLogFolder.h</option>
<option value="listing5.html">/Headers and Stub Libraries/PSOutputFilters.h</option>
<option value="listing6.html">/Headers and Stub Libraries/PSOutputFilters.r</option>
<option value="listing7.html">/Headers and Stub Libraries/PSSectionInfo.h</option>
<option value="listing8.html">/Headers and Stub Libraries/PSStreams.h</option>
<option value="listing9.html">/SampleFilter/Debug.h</option>
<option value="listing10.html">/SampleFilter/DebugMisc.h</option>
<option value="listing11.html">/SampleFilter/LibraryStuff/Hints.h</option>
<option value="listing12.html">/SampleFilter/LibraryStuff/PrintingPlugins.h</option>
<option value="listing13.html">/SampleFilter/LibraryStuff/PrintingPlugins.r</option>
<option value="listing14.html">/SampleFilter/LibraryStuff/PSOutputFilters.h</option>
<option value="listing15.html">/SampleFilter/LibraryStuff/PSOutputFilters.r</option>
<option value="listing16.html">/SampleFilter/LibraryStuff/PSSectionInfo.h</option>
<option value="listing17.html">/SampleFilter/LibraryStuff/PSStreams.h</option>
<option value="listing18.html">/SampleFilter/Macros.h</option>
<option value="listing19.html">/SampleFilter/NoDebug.h</option>
<option value="listing20.html">/SampleFilter/SampleFilter.r</option>
<option value="listing21.html">/SampleFilter/SampleFilterHints.h</option>
<option value="listing22.html">/SampleFilter/SampleFilterMain.c</option>
<option value="listing23.html">/SampleFilter/SampleFilterMain.h</option>
<option value="listing24.html">/SampleFilter/SampleFilterOutput.c</option>
<option value="listing25.html">/SampleFilter/SampleFilterPanel.c</option>
<option value="listing26.html">/SampleFilter/SampleFilterPanel.h</option>
<option value="listing27.html">/SampleFilter/SampleFilterResources.h</option>
<option value="listing28.html">/SampleFilter/Version.h</option>
<option value="listing29.html">/SectionReport/Debug.h</option>
<option value="listing30.html">/SectionReport/LibraryStuff/Hints.h</option>
<option value="listing31.html">/SectionReport/LibraryStuff/PrintingPlugins.h</option>
<option value="listing32.html">/SectionReport/LibraryStuff/PrintingPlugins.r</option>
<option value="listing33.html">/SectionReport/LibraryStuff/PSLogFolder.h</option>
<option value="listing34.html">/SectionReport/LibraryStuff/PSOutputFilters.h</option>
<option value="listing35.html">/SectionReport/LibraryStuff/PSOutputFilters.r</option>
<option value="listing36.html">/SectionReport/LibraryStuff/PSSectionInfo.h</option>
<option value="listing37.html">/SectionReport/NoDebug.h</option>
<option value="listing38.html">/SectionReport/SectionReport.c</option>
<option value="listing39.html">/SectionReport/SectionReport.r</option>
<option value="listing40.html">/SectionReport/Version.h</option></select>
				</p>
				</form>
				<p><strong><a href="PostScript_Output_Filters.zip">Download Sample</a></strong> (&#147;PostScript_Output_Filters.zip&#148;, 229.2K)<BR>
<strong><a href="PostScript_Output_Filters.dmg">Download Sample</a></strong> (&#147;PostScript_Output_Filters.dmg&#148;, 297.8K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/***  File:      SampleFilterMain.c****  Description:  The functions in this file control the**          Sample Filter PlugIn.****  Version:    1.0    ****  Copyright 1999 Apple Computer. All rights reserved.****  You may incorporate this sample code into your applications without**  restriction, though the sample code has been provided &quot;AS IS&quot; and the**  responsibility for its operation is 100% yours.  However, what you are**  not permitted to do is to redistribute the source as &quot;ABC Sample Code&quot;**  after having made changes. If you're going to re-distribute the source,**  we require that you make it clear in the source that the code was**  descended from Apple Sample Code, but that you've made changes.***/#include &lt;CodeFragments.h&gt;#include &lt;Collections.h&gt;#include &lt;Resources.h&gt;#include &lt;String.h&gt;#include &quot;DebugMisc.h&quot;#include &quot;Macros.h&quot;#include &quot;PSOutputFilters.h&quot;#include &quot;Hints.h&quot;#include &quot;SampleFilterMain.h&quot;#include &quot;SampleFilterPanel.h&quot;#include &quot;SampleFilterResources.h&quot;#include &quot;SampleFilterHints.h&quot;/*  There are a couple of different ways we can build our sample depending on some defines.  If the define DOAPPLEPPDTEST is set to 1, then this filter   looks at the value of current PPD's *PCFileName main keyword  and does not run the filter if it starts with 'APL'    If the define DOSPOOLERCHECK is set to 1, then this filter  checks the printer's default collection to determine whether the  set up printer is a spooler.    If the define DYNAMICLW8UILOAD is set to 1, then this filter  dynamically resolves the symbol LWGetPrInfoCollection instead  of using the weak link to the LaserWriter8.Lib file containing  a LW8UILib stub library. This approach is more complex than simply  weak linking but gives more control to the filter. This define only  is used if the DOSPOOLERCHECK define is also set to 1.*/#define DOAPPLEPPDTEST 0#define DOSPOOLERCHECK 0#define DYNAMICLW8UILOAD 0// this sample only has one panel but if it had additional ones we'd// define them hereenum {  kFirstPanel,//  kSecondPanel,  kNumPanels};/* static Global data */OSErr InitLib(CFragInitBlockPtr initBlkPtr);void TerminateLib(void);static short panelCount;static PanelRef panelRefs[kNumPanels];static OSStatus checkPPDMatch(Collection criteriaCollection, Boolean *doesMatchP);static OSStatus checkIfSpooler(LWRef lwRef, Boolean *isSpoolerP);OSErr InitLib(CFragInitBlockPtr initBlkPtr){  Unused(initBlkPtr);    panelCount = 0;  return(noErr);}void TerminateLib(void){  panelCount = 0;}OSStatus psPanelPlugInLibInitData(LWRef lwRef, void **libDataH, short resFRef, unsigned long *libSignatureP){  OSStatus err = noErr;    Unused(lwRef);    *libDataH = (void *)resFRef;            // save our resource fork fRef for later use  *libSignatureP = kSampleFilterSignature;    return(err);}void psPanelPlugInLibCloseData(LWRef lwRef, void *libDataP, Collection jobInfo, Boolean *doItP){  OSStatus err = noErr;  kHintColorModeVar colorMode;  SInt32 size = sizeof(PSColorMode);  short holdResFile, resFRef = (short)libDataP;  Unused(lwRef);  /*    Just to demonstrate how to do this, we'll put up an alert that lets the user    back out if the color mode has been set to black and white.   */  // only bother if we are being called because the user clicked OK or Save in the dialog  if(*doItP){    err = GetCollectionItem(jobInfo, kHintColorModeTag, kHintColorModeId, &amp;size, &amp;colorMode);    if(err == collectionItemNotFoundErr){      err = noErr;      colorMode = kColorMode;    }        // need to make sure our resource fork is the current one if we are going to get resources    if(!err &amp;&amp; resFRef != -1 &amp;&amp; colorMode == kBlackAndWhiteMode) {      holdResFile = CurResFile();      UseResFile(resFRef);      if( CautionAlert(kSETTINGSALRT_ALRT, NULL) == cancel ) {        // cancel the print job if the user has cancelled our dialog        *doItP = false;      }      UseResFile(holdResFile);    }  }    // no need to dispose of anything in libDataP since we only stored  // the resource fork fRef there}OSStatus psPanelPlugInLibKeepRunning(LWRef lwRef, Collection criteriaCollection, Boolean *keepRunningP, void *libDataP){  OSStatus err = noErr;  Boolean keepRunning;  Unused(libDataP);    /*    Here we might potentially check 'criteriaCollection' for whether we want to run.        Let's see if the *PCFileName of the current PPD is one in our list.  */  err = checkPPDMatch(criteriaCollection, &amp;keepRunning);      /*   good place to demonstrate that we can get the prefs collection and determine whether    to keep running. Note that the prefs collection may not reflect    settings we expect because the user may not have set up their printer or there    may not be bi-directional communication to the printer.        Here, just for fun, we'll disable ourselves if the printer represents a spooler.  */  if(!err &amp;&amp; keepRunning){    Boolean isSpooler;    err = checkIfSpooler(lwRef, &amp;isSpooler);    if(!err &amp;&amp; isSpooler)keepRunning = false;  }     /*    If keepRunning is false then we'll tell LaserWriter 8 that we no longer want to     run for this new printer.  */  *keepRunningP = err ? false : keepRunning;      return(err);}OSStatus psPanelSetCriteria(LWRef lwRef, Collection criteriaCollection, short resFRef){  OSStatus err = noErr;  Handle resH;  kHintPanelDriverVersVar driverVers = 0x08000000;  // vers data for LaserWriter 8.0  Unused(lwRef);    // as an example, we'll advertise that we require LaserWriter 8.0 and later  err = AddCollectionItem  (criteriaCollection, kHintPanelDriverVersTag, kHintPanelDriverVersId,                             sizeof(kHintPanelDriverVersVar), &amp;driverVers);  if(!err) {    if(resFRef != -1) {      short holdResFile = CurResFile();      UseResFile(resFRef);      resH = Get1Resource(kPluginInfoType, kPluginInfoID);      if(resH) {        err = AddCollectionItemHdl(criteriaCollection, kPluginInfoType, kPluginInfoID, resH);        ReleaseResource(resH);      } else {        err = ResError();        if(!err) {          err = resNotFound;        }      }      UseResFile(holdResFile);    }  }  return(err);}OSStatus psPanelAddMenu(LWRef lwRef, PanelRef panelRef, void *dataP, StringPtr panelName,       unsigned long bufSize, Boolean *addItP){  OSStatus err = noErr;    Unused(lwRef);    *addItP = false;  if(panelRef == panelRefs[kFirstPanel]) {    err = sampleAddMenu(dataP, panelName, bufSize, addItP);  }else{#if 0    if(panelRef == panelRefs[kSecondPanel]){      err = sampleAddMenuTwo(dataP, panelName, bufSize, addItP);    }else#endif      ckAssert(false);  }      return(err);}OSStatus psPanelRegister(LWRef lwRef, PanelRef panelRef, Collection criteriaCollection, Boolean *addPanelP,               const Rect *panelRectP,              short *ditlIDP, Handle *ditlHP, void **dataH, void *libDataP){  OSStatus err = noErr;  Boolean keepRunning = true;  Unused(panelRectP);  Unused(ditlHP);        switch(panelCount) {   case kFirstPanel:    /*      Here we might potentially check 'criteriaCollection' for whether we want to run at all for this printer.            Let's see if the PCFileName of the current PPD is one in our list    */    err = checkPPDMatch(criteriaCollection, &amp;keepRunning);          /*   good place to demonstrate that we can get the prefs collection and determine whether      to keep running. Note that the prefs collection may not reflect      settings we expect because the user may not have set up their printer or there      may not be bi-directional communication to the printer.            Here, just for fun, we'll disable ourselves if the printer represents a spooler.    */    if(!err &amp;&amp; keepRunning){      Boolean isSpooler;      err = checkIfSpooler(lwRef, &amp;isSpooler);      if(!err &amp;&amp; isSpooler)keepRunning = false;    }    /*      If keepRunning is false then we tell LaserWriter 8 that we are not adding any panels. Note that      we check the PPD match and spooler in psPanelRegister AND psPanelPlugInLibKeepRunning. This is      done since psPanelPlugInLibKeepRunning is only called if we're already been running and the      user switches printers. By also using psPanelRegister, we can show no panels if the first      printer we are loaded for is one we aren't interested in.    */    if(!err &amp;&amp; keepRunning){       panelRefs[kFirstPanel] = panelRef;       err = sampleRegisterPanel(ditlIDP, dataH, libDataP);       *addPanelP = err ? false : true;     }else{       *addPanelP = false;     }     break;#if 0   case kSecondPanel:     panelRefs[kSecondPanel] = panelRef;     err = sampleRegisterPanelTwo(ditlIDP, dataH, libDataP);     *addPanelP = err ? false : true;        break;#endif   default:     *addPanelP = false;     break;  }  panelCount++;    return(err);}OSStatus psPanelPrSpecificInitData(LWRef lwRef, PanelRef panelRef, void *dataP, Collection plugInPrInfo){  OSStatus err = noErr;  Unused(lwRef);    if(panelRef == panelRefs[kFirstPanel]) {    err = samplePrSpecificInitData(dataP, plugInPrInfo);  }else{#if 0    if(panelRef == panelRefs[kSecondPanel]){      err = samplePrSpecificInitDataTwo(dataP, plugInPrInfo);    }else#endif      ckAssert(false);  }    return(err);}OSStatus psPanelPrSpecificCloseData(LWRef lwRef, PanelRef panelRef, void *dataP, Boolean doIt){  OSStatus err = noErr;  Unused(lwRef);  Unused(dataP);  Unused(doIt);    if(panelRef == panelRefs[kFirstPanel]) {  }else{#if 0    if(panelRef == panelRefs[kSecondPanel]{    }else#endif      ckAssert(false);  }      return(err);}OSStatus psPanelInitData(LWRef lwRef, PanelRef panelRef, void *dataP, Collection plugInHints){  OSStatus err = noErr;    Unused(lwRef);  Unused(panelRef);  Unused(dataP);  Unused(plugInHints);    err = sampleInitData(dataP, plugInHints);      return(err);}OSStatus psPanelCloseData(LWRef lwRef, PanelRef panelRef, void *dataP, Boolean doIt){  OSStatus err = noErr;  Unused(lwRef);    if(panelRef == panelRefs[kFirstPanel]) {    err =  sampleCloseData(dataP, doIt);  } else    ckAssert(false);      return(err);}OSStatus psPanelPrSpecificInit(LWRef lwRef, PanelRef panelRef, void *dataP, DialogPtr dp, short offset){  OSStatus err = noErr;  Unused(lwRef);    if(panelRef == panelRefs[kFirstPanel]) {    err =  samplePrSpecificInit(dataP, dp, offset);  }else{#if 0    if(panelRef == panelRefs[kSecondPanel]{      err = samplePrSpecificInitTwo(dataP, dp, offset);    }else#endif      ckAssert(false);  }    return err;}OSStatus psPanelPrSpecificClose(LWRef lwRef, PanelRef panelRef, void *dataP, DialogPtr dp, short offset){  OSStatus err = noErr;    Unused(lwRef);  Unused(panelRef);  Unused(dataP);      Unused(dp);  Unused(offset);    return err;}OSStatus psPanelInit(LWRef lwRef, PanelRef panelRef, void *dataP, DialogPtr dp, short offset){  OSStatus err = noErr;  Unused(lwRef);    if(panelRef == panelRefs[kFirstPanel]) {    err = sampleInit(dataP, dp, offset);  }else{#if 0    if(panelRef == panelRefs[kSecondPanel]{      err = sampleInitTwo(dataP, dp, offset);    }else#endif      ckAssert(false);  }    return err;}OSStatus psPanelClose(LWRef lwRef, PanelRef panelRef, void *dataP, DialogPtr dp, short offset){  OSStatus err = noErr;  Unused(lwRef);    Unused(panelRef);  Unused(dataP);      Unused(dp);  Unused(offset);    if(panelRef == panelRefs[kFirstPanel]) {    err = sampleClose(dataP, dp, offset);  }else{#if 0    if(panelRef == panelRefs[kSecondPanel]{    }else#endif      ckAssert(false);  }    return(err);}OSStatus psPanelItem(LWRef lwRef, PanelRef panelRef, void *dataP, DialogPtr dp, short item,                 short offset, short ctlVal){  OSStatus err = noErr;  Unused(lwRef);    if(panelRef == panelRefs[kFirstPanel]) {    err = sampleItem(dataP, dp,item, offset, ctlVal);  }else{#if 0    if(panelRef == panelRefs[kSecondPanel]{      err = sampleItemTwo(dataP, dp,item, offset, ctlVal);    }else#endif      ckAssert(false);  }    return(err);}OSStatus psPanelFilter(LWRef lwRef, PanelRef panelRef, void *dataP, DialogPtr dp, short offset, EventRecord *ep,                 short *itemHitP, Boolean *weHandledItP){  OSStatus err = noErr;  Unused(lwRef);    if(panelRef == panelRefs[kFirstPanel]) {    err = sampleFilter(dataP, dp,offset, ep, itemHitP, weHandledItP);  }else{#if 0    if(panelRef == panelRefs[kSecondPanel]{      err = sampleFilterTwo(dataP, dp,offset, ep, itemHitP, weHandledItP);    }else#endif      ckAssert(false);  }    return(err);}OSStatus psPanelCheckRange(LWRef lwRef, PanelRef panelRef, void *dataP,                     DialogPtr dp, short offset, Boolean *doitP){  OSStatus err = noErr;  Unused(lwRef);    if(panelRef == panelRefs[kFirstPanel]) {    err = sampleCheckRange(dataP, dp, offset, doitP);  }else{#if 0    if(panelRef == panelRefs[kSecondPanel]{      err = sampleCheckRangeTwo(dataP, dp,offset, ep, itemP, weHandledItP);    }else#endif      ckAssert(false);  }    return(err);}OSStatus psPanelSaveButton(LWRef lwRef, PanelRef panelRef, void *dataP, Collection plugInPrInfo){  OSStatus err = noErr;  Unused(lwRef);    if(panelRef == panelRefs[kFirstPanel]) {    err = sampleSaveButton(dataP, plugInPrInfo);  }else{#if 0    if(panelRef == panelRefs[kSecondPanel]{      err = sampleSaveButtonTwo(dataP, plugInPrInfo);    }else#endif      ckAssert(false);  }  return(err);}static OSStatus checkPPDMatch(Collection criteriaCollection, Boolean *doesMatchP){  OSStatus err = noErr;  Boolean doesMatch = true;#if DOAPPLEPPDTEST  if(!err){      kHintPanelPCFileNameVar pcFileName;    SInt32 size = sizeof(kHintPanelPCFileNameVar);    char *applePPDPCFileName = &quot;APL&quot;;    SInt32 appleSize = strlen(applePPDPCFileName);        // LaserWriter 8 stores this collection item in the criteriaCollection if the *PCFileName    // exists in the current PPD file for the current printer    err = GetCollectionItem(criteriaCollection, kHintPanelPCFileNameTag, kHintPanelPCFileNameId,                       &amp;size, pcFileName+1);    if(!err){      pcFileName[0] = size;    }else{      if(err == collectionItemNotFoundErr){        err = noErr;        pcFileName[0] = 0;        doesMatch = false;      }    }        // do the first 3 characters match the PPD PC Filename?    if(!err &amp;&amp; doesMatch){      if(pcFileName[0] &gt;= appleSize){        short i;        unsigned char *theName = pcFileName;        theName++;  // point to the first character past the size byte        for(i = 0; i &lt; appleSize; i++){          if(theName[i] != applePPDPCFileName[i]){            doesMatch = false;            break;          }        }      }    }  }#else  Unused(criteriaCollection);#endif  *doesMatchP = err ? false : doesMatch;  return err;}static OSStatus checkIfSpooler(LWRef lwRef, Boolean *isSpoolerP){  OSStatus err = noErr;  Boolean isSpooler = false;#if DOSPOOLERCHECK  Collection prefs = NULL;#if DYNAMICLW8UILOAD  OSStatus libErr = noErr;  CFragSymbolClass symClass;  CFragConnectionID connID;  Str255  buff;  Ptr mainAdr;  LWGetPrInfoCollectionProc lwGetPrInfoCollection;  libErr = GetSharedLibrary(&quot;\pLW8UILib&quot;, kCompiledCFragArch, kLoadCFrag, &amp;connID, &amp;mainAdr, buff);  if (!libErr) {    libErr = FindSymbol(connID, &quot;\pLWGetPrInfoCollection&quot;, (Ptr *)&amp;lwGetPrInfoCollection, &amp;symClass);    if (!libErr)prefs = (*lwGetPrInfoCollection)(lwRef);    CloseConnection(&amp;connID);  }#else  // if we are not dynamically loading LW8UILib but are weak linking instead,   // we check that our weak link has been satisfied before calling the routine  if(LWGetPrInfoCollection != (void *)kUnresolvedCFragSymbolAddress){     prefs = LWGetPrInfoCollection(lwRef);  }else{    // this should not happen but lets generate an assert in our debug code if it does    ckAssert(false);  }#endif    // DYNAMICLW8UILOAD  // only continue with our test if we got a prefs collection from our code above  if(prefs){    kHintADOSpoolerVar checkSpooler;    SInt32 size = sizeof(checkSpooler);    // this hint will be in the printer's prefs collection if the printer was set up    // and there was bi-directional communication at the time    err = GetCollectionItem(prefs, kHintADOSpoolerTag, kHintADOSpoolerId, &amp;size, &amp;checkSpooler);        // be prepared for our spooler collection item to not exist    if(err == collectionItemNotFoundErr){      err = noErr;      checkSpooler = kTriUnknown;    // we don't know if the printer is a spooler or not    }        // only if we know for sure that the printer is a spooler do we act accordingly     if(!err &amp;&amp; checkSpooler == kTriTrue){      isSpooler = true;    }  }#else  Unused(lwRef);#endif    // DOSPOOLERCHECK  // here we are saying that if we got an error then the printer is not a spooler  // not very conservative but users of this sample code will have to decide for themselves  *isSpoolerP = err ? false : isSpooler;  return err;}short getControl(DialogPtr dialog, short item)/*  Return the value of item if item is a control.*/{  short itemType, result = 0;  Handle itemH;  Rect itemBox;    if(item &gt; 0 &amp;&amp; item &lt; 100) {    GetDialogItem(dialog, item, &amp;itemType, &amp;itemH, &amp;itemBox);    if(itemType &amp; ctrlItem)        result = GetControlValue((ControlHandle)itemH);  }    return(result);}short setControl(DialogPtr dp, short item, short value)/*  Sets a control in a dialog's item list to the given  value. If the dialog item is not a control then this  function does nothing. If value == -1, the control value  is toggled (i.e., checkboxes).*/{  short type, curValue;  ControlHandle hC;  Rect r;    if(item &gt; 0 &amp;&amp; item &lt; 100) {    GetDialogItem(dp, item, &amp;type, (Handle *)&amp;hC, &amp;r);    if(type &amp; ctrlItem) {      curValue = (*hC)-&gt;contrlValue;      if( (value == -1) ) {        value = !curValue;      }      if(curValue != value) {        SetControlValue(hC, value);      }    }  }    return(value);}void setRadio(DialogPtr dp, short first, short last, short which){  short item;    for(item = first; item &lt;= last; item++) {     setControl(dp, item, item == which);  }}OSStatus setText(DialogPtr dp, short item, ConstStr255Param text){  OSStatus err = noErr;  short type;  Rect r;  Handle h;  ControlRef controlRef = nil;    err = GetDialogItemAsControl(dp, item, &amp;controlRef);    if(!err) {    err = SetControlData(controlRef, 0 , kControlStaticTextTextTag, *text, (Ptr)text + 1);    if(!err &amp;&amp; controlRef)      Draw1Control(controlRef);  } else if(err == errItemNotControl) {    err = noErr;    GetDialogItem(dp, item, &amp;type, &amp;h, &amp;r);    if( (type &amp; statText) || (type &amp; editText) ) {      SetDialogItemText(h, text);    }   }    return(err);}OSStatus getText(DialogPtr dp, short item, Byte *text){  OSStatus err = noErr;  short type;  Handle h;  Rect r;  ControlRef controlRef;  long actualSize;    err = GetDialogItemAsControl(dp, item, &amp;controlRef);    if(!err) {    err = GetControlData(controlRef, 0 , kControlStaticTextTextTag, sizeof(Str255), (Ptr)text + 1, &amp;actualSize);    *text = actualSize;  } else if(err == errItemNotControl) {    err = noErr;    GetDialogItem(dp, item, &amp;type, &amp;h, &amp;r);    if( (type &amp; statText) || (type &amp; editText) ) {      GetDialogItemText(h, text);    }   }    return(err);}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/PostScript_Output_Filters/listing22.html%3Fid%3DDTS10000297-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/PostScript_Output_Filters/listing22.html%3Fid%3DDTS10000297-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/PostScript_Output_Filters/listing22.html%3Fid%3DDTS10000297-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>