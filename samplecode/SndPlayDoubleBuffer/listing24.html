<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>SndPlayDoubleBuffer - /_source/Private_DBFFFunctions.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">SndPlayDoubleBuffer</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/index.html" target="_blank">Reference Library</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">SndPlayDoubleBuffer</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/_source/Private_DBFFFunctions.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/_headers/DBFF.h</option>
<option value="listing2.html">/_headers/DBFF_Errors.h</option>
<option value="listing3.html">/_headers/Defines.h</option>
<option value="listing4.html">/_headers/DoubleBufferFromFile.h</option>
<option value="listing5.html">/_headers/Interrupt_Routines.h</option>
<option value="listing6.html">/_headers/LDandFix.h</option>
<option value="listing7.html">/_headers/MungeBuffer.h</option>
<option value="listing8.html">/_headers/MyAIFF.h</option>
<option value="listing9.html">/_headers/MyGestalt.h</option>
<option value="listing10.html">/_headers/Private_DBFFFunctions.h</option>
<option value="listing11.html">/_headers/ReadResource.h</option>
<option value="listing12.html">/_headers/SetupDBHeader.h</option>
<option value="listing13.html">/_headers/SimpleApp_Sound.h</option>
<option value="listing14.html">/_headers/SND.h</option>
<option value="listing15.html">/_headers/SoundStruct.h</option>
<option value="listing16.html">/_headers/ULAW.h</option>
<option value="listing17.html">/_headers/WAVE.h</option>
<option value="listing18.html">/_source/AIFF.c</option>
<option value="listing19.html">/_source/DoubleBufferFromFile.c</option>
<option value="listing20.html">/_source/Interrupt_Routines.c</option>
<option value="listing21.html">/_source/LDandFix.c</option>
<option value="listing22.html">/_source/MungeBuffer.c</option>
<option value="listing23.html">/_source/MyGestalt.c</option>
<option value="listing24.html">/_source/Private_DBFFFunctions.c</option>
<option value="listing25.html">/_source/ReadResource.c</option>
<option value="listing26.html">/_source/SetupDBHeader.c</option>
<option value="listing27.html">/_source/SimpleApp_Sound.c</option>
<option value="listing28.html">/_source/SND.c</option>
<option value="listing29.html">/_source/ULAW.c</option>
<option value="listing30.html">/_source/WAVE.c</option>
<option value="listing31.html">/SAL Æ’/SAL_Public.h</option></select>
				</p>
				</form>
				<p><strong><a href="SndPlayDoubleBuffer.zip">Download Sample</a></strong> (&#147;SndPlayDoubleBuffer.zip&#148;, 185.7K)<BR>
<strong><a href="SndPlayDoubleBuffer.dmg">Download Sample</a></strong> (&#147;SndPlayDoubleBuffer.dmg&#148;, 253.5K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    Private_DBFFFunctions.c  Contains:  Routines demonstrating how to set up for using SndPlayDoubleBuffer.  Written by: Mark Cookson    Copyright:  Copyright &copy; 1996-1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        8/31/1999  Karl Groethe  Updated for Metrowerks Codewarror Pro 2.1        */#include &quot;MyAIFF.h&quot;#include &quot;Private_DBFFFunctions.h&quot;/********************************************************************************************    ** YOU SHOULD NEVER NEED TO CALL ANY OF THE FOLLOWING ROUTINES DIRECTLY **********************************************************************************************//*  Purpose:    This sets all of local and global variables to safe values.          This routine is called by ASoundNew, and is  called by the          ASoundDone function after it has cleaned up to reset things.  Side Effects:  None.*//*-----------------------------------------------------------------------*/    OSErr  ASoundInit    (SoundInfoPtr theSoundInfo)/*-----------------------------------------------------------------------*/{  NumVersion  SndManagerVer;  OSErr    theErr      = noErr;  theSoundInfo-&gt;globals.gSupports16Bit  = true;  theSoundInfo-&gt;globals.gSupportsSPDB    = true;  theSoundInfo-&gt;signature      = kDBFFSignature;  theSoundInfo-&gt;chan        = kInit;  theSoundInfo-&gt;rateForResume    = kInit;  /* create a Universal Procedure Pointer (UPP) for our sound callback */  theSoundInfo-&gt;theSoundCallBackUPP = NewSndCallBackProc(ASoundDoneCallBack);  theSoundInfo-&gt;fileType      = kInit;  (void)ASoundSetNumBuffers    (theSoundInfo, kStart);  theSoundInfo-&gt;dataStart      = kInit;  (void)ASoundSetSoundLength    (theSoundInfo, kInit);  ASoundSetBytesCopied      (theSoundInfo, kInit);  ASoundSetCurBuffer        (theSoundInfo, kStart);  (void)ASoundSetBufferSize    (theSoundInfo, kInit);  theSoundInfo-&gt;bytesPerFrame    = kInit;  theSoundInfo-&gt;refNum      = kInit;  theSoundInfo-&gt;vRefNum      = nil;  theSoundInfo-&gt;compFactor    = kNoCompression;  theSoundInfo-&gt;paused      = false;  theSoundInfo-&gt;playing      = false;  theSoundInfo-&gt;adjusting      = false;  theSoundInfo-&gt;soundDone      = false;  theSoundInfo-&gt;backwards      = false;  theSoundInfo-&gt;hasBeenAdjusted  = false;  theSoundInfo-&gt;needsMasking    = false;  theSoundInfo-&gt;stopping      = false;  SndManagerVer = SndSoundManagerVersion ();  theErr = InterrogateSystem (&amp;(theSoundInfo-&gt;globals));  if (theErr == noErr) {    if (SndManagerVer.majorRev &gt;= kMinSndMgrVer) {      if ((theSoundInfo-&gt;globals.ggestaltSoundAttr &amp; (1 &lt;&lt; gestaltSndPlayDoubleBuffer)) == false) {        DebugPrint (&quot;\pSndPlayDoubleBuffer isn't supported!&quot;);        theSoundInfo-&gt;globals.gSupportsSPDB = false;        theErr = kNoSPDBErr;      }      if ((theSoundInfo-&gt;globals.ggestaltSoundAttr &amp; (1&lt;&lt; gestalt16BitAudioSupport)) == false) {        DebugPrint (&quot;\pThis machine doesn't support 16 bit audio!&quot;);        theSoundInfo-&gt;globals.gSupports16Bit = false;        theErr = notEnoughHardwareErr;  /* This doesn't have to be a fatal error */      }    }    else {      theErr = kOldSndMgrErr;    }  }  else {    theErr = kInitErr;  }  return theErr;}/*-----------------------------------------------------------------------*/Boolean      IsValid          (SoundInfoPtr theSoundInfo)/*-----------------------------------------------------------------------*/{  return CheckValididity (theSoundInfo, false);}/*-----------------------------------------------------------------------*/Boolean      StrictIsValid      (SoundInfoPtr theSoundInfo)/*-----------------------------------------------------------------------*/{  return CheckValididity (theSoundInfo, true);}/*-----------------------------------------------------------------------*/Boolean      CheckValididity      (SoundInfoPtr theSoundInfo,                    Boolean strict)/*-----------------------------------------------------------------------*/{  Boolean    returnValue    = true;    /* Assume success */  if (theSoundInfo == nil) {    returnValue = false;  }  else {    if (strict == true) {      if (theSoundInfo-&gt;signature != kDBFFSignature) {        returnValue = false;        DebugPrint (&quot;\pStrictIsValid theSoundInfo-&gt;signature is invalid&quot;);      }      else {        if (theSoundInfo-&gt;doubleHeader.dbhNumChannels &lt;= kInit) {          returnValue = false;          DebugPrint (&quot;\pStrictIsValid theSoundInfo-&gt;doubleHeader.dbhNumChannels is invalid&quot;);        }        if (theSoundInfo-&gt;doubleHeader.dbhSampleSize &lt;= kInit) {          returnValue = false;          DebugPrint (&quot;\pStrictIsValid theSoundInfo-&gt;doubleHeader.dbhSampleSize is invalid&quot;);        }        if (theSoundInfo-&gt;doubleHeader.dbhPacketSize &lt; kInit) {          returnValue = false;          DebugPrint (&quot;\pStrictIsValid theSoundInfo-&gt;doubleHeader.dbhPacketSize is invalid&quot;);        }        if (theSoundInfo-&gt;theSoundCallBackUPP == nil) {          returnValue = false;          DebugPrint (&quot;\pStrictIsValid theSoundInfo-&gt;theSoundCallBackUPP is invalid&quot;);        }        if (theSoundInfo-&gt;rateForResume &lt; kInit) {          returnValue = false;          DebugPrint (&quot;\pStrictIsValid theSoundInfo-&gt;rateForResume is invalid&quot;);        }        if (theSoundInfo-&gt;numBuffers &lt;= kInit) {          returnValue = false;          DebugPrint (&quot;\pStrictIsValid theSoundInfo-&gt;numBuffers is invalid&quot;);        }        if (theSoundInfo-&gt;dataStart &lt; kInit) {          returnValue = false;          DebugPrint (&quot;\pStrictIsValid theSoundInfo-&gt;dataStart is invalid&quot;);        }        if (theSoundInfo-&gt;bytesTotal &lt;= kInit) {          returnValue = false;          DebugPrint (&quot;\pStrictIsValid theSoundInfo-&gt;bytesTotal is invalid&quot;);        }        if (theSoundInfo-&gt;bytesCopied &lt;= kInit) {          returnValue = false;          DebugPrint (&quot;\pStrictIsValid theSoundInfo-&gt;bytesCopied is invalid&quot;);        }        if (theSoundInfo-&gt;currentBuffer &lt;= kInit) {          returnValue = false;          DebugPrint (&quot;\pStrictIsValid theSoundInfo-&gt;currentBuffer is invalid&quot;);        }        if (theSoundInfo-&gt;doubleBufferSize &lt;= kInit) {          returnValue = false;          DebugPrint (&quot;\pStrictIsValid theSoundInfo-&gt;doubleBufferSize is invalid&quot;);        }        if (theSoundInfo-&gt;bytesPerFrame &lt;= kInit) {          returnValue = false;          DebugPrint (&quot;\pStrictIsValid theSoundInfo-&gt;bytesPerFrame is invalid&quot;);        }        if (theSoundInfo-&gt;compFactor &lt;= kInit) {          returnValue = false;          DebugPrint (&quot;\pStrictIsValid theSoundInfo-&gt;compFactor is invalid&quot;);        }      }    }    else {      if (theSoundInfo-&gt;signature != kDBFFSignature) {        returnValue = false;        DebugPrint (&quot;\pIsValid theSoundInfo-&gt;signature is invalid&quot;);      }      else {        if (theSoundInfo-&gt;doubleHeader.dbhNumChannels &lt; kInit) {          returnValue = false;          DebugPrint (&quot;\pIsValid theSoundInfo-&gt;doubleHeader.dbhNumChannels is invalid&quot;);        }        if (theSoundInfo-&gt;doubleHeader.dbhSampleSize &lt; kInit) {          returnValue = false;          DebugPrint (&quot;\pIsValid theSoundInfo-&gt;doubleHeader.dbhSampleSize is invalid&quot;);        }        if (theSoundInfo-&gt;doubleHeader.dbhPacketSize &lt; kInit) {          returnValue = false;          DebugPrint (&quot;\pIsValid theSoundInfo-&gt;doubleHeader.dbhPacketSize is invalid&quot;);        }        if (theSoundInfo-&gt;theSoundCallBackUPP == nil) {          returnValue = false;          DebugPrint (&quot;\pIsValid theSoundInfo-&gt;theSoundCallBackUPP is invalid&quot;);        }        if (theSoundInfo-&gt;rateForResume &lt; kInit) {          returnValue = false;          DebugPrint (&quot;\pIsValid theSoundInfo-&gt;rateForResume is invalid&quot;);        }        if (theSoundInfo-&gt;numBuffers &lt; kInit) {          returnValue = false;          DebugPrint (&quot;\pIsValid theSoundInfo-&gt;numBuffers is invalid&quot;);        }        if (theSoundInfo-&gt;dataStart &lt; kInit) {          returnValue = false;          DebugPrint (&quot;\pIsValid theSoundInfo-&gt;dataStart is invalid&quot;);        }        if (theSoundInfo-&gt;bytesTotal &lt; kInit) {          returnValue = false;          DebugPrint (&quot;\pIsValid theSoundInfo-&gt;bytesTotal is invalid&quot;);        }        if (theSoundInfo-&gt;bytesCopied &lt; kInit) {          returnValue = false;          DebugPrint (&quot;\pIsValid theSoundInfo-&gt;bytesCopied is invalid&quot;);        }        if (theSoundInfo-&gt;currentBuffer &lt; kInit) {          returnValue = false;          DebugPrint (&quot;\pIsValid theSoundInfo-&gt;currentBuffer is invalid&quot;);        }        if (theSoundInfo-&gt;doubleBufferSize &lt; kInit) {          returnValue = false;          DebugPrint (&quot;\pIsValid theSoundInfo-&gt;doubleBufferSize is invalid&quot;);        }        if (theSoundInfo-&gt;bytesPerFrame &lt; kInit) {          returnValue = false;          DebugPrint (&quot;\pIsValid theSoundInfo-&gt;bytesPerFrame is invalid&quot;);        }        if (theSoundInfo-&gt;compFactor &lt; kInit) {          returnValue = false;          DebugPrint (&quot;\pIsValid theSoundInfo-&gt;compFactor is invalid&quot;);        }      }    }  }  return returnValue;}/*  Purpose:    Called by StandardFile for every file in a folder to          see if we want to display that file in the open file          dialog.  Return false (don't filter) if you want the          file displayed, true (do filter) if you don't want          it displayed.          This calls ASoundCanThisPlay() which calls the header          parsing routines.  If we can parse the header we          should be able to play the file.  Side Effects:  None.*//*-----------------------------------------------------------------------*/pascal Boolean  ASoundFileFilter    (CInfoPBPtr theFileInfo)/*-----------------------------------------------------------------------*/{  OSErr    theErr      = noErr;  Boolean    returnValue    = true;    /* by default don't display the file */  theErr = ASoundCanThisPlay (theFileInfo);  if (theErr == noErr) {          /* We can play this file. */    returnValue = false;        /* Display this file */  }  if (theErr != noErr &amp;&amp; theErr != kUnknownFormat) {    DebugPrint (&quot;\pError in ASoundFileFilter&quot;);  }  return returnValue;}/*  Purpose:    Sets how many buffers will be needed to play the entire          sound.  Side Effects:  None.*//*-----------------------------------------------------------------------*/    OSErr  ASoundSetNumBuffers    (SoundInfoPtr theSoundInfo,                    long newValue)/*-----------------------------------------------------------------------*/{  OSErr    theErr  = noErr;  if (newValue &gt;= kInit) {    theSoundInfo-&gt;numBuffers = newValue;  }  else {    theErr = kBadValue;  }  return theErr;}/*  Purpose:    To install a callback command into the current sound          channel.  Side Effects:  None.*//*-----------------------------------------------------------------------*/    OSErr  InstallCallBack      (SoundInfoPtr theSoundInfo)/*-----------------------------------------------------------------------*/{  SndCommand  mycmd  = {callBackCmd, kInit, kInit};  OSErr    theErr  = noErr;  mycmd.param2 = SetCurrentA5();  theErr = SndDoCommand (theSoundInfo-&gt;chan, &amp;mycmd, true);  if (theErr != noErr) {    DebugPrint (&quot;\pError in InstallCallBack&quot;);  }  return theErr;}/*  Purpose:    Gather the information needed (from the sound's header)          to setup the structures the Sound Manager will need to          play the sound.  Side Effects:  This will allocate memory for the sound header strucure          that will be disposed of by ASoundDonePlaying.*//*-----------------------------------------------------------------------*/    OSErr  SetUpSoundHeader    (SoundInfoPtr theSoundInfo,                    unsigned long bufferSize)/*-----------------------------------------------------------------------*/{  long double    sampleRate  = kInit;  long      dataStart  = kInit,          sndLength  = kInit,          numBuffers  = kInit;  short      remainder  = kInit;  OSErr      theErr    = noErr;  theSoundInfo-&gt;chan-&gt;userInfo = (long)theSoundInfo;    /* So we know who we are in the SoundCompletion routines */  switch (theSoundInfo-&gt;fileType) {    case kCompressedAIFFFile:    case kUncompressedAIFFFile:      theErr = ASoundGetAIFFHeader (theSoundInfo, &amp;dataStart, &amp;sndLength);      break;    case kWAVEFile:    case kWAVFile:      theErr = ASoundGetWAVEHeader (theSoundInfo, &amp;dataStart, &amp;sndLength);      break;    case kAUFile:      theErr = ASoundGetULAWHeader (theSoundInfo, &amp;dataStart, &amp;sndLength);      break;    case kSNDResource:    case kResource:      theErr = ASoundGetSNDHeader  (theSoundInfo, &amp;dataStart, &amp;sndLength);      break;    default:      theErr = kUnknownFormat;      break;  }  theSoundInfo-&gt;dataStart = dataStart;  if (theErr != noErr) {    DebugPrint (&quot;\pASoundGetAIFFHeader error!&quot;);    (void)SndDisposeChannel (theSoundInfo-&gt;chan, true);  }  else {    if ((theSoundInfo-&gt;doubleHeader.dbhSampleSize == kSixteen) &amp;&amp; (theSoundInfo-&gt;globals.gSupports16Bit == false)) {      DebugPrint (&quot;\pThis is a 16 bit sound, this is not a 16 bit capable machine.&quot;);      theErr = notEnoughHardwareErr;    }    else {        theErr = ASoundSetSoundLength (theSoundInfo, sndLength);      ASoundSetBytesCopied (theSoundInfo, dataStart);        /* skip the header of the file */      sampleRate = ASoundFixToLongDouble (theSoundInfo-&gt;doubleHeader.dbhSampleRate);      if (bufferSize &gt; kInit) {        theErr = ASoundSetBufferSize (theSoundInfo, bufferSize);      }      else {        theErr = ASoundSetBufferSize (theSoundInfo, (((theSoundInfo-&gt;doubleHeader.dbhSampleSize / kBitsPerByte) * theSoundInfo-&gt;doubleHeader.dbhNumChannels * sampleRate) / kBufLen) / theSoundInfo-&gt;compFactor);      }      if (ASoundGetBufferSize (theSoundInfo) &gt; kInit) {        numBuffers = (ASoundGetNumTotalBytes (theSoundInfo) / ASoundGetBufferSize (theSoundInfo));        remainder = (ASoundGetNumTotalBytes (theSoundInfo) % ASoundGetBufferSize (theSoundInfo));        if (remainder != 0) {  /* Is the last buffer only a partial buffer? */          numBuffers++;    /* Don't forget to account for it! */        }        theErr = ASoundSetNumBuffers (theSoundInfo, numBuffers);      }      else {        DebugPrint (&quot;\pThe buffer size is zero, this is bad.&quot;);        theErr = dsZeroDivErr;      }      theSoundInfo-&gt;doubleHeader.dbhDoubleBack = NewSndDoubleBackProc (ASoundDoubleBackProc);      theSoundInfo-&gt;doubleHeader.dbhBufferPtr[kDBBufOne] = nil;      theSoundInfo-&gt;doubleHeader.dbhBufferPtr[kDBBufTwo] = nil;    }  }  if (theErr != noErr) {    DebugPrint (&quot;\pError in SetUpSoundHeader&quot;);  }  return theErr;}/*  Purpose:    Pause the playing of the sound.  Side Effects:  None.*//*-----------------------------------------------------------------------*/    OSErr  PauseSound        (SoundInfoPtr theSoundInfo)/*-----------------------------------------------------------------------*/{  OSErr      theErr  = noErr;  UnsignedFixed  rateMul;  rateMul = 0;  theErr = SndSetInfo (theSoundInfo-&gt;chan, siRateMultiplier, (void*)rateMul);  if (theErr == noErr) {    theSoundInfo-&gt;paused = true;  }  if (theErr != noErr) {    DebugPrint (&quot;\pError in PauseSound&quot;);  }  return theErr;}/*  Purpose:    Resume the playing of the sound.  Side Effects:  This will reinstall the sound completion callback          if it was removed by the ASoundPauseForAdjust function.*//*-----------------------------------------------------------------------*/    OSErr  ResumeSound        (SoundInfoPtr theSoundInfo)/*-----------------------------------------------------------------------*/{  OSErr      theErr  = noErr;  UnsignedFixed  rateMul;  rateMul = (1&lt;&lt;16);  theErr = SndSetInfo (theSoundInfo-&gt;chan, siRateMultiplier, (void*)rateMul);  if (theErr == noErr) {    theSoundInfo-&gt;paused = false;    if (theSoundInfo-&gt;hasBeenAdjusted == true) {      theErr = SndPlayDoubleBuffer (theSoundInfo-&gt;chan, (SndDoubleBufferHeaderPtr)&amp;(theSoundInfo-&gt;doubleHeader));      theErr = InstallCallBack (theSoundInfo);      theSoundInfo-&gt;hasBeenAdjusted = false;    }  }  if (theErr != noErr) {    DebugPrint (&quot;\pError in ResumeSound&quot;);  }  return theErr;}/*-----------------------------------------------------------------------*/    OSErr  ASoundSetBufferSize    (SoundInfoPtr theSoundInfo,                    long newValue)/*-----------------------------------------------------------------------*/{  OSErr      theErr    = noErr;  if (newValue &gt;= nil) {    /* Make sure the buffer is an integer multiple of the packet size,       otherwise IMA will be VERY upset, and WAVE files might not sound       too good either. */    if (theSoundInfo-&gt;doubleHeader.dbhPacketSize &gt; kInit) {      newValue /= theSoundInfo-&gt;bytesPerFrame;//      newValue /= theSoundInfo-&gt;doubleHeader.dbhPacketSize * theSoundInfo-&gt;doubleHeader.dbhNumChannels;    }    newValue *= theSoundInfo-&gt;bytesPerFrame;//    newValue *= theSoundInfo-&gt;doubleHeader.dbhPacketSize * theSoundInfo-&gt;doubleHeader.dbhNumChannels;    theSoundInfo-&gt;doubleBufferSize = newValue;  }  else {    theSoundInfo-&gt;doubleBufferSize = kInit;    DebugPrint (&quot;\pBad value passed to ASoundSetBufferSize&quot;);    theErr = kBadValue;  }  if (theErr != noErr) {    DebugPrint (&quot;\pError in ASoundSetBufferSize&quot;);  }  return theErr;}/*-----------------------------------------------------------------------*/    OSErr  ASoundSetSoundLength  (SoundInfoPtr theSoundInfo,                    long newValue)/*-----------------------------------------------------------------------*/{  OSErr      theErr    = noErr;  if (newValue &gt;= nil) {    theSoundInfo-&gt;bytesTotal = newValue;  }  else {    theSoundInfo-&gt;bytesTotal = kInit;    theErr = kBadValue;  }  if (theErr != noErr) {    DebugPrint (&quot;\pError in ASoundSetSoundLength&quot;);  }  return theErr;}/*  Purpose:    The purpose of this routine is to fill out the          SndDoubleBufferHeader structure with the information the          Sound Manager will need, and to fill out the          myParamBlockRec structure with the information the          ASoundDoubleBackProc interrupt routine will need.  It          then calls ASoundDoubleBackProc to fill the first two          buffers.  Side effects:  This routine allocates two pointers as buffers for the          sound that will be playing.          This routine allocates two custom paramBlockRecs for          the ASoundDoubleBackProc (interrupt routine) to use.*//*-----------------------------------------------------------------------*/    OSErr  ASoundPrimeBuffers    (SoundInfoPtr theSoundInfo)/*-----------------------------------------------------------------------*/{  myParmBlkPtr    myPB      = nil;  SndDoubleBufferPtr  doubleBuffer  = nil;  IOCompletionUPP    myIOCompletion  = nil;  OSErr        theErr      = noErr;  short        i        = kInit;  for (i = kInit; i &lt;= kOne; ++i) {    if (theSoundInfo-&gt;doubleHeader.dbhBufferPtr[i] == nil) {      doubleBuffer = (SndDoubleBufferPtr)NewPtrClear (sizeof(SndDoubleBuffer) + ASoundGetBufferSize (theSoundInfo));      if (doubleBuffer == nil || MemError() != noErr) {        DebugPrint(&quot;\pNo memory for double buffers!&quot;);        theErr = memFullErr;      }      else {        /* Hold the memory in case VM is on, this will help to ensure that we have no sound           drop outs caused by the paging of our buffers. */        HoldMemory (doubleBuffer, sizeof(SndDoubleBuffer) + ASoundGetBufferSize (theSoundInfo));        /* dbNumFrames gets set in the ASoundDoubleBackProc() routine */        doubleBuffer-&gt;dbFlags = nil;        doubleBuffer-&gt;dbUserInfo[kSndInfoPtr] = (long)theSoundInfo;    /* Make this point at our SoundInfo struct */        myPB = (myParamBlockRec *)NewPtrClear(sizeof(myParamBlockRec));    /* Make one for each buffer so */        if (myPB == nil || MemError() != noErr) {              /* we don't reuse the same paramBlock in */          DebugPrint(&quot;\pNo memory for a new paramBlockRec!&quot;);        /* the ioCompletion routine. */          theErr = memFullErr;        }        else {          myPB-&gt;myA5 = SetCurrentA5 ();          myPB-&gt;theSoundInfo = theSoundInfo;          myIOCompletion = NewIOCompletionProc (ASoundFileCallBack);          myPB-&gt;pb.ioParam.ioCompletion = myIOCompletion;          myPB-&gt;pb.ioParam.ioVRefNum = theSoundInfo-&gt;vRefNum;          myPB-&gt;pb.ioParam.ioRefNum = theSoundInfo-&gt;refNum;          myPB-&gt;pb.ioParam.ioPosMode = fsFromStart | noCacheMask;        /* Set the noCacheBit since we probably won't be reading this again */          doubleBuffer-&gt;dbUserInfo[kPBPtr] = (long)myPB;          theSoundInfo-&gt;doubleHeader.dbhBufferPtr[i] = doubleBuffer;        }      }    }    else {      doubleBuffer = theSoundInfo-&gt;doubleHeader.dbhBufferPtr[i];    }    ASoundDoubleBackProc (theSoundInfo-&gt;chan, doubleBuffer);  /* prime the buffers */  }  if (theErr != noErr) {    DebugPrint (&quot;\pError in ASoundPrimeBuffers&quot;);    for (i = kInit; i &lt;= kOne; ++i) {      if (!theSoundInfo-&gt;doubleHeader.dbhBufferPtr[i]) {        DisposePtr ((Ptr)myIOCompletion);        DisposePtr ((Ptr)theSoundInfo-&gt;doubleHeader.dbhBufferPtr[i]-&gt;dbUserInfo[kSndInfoPtr]);        DisposePtr ((Ptr)theSoundInfo-&gt;doubleHeader.dbhBufferPtr[i]);      }    }  }  return theErr;}/* This routine is used to calculate where to put the SFGetFile Dialog *//*-----------------------------------------------------------------------*/    Rect  GetMainScreenRect    (void)/*-----------------------------------------------------------------------*/{  GDHandle  mainDevice;  GrafPtr    mainPort;  Rect    returnRect;  long    response;    Gestalt (gestaltQuickdrawVersion, &amp;response);    if (response == gestaltOriginalQD) {    GetWMgrPort (&amp;mainPort);    returnRect = mainPort-&gt;portRect;  }  else {    mainDevice = GetMainDevice();    returnRect = (*mainDevice)-&gt;gdRect;  }  return returnRect;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/SndPlayDoubleBuffer/listing24.html%3Fid%3DDTS10000371-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/SndPlayDoubleBuffer/listing24.html%3Fid%3DDTS10000371-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/SndPlayDoubleBuffer/listing24.html%3Fid%3DDTS10000371-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>