<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>7Edit - /Source/SVEditFile.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">7Edit</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxInterapplicationCommunication-date.html" target="_blank">Carbon > Interapplication Communication</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">7Edit</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Source/SVEditFile.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Source/DebugUtils.c</option>
<option value="listing2.html">/Source/DebugUtils.h</option>
<option value="listing3.html">/Source/Offscreen.c</option>
<option value="listing4.html">/Source/Offscreen.h</option>
<option value="listing5.html">/Source/SVAEAccessors.c</option>
<option value="listing6.html">/Source/SVAEAccessors.h</option>
<option value="listing7.html">/Source/SVAEClone.c</option>
<option value="listing8.html">/Source/SVAEClone.h</option>
<option value="listing9.html">/Source/SVAEClose.c</option>
<option value="listing10.html">/Source/SVAEClose.h</option>
<option value="listing11.html">/Source/SVAECoercions.c</option>
<option value="listing12.html">/Source/SVAECoercions.h</option>
<option value="listing13.html">/Source/SVAECompare.c</option>
<option value="listing14.html">/Source/SVAECompare.h</option>
<option value="listing15.html">/Source/SVAECopy.c</option>
<option value="listing16.html">/Source/SVAECopy.h</option>
<option value="listing17.html">/Source/SVAECountElements.c</option>
<option value="listing18.html">/Source/SVAECountElements.h</option>
<option value="listing19.html">/Source/SVAECreate.c</option>
<option value="listing20.html">/Source/SVAECreate.h</option>
<option value="listing21.html">/Source/SVAECut.c</option>
<option value="listing22.html">/Source/SVAECut.h</option>
<option value="listing23.html">/Source/SVAEDelete.c</option>
<option value="listing24.html">/Source/SVAEDelete.h</option>
<option value="listing25.html">/Source/SVAEGetData.c</option>
<option value="listing26.html">/Source/SVAEGetData.h</option>
<option value="listing27.html">/Source/SVAEGetDataSize.c</option>
<option value="listing28.html">/Source/SVAEGetDataSize.h</option>
<option value="listing29.html">/Source/SVAEMove.c</option>
<option value="listing30.html">/Source/SVAEMove.h</option>
<option value="listing31.html">/Source/SVAEObjectsExist.c</option>
<option value="listing32.html">/Source/SVAEObjectsExist.h</option>
<option value="listing33.html">/Source/SVAEPaste.c</option>
<option value="listing34.html">/Source/SVAEPaste.h</option>
<option value="listing35.html">/Source/SVAERecording.c</option>
<option value="listing36.html">/Source/SVAERecording.h</option>
<option value="listing37.html">/Source/SVAERevert.c</option>
<option value="listing38.html">/Source/SVAERevert.h</option>
<option value="listing39.html">/Source/SVAESave.c</option>
<option value="listing40.html">/Source/SVAESave.h</option>
<option value="listing41.html">/Source/SVAESelect.c</option>
<option value="listing42.html">/Source/SVAESelect.h</option>
<option value="listing43.html">/Source/SVAESetData.c</option>
<option value="listing44.html">/Source/SVAESetData.h</option>
<option value="listing45.html">/Source/SVAETextUtils.c</option>
<option value="listing46.html">/Source/SVAETextUtils.h</option>
<option value="listing47.html">/Source/SVAEWindowUtils.c</option>
<option value="listing48.html">/Source/SVAEWindowUtils.h</option>
<option value="listing49.html">/Source/SVAppleEvents.c</option>
<option value="listing50.html">/Source/SVAppleEvents.h</option>
<option value="listing51.html">/Source/SVDrag.c</option>
<option value="listing52.html">/Source/SVDrag.h</option>
<option value="listing53.html">/Source/SVEditAEUtils.c</option>
<option value="listing54.html">/Source/SVEditAEUtils.h</option>
<option value="listing55.html">/Source/SVEditFile.c</option>
<option value="listing56.html">/Source/SVEditFile.h</option>
<option value="listing57.html">/Source/SVEditGlobals.c</option>
<option value="listing58.html">/Source/SVEditGlobals.h</option>
<option value="listing59.html">/Source/SVEditMain.c</option>
<option value="listing60.html">/Source/SVEditMain.h</option>
<option value="listing61.html">/Source/SVEditPrinting.c</option>
<option value="listing62.html">/Source/SVEditPrinting.h</option>
<option value="listing63.html">/Source/SVEditUtils.c</option>
<option value="listing64.html">/Source/SVEditUtils.h</option>
<option value="listing65.html">/Source/SVEditWindow.c</option>
<option value="listing66.html">/Source/SVEditWindow.h</option>
<option value="listing67.html">/Source/SVToken.h</option></select>
				</p>
				</form>
				<p><strong><a href="7Edit.zip">Download Sample</a></strong> (&#147;7Edit.zip&#148;, 205.9K)<BR>
<strong><a href="7Edit.dmg">Download Sample</a></strong> (&#147;7Edit.dmg&#148;, 251.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    SVEditFile.c  Contains:    Written by: Original version by Jon Lansdell and Nigel Humphreys.              3.1 updates by Greg Sutton.    Copyright:  Copyright &copy;1995-1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        7/19/1999  Karl Groethe  Updated for Metrowerks Codewarror Pro 2.1        */#include &lt;Errors.h&gt;#include &lt;Resources.h&gt;#include &lt;Desk.h&gt;#include &lt;DriverServices.h&gt;#include &lt;AppleEvents.h&gt;#include &lt;AERegistry.h&gt;#include &lt;StandardFile.h&gt;#include &quot;SVEditFile.h&quot;#include &quot;Offscreen.h&quot;#include &lt;TextUtils.h&gt;/**-----------------------------------------------------------------------    Name:       FileError    Purpose:    Puts up an error alert.  -----------------------------------------------------------------------**/    #pragma segment Filepascal void FileError(Str255 s, Str255 f)  {    short    alertResult;    SetCursor(&amp;qd.arrow);    ParamText(s, f, (unsigned char *)&quot;&quot;, (unsigned char *)&quot;&quot;);    alertResult = Alert(ErrorAlert, nil);  }/**-----------------------------------------------------------------------    Name:       DoClose    Purpose:    Closes a window.  -----------------------------------------------------------------------**/#pragma segment Filepascal OSErr DoClose(WindowPtr aWindow,Boolean canInteract,DescType dialogAnswer){  DPtr    aDocument;  short   alertResult;  OSErr   myErr;              myErr = noErr;      if (gWCount&gt;0)  {    aDocument = DPtrFromWindowPtr(aWindow);                if (aDocument-&gt;dirty)      if (canInteract &amp;&amp; (dialogAnswer==kAEAsk))      {        alertResult = DoFileDialog ( kSaveDontsaveDialog, aWindow );        switch ( alertResult )        {          case kStdOkItemIndex:            if (aDocument-&gt;everSaved == false)            {              myErr = GetFileNameToSaveAs(aDocument);              if (myErr == noErr)                myErr = DoSave(aDocument, aDocument-&gt;theFSSpec);                                                  }            else              myErr = SaveUsingTemp(aDocument);          break;                                          case kStdCancelItemIndex:            return(userCanceledErr);          break;                    case kDontSaveItemIndex:            aDocument-&gt;dirty = false;          break;        }      }      else      {        if (dialogAnswer==kAEYes)          if (aDocument-&gt;everSaved == false)          {            if (canInteract)            {              myErr = GetFileNameToSaveAs(aDocument);              if (myErr==noErr)                myErr = DoSave(aDocument, aDocument-&gt;theFSSpec);            }            else                return(errAENoUserInteraction);          }          else            myErr = SaveUsingTemp(aDocument);        else          myErr = noErr; /* Don't save */      }              if (myErr==noErr)      {        CloseMyWindow(aWindow);      }  }  else    myErr = errAEIllegalIndex;        return(myErr);}//// This is called to display the &quot;save before closing&quot; and &quot;revert&quot; dialogs.//short DoFileDialog ( short theDlogID, WindowRef theWindow ){  short    theItem;  DialogRef  theDialog;  WindowRef  dialogWindow;  DPtr      theDocument;  Str255    theTitle, theReason;      theDocument = DPtrFromWindowPtr ( theWindow );    theDialog = GetNewDialog ( theDlogID, nil, (WindowRef) -1 );  dialogWindow = GetDialogWindow ( theDialog );  SetPortWindowPort ( dialogWindow );      if ( theDocument-&gt;everSaved == false )    GetWTitle ( theWindow, theTitle );     // Pick it up as a script may have changed it  else    PStrCopy ( theTitle, theDocument-&gt;theFileName );  if ( gQuitting )    GetIndString ( theReason, kMiscStrings, kQuittingIndex );  else    GetIndString ( theReason, kMiscStrings, kClosingindex );    SetCursor ( &amp;qd.arrow );  ParamText ( theTitle, theReason, nil, nil );  ShowWindow ( dialogWindow );  SelectWindow ( dialogWindow );    SetDialogDefaultItem ( theDialog, kStdOkItemIndex );  SetDialogCancelItem ( theDialog, kStdCancelItemIndex );      // As long as the only enabled items are the dimissers,   // there is no need to call ModalDialog within a loop.  ModalDialog ( nil, &amp;theItem );  DisposeDialog ( theDialog );    return theItem;}    #pragma segment File//  DoQuit//  saveOpt - one of kAEAsk,kAEYes,kAENo//  if kAEYes or kAEAsk then AEInteactWithUser should have been called//  before DoQuit. Assumes that it can interact if it needs to.pascal void DoQuit ( DescType saveOpt ){  WindowPtr    aWindow;    WindowPtr    nextWindow;    WindowPeek   nextWPeek;    short        theKind;    OSErr        check;      aWindow = FrontWindow();    gQuitting = true;  while ( aWindow )  {    nextWPeek  = ((WindowPeek)aWindow)-&gt;nextWindow;    nextWindow = &amp;nextWPeek-&gt;port;    if (Ours(aWindow))    {      check = DoClose(aWindow, true, saveOpt);      if ( check != noErr )      {        gQuitting = false;        return;      }    }    else    {      theKind = ((WindowPeek)aWindow)-&gt;windowKind;      if (theKind &lt; 0)        CloseDeskAcc(theKind);    }    aWindow = nextWindow;  }    return;  } // DoQuitpascal OSErr GetFile(FSSpec *theFSSpec)  {    SFTypeList         myTypes;    StandardFileReply  reply;    myTypes[0] = 'TEXT';    StandardGetFile(nil, 1, myTypes, &amp;reply);    if (reply.sfGood)      {        *theFSSpec = reply.sfFile;        return(noErr);      }    else      return(userCanceledErr); }#pragma segment Filepascal OSErr DoCreate(FSSpec theSpec)  {      OSErr err;      err = FSpCreate(&amp;theSpec, SVEditAppSig, 'TEXT', smSystemScript);      if (err != noErr)        ShowError((unsigned char *)&quot;\pDoCreate&quot;, err);              return(err);  }#pragma segment Filepascal OSErr WriteFile(DPtr theDocument, short refNum, FSSpec theFSSpec)  {    short        resFile;    long         length;    HHandle      theHHandle;    StScrpHandle theSHandle;    OSErr        err;    StringHandle theAppName;  short        oldSelStart;  short        oldSelEnd;  Handle       thePHandle;  Handle       myText;    tWindowOffscreen*  theOffscreen = nil;        /*        WriteFile := 1; */    /*first write out the text to the data fork*/        length = (*(theDocument-&gt;theText))-&gt;teLength;        myText = (*(theDocument-&gt;theText))-&gt;hText;        HLock(myText);        err = FSWrite(refNum, &amp;length, *myText);    if (err)      return(err);          HUnlock(myText);    /*we are writing to a temporary file, so we need to create the resource file*/    /*before writing out the resources*/    /*now open the resource file*/        HCreateResFile(theFSSpec.vRefNum, theFSSpec.parID, theFSSpec.name);    err = ResError();    if (err)      {        ShowError((unsigned char *)&quot;\pHCreateResFile&quot;, err);        return(err);      }    resFile = HOpenResFile(theFSSpec.vRefNum, theFSSpec.parID, theFSSpec.name, fsWrPerm);    err = ResError();    if (err)      {        ShowError((unsigned char *)&quot;\pHOpenResFile&quot;, err);        return(err);      }     /*write out our 'TFSF' resource to file*/        //  Draw everything into offscreen pixmap.  theOffscreen = DrawOffscreen ( theDocument-&gt;theWindow );  if ( theOffscreen  )    (*theDocument-&gt;theText)-&gt;inPort = (GrafPtr) theOffscreen-&gt;offscreenWorld;        oldSelStart = (*(theDocument-&gt;theText))-&gt;selStart;  oldSelEnd   = (*(theDocument-&gt;theText))-&gt;selEnd;  TESetSelect(0,32000, theDocument-&gt;theText);      theSHandle = TEGetStyleScrapHandle(theDocument-&gt;theText);    TESetSelect(oldSelStart,oldSelEnd, theDocument-&gt;theText);      if ( theOffscreen )  {    // If it wasn't for the caret, we wouldn't need to draw this    theOffscreen = DrawOnscreen ( theOffscreen );    (*theDocument-&gt;theText)-&gt;inPort = theDocument-&gt;theWindow;  }      AddResource((Handle)theSHandle, 'TFSF', 255, (unsigned char *)&quot;\pStyle Info&quot;);    err = ResError();    if (err)      {        ShowError((unsigned char *)&quot;\pAddResource- TFSF&quot;, err);        return(err);      }          // write out the printer info          // First the QD info            if (theDocument-&gt;thePrintSetup)      {        thePHandle = (Handle)theDocument-&gt;thePrintSetup;        err = HandToHand(&amp;thePHandle);                AddResource(thePHandle, 'TFSP', 255, (unsigned char *)&quot;\pPrinter Info&quot;);        err = ResError();        if (err)          {            ShowError((unsigned char *)&quot;\pAddResource- TFSP&quot;, err);            return(err);          }      }                    theHHandle = (HHandle)NewHandle(sizeof(HeaderRec));    HLock((Handle)theHHandle);    GetFontName(theDocument-&gt;theFont, (unsigned char *)&amp;(*theHHandle)-&gt;theFont);    (*theHHandle)-&gt;theSize     = theDocument-&gt;theSize;    (*theHHandle)-&gt;theStyle    = theDocument-&gt;theStyle;    (*theHHandle)-&gt;lastID      = theDocument-&gt;lastID;    HUnlock((Handle)theHHandle);    AddResource((Handle)theHHandle, 'TFSS', 255, (unsigned char *)&quot;\pHeader Info&quot;);    err = ResError();    if (err)      {        ShowError((unsigned char *)&quot;\pAddResource- TFSS&quot;, err);        return(err);      }    /*if we have any sections, write out the records and resources*/        /*Now put an AppName in for Finder in 7.0*/    theAppName = (StringHandle)NewHandle(6);    PStrCopy(*theAppName,(unsigned char *)&quot;\p7Edit&quot;);        AddResource((Handle)theAppName, 'STR ', - 16396, (unsigned char *)&quot;\pFinder App Info&quot;);    err = ResError();    if (err)      {        ShowError((unsigned char *)&quot;\pAppName&quot;, err);        return(err);      }    CloseResFile(resFile);    return(noErr);  } /* WriteFile */#pragma segment Filepascal OSErr ReadFile(DPtr theDocument, short  refNum, Str255 fn) {        long            theSize;        short           resFile;        OSErr           err;        HHandle         aHandle;        Handle          gHandle;    Boolean     gotQDPrintRec;        gotQDPrintRec = false;        err = GetEOF(refNum, &amp;theSize);        if (err)          return(err);        /*we're only using TE, so check that there is not more than 32K worth of text*/                if (theSize &gt; 32000)          return(1);        gHandle = NewHandle(theSize);        HLock(gHandle);        err = FSRead(refNum, &amp;theSize, *gHandle);                if (err)          {            HUnlock(gHandle);            return(err);          }                        resFile = HOpenResFile(theDocument-&gt;theFSSpec.vRefNum,                                theDocument-&gt;theFSSpec.parID,                               fn,                               fsWrPerm);        if (resFile == -1)          err = fnfErr;                  if (err==noErr)          {            aHandle = nil;                if (Count1Resources('TFSS'))              aHandle = (HHandle)Get1Resource('TFSS', 255);            /*              New Format Info            */                        aHandle = nil;                        if (Count1Resources('TFSF'))              aHandle = (HHandle)Get1Resource('TFSF', 255);                          HLock(gHandle);            TEStyleInsert(  *gHandle,                          GetHandleSize(gHandle),                          (StScrpHandle)aHandle,                          theDocument-&gt;theText);                                HUnlock(gHandle);                        /*              If there is a print record saved, ditch the old one              created by new document and fill this one in            */            if (Count1Resources('TFSP'))            {              if (theDocument-&gt;thePrintSetup)                DisposeHandle((Handle)theDocument-&gt;thePrintSetup);                            theDocument-&gt;thePrintSetup = (THPrint)Get1Resource('TFSP', 255);                err = HandToHand((Handle *)&amp;theDocument-&gt;thePrintSetup);                            gotQDPrintRec = true;                  }            CloseResFile(resFile);                err = ResError();            if (err)              {                ShowError((unsigned char *)&quot;\pread file- CloseResFile&quot;, err);                return(err);              }          }        else          TESetText(*gHandle,                     GetHandleSize(gHandle),                     theDocument-&gt;theText);                  if (gHandle)          DisposeHandle(gHandle);                  if (err==fnfErr)          err = noErr;        return(err);    } /* ReadFile *//** -----------------------------------------------------------------------    Name:       GetFileContents    Purpose:    Opens the document specified by theFSSpec and puts                the contents into theDocument.   -----------------------------------------------------------------------**/    #pragma segment Filepascal OSErr GetFileContents(FSSpec theFSSpec, DPtr theDocument)  {     OSErr            err;     short            theRefNum;      /*this can be called from two places- on an OpenDoc AppleEvent*/      /*and by the user just selecting Open from the File Menu*/      /*assume that the CFS is correct when the routine is called*/      err = FSpOpenDF(&amp;theFSSpec,                      fsRdWrPerm,                      &amp;theRefNum);      if (err)        {          ShowError((unsigned char *)&quot;\pFSpOpenDF&quot;, err);          return(err);        }      else        {          err = ReadFile(theDocument, theRefNum, theFSSpec.name);          if (err)            {              ShowError((unsigned char *)&quot;\pReadFile&quot;, err);              return(err);            }          err=FSClose(theRefNum);          if (err)            {              ShowError((unsigned char *)&quot;\pFSClose&quot;, err);              return(err);            }          return(noErr);        }    }    #pragma segment Filepascal OSErr SaveUsingTemp(DPtr theDocument)  {    Str255           tempName;    OSErr            err;    FSSpec            tempFSSpec;    /*save the file to disk using a temporary file*/    /*this is the recommended way of doing things*/    /*first write out the file to disk using a temporary filename*/    /*if it is sucessfully written, exchange the temporary file with the last one saved*/    /*then delete the temporary file- so if anything goes wrong, the original version is still there*/    /*first generate the temporary filename*/    GetTempFileName(theDocument, tempName);    /*create this file on disk*/    tempFSSpec      = theDocument-&gt;theFSSpec;    PStrCopy(tempFSSpec.name,tempName);          err = DoCreate(tempFSSpec);      /*now save the file as normal*/        if (err==noErr)      err = DoSave(theDocument, tempFSSpec);        if (err == noErr)      err = FSpExchangeFiles(&amp;tempFSSpec, &amp;theDocument-&gt;theFSSpec);    /*we've exchanged the files, now delete the temporary one*/        if (err==noErr)      err = FSpDelete(&amp;tempFSSpec);    return(err);  }    #pragma segment File/*  Fills in the document record with the user chosen destination*/pascal OSErr GetFileNameToSaveAs(DPtr theDocument)  {          StandardFileReply   reply;    OSErr               err;    Str255              suggestName;    GetWTitle(theDocument-&gt;theWindow, suggestName);    StandardPutFile((unsigned char *)&quot;\pSave Document As:&quot;, suggestName, &amp;reply);    if (reply.sfGood)      {                err = FSpDelete(&amp;reply.sfFile);                if (!((err==noErr) || (err==fnfErr)))          return(err);        else          err = noErr;                  theDocument-&gt;theFSSpec = reply.sfFile;        PStrCopy(theDocument-&gt;theFileName, reply.sfFile.name);      }    else      err = userCanceledErr;        return(err); } /* GetFileNameToSaveAs */    #pragma segment Filepascal OSErr DoSave(DPtr   theDocument, FSSpec theFSSpec)  {    short      refNum;    OSErr      fileErr;    fileErr = FSpOpenDF(&amp;theFSSpec, fsRdWrPerm, &amp;refNum);        if (fileErr == fnfErr)      {        fileErr = DoCreate(theFSSpec);                if (fileErr)          return(fileErr);                  fileErr = FSpOpenDF(&amp;theFSSpec, fsRdWrPerm, &amp;refNum);      }    if (fileErr == noErr)      {        fileErr = WriteFile(theDocument, refNum, theFSSpec);                if (fileErr==noErr)          theDocument-&gt;dirty = false;                  fileErr = FSClose(refNum);      }    else      FileError((unsigned char *)&quot;\perror opening file &quot;, theFSSpec.name);        return(fileErr);  }    #pragma segment Filepascal OSErr OpenOld(FSSpec aFSSpec)  {        DPtr  theDocument;    OSErr fileErr;    theDocument = NewDocument(true, (WindowPtr)-1L);        SetWTitle(theDocument-&gt;theWindow, aFSSpec.name);        SetPort(theDocument-&gt;theWindow);        theDocument-&gt;theFSSpec   = aFSSpec;        PStrCopy(theDocument-&gt;theFileName,aFSSpec.name);        theDocument-&gt;dirty       = false;    theDocument-&gt;everSaved   = true;    fileErr = GetFileContents(aFSSpec, theDocument);        if (fileErr == noErr)      {        DoResizeWindow(theDocument);        ShowWindow(theDocument-&gt;theWindow);      }    else      FileError((unsigned char *)&quot;\pError Opening &quot;, aFSSpec.name);              return(fileErr);  } /* OpenOld */    #pragma segment Filepascal OSErr OpenUsingAlias(AliasHandle theAliasH)  {    OSErr    err;    FSSpec   aFSSpec;    Boolean  dummy;    err = ResolveAlias(nil, theAliasH, &amp;aFSSpec, &amp;dummy);        if (err == noErr)      err = OpenOld(aFSSpec);              return(err);  }</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/7Edit/listing55.html%3Fid%3DDTS10000200-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/7Edit/listing55.html%3Fid%3DDTS10000200-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/7Edit/listing55.html%3Fid%3DDTS10000200-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>