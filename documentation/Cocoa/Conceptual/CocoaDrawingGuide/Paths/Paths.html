<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Cocoa Drawing Guide: Paths</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Paths"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40003290-CH206" title="Paths"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../GraphicsImaging-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000450" target="_top">Graphics &amp; Imaging</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP40003290-CH201-SW1">Cocoa Drawing Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Color/Color.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../Images/Images.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40003290-CH206-BBCHFJJG" title="Paths"></a><h1>Paths</h1><p>Cocoa provides support for drawing simple or complex geometric shapes using paths. A path is a collection of points used to create primitive shapes such as lines, arcs, and curves. From these primitives, you can create more complex shapes, such as circles, rectangles, polygons, and complex curved shapes, and paint them. Because they are composed of points (as opposed to a rasterized bitmap), paths are lightweight, fast, and scale to different resolutions without losing precision or quality.</p>
<p>The following sections focus primarily on the use of the <code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/cl/NSBezierPath" target="_top">NSBezierPath</a></code> class, which provides the main interface for creating and manipulating paths. Cocoa also provides a handful of functions that offer similar behavior for creating and drawing paths but do not require the overhead of creating an object. Those functions are mentioned where appropriate, but for more information, see <em><a href="../../../Reference/Foundation/ObjC_classic/index.html#//apple_ref/doc/uid/20001091" target="_top">Foundation Framework Reference</a></em> and <em><a href="../../../Reference/ApplicationKit/ObjC_classic/index.html#//apple_ref/doc/uid/20001093" target="_top">Application Kit Framework Reference</a></em>. </p>


<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="Paths.html#//apple_ref/doc/uid/TP40003290-CH206-SW14">Path Building Blocks</a>
				
			<br/>
			
        
			
			
				<a href="Paths.html#//apple_ref/doc/uid/TP40003290-CH206-SW15">The NSBezierPath Class</a>
				
			<br/>
			
        
			
			
				<a href="Paths.html#//apple_ref/doc/uid/TP40003290-CH206-BBCGCFBG">Manipulating Geometric Types</a>
				
			<br/>
			
        
			
			
				<a href="Paths.html#//apple_ref/doc/uid/TP40003290-CH206-SW4">Drawing Fundamental Shapes</a>
				
			<br/>
			
        
			
			
				<a href="Paths.html#//apple_ref/doc/uid/TP40003290-CH206-BBCFABIE">Drawing Rectangles</a>
				
			<br/>
			
        
			
			
				<a href="Paths.html#//apple_ref/doc/uid/TP40003290-CH206-SW29">Working with Paths</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40003290-CH206-SW14" title="Path Building Blocks"></a><h2>Path Building Blocks</h2>
<p>Cocoa defines several fundamental data types for manipulating geometric information in the drawing environment. These data types include <code><a href="../../../Reference/Foundation/Miscellaneous/Foundation_DataTypes/Reference/reference.html#//apple_ref/c/tdef/NSPoint" target="_top">NSPoint</a></code>, <code><a href="../../../Reference/Foundation/Miscellaneous/Foundation_DataTypes/Reference/reference.html#//apple_ref/c/tdef/NSRect" target="_top">NSRect</a></code>, and <code><a href="../../../Reference/Foundation/Miscellaneous/Foundation_DataTypes/Reference/reference.html#//apple_ref/c/tdef/NSSize" target="_top">NSSize</a></code>. You use these data types to specify lines, rectangles, and width and height information for the shapes you want to draw. Everything from lines and rectangles to circles, arcs, and Bezier curves can be specified using one or more of these data structures.</p>
<p>The coordinate values for point, rectangle, and size data types are all specified using floating-point values. Floating-point values allow for much finer precision as the resolution of the underlying destination device goes up. </p>
<p>The <code>NSPoint</code>, <code>NSRect</code>, and <code>NSSize</code> data types have equivalents in the Quartz environment: <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_603"></a><code><a href="../../../../GraphicsImaging/Reference/CGGeometry/Reference/reference.html#//apple_ref/c/tdef/CGPoint" target="_top">CGPoint</a></code>, <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_604"></a><code><a href="../../../../GraphicsImaging/Reference/CGGeometry/Reference/reference.html#//apple_ref/c/tdef/CGRect" target="_top">CGRect</a></code>, and <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_605"></a><code><a href="../../../../GraphicsImaging/Reference/CGGeometry/Reference/reference.html#//apple_ref/c/tdef/CGSize" target="_top">CGSize</a></code>. Because the layout of the Cocoa and Quartz types are identical, you can convert between two types by casting from one type to its counterpart. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH206-SW15" title="The NSBezierPath Class"></a><h2>The NSBezierPath Class</h2>
<p>The <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_606"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/cl/NSBezierPath" target="_top">NSBezierPath</a></code> class provides the behavior for drawing most primitive shapes, and for many complex shapes, it is the only tool available in Cocoa. An <code>NSBezierPath</code> object encapsulates the information associated with a path, including the points that define the path and the attributes that affect the appearance of the path. The following sections explain how <code>NSBezierPath</code> represents path information and also describe the attributes that affect a path’s appearance. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH206-SW16" title="Path Elements"></a><h3>Path Elements</h3>
<p>An <code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/cl/NSBezierPath" target="_top">NSBezierPath</a></code> object uses <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_607"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_608"></a>path elements to build a path. A path element consists of a primitive command and one or more points. The command tells the path object how to interpret the associated points. When assembled, a set of path elements creates a series of line segments that form the desired shape. </p>
<p>The <code>NSBezierPath</code> class handles much of the work of creating and organizing path elements initially. Knowing how to manipulate path elements becomes important, however, if you want to make changes to an existing path. If you create a complex path based on user input, you might want to give the user the option of changing that path later. Although you could create a new path object with the changes, it is far simpler to modify the existing path elements. (For information on how to modify path elements, see <span class="content_text"><a href="Paths.html#//apple_ref/doc/uid/TP40003290-CH206-BBCICAFC">“Manipulating Individual Path Elements.”</a></span>) </p>
<p>The <code>NSBezierPath</code> class defines only four basic path element commands, which are listed in <span class="content_text">Table 5-1</span>. These commands are enough to define all of the possible path shapes. Each command has one or more points that contain information needed to position the path element. Most path elements use the current drawing point as the starting point for drawing. </p><a name="//apple_ref/doc/uid/TP40003290-CH206-BBCHBGIH" title="Table 5-1Path element commands"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">
<caption class="tablecaption"><strong>Table 5-1&nbsp;&nbsp;</strong>Path element commands</caption>

<tr>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Command</p></th>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Number of points</p></th>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th>
</tr>


<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_609"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/c/econst/NSMoveToBezierPathElement" target="_top">NSMoveToBezierPathElement</a></code></p></td>
<td ><p>1</p></td>
<td ><p>Moves the path object’s current drawing point to the specified point. This path element does not result in any drawing. Using this command in the middle of a path results in a disconnected line <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_610"></a>segment. </p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_611"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/c/econst/NSLineToBezierPathElement" target="_top">NSLineToBezierPathElement</a></code></p></td>
<td ><p>1</p></td>
<td ><p>Creates a straight line from the current drawing point to the specified point. <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_612"></a>Lines and rectangles are specified using this <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_613"></a>path element.</p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_614"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/c/econst/NSCurveToBezierPathElement" target="_top">NSCurveToBezierPathElement</a></code></p></td>
<td ><p>3</p></td>
<td ><p>Creates a <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_615"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_616"></a>curved line segment from the current point to the specified endpoint using two control points to define the curve. The points are stored in the following order: <code>controlPoint1</code>, <code>controlPoint2</code>, <code>endPoint</code>. Ovals, arcs, and Bezier curves all use curve elements to specify their <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_617"></a>geometry.</p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_618"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/c/econst/NSClosePathBezierPathElement" target="_top">NSClosePathBezierPathElement</a></code></p></td>
<td ><p>1</p></td>
<td ><p>Marks the end of the current subpath at the specified point. (Note that the point specified for the Close Path element is essentially the same as the current <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_619"></a>point. </p></td>
</tr>

</table></div>
<p>When you add a new shape to a path, <code>NSBezierPath</code> breaks that shape down into one or more component path elements for storage purposes. For example, calling <code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBezierPath/moveToPoint:" target="_top">moveToPoint:</a></code> or <code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBezierPath/lineToPoint:" target="_top">lineToPoint:</a></code> creates a Move To element or Line To element respectively. In the case of more complex shapes, like rectangles and ovals, several line or curve elements may be created. <span class="content_text">Figure 5-1</span> shows two shapes and the resulting path elements. For the curved segment, the figure also shows the control points that define the curve. </p>
<br/><div><a name="//apple_ref/doc/uid/TP40003290-CH206-BBCHIBJC" title="Figure 5-1Path elements for a complex path"></a><p><strong>Figure 5-1&nbsp;&nbsp;</strong>Path elements for a complex path</p>
<img src = "../art/path_elements.gif" alt = "Path elements for a complex path" width="630" height="349"></div><br/>
<p> <span class="content_text">Listing 5-1</span> shows the code that creates the path shown in <span class="content_text">Figure 5-1</span>.</p>
<a name="//apple_ref/doc/uid/TP40003290-CH206-BBCICBEB" title="Listing 5-1Creating a complex path"></a><p class="codesample"><strong>Listing 5-1&nbsp;&nbsp;</strong>Creating a complex path</p><div class="codesample"><table><tr><td scope="row"><pre>NSBezierPath* aPath = [NSBezierPath bezierPath];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>[aPath moveToPoint:NSMakePoint(0.0, 0.0)];<span></span></pre></td></tr><tr><td scope="row"><pre>[aPath lineToPoint:NSMakePoint(10.0, 10.0)];<span></span></pre></td></tr><tr><td scope="row"><pre>[aPath curveToPoint:NSMakePoint(18.0, 21.0)<span></span></pre></td></tr><tr><td scope="row"><pre>        controlPoint1:NSMakePoint(6.0, 2.0)<span></span></pre></td></tr><tr><td scope="row"><pre>        controlPoint2:NSMakePoint(28.0, 10.0)];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>[aPath appendBezierPathWithRect:NSMakeRect(2.0, 16.0, 8.0, 5.0)];<span></span></pre></td></tr></table></div>
<a name="//apple_ref/doc/uid/TP40003290-CH206-SW17" title="Subpaths"></a><h3>Subpaths</h3>
<p>A <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_620"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_621"></a>subpath is a series of connected line and curve segments within an <code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/cl/NSBezierPath" target="_top">NSBezierPath</a></code> object. A single path object may contain multiple subpaths, with each subpath delineated by a Move To or Close Path element. When you set the initial drawing point (typically using the <code>moveToPoint:</code> method), you set the starting point of the first subpath. As you draw, you build the contents of the subpath until you either close the path (using the <code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBezierPath/closePath" target="_top">closePath</a></code> method) or add another Move To element. At that point, the subpath is considered closed and any new elements are added to a new subpath. </p>
<p>Some methods of <code>NSBezierPath</code> automatically create a new subpath for you. For example, creating a rectangle or oval results in the addition of a Move To element, several drawing elements, and a Close Path and Move To element (see <span class="content_text"><a href="Paths.html#//apple_ref/doc/uid/TP40003290-CH206-BBCHIBJC">Figure 5-1</a></span> for an example). The Move To element at the end of the list of elements ensures that the current drawing point is left in a known location, which in this case is at the rectangle’s origin point. </p>
<p>Subpaths exist to help you distinguish different parts of a path object. For example, subpaths affect the way a path is filled; see <span class="content_text"><a href="Paths.html#//apple_ref/doc/uid/TP40003290-CH206-BAJIJJGD">“Winding Rules.”</a></span> The division of a path into <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_622"></a>subpaths also affects methods such as <code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBezierPath/bezierPathByReversingPath" target="_top">bezierPathByReversingPath</a></code>, which reverses the subpaths one at a time. In other cases, though, subpaths in an <code>NSBezierPath</code> object share the same drawing attributes. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH206-BBCDEJGD" title="Path Attributes"></a><h3>Path Attributes</h3>
<p><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_623"></a>An <code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/cl/NSBezierPath" target="_top">NSBezierPath</a></code> object maintains all of the attributes needed to determine the shape of its path. These attributes include the line width, curve flatness, line cap style, line join style, and miter limit of the path. You set these values using the methods of <code>NSBezierPath</code>. </p>
<p>Path attributes do not take effect until you fill or stroke the path, so if you change an attribute more than once before drawing the path, only the last value is used. The <code>NSBezierPath</code> class maintains both a custom and default version of each attribute. Path objects use custom attribute values if they are set. If no custom attribute value is set for a given path object, the default value is used. The <code>NSBezierPath</code> class does not use path attribute values set using Quartz functions.  </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40003290-CH206-SW18" title="Note"></a><p><strong>Note:</strong>&nbsp;Path attributes apply to the entire path. If you want to use different attributes for different parts of a path, you must create two separate path objects and apply the appropriate attributes to each.</p></div>
<p>The following sections describe the attributes you can set for a path object and how those attributes affect your rendered paths. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH206-BBCECBJC" title="Line Width"></a><h4>Line Width</h4>
<p>The <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_624"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_625"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_626"></a>line width attribute controls the width of the entire path. Line width is measured in points and specified as a floating-point value. The default width for all lines is 1. To change the default line width for all <code>NSBezierPath</code> objects, you use the <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_627"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/clm/NSBezierPath/setDefaultLineWidth:" target="_top">setDefaultLineWidth:</a></code> method. To set the line width for the current path object, you use the <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_628"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBezierPath/setLineWidth:" target="_top">setLineWidth:</a></code> method of that path object. To set the default line width for shapes rendered without an <code>NSBezierPath</code> object, you must use the <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_629"></a><code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextSetLineWidth" target="_top">CGContextSetLineWidth</a></code> function in Quartz. </p>
<p>Fractional line widths are rendered as close as possible to the specified width, subject to the limitations of the destination device, the position of the line, and the current anti-aliasing setting. For example, suppose you want to draw a line whose width is 0.2 points. Multiplying this width by 1/72 points per inch yields a line that is 0.0027778 inches wide. On a 90 dpi screen, the smallest possible line would be 1 pixel wide or 0.0111 inches. To ensure your line is not hidden on the screen, Cocoa nominally draws it at the screen’s larger minimum width (0.0111 inches). In reality, if the line straddles a <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_630"></a>pixel boundary or anti-aliasing is enabled, the line might affect additional pixels on either side of the path. If the output device were a 600 dpi printer instead, Quartz would be able to render the line closer to its true width of 0.0027778 inches.  </p>
<p><span class="content_text">Listing 5-2</span> draws a few paths using different techniques. The <code><a href="../../../Reference/ApplicationKit/Miscellaneous/AppKit_Functions/Reference/reference.html#//apple_ref/c/func/NSFrameRect" target="_top">NSFrameRect</a></code> function uses the default line width to draw a rectangle, so that value must be set prior to calling the function. Path objects use the default value only if a custom value has not been set. You can even change the line width of a path object and draw again to achieve a different path width, although you would also need to move the path to see the difference.</p>
<a name="//apple_ref/doc/uid/TP40003290-CH206-SW5" title="Listing 5-2Setting the line width of a path"></a><p class="codesample"><strong>Listing 5-2&nbsp;&nbsp;</strong>Setting the line width of a path</p><div class="codesample"><table><tr><td scope="row"><pre>// Draw a rectangle using the default line width: 2.0.<span></span></pre></td></tr><tr><td scope="row"><pre>[NSBezierPath setDefaultLineWidth:2.0];<span></span></pre></td></tr><tr><td scope="row"><pre>NSFrameRect(NSMakeRect(20.0, 20.0, 10.0, 10.0));<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Set the line width for a single NSBezierPath object.<span></span></pre></td></tr><tr><td scope="row"><pre>NSBezierPath* thePath = [NSBezierPath bezierPath];<span></span></pre></td></tr><tr><td scope="row"><pre>[thePath setLineWidth:1.0]; // Has no effect.<span></span></pre></td></tr><tr><td scope="row"><pre>[thePath moveToPoint:NSMakePoint(0.0, 0.0)];<span></span></pre></td></tr><tr><td scope="row"><pre>[thePath lineToPoint:NSMakePoint(10.0, 0.0)];<span></span></pre></td></tr><tr><td scope="row"><pre>[thePath setLineWidth:3.0];<span></span></pre></td></tr><tr><td scope="row"><pre>[thePath lineToPoint:NSMakePoint(10.0, 10.0)];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Because the last value set is 3.0, all lines are drawn with<span></span></pre></td></tr><tr><td scope="row"><pre>// a width of 3.0, not just the second line.<span></span></pre></td></tr><tr><td scope="row"><pre>[thePath stroke];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Changing the width and stroking again draws the same path<span></span></pre></td></tr><tr><td scope="row"><pre>// using the new line width.<span></span></pre></td></tr><tr><td scope="row"><pre>[thePath setLineWidth:4.0];<span></span></pre></td></tr><tr><td scope="row"><pre>[thePath stroke];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Changing the default line width has no effect because a custom<span></span></pre></td></tr><tr><td scope="row"><pre>// value already exists. The path is rendered with a width of 4.0.<span></span></pre></td></tr><tr><td scope="row"><pre>[thePath setDefaultLineWidth:5.0];<span></span></pre></td></tr><tr><td scope="row"><pre>[thePath stroke];<span></span></pre></td></tr></table></div>
<a name="//apple_ref/doc/uid/TP40003290-CH206-BBCEIDJI" title="Line Cap Styles"></a><h4>Line Cap Styles</h4>
<p>The current <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_631"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_632"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_633"></a>line cap <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_634"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_635"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_636"></a>style determines the appearance of the open end points of a path segment. Cocoa supports the line cap styles shown in <span class="content_text">Figure 5-2</span>.  </p>
<br/><div><a name="//apple_ref/doc/uid/TP40003290-CH206-BBCCJGAG" title="Figure 5-2Line cap styles"></a><p><strong>Figure 5-2&nbsp;&nbsp;</strong>Line cap styles</p><img src = "../art/linecaps.gif" alt = "Line cap styles" width="281" height="156"></div><br/>
<p>To set the line cap style for a <code>NSBezierPath</code> object, use the <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_637"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBezierPath/setLineCapStyle:" target="_top">setLineCapStyle:</a></code> method. The default line cap style is set to <code>NSButtLineCapStyle</code>. To change the default line cap style, use the <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_638"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/clm/NSBezierPath/setDefaultLineCapStyle:" target="_top">setDefaultLineCapStyle:</a></code> method. <span class="content_text">Listing 5-3</span> demonstrates both of these methods:</p>
<a name="//apple_ref/doc/uid/TP40003290-CH206-SW6" title="Listing 5-3Setting the line cap style of a path"></a><p class="codesample"><strong>Listing 5-3&nbsp;&nbsp;</strong>Setting the line cap style of a path</p><div class="codesample"><table><tr><td scope="row"><pre>[// Set the default line cap style<span></span></pre></td></tr><tr><td scope="row"><pre>[NSBezierPath setDefaultLineCapStyle:NSButtLineCapStyle];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Customize the line cap style for the new object.<span></span></pre></td></tr><tr><td scope="row"><pre>NSBezierPath* aPath = [NSBezierPath bezierPath];<span></span></pre></td></tr><tr><td scope="row"><pre>[aPath moveToPoint:NSMakePoint(0.0, 0.0)];<span></span></pre></td></tr><tr><td scope="row"><pre>[aPath lineToPoint:NSMakePoint(10.0, 10.0)];<span></span></pre></td></tr><tr><td scope="row"><pre>[aPath setLineCapStyle:NSSquareLineCapStyle];<span></span></pre></td></tr><tr><td scope="row"><pre>[aPath stroke];<span></span></pre></td></tr></table></div>
<a name="//apple_ref/doc/uid/TP40003290-CH206-BBCFDEIE" title="Line Join Styles"></a><h4>Line Join Styles</h4>
<p>The current <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_639"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_640"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_641"></a>line join <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_642"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_643"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_644"></a>style determines how connected lines in a path are joined at the vertices. Cocoa supports the line join styles shown in <span class="content_text">Figure 5-3</span>.</p>
<br/><div><a name="//apple_ref/doc/uid/TP40003290-CH206-BBCGIDGE" title="Figure 5-3Line join styles"></a><p><strong>Figure 5-3&nbsp;&nbsp;</strong>Line join styles</p><img src = "../art/linejoins.gif" alt = "Line join styles" width="270" height="234"></div><br/>
<p>To set the line join style for an <code>NSBezierPath</code> object, use the <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_645"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBezierPath/setLineJoinStyle:" target="_top">setLineJoinStyle:</a></code> method. The default line join style is set to <code>NSMiterLineJoinStyle</code>. To change the default line join style, use the <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_646"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/clm/NSBezierPath/setDefaultLineJoinStyle:" target="_top">setDefaultLineJoinStyle:</a></code> method. <span class="content_text">Listing 5-4</span> demonstrates both of these methods:</p>
<a name="//apple_ref/doc/uid/TP40003290-CH206-SW7" title="Listing 5-4Setting the line join style of a path"></a><p class="codesample"><strong>Listing 5-4&nbsp;&nbsp;</strong>Setting the line join style of a path</p><div class="codesample"><table><tr><td scope="row"><pre>[// Set the default line join style<span></span></pre></td></tr><tr><td scope="row"><pre>[NSBezierPath setDefaultLineJoinStyle:NSMiterLineJoinStyle];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Customize the line join style for a new path.<span></span></pre></td></tr><tr><td scope="row"><pre>NSBezierPath* aPath = [NSBezierPath bezierPath];<span></span></pre></td></tr><tr><td scope="row"><pre>[aPath moveToPoint:NSMakePoint(0.0, 0.0)];<span></span></pre></td></tr><tr><td scope="row"><pre>[aPath lineToPoint:NSMakePoint(10.0, 10.0)];<span></span></pre></td></tr><tr><td scope="row"><pre>[aPath lineToPoint:NSMakePoint(10.0, 0.0)];<span></span></pre></td></tr><tr><td scope="row"><pre>[aPath setLineJoinStyle:NSRoundLineJoinStyle];<span></span></pre></td></tr><tr><td scope="row"><pre>[aPath stroke];<span></span></pre></td></tr></table></div>
<a name="//apple_ref/doc/uid/TP40003290-CH206-SW19" title="Line Dash Style"></a><h4>Line Dash Style</h4>
<p>The <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_647"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_648"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_649"></a>line dash style determines the pattern used to stroke a path. By default, stroked paths appear solid. Using a line-dash pattern, you can specify an alternating group of solid and transparent swatches. When setting a line dash pattern, you specify the width (in points) of each successive solid or transparent swatch. The widths you specify are then repeated over the entire length of the path.</p>
<p><span class="content_text">Figure 5-4</span> shows some sample line dash patterns, along with the values used to create each pattern. </p>
<br/><div><a name="//apple_ref/doc/uid/TP40003290-CH206-BAJBICGH" title="Figure 5-4Line dash patterns"></a><p><strong>Figure 5-4&nbsp;&nbsp;</strong>Line dash patterns</p>
<img src = "../art/linedash.gif" alt = "Line dash patterns" width="539" height="168"></div><br/>
<p>The <code>NSBezierPath</code> class does not support the concept of a default line dash style. If you want a line dash style, you must apply it to a path explicitly using the <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_650"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBezierPath/setLineDash:count:phase:" target="_top">setLineDash:count:phase:</a></code> method as shown in <span class="content_text">Listing 5-5</span>, which renders the last pattern from the preceding figure.</p>
<a name="//apple_ref/doc/uid/TP40003290-CH206-SW8" title="Listing 5-5Adding a dash style to a path"></a><p class="codesample"><strong>Listing 5-5&nbsp;&nbsp;</strong>Adding a dash style to a path</p><div class="codesample"><table><tr><td scope="row"><pre>void AddDashStyleToPath(NSBezierPath* thePath)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // Set the line dash pattern.<span></span></pre></td></tr><tr><td scope="row"><pre>    float lineDash[6];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    lineDash[0] = 40.0;<span></span></pre></td></tr><tr><td scope="row"><pre>    lineDash[1] = 12.0;<span></span></pre></td></tr><tr><td scope="row"><pre>    lineDash[2] = 8.0;<span></span></pre></td></tr><tr><td scope="row"><pre>    lineDash[3] = 12.0;<span></span></pre></td></tr><tr><td scope="row"><pre>    lineDash[4] = 8.0;<span></span></pre></td></tr><tr><td scope="row"><pre>    lineDash[5] = 12.0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>   [thePath setLineDash:lineDash count:6 phase:0.0];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<a name="//apple_ref/doc/uid/TP40003290-CH206-BBCBBHIG" title="Line Flatness"></a><h4>Line Flatness</h4>
<p>The line <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_651"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_652"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_653"></a>flatness attribute determines the rendering accuracy for curved segments. The flatness value measures the maximum error tolerance (in pixels) to use during rendering. Smaller values result in <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_654"></a>smoother <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_655"></a>curves but require more computation time. Larger values result in more jagged curves but are rendered much faster. </p>
<p>Line flatness is one parameter you can tweak when you want to render a large number of curves quickly and do not care about accuracy. For example, you might increase this value during a live resize or scrolling operation when accuracy is not as crucial. Regardless, you should always measure performance to make sure such a modification actually saves time. </p>
<p><span class="content_text">Figure 5-5</span> shows how changing the default flatness affects curved surfaces. The figure on the left shows a group of curved surfaces rendered with the flatness value set to <code>0.6</code> (its default value). The figure on the right shows the same curved surfaces rendered with the flatness value set to <code>20</code>. The curvature of each surface is lost and now appears to be a set of connected line segments. </p>
<br/><div><a name="//apple_ref/doc/uid/TP40003290-CH206-BBCGDCEE" title="Figure 5-5Flatness effects on curves"></a><p><strong>Figure 5-5&nbsp;&nbsp;</strong>Flatness effects on curves</p>
<img src = "../art/flatness_comparison.gif" alt = "Flatness effects on curves" width="226" height="139"></div><br/>
<p>To set the flatness for a specific <code>NSBezierPath</code> object, use the <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_656"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBezierPath/setFlatness:" target="_top">setFlatness:</a></code> method. To set the default flatness value, use <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_657"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/clm/NSBezierPath/setDefaultFlatness:" target="_top">setDefaultFlatness:</a></code>, as shown in <span class="content_text">Listing 5-6</span>:</p>
<a name="//apple_ref/doc/uid/TP40003290-CH206-SW9" title="Listing 5-6Setting the flatness of a path"></a><p class="codesample"><strong>Listing 5-6&nbsp;&nbsp;</strong>Setting the flatness of a path</p><div class="codesample"><table><tr><td scope="row"><pre>[- (void) drawRect:(NSRect)rect<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if ([self inLiveResize])<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Adjust the default flatness upward to reduce<span></span></pre></td></tr><tr><td scope="row"><pre>        // the number of required computations.<span></span></pre></td></tr><tr><td scope="row"><pre>        [NSBezierPath setDefaultFlatness:10.0];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Draw live resize content.<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    // ...<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<a name="//apple_ref/doc/uid/TP40003290-CH206-BBCFHEIF" title="Miter Limits"></a><h4>Miter Limits</h4>
<p><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_658"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_659"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_660"></a>Miter limits help you avoid spikes that occur when you join two line segments at a <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_661"></a>sharp angle. If the ratio of the miter length—the diagonal length of the miter—to the line thickness exceeds the miter limit, the corner is drawn using a bevel join instead of a miter join. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40003290-CH206-SW20" title="Note"></a><p><strong>Note:</strong>&nbsp;Miter limits apply only to paths rendered using the miter join style.</p></div>
<p><span class="content_text">Figure 5-6</span> shows an example of how different miter limits affect the same path. This path consists of several 10-point wide lines connected by miter joins. In the figure on the left, the miter limit is set to <code>5</code>. Because the miter lengths exceed the miter limit, the line joins are changed to bevel joins. By increasing the miter limit to <code>16</code>, as shown in the figure on the right, the miter joins are restored but extend far beyond the point where the two lines meet. </p>
<br/><div><a name="//apple_ref/doc/uid/TP40003290-CH206-BBCIBHEG" title="Figure 5-6Miter limit effects"></a><p><strong>Figure 5-6&nbsp;&nbsp;</strong>Miter limit effects</p>
<img src = "../art/miter_limits.gif" alt = "Miter limit effects" width="371" height="301"></div><br/>
<p>To set the miter limits for a specific <code>NSBezierPath</code> object, use the <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_662"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBezierPath/setMiterLimit:" target="_top">setMiterLimit:</a></code> method. To set the default miter limit for newly created <code>NSBezierPath</code> objects, use <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_663"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/clm/NSBezierPath/setDefaultMiterLimit:" target="_top">setDefaultMiterLimit:</a></code>. <span class="content_text">Listing 5-7</span> demonstrates both of these methods:</p>
<a name="//apple_ref/doc/uid/TP40003290-CH206-SW10" title="Listing 5-7Setting the miter limit for a path"></a><p class="codesample"><strong>Listing 5-7&nbsp;&nbsp;</strong>Setting the miter limit for a path</p><div class="codesample"><table><tr><td scope="row"><pre>// Increase the default limit<span></span></pre></td></tr><tr><td scope="row"><pre>[NSBezierPath setDefaultMiterLimit:20.0];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Customize the limit for a specific path with sharp angles.<span></span></pre></td></tr><tr><td scope="row"><pre>NSBezierPath* aPath = [NSBezierPath bezierPath];<span></span></pre></td></tr><tr><td scope="row"><pre>[aPath moveToPoint:NSMakePoint(0.0, 0.0)];<span></span></pre></td></tr><tr><td scope="row"><pre>[aPath lineToPoint:NSMakePoint(8.0, 100.0)];<span></span></pre></td></tr><tr><td scope="row"><pre>[aPath lineToPoint:NSMakePoint(16.0, 0.0)];<span></span></pre></td></tr><tr><td scope="row"><pre>[aPath setLineWidth:5.0];<span></span></pre></td></tr><tr><td scope="row"><pre>[aPath setMiterLimit:5.0];<span></span></pre></td></tr><tr><td scope="row"><pre>[aPath stroke];<span></span></pre></td></tr></table></div>
<a name="//apple_ref/doc/uid/TP40003290-CH206-BAJIJJGD" title="Winding Rules"></a><h3>Winding Rules</h3>
<p>When you <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_664"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_665"></a>fill the area encompassed by a path, <code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/cl/NSBezierPath" target="_top">NSBezierPath</a></code> applies the current winding rule to determine which areas of the screen to fill. A <strong><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_666"></a>winding rule</strong> is simply an algorithm that tracks information about each contiguous region that makes up the path's overall fill area. A ray is drawn from a point inside a given region to any point outside the path bounds. The total number of crossed path lines (including implicit lines) and the direction of each path line are then interpreted using the rules in <span class="content_text">Table 5-2</span>, which determine if the region should be filled. </p><a name="//apple_ref/doc/uid/TP40003290-CH206-BBCGFJGE" title="Table 5-2Winding rules"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">
<caption class="tablecaption"><strong>Table 5-2&nbsp;&nbsp;</strong>Winding rules</caption>

<tr>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Winding rule</p></th>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th>
</tr>


<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_667"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/c/econst/NSNonZeroWindingRule" target="_top">NSNonZeroWindingRule</a></code></p></td>
<td ><p>Count each left-to-right path as +1 and each right-to-left path as -1. If the sum of all crossings is 0, the point is outside the path. If the sum is <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_668"></a>nonzero, the point is inside the path and the region containing it is filled. This is the default winding rule.</p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_669"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/c/econst/NSEvenOddWindingRule" target="_top">NSEvenOddWindingRule</a></code></p></td>
<td ><p>Count the total number of path crossings. If the number of crossings is <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_670"></a>even, the point is outside the path. If the number of crossings is odd, the point is inside the path and the region containing it should be filled.</p></td>
</tr>

</table></div><p>Fill operations are suitable for use with both open and closed subpaths. A closed subpath is a sequence of drawing calls that ends with a Close Path path element. An open subpath ends with a Move To path element. When you fill a partial subpath, <code>NSBezierPath</code> closes it for you automatically by creating an implicit (non-rendered) line from the first to the last point of the subpath. </p>
<p><span class="content_text">Figure 5-7</span> shows how the winding rules are applied to a particular path. Subfigure <em>a</em> shows the path rendered using the nonzero rule and subfigure <em>b</em> shows it rendered using the even-odd rule. Subfigures <em>c</em> and <em>d</em> add direction marks and the hidden path line that closes the figure to help you see how the rules are applied to two of the path’s regions. </p>
<br/><div><a name="//apple_ref/doc/uid/TP40003290-CH206-BBCEDBBC" title="Figure 5-7Applying winding rules to a path"></a><p><strong>Figure 5-7&nbsp;&nbsp;</strong>Applying winding rules to a path</p>
<img src = "../art/winding_path_crossing.gif" alt = "Applying winding rules to a path" width="575" height="443"></div><br/>
<p>To set the winding rule for an <code>NSBezierPath</code> object, use the <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_671"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBezierPath/setWindingRule:" target="_top">setWindingRule:</a></code> method. The default winding rule is <code>NSNonZeroWindingRule</code>. To change the default winding rule for all <code>NSBezierPath</code> objects, use the <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_672"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/clm/NSBezierPath/setDefaultWindingRule:" target="_top">setDefaultWindingRule:</a></code> <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_673"></a>method. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH206-BBCGCFBG" title="Manipulating Geometric Types"></a><h2>Manipulating Geometric Types</h2>
<p>The Foundation framework includes numerous functions for <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_674"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_675"></a>manipulating geometric values and for performing various calculations using those values. In addition to basic equality checks, you can perform more complex operations, such as the union and intersection of rectangles or the inclusion of a point in a rectangle’s boundaries. </p>
<p><span class="content_text">Table 5-3</span> lists some of the more commonly used functions and their behaviors. The function syntax is provided in a shorthand notation, with parameter types omitted to demonstrate the calling convention. For a complete list of available functions, and their full syntax, see the Functions section in <em><a href="../../../Reference/Foundation/ObjC_classic/index.html#//apple_ref/doc/uid/20001091" target="_top">Foundation Framework Reference</a></em>.</p><a name="//apple_ref/doc/uid/TP40003290-CH206-BBCIGBEJ" title="Table 5-3Commonly used geometry functions"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">
<caption class="tablecaption"><strong>Table 5-3&nbsp;&nbsp;</strong>Commonly used geometry functions</caption>

<tr>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Operation</p></th>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Function</p></th>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th>
</tr>


<tr>
<td rowspan="3"  scope="row"><p>Creation</p></td>
<td ><p><code>NSPoint <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_676"></a></code><code><a href="../../../Reference/Foundation/Miscellaneous/Foundation_Functions/Reference/reference.html#//apple_ref/c/func/NSMakePoint" target="_top">NSMakePoint</a></code><code>(x, y)</code></p></td>
<td ><p>Returns a properly formatted <code>NSPoint</code> data structure with the specified x and y values.</p></td>
</tr>
<tr>
<td  scope="row"><p><code>NSSize <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_677"></a></code><code><a href="../../../Reference/Foundation/Miscellaneous/Foundation_Functions/Reference/reference.html#//apple_ref/c/func/NSMakeSize" target="_top">NSMakeSize</a></code><code>(w, h)</code></p></td>
<td ><p>Returns a properly formatted <code>NSSize</code> data structure with the specified width and height.</p></td>
</tr>
<tr>
<td  scope="row"><p><code>NSRect <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_678"></a></code><code><a href="../../../Reference/Foundation/Miscellaneous/Foundation_Functions/Reference/reference.html#//apple_ref/c/func/NSMakeRect" target="_top">NSMakeRect</a></code><code>(x, y, w, h)</code></p></td>
<td ><p>Returns a properly formatted <code>NSRect</code> data structure with the specified origin (x, y) and size (width, height).</p></td>
</tr>
<tr>
<td rowspan="3"  scope="row"><p>Equality</p></td>
<td ><p><code>BOOL <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_679"></a></code><code><a href="../../../Reference/Foundation/Miscellaneous/Foundation_Functions/Reference/reference.html#//apple_ref/c/func/NSEqualPoints" target="_top">NSEqualPoints</a></code><code>(p1, p2)</code></p></td>
<td ><p>Returns <code>YES</code> if the two points are the same. </p></td>
</tr>
<tr>
<td  scope="row"><p><code>BOOL <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_680"></a></code><code><a href="../../../Reference/Foundation/Miscellaneous/Foundation_Functions/Reference/reference.html#//apple_ref/c/func/NSEqualSizes" target="_top">NSEqualSizes</a></code><code>(s1, s2)</code></p></td>
<td ><p>Returns <code>YES</code> if the two size types have identical widths and heights.</p></td>
</tr>
<tr>
<td  scope="row"><p><code>BOOL <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_681"></a></code><code><a href="../../../Reference/Foundation/Miscellaneous/Foundation_Functions/Reference/reference.html#//apple_ref/c/func/NSEqualRects" target="_top">NSEqualRects</a></code><code>(r1, r2)</code></p></td>
<td ><p>Returns <code>YES</code>, if the two rectangles have the same origins and the same widths and heights. </p></td>
</tr>
<tr>
<td rowspan="6"  scope="row"><p>Rectangle manipulations</p></td>
<td ><p><code>BOOL <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_682"></a></code><code><a href="../../../Reference/Foundation/Miscellaneous/Foundation_Functions/Reference/reference.html#//apple_ref/c/func/NSContainsRect" target="_top">NSContainsRect</a></code><code>(r1, r2)</code></p></td>
<td ><p>Returns <code>YES</code> if rectangle 1 completely encloses rectangle 2. </p></td>
</tr>
<tr>
<td  scope="row"><p><code>NSRect <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_683"></a></code><code><a href="../../../Reference/Foundation/Miscellaneous/Foundation_Functions/Reference/reference.html#//apple_ref/c/func/NSInsetRect" target="_top">NSInsetRect</a></code><code>(r, dX, dY)</code></p></td>
<td ><p>Returns a copy of the specified rectangle with its sides moved inward by the specified delta values. Negative delta values move the sides outward. Does not modify the original rectangle.</p></td>
</tr>
<tr>
<td  scope="row"><p><code>NSRect <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_684"></a></code><code><a href="../../../Reference/Foundation/Miscellaneous/Foundation_Functions/Reference/reference.html#//apple_ref/c/func/NSIntersectionRect" target="_top">NSIntersectionRect</a></code><code>(r1, r2)</code></p></td>
<td ><p>Returns the intersection of the two rectangles. </p></td>
</tr>
<tr>
<td  scope="row"><p><code>NSRect </code><code><a href="../../../Reference/Foundation/Miscellaneous/Foundation_Functions/Reference/reference.html#//apple_ref/c/func/NSUnionRect" target="_top">NSUnionRect</a></code><code>(r1, r2)</code></p></td>
<td ><p>Returns the union of the two rectangles.</p></td>
</tr>
<tr>
<td  scope="row"><p><code>BOOL <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_685"></a></code><code><a href="../../../Reference/Foundation/Miscellaneous/Foundation_Functions/Reference/reference.html#//apple_ref/c/func/NSMouseInRect" target="_top">NSMouseInRect</a></code><code>(p, r, flipped)</code></p></td>
<td ><p>Tests whether the point lies within the specified view rectangle. Adjusts the hit-detection algorithm to provide consistent behavior from the user’s perspective.</p></td>
</tr>
<tr>
<td  scope="row"><p><code>BOOL <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_686"></a></code><code><a href="../../../Reference/Foundation/Miscellaneous/Foundation_Functions/Reference/reference.html#//apple_ref/c/func/NSPointInRect" target="_top">NSPointInRect</a></code><code>(p, r)</code></p></td>
<td ><p>Tests whether the point lies within the specified rectangle. This is a basic mathematical comparison.</p></td>
</tr>

</table></div>
<a name="//apple_ref/doc/uid/TP40003290-CH206-SW4" title="Drawing Fundamental Shapes"></a><h2>Drawing Fundamental Shapes</h2>
<p>For many types of content, path-based drawing has several advantages over image-based drawing: </p>
<ul class="ul"><li class="li"><p>Because <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_687"></a>paths are specified mathematically, they scale easily to different resolutions. Thus, the same path objects can be used for screen and print-based drawing.</p></li>
<li class="li"><p>The geometry information associated with a path requires much less <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_688"></a>storage space than most image data formats.</p></li>
<li class="li"><p>Rendering paths is often faster than compositing a comparable image. It takes less time to transfer path data to the graphics hardware than it takes to transfer the texture data associated with an image.</p></li></ul>
<p>The following sections provide information about the primitive shapes you can draw using paths. You can combine one or more of these shapes to create a more complex path and then stroke or fill the path as described in <span class="content_text"><a href="Paths.html#//apple_ref/doc/uid/TP40003290-CH206-BBCBGDFI">“Drawing the Shapes in a Path.”</a></span> For some shapes, there may be more than one way to add the shape to a path, or there may be alternate ways to draw the shape immediately. Wherever possible, the benefits and disadvantages of each technique are listed to help you decide which technique is most appropriate in specific situations. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH206-SW21" title="Adding Points"></a><h3>Adding Points</h3>
<p>An <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_689"></a><code>NSPoint</code> <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_690"></a>structure by itself represents a location on the screen; it has no weight and cannot be drawn as such. To draw the equivalent of a point on the screen, you would need to create a small rectangle at the desired location, as shown in <span class="content_text">Listing 5-8</span>. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH206-BBCIGJII" title="Listing 5-8Drawing a point"></a><p class="codesample"><strong>Listing 5-8&nbsp;&nbsp;</strong>Drawing a point</p><div class="codesample"><table><tr><td scope="row"><pre>void DrawPoint(NSPoint aPoint)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSRect aRect = NSMakeRect(aPoint.x, aPoint.y, 1.0, 1.0);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    NSRectFill(aRect);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<p>Of course, a more common use for <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_691"></a>points is to specify the position of other shapes. Many shapes require you to specify the current point before actually creating the shape. You set the current point using the <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_692"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBezierPath/moveToPoint:" target="_top">moveToPoint:</a></code> or <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_693"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBezierPath/relativeMoveToPoint:" target="_top">relativeMoveToPoint:</a></code> methods. Some shapes, like rectangles and ovals, already contain location information and do not require a separate call to <code>moveToPoint:</code>. </p>
<div class="importantbox"><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_15" title="Important:"></a><p><strong>Important:</strong>&nbsp;

You must specify a starting point before drawing individual line, arc, curve, and glyph paths. If you do not, <code>NSBezierPath</code> raises an exception. </p><p></p></div>
<a name="//apple_ref/doc/uid/TP40003290-CH206-BBCHIDGH" title="Adding Lines and Polygons"></a><h3>Adding Lines and Polygons</h3>
<p>Cocoa provides a couple of options for adding <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_694"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_695"></a>lines to a path, with each technique offering different tradeoffs between efficiency and correctness. You can draw lines in the following ways:</p>
<ul class="spaceabove"><li class="li"><p>Create single horizontal and vertical lines by filling a rectangle using <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_696"></a><code><a href="../../../Reference/ApplicationKit/Miscellaneous/AppKit_Functions/Reference/reference.html#//apple_ref/c/func/NSRectFill" target="_top">NSRectFill</a></code>. This technique is less precise but is often a little faster than creating an <code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/cl/NSBezierPath" target="_top">NSBezierPath</a></code> object. To create diagonal lines using this technique, you must apply a rotation transform before drawing. This technique is not appropriate for creating connected line segments.</p></li>
<li class="li"><p>Use the <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_697"></a> <code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBezierPath/lineToPoint:" target="_top">lineToPoint:</a></code>, <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_698"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBezierPath/relativeLineToPoint:" target="_top">relativeLineToPoint:</a></code>, or <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_699"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/clm/NSBezierPath/strokeLineFromPoint:toPoint:" target="_top">strokeLineFromPoint:toPoint:</a></code> methods of <code>NSBezierPath</code> to create individual or connected line segments. This technique is fast and is the most precise option for creating lines and complex polygons. </p></li>
<li class="li"><p>Use the <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_700"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBezierPath/appendBezierPathWithPoints:count:" target="_top">appendBezierPathWithPoints:count:</a></code> method to create a series of connected lines quickly. This technique is faster than adding individual lines.</p></li></ul>
<p><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_701"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_702"></a>Polygons are composed of multiple connected lines and should be created using an <code>NSBezierPath</code> object. The simplest way to create a four-sided nonrectangular shape, like a parallelogram, rhombus, or trapezoid, is using line segments. You could also create these shapes using transforms, but calculating the correct skew factors would require a lot more work. </p>
<p><span class="content_text">Listing 5-9</span> shows code to draw a parallelogram using <code>NSBezierPath</code>. The method in this example inscribes the parallelogram inside the specified rectangle. The <code>withShift</code> parameter specifies the horizontal shift applied to the top left and bottom right corners of the rectangular area.</p>
<a name="//apple_ref/doc/uid/TP40003290-CH206-BBCJFDAB" title="Listing 5-9Using lines to draw a polygon"></a><p class="codesample"><strong>Listing 5-9&nbsp;&nbsp;</strong>Using lines to draw a polygon</p><div class="codesample"><table><tr><td scope="row"><pre>void DrawParallelogramInRect(NSRect rect, float withShift)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSBezierPath* thePath = [NSBezierPath bezierPath];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [thePath moveToPoint:rect.origin];<span></span></pre></td></tr><tr><td scope="row"><pre>    [thePath lineToPoint:NSMakePoint(rect.origin.x - withShift,  rect.origin.y)];<span></span></pre></td></tr><tr><td scope="row"><pre>    [thePath lineToPoint:NSMakePoint(NSMaxX(rect), NSMaxY(rect))];<span></span></pre></td></tr><tr><td scope="row"><pre>    [thePath lineToPoint:NSMakePoint(rect.origin.x + withShift,  NSMaxY(rect))];<span></span></pre></td></tr><tr><td scope="row"><pre>    [thePath closePath];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [thePath stroke];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<a name="//apple_ref/doc/uid/TP40003290-CH206-SW22" title="Adding Rectangles"></a><h3>Adding Rectangles</h3>
<p>Because <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_703"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_704"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_705"></a>rectangles are used frequently, there are several options for drawing them. </p>
<ul class="spaceabove"><li class="li"><p>Use the methods of <code>NSBezierPath</code> to create your rectangle. The following methods are reasonably fast and offer the best precision:</p><ul class="nested">
<li class="nested li"><p><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_706"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/clm/NSBezierPath/strokeRect:" target="_top">strokeRect:</a></code> </p></li>
<li class="nested li"><p><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_707"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/clm/NSBezierPath/fillRect:" target="_top">fillRect:</a></code></p></li>
<li class="nested li"><p><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_708"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/clm/NSBezierPath/bezierPathWithRect:" target="_top">bezierPathWithRect:</a></code></p></li>
<li class="nested li"><p><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_709"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBezierPath/appendBezierPathWithRect:" target="_top">appendBezierPathWithRect:</a></code></p></li></ul></li>
<li class="li"><p>Create rectangles using the Cocoa functions described in <span class="content_text"><a href="Paths.html#//apple_ref/doc/uid/TP40003290-CH206-BBCFABIE">“Drawing Rectangles.”</a></span> These functions draw rectangles faster than, but with less precision than, the methods of <code>NSBezierPath</code>. </p></li>
<li class="li"><p>Create a rectangle using individual lines as described in <span class="content_text"><a href="Paths.html#//apple_ref/doc/uid/TP40003290-CH206-BBCHIDGH">“Adding Lines and Polygons.”</a></span> You could use this technique to create diagonally oriented rectangles—that is, rectangles whose sides are not parallel to the x and y axes—without using a rotation transform. </p></li></ul>
<p><span class="content_text">Listing 5-10</span> shows a simple function that fills and strokes the same rectangle using two different techniques. The current fill and stroke colors are used when drawing the rectangle, along with the default compositing operation. In both cases, the rectangles are drawn immediately; there is no need to send a separate <code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBezierPath/fill" target="_top">fill</a></code> or <code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBezierPath/stroke" target="_top">stroke</a></code> message.</p>
<a name="//apple_ref/doc/uid/TP40003290-CH206-BBCBFGJH" title="Listing 5-10Drawing a rectangle"></a><p class="codesample"><strong>Listing 5-10&nbsp;&nbsp;</strong>Drawing a rectangle</p><div class="codesample"><table><tr><td scope="row"><pre>void DrawRectangle(NSRect aRect)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSRectFill(aRect);<span></span></pre></td></tr><tr><td scope="row"><pre>    [NSBezierPath strokeRect:aRect];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40003290-CH206-SW23" title="Adding Rounded Rectangles"></a><h3>Adding Rounded Rectangles</h3><p>In Mac OS X v10.5 and later, the <code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/cl/NSBezierPath" target="_top">NSBezierPath</a></code> class includes the following methods for creating rounded-rectangles: </p><ul class="spaceabove"><li class="li"><p><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_710"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/clm/NSBezierPath/bezierPathWithRoundedRect:xRadius:yRadius:" target="_top">bezierPathWithRoundedRect:xRadius:yRadius:</a></code></p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_711"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBezierPath/appendBezierPathWithRoundedRect:xRadius:yRadius:" target="_top">appendBezierPathWithRoundedRect:xRadius:yRadius:</a></code></p></li></ul><p>These methods create rectangles whose corners are curved according to the specified radius values. The radii describe the width and height of the oval to use at each corner of the rectangle.  <span class="content_text">Figure 5-8</span> shows how this inscribed oval is used to define the path of the rectangle’s corner segments.   </p><br/><div><a name="//apple_ref/doc/uid/TP40003290-CH206-SW12" title="Figure 5-8Inscribing the corner of a rounded rectangle"></a><p><strong>Figure 5-8&nbsp;&nbsp;</strong>Inscribing the corner of a rounded rectangle</p><img src = "../art/rounded-rect.jpg" alt = "Inscribing the corner of a rounded rectangle" ></div><br/><p><span class="content_text">Listing 5-11</span> shows a code snippet that creates and draws a path with a rounded rectangle.</p><a name="//apple_ref/doc/uid/TP40003290-CH206-SW13" title="Listing 5-11Drawing a rounded rectangle"></a><p class="codesample"><strong>Listing 5-11&nbsp;&nbsp;</strong>Drawing a rounded rectangle</p><div class="codesample"><table><tr><td scope="row"><pre>void DrawRoundedRect(NSRect rect, CGFloat x, CGFloat y)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSBezierPath* thePath = [NSBezierPath bezierPath];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [thePath appendBezierPathWithRoundedRect:rect xRadius:x yRadius:y];<span></span></pre></td></tr><tr><td scope="row"><pre>    [thePath stroke];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<a name="//apple_ref/doc/uid/TP40003290-CH206-SW24" title="Adding Ovals and Circles"></a><h3>Adding Ovals and Circles</h3>
<p>To draw <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_712"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_713"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_714"></a>ovals and <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_715"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_716"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_717"></a>circles, use the following methods of <code>NSBezierPath</code>: </p>
<ul class="spaceabove"><li class="li"><p><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_718"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/clm/NSBezierPath/bezierPathWithOvalInRect:" target="_top">bezierPathWithOvalInRect:</a></code></p></li>
<li class="li"><p><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_719"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBezierPath/appendBezierPathWithOvalInRect:" target="_top">appendBezierPathWithOvalInRect:</a></code></p></li></ul>
<p>Both methods inscribe an oval inside the rectangle you specify. You must then fill or stroke the path object to draw the oval in the current context. The following example creates an oval from the specified rectangle and strokes its path. </p>
<div class="codesample"><table><tr><td scope="row"><pre>void DrawOvalInRect(NSRect ovalRect)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSBezierPath* thePath = [NSBezierPath bezierPath];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [thePath appendBezierPathWithOvalInRect:ovalRect];<span></span></pre></td></tr><tr><td scope="row"><pre>    [thePath stroke];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<p>You could also create an oval using arcs, but doing so would duplicate what the preceding methods do internally and would be a little slower. The only reason to add individual arcs is to create a partial (nonclosed) oval path. For more information, see <span class="content_text"><a href="Paths.html#//apple_ref/doc/uid/TP40003290-CH206-BBCBGFBH">“Adding Arcs.”</a></span></p>
<a name="//apple_ref/doc/uid/TP40003290-CH206-BBCBGFBH" title="Adding Arcs"></a><h3>Adding Arcs</h3>
<p>To draw <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_720"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_721"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_722"></a>arcs, use the following methods of <code>NSBezierPath</code>:</p>
<ul class="spaceabove"><li class="li"><p><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_723"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBezierPath/appendBezierPathWithArcFromPoint:toPoint:radius:" target="_top">appendBezierPathWithArcFromPoint:toPoint:radius:</a></code></p></li>
<li class="li"><p><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_724"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBezierPath/appendBezierPathWithArcWithCenter:radius:startAngle:endAngle:" target="_top">appendBezierPathWithArcWithCenter:radius:startAngle:endAngle:</a></code></p></li>
<li class="li"><p><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_725"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBezierPath/appendBezierPathWithArcWithCenter:radius:startAngle:endAngle:clockwise:" target="_top">appendBezierPathWithArcWithCenter:radius:startAngle:endAngle:clockwise:</a></code></p></li></ul>
<p>The <code>appendBezierPathWithArcFromPoint:toPoint:radius:</code> method creates arcs by inscribing them in an angle formed by the current point and the two points passed to the method. Inscribing a circle in this manner can result in an arc that does not intersect any of the points used to specify it. It can also result in the creation of an unwanted line from the current point to the starting point of the arc. </p>
<p><span class="content_text">Figure 5-9</span> shows three different arcs and the control points used to create them. For the two arcs created using <code>appendBezierPathWithArcFromPoint:toPoint:radius:</code>, the current point must be set before calling the method. In both examples, the point is set to (30, 30). Because the radius of the second arc is shorter, and the starting point of the arc is not the same as the current point, a line is drawn from the current point to the starting point. </p>
<br/><div><a name="//apple_ref/doc/uid/TP40003290-CH206-BAJEBAIJ" title="Figure 5-9Creating arcs"></a><p><strong>Figure 5-9&nbsp;&nbsp;</strong>Creating arcs</p>
<img src = "../art/arc_examples.gif" alt = "Creating arcs" width="552" height="579"></div><br/>
<p><span class="content_text">Listing 5-12</span> shows the code snippets you would use to create each of the arcs from <span class="content_text">Figure 5-9</span>. (Although the figure shows the arcs individually, executing the following code would render the arcs on top of each other. )</p>
<a name="//apple_ref/doc/uid/TP40003290-CH206-SW11" title="Listing 5-12Creating three arcs"></a><p class="codesample"><strong>Listing 5-12&nbsp;&nbsp;</strong>Creating three arcs</p><div class="codesample"><table><tr><td scope="row"><pre>NSBezierPath*   arcPath1 = [NSBezierPath bezierPath];<span></span></pre></td></tr><tr><td scope="row"><pre>NSBezierPath*   arcPath2 = [NSBezierPath bezierPath];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>[[NSColor blackColor] setStroke];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Create the first arc<span></span></pre></td></tr><tr><td scope="row"><pre>[arcPath1 moveToPoint:NSMakePoint(30,30)];<span></span></pre></td></tr><tr><td scope="row"><pre>[arcPath1 appendBezierPathWithArcFromPoint:NSMakePoint(0,30)  toPoint:NSMakePoint(0,60) radius:30];<span></span></pre></td></tr><tr><td scope="row"><pre>[arcPath1 stroke];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Create the second arc.<span></span></pre></td></tr><tr><td scope="row"><pre>[arcPath2 moveToPoint:NSMakePoint(30,30)];<span></span></pre></td></tr><tr><td scope="row"><pre>[arcPath2 appendBezierPathWithArcFromPoint:NSMakePoint(30,40)  toPoint:NSMakePoint(70,30) radius:20];<span></span></pre></td></tr><tr><td scope="row"><pre>[arcPath2 stroke];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Clear the old arc and do not set an initial point, which prevents a<span></span></pre></td></tr><tr><td scope="row"><pre>// line being drawn from the current point to the start of the arc.<span></span></pre></td></tr><tr><td scope="row"><pre>[arcPath2 removeAllPoints];<span></span></pre></td></tr><tr><td scope="row"><pre>[arcPath2 appendBezierPathWithArcWithCenter:NSMakePoint(30,30) radius:30  startAngle:45 endAngle:135];<span></span></pre></td></tr><tr><td scope="row"><pre>[arcPath2 stroke];<span></span></pre></td></tr></table></div>
<a name="//apple_ref/doc/uid/TP40003290-CH206-SW25" title="Adding Bezier Curves"></a><h3>Adding Bezier Curves</h3>
<p>To draw <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_726"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_727"></a>Bezier <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_728"></a>curves, you must use the <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_729"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBezierPath/curveToPoint:controlPoint1:controlPoint2:" target="_top">curveToPoint:controlPoint1:controlPoint2:</a></code> method of <code>NSBezierPath</code>. This method supports the creation of a cubic curve from the current point to the destination point you specify when calling the method. The <code>controlPoint1</code> parameter determines the curvature starting from the current point, and <code>controlPoint2</code> determines the curvature of the destination point, as shown in <span class="content_text"><a href="Paths.html#//apple_ref/doc/uid/TP40003290-CH206-BBCHIBJC">Figure 5-1</a></span>. </p>
<br/><div><a name="//apple_ref/doc/uid/TP40003290-CH206-SW26" title="Figure 5-10Cubic Bezier curve"></a><p><strong>Figure 5-10&nbsp;&nbsp;</strong>Cubic Bezier curve</p><img src = "../art/bezier_curve.gif" alt = "Cubic Bezier curve" width="416" height="329"></div><br/>
<a name="//apple_ref/doc/uid/TP40003290-CH206-SW27" title="Adding Text"></a><h3>Adding Text</h3>
<p>Because <code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/cl/NSBezierPath" target="_top">NSBezierPath</a></code> only supports path-based content, you cannot add <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_730"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_731"></a>text characters directly to a path; instead, you must add <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_732"></a>glyphs. A <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_733"></a>glyph is the visual representation of a character (or partial character) in a particular font. For glyphs in an outline font, this visual representation is stored as a set of mathematical paths that can be added to an <code>NSBezierPath</code> object. </p>
<div class="notebox"><a name="//apple_ref/doc/uid/TP40003290-CH206-SW28" title="Note"></a><p><strong>Note:</strong>&nbsp;Using <code>NSBezierPath</code> is not the most efficient way to render text, but can be used in situations where you need the path information associated with the text. </p></div>
<p>To obtain a set of glyphs, you can use the Cocoa text system or the <code>NSFont</code> class. Getting glyphs from the Cocoa text system is usually easier because you can get glyphs for an arbitrary string of characters, whereas using <code>NSFont</code> requires you to know the names of individual glyphs. To get glyphs from the Cocoa text system, you must do the following:</p>
<ol class="ol"><li class="li"><p>Create the text system objects needed to manage text layout. For a tutorial on how to do this, see <span class="content_text"><a href="../../TextArchitecture/Tasks/AssembleSysByHand.html#//apple_ref/doc/uid/20000843" target="_top">Assembling the Text System by Hand</a></span> in <em><a href="../../TextArchitecture/index.html#//apple_ref/doc/uid/10000086i" target="_top">Text System Overview</a></em>.</p></li>
<li class="li"><p>Use the <code><a href="../../../Reference/ApplicationKit/Classes/NSLayoutManager_Class/Reference/Reference.html#//apple_ref/occ/instm/NSLayoutManager/glyphAtIndex:" target="_top">glyphAtIndex:</a></code> or <code><a href="../../../Reference/ApplicationKit/Classes/NSLayoutManager_Class/Reference/Reference.html#//apple_ref/occ/instm/NSLayoutManager/getGlyphs:range:" target="_top">getGlyphs:range:</a></code> method of <code>NSLayoutManager</code> to retrieve the desired glyphs.</p></li>
<li class="li"><p>Add the glyphs to your <code>NSBezierPath</code> object using one of the following methods: </p><ul class="ul"><li class="li"><p><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_734"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBezierPath/appendBezierPathWithGlyph:inFont:" target="_top">appendBezierPathWithGlyph:inFont:</a></code></p></li>
<li class="li"><p><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_735"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBezierPath/appendBezierPathWithGlyphs:count:inFont:" target="_top">appendBezierPathWithGlyphs:count:inFont:</a></code></p></li></ul></li></ol>
<p>When added to your <code>NSBezierPath</code> object, glyphs are converted to a series of path elements. These path elements simply specify lines and curves and do not retain any information about the characters themselves. You can manipulate paths containing glyphs just like you would any other path by changing the points of a path element or by modifying the path attributes.</p>
<a name="//apple_ref/doc/uid/TP40003290-CH206-BBCBGDFI" title="Drawing the Shapes in a Path"></a><h3>Drawing the Shapes in a Path</h3>
<p>There are two options for <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_736"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_737"></a>drawing the contents of a path: you can <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_738"></a>stroke the path or <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_739"></a>fill it. Stroking a path renders an outline of the path’s shape using the current stroke color and path attributes. Filling the path renders the area encompassed by the path using the current fill color and winding rule. </p>
<p><span class="content_text">Figure 5-11</span> shows the same path from <span class="content_text"><a href="Paths.html#//apple_ref/doc/uid/TP40003290-CH206-BBCHIBJC">Figure 5-1</a></span> but with the contents filled and a different stroke width applied. </p>
<br/><div><a name="//apple_ref/doc/uid/TP40003290-CH206-BAJGCHCD" title="Figure 5-11Stroking and filling a path."></a><p><strong>Figure 5-11&nbsp;&nbsp;</strong>Stroking and filling a path.</p>
<img src = "../art/path_stroke_fill.gif" alt = "Stroking and filling a path." width="586" height="230"></div><br/>
<a name="//apple_ref/doc/uid/TP40003290-CH206-BBCFABIE" title="Drawing Rectangles"></a><h2>Drawing Rectangles</h2>
<p>Cocoa provides several functions for <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_740"></a>drawing <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_741"></a>rectangles to the current context immediately using the default attributes. These functions use Quartz primitives to draw one or more rectangles quickly, but in a way that may be less precise than if you were to use <code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/cl/NSBezierPath" target="_top">NSBezierPath</a></code>. For example, these routines do not apply the current join style to the corners of a framed rectangle. </p>
<p><span class="content_text">Table 5-4</span> lists some of the more commonly used functions for drawing rectangles along with their behaviors. You can use these functions in places where speed is more important than precision. The syntax for each function is provided in a shorthand notation, with parameter types omitted to demonstrate the calling conventions. For a complete list of available functions, and their full syntax, see <em><a href="../../../Reference/ApplicationKit/Miscellaneous/AppKit_Functions/index.html#//apple_ref/doc/uid/TP40004154" target="_top">Application Kit Functions Reference</a></em>.</p><a name="//apple_ref/doc/uid/TP40003290-CH206-BBCBCEID" title="Table 5-4Rectangle frame and fill functions"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">
<caption class="tablecaption"><strong>Table 5-4&nbsp;&nbsp;</strong>Rectangle frame and fill functions</caption>

<tr>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Function</p></th>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th>
</tr>


<tr>
<td  scope="row"><p><code>void <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_742"></a></code><code><a href="../../../Reference/ApplicationKit/Miscellaneous/AppKit_Functions/Reference/reference.html#//apple_ref/c/func/NSEraseRect" target="_top">NSEraseRect</a></code><code>(aRect)</code></p></td>
<td ><p>Fills the specified rectangle with white. </p></td>
</tr>
<tr>
<td  scope="row"><p><code>void <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_743"></a></code><code><a href="../../../Reference/ApplicationKit/Miscellaneous/AppKit_Functions/Reference/reference.html#//apple_ref/c/func/NSFrameRect" target="_top">NSFrameRect</a></code><code>(aRect)</code></p></td>
<td ><p>Draws the frame of the rectangle using the current fill color, the default line width, and the <code>NSCompositeCopy</code><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_744"></a> compositing operation.</p></td>
</tr>
<tr>
<td  scope="row"><p><code>void <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_745"></a></code><code><a href="../../../Reference/ApplicationKit/Miscellaneous/AppKit_Functions/Reference/reference.html#//apple_ref/c/func/NSFrameRectWithWidth" target="_top">NSFrameRectWithWidth</a></code><code>(aRect, width)</code></p></td>
<td ><p>Draws the frame of the rectangle using the current fill color, the specified width, and the <code>NSCompositeCopy</code> compositing operation.</p></td>
</tr>
<tr>
<td  scope="row"><p><code>void <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_746"></a></code><code><a href="../../../Reference/ApplicationKit/Miscellaneous/AppKit_Functions/Reference/reference.html#//apple_ref/c/func/NSFrameRectWithWidthUsingOperation" target="_top">NSFrameRectWithWidthUsingOperation</a></code><code>(aRect, width, op)</code></p></td>
<td ><p>Draws the frame of the rectangle using the current fill color, the specified width, and the specified operation. </p></td>
</tr>
<tr>
<td  scope="row"><p><code>void <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_747"></a></code><code><a href="../../../Reference/ApplicationKit/Miscellaneous/AppKit_Functions/Reference/reference.html#//apple_ref/c/func/NSRectFill" target="_top">NSRectFill</a></code><code>(aRect)</code></p></td>
<td ><p>Fills the rectangle using the current fill color and the <code>NSCompositeCopy</code> compositing operation. </p></td>
</tr>
<tr>
<td  scope="row"><p><code>void <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_748"></a></code><code><a href="../../../Reference/ApplicationKit/Miscellaneous/AppKit_Functions/Reference/reference.html#//apple_ref/c/func/NSRectFillUsingOperation" target="_top">NSRectFillUsingOperation</a></code><code>(aRect, op)</code></p></td>
<td ><p>Fills the rectangle using the current fill color and specified compositing operation. </p></td>
</tr>
<tr>
<td  scope="row"><p><code>void <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_749"></a></code><code><a href="../../../Reference/ApplicationKit/Miscellaneous/AppKit_Functions/Reference/reference.html#//apple_ref/c/func/NSRectFillList" target="_top">NSRectFillList</a></code><code>(rectList, count)</code></p></td>
<td ><p>Fills the C-style array of rectangles using the current fill color and the <code>NSCompositeCopy</code> compositing operation. </p></td>
</tr>
<tr>
<td  scope="row"><p><code>void <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_750"></a></code><code><a href="../../../Reference/ApplicationKit/Miscellaneous/AppKit_Functions/Reference/reference.html#//apple_ref/c/func/NSRectFillListWithColors" target="_top">NSRectFillListWithColors</a></code><code>(rects, colors, count)</code></p></td>
<td ><p>Fills the C-style array of rectangles using the corresponding list of colors. Each list must have the same number of entries. </p></td>
</tr>
<tr>
<td  scope="row"><p><code>void <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_751"></a></code><code><a href="../../../Reference/ApplicationKit/Miscellaneous/AppKit_Functions/Reference/reference.html#//apple_ref/c/func/NSRectFillListUsingOperation" target="_top">NSRectFillListUsingOperation</a></code><code>(rects, count, op)</code></p></td>
<td ><p>Fills the C-style array of rectangles using the current fill color and the specified compositing operation. </p></td>
</tr>
<tr>
<td  scope="row"><p><code>void <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_752"></a></code><code><a href="../../../Reference/ApplicationKit/Miscellaneous/AppKit_Functions/Reference/reference.html#//apple_ref/c/func/NSRectFillListWithColorsUsingOperation" target="_top">NSRectFillListWithColorsUsingOperation</a></code><code>(rects, colors, count, op)</code></p></td>
<td ><p>Fills the C-style array of rectangles using the corresponding list of colors and the specified compositing operation. The list of rectangles and list of colors must contain the same number of items. </p></td>
</tr>

</table></div><div class="importantbox"><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_16" title="Important:"></a><p><strong>Important:</strong>&nbsp;You may have noticed that the <code>NSFrameRect</code>, <code>NSFrameRectWithWidth</code>, and <code>NSFrameRectWithWidthUsingOperation</code> functions draw the rectangle using the fill color instead of the stroke color. These methods draw the rectangle’s frame by filling four subrectangles, one for each side of the rectangle. This differs from the way <code>NSBezierPath</code> draws rectangles and can sometimes lead to confusion. If your rectangle does not show up the way you expected, check your code to make sure you are setting the drawing color using either the <code>set</code> or <code>setFill</code> method of <code>NSColor</code>.</p><p></p></div>
<a name="//apple_ref/doc/uid/TP40003290-CH206-SW29" title="Working with Paths"></a><h2>Working with Paths</h2>
<p>Building a sleek and attractive user interface is hard work and most programs use a combination of images and paths to do it. Paths have the advantage of being lightweight, scalable, and fast. Even so, paths are not appropriate in all situations. The following sections provide some basic tips and guidance on how to use paths effectively in your program. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH206-SW30" title="Building Paths"></a><h3>Building Paths</h3>
<p>Building a <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_753"></a>path involves creating an <code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/cl/NSBezierPath" target="_top">NSBezierPath</a></code> object and adding path elements to it. All paths must start with a Move To element to mark the first point of the path. In some cases, this element is added for you but in others you must add it yourself. For example, methods that create a closed path (such as an oval or rectangle) insert a MoveTo element for you.</p>
<p>A single <code>NSBezierPath</code> object may have multiple <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_754"></a>subpaths. Each subpath is itself a complete path, meaning the subpath may not appear connected to any other subpaths when drawn. Filled subpaths can still interact with each other, however. Overlapping subpaths may cancel each other’s fill effect, resulting in holes in the fill area. </p>
<p>All subpaths in an <code>NSBezierPath</code> object share the same drawing attributes. The only way to assign different attributes to different paths is to create different <code>NSBezierPath</code> objects for each. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH206-SW31" title="Improving Rendering Performance"></a><h3>Improving Rendering Performance</h3>
<p>As <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_755"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_756"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_757"></a>you work on your drawing code, you should keep performance in mind. Drawing is a processor intensive activity but there are many ways to reduce the amount of drawing performed by your application. The following sections offer some basic tips related to improving drawing performance with Cocoa applications. For additional drawing-related performance tips, see <em><a href="../../../../Performance/Conceptual/Drawing/index.html#//apple_ref/doc/uid/10000151i" target="_top">Drawing Performance Guidelines</a></em>. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40003290-CH206-SW32" title="Note"></a><p><strong>Note:</strong>&nbsp;As with any determination of performance, you should measure the speed of your drawing operations before making any changes. If the amount of time spent inside the methods of <code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/cl/NSBezierPath" target="_top">NSBezierPath</a></code> becomes significant, simplifying your paths might offer better performance. Limiting the total amount of drawing you do during an update cycle might also improve performance.</p></div><a name="//apple_ref/doc/uid/TP40003290-CH206-SW33" title="Reuse Your Path Objects"></a><h4>Reuse Your Path Objects</h4><p>If you draw the same content repeatedly, consider caching the objects used to draw that content. It is usually more efficient to retain an existing <code>NSBezierPath</code> object than to recreate it during each drawing cycle. For content that might change dynamically, you might also consider maintaining a pool of reusable objects. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH206-SW34" title="Correctness Versus Efficiency"></a><h4>Correctness Versus Efficiency</h4>
<p>When writing your drawing code, you should always try to make that code as efficient as possible without sacrificing the quality of the rendered content. If your drawing code seems slow, there are some tradeoffs you can make to improve efficiency that reduce quality only temporarily: </p>
<ul class="spaceabove"><li class="li"><p>Use the available update rectangles to draw only what has changed. Use different <code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/cl/NSBezierPath" target="_top">NSBezierPath</a></code> objects for each part of the screen rather than one large object that covers everything. For more information, see <span class="content_text"><a href="Paths.html#//apple_ref/doc/uid/TP40003290-CH206-BBCFGAGF">“Reduce Path Complexity.”</a></span></p></li>
<li class="li"><p>During scrolling, live resizing, or other time-critical operations, consider the following options:</p><ul class="nested"><li class="nested li"><p>If your screen contains animated content, pause the animation until the operation is complete. </p></li>
<li class="nested li"><p>Try temporarily increasing the flatness value for curved paths. The default flatness value is set to 0.6, which results in nice smooth curves. Increasing this value above 1.0 may make your curves look more jagged but should improve performance. You may want to try a few different values to determine a good tradeoff between appearance and speed.</p></li>
<li class="nested li"><p>Disable anti-aliasing. For more information, see <span class="content_text"><a href="../GraphicsContexts/GraphicsContexts.html#//apple_ref/doc/uid/TP40003290-CH203-BCIJJCBB">“Setting the Anti-aliasing Options.”</a></span> </p></li></ul></li>
<li class="li"><p>When drawing rectangles, use <code>NSFrameRect</code> and <code>NSRectFill</code> for operations where the highest quality is not required. These functions offer close approximations to what you would get with <code>NSBezierPath</code> but are often a little faster. </p></li></ul>
<a name="//apple_ref/doc/uid/TP40003290-CH206-BBCFGAGF" title="Reduce Path Complexity"></a><h4>Reduce Path Complexity</h4>
<p>If you are drawing a large amount of content, you should do your best to reduce the <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_758"></a>complexity of the path data you store in a single <code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/cl/NSBezierPath" target="_top">NSBezierPath</a></code> object. Path objects with hundreds of path elements require more calculations than those with 10 or 20 elements. Every line or curve segment you add increases the number of calculations required to flatten the path or determine whether a point is inside it. Numerous path crossings also increases the number of required calculations when filling the path.</p>
<p>If the accuracy of rendered paths is not crucial, try using multiple <code>NSBezierPath</code> objects to draw the same content. There is very little visual difference between using one path object or multiple path objects. If your path is already grouped into multiple subpaths, then it becomes easy to put some of those subpaths in other <code>NSBezierPath</code> objects. Using multiple path objects reduces the number of calculations for each subpath and also allows you to limit rendering to only those paths that are in the current update <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_759"></a>rectangle. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH206-BBCICAFC" title="Manipulating Individual Path Elements"></a><h3>Manipulating Individual Path Elements</h3>
<p>Given an <code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/cl/NSBezierPath" target="_top">NSBezierPath</a></code> object with some existing <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_760"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_761"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_762"></a>path data, you can retrieve the points associated with that path and modify them individually. An illustration program might do this in response to a mouse event over one of the points in a path. If the mouse event results in that point being dragged to a new location, you can quickly update the path element with the new location and redraw the path. </p>
<p>The <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_763"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBezierPath/elementCount" target="_top">elementCount</a></code> method of <code>NSBezierPath</code> returns the total number of path elements for all subpaths of the object. To find out the type of a given path element, use the <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_764"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBezierPath/elementAtIndex:" target="_top">elementAtIndex:</a></code> or <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_765"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBezierPath/elementAtIndex:associatedPoints:" target="_top">elementAtIndex:associatedPoints:</a></code> method. These methods return one of the values listed in <span class="content_text"><a href="Paths.html#//apple_ref/doc/uid/TP40003290-CH206-BBCHBGIH">Table 5-1</a></span>. Use the <code>elementAtIndex:associatedPoints:</code> method if you also want to retrieve the points associated with an element. If you do not already know the type of the path element, you should pass this method an array capable of holding at least three <code>NSPoint</code> data types. </p>
<p>To change the points associated with a path element, use the <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_766"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBezierPath/setAssociatedPoints:atIndex:" target="_top">setAssociatedPoints:atIndex:</a></code> method. You cannot change the type of a path element, only the points associated with it. When changing the points, <code>NSBezierPath</code> takes only as many points from your point array as are needed. For example, if you specify three points for a Line To path element, only the first point is used. </p>
<p><span class="content_text">Listing 5-13</span> shows a method that updates the control point associated with a curve path element on the end of the current path. The points that define the curve are stored in the order <code>controlPoint1</code>, <code>controlPoint2</code>, <code>endPoint</code>. This method replaces the point <code>controlPoint2</code>, which affects the end portion of the curve.</p>
<a name="//apple_ref/doc/uid/TP40003290-CH206-BBCEABEJ" title="Listing 5-13Changing the control point of a curve path element"></a><p class="codesample"><strong>Listing 5-13&nbsp;&nbsp;</strong>Changing the control point of a curve path element</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)replaceLastControlPointWithPoint:(NSPoint)newControl<span></span></pre></td></tr><tr><td scope="row"><pre>            inPath:(NSBezierPath*)thePath<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    int elemCount = [thePath elementCount];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSBezierPathElement elemType =<span></span></pre></td></tr><tr><td scope="row"><pre>                [thePath elementAtIndex:(elemCount - 1)];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (elemType != NSCurveToBezierPathElement)<span></span></pre></td></tr><tr><td scope="row"><pre>        return;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Get the current points for the curve.<span></span></pre></td></tr><tr><td scope="row"><pre>    NSPoint points[3];<span></span></pre></td></tr><tr><td scope="row"><pre>    [thePath elementAtIndex:(elemCount - 1) associatedPoints:points];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Replace the old control point.<span></span></pre></td></tr><tr><td scope="row"><pre>    points[1] = newControl;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Update the points.<span></span></pre></td></tr><tr><td scope="row"><pre>    [thePath setAssociatedPoints:points atIndex:(elemCount - 1)];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<a name="//apple_ref/doc/uid/TP40003290-CH206-SW35" title="Transforming a Path"></a><h3>Transforming a Path</h3>
<p>The <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_767"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_768"></a>coordinate system of an <code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/cl/NSBezierPath" target="_top">NSBezierPath</a></code> object always matches the coordinate system of the view in which it is drawn. Thus, given a path whose first point is at (0, 0) in your <code>NSBezierPath</code> object, drawing the path in your view places that point at (0, 0) in the view’s current coordinate system. To draw that path in a different location, you must apply a transform in one of two ways:</p>
<ul class="spaceabove"><li class="li"><p>Apply the transform to the view coordinate system and then draw the path. For information on how to apply transforms to a view, see <span class="content_text"><a href="../Transforms/Transforms.html#//apple_ref/doc/uid/TP40003290-CH204-BCIHIFEA">“Creating and Applying a Transform.”</a></span> </p></li>
<li class="li"><p>Apply the transform to the <code>NSBezierPath</code> object itself using the <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_769"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBezierPath/transformUsingAffineTransform:" target="_top">transformUsingAffineTransform:</a></code> method and then draw it in an unmodified view. </p></li></ul>
<p>Both techniques cause the path to be drawn at the same location in the view; however, the second technique also has the side effect of permanently modifying the <code>NSBezierPath</code> object. Depending on your content, this may or may not be appropriate. For example, in an illustration program, you might want the user to be able to drag shapes around the view; therefore, you would want to modify the <code>NSBezierPath</code> object to retain the new position of the path.</p><a name="//apple_ref/doc/uid/TP40003290-CH206-SW2" title="Creating a CGPathRef From an NSBezierPath Object"></a><h3>Creating a CGPathRef From an NSBezierPath Object</h3><p><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_770"></a>There may be times when it is necessary to convert an <code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/cl/NSBezierPath" target="_top">NSBezierPath</a></code> object to a <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_771"></a><code><a href="../../../../GraphicsImaging/Reference/CGPath/Reference/reference.html#//apple_ref/c/tdef/CGPathRef" target="_top">CGPathRef</a></code> data type so that you can perform path-based operations using <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_772"></a>Quartz. For example, you might want to draw your path to a Quartz transparency layer or use it to do advanced hit detection. Although you cannot use a <code>NSBezierPath</code> object directly from Quartz, you can use its path elements to build a <code>CGPathRef</code> object. </p><p> <span class="content_text">Listing 5-14</span> shows you how to create a <code>CGPathRef</code> data type from an <code>NSBezierPath</code> object. The example extends the behavior of the <code>NSBezierPath</code> class using a category. The <code>quartzPath</code> method uses the path elements of the <code>NSBezierPath</code> object to call the appropriate Quartz path creation functions. Although the method creates a mutable <code>CGPathRef</code> object, it returns an immutable copy for drawing. To ensure that the returned path returns correct results during hit detection, this method implicitly closes the last subpath if your code does not do so explicitly. Quartz requires paths to be closed in order to do hit detection on the path’s fill area.</p><a name="//apple_ref/doc/uid/TP40003290-CH206-SW1" title="Listing 5-14Creating a CGPathRef from an NSBezierPath"></a><p class="codesample"><strong>Listing 5-14&nbsp;&nbsp;</strong>Creating a CGPathRef from an NSBezierPath</p><div class="codesample"><table><tr><td scope="row"><pre>@implementation NSBezierPath (BezierPathQuartzUtilities)<span></span></pre></td></tr><tr><td scope="row"><pre>// This method works only in Mac OS X v10.2 and later.<span></span></pre></td></tr><tr><td scope="row"><pre>- (CGPathRef)quartzPath<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    int i, numElements;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Need to begin a path here.<span></span></pre></td></tr><tr><td scope="row"><pre>    CGPathRef           immutablePath = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Then draw the path elements.<span></span></pre></td></tr><tr><td scope="row"><pre>    numElements = [self elementCount];<span></span></pre></td></tr><tr><td scope="row"><pre>    if (numElements > 0)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        CGMutablePathRef    path = CGPathCreateMutable();<span></span></pre></td></tr><tr><td scope="row"><pre>        NSPoint             points[3];<span></span></pre></td></tr><tr><td scope="row"><pre>        BOOL                didClosePath = YES;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        for (i = 0; i &lt; numElements; i++)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            switch ([self elementAtIndex:i associatedPoints:points])<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                case NSMoveToBezierPathElement:<span></span></pre></td></tr><tr><td scope="row"><pre>                    CGPathMoveToPoint(path, NULL, points[0].x, points[0].y);<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                case NSLineToBezierPathElement:<span></span></pre></td></tr><tr><td scope="row"><pre>                    CGPathAddLineToPoint(path, NULL, points[0].x, points[0].y);<span></span></pre></td></tr><tr><td scope="row"><pre>                    didClosePath = NO;<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                case NSCurveToBezierPathElement:<span></span></pre></td></tr><tr><td scope="row"><pre>                    CGPathAddCurveToPoint(path, NULL, points[0].x, points[0].y,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        points[1].x, points[1].y,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        points[2].x, points[2].y);<span></span></pre></td></tr><tr><td scope="row"><pre>                    didClosePath = NO;<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                case NSClosePathBezierPathElement:<span></span></pre></td></tr><tr><td scope="row"><pre>                    CGPathCloseSubpath(path);<span></span></pre></td></tr><tr><td scope="row"><pre>                    didClosePath = YES;<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Be sure the path is closed or Quartz may not do valid hit detection.<span></span></pre></td></tr><tr><td scope="row"><pre>        if (!didClosePath)<span></span></pre></td></tr><tr><td scope="row"><pre>            CGPathCloseSubpath(path);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        immutablePath = CGPathCreateCopy(path);<span></span></pre></td></tr><tr><td scope="row"><pre>        CGPathRelease(path);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return immutablePath;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>The code from the preceding example closes only the last open path by default. Depending on your path objects, you might also want to close intermediate subpaths whenever a new Move To element is encountered. If your path objects typically contain only one path, you do not need to do so, however. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH206-SW36" title="Detecting Mouse Hits on a Path"></a><h3>Detecting Mouse Hits on a Path</h3>
<p>If you <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_773"></a><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_774"></a>need to determine whether a mouse event occurred on a path or its fill area, you can use the <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_775"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBezierPath/containsPoint:" target="_top">containsPoint:</a></code> method of <code>NSBezierPath</code>. This method tests the point against all closed and open subpaths in the path object. If the point lies on or inside any of the subpaths, the method returns <code>YES</code>. When determining whether a point is inside a subpath, the method uses the nonzero winding rule.</p><p>If your software runs in Mac OS X v10.4 and later, you can perform more advanced hit detection using the <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_776"></a><code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextPathContainsPoint" target="_top">CGContextPathContainsPoint</a></code> and <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_777"></a><code><a href="../../../../GraphicsImaging/Reference/CGPath/Reference/reference.html#//apple_ref/c/func/CGPathContainsPoint" target="_top">CGPathContainsPoint</a></code> functions in <a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_778"></a>Quartz. Using these functions you can determine if a point is on the path itself or if the point is inside the path using either the nonzero or even-odd winding rule.  Although you cannot use these functions on an <code>NSBezierPath</code> object directly, you can convert your path object to a <code>CGPathRef</code> data type and then use them. For information on how to convert a path object to a <code>CGPathRef</code> data type, see <span class="content_text"><a href="Paths.html#//apple_ref/doc/uid/TP40003290-CH206-SW2">“Creating a CGPathRef From an NSBezierPath Object.”</a></span></p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40003290-CH206-DontLinkElementID_17" title="Important:"></a><p><strong>Important:</strong>&nbsp;Quartz considers a point to be inside a path only if the path is explicitly closed. If you are converting your <code>NSBezierPath</code> objects to Quartz paths for use in hit detection, be sure to close any open subpaths either prior to or during the conversion. If you do not, points lying inside your path may not be correctly identified as such.</p><p></p></div><p><span class="content_text">Listing 5-15</span> shows an example of how you might perform advanced hit detection on an <code>NSBezierPath</code> object. This example adds a method to the <code>NSBezierPath</code> class using a category. The implementation of the method adds a <code>CGPathRef</code> version of the current path to the current context and calls the <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextPathContainsPoint" target="_top">CGContextPathContainsPoint</a></code> function. This function uses the specified mode to analyze the location of the specified point relative to the current path and returns an appropriate value. Modes can include <code><a href="../../../../GraphicsImaging/Reference/CGPath/Reference/reference.html#//apple_ref/c/econst/kCGPathFill" target="_top">kCGPathFill</a></code>, <code><a href="../../../../GraphicsImaging/Reference/CGPath/Reference/reference.html#//apple_ref/c/econst/kCGPathEOFill" target="_top">kCGPathEOFill</a></code>, <code><a href="../../../../GraphicsImaging/Reference/CGPath/Reference/reference.html#//apple_ref/c/econst/kCGPathStroke" target="_top">kCGPathStroke</a></code>, <code><a href="../../../../GraphicsImaging/Reference/CGPath/Reference/reference.html#//apple_ref/c/econst/kCGPathFillStroke" target="_top">kCGPathFillStroke</a></code>, or <code><a href="../../../../GraphicsImaging/Reference/CGPath/Reference/reference.html#//apple_ref/c/econst/kCGPathEOFillStroke" target="_top">kCGPathEOFillStroke</a></code>. </p><a name="//apple_ref/doc/uid/TP40003290-CH206-SW3" title="Listing 5-15Detecting hits on a path"></a><p class="codesample"><strong>Listing 5-15&nbsp;&nbsp;</strong>Detecting hits on a path</p><div class="codesample"><table><tr><td scope="row"><pre>@implementation NSBezierPath (BezierPathQuartzUtilities)<span></span></pre></td></tr><tr><td scope="row"><pre>// Note, this method works only in Mac OS X v10.4 and later.<span></span></pre></td></tr><tr><td scope="row"><pre>- (BOOL)pathContainsPoint:(NSPoint)point forMode:(CGPathDrawingMode)mode<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CGPathRef       path = [self quartzPath]; // Custom method to create a CGPath<span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextRef    cgContext = (CGContextRef)[[NSGraphicsContext currentContext] graphicsPort];<span></span></pre></td></tr><tr><td scope="row"><pre>    CGPoint         cgPoint;<span></span></pre></td></tr><tr><td scope="row"><pre>    BOOL            containsPoint = NO;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    cgPoint.x = point.x;<span></span></pre></td></tr><tr><td scope="row"><pre>    cgPoint.y = point.y;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Save the graphics state before doing the hit detection.<span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextSaveGState(cgContext);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextAddPath(cgContext, path);<span></span></pre></td></tr><tr><td scope="row"><pre>    containsPoint = CGContextPathContainsPoint(cgContext, cgPoint, mode);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextRestoreGState(cgContext);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return containsPoint;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Color/Color.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../Images/Images.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2005, 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-01-06<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/CocoaDrawingGuide/Paths/Paths.html%3Fid%3DTP40003290-2.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/CocoaDrawingGuide/Paths/Paths.html%3Fid%3DTP40003290-2.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/CocoaDrawingGuide/Paths/Paths.html%3Fid%3DTP40003290-2.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>