<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Make QTVR Panorama - /CMovieMaker.cp</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxQuickTime-date.html">QuickTime</a> &gt; <A HREF="javascript:location.replace('index.html');">Make QTVR Panorama</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/QuickTime/index.html" target="_blank">Reference Library > QuickTime</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Make QTVR Panorama</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/CMovieMaker.cp</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/CApp.cp</option>
<option value="listing2.html">/CApp.h</option>
<option value="listing3.html">/CBeachBall.cp</option>
<option value="listing4.html">/CBeachBall.h</option>
<option value="listing5.html">/CKeyFilters.cp</option>
<option value="listing6.html">/CKeyFilters.h</option>
<option value="listing7.html">/CLogConsole.cp</option>
<option value="listing8.html">/CMovieMaker.cp</option>
<option value="listing9.html">/CMovieMaker.h</option>
<option value="listing10.html">/CPict2VRWindow.cp</option>
<option value="listing11.html">/CPict2VRWindow.h</option>
<option value="listing12.html">/CPreferences.cp</option>
<option value="listing13.html">/CPreferences.h</option>
<option value="listing14.html">/CPrefsWindow.cp</option>
<option value="listing15.html">/CPrefsWindow.h</option>
<option value="listing16.html">/CUtils.cp</option>
<option value="listing17.html">/CUtils.h</option>
<option value="listing18.html">/QTVRPanoAuthoring.h</option>
<option value="listing19.html">/ToDoHistory.h</option></select>
				</p>
				</form>
				<p><strong><a href="Make_QTVR_Panorama.zip">Download Sample</a></strong> (&#147;Make_QTVR_Panorama.zip&#148;, 233.0K)<BR>
<strong><a href="Make_QTVR_Panorama.dmg">Download Sample</a></strong> (&#147;Make_QTVR_Panorama.dmg&#148;, 312.5K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  A set of static functions for creating QTVR movies from a source PICT file.    Created 29 Jan 1996 by EGH    Copyright &copy; 1996, Apple Computer, Inc.*/#include &lt;ImageCompression.h&gt;#include &lt;String_Utils.h&gt;#include &quot;CBeachBall.h&quot;#include &quot;CUtils.h&quot;#include &quot;QTVRPanoAuthoring.h&quot;#include &quot;CMovieMaker.h&quot;/* CMovieMaker::MakeAMovie  What we are here for. Takes the FSSpec for a source PICT file, a tile movie and  a destination QTVR movie file and creates them.    Return whether or not the operation completed. Note this function returns even  if an error occurs - exceptions are handled here.*/Boolean CMovieMaker::MakeAMovie(  Boolean inReplaceFiles,  const FSSpec &amp;inSrcSpec,  const FSSpec &amp;inTileSpec,  const FSSpec &amp;inDestSpec,  Int16 inWidth,  Int16 inHeight,  Fixed inPan,  Fixed inTilt,  Fixed inZoom,  CodecType inCodec,  CodecQ inSpatialQuality,  Int16 inDepth,  ProgressProc inProgressProc){  Boolean completed = true;  Int16 errStrIndex;  PicHandle srcPicH = nil;  FSSpec    tileSpec = inTileSpec,    destSpec = inDestSpec;    try  {    if (inProgressProc(&quot;\pCreating tile movie&quot;))      throw(Exception_UserCancelled);          // find unique file names if necessary    if (!inReplaceFiles)    {      FSSpec tempSpec; // a place for FSMakeFSSpec to do whatever it might      Int32 increment = 1; // just a number to place after the file name      unsigned char added = 0; // chars added to the name in case they need to be removed      OSErr result;      Str255        suffixStr,        numStr;            do      {        result = ::FSMakeFSSpec(tileSpec.vRefNum, tileSpec.parID, tileSpec.name,          &amp;tempSpec);        if (result == noErr)        {            // the file exists, so try another name          tileSpec.name[0] -= added;                    CopyPStr(&quot;\p_&quot;, suffixStr);          ::NumToString(increment++, numStr);                      // if necessary, chop off characters so the suffix will fit            // the changing part of the file name must be used          unsigned char charspace = 31 - suffixStr[0];          if (tileSpec.name[0] &gt; charspace)            tileSpec.name[0] = charspace;                    ConcatPStr(suffixStr, numStr);                    added = suffixStr[0];          ConcatPStr(tileSpec.name, suffixStr);        }      } while (result == noErr);            added = 0;      increment = 1;            do      {        result = ::FSMakeFSSpec(destSpec.vRefNum, destSpec.parID, destSpec.name,          &amp;tempSpec);        if (result == noErr)        {            // the file exists, so try another name          destSpec.name[0] -= added;          CopyPStr(&quot;\p_&quot;, suffixStr);          ::NumToString(increment++, numStr);            // if necessary, chop off characters so the suffix will fit            // the changing part of the file name must be used          unsigned char charspace = 31 - suffixStr[0];          if (destSpec.name[0] &gt; charspace)            destSpec.name[0] = charspace;                    ConcatPStr(suffixStr, numStr);          added = suffixStr[0];          ConcatPStr(destSpec.name, suffixStr);        }      } while (result == noErr);    }          // open the pict file and read the picture into a handle    errStrIndex = err_OpenPicture;    LFile pictFile(inSrcSpec);    Int16 fileRef = pictFile.OpenDataFork(fsRdPerm);    Int32 logEOF;    ThrowIfOSErr_(::GetEOF(fileRef, &amp;logEOF));    logEOF -= 512; // dont need the header    ThrowIfOSErr_(::SetFPos(fileRef, fsFromStart, 512));    srcPicH = (PicHandle)::NewHandle(logEOF);    ThrowIfMemError_();    ThrowIfOSErr_(::FSRead(fileRef, &amp;logEOF, *srcPicH));    pictFile.CloseDataFork();          // examine the PICT's rectangle    Int16      picHeight = (*srcPicH)-&gt;picFrame.bottom - (*srcPicH)-&gt;picFrame.top,      picWidth = (*srcPicH)-&gt;picFrame.right - (*srcPicH)-&gt;picFrame.left;          // check for correct orientation    if (picHeight &lt; picWidth)    {      CBeachBall::StopSpinningTask();      ::SetCursor(&amp;qd.arrow);      Str255        cwstr, chstr;      ::NumToString(picWidth, cwstr);      ::NumToString(picHeight, chstr);            gApp-&gt;BugUserTilSwitchedIn();      ::ParamText(cwstr, chstr, &quot;\p&quot;, &quot;\p&quot;);      if (::CautionAlert(ALRT_ConfirmOrientation, nil) != ok)      {        errStrIndex = err_BadPictHeight;        throw(Exception_UserCancelled);      }            CBeachBall::StartSpinningTask(5);    }          // check for % 96 height and % 4 width    if ((picHeight % 96) != 0 || (picWidth % 4) != 0)    {      CBeachBall::StopSpinningTask();      ::SetCursor(&amp;qd.arrow);      Str255        hstr, wstr;            if ((picHeight % 96) != 0)      {        Int16 newPicHeight = picHeight - (picHeight % 96);        double scale = (double)newPicHeight / (double)picHeight;        Int16 newPicWidth = (Int16)((double)picWidth * scale);        newPicWidth = newPicWidth - (newPicWidth % 4);        ::NumToString(newPicHeight, hstr);        ::NumToString(newPicWidth, wstr);      }      else        ::NumToString(picHeight, hstr);            if ((picWidth % 4) != 0)      {        Int16 newPicWidth = picWidth - (picWidth % 4);        ::NumToString(newPicWidth, wstr);      }            Str255        cwstr, chstr;      ::NumToString(picWidth, cwstr);      ::NumToString(picHeight, chstr);            gApp-&gt;BugUserTilSwitchedIn();      ::ParamText(cwstr, chstr, wstr, hstr);      if (::CautionAlert(ALRT_ConfirmSize, nil) != ok)      {        errStrIndex = err_BadPictHeight;        throw(Exception_UserCancelled);      }            CBeachBall::StartSpinningTask(5);    }          // create the tile movie file    errStrIndex = err_CreateTileMovie;    CreateTileMovie(srcPicH, tileSpec, inCodec, inSpatialQuality, inDepth, inProgressProc);    ::DisposeHandle((Handle)srcPicH);    srcPicH = nil;          // create the single node movie    errStrIndex = err_CreatePanoMovie;    if (inProgressProc(&quot;\pCreating panorama movie&quot;))      throw(Exception_UserCancelled);    CreateSingleNodeMovie(tileSpec, destSpec, inWidth, inHeight, inPan, inTilt, inZoom);  }  catch (ExceptionCode err)  {    if (srcPicH != nil)      ::DisposeHandle((Handle)srcPicH);        CBeachBall::StopSpinningTask();        if (err != Exception_UserCancelled)      ReportError(err, errStrIndex);        completed = false;  }    return completed;}/* CMovieMaker::QTProgress  A progress function passed to QuickTime and called during  compression. This was implemented to provide the user  finer control over the UI during processing.    It simply calls the app's progress proc and returns an error if the  user aborted the operation.*///staticpascal OSErr CMovieMaker::QTProgress(  short inMessage,  Fixed inCompleteness,  long inRefcon){  if (((ProgressProc)inRefcon)(nil))    return codecAbortErr;  return noErr;}/* CMovieMaker::CreateSingleNodeMovie  Create a QuickTime VR movie from the passed movie containg tiles.*/void CMovieMaker::CreateSingleNodeMovie(  const FSSpec &amp;inTileSpec,  const FSSpec &amp;inMovieSpec,  Int16 inWidth,  Int16 inHeight,  Fixed inPan,  Fixed inTilt,  Fixed inZoom){  OSErr result;  short tileResRefNum = 0;  Movie tileMovie = nil;  short resID = 0;  Track sceneTrack;  Fixed    sceneWidth, sceneHeight;  long sceneTrackID = 0;  Movie panoMovie = nil;  short panoResRefNum = 0;  PanoramaDescriptionHandle panoDesc = nil;  PanoSampleHeaderAtomHandle panoHeader = nil;    try  {    result = ::OpenMovieFile(&amp;inTileSpec, &amp;tileResRefNum, fsRdPerm);    ThrowIfOSErr_(result);        result = ::NewMovieFromFile(&amp;tileMovie, tileResRefNum, &amp;resID, 0, 0, 0);    ThrowIfOSErr_(result);        sceneTrack = ::GetMovieIndTrack(tileMovie, 1);    ThrowIfNil_(sceneTrack);    ::SetTrackEnabled(sceneTrack, false);    ::GetTrackDimensions(sceneTrack, &amp;sceneWidth, &amp;sceneHeight);    sceneWidth = sceneWidth &gt;&gt; 16;    sceneHeight = sceneHeight &gt;&gt; 16;    sceneTrackID = ::GetTrackID(sceneTrack);        UserData userData;    OSType controllerSubType;    userData = ::GetMovieUserData(tileMovie);    controllerSubType = kPanoMediaType;    ::SetUserDataItem(      userData, &amp;controllerSubType, sizeof(controllerSubType), 'ctyp', 0);        panoMovie = ::FlattenMovieData(      tileMovie, flattenDontInterleaveFlatten, &amp;inMovieSpec,       'vrod', 0, createMovieFileDeleteCurFile);          result = ::OpenMovieFile(&amp;inMovieSpec, &amp;panoResRefNum, fsRdWrPerm);     ThrowIfOSErr_(result);          ::AddMovieResource(panoMovie, panoResRefNum, &amp;resID, 0);          Track panoTrack;     panoTrack = ::NewMovieTrack(       panoMovie, ((long)inWidth) &lt;&lt; 16, ((long)inHeight) &lt;&lt; 16, 0);          TimeScale panoTimeScale;     panoTimeScale = ::GetMovieTimeScale(panoMovie);          Media panoMedia;     panoMedia = ::NewTrackMedia(panoTrack, kPanoMediaType, panoTimeScale, 0, 0);     result = ::GetMoviesError();     ThrowIfOSErr_(result);          TimeValue panoDuration;     panoDuration = ::GetMovieDuration(panoMovie);          panoDesc = (PanoramaDescriptionHandle)::NewHandleClear(       sizeof (PanoramaDescription));     ThrowIfOSErr_(::MemError());          (*panoDesc)-&gt;size = sizeof (PanoramaDescription);     (*panoDesc)-&gt;type = kPanDescType;          (*panoDesc)-&gt;sceneTrackID = sceneTrackID;     (*panoDesc)-&gt;hotSpotTrackID = 0; // no hot sport tracks          for (int i = 1; i &lt; 6; i++)     {       (*panoDesc)-&gt;reserved3[i] = 0;       (*panoDesc)-&gt;reserved4[i] = 0;     }          (*panoDesc)-&gt;sceneNumFramesX = 1;     (*panoDesc)-&gt;sceneNumFramesY = 24;     (*panoDesc)-&gt;numFrames = 24;     (*panoDesc)-&gt;sceneSizeX = sceneWidth;     (*panoDesc)-&gt;sceneSizeY = sceneHeight * 24;          (*panoDesc)-&gt;hPanStart = 0;    (*panoDesc)-&gt;hPanEnd = 360 &lt;&lt; 16;        float theta =       180.0 * (atan((*panoDesc)-&gt;sceneSizeX * 3.14159 /      (*panoDesc)-&gt;sceneSizeY)) / 3.14159;        (*panoDesc)-&gt;vPanTop = (Fixed)(theta * 65536);    (*panoDesc)-&gt;vPanBottom = (Fixed)(-theta * 65536);        (*panoDesc)-&gt;minimumZoom = 0;    (*panoDesc)-&gt;maximumZoom = 0;        (*panoDesc)-&gt;sceneColorDepth = 32;          // no hot spots    (*panoDesc)-&gt;hotSpotNumFramesX = 0;    (*panoDesc)-&gt;hotSpotNumFramesY = 0;    (*panoDesc)-&gt;hotSpotSizeX = 0;    (*panoDesc)-&gt;hotSpotSizeY = 0;    (*panoDesc)-&gt;hotSpotColorDepth = 8;          // fill in the panorama header atom data    panoHeader = (PanoSampleHeaderAtomHandle)::NewHandleClear(      sizeof(PanoSampleHeaderAtom));    (*panoHeader)-&gt;size = sizeof(PanoSampleHeaderAtom);    (*panoHeader)-&gt;type = kPanHeaderType;    (*panoHeader)-&gt;nodeID = 0;            // check pan for obvious errors    if (inPan &lt; 0)      inPan = 0;    if (inPan &gt; 360 &lt;&lt; 16)      inPan = 360 &lt;&lt; 16;          // set the default pan, tilt &amp; zoom    (*panoHeader)-&gt;defHPan = inPan;    (*panoHeader)-&gt;defVPan = inTilt;    if (inZoom == 0) // default: use some reasonable value      (*panoHeader)-&gt;defZoom = (Fixed)(1.5 * theta * 65536);    else      (*panoHeader)-&gt;defZoom = inZoom;        (*panoHeader)-&gt;commentStrOffset = 0;        result = ::BeginMediaEdits(panoMedia);    ThrowIfOSErr_(result);        result = ::AddMediaSample(panoMedia, (Handle)panoHeader, 0,       (*panoHeader)-&gt;size, panoDuration,       (SampleDescriptionHandle)panoDesc, 1, 0, nil);    if (result != noErr)    {      ::EndMediaEdits(panoMedia);      ThrowIfOSErr_(result);    }        result = ::EndMediaEdits(panoMedia);    ThrowIfOSErr_(result);        ::InsertMediaIntoTrack(panoTrack, 0, 0,       ::GetMediaDuration(panoMedia), 1 &lt;&lt; 16);    ThrowIfOSErr_(::GetMoviesError());        result = ::UpdateMovieResource(panoMovie, panoResRefNum, resID, 0);    ThrowIfOSErr_(result);        ::CloseMovieFile(tileResRefNum);    ::DisposeMovie(tileMovie);    ::CloseMovieFile(panoResRefNum);    ::DisposeMovie(panoMovie);    ::DisposeHandle((Handle)panoDesc);    ::DisposeHandle((Handle)panoHeader);  }  catch(ExceptionCode inErr)  {    if (tileResRefNum != 0)      ::CloseMovieFile(tileResRefNum);    if (tileMovie != nil)      ::DisposeMovie(tileMovie);        if (panoResRefNum != 0)      ::CloseMovieFile(panoResRefNum);    if (panoMovie != nil)      ::DisposeMovie(panoMovie);        if (panoDesc != nil)      ::DisposeHandle((Handle)panoDesc);    if (panoHeader != nil)      ::DisposeHandle((Handle)panoHeader);        throw(inErr);  }}/* CMovieMaker::CreateTileMovie  Create a QuickTime movie containing 24 tiles created from the passed PICT.*/void CMovieMaker::CreateTileMovie(  PicHandle inPicH,  const FSSpec &amp;inTileSpec,  CodecType inCodec,  CodecQ inSpatialQuality,  Int16 inDepth,  ProgressProc inProgressProc){  Rect    pictRect, tileRect;  LGWorld *tileWorld = nil;  OSErr result;  Movie tileMovie = nil;  short movieResRefNum = 0;  Track tileTrack;  Media tileMedia;  Handle compressedData = nil;  ImageDescriptionHandle imageDesc = nil;  Ptr compressedDataPtr;    try  {      // create a gworld to draw the tiles into    pictRect = tileRect = (*inPicH)-&gt;picFrame;    tileRect.bottom = tileRect.top + ((tileRect.bottom - tileRect.top) / 24);    tileWorld = new LGWorld(tileRect, 32, 0, nil, nil);          // create the tile movie file    result = ::CreateMovieFile(      &amp;inTileSpec,      'TVOD', 0,       createMovieFileDeleteCurFile,      &amp;movieResRefNum,      &amp;tileMovie);    ThrowIfOSErr_(result);          // create a track &amp; media to contain the tiles    tileTrack = ::NewMovieTrack(      tileMovie,      ((long)(tileRect.right - tileRect.left)) &lt;&lt; 16,       ((long)(tileRect.bottom - tileRect.top)) &lt;&lt; 16,      0);    ThrowIfNil_(tileTrack);        tileMedia = ::NewTrackMedia(      tileTrack,      VideoMediaType, 600, 0, 0);    ThrowIfNil_(tileMedia);        result = ::BeginMediaEdits(tileMedia);    ThrowIfOSErr_(result);          // prepare an image description handle    imageDesc = (ImageDescriptionHandle)::NewHandle(4);    ThrowIfOSErr_(::MemError());          // set up the progress record    ICMProgressProcRecord qtproc;    qtproc.progressProc = NewICMProgressProc(QTProgress);    qtproc.progressRefCon = (long)inProgressProc;        long compressedFrameSize;    TimeValue      duration = 60, currentTime;    for (Int16 i = 0; i &lt; 24; i++)    {        // let the user know what is going on      Str255        s1, s2;      CopyPStr(&quot;\pCompressing tile &quot;, s1);      ::NumToString(i + 1, s2);      ConcatPStr(s1, s2);      ConcatPStr(s1, &quot;\p of 24&quot;);      if (inProgressProc(s1))        throw(Exception_UserCancelled);        // draw the picture into the tile gworld      tileWorld-&gt;BeginDrawing();      ::DrawPicture(inPicH, &amp;pictRect);      tileWorld-&gt;EndDrawing();              // offset the pict rect for next time      ::OffsetRect(&amp;pictRect, 0, -(tileRect.bottom - tileRect.top));              // prepare a handle for compression      ::LockPixels(::GetGWorldPixMap(tileWorld-&gt;GetMacGWorld()));      result = GetMaxCompressionSize(        ::GetGWorldPixMap(tileWorld-&gt;GetMacGWorld()),         &amp;tileRect, inDepth, inSpatialQuality,        inCodec, anyCodec, &amp;compressedFrameSize);      ::UnlockPixels(::GetGWorldPixMap(tileWorld-&gt;GetMacGWorld()));      ThrowIfOSErr_(result);      compressedData = ::NewHandle(compressedFrameSize);      ThrowIfOSErr_(::MemError());      ::HLock(compressedData);      compressedDataPtr = StripAddress((*compressedData));              // compress the tile      ::LockPixels(::GetGWorldPixMap(tileWorld-&gt;GetMacGWorld()));      result = ::FCompressImage(        ::GetGWorldPixMap(tileWorld-&gt;GetMacGWorld()), &amp;tileRect,        0, inSpatialQuality, inCodec, anyCodec,        nil, 0, 0, nil, &amp;qtproc,        imageDesc, compressedDataPtr);      ::UnlockPixels(::GetGWorldPixMap(tileWorld-&gt;GetMacGWorld()));      if (result == codecAbortErr)        throw(Exception_UserCancelled); // the user did it      ThrowIfOSErr_(result);              // add the tile to the movie      result = ::AddMediaSample(tileMedia, compressedData,0,        (*imageDesc)-&gt;dataSize, duration,        (SampleDescriptionHandle)imageDesc, 1, 0, &amp;currentTime);      ThrowIfOSErr_(result);            ::DisposeHandle(compressedData);      compressedData = nil;    }        delete tileWorld;    tileWorld = nil;        result = ::EndMediaEdits(tileMedia);    ThrowIfOSErr_(result);        ::InsertMediaIntoTrack(      tileTrack,      0, 0,      GetMediaDuration(tileMedia), 1L&lt;&lt;16);    ThrowIfOSErr_(::GetMoviesError());        short resID = 128;    result = ::AddMovieResource(      tileMovie, movieResRefNum, &amp;resID, &quot;\pMovie 1&quot;);    ThrowIfOSErr_(result);        ::DisposeHandle((Handle)imageDesc);    imageDesc = nil;    ::DisposeHandle(compressedData);    compressedData = nil;        ::CloseMovieFile(movieResRefNum);    ::DisposeMovie(tileMovie);  }  catch(ExceptionCode inErr)  {    if (tileWorld != nil)      delete tileWorld;      // at least try to delete the tile movie file    if (movieResRefNum != 0)    {      ::CloseMovieFile(movieResRefNum);      ::DeleteMovieFile(&amp;inTileSpec);    }        if (compressedData != nil)      ::DisposeHandle(compressedData);    if (imageDesc != nil)      ::DisposeHandle((Handle)imageDesc);        if (tileMovie != nil)      ::DisposeMovie(tileMovie);        throw(inErr);  }}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Make_QTVR_Panorama/listing8.html%3Fid%3DDTS10000339-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Make_QTVR_Panorama/listing8.html%3Fid%3DDTS10000339-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Make_QTVR_Panorama/listing8.html%3Fid%3DDTS10000339-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>