<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>vImage Transform Reference</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="vImage Transform Reference"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40005493-DontLinkChapterID_1" title="vImage Transform Reference"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> &gt; <a href="../../../../../reference/Performance/index.html#//apple_ref/doc/uid/TP30001281-TP30000430" target="_top">Performance</a> &gt; <a href="../../../../../reference/Performance/idxGraphicsImaging-date.html#//apple_ref/doc/uid/TP30001281-TP30000430-TP30000450" target="_top">Graphics &amp; Imaging</a> &gt; <a href="../index.html" target="_top">vImage Transform Reference</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <!-- Previous button --><span style="margin-left: 8px"><a href="../revhx.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40005493-DontLinkChapterID_1-DontLinkElementID_11" title="vImage Transform Reference"></a><h1>vImage Transform Reference</h1><div class="spec_sheet_info_box"><table cellspacing="0" class="specbox"><tr><td scope="row"><strong><span style="white-space: nowrap;">Framework</span></strong></td><td><div style="margin-bottom:1px"><a href="../../vDSP_Reference_Collection/index.html#//apple_ref/doc/uid/TP40006226" target="_top">Accelerate</a>/vImage</div></td></tr><tr><td scope="row"><strong><span class="noWrap">Companion guide</span></strong></td><td><div style="margin-bottom:1px"><span class="content_text"><a href="../../../Conceptual/vImage/index.html#//apple_ref/doc/uid/TP30001001" target="_top">vImage Programming Guide</a></span><br/></div></td></tr><tr><td scope="row"><strong><span style="white-space: nowrap;">Declared in</span></strong></td><td><div style="margin-bottom:1px"><span class="content_text">Transform.h</span><br/></div></td></tr></table></div><br/><a name="//apple_ref/doc/uid/TP40005493-CH1-DontLinkElementID_8" title="Overview"></a><h2>Overview</h2><p>Transformation functions alter the values of pixels in the image. Unlike convolutions, transformation functions do not depend on the values of nearby pixels. The vImage transformation functions fall into four broad categories:</p><ul class="ul"><li class="li"><p>Gamma correction functions  correct the brightness profile of an image by multiplying each pixel by the value of the function. Gamma correction prepares an image for display or printing on a particular device.</p></li><li class="li"><p>Lookup table  functions are like the piecewise polynomial functions, but instead of applying a polynomial they use a lookup table that you supply.</p></li><li class="li"><p>Matrix multiplication functions have a variety of uses, such as to convert between color spaces (RGB and YUV, for example), change a color image to a grayscale one, and for “color twisting.”</p></li><li class="li"><p>Piecewise functions are similar to the gamma correction functions, but instead of applying a predefined gamma function they apply one or more polynomials that you supply. The number of polynomials must be an integer power of 2, and they must all be of the same order.</p></li></ul><p>Transformation functions use a vImage buffer structure (<code>vImage_Buffer</code>—see <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>) to receive and supply image data. This buffer contains a pointer to image data, the height and width (in pixels) of the image data, and the number of row bytes. You actually pass a pointer to a vImage buffer structure. </p><p>Some transformation functions “work in place”. That is, the source and destination images can occupy the same memory if the they are strictly aligned pixel for pixel. For these, you can can provide a pointer to the same vImage buffer structure for one of the source images and the destination image.</p><a name="//apple_ref/doc/uid/TP40005493-DontLinkChapterID_1-DontLinkElementID_9" title="Functions by Task"></a><h2>Functions by Task</h2>
<a name="//apple_ref/doc/uid/TP40005493-CH210-DontLinkElementID_1" title="Transforming with a Lookup Table"></a>
    
    <h3 class="tasks">Transforming with a Lookup Table</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageLookupTable_Planar8toPlanarF">vImageLookupTable_Planar8toPlanarF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Uses a lookup table to transform an image in Planar8 format to an image in PlanarF format.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageLookupTable_PlanarFtoPlanar8">vImageLookupTable_PlanarFtoPlanar8</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Uses a lookup table to transform an image in PlanarF format to an image in Planar8 format. '/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageInterpolatedLookupTable_PlanarF">vImageInterpolatedLookupTable_PlanarF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Uses a lookup table to transform an image in PlanarF format to an image in PlanarF format.'/>
            </span></li>
    </ul>


<a name="//apple_ref/doc/uid/TP40005493-CH210-DontLinkElementID_2" title="Applying a Polynomial"></a>
    
    <h3 class="tasks">Applying a Polynomial</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImagePiecewisePolynomial_PlanarF">vImagePiecewisePolynomial_PlanarF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Applies a set of piecewise polynomials to an image in PlanarF format.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImagePiecewisePolynomial_Planar8toPlanarF">vImagePiecewisePolynomial_Planar8toPlanarF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Applies a set of piecewise polynomials to transform an image in Planar8 format to an image in PlanarF format. '/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImagePiecewisePolynomial_PlanarFtoPlanar8">vImagePiecewisePolynomial_PlanarFtoPlanar8</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Applies a set of piecewise polynomials to transform an image in PlanarF format to an image in Planar8 format.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImagePiecewiseRational_PlanarF">vImagePiecewiseRational_PlanarF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Applies a piecewise rational expression to  an image in PlanarF format. '/>
            </span></li>
    </ul>


<a name="//apple_ref/doc/uid/TP40005493-CH210-237498" title="Multiplying Pixels by a Matrix"></a>
    
    <h3 class="tasks">Multiplying Pixels by a Matrix</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageMatrixMultiply_Planar8">vImageMatrixMultiply_Planar8</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Operates on a set of 8-bit source image planes, multiplying each pixel by the provided matrix to produce a set of 8-bit destination image planes.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageMatrixMultiply_PlanarF">vImageMatrixMultiply_PlanarF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Operates upon a set of floating-point source image planes, multiplying each pixel by the provided  matrix to produce a set of floating-point destination image planes. '/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageMatrixMultiply_ARGB8888">vImageMatrixMultiply_ARGB8888</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Operates upon an interleaved 8-bit source image, multiplying each pixel by the provided  matrix to produce an interleaved 8-bit destination image.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageMatrixMultiply_ARGBFFFF">vImageMatrixMultiply_ARGBFFFF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Operates upon an interleaved floating-point source image, multiplying each pixel by the provided  matrix to produce an interleaved floating-point destination image. '/>
            </span></li>
    </ul>


<a name="//apple_ref/doc/uid/TP40005493-CH210-274329" title="Correcting Gamma"></a><a name="//apple_ref/doc/uid/TP40005493-CH210-BBCDFFJD" title="Correcting Gamma"></a>
    
    <h3 class="tasks"><a name="//apple_ref/doc/uid/TP40005493-CH210-BBCIJFBJ" title="Correcting Gamma"></a>Correcting Gamma</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageCreateGammaFunction">vImageCreateGammaFunction</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Returns a gamma function object.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageDestroyGammaFunction">vImageDestroyGammaFunction</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Destroys a gamma function object created.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageGamma_Planar8toPlanarF">vImageGamma_Planar8toPlanarF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Applies a gamma function to a Planar8 image to produce a PlanarF image.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageGamma_PlanarFtoPlanar8">vImageGamma_PlanarFtoPlanar8</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Applies a gamma function to an image in PlanarF format to an image in Planar8 format.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageGamma_PlanarF">vImageGamma_PlanarF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Applies a gamma function to a PlanarF image.'/>
            </span></li>
    </ul>

<a name="//apple_ref/doc/uid/TP40005493-CH210-222475" title="Functions"></a><a name="//apple_ref/doc/uid/TP40005493-CH210-BBCCEIDH" title="Functions"></a><h2><a name="//apple_ref/doc/uid/TP40005493-CH210-TPXREF102" title="Functions"></a>Functions</h2>            <a name="//apple_ref/c/func/vImageCreateGammaFunction" title="vImageCreateGammaFunction"></a><a name="//apple_ref/doc/c_ref/vImageCreateGammaFunction" title="vImageCreateGammaFunction"></a><a name="//apple_ref/doc/uid/TP40005493-CH210-SW2" title="vImageCreateGammaFunction"></a><a name="//apple_ref/doc/uid/TP40005493-CH210-DontLinkElementID_13"></a><h3 class="tight">vImageCreateGammaFunction</h3> <p class="spaceabove">Returns a gamma function object.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/GammaFunction" target="_top">GammaFunction</a> vImageCreateGammaFunction (
   float gamma,
   int gamma_type,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>gamma</em></dt> <dd><p>The exponent of a power function for calculating full-precision gamma correction.</p></dd> <dt><em>gamma-type</em></dt> <dd><p>A selector for  the type of gamma correction to use. Pass one of the full- or half-precision type constants defined in <span class="content_text"><a href="reference.html#//apple_ref/doc/constant_group/Gamma_Function_Types">“Gamma Function Types.”</a></span></p></dd> <dt><em>flags</em></dt> <dd><p>Pass <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> if you plan to perform your own tiling or use multithreading.</p></dd></dl> <h5 class="tight">Return Value</h5> <p>A gamma function object that encapsulates a gamma value, a gamma function type, and option flags.</p> <h5 class="tight">Discussion</h5> <p>You can pass a gamma function object to any of the three gamma correction functions: <code><a href="reference.html#//apple_ref/c/func/vImageGamma_Planar8toPlanarF">vImageGamma_Planar8toPlanarF</a></code>, <code><a href="reference.html#//apple_ref/c/func/vImageGamma_PlanarFtoPlanar8">vImageGamma_PlanarFtoPlanar8</a></code>, <code><a href="reference.html#//apple_ref/c/func/vImageGamma_PlanarF">vImageGamma_PlanarF</a></code>.</p><p>The gamma-type parameter determines the type of calculation to be used. The simplest calculation is:</p> <div class="codesample"><table><tr><td scope="row"><pre>if (value == 0) result = 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>else {<span></span></pre></td></tr><tr><td scope="row"><pre>    if (value &lt; 0)<span></span></pre></td></tr><tr><td scope="row"><pre>        sign = -1.0f;<span></span></pre></td></tr><tr><td scope="row"><pre>    else<span></span></pre></td></tr><tr><td scope="row"><pre>        sign = 1.0f;<span></span></pre></td></tr><tr><td scope="row"><pre>    result = pow( fabs( value ), gamma) * sign;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div> <p>This calculation results in symmetric gamma curves about 0, and makes sure that only well-behaved values are used in <code>pow()</code>.</p> <p>You can use an equivalent calculation that uses a more efficient method, depending on the desired precision.</p> <p>In addition to the full-precision gamma correction, there is a faster half-precision option that provides 12-bit precision.</p> <p>f your data will ultimately be converted to 8-bit integer data, consider using half-precision. The half-precision variants  work correctly only for floating-point input values in the range 0.0 ... 1.0, though out-of-range values produce results that clamp appropriately to 0 or 255 on conversion back to 8-bit. In addition, there are restrictions on the range of the exponent: it must be positive, in the range 0.1 to 10.0.</p> <p>Finally, there is a set of still faster half-precision options that use predefined gamma values, ignoring the value set in <code><a href="reference.html#//apple_ref/doc/c_ref/vImageCreateGammaFunction">vImageCreateGammaFunction</a></code>. These options have the same restrictions on input values as stated previously.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Transform.h</code><a name="//apple_ref/c/func/vImageDestroyGammaFunction" title="vImageDestroyGammaFunction"></a><a name="//apple_ref/doc/c_ref/vImageDestroyGammaFunction" title="vImageDestroyGammaFunction"></a><a name="//apple_ref/doc/uid/TP40005493-CH210-DontLinkElementID_7" title="vImageDestroyGammaFunction"></a><a name="//apple_ref/doc/uid/TP40005493-CH210-DontLinkElementID_14"></a><h3 class="tight">vImageDestroyGammaFunction</h3> <p class="spaceabove">Destroys a gamma function object created.</p> <p class="spaceabove"><pre>
void vImageDestroyGammaFunction (
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/GammaFunction" target="_top">GammaFunction</a> f
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>f</em></dt> <dd><p>A gamma function object created with the function <code><a href="reference.html#//apple_ref/c/func/vImageCreateGammaFunction">vImageCreateGammaFunction</a></code>.</p></dd></dl><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Transform.h</code><a name="//apple_ref/c/func/vImageGamma_Planar8toPlanarF" title="vImageGamma_Planar8toPlanarF"></a><a name="//apple_ref/doc/c_ref/vImageGamma_Planar8toPlanarF" title="vImageGamma_Planar8toPlanarF"></a><a name="//apple_ref/doc/uid/TP40005493-CH210-SW5" title="vImageGamma_Planar8toPlanarF"></a><a name="//apple_ref/doc/uid/TP40005493-CH210-DontLinkElementID_15"></a><h3 class="tight">vImageGamma_Planar8toPlanarF</h3> <p class="spaceabove">Applies a gamma function to a Planar8 image to produce a PlanarF image.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageGamma_Planar8toPlanarF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   const <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/GammaFunction" target="_top">GammaFunction</a> gamma,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>gamma</em></dt> <dd><p>A gamma function object, created with by calling the function <code><a href="reference.html#//apple_ref/c/func/vImageCreateGammaFunction">vImageCreateGammaFunction</a></code>.</p></dd> <dt><em>flags</em></dt> <dd><p>Reserved for future use; pass 0.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Transform.h</code><a name="//apple_ref/c/func/vImageGamma_PlanarF" title="vImageGamma_PlanarF"></a><a name="//apple_ref/doc/c_ref/vImageGamma_PlanarF" title="vImageGamma_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005493-CH210-SW7" title="vImageGamma_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005493-CH210-DontLinkElementID_16"></a><h3 class="tight">vImageGamma_PlanarF</h3> <p class="spaceabove">Applies a gamma function to a PlanarF image.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageGamma_PlanarF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   const <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/GammaFunction" target="_top">GammaFunction</a> gamma,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>gamma</em></dt> <dd><p>A gamma function object, created with by calling the function <code><a href="reference.html#//apple_ref/c/func/vImageCreateGammaFunction">vImageCreateGammaFunction</a></code>.</p></dd> <dt><em>flags</em></dt> <dd><p>Reserved for future use; pass 0.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Transform.h</code><a name="//apple_ref/c/func/vImageGamma_PlanarFtoPlanar8" title="vImageGamma_PlanarFtoPlanar8"></a><a name="//apple_ref/doc/c_ref/vImageGamma_PlanarFtoPlanar8" title="vImageGamma_PlanarFtoPlanar8"></a><a name="//apple_ref/doc/uid/TP40005493-CH210-SW6" title="vImageGamma_PlanarFtoPlanar8"></a><a name="//apple_ref/doc/uid/TP40005493-CH210-DontLinkElementID_17"></a><h3 class="tight">vImageGamma_PlanarFtoPlanar8</h3> <p class="spaceabove">Applies a gamma function to an image in PlanarF format to an image in Planar8 format.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageGamma_PlanarFtoPlanar8 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   const <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/GammaFunction" target="_top">GammaFunction</a> gamma,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>gamma</em></dt> <dd><p>A gamma function object, created with by calling the function <code><a href="reference.html#//apple_ref/c/func/vImageCreateGammaFunction">vImageCreateGammaFunction</a></code>.</p></dd> <dt><em>flags</em></dt> <dd><p>Reserved for future use; pass 0.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Transform.h</code><a name="//apple_ref/c/func/vImageInterpolatedLookupTable_PlanarF" title="vImageInterpolatedLookupTable_PlanarF"></a><a name="//apple_ref/doc/c_ref/vImageInterpolatedLookupTable_PlanarF" title="vImageInterpolatedLookupTable_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005493-CH210-BBCBJCED" title="vImageInterpolatedLookupTable_PlanarF"></a> <a name="//apple_ref/doc/uid/TP40005493-CH210-DontLinkElementID_18"></a><h3 class="tight">vImageInterpolatedLookupTable_PlanarF</h3> <p class="spaceabove">Uses a lookup table to transform an image in PlanarF format to an image in PlanarF format.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageInterpolatedLookupTable_PlanarF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   const <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_F" target="_top">Pixel_F</a> *table,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> tableEntries,
   float maxFloat,
   float minFloat,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>table</em></dt> <dd><p>A lookup table of floating-point values.</p></dd> <dt><em>tableEntries</em></dt> <dd><p>A value of type <code>vImagePixelCount</code>, giving the number of values in the array.</p></dd> <dt><em>maxFloat</em></dt> <dd><p>A value of type <code>float</code>.</p></dd> <dt><em>minFloat</em></dt> <dd><p>A value of type <code>float</code>.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing the transformation. Pass <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> if you plan to perform your own tiling or use multithreading.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>It will work in place. The table contains an arbitrary number of values; it is entered with an index interpolated from a value from the source image, to look up a floating-point value for the destination image.</p><p>The input pixel is first clipped to the range <em>minFloat</em> ... <em>maxFloat</em>. The result is then calculated as</p> <div class="codesample"><table><tr><td scope="row"><pre>    float clippedPixel =MAX(MIN(src_pixel, maxFloat), minFloat);<span></span></pre></td></tr><tr><td scope="row"><pre>    float fIndex =  (float) (tableEntries - 1) * (clippedPixel -  minFloat)<span></span></pre></td></tr><tr><td scope="row"><pre>                    / (maxFloat - minFloat);<span></span></pre></td></tr><tr><td scope="row"><pre>    float fract = fIndex - floor(fIndex);<span></span></pre></td></tr><tr><td scope="row"><pre>    unsigned long i = fIndex;<span></span></pre></td></tr><tr><td scope="row"><pre>    float result = table[i] * (1.0f - fract) + table[i + 1] * fract;<span></span></pre></td></tr></table></div><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Transform.h</code><a name="//apple_ref/c/func/vImageLookupTable_Planar8toPlanarF" title="vImageLookupTable_Planar8toPlanarF"></a><a name="//apple_ref/doc/c_ref/vImageLookupTable_Planar8toPlanarF" title="vImageLookupTable_Planar8toPlanarF"></a><a name="//apple_ref/doc/uid/TP40005493-CH210-BBCCAGCF" title="vImageLookupTable_Planar8toPlanarF"></a> <a name="//apple_ref/doc/uid/TP40005493-CH210-DontLinkElementID_19"></a><h3 class="tight">vImageLookupTable_Planar8toPlanarF</h3> <p class="spaceabove">Uses a lookup table to transform an image in Planar8 format to an image in PlanarF format.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageLookupTable_Planar8toPlanarF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   const <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_F" target="_top">Pixel_F</a> table[256],
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>table</em></dt> <dd><p>A lookup table that contains 256 values.</p></dd> <dt><em>flags</em></dt> <dd><p>Reserved for future use; pass 0.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>For each pixel, the 8-bit value from the source Planar8 image is used as an index to get a floating-point value from the table. This value is used as the corresponding pixel in the PlanarF result image.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Transform.h</code><a name="//apple_ref/c/func/vImageLookupTable_PlanarFtoPlanar8" title="vImageLookupTable_PlanarFtoPlanar8"></a><a name="//apple_ref/doc/c_ref/vImageLookupTable_PlanarFtoPlanar8" title="vImageLookupTable_PlanarFtoPlanar8"></a><a name="//apple_ref/doc/uid/TP40005493-CH210-BBCHJBFB" title="vImageLookupTable_PlanarFtoPlanar8"></a> <a name="//apple_ref/doc/uid/TP40005493-CH210-DontLinkElementID_20"></a><h3 class="tight">vImageLookupTable_PlanarFtoPlanar8</h3> <p class="spaceabove">Uses a lookup table to transform an image in PlanarF format to an image in Planar8 format. </p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageLookupTable_PlanarFtoPlanar8 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   const <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_8" target="_top">Pixel_8</a> table[4096],
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains  the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>table</em></dt> <dd><p>A lookup table that contains 4096 values.</p></dd> <dt><em>flags</em></dt> <dd><p>Reserved for future use; pass 0.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>The table contains 4096 values; it is entered with an integer index derived from a pixel value in the source image, to look up an 8-bit value for the destination image.</p><p>For each pixel, the floating-point value from the source PlanarF image is first clipped to the range 0.0 ... 1.0, and then converted to an integer in the range 0 ... 4095. The conversion calculation is equivalent to</p> <div class="codesample"><table><tr><td scope="row"><pre>    if (realValue &lt; 0.0f) realValue = 0.0f;<span></span></pre></td></tr><tr><td scope="row"><pre>    if (realValue > 1.0f) realValue = 1.0f;<span></span></pre></td></tr><tr><td scope="row"><pre>    intValue = (int)(realValue * 4095.0f + 0.5f);<span></span></pre></td></tr></table></div> <p>This integer is used as an index to get an 8-bit value from the table. This value is used as the corresponding pixel in the Planar8 result image.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Transform.h</code><a name="//apple_ref/c/func/vImageMatrixMultiply_ARGB8888" title="vImageMatrixMultiply_ARGB8888"></a><a name="//apple_ref/doc/c_ref/vImageMatrixMultiply_ARGB8888" title="vImageMatrixMultiply_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005493-CH210-SW4" title="vImageMatrixMultiply_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005493-CH210-DontLinkElementID_21"></a><h3 class="tight">vImageMatrixMultiply_ARGB8888</h3><p class="spaceabove">Operates upon an interleaved 8-bit source image, multiplying each pixel by the provided  matrix to produce an interleaved 8-bit destination image.</p><p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageMatrixMultiply_ARGB8888 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   const int16_t matrix[4 *4],
   int32_t divisor,
   const int16_t *pre_bias,
   const int32_t *post_bias,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p><h5 class="tight">Parameters</h5><dl class="termdef"><dt><em>src</em></dt><dd><p>A pointer to a vImage buffer structure that contains  the source image.</p></dd><dt><em>dest</em></dt><dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd><dt><em>matrix</em></dt><dd><p>A 1-dimensional array whose values represent a 4<code>x</code>4 matrix. vImage multiplies each source pixel  by this matrix to produce a destination pixel.</p></dd><dt><em>divisor</em></dt><dd><p>A divisor for normalization after performing the matrix multiplication.</p></dd><dt><em>pre_bias</em></dt><dd><p>A packed array of bias values, one for each source plane. vImage adds the appropriate bias value to each source value prior to matrix multiplication. Pass <code><!--a  -->NULL<!--/a--></code> if you do not want to apply a preprocessing bias value.</p></dd><dt><em>post_bias</em></dt><dd><p>A packed array of bias values, one for each destination plane. vImage adds the appropriate bias value to each destination value after matrix multiplication. Pass <code><!--a  -->NULL<!--/a--></code> if you do not want to apply a preprocessing bias value.</p></dd><dt><em>flags</em></dt><dd><p>Reserved for future use; pass 0.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p><h5 class="tight">Discussion</h5><p>Be aware that 32-bit signed accumulators are used. If the sum over any matrix column is greater than ±223, overflow may occur. Generally speaking this will not happen because the matrix elements are 16-bit integers, so it would take more than 256 source planes before trouble could arise.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Transform.h</code><a name="//apple_ref/c/func/vImageMatrixMultiply_ARGBFFFF" title="vImageMatrixMultiply_ARGBFFFF"></a><a name="//apple_ref/doc/c_ref/vImageMatrixMultiply_ARGBFFFF" title="vImageMatrixMultiply_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005493-CH210-DontLinkElementID_6" title="vImageMatrixMultiply_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005493-CH210-DontLinkElementID_22"></a><h3 class="tight">vImageMatrixMultiply_ARGBFFFF</h3><p class="spaceabove">Operates upon an interleaved floating-point source image, multiplying each pixel by the provided  matrix to produce an interleaved floating-point destination image. </p><p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageMatrixMultiply_ARGBFFFF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   const float matrix[4 *4],
   const float *pre_bias,
   const float *post_bias,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p><h5 class="tight">Parameters</h5><dl class="termdef"><dt><em>src</em></dt><dd><p>A pointer to a vImage buffer structure that contains  the source image.</p></dd><dt><em>dest</em></dt><dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd><dt><em>matrix</em></dt><dd><p>A 1-dimensional array whose values represent a 4<code>x</code>4 matrix. vImage multiplies each source pixel  by this matrix to produce a destination pixel.</p></dd><dt><em>pre_bias</em></dt><dd><p>A packed array of bias values, one for each source plane. vImage adds the appropriate bias value to each source value prior to matrix multiplication. Pass <code><!--a  -->NULL<!--/a--></code> if you do not want to apply a preprocessing bias value.</p></dd><dt><em>post_bias</em></dt><dd><p>A packed array of bias values, one for each destination plane. vImage adds the appropriate bias value to each destination value after matrix multiplication. Pass <code><!--a  -->NULL<!--/a--></code> if you do not want to apply a preprocessing bias value.</p></dd><dt><em>flags</em></dt><dd><p>Reserved for future use; pass 0.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p><h5 class="tight">Discussion</h5><p>The operation is the same as <code><a href="reference.html#//apple_ref/c/func/vImageMatrixMultiply_ARGB8888">vImageMatrixMultiply_ARGB8888</a></code> except that floating-point values are used and there is no divisor.</p><p>Be aware that 32-bit signed accumulators are used. If the sum over any matrix column is greater than ±223, overflow may occur. Generally speaking this will not happen because the matrix elements are 16-bit integers, so it would take more than 256 source planes before trouble could arise.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Transform.h</code><a name="//apple_ref/c/func/vImageMatrixMultiply_Planar8" title="vImageMatrixMultiply_Planar8"></a><a name="//apple_ref/doc/c_ref/vImageMatrixMultiply_Planar8" title="vImageMatrixMultiply_Planar8"></a><a name="//apple_ref/doc/uid/TP40005493-CH210-SW3" title="vImageMatrixMultiply_Planar8"></a><a name="//apple_ref/doc/uid/TP40005493-CH210-DontLinkElementID_23"></a><h3 class="tight">vImageMatrixMultiply_Planar8</h3><p class="spaceabove">Operates on a set of 8-bit source image planes, multiplying each pixel by the provided matrix to produce a set of 8-bit destination image planes.</p><p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageMatrixMultiply_Planar8 (
   const <!--a-->vImage_Buffer<!--/a--> *srcs[],
   const <!--a-->vImage_Buffer<!--/a--> *dests[],
   uint32_t src_planes,
   uint32_t dest_planes,
   const int16_t matrix[],
   int32_t divisor,
   const int16_t *pre_bias,
   const int32_t *post_bias,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p><h5 class="tight">Parameters</h5><dl class="termdef"><dt><em>srcs</em></dt><dd><p>A pointer to an array of vImage buffer structures, one buffer for each source plane.</p></dd><dt><em>dests</em></dt><dd><p>A pointer to an array of pointers to vImage buffer data structures, one buffer structure for each destination plane. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of these structures, and for allocating data buffers of the appropriate size.  On return, the data buffers in these structures contains  the destination image data for each plane. When you no longer need the data buffers, you must deallocate the memory.</p></dd><dt><em>src_planes</em></dt><dd><p>The number of source planes.</p></dd><dt><em>dest_planes</em></dt><dd><p>The number of destination planes.</p></dd><dt><em>matrix</em></dt><dd><p>A 1-dimensional array whose values represent a matrix with dimensions <em>dest_planes</em><code>x</code><em>src_planes</em>. vImage multiplies each source pixel  by this matrix to produce a destination pixel.</p></dd><dt><em>divisor</em></dt><dd><p>A divisor for normalization after performing the matrix multiplication.</p></dd><dt><em>pre_bias</em></dt><dd><p>A packed array of bias values, one for each source plane. vImage adds the appropriate bias value to each source value prior to matrix multiplication. Pass <code><!--a  -->NULL<!--/a--></code> if you do not want to apply a preprocessing bias value.</p></dd><dt><em>post_bias</em></dt><dd><p>A packed array of bias values, one for each destination plane. vImage adds the appropriate bias value to each destination value after matrix multiplication. Pass <code><!--a  -->NULL<!--/a--></code> if you do not want to apply a preprocessing bias value.</p></dd><dt><em>flags</em></dt><dd><p>The options to use when performing the transformation. Pass <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> if you plan to perform your own tiling or use multithreading.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p><h5 class="tight">Discussion</h5><p>Be aware that 32-bit signed accumulators are used. If the sum over any matrix column is greater than ±223, overflow may occur. Generally speaking this will not happen because the matrix elements are 16-bit integers, so it would take more than 256 source planes before trouble could arise.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Transform.h</code><a name="//apple_ref/c/func/vImageMatrixMultiply_PlanarF" title="vImageMatrixMultiply_PlanarF"></a><a name="//apple_ref/doc/c_ref/vImageMatrixMultiply_PlanarF" title="vImageMatrixMultiply_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005493-CH210-DontLinkElementID_5" title="vImageMatrixMultiply_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005493-CH210-DontLinkElementID_24"></a><h3 class="tight">vImageMatrixMultiply_PlanarF</h3><p class="spaceabove">Operates upon a set of floating-point source image planes, multiplying each pixel by the provided  matrix to produce a set of floating-point destination image planes. </p><p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageMatrixMultiply_PlanarF (
   const <!--a-->vImage_Buffer<!--/a--> *srcs[],
   const <!--a-->vImage_Buffer<!--/a--> *dests[],
   uint32_t src_planes,
   uint32_t dest_planes,
   const float matrix[],
   const float *pre_bias,
   const float *post_bias,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p><h5 class="tight">Parameters</h5><dl class="termdef"><dt><em>srcs</em></dt><dd><p>A pointer to an array of vImage buffer structures, one buffer for each source plane.</p></dd><dt><em>dests</em></dt><dd><p>A pointer to an array of pointers to vImage buffer data structures, one buffer structure for each destination plane. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of these structures, and for allocating data buffers of the appropriate size.  On return, the data buffers in these structures contains  the destination image data for each plane. When you no longer need the data buffers, you must deallocate the memory.</p></dd><dt><em>src_planes</em></dt><dd><p>The number of source planes.</p></dd><dt><em>dest_planes</em></dt><dd><p>The number of destination planes.</p></dd><dt><em>matrix</em></dt><dd><p>A 1-dimensional array whose values represent a matrix with dimensions <em>dest_planes</em><code>x</code><em>src_planes</em>. vImage multiplies each source pixel  by this matrix to produce a destination pixel.</p></dd><dt><em>pre_bias</em></dt><dd><p>A packed array of bias values, one for each source plane. vImage adds the appropriate bias value to each source value prior to matrix multiplication. Pass <code><!--a  -->NULL<!--/a--></code> if you do not want to apply a preprocessing bias value.</p></dd><dt><em>post_bias</em></dt><dd><p>A packed array of bias values, one for each destination plane. vImage adds the appropriate bias value to each destination value after matrix multiplication. Pass <code><!--a  -->NULL<!--/a--></code> if you do not want to apply a preprocessing bias value.</p></dd><dt><em>flags</em></dt><dd><p>Reserved for future use; pass 0.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p><h5 class="tight">Discussion</h5><p>The operation is the same as<code><a href="reference.html#//apple_ref/c/func/vImageMatrixMultiply_Planar8">vImageMatrixMultiply_Planar8</a></code> except that floating-point values are used and there is no divisor.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Transform.h</code><a name="//apple_ref/c/func/vImagePiecewisePolynomial_Planar8toPlanarF" title="vImagePiecewisePolynomial_Planar8toPlanarF"></a><a name="//apple_ref/doc/c_ref/vImagePiecewisePolynomial_Planar8toPlanarF" title="vImagePiecewisePolynomial_Planar8toPlanarF"></a><a name="//apple_ref/doc/uid/TP40005493-CH210-DontLinkElementID_3" title="vImagePiecewisePolynomial_Planar8toPlanarF"></a><a name="//apple_ref/doc/uid/TP40005493-CH210-DontLinkElementID_25"></a><h3 class="tight">vImagePiecewisePolynomial_Planar8toPlanarF</h3> <p class="spaceabove">Applies a set of piecewise polynomials to transform an image in Planar8 format to an image in PlanarF format. </p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImagePiecewisePolynomial_Planar8toPlanarF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   const float **coefficients,
   const float *boundaries,
   uint32_t order,
   uint32_t log2segments,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>coefficients</em></dt> <dd><p>A pointer to an array of polynomial coefficient arrays. Each polynomial coefficient array contains the coefficients for one polynomial. Note that a polynomial of order R has R+1 coefficients. All the polynomial coefficient arrays must be the same size, R+1, and in each array the coefficients must be ordered from the 0th-order term to the highest-order term.</p></dd> <dt><em>boundaries</em></dt> <dd><p>A pointer to an array of boundary values, in increasing order, for separating adjacent ranges of pixel values. The first boundary value is the lowest in the range; input values lower than this are clipped to this value. The last boundary value is the highest in the range; input values higher than this are clipped to this value. The boundary values between the first and last separate the subranges from each other.</p></dd><dt><em>log2segments</em></dt><dd><p>The number of polynomials represented as a  base-2 logarithm. If you pass a non-integer power-of-two number of polynomials (for example, 5), you must round up to the next integer power of 2 (for the example of 5, that would be 8), and simply repeat the last polynomial the appropriate number of times.</p></dd> <dt><em>flags</em></dt> <dd><p>Reserved for future use; pass 0.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>You can approximate many different correction functions by carefully choosing the polynomials and the ranges of input values they operate on. The number of polynomials must be a non-negative integer power of 2.</p><p>Suppose that you want to use N polynomials of order R to process N contiguous ranges of pixel values. For each pixel in the image, the range of usable values is divided into segments by the values passed in the <em>boundaries</em> array. Each segment is processed by the corresponding polynomial. Since there are N polynomials, then there must be N segments, so you must supply N+1 boundaries.</p><p>You must order the boundaries  by increasing value. The ith segment is the set of pixel values that fall in the range:</p><div class="codesample"><table><tr><td scope="row"><pre>    boundary[i] &lt;= value &lt; boundary{i+1}<span></span></pre></td></tr></table></div><p>where i ranges from 0 to N. Values in this segment are processed by the i-th polynomial.</p><p>From a performance standpoint, it costs much more to resolve additional polynomials than to work with higher-order polynomials. You typically achieve better performance with one 9th-order polynomial that covers the whole range of values you are interested in than with many lower-order polynomials covering the range piecewise.</p><p>This function uses single-precision floating-point arithmetic. As a result, polynomials with large high-order coefficients may cause significant rounding error.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">See Also</h5><ul class="availability"><li class="availability">  <code><a href="reference.html#//apple_ref/c/func/vImagePiecewisePolynomial_PlanarF" target="_self">vImagePiecewisePolynomial_PlanarF</a></code></li></ul><h5 class="tight">Declared In</h5><code>Transform.h</code><a name="//apple_ref/c/func/vImagePiecewisePolynomial_PlanarF" title="vImagePiecewisePolynomial_PlanarF"></a><a name="//apple_ref/doc/c_ref/vImagePiecewisePolynomial_PlanarF" title="vImagePiecewisePolynomial_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005493-CH210-BBCBDFIB" title="vImagePiecewisePolynomial_PlanarF"></a> <a name="//apple_ref/doc/uid/TP40005493-CH210-DontLinkElementID_26"></a><h3 class="tight">vImagePiecewisePolynomial_PlanarF</h3> <p class="spaceabove">Applies a set of piecewise polynomials to an image in PlanarF format.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImagePiecewisePolynomial_PlanarF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   const float **coefficients,
   const float *boundaries,
   uint32_t order,
   uint32_t log2segments,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>coefficients</em></dt> <dd><p>A pointer to an array of polynomial coefficient arrays. Each polynomial coefficient array contains the coefficients for one polynomial. Note that a polynomial of order R has R+1 coefficients. All the polynomial coefficient arrays must be the same size, R+1, and in each array the coefficients must be ordered from the 0th-order term to the highest-order term.</p></dd> <dt><em>boundaries</em></dt> <dd><p>A pointer to an array of boundary values, in increasing order, for separating adjacent ranges of pixel values. The first boundary value is the lowest in the range; input values lower than this are clipped to this value. The last boundary value is the highest in the range; input values higher than this are clipped to this value. The boundary values between the first and last separate the subranges from each other.</p></dd><dt><em>log2segments</em></dt><dd><p>The number of polynomials represented as a  base-2 logarithm. If you pass a non-integer power-of-two number of polynomials (for example, 5), you must round up to the next integer power of 2 (for the example of 5, that would be 8), and simply repeat the last polynomial the appropriate number of times.</p></dd> <dt><em>flags</em></dt> <dd><p>Reserved for future use; pass 0.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>You can approximate many different correction functions by carefully choosing the polynomials and the ranges of input values they operate on. The number of polynomials must be a non-negative integer power of 2.</p> <p>Suppose that you want to use N polynomials of order R to process N contiguous ranges of pixel values. For each pixel in the image, the range of usable values is divided into segments by the values passed in the <em>boundaries</em> array. Each segment is processed by the corresponding polynomial. Since there are N polynomials, then there must be N segments, so you must supply N+1 boundaries.</p> <p>You must order the boundaries  by increasing value. The ith segment is the set of pixel values that fall in the range:</p> <div class="codesample"><table><tr><td scope="row"><pre>    boundary[i] &lt;= value &lt; boundary{i+1}<span></span></pre></td></tr></table></div> <p>where i ranges from 0 to N. Values in this segment are processed by the i-th polynomial.</p> <p>From a performance standpoint, it costs much more to resolve additional polynomials than to work with higher-order polynomials. You typically achieve better performance with one 9th-order polynomial that covers the whole range of values you are interested in than with many lower-order polynomials covering the range piecewise.</p> <p>This function uses single-precision floating-point arithmetic. As a result, polynomials with large high-order coefficients may cause significant rounding error.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Transform.h</code><a name="//apple_ref/c/func/vImagePiecewisePolynomial_PlanarFtoPlanar8" title="vImagePiecewisePolynomial_PlanarFtoPlanar8"></a><a name="//apple_ref/doc/c_ref/vImagePiecewisePolynomial_PlanarFtoPlanar8" title="vImagePiecewisePolynomial_PlanarFtoPlanar8"></a><a name="//apple_ref/doc/uid/TP40005493-CH210-DontLinkElementID_4" title="vImagePiecewisePolynomial_PlanarFtoPlanar8"></a><a name="//apple_ref/doc/uid/TP40005493-CH210-DontLinkElementID_27"></a><h3 class="tight">vImagePiecewisePolynomial_PlanarFtoPlanar8</h3> <p class="spaceabove">Applies a set of piecewise polynomials to transform an image in PlanarF format to an image in Planar8 format.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImagePiecewisePolynomial_PlanarFtoPlanar8 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   const float **coefficients,
   const float *boundaries,
   uint32_t order,
   uint32_t log2segments,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd> <dt><em>coefficients</em></dt> <dd><p>A pointer to an array of polynomial coefficient arrays. Each polynomial coefficient array contains the coefficients for one polynomial. Note that a polynomial of order R has R+1 coefficients. All the polynomial coefficient arrays must be the same size, R+1, and in each array the coefficients must be ordered from the 0th-order term to the highest-order term.</p></dd> <dt><em>boundaries</em></dt> <dd><p>A pointer to an array of boundary values, in increasing order, for separating adjacent ranges of pixel values. The first boundary value is the lowest in the range; input values lower than this are clipped to this value. The last boundary value is the highest in the range; input values higher than this are clipped to this value. The boundary values between the first and last separate the subranges from each other.</p></dd><dt><em>log2segments</em></dt><dd><p>The number of polynomials represented as a  base-2 logarithm. If you pass a non-integer power-of-two number of polynomials (for example, 5), you must round up to the next integer power of 2 (for the example of 5, that would be 8), and simply repeat the last polynomial the appropriate number of times.</p></dd> <dt><em>flags</em></dt> <dd><p>Reserved for future use; pass 0.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>You can approximate many different correction functions by carefully choosing the polynomials and the ranges of input values they operate on. The number of polynomials must be a non-negative integer power of 2.</p><p>Suppose that you want to use N polynomials of order R to process N contiguous ranges of pixel values. For each pixel in the image, the range of usable values is divided into segments by the values passed in the <em>boundaries</em> array. Each segment is processed by the corresponding polynomial. Since there are N polynomials, then there must be N segments, so you must supply N+1 boundaries.</p><p>You must order the boundaries  by increasing value. The ith segment is the set of pixel values that fall in the range:</p><div class="codesample"><table><tr><td scope="row"><pre>    boundary[i] &lt;= value &lt; boundary{i+1}<span></span></pre></td></tr></table></div><p>where i ranges from 0 to N. Values in this segment are processed by the i-th polynomial.</p><p>From a performance standpoint, it costs much more to resolve additional polynomials than to work with higher-order polynomials. You typically achieve better performance with one 9th-order polynomial that covers the whole range of values you are interested in than with many lower-order polynomials covering the range piecewise.</p><p>This function uses single-precision floating-point arithmetic. As a result, polynomials with large high-order coefficients may cause significant rounding error.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">See Also</h5><ul class="availability"><li class="availability">  <code><a href="reference.html#//apple_ref/c/func/vImagePiecewisePolynomial_PlanarF" target="_self">vImagePiecewisePolynomial_PlanarF</a></code></li></ul><h5 class="tight">Declared In</h5><code>Transform.h</code><a name="//apple_ref/c/func/vImagePiecewiseRational_PlanarF" title="vImagePiecewiseRational_PlanarF"></a><a name="//apple_ref/doc/c_ref/vImagePiecewiseRational_PlanarF" title="vImagePiecewiseRational_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005493-CH210-SW1" title="vImagePiecewiseRational_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005493-CH210-DontLinkElementID_28"></a><h3 class="tight">vImagePiecewiseRational_PlanarF</h3><p class="spaceabove">Applies a piecewise rational expression to  an image in PlanarF format. </p><p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImagePiecewiseRational_PlanarF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   const float **topCoefficients,
   const float **bottomCoefficients,
   const float *boundaries,
   uint32_t topOrder,
   uint32_t bottomOrder,
   uint32_t log2segments,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p><h5 class="tight">Parameters</h5><dl class="termdef"><dt><em>src</em></dt><dd><p>A pointer to a vImage buffer structure that contains the source image.</p></dd><dt><em>dest</em></dt><dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p></dd><dt><em>topCoefficients</em></dt><dd><p>An array of pointers to polynomial coefficient arrays  The array of pointers has length 2<sup>log2segments</sup>. Each array pointed to has length <code>topOrder</code>+1.</p><p>Each polynomial coefficient array contains the coefficients for one polynomial. Note that a polynomial of order R has R+1 coefficients. All the polynomial coefficient arrays must be the same size, R+1, and in each array the coefficients must be ordered from the 0th-order term to the highest-order term.</p></dd><dt><em>bottomCoefficients</em></dt><dd><p>An array of pointers to polynomial coefficient arrays  The array of pointers has length 2<sup>log2segments</sup>. Each array pointed to has length<code> bottomOrder</code>+1.</p><p>Each polynomial coefficient array contains the coefficients for one polynomial. Note that a polynomial of order R has R+1 coefficients. All the polynomial coefficient arrays must be the same size, R+1, and in each array the coefficients must be ordered from the 0th-order term to the highest-order term. These do not need to be the same order as the top polynomials.</p></dd><dt><em>boundaries</em></dt><dd><p>An array of floating-point values with size  (2<sup>log2segments</sup>)+1, in increasing order, for separating adjacent ranges of pixel values. The first boundary value is the lowest in the range; input values lower than this are clipped to this value. The last boundary value is the highest in the range; input values higher than this are clipped to this value. The boundary values between the first and last separate the subranges from each other. The boundaries must be the same for both the top and bottom polynomials.</p></dd><dt><em>topOrder</em></dt><dd><p>The order of the top polynomial. Make sure you pass the <em>order</em> (that is, the highest power of x), not the number of coefiicients.</p></dd><dt><em>bottomOrder</em></dt><dd><p>The order of the bottom polynomial. Make sure you pass the <em>order</em> (that is, the highest power of x), not the number of coefiicients.</p></dd><dt><em>log2segments</em></dt><dd><p>The number of rationals represented as a  base-2 logarithm. If you pass a non-integer power-of-two number of rational (for example, 5), you must round up to the next integer power of 2 (for the example of 5, that would be 8), and simply repeat the last rational the appropriate number of times.</p></dd><dt><em>flags</em></dt><dd><p>Reserved for future use; pass 0.</p></dd></dl><h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise  one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p><h5 class="tight">Discussion</h5><p>This function is similar to<code><a href="reference.html#//apple_ref/c/func/vImagePiecewisePolynomial_PlanarF">vImagePiecewisePolynomial_PlanarF</a></code> except that it evaluates a piecewise rational expression in the form of: </p><br/><div><img src = "../Art/piecewise_rational.jpg" alt = "A rational equation." ></div><br/><p>Each polynomial has its own set of coefficients and its own polynomial order. The two polynomials share the same set of segment boundaries. If the polynomials are split then all the top polynomials must be of the same order, and all the bottom polynomials must be of the same order. However, regardless of whether the polynomial is split or not, the top polynomials do not need to be the same order as the bottom polynomials.</p><p>This function does not deliver IEEE-754 correct division. The divide does not round per the IEEE-754 current rounding mode. It incurs up to 2 ULPs (Units in the Last Place) of error. Edge cases involving denormals, infinities, NaNs and division by zero return undefined results. (They will not  crash, but NaN is a likely result in such cases.) Denormals can be rescued on AltiVec enabled machines by turning off the Non-Java bit in the VSCR, at the expense of taking a many-thousand cycle kernel exception every time a denormal number is encountered. Since you can predict ahead of time whether a given set of bounded polynomials is going to encounter these conditions,  this problem should be avoidable by wise choice of polynomials. Developers who require IEEE-754  correct results should call the polynomial evaluator above twice and do the division themselves. </p><p>The approximate cost of evaluating a rational (in the same units as polynomial above) is:</p><div class="codesample"><table><tr><td scope="row"><pre>time = (base cost to touch all the data) + top polynomial order<span></span></pre></td></tr><tr><td scope="row"><pre>      + bottom polynomial order + 4 + 4 * log2segments<span></span></pre></td></tr></table></div><p> With data not in cache, the time may be significantly different. For sufficiently small polynomials, the  cost may be a fixed cost, dependent only on how much data is touched, and not on polynomial order.</p><p>This performance behavior is provided to help you evaluate speed tradeoffs. It is not a guaranteed.  It is subject to change in future operating system revisions, and may be different on different hardware within the same or different operating system revisions.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">Declared In</h5><code>Transform.h</code><a name="//apple_ref/doc/uid/TP40005493-CH211-DontLinkElementID_10" title="Constants"></a><h2>Constants</h2><a name="//apple_ref/doc/constant_group/Gamma_Function_Types" title="Gamma Function Types" role="Enum"></a><a name="//apple_ref/doc/uid/TP40005493-CH211-SW1" title="Gamma Function Types" role="Enum"></a><a name="//apple_ref/doc/uid/TP40005493-CH211-DontLinkElementID_29"></a><h3 class="tight">Gamma Function Types</h3><p class="spaceabove">Types of full- or half-precision gamma functions.</p><p class="spaceabove"><pre>
   
enum
{
   <a href="reference.html#//apple_ref/doc/c_ref/kvImageGamma_UseGammaValue">kvImageGamma_UseGammaValue</a>                  =   0,
   <a href="reference.html#//apple_ref/doc/c_ref/kvImageGamma_UseGammaValue_half_precision">kvImageGamma_UseGammaValue_half_precision</a>   =   1,
   <a href="reference.html#//apple_ref/doc/c_ref/kvImageGamma_5_over_9_half_precision">kvImageGamma_5_over_9_half_precision</a>        =   2,
   <a href="reference.html#//apple_ref/doc/c_ref/kvImageGamma_9_over_5_half_precision">kvImageGamma_9_over_5_half_precision</a>        =   3,
   <a href="reference.html#//apple_ref/doc/c_ref/kvImageGamma_5_over_11_half_precision">kvImageGamma_5_over_11_half_precision</a>       =   4,
   <a href="reference.html#//apple_ref/doc/c_ref/kvImageGamma_11_over_5_half_precision">kvImageGamma_11_over_5_half_precision</a>       =   5,
   <a href="reference.html#//apple_ref/doc/c_ref/kvImageGamma_sRGB_forward_half_precision">kvImageGamma_sRGB_forward_half_precision</a>    =   6,
   <a href="reference.html#//apple_ref/doc/c_ref/kvImageGamma_sRGB_reverse_half_precision">kvImageGamma_sRGB_reverse_half_precision</a>    =   7,
   <a href="reference.html#//apple_ref/doc/c_ref/kvImageGamma_11_over_9_half_precision">kvImageGamma_11_over_9_half_precision</a>       =   8,
   <a href="reference.html#//apple_ref/doc/c_ref/kvImageGamma_9_over_11_half_precision">kvImageGamma_9_over_11_half_precision</a>       =   9,
   <a href="reference.html#//apple_ref/doc/c_ref/kvImageGamma_BT709_forward_half_precision">kvImageGamma_BT709_forward_half_precision</a>   =  10,
   <a href="reference.html#//apple_ref/doc/c_ref/kvImageGamma_BT709_reverse_half_precision">kvImageGamma_BT709_reverse_half_precision</a>   =   11
};
</pre></p><h5 class="tight">Constants</h5><dl class="termdef"><a name="//apple_ref/c/econst/kvImageGamma_UseGammaValue" title="kvImageGamma_UseGammaValue"></a><a name="//apple_ref/doc/c_ref/kvImageGamma_UseGammaValue" title="kvImageGamma_UseGammaValue"></a><a name="//apple_ref/doc/uid/TP40005493-CH211-DontLinkElementID_30"></a><dt><code>kvImageGamma_UseGammaValue</code></dt><dd><p>Full-precision calculation using the gamma value set in <code><a href="reference.html#//apple_ref/doc/c_ref/vImageCreateGammaFunction">vImageCreateGammaFunction</a></code>.</p><p>Available in Mac OS X v10.4 and later.</p><p>Declared in <code>Transform.h</code>.</p></dd><a name="//apple_ref/c/econst/kvImageGamma_UseGammaValue_half_precision" title="kvImageGamma_UseGammaValue_half_precision"></a><a name="//apple_ref/doc/c_ref/kvImageGamma_UseGammaValue_half_precision" title="kvImageGamma_UseGammaValue_half_precision"></a><a name="//apple_ref/doc/uid/TP40005493-CH211-DontLinkElementID_31"></a><dt><code>kvImageGamma_UseGammaValue_half_precision</code></dt><dd><p> Half-precision calculation using the gamma value set in <code><a href="reference.html#//apple_ref/doc/c_ref/vImageCreateGammaFunction">vImageCreateGammaFunction</a></code>.</p><p>Available in Mac OS X v10.4 and later.</p><p>Declared in <code>Transform.h</code>.</p></dd><a name="//apple_ref/c/econst/kvImageGamma_5_over_9_half_precision" title="kvImageGamma_5_over_9_half_precision"></a><a name="//apple_ref/doc/c_ref/kvImageGamma_5_over_9_half_precision" title="kvImageGamma_5_over_9_half_precision"></a><a name="//apple_ref/doc/uid/TP40005493-CH211-DontLinkElementID_32"></a><dt><code>kvImageGamma_5_over_9_half_precision</code></dt><dd><p>Half-precision calculation using a gamma value of 5/9 or 1/1.8.</p><p>Available in Mac OS X v10.4 and later.</p><p>Declared in <code>Transform.h</code>.</p></dd><a name="//apple_ref/c/econst/kvImageGamma_9_over_5_half_precision" title="kvImageGamma_9_over_5_half_precision"></a><a name="//apple_ref/doc/c_ref/kvImageGamma_9_over_5_half_precision" title="kvImageGamma_9_over_5_half_precision"></a><a name="//apple_ref/doc/uid/TP40005493-CH211-DontLinkElementID_33"></a><dt><code>kvImageGamma_9_over_5_half_precision</code></dt><dd><p>Half-precision calculation using a gamma value of 9/5 or 1.8.</p><p>Available in Mac OS X v10.4 and later.</p><p>Declared in <code>Transform.h</code>.</p></dd><a name="//apple_ref/c/econst/kvImageGamma_5_over_11_half_precision" title="kvImageGamma_5_over_11_half_precision"></a><a name="//apple_ref/doc/c_ref/kvImageGamma_5_over_11_half_precision" title="kvImageGamma_5_over_11_half_precision"></a><a name="//apple_ref/doc/uid/TP40005493-CH211-DontLinkElementID_34"></a><dt><code>kvImageGamma_5_over_11_half_precision</code></dt><dd><p>Half-precision calculation using a gamma value of 5/11 or 1/2.2.</p><p>Available in Mac OS X v10.4 and later.</p><p>Declared in <code>Transform.h</code>.</p></dd><a name="//apple_ref/c/econst/kvImageGamma_11_over_5_half_precision" title="kvImageGamma_11_over_5_half_precision"></a><a name="//apple_ref/doc/c_ref/kvImageGamma_11_over_5_half_precision" title="kvImageGamma_11_over_5_half_precision"></a><a name="//apple_ref/doc/uid/TP40005493-CH211-DontLinkElementID_35"></a><dt><code>kvImageGamma_11_over_5_half_precision</code></dt><dd><p>Half-precision calculation using a gamma value of 11/5 or 2.2. On exit, gamma is 5/11.</p><p>Available in Mac OS X v10.4 and later.</p><p>Declared in <code>Transform.h</code>.</p></dd><a name="//apple_ref/c/econst/kvImageGamma_sRGB_forward_half_precision" title="kvImageGamma_sRGB_forward_half_precision"></a><a name="//apple_ref/doc/c_ref/kvImageGamma_sRGB_forward_half_precision" title="kvImageGamma_sRGB_forward_half_precision"></a><a name="//apple_ref/doc/uid/TP40005493-CH211-DontLinkElementID_36"></a><dt><code>kvImageGamma_sRGB_forward_half_precision</code></dt><dd><p>Half-precision calculation using the sRGB standard gamma value of 2.2.</p><p>Available in Mac OS X v10.4 and later.</p><p>Declared in <code>Transform.h</code>.</p></dd><a name="//apple_ref/c/econst/kvImageGamma_sRGB_reverse_half_precision" title="kvImageGamma_sRGB_reverse_half_precision"></a><a name="//apple_ref/doc/c_ref/kvImageGamma_sRGB_reverse_half_precision" title="kvImageGamma_sRGB_reverse_half_precision"></a><a name="//apple_ref/doc/uid/TP40005493-CH211-DontLinkElementID_37"></a><dt><code>kvImageGamma_sRGB_reverse_half_precision</code></dt><dd><p>Half-precision calculation using the sRGB standard gamma value of 1/2.2.</p><p>Available in Mac OS X v10.4 and later.</p><p>Declared in <code>Transform.h</code>.</p></dd><a name="//apple_ref/c/econst/kvImageGamma_11_over_9_half_precision" title="kvImageGamma_11_over_9_half_precision"></a><a name="//apple_ref/doc/c_ref/kvImageGamma_11_over_9_half_precision" title="kvImageGamma_11_over_9_half_precision"></a><a name="//apple_ref/doc/uid/TP40005493-CH211-DontLinkElementID_38"></a><dt><code>kvImageGamma_11_over_9_half_precision</code></dt><dd><p>Half-precision calculation using a gamma value of 11/9 or (11/5)/(9/5).</p><p>Available in Mac OS X v10.4 and later.</p><p>Declared in <code>Transform.h</code>.</p></dd><a name="//apple_ref/c/econst/kvImageGamma_9_over_11_half_precision" title="kvImageGamma_9_over_11_half_precision"></a><a name="//apple_ref/doc/c_ref/kvImageGamma_9_over_11_half_precision" title="kvImageGamma_9_over_11_half_precision"></a><a name="//apple_ref/doc/uid/TP40005493-CH211-DontLinkElementID_39"></a><dt><code>kvImageGamma_9_over_11_half_precision</code></dt><dd><p>Half-precision calculation using a gamma value of 9/11 or (9/5)/(11/5).</p><p>Available in Mac OS X v10.4 and later.</p><p>Declared in <code>Transform.h</code>.</p></dd><a name="//apple_ref/c/econst/kvImageGamma_BT709_forward_half_precision" title="kvImageGamma_BT709_forward_half_precision"></a><a name="//apple_ref/doc/c_ref/kvImageGamma_BT709_forward_half_precision" title="kvImageGamma_BT709_forward_half_precision"></a><a name="//apple_ref/doc/uid/TP40005493-CH211-DontLinkElementID_40"></a><dt><code>kvImageGamma_BT709_forward_half_precision</code></dt><dd><p>ITU-R BT.709 standard. This is like kvImageGamma_sRGB_forward_half_precision above but without the 1.125 viewing gamma for computer graphics: <code>x&lt;0.081? x/4.5: pow((x+0.099)/1.099, 1/0.45)</code>.</p><p>Available in Mac OS X v10.4 and later.</p><p>Declared in <code>Transform.h</code>.</p></dd><a name="//apple_ref/c/econst/kvImageGamma_BT709_reverse_half_precision" title="kvImageGamma_BT709_reverse_half_precision"></a><a name="//apple_ref/doc/c_ref/kvImageGamma_BT709_reverse_half_precision" title="kvImageGamma_BT709_reverse_half_precision"></a><a name="//apple_ref/doc/uid/TP40005493-CH211-DontLinkElementID_41"></a><dt><code>kvImageGamma_BT709_reverse_half_precision</code></dt><dd><p>ITU-R BT.709 standard reverse. This is like kvImageGamma_sRGB_reverse_half_precision above but without the 1.125 viewing gamma for computer graphics: <code>x&lt;0.018? 4.5*x: 1.099*pow(x,0.45) - 0.099</code>.</p><p>Available in Mac OS X v10.4 and later.</p><p>Declared in <code>Transform.h</code>.</p></dd></dl><h5 class="tight">Declared In</h5><code>Transform.h</code>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <!-- Previous button --><span style="margin-left: 8px"><a href="../revhx.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-07-12<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Performance/Reference/vImage_transform/Reference/reference.html%3Fid%3DTP40005493-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Performance/Reference/vImage_transform/Reference/reference.html%3Fid%3DTP40005493-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Performance/Reference/vImage_transform/Reference/reference.html%3Fid%3DTP40005493-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>