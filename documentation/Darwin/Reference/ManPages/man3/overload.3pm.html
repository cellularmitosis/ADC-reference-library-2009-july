<html><head><title>Mac OS X
 Manual Page For overload(3pm)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3pm/overload" title="Mac OS X
 Manual Page for overload(3pm)"><a name="//apple_ref/doc/man/3/overload" title="Mac OS X
 Manual Page for overload(3pm)"><!-- headerDoc=man; indexgroup=Section 3pm; uid="//apple_ref/doc/man/3pm/overload"; name=overload(3pm) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
overload(3pm)                         Perl Programmers Reference Guide                         overload(3pm)



<b>NAME</b>
       overload - Package for overloading Perl operations

<b>SYNOPSIS</b>
           package SomeThing;

           use overload
               '+' =&gt; \&amp;myadd,
               '-' =&gt; \&amp;mysub;
               # etc
           ...

           package main;
           $a = new SomeThing 57;
           $b=5+$a;
           ...
           if (overload::Overloaded $b) {...}
           ...
           $strval = overload::StrVal $b;

<b>DESCRIPTION</b>
       <b>Declaration</b> <b>of</b> <b>overloaded</b> <b>functions</b>

       The compilation directive

           package Number;
           use overload
               "+" =&gt; \&amp;add,
               "*=" =&gt; "muas";

       declares function <u>Number::add()</u> for addition, and method <u>muas()</u> in the "class" "Number" (or one of
       its base classes) for the assignment form "*=" of multiplication.

       Arguments of this directive come in (key, value) pairs.  Legal values are values legal inside a "&amp;{
       ... }" call, so the name of a subroutine, a reference to a subroutine, or an anonymous subroutine
       will all work.  Note that values specified as strings are interpreted as methods, not subroutines.
       Legal keys are listed below.

       The subroutine "add" will be called to execute "$a+$b" if $a is a reference to an object blessed into
       the package "Number", or if $a is not an object from a package with defined mathemagic addition, but
       $b is a reference to a "Number".  It can also be called in other situations, like "$a+=7", or "$a++".
       See "MAGIC AUTOGENERATION".  (Mathemagical methods refer to methods triggered by an overloaded mathe-<font color="#ffffff" class="whiteout">matical&nbsp;mathematical</font>
       matical operator.)

       Since overloading respects inheritance via the @ISA hierarchy, the above declaration would also trig-<font color="#ffffff" class="whiteout">ger&nbsp;trigger</font>
       ger overloading of "+" and "*=" in all the packages which inherit from "Number".

       <b>Calling</b> <b>Conventions</b> <b>for</b> <b>Binary</b> <b>Operations</b>

       The functions specified in the "use overload ..." directive are called with three (in one particular
       case with four, see "Last Resort") arguments.  If the corresponding operation is binary, then the
       first two arguments are the two arguments of the operation.  However, due to general object calling
       conventions, the first argument should always be an object in the package, so in the situation of
       "7+$a", the order of the arguments is interchanged.  It probably does not matter when implementing
       the addition method, but whether the arguments are reversed is vital to the subtraction method.  The
       method can query this information by examining the third argument, which can take three different
       values:

       FALSE  the order of arguments is as in the current operation.

       TRUE   the arguments are reversed.

       "undef"
              the current operation is an assignment variant (as in "$a+=7"), but the usual function is
              called instead.  This additional information can be used to generate some optimizations.  Com-<font color="#ffffff" class="whiteout">pare&nbsp;Compare</font>
              pare "Calling Conventions for Mutators".

       <b>Calling</b> <b>Conventions</b> <b>for</b> <b>Unary</b> <b>Operations</b>

       Unary operation are considered binary operations with the second argument being "undef".  Thus the
       functions that overloads "{"++"}" is called with arguments "($a,undef,'')" when $a++ is executed.

       <b>Calling</b> <b>Conventions</b> <b>for</b> <b>Mutators</b>

       Two types of mutators have different calling conventions:

       "++" and "--"
           The routines which implement these operators are expected to actually <u>mutate</u> their arguments.
           So, assuming that $obj is a reference to a number,

             sub incr { my $n = $ {$_[0]}; ++$n; $_[0] = bless \$n}

           is an appropriate implementation of overloaded "++".  Note that

             sub incr { ++$ {$_[0]} ; shift }

           is OK if used with preincrement and with postincrement. (In the case of postincrement a copying
           will be performed, see "Copy Constructor".)

       "x=" and other assignment versions
           There is nothing special about these methods.  They may change the value of their arguments, and
           may leave it as is.  The result is going to be assigned to the value in the left-hand-side if
           different from this value.

           This allows for the same method to be used as overloaded "+=" and "+".  Note that this is
           <u>allowed</u>, but not recommended, since by the semantic of "Fallback" Perl will call the method for
           "+" anyway, if "+=" is not overloaded.

       <b>Warning.</b>  Due to the presence of assignment versions of operations, routines which may be called in
       assignment context may create self-referential structures.  Currently Perl will not free self-refer-<font color="#ffffff" class="whiteout">ential&nbsp;self-referential</font>
       ential structures until cycles are "explicitly" broken.  You may get problems when traversing your
       structures too.

       Say,

         use overload '+' =&gt; sub { bless [ \$_[0], \$_[1] ] };

       is asking for trouble, since for code "$obj += $foo" the subroutine is called as "$obj = add($obj,
       $foo, undef)", or "$obj = [\$obj, \$foo]".  If using such a subroutine is an important optimization,
       one can overload "+=" explicitly by a non-"optimized" version, or switch to non-optimized version if
       "not defined $_[2]" (see "Calling Conventions for Binary Operations").

       Even if no <u>explicit</u> assignment-variants of operators are present in the script, they may be generated
       by the optimizer.  Say, ",$obj," or ',' . $obj . ',' may be both optimized to

         my $tmp = ',' . $obj;    $tmp .= ',';

       <b>Overloadable</b> <b>Operations</b>

       The following symbols can be specified in "use overload" directive:

       * <u>Arithmetic</u> <u>operations</u>
                "+", "+=", "-", "-=", "*", "*=", "/", "/=", "%", "%=",
                "**", "**=", "&lt;&lt;", "&lt;&lt;=", "&gt;&gt;", "&gt;&gt;=", "x", "x=", ".", ".=",

            For these operations a substituted non-assignment variant can be called if the assignment vari-<font color="#ffffff" class="whiteout">ant&nbsp;variant</font>
            ant is not available.  Methods for operations "+", "-", "+=", and "-=" can be called to automat-<font color="#ffffff" class="whiteout">ically&nbsp;automatically</font>
            ically generate increment and decrement methods.  The operation "-" can be used to autogenerate
            missing methods for unary minus or "abs".

            See "MAGIC AUTOGENERATION", "Calling Conventions for Mutators" and "Calling Conventions for
            Binary Operations") for details of these substitutions.

       * <u>Comparison</u> <u>operations</u>
                "&lt;",  "&lt;=", "&gt;",  "&gt;=", "==", "!=", "&lt;=&gt;",
                "lt", "le", "gt", "ge", "eq", "ne", "cmp",

            If the corresponding "spaceship" variant is available, it can be used to substitute for the
            missing operation.  During "sort"ing arrays, "cmp" is used to compare values subject to "use
            overload".

       * <u>Bit</u> <u>operations</u>
                "&amp;", "^", "|", "neg", "!", "~",

            "neg" stands for unary minus.  If the method for "neg" is not specified, it can be autogenerated
            using the method for subtraction. If the method for "!" is not specified, it can be autogener-<font color="#ffffff" class="whiteout">ated&nbsp;autogenerated</font>
            ated using the methods for "bool", or "", or "0+".

       * <u>Increment</u> <u>and</u> <u>decrement</u>
                "++", "--",

            If undefined, addition and subtraction methods can be used instead.  These operations are called
            both in prefix and postfix form.

       * <u>Transcendental</u> <u>functions</u>
                "atan2", "cos", "sin", "exp", "abs", "log", "sqrt", "int"

            If "abs" is unavailable, it can be autogenerated using methods for "&lt;" or "&lt;=&gt;" combined with
            either unary minus or subtraction.

            Note that traditionally the Perl function int rounds to 0, thus for floating-point-like types
            one should follow the same semantic.  If "int" is unavailable, it can be autogenerated using the
            overloading of "0+".

       * <u>Boolean,</u> <u>string</u> <u>and</u> <u>numeric</u> <u>conversion</u>
                'bool', '""', '0+',

            If one or two of these operations are not overloaded, the remaining ones can be used instead.
            "bool" is used in the flow control operators (like "while") and for the ternary "?:" operation.
            These functions can return any arbitrary Perl value.  If the corresponding operation for this
            value is overloaded too, that operation will be called again with this value.

            As a special case if the overload returns the object itself then it will be used directly. An
            overloaded conversion returning the object is probably a bug, because you're likely to get some-<font color="#ffffff" class="whiteout">thing&nbsp;something</font>
            thing that looks like "YourPackage=HASH(0x8172b34)".

       * <u>Iteration</u>
                "&lt;&gt;"

            If not overloaded, the argument will be converted to a filehandle or glob (which may require a
            stringification).  The same overloading happens both for the <u>read-filehandle</u> syntax "&lt;$var&gt;" and
            <u>globbing</u> syntax "&lt;${var}&gt;".

            <b>BUGS</b> Even in list context, the iterator is currently called only once and with scalar context.

       * <u>Dereferencing</u>
                '${}', '@{}', '%{}', '&amp;{}', '*{}'.

            If not overloaded, the argument will be dereferenced <u>as</u> <u>is</u>, thus should be of correct type.
            These functions should return a reference of correct type, or another object with overloaded
            dereferencing.

            As a special case if the overload returns the object itself then it will be used directly (pro-<font color="#ffffff" class="whiteout">vided&nbsp;(provided</font>
            vided it is the correct type).

            The dereference operators must be specified explicitly they will not be passed to "nomethod".

       * <u>Special</u>
                "nomethod", "fallback", "=",

            see "SPECIAL SYMBOLS FOR "use overload"".

       See "Fallback" for an explanation of when a missing method can be autogenerated.

       A computer-readable form of the above table is available in the hash %overload::ops, with values
       being space-separated lists of names:

        with_assign      =&gt; '+ - * / % ** &lt;&lt; &gt;&gt; x .',
        assign           =&gt; '+= -= *= /= %= **= &lt;&lt;= &gt;&gt;= x= .=',
        num_comparison   =&gt; '&lt; &lt;= &gt; &gt;= == !=',
        '3way_comparison'=&gt; '&lt;=&gt; cmp',
        str_comparison   =&gt; 'lt le gt ge eq ne',
        binary           =&gt; '&amp; | ^',
        unary            =&gt; 'neg ! ~',
        mutators         =&gt; '++ --',
        func             =&gt; 'atan2 cos sin exp abs log sqrt',
        conversion       =&gt; 'bool "" 0+',
        iterators        =&gt; '&lt;&gt;',
        dereferencing    =&gt; '${} @{} %{} &amp;{} *{}',
        special          =&gt; 'nomethod fallback ='

       <b>Inheritance</b> <b>and</b> <b>overloading</b>

       Inheritance interacts with overloading in two ways.

       Strings as values of "use overload" directive
           If "value" in

             use overload key =&gt; value;

           is a string, it is interpreted as a method name.

       Overloading of an operation is inherited by derived classes
           Any class derived from an overloaded class is also overloaded.  The set of overloaded methods is
           the union of overloaded methods of all the ancestors. If some method is overloaded in several
           ancestor, then which description will be used is decided by the usual inheritance rules:

           If "A" inherits from "B" and "C" (in this order), "B" overloads "+" with "\&amp;D::plus_sub", and "C"
           overloads "+" by "plus_meth", then the subroutine "D::plus_sub" will be called to implement oper-<font color="#ffffff" class="whiteout">ation&nbsp;operation</font>
           ation "+" for an object in package "A".

       Note that since the value of the "fallback" key is not a subroutine, its inheritance is not governed
       by the above rules.  In the current implementation, the value of "fallback" in the first overloaded
       ancestor is used, but this is accidental and subject to change.

<b>SPECIAL</b> <b>SYMBOLS</b> <b>FOR</b> <b>"use</b> <b>overload"</b>
       Three keys are recognized by Perl that are not covered by the above description.

       <b>Last</b> <b>Resort</b>

       "nomethod" should be followed by a reference to a function of four parameters.  If defined, it is
       called when the overloading mechanism cannot find a method for some operation.  The first three argu-<font color="#ffffff" class="whiteout">ments&nbsp;arguments</font>
       ments of this function coincide with the arguments for the corresponding method if it were found, the
       fourth argument is the symbol corresponding to the missing method.  If several methods are tried, the
       last one is used.  Say, "1-$a" can be equivalent to

               &amp;nomethodMethod($a,1,1,"-")

       if the pair "nomethod" =&gt; "nomethodMethod" was specified in the "use overload" directive.

       The "nomethod" mechanism is <u>not</u> used for the dereference operators ( ${} @{} %{} &amp;{} *{} ).

       If some operation cannot be resolved, and there is no function assigned to "nomethod", then an excep-<font color="#ffffff" class="whiteout">tion&nbsp;exception</font>
       tion will be raised via <u>die()</u>-- unless "fallback" was specified as a key in "use overload" directive.

       <b>Fallback</b>

       The key "fallback" governs what to do if a method for a particular operation is not found.  Three
       different cases are possible depending on the value of "fallback":

       * "undef"       Perl tries to use a substituted method (see "MAGIC AUTOGENERATION").  If this fails,
                       it then tries to calls "nomethod" value; if missing, an exception will be raised.

       * TRUE          The same as for the "undef" value, but no exception is raised.  Instead, it silently
                       reverts to what it would have done were there no "use overload" present.

       * defined, but FALSE
                       No autogeneration is tried.  Perl tries to call "nomethod" value, and if this is
                       missing, raises an exception.

       <b>Note.</b> "fallback" inheritance via @ISA is not carved in stone yet, see "Inheritance and overloading".

       <b>Copy</b> <b>Constructor</b>

       The value for "=" is a reference to a function with three arguments, i.e., it looks like the other
       values in "use overload". However, it does not overload the Perl assignment operator. This would go
       against Camel hair.

       This operation is called in the situations when a mutator is applied to a reference that shares its
       object with some other reference, such as

               $a=$b;
               ++$a;

       To make this change $a and not change $b, a copy of $$a is made, and $a is assigned a reference to
       this new object.  This operation is done during execution of the "++$a", and not during the assign-<font color="#ffffff" class="whiteout">ment,&nbsp;assignment,</font>
       ment, (so before the increment $$a coincides with $$b).  This is only done if "++" is expressed via a
       method for '++' or '+=' (or "nomethod").  Note that if this operation is expressed via '+' a nonmuta-<font color="#ffffff" class="whiteout">tor,&nbsp;nonmutator,</font>
       tor, i.e., as in

               $a=$b;
               $a=$a+1;

       then $a does not reference a new copy of $$a, since $$a does not appear as lvalue when the above code
       is executed.

       If the copy constructor is required during the execution of some mutator, but a method for '=' was
       not specified, it can be autogenerated as a string copy if the object is a plain scalar.

       <b>Example</b>
            The actually executed code for

                    $a=$b;
                    Something else which does not modify $a or $b....
                    ++$a;

            may be

                    $a=$b;
                    Something else which does not modify $a or $b....
                    $a = $a-&gt;clone(undef,"");
                    $a-&gt;incr(undef,"");

            if $b was mathemagical, and '++' was overloaded with "\&amp;incr", '=' was overloaded with
            "\&amp;clone".

       Same behaviour is triggered by "$b = $a++", which is consider a synonym for "$b = $a; ++$a".

<b>MAGIC</b> <b>AUTOGENERATION</b>
       If a method for an operation is not found, and the value for  "fallback" is TRUE or undefined, Perl
       tries to autogenerate a substitute method for the missing operation based on the defined operations.
       Autogenerated method substitutions are possible for the following operations:

       <u>Assignment</u> <u>forms</u> <u>of</u> <u>arithmetic</u> <u>operations</u>
                       "$a+=$b" can use the method for "+" if the method for "+=" is not defined.

       <u>Conversion</u> <u>operations</u>
                       String, numeric, and boolean conversion are calculated in terms of one another if not
                       all of them are defined.

       <u>Increment</u> <u>and</u> <u>decrement</u>
                       The "++$a" operation can be expressed in terms of "$a+=1" or "$a+1", and "$a--" in
                       terms of "$a-=1" and "$a-1".

       "abs($a)"       can be expressed in terms of "$a&lt;0" and "-$a" (or "0-$a").

       <u>Unary</u> <u>minus</u>     can be expressed in terms of subtraction.

       <u>Negation</u>        "!" and "not" can be expressed in terms of boolean conversion, or string or numerical
                       conversion.

       <u>Concatenation</u>   can be expressed in terms of string conversion.

       <u>Comparison</u> <u>operations</u>
                       can be expressed in terms of its "spaceship" counterpart: either "&lt;=&gt;" or "cmp":

                           &lt;, &gt;, &lt;=, &gt;=, ==, !=        in terms of &lt;=&gt;
                           lt, gt, le, ge, eq, ne      in terms of cmp

       <u>Iterator</u>
                           &lt;&gt;                          in terms of builtin operations

       <u>Dereferencing</u>
                           ${} @{} %{} &amp;{} *{}         in terms of builtin operations

       <u>Copy</u> <u>operator</u>   can be expressed in terms of an assignment to the dereferenced value, if this value
                       is a scalar and not a reference.

<b>Losing</b> <b>overloading</b>
       The restriction for the comparison operation is that even if, for example, `"cmp"' should return a
       blessed reference, the autogenerated `"lt"' function will produce only a standard logical value based
       on the numerical value of the result of `"cmp"'.  In particular, a working numeric conversion is
       needed in this case (possibly expressed in terms of other conversions).

       Similarly, ".="  and "x=" operators lose their mathemagical properties if the string conversion sub-<font color="#ffffff" class="whiteout">stitution&nbsp;substitution</font>
       stitution is applied.

       When you <u>chop()</u> a mathemagical object it is promoted to a string and its mathemagical properties are
       lost.  The same can happen with other operations as well.

<b>Run-time</b> <b>Overloading</b>
       Since all "use" directives are executed at compile-time, the only way to change overloading during
       run-time is to

           eval 'use overload "+" =&gt; \&amp;addmethod';

       You can also use

           eval 'no overload "+", "--", "&lt;="';

       though the use of these constructs during run-time is questionable.

<b>Public</b> <b>functions</b>
       Package "overload.pm" provides the following public functions:

       overload::StrVal(arg)
            Gives string value of "arg" as in absence of stringify overloading. If you are using this to get
            the address of a reference (useful for checking if two references point to the same thing) then
            you may be better off using "Scalar::Util::refaddr()", which is faster.

       overload::Overloaded(arg)
            Returns true if "arg" is subject to overloading of some operations.

       overload::Method(obj,op)
            Returns "undef" or a reference to the method that implements "op".

<b>Overloading</b> <b>constants</b>
       For some applications, the Perl parser mangles constants too much.  It is possible to hook into this
       process via "overload::constant()" and "overload::remove_constant()" functions.

       These functions take a hash as an argument.  The recognized keys of this hash are:

       integer to overload integer constants,

       float   to overload floating point constants,

       binary  to overload octal and hexadecimal constants,

       q       to overload "q"-quoted strings, constant pieces of "qq"- and "qx"-quoted strings and
               here-documents,

       qr      to overload constant pieces of regular expressions.

       The corresponding values are references to functions which take three arguments: the first one is the
       <u>initial</u> string form of the constant, the second one is how Perl interprets this constant, the third
       one is how the constant is used.  Note that the initial string form does not contain string delim-
       iters, and has backslashes in backslash-delimiter combinations stripped (thus the value of delimiter
       is not relevant for processing of this string).  The return value of this function is how this con-<font color="#ffffff" class="whiteout">stant&nbsp;constant</font>
       stant is going to be interpreted by Perl.  The third argument is undefined unless for overloaded "q"-<font color="#ffffff" class="whiteout">and&nbsp;"q"and</font>
       and "qr"- constants, it is "q" in single-quote context (comes from strings, regular expressions, and
       single-quote HERE documents), it is "tr" for arguments of "tr"/"y" operators, it is "s" for right-<font color="#ffffff" class="whiteout">hand&nbsp;righthand</font>
       hand side of "s"-operator, and it is "qq" otherwise.

       Since an expression "ab$cd,," is just a shortcut for 'ab' . $cd . ',,', it is expected that over-<font color="#ffffff" class="whiteout">loaded&nbsp;overloaded</font>
       loaded constant strings are equipped with reasonable overloaded catenation operator, otherwise absurd
       results will result.  Similarly, negative numbers are considered as negations of positive constants.

       Note that it is probably meaningless to call the functions <u>overload::constant()</u> and <u>over</u>-<font color="#ffffff" class="whiteout">load::remove_constant()&nbsp;overload::remove_constant()</font>
       <u>load::remove</u><b>_</b><u>constant()</u> from anywhere but <u>import()</u> and <u>unimport()</u> methods.  From these methods they
       may be called as

               sub import {
                 shift;
                 return unless @_;
                 die "unknown import: @_" unless @_ == 1 and $_[0] eq ':constant';
                 overload::constant integer =&gt; sub {Math::BigInt-&gt;new(shift)};
               }

       <b>BUGS</b> Currently overloaded-ness of constants does not propagate into "eval '...'".

<b>IMPLEMENTATION</b>
       What follows is subject to change RSN.

       The table of methods for all operations is cached in magic for the symbol table hash for the package.
       The cache is invalidated during processing of "use overload", "no overload", new function defini-<font color="#ffffff" class="whiteout">tions,&nbsp;definitions,</font>
       tions, and changes in @ISA. However, this invalidation remains unprocessed until the next "bless"ing
       into the package. Hence if you want to change overloading structure dynamically, you'll need an addi-<font color="#ffffff" class="whiteout">tional&nbsp;additional</font>
       tional (fake) "bless"ing to update the table.

       (Every SVish thing has a magic queue, and magic is an entry in that queue.  This is how a single
       variable may participate in multiple forms of magic simultaneously.  For instance, environment vari-<font color="#ffffff" class="whiteout">ables&nbsp;variables</font>
       ables regularly have two forms at once: their %ENV magic and their taint magic. However, the magic
       which implements overloading is applied to the stashes, which are rarely used directly, thus should
       not slow down Perl.)

       If an object belongs to a package using overload, it carries a special flag.  Thus the only speed
       penalty during arithmetic operations without overloading is the checking of this flag.

       In fact, if "use overload" is not present, there is almost no overhead for overloadable operations,
       so most programs should not suffer measurable performance penalties.  A considerable effort was made
       to minimize the overhead when overload is used in some package, but the arguments in question do not
       belong to packages using overload.  When in doubt, test your speed with "use overload" and without
       it.  So far there have been no reports of substantial speed degradation if Perl is compiled with
       optimization turned on.

       There is no size penalty for data if overload is not used. The only size penalty if overload is used
       in some package is that <u>all</u> the packages acquire a magic during the next "bless"ing into the package.
       This magic is three-words-long for packages without overloading, and carries the cache table if the
       package is overloaded.

       Copying ("$a=$b") is shallow; however, a one-level-deep copying is carried out before any operation
       that can imply an assignment to the object $a (or $b) refers to, like "$a++".  You can override this
       behavior by defining your own copy constructor (see "Copy Constructor").

       It is expected that arguments to methods that are not explicitly supposed to be changed are constant
       (but this is not enforced).

<b>Metaphor</b> <b>clash</b>
       One may wonder why the semantic of overloaded "=" is so counter intuitive.  If it <u>looks</u> counter intu-<font color="#ffffff" class="whiteout">itive&nbsp;intuitive</font>
       itive to you, you are subject to a metaphor clash.

       Here is a Perl object metaphor:

         <u>object</u> <u>is</u> <u>a</u> <u>reference</u> <u>to</u> <u>blessed</u> <u>data</u>

       and an arithmetic metaphor:

         <u>object</u> <u>is</u> <u>a</u> <u>thing</u> <u>by</u> <u>itself</u>.

       The <u>main</u> problem of overloading "=" is the fact that these metaphors imply different actions on the
       assignment "$a = $b" if $a and $b are objects.  Perl-think implies that $a becomes a reference to
       whatever $b was referencing.  Arithmetic-think implies that the value of "object" $a is changed to
       become the value of the object $b, preserving the fact that $a and $b are separate entities.

       The difference is not relevant in the absence of mutators.  After a Perl-way assignment an operation
       which mutates the data referenced by $a would change the data referenced by $b too.  Effectively,
       after "$a = $b" values of $a and $b become <u>indistinguishable</u>.

       On the other hand, anyone who has used algebraic notation knows the expressive power of the arith-<font color="#ffffff" class="whiteout">metic&nbsp;arithmetic</font>
       metic metaphor.  Overloading works hard to enable this metaphor while preserving the Perlian way as
       far as possible.  Since it is not possible to freely mix two contradicting metaphors, overloading
       allows the arithmetic way to write things <u>as</u> <u>far</u> <u>as</u> <u>all</u> <u>the</u> <u>mutators</u> <u>are</u> <u>called</u> <u>via</u> <u>overloaded</u> <u>access</u>
       <u>only</u>.  The way it is done is described in "Copy Constructor".

       If some mutator methods are directly applied to the overloaded values, one may need to <u>explicitly</u>
       <u>unlink</u> other values which references the same value:

           $a = new Data 23;
           ...
           $b = $a;            # $b is "linked" to $a
           ...
           $a = $a-&gt;clone;     # Unlink $b from $a
           $a-&gt;increment_by(4);

       Note that overloaded access makes this transparent:

           $a = new Data 23;
           $b = $a;            # $b is "linked" to $a
           $a += 4;            # would unlink $b automagically

       However, it would not make

           $a = new Data 23;
           $a = 4;             # Now $a is a plain 4, not 'Data'

       preserve "objectness" of $a.  But Perl <u>has</u> a way to make assignments to an object do whatever you
       want.  It is just not the overload, but <u>tie()</u>ing interface (see "tie" in perlfunc).  Adding a <u>FETCH()</u>
       method which returns the object itself, and <u>STORE()</u> method which changes the value of the object, one
       can reproduce the arithmetic metaphor in its completeness, at least for variables which were <u>tie()</u>d
       from the start.

       (Note that a workaround for a bug may be needed, see "BUGS".)

<b>Cookbook</b>
       Please add examples to what follows!

       <b>Two-face</b> <b>scalars</b>

       Put this in <u>two</u><b>_</b><u>face.pm</u> in your Perl library directory:

         package two_face;             # Scalars with separate string and
                                       # numeric values.
         sub new { my $p = shift; bless [@_], $p }
         use overload '""' =&gt; \&amp;str, '0+' =&gt; \&amp;num, fallback =&gt; 1;
         sub num {shift-&gt;[1]}
         sub str {shift-&gt;[0]}

       Use it as follows:

         require two_face;
         my $seven = new two_face ("vii", 7);
         printf "seven=$seven, seven=%d, eight=%d\n", $seven, $seven+1;
         print "seven contains `i'\n" if $seven =~ /i/;

       (The second line creates a scalar which has both a string value, and a numeric value.)  This prints:

         seven=vii, seven=7, eight=8
         seven contains `i'

       <b>Two-face</b> <b>references</b>

       Suppose you want to create an object which is accessible as both an array reference and a hash refer-<font color="#ffffff" class="whiteout">ence,&nbsp;reference,</font>
       ence, similar to the pseudo-hash builtin Perl type.  Let's make it better than a pseudo-hash by
       allowing index 0 to be treated as a normal element.

         package two_refs;
         use overload '%{}' =&gt; \&amp;gethash, '@{}' =&gt; sub { $ {shift()} };
         sub new {
           my $p = shift;
           bless \ [@_], $p;
         }
         sub gethash {
           my %h;
           my $self = shift;
           tie %h, ref $self, $self;
           \%h;
         }

         sub TIEHASH { my $p = shift; bless \ shift, $p }
         my %fields;
         my $i = 0;
         $fields{$_} = $i++ foreach qw{zero one two three};
         sub STORE {
           my $self = ${shift()};
           my $key = $fields{shift()};
           defined $key or die "Out of band access";
           $$self-&gt;[$key] = shift;
         }
         sub FETCH {
           my $self = ${shift()};
           my $key = $fields{shift()};
           defined $key or die "Out of band access";
           $$self-&gt;[$key];
         }

       Now one can access an object using both the array and hash syntax:

         my $bar = new two_refs 3,4,5,6;
         $bar-&gt;[2] = 11;
         $bar-&gt;{two} == 11 or die 'bad hash fetch';

       Note several important features of this example.  First of all, the <u>actual</u> type of $bar is a scalar
       reference, and we do not overload the scalar dereference.  Thus we can get the <u>actual</u> non-overloaded
       contents of $bar by just using $$bar (what we do in functions which overload dereference).  Simi-<font color="#ffffff" class="whiteout">larly,&nbsp;Similarly,</font>
       larly, the object returned by the <u>TIEHASH()</u> method is a scalar reference.

       Second, we create a new tied hash each time the hash syntax is used.  This allows us not to worry
       about a possibility of a reference loop, which would lead to a memory leak.

       Both these problems can be cured.  Say, if we want to overload hash dereference on a reference to an
       object which is <u>implemented</u> as a hash itself, the only problem one has to circumvent is how to access
       this <u>actual</u> hash (as opposed to the <u>virtual</u> hash exhibited by the overloaded dereference operator).
       Here is one possible fetching routine:

         sub access_hash {
           my ($self, $key) = (shift, shift);
           my $class = ref $self;
           bless $self, 'overload::dummy'; # Disable overloading of %{}
           my $out = $self-&gt;{$key};
           bless $self, $class;        # Restore overloading
           $out;
         }

       To remove creation of the tied hash on each access, one may an extra level of indirection which
       allows a non-circular structure of references:

         package two_refs1;
         use overload '%{}' =&gt; sub { ${shift()}-&gt;[1] },
                      '@{}' =&gt; sub { ${shift()}-&gt;[0] };
         sub new {
           my $p = shift;
           my $a = [@_];
           my %h;
           tie %h, $p, $a;
           bless \ [$a, \%h], $p;
         }
         sub gethash {
           my %h;
           my $self = shift;
           tie %h, ref $self, $self;
           \%h;
         }

         sub TIEHASH { my $p = shift; bless \ shift, $p }
         my %fields;
         my $i = 0;
         $fields{$_} = $i++ foreach qw{zero one two three};
         sub STORE {
           my $a = ${shift()};
           my $key = $fields{shift()};
           defined $key or die "Out of band access";
           $a-&gt;[$key] = shift;
         }
         sub FETCH {
           my $a = ${shift()};
           my $key = $fields{shift()};
           defined $key or die "Out of band access";
           $a-&gt;[$key];
         }

       Now if $baz is overloaded like this, then $baz is a reference to a reference to the intermediate
       array, which keeps a reference to an actual array, and the access hash.  The <u>tie()</u>ing object for the
       access hash is a reference to a reference to the actual array, so

          There are no loops of references.

          Both "objects" which are blessed into the class "two_refs1" are references to a reference to an
           array, thus references to a <u>scalar</u>.  Thus the accessor expression "$$foo-&gt;[$ind]" involves no
           overloaded operations.

       <b>Symbolic</b> <b>calculator</b>

       Put this in <u>symbolic.pm</u> in your Perl library directory:

         package symbolic;             # Primitive symbolic calculator
         use overload nomethod =&gt; \&amp;wrap;

         sub new { shift; bless ['n', @_] }
         sub wrap {
           my ($obj, $other, $inv, $meth) = @_;
           ($obj, $other) = ($other, $obj) if $inv;
           bless [$meth, $obj, $other];
         }

       This module is very unusual as overloaded modules go: it does not provide any usual overloaded opera-<font color="#ffffff" class="whiteout">tors,&nbsp;operators,</font>
       tors, instead it provides the "Last Resort" operator "nomethod".  In this example the corresponding
       subroutine returns an object which encapsulates operations done over the objects: "new symbolic 3"
       contains "['n', 3]", "2 + new symbolic 3" contains "['+', 2, ['n', 3]]".

       Here is an example of the script which "calculates" the side of circumscribed octagon using the above
       package:

         require symbolic;
         my $iter = 1;                 # 2**($iter+2) = 8
         my $side = new symbolic 1;
         my $cnt = $iter;

         while ($cnt--) {
           $side = (sqrt(1 + $side**2) - 1)/$side;
         }
         print "OK\n";

       The value of $side is

         ['/', ['-', ['sqrt', ['+', 1, ['**', ['n', 1], 2]],
                              undef], 1], ['n', 1]]

       Note that while we obtained this value using a nice little script, there is no simple way to <u>use</u> this
       value.  In fact this value may be inspected in debugger (see perldebug), but ony if "bareStringify"
       <b>O</b>ption is set, and not via "p" command.

       If one attempts to print this value, then the overloaded operator "" will be called, which will call
       "nomethod" operator.  The result of this operator will be stringified again, but this result is again
       of type "symbolic", which will lead to an infinite loop.

       Add a pretty-printer method to the module <u>symbolic.pm</u>:

         sub pretty {
           my ($meth, $a, $b) = @{+shift};
           $a = 'u' unless defined $a;
           $b = 'u' unless defined $b;
           $a = $a-&gt;pretty if ref $a;
           $b = $b-&gt;pretty if ref $b;
           "[$meth $a $b]";
         }

       Now one can finish the script by

         print "side = ", $side-&gt;pretty, "\n";

       The method "pretty" is doing object-to-string conversion, so it is natural to overload the operator
       "" using this method.  However, inside such a method it is not necessary to pretty-print the <u>compo</u>-<font color="#ffffff" class="whiteout">nents&nbsp;components</font>
       <u>nents</u> $a and $b of an object.  In the above subroutine "[$meth $a $b]" is a catenation of some
       strings and components $a and $b.  If these components use overloading, the catenation operator will
       look for an overloaded operator "."; if not present, it will look for an overloaded operator "".
       Thus it is enough to use

         use overload nomethod =&gt; \&amp;wrap, '""' =&gt; \&amp;str;
         sub str {
           my ($meth, $a, $b) = @{+shift};
           $a = 'u' unless defined $a;
           $b = 'u' unless defined $b;
           "[$meth $a $b]";
         }

       Now one can change the last line of the script to

         print "side = $side\n";

       which outputs

         side = [/ [- [sqrt [+ 1 [** [n 1 u] 2]] u] 1] [n 1 u]]

       and one can inspect the value in debugger using all the possible methods.

       Something is still amiss: consider the loop variable $cnt of the script.  It was a number, not an
       object.  We cannot make this value of type "symbolic", since then the loop will not terminate.

       Indeed, to terminate the cycle, the $cnt should become false.  However, the operator "bool" for
       checking falsity is overloaded (this time via overloaded ""), and returns a long string, thus any
       object of type "symbolic" is true.  To overcome this, we need a way to compare an object to 0.  In
       fact, it is easier to write a numeric conversion routine.

       Here is the text of <u>symbolic.pm</u> with such a routine added (and slightly modified <u>str()</u>):

         package symbolic;             # Primitive symbolic calculator
         use overload
           nomethod =&gt; \&amp;wrap, '""' =&gt; \&amp;str, '0+' =&gt; \&amp;num;

         sub new { shift; bless ['n', @_] }
         sub wrap {
           my ($obj, $other, $inv, $meth) = @_;
           ($obj, $other) = ($other, $obj) if $inv;
           bless [$meth, $obj, $other];
         }
         sub str {
           my ($meth, $a, $b) = @{+shift};
           $a = 'u' unless defined $a;
           if (defined $b) {
             "[$meth $a $b]";
           } else {
             "[$meth $a]";
           }
         }
         my %subr = ( n =&gt; sub {$_[0]},
                      sqrt =&gt; sub {sqrt $_[0]},
                      '-' =&gt; sub {shift() - shift()},
                      '+' =&gt; sub {shift() + shift()},
                      '/' =&gt; sub {shift() / shift()},
                      '*' =&gt; sub {shift() * shift()},
                      '**' =&gt; sub {shift() ** shift()},
                    );
         sub num {
           my ($meth, $a, $b) = @{+shift};
           my $subr = $subr{$meth}
             or die "Do not know how to ($meth) in symbolic";
           $a = $a-&gt;num if ref $a eq __PACKAGE__;
           $b = $b-&gt;num if ref $b eq __PACKAGE__;
           $subr-&gt;($a,$b);
         }

       All the work of numeric conversion is done in %subr and <u>num()</u>.  Of course, %subr is not complete, it
       contains only operators used in the example below.  Here is the extra-credit question: why do we need
       an explicit recursion in <u>num()</u>?  (Answer is at the end of this section.)

       Use this module like this:

         require symbolic;
         my $iter = new symbolic 2;    # 16-gon
         my $side = new symbolic 1;
         my $cnt = $iter;

         while ($cnt) {
           $cnt = $cnt - 1;            # Mutator `--' not implemented
           $side = (sqrt(1 + $side**2) - 1)/$side;
         }
         printf "%s=%f\n", $side, $side;
         printf "pi=%f\n", $side*(2**($iter+2));

       It prints (without so many line breaks)

         [/ [- [sqrt [+ 1 [** [/ [- [sqrt [+ 1 [** [n 1] 2]]] 1]
                                 [n 1]] 2]]] 1]
            [/ [- [sqrt [+ 1 [** [n 1] 2]]] 1] [n 1]]]=0.198912
         pi=3.182598

       The above module is very primitive.  It does not implement mutator methods ("++", "-=" and so on),
       does not do deep copying (not required without mutators!), and implements only those arithmetic oper-<font color="#ffffff" class="whiteout">ations&nbsp;operations</font>
       ations which are used in the example.

       To implement most arithmetic operations is easy; one should just use the tables of operations, and
       change the code which fills %subr to

         my %subr = ( 'n' =&gt; sub {$_[0]} );
         foreach my $op (split " ", $overload::ops{with_assign}) {
           $subr{$op} = $subr{"$op="} = eval "sub {shift() $op shift()}";
         }
         my @bins = qw(binary 3way_comparison num_comparison str_comparison);
         foreach my $op (split " ", "@overload::ops{ @bins }") {
           $subr{$op} = eval "sub {shift() $op shift()}";
         }
         foreach my $op (split " ", "@overload::ops{qw(unary func)}") {
           print "defining `$op'\n";
           $subr{$op} = eval "sub {$op shift()}";
         }

       Due to "Calling Conventions for Mutators", we do not need anything special to make "+=" and friends
       work, except filling "+=" entry of %subr, and defining a copy constructor (needed since Perl has no
       way to know that the implementation of '+=' does not mutate the argument, compare "Copy Construc-<font color="#ffffff" class="whiteout">tor").&nbsp;Constructor").</font>
       tor").

       To implement a copy constructor, add "'=' =&gt; \&amp;cpy" to "use overload" line, and code (this code
       assumes that mutators change things one level deep only, so recursive copying is not needed):

         sub cpy {
           my $self = shift;
           bless [@$self], ref $self;
         }

       To make "++" and "--" work, we need to implement actual mutators, either directly, or in "nomethod".
       We continue to do things inside "nomethod", thus add

           if ($meth eq '++' or $meth eq '--') {
             @$obj = ($meth, (bless [@$obj]), 1); # Avoid circular reference
             return $obj;
           }

       after the first line of <u>wrap()</u>.  This is not a most effective implementation, one may consider

         sub inc { $_[0] = bless ['++', shift, 1]; }

       instead.

       As a final remark, note that one can fill %subr by

         my %subr = ( 'n' =&gt; sub {$_[0]} );
         foreach my $op (split " ", $overload::ops{with_assign}) {
           $subr{$op} = $subr{"$op="} = eval "sub {shift() $op shift()}";
         }
         my @bins = qw(binary 3way_comparison num_comparison str_comparison);
         foreach my $op (split " ", "@overload::ops{ @bins }") {
           $subr{$op} = eval "sub {shift() $op shift()}";
         }
         foreach my $op (split " ", "@overload::ops{qw(unary func)}") {
           $subr{$op} = eval "sub {$op shift()}";
         }
         $subr{'++'} = $subr{'+'};
         $subr{'--'} = $subr{'-'};

       This finishes implementation of a primitive symbolic calculator in 50 lines of Perl code.  Since the
       numeric values of subexpressions are not cached, the calculator is very slow.

       Here is the answer for the exercise: In the case of <u>str()</u>, we need no explicit recursion since the
       overloaded "."-operator will fall back to an existing overloaded operator "".  Overloaded arithmetic
       operators <u>do</u> <u>not</u> fall back to numeric conversion if "fallback" is not explicitly requested.  Thus
       without an explicit recursion <u>num()</u> would convert "['+', $a, $b]" to "$a + $b", which would just
       rebuild the argument of <u>num()</u>.

       If you wonder why defaults for conversion are different for <u>str()</u> and <u>num()</u>, note how easy it was to
       write the symbolic calculator.  This simplicity is due to an appropriate choice of defaults.  One
       extra note: due to the explicit recursion <u>num()</u> is more fragile than <u>sym()</u>: we need to explicitly
       check for the type of $a and $b.  If components $a and $b happen to be of some related type, this may
       lead to problems.

       <u>Really</u> <b>symbolic</b> <b>calculator</b>

       One may wonder why we call the above calculator symbolic.  The reason is that the actual calculation
       of the value of expression is postponed until the value is <u>used</u>.

       To see it in action, add a method

         sub STORE {
           my $obj = shift;
           $#$obj = 1;
           @$obj-&gt;[0,1] = ('=', shift);
         }

       to the package "symbolic".  After this change one can do

         my $a = new symbolic 3;
         my $b = new symbolic 4;
         my $c = sqrt($a**2 + $b**2);

       and the numeric value of $c becomes 5.  However, after calling

         $a-&gt;STORE(12);  $b-&gt;STORE(5);

       the numeric value of $c becomes 13.  There is no doubt now that the module symbolic provides a <u>sym</u>-<font color="#ffffff" class="whiteout">bolic&nbsp;symbolic</font>
       <u>bolic</u> calculator indeed.

       To hide the rough edges under the hood, provide a <u>tie()</u>d interface to the package "symbolic" (compare
       with "Metaphor clash").  Add methods

         sub TIESCALAR { my $pack = shift; $pack-&gt;new(@_) }
         sub FETCH { shift }
         sub nop {  }          # Around a bug

       (the bug is described in "BUGS").  One can use this new interface as

         tie $a, 'symbolic', 3;
         tie $b, 'symbolic', 4;
         $a-&gt;nop;  $b-&gt;nop;    # Around a bug

         my $c = sqrt($a**2 + $b**2);

       Now numeric value of $c is 5.  After "$a = 12; $b = 5" the numeric value of $c becomes 13.  To insu-<font color="#ffffff" class="whiteout">late&nbsp;insulate</font>
       late the user of the module add a method

         sub vars { my $p = shift; tie($_, $p), $_-&gt;nop foreach @_; }

       Now

         my ($a, $b);
         symbolic-&gt;vars($a, $b);
         my $c = sqrt($a**2 + $b**2);

         $a = 3; $b = 4;
         printf "c5  %s=%f\n", $c, $c;

         $a = 12; $b = 5;
         printf "c13  %s=%f\n", $c, $c;

       shows that the numeric value of $c follows changes to the values of $a and $b.

<b>AUTHOR</b>
       Ilya Zakharevich &lt;<u>ilya@math.mps.ohio-state.edu&gt;</u>.

<b>DIAGNOSTICS</b>
       When Perl is run with the <b>-Do</b> switch or its equivalent, overloading induces diagnostic messages.

       Using the "m" command of Perl debugger (see perldebug) one can deduce which operations are overloaded
       (and which ancestor triggers this overloading). Say, if "eq" is overloaded, then the method "(eq" is
       shown by debugger. The method "()" corresponds to the "fallback" key (in fact a presence of this
       method shows that this package has overloading enabled, and it is what is used by the "Overloaded"
       function of module "overload").

       The module might issue the following warnings:

       Odd number of arguments for overload::constant
           (W) The call to overload::constant contained an odd number of arguments.  The arguments should
           come in pairs.

       `%s' is not an overloadable type
           (W) You tried to overload a constant type the overload package is unaware of.

       `%s' is not a code reference
           (W) The second (fourth, sixth, ...) argument of overload::constant needs to be a code reference.
           Either an anonymous subroutine, or a reference to a subroutine.

<b>BUGS</b>
       Because it is used for overloading, the per-package hash %OVERLOAD now has a special meaning in Perl.
       The symbol table is filled with names looking like line-noise.

       For the purpose of inheritance every overloaded package behaves as if "fallback" is present (possibly
       undefined). This may create interesting effects if some package is not overloaded, but inherits from
       two overloaded packages.

       Relation between overloading and <u>tie()</u>ing is broken.  Overloading is triggered or not basing on the
       <u>previous</u> class of <u>tie()</u>d value.

       This happens because the presence of overloading is checked too early, before any <u>tie()</u>d access is
       attempted.  If the <u>FETCH()</u>ed class of the <u>tie()</u>d value does not change, a simple workaround is to
       access the value immediately after <u>tie()</u>ing, so that after this call the <u>previous</u> class coincides
       with the current one.

       <b>Needed:</b> a way to fix this without a speed penalty.

       Barewords are not covered by overloaded string constants.

       This document is confusing.  There are grammos and misleading language used in places.  It would seem
       a total rewrite is needed.



perl v5.8.8                                      2001-09-21                                    overload(3pm)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/overload.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/overload.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/overload.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
