<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Magnify - /Magnify.cp</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxCarbon-date.html">Carbon</a> &gt; <A HREF="javascript:location.replace('index.html');">Magnify</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxHumanInterfaceToolbox-date.html" target="_blank">Carbon > Human Interface Toolbox</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Magnify</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Magnify.cp</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Magnify.cp</option></select>
				</p>
				</form>
				<p><strong><a href="Magnify.zip">Download Sample</a></strong> (&#147;Magnify.zip&#148;, 434.2K)<BR>
<strong><a href="Magnify.dmg">Download Sample</a></strong> (&#147;Magnify.dmg&#148;, 562.3K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*
  File:    Magnify.cp

  Contains:  Sample application which implements a magnifying lens tool.

  Version:  Mac OS X

  Disclaimer:  IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc.
        (&quot;Apple&quot;) in consideration of your agreement to the following terms, and your
        use, installation, modification or redistribution of this Apple software
        constitutes acceptance of these terms.  If you do not agree with these terms,
        please do not use, install, modify or redistribute this Apple software.

        In consideration of your agreement to abide by the following terms, and subject
        to these terms, Apple grants you a personal, non-exclusive license, under Apple's
        copyrights in this original Apple software (the &quot;Apple Software&quot;), to use,
        reproduce, modify and redistribute the Apple Software, with or without
        modifications, in source and/or binary forms; provided that if you redistribute
        the Apple Software in its entirety and without modifications, you must retain
        this notice and the following text and disclaimers in all such redistributions of
        the Apple Software.  Neither the name, trademarks, service marks or logos of
        Apple Computer, Inc. may be used to endorse or promote products derived from the
        Apple Software without specific prior written permission from Apple.  Except as
        expressly stated in this notice, no other rights or licenses, express or implied,
        are granted by Apple herein, including but not limited to any patent rights that
        may be infringed by your derivative works or by other works in which the Apple
        Software may be incorporated.

        The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE MAKES NO
        WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED
        WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR
        PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN
        COMBINATION WITH YOUR PRODUCTS.

        IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR
        CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
        GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
        ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION
        OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT
        (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN
        ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  Copyright &copy; 1998-2001 Apple Computer, Inc., All Rights Reserved
*/

#ifdef __APPLE_CC__
#include &lt;Carbon/Carbon.h&gt;
#else
#include &lt;Carbon.h&gt;
#endif

enum
{
  kCmdMagnificationChanged  = 'MChg',
  kCmdShowMouseLocation    = 'MLoc',
  kCmdFloat          = 'Floa'
};

struct PrefInfo
{
  UInt8      origMagFactor;
  Boolean      origShowInfo;
  Boolean      origFloats;
  WindowRef    window;
};
typedef struct PrefInfo PrefInfo;

static pascal OSStatus      WindowHandler( EventHandlerCallRef inHandler, EventRef inEvent, void* userData );
static pascal OSStatus      AppCommandHandler( EventHandlerCallRef inHandler, EventRef inEvent, void* userData );
static pascal OSStatus      PrefHandler( EventHandlerCallRef inHandler, EventRef inEvent, void* userData );

pascal void        MagnifyEventLoopTimer(EventLoopTimerRef /*inTimer*/, void *inUserData);
static pascal OSErr    QuitAppleEventHandler(const AppleEvent *appleEvt, AppleEvent* reply, long refcon);

static void        DoPreferences();
static void        AdjustWindowFloating();

static GrafPtr      sGlobalPort = NULL;
static UInt8      sMagFactor = 8;
static Boolean      sShowInfo = true;
static Boolean      sFloats = false;
static Boolean      sForceUpdate = false;
static WindowRef    sMagnifyWindow;

static const ControlID  kMagSlider     = { 'PREF', 1 };
static const ControlID  kShowInfoCheck   = { 'PREF', 2 };
static const ControlID  kFloatCheck   = { 'PREF', 3 };

#define kPreferencesKey  CFSTR( &quot;com.apple.carbon.examples.magnify&quot; )

//----------------------------------------------------------------------------
//  * MagnifyEventLoopTimer
//
//  Our magnification timer. Ideally we should be event based, but we can't
//  detect every event that might cause a screen update (window move, etc.)
//  so we resort to this.
//----------------------------------------------------------------------------

pascal void
MagnifyEventLoopTimer(EventLoopTimerRef /*inTimer*/, void *inUserData)
{
  WindowRef  window = (WindowRef)inUserData;
  Point    mouse;
  GrafPtr    windowPort;
  GrafPtr    savePort;
  Rect    sourceRect;
  Rect    destRect;
  Rect    portBounds;
  SInt16    distance;
    static Point  sLastMouse = { -1, -1};
    
  GetPort( &amp;savePort );
  windowPort = GetWindowPort(window);

  GetPortBounds( windowPort, &amp;portBounds );

  GetGlobalMouse( &amp;mouse );

    if ( !EqualPt( mouse, sLastMouse ) || sForceUpdate )
    {
        Rect  monitorBounds;
    SInt32  temp;
        
        sLastMouse = mouse;
        SetPort(windowPort);

        distance = SInt16((portBounds.right - portBounds.left) / (sMagFactor * 2));

        // Pin the mouse position to the main monitor
        monitorBounds = (**GetMainDevice()).gdRect;

        InsetRect( &amp;monitorBounds, distance, distance );

        temp = PinRect( &amp;monitorBounds, mouse );
        mouse = *(Point*)&amp;temp;
        
        sourceRect.left = mouse.h - distance;
        sourceRect.right = mouse.h + distance;
        sourceRect.top = mouse.v - distance;
        sourceRect.bottom = mouse.v + distance;

        destRect = portBounds;

        ForeColor(blackColor);
        BackColor(whiteColor);
    PenMode( srcCopy );

        CopyBits( *(BitMap **)GetPortPixMap(sGlobalPort), *(BitMap **)GetPortPixMap(windowPort), &amp;sourceRect, &amp;destRect, srcCopy, NULL );

    if ( sShowInfo )
    {
      CFStringRef    string;
      
      string = CFStringCreateWithFormat( NULL, NULL, CFSTR( &quot;(%d,%d), %dx&quot; ), sLastMouse.h, sLastMouse.v, sMagFactor );

      if ( string )
      {
        Rect      box;
        Point      size;
        SInt16      baseLine;
        const RGBColor  kWhite = { 0xFFFF, 0xFFFF, 0xFFFF };
        const RGBColor  kBlack = { 0, 0, 0 };

        TextFont( 0 );
        TextSize( 12 );
                
        GetThemeTextDimensions( string, kThemeCurrentPortFont, kThemeStateActive,
            false, &amp;size, &amp;baseLine );
        
        box.left = portBounds.left;
        box.bottom = portBounds.bottom;
        box.right = box.left + size.h;
        box.top = box.bottom - size.v;
        
        RGBForeColor( &amp;kBlack );
        PaintRect( &amp;box );
        
        RGBForeColor( &amp;kWhite );
        DrawThemeTextBox( string, kThemeCurrentPortFont, kThemeStateActive,
            false, &amp;box, teCenter, NULL );
        
        CFRelease( string );
      }
    }

      
    ForeColor( blackColor );
    BackColor( whiteColor );
    PenMode( patXor );

    MoveTo( ( portBounds.right / 2 ) - 4, portBounds.bottom / 2 );
    Line( 8, 0 );
    MoveTo( portBounds.right / 2, ( portBounds.bottom / 2 ) - 4 );
    Line( 0, 8 );
    
        SetPort( savePort );
    }
    
    sForceUpdate = false;
}

//----------------------------------------------------------------------------
//  * CreateMagnifyWindow
//
//  Create our magnification window.
//----------------------------------------------------------------------------

static OSStatus
CreateMagnifyWindow( IBNibRef nibRef )
{
  WindowRef      window;
  EventLoopTimerUPP  eventLoopTimer;
  EventHandlerRef    eventHandlerRef;
  EventHandlerUPP    handlerProc;
  EventTypeSpec    events[] = { { kEventClassWindow, kEventWindowBoundsChanging } };
  OSStatus      err;

  err = CreateWindowFromNib( nibRef, CFSTR( &quot;MainWindow&quot; ), &amp;window );
  require_noerr( err, CantCreateWindow );

  // Now install our own handler so we can intercept window size changes
  // For this handler, plus our timer below, we create a UPP, but we never
  // dispose of it. This is because our window stays around until we quit.
  // If we had a window that came and went, we would need to clean up
  // properly and Dispose the EventHandlerUPP and the EventLoopTimerUPP for
  // the window.

  handlerProc = NewEventHandlerUPP( WindowHandler );
  verify_noerr( InstallWindowEventHandler( window, handlerProc, GetEventTypeCount( events ),
        events, window, &amp;eventHandlerRef ) );

  // Install our timer, which we use to update the window.
  
    eventLoopTimer = NewEventLoopTimerUPP(MagnifyEventLoopTimer);
  
  verify_noerr( InstallEventLoopTimer( GetCurrentEventLoop(), kEventDurationSecond,
        kEventDurationSecond / 20, eventLoopTimer, (void *)window, NULL ) );
  
  // Make this window such that it does not hide when we are suspended.
  // Normally, floating windows have the hide-on-suspend attribute set
  // so that they hide when switching out and show when resumed later.
  
  ChangeWindowAttributes( window, 0, kWindowHideOnSuspendAttribute );

  sMagnifyWindow = window;
  
  // Adjust our float-ness as per our current settings
  
  AdjustWindowFloating();
  
  // And it's always nice to see the windows we create.
  
  ShowWindow(window);
  
CantCreateWindow:
  return err;
}

//----------------------------------------------------------------------------
//  * WindowHandler
//
//  Constrain our resizing to a perfect square.
//----------------------------------------------------------------------------

static pascal OSStatus
WindowHandler( EventHandlerCallRef inHandler, EventRef inEvent, void* userData )
{
  Rect    bounds;
  SInt16    height, width;
  UInt32    attributes;
  OSStatus  result = eventNotHandledErr;
  
  GetEventParameter( inEvent, kEventParamAttributes, typeUInt32, NULL, sizeof( UInt32 ), NULL, &amp;attributes );
  
  // We only constrain on size changes. There is no point constraining if
  // the position (origin) is changing.
  
  if ( (attributes &amp; kWindowBoundsChangeSizeChanged) != 0 )
  {
    // Extract the current bounds. This is the paramter you get to modify to 
    // alter the window position or size during a window resizing.
    GetEventParameter( inEvent, kEventParamCurrentBounds, typeQDRectangle, NULL, sizeof( bounds ), NULL, &amp;bounds );
  
    // Make the bounds square
    height = bounds.bottom - bounds.top;
    width = bounds.right - bounds.left;
  
    if ( width &gt; height )
    {
      bounds.bottom = bounds.top + width;
    }
    else
    {
      bounds.right = bounds.left + height;
    }
  
    // Set the current bounds parameter to our adjusted bounds. Return
    // noErr to indicate we handled this event.
    SetEventParameter( inEvent, kEventParamCurrentBounds, typeQDRectangle, sizeof( bounds ), &amp;bounds );
    result = noErr;
  }
  return result;
}

static pascal OSErr QuitAppleEventHandler(const AppleEvent *appleEvt, AppleEvent* reply, long refcon)
{
#pragma unused (appleEvt, reply, refcon)
  QuitApplicationEventLoop();
  return(noErr);
}

//----------------------------------------------------------------------------
//  * main
//
//  Where it all begins...
//----------------------------------------------------------------------------

int main( int argc, char* argv[] )
{
  long         response;
  IBNibRef      nibRef;
  Boolean        test;
  OSStatus      err      = noErr;
  EventTypeSpec    cmdEvent  = { kEventClassCommand, kEventCommandProcess };
  
  // Make sure the arrow cursor is displayed

  InitCursor();

    err = AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, NewAEEventHandlerUPP(QuitAppleEventHandler), 0, false);
  if (err != noErr)
    ExitToShell();

  // Open our nib and set up the menu bar from it

  err = CreateNibReference( CFSTR( &quot;Magnify&quot; ), &amp;nibRef );
  require_noerr( err, CantOpenNib );

  err = Gestalt(gestaltMenuMgrAttr, &amp;response);
  if ((err == noErr) &amp;&amp; (response &amp; gestaltMenuMgrAquaLayoutMask))
    err = SetMenuBarFromNib( nibRef, CFSTR( &quot;MainMenuX&quot; ) );
  else
    err = SetMenuBarFromNib( nibRef, CFSTR( &quot;MainMenu9&quot; ) );
  require_noerr( err, CantSetMenuBar );

  
  // We have a preference dialog, so we need to activate
  // the Preferences menu item in our Application menu.
  // The way to do that is by command ID. Normally, this
  // menu item is disabled.

  EnableMenuCommand( NULL, kHICommandPreferences );
  
  // Create a global port so we can copy bits from the screen

  sGlobalPort = CreateNewPort();
  require_noerr( QDError(), NewPortFailed );

  // Let's see the menu bar, please.
  
  DrawMenuBar();

  // Load any prefs. We use CFPreferences to store our preferences.
  // When doing this, you need to create a key for your application.
  // Normally this is the bundle ID of your app.

  sShowInfo = CFPreferencesGetAppBooleanValue( CFSTR( &quot;ShowInfo&quot; ), kPreferencesKey, &amp;test );
  if ( !test ) sShowInfo = true;

  sMagFactor = CFPreferencesGetAppIntegerValue( CFSTR( &quot;MagFactor&quot; ), kPreferencesKey, &amp;test );
  if ( !test ) sMagFactor = 8;
  
  sFloats = CFPreferencesGetAppBooleanValue( CFSTR( &quot;Float&quot; ), kPreferencesKey, &amp;test );
  if ( !test ) sFloats = false;
  
  // Now create our window and dispose the nib ref - we're done with it.
  
  CreateMagnifyWindow( nibRef );
  DisposeNibReference( nibRef );

  // Because we want to respond to the preferences menu item, we need to
  // install a command handler to handle the menu selection. Here we are
  // creating the UPP on the fly and not disposing it, since it will get
  // destroyed when the app terminates.

  InstallApplicationEventHandler( NewEventHandlerUPP( AppCommandHandler ), 1, &amp;cmdEvent, 0, NULL );

  // Run Lola, Run!

  RunApplicationEventLoop();

  // Clean up and exit.

  DisposePort( sGlobalPort );

  return noErr;
  
NewPortFailed:
CantSetMenuBar:
  DisposeNibReference( nibRef );

CantOpenNib:
  return err;
}

//----------------------------------------------------------------------------
//  * AppCommandHandler
//
//  Look for the preferences menu item and call DoPreferences when we
//  receive it.
//----------------------------------------------------------------------------

static pascal OSStatus
AppCommandHandler( EventHandlerCallRef inHandler, EventRef inEvent, void* inUserData )
{
  #pragma unused( inHandler, inUserData )
  
  HICommand      cmd;
  OSStatus      result = eventNotHandledErr;
  
  GetEventParameter( inEvent, kEventParamDirectObject, typeHICommand, NULL, sizeof( cmd ), NULL, &amp;cmd );
  if ( cmd.commandID == kHICommandPreferences )
  {
    DoPreferences();
    result = noErr;
  }
  
  return result;
}

//----------------------------------------------------------------------------
//  * DoPreferences
//
//  Open our preferences dialog and run it modally.
//----------------------------------------------------------------------------

static void
DoPreferences()
{
  IBNibRef      nibRef;
  EventTypeSpec    cmdEvent = { kEventClassCommand, kEventCommandProcess };
  WindowRef      window;
  OSStatus      err;
  ControlRef      control;
  PrefInfo      info;
  EventHandlerUPP    handler;
  
  // Open our nib, create the window, and close the nib.
  err = CreateNibReference( CFSTR( &quot;Magnify&quot; ), &amp;nibRef );
  require_noerr( err, CantOpenNib );
  
  err = CreateWindowFromNib( nibRef, CFSTR( &quot;Preferences&quot; ), &amp;window );
  require_noerr( err, CantCreateWindow );

  DisposeNibReference( nibRef );

  // For each control of interest, set its value as appropriate
  // for the settings we currently have.

  GetControlByID( window, &amp;kMagSlider, &amp;control );
  SetControlValue( control, (sMagFactor &gt;&gt; 2) + 1 );

  GetControlByID( window, &amp;kShowInfoCheck, &amp;control );
  SetControlValue( control, sShowInfo );
  
  GetControlByID( window, &amp;kFloatCheck, &amp;control );
  SetControlValue( control, sFloats );
  
  // Build up a structure to pass to the window handler we are about
  // to install. We store the window itself, as well as the original
  // states of our settings. We use this to revert if the user clicks
  // the cancel button.

  info.window     = window;
  info.origMagFactor   = sMagFactor;
  info.origShowInfo   = sShowInfo;
  info.origFloats   = sFloats;

  // Now create our UPP and install the handler.
  
  handler = NewEventHandlerUPP( PrefHandler );
  InstallWindowEventHandler( window, handler, 1, &amp;cmdEvent, &amp;info, NULL );
  
  // Position and show the window
  
  RepositionWindow( window, NULL, kWindowAlertPositionOnMainScreen );
  ShowWindow( window );
  
  // Now we run modally. We will remain here until the PrefHandler
  // calls QuitAppModalLoopForWindow if the user clicks OK or
  // Cancel.

  RunAppModalLoopForWindow( window );

  // OK, we're done. Dispose of our window and our UPP.
  // We do the UPP last because DisposeWindow can send out
  // CarbonEvents, and we haven't explicitly removed our
  // handler. If we disposed the UPP, the Toolbox might try
  // to call it. That would be bad.

  DisposeWindow( window );
  DisposeEventHandlerUPP( handler );

  return;

CantCreateWindow:
  DisposeNibReference( nibRef );
  
CantOpenNib:
  return;
}

//----------------------------------------------------------------------------
//  * PrefHandler
//
//  Our command handler for the Preferences dialog.
//----------------------------------------------------------------------------

static pascal OSStatus
PrefHandler( EventHandlerCallRef inHandler, EventRef inEvent, void* inUserData )
{
  #pragma unused( inHandler )
  
  HICommand      cmd;
  OSStatus      result = eventNotHandledErr;
  PrefInfo*      info = (PrefInfo*)inUserData;
  ControlRef      control;
  CFNumberRef     number;
  WindowRef      window = info-&gt;window;

  // The direct object for a 'process commmand' event is the HICommand.
  // Extract it here and switch off the command ID.

  GetEventParameter( inEvent, kEventParamDirectObject, typeHICommand, NULL, sizeof( cmd ), NULL, &amp;cmd );

  switch ( cmd.commandID )
  {
    case kHICommandOK:
      number = CFNumberCreate( NULL, kCFNumberSInt8Type, &amp;sMagFactor );
      CFPreferencesSetAppValue( CFSTR( &quot;MagFactor&quot; ), number, kPreferencesKey );
      CFPreferencesSetAppValue( CFSTR( &quot;ShowInfo&quot; ), sShowInfo ? kCFBooleanTrue : kCFBooleanFalse, kPreferencesKey );
      CFPreferencesSetAppValue( CFSTR( &quot;Float&quot; ), sFloats ? kCFBooleanTrue : kCFBooleanFalse, kPreferencesKey );
      CFPreferencesAppSynchronize( kPreferencesKey );
      CFRelease( number );

      QuitAppModalLoopForWindow( window );
      result = noErr;
      break;
    
    case kHICommandCancel:
      sMagFactor = info-&gt;origMagFactor;
      sShowInfo = info-&gt;origShowInfo;
      sFloats = info-&gt;origFloats;
      AdjustWindowFloating();
      sForceUpdate = true;
      QuitAppModalLoopForWindow( window );
      result = noErr;
      break;
    
    case kCmdMagnificationChanged:
      GetControlByID( window, &amp;kMagSlider, &amp;control );
      sMagFactor = 2 &lt;&lt; (GetControlValue( control ) - 1);
      sForceUpdate = true;
      result = noErr;
      break;
    
    case kCmdShowMouseLocation:
      GetControlByID( window, &amp;kShowInfoCheck, &amp;control );
      sShowInfo = GetControlValue( control );
      sForceUpdate = true;
      result = noErr;
      break;

    case kCmdFloat:
      GetControlByID( window, &amp;kFloatCheck, &amp;control );
      sFloats = GetControlValue( control );
      AdjustWindowFloating();
      result = noErr;
      break;
  }  
  return result;
}

//----------------------------------------------------------------------------
//  * AdjustWindowFloating
//
//  Adjust our window's floating state based on the current setting. We can
//  either float in our application's layer, or above all applications. We
//  accomplish this magic by moving the window between the appropriate window
//  groups.
//----------------------------------------------------------------------------

static void
AdjustWindowFloating()
{
  check( sMagnifyWindow != NULL );
  
  if ( sFloats )
    SetWindowGroup( sMagnifyWindow, GetWindowGroupOfClass( kUtilityWindowClass ) );
  else
    SetWindowGroup( sMagnifyWindow, GetWindowGroupOfClass( kFloatingWindowClass ) );
}
</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Magnify/listing1.html%3Fid%3DDTS10000088-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Magnify/listing1.html%3Fid%3DDTS10000088-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Magnify/listing1.html%3Fid%3DDTS10000088-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>