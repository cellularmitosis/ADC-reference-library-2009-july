<html><head><title>Mac OS X
 Manual Page For http(ntcl)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/ntcl/http" title="Mac OS X
 Manual Page for http(ntcl)"><a name="//apple_ref/doc/man/n/http" title="Mac OS X
 Manual Page for http(ntcl)"><!-- headerDoc=man; indexgroup=Section ntcl; uid="//apple_ref/doc/man/ntcl/http"; name=http(ntcl) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
http(n)                                     Tcl Bundled Packages                                     http(n)



____________________________________________________________________________________________________________

<b>NAME</b>
       http - Client-side implementation of the HTTP/1.0 protocol.

<b>SYNOPSIS</b>
       <b>package</b> <b>require</b> <b>http</b> <b>?2.5?</b>

       <b>::http::config</b> <u>?options?</u>

       <b>::http::geturl</b> <u>url</u> <u>?options?</u>

       <b>::http::formatQuery</b> <u>key</u> <u>value</u> ?<u>key</u> <u>value</u> ...?

       <b>::http::reset</b> <u>token</u> ?<u>why</u>?

       <b>::http::wait</b> <u>token</u>

       <b>::http::status</b> <u>token</u>

       <b>::http::size</b> <u>token</u>

       <b>::http::code</b> <u>token</u>

       <b>::http::ncode</b> <u>token</u>

       <b>::http::data</b> <u>token</u>

       <b>::http::error</b> <u>token</u>

       <b>::http::cleanup</b> <u>token</u>

       <b>::http::register</b> <u>proto</u> <u>port</u> <u>command</u>

       <b>::http::unregister</b> <u>proto</u>
____________________________________________________________________________________________________________


<b>DESCRIPTION</b>
       The  <b>http</b> package provides the client side of the HTTP/1.0 protocol.  The package implements the GET,
       POST, and HEAD operations of HTTP/1.0.  It allows configuration of a proxy host to get through  fire-<font color="#ffffff" class="whiteout">walls.&nbsp;firewalls.</font>
       walls.   The  package is compatible with the <b>Safesock</b> security policy, so it can be used by untrusted
       applets to do URL fetching from a restricted set of hosts. This package can be  extended  to  support
       additional  HTTP  transport  protocols,  such  as  HTTPS,  by  providing a custom <b>socket</b> command, via
       <b>http::register</b>.

       The <b>::http::geturl</b> procedure does a HTTP transaction.  Its <u>options</u>  determine whether a GET, POST, or
       HEAD  transaction  is  performed.  The return value of <b>::http::geturl</b> is a token for the transaction.
       The value is also the name of an array in the ::http namespace that contains state information  about
       the transaction.  The elements of this array are described in the STATE ARRAY section.

       If  the  <b>-command</b>  option  is  specified,  then  the  HTTP  operation  is  done  in  the  background.
       <b>::http::geturl</b> returns immediately after generating the HTTP request and the callback is invoked when
       the  transaction completes.  For this to work, the Tcl event loop must be active.  In Tk applications
       this is always true.  For pure-Tcl applications,  the  caller  can  use  <b>::http::wait</b>  after  calling
       <b>::http::geturl</b> to start the event loop.

<b>COMMANDS</b>
       <b>::http::config</b> ?<u>options</u>?
              The <b>::http::config</b> command is used to set and query the name of the proxy server and port, and
              the User-Agent name used in the HTTP requests.  If no options are specified, then the  current
              configuration  is  returned.   If a single argument is specified, then it should be one of the
              flags described below.  In this case the current value of that setting  is  returned.   Other-<font color="#ffffff" class="whiteout">wise,&nbsp;Otherwise,</font>
              wise, the options should be a set of flags and values that define the configuration:

              <b>-accept</b> <u>mimetypes</u>
                     The  Accept  header  of the request.  The default is */*, which means that all types of
                     documents are accepted.  Otherwise you can supply a comma separated list of  mime  type
                     patterns  that  you  are  willing  to  receive.   For  example, "image/gif, image/jpeg,
                     text/*".

              <b>-proxyhost</b> <u>hostname</u>
                     The name of the proxy host, if any.  If this value is the empty string, the URL host is
                     contacted directly.

              <b>-proxyport</b> <u>number</u>
                     The proxy port number.

              <b>-proxyfilter</b> <u>command</u>
                     The command is a callback that is made during <b>::http::geturl</b> to determine if a proxy is
                     required for a given host.  One argument, a host name, is added to <u>command</u> when  it  is
                     invoked.   If  a  proxy is required, the callback should return a two element list con-<font color="#ffffff" class="whiteout">taining&nbsp;containing</font>
                     taining the proxy server and proxy port.  Otherwise the filter should return  an  empty
                     list.   The default filter returns the values of the <b>-proxyhost</b> and <b>-proxyport</b> settings
                     if they are non-empty.

              <b>-urlencoding</b> <u>encoding</u>
                     The <u>encoding</u> used for creating the x-url-encoded URLs  with  <b>::http::formatQuery</b>.   The
                     default  is  <b>utf-8</b>,  as specified by RFC 2718.  Prior to http 2.5 this was unspecified,
                     and that behavior can be  returned  by  specifying  the  empty  string  (<b>{}</b>),  although
                     <u>iso8859-1</u>  is  recommended  to restore similar behavior but without the <b>::http::format</b>-<font color="#ffffff" class="whiteout">Query&nbsp;::http::formatQuery</font>
                     <b>Query</b> throwing an error processing non-latin-1 characters.

              <b>-useragent</b> <u>string</u>
                     The value of the User-Agent header in the HTTP  request.   The  default  is  <b>"Tcl</b>  <b>http</b>
                     <b>client</b> <b>package</b> <b>2.4."</b>

       <b>::http::geturl</b> <u>url</u> ?<u>options</u>?
              The  <b>::http::geturl</b>  command is the main procedure in the package.  The <b>-query</b> option causes a
              POST operation and the <b>-validate</b> option causes a HEAD operation; otherwise, a GET operation is
              performed.   The <b>::http::geturl</b> command returns a <u>token</u> value that can be used to get informa-<font color="#ffffff" class="whiteout">tion&nbsp;information</font>
              tion about the transaction.  See  the  STATE  ARRAY  and  ERRORS  section  for  details.   The
              <b>::http::geturl</b> command blocks until the operation completes, unless the <b>-command</b> option speci-<font color="#ffffff" class="whiteout">fies&nbsp;specifies</font>
              fies a callback that is invoked when the HTTP  transaction  completes.   <b>::http::geturl</b>  takes
              several options:

              <b>-binary</b> <u>boolean</u>
                     Specifies whether to force interpreting the url data as binary.  Normally this is auto-<font color="#ffffff" class="whiteout">detected&nbsp;autodetected</font>
                     detected (anything not beginning with a <b>text</b> content type or whose content encoding  is
                     <b>gzip</b> or <b>compress</b> is considered binary data).

              <b>-blocksize</b> <u>size</u>
                     The  blocksize  used when reading the URL.  At most <u>size</u> bytes are read at once.  After
                     each block, a call to the <b>-progress</b> callback is made (if that option is specified).

              <b>-channel</b> <u>name</u>
                     Copy the URL contents to channel <u>name</u> instead of saving it in <b>state(body)</b>.

              <b>-command</b> <u>callback</u>
                     Invoke  <u>callback</u>  after  the  HTTP   transaction   completes.    This   option   causes
                     <b>::http::geturl</b> to return immediately.  The <u>callback</u> gets an additional argument that is
                     the <u>token</u> returned from <b>::http::geturl</b>. This token is the name  of  an  array  that  is
                     described in the STATE ARRAY section.  Here is a template for the callback:
                            proc httpCallback {token} {
                                upvar #0 $token state
                                # Access state as a Tcl array
                            }

              <b>-handler</b> <u>callback</u>
                     Invoke  <u>callback</u> whenever HTTP data is available; if present, nothing else will be done
                     with the HTTP data.  This procedure gets two additional arguments: the socket  for  the
                     HTTP  data  and  the  <u>token</u>  returned  from <b>::http::geturl</b>.  The token is the name of a
                     global array that is described in the STATE ARRAY section.  The procedure  is  expected
                     to  return  the number of bytes read from the socket.  Here is a template for the call-<font color="#ffffff" class="whiteout">back:&nbsp;callback:</font>
                     back:
                            proc httpHandlerCallback {socket token} {
                                upvar #0 $token state
                                # Access socket, and state as a Tcl array
                                ...
                                (example: set data [read $socket 1000];set nbytes [string length $data])
                                ...
                                return nbytes
                            }

              <b>-headers</b> <u>keyvaluelist</u>
                     This option is used to add extra headers to the HTTP request.  The  <u>keyvaluelist</u>  argu-<font color="#ffffff" class="whiteout">ment&nbsp;argument</font>
                     ment  must  be  a  list with an even number of elements that alternate between keys and
                     values.  The keys become header field names.  Newlines are stripped from the values  so
                     the  header  cannot be corrupted.  For example, if <u>keyvaluelist</u> is <b>Pragma</b> <b>no-cache</b> then
                     the following header is included in the HTTP request:
                     Pragma: no-cache

              <b>-progress</b> <u>callback</u>
                     The <u>callback</u> is made after each transfer of data from the URL.  The callback gets three
                     additional  arguments:  the  <u>token</u>  from <b>::http::geturl</b>, the expected total size of the
                     contents from the <b>Content-Length</b> meta-data, and the current number of bytes transferred
                     so  far.   The  expected total size may be unknown, in which case zero is passed to the
                     callback.  Here is a template for the progress callback:
                            proc httpProgress {token total current} {
                                upvar #0 $token state
                            }

              <b>-query</b> <u>query</u>
                     This flag causes <b>::http::geturl</b> to do a POST request  that  passes  the  <u>query</u>  to  the
                     server.  The  <u>query</u>  must be a x-url-encoding formatted query.  The <b>::http::formatQuery</b>
                     procedure can be used to do the formatting.

              <b>-queryblocksize</b> <u>size</u>
                     The blocksize used when posting query data to the URL.  At most <u>size</u> bytes are  written
                     at  once.   After  each  block,  a call to the <b>-queryprogress</b> callback is made (if that
                     option is specified).

              <b>-querychannel</b> <u>channelID</u>
                     This flag causes <b>::http::geturl</b> to do a POST request that passes the data contained  in
                     <u>channelID</u>  to the server. The data contained in <u>channelID</u> must be a x-url-encoding for-<font color="#ffffff" class="whiteout">matted&nbsp;formatted</font>
                     matted query unless the <b>-type</b> option below is used.  If a Content-Length header is  not
                     specified  via  the  <b>-headers</b> options, <b>::http::geturl</b> attempts to determine the size of
                     the post data in order to create that header.  If it is unable to determine  the  size,
                     it returns an error.

              <b>-queryprogress</b> <u>callback</u>
                     The  <u>callback</u>  is  made  after  each  transfer  of data to the URL (i.e. POST) and acts
                     exactly like the <b>-progress</b> option (the callback format is the same).

              <b>-timeout</b> <u>milliseconds</u>
                     If <u>milliseconds</u> is non-zero, then <b>::http::geturl</b> sets up a timeout to occur  after  the
                     specified  number of milliseconds.  A timeout results in a call to <b>::http::reset</b> and to
                     the <b>-command</b> callback, if specified.  The return value  of  <b>::http::status</b>  is  <b>timeout</b>
                     after a timeout has occurred.

              <b>-type</b> <u>mime-type</u>
                     Use  <u>mime-type</u>  as the <b>Content-Type</b> value, instead of the default value (<b>application/x</b>-<font color="#ffffff" class="whiteout">www-form-urlencoded)&nbsp;(application/xwww-form-urlencoded)</font>
                     <b>www-form-urlencoded</b>) during a POST operation.

              <b>-validate</b> <u>boolean</u>
                     If <u>boolean</u> is non-zero, then <b>::http::geturl</b> does an HTTP HEAD  request.   This  request
                     returns  meta  information  about the URL, but the contents are not returned.  The meta
                     information is available in the <b>state(meta)</b>  variable after the transaction.   See  the
                     STATE ARRAY section for details.

       <b>::http::formatQuery</b> <u>key</u> <u>value</u> ?<u>key</u> <u>value</u> ...?
              This  procedure  does x-url-encoding of query data.  It takes an even number of arguments that
              are the keys and values of the query.  It encodes the  keys  and  values,  and  generates  one
              string  that  has  the proper &amp; and = separators.  The result is suitable for the <b>-query</b> value
              passed to <b>::http::geturl</b>.

       <b>::http::reset</b> <u>token</u> ?<u>why</u>?
              This command resets the  HTTP  transaction  identified  by  <u>token</u>,  if  any.   This  sets  the
              <b>state(status)</b>  value  to  <u>why</u>, which defaults to <b>reset</b>, and then calls the registered <b>-command</b>
              callback.

       <b>::http::wait</b> <u>token</u>
              This is a convenience procedure that blocks and waits for the transaction to  complete.   This
              only  works  in  trusted code because it uses <b>vwait</b>.  Also, it's not useful for the case where
              <b>::http::geturl</b> is called <u>without</u> the <b>-command</b> option because in this case  the  <b>::http::geturl</b>
              call  doesn't  return until the HTTP transaction is complete, and thus there's nothing to wait
              for.

       <b>::http::data</b> <u>token</u>
              This is a convenience procedure that returns the <b>body</b> element (i.e.,  the  URL  data)  of  the
              state array.

       <b>::http::error</b> <u>token</u>
              This is a convenience procedure that returns the <b>error</b> element of the state array.

       <b>::http::status</b> <u>token</u>
              This is a convenience procedure that returns the <b>status</b> element of the state array.

       <b>::http::code</b> <u>token</u>
              This is a convenience procedure that returns the <b>http</b> element of the state array.

       <b>::http::ncode</b> <u>token</u>
              This  is  a  convenience  procedure that returns just the numeric return code (200, 404, etc.)
              from the <b>http</b> element of the state array.

       <b>::http::size</b> <u>token</u>
              This is a convenience procedure that returns the <b>currentsize</b> element of the state array, which
              represents the number of bytes received from the URL in the <b>::http::geturl</b> call.

       <b>::http::cleanup</b> <u>token</u>
              This  procedure cleans up the state associated with the connection identified by <u>token</u>.  After
              this call, the procedures like <b>::http::data</b> cannot be used to get information about the opera-<font color="#ffffff" class="whiteout">tion.&nbsp;operation.</font>
              tion.   It  is <u>strongly</u> recommended that you call this function after you're done with a given
              HTTP request.  Not doing so will result in memory not being  freed,  and  if  your  app  calls
              <b>::http::geturl</b> enough times, the memory leak could cause a performance hit...or worse.

       <b>::http::register</b> <u>proto</u> <u>port</u> <u>command</u>
              This procedure allows one to provide custom HTTP transport types such as HTTPS, by registering
              a prefix, the default port, and the command to execute to create the Tcl <b>channel</b>. E.g.:
                     package require http
                     package require tls

                     http::register https 443 ::tls::socket

                     set token [http::geturl https://my.secure.site/]

       <b>::http::unregister</b> <u>proto</u>
              This procedure unregisters a protocol handler that was previously registered via  <b>http::regis</b>-<font color="#ffffff" class="whiteout">ter.&nbsp;http::register.</font>
              <b>ter</b>.


<b>ERRORS</b>
       The <b>http::geturl</b> procedure will raise errors in the following cases: invalid command line options, an
       invalid URL, a URL on a non-existent host, or a URL at a bad port on an existing host.  These  errors
       mean  that  it  cannot even start the network transaction.  It will also raise an error if it gets an
       I/O error while writing out the HTTP request header.  For  synchronous  <b>::http::geturl</b>  calls  (where
       <b>-command</b>  is  not  specified),  it will raise an error if it gets an I/O error while reading the HTTP
       reply headers or data.  Because <b>::http::geturl</b> doesn't return a token in these cases, it does all the
       required cleanup and there's no issue of your app having to call <b>::http::cleanup</b>.

       For  asynchronous  <b>::http::geturl</b>  calls,  all  of  the  above error situations apply, except that if
       there's any error while reading the HTTP reply headers or data, no  exception  is  thrown.   This  is
       because  after writing the HTTP headers, <b>::http::geturl</b> returns, and the rest of the HTTP transaction
       occurs in the background.  The command callback can check if any error occurred during  the  read  by
       calling  <b>::http::status</b>  to check the status and if its <u>error</u>, calling <b>::http::error</b> to get the error
       message.

       Alternatively, if the main program flow reaches a point where it needs to  know  the  result  of  the
       asynchronous  HTTP  request,  it  can  call <b>::http::wait</b> and then check status and error, just as the
       callback does.

       In any case, you must still call <b>http::cleanup</b> to delete the state array when you're done.

       There are other possible results of the HTTP transaction determined  by  examining  the  status  from
       <b>http::status</b>.  These are described below.

       ok     If the HTTP transaction completes entirely, then status will be <b>ok</b>.  However, you should still
              check the <b>http::code</b> value to get the HTTP status.  The <b>http::ncode</b>  procedure  provides  just
              the  numeric error (e.g., 200, 404 or 500) while the <b>http::code</b> procedure returns a value like
              "HTTP 404 File not found".

       eof    If the server closes the socket without replying, then no error is raised, but the  status  of
              the transaction will be <b>eof</b>.

       error  The  error  message  will  also  be  stored  in the <b>error</b> status array element, accessible via
              <b>::http::error</b>.

       Another error possibility is that <b>http::geturl</b> is unable to write all the  post  query  data  to  the
       server before the server responds and closes the socket.  The error message is saved in the <b>posterror</b>
       status array element and then  <b>http::geturl</b> attempts to complete the transaction.  If it can read the
       server's response it will end up with an <b>ok</b> status, otherwise it will have an <b>eof</b> status.


<b>STATE</b> <b>ARRAY</b>
       The  <b>::http::geturl</b> procedure returns a <u>token</u> that can be used to get to the state of the HTTP trans-<font color="#ffffff" class="whiteout">action&nbsp;transaction</font>
       action in the form of a Tcl array.  Use this construct to create an easy-to-use array variable:
              upvar #0 $token state
       Once the data associated with the url is no longer needed, the state array should be unset to free up
       storage.   The  <b>http::cleanup</b>  procedure is provided for that purpose.  The following elements of the
       array are supported:

              <b>body</b>   The contents of the URL.  This will be empty if the <b>-channel</b> option has been specified.
                     This value is returned by the <b>::http::data</b> command.

              <b>charset</b>
                     The  value of the charset attribute from the <b>Content-Type</b> meta-data value.  If none was
                     specified,  this  defaults  to  the  RFC  standard   <b>iso8859-1</b>,   or   the   value   of
                     <b>$::http::defaultCharset</b>.   Incoming text data will be automatically converted from this
                     charset to utf-8.

              <b>coding</b> A copy of the <b>Content-Encoding</b> meta-data value.

              <b>currentsize</b>
                     The current number of bytes fetched from the  URL.   This  value  is  returned  by  the
                     <b>::http::size</b> command.

              <b>error</b>  If defined, this is the error string seen when the HTTP transaction was aborted.

              <b>http</b>   The HTTP status reply from the server.  This value is returned by the <b>::http::code</b> com-<font color="#ffffff" class="whiteout">mand.&nbsp;command.</font>
                     mand.  The format of this value is:
                            <u>HTTP/1.0</u> <u>code</u> <u>string</u>
                     The <u>code</u> is a three-digit number defined in the HTTP standard.  A code of  200  is  OK.
                     Codes  beginning  with  4 or 5 indicate errors.  Codes beginning with 3 are redirection
                     errors.  In this case the <b>Location</b> meta-data specifies a  new  URL  that  contains  the
                     requested information.

              <b>meta</b>   The  HTTP protocol returns meta-data that describes the URL contents.  The <b>meta</b> element
                     of the state array is a list of the keys and values of the meta-data.   This  is  in  a
                     format useful for initializing an array that just contains the meta-data:
                            array set meta $state(meta)
                     Some  of  the  meta-data keys are listed below, but the HTTP standard defines more, and
                     servers are free to add their own.

                     <b>Content-Type</b>
                            The type of the URL contents.  Examples include <b>text/html</b>,  <b>image/gif,</b>  <b>applica</b>-<font color="#ffffff" class="whiteout">tion/postscript&nbsp;application/postscript</font>
                            <b>tion/postscript</b> and <b>application/x-tcl</b>.

                     <b>Content-Length</b>
                            The advertised size of the contents.  The actual size obtained by <b>::http::geturl</b>
                            is available as <b>state(size)</b>.

                     <b>Location</b>
                            An alternate URL that contains the requested data.

              <b>posterror</b>
                     The error, if any, that occurred while writing the post query data to the server.

              <b>status</b> Either <b>ok</b>, for successful completion,  <b>reset</b>  for  user-reset,  <b>timeout</b>  if  a  timeout
                     occurred  before the transaction could complete, or <b>error</b> for an error condition.  Dur-<font color="#ffffff" class="whiteout">ing&nbsp;During</font>
                     ing the transaction this value is the empty string.

              <b>totalsize</b>
                     A copy of the <b>Content-Length</b> meta-data value.

              <b>type</b>   A copy of the <b>Content-Type</b> meta-data value.

              <b>url</b>    The requested URL.

<b>EXAMPLE</b>
              # Copy a URL to a file and print meta-data
              proc ::http::copy { url file {chunk 4096} } {
                  set out [open $file w]
                  set token [geturl $url -channel $out -progress ::http::Progress \
                -blocksize $chunk]
                  close $out
                  # This ends the line started by http::Progress
                  puts stderr ""
                  upvar #0 $token state
                  set max 0
                  foreach {name value} $state(meta) {
                if {[string length $name] &gt; $max} {
                    set max [string length $name]
                }
                if {[regexp -nocase ^location$ $name]} {
                    # Handle URL redirects
                    puts stderr "Location:$value"
                    return [copy [string trim $value] $file $chunk]
                }
                  }
                  incr max
                  foreach {name value} $state(meta) {
                puts [format "%-*s %s" $max $name: $value]
                  }

                  return $token
              }
              proc ::http::Progress {args} {
                  puts -nonewline stderr . ; flush stderr
              }



<b>SEE</b> <b>ALSO</b>
       <a href="safe.ntcl.html#//apple_ref/doc/man/n/safe">safe(n)</a>, <a href="socket.ntcl.html#//apple_ref/doc/man/n/socket">socket(n)</a>, <!-- a -->safesock(n)<!-- /a -->


<b>KEYWORDS</b>
       security policy, socket



http                                                 2.5                                             http(n)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/mann/http.ntcl.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/mann/http.ntcl.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/mann/http.ntcl.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
