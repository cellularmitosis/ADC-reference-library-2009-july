<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><HTML><head><script language="JavaScript" src="../../frametest.js"></script><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1"><META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css"><META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter"><!-- Link line removed --><TITLE> Working with SoundConverterFillBuffer</TITLE><script language=javascript> window.parent.focus(); </script></HEAD><BODY BGCOLOR="#ffffff"><!-- start of header --><!--#include virtual="/includes/framesetheader" --><!-- end of header --><!-- path goes here --><!-- QTnavbar start --><P><I>Inside Macintosh: QuickTime Reference</I><P>| <A HREF="QT41WhatsNew-88.html">Previous</A> | <A HREF="QT41WhatsNew-1.html">Chapter Contents</A> | <A HREF="QT41WhatsNew.html">Chapter Top</A> | <A HREF="QT41WhatsNew-90.html">Next</A> |</P><!-- QTnavbar end --><H1><A NAME="pgfId-31477"></A>Working with SoundConverterFillBuffer</H1><A NAME="pgfId-31478"></A>In general, working with the <TT>SoundConverterFillBuffer</TT> function is much like working with <TT>SoundConverterConvertBuffer</TT>. You still call the <TT>SoundConverterOpen</TT>, <TT>SoundConverterClose</TT>, <TT>SoundConverterBeginConversion</TT> and <TT>SoundConverterEndConversion</TT> routines just as you always have and you still typically perform the conversion in a loop.</P><P CLASS="T1-Text1"><A NAME="pgfId-31479"></A>The differences begin with how the buffering is done. <TT>SoundConverterFillBuffer</TT> will do as much or as little work as is required to satisfy a given request. This means that you can pass in buffers of any size you like and expect that the Sound Converter will never overflow the output buffer.</P><P CLASS="T1-Text1"><A NAME="pgfId-31480"></A>Moreover, the <TT>SoundConverterFillBufferDataProc</TT> function will be called as many times as necessary to fulfill a request. This means that the <TT>SoundConverterFillBufferDataProc</TT> routine is free to provide data in whatever chunk size it likes. Of course with both sides, the buffer sizes will control how many times you need to request data and there is a certain amount of overhead for each call. You will want to balance this against the performance you require. While a call to <TT>SoundConverterGetBufferSizes</TT> is not required by the <TT>SoundConverterFillBuffer</TT> function, it is useful as a guide for non-VBR formats.</P><P CLASS="T1-Text1"><A NAME="pgfId-31481"></A>The following code snippet illustrates a typical use of <TT>SoundConverterFillBuffer</TT>. </P><P CLASS="L-Listing"><A NAME="pgfId-42661"></A><B>Listing 7&nbsp;&nbsp;</B>A typical usage of the SoundConverterFillBuffer routine</P><TT><A NAME="pgfId-55724"></A>{<BR>SoundComponentData&nbsp;inputFormat,&nbsp;outputFormat;<BR>SoundConverter&nbsp;sc;<BR>Boolean&nbsp;hasLeftOverData&nbsp;=&nbsp;false;<BR>unsigned&nbsp;long&nbsp;totalBytesWritten&nbsp;=&nbsp;0;<BR>unsigned&nbsp;long&nbsp;totalFramesWritten&nbsp;=&nbsp;0;<BR>unsigned&nbsp;long&nbsp;bytesWritten&nbsp;=&nbsp;0;<BR>unsigned&nbsp;long&nbsp;framesWritten&nbsp;=&nbsp;0;<BR>unsigned&nbsp;long&nbsp;outputFlags&nbsp;=&nbsp;0;<BR>unsigned&nbsp;long&nbsp;outputBufferByteSize&nbsp;=&nbsp;0;<BR>void*&nbsp;outputBuffer&nbsp;=&nbsp;NULL;<BR><BR>GetFormats(&amp;inputFormat,&nbsp;&amp;outputFormat);<BR><BR>SoundConverterOpen(&amp;inputFormat,&nbsp;outputFormat,&nbsp;&amp;sc);<BR><BR>SoundConverterBeginConversion(sc);</TT><TT><A NAME="pgfId-55728"></A><BR><BR>while(HasMoreSourceData()&nbsp;||&nbsp;hasLeftOverData)<BR>{<BR>bytesWritten&nbsp;=&nbsp;0;<BR>framesWritten&nbsp;=&nbsp;0;<BR>outputFlags&nbsp;=&nbsp;0;<BR>outputBufferByteSize&nbsp;=&nbsp;0;<BR>outputBuffer&nbsp;=&nbsp;GetNextOutputBuffer(&amp;outputBufferByteSize);<BR><BR>SoundConverterFillBuffer(sc,&nbsp;MySoundConverterFillBufferDataUPP,&nbsp;NULL,&nbsp;outputBuffer,<BR>&nbsp;&nbsp;&nbsp;outputBufferByteSize,&nbsp;&amp;bytesWritten,&nbsp;&amp;framesWritten,&nbsp;&amp;outputFlags);<BR><BR>//&nbsp;&nbsp;&nbsp;&nbsp;advance&nbsp;whatever&nbsp;pointers&nbsp;we&nbsp;need&nbsp;to<BR>totalBytesWritten&nbsp;+=&nbsp;bytesWritten;<BR>totalFramesWritten&nbsp;+=&nbsp;framesWritten;<BR><BR>//&nbsp;&nbsp;&nbsp;&nbsp;figure&nbsp;out&nbsp;if&nbsp;we&nbsp;have&nbsp;any&nbsp;data&nbsp;still&nbsp;stuck&nbsp;in&nbsp;the&nbsp;chain<BR>hasLeftOverData&nbsp;=&nbsp;outputFlags&nbsp;&amp;&nbsp;kSoundConverterHasLeftOverData;<BR>}<BR><BR>//&nbsp;&nbsp;&nbsp;&nbsp;get&nbsp;the&nbsp;left&nbsp;overs<BR>outputBuffer&nbsp;=&nbsp;GetNextOutputBuffer(&amp;outputBufferByteSize);&nbsp;&nbsp;&nbsp;&nbsp;<BR>SoundConverterEndConversion(sc,&nbsp;outputBuffer,&nbsp;&amp;bytesWritten,&nbsp;&amp;framesWritten);<BR><BR>//&nbsp;&nbsp;&nbsp;&nbsp;advance&nbsp;whatever&nbsp;pointers&nbsp;we&nbsp;need&nbsp;to<BR>totalBytesWritten&nbsp;+=&nbsp;bytesWritten;<BR>totalFramesWritten&nbsp;+=&nbsp;framesWritten;<BR><BR>SoundConverterClose(sc);<BR>}<BR></TT><P CLASS="T1-Text1"><A NAME="pgfId-46197"></A>The <TT>SoundConverterFillBufferDataProc</TT> could look something like this:</P><TT><A NAME="pgfId-55732"></A>pascal Boolean    SoundConverterFillBufferDataProc( SoundComponentDataPtr*    data,<BR>void*                     refCon)<BR>{<BR>*data = GetNextSourceBuffer(refCon);<BR><BR>return *data != NULL;<BR>}</TT><P><hr>&#169; 2000 Apple Computer, Inc.<!-- QTnavbar start --><P><I>Inside Macintosh: QuickTime Reference</I><P>| <A HREF="QT41WhatsNew-88.html">Previous</A> | <A HREF="QT41WhatsNew-1.html">Chapter Contents</A> | <A HREF="QT41WhatsNew.html">Chapter Top</A> | <A HREF="QT41WhatsNew-90.html">Next</A> |</P><!-- QTnavbar end --></DIV><!-- start of footer --><!--#include virtual="/includes/framesetfooter" --><!-- end of footer --></BODY></HTML>