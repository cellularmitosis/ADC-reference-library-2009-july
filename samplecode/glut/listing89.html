<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>GLUT - /HID_Queue_Utilities.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/GraphicsImaging/index.html">Graphics & Imaging</a> &gt; <a href="../../samplecode/GraphicsImaging/idxOpenGL-date.html">OpenGL</a> &gt; <A HREF="javascript:location.replace('index.html');">GLUT</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->


	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">GLUT</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/HID_Queue_Utilities.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/gle/copy.h</option>
<option value="listing2.html">/gle/ex_angle.c</option>
<option value="listing3.html">/gle/ex_cut_round.c</option>
<option value="listing4.html">/gle/ex_raw.c</option>
<option value="listing5.html">/gle/extrude.c</option>
<option value="listing6.html">/gle/extrude.h</option>
<option value="listing7.html">/gle/gle_osx.h</option>
<option value="listing8.html">/gle/gutil.h</option>
<option value="listing9.html">/gle/intersect.c</option>
<option value="listing10.html">/gle/intersect.h</option>
<option value="listing11.html">/gle/port.h</option>
<option value="listing12.html">/gle/rot.h</option>
<option value="listing13.html">/gle/rot_prince.c</option>
<option value="listing14.html">/gle/rotate.c</option>
<option value="listing15.html">/gle/round_cap.c</option>
<option value="listing16.html">/gle/segment.c</option>
<option value="listing17.html">/gle/segment.h</option>
<option value="listing18.html">/gle/texgen.c</option>
<option value="listing19.html">/gle/tube.h</option>
<option value="listing20.html">/gle/tube_gc.h</option>
<option value="listing21.html">/gle/urotate.c</option>
<option value="listing22.html">/gle/view.c</option>
<option value="listing23.html">/gle/vvector.h</option>
<option value="listing24.html">/glsmap/glsmap.h</option>
<option value="listing25.html">/glsmap/glsmapint.h</option>
<option value="listing26.html">/glsmap/smap_buildsmap.c</option>
<option value="listing27.html">/glsmap/smap_context.c</option>
<option value="listing28.html">/glsmap/smap_create.c</option>
<option value="listing29.html">/glsmap/smap_destroy.c</option>
<option value="listing30.html">/glsmap/smap_drawmesh.c</option>
<option value="listing31.html">/glsmap/smap_flag.c</option>
<option value="listing32.html">/glsmap/smap_get.c</option>
<option value="listing33.html">/glsmap/smap_getfunc.c</option>
<option value="listing34.html">/glsmap/smap_gettexdim.c</option>
<option value="listing35.html">/glsmap/smap_gettexobj.c</option>
<option value="listing36.html">/glsmap/smap_getvec.c</option>
<option value="listing37.html">/glsmap/smap_makemesh.c</option>
<option value="listing38.html">/glsmap/smap_nearfar.c</option>
<option value="listing39.html">/glsmap/smap_origin.c</option>
<option value="listing40.html">/glsmap/smap_render.c</option>
<option value="listing41.html">/glsmap/smap_rvec2st.c</option>
<option value="listing42.html">/glsmap/smap_set.c</option>
<option value="listing43.html">/glsmap/smap_setfunc.c</option>
<option value="listing44.html">/glsmap/smap_setvec.c</option>
<option value="listing45.html">/glsmap/smap_texdim.c</option>
<option value="listing46.html">/glsmap/smap_texobj.c</option>
<option value="listing47.html">/glut.h</option>
<option value="listing48.html">/glut_8x13.c</option>
<option value="listing49.html">/glut_9x15.c</option>
<option value="listing50.html">/glut_bitmap.c</option>
<option value="listing51.html">/glut_bwidth.c</option>
<option value="listing52.html">/glut_cindex.c</option>
<option value="listing53.html">/glut_ext.c</option>
<option value="listing54.html">/glut_hel10.c</option>
<option value="listing55.html">/glut_hel12.c</option>
<option value="listing56.html">/glut_hel18.c</option>
<option value="listing57.html">/glut_mroman.c</option>
<option value="listing58.html">/glut_roman.c</option>
<option value="listing59.html">/glut_shapes.c</option>
<option value="listing60.html">/glut_stroke.c</option>
<option value="listing61.html">/glut_swidth.c</option>
<option value="listing62.html">/glut_teapot.c</option>
<option value="listing63.html">/glut_tr10.c</option>
<option value="listing64.html">/glut_tr24.c</option>
<option value="listing65.html">/glut_vidresize.c</option>
<option value="listing66.html">/GLUTApplication.h</option>
<option value="listing67.html">/GLUTApplication.m</option>
<option value="listing68.html">/glutbitmap.h</option>
<option value="listing69.html">/GLUTClipboardController.h</option>
<option value="listing70.html">/GLUTClipboardController.m</option>
<option value="listing71.html">/glutf90.h</option>
<option value="listing72.html">/GLUTMenu.h</option>
<option value="listing73.html">/GLUTMenu.m</option>
<option value="listing74.html">/GLUTMenuItem.h</option>
<option value="listing75.html">/GLUTMenuItem.m</option>
<option value="listing76.html">/GLUTPreferencesController.h</option>
<option value="listing77.html">/GLUTPreferencesController.m</option>
<option value="listing78.html">/glutstroke.h</option>
<option value="listing79.html">/GLUTView.h</option>
<option value="listing80.html">/GLUTView.m</option>
<option value="listing81.html">/GLUTWindow.h</option>
<option value="listing82.html">/GLUTWindow.m</option>
<option value="listing83.html">/HID_Config_Utilities.c</option>
<option value="listing84.html">/HID_Config_Utilities.h</option>
<option value="listing85.html">/HID_Error_Handler.c</option>
<option value="listing86.html">/HID_Error_Handler.h</option>
<option value="listing87.html">/HID_Name_Lookup.c</option>
<option value="listing88.html">/HID_Name_Lookup.h</option>
<option value="listing89.html">/HID_Queue_Utilities.c</option>
<option value="listing90.html">/HID_Queue_Utilities.h</option>
<option value="listing91.html">/HID_Utilities.c</option>
<option value="listing92.html">/HID_Utilities.h</option>
<option value="listing93.html">/HID_Utilities_External.h</option>
<option value="listing94.html">/HID_Utilities_Internal.h</option>
<option value="listing95.html">/libForeground.a</option>
<option value="listing96.html">/macx_cursor.m</option>
<option value="listing97.html">/macx_dials.m</option>
<option value="listing98.html">/macx_dstr.m</option>
<option value="listing99.html">/macx_event.m</option>
<option value="listing100.html">/macx_fortran.m</option>
<option value="listing101.html">/macx_gamemode.m</option>
<option value="listing102.html">/macx_get.m</option>
<option value="listing103.html">/macx_glut.h</option>
<option value="listing104.html">/macx_init.m</option>
<option value="listing105.html">/macx_input.m</option>
<option value="listing106.html">/macx_joy.m</option>
<option value="listing107.html">/macx_key.m</option>
<option value="listing108.html">/macx_menu.m</option>
<option value="listing109.html">/macx_modifier.m</option>
<option value="listing110.html">/macx_overlay.m</option>
<option value="listing111.html">/macx_space.m</option>
<option value="listing112.html">/macx_swap.m</option>
<option value="listing113.html">/macx_tablet.m</option>
<option value="listing114.html">/macx_util.m</option>
<option value="listing115.html">/macx_utilities.h</option>
<option value="listing116.html">/macx_warp.m</option>
<option value="listing117.html">/macx_win.m</option>
<option value="listing118.html">/ReadMe.txt</option></select>
				</p>
				</form>
				<p><strong><a href="glut.zip">Download Sample</a></strong> (&#147;glut.zip&#148;, 374.3K)<BR>
<strong><a href="glut.dmg">Download Sample</a></strong> (&#147;glut.dmg&#148;, 680.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">//
// File:       HID_Queue_Utilities.c
//
// Disclaimer: IMPORTANT:  This Apple software is supplied to you by Apple Inc. (&quot;Apple&quot;)
//             in consideration of your agreement to the following terms, and your use,
//             installation, modification or redistribution of this Apple software
//             constitutes acceptance of these terms.  If you do not agree with these
//             terms, please do not use, install, modify or redistribute this Apple
//             software.
//
//             In consideration of your agreement to abide by the following terms, and
//             subject to these terms, Apple grants you a personal, non - exclusive
//             license, under Apple's copyrights in this original Apple software ( the
//             &quot;Apple Software&quot; ), to use, reproduce, modify and redistribute the Apple
//             Software, with or without modifications, in source and / or binary forms;
//             provided that if you redistribute the Apple Software in its entirety and
//             without modifications, you must retain this notice and the following text
//             and disclaimers in all such redistributions of the Apple Software. Neither
//             the name, trademarks, service marks or logos of Apple Inc. may be used to
//             endorse or promote products derived from the Apple Software without specific
//             prior written permission from Apple.  Except as expressly stated in this
//             notice, no other rights or licenses, express or implied, are granted by
//             Apple herein, including but not limited to any patent rights that may be
//             infringed by your derivative works or by other works in which the Apple
//             Software may be incorporated.
//
//             The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE MAKES NO
//             WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED
//             WARRANTIES OF NON - INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A
//             PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION
//             ALONE OR IN COMBINATION WITH YOUR PRODUCTS.
//
//             IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR
//             CONSEQUENTIAL DAMAGES ( INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
//             SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
//             INTERRUPTION ) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION
//             AND / OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER
//             UNDER THEORY OF CONTRACT, TORT ( INCLUDING NEGLIGENCE ), STRICT LIABILITY OR
//             OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Copyright ( C ) 2001-2008 Apple Inc. All Rights Reserved.
//

#include &quot;HID_Utilities_Internal.h&quot;
#include &quot;HID_Utilities_External.h&quot;

static IOReturn HIDCreateQueue (pRecDevice pDevice);
static unsigned char HIDIsDeviceQueueEmpty (pRecDevice pDevice);
static IOReturn HIDDisposeReleaseQueue (pRecDevice pDevice);

// ==================================
// private functions

// creates a queue for a device, creates and opens device interface if required

static IOReturn HIDCreateQueue (pRecDevice pDevice)
{
    IOReturn result = kIOReturnSuccess;
    if (NULL == pDevice-&gt;queue) // do we already have a queue
    {    
        if (NULL != pDevice-&gt;interface) 
        {
            pDevice-&gt;queue =(void *) (*(IOHIDDeviceInterface **) pDevice-&gt;interface)-&gt;allocQueue (pDevice-&gt;interface); // alloc queue
            if (pDevice-&gt;queue)
            {
                result = (*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;create (pDevice-&gt;queue, 0, kDeviceQueueSize); // create actual queue
                if (kIOReturnSuccess != result)
                    HIDReportErrorNum (&quot;Failed to create queue via create&quot;, result);
            }
            else
            {
                HIDReportError (&quot;Failed to alloc IOHIDQueueInterface ** via allocQueue&quot;);
                result = kIOReturnError; // synthesis error
            }
        }
        else
            HIDReportErrorNum (&quot;Device inteface does not exist for queue creation&quot;, result);
    }
    return result;
}

// ---------------------------------

// returns true if queue is empty false otherwise
// error if no device, empty if no queue

static unsigned char HIDIsDeviceQueueEmpty (pRecDevice pDevice)
{
    if (pDevice &amp;&amp; pDevice-&gt;queue) // need device and queue
    {
        pRecElement pElement = HIDGetFirstDeviceElement (pDevice, kHIDElementTypeIO);
        while (pElement)
        {
            if ((*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;hasElement (pDevice-&gt;queue, pElement-&gt;cookie))
                return false;
            pElement = HIDGetNextDeviceElement (pElement, kHIDElementTypeIO);
        } 
    }
    else if (NULL == pDevice) // if no device (if just no queue then queue must be empty)
        HIDReportError (&quot;NULL device passed to DeviceQueueEmpty.&quot;);
    return true;   
}

// ---------------------------------

// disposes and releases queue, sets queue to NULL,.
// Note: will have no effect if device or queue do not exist

static IOReturn HIDDisposeReleaseQueue (pRecDevice pDevice)
{
    IOReturn result = kIOReturnSuccess;

    if ((NULL != pDevice) &amp;&amp; (NULL != pDevice-&gt;queue))
    {
        // stop queue
        result = (*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;stop (pDevice-&gt;queue);
        if (kIOReturnSuccess != result)
            HIDReportErrorNum (&quot;Failed to stop queue.&quot;, result);
        // dispose of queue
        result = (*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;dispose (pDevice-&gt;queue);
        if (kIOReturnSuccess != result)
            HIDReportErrorNum (&quot;Failed to dipose queue.&quot;, result);
        // release the queue
        result = (*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;Release (pDevice-&gt;queue);
        if (kIOReturnSuccess != result)
            HIDReportErrorNum (&quot;Failed to release queue.&quot;, result);
            
        pDevice-&gt;queue = NULL;
    }
    return result;
}

// ==================================
// public functions

// Create and open an interface to device, required prior to extracting values or building queues
// Note: appliction now owns the device and must close and release it prior to exiting

IOReturn HIDCreateOpenDeviceInterface (io_object_t hidDevice, pRecDevice pDevice)
{
    IOReturn result = kIOReturnSuccess;
    HRESULT plugInResult = S_OK;
    SInt32 score = 0;
    IOCFPlugInInterface ** ppPlugInInterface = NULL;
    
    if (NULL == pDevice-&gt;interface)
    {
        result = IOCreatePlugInInterfaceForService (hidDevice, kIOHIDDeviceUserClientTypeID,
                                                    kIOCFPlugInInterfaceID, &amp;ppPlugInInterface, &amp;score);
        if (kIOReturnSuccess == result)
        {
            // Call a method of the intermediate plug-in to create the device interface
            plugInResult = (*ppPlugInInterface)-&gt;QueryInterface (ppPlugInInterface, 
                                CFUUIDGetUUIDBytes (kIOHIDDeviceInterfaceID), (void *) &amp;(pDevice-&gt;interface));
            if (S_OK != plugInResult)
                HIDReportErrorNum (&quot;Couldn't query HID class device interface from plugInInterface&quot;, plugInResult);
            IODestroyPlugInInterface (ppPlugInInterface); // replace (*ppPlugInInterface)-&gt;Release (ppPlugInInterface)
        }
        else
            HIDReportErrorNum (&quot;Failed to create **plugInInterface via IOCreatePlugInInterfaceForService.&quot;, result);
    }
    if (NULL != pDevice-&gt;interface)
    {
        result = (*(IOHIDDeviceInterface **)pDevice-&gt;interface)-&gt;open (pDevice-&gt;interface, 0);
        if (kIOReturnSuccess != result)
            HIDReportErrorNum (&quot;Failed to open pDevice-&gt;interface via open.&quot;, result);
    }
    return result;
}

// ---------------------------------

// queues specific element, performing any device queue set up required
// queue is started and ready to return events on exit from this function

int  HIDQueueElement (pRecDevice pDevice, pRecElement pElement)
{
    IOReturn result = kIOReturnSuccess;

    // error checking
    if ((NULL == pDevice) || (NULL == pElement))
    {
        HIDReportError (&quot;Device or element does not exist, cannot queue element.&quot;);
        return kIOReturnBadArgument;
    }
    if (NULL == pDevice-&gt;interface) // must have interface
    {
        HIDReportError (&quot;Device does not have interface, cannot queue element.&quot;);
        return kIOReturnError;
    }
    if (NULL == pDevice-&gt;queue) // if no queue create queue
        result = HIDCreateQueue (pDevice);
    if ((kIOReturnSuccess != result) || (NULL == pDevice-&gt;queue))
    {
        HIDReportErrorNum (&quot;Could not queue element due to problem creating queue.&quot;, result);
        if (kIOReturnSuccess != result)
            return result;
        else
            return kIOReturnError;
    }

    // stop queue
    result = (*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;stop (pDevice-&gt;queue);
    if (kIOReturnSuccess != result)
        HIDReportError (&quot;Failed to stop queue.&quot;);

    // queue element
    if (!(*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;hasElement (pDevice-&gt;queue, pElement-&gt;cookie))
    {
        result = (*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;addElement (pDevice-&gt;queue, pElement-&gt;cookie, 0);
        if (kIOReturnSuccess != result)
            HIDReportError (&quot;Failed to add element to queue via addElement.&quot;);
    }

    // restart queue
    result = (*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;start (pDevice-&gt;queue);
    if (kIOReturnSuccess != result)
        HIDReportError (&quot;Failed to start queue.&quot;);

   return result;
}

// ---------------------------------

// adds all elements to queue, performing any device queue set up required
// queue is started and ready to return events on exit from this function

int  HIDQueueDevice (pRecDevice pDevice)
{
    IOReturn result = kIOReturnSuccess;
    pRecElement pElement;
    
    // error checking
    if (NULL == pDevice)
    {
        HIDReportError (&quot;Device does not exist, cannot queue device.&quot;);
        return kIOReturnBadArgument;
    }
    if (NULL == pDevice-&gt;interface) // must have interface
    {
        HIDReportError (&quot;Device does not have interface, cannot queue device.&quot;);
        return kIOReturnError;
    }
    if (NULL == pDevice-&gt;queue) // if no queue create queue
        result = HIDCreateQueue (pDevice);
    if ((kIOReturnSuccess != result) || (NULL == pDevice-&gt;queue))
    {
        HIDReportErrorNum (&quot;Could not queue device due to problem creating queue.&quot;, result);
        if (kIOReturnSuccess != result)
            return result;
        else
            return kIOReturnError;
    }

    // stop queue
    result = (*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;stop (pDevice-&gt;queue);
    if (kIOReturnSuccess != result)
        HIDReportErrorNum (&quot;Failed to stop queue.&quot;, result);

    // queue element
    pElement = HIDGetFirstDeviceElement (pDevice, kHIDElementTypeIO);
    while (pElement)
    {
        if (!(*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;hasElement (pDevice-&gt;queue, pElement-&gt;cookie))
        {
            result = (*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;addElement (pDevice-&gt;queue, pElement-&gt;cookie, 0);
            if (kIOReturnSuccess != result)
                HIDReportErrorNum (&quot;Failed to add element to queue via addElement&quot;, result);
        }
        pElement = HIDGetNextDeviceElement (pElement, kHIDElementTypeIO);
    }    

    // start queue
    result = (*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;start (pDevice-&gt;queue);
    if (kIOReturnSuccess != result)
        HIDReportErrorNum (&quot;Failed to start queue.&quot;, result);

    return result;
}

// ---------------------------------

// removes element for queue, if last element in queue will release queue and closes device interface

int  HIDDequeueElement (pRecDevice pDevice, pRecElement pElement)
{
    IOReturn result = kIOReturnSuccess;
    if (!pDevice || !pElement)
        result = kIOReturnBadArgument;
    else
    {
        if ((pDevice-&gt;interface) &amp;&amp; (pDevice-&gt;queue))
        {
            // stop queue
            result = (*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;stop (pDevice-&gt;queue);
            if (kIOReturnSuccess != result)
                HIDReportErrorNum (&quot;Failed to stop queue.&quot;, result);
        
            if ((*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;hasElement (pDevice-&gt;queue, pElement-&gt;cookie)) // if has element then remove
            {
                result = (*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;removeElement (pDevice-&gt;queue, pElement-&gt;cookie);
                if (kIOReturnSuccess != result)
                    HIDReportErrorNum (&quot;Failed to add element to queue via addElement&quot;, result);
            }
            
            if (HIDIsDeviceQueueEmpty (pDevice)) // release device queue and close interface if queue empty
            {
                result = HIDDisposeReleaseQueue (pDevice);
                if (kIOReturnSuccess != result)
                    HIDReportErrorNum (&quot;Failed to dispose and release queue.&quot;, result);
            }
            else // not empty so restart queue
            {
                result = (*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;start (pDevice-&gt;queue);
                if (kIOReturnSuccess != result)
                    HIDReportErrorNum (&quot;Failed to start queue.&quot;, result);
            }
        }
        else
        {
            HIDReportError (&quot;No device inteface or queue.&quot;);
            return kIOReturnError;
        }
    }
    return result;
}

// ---------------------------------

// completely removes all elements from queue and releases queue and closes device interface
// does not release device interfaces, application must call ReleaseHIDDeviceList on exit

int  HIDDequeueDevice (pRecDevice pDevice)
{
    IOReturn result = kIOReturnSuccess;
    if (!pDevice)
        result = kIOReturnBadArgument;
    else
    {
        if ((pDevice-&gt;interface) &amp;&amp; (pDevice-&gt;queue))
        {
            // iterate through elements and if queued, remove
            pRecElement pElement = HIDGetFirstDeviceElement (pDevice, kHIDElementTypeIO);
            while (pElement)
            {
                if ((*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;hasElement (pDevice-&gt;queue, pElement-&gt;cookie))
                {
                    result = (*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;removeElement (pDevice-&gt;queue, pElement-&gt;cookie);
                    if (kIOReturnSuccess != result)
                        HIDReportErrorNum (&quot;Failed to add element to queue via addElement&quot;, result);
                }
                pElement = HIDGetNextDeviceElement (pElement, kHIDElementTypeIO);
            }    
        }
        // ensure queue is disposed and released
        // interface will be closed and released on call to ReleaseHIDDeviceList
        result = HIDDisposeReleaseQueue (pDevice);
        if (kIOReturnSuccess != result)
            HIDReportErrorNum (&quot;Failed to dispose and release queue.&quot;, result);
    }
    return result;
}

// ---------------------------------

// releases all device queues for quit or rebuild (must be called)
// does not release device interfaces, application must call ReleaseHIDDeviceList on exit

IOReturn HIDReleaseAllDeviceQueues (void)
{
    IOReturn result = kIOReturnSuccess;
    pRecDevice pDevice = HIDGetFirstDevice ();
    while (pDevice)
    {
        result = HIDDequeueDevice (pDevice);
        if (kIOReturnSuccess != result)
            HIDReportErrorNum (&quot;Could not dequeue device.&quot;, result);
        pDevice = HIDGetNextDevice (pDevice);
    }
    return result;
}

// ---------------------------------

// Closes and releases interface to device, should be done prior to exting application
// Note: will have no affect if device or interface do not exist
// application will &quot;own&quot; the device if interface is not closed
// (device may have to be plug and re-plugged in different location to get it working again without a restart)

IOReturn HIDCloseReleaseInterface (pRecDevice pDevice)
{
    IOReturn result = kIOReturnSuccess;
    
    if ((NULL != pDevice) &amp;&amp; (NULL != pDevice-&gt;interface))
    {
        // close the interface
        result = (*(IOHIDDeviceInterface **) pDevice-&gt;interface)-&gt;close (pDevice-&gt;interface);
        if (kIOReturnNotOpen == result)
        {
            //  do nothing as device was not opened, thus can't be closed
        }
        else if (kIOReturnSuccess != result)
            HIDReportErrorNum (&quot;Failed to close IOHIDDeviceInterface.&quot;, result);
        //release the interface
        result = (*(IOHIDDeviceInterface **) pDevice-&gt;interface)-&gt;Release (pDevice-&gt;interface);
        if (kIOReturnSuccess != result)
            HIDReportErrorNum (&quot;Failed to release IOHIDDeviceInterface.&quot;, result);
        pDevice-&gt;interface = NULL;
    }    
    return result;
}      

// ---------------------------------

// Get the next event in the queue for a device
// elements or entire device should be queued prior to calling this with HIDQueueElement or HIDQueueDevice
// returns true if an event is avialable for the element and fills out *pHIDEvent structure, returns false otherwise
// Note: kIOReturnUnderrun returned from getNextEvent indicates an empty queue not an error condition
// Note: application should pass in a pointer to a IOHIDEventStruct cast to a void (for CFM compatibility)

unsigned char HIDGetEvent (pRecDevice pDevice, void * pHIDEvent)
{
    IOReturn result = kIOReturnSuccess;
    AbsoluteTime zeroTime = {0,0};
    if (pDevice)
    {
        if (pDevice-&gt;queue)
        {
            result = (*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;getNextEvent (pDevice-&gt;queue, (IOHIDEventStruct *)pHIDEvent, zeroTime, 0);
            if (kIOReturnUnderrun == result)
                return false;  // no events in queue not an error per say
            else if (kIOReturnSuccess != result) // actual error versus just an empty queue
                HIDReportErrorNum (&quot;Could not get HID event via getNextEvent.&quot;, result);
            else
                return true;
        }
        else
            HIDReportError (&quot;Could not get HID event, queue does not exist.&quot;);
    }
    else
        HIDReportError (&quot;Could not get HID event, device does not exist.&quot;);
    return false; // did not get event
}

// ---------------------------------

// returns current value for element, polling element
// will return 0 on error conditions which should be accounted for by application

int HIDGetElementValue (pRecDevice pDevice, pRecElement pElement)
{
    IOReturn result = kIOReturnSuccess;
    IOHIDEventStruct hidEvent;
    hidEvent.value = 0;
    
    if (NULL != pDevice)
    {
        if (NULL != pElement)
        {
             if (NULL != pDevice-&gt;interface)
            {
                result = (*(IOHIDDeviceInterface **) pDevice-&gt;interface)-&gt;getElementValue (pDevice-&gt;interface, pElement-&gt;cookie, &amp;hidEvent);
                if (kIOReturnSuccess != result)
                        HIDReportErrorNum (&quot;Could not get HID element value via getElementValue.&quot;, result);
                // on 10.0.x this returns the incorrect result for negative ranges, so fix it!!!
                // this is not required on Mac OS X 10.1+
                if ((pElement-&gt;min &lt; 0) &amp;&amp; (hidEvent.value &gt; pElement-&gt;max)) // assume range problem
                    hidEvent.value = hidEvent.value + pElement-&gt;min - pElement-&gt;max - 1;
            }
            else
                HIDReportError (&quot;Did not have interface for device prior to getting element value.&quot;);
        }
        else
            HIDReportError (&quot;Bad element passed to GetElementValue.&quot;);
    }
    else
        HIDReportError (&quot;Bad device passed to GetElementValue.&quot;);
    // record min and max for auto scale and auto ...
    if (hidEvent.value &lt; pElement-&gt;minReport)
        pElement-&gt;minReport = hidEvent.value; 
    if (hidEvent.value &gt; pElement-&gt;maxReport)
        pElement-&gt;maxReport = hidEvent.value; 

    return hidEvent.value;
}
</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/glut/listing89.html%3Fid%3DDTS10000528-2.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/glut/listing89.html%3Fid%3DDTS10000528-2.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/glut/listing89.html%3Fid%3DDTS10000528-2.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>