<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>The Objective-C 2.0 Programming Language: Protocols</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Protocols"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30001163-CH15" title="Protocols"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../ObjectiveCLanguage-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000856" target="_top">Objective-C Language</a> &gt; <a href="../Introduction/introObjectiveC.html#//apple_ref/doc/uid/TP30001163-CH1-SW2">The Objective-C 2.0 Programming Language</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="ocCategories.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="ocFastEnumeration.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30001163-CH15-SW1" title="Protocols"></a><h1>Protocols</h1><p>Protocols<a name="//apple_ref/doc/uid/TP30001163-CH15-DontLinkElementID_375"></a> declare methods that can be implemented by any class. <a name="//apple_ref/doc/uid/TP30001163-CH15-DontLinkElementID_376"></a>Protocols are useful in at least three situations:</p><ul class="ul"><li class="li"><p>To declare methods that others are expected to implement</p></li><li class="li"><p>To declare the interface to an object while concealing its class</p></li><li class="li"><p>To capture similarities among classes that are not hierarchically related</p></li></ul>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="ocProtocols.html#//apple_ref/doc/uid/TP30001163-CH15-BAJJABHJ">Declaring Interfaces for Others to Implement</a>
				
			<br/>
			
        
			
			
				<a href="ocProtocols.html#//apple_ref/doc/uid/TP30001163-CH15-TPXREF144">Methods for Others to Implement</a>
				
			<br/>
			
        
			
			
				<a href="ocProtocols.html#//apple_ref/doc/uid/TP30001163-CH15-TPXREF145">Declaring Interfaces for Anonymous Objects</a>
				
			<br/>
			
        
			
			
				<a href="ocProtocols.html#//apple_ref/doc/uid/TP30001163-CH15-TPXREF146">Non-Hierarchical Similarities</a>
				
			<br/>
			
        
			
			
				<a href="ocProtocols.html#//apple_ref/doc/uid/TP30001163-CH15-TPXREF148">Formal Protocols</a>
				
			<br/>
			
        
			
			
				<a href="ocProtocols.html#//apple_ref/doc/uid/TP30001163-CH15-TPXREF147">Informal Protocols</a>
				
			<br/>
			
        
			
			
				<a href="ocProtocols.html#//apple_ref/doc/uid/TP30001163-CH15-TPXREF149">Protocol Objects</a>
				
			<br/>
			
        
			
			
				<a href="ocProtocols.html#//apple_ref/doc/uid/TP30001163-CH15-SW3">Adopting a Protocol</a>
				
			<br/>
			
        
			
			
				<a href="ocProtocols.html#//apple_ref/doc/uid/TP30001163-CH15-TPXREF150">Conforming to a Protocol</a>
				
			<br/>
			
        
			
			
				<a href="ocProtocols.html#//apple_ref/doc/uid/TP30001163-CH15-TPXREF151">Type Checking</a>
				
			<br/>
			
        
			
			
				<a href="ocProtocols.html#//apple_ref/doc/uid/TP30001163-CH15-TPXREF152">Protocols Within Protocols</a>
				
			<br/>
			
        
			
			
				<a href="ocProtocols.html#//apple_ref/doc/uid/TP30001163-CH15-TPXREF153">Referring to Other Protocols</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30001163-CH15-113922" title="Declaring Interfaces for Others to Implement"></a><a name="//apple_ref/doc/uid/TP30001163-CH15-BAJJABHJ" title="Declaring Interfaces for Others to Implement"></a><h2>Declaring Interfaces for Others to Implement</h2><p><a name="//apple_ref/doc/uid/TP30001163-CH15-DontLinkElementID_377"></a>Class and category interfaces declare methods that are associated with a particular class—mainly methods that the class implements. Informal and formal <strong>protocols</strong><a name="//apple_ref/doc/uid/TP30001163-CH15-DontLinkElementID_378"></a>, on the other hand, declare methods that are independent of any specific class, but which any class, and perhaps many classes, might implement.</p><p>A protocol is simply a list of method declarations, unattached to a class definition. For example, these methods that report user actions on the mouse could be gathered into a protocol:</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)mouseDown:(NSEvent *)theEvent;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)mouseDragged:(NSEvent *)theEvent;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)mouseUp:(NSEvent *)theEvent;<span></span></pre></td></tr></table></div><p>Any class that wanted to respond to mouse events could adopt the protocol and implement its methods.</p><p>Protocols free method declarations from dependency on the class hierarchy, so they can be used in ways that classes and categories cannot. Protocols list methods that are (or may be) implemented somewhere, but the identity of the class that implements them is not of interest. What is of interest is whether or not a particular class <strong>conforms</strong><a name="//apple_ref/doc/uid/TP30001163-CH15-DontLinkElementID_379"></a><a name="//apple_ref/doc/uid/TP30001163-CH15-DontLinkElementID_380"></a> to the protocol—whether it has implementations of the methods the protocol declares. Thus objects can be grouped into types not just on the basis of similarities due to the fact that they inherit from the same class, but also on the basis of their similarity in conforming to the same protocol. Classes in unrelated branches of the inheritance hierarchy might be typed alike because they conform to the same protocol.</p><p>Protocols can play a significant role in object-oriented design, especially where a project is divided among many implementors or it incorporates objects developed in other projects. Cocoa software uses protocols heavily to support interprocess communication through Objective-C messages.</p><p>However, an Objective-C program doesn’t need to use protocols. Unlike class definitions and message expressions, they’re optional. Some Cocoa frameworks use them; some don’t. It all depends on the task at hand.</p><a name="//apple_ref/doc/uid/TP30001163-CH15-114029" title="Methods for Others to Implement"></a><a name="//apple_ref/doc/uid/TP30001163-CH15-TPXREF144" title="Methods for Others to Implement"></a><h2>Methods for Others to Implement</h2><p>If you know the class of an object, you can look at its interface declaration (and the interface declarations of the classes it inherits from) to find what messages it responds to. These declarations advertise the messages it can receive. Protocols provide a way for it to also advertise the messages it sends.</p><p>Communication works both ways; objects send messages as well as receive them. For example, an object might delegate responsibility for a certain operation to another object, or it may on occasion simply need to ask another object for information. In some cases, an object might be willing to notify other objects of its actions so that they can take whatever collateral measures might be required.</p><p>If you develop the class of the sender and the class of the receiver as part of the same project (or if someone else has supplied you with the receiver and its interface file), this communication is easily coordinated. The sender simply imports the interface file of the receiver. The imported file declares the method selectors the sender uses in the messages it sends.</p><p>However, if you develop an object that sends messages to objects that aren’t yet defined—objects that you’re leaving for others to implement—you won’t have the receiver’s interface file. You need another way to declare the methods you use in messages but don’t implement. A protocol serves this purpose. It informs the compiler about methods the class uses and also informs other implementors of the methods they need to define to have their objects work with yours.</p><p>Suppose, for example, that you develop an object that asks for the assistance of another object by sending it <code>helpOut:</code> and other messages. You provide an <code>assistant</code> instance variable to record the outlet for these messages and define a companion method to set the instance variable. This method lets other objects register themselves as potential recipients of your object’s messages:</p><div class="codesample"><table><tr><td scope="row"><pre>- setAssistant:anObject<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    assistant = anObject;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Then, whenever a message is to be sent to the <code>assistant</code>, a check is made to be sure that the receiver implements a method that can respond:</p><div class="codesample"><table><tr><td scope="row"><pre>- (BOOL)doWork<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( [assistant respondsToSelector:@selector(helpOut:)] ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        [assistant helpOut:self];<span></span></pre></td></tr><tr><td scope="row"><pre>        return YES;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return NO;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Since, at the time you write this code, you can’t know what kind of object might register itself as the <code>assistant</code>, you can only declare a protocol for the <code>helpOut:</code> method; you can’t import the interface file of the class that implements it.</p><a name="//apple_ref/doc/uid/TP30001163-CH15-114174" title="Declaring Interfaces for Anonymous Objects"></a><a name="//apple_ref/doc/uid/TP30001163-CH15-TPXREF145" title="Declaring Interfaces for Anonymous Objects"></a><h2>Declaring Interfaces for Anonymous Objects</h2><p>A protocol can be used to declare the methods of an <strong>anonymous object</strong><a name="//apple_ref/doc/uid/TP30001163-CH15-DontLinkElementID_381"></a><a name="//apple_ref/doc/uid/TP30001163-CH15-DontLinkElementID_382"></a>, an object of unknown class. An anonymous object may represent a service or handle a limited set of functions, especially where only one object of its kind is needed. (Objects that play a fundamental role in defining an application’s architecture and objects that you must initialize before using are not good candidates for anonymity.)</p><p>Objects are not anonymous to their developers, of course, but they are anonymous when the developer supplies them to someone else. For example, consider the following situations:</p><ul class="ul"><li class="li"><p>Someone who supplies a framework or a suite of objects for others to use can include objects that are not identified by a class name or an interface file. Lacking the name and class interface, users have no way of creating instances of the class. Instead, the supplier must provide a ready-made instance. Typically, a method in another class returns a usable object:</p><div class="codesample"><table><tr><td scope="row"><pre>id formatter = [receiver formattingService];<span></span></pre></td></tr></table></div><p>The object returned by the method is an object without a class identity, at least not one the supplier is willing to reveal. For it to be of any use at all, the supplier must be willing to identify at least some of the messages that it can respond to. This is done by associating the object with a list of methods declared in a protocol.</p></li><li class="li"><p>You can send Objective-C messages to <strong>remote objects</strong><a name="//apple_ref/doc/uid/TP30001163-CH15-DontLinkElementID_383"></a><a name="//apple_ref/doc/uid/TP30001163-CH15-DontLinkElementID_384"></a>—objects in other applications. (<span class="content_text"><a href="ocRemoteMessaging.html#//apple_ref/doc/uid/TP30001163-CH21-SW1" target="_self">Remote Messaging</a></span> in the <em><a href="../../ObjCRuntimeGuide/index.html#//apple_ref/doc/uid/TP40008048" target="_top">Objective-C 2.0 Runtime Programming Guide</a></em>, discusses this possibility in more detail.)</p><p>Each application has its own structure, classes, and internal logic. But you don’t need to know how another application works or what its components are to communicate with it. As an outsider, all you need to know is what messages you can send (the protocol) and where to send them (the receiver).</p><p>An application that publishes one of its objects as a potential receiver of remote messages must also publish a protocol declaring the methods the object will use to respond to those messages. It doesn’t have to disclose anything else about the object. The sending application doesn’t need to know the class of the object or use the class in its own design. All it needs is the protocol.</p></li></ul><p>Protocols make anonymous objects possible. Without a protocol, there would be no way to declare an interface to an object without identifying its class.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001163-CH15-SW4" title="Note"></a><p><strong>Note:</strong>&nbsp;Even though the supplier of an anonymous object doesn’t reveal its class, the object itself reveals it at runtime. A class message returns the anonymous object’s class. However, there’s usually little point in discovering this extra information; the information in the protocol is sufficient.</p></div><a name="//apple_ref/doc/uid/TP30001163-CH15-173878" title="Non-Hierarchical Similarities"></a><a name="//apple_ref/doc/uid/TP30001163-CH15-TPXREF146" title="Non-Hierarchical Similarities"></a><h2>Non-Hierarchical Similarities</h2><p>If more than one class implements a set of methods, those classes are often grouped under an abstract class<a name="//apple_ref/doc/uid/TP30001163-CH15-DontLinkElementID_385"></a> that declares the methods they have in common. Each subclass may re-implement the methods in its own way, but the inheritance hierarchy and the common declaration in the abstract class captures the essential similarity between the subclasses.</p><p>However, sometimes it’s not possible to group common methods in an abstract class. Classes that are unrelated in most respects might nevertheless need to implement some similar methods. This limited similarity may not justify a hierarchical relationship. For example, you might want to add support for creating XML representations of objects in your application and for initializing objects from an XML representation:</p><div class="codesample"><table><tr><td scope="row"><pre>- (NSXMLElement *)XMLRepresentation;<span></span></pre></td></tr><tr><td scope="row"><pre>- initFromXMLRepresentation:(NSXMLElement *)xmlString;<span></span></pre></td></tr></table></div><p>These methods could be grouped into a protocol and the similarity between implementing classes accounted for by noting that they all conform to the same protocol.</p><p>Objects can be typed by this similarity (the protocols they conform to), rather than by their class. For example, an <code>NSMatrix</code> instance must communicate with the objects that represent its cells. The matrix could require each of these objects to be a kind of <code>NSCell</code> (a type based on class) and rely on the fact that all objects that inherit from the <code>NSCell</code> class have the methods needed to respond to <code>NSMatrix</code> messages. Alternatively, the <code>NSMatrix</code> object could require objects representing cells to have methods that can respond to a particular set of messages (a type based on protocol). In this case, the <code>NSMatrix</code> object wouldn’t care what class a cell object belonged to, just that it implemented the methods.</p><a name="//apple_ref/doc/uid/TP30001163-CH15-114390" title="Formal Protocols"></a><a name="//apple_ref/doc/uid/TP30001163-CH15-TPXREF148" title="Formal Protocols"></a><h2>Formal Protocols</h2><a name="//apple_ref/doc/uid/TP30001163-CH15-DontLinkElementID_386"></a><a name="//apple_ref/doc/uid/TP30001163-CH15-DontLinkElementID_387"></a><p><a name="//apple_ref/doc/uid/TP30001163-CH15-DontLinkElementID_388"></a>The Objective-C language provides a way to formally declare a list of methods (including declared properties) as a protocol. Formal protocols are supported by the language and the runtime system. For example, the compiler can check for types based on protocols, and objects can introspect at runtime to report whether or not they conform to a protocol.</p><a name="//apple_ref/doc/uid/TP30001163-CH15-SW2" title="Declaring a Protocol"></a><h3>Declaring a Protocol</h3><p>You declare formal protocols with the <code>@protocol</code> directive:</p><div class="codesample"><table><tr><td scope="row"><pre>@protocol ProtocolName<span></span></pre></td></tr><tr><td scope="row"><pre>method declarations<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>For example, you could declare an XML representation protocol like this:</p><div class="codesample"><table><tr><td scope="row"><pre>@protocol MyXMLSupport<span></span></pre></td></tr><tr><td scope="row"><pre>- initFromXMLRepresentation:(NSXMLElement *)XMLElement;<span></span></pre></td></tr><tr><td scope="row"><pre>@property (nonatomic, readonly) (NSXMLElement *)XMLRepresentation;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>Unlike class names, protocol names don’t have global visibility. They live in their own namespace.</p><a name="//apple_ref/doc/uid/TP30001163-CH15-SW8" title="Optional Protocol Methods"></a><h3>Optional Protocol Methods</h3><p>Protocol methods can be marked as optional using the <code>@optional</code> keyword. Corresponding to the <code>@optional</code> modal keyword, there is a <code>@required</code> keyword to formally denote the semantics of the default behavior. You can use <code>@optional</code> and <code>@required</code> to partition your protocol into sections as you see fit. If you do not specify any keyword, the default is <code>@required</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>@protocol MyProtocol<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)requiredMethod;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@optional<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)anOptionalMethod;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)anotherOptionalMethod;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@required<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)anotherRequiredMethod;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP30001163-CH15-SW5" title="Note"></a><p><strong>Note:</strong>&nbsp;On Mac OS X v10.5, protocols may not include optional declared properties.</p></div><a name="//apple_ref/doc/uid/TP30001163-CH15-114323" title="Informal Protocols "></a><a name="//apple_ref/doc/uid/TP30001163-CH15-TPXREF147" title="Informal Protocols "></a><h2>Informal Protocols </h2><a name="//apple_ref/doc/uid/TP30001163-CH15-DontLinkElementID_389"></a><a name="//apple_ref/doc/uid/TP30001163-CH15-DontLinkElementID_390"></a><a name="//apple_ref/doc/uid/TP30001163-CH15-DontLinkElementID_391"></a><p>In addition to formal protocols, you can also define an <strong>informal</strong> protocol by grouping the methods in a category<a name="//apple_ref/doc/uid/TP30001163-CH15-DontLinkElementID_392"></a> declaration:</p><div class="codesample"><table><tr><td scope="row"><pre>@interface NSObject ( MyXMLSupport )<span></span></pre></td></tr><tr><td scope="row"><pre>- initFromXMLRepresentation:(NSXMLElement *)XMLElement;<span></span></pre></td></tr><tr><td scope="row"><pre>@property (nonatomic, readonly) (NSXMLElement *)XMLRepresentation;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>Informal protocols are typically declared as categories<a name="//apple_ref/doc/uid/TP30001163-CH15-DontLinkElementID_393"></a> of the <code>NSObject</code> class, since that broadly associates the method names with any class that inherits from <code>NSObject</code>. Because all classes inherit from the root class, the methods aren’t restricted to any part of the inheritance hierarchy. (It would also be possible to declare an informal protocol as a category of another class to limit it to a certain branch of the inheritance hierarchy, but there is little reason to do so.)</p><p>When used to declare a protocol, a category interface doesn’t have a corresponding implementation. Instead, classes that implement the protocol declare the methods again in their own interface files and define them along with other methods in their implementation files.</p><p>An informal protocol bends the rules of category declarations to list a group of methods but not associate them with any particular class or implementation.</p><p>Being informal, protocols declared in categories don’t receive much language support. There’s no type checking at compile time nor a check at runtime to see whether an object conforms to the protocol. To get these benefits, you must use a formal protocol. An informal protocol may be useful when all the methods are optional, such as for a delegate, but (on Mac OS X v10.5 and later) it is typically better to use a formal protocol with optional methods.</p><a name="//apple_ref/doc/uid/TP30001163-CH15-114567" title="Protocol Objects"></a><a name="//apple_ref/doc/uid/TP30001163-CH15-TPXREF149" title="Protocol Objects"></a><h2>Protocol Objects</h2><a name="//apple_ref/doc/uid/TP30001163-CH15-DontLinkElementID_394"></a><p>Just as classes are represented at runtime by class objects and methods by selector codes, formal protocols are represented by a special data type—instances of the Protocol<a name="//apple_ref/doc/uid/TP30001163-CH15-DontLinkElementID_395"></a> class. Source code that deals with a protocol (other than to use it in a type specification) must refer to the Protocol object.</p><p>In many ways, protocols are similar to class definitions. They both declare methods, and at runtime they’re both represented by objects—classes by class objects and protocols by Protocol objects. Like class objects, Protocol objects are created automatically from the definitions and declarations found in source code and are used by the runtime system. They’re not allocated and initialized in program source code.</p><p>Source code can refer to a Protocol object using the <code>@protocol()</code> directive—the same directive that declares a protocol, except that here it has a set of trailing parentheses. The parentheses enclose the protocol name:</p><div class="codesample"><table><tr><td scope="row"><pre>Protocol *myXMLSupportProtocol = @protocol(MyXMLSupport);<span></span></pre></td></tr></table></div><p>This is the only way that source code can conjure up a Protocol object. Unlike a class name, a protocol name doesn’t designate the object—except inside <code>@protocol()</code>.</p><p>The compiler creates a Protocol object for each protocol declaration it encounters, but only if the protocol is also: </p><ul class="ul"><li class="li"><p>Adopted by a class, or</p></li><li class="li"><p>Referred to somewhere in source code (using <code>@protocol()</code>)</p></li></ul><p>Protocols that are declared but not used (except for type checking as described below) aren’t represented by Protocol objects at runtime.</p><a name="//apple_ref/doc/uid/TP30001163-CH15-SW3" title="Adopting a Protocol"></a><h2>Adopting a Protocol</h2><p>Adopting a protocol is similar in some ways to declaring a superclass. Both assign methods to the class. The superclass declaration assigns it inherited methods; the protocol assigns it methods declared in the protocol list. A class is said to <strong>adopt</strong><a name="//apple_ref/doc/uid/TP30001163-CH15-DontLinkElementID_396"></a> a formal protocol if in its declaration it lists the protocol within angle brackets after the superclass name:</p><div class="codesample"><table><tr><td scope="row"><pre>@interface ClassName : ItsSuperclass &lt; protocol list ><span></span></pre></td></tr></table></div><p>Categories adopt protocols in much the same way:</p><div class="codesample"><table><tr><td scope="row"><pre>@interface ClassName ( CategoryName ) &lt; protocol list ><span></span></pre></td></tr></table></div><p>A class can adopt more than one protocol; names in the protocol list are separated by commas.</p><div class="codesample"><table><tr><td scope="row"><pre>@interface Formatter : NSObject &lt; Formatting, Prettifying ><span></span></pre></td></tr></table></div><p>A class or category that adopts a protocol must implement all the required methods the protocol declares, otherwise the compiler issues a warning. The Formatter class above would define all the required methods declared in the two protocols it adopts, in addition to any it might have declared itself. </p><p>A class or category that adopts a protocol must import the header file where the protocol is declared. The methods declared in the adopted protocol are not declared elsewhere in the class or category interface.</p><p>It’s possible for a class to simply adopt protocols and declare no other methods. For example, the following class declaration adopts the Formatting and Prettifying protocols, but declares no instance variables or methods of its own:</p><div class="codesample"><table><tr><td scope="row"><pre>@interface Formatter : NSObject &lt; Formatting, Prettifying ><span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30001163-CH15-114645" title="Conforming to a Protocol"></a><a name="//apple_ref/doc/uid/TP30001163-CH15-TPXREF150" title="Conforming to a Protocol"></a><h2>Conforming to a Protocol</h2><a name="//apple_ref/doc/uid/TP30001163-CH15-DontLinkElementID_397"></a><p>A class is said to <strong>conform</strong> to a formal protocol if it adopts the protocol or inherits from another class that adopts it. An instance of a class is said to conform to the same set of protocols its class conforms to.</p><p>Since a class must implement all the required methods declared in the protocols it adopts, saying that a class or an instance conforms to a protocol is equivalent to saying that it has in its repertoire all the methods the protocol declares.</p><p>It’s possible to check whether an object conforms to a protocol by sending it a <code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/conformsToProtocol:" target="_top">conformsToProtocol:</a></code> message.</p><div class="codesample"><table><tr><td scope="row"><pre>if ( ! [receiver conformsToProtocol:@protocol(MyXMLSupport)]  ) {<span></span></pre></td></tr><tr><td scope="row"><pre>    // Object does not conform to MyXMLSupport protocol<span></span></pre></td></tr><tr><td scope="row"><pre>    // If you are expecting receiver to implement methods declared in the<span></span></pre></td></tr><tr><td scope="row"><pre>    //  MyXMLSupport protocol, this is probably an error<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>(Note that there is also a class method with the same name—<code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/clm/NSObject/conformsToProtocol:" target="_top">conformsToProtocol:</a></code>.)</p><p>The <code>conformsToProtocol:</code> test is like the <code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/respondsToSelector:" target="_top">respondsToSelector:</a></code> test for a single method, except that it tests whether a protocol has been adopted (and presumably all the methods it declares implemented) rather than just whether one particular method has been implemented. Because it checks for all the methods in the protocol, <code>conformsToProtocol:</code> can be more efficient than <code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/respondsToSelector:" target="_top">respondsToSelector:</a></code>.</p><p>The <code>conformsToProtocol:</code> test is also like the <code>isKindOfClass:</code> test, except that it tests for a type based on a protocol rather than a type based on the inheritance hierarchy.</p><a name="//apple_ref/doc/uid/TP30001163-CH15-114729" title="Type Checking"></a><a name="//apple_ref/doc/uid/TP30001163-CH15-TPXREF151" title="Type Checking"></a><h2>Type Checking</h2><a name="//apple_ref/doc/uid/TP30001163-CH15-DontLinkElementID_398"></a><p>Type declarations for objects can be extended to include formal protocols<a name="//apple_ref/doc/uid/TP30001163-CH15-DontLinkElementID_399"></a>. Protocols thus offer the possibility of another level of type checking by the compiler, one that’s more abstract since it’s not tied to particular implementations.</p><p>In a type declaration, protocol names are listed between angle brackets after the type name:</p><div class="codesample"><table><tr><td scope="row"><pre>- (id &lt;Formatting>)formattingService;<span></span></pre></td></tr><tr><td scope="row"><pre>id &lt;MyXMLSupport> anObject;<span></span></pre></td></tr></table></div><p>Just as static typing permits the compiler to test for a type based on the class hierarchy, this syntax permits the compiler to test for a type based on conformance to a protocol.</p><p>For example, if Formatter is an abstract class, this declaration</p><div class="codesample"><table><tr><td scope="row"><pre>Formatter *anObject;<span></span></pre></td></tr></table></div><p>groups all objects that inherit from Formatter into a type and permits the compiler to check assignments against that type.</p><p>Similarly, this declaration,</p><div class="codesample"><table><tr><td scope="row"><pre>id &lt;Formatting> anObject;<span></span></pre></td></tr></table></div><p>groups all objects that conform to the Formatting protocol into a type, regardless of their positions in the class hierarchy. The compiler can make sure only objects that conform to the protocol are assigned to the type.</p><p>In each case, the type groups similar objects—either because they share a common inheritance, or because they converge on a common set of methods.</p><p>The two types can be combined in a single declaration:</p><div class="codesample"><table><tr><td scope="row"><pre>Formatter &lt;Formatting> *anObject;<span></span></pre></td></tr></table></div><p>Protocols can’t be used to type class objects. Only instances can be statically typed to a protocol, just as only instances can be statically typed to a class. (However, at runtime, both classes and instances will respond to a <code>conformsToProtocol:</code> message.)</p><a name="//apple_ref/doc/uid/TP30001163-CH15-114849" title="Protocols Within Protocols"></a><a name="//apple_ref/doc/uid/TP30001163-CH15-TPXREF152" title="Protocols Within Protocols"></a><h2>Protocols Within Protocols</h2><p><a name="//apple_ref/doc/uid/TP30001163-CH15-DontLinkElementID_400"></a>One protocol can incorporate other protocols using the same syntax that classes use to adopt<a name="//apple_ref/doc/uid/TP30001163-CH15-DontLinkElementID_401"></a> a protocol:</p><div class="codesample"><table><tr><td scope="row"><pre>@protocol ProtocolName &lt; protocol list ><span></span></pre></td></tr></table></div><p>All the protocols listed between angle brackets are considered part of the <em>ProtocolName</em> protocol. For example, if the Paging protocol incorporates the Formatting protocol,</p><div class="codesample"><table><tr><td scope="row"><pre>@protocol Paging &lt; Formatting ><span></span></pre></td></tr></table></div><p>any object that conforms<a name="//apple_ref/doc/uid/TP30001163-CH15-DontLinkElementID_402"></a> to the Paging protocol also conforms to Formatting. Type declarations</p><div class="codesample"><table><tr><td scope="row"><pre>id &lt;Paging> someObject;<span></span></pre></td></tr></table></div><p>and <code>conformsToProtocol:</code> messages</p><div class="codesample"><table><tr><td scope="row"><pre>if ( [anotherObject conformsToProtocol:@protocol(Paging)] )<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr></table></div><p>need to mention only the Paging protocol to test for conformance to Formatting as well.</p><p>When a class adopts a protocol, it must implement the required methods the protocol declares, as mentioned earlier. In addition, it must conform to any protocols the adopted protocol incorporates. If an incorporated protocol incorporates still other protocols, the class must also conform to them. A class can conform to an incorporated protocol by either:</p><ul class="ul"><li class="li"><p>Implementing the methods the protocol declares, or</p></li><li class="li"><p>Inheriting from a class that adopts the protocol and implements the methods.</p></li></ul><p>Suppose, for example, that the Pager class adopts the Paging protocol. If Pager is a subclass of <code>NSObject</code>, </p><div class="codesample"><table><tr><td scope="row"><pre>@interface Pager : NSObject &lt; Paging ><span></span></pre></td></tr></table></div><p>it must implement all the Paging methods, including those declared in the incorporated Formatting protocol. It adopts the Formatting protocol along with Paging.</p><p>On the other hand, if Pager is a subclass of Formatter (a class that independently adopts the Formatting protocol),</p><div class="codesample"><table><tr><td scope="row"><pre>@interface Pager : Formatter &lt; Paging ><span></span></pre></td></tr></table></div><p>it must implement all the methods declared in the Paging protocol proper, but not those declared in Formatting. Pager inherits conformance to the Formatting protocol from Formatter.</p><p>Note that a class can conform to a protocol without formally adopting it simply by implementing the methods declared in the protocol.<a name="//apple_ref/doc/uid/TP30001163-CH15-DontLinkElementID_403"></a></p><a name="//apple_ref/doc/uid/TP30001163-CH15-115018" title="Referring to Other Protocols"></a><a name="//apple_ref/doc/uid/TP30001163-CH15-TPXREF153" title="Referring to Other Protocols"></a><h2>Referring to Other Protocols</h2><p>When working on complex applications, you occasionally find yourself writing code that looks like this:</p><div class="codesample"><table><tr><td scope="row"><pre>#import "B.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@protocol A<span></span></pre></td></tr><tr><td scope="row"><pre>- foo:(id &lt;B>)anObject;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>where protocol B is declared like this:</p><div class="codesample"><table><tr><td scope="row"><pre>#import "A.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@protocol B<span></span></pre></td></tr><tr><td scope="row"><pre>- bar:(id &lt;A>)anObject;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>In such a situation, circularity results and neither file will compile correctly. To break this recursive cycle, you must use the <code>@protocol</code><a name="//apple_ref/doc/uid/TP30001163-CH15-DontLinkElementID_404"></a><a name="//apple_ref/doc/uid/TP30001163-CH15-DontLinkElementID_405"></a> directive to make a forward reference<a name="//apple_ref/doc/uid/TP30001163-CH15-DontLinkElementID_406"></a> to the needed protocol instead of importing the interface file where the protocol is defined. The following code excerpt illustrates how you would do this:</p><div class="codesample"><table><tr><td scope="row"><pre>@protocol B;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@protocol A<span></span></pre></td></tr><tr><td scope="row"><pre>- foo:(id &lt;B>)anObject;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>Note that using the <code>@protocol</code> directive in this manner simply informs the compiler that “B” is a protocol to be defined later. It doesn’t import the interface file where protocol B is defined.<a name="//apple_ref/doc/uid/TP30001163-CH15-DontLinkElementID_407"></a><a name="//apple_ref/doc/uid/TP30001163-CH15-DontLinkElementID_408"></a></p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="ocCategories.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="ocFastEnumeration.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-05-06<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/ObjectiveC/Articles/ocProtocols.html%3Fid%3DTP30001163-4.9&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/ObjectiveC/Articles/ocProtocols.html%3Fid%3DTP30001163-4.9&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/ObjectiveC/Articles/ocProtocols.html%3Fid%3DTP30001163-4.9&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>