<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>GetZoneList - /UFailure.h</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">GetZoneList</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/index.html" target="_blank">Reference Library</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">GetZoneList</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/UFailure.h</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/GetZoneList.c</option>
<option value="listing2.html">/GetZoneList.p</option>
<option value="listing3.html">/GetZoneList.r</option>
<option value="listing4.html">/UFailure.a</option>
<option value="listing5.html">/UFailure.h</option>
<option value="listing6.html">/UFailure.inc1.p</option>
<option value="listing7.html">/UFailure.p</option></select>
				</p>
				</form>
				<p><strong><a href="GetZoneList.zip">Download Sample</a></strong> (&#147;GetZoneList.zip&#148;, 47.2K)<BR>
<strong><a href="GetZoneList.dmg">Download Sample</a></strong> (&#147;GetZoneList.dmg&#148;, 104.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*------------------------------------------------------------------------------##  Apple Macintosh Developer Technical Support##  Exception handling for MPW Pascal, MacApp and MPW C##  UFailure (aka Signals) - &quot;Exceptional code, with a few exceptions.&quot;##  UFailure.h  -  C header##  Copyright &copy; 1985-1988 Apple Computer, Inc.#  All rights reserved.##  Versions:  1.0          11/88##  Components:  UFailure.p      November 1, 1988#        UFailure.h      November 1, 1988#        UFailure.inc1.p    November 1, 1988#        UFailure.a      November 1, 1988#        TestCignal.c    November 1, 1988#        TestCignal.make    November 1, 1988#        TestSignal.p    November 1, 1988#        TestSignal.make    November 1, 1988##  UFailure (or Signals) is a set of exception handling routines suitable for#  use with MacApp, MPW C, and MPW Pascal. It is a jazzed-up version of the MacApp#  UFailure unit. There is a set of C interfaces to it as well.#------------------------------------------------------------------------------*//*Theory:  See the &quot;theory of operation&quot; comments below, and the commentary in Technical  Note #88.  *** New ***  The warnings in technote 88 about not using CatchSignal in an expression, etc. no  longer apply. The exact state of the routine is now restored (all non-scratch  registers are preserved). Also, a fixed-size nonrelocatable block is now used, so  there is a limit on the depth of nested CatchSignals. This may be adjusted by  changing the constant SigBlockSize in UFailure.a and rebuilding the unit. For most  applications, though, the default depth of eight will be more than sufficient.  Note:  *** There is a special c version of CatchFailures called CatchCFailures. If you use it  you will be required to call FreeSignal or Success explicitly (as with CatchFailures in  Pascal). There is no c version of CatchFailures because c doesn't support the concept  of nested procedures. CatchCFailures provides the same functionality. ***  *** You can use either the technote mechanism or the MacApp one in your program. It  is OK to call Signal if CatchFailures was used, and OK to call Failure if  CatchSignal was used, i.e. the two schemes may be freely intermixed. ***  What this version adds to the MacApp mechanism is two things:    1.      Exception records (FailInfo) are taken from a special heap block when      you use CatchSignal, so you don't have to pass a FailInfo record as a      parameter.    2.      You can take advantage of stack frames and use of Signals as described      in Technical Note #88, without being forced to make explicit calls to      FreeSignal. This unit is fully upwards compatible with the 1986 version      of the technote.  This includes all of the MacApp calls from the original UFailure, of course.          T H E O R Y   O F   O P E R A T I O N  This unit implements the MacApp and Signal failure mechanisms.  The failure mechanism is built around exception handlers.  An exception  handler is a piece of code, generally local to some other routine, that is  called when a failure occurs and takes action to handle the failure.  An exception handler is of the form    PROCEDURE ExceptionHandler (error: OSErr; message: LONGINT);                  or    the handler may consist of execution returning to the point of a    CatchSignal  where error is the error that caused the failure, and message identifies  the error message that may be displayed.  Consider a routine that opens  a file, reads its contents, and closes the file.  If a failure occured  while reading the file, an exception handler would be needed to close the  file, as the rest of the routine would not be executed.  (See TestCignal  and TestSignal for examples of how to use these calls.)  References to exception handlers are kept in the FailInfo record. The  exception handlers form a linked-list via the nextInfo field of FailInfo.  The linked list is a stack since new exception handlers are added to the  front of the list.  New exception handlers are added to the stack with the CatchSignal  function or CatchFailures procedure. They are removed from the stack  automatically (CatchSignal) or via the Success procedure (if CatchFailures  was used). In general you call CatchFailures/CatchSignal to post an exception  handler when an error the application should handle might occur. You  can then manually pop the last handler off the stack with FreeSignal or  Success, if necessary. You may want to pop the handler (even if you used  CatchSignal) after the possibility of a specific type of error no longer  exists. Subsequent exceptions would then be passed to a previous (more  general) handler.  Any failure detected within the limits of the CatchFailures/CatchSignal call  results in the execution of the exception handler.  (Failure does  not have to occur in the same routine as your call to CatchFailures.  The failure may occur in any routine called after the catch but before the  implicit/explicit pop of the handler.)  When MacApp (or your code) determines that a failure has occured, it  calls Failure or Signal.  As a convenience, several procedures are provided  to check for standard kinds of failures and call Failure if needed.  These procedures are:    FailNIL      Calls Failure if its parameter is NIL.    FailOSErr    Calls Failure if its parameter is not noErr.    FailMemError  Calls Failure if MemError returns other than noErr.    FailResError  Calls Failure if ResError returns other than noErr.  When the exception is raised, execution of the routine that signalled is  terminated and the exception handler at the top of the stack is popped.  For each routine that was called after the handler was posted  to the stack, execution is terminated as though from an EXIT statement,  and the exception handler is called.  It generally cleans up for the  routine in which it is nested.  Upon completion the next exception handler  is popped from the stack, repeating the process.  The error causing the failure, and a message code is passed to the handler.  MacApp Specifics  For MacApp, the last exception handler on the stack is the one in  TApplication.PollEvent.  It calls TApplication.ShowError, which calls  ErrorAlert, which decodes the message and displays an alert.  Your exception  handlers may set the message code to one more specific to your application  by calling FailNewMessage at the end of your exception handler.  FailNewMessage changes the message only if the current one is non-zero.  This has the effect of allowing those exception handlers closest to the  source of the error to set the message.  One last note about exception handlers:  It is possible for an exception  handler to terminate exception processing by using a non-local GOTO to  jump back into the routine in which the exception handler is nested.  This  is how MacApp keeps the application running when a failure occurs.  The  last exception handler on the stack, in TApplication.PollEvent, uses a  GOTO to continue event processing.*/typedef struct {  long      regs[11];      /* D3-D7/A2-A7 */  short      error;  long      message;  long      failA6;  long      failPC;  Ptr        nextInfo;  /* this is needed for compatibility with MacApp debugging */  long      whoPC;  /* these are added for USignalFailure unit use */  short      whatSignals;  /* this is used to keep the old stack frame return address */  long      sigFRet;} FailInfo, *PFailInfo;typedef pascal void (*HandlerFuncPtr)(short error, long message);/* Call the following initialization routine before your other initializations (InitGraf, etc.)- in other words as early as you can in the application. */extern pascal void InitUFailure();  /* Allocates the heap block for CatchSignals and initializes the global    variables used by the unit. C programs must use this instead of InitSignals. */extern pascal short CatchSignal();  /* Until the function which encloses this call returns, this will catch    subsequent Signal calls, returning the code passed to Signal.  When    CatchSignal is encountered initially, it returns a code of zero.  These    calls may &quot;nest&quot;; i.e. you may have multiple CatchSignals in one function.    Each nested CatchSignal call uses 72 bytes of heap space.    If you signal with Failure and pass in a non-zero message you should use    CatchCFailures instead so you have a way of getting at the message. */extern pascal void FreeSignal();  /* This undoes the effect of the last CatchSignal/CatchFailures.  A Signal will then invoke    the CatchSignal prior to the last one. */extern pascal void Signal(short code);  /* Returns control to the point of the last CatchSignal/CatchFailures.  The program will    then behave as though that CatchSignal had returned with the code parameter    supplied to Signal. If CatchCFailures is catching, the message parameter will be 0. */extern pascal void SignalMessage(short code, long message);  /* Returns control to the point of the last CatchSignal. If CatchCFailures is catching,    the message parameter will be returned. *//*------------------------------------+|  MacApp routines          |+------------------------------------*/pascal long  BuildMessage(short lowWord, short highWord)      = 0x2E9F;  /*  MOVE.L    (A7)+,(A7)   */  /* Takes the 2 integers and combines them into a LONGINT.  Note that the    low-order word is the first parameter. */extern pascal void CatchCFailures(FailInfo *fi, HandlerFuncPtr handler);  /* Call this to set up an exception handler. This pushes your handler onto    a stack of exception handlers. */extern pascal void Failure(short error, long message);  /* Call this to signal a failure.  Control will branch to the most recent    exception handler, which will be popped off the handler stack. */extern pascal void FailMemError();  /* If MemError != noErr then call Failure(MemError, 0);  If you are using    assembler, then you should just test the return code from the Memory    Manager in DO by calling FailOSErr.  (See the discussion of MemError in    Inside Macintosh.) */extern pascal void FailResError();  /* If ResError != noErr then call Failure(ResError, 0); (See Inside Macintosh.) */extern pascal void FailNewMessage(short error, long oldMessage, long newMessage);  /* This does:    if (oldMessage == 0)      Failure(error, newMessage);    else      Failure(error, oldMessage);   */extern pascal void FailNIL(Ptr p);  /* Call this with a pointer/handle; this signals Failure(memFullErr, 0) iff    the pointer is nil. */extern pascal void FailOSErr(short error);  /* Call this with an OSError; signals Failure(error, 0) iff error != noErr. */extern pascal void Success(FailInfo *fi);  /* Call this when you want to de-install your exception handler (pop 1    element off the handler stack). */</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/GetZoneList/listing5.html%3Fid%3DDTS10000237-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/GetZoneList/listing5.html%3Fid%3DDTS10000237-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/GetZoneList/listing5.html%3Fid%3DDTS10000237-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>