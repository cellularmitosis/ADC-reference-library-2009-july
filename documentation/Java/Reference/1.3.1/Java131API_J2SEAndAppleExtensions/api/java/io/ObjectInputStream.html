
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Thu Jul 18 01:51:23 PDT 2002 -->
<TITLE>
Java 2 Platform SE v1.3.1: Class  ObjectInputStream
</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">
</HEAD>
<BODY BGCOLOR="white">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ObjectInputStream.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Std.&nbsp;Ed. v1.3.1</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/io/LineNumberReader.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../java/io/ObjectInputStream.GetField.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="ObjectInputStream.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;<A HREF="#inner_class_summary">INNER</A>&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.io</FONT>
<BR>
Class  ObjectInputStream</H2>
<PRE>
<A HREF="../../java/lang/Object.html">java.lang.Object</A>
  |
  +--<A HREF="../../java/io/InputStream.html">java.io.InputStream</A>
        |
        +--<B>java.io.ObjectInputStream</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD><A HREF="../../java/io/DataInput.html">DataInput</A>, <A HREF="../../java/io/ObjectInput.html">ObjectInput</A>, <A HREF="../../java/io/ObjectStreamConstants.html">ObjectStreamConstants</A></DD>
</DL>
<HR>
<DL>
<DT>public class <B>ObjectInputStream</B><DT>extends <A HREF="../../java/io/InputStream.html">InputStream</A><DT>implements <A HREF="../../java/io/ObjectInput.html">ObjectInput</A>, <A HREF="../../java/io/ObjectStreamConstants.html">ObjectStreamConstants</A></DL>

<P>
An ObjectInputStream deserializes primitive data and objects previously
 written using an ObjectOutputStream.
 
 ObjectOutputStream and ObjectInputStream can provide an application
 with persistent storage for graphs of objects when used with a
 FileOutputStream and FileInputStream respectively.
 ObjectInputStream is used to recover those objects previously
 serialized. Other uses include passing objects between hosts using
 a socket stream or for marshaling and unmarshaling arguments and
 parameters in a remote communication system.<p>

 ObjectInputStream ensures that the types of all objects in the
 graph created from the stream match the classes present in the
 Java Virtual Machine.  Classes are loaded as required using the
 standard mechanisms. <p>

 Only objects that support the java.io.Serializable or
 java.io.Externalizable interface can be read from streams.

 The method <STRONG>readObject</STRONG> is used to read an object
 from the stream.  Java's safe casting should be used to get the
 desired type.  In Java, strings and arrays are objects and are
 treated as objects during serialization. When read they need to be
 cast to the expected type.<p>

 Primitive data types can be read from the stream using the appropriate
 method on DataInput. <p>
 
 The default deserialization mechanism for objects restores the
 contents of each field to the value and type it had when it was written.
 Fields declared as transient or static are ignored by the
 deserialization process.  References to other objects cause those
 objects to be read from the stream as necessary.  Graphs of objects
 are restored correctly using a reference sharing mechanism.  New
 objects are always allocated when deserializing, which prevents
 existing objects from being overwritten. <p>

 Reading an object is analogous to running the constructors of a new
 object.  Memory is allocated for the object and initialized to zero
 (NULL).  No-arg constructors are invoked for the non-serializable
 classes and then the fields of the serializable classes are
 restored from the stream starting with the serializable class closest to
 java.lang.object and finishing with the object's most specifiec
 class. <p>

 For example to read from a stream as written by the example in
 ObjectOutputStream: <br>

 <PRE>
	FileInputStream istream = new FileInputStream("t.tmp");
	ObjectInputStream p = new ObjectInputStream(istream);

	int i = p.readInt();
	String today = (String)p.readObject();
	Date date = (Date)p.readObject();

	istream.close();
 </PRE>

 Classes control how they are serialized by implementing either the
 java.io.Serializable or java.io.Externalizable interfaces.<P>

 Implementing the Serializable interface allows object serialization
 to save and restore the entire state of the object and it allows
 classes to evolve between the time the stream is written and the time it is
 read.  It automatically traverses references between objects,
 saving and restoring entire graphs.

 Serializable classes that require special handling during the
 serialization and deserialization process should implement both
 of these methods:<p>

 <PRE>
 private void writeObject(java.io.ObjectOutputStream stream)
     throws IOException;
 private void readObject(java.io.ObjectInputStream stream)
     throws IOException, ClassNotFoundException; 
 </PRE><p>

 The readObject method is responsible for reading and restoring the
 state of the object for its particular class using data written to
 the stream by the corresponding writeObject method.  The method
 does not need to concern itself with the state belonging to its
 superclasses or subclasses.  State is restored by reading data from
 the ObjectInputStream for the individual fields and making
 assignments to the appropriate fields of the object.  Reading
 primitive data types is supported by DataInput. <p>

 Serialization does not read or assign values to the fields of any
 object that does not implement the java.io.Serializable interface.
 Subclasses of Objects that are not serializable can be
 serializable. In this case the non-serializable class must have a
 no-arg constructor to allow its fields to be initialized.  In this
 case it is the responsibility of the subclass to save and restore
 the state of the non-serializable class. It is frequently the case that
 the fields of that class are accessible (public, package, or
 protected) or that there are get and set methods that can be used
 to restore the state. <p>

 Any exception that occurs while deserializing an object will be
 caught by the ObjectInputStream and abort the reading process. <p>

 Implementing the Externalizable interface allows the object to
 assume complete control over the contents and format of the object's
 serialized form.  The methods of the Externalizable interface,
 writeExternal and readExternal, are called to save and restore the
 objects state.  When implemented by a class they can write and read
 their own state using all of the methods of ObjectOutput and
 ObjectInput.  It is the responsibility of the objects to handle any
 versioning that occurs.
<P>
<DL>
<DT><B>Since: </B><DD>JDK1.1</DD>
<DT><B>See Also: </B><DD><A HREF="../../java/io/DataInput.html"><CODE>DataInput</CODE></A>, 
<A HREF="../../java/io/ObjectOutputStream.html"><CODE>ObjectOutputStream</CODE></A>, 
<A HREF="../../java/io/Serializable.html"><CODE>Serializable</CODE></A>, 
<a href="../../../guide/serialization/spec/input.doc.html"> Object Serialization Specification, Section 3, Object Input Classes</a></DL>
<HR>

<P>
<!-- ======== INNER CLASS SUMMARY ======== -->

<A NAME="inner_class_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Inner Class Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.GetField.html">ObjectInputStream.GetField</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Provide access to the persistent fields read from the input stream.</TD>
</TR>
</TABLE>
&nbsp;
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="fields_inherited_from_class_java.io.ObjectStreamConstants"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Fields inherited from interface java.io.<A HREF="../../java/io/ObjectStreamConstants.html">ObjectStreamConstants</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/io/ObjectStreamConstants.html#baseWireHandle">baseWireHandle</A>, <A HREF="../../java/io/ObjectStreamConstants.html#PROTOCOL_VERSION_1">PROTOCOL_VERSION_1</A>, <A HREF="../../java/io/ObjectStreamConstants.html#PROTOCOL_VERSION_2">PROTOCOL_VERSION_2</A>, <A HREF="../../java/io/ObjectStreamConstants.html#SC_BLOCK_DATA">SC_BLOCK_DATA</A>, <A HREF="../../java/io/ObjectStreamConstants.html#SC_EXTERNALIZABLE">SC_EXTERNALIZABLE</A>, <A HREF="../../java/io/ObjectStreamConstants.html#SC_SERIALIZABLE">SC_SERIALIZABLE</A>, <A HREF="../../java/io/ObjectStreamConstants.html#SC_WRITE_METHOD">SC_WRITE_METHOD</A>, <A HREF="../../java/io/ObjectStreamConstants.html#STREAM_MAGIC">STREAM_MAGIC</A>, <A HREF="../../java/io/ObjectStreamConstants.html#STREAM_VERSION">STREAM_VERSION</A>, <A HREF="../../java/io/ObjectStreamConstants.html#SUBCLASS_IMPLEMENTATION_PERMISSION">SUBCLASS_IMPLEMENTATION_PERMISSION</A>, <A HREF="../../java/io/ObjectStreamConstants.html#SUBSTITUTION_PERMISSION">SUBSTITUTION_PERMISSION</A>, <A HREF="../../java/io/ObjectStreamConstants.html#TC_ARRAY">TC_ARRAY</A>, <A HREF="../../java/io/ObjectStreamConstants.html#TC_BASE">TC_BASE</A>, <A HREF="../../java/io/ObjectStreamConstants.html#TC_BLOCKDATA">TC_BLOCKDATA</A>, <A HREF="../../java/io/ObjectStreamConstants.html#TC_BLOCKDATALONG">TC_BLOCKDATALONG</A>, <A HREF="../../java/io/ObjectStreamConstants.html#TC_CLASS">TC_CLASS</A>, <A HREF="../../java/io/ObjectStreamConstants.html#TC_CLASSDESC">TC_CLASSDESC</A>, <A HREF="../../java/io/ObjectStreamConstants.html#TC_ENDBLOCKDATA">TC_ENDBLOCKDATA</A>, <A HREF="../../java/io/ObjectStreamConstants.html#TC_EXCEPTION">TC_EXCEPTION</A>, <A HREF="../../java/io/ObjectStreamConstants.html#TC_LONGSTRING">TC_LONGSTRING</A>, <A HREF="../../java/io/ObjectStreamConstants.html#TC_MAX">TC_MAX</A>, <A HREF="../../java/io/ObjectStreamConstants.html#TC_NULL">TC_NULL</A>, <A HREF="../../java/io/ObjectStreamConstants.html#TC_OBJECT">TC_OBJECT</A>, <A HREF="../../java/io/ObjectStreamConstants.html#TC_PROXYCLASSDESC">TC_PROXYCLASSDESC</A>, <A HREF="../../java/io/ObjectStreamConstants.html#TC_REFERENCE">TC_REFERENCE</A>, <A HREF="../../java/io/ObjectStreamConstants.html#TC_RESET">TC_RESET</A>, <A HREF="../../java/io/ObjectStreamConstants.html#TC_STRING">TC_STRING</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#ObjectInputStream()">ObjectInputStream</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Provide a way for subclasses that are completely reimplementing
 ObjectInputStream to not have to allocate private data just used by
 this implementation of ObjectInputStream.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#ObjectInputStream(java.io.InputStream)">ObjectInputStream</A></B>(<A HREF="../../java/io/InputStream.html">InputStream</A>&nbsp;in)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create an ObjectInputStream that reads from the specified InputStream.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#available()">available</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of bytes that can be read without blocking.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#close()">close</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Closes the input stream.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#defaultReadObject()">defaultReadObject</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Read the non-static and non-transient fields of the current class
 from this stream.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#enableResolveObject(boolean)">enableResolveObject</A></B>(boolean&nbsp;enable)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enable the stream to allow objects read from the stream to be replaced.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#read()">read</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reads a byte of data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#read(byte[], int, int)">read</A></B>(byte[]&nbsp;b,
     int&nbsp;off,
     int&nbsp;len)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reads into an array of bytes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readBoolean()">readBoolean</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reads in a boolean.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readByte()">readByte</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reads an 8 bit byte.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readChar()">readChar</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reads a 16 bit char.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/io/ObjectStreamClass.html">ObjectStreamClass</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readClassDescriptor()">readClassDescriptor</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Read a class descriptor from the serialization stream.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readDouble()">readDouble</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reads a 64 bit double.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/io/ObjectInputStream.GetField.html">ObjectInputStream.GetField</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readFields()">readFields</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reads the persistent fields from the stream and makes them 
 available by name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readFloat()">readFloat</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reads a 32 bit float.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readFully(byte[])">readFully</A></B>(byte[]&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reads bytes, blocking until all bytes are read.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readFully(byte[], int, int)">readFully</A></B>(byte[]&nbsp;data,
          int&nbsp;offset,
          int&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reads bytes, blocking until all bytes are read.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readInt()">readInt</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reads a 32 bit int.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readLine()">readLine</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>This method does not properly convert bytes to characters.
 see DataInputStream for the details and alternatives.</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readLong()">readLong</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reads a 64 bit long.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Object.html">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readObject()">readObject</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Read an object from the ObjectInputStream.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Object.html">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readObjectOverride()">readObjectOverride</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method is called by trusted subclasses of ObjectOutputStream
 that constructed ObjectOutputStream using the 
 protected no-arg constructor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;short</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readShort()">readShort</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reads a 16 bit short.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readStreamHeader()">readStreamHeader</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The readStreamHeader method is provided to allow subclasses to
 read and verify their own stream headers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readUnsignedByte()">readUnsignedByte</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reads an unsigned 8 bit byte.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readUnsignedShort()">readUnsignedShort</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reads an unsigned 16 bit short.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readUTF()">readUTF</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reads a UTF format String.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#registerValidation(java.io.ObjectInputValidation, int)">registerValidation</A></B>(<A HREF="../../java/io/ObjectInputValidation.html">ObjectInputValidation</A>&nbsp;obj,
                   int&nbsp;prio)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Register an object to be validated before the graph is
 returned.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Class.html">Class</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#resolveClass(java.io.ObjectStreamClass)">resolveClass</A></B>(<A HREF="../../java/io/ObjectStreamClass.html">ObjectStreamClass</A>&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Load the local class equivalent of the specified stream class description.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Object.html">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#resolveObject(java.lang.Object)">resolveObject</A></B>(<A HREF="../../java/lang/Object.html">Object</A>&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method will allow trusted subclasses of ObjectInputStream
 to substitute one object for another during
 deserialization.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Class.html">Class</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#resolveProxyClass(java.lang.String[])">resolveProxyClass</A></B>(<A HREF="../../java/lang/String.html">String</A>[]&nbsp;interfaces)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a proxy class that implements the interfaces named in a
 proxy class descriptor; subclasses may implement this method to
 read custom data from the stream along with the descriptors for
 dynamic proxy classes, allowing them to use an alternate loading
 mechanism for the interfaces and the proxy class.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#skipBytes(int)">skipBytes</A></B>(int&nbsp;len)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Skips bytes, block until all bytes are skipped.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.io.InputStream"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.io.<A HREF="../../java/io/InputStream.html">InputStream</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/io/InputStream.html#mark(int)">mark</A>, <A HREF="../../java/io/InputStream.html#markSupported()">markSupported</A>, <A HREF="../../java/io/InputStream.html#read(byte[])">read</A>, <A HREF="../../java/io/InputStream.html#reset()">reset</A>, <A HREF="../../java/io/InputStream.html#skip(long)">skip</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.<A HREF="../../java/lang/Object.html">Object</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A>, <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A>, <A HREF="../../java/lang/Object.html#finalize()">finalize</A>, <A HREF="../../java/lang/Object.html#getClass()">getClass</A>, <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A>, <A HREF="../../java/lang/Object.html#notify()">notify</A>, <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A>, <A HREF="../../java/lang/Object.html#toString()">toString</A>, <A HREF="../../java/lang/Object.html#wait()">wait</A>, <A HREF="../../java/lang/Object.html#wait(long)">wait</A>, <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.io.ObjectInput"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from interface java.io.<A HREF="../../java/io/ObjectInput.html">ObjectInput</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/io/ObjectInput.html#read(byte[])">read</A>, <A HREF="../../java/io/ObjectInput.html#skip(long)">skip</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->


<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="ObjectInputStream(java.io.InputStream)"><!-- --></A><H3>
ObjectInputStream</H3>
<PRE>
public <B>ObjectInputStream</B>(<A HREF="../../java/io/InputStream.html">InputStream</A>&nbsp;in)
                  throws <A HREF="../../java/io/IOException.html">IOException</A>,
                         <A HREF="../../java/io/StreamCorruptedException.html">StreamCorruptedException</A></PRE>
<DL>
<DD>Create an ObjectInputStream that reads from the specified InputStream.
 The stream header containing the magic number and version number
 are read from the stream and verified. This method will block
 until the corresponding ObjectOutputStream has written and flushed the 
 header.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>in</CODE> - the underlying <code>InputStream</code> from which to read<DT><B>Throws:</B><DD><CODE><A HREF="../../java/io/StreamCorruptedException.html">StreamCorruptedException</A></CODE> - The version or magic number are 
 incorrect.<DD><CODE><A HREF="../../java/io/IOException.html">IOException</A></CODE> - An exception occurred in the underlying stream.</DL>
</DD>
</DL>
<HR>

<A NAME="ObjectInputStream()"><!-- --></A><H3>
ObjectInputStream</H3>
<PRE>
protected <B>ObjectInputStream</B>()
                     throws <A HREF="../../java/io/IOException.html">IOException</A>,
                            <A HREF="../../java/lang/SecurityException.html">SecurityException</A></PRE>
<DL>
<DD>Provide a way for subclasses that are completely reimplementing
 ObjectInputStream to not have to allocate private data just used by
 this implementation of ObjectInputStream.

 <p>If there is a security manager installed, this method first calls the
 security manager's <code>checkPermission</code> method with the
 <code>SerializablePermission("enableSubclassImplementation")</code>
 permission to ensure it's ok to enable subclassing.<DD><DL>
<DT><B>Throws:</B><DD><CODE><A HREF="../../java/io/IOException.html">IOException</A></CODE> - Thrown if not called by a subclass.<DD><CODE><A HREF="../../java/lang/SecurityException.html">SecurityException</A></CODE> - if a security manager exists and its 
    <code>checkPermission</code> method denies
    enabling subclassing.<DT><B>See Also: </B><DD><A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>SecurityManager.checkPermission(java.security.Permission)</CODE></A>, 
<A HREF="../../java/io/SerializablePermission.html"><CODE>SerializablePermission</CODE></A></DL>
</DD>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="readObject()"><!-- --></A><H3>
readObject</H3>
<PRE>
public final <A HREF="../../java/lang/Object.html">Object</A> <B>readObject</B>()
                        throws <A HREF="../../java/io/OptionalDataException.html">OptionalDataException</A>,
                               <A HREF="../../java/lang/ClassNotFoundException.html">ClassNotFoundException</A>,
                               <A HREF="../../java/io/IOException.html">IOException</A></PRE>
<DL>
<DD>Read an object from the ObjectInputStream.
 The class of the object, the signature of the class, and the values
 of the non-transient and non-static fields of the class and all
 of its supertypes are read.  Default deserializing for a class can be
 overriden using the writeObject and readObject methods.
 Objects referenced by this object are read transitively so
 that a complete equivalent graph of objects is reconstructed by 
 readObject. <p>

 The root object is completly restored when all of its fields
 and the objects it references are completely restored.  At this
 point the object validation callbacks are executed in order
 based on their registered priorities. The callbacks are
 registered by objects (in the readObject special methods)
 as they are individually restored.

 Exceptions are thrown for problems with the InputStream and for classes
 that should not be deserialized.  All exceptions are fatal to the 
 InputStream and leave it in an indeterminate state; it is up to the 
 caller to ignore or recover the stream state.<DD><DL>
<DT><B>Specified by: </B><DD><CODE><A HREF="../../java/io/ObjectInput.html#readObject()">readObject</A></CODE> in interface <CODE><A HREF="../../java/io/ObjectInput.html">ObjectInput</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Throws:</B><DD><CODE><A HREF="../../java/lang/ClassNotFoundException.html">ClassNotFoundException</A></CODE> - Class of a serialized object
      cannot be found.<DD><CODE><A HREF="../../java/io/InvalidClassException.html">InvalidClassException</A></CODE> - Something is wrong with a class used by
     serialization.<DD><CODE><A HREF="../../java/io/StreamCorruptedException.html">StreamCorruptedException</A></CODE> - Control information in the
     stream is inconsistent.<DD><CODE><A HREF="../../java/io/OptionalDataException.html">OptionalDataException</A></CODE> - Primitive data was found in the 
 stream instead of objects.<DD><CODE><A HREF="../../java/io/IOException.html">IOException</A></CODE> - Any of the usual Input/Output related exceptions.</DL>
</DD>
</DL>
<HR>

<A NAME="readObjectOverride()"><!-- --></A><H3>
readObjectOverride</H3>
<PRE>
protected <A HREF="../../java/lang/Object.html">Object</A> <B>readObjectOverride</B>()
                             throws <A HREF="../../java/io/OptionalDataException.html">OptionalDataException</A>,
                                    <A HREF="../../java/lang/ClassNotFoundException.html">ClassNotFoundException</A>,
                                    <A HREF="../../java/io/IOException.html">IOException</A></PRE>
<DL>
<DD>This method is called by trusted subclasses of ObjectOutputStream
 that constructed ObjectOutputStream using the 
 protected no-arg constructor. The subclass is expected to provide
 an override method with the modifier "final".<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Returns:</B><DD>the Object read from the stream.<DT><B>Throws:</B><DD><CODE><A HREF="../../java/lang/ClassNotFoundException.html">ClassNotFoundException</A></CODE> - Class definition of a
 serialized object cannot be found.<DD><CODE><A HREF="../../java/io/OptionalDataException.html">OptionalDataException</A></CODE> - Primitive data was found in the 
 stream instead of objects.<DD><CODE><A HREF="../../java/io/IOException.html">IOException</A></CODE> - if I/O errors occurred while reading from the
 underlying stream<DT><B>Since: </B><DD>1.2</DD>
<DT><B>See Also: </B><DD><A HREF="../../java/io/ObjectInputStream.html#ObjectInputStream()"><CODE>ObjectInputStream()</CODE></A>, 
<A HREF="../../java/io/ObjectInputStream.html#readObject()"><CODE>readObject()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="defaultReadObject()"><!-- --></A><H3>
defaultReadObject</H3>
<PRE>
public void <B>defaultReadObject</B>()
                       throws <A HREF="../../java/io/IOException.html">IOException</A>,
                              <A HREF="../../java/lang/ClassNotFoundException.html">ClassNotFoundException</A>,
                              <A HREF="../../java/io/NotActiveException.html">NotActiveException</A></PRE>
<DL>
<DD>Read the non-static and non-transient fields of the current class
 from this stream.  This may only be called from the readObject method
 of the class being deserialized. It will throw the NotActiveException
 if it is called otherwise.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Throws:</B><DD><CODE><A HREF="../../java/lang/ClassNotFoundException.html">ClassNotFoundException</A></CODE> - if the class of a serialized
              object could not be found.<DD><CODE><A HREF="../../java/io/IOException.html">IOException</A></CODE> - if an I/O error occurs.<DD><CODE><A HREF="../../java/io/NotActiveException.html">NotActiveException</A></CODE> - if the stream is not currently reading
              objects.</DL>
</DD>
</DL>
<HR>

<A NAME="readFields()"><!-- --></A><H3>
readFields</H3>
<PRE>
public <A HREF="../../java/io/ObjectInputStream.GetField.html">ObjectInputStream.GetField</A> <B>readFields</B>()
                                      throws <A HREF="../../java/io/IOException.html">IOException</A>,
                                             <A HREF="../../java/lang/ClassNotFoundException.html">ClassNotFoundException</A>,
                                             <A HREF="../../java/io/NotActiveException.html">NotActiveException</A></PRE>
<DL>
<DD>Reads the persistent fields from the stream and makes them 
 available by name.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Returns:</B><DD>the <code>GetField</code> object representing the persistent
 fields of the object being deserialized<DT><B>Throws:</B><DD><CODE><A HREF="../../java/lang/ClassNotFoundException.html">ClassNotFoundException</A></CODE> - if the class of a serialized
              object could not be found.<DD><CODE><A HREF="../../java/io/IOException.html">IOException</A></CODE> - if an I/O error occurs.<DD><CODE><A HREF="../../java/io/NotActiveException.html">NotActiveException</A></CODE> - if the stream is not currently reading
              objects.<DT><B>Since: </B><DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="registerValidation(java.io.ObjectInputValidation, int)"><!-- --></A><H3>
registerValidation</H3>
<PRE>
public void <B>registerValidation</B>(<A HREF="../../java/io/ObjectInputValidation.html">ObjectInputValidation</A>&nbsp;obj,
                               int&nbsp;prio)
                        throws <A HREF="../../java/io/NotActiveException.html">NotActiveException</A>,
                               <A HREF="../../java/io/InvalidObjectException.html">InvalidObjectException</A></PRE>
<DL>
<DD>Register an object to be validated before the graph is
 returned.  While similar to resolveObject these validations are
 called after the entire graph has been reconstituted.
 Typically, a readObject method will register the object with
 the stream so that when all of the objects are restored a final
 set of validations can be performed.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>obj</CODE> - the object to receive the validation callback.<DD><CODE>prio</CODE> - controls the order of callbacks;zero is a good default.
 Use higher numbers to be called back earlier, lower numbers for later
 callbacks. Within a priority, callbacks are processed in no
 particular order.<DT><B>Throws:</B><DD><CODE><A HREF="../../java/io/NotActiveException.html">NotActiveException</A></CODE> - The stream is not currently reading 
 objects so it is invalid to register a callback.<DD><CODE><A HREF="../../java/io/InvalidObjectException.html">InvalidObjectException</A></CODE> - The validation object is null.</DL>
</DD>
</DL>
<HR>

<A NAME="resolveClass(java.io.ObjectStreamClass)"><!-- --></A><H3>
resolveClass</H3>
<PRE>
protected <A HREF="../../java/lang/Class.html">Class</A> <B>resolveClass</B>(<A HREF="../../java/io/ObjectStreamClass.html">ObjectStreamClass</A>&nbsp;v)
                      throws <A HREF="../../java/io/IOException.html">IOException</A>,
                             <A HREF="../../java/lang/ClassNotFoundException.html">ClassNotFoundException</A></PRE>
<DL>
<DD>Load the local class equivalent of the specified stream class description.

 Subclasses may implement this method to allow classes to be
 fetched from an alternate source. 

 The corresponding method in ObjectOutputStream is
 annotateClass.  This method will be invoked only once for each
 unique class in the stream.  This method can be implemented by
 subclasses to use an alternate loading mechanism but must
 return a Class object.  Once returned, the serialVersionUID of the
 class is compared to the serialVersionUID of the serialized class.
 If there is a mismatch, the deserialization fails and an exception
 is raised. <p>

 By default the class name is resolved relative to the class
 that called readObject. <p><DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - an instance of class ObjectStreamClass<DT><B>Returns:</B><DD>a Class object corresponding to <code>v</code><DT><B>Throws:</B><DD><CODE><A HREF="../../java/io/IOException.html">IOException</A></CODE> - Any of the usual Input/Output exceptions.<DD><CODE><A HREF="../../java/lang/ClassNotFoundException.html">ClassNotFoundException</A></CODE> - If class of
 a serialized object cannot be found.</DL>
</DD>
</DL>
<HR>

<A NAME="resolveProxyClass(java.lang.String[])"><!-- --></A><H3>
resolveProxyClass</H3>
<PRE>
protected <A HREF="../../java/lang/Class.html">Class</A> <B>resolveProxyClass</B>(<A HREF="../../java/lang/String.html">String</A>[]&nbsp;interfaces)
                           throws <A HREF="../../java/io/IOException.html">IOException</A>,
                                  <A HREF="../../java/lang/ClassNotFoundException.html">ClassNotFoundException</A></PRE>
<DL>
<DD>Returns a proxy class that implements the interfaces named in a
 proxy class descriptor; subclasses may implement this method to
 read custom data from the stream along with the descriptors for
 dynamic proxy classes, allowing them to use an alternate loading
 mechanism for the interfaces and the proxy class.

 <p>This method is called exactly once for each unique proxy class
 descriptor in the stream.

 <p>The corresponding method in <code>ObjectOutputStream</code> is
 <code>annotateProxyClass</code>.  For a given subclass of
 <code>ObjectInputStream</code> that overrides this method, the
 <code>annotateProxyClass</code> method in the corresponding
 subclass of <code>ObjectOutputStream</code> must write any data or
 objects read by this method.

 <p>The default implementation of this method in
 <code>ObjectInputStream</code> returns the result of calling
 <code>Proxy.getProxyClass</code> with the list of
 <code>Class</code> objects for the interfaces that are named in
 the <code>interfaces</code> parameter.  The <code>Class</code>
 object for each interface name <code>i</code> is the value
 returned by calling
 <pre>
     Class.forName(i, false, loader)
 </pre>
 where <code>loader</code> is that of the first non-null class
 loader up the execution stack, or <code>null</code> if no non-null
 class loaders are on the stack (the same class loader choice used
 by the <code>resolveClass</code> method).  This same value of
 <code>loader</code> is also the class loader passed to
 <code>Proxy.getProxyClass</code>.  If <code>Proxy.getProxyClass</code>
 throws an <code>IllegalArgumentException</code>,
 <code>resolveProxyClass</code> will throw a
 <code>ClassNotFoundException</code> containing the
 <code>IllegalArgumentException</code>.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>interfaces</CODE> - the list of interface names that were
		deserialized in the proxy class descriptor<DT><B>Returns:</B><DD>a proxy class for the specified interfaces<DT><B>Throws:</B><DD><CODE><A HREF="../../java/io/IOException.html">IOException</A></CODE> - any exception thrown by the underlying
		<code>InputStream</code><DD><CODE><A HREF="../../java/lang/ClassNotFoundException.html">ClassNotFoundException</A></CODE> - if the proxy class or any of the
 		named interfaces could not be found<DT><B>Since: </B><DD>1.3</DD>
<DT><B>See Also: </B><DD><A HREF="../../java/io/ObjectOutputStream.html#annotateProxyClass(java.lang.Class)"><CODE>ObjectOutputStream.annotateProxyClass(Class)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="resolveObject(java.lang.Object)"><!-- --></A><H3>
resolveObject</H3>
<PRE>
protected <A HREF="../../java/lang/Object.html">Object</A> <B>resolveObject</B>(<A HREF="../../java/lang/Object.html">Object</A>&nbsp;obj)
                        throws <A HREF="../../java/io/IOException.html">IOException</A></PRE>
<DL>
<DD>This method will allow trusted subclasses of ObjectInputStream
 to substitute one object for another during
 deserialization. Replacing objects is disabled until
 enableResolveObject is called. The enableResolveObject method
 checks that the stream requesting to resolve object can be
 trusted. Every reference to serializable objects is passed to
 resolveObject.  To insure that the private state of objects is
 not unintentionally exposed only trusted streams may use
 resolveObject. <p>

 This method is called after an object has been read but before it is
 returned from readObject.  The default resolveObject method
 just returns the same object. <p>

 When a subclass is replacing objects it must insure that the
 substituted object is compatible with every field where the
 reference will be stored.  Objects whose type is not a subclass
 of the type of the field or array element abort the
 serialization by raising an exception and the object is not be
 stored. <p>

 This method is called only once when each object is first encountered.
 All subsequent references to the object will be redirected to the
 new object. <P><DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>obj</CODE> - object to be substituted<DT><B>Returns:</B><DD>the substituted object<DT><B>Throws:</B><DD><CODE><A HREF="../../java/io/IOException.html">IOException</A></CODE> - Any of the usual Input/Output exceptions.</DL>
</DD>
</DL>
<HR>

<A NAME="enableResolveObject(boolean)"><!-- --></A><H3>
enableResolveObject</H3>
<PRE>
protected boolean <B>enableResolveObject</B>(boolean&nbsp;enable)
                               throws <A HREF="../../java/lang/SecurityException.html">SecurityException</A></PRE>
<DL>
<DD>Enable the stream to allow objects read from the stream to be replaced.
 
 When enabled, the resolveObject method is called for every object
 being deserialized.

 If <i>enable</i> is true, and there is a security manager installed, 
 this method first calls the
 security manager's <code>checkPermission</code> method with the
 <code>SerializablePermission("enableSubstitution")</code>
 permission to ensure it's ok to 
 enable the stream to allow objects read from the stream to be replaced.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>enable</CODE> - true for enabling use of <code>resolveObject</code> for
               every object being deserialized<DT><B>Returns:</B><DD>the previous setting before this method was invoked<DT><B>Throws:</B><DD><CODE><A HREF="../../java/lang/SecurityException.html">SecurityException</A></CODE> - if a security manager exists and its 
    <code>checkPermission</code> method denies
    enabling the stream to allow objects read from the stream to be
    replaced.<DT><B>See Also: </B><DD><A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>SecurityManager.checkPermission(java.security.Permission)</CODE></A>, 
<A HREF="../../java/io/SerializablePermission.html"><CODE>SerializablePermission</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="readStreamHeader()"><!-- --></A><H3>
readStreamHeader</H3>
<PRE>
protected void <B>readStreamHeader</B>()
                         throws <A HREF="../../java/io/IOException.html">IOException</A>,
                                <A HREF="../../java/io/StreamCorruptedException.html">StreamCorruptedException</A></PRE>
<DL>
<DD>The readStreamHeader method is provided to allow subclasses to
 read and verify their own stream headers. It reads and
 verifies the magic number and version number.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Throws:</B><DD><CODE><A HREF="../../java/io/IOException.html">IOException</A></CODE> - if there are I/O errors while reading from the
 underlying <code>InputStream</code><DD><CODE><A HREF="../../java/io/StreamCorruptedException.html">StreamCorruptedException</A></CODE> - if control information in the
 stream is inconsistent</DL>
</DD>
</DL>
<HR>

<A NAME="readClassDescriptor()"><!-- --></A><H3>
readClassDescriptor</H3>
<PRE>
protected <A HREF="../../java/io/ObjectStreamClass.html">ObjectStreamClass</A> <B>readClassDescriptor</B>()
                                         throws <A HREF="../../java/io/IOException.html">IOException</A>,
                                                <A HREF="../../java/lang/ClassNotFoundException.html">ClassNotFoundException</A></PRE>
<DL>
<DD>Read a class descriptor from the serialization stream.  This method is
 called when the ObjectInputStream expects a class descriptor as the next
 item in the serialization stream.  Subclasses of ObjectInputStream may
 override this method to read in class descriptors that have been written
 in non-standard formats (by subclasses of ObjectOutputStream which have
 overridden the <code>writeClassDescriptor</code> method).  By default,
 this method reads class descriptors according to the format defined in
 the Object Serialization specification.
 <p><DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Returns:</B><DD>the class descriptor read<DT><B>Throws:</B><DD><CODE><A HREF="../../java/io/IOException.html">IOException</A></CODE> - If an I/O error has occurred.<DD><CODE><A HREF="../../java/lang/ClassNotFoundException.html">ClassNotFoundException</A></CODE> - If the Class of a serialized object
            used in the class descriptor representation cannot be found<DT><B>Since: </B><DD>1.3</DD>
<DT><B>See Also: </B><DD><A HREF="../../java/io/ObjectOutputStream.html#writeClassDescriptor(java.io.ObjectStreamClass)"><CODE>ObjectOutputStream.writeClassDescriptor(java.io.ObjectStreamClass)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="read()"><!-- --></A><H3>
read</H3>
<PRE>
public int <B>read</B>()
         throws <A HREF="../../java/io/IOException.html">IOException</A></PRE>
<DL>
<DD>Reads a byte of data. This method will block if no input is 
 available.<DD><DL>
<DT><B>Specified by: </B><DD><CODE><A HREF="../../java/io/ObjectInput.html#read()">read</A></CODE> in interface <CODE><A HREF="../../java/io/ObjectInput.html">ObjectInput</A></CODE><DT><B>Overrides:</B><DD><CODE><A HREF="../../java/io/InputStream.html#read()">read</A></CODE> in class <CODE><A HREF="../../java/io/InputStream.html">InputStream</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Returns:</B><DD>the byte read, or -1 if the end of the
		stream is reached.<DT><B>Throws:</B><DD><CODE><A HREF="../../java/io/IOException.html">IOException</A></CODE> - If an I/O error has occurred.</DL>
</DD>
</DL>
<HR>

<A NAME="read(byte[], int, int)"><!-- --></A><H3>
read</H3>
<PRE>
public int <B>read</B>(byte[]&nbsp;b,
                int&nbsp;off,
                int&nbsp;len)
         throws <A HREF="../../java/io/IOException.html">IOException</A></PRE>
<DL>
<DD>Reads into an array of bytes.  This method will
 block until some input is available. Consider
 using java.io.DataInputStream.readFully to read exactly
 'length' bytes.<DD><DL>
<DT><B>Specified by: </B><DD><CODE><A HREF="../../java/io/ObjectInput.html#read(byte[], int, int)">read</A></CODE> in interface <CODE><A HREF="../../java/io/ObjectInput.html">ObjectInput</A></CODE><DT><B>Overrides:</B><DD><CODE><A HREF="../../java/io/InputStream.html#read(byte[], int, int)">read</A></CODE> in class <CODE><A HREF="../../java/io/InputStream.html">InputStream</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>b</CODE> - the buffer into which the data is read<DD><CODE>off</CODE> - the start offset of the data<DD><CODE>len</CODE> - the maximum number of bytes read<DT><B>Returns:</B><DD>the actual number of bytes read, -1 is
 		returned when the end of the stream is reached.<DT><B>Throws:</B><DD><CODE><A HREF="../../java/io/IOException.html">IOException</A></CODE> - If an I/O error has occurred.<DT><B>See Also: </B><DD><A HREF="../../java/io/DataInputStream.html#readFully(byte[], int, int)"><CODE>DataInputStream.readFully(byte[],int,int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="available()"><!-- --></A><H3>
available</H3>
<PRE>
public int <B>available</B>()
              throws <A HREF="../../java/io/IOException.html">IOException</A></PRE>
<DL>
<DD>Returns the number of bytes that can be read without blocking.<DD><DL>
<DT><B>Specified by: </B><DD><CODE><A HREF="../../java/io/ObjectInput.html#available()">available</A></CODE> in interface <CODE><A HREF="../../java/io/ObjectInput.html">ObjectInput</A></CODE><DT><B>Overrides:</B><DD><CODE><A HREF="../../java/io/InputStream.html#available()">available</A></CODE> in class <CODE><A HREF="../../java/io/InputStream.html">InputStream</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Returns:</B><DD>the number of available bytes.<DT><B>Throws:</B><DD><CODE><A HREF="../../java/io/IOException.html">IOException</A></CODE> - if there are I/O errors while reading from the
 underlying <code>InputStream</code></DL>
</DD>
</DL>
<HR>

<A NAME="close()"><!-- --></A><H3>
close</H3>
<PRE>
public void <B>close</B>()
           throws <A HREF="../../java/io/IOException.html">IOException</A></PRE>
<DL>
<DD>Closes the input stream. Must be called
 to release any resources associated with
 the stream.<DD><DL>
<DT><B>Specified by: </B><DD><CODE><A HREF="../../java/io/ObjectInput.html#close()">close</A></CODE> in interface <CODE><A HREF="../../java/io/ObjectInput.html">ObjectInput</A></CODE><DT><B>Overrides:</B><DD><CODE><A HREF="../../java/io/InputStream.html#close()">close</A></CODE> in class <CODE><A HREF="../../java/io/InputStream.html">InputStream</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Throws:</B><DD><CODE><A HREF="../../java/io/IOException.html">IOException</A></CODE> - If an I/O error has occurred.</DL>
</DD>
</DL>
<HR>

<A NAME="readBoolean()"><!-- --></A><H3>
readBoolean</H3>
<PRE>
public boolean <B>readBoolean</B>()
                    throws <A HREF="../../java/io/IOException.html">IOException</A></PRE>
<DL>
<DD>Reads in a boolean.<DD><DL>
<DT><B>Specified by: </B><DD><CODE><A HREF="../../java/io/DataInput.html#readBoolean()">readBoolean</A></CODE> in interface <CODE><A HREF="../../java/io/DataInput.html">DataInput</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Returns:</B><DD>the boolean read.<DT><B>Throws:</B><DD><CODE><A HREF="../../java/io/EOFException.html">EOFException</A></CODE> - If end of file is reached.<DD><CODE><A HREF="../../java/io/IOException.html">IOException</A></CODE> - If other I/O error has occurred.</DL>
</DD>
</DL>
<HR>

<A NAME="readByte()"><!-- --></A><H3>
readByte</H3>
<PRE>
public byte <B>readByte</B>()
              throws <A HREF="../../java/io/IOException.html">IOException</A></PRE>
<DL>
<DD>Reads an 8 bit byte.<DD><DL>
<DT><B>Specified by: </B><DD><CODE><A HREF="../../java/io/DataInput.html#readByte()">readByte</A></CODE> in interface <CODE><A HREF="../../java/io/DataInput.html">DataInput</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Returns:</B><DD>the 8 bit byte read.<DT><B>Throws:</B><DD><CODE><A HREF="../../java/io/EOFException.html">EOFException</A></CODE> - If end of file is reached.<DD><CODE><A HREF="../../java/io/IOException.html">IOException</A></CODE> - If other I/O error has occurred.</DL>
</DD>
</DL>
<HR>

<A NAME="readUnsignedByte()"><!-- --></A><H3>
readUnsignedByte</H3>
<PRE>
public int <B>readUnsignedByte</B>()
                     throws <A HREF="../../java/io/IOException.html">IOException</A></PRE>
<DL>
<DD>Reads an unsigned 8 bit byte.<DD><DL>
<DT><B>Specified by: </B><DD><CODE><A HREF="../../java/io/DataInput.html#readUnsignedByte()">readUnsignedByte</A></CODE> in interface <CODE><A HREF="../../java/io/DataInput.html">DataInput</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Returns:</B><DD>the 8 bit byte read.<DT><B>Throws:</B><DD><CODE><A HREF="../../java/io/EOFException.html">EOFException</A></CODE> - If end of file is reached.<DD><CODE><A HREF="../../java/io/IOException.html">IOException</A></CODE> - If other I/O error has occurred.</DL>
</DD>
</DL>
<HR>

<A NAME="readShort()"><!-- --></A><H3>
readShort</H3>
<PRE>
public short <B>readShort</B>()
                throws <A HREF="../../java/io/IOException.html">IOException</A></PRE>
<DL>
<DD>Reads a 16 bit short.<DD><DL>
<DT><B>Specified by: </B><DD><CODE><A HREF="../../java/io/DataInput.html#readShort()">readShort</A></CODE> in interface <CODE><A HREF="../../java/io/DataInput.html">DataInput</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Returns:</B><DD>the 16 bit short read.<DT><B>Throws:</B><DD><CODE><A HREF="../../java/io/EOFException.html">EOFException</A></CODE> - If end of file is reached.<DD><CODE><A HREF="../../java/io/IOException.html">IOException</A></CODE> - If other I/O error has occurred.</DL>
</DD>
</DL>
<HR>

<A NAME="readUnsignedShort()"><!-- --></A><H3>
readUnsignedShort</H3>
<PRE>
public int <B>readUnsignedShort</B>()
                      throws <A HREF="../../java/io/IOException.html">IOException</A></PRE>
<DL>
<DD>Reads an unsigned 16 bit short.<DD><DL>
<DT><B>Specified by: </B><DD><CODE><A HREF="../../java/io/DataInput.html#readUnsignedShort()">readUnsignedShort</A></CODE> in interface <CODE><A HREF="../../java/io/DataInput.html">DataInput</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Returns:</B><DD>the 16 bit short read.<DT><B>Throws:</B><DD><CODE><A HREF="../../java/io/EOFException.html">EOFException</A></CODE> - If end of file is reached.<DD><CODE><A HREF="../../java/io/IOException.html">IOException</A></CODE> - If other I/O error has occurred.</DL>
</DD>
</DL>
<HR>

<A NAME="readChar()"><!-- --></A><H3>
readChar</H3>
<PRE>
public char <B>readChar</B>()
              throws <A HREF="../../java/io/IOException.html">IOException</A></PRE>
<DL>
<DD>Reads a 16 bit char.<DD><DL>
<DT><B>Specified by: </B><DD><CODE><A HREF="../../java/io/DataInput.html#readChar()">readChar</A></CODE> in interface <CODE><A HREF="../../java/io/DataInput.html">DataInput</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Returns:</B><DD>the 16 bit char read.<DT><B>Throws:</B><DD><CODE><A HREF="../../java/io/EOFException.html">EOFException</A></CODE> - If end of file is reached.<DD><CODE><A HREF="../../java/io/IOException.html">IOException</A></CODE> - If other I/O error has occurred.</DL>
</DD>
</DL>
<HR>

<A NAME="readInt()"><!-- --></A><H3>
readInt</H3>
<PRE>
public int <B>readInt</B>()
            throws <A HREF="../../java/io/IOException.html">IOException</A></PRE>
<DL>
<DD>Reads a 32 bit int.<DD><DL>
<DT><B>Specified by: </B><DD><CODE><A HREF="../../java/io/DataInput.html#readInt()">readInt</A></CODE> in interface <CODE><A HREF="../../java/io/DataInput.html">DataInput</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Returns:</B><DD>the 32 bit integer read.<DT><B>Throws:</B><DD><CODE><A HREF="../../java/io/EOFException.html">EOFException</A></CODE> - If end of file is reached.<DD><CODE><A HREF="../../java/io/IOException.html">IOException</A></CODE> - If other I/O error has occurred.</DL>
</DD>
</DL>
<HR>

<A NAME="readLong()"><!-- --></A><H3>
readLong</H3>
<PRE>
public long <B>readLong</B>()
              throws <A HREF="../../java/io/IOException.html">IOException</A></PRE>
<DL>
<DD>Reads a 64 bit long.<DD><DL>
<DT><B>Specified by: </B><DD><CODE><A HREF="../../java/io/DataInput.html#readLong()">readLong</A></CODE> in interface <CODE><A HREF="../../java/io/DataInput.html">DataInput</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Returns:</B><DD>the read 64 bit long.<DT><B>Throws:</B><DD><CODE><A HREF="../../java/io/EOFException.html">EOFException</A></CODE> - If end of file is reached.<DD><CODE><A HREF="../../java/io/IOException.html">IOException</A></CODE> - If other I/O error has occurred.</DL>
</DD>
</DL>
<HR>

<A NAME="readFloat()"><!-- --></A><H3>
readFloat</H3>
<PRE>
public float <B>readFloat</B>()
                throws <A HREF="../../java/io/IOException.html">IOException</A></PRE>
<DL>
<DD>Reads a 32 bit float.<DD><DL>
<DT><B>Specified by: </B><DD><CODE><A HREF="../../java/io/DataInput.html#readFloat()">readFloat</A></CODE> in interface <CODE><A HREF="../../java/io/DataInput.html">DataInput</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Returns:</B><DD>the 32 bit float read.<DT><B>Throws:</B><DD><CODE><A HREF="../../java/io/EOFException.html">EOFException</A></CODE> - If end of file is reached.<DD><CODE><A HREF="../../java/io/IOException.html">IOException</A></CODE> - If other I/O error has occurred.</DL>
</DD>
</DL>
<HR>

<A NAME="readDouble()"><!-- --></A><H3>
readDouble</H3>
<PRE>
public double <B>readDouble</B>()
                  throws <A HREF="../../java/io/IOException.html">IOException</A></PRE>
<DL>
<DD>Reads a 64 bit double.<DD><DL>
<DT><B>Specified by: </B><DD><CODE><A HREF="../../java/io/DataInput.html#readDouble()">readDouble</A></CODE> in interface <CODE><A HREF="../../java/io/DataInput.html">DataInput</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Returns:</B><DD>the 64 bit double read.<DT><B>Throws:</B><DD><CODE><A HREF="../../java/io/EOFException.html">EOFException</A></CODE> - If end of file is reached.<DD><CODE><A HREF="../../java/io/IOException.html">IOException</A></CODE> - If other I/O error has occurred.</DL>
</DD>
</DL>
<HR>

<A NAME="readFully(byte[])"><!-- --></A><H3>
readFully</H3>
<PRE>
public void <B>readFully</B>(byte[]&nbsp;data)
               throws <A HREF="../../java/io/IOException.html">IOException</A></PRE>
<DL>
<DD>Reads bytes, blocking until all bytes are read.<DD><DL>
<DT><B>Specified by: </B><DD><CODE><A HREF="../../java/io/DataInput.html#readFully(byte[])">readFully</A></CODE> in interface <CODE><A HREF="../../java/io/DataInput.html">DataInput</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>data</CODE> - the buffer into which the data is read<DT><B>Throws:</B><DD><CODE><A HREF="../../java/io/EOFException.html">EOFException</A></CODE> - If end of file is reached.<DD><CODE><A HREF="../../java/io/IOException.html">IOException</A></CODE> - If other I/O error has occurred.</DL>
</DD>
</DL>
<HR>

<A NAME="readFully(byte[], int, int)"><!-- --></A><H3>
readFully</H3>
<PRE>
public void <B>readFully</B>(byte[]&nbsp;data,
                      int&nbsp;offset,
                      int&nbsp;size)
               throws <A HREF="../../java/io/IOException.html">IOException</A></PRE>
<DL>
<DD>Reads bytes, blocking until all bytes are read.<DD><DL>
<DT><B>Specified by: </B><DD><CODE><A HREF="../../java/io/DataInput.html#readFully(byte[], int, int)">readFully</A></CODE> in interface <CODE><A HREF="../../java/io/DataInput.html">DataInput</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>data</CODE> - the buffer into which the data is read<DD><CODE>offset</CODE> - the start offset of the data<DD><CODE>size</CODE> - the maximum number of bytes to read<DT><B>Throws:</B><DD><CODE><A HREF="../../java/io/EOFException.html">EOFException</A></CODE> - If end of file is reached.<DD><CODE><A HREF="../../java/io/IOException.html">IOException</A></CODE> - If other I/O error has occurred.</DL>
</DD>
</DL>
<HR>

<A NAME="skipBytes(int)"><!-- --></A><H3>
skipBytes</H3>
<PRE>
public int <B>skipBytes</B>(int&nbsp;len)
              throws <A HREF="../../java/io/IOException.html">IOException</A></PRE>
<DL>
<DD>Skips bytes, block until all bytes are skipped.<DD><DL>
<DT><B>Specified by: </B><DD><CODE><A HREF="../../java/io/DataInput.html#skipBytes(int)">skipBytes</A></CODE> in interface <CODE><A HREF="../../java/io/DataInput.html">DataInput</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>len</CODE> - the number of bytes to be skipped<DT><B>Returns:</B><DD>the actual number of bytes skipped.<DT><B>Throws:</B><DD><CODE><A HREF="../../java/io/EOFException.html">EOFException</A></CODE> - If end of file is reached.<DD><CODE><A HREF="../../java/io/IOException.html">IOException</A></CODE> - If other I/O error has occurred.</DL>
</DD>
</DL>
<HR>

<A NAME="readLine()"><!-- --></A><H3>
readLine</H3>
<PRE>
public <A HREF="../../java/lang/String.html">String</A> <B>readLine</B>()
                throws <A HREF="../../java/io/IOException.html">IOException</A></PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>This method does not properly convert bytes to characters.
 see DataInputStream for the details and alternatives.</I>
<P>
<DD>Reads in a line that has been terminated by a \n, \r, \r\n or EOF.<DD><DL>
<DT><B>Specified by: </B><DD><CODE><A HREF="../../java/io/DataInput.html#readLine()">readLine</A></CODE> in interface <CODE><A HREF="../../java/io/DataInput.html">DataInput</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Returns:</B><DD>a String copy of the line.<DT><B>Throws:</B><DD><CODE><A HREF="../../java/io/IOException.html">IOException</A></CODE> - if there are I/O errors while reading from the
 underlying <code>InputStream</code></DL>
</DD>
</DL>
<HR>

<A NAME="readUTF()"><!-- --></A><H3>
readUTF</H3>
<PRE>
public <A HREF="../../java/lang/String.html">String</A> <B>readUTF</B>()
               throws <A HREF="../../java/io/IOException.html">IOException</A></PRE>
<DL>
<DD>Reads a UTF format String.<DD><DL>
<DT><B>Specified by: </B><DD><CODE><A HREF="../../java/io/DataInput.html#readUTF()">readUTF</A></CODE> in interface <CODE><A HREF="../../java/io/DataInput.html">DataInput</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Returns:</B><DD>the String.<DT><B>Throws:</B><DD><CODE><A HREF="../../java/io/IOException.html">IOException</A></CODE> - if there are I/O errors while reading from the
 underlying <code>InputStream</code></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ObjectInputStream.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Std.&nbsp;Ed. v1.3.1</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/io/LineNumberReader.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../java/io/ObjectInputStream.GetField.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="ObjectInputStream.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;<A HREF="#inner_class_summary">INNER</A>&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<font size="-1"><a href="http://java.sun.com/cgi-bin/bugreport.cgi">Submit a bug or feature</a><br>For further API reference and developer documentation, see <a href="http://java.sun.com/j2se/1.3/index.jsp">Java 2 SDK SE Developer Documentation</a>. That documentation  contains more detailed, developer-targeted descriptions, with conceptual overviews, definitions of terms, workarounds, and working code examples. <p>Java, Java 2D, and JDBC are trademarks or registered trademarks of Sun Microsystems, Inc. in the US and other countries.<br>Copyright 1993-2001 Sun Microsystems, Inc. 901 San Antonio Road<br>Palo Alto, California, 94303, U.S.A.  All Rights Reserved.</font>
</BODY>
</HTML>
