<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Summary of the Device Manager(IM: D)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING52></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->




<!-- Main Body -->

<CENTER>
<P>
<A HREF="Devices-51.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Devices-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Devices-328.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Devices-53.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Devices-2.html"><B>Devices</B></A> / <BR><DD><A HREF="Devices-10.html"><B>Chapter 1 - Device Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING52-0></A>
<H1><A NAME=MARKER-9-401></A>Summary of the Device Manager</H1>
<A NAME=HEADING52-1></A>
<H2>C Summary</H2>
<A NAME=HEADING52-2></A>
<H3>Constants</H3>
<PRE>
enum {
   /* request codes passed by the Device Manager to a driver's 
      prime routine */
   aRdCmd            = 2,     /* read operation requested */
   aWrCmd            = 3      /* write operation requested */
};
enum {
   /* flags used in the driver header and device control entry */
   dNeedLockMask    = 0x4000, /* set if driver must be locked in memory as
                                 soon as it is opened */ 
   dNeedTimeMask    = 0x2000, /* set if driver needs time for performing
                                 periodic tasks */ 
   dNeedGoodByeMask = 0x1000, /* set if driver needs to be called before the
                                 application heap is initialized */ 
   dStatEnableMask  = 0x0800, /* set if driver responds to status requests */ 
   dCtlEnableMask   = 0x0400, /* setifdriverrespondstocontrolrequests */ 
   dWritEnableMask  = 0x0200, /* set if driver responds to write requests */ 
   dReadEnableMask  = 0x0100, /* set if driver responds to read requests */ 

   /* run-time flags used in the device control entry */
   drvrActiveMask   = 0x0080, /* driver is currently processing a request */
   dRAMBasedMask    = 0x0040, /* dCtlDriver is a handle (1) or pointer (0) */ 
   dOpenedMask      = 0x0020  /* driver is open */ 
};
enum {
   /* access permissions */
   fsCurPerm         = 0,     /* retain current permission */
   fsRdPerm          = 1,     /* allow reads only */
   fsWrPerm          = 2,     /* allow writes only */
   fsRdWrPerm        = 3,     /* allow reads and writes */


   /* positioning modes */
   fsAtMark          = 0,     /* at current position */
   fsFromStart       = 1,     /* offset from beginning */
   fsFromMark        = 3,     /* offset from current position */

   /* read modes */
   rdVerify          = 64     /* read-verify mode */
};
enum {
   /* control codes */
   goodbye           = -1,    /* heap being reinitialized */
   killCode          =  1,    /* KillIO requested */
   accEvent          = 64,    /* handle an event */
   accRun            = 65,    /* time for periodic action */
   accCursor         = 66,    /* change cursor shape */
   accMenu           = 67,    /* handle menu item */
   accUndo           = 68,    /* handle undo command */
   accCut            = 70,    /* handle cut command */
   accCopy           = 71,    /* handle copy command */
   accPaste          = 72,    /* handle paste command */
   accClear          = 73     /* handle clear command */
};
enum {
   /* Chooser messages */
   chooserInitMsg    = 11,    /* the user selected this device package */
   newSelMsg         = 12,    /* the user made new device selections */
   fillListMsg       = 13,    /* fill the device list with choices */
   getSelMsg         = 14,    /* mark one or more choices as selected */
   selectMsg         = 15,    /* the user made a selection */
   deselectMsg       = 16,    /* the user canceled a selection */
   terminateMsg      = 17,    /* allows device package to clean up */
   buttonMsg         = 19     /* the user selected a button */
};
</PRE>
<A NAME=HEADING52-8></A>
<H3>Data Types</H3>
<PRE>
typedef union ParamBlockRec {
   IOParam        ioParam;
   FileParam      fileParam;
   VolumeParam    volumeParam;
   CntrlParam     cntrlParam;
   SlotDevParam   slotDevParam;
   MultiDevParam  multiDevParam;
} ParamBlockRec;
typedef ParamBlockRec *ParmBlkPtr;
typedef struct IOParam {
   QElemPtr    qLink;         /* next queue entry */
   short       qType;         /* queue type */
   short       ioTrap;        /* routine trap */
   Ptr         ioCmdAddr;     /* routine address */
   ProcPtr     ioCompletion;  /* completion routine address */
   OSErr       ioResult;      /* result code */
   StringPtr   ioNamePtr;     /* pointer to driver name */
   short       ioVRefNum;     /* volume reference or drive number */
   short       ioRefNum;      /* driver reference number */
   char        ioVersNum;     /* not used by the Device Manager */
   char        ioPermssn;     /* read/write permission */
   Ptr         ioMisc;        /* not used by the Device Manager */
   Ptr         ioBuffer;      /* pointer to data buffer */
   long        ioReqCount;    /* requested number of bytes */
   long        ioActCount;    /* actual number of bytes completed */
   short       ioPosMode;     /* positioning mode */
   long        ioPosOffset;   /* positioning offset */
} IOParam;

typedef struct CntrlParam {
   QElemPtr    qLink;         /* next queue entry */
   short       qType;         /* queue type */
   short       ioTrap;        /* routine trap */
   Ptr         ioCmdAddr;     /* routine address */
   ProcPtr     ioCompletion;  /* completion routine address */
   OSErr       ioResult;      /* result code */
   StringPtr   ioNamePtr;     /* pointer to driver name */
   short       ioVRefNum;     /* volume reference or drive number */
   short       ioCRefNum;     /* driver reference number */
   short       csCode;        /* type of control or status request */
   short       csParam[11];   /* control or status information */
} CntrlParam;
typedef struct AuxDCE {
   Ptr         dCtlDriver;    /* pointer or handle to driver */
   short       dCtlFlags;     /* flags */
   QHdr        dCtlQHdr;      /* I/O queue header */
   long        dCtlPosition;  /* current R/W byte position */
   Handle      dCtlStorage;   /* handle to private storage */
   short       dCtlRefNum;    /* driver reference number */
   long        dCtlCurTicks;  /* used internally */
   GrafPtr     dCtlWindow;    /* pointer to driver's window */
   short       dCtlDelay;     /* ticks between periodic actions */
   short       dCtlEMask;     /* desk accessory event mask */
   short       dCtlMenu;      /* desk accessory menu ID */
   char        dCtlSlot;      /* slot */
   char        dCtlSlotId;    /* sResource directory ID */
   long        dCtlDevBase;   /* slot device base address */
   Ptr         dCtlOwner;     /* reserved; must be 0 */
   char        dCtlExtDev;    /* external device ID */
   char        fillByte;      /* reserved */
} AuxDCE;
typedef AuxDCE *AuxDCEPtr, **AuxDCEHandle;
</PRE>
<A NAME=HEADING52-12></A>
<H3>Functions</H3>
<A NAME=HEADING52-13></A>
<H4>Opening and Closing Device Drivers</H4>
<PRE>
pascal OSErr OpenDriver   (ConstStr255Param name, short *drvrRefNum);
pascal OSErr PBOpen       (ParmBlkPtr paramBlock, Boolean async);
pascal OSErr PBOpenSync   (ParmBlkPtr paramBlock);
pascal OSErr OpenSlot     (ParmBlkPtr paramBlock, Boolean async);
pascal short OpenDeskAcc  (ConstStr255Param deskAccName);
pascal OSErr CloseDriver  (short refNum);
pascal OSErr PBClose      (ParmBlkPtr paramBlock, Boolean async);
pascal OSErr PBCloseSync  (ParmBlkPtr paramBlock);
pascal void  CloseDeskAcc (short refNum);
</PRE>
<A NAME=HEADING52-23></A>
<H4>Communicating With Device Drivers</H4>
<PRE>
pascal OSErr FSRead        (short refNum, long *count, void *buffPtr);
pascal OSErr PBRead        (ParmBlkPtr paramBlock, Boolean async);
pascal OSErr PBReadSync    (ParmBlkPtr paramBlock);
pascal OSErr PBReadAsync   (ParmBlkPtr paramBlock);
pascal OSErr FSWrite       (short refNum,long *count,const void *buffPtr);
pascal OSErr PBWrite       (ParmBlkPtr paramBlock, Boolean async);
pascal OSErr PBWriteSync   (ParmBlkPtr paramBlock);
pascal OSErr PBWriteAsync  (ParmBlkPtr paramBlock);
</PRE>
<A NAME=HEADING52-32></A>
<H4>Controlling and Monitoring Device Drivers</H4>
<PRE>
pascal OSErr Control          (short refNum, short csCode, const void 
                               *csParamPtr);
pascal OSErr PBControl        (ParmBlkPtr paramBlock, Boolean async);
pascal OSErr PBControlSync    (ParmBlkPtr paramBlock);
pascal OSErr PBControlAsync   (ParmBlkPtr paramBlock);
pascal OSErr Status           (short refNum, short csCode, void *csParamPtr);
pascal OSErr PBStatus         (ParmBlkPtr paramBlock, Boolean async);
pascal OSErr PBStatusSync     (ParmBlkPtr paramBlock);
pascal OSErr PBStatusAsync    (ParmBlkPtr paramBlock);
pascal OSErr KillIO           (short refNum);
pascal OSErr PBKillIO         (ParmBlkPtr paramBlock, Boolean async);
pascal OSErr PBKillIOSync     (ParmBlkPtr paramBlock);
pascal OSErr PBKillIOAsync    (ParmBlkPtr paramBlock);
</PRE>
<A NAME=HEADING52-45></A>
<H4>Driver Support Functions</H4>
<PRE>
pascal OSErr DriverInstall              (Ptr drvrPtr, short refNum);
pascal OSErr DriverInstallReserveMem    (Ptr drvrPtr, short refNum);
pascal OSErr DriverRemove               (short refNum);
pascal DCtlHandle GetDCtlEntry          (short refNum);
</PRE>
<A NAME=HEADING52-50></A>
<H2>Pascal Summary</H2>
<A NAME=HEADING52-51></A>
<H3>Constants</H3>
<PRE>
CONST
   {request codes passed by the Device Manager to a driver's prime routine}
   aRdCmd            = 2;        {read operation requested}
   aWrCmd            = 3;        {write operation requested}
   {flags used in the driver header and device control entry}
   dNeedLockMask     = $4000;    {set if driver must be locked in memory as }
                                 { soon as it is opened}
   dNeedTimeMask     = $2000;    {set if driver needs time for performing }
                                 { periodic tasks}
   dNeedGoodByeMask  = $1000;    {set if driver needs to be called before }
                                 { the application heap is initialized}
   dStatEnableMask   = $0800;    {set if driver responds to status requests}
   dCtlEnableMask    = $0400;    {set if driver responds to control requests}
   dWritEnableMask   = $0200;    {set if driver responds to write requests}
   dReadEnableMask   = $0100;    {set if driver responds to read requests}
   {run-time flags used in the device control entry}
   drvrActiveMask    = $0080;    {driver is currently processing a request}
   dRAMBasedMask     = $0040;    {dCtlDriver is a handle (1) or pointer (0)}
   dOpenedMask       = $0020;    {driver is open}
   {access permissions}
   fsCurPerm         = 0;        {retain current permission}
   fsRdPerm          = 1;        {allow reads only}
   fsWrPerm          = 2;        {allow writes only}
   fsRdWrPerm        = 3;        {allow reads and writes}

   {positioning modes}
   fsAtMark          = 0;        {at current position}
   fsFromStart       = 1;        {offset from beginning}
   fsFromMark        = 3;        {offset from current position}
   {read modes}
   rdVerify          = 64;       {read-verify mode}

   {control codes}
   goodbye           = -1;       {heap being reinitialized}
   killCode          =  1;       {KillIO requested}
   accEvent          = 64;       {handle an event}
   accRun            = 65;       {time for periodic action}
   accCursor         = 66;       {change cursor shape}
   accMenu           = 67;       {handle menu item}
   accUndo           = 68;       {handle undo command}
   accCut            = 70;       {handle cut command}
   accCopy           = 71;       {handle copy command}
   accPaste          = 72;       {handle paste command}
   accClear          = 73;       {handle clear command}
   {Chooser messages}
   chooserInitMsg    = 11;       {the user selected this device package}
   newSelMsg         = 12;       {the user made new device selections}
   fillListMsg       = 13;       {fill the device list with choices}
   getSelMsg         = 14;       {mark one or more choices as selected}
   selectMsg         = 15;       {the user made a selection}
   deselectMsg       = 16;       {the user canceled a selection}
   terminateMsg      = 17;       {allows device package to clean up}
   buttonMsg         = 19;       {the user selected a button}
</PRE>
<A NAME=HEADING52-58></A>
<H3>Data Types</H3>
<PRE>
TYPE  ParamBlkType = (IOParam, FileParam, VolumeParam, CntrlParam,
                      SlotDevParam, MultiDevParam);

      ParamBlockRec =
      RECORD
         qLink:         QElemPtr;   {next queue entry}
         qType:         Integer;    {queue type}
         ioTrap:        Integer;    {routine trap}
         ioCmdAddr:     Ptr;        {routine address}
         ioCompletion:  ProcPtr;    {completion routine address}
         ioResult:      OSErr;      {result code}
         ioNamePtr:     StringPtr;  {pointer to driver name}
         ioVRefNum:     Integer;    {volume reference or drive number}
      CASE ParamBlkType OF
      IOParam:
         (ioRefNum:     Integer;    {driver reference number}
         ioVersNum:     SignedByte; {not used}
         ioPermssn:     SignedByte; {read/write permission}
         ioMisc:        Ptr;        {not used}
         ioBuffer:      Ptr;        {pointer to data buffer}
         ioReqCount:    LongInt;    {requested number of bytes}
         ioActCount:    LongInt;    {actual number of bytes}
         ioPosMode:     Integer;    {positioning mode}
         ioPosOffset:   LongInt);   {positioning offset}
      CntrlParam:
         (ioCRefNum:    Integer;    {driver reference number}
         csCode:        Integer;    {type of control or status request}
         csParam:       ARRAY[0..10] OF Integer);  {control or status info}
      END;
      ParmBlkPtr = ^ParamBlockRec;
      AuxDCE = 
      RECORD
         dCtlDriver:    Ptr;        {pointer or handle to driver}
         dCtlFlags:     Integer;    {flags}
         dCtlQHdr:      QHdr;       {driver I/O queue header}
         dCtlPosition:  LongInt;    {byte position}
         dCtlStorage:   Handle;     {handle to private storage}
         dCtlRefNum:    Integer;    {driver reference number}
         dCtlCurTicks:  LongInt;    {used internally}
         dCtlWindow:    GrafPtr;    {pointer to driver's window}
         dCtlDelay:     Integer;    {ticks between periodic actions}
         dCtlEMask:     Integer;    {event mask for desk accessories}
         dCtlMenu:      Integer;    {menu ID for desk accessories}
         dCtlSlot:      Byte;       {slot}
         dCtlSlotId:    Byte;       {sResource directory ID}
         dCtlDevBase:   LongInt;    {slot device base address}
         dCtlOwner:     Ptr;        {reserved; must be 0}
         dCtlExtDev:    Byte;       {external device ID}
         fillByte:      Byte;       {reserved}
      END;
      AuxDCEPtr         = ^AuxDCE;
      AuxDCEHandle      = ^AuxDCEPtr;
</PRE>
<A NAME=HEADING52-61></A>
<H3>Routines</H3>
<A NAME=HEADING52-62></A>
<H4>Opening and Closing Device Drivers</H4>
<PRE>
FUNCTION OpenDriver     (name: Str255; VAR refNum: Integer): OSErr;
FUNCTION PBOpen         (paramBlock: ParmBlkPtr; async: Boolean): OSErr;
FUNCTION PBOpenSync     (paramBlock: ParmBlkPtr): OSErr;
FUNCTION OpenSlot       (paramBlock: ParmBlkPtr; async: Boolean): OSErr;
FUNCTION OpenDeskAcc    (deskAccName: Str255): INTEGER;
FUNCTION CloseDriver    (refNum: Integer): OSErr;
FUNCTION PBClose        (paramBlock: ParmBlkPtr; async: Boolean): OSErr;
FUNCTION PBCloseSync    (paramBlock: ParmBlkPtr): OSErr;
PROCEDURE CloseDeskAcc  (refNum: INTEGER);
</PRE>
<A NAME=HEADING52-72></A>
<H4>Communicating With Device Drivers</H4>
<PRE>
FUNCTION FSRead         (refNum: Integer; VAR count: LongInt; 
                         buffPtr: Ptr): OSErr;
FUNCTION PBRead         (paramBlock: ParmBlkPtr; async: Boolean): OSErr;
FUNCTION PBReadSync     (paramBlock: ParmBlkPtr): OSErr;
FUNCTION PBReadAsync    (paramBlock: ParmBlkPtr): OSErr;
FUNCTION FSWrite        (refNum: Integer: VAR count: LongInt;
                         buffPtr: Ptr): OSErr;
FUNCTION PBWrite        (paramBlock: ParmBlkPtr; async: Boolean): OSErr;
FUNCTION PBWriteSync    (paramBlock: ParmBlkPtr): OSErr;
FUNCTION PBWriteAsync   (paramBlock: ParmBlkPtr): OSErr;
</PRE>
<A NAME=HEADING52-81></A>
<H4>Controlling and Monitoring Device Drivers</H4>
<PRE>
FUNCTION Control          (refNum: Integer; csCode: Integer; 
                           csParamPtr: Ptr): OSErr;
FUNCTION PBControl        (paramBlock: ParmBlkPtr; async: Boolean): OSErr;
FUNCTION PBControlSync    (paramBlock: ParmBlkPtr): OSErr;
FUNCTION PBControlAsync   (paramBlock: ParmBlkPtr): OSErr;
FUNCTION Status           (refNum: Integer; csCode: Integer; 
                           csParamPtr: Ptr): OSErr;
FUNCTION PBStatus         (paramBlock: ParmBlkPtr; async: Boolean): OSErr;
FUNCTION PBStatusSync     (paramBlock: ParmBlkPtr): OSErr;
FUNCTION PBStatusAsync    (paramBlock: ParmBlkPtr): OSErr;
FUNCTION KillIO           (refNum: Integer): OSErr;
FUNCTION PBKillIO         (paramBlock: ParmBlkPtr; async: Boolean): OSErr;
FUNCTION PBKillIOSync     (paramBlock: ParmBlkPtr): OSErr;
FUNCTION PBKillIOAsync    (paramBlock: ParmBlkPtr): OSErr;
</PRE>
<A NAME=HEADING52-94></A>
<H4>Driver Support Routines</H4>
<PRE>
FUNCTION DriverInstall            (drvrPtr: Ptr; refNum: Integer): OSErr;
FUNCTION DriverInstallReserveMem  (drvrPtr: Ptr; refNum: Integer): OSErr;
FUNCTION DriverRemove             (refNum: Integer): OSErr;
FUNCTION GetDCtlEntry             (refNum: Integer): DCtlHandle;
</PRE>
<A NAME=HEADING52-99></A>
<H2>Assembly-Language Summary</H2>
<A NAME=HEADING52-100></A>
<H3>Data Structures</H3>
<A NAME=HEADING52-101></A>
<H4>Device Manager Parameter Block Header
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>0<TH>qLink<TH>long<TH>used internally by the Device Manager<TR>
<TD>4<TD>qType<TD>word<TD>used internally by the Device Manager<TR>
<TD>6<TD>ioTrap<TD>word<TD>used internally by the Device Manager<TR>
<TD>8<TD>ioCmdAddr<TD>long<TD>used internally by the Device Manager<TR>
<TD>12<TD>ioCompletion<TD>long<TD>completion routine<TR>
<TD>16<TD>ioResult<TD>word<TD>result code<TR>
<TD>18<TD>ioNamePtr<TD>long<TD>driver name<TR>
<TD>22<TD>ioVRefNum<TD>word<TD>drive number</TABLE>
 </H4>
<A NAME=HEADING52-102></A>
<H4>I/O Parameter Structure
<TABLE BORDER="0" CELLPADDING=3><TD>24<TD>ioRefNum<TD>word<TD>driver reference number<TR>
<TD>26<TD>ioVersNum<TD>byte<TD>not used<TR>
<TD>27<TD>ioPermssn<TD>byte<TD>read/write permission<TR>
<TD>28<TD>ioMisc<TD>long<TD>not used<TR>
<TD>32<TD>ioBuffer<TD>long<TD>pointer to data buffer<TR>
<TD>36<TD>ioReqCount<TD>long<TD>requested number of bytes<TR>
<TD>40<TD>ioActCount<TD>long<TD>actual number of bytes<TR>
<TD>44<TD>ioPosMode<TD>word<TD>positioning mode<TR>
<TD>46<TD>ioPosOffset<TD>long<TD>positioning offset</TABLE>
 </H4>
<A NAME=HEADING52-103></A>
<H4>Control Parameter Structure
<TABLE BORDER="0" CELLPADDING=3><TD>24<TD>ioCRefNum<TD>word<TD>driver reference number<TR>
<TD>26<TD>csCode<TD>word<TD>type of control or status request<TR>
<TD>28<TD>csParam<TD>22 bytes<TD>control or status information</TABLE>
 </H4>
<A NAME=HEADING52-104></A>
<H3>Trap Macros</H3>
<A NAME=HEADING52-105></A>
<H4>Trap Macro Names
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>C and Pascal name<TH>Trap macro name<TR>
<TD>PBOpen<TD>_Open<TR>
<TD>OpenSlot<TD>_Open<TR>
<TD>PBClose<TD>_Close<TR>
<TD>PBRead<TD>_Read<TR>
<TD>PBWrite<TD>_Write<TR>
<TD>PBControl<TD>_Control<TR>
<TD>PBStatus<TD>_Status<TR>
<TD>PBKillIO<TD>_KillIO<TR>
<TD>DriverInstall<TD>_DrvrInstall<TR>
<TD>DriverRemove<TD>_DrvrRemove</TABLE>
</H4>
<A NAME=HEADING52-106></A>
<H4>Routines Requiring Jump Vectors
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Routine<TH>Jump vector<TR>
<TD>Fetch<TD>JFetch<TR>
<TD>Stash<TD>JStash<TR>
<TD>IODone<TD>JIODone</TABLE>
</H4>
<A NAME=HEADING52-107></A>
<H2>Result Codes
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>noErr<TH>0<TH>No error<TR>
<TD>controlErr<TD>-17<TD>Driver does not respond to this control request<TR>
<TD>statusErr<TD>-18<TD>Driver does not respond to this status request<TR>
<TD>readErr<TD>-19<TD>Driver does not respond to read requests<TR>
<TD>writErr<TD>-20<TD>Driver does not respond to write requests<TR>
<TD>badUnitErr<TD>-21<TD>Driver reference number does not match unit table<TR>
<TD>unitEmptyErr<TD>-22<TD>Driver reference number specifies a <CODE>nil</CODE> handle in unit table<TR>
<TD>openErr<TD>-23<TD>Requested read/write permission does not match driver's open permission<TR>
<TD>closErr<TD>-24<TD>Driver unable to complete close request<TR>
<TD>dRemovErr<TD>-25<TD>Attempt to remove an open driver<TR>
<TD>dInstErr<TD>-26<TD>Driver resource not found<TR>
<TD>abortErr<TD>-27<TD>Request aborted by <CODE>KillIO</CODE><TR>
<TD>notOpenErr<TD>-28<TD>Driver not open<TR>
<TD>ioErr<TD>-36<TD>Data does not match in read-verify mode</TABLE>
</H2>
 <A NAME=MARKER-2-402></A><P>
</BLOCKQUOTE><P>
<DD>
</DL>
</DL>
</B>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Devices-51.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Devices-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Devices-328.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Devices-53.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Devices-3.html">&copy; Apple Computer, Inc.</A><br>3 JUL 1996</center></font><P>
<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->
</BODY>
</HTML>  
