<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Tumbler and Podium - /TumblerSource/Tumbler_menus.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">Tumbler and Podium</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Tumbler and Podium</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/TumblerSource/Tumbler_menus.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/TumblerSource/Tumbler_AEVT.c</option>
<option value="listing2.html">/TumblerSource/Tumbler_AEVT.h</option>
<option value="listing3.html">/TumblerSource/Tumbler_camera.c</option>
<option value="listing4.html">/TumblerSource/Tumbler_camera.h</option>
<option value="listing5.html">/TumblerSource/Tumbler_cursor.c</option>
<option value="listing6.html">/TumblerSource/Tumbler_cursor.h</option>
<option value="listing7.html">/TumblerSource/Tumbler_document.c</option>
<option value="listing8.html">/TumblerSource/Tumbler_document.h</option>
<option value="listing9.html">/TumblerSource/Tumbler_drag.c</option>
<option value="listing10.html">/TumblerSource/Tumbler_drag.h</option>
<option value="listing11.html">/TumblerSource/Tumbler_ErrorHandler.c</option>
<option value="listing12.html">/TumblerSource/Tumbler_ErrorHandler.h</option>
<option value="listing13.html">/TumblerSource/Tumbler_event.c</option>
<option value="listing14.html">/TumblerSource/Tumbler_event.h</option>
<option value="listing15.html">/TumblerSource/Tumbler_file.c</option>
<option value="listing16.html">/TumblerSource/Tumbler_file.h</option>
<option value="listing17.html">/TumblerSource/Tumbler_globals.h</option>
<option value="listing18.html">/TumblerSource/Tumbler_HideMenuBar.c</option>
<option value="listing19.html">/TumblerSource/Tumbler_HideMenuBar.h</option>
<option value="listing20.html">/TumblerSource/Tumbler_initialize.c</option>
<option value="listing21.html">/TumblerSource/Tumbler_initialize.h</option>
<option value="listing22.html">/TumblerSource/Tumbler_main.c</option>
<option value="listing23.html">/TumblerSource/Tumbler_main.h</option>
<option value="listing24.html">/TumblerSource/Tumbler_menus.c</option>
<option value="listing25.html">/TumblerSource/Tumbler_menus.h</option>
<option value="listing26.html">/TumblerSource/Tumbler_offscreen.c</option>
<option value="listing27.html">/TumblerSource/Tumbler_offscreen.h</option>
<option value="listing28.html">/TumblerSource/Tumbler_PICTImport.c</option>
<option value="listing29.html">/TumblerSource/Tumbler_PICTImport.h</option>
<option value="listing30.html">/TumblerSource/Tumbler_podium.c</option>
<option value="listing31.html">/TumblerSource/Tumbler_podium.h</option>
<option value="listing32.html">/TumblerSource/Tumbler_prototypes.h</option>
<option value="listing33.html">/TumblerSource/Tumbler_resources.h</option>
<option value="listing34.html">/TumblerSource/Tumbler_teutilities.c</option>
<option value="listing35.html">/TumblerSource/Tumbler_teutilities.h</option>
<option value="listing36.html">/TumblerSource/Tumbler_traps.c</option>
<option value="listing37.html">/TumblerSource/Tumbler_traps.h</option>
<option value="listing38.html">/TumblerSource/Tumbler_utility.c</option>
<option value="listing39.html">/TumblerSource/Tumbler_utility.h</option>
<option value="listing40.html">/TumblerSource/Tumbler_windows.c</option>
<option value="listing41.html">/TumblerSource/Tumbler_windows.h</option></select>
				</p>
				</form>
				<p><strong><a href="Tumbler_and_Podium.zip">Download Sample</a></strong> (&#147;Tumbler_and_Podium.zip&#148;, 1.07M)<BR>
<strong><a href="Tumbler_and_Podium.dmg">Download Sample</a></strong> (&#147;Tumbler_and_Podium.dmg&#148;, 1.15M)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">//    Tumbler_menus.c////    Menu handling routines and utilities.//    ////    Author:    Nick Thompson &amp; Pablo Fernicola, with thanks to the QuickDraw 3D team////  Modification History:////  11/25/94  Nick  Started Factoring for AppleEvent senders, cleanup////    Copyright &copy; 1992-95 Apple Computer, Inc., All Rights Reserved#define FINAL#include &lt;Drag.h&gt;#include &lt;Devices.h&gt;#include &lt;ColorPicker.h&gt;#include &quot;Tumbler_globals.h&quot;#include &quot;Tumbler_prototypes.h&quot;#include &quot;Tumbler_resources.h&quot;#include &quot;Tumbler_AEVT.h&quot;#include &quot;QD3DStorage.h&quot;#include &quot;QD3DIO.h&quot;#include &quot;QD3DView.h&quot;#include &quot;QD3DTransform.h&quot;#include &quot;QD3DDrawContext.h&quot;#include &quot;QD3DGeometry.h&quot;#include &quot;QD3DGroup.h&quot;#include &quot;QD3DShader.h&quot;#include &quot;QD3DLight.h&quot;#include &quot;QD3DRenderer.h&quot;#include &quot;QD3DAcceleration.h&quot;#include &quot;Tumbler_menus.h&quot;#include &quot;Tumbler_document.h&quot;#include &quot;Tumbler_file.h&quot;#include &quot;Tumbler_windows.h&quot;#include &quot;Tumbler_PICTImport.h&quot;#include &quot;Tumbler_drag.h&quot;#include &quot;Tumbler_offscreen.h&quot;#include &quot;Tumbler_menus.h&quot;#include &quot;Tumbler_utility.h&quot;#include &quot;Tumbler_camera.h&quot;#define BETA_OR_LATER 1#if !defined(BETA_OR_LATER) || (BETA_OR_LATER == 0)#include &quot;Catwoman.h&quot;#endifstatic void DoCopy(DocumentPtr theDocument, Boolean cut);static short FindCheckItem(MenuHandle theMenu, short rangeStart, short rangeEnd);static short Check1Item(MenuHandle theMenu, short theItem, short rangeStart, short rangeEnd);static short ItemCheck(MenuHandle theMenu, short theItem);static short ToggleCheck(MenuHandle theMenu, short theItem);static void SetItemEnable(MenuHandle theMenu, short theItem, short enable);static short ItemStringToItem(Str255 theItemString, MenuHandle theMenu);static short FontToItem(short fontFamilyNumber);static short DoSpecialPaste(DocumentPtr theDocument);static void DoPaste(DocumentPtr theDocument);static void UpdateWindow( WindowPtr theWindow){  GrafPtr  savedPort ;    // just tell the toolbox that the window is bogus  GetPort(&amp;savedPort) ;  SetPort(theWindow) ;  InvalRect( &amp;theWindow-&gt;portRect ) ;  SetPort(savedPort) ;}static void DoCopy(DocumentPtr theDocument, Boolean cut){  TQ3FileObject     fd;  TQ3StorageObject   st;  Handle        theData;  long         anErr;  unsigned long    size;  PicHandle      thePicture;  GrafPtr        restorePort;  RGBColor      qdBgColor;  Boolean        didAllocate = false ;    // Write the data to a strage object   // as of 1.0a3 handle storage objects break when increasing the size  // of the handle in increments with complex models.  To try to get  // around this we'll temporarily allocate a 1 meg handle. FIX THIS  if((theData = NewHandle( 1024 * 1024 )) != nil) {    MoveHHi( theData ) ;    HLock( theData ) ;    didAllocate = true ;    st = Q3HandleStorage_New( theData, GetHandleSize( theData ) );  }  else      st = Q3HandleStorage_New(nil, 0);  if (st == nil)  {    if( didAllocate )      DisposeHandle( theData ) ;    return;  }    fd = Q3File_New();    if (fd == nil) {    Q3Object_Dispose(st);    if( didAllocate )      DisposeHandle( theData ) ;    return;  }    Q3File_SetStorage(fd, st);        Tumbler_WriteScene(fd,             false,            theDocument) ;    theData = nil; size = 0;    if( Q3HandleStorage_Get(st, &amp;theData, &amp;size) == kQ3Failure ) {    Q3Object_Dispose(st);    if( didAllocate )      DisposeHandle( theData ) ;    return;  }    /* Transfer the data to the scrap */  HLock(theData);    GetPort( &amp;restorePort);  SetPort( (GrafPtr) theDocument-&gt;theWindow);    qdBgColor.red   = (unsigned short)65535;  qdBgColor.green = (unsigned short)65535;  qdBgColor.blue   = (unsigned short)65535;  RGBBackColor(&amp;qdBgColor);  qdBgColor.red   = 0;  qdBgColor.green = 0;  qdBgColor.blue   = 0;  RGBForeColor(&amp;qdBgColor);  thePicture = OpenPicture(&amp;theDocument-&gt;theWindow-&gt;portRect);  EraseRect( &amp;theDocument-&gt;theWindow-&gt;portRect ) ;    if( DrawOffscreen(theDocument) == kQ3Failure ) {    goto memExit;  }    ClosePicture();    HLock( (Handle) thePicture);    /* Initialize the scrap */  anErr = LoadScrap();  if (anErr != noErr) {    goto errorExit;  } else {    anErr = ZeroScrap();    if (anErr == noErr) {      anErr = PutScrap(size, '3DMF', (Ptr) *theData);      if (anErr == noErr) {        anErr = PutScrap(GetHandleSize((Handle)thePicture), 'PICT', (Ptr) *thePicture);        if (anErr == noErr) {          anErr = UnloadScrap();        }      }    }  }    HUnlock(theData);  if( cut == true ) {    Q3Object_Dispose(theDocument-&gt;documentGroup);    theDocument-&gt;documentGroup = nil;    SetPort(theDocument-&gt;theWindow) ;    InvalRect( &amp;theDocument-&gt;theWindow-&gt;portRect) ;  }  errorExit:    SetPort(restorePort);  HUnlock((Handle)thePicture);  KillPicture(thePicture);  memExit:    Q3Object_Dispose(st);    if( didAllocate )    DisposeHandle( theData ) ;      Q3Object_Dispose(fd);  return;}////  Given a range of menu items and a menu, FindCheckItem returns the//  item number of the first checked item. If no items in the range//  are checked, FindCheckItem returns 0 (zero).//static short FindCheckItem(MenuHandle theMenu, short rangeStart, short rangeEnd){  short    theMark;  while (rangeStart &lt;= rangeEnd) {    GetItemMark(theMenu, rangeStart, &amp;theMark);    if (theMark == checkMark)      return(rangeStart);    rangeStart++;  }  return(0);}////  Check1Item checks a single menu item in a range of menu items. theItem is//  the item number to check. rangeStart and rangeEnd denote a range of menu//  items that theItem belongs to. Check1Item checks theItem and removes//  any checks from the other items in the given range. Check1Item returns//  the item number of the checked item if a newly checked item is selected.//  If theItem was already checked or theItem was outside of the given range,//  Check1Item returns 0 (zero).//static short Check1Item(MenuHandle theMenu, short theItem, short rangeStart, short rangeEnd){  short    theMark;  if ((theItem &lt; rangeStart) || (theItem &gt; rangeEnd))    return(0);  while (rangeStart &lt;= rangeEnd) {    if (rangeStart != theItem)      CheckItem(theMenu, rangeStart, false);    rangeStart++;  }  GetItemMark(theMenu, theItem, &amp;theMark);  if (theMark != checkMark) {    CheckItem(theMenu, theItem, true);    return(theItem);  } else {    return(0);  }}////  ItemCheck returns true if the given menu item is checked, false otherwise.//static short ItemCheck(MenuHandle theMenu, short theItem){  short    theMark;  GetItemMark(theMenu, theItem, &amp;theMark);  return(theMark == checkMark);}////  ToggleCheck toggles the check mark on the given menu item. ToggleCheck//  returns true if the item becomes checked and false if the item becomes//  unchecked.//static short ToggleCheck(MenuHandle theMenu, short theItem){  short    theMark;  GetItemMark(theMenu, theItem, &amp;theMark);  CheckItem(theMenu, theItem, theMark = (theMark != checkMark));  return(theMark);}////  SetItemEnable enables or disables a menu item depending on the value//  of the enable parameter.//static void SetItemEnable(MenuHandle theMenu, short theItem, short enable){  if (enable) {    EnableItem(theMenu, theItem);  } else {    DisableItem(theMenu, theItem);  }}////  Given a string and a menu, ItemStringToItem will return the item number//  of the last item that matches the string.//static short ItemStringToItem(Str255 theItemString, MenuHandle theMenu){  short    index;  Str255    theString;  index = CountMItems(theMenu);  while (index) {    GetMenuItemText(theMenu, index, theString);    if (PStrCmp( (char *) theString, (char *) theItemString))      return(index);    index--;  }  return(0);}static short FontToItem(short fontFamilyNumber){  Str255    fontName;  GetFontName(fontFamilyNumber, fontName);  return(ItemStringToItem(fontName, GetMenuHandle(idDisplayMenu)));}////  PrepareMenus is called before the user pulls down a menu from the menu//  bar or types a command key equivalent. PrepareMenus enables and disables//  menu items within the current program context. Any other menu related//  setup may be performed here.//void PrepareMenus(void){  MenuHandle    theMenu;  DocumentPtr   theDocument;  WindowPtr    theWindow = FrontWindow() ;  short      teSelection, theMode;  Str255      theStr;  theDocument = GetDocumentFromWindow(theWindow);  teSelection = (short) theDocument-&gt;documentGroup;  theMenu = GetMenuHandle(idFileMenu);  SetItemEnable(theMenu, NewItem,   gDocumentCount &lt; MaxDocumentCount);  SetItemEnable(theMenu, OpenItem,  gDocumentCount &lt; MaxDocumentCount);  SetItemEnable(theMenu, CloseItem, theDocument != 0L);  SetItemEnable(theMenu, SaveItem, (theDocument) &amp;&amp; (theDocument-&gt;dirty));  SetItemEnable(theMenu, SaveAsItem, theDocument != 0L);  SetItemEnable(theMenu, RevertItem, (theDocument) &amp;&amp;                     (theDocument-&gt;theFileSpec.parID != 0 ) &amp;&amp;                     (theDocument-&gt;theFileSpec.vRefNum != 0 ));#ifdef PODIUM_APP  SetItemEnable(theMenu, ImportItem, theWindow != nil ) ;#endif  SetItemEnable(theMenu, PageSetupItem, false);  SetItemEnable(theMenu, PrintItem, false);  theMenu = GetMenuHandle(idEditMenu);  GetIndString(theStr, MenuStringsID, gCanUndoDrag);  SetMenuItemText(theMenu, iUndo, theStr);  SetItemEnable(theMenu, iUndo, gCanUndoDrag != slCantUndo);  SetItemEnable(theMenu, iCut, teSelection);  SetItemEnable(theMenu, iCopy, teSelection);  SetItemEnable(theMenu, iPaste, theDocument != 0L);  SetItemEnable(theMenu, iClear, teSelection);  SetItemEnable(theMenu, iSelectAll, theDocument != 0L);  SetItemEnable(theMenu, iShowClipboard, false);#ifdef PODIUM_APP  theMenu = GetMenuHandle(idSlides);  SetItemEnable(theMenu, 0, theWindow != nil);    if(theWindow != nil ) {      SetItemEnable(theMenu, iNext, false);    // dummy item, never used    SetItemEnable(theMenu, iPrevious, false);    // dummy item, never used    SetItemEnable(theMenu, iIndex, false);    // dummy item, never used      SetItemEnable(theMenu, iRotateModel, true);        SetItemEnable(theMenu, iHideShowMenu, true);        CheckItem(theMenu, iRotateModel, theDocument-&gt;animateModel);  }#else  theMenu = GetMenuHandle(idDisplayMenu);  SetItemEnable(theMenu, iShaded, false);  SetItemEnable(theMenu, iLighted, false);  SetItemEnable(theMenu, iAnimated, false);  SetItemEnable(theMenu, iRenderer, false);  SetItemEnable(theMenu, iBackFacing, false);    if (theDocument) {    theMode = 0;    if( theDocument-&gt;documentGroup) {      MenuHandle    subMenu;      SetItemEnable(theMenu, iShaded, true);      subMenu = GetMenu(idStyleMenu);      CheckItem(subMenu, iGouraud, false);      CheckItem(subMenu, iPhong, false);      CheckItem(subMenu, iFlat, false);      if( theDocument-&gt;currentInterpolation == kQ3InterpolationStyleNone) {        CheckItem(subMenu, iFlat, true);      } else if( theDocument-&gt;currentInterpolation == kQ3InterpolationStylePixel) {        CheckItem(subMenu, iPhong, true);      } else {        CheckItem(subMenu, iGouraud, true);      }      SetItemEnable(theMenu, iRenderer, true);      subMenu = GetMenu(idRendererMenu);      CheckItem(subMenu, iWF, false);      CheckItem(subMenu, iCTSW, false);      CheckItem(subMenu, iCTHW, false);      {        TQ3Object  renderer;                Q3View_GetRenderer(theDocument-&gt;theView, &amp;renderer);                switch(Q3Object_GetLeafType(renderer)) {          case kQ3RendererTypeWireFrame:            CheckItem(subMenu, iWF, true);            break;          case kQ3RendererTypeInteractive:            if(!gUsingHardware) {              CheckItem(subMenu, iCTSW, true);            }            else {              CheckItem(subMenu, iCTHW, true);            }            break;          default:            break;        }        Q3Object_Dispose(renderer);      }             SetItemEnable(theMenu, iLighted, true);      if( theDocument-&gt;light == kQ3True) {        CheckItem(theMenu, iLighted, true);      } else {        CheckItem(theMenu, iLighted, false);      }      SetItemEnable(theMenu, iAnimated, true);      subMenu = GetMenu(idAnimateMenu);      if( theDocument-&gt;animateLights == kQ3True) {        CheckItem(subMenu, iLights, true);      } else {        CheckItem(subMenu, iLights, false);      }      if( theDocument-&gt;animateModel == kQ3True) {        CheckItem(subMenu, iModel, true);      } else {        CheckItem(subMenu, iModel, false);      }            SetItemEnable(theMenu, iBackFacing, true);    }  }#endif  DrawMenuBar() ;}static short DoSpecialPaste(DocumentPtr theDocument){  long    size, offset;  Handle    theData;  size = GetScrap(0L, 'UPRC', &amp;offset);  if (size &lt;= 0)    return(0);  theData = NewHandle(size);  GetScrap(theData, 'UPRC', &amp;offset);  HLock(theData);  PutScrap(size, 'test', *theData);  HUnlock(theData);  DisposeHandle(theData);  return(0);}static void DoPaste(DocumentPtr theDocument){  long      size, offset;  Handle      theData;  long      anErr= noErr;  TQ3SharedObject  viewHints ;    anErr = LoadScrap();  if (anErr == noErr) {    size = GetScrap(0L, '3DMF', &amp;offset);      if (size &gt; 0) {      TQ3FileObject     fd;      TQ3StorageObject     storage;      TQ3Object       objects = nil;        theData = NewHandle(size);      if( theData ) {        GetScrap(theData, '3DMF', &amp;offset);              HLock(theData);            /* Read from clipboard */        storage = Q3MemoryStorage_New((unsigned char *) *theData, (unsigned long) size);                if (storage == nil)          goto bail;                fd = Q3File_New();        Q3File_SetStorage(fd, storage);        Q3Object_Dispose(storage);                if (fd == nil)          goto bail;                Tumbler_ReadScene(  fd,                  false,                  &amp;viewHints,                  &amp;theDocument-&gt;documentGroup) ;                TumblerDocument_UpdateView( theDocument, viewHints ) ;                AdjustLightsPositions(theDocument);              if (viewHints != NULL )          Q3Object_Dispose(viewHints);        DrawOffscreen(theDocument);        // DrawControls(theDocument-&gt;theWindow);        DoDrawGrowIcon(theDocument-&gt;theWindow);      bail:        Q3Object_Dispose(fd);            HUnlock(theData);        DisposeHandle(theData);      }    } else {      size = GetScrap(0L,'PICT', &amp;offset);            if( size &gt; 0 &amp;&amp; theDocument-&gt;documentGroup) {        TQ3StoragePixmap     textureImage;            theData = NewHandle(size);                if( theData ) {          GetScrap(theData, 'PICT', &amp;offset);                  HLock(theData);                if( TextureFromPICT( (PicHandle) theData, &amp;textureImage) == kQ3True ) {              if( AddTextureToDocument( theDocument, &amp;textureImage) == kQ3Success ) {                DrawOffscreen(theDocument);                            // DrawControls(theDocument-&gt;theWindow);              DoDrawGrowIcon(theDocument-&gt;theWindow);            } else {              Alert(130, 0L);            }          } else {            Alert(130, 0L);          }          HUnlock(theData);          DisposeHandle(theData);        } else {          Alert(130, 0L);        }      }    }  }}////  DoMenuCommand dispatches menu command routines from a menu select parameter.//  This function is called when the user selects a menu item with the mouse//  or types a command key equivalent.//void DoMenuCommand(long select){  short    theMenuID, theItem, result;  MenuHandle  theMenu;  Str255    theName;  WindowPtr  theWindow;  DocumentPtr theDocument;  theDocument = GetDocumentFromWindow(theWindow = FrontWindow());  theItem   = LoWord(select);  theMenuID = HiWord(select);  theMenu   = GetMenuHandle(theMenuID);  switch(theMenuID) {    case idAppleMenu:      switch(theItem) {        case AboutItem:          result = Alert(256, 0L);          break;        default:          GetMenuItemText(GetMenuHandle(idAppleMenu), theItem, theName);          OpenDeskAcc(theName);      }      break;    case idFileMenu:      switch(theItem) {              case NewItem:          DoNewDocument();          break;                  case OpenItem:          DoOpenDocument(theDocument);          break;#ifdef PODIUM_APP        case ImportItem:          DoImport3DMFDocument(theDocument);          break;#endif                  case CloseItem:          if (theDocument) {            (void)CloseDocument(theDocument);    // it's not important what the result is here          }          break;                  case SaveItem:          if (theDocument)            DidSaveDocument(theDocument);          break;                  case SaveAsItem:          if (theDocument)            DoSaveAsDocument(theDocument);          break;                  case RevertItem:          if (theDocument)            DoRevertDocument(theDocument);          break;                  case QuitItem:          // to quit we just send ourselves an appleEvent          SendQuitApp() ;          break;      }      break;    case idEditMenu:      switch(theItem) {        case iUndo:          break;                  case iCut:          if (theDocument) {            DoCopy(theDocument, true);          }          break;                  case iCopy:          if (theDocument) {            DoCopy(theDocument, false);          }          break;                  case iPaste:          if (theDocument) {            DoPaste(theDocument);          }          UpdateWindow( theDocument-&gt;theWindow ) ;           break;                  case iClear:          break;                  case iSelectAll:          break;                }      break;#ifndef PODIUM_APP    case idDisplayMenu:      switch(theItem) {        case iBGColor:          {            TQ3DrawContextObject    drawCtx ;            RGBColor          currentRGBClearColor = { 0xffff, 0xffff, 0xffff } ;            RGBColor          newRGBClearColor ;                        Point            wherePt = { 0, 0 } ;            float            factor = 0xffff ;            GrafPtr            savedPort ;                        Q3View_GetDrawContext( theDocument-&gt;theView, &amp;drawCtx ) ;                        currentRGBClearColor.red *= theDocument-&gt;clearColor.r ;            currentRGBClearColor.green *= theDocument-&gt;clearColor.g ;            currentRGBClearColor.blue *= theDocument-&gt;clearColor.b ;                        // query the user for a color            if(GetColor(wherePt,&quot;\pChoose a new background color&quot;,&amp;currentRGBClearColor,&amp;newRGBClearColor)) {                          theDocument-&gt;clearColor.r = newRGBClearColor.red / factor ;              theDocument-&gt;clearColor.g = newRGBClearColor.green / factor ;              theDocument-&gt;clearColor.b = newRGBClearColor.blue / factor ;                            Q3DrawContext_SetClearImageColor( drawCtx, &amp;theDocument-&gt;clearColor ) ;                          }                        Q3Object_Dispose( drawCtx ) ;                        GetPort( &amp;savedPort ) ;            SetPort( (GrafPtr)theDocument-&gt;theWindow) ;            InvalRect( &amp;theDocument-&gt;theWindow-&gt;portRect ) ;            SetPort( savedPort ) ;                                }          break ;        case iLighted:          if( theDocument-&gt;light == kQ3True) {            TQ3GroupPosition    lightPosition;            TQ3LightObject    theLight;            TQ3GroupObject    lightGroup;                            theDocument-&gt;light = kQ3False;                        Q3View_GetLightGroup(theDocument-&gt;theView, &amp;lightGroup);            Q3Group_GetFirstPosition(lightGroup, &amp;lightPosition);                        /* First one is always on, skip */            Q3Group_GetNextPosition(lightGroup, &amp;lightPosition);            Q3Group_GetPositionObject(lightGroup, lightPosition, &amp;theLight);            Q3Light_SetState(theLight,kQ3False);            Q3Object_Dispose(theLight);                                    Q3Group_GetNextPosition(lightGroup, &amp;lightPosition);            Q3Group_GetPositionObject(lightGroup, lightPosition, &amp;theLight);            Q3Light_SetState(theLight,kQ3False);                        Q3Object_Dispose(theLight);                                    Q3Group_GetNextPosition(lightGroup, &amp;lightPosition);            Q3Group_GetPositionObject(lightGroup, lightPosition, &amp;theLight);            Q3Light_SetState(theLight,kQ3False);                        Q3Object_Dispose(theLight);                        Q3Object_Dispose(lightGroup);            CheckItem(theMenu, theItem, false);          }else {              TQ3GroupPosition    lightPosition;            TQ3LightObject    theLight;            TQ3GroupObject  lightGroup;                            theDocument-&gt;light = kQ3True;                        Q3View_GetLightGroup(theDocument-&gt;theView, &amp;lightGroup);            Q3Group_GetFirstPosition(lightGroup, &amp;lightPosition);                        /* First one is always on, skip */            Q3Group_GetNextPosition(lightGroup, &amp;lightPosition);            Q3Group_GetPositionObject(lightGroup, lightPosition, &amp;theLight);            Q3Light_SetState(theLight,kQ3True);            Q3Object_Dispose(theLight);                                    Q3Group_GetNextPosition(lightGroup, &amp;lightPosition);            Q3Group_GetPositionObject(lightGroup, lightPosition, &amp;theLight);            Q3Light_SetState(theLight,kQ3True);                        Q3Object_Dispose(theLight);                                    Q3Group_GetNextPosition(lightGroup, &amp;lightPosition);            Q3Group_GetPositionObject(lightGroup, lightPosition, &amp;theLight);            Q3Light_SetState(theLight,kQ3True);                        Q3Object_Dispose(theLight);                        Q3Object_Dispose(lightGroup);                        CheckItem(theMenu, theItem, true);          }                      DrawOffscreen(theDocument);          UpdateWindow( theDocument-&gt;theWindow ) ;          if( theDocument-&gt;viewHints ) {            Q3Object_Dispose(theDocument-&gt;viewHints);          }          theDocument-&gt;viewHints = Q3ViewHints_New(theDocument-&gt;theView);          DoDrawGrowIcon(theDocument-&gt;theWindow);          break;                  default:          break;      }      break;      #endif     case idAnimateMenu:      if( theItem == iModel ) {        if( theDocument-&gt;animateModel == kQ3True) {          theDocument-&gt;animateModel = kQ3False;          CheckItem(theMenu, theItem, false);        }else {          theDocument-&gt;animateModel = kQ3True;          CheckItem(theMenu, theItem, true);        }      } else if( theItem == iLights) {        if( theDocument-&gt;animateLights == kQ3True) {          theDocument-&gt;animateLights = kQ3False;          CheckItem(theMenu, theItem, false);        }else {          theDocument-&gt;animateLights = kQ3True;          CheckItem(theMenu, theItem, true);        }      }        break;        case idRendererMenu:      {        TQ3DrawContextObject    myDrawContext;        // set the doupble buffer state to false, make the active buffer        // to be the front buffer        gUsingHardware = false ;        Q3View_GetDrawContext(theDocument-&gt;theView, &amp;myDrawContext) ;        Q3DrawContext_SetDoubleBufferState(  myDrawContext, kQ3True ) ;        Q3Object_Dispose( myDrawContext ) ;      }      switch(theItem) {        case iWF:          Q3View_SetRendererByType(theDocument-&gt;theView,kQ3RendererTypeWireFrame);          CheckItem(theMenu, iCTHW, false);          CheckItem(theMenu, iCTSW, false);          CheckItem(theMenu, iWF, true);          theDocument-&gt;shaded = kQ3False;          break;        case iCTSW:          {            {              TQ3RendererObject rendererObject;                            rendererObject = Q3Renderer_NewFromType(kQ3RendererTypeInteractive);              Q3View_SetRenderer(theDocument-&gt;theView,rendererObject);              #ifdef FINAL              Q3InteractiveRenderer_SetPreferences(rendererObject, kQAVendor_Apple, kQAVendor_BestChoice);#else              Q3InteractiveRenderer_SetPreferences(rendererObject, ZcVendor_Apple, ZcVendor_BestChoice);#endif              Q3Object_Dispose(rendererObject);            }            CheckItem(theMenu, iWF, false);            CheckItem(theMenu, iCTHW, false);            CheckItem(theMenu, iCTSW, true);            theDocument-&gt;shaded = kQ3True;          }          break;        case iCTHW:          {            TQ3DrawContextObject    myDrawContext;            // set the doupble buffer state to false, make the active buffer            // to be the front buffer            gUsingHardware = true ;            Q3View_GetDrawContext(theDocument-&gt;theView, &amp;myDrawContext) ;            Q3DrawContext_SetDoubleBufferState(  myDrawContext, kQ3False ) ;            Q3Object_Dispose( myDrawContext ) ;                        {              TQ3RendererObject rendererObject;                            rendererObject = Q3Renderer_NewFromType(kQ3RendererTypeInteractive);              Q3View_SetRenderer(theDocument-&gt;theView,rendererObject);              #ifdef FINAL              Q3InteractiveRenderer_SetPreferences(rendererObject, kQAVendor_BestChoice, 0);#else              Q3InteractiveRenderer_SetPreferences(rendererObject, ZcVendor_BestChoice, 0);#endif              Q3Object_Dispose(rendererObject);            }            CheckItem(theMenu, iWF, false);            CheckItem(theMenu, iCTSW, false);            CheckItem(theMenu, iCTHW, true);            theDocument-&gt;shaded = kQ3True;          }          break;      }      DrawOffscreen(theDocument) ;      UpdateWindow( theDocument-&gt;theWindow ) ;      if( theDocument-&gt;viewHints ) {        Q3Object_Dispose(theDocument-&gt;viewHints);      }      theDocument-&gt;viewHints = Q3ViewHints_New(theDocument-&gt;theView);      DoDrawGrowIcon(theDocument-&gt;theWindow) ;      break ;          // menu to allow modification of the backfacing style    case idBackfacingMenu:      switch(theItem) {              case iDrawBoth:          Q3BackfacingStyle_Set(theDocument-&gt;backfacingStyle, kQ3BackfacingStyleBoth);          CheckItem(theMenu, iDrawBoth, true);          CheckItem(theMenu, iRemoveBackfacing, false);          CheckItem(theMenu, iFlipNormals, false);          break;                  case iRemoveBackfacing:                  Q3BackfacingStyle_Set(theDocument-&gt;backfacingStyle, kQ3BackfacingStyleRemove);          CheckItem(theMenu, iDrawBoth, false);          CheckItem(theMenu, iRemoveBackfacing, true);          CheckItem(theMenu, iFlipNormals, false);          break;                  case iFlipNormals:          Q3BackfacingStyle_Set(theDocument-&gt;backfacingStyle, kQ3BackfacingStyleFlip);          CheckItem(theMenu, iDrawBoth, false);          CheckItem(theMenu, iRemoveBackfacing, false);          CheckItem(theMenu, iFlipNormals, true);          break;                }      DrawOffscreen(theDocument);      UpdateWindow( theDocument-&gt;theWindow ) ;            // DrawControls(theDocument-&gt;theWindow);      DoDrawGrowIcon(theDocument-&gt;theWindow);      break;    case idStyleMenu://      DisableUndoDrag();      switch(theItem){        case iFlat:          theDocument-&gt;currentInterpolation = kQ3InterpolationStyleNone;          CheckItem(theMenu, iGouraud, false);          CheckItem(theMenu, iPhong, false);          CheckItem(theMenu, iFlat, true);          break;        case iGouraud:          theDocument-&gt;currentInterpolation = kQ3InterpolationStyleVertex;          CheckItem(theMenu, iPhong, false);          CheckItem(theMenu, iFlat, false);          CheckItem(theMenu, iGouraud, true);          break;        case iPhong:          theDocument-&gt;currentInterpolation = kQ3InterpolationStylePixel;          CheckItem(theMenu, iGouraud, false);          CheckItem(theMenu, iFlat, false);          CheckItem(theMenu, iPhong, true);          break;      }            DrawOffscreen(theDocument);      UpdateWindow( theDocument-&gt;theWindow ) ;      DoDrawGrowIcon(theDocument-&gt;theWindow);      break;#ifdef PODIUM_APP    case idSlides:      switch(theItem){        case iRotateModel:          if( theDocument-&gt;animateModel == kQ3True )            theDocument-&gt;animateModel = kQ3False ;          else            theDocument-&gt;animateModel = kQ3True ;          break ;        case iHideShowMenu:          {            void ToggleMenuBar(void) ;            ToggleMenuBar() ;          }        default:          break ;      }      break ;#endif              default:      break;  }//  if ((theDocument = GetDocumentFromWindow(FrontWindow())) != nil)//    TEGetHiliteRgn(theDocument-&gt;hiliteRgn, theDocument-&gt;theTE);  HiliteMenu(0);}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Tumbler_and_Podium/listing24.html%3Fid%3DDTS10000127-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Tumbler_and_Podium/listing24.html%3Fid%3DDTS10000127-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Tumbler_and_Podium/listing24.html%3Fid%3DDTS10000127-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>