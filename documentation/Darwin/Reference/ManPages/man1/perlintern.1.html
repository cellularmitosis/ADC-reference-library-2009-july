<html><head><title>Mac OS X
 Manual Page For perlintern(1)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/1/perlintern" title="Mac OS X
 Manual Page for perlintern(1)"><!-- headerDoc=man; indexgroup=Section 1; uid="//apple_ref/doc/man/1/perlintern"; name=perlintern(1) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
PERLINTERN(1)                         Perl Programmers Reference Guide                         PERLINTERN(1)



<b>NAME</b>
       perlintern - autogenerated documentation of purely <b>internal</b>            Perl functions

<b>DESCRIPTION</b>
       This file is the autogenerated documentation of functions in the Perl interpreter that are documented
       using Perl's internal documentation format but are not marked as part of the Perl API. In other
       words, <b>they</b> <b>are</b> <b>not</b> <b>for</b> <b>use</b> <b>in</b> <b>extensions</b>!

<b>CV</b> <b>reference</b> <b>counts</b> <b>and</b> <b>CvOUTSIDE</b>
       CvWEAKOUTSIDE
               Each CV has a pointer, "CvOUTSIDE()", to its lexically enclosing CV (if any). Because point-<font color="#ffffff" class="whiteout">ers&nbsp;pointers</font>
               ers to anonymous sub prototypes are stored in "&amp;" pad slots, it is a possible to get a circu-<font color="#ffffff" class="whiteout">lar&nbsp;circular</font>
               lar reference, with the parent pointing to the child and vice-versa. To avoid the ensuing
               memory leak, we do not increment the reference count of the CV pointed to by "CvOUTSIDE" in
               the <u>one</u> <u>specific</u> <u>instance</u> that the parent has a "&amp;" pad slot pointing back to us. In this
               case, we set the "CvWEAKOUTSIDE" flag in the child. This allows us to determine under what
               circumstances we should decrement the refcount of the parent when freeing the child.

               There is a further complication with non-closure anonymous subs (i.e. those that do not refer
               to any lexicals outside that sub). In this case, the anonymous prototype is shared rather
               than being cloned. This has the consequence that the parent may be freed while there are
               still active children, eg

                   BEGIN { $a = sub { eval '$x' } }

               In this case, the BEGIN is freed immediately after execution since there are no active refer-<font color="#ffffff" class="whiteout">ences&nbsp;references</font>
               ences to it: the anon sub prototype has "CvWEAKOUTSIDE" set since it's not a closure, and $a
               points to the same CV, so it doesn't contribute to BEGIN's refcount either.  When $a is exe-<font color="#ffffff" class="whiteout">cuted,&nbsp;executed,</font>
               cuted, the "eval '$x'" causes the chain of "CvOUTSIDE"s to be followed, and the freed BEGIN
               is accessed.

               To avoid this, whenever a CV and its associated pad is freed, any "&amp;" entries in the pad are
               explicitly removed from the pad, and if the refcount of the pointed-to anon sub is still pos-<font color="#ffffff" class="whiteout">itive,&nbsp;positive,</font>
               itive, then that child's "CvOUTSIDE" is set to point to its grandparent. This will only occur
               in the single specific case of a non-closure anon prototype having one or more active refer-<font color="#ffffff" class="whiteout">ences&nbsp;references</font>
               ences (such as $a above).

               One other thing to consider is that a CV may be merely undefined rather than freed, eg "undef
               &amp;foo". In this case, its refcount may not have reached zero, but we still delete its pad and
               its "CvROOT" etc.  Since various children may still have their "CvOUTSIDE" pointing at this
               undefined CV, we keep its own "CvOUTSIDE" for the time being, so that the chain of lexical
               scopes is unbroken. For example, the following should print 123:

                   my $x = 123;
                   sub tmp { sub { eval '$x' } }
                   my $a = tmp();
                   undef &amp;tmp;
                   print  $a-&gt;();

                       bool    CvWEAKOUTSIDE(CV *cv)

<b>Functions</b> <b>in</b> <b>file</b> <b>pad.h</b>
       CX_CURPAD_SAVE
               Save the current pad in the given context block structure.

                       void    CX_CURPAD_SAVE(struct context)

       CX_CURPAD_SV
               Access the SV at offset po in the saved current pad in the given context block structure (can
               be used as an lvalue).

                       SV *    CX_CURPAD_SV(struct context, PADOFFSET po)

       PAD_BASE_SV
               Get the value from slot "po" in the base (DEPTH=1) pad of a padlist

                       SV *    PAD_BASE_SV(PADLIST padlist, PADOFFSET po)

       PAD_CLONE_VARS
               |CLONE_PARAMS* param Clone the state variables associated with running and compiling pads.

                       void    PAD_CLONE_VARS(PerlInterpreter *proto_perl \)

       PAD_COMPNAME_FLAGS
               Return the flags for the current compiling pad name at offset "po". Assumes a valid slot
               entry.

                       U32     PAD_COMPNAME_FLAGS(PADOFFSET po)

       PAD_COMPNAME_GEN
               The generation number of the name at offset "po" in the current compiling pad (lvalue). Note
               that "SvCUR" is hijacked for this purpose.

                       STRLEN  PAD_COMPNAME_GEN(PADOFFSET po)

       PAD_COMPNAME_GEN_set
               Sets the generation number of the name at offset "po" in the current ling pad (lvalue) to
               "gen".  Note that "SvCUR_set" is hijacked for this purpose.

                       STRLEN  PAD_COMPNAME_GEN_set(PADOFFSET po, int gen)

       PAD_COMPNAME_OURSTASH
               Return the stash associated with an "our" variable.  Assumes the slot entry is a valid "our"
               lexical.

                       HV *    PAD_COMPNAME_OURSTASH(PADOFFSET po)

       PAD_COMPNAME_PV
               Return the name of the current compiling pad name at offset "po". Assumes a valid slot entry.

                       char *  PAD_COMPNAME_PV(PADOFFSET po)

       PAD_COMPNAME_TYPE
               Return the type (stash) of the current compiling pad name at offset "po". Must be a valid
               name. Returns null if not typed.

                       HV *    PAD_COMPNAME_TYPE(PADOFFSET po)

       PAD_DUP Clone a padlist.

                       void    PAD_DUP(PADLIST dstpad, PADLIST srcpad, CLONE_PARAMS* param)

       PAD_RESTORE_LOCAL
               Restore the old pad saved into the local variable opad by <u>PAD</u><b>_</b><u>SAVE</u><b>_</b><u>LOCAL()</u>

                       void    PAD_RESTORE_LOCAL(PAD *opad)

       PAD_SAVE_LOCAL
               Save the current pad to the local variable opad, then make the current pad equal to npad

                       void    PAD_SAVE_LOCAL(PAD *opad, PAD *npad)

       PAD_SAVE_SETNULLPAD
               Save the current pad then set it to null.

                       void    PAD_SAVE_SETNULLPAD()

       PAD_SETSV
               Set the slot at offset "po" in the current pad to "sv"

                       SV *    PAD_SETSV(PADOFFSET po, SV* sv)

       PAD_SET_CUR
               Set the current pad to be pad "n" in the padlist, saving the previous current pad. NB cur-<font color="#ffffff" class="whiteout">rently&nbsp;currently</font>
               rently this macro expands to a string too long for some compilers, so it's best to replace it
               with

                   SAVECOMPPAD();
                   PAD_SET_CUR_NOSAVE(padlist,n);

                       void    PAD_SET_CUR(PADLIST padlist, I32 n)

       PAD_SET_CUR_NOSAVE
               like PAD_SET_CUR, but without the save

                       void    PAD_SET_CUR_NOSAVE(PADLIST padlist, I32 n)

       PAD_SV  Get the value at offset "po" in the current pad

                       void    PAD_SV(PADOFFSET po)

       PAD_SVl Lightweight and lvalue version of "PAD_SV".  Get or set the value at offset "po" in the cur-<font color="#ffffff" class="whiteout">rent&nbsp;current</font>
               rent pad.  Unlike "PAD_SV", does not print diagnostics with -DX.  For internal use only.

                       SV *    PAD_SVl(PADOFFSET po)

       SAVECLEARSV
               Clear the pointed to pad value on scope exit. (i.e. the runtime action of 'my')

                       void    SAVECLEARSV(SV **svp)

       SAVECOMPPAD
               save PL_comppad and PL_curpad

                       void    SAVECOMPPAD()

       SAVEPADSV
               Save a pad slot (used to restore after an iteration)

               XXX DAPM it would make more sense to make the arg a PADOFFSET      void SAVEPADSV(PADOFFSET
               po)

<b>Functions</b> <b>in</b> <b>file</b> <b>pp_ctl.c</b>
       find_runcv
               Locate the CV corresponding to the currently executing sub or eval.  If db_seqp is non_null,
               skip CVs that are in the DB package and populate *db_seqp with the cop sequence number at the
               point that the DB:: code was entered. (allows debuggers to eval in the scope of the break-<font color="#ffffff" class="whiteout">point&nbsp;breakpoint</font>
               point rather than in the scope of the debugger itself).

                       CV*     find_runcv(U32 *db_seqp)

<b>Global</b> <b>Variables</b>
       PL_DBsingle
               When Perl is run in debugging mode, with the <b>-d</b> switch, this SV is a boolean which indicates
               whether subs are being single-stepped.  Single-stepping is automatically turned on after
               every step.  This is the C variable which corresponds to Perl's $DB::single variable.  See
               "PL_DBsub".

                       SV *    PL_DBsingle

       PL_DBsub
               When Perl is run in debugging mode, with the <b>-d</b> switch, this GV contains the SV which holds
               the name of the sub being debugged.  This is the C variable which corresponds to Perl's
               $DB::sub variable.  See "PL_DBsingle".

                       GV *    PL_DBsub

       PL_DBtrace
               Trace variable used when Perl is run in debugging mode, with the <b>-d</b> switch.  This is the C
               variable which corresponds to Perl's $DB::trace variable.  See "PL_DBsingle".

                       SV *    PL_DBtrace

       PL_dowarn
               The C variable which corresponds to Perl's $^W warning variable.

                       bool    PL_dowarn

       PL_last_in_gv
               The GV which was last used for a filehandle input operation. ("&lt;FH&gt;")

                       GV*     PL_last_in_gv

       PL_ofs_sv
               The output field separator - $, in Perl space.

                       SV*     PL_ofs_sv

       PL_rs   The input record separator - $/ in Perl space.

                       SV*     PL_rs

<b>GV</b> <b>Functions</b>
       is_gv_magical
               Returns "TRUE" if given the name of a magical GV.

               Currently only useful internally when determining if a GV should be created even in rvalue
               contexts.

               "flags" is not used at present but available for future extension to allow selecting particu-<font color="#ffffff" class="whiteout">lar&nbsp;particular</font>
               lar classes of magical variable.

               Currently assumes that "name" is NUL terminated (as well as len being valid).  This assump-<font color="#ffffff" class="whiteout">tion&nbsp;assumption</font>
               tion is met by all callers within the perl core, which all pass pointers returned by SvPV.

                       bool    is_gv_magical(char *name, STRLEN len, U32 flags)

<b>IO</b> <b>Functions</b>
       start_glob
               Function called by "do_readline" to spawn a glob (or do the glob inside perl on VMS). This
               code used to be inline, but now perl uses "File::Glob" this glob starter is only used by
               miniperl during the build process.  Moving it away shrinks pp_hot.c; shrinking pp_hot.c helps
               speed perl up.

                       PerlIO* start_glob(SV* pattern, IO *io)

<b>Pad</b> <b>Data</b> <b>Structures</b>
       CvPADLIST
               CV's can have CvPADLIST(cv) set to point to an AV.

               For these purposes "forms" are a kind-of CV, eval""s are too (except they're not callable at
               will and are always thrown away after the eval"" is done executing).

               XSUBs don't have CvPADLIST set - dXSTARG fetches values from PL_curpad, but that is really
               the callers pad (a slot of which is allocated by every entersub).

               The CvPADLIST AV has does not have AvREAL set, so REFCNT of component items is managed "man-<font color="#ffffff" class="whiteout">ual"&nbsp;"manual"</font>
               ual" (mostly in pad.c) rather than normal av.c rules.  The items in the AV are not SVs as for
               a normal AV, but other AVs:

               0'th Entry of the CvPADLIST is an AV which represents the "names" or rather the "static type
               information" for lexicals.

               The CvDEPTH'th entry of CvPADLIST AV is an AV which is the stack frame at that depth of
               recursion into the CV.  The 0'th slot of a frame AV is an AV which is @_.  other entries are
               storage for variables and op targets.

               During compilation: "PL_comppad_name" is set to the names AV.  "PL_comppad" is set to the
               frame AV for the frame CvDEPTH == 1.  "PL_curpad" is set to the body of the frame AV (i.e.
               AvARRAY(PL_comppad)).

               During execution, "PL_comppad" and "PL_curpad" refer to the live frame of the currently exe-<font color="#ffffff" class="whiteout">cuting&nbsp;executing</font>
               cuting sub.

               Iterating over the names AV iterates over all possible pad items. Pad slots that are
               SVs_PADTMP (targets/GVs/constants) end up having &amp;PL_sv_undef "names" (see <u>pad</u><b>_</b><u>alloc()</u>).

               Only my/our variable (SVs_PADMY/SVs_PADOUR) slots get valid names.  The rest are op tar-<font color="#ffffff" class="whiteout">gets/GVs/constants&nbsp;targets/GVs/constants</font>
               gets/GVs/constants which are statically allocated or resolved at compile time.  These don't
               have names by which they can be looked up from Perl code at run time through eval"" like
               my/our variables can be.  Since they can't be looked up by "name" but only by their index
               allocated at compile time (which is usually in PL_op-&gt;op_targ), wasting a name SV for them
               doesn't make sense.

               The SVs in the names AV have their PV being the name of the variable.  NV+1..IV inclusive is
               a range of cop_seq numbers for which the name is valid.  For typed lexicals name SV is
               SVt_PVMG and SvSTASH points at the type.  For "our" lexicals, the type is SVt_PVGV, and GvS-<font color="#ffffff" class="whiteout">TASH&nbsp;GvSTASH</font>
               TASH points at the stash of the associated global (so that duplicate "our" declarations in
               the same package can be detected).  SvCUR is sometimes hijacked to store the generation num-<font color="#ffffff" class="whiteout">ber&nbsp;number</font>
               ber during compilation.

               If SvFAKE is set on the name SV then slot in the frame AVs are a REFCNT'ed references to a
               lexical from "outside". In this case, the name SV does not have a cop_seq range, since it is
               in scope throughout.

               If the 'name' is '&amp;' the corresponding entry in frame AV is a CV representing a possible clo-<font color="#ffffff" class="whiteout">sure.&nbsp;closure.</font>
               sure.  (SvFAKE and name of '&amp;' is not a meaningful combination currently but could become so
               if "my sub foo {}" is implemented.)

               The flag SVf_PADSTALE is cleared on lexicals each time the <u>my()</u> is executed, and set on scope
               exit. This allows the 'Variable $x is not available' warning to be generated in evals, such
               as

                   { my $x = 1; sub f { eval '$x'} } f();

                       AV *    CvPADLIST(CV *cv)

       cv_clone
               Clone a CV: make a new CV which points to the same code etc, but which has a newly-created
               pad built by copying the prototype pad and capturing any outer lexicals.

                       CV*     cv_clone(CV* proto)

       cv_dump dump the contents of a CV

                       void    cv_dump(const CV *cv, const char *title)

       do_dump_pad
               Dump the contents of a padlist

                       void    do_dump_pad(I32 level, PerlIO *file, PADLIST *padlist, int full)

       intro_my
               "Introduce" my variables to visible status.

                       U32     intro_my()

       pad_add_anon
               Add an anon code entry to the current compiling pad

                       PADOFFSET       pad_add_anon(SV* sv, OPCODE op_type)

       pad_add_name
               Create a new name in the current pad at the specified offset.  If "typestash" is valid, the
               name is for a typed lexical; set the name's stash to that value.  If "ourstash" is valid,
               it's an our lexical, set the name's GvSTASH to that value

               Also, if the name is @.. or %.., create a new array or hash for that slot

               If fake, it means we're cloning an existing entry

                       PADOFFSET       pad_add_name(char *name, HV* typestash, HV* ourstash, bool clone)

       pad_alloc
               Allocate a new my or tmp pad entry. For a my, simply push a null SV onto the end of PL_comp-<font color="#ffffff" class="whiteout">pad,&nbsp;PL_comppad,</font>
               pad, but for a tmp, scan the pad from PL_padix upwards for a slot which has no name and no
               active value.

                       PADOFFSET       pad_alloc(I32 optype, U32 tmptype)

       pad_block_start
               Update the pad compilation state variables on entry to a new block

                       void    pad_block_start(int full)

       pad_check_dup
               Check for duplicate declarations: report any of:
                    * a my in the current scope with the same name;
                    * an our (anywhere in the pad) with the same name and the same stash
                      as "ourstash" "is_our" indicates that the name to check is an 'our' declaration

                       void    pad_check_dup(char* name, bool is_our, HV* ourstash)

       pad_findlex
               Find a named lexical anywhere in a chain of nested pads. Add fake entries in the inner pads
               if it's found in an outer one. innercv is the CV *inside* the chain of outer CVs to be
               searched. If newoff is non-null, this is a run-time cloning: don't add fake entries, just
               find the lexical and add a ref to it at newoff in the current pad.

                       PADOFFSET       pad_findlex(const char* name, PADOFFSET newoff, const CV* innercv)

       pad_findmy
               Given a lexical name, try to find its offset, first in the current pad, or failing that, in
               the pads of any lexically enclosing subs (including the complications introduced by eval). If
               the name is found in an outer pad, then a fake entry is added to the current pad.  Returns
               the offset in the current pad, or NOT_IN_PAD on failure.

                       PADOFFSET       pad_findmy(char* name)

       pad_fixup_inner_anons
               For any anon CVs in the pad, change CvOUTSIDE of that CV from old_cv to new_cv if necessary.
               Needed when a newly-compiled CV has to be moved to a pre-existing CV struct.

                       void    pad_fixup_inner_anons(PADLIST *padlist, CV *old_cv, CV *new_cv)

       pad_free
               Free the SV at offset po in the current pad.

                       void    pad_free(PADOFFSET po)

       pad_leavemy
               Cleanup at end of scope during compilation: set the max seq number for lexicals in this scope
               and warn of any lexicals that never got introduced.

                       void    pad_leavemy()

       pad_new Create a new compiling padlist, saving and updating the various global vars at the same time
               as creating the pad itself. The following flags can be OR'ed together:

                   padnew_CLONE        this pad is for a cloned CV
                   padnew_SAVE         save old globals
                   padnew_SAVESUB      also save extra stuff for start of sub

                       PADLIST*        pad_new(int flags)

       pad_push
               Push a new pad frame onto the padlist, unless there's already a pad at this depth, in which
               case don't bother creating a new one.  If has_args is true, give the new pad an @_ in slot
               zero.

                       void    pad_push(PADLIST *padlist, int depth, int has_args)

       pad_reset
               Mark all the current temporaries for reuse

                       void    pad_reset()

       pad_setsv
               Set the entry at offset po in the current pad to sv.  Use the macro <u>PAD</u><b>_</b><u>SETSV()</u> rather than
               calling this function directly.

                       void    pad_setsv(PADOFFSET po, SV* sv)

       pad_swipe
               Abandon the tmp in the current pad at offset po and replace with a new one.

                       void    pad_swipe(PADOFFSET po, bool refadjust)

       pad_tidy
               Tidy up a pad after we've finished compiling it:
                   * remove most stuff from the pads of anonsub prototypes;
                   * give it a @_;
                   * mark tmps as such.

                       void    pad_tidy(padtidy_type type)

       pad_undef
               Free the padlist associated with a CV.  If parts of it happen to be current, we null the rel-<font color="#ffffff" class="whiteout">evant&nbsp;relevant</font>
               evant PL_*pad* global vars so that we don't have any dangling references left.  We also
               repoint the CvOUTSIDE of any about-to-be-orphaned inner subs to the outer of this cv.

               (This function should really be called pad_free, but the name was already taken)

                       void    pad_undef(CV* cv)

<b>Stack</b> <b>Manipulation</b> <b>Macros</b>
       djSP    Declare Just "SP". This is actually identical to "dSP", and declares a local copy of perl's
               stack pointer, available via the "SP" macro.  See "SP".  (Available for backward source code
               compatibility with the old (Perl 5.005) thread model.)

                               djSP;

       LVRET   True if this op will be the return value of an lvalue subroutine

<b>SV</b> <b>Manipulation</b> <b>Functions</b>
       report_uninit
               Print appropriate "Use of uninitialized variable" warning

                       void    report_uninit()

       sv_add_arena
               Given a chunk of memory, link it to the head of the list of arenas, and split it into a list
               of free SVs.

                       void    sv_add_arena(char* ptr, U32 size, U32 flags)

       sv_clean_all
               Decrement the refcnt of each remaining SV, possibly triggering a cleanup. This function may
               have to be called multiple times to free SVs which are in complex self-referential hierar-<font color="#ffffff" class="whiteout">chies.&nbsp;hierarchies.</font>
               chies.

                       I32     sv_clean_all()

       sv_clean_objs
               Attempt to destroy all objects not yet freed

                       void    sv_clean_objs()

       sv_free_arenas
               Deallocate the memory used by all arenas. Note that all the individual SV heads and bodies
               within the arenas must already have been freed.

                       void    sv_free_arenas()

<b>AUTHORS</b>
       The autodocumentation system was originally added to the Perl core by Benjamin Stuhl. Documentation
       is by whoever was kind enough to document their functions.

<b>SEE</b> <b>ALSO</b>
       <a href="perlguts.1.html#//apple_ref/doc/man/1/perlguts"><u>perlguts</u>(1)</a>, <a href="perlapi.1.html#//apple_ref/doc/man/1/perlapi"><u>perlapi</u>(1)</a>



perl v5.8.8                                      2006-01-07                                    PERLINTERN(1)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man1/perlintern.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man1/perlintern.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man1/perlintern.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
