<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>DefProcs - /wprocasm.a</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">DefProcs</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxHumanInterfaceToolbox-date.html" target="_blank">Carbon > Human Interface Toolbox</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">DefProcs</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/wprocasm.a</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/butcdef.a</option>
<option value="listing2.html">/LDefProc0.A</option>
<option value="listing3.html">/mdefproc.a</option>
<option value="listing4.html">/rdocproc.a</option>
<option value="listing5.html">/Read Me â€¢ DefProcs.txt</option>
<option value="listing6.html">/sbarcdef.a</option>
<option value="listing7.html">/wprocasm.a</option></select>
				</p>
				</form>
				<p><strong><a href="DefProcs.zip">Download Sample</a></strong> (&#147;DefProcs.zip&#148;, 78.9K)<BR>
<strong><a href="DefProcs.dmg">Download Sample</a></strong> (&#147;DefProcs.dmg&#148;, 151.3K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">;EASE$$$ READ ONLY COPY of file &quot;wprocasm.a&quot;; 1.0  CCH 11/16/1988 Added to EASE.; END EASE MODIFICATION HISTORY ;;File wProcAsm.a;--------------------------------------------------------------------------;;  Window Definition Routine for the;    MacIntosh Window Manager;;  written by Andy Hertzfeld  Aug 4, 1982;;  (c) 1982-1986 by Apple Computer, Inc.  All rights reserved.;;   This file contains the window definition procedure;  &quot;DocumentProc&quot;, the standard Mac window type.  It is;  a rectangular window with a title bar.  It is assembled;  part of the window manager.;;  Modification History:;;   21-Aug-82  AJH  Made DocumentProc support rectangular windows only;   30-Aug-82  AJH  Added growIcon hit detection, fixed hit to exclude perimeter drag;   07-Sep-82  AJH  Added handler for grow message;   12-Sep-82  AJH  Made it so proc doesn't have to calcRgns when not visible;   20-Sep-82  AJH  Added go-away button drawing and hit-testing;   25-Sep-82  AJH  Added cheap dialogBox window definition proc;   28-Sep-82  AJH  New GoAway button; restructured goAway drawing;   05-Oct-82  AJH  Removed Init message to save code;   06-Oct-82  AJH  Fixed dialogBox dragRgn bug;   10-Oct-82  AJH  Converted to QuickDraw trap interface;   16-Oct-82  AJH  Fixed GoAway hit-test origin bug;   17-OCt-82  AJH  Made both windowProcs preserve A1;   07-Nov-82  AJH  Changed DocumentProc hiliting to Lisa way;   14-Nov-82  AJH  Improved shape of Grow outline ala Lisa;   16-Nov-82  AJH  Made branch table offset-based to save space;   16-Nov-82  AJH  Special-cased hiliting of small windows;   20-Dec-82  AJH  Changed title bar to 20 pixels tall;   24-Dec-82  AJH  Made wProcAsm a separate assembly;   17-Mar-83  AJH  Added third variant -- shadowless dBoxProc;   27-Apr-83  AJH  only plot, hit-test goAway if window is active;   25-Jul-83  SC   Fixed third variant -- frame was incorrect, see DrawDBox;   06-Aug-83  AJH  changed hiliting to use pattern;   09-Aug-83  AJH  added draw grow icon message receiver;   20-Aug-83  AJH  made it only hit-test or draws goAway if window is active;   29-Oct-83  AJH  new dBox border;   10-Nov-83  AJH  added variant 4 -- just like variant 0, but no inGrow;   24-Dec-83  AJH  fixed structRgn calc bug in variant 1;   24-Feb-84  AJH  fixed hit-testing of go-away -- was off by 2;   09-Jan-85  JTC  modified for MDS assembly: label DocumentProc changed;           to DocProc to avoid collision.;   15-Jan-85  EHB  fixed erase of 3 pixels of content rgn in DrawFrame;;           prevented erase of top line in DoTitleString.;   15-Jan-85  EHB  eliminated title flicker in CheckHilite; gnrl cleanup;   30-Jan-85  EHB  fixed boundary testing of GoAwayBox;   14-Feb-85  JTC  named rsrc.;   16-May-85  EHB  For GrowBox hitTesting, changed D4=16 to D4=14;v3  16-May-85  EHB  Check left of window title when no grow box too;   29-Jul-85  EHB  converted back to porkshop;v4   5-Aug-85  EHB  Allow variable size titles;v5  29-Aug-85  EHB  Variant 8 knows how to zoom;   18-Sep-85  EHB  Added routine ChkPoint to allow slop on large zoom size;   09-Oct-85  EHB  Added designer zoom icon, restored old close mask;   18-Oct-85  EHB  New Zoom positioning (avoid lawsuits). Needs title fixes too;           Add tempRgn to frame to save clip, to calc window's region;   18-Oct-85  EHB  Only allow zooming on new ROMs (just in case);   21-Oct-85  EHB  In HitDoc, use BuildTBarRect to hit-test title bar.  The old;           way didn't work with null content regions.;   03-Nov-85  EHB  Zoom was one pixel too far left (fix draw and hit);;-Reno World------------------------------------------------------------------;;   &lt;C59/30Jun86&gt; DAF  Added color support on nuMac. Dropped Krispee stuff;   &lt;C117/25Sep86&gt; DAF Updated defproc to use RGBForeColor/RGBBackColor;   &lt;C203/06Oct86&gt; DAF Updated SetUpColor to look up window part color rather;            than assume part from position.  Changed textMode to;            srcOr for titleString.  Made window rgn square;            conditionally.;   &lt;A285/28Oct86&gt; DAF  Changed SquareWindows conditional to be true on nuMac only.;   &lt;C407/16Nov86&gt; DAF  Changed textMode to srcCopy, per Cary's recommendation;    &lt;C424/18Nov86&gt; DAF  Added portToMap to correct problems in cWindows.;   &lt;C491/08Dec86&gt; DAF Locked titleString handle before drawing (OLD BUG!);   &lt;C666/22Jan87&gt; DAF Universal defproc (version 10).  With the exception of ;            Square window flag, this defproc no longer has conditional ;            build sections (all system determination is dynamic);   &lt;C700/26Jan87&gt; DAF Square windows now supported dynamically;      BLANKS    ON      STRING    ASIS      PRINT    OFF      LOAD    'inc.sum.d'      LOAD    'nEqu.d'      INCLUDE    'colorEqu.a'      PRINT    ON      WDEF0    PROC    EXPORT;;  FUNCTION   DocProc(selector: INTEGER;;            window: WindowPtr,;            message: INTEGER;;            parameter: LongInt): LongIntLinkSize  EQU    -34IsColor    EQU    -34      ; do we have colorQD and toolbox?  [boolean]Align    EQU    -33      ; a dead byte for IsColor      SavBkCol  EQU    -32      ; saved wmgrCPort RGBBackColor   (color only)SavFgCol  EQU    -26      ; saved wmgrCPort RGBForeColor   (color only)AuxCPtr    EQU    -20      ; pointer to auxCTable      (color only)AuxCTab    EQU    -16      ; handle to auxCTable      (color only)TempRgn   EQU   -12     ; &lt;18Oct85&gt;WInfoRec  EQU   -8      ; &lt;1Aug85&gt;WAscent   EQU   -8      ; &lt;1Aug85&gt;WDescent  EQU   -6      ; &lt;1Aug85&gt;WHeight   EQU   -4      ; &lt;1Aug85&gt;WBoxDelta  EQU   -2      ; &lt;1Aug85&gt;message    EQU    12      ;                &lt;C666/22Jan87&gt; DAFHasZoom   EQU   3      ; bit 3 is zoom bit       &lt;EHB 29Aug85&gt;hasGrow   EQU   2      ; bit 2 is grow bit       &lt;EHB 29Aug85&gt;wZoom    EQU   wGoAway+1  ;                &lt;EHB 29Aug85&gt;DocProc      BRA.S  DP1; standard header      DC.W  0          ; flags word      DC.B  'WDEF'        ; resource type      DC.W  0          ; resource ID      DC.W  10          ; version numberDP1      LINK  A6,#LinkSize     ; set up a stack frame to address parameters      MOVEM.L D3-D7/A1-A4,-(SP)  ; save work registers      ; test if the message is in range      CMP.W  #wGIconMsg,message(A6)  ; compare to highest value      &lt;C666/22Jan87&gt; DAF      BGT   OORange          ; skip it, it's too high      &lt;C666/22Jan87&gt; DAF      CMP.W  #wDrawMsg,message(A6)  ;  compare to lowest value, too    &lt;C666/22Jan87&gt; DAF      BMI   OORange          ;                  &lt;C666/22Jan87&gt; DAF            MOVE.L  (A5),A0       ; get pointer to quickDraw globals      &lt;7Aug85&gt;      MOVE.L  (A0),-(SP)      ; save current port on stack        &lt;7Aug85&gt;; Determine type of system.  We need to know if we have color QuickDraw and a color;  window manager port.        CMP.W  #$3FFF,ROM85    ; do we have color QD?       SLS    IsColor(A6)      ; set boolean depending on color or B&amp;W system      BHI.S  @BWSys        ; no, this system has B&amp;W QD; when using the wmgrCPort, it is the defproc's responsibility to reconcile;   the wmgrPort and the wmgrCPort.        BSR   UpdateCPort      ; compare and update wmgrPorts, also set WMgrCPort      BRA.S  @CommonSys      ; @BWSys            MOVE.L  WMgrPort,-(SP)    ; and set port to window manager port      _SetPort          ; @CommonSys; get the font info for this font.  Put the height of the title bar in D7 and wHeight(A6).; put the distance of the top of the goaway box from the top of the bar in WBoxDelta(A6).@1      LEA   WInfoRec(A6),A3   ; point to our info rec           &lt;5Aug85&gt;      MOVE.L  A3,-(SP)      ; push a pointer              &lt;5Aug85&gt;      _GetFontInfo        ; and get the font's info                   &lt;5Aug85&gt;      MOVE.W  (A3)+,D7      ; (rect inset by 1 when WAscent used)    &lt;5Aug85&gt;      ADD.W  (A3)+,D7      ; add descent                &lt;5Aug85&gt;      ADDQ.W  #4,D7        ; get the height              &lt;5Aug85&gt;      BSET  #0,D7        ; make height odd for symmetry        &lt;5Aug85&gt;      MOVEQ  #19,D1        ; get 19                  &lt;26Aug85&gt;      CMP.W  D1,D7        ; force height to 19 min          &lt;26Aug85&gt;      BGE.S  @3          ; =&gt; not a tiny font            &lt;5Aug85&gt;      SUB.W  D7,D1        ; how much less than 19 is it?        &lt;26Aug85&gt;      LSR.W  #1,D1        ; used for centering tiny fonts       &lt;26Aug85&gt;      ADD.W  D1,WAscent(A6)    ; make the ascent &quot;bigger&quot;          &lt;26Aug85&gt;      MOVEQ  #19,D7        ;                      &lt;5Aug85&gt;@3      MOVE.W  D7,(A3)+      ; WHeight = ascent+descent+2        &lt;5Aug85&gt;      MOVE.W  D7,D0        ; get height                &lt;EHB 29Aug85&gt;      SUB.W  #13,D0        ; subtract height of box          &lt;5Aug85&gt;      LSR.W  #1,D0        ; divide by 2                &lt;5Aug85&gt;      MOVE.W  D0,(A3)       ; save delta to goAway box          &lt;5Aug85&gt;; set up a temp region      CLR.L  -(SP)        ; make room for result            &lt;EHB 18Oct85&gt;      _NewRgn           ; get a new region              &lt;EHB 18Oct85&gt;      MOVE.L  (SP)+,TempRgn(A6)  ; and save in our frame           &lt;EHB 18Oct85&gt;; save off the current port fore- &amp; backcolors on color systems.             TST.B  IsColor(A6)      ; is it a color system?      BEQ.S  @NoColor1      ; nope, so skip this            PEA    SavFgCol(A6)    ; push a pointer to save area      _GetForeColor        ; get the current color      PEA    SavBkCol(A6)    ;       _GetBackColor        ;; also, find the auxWinRec and lock it down            CLR.L  -(SP)        ; here's a space for the var handle      CLR.W  -(SP)        ; function return here      MOVE.L  14(A6),-(SP)    ; push window ptr       PEA    6(SP)        ; a pointer to the space above      _GetAuxWin          ; find the auxrec      ADDQ  #2,SP        ; pitch the boolean (it doesn't matter)      MOVE.L  (SP)+,A0      ; get the auxRecHandle      MOVE.L  (A0),A0        ; handle -&gt; ptr      MOVE.L  winCTable(A0),A0  ; get the colortable handle      MOVE.L  A0,AuxCTab(A6)    ; save this handle      _HLock            ; lock the table down in memory      MOVE.L  (A0),AuxCPtr(A6)  ; and get a pointer too!@NoColor1                ; END OF A COLOR-ONLY SECTION; fetch the parameters into registers      LEA   8(A6),A0      ; get ptr to first parameter      MOVE.L  (A0)+,D3      ; get param in D3      MOVE.W  (A0)+,D0      ; get message      MOVE.L  (A0)+,A3      ; get the window pointer      MOVE.W  (A0)+,D5      ; get the selector integer      MOVE  D5,D6        ; keep copy in D6      AND   #3,D5        ; ignore &quot;inGrow&quot; variant      CLR.L  (A0)        ; clear out function result; case out on the message number      ADD   D0,D0        ; double for word index      LEA   GoDocProc,A0    ; get jump table address      ADD.W  GODOCPROC(D0),A0  ; compute dispatch address      JSR   (A0); we're done -- restore registers and return to caller      MOVE.L  TempRgn(A6),-(SP)  ; dispose of temp region      &lt;EHB 18Oct85&gt;      _DisposRgn          ;                  &lt;EHB 18Oct85&gt;      TST.B  IsColor(A6)      ; are we on a color system?            BEQ.S  @NoColor2      ; if on B&amp;W, then skip                  MOVE.L  AuxCTab(A6),A0    ; get the colortable handle  &lt;DAF 15-Apr-86&gt;      _HUnlock          ; release it        &lt;DAF 15-Apr-86&gt;      ; restore the fore- and backColors                  &lt;C203/08Oct86&gt; DAF      PEA    savBkCol(A6)    ; pointer to RGBColor      _RGBBackColor        ;      PEA    savFgCol(A6)    ; pointer to RGBColor      _RGBForeColor        ;@NoColor2                ; END OF A COLOR-ONLY SECTION      _SetPort          ; the old port is on top of stack  &lt;EHB 7Aug85&gt;OORange                  ; 'Out Of Range, of course'      &lt;C666/22Jan87&gt; DAF      MOVEM.L (SP)+,D3-D7/A1-A4  ; restore work registers      UNLK  A6          ; unlink stack frame      MOVE.L  (SP)+,A0      ; get return address      ADD   #12,SP        ; strip parameters      JMP   (A0)        ; return to caller; DocumentProc dispatch table -- entries must be long branches!GODOCPROC      DC.W  DrawDoc-GoDocProc  ; draw is message #0      DC.W  HitDoc-GoDocProc  ; hit test is message #1      DC.W  CalcDoc-GoDocProc  ; calc test is message #2      DC.W  InitDoc-GoDocProc  ; init is message #3      DC.W  DisposeDoc-GoDocProc   ; dispose is message #4      DC.W  GrowDoc-GoDocProc  ; grow message is #5      DC.W  DrawGIcon-GoDocProc ; draw grow icon is #6; utility UpdateCPort ;  This utility compares the pertinent fields of the wmgrPort and the wmgrCPort,;  updating the wmgrCPort as necessary to match the wmgrPort.UpdateCPort                ; &lt;C666/22Jan87&gt; DAF        MOVE.L  WmgrCPort,-(SP)    ; make the wmgrCPort the current port      _SetPort          ; set it      MOVE.L  WmgrPort,A0      ; get the wmgrPort addr      MOVE.L  WmgrCPort,A1    ; and the wmgrCPort too            PEA    bkPat(A0)      ; push pointers to pattern for later      PEA    pnPat(A0)      ;; copy all fields from pnLoc to end of grafPort, excluding pnPixPat and fillPixPat      LEA    pnLoc(A0),A0          ; point at source      LEA    pnLoc(A1),A1          ; point at dest      MOVE.L  (A0)+,(A1)+            ; copy pnLoc      MOVE.L  (A0)+,(A1)+            ; copy pnSize      MOVE.W  (A0)+,(A1)+            ; copy pnMode      ADDQ  #8,A0              ; skip pnPat (aka, pnPixPat,fillPixPat)      ADDQ  #8,A1              ;       MOVE.W  #((portRec-pnVis)/2)-1,D0    ; set up a counter (long sized)@1      MOVE.W  (A0)+,(A1)+            ; copy it      DBRA  D0,@1              ; loop      ; now set up the patterns in the wmgrCPort (which is thePort);  the parameters were pushed before the copying loop above      _PenPat      _BackPat      RTS              ; &lt;C666/22Jan87&gt; DAF; InitDoc is used to initialize our zoom sizeInitDoc   BTST  #hasZoom,D6     ; does it want a zoom box?    &lt;EHB 29Aug85&gt;      BEQ.S  noZoom        ; =&gt; nope, no zoom        &lt;EHB 29Aug85&gt;      CLR.B  wZoom(A3)      ; assume no zoom box      &lt;EHB 29Aug85&gt;      TST.W  ROM85        ; running on new roms?      &lt;EHB 18Oct85&gt;      BMI.S  noZoom        ; =&gt; no, use default      &lt;EHB 18Oct85&gt;      MOVEQ  #16,D0        ; space for 2 rects       &lt;EHB 29Aug85&gt;      _NewHandle ,CLEAR      ; allocate the space      &lt;EHB 29Aug85&gt;      BNE.S  noZoom        ; =&gt; not able to get space    &lt;EHB 29Aug85&gt;; set default zoom data.  Consists of 2 fields:  SmallSize, BigSize: Rect      ADDQ.B  #1,wZoom(A3)    ; set zoom flag to TRUE     &lt;EHB 29Aug85&gt;      MOVE.L  A0,WDataHandle(A3)  ; save handle to data      &lt;EHB 29Aug85&gt;      MOVE.L  (A0),A4       ; point to data         &lt;EHB 29Aug85&gt;      ADDQ.W  #8,A4        ; point to bigSize        &lt;EHB 29Aug85&gt;; get the size of the zoomed out window in global coordinates.  To do this,; pull the screen size from screenbits.bounds and indent a little.      MOVE.L  GrafGlobals(A5),A1  ; point to QuickDraw globals  &lt;EHB 29Aug85&gt;      MOVE.L  Screenbits+Bounds(A1),(A4)+   ; get topLeft    &lt;EHB 29Aug85&gt;      MOVE.L  Screenbits+Bounds+4(A1),(A4)+  ; get botRight    &lt;EHB 29Aug85&gt;      MOVEQ  #3,D0              ; get indent    &lt;EHB 29Aug85&gt;      SUB.W  D0,-(A4)      ; indent right          &lt;EHB 29Aug85&gt;      SUB.W  D0,-(A4)      ; indent bottom         &lt;EHB 29Aug85&gt;      ADD.W  D0,-(A4)      ; indent left          &lt;EHB 29Aug85&gt;      ADD.W  D0,-(A4)      ; indent top          &lt;EHB 29Aug85&gt;      ADD.W  D7,(A4)       ; past menu bar         &lt;EHB 29Aug85&gt;      ADD.W  D7,(A4)       ; and past window title     &lt;EHB 29Aug85&gt;      MOVE.L  (A0),A4       ; A4 = smallsize        &lt;EHB 29Aug85&gt;; get current size into rect in A4GetRect   MOVE.L  A4,-(SP)      ; push address of rect      &lt;EHB 29Aug85&gt;      MOVE.L  PortRect(A3),(A4)  ; get topLeft (local)      &lt;EHB 29Aug85&gt;      MOVE.L  PortRect+4(A3),4(A4)  ; get botRight (local)    &lt;EHB 29Aug85&gt;      MOVE.L  A3,A0        ; copy portPtr for PortToMap  &lt;C424/18Nov86&gt; DAF      BSR    PortToMap      ; get the rect pointer      &lt;C424/18Nov86&gt; DAF      MOVE.L  Bounds(A0),-(SP)  ; push offset locToGlob   &lt;EHB 29Aug85&gt;      NEG.W  (SP)          ; make offset positive    &lt;EHB 29Aug85&gt;      NEG.W  2(SP)      _OffsetRect         ; convert rect to globalNoZoom    RTS; IsItSmall returns NE if the window has been resized or moved (NE if window &quot;small&quot;); It updates smallsize if it has.  (If tab, only move small window).;      Trashes A0,A1,A4IsItSmall  SUBQ  #8,SP        ; make room for a rect      &lt;EHB 29Aug85&gt;      MOVE.L  SP,A4        ; point to it          &lt;EHB 29Aug85&gt;      BSR.S  GetRect       ; A4 = curSize          &lt;EHB 29Aug85&gt;      MOVE.L  wDataHandle(A3),A0  ; get data handle        &lt;EHB 29Aug85&gt;      MOVE.L  (A0),A2       ; A2 = bigSize          &lt;EHB 29Aug85&gt;      ADDQ  #8,A2; the window is large if all corners are within 7 of their default positions      BSR.S  ChkPoint      ; compare topleft        &lt;EHB 18Sep85&gt;      BNE.S  IsSmall       ; =&gt; not close enough      &lt;EHB 29Aug85&gt;      BSR.S  ChkPoint      ; compare botright        &lt;EHB 18Sep85&gt;      BEQ.S  NotSmall      ; =&gt; it's close enough          &lt;EHB 29Aug85&gt;IsSmall   MOVE.L  wDataHandle(A3),A0  ; get data handle        &lt;EHB 29Aug85&gt;      MOVE.L  (A0),A4       ; save window's current size    &lt;EHB 29Aug85&gt;      BSR.S  GetRect       ; get current size into A4    &lt;EHB 29Aug85&gt;SaySmall  MOVEQ  #1,D0        ; return NE!          &lt;EHB 29Aug85&gt;NotSmall  ADDQ  #8,SP        ; strip rect from stack     &lt;EHB 29Aug85&gt;      RTSChkPoint  MOVE.L  (A2),-(SP)      ; make point into a rect    &lt;EHB 18Sep85&gt;      MOVE.L  (A2)+,-(SP)     ; by pushing twice        &lt;EHB 18Sep85&gt;      MOVE.L  SP,-(SP)      ; and insetting by 7      &lt;EHB 18Sep85&gt;      MOVE.L  #$FFF9FFF9,-(SP)  ;                &lt;EHB 18Sep85&gt;      _InsetRect          ;                &lt;EHB 18Sep85&gt;      CLR.W  -(SP)        ; is cursize within 7 of    &lt;EHB 18Sep85&gt;      MOVE.L  (A4)+,-(SP)     ; that point?          &lt;EHB 18Sep85&gt;      PEA   6(SP)        ;                &lt;EHB 18Sep85&gt;      _PtInRect          ;                &lt;EHB 18Sep85&gt;      SUBQ.B  #1,(SP)       ; reverse sign of result    &lt;EHB 18Sep85&gt;      MOVE.B  (SP)+,D0      ;                &lt;EHB 18Sep85&gt;      ADDQ  #8,SP        ; strip off the rect      &lt;EHB 18Sep85&gt;      RTS             ; exit w/EQ if &quot;Big&quot;      &lt;EHB 18Sep85&gt;; IsThereZoom returns EQ if zoom not enabledIsThereZoom BTST  #hasZoom,D6     ; zooming variant        &lt;EHB 29Aug85&gt;      BEQ.S   IsNoZoom      ; =&gt; no             &lt;EHB 29Aug85&gt;      TST.B  wZoom(A3)      ; did we get the handle?    &lt;EHB 29Aug85&gt;IsNoZoom  RTS             ; EQ if no Zoom         &lt;EHB 29Aug85&gt;; DisposeDoc is called when the window is being closed.  All we need to do is; give back the handle we borrowed.DisposeDoc  BSR.S  IsThereZoom     ; is there a zoom box?      &lt;EHB 29Aug85&gt;      BEQ.S  InDisposed      ; =&gt; no, we're done             &lt;EHB 29Aug85&gt;      MOVE.L  wDataHandle(A3),A0  ; get handle to our data    &lt;EHB 29Aug85&gt;      _DisposHandle        ; release it, ignoring errors  &lt;EHB 29Aug85&gt;InDisposed  RTS; SetUpColor takes a window part identifier in D0, finds the corresponding;  part in the AuxWinTable (the part code is in the .value field) and returns;  a pointer to its RGB on the stack.  If the requested part is not found,;  the first color table element is used (I'd use frameColor, but that might;  not be there!).  Trashes A0/D0.    ; rewritten &lt;C177/25Sep86&gt; DAFSetUpColor      MOVE.L  D1,-(SP)      ; save a register      MOVE.L  AuxCPtr(A6),A0    ; get the color table pointer      MOVE.W  CTSize(A0),D1    ; get the color table size      MULU  #8,D1        ; convert to color table indexLegalIndex        CMP.W  CTTable+value(A0,D1),D0  ; is this the one?      BEQ.S  FoundIt        ; if equal, then done      SUB.W  #8,D1        ; try the previous one      BGE.S  LegalIndex      ; loop while index positive      MOVEQ  #0,D1        ; OK, use the first oneFoundIt          LEA    CTTable+rgb(A0,D1),A0 ; get the address of the color to use      MOVE.L  A0,D0        ; we'll need A0 in a second      MOVE.L  (SP)+,D1      ; restore the register      MOVE.L  (SP)+,A0      ; get the return address      MOVE.L  D0,-(SP)      ; push the rgb addr on the stack      JMP    (A0)        ; return to caller      PORTTOMAP                    ; &lt;C424/18Nov86&gt; DAF;----------------------------------------------------------;; Given a window pointer in A0, return the bitmap/pixmap pointer in A0      ADDQ  #PORTBITS,A0        ;POINT TO BITMAP/PIXMAP HANDLE      TST    ROWBYTES(A0)        ;BITMAP OR PIXMAP HANDLE?      BPL.S  GOTBITMAP          ;=&gt;JUST A BITMAP      MOVE.L  BASEADDR(A0),A0        ;ELSE GET PORT'S PIXMAP HANDLE      MOVE.L  (A0),A0            ;GET PIXMAP POINTERGOTBITMAP  RTS                  ;  DrawDoc -- draw the document window.   The windowPtr is in A3DrawDoc      TST.B  WVISIBLE(A3)    ; is it visible?      BEQ   DoneDoc       ; if not, don't do anything; see if its a EORGoAway call and special case it      CMP   #wInGoAway,D3    ; is it a goAway call?      BGE   EorStuff      ; if so, go handle it        &lt;EHB 29Aug85&gt;      _PenNormal          ; we want the normal pen      TST.W  D5          ; test dialogBox flag      BNE   DrawDBox      ; dBox window has no title bar; derive the titleBar rectangle from the structRgn and keep it in TempRect      BSR   BuildTBarRect; draw the title bar      TST.B  IsColor(A6)      ; is it color?            BEQ.S  @NoColor3      ; no, so skip this            MOVE.W  #wFrameColor,D0    ; color to set          &lt;C203/08Oct86&gt; DAF      BSR.S  SetUpColor      ; set it up            &lt;C203/08Oct86&gt; DAF      _RGBForeColor        ;                 &lt;C203/08Oct86&gt; DAF            MOVE.W  #wTitleBarColor,D0   ;                  &lt;C203/08Oct86&gt; DAF      BSR.S  SetUpColor      ;                 &lt;C203/08Oct86&gt; DAF      _RGBBackColor        ;                 &lt;C203/08Oct86&gt; DAF      @NoColor3                ; END OF A COLOR-ONLY SECTION      PEA   TEMPRECT      ; tempRect bounds the title bar      MOVE.L  (SP),-(SP)      ; make another copy of tempRect pointer      MOVE.L  (SP),-(SP)      ; and yet another      _FrameRect          ; frame the title bar      MOVE.L  OneOne,-(SP)    ; push inset factor      _InsetRect      _EraseRect          ; clear the inside      BSR   DoTitleString    ;; and draw the centered Title; To prevent title flicker, DoTitleString returns the left edge of the; title in D3 and the right edge in D4.  If the title bar needs to be; highlighted, the highlighting is done in 2 sections, one on each side; of the title.CheckHilite      TST.B  WHILITED(A3)    ; is it hilited?      BEQ   DrawBody      ; =&gt; go draw the frameDoHilite        TST.B  IsColor(A6)      ; is it color?            BEQ.S  @NoColor4      ; no, so skip this            MOVE.W  #wTitleBarColor,D0  ; set up colors            &lt;C203/08Oct86&gt; DAF      BSR   SetUpColor      ;      _RGBBackColor        ;            MOVE.W  #wHiliteColor,D0  ;      BSR   SetUpColor      ;      _RGBForeColor        ;                  &lt;C203/08Oct86&gt; DAF@NoColor4                ; END OF A COLOR-ONLY SECTION      PEA   TEMPRECT      ; push the title rect      MOVE.W  #1,-(SP)      ; push dh              &lt;5Aug85&gt;      MOVE.W  WBoxDelta(A6),-(SP) ; push dv              &lt;5Aug85&gt;      _InsetRect          ; inset it some      MOVE.W  TempRect+Right,-(SP)  ; save right of TempRect      MOVE.W  D3,TempRect+Right    ; new right = title left; used A4 instead of A0 to save a couple o'bytes (EHB)      MOVE.L  TempRect,D0     ; get topLeft      AND.L  #$00070007,D0    ; only use mod 8      MOVE.L  (A5),A4       ; get globals, save in A4      MOVE.L  D0,PatAlign(A4)   ; set up patAlign      PEA   TempRect      ; fill this rect      PEA   HilitePattern    ; push the pattern address      _FillRect          ; fill left half with the pattern      BSR    IsThereZoom     ; is zooming allowed? (was .S)        &lt;EHB 18-Oct-85&gt;      BEQ.S  @1          ; =&gt; no, use current d4       &lt;EHB 18-Oct-85&gt;      MOVE.W  (SP),D0       ; else get right edge of box    &lt;EHB 18-Oct-85&gt;      SUB.W  #26,D0        ; how much room is there?      &lt;EHB 18-Oct-85&gt;      CMP.W  D4,D0        ; need at least 26 pixels      &lt;EHB 18-Oct-85&gt;      BGE.S  @1          ; =&gt; got 'em, use current d4        &lt;EHB 18-Oct-85&gt;      MOVE.W  D0,D4        ; else use right-26         &lt;EHB 18-Oct-85&gt;@1      MOVE.W  (SP)+,TempRect+Right  ; restore right of title box      MOVE.W  D4,TempRect+Left  ; set new left of title box      PEA   TempRect      ; fill this rect      PEA   HilitePattern    ; push the pattern address      _FillRect      CLR.L  PatAlign(A4); plot the goAway buttonDoGoAway      TST.B  WGoAway(A3)     ; is there a goaway button?      BEQ.S  DoZoom        ; =&gt; if not, try for zoom    &lt;EHB 29Aug85&gt;      BSR   BuildTBarRect      LEA   GoAwayData,A1    ; get the goAway symbol      MOVEQ  #srcCopy,D0     ; plot in srcCopy mode      &lt;EHB 29Aug85&gt;      BSR   PlotGoAwayDoZoom    BSR   IsThereZoom     ; is there a zoom box?      &lt;EHB 29Aug85&gt;      BEQ.S  DrawBody      ; =&gt; no, draw window frame    &lt;EHB 29Aug85&gt;      BSR   BuildTBarRect    ; build a title bar rect    &lt;EHB 29Aug85&gt;      LEA   ZoomData,A1     ; get the zoom data       &lt;EHB 29Aug85&gt;      MOVEQ  #srcCopy,D0     ; plot in srcCopy mode      &lt;EHB 29Aug85&gt;      BSR   PlotZoom      ; and plot the symbol      &lt;EHB 29Aug85&gt;DrawBody  MOVE.L  OneOne,D4      ; constant for shadowing; frame the body of the windowDrawFrame      TST.B  IsColor(A6)      ; is it color?      BEQ.S  @NoColor5      ; no, so skip this section            MOVE.L  #wFrameColor,D0    ; set up colors &lt;C203/08Oct86&gt; DAF      BSR    SetUpColor      ;         &lt;C203/08Oct86&gt; DAF      _RGBForeColor        ;         &lt;C203/08Oct86&gt; DAF      MOVE.L  #wContentColor,D0  ; set up background too for variant 1   &lt;CXXX/21Jan87&gt; DAF      BSR    SetUpColor      ;                     &lt;CXXX/21Jan87&gt; DAF      _RGBBackColor        ;                     &lt;CXXX/21Jan87&gt; DAF@NoColor5                ; END OF A COLOR-ONLY SECTION      MOVE.L  STRUCTRGN(A3),A0  ; get region handle      MOVE.L  (A0),A0       ; get region ptr      LEA   RGNBBOX(A0),A4    ; point A4 at the bounding box      SUB   D4,Bottom(A4)    ; inset the bottom (ignore shadow)      SUB   D4,Right(A4)    ; inset the right to ignore shadow      MOVE.L  A4,-(SP)      ; push bounding box      _FrameRect          ; frame the body; draw the drop shadow (for variant 0 and 3)      CMP   #3,D5        ; variant 3?      BEQ.S  @3          ; if so, paint it      TST.W  D5          ; variant 0?      BNE.S  @1          ; if not, skip@3      BSR   PaintDropShadow   ; paint the drop shadow; draw fancy for dialog box ( only for variant 1)@1      CMP   #1,D5        ; dialog box?      BNE.S  @2          ; if not, skip      MOVE.L  (A4),TempRect    ; copy bounds into tempRect      MOVE.L  4(A4),TempRect+4      PEA   TempRect      MOVE.L  (SP),-(SP)      ; copy it      MOVE.L  (SP),-(SP)      MOVE.L  OneOne,-(SP)      _InsetRect          ; inset it      MOVE.L  #$00070007,-(SP)  ; erase to edge of content rgn      _PenSize      MOVE.L  (A5),A0      PEA   White(A0)      _PenPat      _FrameRect      MOVE.L  (A5),A0      PEA   Black(A0)      _PenPat      MOVE.L  #$00020002,-(SP)  ; push inset factor      MOVE.L  (SP),-(SP)      ;; push new pen size      _PenSize          ; set new pen size      _InsetRect      PEA   TempRect      _FrameRect          ; and frame it      _PenNormal@2            MOVE.L  STRUCTRGN(A3),A4  ; get region handle again, for safety  &lt;S369/25Jan88&gt; DAF      MOVE.L  (A4),A4       ; get region ptr            &lt;S369/25Jan88&gt; DAF      LEA   RGNBBOX(A4),A4    ; point A4 at the bounding box      &lt;S369/25Jan88&gt; DAF            ADD   D4,Bottom(A4)      ADD   D4,Right(A4)DoneDoc      RTSHilitePattern      DC.W  $FF00,$FF00,$FF00,$FF00; BuildTBarRect builds a rectangle enclosing the titleBar in TempRectBuildTBarRect      LEA   TEMPRECT,A0     ; get pointer to tempRect      MOVE.L  STRUCTRGN(A3),A1  ; get structure region handle      MOVE.L  (A1),A1       ; get strucRgn pointer      ADDQ  #RGNBBOX,A1     ; point A1 at the bounding box      MOVE.L  (A1)+,(A0)      ; copy bounding box into tempRect      MOVE.L  (A1),4(A0);  make bottom := top + WHeight      MOVE  Top(A0),D0      ; get top      ADD.W  D7,D0        ; add precomputed height        &lt;29Aug85&gt;      MOVE  D0,Bottom(A0)    ; update bottom      SUBQ  #1,Right(A0)    ; inset right      RTS             ; return to caller; decide which icon needs hilitingEORStuff  BEQ.S  EORGoAway      ; =&gt; it's the goAway                &lt;EHB 29Aug85&gt;      BSR   IsThereZoom     ; should we do zoom?        &lt;EHB 29Aug85&gt;      BEQ.S  NoGo        ; =&gt; no               &lt;EHB 29Aug85&gt;; EORZoom hilites/unhilites the zoom button.  Falls into PlotZoomEORZoom   BSR.S  BuildTBarRect    ; build the bounding rect      &lt;EHB 29Aug85&gt;      LEA   ZoomData+32,A1    ; get the zoom data       &lt;EHB 29Aug85&gt;      MOVEQ  #srcXOR,D0      ; set EOR as the plot mode      &lt;EHB 29Aug85&gt;PlotZoom  LEA   TempRect,A0     ; start from titlebar rect      &lt;EHB 29Aug85&gt;      MOVE  right(A0),left(A0)  ; left := right-22          &lt;EHB 03Nov85&gt;      MOVEQ  #-22,D1       ;                  &lt;EHB 03Nov85&gt;      BRA.S  PlotIt        ; use common code to plot it    &lt;EHB 29Aug85&gt;; EORGoAway hilites/unhilites the goAway button.  It falls through into PlotGoAwayEorGoAway      BSR.S  BuildTBarRect    ; build the bounding rect      LEA   GoAwayData+32,A1  ; get the bitMap      MOVEQ  #srcXOR,D0      ; set EOR as the plot mode; PlotGoAway plots the goAway button.  A1 holds the symbol, D1 the plotting modePlotGoAway; make Temprect into a 16x16 square for our little bitmap      LEA   TempRect,A0     ; point to temprect           &lt;5Aug85&gt;      MOVEQ  #7,D1        ; add margin to left          &lt;5Aug85&gt;PlotIt    ADD.W  D1,left(A0)     ; add offset to left           &lt;29Aug85&gt;      MOVE.W  WBoxDelta(A6),D1  ; get offset from top to GABox      &lt;5Aug85&gt;      ADD.W  D1,(A0)       ; add offset to top           &lt;5Aug85&gt;      SUBQ.W  #1,(A0)       ; align bitmap              &lt;5Aug85&gt;      MOVE.L  (A0)+,(A0)      ; bottom/right = top/left        &lt;5Aug85&gt;      MOVEQ  #16,D1        ; get a constant            &lt;5Aug85&gt;      ADD.W  D1,(A0)+      ; Bottom = top + 16           &lt;5Aug85&gt;      ADD.W  D1,(A0)       ; Right = Left + 16           &lt;5Aug85&gt;      MOVE.L  #$00100010,D1      BSR   PlotSymbol      ; plot it in tempRectNoGo    RTS; DialogBoxes have no title bar and extra shadowDrawDBox      MOVE.L  #$00020002,D4    ; get shadow factor      CMP.W  #3,D5        ; does it have shadow?      BEQ    DrawFrame      ; if so, we're cool (was .S)      MOVEQ  #0,D4        ; otherwise no shadow      BRA   DrawFrame      ; go draw it (was .S); DoTitleString is the common code that draws the title centered in tempRect.  Warning --; it trashes D3.  On exit, the left edge of the title's box is in D3 and; the right edge is in D4.DoTitleString; compute indent factor based on GoAwayButton state@1      MOVE.W  TempRect+Right,D4  ; get right into D4     &lt;EHB 18-Oct-85&gt;      MOVE.W  D4,D3        ;              &lt;EHB 18-Oct-85&gt;      SUB.W  TempRect+Left,D3  ; compute width      SUB.W  WTITLEWIDTH(A3),D3  ; compute extra x      ASR.W  #1,D3        ; divide by 2; if the string is too long, position left edge      MOVEQ  #2,D0        ; start title at x = 2    &lt;16-May-85 EHB&gt;      TST.B  WGoAway(A3)     ; is there a go away button &lt;16-May-85 EHB&gt;      BEQ.S  @2          ; skip if there's not       &lt;16-May-85 EHB&gt;      MOVEQ  #32,D0        ; start title at x = 32   &lt;16-May-85 EHB&gt;@2      CMP.W  D0,D3        ; to left of x?       &lt;16-May-85 EHB&gt;      BGE.S  @3          ; =&gt; no, D3 is ok      &lt;16-May-85 EHB&gt;      MOVE.W  D0,D3@3      ADD.W  TempRect+Left,D3  ; compute x position      MOVE.W  D4,-(SP)      ; save right across clip  &lt;EHB 18-Oct-85&gt;      BSR   IsThereZoom     ; is there a zoom box?    &lt;EHB 18-Oct-85&gt;      BEQ.S  @4          ; =&gt; no, edge ok      &lt;EHB 18-Oct-85&gt;      SUB.W  #32,D4        ; get default right edge  &lt;EHB 18-Oct-85&gt;@4; set clip to d3..d4      MOVE.L   TempRgn(A6),-(SP)  ; get our temp region    &lt;EHB 18-Oct-85&gt;      MOVE.L   (SP),-(SP)     ; copy for SectRgn      &lt;EHB 18-Oct-85&gt;      _GetClip          ; and save for restore    &lt;EHB 18-Oct-85&gt;      MOVE.W  D4,TempRect+Right  ; set right for clipping  &lt;EHB 18-Oct-85&gt;      PEA   TempRect      ; point to tempRect     &lt;EHB 18-Oct-85&gt;      _ClipRect          ; set clipping to it    &lt;EHB 18-Oct-85&gt;      MOVE.L  (A5),A0       ; get globals        &lt;EHB 18-Oct-85&gt;      MOVE.L  (A0),A0       ; get port          &lt;EHB 18-Oct-85&gt;      MOVE.L  ClipRgn(A0),-(SP)  ; and the rect region    &lt;EHB 18-Oct-85&gt;      MOVE.L  (SP),-(SP)      ; and use clip as dest    &lt;EHB 18-Oct-85&gt;      _SectRgn          ; get the intersection    &lt;EHB 18-Oct-85&gt;      MOVE.W  (SP)+,TempRect+Right  ; restore tempRect    &lt;EHB 18-Oct-85&gt;      MOVE.W  D3,-(SP)      ; push left for MoveTo      MOVE.W  TempRect+Top,D0   ; get top            &lt;EHB 5Aug85&gt;      ADD.W  WAscent(A6),D0    ; move down to baseline     &lt;EHB 5Aug85&gt;      ADDQ.W  #1,D0        ; leave 2 pixels white space  &lt;EHB 7Aug85&gt;      MOVE.W  D0,-(SP)      ; push baseline         &lt;EHB 5Aug85&gt;      _MoveTo      TST.B  IsColor(A6)      ; is it on a color system?        BEQ.S  @NoColor6      MOVE.W  #wTitleBarColor,D0  ; set up drawing colors      BSR    SetUpColor      ;      _RGBBackColor      MOVE.W  #wTextColor,D0    ;          BSR    SetUpColor      ;       _RGBForeColor        ;            MOVE.W  #srcOR,-(SP)    ; set the mode to source OR    &lt;C407/16Nov86&gt; DAF      _TextMode          ;                &lt;C407/16Nov86&gt; DAF      @NoColor6                ; END OF A COLOR ONLY SECTION            MOVE.L  WTITLEHANDLE(A3),A0 ; get titleHandle      _HLock            ; lock the title down      &lt;C491/08Dec86&gt; DAF      MOVE.L  (A0),-(SP)      ; push title pointer      _DrawString         ; draw it      MOVE.L  WTitleHandle(A3),A0  ; get the handle again      &lt;C491/08Dec86&gt; DAF      _HUnlock          ; release it          &lt;C491/08Dec86&gt; DAF            MOVE.L  TempRgn(A6),-(SP)  ; push the old clip       &lt;EHB 18-Oct-85&gt;      _SetClip          ; and restore it        &lt;EHB 18-Oct-85&gt;; now calculate the size of the clear area needed for the title; (only used if the window is highlighted).      MOVE.W  D3,D0        ; left in D3, calc right in D0      SUBQ  #6,D3        ; indent to the left      ADD.W  WTitleWidth(A3),D0  ; add in the length       &lt;EHB 18-Oct-85&gt;      CMP.W  D4,D0        ; was title longer than space?  &lt;EHB 18-Oct-85&gt;      BGE.S  @5          ; =&gt; yes, use D4        &lt;EHB 18-Oct-85&gt;      MOVE.W  D0,D4        ;                &lt;EHB 18-Oct-85&gt;@5      ADD.W  #6,D4        ; indent on right        &lt;EHB 18-Oct-85&gt;      RTS             ; Left in D3, right in D4; old arrow zoom data;ZoomData   .WORD   $0000,$0000,$0078,$0038;       .WORD   $0078,$00E8,$01C0,$0380;       .WORD   $0700,$2E00,$3C00,$3800;       .WORD   $3C00,$0000,$0000,$0000; mask;       .WORD   $0000,$0000,$0078,$0038;       .WORD   $0198,$0008,$0020,$0820;       .WORD   $0800,$2000,$3300,$3800;       .WORD   $3C00,$0000,$0000,$0000; Snazzy new zoom dataZoomData  DC.W  $0000,$0000,$BFFB,$2088      DC.W  $A08B,$2088,$A08B,$2088      DC.W  $BF8B,$2008,$A00B,$2008      DC.W  $BFFB,$0000,$0000,$0000; mask      DC.W  $0000,$0000,$0000,$0180      DC.W  $09A0,$05C0,$0080,$1CF0      DC.W  $1F80,$0540,$0920,$0100      DC.W  $0000,$0000,$0000,$0000; BitMap for default GoAway buttonGoAwayData; This is the real goAway Data      DC.W  $0000,$0000,$BFFB,$2008      DC.W  $A00B,$2008,$A00B,$2008      DC.W  $A00B,$2008,$A00B,$2008      DC.W  $BFFB,$0000,$0000,$0000; starburst mask       DC.W    $0000,$0000,$0000,$0100       DC.W    $0920,$0540,$0000,$1C70       DC.W    $0000,$0540,$0920,$0100       DC.W    $0000,$0000,$0000,$0000;  Mask for goAway button (concentric squares);       .WORD   $0000,$0000,$0000,$0000;       .WORD   $0FE0,$0820,$0BA0,$0AA0;       .WORD   $0BA0,$0820,$0FE0,$0000;       .WORD   $0000,$0000,$0000,$0000; HitDoc -- perform a hit test on the document.  On entry, D3 contains the mousePoint; in global coordinates while A3 holds the window pointerHitDoc      CLR.W  -(SP)        ; make room for function result      MOVE.L  D3,-(SP)      ; push the mouse point      MOVE.L  CONTRGN(A3),-(SP)  ; push content region handle      _PtInRgn          ; is the point in the content region?      TST.B  (SP)+        ; well, is it?      BEQ.S  NotInContent    ; if not, go check out drag region; it's in the content region -- see if its in the grow icon area      TST.W  D5          ; is it a dialogBox?      BNE.S  justContent     ; if so, its only in the content      BTST  #hasGrow,D6         ; inGrow enabled?           &lt;EHB 29Aug85&gt;      BGT.S  justContent     ; if not, skip      TST.B  WHilited(A3)    ; is it active?      BEQ.S  justContent     ; if not, it cant be in grow      MOVE.L  ContRgn(A3),A0    ; get region handle      MOVE.L  (A0),A0       ; get region ptr      MOVE.L  RgnBBox+botRight(A0),D0 ; get bottom left of content; first consider the x coordinate &lt;16-May-85 EHB&gt;      MOVEQ  #14,D4        ; keep 14 in a register to save code      SUB   D4,D0        ; offset x by 14      CMP   D0,D3        ; if &lt;, just in content      BLT.S  justContent; its within range on x so try y      SWAP  D0      SUB   D4,D0        ; check out y dimension      SWAP  D3      CMP   D0,D3        ; compare y coordinates      BLT.S  justContent      MOVEQ  #wInGrow,D0     ; flag in grow Icon      BRA   DoneHitDoc; the point is in the content region so return a '1'justContent      MOVEQ  #wInContent,D0    ; return in content      BRA    DoneHitDoc      ; go store function result and return; its not in the content -- see if its in the dragRgn (content extended by titleBar)NotInContent      TST   D5          ; is it a dialogBox?      BNE     DoneHit1      ; dBoxes have no drag region      BSR   BuildTBarRect    ; get the title bar rect into A0  &lt;EHB 21-Oct-85&gt;      CLR.W  -(SP)        ; make room for function result      MOVE.L  D3,-(SP)      ; push the mouse point      MOVE.L  A0,-(SP)      ; and push the rect         &lt;EHB 21-Oct-85&gt;      _PtInRect          ; is the point in the title bar?      TST.B  (SP)+        ; examine result      BEQ.S  DoneHit1      ; if not, return 0 (do nothing)      TST.B  WHilited(A3)    ; is it hilited?      BEQ.S  ItsInDrag      ; if not, can't be in GoAway; test vertical for goAway and Zoom since they're the same      MOVE.L  D3,D0        ; check vertical        &lt;EHB 29Aug85&gt;      SWAP  D0          ; which is high word of D3    &lt;EHB 29Aug85&gt;      MOVE.L  A3,A0        ; convert the pointer if its a pixmap &lt;C424/18Nov86&gt; DAF      BSR    PortToMap      ; convert            &lt;C424/18Nov86&gt; DAF      ADD.W  Bounds+Top(A0),D0  ; convert to local      &lt;EHB 29Aug85&gt;      SUB.W  PortRect+Top(A3),D0   ; compensate for origin   &lt;EHB 29Aug85&gt;      ADD.W  WBoxDelta(A6),D0    ; below box?        &lt;5Aug85&gt;      BPL.S  ItsInDrag        ; =&gt; yes          &lt;5Aug85&gt;      ADD.W  #11,D0          ; in box?          &lt;5Aug85&gt;      BMI.S  ItsInDrag        ; =&gt; no           &lt;5Aug85&gt;      TST.B  WGoAway(A3)     ; is there a goAway button?      BEQ.S  HitZoom       ; =&gt; no, hit-test zoom      &lt;EHB 29Aug85&gt;      MOVE.L  D3,D0        ; get mousePt      ADD   Bounds+Left(A0),D0  ; convert to local (A0 still valid) &lt;C424/18Nov86&gt; DAF      SUB   PortRect+Left(A3),D0  ; compensate for origin      CMP   #18,D0        ; is it too far right?      BGT.S  HitZoom       ; if so, its in drag      &lt;EHB 29Aug85&gt;      SUBQ.W  #8,D0        ; it must be at least 7      BMI.S  ItsInDrag; its in the goAway button so signal it      MOVEQ  #wInGoAway,D0      BRA.S  DoneHitDocHitZoom   BSR   IsThereZoom     ; is zooming permitted?     &lt;EHB 29Aug85&gt;      BEQ.S  ItsInDrag      ; =&gt; not in these here parts  &lt;EHB 29Aug85&gt;      MOVE.W  D3,D0          ; get mousePt        &lt;EHB 29Aug85&gt;      MOVE.L  A3,A0          ; convert the pointer if its a pixmap &lt;C424/18Nov86&gt; DAF      BSR    PortToMap        ; convert          &lt;C424/18Nov86&gt; DAF      ADD.W  Bounds+Left(A0),D0  ; convert to local      &lt;EHB 29Aug85&gt;      SUB.W  PortRect+Right(A3),D0  ; make right edge = 0    &lt;EHB 29Aug85&gt;      CMP.W  #-19,D0         ; too far left?       &lt;EHB 03Nov85&gt;      BLT.S  ItsInDrag        ; =&gt; if so, it's in drag    &lt;EHB 29Aug85&gt;      CMP.W  #-9,D0          ; too far right?      &lt;EHB 03Nov85&gt;      BGT.S  ItsInDrag        ; =&gt; if so, it's in drag    &lt;EHB 18Oct85&gt;      BSR   IsItSmall        ; is window big?      &lt;EHB 29Aug85&gt;      BEQ.S  @1            ; =&gt; oh boy, right again  &lt;EHB 29Aug85&gt;      MOVEQ  #wInZoomOut,D0      ; say window small      &lt;EHB 29Aug85&gt;      BRA.S  DoneHitDoc        ; und scram-muller      &lt;EHB 29Aug85&gt;@1      MOVEQ  #wInZoomIn,D0      ; say window big      &lt;EHB 29Aug85&gt;      BRA.S  DoneHitDoc        ; and muller out of here  &lt;EHB 29Aug85&gt;ItsInDrag  MOVEQ  #wInDrag,D0     ; flag in drag regionDoneHitDoc  MOVE.L  D0,20(A6)      ; update function resultDoneHit1  RTS; CalcDoc  -- calculate the structure and content regions for the window pointed; to by A3.  First update size for zooming if necessaryCalcDoc   BSR   IsThereZoom     ; zoom feature enabled?     &lt;EHB 29Aug85&gt;      BEQ.S  @1          ; =&gt; no             &lt;EHB 29Aug85&gt;      BSR   IsItSmall      ; update window size      &lt;EHB 29Aug85&gt;@1      LEA   TEMPRECT,A0     ; get a pointer to the work rectangle      MOVE.L  A0,-(SP)      ; push for later offset      MOVE.L  PORTRECT(A3),(A0)+  ; copy topLeft of portRect      MOVE.L  PORTRECT+4(A3),(A0) ; copy botLeft of portRect; offset it to global coordinates      MOVE.L  A3,A0        ; convert the pointer if its a pixmap &lt;C424/18Nov86&gt; DAF      BSR    PortToMap      ; convert            &lt;C424/18Nov86&gt; DAF      MOVE.L  BOUNDS(A0),-(SP)  ; push topLeft of port.portBits.bounds &lt;C424/18Nov86&gt; DAF      NEG   0(SP)        ; negate offset      NEG   2(SP)        ; both words      _OffsetRect         ; offset tempRect to global coordinates;  make the rectangular content region      MOVE.L  CONTRGN(A3),-(SP)  ; content region gets the result      PEA   TempRect      ; tempRect is the rectangle      _RectRgn          ; go make the region into content region; now do the structure region.  First correct the bounding rectangle (tempRect) for; structure instead of content      MOVE.L  #$00020002,D4    ; get the shadow factor for DBox      MOVE.L  STRUCTRGN(A3),-(SP) ; push the structRgn for later      PEA   TEMPRECT      ; push a pointer to the rect      MOVE.L  (SP),-(SP)      ; make two copies      MOVE.L  MinusOne,-(SP)    ; make 1 pixel bigger, all around      _InsetRect          ; make it bigger      TST.W  D5          ; is it dBox?      BNE.S  DoDBoxCalc      ; skip if it is      MOVE.W  D7,D0        ; move up to top of window        &lt;29Aug85&gt;      SUBQ.W  #1,D0        ; tweak it                &lt;5Aug85&gt;      SUB.W  D0,TempRect+Top   ; and set top of struct region      &lt;5Aug85&gt;      LSR.L  #1,D4        ; adjust shadow factorCalcCommon      _RectRgn          ; RectRgn(structRgn,tempRect); now add in the 1 or 2 pixel drop shadow (if necessary)      TST   D5      BEQ.S  @1          ; if so, it has shadow      CMP   #3,D5        ; is it variant 3?      BNE.S  NoDropShadow    ; if not, no shadow@1      TST.B  IsColor(A6)      ; are we on a multi-bit Mac?      BEQ.S  NormShadow      ; if not, then do normal shadows      TST.W  D5          ; if it's a dialog box, do a normal shadow also      BNE.S  NormShadow      ;            ADD.L  D4,TempRect+botright ; increase rect by shadow size      MOVE.L  StructRgn(A3),-(SP)  ; push the regionHandle      PEA    TempRect      ; and the rect      _RectRgn          ; and set it      BRA.S  CommShadow      ; and continueNormShadow      MOVE.L  TempRgn(A6),-(SP)  ; get temp region          &lt;EHB 18Oct85&gt;      PEA   TempRect      ; push tempRect      MOVE.L  (SP),-(SP)      ; save another copy      MOVE.L  D4,-(SP)      ; push shadow factor      _OffsetRect         ; offset it      _RectRgn      MOVE.L  StructRgn(A3),-(SP)      MOVE.L  TempRgn(A6),-(SP)  ; get temp region          &lt;EHB 18Oct85&gt;      MOVE.L  StructRgn(A3),-(SP) ; structure gets the result      _UnionRgn          ; add it inCommShadow; all done with CalcDocRgnsNoDropShadow      RTSDoDBoxCalc      CMP   #1,D5        ; is it variant 1?      BNE.S  CalcCommon      PEA   TempRect      ; push our rectangle      MOVE.L  #$FFF9FFF9,-(SP)  ; push (-7,-7)      _InsetRect          ; inset it      BRA.S  CalcCommon      ; use common code for the rest; GrowDoc handles the grow message by drawing a grow outline based on the rectangle; passed in D3GrowDoc; first make it one pixel bigger to jibe with the structure      MOVE.L  D3,-(SP)      ; push the rect      MOVE.L  MinusOne,-(SP)    ; push (-1,-1)      _InsetRect      MOVE.L  D3,A3        ; get rect ptr      MOVE.L  Top(A3),-(SP)    ; save topleft for below      &lt;5Aug85&gt;      MOVE.W  D7,D0        ; adjust for title          &lt;29Aug85&gt;      SUB.W  #1,D0        ; and tweak it            &lt;5Aug85&gt;      SUB.W  D0,Top(A3)      ; and save it            &lt;5Aug85&gt;      MOVE.L  D3,-(SP)      ; push the rectangle      _FrameRect          ; frame it;  now that the rectangle is drawn, draw the lower horizontal line      MOVE.W  Left(A3),-(SP)    ; push left      MOVE.W  Bottom(A3),-(SP)  ; push bottom      SUB   #16,(SP)      ; really 16 pixels above bottom      MOVE.L  (SP),-(SP)      ; make a copy of this point      _MoveTo           ; move to it      MOVE.W  Right(A3),2(SP)   ; now go to the right edge      _LineTo           ; draw the horizontal line; draw the upper horizontal line      MOVE.L  (SP),Top(A3)    ; restore topLeft, leave on stack  &lt;5Aug85&gt;      MOVE.L  (SP),-(SP)      ; make a copy of this point      _MoveTo           ; move to it      MOVE.W  Right(A3),2(SP)   ; now go to the right edge      _LineTo           ; draw the horizontal line; draw the vertical line      MOVE.W  Right(A3),-(SP)   ; push right      SUB   #16,(SP)      ; really want right - 16      MOVE.W  Top(A3),-(SP)    ; push top      MOVE.L  (SP),-(SP)      ; make a copy of this point      _MoveTo           ; and move to it      MOVE.W  Bottom(A3),(SP)   ; now go to bottom edge      _LineTo           ; draw the vertical line; restore the rect back to how it was when we got it      MOVE.L  D3,-(SP)      ; push the rect      MOVE.L  OneOne,-(SP)    ; push (1,1)      _InsetRect      RTS             ; all done!;  Utility PaintDropShadow -- drop shadows the rectangle in A4, by the amount in D4PaintDropShadow      MOVE.L  D4,-(SP)      ; push shadow factor      _PenSize          ; make penSize = shadow factor      MOVE  RIGHT(A4),D0    ; get right of menuRect      MOVE  D0,-(SP)      ; push right      MOVE  TOP(A4),-(SP)    ; push top;+++    IF not SquareWind THEN      ;           &lt;C203/06Oct86&gt; DAF;+++      ADD   D4,(SP)       ; want top+shadow;+++    ENDIF              ;           &lt;C203/06Oct86&gt; DAF      MOVE  D0,-(SP)      ; push right      MOVE  BOTTOM(A4),D0    ; get bottom      MOVE  D0,-(SP)      ; push bottom      MOVE  LEFT(A4),-(SP)    ; push left;+++    IF not SquareWind THEN      ;           &lt;C203/06Oct86&gt; DAF;+++      ADD   D4,(SP)       ; want left+shadow;+++    ENDIF              ;           &lt;C203/06Oct86&gt; DAF      MOVE  D0,-(SP)      ; push bottom      TST.B  IsColor(A6)      ; are we on a multi-bit Mac?      BNE.S  NOffSh        ; if so, then don't offset shadow      TST.W  D5          ;       BEQ.S  NOffSh        ;      ; adjust shadow line ends                  ADD    D4,2(SP)      ; want left+shadow      ADD    D4,8(SP)      ; want top+shadow            NOffSh; colors are OK here      _MoveTo           ; MoveTo(left+shadow,bottom)      _LineTo           ; LineTo(right,bottom)      _LineTo           ; LineTo(right,top+shadow)      _PenNormal          ; restore normal pen      RTS;  PlotSymbol -- plot the little 16 by 16 symbol bitmap pointed to by A1 into the rectangle;  pointed held in TempRect. D0 holds the mode.PlotSymbol      LEA   IconBitMap,A0    ; get pointer to source bitmap      MOVE.L  A1,(A0)+      ; update base address of bitMap      MOVE  #2,(A0)+      ; update rowBytes      CLR.L  (A0)+        ; topLeft is zero, zero      MOVE.L  D1,(A0)       ; adjust boundsRect; push parameters for CopyBits call to transfer arrow bitMap      PEA   IconBitMap      ; push pointer source bitmap      MOVE.L  (SP),A0       ; remember in A0, too      MOVE.L  GrafGlobals(A5),A1    ; get lisaGraf global baseaddress      MOVE.L  THEPORT(A1),A1    ; get thePort      PEA   PORTBITS(A1)    ; that's the destination bitmap      PEA   BOUNDS(A0)      ; boundsRect of bitmap is source      PEA   TempRect      ; tempRect is the destination      MOVE.W  D0,-(SP)      ; theMode is in D0      CLR.L  -(SP)        ; no mask region; the colors should be OK here                    &lt;DAF 16-Apr-86&gt;; transfer the bitMap (stretching as necessary...)      _CopyBits          ; let Bill stretch those bits      RTS             ; return to caller;  Draw the grow icon.  First make this window the current grafPortDrawGIcon      MOVE.L  GrafGlobals(A5),A0  ; get the current port and save it &lt;C203&gt; DAF      MOVE.L  thePort(A0),-(SP)  ;                   &lt;C203&gt; DAF            MOVE.L  A3,-(SP)      ; push the window's port      _SetPort          ; make that the port            ; save the foreground and background of the user port &amp; set new colors  &lt;DAF 16-Apr-86&gt;      TST.B  IsColor(A6)      ; is this a color system?      BEQ.S  @NoColor7      ; nope, so skip this stuff            SUBQ  #6,SP        ; make room for rgbColor on stack  &lt;C???/11Jan87&gt; DAF      MOVE.L  SP,-(SP)      ; push pointer to placeholder    &lt;C???/11Jan87&gt; DAF      _GetForeColor        ; get the window port's foreColor  &lt;C???/11Jan87&gt; DAF            SUBQ  #6,SP        ; make room for the backColor too  &lt;C???/11Jan87&gt; DAF      MOVE.L  SP,-(SP)      ; push pointer to placeholder    &lt;C???/11Jan87&gt; DAF      _GetBackColor        ; get the window port's backColor  &lt;C???/11Jan87&gt; DAF      MOVE.W  #wContentColor,D0  ; get the drawing color      BSR    SetUpColor      ;       _RGBBackColor        ;                  &lt;C117/25Sep86&gt; DAF      MOVE.W  #wFrameColor,D0    ;      BSR    SetUpColor      ;      _RGBForeColor        ;                  &lt;C117/25Sep86&gt; DAF@NoColor7                ; END OF COLOR-ONLY SECTION;  compute the grow icon rectangle in tempRect      LEA   TempRect,A4     ; get pointer to tempRect      MOVE.L  PortRect+4(A3),4(A4)  ; copy in botRight of tempRect      MOVE.L  4(A4),(A4)      ; into the topLeft, too      SUB.W  #15,Top(A4)      SUB.W  #15,Left(A4)    ; and left, too; plot the grow icon      TST.B  WHilited(A3)    ; is it hilited?      BEQ.S  ClearGoAway     ; if not, go clear it      LEA   GrowBits,A1     ; get pointer to the bits      MOVEQ  #0,D0        ; use srcCopy      MOVE.L  #$00100010,D1      BSR    PlotSymbol      ; plot it; plot the  boundary linesPlotBoundary      MOVE.W  Left(A4),-(SP)    ; push tempRect.left      MOVE.W  (SP),-(SP)      ; copy it again for later      MOVE  PortRect+Top(A3),-(SP)  ; push portRect.top      _MoveTo           ; move to it      MOVE  PortRect+Bottom(A3),-(SP)  ; push portRect.bottom      _LineTo           ; draw the vertical line; now draw the horizontal line      MOVE.W  PortRect+Left(A3),-(SP) ; push portRect.left      MOVE.W  Top(A4),-(SP)    ; push tempRect.top      _MoveTo      MOVE.W  PortRect+right(A3),-(SP)  ; push portRect.right      MOVE.W  Top(A4),-(SP)    ; push tempRect.top      _LineTo; all done with DrawDocGrowDoneDDG      TST.B  IsColor(A6)      ; is it a color system?      BEQ.S  @NoColor8      ; no, so skip this restore            MOVE.L  SP,-(SP)      ; push ptr to rgbColor previously saved on top of stack   &lt;C117/25Sep86&gt; DAF        _RGBBackColor        ;                 &lt;C117/25Sep86&gt; DAF        ADDQ  #6,SP        ; trash backcolor        &lt;C117/25Sep86&gt; DAF        MOVE.L  SP,-(SP)      ;                 &lt;C117/25Sep86&gt; DAF        _RGBForeColor        ;                &lt;C117/25Sep86&gt; DAF        ADDQ  #6,SP        ;                &lt;C117/25Sep86&gt; DAF  @NoColor8                ; END OF A COLOR-ONLY SECTION          _SetPort          ; restore the incoming port (saved above) &lt;C203&gt; DAF                          RTSClearGoAway      PEA   TempRect      _EraseRect      BRA.S  PlotBoundary; BitMap for GrowIconGrowBits      DC.W  $0000,$0000,$0000,$1FE0      DC.W  $1020,$103E,$1022,$1022      DC.W  $1022,$1022,$1FE2,$0402      DC.W  $0402,$0402,$07FE,$0000      END ; end of Window DefProc #0</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/DefProcs/listing7.html%3Fid%3DDTS10000184-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/DefProcs/listing7.html%3Fid%3DDTS10000184-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/DefProcs/listing7.html%3Fid%3DDTS10000184-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>