<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>QTCoreVideo202 - /Classes/OpenGL/PBOUnpack/OpenGLPBOUnpackKit.m</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../index.html#//apple_ref/doc/uid/TP30000925" target="_top">Sample Code</a> &gt; <a href="../GraphicsImaging/index.html#//apple_ref/doc/uid/TP30000925-TP30000424" target="_top">Graphics &amp; Imaging</a> &gt; <a href="../GraphicsImaging/idxQuickTime-date.html#//apple_ref/doc/uid/TP30000925-TP30000424-TP30000457">QuickTime</a> &gt; <A HREF="javascript:location.replace('index.html');">QTCoreVideo202</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->


	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">QTCoreVideo202</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Classes/OpenGL/PBOUnpack/OpenGLPBOUnpackKit.m</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Classes/Alert/Alert.c</option>
<option value="listing2.html">/Classes/Alert/Alert.h</option>
<option value="listing3.html">/Classes/Alert/AlertPanelKit.h</option>
<option value="listing4.html">/Classes/Alert/AlertPanelKit.m</option>
<option value="listing5.html">/Classes/MemObject/MemObject.h</option>
<option value="listing6.html">/Classes/MemObject/MemObject.m</option>
<option value="listing7.html">/Classes/MemObject/Memory.c</option>
<option value="listing8.html">/Classes/MemObject/Memory.h</option>
<option value="listing9.html">/Classes/OpenGL/PBOUnpack/OpenGLPBOUnpackKit.h</option>
<option value="listing10.html">/Classes/OpenGL/PBOUnpack/OpenGLPBOUnpackKit.m</option>
<option value="listing11.html">/Classes/OpenGL/Quad/OpenGLQuad.h</option>
<option value="listing12.html">/Classes/OpenGL/Quad/OpenGLQuad.m</option>
<option value="listing13.html">/Classes/OpenGL/Teapot/OpenGLTeapot.h</option>
<option value="listing14.html">/Classes/OpenGL/Teapot/OpenGLTeapot.m</option>
<option value="listing15.html">/Classes/OpenGL/Teapot/OpenGLTeapotList.c</option>
<option value="listing16.html">/Classes/OpenGL/Teapot/OpenGLTeapotList.h</option>
<option value="listing17.html">/Classes/OpenGL/Teapot/OpenGLTeapotTextured.h</option>
<option value="listing18.html">/Classes/OpenGL/Teapot/OpenGLTeapotTextured.m</option>
<option value="listing19.html">/Classes/OpenGL/View/OpenGLViewKit.h</option>
<option value="listing20.html">/Classes/OpenGL/View/OpenGLViewKit.m</option>
<option value="listing21.html">/Classes/QT/CoreVideo/QTCoreVideoController.h</option>
<option value="listing22.html">/Classes/QT/CoreVideo/QTCoreVideoController.m</option>
<option value="listing23.html">/Classes/QT/CoreVideo/QTCoreVideoOpenGLView.h</option>
<option value="listing24.html">/Classes/QT/CoreVideo/QTCoreVideoOpenGLView.m</option>
<option value="listing25.html">/Classes/QT/VisualContext/QTVisualContextKit.h</option>
<option value="listing26.html">/Classes/QT/VisualContext/QTVisualContextKit.m</option>
<option value="listing27.html">/main.m</option>
<option value="listing28.html">/QTCoreVideo202_Prefix.pch</option></select>
				</p>
				</form>
				<p><strong><a href="QTCoreVideo202.zip">Download Sample</a></strong> (&#147;QTCoreVideo202.zip&#148;, 1.35M)<BR>
<strong><a href="QTCoreVideo202.dmg">Download Sample</a></strong> (&#147;QTCoreVideo202.dmg&#148;, 1.59M)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">//---------------------------------------------------------------------------
//
//    File: OpenGLPBOUnpackKit.m
//
//  Abstract: Utility toolkit for handling PBOs (unpack)
//              
//  Disclaimer: IMPORTANT:  This Apple software is supplied to you by Apple
//  Computer, Inc. (&quot;Apple&quot;) in consideration of your agreement to the
//  following terms, and your use, installation, modification or
//  redistribution of this Apple software constitutes acceptance of these
//  terms.  If you do not agree with these terms, please do not use,
//  install, modify or redistribute this Apple software.
//  
//  In consideration of your agreement to abide by the following terms, and
//  subject to these terms, Apple grants you a personal, non-exclusive
//  license, under Apple&apos;s copyrights in this original Apple software (the
//  &quot;Apple Software&quot;), to use, reproduce, modify and redistribute the Apple
//  Software, with or without modifications, in source and/or binary forms;
//  provided that if you redistribute the Apple Software in its entirety and
//  without modifications, you must retain this notice and the following
//  text and disclaimers in all such redistributions of the Apple Software. 
//  Neither the name, trademarks, service marks or logos of Apple Computer,
//  Inc. may be used to endorse or promote products derived from the Apple
//  Software without specific prior written permission from Apple.  Except
//  as expressly stated in this notice, no other rights or licenses, express
//  or implied, are granted by Apple herein, including but not limited to
//  any patent rights that may be infringed by your derivative works or by
//  other works in which the Apple Software may be incorporated.
//  
//  The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE
//  MAKES NO WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION
//  THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS
//  FOR A PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND
//  OPERATION ALONE OR IN COMBINATION WITH YOUR PRODUCTS.
//  
//  IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL
//  OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
//  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
//  INTERRUPTION) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION,
//  MODIFICATION AND/OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED
//  AND WHETHER UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE),
//  STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
// 
//  Copyright (c) 2008 Apple Inc., All rights reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------

#import &lt;Accelerate/Accelerate.h&gt;

//---------------------------------------------------------------------------

#import &quot;AlertPanelKit.h&quot;
#import &quot;MemObject.h&quot;
#import &quot;OpenGLPBOUnpackKit.h&quot;

//---------------------------------------------------------------------------

//---------------------------------------------------------------------------

#define BUFFER_OFFSET(i) ((char *)NULL + (i))

//---------------------------------------------------------------------------

//---------------------------------------------------------------------------

struct OpenGLTextureAttributes
{
    GLuint         name;                // texture id
    GLuint         samplesPerPixel;        // number of bytes per pixel
    GLuint         size;                // width * height * samples per pixel
    GLint          level;                // level-of-detail    number
    GLint          hint;                // texture hint
    GLint          border;                // width of the border, either 0  or 1
    GLint          xoffset;                // x offset for texture copy
    GLint          yoffset;                // y offset for texture copy
    GLenum         target;                // e.g., texture 2D or texture rectangle
    GLenum         format;                // format
    GLenum         internalFormat;        // internal format
    GLenum         type;                // OpenGL specific type
    vImage_Buffer  buffer;                // An image buffer
};

typedef struct OpenGLTextureAttributes  OpenGLTextureAttributes;

//---------------------------------------------------------------------------

struct OpenGLPBOAttributes
{
    GLuint         name[2];        // PBO ids
    GLuint         index;        // PBO current index
    GLenum         target;        // e.g., pixel pack or unpack
    GLenum         usage;        // e.g., stream draw
    GLenum         access;        // e.g., read, write, or both
    GLuint         size;        // width * height * data size
    vImage_Buffer  buffer;        // An image buffer
};

typedef struct OpenGLPBOAttributes  OpenGLPBOAttributes;

//---------------------------------------------------------------------------

struct OpenGLPBOUnpackAttributes
{
    OpenGLTextureAttributes  texture;    // OpenGL texture attributes
    OpenGLPBOAttributes      pbo;        // OpenGL PBO attributes
    vImage_Buffer            source;    // Source image buffer
};

typedef struct OpenGLPBOUnpackAttributes   OpenGLPBOUnpackAttributes;

//---------------------------------------------------------------------------

//---------------------------------------------------------------------------

#pragma mark

//---------------------------------------------------------------------------

//---------------------------------------------------------------------------

@implementation OpenGLPBOUnpackKit

//---------------------------------------------------------------------------

#pragma mark -- OpenGL PBO Unpack Attribute Initializations --

//---------------------------------------------------------------------------
//
// Some other initialization values may come from:
//
//        texture-&gt;target         = GL_TEXTURE_RECTANGLE_EXT;
//        texture-&gt;format         = GL_BGRA_EXT;
//        texture-&gt;internalFormat = GL_RGBA;
//
// For samples-per-pixel with OpenGL type GL_UNSIGNED_INT_8_8_8_8 or 
// GL_UNSIGNED_INT_8_8_8_8_REV:
//
//        texture-&gt;samplesPerPixel = 4;
//
//---------------------------------------------------------------------------

- (void) newOpenGLTextureAttributes:(const NSSize *)theTextureSize
{
    attributes-&gt;texture.name            = 0;
    attributes-&gt;texture.level           = 0;
    attributes-&gt;texture.border          = 0;
    attributes-&gt;texture.xoffset         = 0;
    attributes-&gt;texture.yoffset         = 0;
    attributes-&gt;texture.hint            = GL_STORAGE_PRIVATE_APPLE;
    attributes-&gt;texture.target          = GL_TEXTURE_RECTANGLE_ARB;
    attributes-&gt;texture.format          = GL_BGRA;
    attributes-&gt;texture.type            = GL_UNSIGNED_INT_8_8_8_8_REV;
    attributes-&gt;texture.internalFormat  = GL_RGBA8;
    attributes-&gt;texture.samplesPerPixel = 4;
    attributes-&gt;texture.buffer.width    = (vImagePixelCount)theTextureSize-&gt;width;
    attributes-&gt;texture.buffer.height   = (vImagePixelCount)theTextureSize-&gt;height;
    attributes-&gt;texture.buffer.rowBytes = attributes-&gt;texture.buffer.width  * attributes-&gt;texture.samplesPerPixel;
    attributes-&gt;texture.size            = attributes-&gt;texture.buffer.height * attributes-&gt;texture.buffer.rowBytes;
    attributes-&gt;texture.buffer.data        = NULL;
} // newOpenGLTextureAttributes
 
//---------------------------------------------------------------------------
//
//  Other PBO usage types that may be utilized,
//
//        theAttributes-&gt;pbo.usage = GL_STATIC_DRAW;
//
//---------------------------------------------------------------------------

- (void) newOpenGLPBOAttributes
{
    attributes-&gt;pbo.name[0]         = 0;
    attributes-&gt;pbo.name[1]         = 0;
    attributes-&gt;pbo.index           = 0;
    attributes-&gt;pbo.target          = GL_PIXEL_UNPACK_BUFFER_ARB;
    attributes-&gt;pbo.usage           = GL_STREAM_DRAW_ARB;
    attributes-&gt;pbo.access          = GL_WRITE_ONLY_ARB;
    attributes-&gt;pbo.size            = attributes-&gt;texture.size;
    attributes-&gt;pbo.buffer.width    = attributes-&gt;texture.buffer.width;
    attributes-&gt;pbo.buffer.height   = attributes-&gt;texture.buffer.height;
    attributes-&gt;pbo.buffer.rowBytes = attributes-&gt;texture.buffer.rowBytes;
    attributes-&gt;pbo.buffer.data     = NULL;
} // newOpenGLPBOAttributes

//---------------------------------------------------------------------------

- (void) newSourceImageAttributes
{
    attributes-&gt;source.width    = attributes-&gt;texture.buffer.width;
    attributes-&gt;source.height   = attributes-&gt;texture.buffer.height;
    attributes-&gt;source.rowBytes = attributes-&gt;texture.buffer.rowBytes;
    attributes-&gt;source.data     = NULL;
} // newSourceImageAttributes

//---------------------------------------------------------------------------

#pragma mark -- Designated initializer --

//---------------------------------------------------------------------------

- (void) newOpenGLAttributes:(const NSSize *)thePBOSize
{
    [self newOpenGLTextureAttributes:thePBOSize];
    [self newOpenGLPBOAttributes];
    [self newSourceImageAttributes];
} // newOpenGLAttributes

//---------------------------------------------------------------------------

- (void) newOpenGLTexture
{
    glGenTextures(1, &amp;attributes-&gt;texture.name);
    
    glEnable(attributes-&gt;texture.target);
    
    glTextureRangeAPPLE(attributes-&gt;texture.target, 0, NULL);
    glTextureRangeAPPLE(GL_TEXTURE_2D, 0, NULL);
    
    glPixelStorei(GL_UNPACK_CLIENT_STORAGE_APPLE, GL_FALSE);
    
    glBindTexture(attributes-&gt;texture.target, attributes-&gt;texture.name);
    
    glTexParameteri(attributes-&gt;texture.target, GL_TEXTURE_STORAGE_HINT_APPLE, attributes-&gt;texture.hint);
    glTexParameteri(attributes-&gt;texture.target, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(attributes-&gt;texture.target, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(attributes-&gt;texture.target, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(attributes-&gt;texture.target, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    
    glTexImage2D(attributes-&gt;texture.target, 
                 attributes-&gt;texture.level, 
                 attributes-&gt;texture.internalFormat, 
                 attributes-&gt;texture.buffer.width,
                 attributes-&gt;texture.buffer.height, 
                 attributes-&gt;texture.border, 
                 attributes-&gt;texture.format,
                 attributes-&gt;texture.type, 
                 BUFFER_OFFSET(0));
    
    glDisable(attributes-&gt;texture.target);
} // newOpenGLTexture

//---------------------------------------------------------------------------

- (void) newOpenGLPBOUnpack
{
    glGenBuffersARB(2, attributes-&gt;pbo.name);
    
    glBindBufferARB(attributes-&gt;pbo.target, attributes-&gt;pbo.name[0]);
    
    glBufferDataARB(attributes-&gt;pbo.target, 
                    attributes-&gt;pbo.size, 
                    NULL, 
                    attributes-&gt;pbo.usage);
    
    glBindBufferARB(attributes-&gt;pbo.target, attributes-&gt;pbo.name[1]);
    
    glBufferDataARB(attributes-&gt;pbo.target, 
                    attributes-&gt;pbo.size, 
                    NULL, 
                    attributes-&gt;pbo.usage);
    
    glBindBufferARB(attributes-&gt;pbo.target, 0);
} // newOpenGLPBOUnpack

//---------------------------------------------------------------------------
//
// Initialize
//
//---------------------------------------------------------------------------

- (id) initPBOUnpackWithSize:(NSSize)thePBOSize
{
    self = [super initMemoryWithType:kMemAlloc size:sizeof(OpenGLPBOUnpackAttributes)];
    
    if ( self )
    {
        attributes = (OpenGLPBOUnpackAttributesRef)[self pointer];
        
        if ( [self isPointerValid] )
        {
            [self newOpenGLAttributes:&amp;thePBOSize];
            [self newOpenGLTexture];
            [self newOpenGLPBOUnpack];
        } // if
        else
        {
            [[AlertPanelKit withTitle:@&quot;OpenGL PBO Unpack Kit&quot; 
                              message:@&quot;Failure Allocating Memory For PBO Unpack Attributes&quot;
                                 exit:YES] displayAlertPanel];
        } // else
    } // if
    
    return  self;
} // initPBOUnpackWithSize

//---------------------------------------------------------------------------

#pragma mark -- Dealloc all the Resources --

//---------------------------------------------------------------------------

- (void) dealloc 
{
    if ( attributes-&gt;pbo.name )
    {
        glDeleteBuffers( 2, attributes-&gt;pbo.name );
    } // if
    
    if ( attributes-&gt;texture.name )
    {
        glDeleteTextures( 1, &amp;attributes-&gt;texture.name );
    } // if

    [super dealloc];
} // dealloc

//---------------------------------------------------------------------------

#pragma mark -- Draw into the OpenGL View --

//---------------------------------------------------------------------------

- (void) pboWrite
{
    GLint nextIndex = 0;  // pbo index used for next frame

    // Increment the current index first, then increment the 
    // next index:
    //
    // (1)  &quot;attributes-&gt;pbo.index&quot; is used to copy pixels 
    //      from a  PBO to a texture.
    //
    // (2)  The local variable &quot;nextIndex&quot; is used to update 
    //      pixels in a PBO
    
    attributes-&gt;pbo.index = (attributes-&gt;pbo.index + 1) % 2;
    
    nextIndex = (attributes-&gt;pbo.index + 1) % 2;

    // Bind the texture and PBO
    
    glBindTexture(attributes-&gt;texture.target, attributes-&gt;texture.name);
    
    glBindBufferARB(attributes-&gt;pbo.target, 
                    attributes-&gt;pbo.name[attributes-&gt;pbo.index] );

    // Use offset instead of pointer to copy pixels from PBO 
    // to texture.
    
    glTexSubImage2D(attributes-&gt;texture.target, 
                    attributes-&gt;texture.level, 
                    attributes-&gt;texture.xoffset, 
                    attributes-&gt;texture.yoffset, 
                    attributes-&gt;texture.buffer.width, 
                    attributes-&gt;texture.buffer.height,
                    attributes-&gt;texture.format, 
                    attributes-&gt;texture.type, 
                    BUFFER_OFFSET(0) );
    
    // Bind PBO to update pixel values
    
    glBindBufferARB(attributes-&gt;pbo.target, 
                    attributes-&gt;pbo.name[nextIndex]);
    
    // If GPU is working with a buffer, glMapBufferARB results in a sync
    // issue and will stall the GPU pipeline until such time the current 
    // job is processed. To avoid stalling the pipeline, one should call 
    // the API glBufferDataARB with a NULL pointer before calling the API,
    // glMapBufferARB. If you do so then the previous data in a PBO will 
    // be discarded and glMapBufferARB returns a new allocated pointer 
    // immediately even thought the GPU is still processing the previous 
    // data.
    
    glBufferDataARB(attributes-&gt;pbo.target, 
                    attributes-&gt;pbo.size, 
                    NULL,
                    attributes-&gt;pbo.usage );
    
    attributes-&gt;pbo.buffer.data 
    = (GLubyte *)glMapBufferARB(attributes-&gt;pbo.target, 
                                attributes-&gt;pbo.access);    
    
    if( attributes-&gt;pbo.buffer.data != NULL )
    {
        // Copy the pixel buffer to pbo and vertically
        // reflect the pixels
        
        vImageVerticalReflect_ARGB8888(&amp;attributes-&gt;source, 
                                       &amp;attributes-&gt;pbo.buffer, 
                                       kvImageNoFlags);
        
        // Release pointer to the mapping buffer
        
        glUnmapBufferARB(attributes-&gt;pbo.target);
    } // if

    // At this stage, it is good idea to release a PBO 
    // (with ID 0) after use. Once bound to ID 0, all 
    // pixel operations default to normal behavior.
    
    glBindBufferARB(attributes-&gt;pbo.target, 0);
} // pboWrite

//---------------------------------------------------------------------------

- (void) update:(CVPixelBufferRef)thePixelBuffer 
          flags:(CVOptionFlags)theFlags
{
    // Get the base address of the CoreVideo pixel buffer address
    
    CVPixelBufferLockBaseAddress( thePixelBuffer, theFlags );

        attributes-&gt;source.data = CVPixelBufferGetBaseAddress(thePixelBuffer);
        
    CVPixelBufferUnlockBaseAddress( thePixelBuffer, theFlags );
    
    // Update the pbo
    
    [self pboWrite];

    // Activate the pbo bound texture
    
    glEnable( attributes-&gt;texture.target );

    glBindTexture( attributes-&gt;texture.target, attributes-&gt;texture.name );
} // update

//---------------------------------------------------------------------------

@end

//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/QTCoreVideo202/listing10.html%3Fid%3DDTS40007786-1.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/QTCoreVideo202/listing10.html%3Fid%3DDTS40007786-1.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/QTCoreVideo202/listing10.html%3Fid%3DDTS40007786-1.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>