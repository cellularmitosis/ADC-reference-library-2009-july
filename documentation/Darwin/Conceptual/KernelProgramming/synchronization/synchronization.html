<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Kernel Programming Guide: Synchronization Primitives</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Synchronization Primitives"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30000905-CH218" title="Synchronization Primitives"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000422" target="_top">Darwin</a> &gt; <a href="../../../Kernel-date.html#//apple_ref/doc/uid/TP30000440-TP30000422-TP30000532" target="_top">Kernel</a> &gt; <a href="../About/About.html#//apple_ref/doc/uid/TP30000905-CH204-TPXREF101">Kernel Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../boundaries/boundaries.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../services/services.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30000905-CH218-BEHJDFCA" title="Synchronization Primitives"></a><h1>Synchronization Primitives</h1><p>This chapter is not intended as an introduction to synchronization. It is assumed that you have some understanding of the basic concepts of locks and semaphores already. If you need additional background reading, synchronization is covered in most introductory operating systems texts. However, since synchronization in the kernel is somewhat different from locking in an application this chapter does provide a brief overview to help ease the transition, or for experienced kernel developers, to refresh your memory.</p>
<p>As a Mac OS X kernel programmer, you have many choices of synchronization mechanisms at your disposal. The kernel itself provides two such mechanisms: locks and semaphores.</p>
<p>A <strong>lock</strong><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_878"></a> is used for basic protection of shared resources. Multiple threads can attempt to acquire a lock, but only one thread can actually hold it at any given time (at least for traditional locks—more on this later). While that thread holds the lock, the other threads must wait. There are several different types of locks, differing mainly in what threads do while waiting to acquire them.</p>
<p>A <strong>semaphore</strong><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_879"></a> is much like a lock, except that a finite number of threads can hold it simultaneously. Semaphores can be thought of as being much like piles of tokens. Multiple threads can take these tokens, but when there are none left, a thread must wait until another thread returns one. It is important to note that semaphores can be implemented in many different ways, so Mach semaphores may not behave in the same way as semaphores on other platforms.</p>
<p>In addition to locks and semaphores, certain low-level synchronization primitives like test and set are also available, along with a number of other atomic operations<a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_880"></a>. These additional operations are described in <code>libkern/gen/OSAtomicOperations.c</code> in the kernel sources. Such atomic operations may be helpful if you do not need something as robust as a full-fledged lock or semaphore. Since they are not general synchronization mechanisms, however, they are beyond the scope of this chapter.</p>


<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="synchronization.html#//apple_ref/doc/uid/TP30000905-CH218-TPXREF108">Semaphores</a>
				
			<br/>
			
        
			
			
				<a href="synchronization.html#//apple_ref/doc/uid/TP30000905-CH218-TPXREF109">Condition Variables</a>
				
			<br/>
			
        
			
			
				<a href="synchronization.html#//apple_ref/doc/uid/TP30000905-CH218-TPXREF110">Locks</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30000905-CH218-TPXREF108" title="Semaphores"></a><h2>Semaphores</h2>
<p>Semaphores and locks are similar, except that with semaphores, more than one thread can be doing a given operation at once. Semaphores are commonly used when protecting multiple indistinct resources. For example, you might use a semaphore to prevent a queue from overflowing its bounds.</p>
<p>Mac OS X uses traditional counting semaphores<a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_881"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_882"></a> rather than binary semaphores<a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_883"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_884"></a> (which are essentially locks). Mach semaphores obey Mesa semantics<a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_885"></a>—that is, when a thread is awakened by a semaphore becoming available, it is not executed immediately. This presents the potential for starvation in multiprocessor situations when the system is under low overall load because other threads could keep downing the semaphore before the just-woken thread gets a chance to run. This is something that you should consider carefully when writing applications with semaphores.</p>
<p>Semaphores can be used any place where mutexes can occur. This precludes their use in interrupt handlers or within the context of the scheduler, and makes it strongly discouraged in the VM system. The public API for semaphores is divided between the MIG–generated <code>task.h </code>file (located in your build output directory, included with <code>#include &lt;mach/task.h></code>) and <code>osfmk/mach/semaphore.h</code> (<code>included with #include &lt;mach/semaphore.h></code>).</p>
<p>The public semaphore API includes the following <a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_886"></a>functions:<a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_887"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_888"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_889"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_890"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_891"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_892"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_893"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_894"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_895"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_896"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_897"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_898"></a></p>
<div class="codesample"><table><tr><td scope="row"><pre>kern_return_t semaphore_create(task_t task, semaphore_t *semaphore,<span></span></pre></td></tr><tr><td scope="row"><pre>    int policy, int value)<span></span></pre></td></tr><tr><td scope="row"><pre>kern_return_t semaphore_signal(semaphore_t semaphore)<span></span></pre></td></tr><tr><td scope="row"><pre>kern_return_t semaphore_signal_all(semaphore_t semaphore)<span></span></pre></td></tr><tr><td scope="row"><pre>kern_return_t semaphore_wait(semaphore_t semaphore)<span></span></pre></td></tr><tr><td scope="row"><pre>kern_return_t semaphore_destroy(task_t task, semaphore_t semaphore)<span></span></pre></td></tr><tr><td scope="row"><pre>kern_return_t semaphore_signal_thread(semaphore_t semaphore,<span></span></pre></td></tr><tr><td scope="row"><pre>    thread_act_t thread_act)<span></span></pre></td></tr></table></div>
<p>which are described in <code>&lt;mach/semaphore.h></code> or <code>xnu/osfmk/mach/semaphore.h</code> (except for create and destroy, which are described in <code>&lt;mach/task.h></code>.</p>
<p>The use of these functions is relatively straightforward with the exception of the <code><!--a-->semaphore_create<!--/a--></code>, <code><!--a-->semaphore_destroy<!--/a--></code>, and <code><!--a-->semaphore_signal_thread<!--/a--></code> calls.</p>
<p>The <code>value</code> and <code>semaphore</code> parameters for <code><!--a-->semaphore_create<!--/a--></code> are exactly what you would expect—a pointer to the semaphore structure to be filled out and the initial value for the semaphore, respectively.</p>
<p>The <code>task</code> parameter refers to the primary Mach task that will “own” the lock. This task should be the one that is ultimately responsible for the subsequent destruction of the semaphore. The <code>task</code> parameter used when calling <code><!--a-->semaphore_destroy<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_899"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_900"></a> must match the one used when it was created.</p>
<p>For communication within the kernel, the <code>task</code> parameter should be the result of a call to <code><!--a-->current_task<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_901"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_902"></a>. For synchronization with a user process, you need to determine the underlying Mach task for that process by calling <code><!--a-->current_task<!--/a--></code> on the kernel side and <code><!--a-->mach_task_self<!--/a--></code> on the application side.</p>
<div class="codesample"><table><tr><td scope="row"><pre>task_t current_task(void);  // returns the kernel task port<span></span></pre></td></tr><tr><td scope="row"><pre>task_t mach_task_self(void);// returns the task port of the current  thread<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP30000905-CH218-SW1" title="Note"></a><p><strong>Note:</strong>&nbsp;In the kernel, be sure to always use <code><!--a-->current_task<!--/a--></code>. In the kernel, <code><!--a-->mach_task_self<!--/a--></code> returns a pointer to the kernel’s VM map, which is probably not what you want.</p>The details of user-kernel synchronization are beyond the scope of this document.</p></div>
<p>The <code>policy</code> parameter is passed as the policy for the wait queue contained within the semaphore. The possible values are defined in <code>osfmk/mach/sync_policy.h</code>. Current possible values are:</p>
<ul class="ul"><li class="li"><p><code><!--a  -->SYNC_POLICY_FIFO<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_903"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_904"></a></p></li>
<li class="li"><p><code><!--a  -->SYNC_POLICY_FIXED_PRIORITY<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_905"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_906"></a></p></li>
<li class="li"><p><code><!--a  -->SYNC_POLICY_PREPOST<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_907"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_908"></a></p></li></ul>
<p><code></code>The FIFO policy is, as the name suggests, first-in-first-out. The fixed priority policy causes wait queue reordering based on fixed thread priority policies. The prepost policy causes the <code><!--a-->semaphore_signal<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_909"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_910"></a> function to not increment the counter if no threads are waiting on the queue. This policy is needed for creating condition variables (where a thread is expected to always wait until signalled). See the section <span class="content_text"><a href="../scheduler/scheduler.html#//apple_ref/doc/uid/TP30000905-CH211-TPXREF113">“Wait Queues and Wait Primitives”</a></span> for more information.</p>
<p>The <code><!--a-->semaphore_signal_thread<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_911"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_912"></a> call takes a particular thread from the wait queue and places it back into one of the scheduler’s wait-queues, thus making that thread available to be scheduled for execution. If <code>thread_act</code> is <code><!--a  -->NULL<!--/a--></code>, the first thread in the queue is similarly made runnable.</p>
<p>With the exception of <code>semaphore_create</code><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_913"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_914"></a> and <code>semaphore_destroy</code><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_915"></a>, these functions can also be called from user space via RPC. See <span class="content_text"><a href="../boundaries/boundaries.html#//apple_ref/doc/uid/TP30000905-CH217-BABDAJGG">“Calling RPC From User Applications”</a></span> for more information.<a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_916"></a></p>
<a name="//apple_ref/doc/uid/TP30000905-CH218-TPXREF109" title="Condition Variables"></a><h2>Condition Variables</h2>
<p>The BSD portion of Mac OS X provides <code><!--a-->msleep<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_917"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_918"></a>, <code><!--a-->wakeup<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_919"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_920"></a>, and <code><!--a-->wakeup_one<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_921"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_922"></a>, which are equivalent to condition variables with the addition of an optional time-out. You can find these functions in <code>sys/proc.h</code> in the Kernel framework headers.</p><div class="codesample"><table><tr><td scope="row"><pre>msleep(void *channel, lck_mtx_t *mtx, int priority, const char *wmesg,  struct  timespec *timeout);<span></span></pre></td></tr><tr><td scope="row"><pre>msleep0(vvoid *channel, lck_mtx_t *mtx, int priority, const char  *wmesg, uint64_t  deadline);<span></span></pre></td></tr><tr><td scope="row"><pre>wakeup(void *channel);<span></span></pre></td></tr><tr><td scope="row"><pre>wakeup_one(void *channel);<span></span></pre></td></tr></table></div><p>Since <code>msleep</code> is more commonly used for waiting a predetermined period of time, the <code>wakeup</code> and <code>wakeup_one</code> calls are discussed along with <code>msleep</code> in more detail in the section <span class="content_text"><a href="../services/services.html#//apple_ref/doc/uid/TP30000905-CH219-CHDFIGGH">“Using msleep”</a></span> as part of the <span class="content_text"><a href="../services/services.html#//apple_ref/doc/uid/TP30000905-CH219-BEHJDFCA">“Miscellaneous Kernel Services”</a></span> chapter.</p>
<p>Outside the BSD portion of the kernel, condition variables<a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_923"></a> may be implemented using semaphores.</p>
<a name="//apple_ref/doc/uid/TP30000905-CH218-TPXREF110" title="Locks"></a><h2>Locks</h2>
<p>Mac OS X (and Mach in general) has three basic types of lock<a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_924"></a>s: spinlock<a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_925"></a>s<a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_926"></a>, mutexes<a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_927"></a>, and read-write locks<a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_928"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_929"></a>. Each of these has different uses and different problems. There are also many other types of locks that are not implemented in Mac OS X, such as spin-sleep locks, some of which may be useful to implement for performance comparison purposes.</p>
<a name="//apple_ref/doc/uid/TP30000905-CH218-TPXREF111" title="Spinlocks"></a><h3>Spinlocks</h3>
<p>A spinlock is the simplest type of lock. In a system with a test-and-set instruction or the equivalent, the code looks something like this:</p>
<div class="codesample"><table><tr><td scope="row"><pre>while (test_and_set(bit) != 0);<span></span></pre></td></tr></table></div>
<p>In other words, until the lock is available, it simply “spins” in a tight loop that keeps checking the lock until the thread’s <strong>time quantum</strong><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_930"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_931"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_932"></a> expires and the next thread begins to execute. Since the entire time quantum for the first thread must complete before the next thread can execute and (possibly) release the lock, a spinlock is very wasteful of CPU time, and should be used <em>only</em> in places where a mutex cannot be used, such as in a hardware exception handler or low-level interrupt handler.</p>
<p>Note that a thread may not block while holding a spinlock, because that could cause deadlock. Further, preemption is disabled on a given processor while a spinlock is held.</p>
<p>There are three basic types of spinlocks<a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_933"></a> available in Mac OS X: <code>lck_spin_t</code><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_934"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_935"></a> (which supersedes <code>simple_lock_t</code>), <code>usimple_lock_t</code><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_936"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_937"></a>, and <code>hw_lock_t</code>. You are strongly encouraged to <em>not</em> use <code>hw_lock_t</code><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_938"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_939"></a>; it is only mentioned for the sake of completeness. Of these, only <code>lck_spin_t</code> is accessible from kernel extensions.</p>
<p>The <code>u</code> in <code>usimple</code> stands for uniprocessor, because they are the only spinlocks that provide actual locking on uniprocessor systems. Traditional simple locks, by contrast, disable preemption but do not spin on uniprocessor systems. Note that in most contexts, it is not useful to spin on a uniprocessor system, and thus you usually only need simple locks. Use of usimple locks is permissible for synchronization between thread context and interrupt context or between a uniprocessor and an intelligent device. However, in most cases, a mutex is a better choice.</p>
<div class="importantbox"><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_12" title="Important:"></a><p><strong>Important:</strong>&nbsp;

Simple and usimple locks that could potentially be shared between interrupt context and thread context must have their use coordinated with <strong>spl</strong><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_940"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_941"></a> (see glossary). The IPL<a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_942"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_943"></a> (interrupt priority level) must always be the same when acquiring the lock, otherwise deadlock may result. (This is not an issue for kernel extensions, however, as the spl functions cannot be used there.)</p><p></p></div>
<p>The<a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_944"></a> spinlock functions accessible to kernel extensions consist of the following:</p>
<div class="codesample"><table><tr><td scope="row"><pre> extern lck_spin_t     *lck_spin_alloc_init(<span></span></pre></td></tr><tr><td scope="row"><pre>          lck_grp_t     *grp,<span></span></pre></td></tr><tr><td scope="row"><pre>          lck_attr_t     *attr);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> extern void lck_spin_init(<span></span></pre></td></tr><tr><td scope="row"><pre>          lck_spin_t     *lck,<span></span></pre></td></tr><tr><td scope="row"><pre>          lck_grp_t     *grp,<span></span></pre></td></tr><tr><td scope="row"><pre>          lck_attr_t     *attr);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> extern void lck_spin_lock(<span></span></pre></td></tr><tr><td scope="row"><pre>          lck_spin_t     *lck);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> extern void lck_spin_unlock(<span></span></pre></td></tr><tr><td scope="row"><pre>          lck_spin_t     *lck);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> extern void lck_spin_destroy(<span></span></pre></td></tr><tr><td scope="row"><pre>          lck_spin_t     *lck,<span></span></pre></td></tr><tr><td scope="row"><pre>          lck_grp_t     *grp);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> extern void lck_spin_free(<span></span></pre></td></tr><tr><td scope="row"><pre>          lck_spin_t     *lck,<span></span></pre></td></tr><tr><td scope="row"><pre>          lck_grp_t     *grp);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> extern wait_result_t lck_spin_sleep(<span></span></pre></td></tr><tr><td scope="row"><pre>          lck_spin_t     *lck,<span></span></pre></td></tr><tr><td scope="row"><pre>          lck_sleep_action_t     lck_sleep_action,<span></span></pre></td></tr><tr><td scope="row"><pre>          event_t     event,<span></span></pre></td></tr><tr><td scope="row"><pre>          wait_interrupt_t     interruptible);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> extern wait_result_t lck_spin_sleep_deadline(<span></span></pre></td></tr><tr><td scope="row"><pre>          lck_spin_t     *lck,<span></span></pre></td></tr><tr><td scope="row"><pre>          lck_sleep_action_t     lck_sleep_action,<span></span></pre></td></tr><tr><td scope="row"><pre>          event_t     event,<span></span></pre></td></tr><tr><td scope="row"><pre>          wait_interrupt_t     interruptible,<span></span></pre></td></tr><tr><td scope="row"><pre>          uint64_t     deadline);<span></span></pre></td></tr></table></div>
<p><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_945"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_946"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_947"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_948"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_949"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_950"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_951"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_952"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_953"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_954"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_955"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_956"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_957"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_958"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_959"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_960"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_961"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_962"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_963"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_964"></a>Prototypes for these locks can be found in <code>&lt;kern/locks.h></code>.</p>
<p>The arguments to these functions are described in detail in <span class="content_text"><a href="synchronization.html#//apple_ref/doc/uid/TP30000905-CH218-BABCHEIA">“Using Lock Functions.”</a></span></p>
<a name="//apple_ref/doc/uid/TP30000905-CH218-TPXREF112" title="Mutexes"></a><h3>Mutexes</h3><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_965"></a>
<p>A mutex, mutex lock, or sleep lock, is similar to a spinlock, except that instead of constantly polling, it places itself on a queue of threads waiting for the lock, then yields the remainder of its time quantum<a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_966"></a>. It does not execute again until the thread holding the lock wakes it (or in some user space variations, until an asynchronous signal arrives).</p>
<p>Mutexes are more efficient than spinlocks for most purposes. However, they are less efficient in multiprocessing environments where the expected lock-holding time is relatively short. If the average time is relatively short but occasionally long, spin/sleep locks may be a better choice. Although Mac OS X does not support spin/sleep locks in the kernel, they can be easily implemented on top of existing locking primitives. If your code performance improves as a result of using such locks, however, you should probably look for ways to restructure your code, such as using more than one lock or moving to read-write locks, depending on the nature of the code in question. See <span class="content_text"><a href="synchronization.html#//apple_ref/doc/uid/TP30000905-CH218-CJHDBCAD">“Spin/Sleep Locks”</a></span> for more information.</p>
<p>Because mutexes are based on blocking, they can only be used in places where blocking<a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_967"></a> is allowed. For this reason, mutexes cannot be used in the context of interrupt handlers. Interrupt handlers<a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_968"></a> are not allowed to block because interrupts are disabled for the duration of an interrupt handler, and thus, if an interrupt handler blocked, it would prevent the scheduler from receiving timer interrupts, which would prevent any other thread from executing, resulting in deadlock.</p>
<p>For a similar reason, it is not reasonable to block within the scheduler. Also, blocking within the VM system can easily lead to deadlock<a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_969"></a> if the lock you are waiting for is held by a task that is paged out.</p>
<p>However, unlike simple locks, it is permissible to block while holding a mutex. This would occur, for example, if you took one lock, then tried to take another, but the second lock was being held by another thread. However, this is generally not recommended unless you carefully scrutinize all uses of that mutex for possible circular waits<a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_970"></a>, as it can result in deadlock. You can avoid this by always taking locks in a certain order.</p>
<p>In general, blocking while holding a mutex specific to your code is fine as long as you wrote your code correctly, but blocking while holding a more global mutex is probably not, since you may not be able to guarantee that other developers’ code obeys the same ordering rules.</p>
<p>A Mach mutex is of type <code>mutex_t</code><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_971"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_972"></a>. The functions<a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_973"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_974"></a> that operate on mutexes include:<a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_975"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_976"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_977"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_978"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_979"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_980"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_981"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_982"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_983"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_984"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_985"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_986"></a></p>
<div class="codesample"><table><tr><td scope="row"><pre>lck_mtx_t           *lck_mtx_alloc_init(lck_grp_t       *grp,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        lck_attr_t      *attr);<span></span></pre></td></tr><tr><td scope="row"><pre>extern void         lck_mtx_init(       lck_mtx_t       *lck,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        lck_grp_t       *grp,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        lck_attr_t      *attr);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>extern void         lck_mtx_lock(   lck_mtx_t           *lck);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>extern void         lck_mtx_unlock( lck_mtx_t           *lck);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>extern void         lck_mtx_destroy(lck_mtx_t           *lck,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    lck_grp_t           *grp);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>extern void         lck_mtx_free(   lck_mtx_t           *lck,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    lck_grp_t           *grp);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>extern wait_result_tlck_mtx_sleep(  lck_mtx_t           *lck,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    lck_sleep_action_t  lck_sleep_action,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    event_t             event,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    wait_interrupt_t    interruptible);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>extern wait_result_tlck_mtx_sleep_deadline(<span></span></pre></td></tr><tr><td scope="row"><pre>                                    lck_mtx_t           *lck,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    lck_sleep_action_t  lck_sleep_action,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    event_t             event,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    wait_interrupt_t    interruptible,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    uint64_t            deadline);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>extern void         lck_mtx_assert( lck_mtx_t           *lck,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    unsigned int        type);<span></span></pre></td></tr></table></div>
<p>as described in <code>&lt;kern/locks.h></code>.</p>
<p>The arguments to these functions are described in detail in <span class="content_text"><a href="synchronization.html#//apple_ref/doc/uid/TP30000905-CH218-BABCHEIA">“Using Lock Functions.”</a></span></p>
<a name="//apple_ref/doc/uid/TP30000905-CH218-CJHFIAEH" title="Read-Write Locks"></a><h3>Read-Write Locks</h3>
<p>Read-write lock<a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_987"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_988"></a>s (also called shared-exclusive locks) are somewhat different from traditional locks in that they are not always exclusive locks. A read-write lock is useful when shared data can be reasonably read concurrently by multiple threads except while a thread is modifying the data. Read-write locks can dramatically improve performance if the majority of operations on the shared data are in the form of reads (since it allows concurrency), while having negligible impact in the case of multiple writes.</p>
<p>A read-write lock allows this sharing by enforcing the following constraints:</p>
<ul class="spaceabove"><li class="li"><p>Multiple readers can hold the lock at any time.</p></li>
<li class="li"><p>Only one writer can hold the lock at any given time.</p></li>
<li class="li"><p>A writer must block until all readers have released the lock before obtaining the lock for writing.</p></li>
<li class="li"><p>Readers arriving while a writer is waiting to acquire the lock will block until after the writer has obtained and released the lock.</p></li></ul>
<p>The first constraint allows read sharing<a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_989"></a>. The second constraint prevents write sharing<a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_990"></a>. The third prevents read-write sharing<a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_991"></a>, and the fourth prevents starvation<a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_992"></a> of the writer by a steady stream of incoming readers.</p>
<p>Mach read-write locks also provide the ability for a reader to become a writer and vice-versa. In locking terminology, an upgrade<a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_993"></a> is when a reader becomes a writer, and a downgrade<a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_994"></a> is when a writer becomes a reader. To prevent deadlock, some additional constraints must be added for upgrades and downgrades:</p>
<ul class="spaceabove"><li class="li"><p>Upgrades are favored over writers.</p></li>
<li class="li"><p>The second and subsequent concurrent upgrades will fail, causing that thread’s read lock to be released.</p></li></ul>
<p>The first constraint is necessary because the reader requesting an upgrade is holding a read lock, and the writer would not be able to obtain a write lock until the reader releases its read lock. In this case, the reader and writer would wait for each other forever. The second constraint is necessary to prevents the deadlock<a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_995"></a> that would occur if two readers wait for the other to release its read lock so that an upgrade can occur.</p>
<p>The functions that operate on read-write locks are:</p>
<div class="codesample"><table><tr><td scope="row"><pre>extern lck_rw_t *lck_rw_alloc_init(<span></span></pre></td></tr><tr><td scope="row"><pre>            lck_grp_t               *grp,<span></span></pre></td></tr><tr><td scope="row"><pre>            lck_attr_t              *attr);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>extern void lck_rw_init(<span></span></pre></td></tr><tr><td scope="row"><pre>            lck_rw_t                *lck,<span></span></pre></td></tr><tr><td scope="row"><pre>            lck_grp_t               *grp,<span></span></pre></td></tr><tr><td scope="row"><pre>            lck_attr_t              *attr);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>extern void lck_rw_lock(<span></span></pre></td></tr><tr><td scope="row"><pre>            lck_rw_t                *lck,<span></span></pre></td></tr><tr><td scope="row"><pre>            lck_rw_type_t   lck_rw_type);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>extern void lck_rw_unlock(<span></span></pre></td></tr><tr><td scope="row"><pre>            lck_rw_t                *lck,<span></span></pre></td></tr><tr><td scope="row"><pre>            lck_rw_type_t   lck_rw_type);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>extern void lck_rw_lock_shared(<span></span></pre></td></tr><tr><td scope="row"><pre>            lck_rw_t                *lck);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>extern void lck_rw_unlock_shared(<span></span></pre></td></tr><tr><td scope="row"><pre>            lck_rw_t                *lck);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>extern void lck_rw_lock_exclusive(<span></span></pre></td></tr><tr><td scope="row"><pre>            lck_rw_t                *lck);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>extern void lck_rw_unlock_exclusive(<span></span></pre></td></tr><tr><td scope="row"><pre>            lck_rw_t                *lck);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>extern void lck_rw_destroy(<span></span></pre></td></tr><tr><td scope="row"><pre>            lck_rw_t                *lck,<span></span></pre></td></tr><tr><td scope="row"><pre>            lck_grp_t               *grp);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>extern void lck_rw_free(<span></span></pre></td></tr><tr><td scope="row"><pre>            lck_rw_t                *lck,<span></span></pre></td></tr><tr><td scope="row"><pre>            lck_grp_t               *grp);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>extern wait_result_t lck_rw_sleep(<span></span></pre></td></tr><tr><td scope="row"><pre>            lck_rw_t                        *lck,<span></span></pre></td></tr><tr><td scope="row"><pre>            lck_sleep_action_t      lck_sleep_action,<span></span></pre></td></tr><tr><td scope="row"><pre>            event_t                         event,<span></span></pre></td></tr><tr><td scope="row"><pre>            wait_interrupt_t        interruptible);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>extern wait_result_t lck_rw_sleep_deadline(<span></span></pre></td></tr><tr><td scope="row"><pre>            lck_rw_t                        *lck,<span></span></pre></td></tr><tr><td scope="row"><pre>            lck_sleep_action_t      lck_sleep_action,<span></span></pre></td></tr><tr><td scope="row"><pre>            event_t                         event,<span></span></pre></td></tr><tr><td scope="row"><pre>            wait_interrupt_t        interruptible,<span></span></pre></td></tr><tr><td scope="row"><pre>            uint64_t                        deadline);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr></table></div>
<p><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_996"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_997"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_998"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_999"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_1000"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_1001"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_1002"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_1003"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_1004"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_1005"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_1006"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_1007"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_1008"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_1009"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_1010"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_1011"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_1012"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_1013"></a>This<a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_1014"></a> is a more complex interface than that of the other locking mechanisms, and actually is the interface upon which the other locks are built<a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_1015"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_1016"></a>.</p>
<p>The functions <code><!--a-->lck_rw_lock<!--/a--></code> and <code><!--a-->lck_rw_lock<!--/a--></code> lock and unlock a lock as either shared (read) or exclusive (write), depending on the value of <code>lck_rw_type</code>., which can contain either <code><!--a  -->LCK_RW_TYPE_SHARED<!--/a--></code> or <code><!--a  -->LCK_RW_TYPE_EXCLUSIVE<!--/a--></code>.<a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_1017"></a> You should always be careful when using these functions, as unlocking a lock held in shared mode using an exclusive call or vice-versa will lead to undefined results.</p>
<p>The arguments to these functions are described in detail in <span class="content_text"><a href="synchronization.html#//apple_ref/doc/uid/TP30000905-CH218-BABCHEIA">“Using Lock Functions.”</a></span></p>
<a name="//apple_ref/doc/uid/TP30000905-CH218-CJHDBCAD" title="Spin/Sleep Locks"></a><h3>Spin/Sleep Locks</h3>
<p>Spin/sleep locks<a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_1018"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_1019"></a> are not implemented in the Mac OS X kernel. However, they can be easily implemented on top of existing locks if desired.</p>
<p>For short waits on multiprocessor systems, the amount of time spent in the context switch can be greater than the amount of time spent spinning. When the time spent spinning while waiting for the lock becomes greater than the context switch overhead, however, mutexes become more efficient. For this reason, if there is a large degree of variation in wait time on a highly contended lock, spin/sleep locks may be more efficient than traditional spinlocks or mutexes.</p>
<p>Ideally, a program should be written in such a way that the time spent holding a lock is always about the same, and the choice of locking is clear. However, in some cases, this is not practical for a highly contended lock. In those cases, you may consider using spin/sleep locks.</p>
<p>The basic principle of spin/sleep locks is simple. A thread takes the lock if it is available. If the lock is not available, the thread may enter a spin cycle. After a certain period of time (usually a fraction of a time quantum or a small number of time quanta), the spin routine’s time-out is reached, and it returns failure. At that point, the lock places the waiting thread on a queue and puts it to sleep.</p>
<p>In other variations on this design, spin/sleep locks determine whether to spin or sleep according to whether the lock-holding thread is currently on another processor (or is about to be).</p>
<p>For short wait periods on multiprocessor computers, the spin/sleep lock is more efficient than a mutex, and roughly as efficient as a standard spinlock. For longer wait periods, the spin/sleep lock is significantly more efficient than the spinlock and only slightly less efficient than a mutex. There is a period near the transition between spinning and sleeping in which the spin/sleep lock may behave significantly worse than either of the basic lock types, however. Thus, spin/sleep locks should not be used unless a lock is heavily contended and has widely varying hold times. When possible, you should rewrite the code to avoid such designs.</p>
<a name="//apple_ref/doc/uid/TP30000905-CH218-BABCHEIA" title="Using Lock Functions"></a><h3>Using Lock Functions</h3>
<p>While most of the locking functions are straightforward, there are a few details related to allocating, deallocating, and sleeping on locks that require additional explanation. As the syntax of these functions is identical across all of the lock types, this section explains only the usage for spinlocks. Extending this to other lock types is left as a (trivial) exercise for the reader.</p>
<p>The first thing you must do when allocating locks is to allocate a lock group and a lock attribute set. Lock groups are used to name locks for debugging purposes and to group locks by function for general understandability. Lock attribute sets allow you to set flags that alter the behavior of a lock.</p>
<p>The following code illustrates how to allocate an attribute structure and a lock group structure for a lock. In this case, a spinlock is used, but with the exception of the lock allocation itself, the process is the same for other lock types.</p>
<a name="//apple_ref/doc/uid/TP30000905-CH218-SW2" title="Listing 16-1Allocating lock attributes and groups (lifted liberally from kern_time.c)"></a><p class="codesample"><strong>Listing 16-1&nbsp;&nbsp;</strong>Allocating lock attributes and groups (lifted liberally from kern_time.c)</p>
<div class="codesample"><table><tr><td scope="row"><pre>lck_grp_attr_t *tz_slock_grp_attr;<span></span></pre></td></tr><tr><td scope="row"><pre>lck_grp_t *tz_slock_grp;<span></span></pre></td></tr><tr><td scope="row"><pre>lck_attr_t *tz_slock_attr;<span></span></pre></td></tr><tr><td scope="row"><pre>lck_spin_t *tz_slock;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* allocate lock group attribute and group */<span></span></pre></td></tr><tr><td scope="row"><pre>tz_slock_grp_attr = lck_grp_attr_alloc_init();<span></span></pre></td></tr><tr><td scope="row"><pre>lck_grp_attr_setstat(tz_slock_grp_attr);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>tz_slock_grp =  lck_grp_alloc_init("tzlock", tz_slock_grp_attr);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Allocate lock attribute */<span></span></pre></td></tr><tr><td scope="row"><pre>tz_slock_attr = lck_attr_alloc_init();<span></span></pre></td></tr><tr><td scope="row"><pre>//lck_attr_setdebug(tz_slock_attr); // set the debug flag<span></span></pre></td></tr><tr><td scope="row"><pre>//lck_attr_setdefault(tz_slock_attr); // clear the debug flag<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Allocate the spin lock */<span></span></pre></td></tr><tr><td scope="row"><pre>tz_slock = lck_spin_alloc_init(tz_slock_grp, tz_slock_attr);<span></span></pre></td></tr></table></div>
<p>The first argument to the lock initializer, of type <code>lck_grp_t</code><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_1020"></a><a name="//apple_ref/doc/uid/TP30000905-CH218-DontLinkElementID_1021"></a>, is a lock group. This is used for debugging purposes, including lock contention profiling. The details of lock tracing are beyond the scope of this document, however, every lock must belong to a group (even if that group contains only one lock).</p>
<p>The second argument to the lock initializer, of type <code>lck_attr_t</code>, contains attributes for the lock. Currently, the only attribute available is lock debugging. This attribute can be set using <code><!--a-->lck_attr_setdebug<!--/a--></code> and cleared with <code><!--a-->lck_attr_setdefault<!--/a--></code>.</p><p>To dispose of a lock, you simply call the matching free functions. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>lck_spin_free(tz_slock, tz_slock_grp);<span></span></pre></td></tr><tr><td scope="row"><pre>lck_attr_free(tz_slock_attr);<span></span></pre></td></tr><tr><td scope="row"><pre>lck_grp_free(tz_slock_grp);<span></span></pre></td></tr><tr><td scope="row"><pre>lck_grp_attr_free(tz_slock_grp_attr);<span></span></pre></td></tr></table></div>
<div class="notebox"><a name="//apple_ref/doc/uid/TP30000905-CH218-SW3" title="Note"></a><p><strong>Note:</strong>&nbsp;While you can safely dispose of the lock attribute and lock group attribute structures, it is important to keep track of the lock group associated with a lock as long as the lock exists, since you will need to pass the group to the lock's matching free function when you deallocate the lock (generally at unload time).</p></div>
<p>The other two interesting functions are <code><!--a-->lck_spin_sleep<!--/a--></code> and <code><!--a-->lck_spin_sleep_deadline<!--/a--></code>. These functions release a spinlock and sleep until an event occurs, then wake. The latter includes a timeout, at which point it will wake even if the event has not occurred.</p>
<div class="codesample"><table><tr><td scope="row"><pre>extern wait_result_t lck_spin_sleep(<span></span></pre></td></tr><tr><td scope="row"><pre>                lck_rspin_t         *lck,<span></span></pre></td></tr><tr><td scope="row"><pre>                lck_sleep_action_t  lck_sleep_action,<span></span></pre></td></tr><tr><td scope="row"><pre>                event_t             event,<span></span></pre></td></tr><tr><td scope="row"><pre>                wait_interrupt_t    interruptible);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>extern wait_result_t lck_spin_sleep_deadline(<span></span></pre></td></tr><tr><td scope="row"><pre>                lck_spin_t          *lck,<span></span></pre></td></tr><tr><td scope="row"><pre>                lck_sleep_action_t  lck_sleep_action,<span></span></pre></td></tr><tr><td scope="row"><pre>                event_t             event,<span></span></pre></td></tr><tr><td scope="row"><pre>                wait_interrupt_t    interruptible,<span></span></pre></td></tr><tr><td scope="row"><pre>                uint64_t            deadline);<span></span></pre></td></tr></table></div>
<p>The parameter <code>lck_sleep_action</code> controls whether the lock will be reclaimed after sleeping prior to this function returning. The valid options are:</p>
<dl class="termdef">	<dt><code><!--a  -->LCK_SLEEP_DEFAULT<!--/a--></code></dt>
<dd><p>Release the lock while waiting for the event, then reclaim it. Read-write locks are held in the same mode as they were originally held.</p></dd>
<dt><code><!--a  -->LCK_SLEEP_UNLOCK<!--/a--></code></dt>
<dd><p>Release the lock and return with the lock unheld.</p></dd>
<dt><code><!--a  -->LCK_SLEEP_SHARED<!--/a--></code></dt>
<dd><p>Reclaim the lock in shared mode (read-write locks only).</p></dd>
<dt><code><!--a  -->LCK_SLEEP_EXCLUSIVE<!--/a--></code></dt>
<dd><p>Reclaim the lock in exclusive mode (read-write locks only).</p></dd></dl>
<p>The <code>event</code> parameter can be any arbitrary integer, but it must be unique across the system. To ensure uniqueness, a common programming practice is to use the address of a global variable (often the one containing a lock) as the event value. For more information on these events, see <span class="content_text"><a href="../services/services.html#//apple_ref/doc/uid/TP30000905-CH219-TPXREF109">“Event and Timer Waits.”</a></span></p>
<p>The parameter <code>interruptible</code> indicates whether the scheduler should allow the wait to be interrupted by asynchronous signals. If this is false, any false wakes will result in the process going immediately back to sleep (with the exception of a timer expiration signal, which will still wake <code><!--a-->lck_spin_sleep_deadline<!--/a--></code>).</p>
<p></p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../boundaries/boundaries.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../services/services.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2002, 2006 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2006-11-07<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Conceptual/KernelProgramming/synchronization/synchronization.html%3Fid%3DTP30000905-5.7&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Conceptual/KernelProgramming/synchronization/synchronization.html%3Fid%3DTP30000905-5.7&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Conceptual/KernelProgramming/synchronization/synchronization.html%3Fid%3DTP30000905-5.7&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>