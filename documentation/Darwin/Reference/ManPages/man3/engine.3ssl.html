<html><head><title>Mac OS X
 Manual Page For engine(3ssl)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3ssl/engine" title="Mac OS X
 Manual Page for engine(3ssl)"><a name="//apple_ref/doc/man/3/engine" title="Mac OS X
 Manual Page for engine(3ssl)"><!-- headerDoc=man; indexgroup=Section 3ssl; uid="//apple_ref/doc/man/3ssl/engine"; name=engine(3ssl) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
engine(3)                                          OpenSSL                                         engine(3)



<b>NAME</b>
       engine - ENGINE cryptographic module support

<b>SYNOPSIS</b>
        #include &lt;openssl/engine.h&gt;

        ENGINE *ENGINE_get_first(void);
        ENGINE *ENGINE_get_last(void);
        ENGINE *ENGINE_get_next(ENGINE *e);
        ENGINE *ENGINE_get_prev(ENGINE *e);

        int ENGINE_add(ENGINE *e);
        int ENGINE_remove(ENGINE *e);

        ENGINE *ENGINE_by_id(const char *id);

        int ENGINE_init(ENGINE *e);
        int ENGINE_finish(ENGINE *e);

        void ENGINE_load_openssl(void);
        void ENGINE_load_dynamic(void);
        void ENGINE_load_cswift(void);
        void ENGINE_load_chil(void);
        void ENGINE_load_atalla(void);
        void ENGINE_load_nuron(void);
        void ENGINE_load_ubsec(void);
        void ENGINE_load_aep(void);
        void ENGINE_load_sureware(void);
        void ENGINE_load_4758cca(void);
        void ENGINE_load_openbsd_dev_crypto(void);
        void ENGINE_load_builtin_engines(void);

        void ENGINE_cleanup(void);

        ENGINE *ENGINE_get_default_RSA(void);
        ENGINE *ENGINE_get_default_DSA(void);
        ENGINE *ENGINE_get_default_DH(void);
        ENGINE *ENGINE_get_default_RAND(void);
        ENGINE *ENGINE_get_cipher_engine(int nid);
        ENGINE *ENGINE_get_digest_engine(int nid);

        int ENGINE_set_default_RSA(ENGINE *e);
        int ENGINE_set_default_DSA(ENGINE *e);
        int ENGINE_set_default_DH(ENGINE *e);
        int ENGINE_set_default_RAND(ENGINE *e);
        int ENGINE_set_default_ciphers(ENGINE *e);
        int ENGINE_set_default_digests(ENGINE *e);
        int ENGINE_set_default_string(ENGINE *e, const char *list);

        int ENGINE_set_default(ENGINE *e, unsigned int flags);

        unsigned int ENGINE_get_table_flags(void);
        void ENGINE_set_table_flags(unsigned int flags);

        int ENGINE_register_RSA(ENGINE *e);
        void ENGINE_unregister_RSA(ENGINE *e);
        void ENGINE_register_all_RSA(void);
        int ENGINE_register_DSA(ENGINE *e);
        void ENGINE_unregister_DSA(ENGINE *e);
        void ENGINE_register_all_DSA(void);
        int ENGINE_register_DH(ENGINE *e);
        void ENGINE_unregister_DH(ENGINE *e);
        void ENGINE_register_all_DH(void);
        int ENGINE_register_RAND(ENGINE *e);
        void ENGINE_unregister_RAND(ENGINE *e);
        void ENGINE_register_all_RAND(void);
        int ENGINE_register_ciphers(ENGINE *e);
        void ENGINE_unregister_ciphers(ENGINE *e);
        void ENGINE_register_all_ciphers(void);
        int ENGINE_register_digests(ENGINE *e);
        void ENGINE_unregister_digests(ENGINE *e);
        void ENGINE_register_all_digests(void);
        int ENGINE_register_complete(ENGINE *e);
        int ENGINE_register_all_complete(void);

        int ENGINE_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)());
        int ENGINE_cmd_is_executable(ENGINE *e, int cmd);
        int ENGINE_ctrl_cmd(ENGINE *e, const char *cmd_name,
                long i, void *p, void (*f)(), int cmd_optional);
        int ENGINE_ctrl_cmd_string(ENGINE *e, const char *cmd_name, const char *arg,
                        int cmd_optional);

        int ENGINE_set_ex_data(ENGINE *e, int idx, void *arg);
        void *ENGINE_get_ex_data(const ENGINE *e, int idx);

        int ENGINE_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
                CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);

        ENGINE *ENGINE_new(void);
        int ENGINE_free(ENGINE *e);

        int ENGINE_set_id(ENGINE *e, const char *id);
        int ENGINE_set_name(ENGINE *e, const char *name);
        int ENGINE_set_RSA(ENGINE *e, const RSA_METHOD *rsa_meth);
        int ENGINE_set_DSA(ENGINE *e, const DSA_METHOD *dsa_meth);
        int ENGINE_set_DH(ENGINE *e, const DH_METHOD *dh_meth);
        int ENGINE_set_RAND(ENGINE *e, const RAND_METHOD *rand_meth);
        int ENGINE_set_destroy_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR destroy_f);
        int ENGINE_set_init_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR init_f);
        int ENGINE_set_finish_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR finish_f);
        int ENGINE_set_ctrl_function(ENGINE *e, ENGINE_CTRL_FUNC_PTR ctrl_f);
        int ENGINE_set_load_privkey_function(ENGINE *e, ENGINE_LOAD_KEY_PTR loadpriv_f);
        int ENGINE_set_load_pubkey_function(ENGINE *e, ENGINE_LOAD_KEY_PTR loadpub_f);
        int ENGINE_set_ciphers(ENGINE *e, ENGINE_CIPHERS_PTR f);
        int ENGINE_set_digests(ENGINE *e, ENGINE_DIGESTS_PTR f);
        int ENGINE_set_flags(ENGINE *e, int flags);
        int ENGINE_set_cmd_defns(ENGINE *e, const ENGINE_CMD_DEFN *defns);

        const char *ENGINE_get_id(const ENGINE *e);
        const char *ENGINE_get_name(const ENGINE *e);
        const RSA_METHOD *ENGINE_get_RSA(const ENGINE *e);
        const DSA_METHOD *ENGINE_get_DSA(const ENGINE *e);
        const DH_METHOD *ENGINE_get_DH(const ENGINE *e);
        const RAND_METHOD *ENGINE_get_RAND(const ENGINE *e);
        ENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e);
        ENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e);
        ENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e);
        ENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e);
        ENGINE_LOAD_KEY_PTR ENGINE_get_load_privkey_function(const ENGINE *e);
        ENGINE_LOAD_KEY_PTR ENGINE_get_load_pubkey_function(const ENGINE *e);
        ENGINE_CIPHERS_PTR ENGINE_get_ciphers(const ENGINE *e);
        ENGINE_DIGESTS_PTR ENGINE_get_digests(const ENGINE *e);
        const EVP_CIPHER *ENGINE_get_cipher(ENGINE *e, int nid);
        const EVP_MD *ENGINE_get_digest(ENGINE *e, int nid);
        int ENGINE_get_flags(const ENGINE *e);
        const ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e);

        EVP_PKEY *ENGINE_load_private_key(ENGINE *e, const char *key_id,
            UI_METHOD *ui_method, void *callback_data);
        EVP_PKEY *ENGINE_load_public_key(ENGINE *e, const char *key_id,
            UI_METHOD *ui_method, void *callback_data);

        void ENGINE_add_conf_module(void);

<b>DESCRIPTION</b>
       These functions create, manipulate, and use cryptographic modules in the form of <b>ENGINE</b> objects.
       These objects act as containers for implementations of cryptographic algorithms, and support a
       reference-counted mechanism to allow them to be dynamically loaded in and out of the running
       application.

       The cryptographic functionality that can be provided by an <b>ENGINE</b> implementation includes the
       following abstractions;

        RSA_METHOD - for providing alternative RSA implementations
        DSA_METHOD, DH_METHOD, RAND_METHOD - alternative DSA, DH, and RAND
        EVP_CIPHER - potentially multiple cipher algorithms (indexed by 'nid')
        EVP_DIGEST - potentially multiple hash algorithms (indexed by 'nid')
        key-loading - loading public and/or private EVP_PKEY keys

       <b>Reference</b> <b>counting</b> <b>and</b> <b>handles</b>

       Due to the modular nature of the ENGINE API, pointers to ENGINEs need to be treated as handles - ie.
       not only as pointers, but also as references to the underlying ENGINE object. Ie. you should obtain a
       new reference when making copies of an ENGINE pointer if the copies will be used (and released)
       independantly.

       ENGINE objects have two levels of reference-counting to match the way in which the objects are used.
       At the most basic level, each ENGINE pointer is inherently a <b>structural</b> reference - you need a
       structural reference simply to refer to the pointer value at all, as this kind of reference is your
       guarantee that the structure can not be deallocated until you release your reference.

       However, a structural reference provides no guarantee that the ENGINE has been initiliased to be
       usable to perform any of its cryptographic implementations - and indeed it's quite possible that most
       ENGINEs will not initialised at all on standard setups, as ENGINEs are typically used to support
       specialised hardware. To use an ENGINE's functionality, you need a <b>functional</b> reference. This kind of
       reference can be considered a specialised form of structural reference, because each functional
       reference implicitly contains a structural reference as well - however to avoid difficult-to-find
       programming bugs, it is recommended to treat the two kinds of reference independantly. If you have a
       functional reference to an ENGINE, you have a guarantee that the ENGINE has been initialised ready to
       perform cryptographic operations and will not be uninitialised or cleaned up until after you have
       released your reference.

       We will discuss the two kinds of reference separately, including how to tell which one you are
       dealing with at any given point in time (after all they are both simply (ENGINE *) pointers, the
       difference is in the way they are used).

       <u>Structural</u> <u>references</u>

       This basic type of reference is typically used for creating new ENGINEs dynamically, iterating across
       OpenSSL's internal linked-list of loaded ENGINEs, reading information about an ENGINE, etc.
       Essentially a structural reference is sufficient if you only need to query or manipulate the data of
       an ENGINE implementation rather than use its functionality.

       The <u>ENGINE</u><b>_</b><u>new()</u> function returns a structural reference to a new (empty) ENGINE object. Other than
       that, structural references come from return values to various ENGINE API functions such as;
       <u>ENGINE</u><b>_</b><u>by</u><b>_</b><u>id()</u>, <u>ENGINE</u><b>_</b><u>get</u><b>_</b><u>first()</u>, <u>ENGINE</u><b>_</b><u>get</u><b>_</b><u>last()</u>, <u>ENGINE</u><b>_</b><u>get</u><b>_</b><u>next()</u>, <u>ENGINE</u><b>_</b><u>get</u><b>_</b><u>prev()</u>. All
       structural references should be released by a corresponding to call to the <u>ENGINE</u><b>_</b><u>free()</u> function -<font color="#ffffff" class="whiteout">the&nbsp;functionthe</font>
       the ENGINE object itself will only actually be cleaned up and deallocated when the last structural
       reference is released.

       It should also be noted that many ENGINE API function calls that accept a structural reference will
       internally obtain another reference - typically this happens whenever the supplied ENGINE will be
       needed by OpenSSL after the function has returned. Eg. the function to add a new ENGINE to OpenSSL's
       internal list is <u>ENGINE</u><b>_</b><u>add()</u> - if this function returns success, then OpenSSL will have stored a new
       structural reference internally so the caller is still responsible for freeing their own reference
       with <u>ENGINE</u><b>_</b><u>free()</u> when they are finished with it. In a similar way, some functions will
       automatically release the structural reference passed to it if part of the function's job is to do
       so. Eg. the <u>ENGINE</u><b>_</b><u>get</u><b>_</b><u>next()</u> and <u>ENGINE</u><b>_</b><u>get</u><b>_</b><u>prev()</u> functions are used for iterating across the
       internal ENGINE list - they will return a new structural reference to the next (or previous) ENGINE
       in the list or NULL if at the end (or beginning) of the list, but in either case the structural
       reference passed to the function is released on behalf of the caller.

       To clarify a particular function's handling of references, one should always consult that function's
       documentation "man" page, or failing that the openssl/engine.h header file includes some hints.

       <u>Functional</u> <u>references</u>

       As mentioned, functional references exist when the cryptographic functionality of an ENGINE is
       required to be available. A functional reference can be obtained in one of two ways; from an existing
       structural reference to the required ENGINE, or by asking OpenSSL for the default operational ENGINE
       for a given cryptographic purpose.

       To obtain a functional reference from an existing structural reference, call the <u>ENGINE</u><b>_</b><u>init()</u>
       function. This returns zero if the ENGINE was not already operational and couldn't be successfully
       initialised (eg. lack of system drivers, no special hardware attached, etc), otherwise it will return
       non-zero to indicate that the ENGINE is now operational and will have allocated a new <b>functional</b>
       reference to the ENGINE. In this case, the supplied ENGINE pointer is, from the point of the view of
       the caller, both a structural reference and a functional reference - so if the caller intends to use
       it as a functional reference it should free the structural reference with <u>ENGINE</u><b>_</b><u>free()</u> first. If the
       caller wishes to use it only as a structural reference (eg. if the <u>ENGINE</u><b>_</b><u>init()</u> call was simply to
       test if the ENGINE seems available/online), then it should free the functional reference; all
       functional references are released by the <u>ENGINE</u><b>_</b><u>finish()</u> function.

       The second way to get a functional reference is by asking OpenSSL for a default implementation for a
       given task, eg. by <u>ENGINE</u><b>_</b><u>get</u><b>_</b><u>default</u><b>_</b><u>RSA()</u>, <u>ENGINE</u><b>_</b><u>get</u><b>_</b><u>default</u><b>_</b><u>cipher</u><b>_</b><u>engine()</u>, etc. These are
       discussed in the next section, though they are not usually required by application programmers as
       they are used automatically when creating and using the relevant algorithm-specific types in OpenSSL,
       such as RSA, DSA, EVP_CIPHER_CTX, etc.

       <b>Default</b> <b>implementations</b>

       For each supported abstraction, the ENGINE code maintains an internal table of state to control which
       implementations are available for a given abstraction and which should be used by default. These
       implementations are registered in the tables separated-out by an 'nid' index, because abstractions
       like EVP_CIPHER and EVP_DIGEST support many distinct algorithms and modes - ENGINEs will support
       different numbers and combinations of these. In the case of other abstractions like RSA, DSA, etc,
       there is only one "algorithm" so all implementations implicitly register using the same 'nid' index.
       ENGINEs can be <b>registered</b> into these tables to make themselves available for use automatically by the
       various abstractions, eg. RSA. For illustrative purposes, we continue with the RSA example, though
       all comments apply similarly to the other abstractions (they each get their own table and linkage to
       the corresponding section of openssl code).

       When a new RSA key is being created, ie. in <u>RSA</u><b>_</b><u>new</u><b>_</b><u>method()</u>, a "get_default" call will be made to
       the ENGINE subsystem to process the RSA state table and return a functional reference to an
       initialised ENGINE whose RSA_METHOD should be used. If no ENGINE should (or can) be used, it will
       return NULL and the RSA key will operate with a NULL ENGINE handle by using the conventional RSA
       implementation in OpenSSL (and will from then on behave the way it used to before the ENGINE API
       existed - for details see <a href="RSA_new_method.3ssl.html#//apple_ref/doc/man/3/RSA_new_method"><u>RSA</u><b>_</b><u>new</u><b>_</b><u>method</u>(3)</a>).

       Each state table has a flag to note whether it has processed this "get_default" query since the table
       was last modified, because to process this question it must iterate across all the registered ENGINEs
       in the table trying to initialise each of them in turn, in case one of them is operational. If it
       returns a functional reference to an ENGINE, it will also cache another reference to speed up
       processing future queries (without needing to iterate across the table). Likewise, it will cache a
       NULL response if no ENGINE was available so that future queries won't repeat the same iteration
       unless the state table changes. This behaviour can also be changed; if the ENGINE_TABLE_FLAG_NOINIT
       flag is set (using <u>ENGINE</u><b>_</b><u>set</u><b>_</b><u>table</u><b>_</b><u>flags()</u>), no attempted initialisations will take place, instead
       the only way for the state table to return a non-NULL ENGINE to the "get_default" query will be if
       one is expressly set in the table. Eg.  <u>ENGINE</u><b>_</b><u>set</u><b>_</b><u>default</u><b>_</b><u>RSA()</u> does the same job as
       <u>ENGINE</u><b>_</b><u>register</u><b>_</b><u>RSA()</u> except that it also sets the state table's cached response for the
       "get_default" query.

       In the case of abstractions like EVP_CIPHER, where implementations are indexed by 'nid', these flags
       and cached-responses are distinct for each 'nid' value.

       It is worth illustrating the difference between "registration" of ENGINEs into these per-algorithm
       state tables and using the alternative "set_default" functions. The latter handles both
       "registration" and also setting the cached "default" ENGINE in each relevant state table - so
       registered ENGINEs will only have a chance to be initialised for use as a default if a default ENGINE
       wasn't already set for the same state table.  Eg. if ENGINE X supports cipher nids {A,B} and RSA,
       ENGINE Y supports ciphers {A} and DSA, and the following code is executed;

        <!-- a -->ENGINE_register_complete(X)<!-- /a -->;
        ENGINE_set_default(Y, ENGINE_METHOD_ALL);
        e1 = ENGINE_get_default_RSA();
        e2 = <!-- a -->ENGINE_get_cipher_engine(A)<!-- /a -->;
        e3 = <!-- a -->ENGINE_get_cipher_engine(B)<!-- /a -->;
        e4 = ENGINE_get_default_DSA();
        e5 = <!-- a -->ENGINE_get_cipher_engine(C)<!-- /a -->;

       The results would be as follows;

        assert(e1 == X);
        assert(e2 == Y);
        assert(e3 == X);
        assert(e4 == Y);
        assert(e5 == NULL);

       <b>Application</b> <b>requirements</b>

       This section will explain the basic things an application programmer should support to make the most
       useful elements of the ENGINE functionality available to the user. The first thing to consider is
       whether the programmer wishes to make alternative ENGINE modules available to the application and
       user. OpenSSL maintains an internal linked list of "visible" ENGINEs from which it has to operate -<font color="#ffffff" class="whiteout">at&nbsp;operateat</font>
       at start-up, this list is empty and in fact if an application does not call any ENGINE API calls and
       it uses static linking against openssl, then the resulting application binary will not contain any
       alternative ENGINE code at all. So the first consideration is whether any/all available ENGINE
       implementations should be made visible to OpenSSL - this is controlled by calling the various "load"
       functions, eg.

        /* Make the "dynamic" ENGINE available */
        void ENGINE_load_dynamic(void);
        /* Make the CryptoSwift hardware acceleration support available */
        void ENGINE_load_cswift(void);
        /* Make support for nCipher's "CHIL" hardware available */
        void ENGINE_load_chil(void);
        ...
        /* Make ALL ENGINE implementations bundled with OpenSSL available */
        void ENGINE_load_builtin_engines(void);

       Having called any of these functions, ENGINE objects would have been dynamically allocated and
       populated with these implementations and linked into OpenSSL's internal linked list. At this point it
       is important to mention an important API function;

        void ENGINE_cleanup(void);

       If no ENGINE API functions are called at all in an application, then there are no inherent memory
       leaks to worry about from the ENGINE functionality, however if any ENGINEs are "load"ed, even if they
       are never registered or used, it is necessary to use the <u>ENGINE</u><b>_</b><u>cleanup()</u> function to correspondingly
       cleanup before program exit, if the caller wishes to avoid memory leaks. This mechanism uses an
       internal callback registration table so that any ENGINE API functionality that knows it requires
       cleanup can register its cleanup details to be called during <u>ENGINE</u><b>_</b><u>cleanup()</u>. This approach allows
       <u>ENGINE</u><b>_</b><u>cleanup()</u> to clean up after any ENGINE functionality at all that your program uses, yet
       doesn't automatically create linker dependencies to all possible ENGINE functionality - only the
       cleanup callbacks required by the functionality you do use will be required by the linker.

       The fact that ENGINEs are made visible to OpenSSL (and thus are linked into the program and loaded
       into memory at run-time) does not mean they are "registered" or called into use by OpenSSL
       automatically - that behaviour is something for the application to have control over. Some
       applications will want to allow the user to specify exactly which ENGINE they want used if any is to
       be used at all. Others may prefer to load all support and have OpenSSL automatically use at run-time
       any ENGINE that is able to successfully initialise - ie. to assume that this corresponds to
       acceleration hardware attached to the machine or some such thing. There are probably numerous other
       ways in which applications may prefer to handle things, so we will simply illustrate the consequences
       as they apply to a couple of simple cases and leave developers to consider these and the source code
       to openssl's builtin utilities as guides.

       <u>Using</u> <u>a</u> <u>specific</u> <u>ENGINE</u> <u>implementation</u>

       Here we'll assume an application has been configured by its user or admin to want to use the "ACME"
       ENGINE if it is available in the version of OpenSSL the application was compiled with. If it is
       available, it should be used by default for all RSA, DSA, and symmetric cipher operation, otherwise
       OpenSSL should use its builtin software as per usual. The following code illustrates how to approach
       this;

        ENGINE *e;
        const char *engine_id = "ACME";
        ENGINE_load_builtin_engines();
        e = ENGINE_by_id(engine_id);
        if(!e)
            /* the engine isn't available */
            return;
        if(!ENGINE_init(e)) {
            /* the engine couldn't initialise, release 'e' */
            <!-- a -->ENGINE_free(e)<!-- /a -->;
            return;
        }
        if(!ENGINE_set_default_RSA(e))
            /* This should only happen when 'e' can't initialise, but the previous
             * statement suggests it did. */
            abort();
        <!-- a -->ENGINE_set_default_DSA(e)<!-- /a -->;
        <!-- a -->ENGINE_set_default_ciphers(e)<!-- /a -->;
        /* Release the functional reference from ENGINE_init() */
        <!-- a -->ENGINE_finish(e)<!-- /a -->;
        /* Release the structural reference from ENGINE_by_id() */
        <!-- a -->ENGINE_free(e)<!-- /a -->;

       <u>Automatically</u> <u>using</u> <u>builtin</u> <u>ENGINE</u> <u>implementations</u>

       Here we'll assume we want to load and register all ENGINE implementations bundled with OpenSSL, such
       that for any cryptographic algorithm required by OpenSSL - if there is an ENGINE that implements it
       and can be initialise, it should be used. The following code illustrates how this can work;

        /* Load all bundled ENGINEs into memory and make them visible */
        ENGINE_load_builtin_engines();
        /* Register all of them for every algorithm they collectively implement */
        ENGINE_register_all_complete();

       That's all that's required. Eg. the next time OpenSSL tries to set up an RSA key, any bundled ENGINEs
       that implement RSA_METHOD will be passed to <u>ENGINE</u><b>_</b><u>init()</u> and if any of those succeed, that ENGINE
       will be set as the default for use with RSA from then on.

       <b>Advanced</b> <b>configuration</b> <b>support</b>

       There is a mechanism supported by the ENGINE framework that allows each ENGINE implementation to
       define an arbitrary set of configuration "commands" and expose them to OpenSSL and any applications
       based on OpenSSL. This mechanism is entirely based on the use of name-value pairs and and assumes
       ASCII input (no unicode or UTF for now!), so it is ideal if applications want to provide a
       transparent way for users to provide arbitrary configuration "directives" directly to such ENGINEs.
       It is also possible for the application to dynamically interrogate the loaded ENGINE implementations
       for the names, descriptions, and input flags of their available "control commands", providing a more
       flexible configuration scheme. However, if the user is expected to know which ENGINE device he/she is
       using (in the case of specialised hardware, this goes without saying) then applications may not need
       to concern themselves with discovering the supported control commands and simply prefer to allow
       settings to passed into ENGINEs exactly as they are provided by the user.

       Before illustrating how control commands work, it is worth mentioning what they are typically used
       for. Broadly speaking there are two uses for control commands; the first is to provide the necessary
       details to the implementation (which may know nothing at all specific to the host system) so that it
       can be initialised for use. This could include the path to any driver or config files it needs to
       load, required network addresses, smart-card identifiers, passwords to initialise password-protected
       devices, logging information, etc etc. This class of commands typically needs to be passed to an
       ENGINE <b>before</b> attempting to initialise it, ie. before calling <u>ENGINE</u><b>_</b><u>init()</u>. The other class of
       commands consist of settings or operations that tweak certain behaviour or cause certain operations
       to take place, and these commands may work either before or after <u>ENGINE</u><b>_</b><u>init()</u>, or in same cases
       both. ENGINE implementations should provide indications of this in the descriptions attached to
       builtin control commands and/or in external product documentation.

       <u>Issuing</u> <u>control</u> <u>commands</u> <u>to</u> <u>an</u> <u>ENGINE</u>

       Let's illustrate by example; a function for which the caller supplies the name of the ENGINE it
       wishes to use, a table of string-pairs for use before initialisation, and another table for use after
       initialisation. Note that the string-pairs used for control commands consist of a command "name"
       followed by the command "parameter" - the parameter could be NULL in some cases but the name can not.
       This function should initialise the ENGINE (issuing the "pre" commands beforehand and the "post"
       commands afterwards) and set it as the default for everything except RAND and then return a boolean
       success or failure.

        int generic_load_engine_fn(const char *engine_id,
                                   const char **pre_cmds, int pre_num,
                                   const char **post_cmds, int post_num)
        {
            ENGINE *e = ENGINE_by_id(engine_id);
            if(!e) return 0;
            while(pre_num--) {
                if(!ENGINE_ctrl_cmd_string(e, pre_cmds[0], pre_cmds[1], 0)) {
                    fprintf(stderr, "Failed command (%s - %s:%s)\n", engine_id,
                        pre_cmds[0], pre_cmds[1] ? pre_cmds[1] : "(NULL)");
                    <!-- a -->ENGINE_free(e)<!-- /a -->;
                    return 0;
                }
                pre_cmds += 2;
            }
            if(!ENGINE_init(e)) {
                fprintf(stderr, "Failed initialisation\n");
                <!-- a -->ENGINE_free(e)<!-- /a -->;
                return 0;
            }
            /* ENGINE_init() returned a functional reference, so free the structural
             * reference from ENGINE_by_id(). */
            <!-- a -->ENGINE_free(e)<!-- /a -->;
            while(post_num--) {
                if(!ENGINE_ctrl_cmd_string(e, post_cmds[0], post_cmds[1], 0)) {
                    fprintf(stderr, "Failed command (%s - %s:%s)\n", engine_id,
                        post_cmds[0], post_cmds[1] ? post_cmds[1] : "(NULL)");
                    <!-- a -->ENGINE_finish(e)<!-- /a -->;
                    return 0;
                }
                post_cmds += 2;
            }
            ENGINE_set_default(e, ENGINE_METHOD_ALL &amp; ~ENGINE_METHOD_RAND);
            /* Success */
            return 1;
        }

       Note that <u>ENGINE</u><b>_</b><u>ctrl</u><b>_</b><u>cmd</u><b>_</b><u>string()</u> accepts a boolean argument that can relax the semantics of the
       function - if set non-zero it will only return failure if the ENGINE supported the given command name
       but failed while executing it, if the ENGINE doesn't support the command name it will simply return
       success without doing anything. In this case we assume the user is only supplying commands specific
       to the given ENGINE so we set this to FALSE.

       <u>Discovering</u> <u>supported</u> <u>control</u> <u>commands</u>

       It is possible to discover at run-time the names, numerical-ids, descriptions and input parameters of
       the control commands supported from a structural reference to any ENGINE. It is first important to
       note that some control commands are defined by OpenSSL itself and it will intercept and handle these
       control commands on behalf of the ENGINE, ie. the ENGINE's <u>ctrl()</u> handler is not used for the control
       command. openssl/engine.h defines a symbol, ENGINE_CMD_BASE, that all control commands implemented by
       ENGINEs from. Any command value lower than this symbol is considered a "generic" command is handled
       directly by the OpenSSL core routines.

       It is using these "core" control commands that one can discover the the control commands implemented
       by a given ENGINE, specifically the commands;

        #define ENGINE_HAS_CTRL_FUNCTION               10
        #define ENGINE_CTRL_GET_FIRST_CMD_TYPE         11
        #define ENGINE_CTRL_GET_NEXT_CMD_TYPE          12
        #define ENGINE_CTRL_GET_CMD_FROM_NAME          13
        #define ENGINE_CTRL_GET_NAME_LEN_FROM_CMD      14
        #define ENGINE_CTRL_GET_NAME_FROM_CMD          15
        #define ENGINE_CTRL_GET_DESC_LEN_FROM_CMD      16
        #define ENGINE_CTRL_GET_DESC_FROM_CMD          17
        #define ENGINE_CTRL_GET_CMD_FLAGS              18

       Whilst these commands are automatically processed by the OpenSSL framework code, they use various
       properties exposed by each ENGINE by which to process these queries. An ENGINE has 3 properties it
       exposes that can affect this behaviour; it can supply a <u>ctrl()</u> handler, it can specify
       ENGINE_FLAGS_MANUAL_CMD_CTRL in the ENGINE's flags, and it can expose an array of control command
       descriptions.  If an ENGINE specifies the ENGINE_FLAGS_MANUAL_CMD_CTRL flag, then it will simply pass
       all these "core" control commands directly to the ENGINE's <u>ctrl()</u> handler (and thus, it must have
       supplied one), so it is up to the ENGINE to reply to these "discovery" commands itself. If that flag
       is not set, then the OpenSSL framework code will work with the following rules;

        if no ctrl() handler supplied;
            ENGINE_HAS_CTRL_FUNCTION returns FALSE (zero),
            all other commands fail.
        if a ctrl() handler was supplied but no array of control commands;
            ENGINE_HAS_CTRL_FUNCTION returns TRUE,
            all other commands fail.
        if a ctrl() handler and array of control commands was supplied;
            ENGINE_HAS_CTRL_FUNCTION returns TRUE,
            all other commands proceed processing ...

       If the ENGINE's array of control commands is empty then all other commands will fail, otherwise;
       ENGINE_CTRL_GET_FIRST_CMD_TYPE returns the identifier of the first command supported by the ENGINE,
       ENGINE_GET_NEXT_CMD_TYPE takes the identifier of a command supported by the ENGINE and returns the
       next command identifier or fails if there are no more, ENGINE_CMD_FROM_NAME takes a string name for a
       command and returns the corresponding identifier or fails if no such command name exists, and the
       remaining commands take a command identifier and return properties of the corresponding commands. All
       except ENGINE_CTRL_GET_FLAGS return the string length of a command name or description, or populate a
       supplied character buffer with a copy of the command name or description. ENGINE_CTRL_GET_FLAGS
       returns a bitwise-OR'd mask of the following possible values;

        #define ENGINE_CMD_FLAG_NUMERIC                (unsigned int)0x0001
        #define ENGINE_CMD_FLAG_STRING                 (unsigned int)0x0002
        #define ENGINE_CMD_FLAG_NO_INPUT               (unsigned int)0x0004
        #define ENGINE_CMD_FLAG_INTERNAL               (unsigned int)0x0008

       If the ENGINE_CMD_FLAG_INTERNAL flag is set, then any other flags are purely informational to the
       caller - this flag will prevent the command being usable for any higher-level ENGINE functions such
       as <u>ENGINE</u><b>_</b><u>ctrl</u><b>_</b><u>cmd</u><b>_</b><u>string()</u>.  "INTERNAL" commands are not intended to be exposed to text-based
       configuration by applications, administrations, users, etc. These can support arbitrary operations
       via <u>ENGINE</u><b>_</b><u>ctrl()</u>, including passing to and/or from the control commands data of any arbitrary type.
       These commands are supported in the discovery mechanisms simply to allow applications determinie if
       an ENGINE supports certain specific commands it might want to use (eg. application "foo" might query
       various ENGINEs to see if they implement "FOO_GET_VENDOR_LOGO_GIF" - and ENGINE could therefore
       decide whether or not to support this "foo"-specific extension).

       <b>Future</b> <b>developments</b>

       The ENGINE API and internal architecture is currently being reviewed. Slated for possible release in
       0.9.8 is support for transparent loading of "dynamic" ENGINEs (built as self-contained shared-<font color="#ffffff" class="whiteout">libraries).&nbsp;sharedlibraries).</font>
       libraries). This would allow ENGINE implementations to be provided independantly of OpenSSL libraries
       and/or OpenSSL-based applications, and would also remove any requirement for applications to
       explicitly use the "dynamic" ENGINE to bind to shared-library implementations.

<b>SEE</b> <b>ALSO</b>
       <a href="rsa.3ssl.html#//apple_ref/doc/man/3/rsa"><u>rsa</u>(3)</a>, <a href="dsa.3ssl.html#//apple_ref/doc/man/3/dsa"><u>dsa</u>(3)</a>, <a href="dh.3ssl.html#//apple_ref/doc/man/3/dh"><u>dh</u>(3)</a>, <a href="rand.3.html#//apple_ref/doc/man/3/rand"><u>rand</u>(3)</a>, <a href="RSA_new_method.3ssl.html#//apple_ref/doc/man/3/RSA_new_method"><u>RSA</u><b>_</b><u>new</u><b>_</b><u>method</u>(3)</a>



0.9.7l                                           2002-12-15                                        engine(3)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/engine.3ssl.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/engine.3ssl.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/engine.3ssl.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
