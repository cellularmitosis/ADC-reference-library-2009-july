<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Getting Started With TextEdit(IM: Tx)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING50></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Text-49.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Text-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Text-594.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Text-51.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Text-2.html"><B>Text</B></A> / <BR><DD><A HREF="Text-40.html"><B>Chapter 2 - TextEdit</B></A> / <A HREF="Text-49.html"><B>Using TextEdit</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING50-0></A>
<H2><A NAME=MARKER-9-702></A>Getting Started With TextEdit</H2>
 You can use TextEdit to display static text, for example, in a dialog box; the TextEdit procedure that you use to do this creates its own edit record. You can use TextEdit to display and manipulate modifiable text, for which purpose you must first create an edit record. This section discusses these two uses of TextEdit. It describes how you create an edit record and bring existing text into its text buffer, then set the text selection range or insertion point, scroll the text, and, finally, release the memory allocated for the edit record when you are finished with it. The topics are described in the following order:<P>
<UL>
<LI>preparing to use TextEdit
<LI>displaying static text
<LI>creating an edit record
<LI>setting the text of an edit record
<LI>setting the selection range or the insertion point
<LI>scrolling text
<LI>disposing of an edit record<P>
</UL>
<A NAME=HEADING50-9></A>
<H3><A NAME=MARKER-2-807></A>Preparing to Use TextEdit</H3>
 This section describes two basic tasks that your application needs to perform before using TextEdit. It must<P>
<UL>
<LI>determine the installed version of TextEdit
<LI>initialize other managers and TextEdit<P>
</UL>
 To determine the installed version of TextEdit, you use the Gestalt Manager, which is fully documented in the chapter "The Gestalt Manager" in <I><A HREF="../OSUtilities/OSUtilities-2.html">Inside Macintosh: Operating System Utilities</A></I>.<P>
 You can get information about the current version of TextEdit using the <CODE>Gestalt</CODE> function <A NAME=MARKER-2-15></A>with the <CODE>Gestalt</CODE> selector <CODE>gestaltTextEditVersion</CODE>, which returns one of the values listed and described below. In this list, a new feature is shown only when it is first introduced in the software, although it is part of TextEdit in succeeding versions. For system software version 6.0.4, different patches were made to TextEdit for different hardware platforms. In these cases, unique values are returned that also identify <BR>the hardware.<BR><A NAME=MARKER-2-331></A><A NAME=MARKER-2-332></A>
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Returned value<TH>New features<TH>System software/hardware<TR>
<TD>gestaltUndefSelectorEr<CODE>r</CODE><TD>Multistyled TextEdit<TD>Systems before 6.0.4/all hardware<TR>
<TD>gestaltTE1<TD>&nbsp;<TD>System 6.0.4 Roman script system/IIci-family hardware<TR>
<TD>gestaltTE2<TD>New width measurement hook<CODE> <BR><BR></CODE>Script Manager compatible<TD>System 6.0.4 non-Roman script system/IIci-family hardware<TR>
<TD>gestaltTE3<TD>&nbsp;<TD>System 6.0.4 non-Roman script system/all non-IIci family hardware<TR>
<TD>gestaltTE4<TD>TEFeatureFlag<TD>System 6.0.5/all hardware<TR>
<TD>gestaltTE5<TD>Text width measurement hook<TD>Sy<A NAME=MARKER-2-768></A>stem 7.0/all hardware</TABLE>
<P>
 You need to initialize other managers and TextEdit before your application calls any TextEdit routines, including <CODE>TEInit</CODE>. First, you initialize QuickDraw, the Font Manager, and the Window Manager, and then TextEdit, in that order. To do this, call the following<A NAME=MARKER-2-454></A> routines from an initialization procedure that is called from your application's <BR>main routine.<A NAME=MARKER-2-301></A><P>
<PRE>
BEGIN
   InitGraf(@thePort);
   InitFonts;
   InitWindows;
   InitMenus;
   TEInit;
   ....
</PRE>
 In addition to initializing miscellaneous global variables, such as <CODE>TEDoText</CODE> and <CODE>TERecal</CODE>, the <CODE>TEInit</CODE> procedure sets up the <A NAME=MARKER-2-201></A>private scrap and allocates a handle to it.<A NAME=MARKER-2-232></A><P>
<DL>
<DT><B>Note</B>
<DD>You should call <CODE>TEInit</CODE> even if your application doesn't use TextEdit so that desk accessories and dialog and alert boxes, which use TextEdit routines, work correctly.<EM></EM><A NAME=MARKER-2-377></A>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING50-19></A>
<H3><A NAME=MARKER-2-150></A><A NAME=MARKER-2-275></A><A NAME=MARKER-2-287></A>Displaying Static Text</H3>
 TextEdit provides an easy way for your application to display static text whether or <BR>not it uses other TextEdit features to implement editing services. The <CODE>TETextBox</CODE> procedure displays unchanging text that you cannot edit. You don't create an edit record because the <CODE>TETextBox</CODE> procedure creates its own edit record, which it deletes when it's finished with it.<P>
 The <A NAME=MARKER-2-335></A><CODE>TETextBox</CODE> procedure draws the text in a rectangle whose size you specify in the local coordinates of the current graphics port. You can also specify how text is aligned in the box. Text can be right aligned, left aligned, or centered.<P>
 You can use any of the following constants to specify how text is aligned in the box that <CODE>TETextBox</CODE> creates.
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Constant<TH>Description<TR>
<TD><A NAME=MARKER-2-892></A>teFlushDefault<TD>Default alignment according to the primary line direction<TR>
<TD>teCenter<TD>Center for all scripts<TR>
<TD>teFlushRight<TD>Right for all scripts<TR>
<TD><A NAME=MARKER-2-392></A>teFlushLeft<TD>Left for all scripts</TABLE>
<P>
 <A HREF=#MARKER-9-296>Listing 2-1</A> shows how to use <CODE>TETextBox</CODE>. The first parameter is a pointer to the text to be drawn, which is a Pascal string. Because Pascal strings start with a length byte, you need to advance the pointer one position past the beginning of the string to point to the start of the text.<P>
<A NAME=MARKER-9-296></A><B>Listing 2-1  Using <CODE>TETextBox</CODE> to draw static text</B><P>
<PRE>
str   := 'String in a box'; 
SetRect(r,100,100,200,200); 
TETextBox(POINTER(ORD(@str)+1),LENGTH(str),r,teCenter); 
FrameRect(r);
</PRE>
<A NAME=HEADING50-26></A>
<H3>Creating an Edit Record</H3>
 To use all other TextEdit routines in your application except the <CODE>TETextBox</CODE> procedure, first you need to create an edit <A NAME=MARKER-2-69></A>record. This section discusses how to create an edit record. It also describes<P>
<UL>
<LI>which type of edit record to use, monostyled or multistyled, and why
<LI>some ways to store the edit record handle that the function returns when you create an edit record
<LI>what to consider when you specify values for the destination and view rectangles when you create an edit record
<LI>how TextEdit initializes those edit record fields that are used differently for monostyled and multistyled edit records, and those that are used the same<P>
</UL>
 The <A NAME=MARKER-2-289></A><CODE>TEStyleNew</CODE> function allocates a multistyled edit record which contains text with character attribute information that can vary from character to character. The <CODE>TENew</CODE> function allocates a monostyled edit record which contains text in a single font, face, and size. (Before your application calls either of these functions, the window must be the current graphics port.)<P>
 If your application supports only monostyled text, use <CODE>TENew</CODE> to avoid the unnecessary allocation of additional data structures used to store character attribute information for multistyled edit records. You can use <CODE>TEStyleNew</CODE> in this case also, although it is not recommended.<P>
 Both <CODE>TENew</CODE> and <CODE>TEStyleNew</CODE> <A NAME=MARKER-2-357></A>return a handle to the newly created record. Most TextEdit routines require you to pass this handle as a parameter, so your application needs to st<A NAME=MARKER-9-366></A>ore it using any of the following methods:<P>
<UL>
<LI>You can store the edit record handle in a private data structure whose handle is stored in your application window's <CODE>refcon</CODE> field.
<LI>You can create a record in which to store information about the window, and include a field to store the edit record handle. <A HREF=#MARKER-9-159>Listing 2-2</A> provides an example of this method.
<LI>You can define a variable in your application for each edit record handle, and then use the variable to store the handle.<P>
</UL>
 <A HREF=#MARKER-9-159>Listing 2-2</A> shows a sample document record declaration for an application that handles text files. The document record is an application-specific data structure that contains the handle to the edit record, and any controls for scroll bars.<P>
<B>Listing 2-2  <A NAME=MARKER-9-159></A>A sample document record</B><P>
<PRE>
TYPE
   MyDocRecHnd =  ^MyDocRecPtr;
   MyDocRecPtr =  ^MyDocRec;
   MyDocRec    =
   RECORD
      editRec:       TEHandle;      {handle to TextEdit record}
      vScrollBar:    ControlHandle; {vertical scroll bar}
      hScrollBar:    ControlHandle; {horizontal scroll bar}
   END;
</PRE>
 To associate an application-defined document record with a particular window, you can set a handle to that record as the reference constant of the window by using the Window Manager procedure <CODE>SetWRefCon</CODE>. This technique is described further in the chapter "Introduction to File Management" in <I><A HREF="../Files/Files-2.html">Inside Macintosh: Files</A></I>.<P>
 <A NAME=MARKER-2-431></A>When you create an edit record, you specify the area in which the text is drawn as the destination rectangle, and the portion of the window in which the text is actually displayed as the view rectangle.<P>
 To ensure that the first and last characters in each line are legible in a document window, you can inset the destination rectangle at least four pixels from the left and right edges of the graphics port (20 pixels from the right edge if the window contains a scroll bar <BR>or size box).<P>
 The destination <A NAME=MARKER-2-249></A>rectangle must always be at least as wide as the first character drawn. The view <A NAME=MARKER-2-341></A>rectangle must not be empty; for example, if you do not want any text visible, specify a rectangle off the screen--don't make its trailing edge less than its leading edge.<P>
 Editing operations may lengthen or shorten the text. The bottom of the destination rectangle can extend to accommodate the end of the text. In other words, you can think of the destination rectangle as bottomless. The sides of the destination rectangle determine the beginning and the end of each line of text, and its top determines the position of the first line.<P>
 Your program should not have a destination rectangle that is wider than the view rectangle if you are displaying mixed-directional text. For example, the Dialog Manager makes the destination rectangle extend twice as far on the right as the view rectangle, so that horizontal scrolling can be used in normal dialog boxes. When the Arabic script system is installed, this extension is disabled, because the text may be right aligned, and therefore out of view. Your application can include the following code to check that the destination and view rectangles have the same width.<P>
<PRE>
IF scriptsInstalled &gt; 1 THEN
   IF GetEnvirons (smBidirect)&lt;&gt;0 THEN
      BEGIN
      {make the rectangles the same width}
      END;
</PRE>
 When you create an edit record, TextEdit initializes the record's fields, based on values in the current graphics port record and the kind of edit record you create. Although most edit record fields are initialized similarly for both monostyled and multistyled edit records, there are some fields that are used differently, and their initial values depend on how they are used.<P>
 For a monostyled edit record that you create by calling <CODE>TENew</CODE>, the <CODE>txSize</CODE>, <CODE>lineHeight</CODE>, and <CODE>fontAscent</CODE> fields of the edit record hold actual values reflecting the text size, the line height, and the font ascent. Because the text is monostyled, these values apply to all of the text of the edit record.<P>
<UL>
<LI>The <CODE>txSize</CODE> field is set to the value of the current graphics port's text size (<CODE>txSize</CODE>) field, which indicates that all text is set in a single font, size, and face.
<LI>The value of the <CODE>lineHeight</CODE> field specifies the fixed vertical distance from the <A NAME=MARKER-2-358></A>ascent line of one line of text down to the ascent line of the next. The line height corresponds to the ascent plus descent for the font and leading to create single-spacing for the lines in the new edit record.
<LI>The value of the <CODE>fontAscent</CODE> field  specifies how far above the base line the pen is positioned to draw the caret or to highlight the text. For single-spaced text, this is the ascent of the text in pixels (the height of the tallest characters in the font from the base line). The font ascent corresponds to the ascent of the font indicated by the <CODE>txFont</CODE> and <CODE>txSize</CODE> fields of the current graphics port.<P>
</UL>
<DL>
<DT><B>Note</B>
<DD>To adjust the spacing for a monostyled edit record, you can alter the values in the <CODE>fontAscent</CODE> and <CODE>lineHeight</CODE> fields of the edit record.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 For more information, see the discussion of font measurements in the chapter "Font Manager" in this book.<P>
 For a multistyled edit record, <CODE>TEStyleNew</CODE> initializes the <CODE>txSize</CODE>, <CODE>lineHeight</CODE>, and <CODE>fontAscent</CODE> fields of the edit record to -1. A value of -1 in each of these fields means:<P>
<UL>
<LI><CODE>txSize</CODE><P>
The edit record contains associated character attribute information and the <CODE>txFont</CODE> and <CODE>txFace</CODE> fields combine to contain the text style record handle for the character attribute information.
<LI><CODE>lineHeight</CODE><P>
The vertical distance from the <A NAME=MARKER-2-164></A>ascent line of one line of text down to the ascent line of the next is calculated independently for each line, based on the maximum value for any individual character attribute on that line. These values are stored in the line height table (<CODE>LHTable</CODE>).
<LI><CODE>fontAscent</CODE><P>
The font ascent is calculated independently for each line, based on the maximum value for any individual character attribute on that line. These values are stored in the line height table (<CODE>LHTable</CODE>).<A NAME=MARKER-2-393></A><P>
</UL>
 For both multistyled and monostyled records, the following fields are initially set to the same values:<P>
<UL>
<LI>The record initially contains no text. The text handle (<CODE>hText</CODE>) points to a zero-length block in the heap, and the text length field (<CODE>teLength</CODE>) of the edit record is set to 0. To furnish text to be edited, you use the <CODE>TESetText</CODE> procedure if you are incorporating existing text and the <CODE>TEKey</CODE> procedure if the user is entering text.
<LI>The value of the <CODE>just</CODE> field determines the alignment of text in the edit record. The default value is <CODE>teFlushDefault</CODE>, indicating that the alignment is to follow the primary line direction. For languages that are read from left to right, the default value is left; for languages that are read from right to left, the default value is right. To change the alignment of text in the record, you use the <CODE>TESetAlignment</CODE> procedure.<A NAME=MARKER-2-959></A>
<LI>The <CODE>selStart</CODE> and <CODE>selEnd</CODE> fields are initially set to 0; this places the insertion point at the beginning of the text.
<LI>The edit record uses the drawing environment of the graphics port specified by the <CODE>destRect</CODE> and <CODE>viewRect</CODE> <A NAME=MARKER-2-392></A>parameters. These parameters contain the local coordinates of rectangles within the current graphics port, which <A NAME=MARKER-9-217></A>becomes the graphics port for the new edit record. The text in the new edit record is to have the characteristics of the current graphics port.<P>
</UL>
 <A HREF=#MARKER-9-170>Listing 2-3</A> shows the <CODE>MyAddTE</CODE> function, which is a sample application-defined function that creates a new multistyled edit record for an existing window. The <CODE>TEStyleNew</CODE> function call returns a handle to the edit record that it creates. The code stores the handle in the <CODE>docTE</CODE> variable. The <CODE>TEAutoView</CODE> procedure call turns on <A NAME=MARKER-2-327></A>automatic scrolling for the newly created edit record. For a complete discussion of scrolling, see the chapter "Control Manager" in <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I>.<P>
<B>Listing 2-3  <A NAME=MARKER-9-170></A>Creating a multistyled edit record</B><P>
<PRE>
FUNCTION MyAddTE (myWindow: WindowPtr): TEHandle;
VAR
   destRect, viewRect:  Rect;
   docTE:               TEHandle;
   CONST
   kMaxDocWidth = 576;
BEGIN
   MyGetTERect(myWindow, viewRect); {get TextEdit rectangle}
   destRect := viewRect;
   destRect.right := destRect.left + kMaxDocWidth;
   docTE := TEStyleNew(destRect, viewRect);
   IF docTE &lt;&gt; NIL THEN 
      BEGIN
         TEAutoView(TRUE, docTE);
         docTE^^.clikLoop := @AsmClikLoop;
      END;
   MyAddTE := docTE; 
END;
</PRE>
<A NAME=HEADING50-70></A>
<H3>Specifying the Destination and View Rectangles</H3>
 When you create an edit record, whether monostyled or multistyled, you specify the area in which the text is drawn as the destination rectangle, and the portion of the window in which the text is actually displayed as the view rectangle.<P>
 To ensure that the first and last glyphs in each line are legible in a document window, you can inset the destination rectangle at least four pixels from the left and right edges of the graphics port (20 pixels from the right edge if the window contains a scroll bar <BR>or size box).<P>
 The destination <A NAME=MARKER-2-171></A>rectangle must always be at least as wide as the first glyph drawn. The view <A NAME=MARKER-9-396></A>rectangle must not be empty; for example, if you do not want any text visible, specify a rectangle off the screen--don't make its trailing edge less than its leading edge.<P>
 Editing operations may lengthen or shorten the text. The bottom of the destination rectangle can extend to accommodate the end of the text. In other words, you can think of the destination rectangle as bottomless. The sides of the destination rectangle determine the beginning and the end of each line of text, and its top determines the position of the first line.<P>
 Your program should not have a destination rectangle that is wider than the view rectangle if you are displaying mixed-directional text. For example, the Dialog Manager makes the destination rectangle extend twice as far on the right as the view rectangle, so that horizontal scrolling can be used in normal dialog boxes. When the Arabic script system is installed, this extension is disabled, because the text may be right aligned, and therefore out of view. Your application can include the following code to check that the destination and view rectangles have the same width.<P>
<PRE>
IF scriptsInstalled &gt; 1 THEN
   IF GetEnvirons (smBidirect)&lt;&gt;0 THEN
      BEGIN
      {make the rectangles the same width}
      END;
</PRE>
<A NAME=HEADING50-77></A>
<H3>Setting the Text of an Edit Record</H3>
 When you create an edit record, it doesn't contain any text until either the user enters text through the keyboard or opens an existing document. This section describes how to specify <I>existing</I> text to be edited. <A HREF=Text-51.html#MARKER-9-219>"Accepting Text Input Through Key-Down Events" on page 2-33</A> discusses how to insert text that the user enters through the keyboard.<P>
 When a user<A NAME=MARKER-2-900></A> opens a document, your application can bring the document's text into the text buffer of an edit record by calling <A NAME=MARKER-2-899></A><CODE>TESetText</CODE>. If the text has associated character attribute information, your application also needs to manage it.<P>
 There are two ways to specify existing text to be edited. The easier method is to use <CODE>TESetText</CODE>, which creates a copy of the text and stores the copy in the existing handle of the edit record's <CODE>hText</CODE> <A NAME=MARKER-2-901></A>field. One of the parameters that you pass to <CODE>TESetText</CODE> specifies the length of the text. The <CODE>TESetText</CODE> procedure resets the <CODE>teLength</CODE> field of the edit record with this value and uses it to determine the end of the text; it sets the <CODE>selStart</CODE> and <CODE>selEnd</CODE> fields to the last byte offset of the text so that the insertion point is positioned at the end of the displayed text. The <CODE>TESetText</CODE> procedure calculates line breaks, eliminating the need for your application to do this.<P>
 You can use the second method to save space if you have a lot of text. Using this method, you can bring text into an edit record by directly changing the <CODE>hText</CODE> field of the edit record, replacing the existing handle with the handle of the new text. When you do this for a monostyled edit record, you need to modify the <CODE>teLength</CODE> field to specify the length of the new text, and then call <CODE>TECalText</CODE> <A NAME=MARKER-2-5></A>to recalculate the <CODE>lineStarts</CODE> array and <CODE>nLines</CODE> values to match the new text.<P>
 Using the second method is somewhat more complicated for multistyled text because <CODE>TECalText</CODE> does not update the style run table (<CODE>StyleRun</CODE>) properly. To compensate for this, your application needs to perform the following tasks:<P>
<UL>
<LI>Before changing the edit record's <CODE>hText</CODE> field, reduce the style run table to one entry.<br>
Do this by setting the edit record's <CODE>selStart</CODE> field to 0 and its <CODE>selEnd</CODE> field to 32767, then call <CODE>TESetStyle</CODE>.
<LI>Before calling <CODE>TECalText</CODE>, set the start character (<CODE>startChar</CODE>) field of the style run table to the length of the new text plus one, that is:<P>
<pre>TEStyleRec.runs[1] to length(hText)+1</pre><P>
</UL>
<B>Using the same edit record for different pieces of text</B><P>
<DL>
<DD>Rather than allocate a new edit record for each piece of text you want to edit, you can use the same record to edit different pieces of text. For example, you can create an edit record and either accept user input or call <CODE>TESetText</CODE> to incorpora<A NAME=MARKER-2-910></A>te existing text. If you know that you'll want to edit the text again whose handle is currently stored in the <CODE>hText</CODE> field, first you need to save the text before you call <CODE>TESetText</CODE>, because <CODE>TESetText</CODE> uses the same handle, resizing it for the new text, if necessary.<EM></EM><A NAME=MARKER-2-330></A>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 The <CODE>TESetText</CODE> procedure doesn't affect the text drawn in the destination rectangle, so call the Window Manager's <CODE>InvalRect</CODE> procedure afterward, if necessary. For more information about the <CODE>InvalRect</CODE> procedure, see the chapter "Window Manager" in <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I>.<P>
<A NAME=HEADING50-90></A>
<H3>Setting the Selection Range or the Insertion Point</H3>
 You can use the <A NAME=MARKER-2-351></A><CODE>TESetSelect</CODE> procedure to specify the selection range or the position of the insertion point as determined by the application. For example, you can use <CODE>TESetSelect</CODE> to highlight an initial default value in an application such as an online data-entry form, or to position the caret at the start of the field where you want the user to enter a value. You can also use it to implement a Select All menu command.<P>
 You can set the selection range (or insertion point) to any character positions within the text of the edit record corresponding to byte offsets 0 through 32767. To select a range of text, you pass <CODE>TESetSelect</CODE> the handle to the edit record along with the byte offsets corresponding to the beginning and the ending characters of the text to be highlighted. The <CODE>TESetSelect</CODE> procedure modifies the <CODE>selStart</CODE> and <CODE>selEnd</CODE> fields of the edit record.<P>
 To display a caret at an insertion point, specify the same value for both the <CODE>selStart</CODE> and <CODE>selEnd</CODE> parameters. To encompass the edit record's entire text block as the selection range, specify 0 as the value of <CODE>selStart</CODE> and 32767 as the value of <CODE>selEnd</CODE>. You can implement a Select All menu command by specifying the edit record's entire range of text, as shown in the following code fragment, by using the <CODE>teLength</CODE> field.<P>
<PRE>
iSelectAll:
   TESetSelect(0, myTERec^^.teLength, myTERec);
</PRE>
<A NAME=HEADING50-95></A>
<H3>Scrolling Text</H3>
 Using TextEdit routines, your application can allow the user to control text scrolling through the scroll bars; in this case, you scroll the text by calling a TextEdit procedure. It can also automatically scroll the text of an edit record <A NAME=MARKER-2-205></A>into view when the user clicks in the view rectangle, and then drags the mouse outside of it, if you enable automatic scrolling through another TextEdit procedure.<P>
 To scroll the text when a mouse-down event occurs in a scroll bar, your application needs to determine how far to scroll the text. For example, to vertically scroll the text of <A NAME=MARKER-9-236></A>a monostyled edit record, you can use the <CODE>lineHeight</CODE> field of the edit record to calculate the number of pixels to scroll; you multiply every click in the scroll bar by the number of pixels in the <CODE>lineHeight</CODE> field and by the number of lines displayed in the view rectangle. For multistyled text, you need to use the value of the <CODE>lhHeight</CODE> field of the line height table for each line in the view rectangle because line height can vary from line to line.<A NAME=MARKER-2-182></A><P>
 To scroll the text, you call either <A NAME=MARKER-2-257></A><CODE>TEScroll</CODE> or <CODE>TEPinScroll</CODE> <A NAME=MARKER-9-298></A>specifying the number of pixels to scroll. The only difference between <CODE>TEScroll</CODE> and <CODE>TEPinScroll</CODE> is that <CODE>TEPinScroll</CODE> stops scrolling when the last line is scrolled into the view rectangle.<P>
 When the user clicks in the scroll arrow pointing down, you scroll the text up. When the user clicks in the scroll arrow pointing up, you scroll the text down. Passing a positive value to either routine moves the text right and down, passing a negative value moves the text left and up. The destination rectangle is offset by the amount you scroll. For example, the following call scrolls the text of a monostyled edit record up one line.<P>
<PRE>
TEScroll(0, -hTE^^.lineHeight, hTE)
</PRE>
 There are two ways to enable or disable automatic scrolling for an edit record. You can use the <CODE>TEAutoView<A NAME=MARKER-9-7></A></CODE> procedure or the <CODE>teFAutoScroll</CODE> feature of the <CODE>TEFeatureFlag</CODE> <A NAME=MARKER-2-193></A>function. However, neither of these routines actually scrolls the text. To ensure that the selection range is always visible, your application should call <CODE>TESelView</CODE>. <A NAME=MARKER-2-230></A>When automatic scrolling is turned on, <CODE>TESelView</CODE> scrolls the selection range into view, if necessary.<P>
 <A HREF=#MARKER-9-170>Listing 2-3 on page 2-25</A> creates a multistyled edit record and turns on automatic scrolling for it. It saves the address of the default c<A NAME=MARKER-2-874></A>lick loop procedure installed in the edit record's <CODE>clikLoop</CODE> field, then replaces it with the address of its own customized click loop routine.<P>
 The <CODE>clikLoop</CODE> field of the edit record contains the address of a click loop procedure that is called continuously as long as the mouse button is held down. When automatic scrolling is turned on, the default click loop routine determines if the mouse has been dragged out of the view rectangle; if it has, the default click routine scrolls the text using <CODE>TEPinScroll</CODE>. For example, if the user clicks in the text and drags the mouse outside of it to the right, the text is automatically scrolled left.<P>
 How much the text is scrolled vertically is determined by the <CODE>lineHeight</CODE> field of the edit record for a monostyled edit record and by the <A NAME=MARKER-2-341></A><CODE>lhHeight</CODE> field of the line height table for a multistyled edit record.<P>
 Scroll bars are not scrolled automatically with the text if the default click loop routine is used. However, you can replace the default click loop routine with a routine that updates scroll bars. For more information about customizing scrolling, see <A HREF=Text-55.html#MARKER-9-329>"Customizing Automatic Scrolling" on page 2-57</A>. For a complete discussion of scrolling, see the chapter "Control Manager" in <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I><A NAME=MARKER-2-45></A>.<P>
<A NAME=HEADING50-106></A>
<H3>Disposing of an Edit Record</H3>
 When your application is completely finished with an edit record, you should release any memory a<A NAME=MARKER-2-897></A>llocated for it by calling <A NAME=MARKER-2-907></A><CODE>TEDispose</CODE>. To continue to refer to the text once you've destroyed the edit record, use the Operating System Utilities <A NAME=MARKER-2-409></A><CODE>HandToHand</CODE> function before you call <CODE>TEDispose</CODE>. It copies the text (whose handle is stored in the edit record's <CODE>hText</CODE> field), and returns a new handle to it. (See <I><A HREF="../OSUtilities/OSUtilities-2.html">Inside Macintosh: Operating System Utilities</A></I> for more information.) For a multistyled edit record, you also need to save the character attribute information. If your program retains the original handle to the text stored in the <CODE>hText</CODE> field after you call <CODE>TEDispose</CODE>, the handle becomes invalid because the text is removed--the memory used for it is deallocated.<P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Text-49.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Text-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Text-594.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Text-51.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Text-3.html">&copy; Apple Computer, Inc.</A><br>6 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
