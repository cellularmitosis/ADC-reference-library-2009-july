<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 03-24-01 --><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css">   <title>Technical Note TN1076: Cross-Platform Communication Using the PC Compatibility Messaging System</title>       <meta name="keywords" content="Mac OS 8 cross-platform PC compatible messaging system communication">    <meta name="Description" content="Technical Note TN1076: This Technical Note describes theMessaging System Architecture used in Apple's PC Compatibilityand DOS Compatibility products. Specifically, the messagingsystem allows communication of data between the PC-basedmachine running on a NuBus or PCI card and the MacintoshOS. Such topics as Using the Messaging System, Basic MessagingConcepts, and essential data types of the messaging systemare discussed."><meta name="categories" content="Cross-Platform"><meta name="week-posted" content="Sep 30, 1996 - Oct 4, 1996"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002917" title="Cross-Platform Communication Using the PC Compatibility Messaging System"></a><A NAME="top"></A><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/QuickTime/index.html">QuickTime</a> &gt; <a href="../../technicalnotes/QuickTime/idxQuickTimeforWindows-date.html">QuickTime for Windows</a> &gt; </p><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1076</div>
<div id="pageheadsub">Cross-Platform Communication Using the PC Compatibility Messaging System</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"> <!-- begin_header_box --> <table width="600" cellpadding="0" cellspacing="0" border="0">	<tr>		<td width=300 valign="top" align=left scope="row">			<table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>				</tr>				<tr bgcolor="#e6e6e6">					<td background="images/tnmenubody.gif" width=300 align=left>						<span id="menutitle">							CONTENTS                             <br>                            <br>						</span>					</td>				</tr>				<tr bgcolor="#e6e6e6">					<td background="images/tnmenubody.gif" width=300 align=left><!-- begin_toc --><p id="menutext"><A HREF = "#RTFToC1">About the PC Compatibility Messaging   System</A><BR><BR><A HREF = "#RTFToC2">Using the Messaging System</A><BR><BR><A HREF = "#RTFToC3">Basic Messaging Concepts</A><BR><BR><A HREF = "#RTFToC4">Summary of Messaging System</A><BR><BR><A HREF = "#RTFToC5">Summary</A><BR><BR><A HREF="#Downloads">Downloadables</A></p>                  <!-- end_toc --> 								</td>				</tr>				<tr>					<td width=300 align=left scope="row">						<img src="images/tnmenubottom.gif" alt="" width=300 height=16>					</td>				</tr>			</table>		</td>		<td width=300 valign="top" align=left>			<!-- begin_intro_text -->            <P id = "introtext">This Technote describes the Messaging System Architecture used inApple's PC Compatibility and DOS Compatibility products.Specifically, the messaging system allows communication of databetween the PC-based machine running on a NuBus or PCI card and theMacintosh OS. This inter-machine communication is facilitated througha driver on the Macintosh which controls the PC card and allows it torun within the Macintosh hardware and software space.</P><P id ="introtext">This Technote is directed toward third-party developers who areinterested in developing software for the Mac and the PC which needsto communicate instructions or data between platforms. Theapplications developed to use the messaging system would be intendedto run specifically with Apple's PC Compatibility products.</P><P id ="introtext">This document assumes the developer is familiar with applicationand driver-level software development on the Macintosh platform aswell as the PC. For the Mac, an understanding of the Device Managerand implementing 68K and PPC native code is essential. For the PC, anunderstanding of 16-bit DOS Real mode execution and x86 assemblylanguage is useful. For development in conjunction with Window'sbased applications, a knowledge of 32-bit Windows programming andvirtual device drivers (VxD's) is necessary.</P><P id ="introtext">This document also assumes the reader is familiar with Apple's PCCompatibility products and how they function within the Macintosh OS.</P><P id ="introtext">Further information on Macintosh programming at the device levelcan be found in <CITE>Inside Macintosh: Devices</CITE> . For moreinformation on Windows VxD programming (only necessary for using themessage system with Windows 3.x or Windows 95), see <CITE>WritingWindows Virtual Device Drivers</CITE> by David Thielen and BryanWoodruff.</P><!-- end_intro_text --><!-- begin_date --><h3>&nbsp;Updated: [Oct 01 1996]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_header_box --> <BR><BR><hr width=500 align=center>          <BR><BR> <!-- begin_content --><A NAME="RTFToC1"></A><H2>About the PC Compatibility Messaging System</H2><P>The PC Compatibility (or DOS Compatibility) systems currentlysupported by this messaging architecture are the Centris 610 DOSCompatible, PowerMac 6100/66 DOS Compatible, the Quadra 630 DOSCompatible, and any PCI-based Macintosh which includes the mostrecent PCI-based 100Mhz Pentium and Cyrix 5x86 PC CompatibilityCards. Currently, the only system bundled with the PCI- based cardsis the PowerMac 7200/120. All of these systems must be runningversion 1.5 of the PC Compatibility Software or later, which includesthe driver that allows the messaging system to function.</P><P>The messaging system is implemented as a 16-bit DOS real-modedriver and is used extensively in these current products to allow thePC to have access to the shared devices on the Mac (HD, CD, floppy,etc.), networking communications, folder sharing, and clipboardsupport.</P><P><A HREF="#top">Back to top</A></P><A NAME="RTFToC2"></A><H2>Using the Messaging System</H2><P>Software programs on the Mac and the PC are capable of exchangingmessages containing up to 64K of data by using the Messaging SystemAPI. Applications that plan on sharing messages must define andunderstand the types of messages to be sent and received. Moreimportantly, verification and acknowledgment of sent and receivedmessages must be maintained by the sending and receivingapplications.</P><P>The driver installed at the Mac OS startup time is called".Symbiosis" and needs to be opened by your Macintosh applicationbefore driver calls can be made. Your program will then use devicemanager _Control calls to register, send, and receive messages. ThePC accesses the messaging system through a software interruptinterface. The application will load x86 registers with appropriatevalues, a function selector, and then call the messaging system viaan INT 5Fh call.</P><A NAME="RTFToC3"></A><H3>Basic Messaging Concepts</H3><P>Both the Mac and the PC applications accessing the messagingsystems must define a 32-bit selector for their messages and a countvalue that denotes the number of different types of messagesavailable for this selector. Typically, applications that are to passmessages define one selector type. Selector types can be any unique32-bit value, so 4-character values work well (32-bit OSType). Boththe Mac and the PC applications must know the message selector andthey must know the number of message types associated with thatselector in order to register themselves with the messaging system(See the <CITE>Registering Messages</CITE> section for more detailson Message Selectors and Types).</P><P>The basic process of <B>single message</B> communication betweenan application on the Mac and an application on the PC is as follows: </P><OL>   <LI>Open the messaging system and verify it is available.</li>   <LI>Accurately register message selector and number of message   types.</li>   <LI>Install message handlers and completion routines.</li>   <LI>Begin transceiving messages.</li>      <LI>Once the message handler is called, the application can   provide space to receive the data or ignore the message.</li>   <LI>After the data has been received, the receiving application   should send a response to the sending application, acknowledging   the data was properly received.</li>   <LI>Once the acknowledge has been received, the calling   application can then send another message (goto step 4) or both   apps can stop sending messages.</li>   <LI>After all messages have been sent, both applications must   remove and deallocate all their message handlers.</li></OL><P>Performing <B>multiple message</B> communication is also possible(i.e., the ability to send more than one message before receiving anacknowledge), but requires more maintenance. The intent here is todescribe the basic communication between applications. Therefore,multiple message communication concepts are discussed in the<CITE>Advanced Messaging Techniques </CITE> section of this Technote.</p><H3>Opening the Messaging System</H3><P>On the Mac, the application must open the .Symbiosis driver andretrieve the refNum for the driver in order to make other messagesystem control calls. Your application can do this using theOpenDriver function. If this returns an error, the .Symbiosis driveris not available and the messaging system cannot be used.</P><P>On the PC, the application must load the AH register with 0 andcall the software interrupt INT 5Fh. If the messaging system isinstalled, AH = $A5 and AL will equal the highest implementedfunction code, which is currently 5, when the interrupt returns. Thehighest implemented function code means there are a total of 5functions supported for registering and receiving messages. This willbe discussed in detail later.</P><H3>Essential Data Types</H3><P>The basic data structures for accessing the messaging system onthe Mac side are defined as follows: </P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>typedef struct {    QElemPtr    qLink;    SInt16      qType;    SInt16      ioTrap;    Ptr         ioCmdAddr;    ProcPtr     ioCompletion;   // always NULL    OSErr       ioResult;       // error result info.    StringPtr   ioNamePtr;    SInt16      ioVRefNum;    SInt16      ioCRefNum;      // refNum of Symbiosis driver.    SInt16      csCode;         // messaging system function    void *      csPtr;          // pointer to procedure or data    SInt32      csData;         // data    SInt32      csData2;        // data}SBParamBlockRec, *SBParamBlockRecPtr;</pre>	</TD></TR></TABLE></CENTER><P>The <code>SBParamBlockRec</code> is virtually the same as a standard<code>paramBlockRec</code> except only the fields used by the messaging system areincluded for the data area. The only fields needed for messaging arethe <code>ioCRefNum</code> and <code>csCode</code> for calling the driver, and then the csPtrand <code>csData</code> fields which are used to point to other structures thatare defined below. The different <code>csCode</code>'s used for calling themessaging system are defined below: </P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>enum {    eSendMessage            = 800,  // Send a message    eInstallMsgHandler      = 801,  // Install a message handler    eRemoveMsgHandler       = 802,  // Remove message handler    eRegisterMessage        = 803   // Register message type};</pre>	</TD></TR></TABLE></CENTER><P>The data structures used for sending and receiving messages arebelow: </P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>typedef struct MsgPBlk {    struct MsgPBlk* msgQLink;           // Pointer to next MsgPBlk    SInt16              msgQType;       // Queue Flags    SInt16              msgCmd;         // The message type or command    SInt32              msgParam1;      // Message parameter 1    SInt32              msgParam2;      // Message parameter 2    void*               msgBuffer;      // Ptr to the msg data buffer    SInt32              msgReqCount;    // Requested data length    SInt32              msgActCount;    // Actual data length    MsgCompletionUPP    msgCompletion;  // Ptr to comp. rtn. or NULL    SInt16              msgResult;      // The result of msg operation    UInt16              msgFlags;       // Message flags    UInt32              msgUserData;    // refCon (a5, etc)}MsgPBlk, *MsgPBlkPtr;typedef struct MsgRecElem {    struct MsgRecElem*  recQLink;           // Next queue element    SInt16                  recQType;       // queue flags    SInt16                  recFlags;       // Not used...Set to zero    MsgReceiveUPP           recProc;        // Ptr to the receive proc.    SInt16                  recCmdBase;     // Msg Selector base.    SInt16                  recCmdCount;    // # of msgTypes    UInt32                  recUserData;    // refCon (could be A5...)}MsgRecElem, *MsgRecElemPtr;</pre>	</TD></TR></TABLE></CENTER><P>The <code>MsgPBlk</code> is used for sending and receiving data and the<code>MsgRecElem</code> is used for notification of incoming messages.</P><P>For the PC application using the messaging system, the PC Datastructures and function ID constants are defined below: </P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>enum {    eIsAvailable = 0            // Index for is available    eSendMessage = 1            // Index for Send func    eInstallMsgHandler = 2      // Index for Install Msg Handler func    eRemoveMsgHandler = 3       // Index for Remove Msg Handler func    eRegisterMessage = 4        // Index for Register Msg    eVersionCheck = 5           // Index to get the version numbers};// some basic types used for the MsgPBlk and MsgRecElem structures.typedef char    SInt8;typedef short   SInt16;typedef long    SInt32;typedef unsigned char  UInt8;typedef unsigned short UInt16;typedef unsigned long  UInt32;typedef char __far* Ptr32;typedef struct MsgPBlk {   struct MsgPBlk*      link;       // Pointer to the next MsgPBlk.   SInt16           msgCmd;         // The message command or type   SInt32           msgParam1;      // Param 1   SInt32           msgParam2;      // Param 2   UInt32           msgCompletion;  // Ptr to the completion routine   Ptr32            msgBuffer;      // Ptr to the data buffer   SInt32           msgReqCount;    // Length of the data   SInt32           msgActCount;    // # of bytes actually transfered   SInt8            msgResult;      // The err code after complete or 1   UInt8            msgFlags;       // Not used, init to zero.   UInt32           msgUserData;    // for caller's use   UInt32           msgVXD;         // Used by VxD}MsgPBlk, *MsgPBlkPtr;typedef struct MsgRecElem {   struct MsgRecElem*     Link;   SInt32                 Code;   SInt16                 cmdBase; // the base message number for this proc   SInt16                 cmdCount;// the # of message numbers for this proc   UInt32                 userData;// for caller's use   UInt32                 recVXD; // reserved - Used by VxD}MsgRecElem, *MsgRecElemPtr;</pre>	</TD></TR></TABLE></CENTER><H3>Registering Messages with the Message System</H3><P>The process of message registration requires both the Macapplication and the PC application to be aware of a predefined set ofmessage types that are defined by the application developer. Bothapplications are aware of the data formats of these messages and knowhow to decode and use certain parts of the messages based on theirdistinct message type ID. These message types are grouped together bya message selector (4-byte value of type OSType) known to both theMac and the PC application.</P><P>Both applications send the message selector and the number ofmessage types to the message system and the message system returns a<code>cmdBaseID</code> (See Figure 1).</P><P align=center><img src="images/tn1076_002.gif" width=356 height=176 alt="Figure 1"><BR><B>Figure 1.</B> Registering a message selector and message types.</P><P>Once the set of messages for the Mac and PC applications has beenregistered with the message system, each individual message has aunique value (called a <code>msgCmd</code>) which ranges from the msgCmdBaseID tothe total number of messages - 1. When the applications send andreceive messages, they will reference particular message typesthrough the <code>msgCmdBaseID</code> plus some value which specifies the messagetype. The resulting value is the <code>msgCmd</code>.</P><H3>Registering a Message on the Mac</H3><P>To register messages on the Mac, your application must fill out a<code>SBParamBlockRec</code> make the appropriate driver call. To do this, fillout the following fields of a <code>SBParamBlockRec</code>: </P>            <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>--&gt;  ioCRefNum =         &lt;refNum of the .Symbiosis driver&gt;;--&gt;  ioVRefNum =         0;--&gt;  ioCompletion =      0;&lt;--  ioResult =          0;--&gt;  csCode =            eRegisterMessage;&lt;-&gt;   csPtr =         &lt;message selector&gt;;--&gt;  csData =            &lt;number of message types&gt;;</pre>	</TD></TR></TABLE></CENTER><P>The message selector entered in the <code>csPtr</code> field should by a 4-bytevalue of type OSType. The <code>csData</code> field should be the number ofmessage types registered.</P><P>Make the driver call using the <code>PBControlImmed</code> function. If theregistration is successful, the <code>ioResult</code> will equal <code>noErr</code> and the<code>csPtr</code> will contain a message base command (<code>msgCmdBaseID</code>) value whichis used in the message send and receive parameter blocks.</P><H3>Registering a Message on the PC</H3><P>To register a message on the PC, load the 32-bit message selectorinto the EBX register and put the number of message types in CX. Thencall INT 5Fh with AH equal to the <code>registerMessage</code> function ID (4). Onreturn from the interrupt, BX will contain a message command base IDwhich must be used in the <code>MsgPBlk</code>'s and <code>MsgRecElem</code>'s. A samplefunction called <code>MsgRegister</code>, which passes in a selector and count(number of msg types) and returns the command base ID, is shownbelow: </P>              <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>MsgRegister PROC FAR C  msgSel: DWORD, msgCount: WORD, msgCmmd: WORD   mov   ebx,msgSel             ; load EBX with the msgSelector.   mov   cx,msgCount            ; load CX with the msgCount   mov   ah,registerMessage     ; load AH with the function ID.   int   05Fh                   ; make the interrupt call.   mov   dx,bx                  ; move BX to DX.   mov   bx,msgCmmd             ; Put the address of msgCmd in BX.   mov   [bx],dx                ; Return the msgCmd value.   retMsgRegister ENDP</pre>	</TD></TR></TABLE></CENTER><H3>Sending a Message from the Mac</H3><P>For either machine to send a message to the other, a <code>MsgPBlk</code> mustbe filled out and passed to the message system. The message systemfunction for sending messages is <I>always</I> executedasynchronously, but the actual driver call is still made withPBControlImmed function and the ioCompletion field of the<code>SBParamBlockRec</code> should be set to NULL. The <code>SBParamBlockRec</code> is onlyused to send the <code>MsgPBlk</code> to the messaging system, so the completionroutine function pointer is filled in the <code>ioCompletion</code> field of the<code>MsgPBlk</code>. The <code>csPtr</code> field on the <code>SBParamBlockRec</code> should be a ptr tothe completed <code>MsgPBlk</code>.</P><P>To send a message, your application should fill out the MsgPBlk asfollows: </P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>&nbsp;--&gt;  msgCmd =            &lt;message cmdBase ID + type ID&gt;;--&gt;  msgParam1 =         &lt;any 32-bit value&gt;;--&gt;  msgParam2 =         &lt;any 32-bit value&gt;;--&gt;  msgBuffer =         &lt;pointer to a data buffer (64K max)&gt;;--&gt;  msgReqCount =       &lt;size (in bytes) of the data buffer)&gt;;&lt;--  msgActCount =       0;  // init to zero!--&gt;  msgCompletion =     &lt;pointer to completion rtn. or NULL&gt;;&lt;--  msgResult =         0;      // init to zero.--&gt;  msgFlags =          0;      // always set to zero!--&gt;  msgUserData =       &lt;any 32-bit pointer of value&gt;;</pre>	</TD></TR></TABLE></CENTER><P>The msgCmd field should contain a value equal to the messagecmdBase ID returned from the message registration function plus themessage type value for this message. If your application registered15 message types for a particular selector (for which a <code>cmdBase</code> IDwas returned), <code>cmdBaseID</code> &lt;= <code>msgCmd</code> &lt; (<code>cmdBaseID</code> + number ofmessage types). The message handler on the PC will receive the <code>msgCmd</code>and can determine the message type ID by subtracting the <code>cmdBaseID</code>from the <code>msgCmd</code>. The format and/or types of these messages arepredefined and recognizable by the applications which defined them.</P><P>The <code>msgParam1</code> and <code>msgParam2</code> fields can contain any 32-bit valuesthe sending application wishes to place in them. The receivingfunction on the PC will have access to these paramters before the<code>msgBuffer</code> is actually transferred to the PC. So these fields can beused for messages without a data block or they can be used todetermine if the receiving application wants to receive the databuffer.</P><P>The <code>MsgReqCount</code> field should contain the length (in bytes) of thedata that is contained within the <code>msgBuffer</code> block. This does not meanit should be the length of the <code>msgBuffer</code> block, only the length ofthe data you wish to send that is contained from the start of the<code>msgBuffer</code> (e.g., <code>msgReqCount</code> &lt;= size of buffer). The <code>msgActCount</code>field is filled in by the message system contains the number of bytesthat were actually sent to the PC.</P><P>The <code>msgUserData</code> is a <code>refCon</code> that can be a 32-bit value or apointer to data. This field does not get transferred to the PC, butit available for use when the completion routine gets called.</P><P>Once the message is sent, the <code>msgResult</code> field will be set to 1 tomark that the message is currently busy. Once the completion routineis called, <code>msgResult</code> will be 0 (<code>noErr</code>) or -3 (<code>msgTimeout</code>).</P><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The completion routine gets called at Deferred Tasktime and can use registers D0-D2, A0, and A1. All other registersmust be saved and restored. A0 will contain a pointer to the <code>MsgPBlk</code>.A5 must be restored and saved if access to globals are necessary andyou are coding under 68K. Use the msgUserData field hold onto your A5world.</P></TD></TR></TABLE></CENTER><BR><P>If your application is PPC Native, universal proc pointers andmixed-mode function definitions have been provided in the Messaging.hfile included in the <code>MessageTest</code> tool source code that accompaniesthis Technote. Obviously, no save and restore of global space isnecessary when running from PPC Native code.</P><H3>Sending a Message from the PC</H3><P>The <code>MsgPBlk</code> on the Mac and the <code>MsgPBlk</code> on the PC are virtuallyidentical as far as the fields of the data structure the messagingapplication must use. The PC application should build the <code>MsgPBlk</code> inthe same manner as described in the previous section and then send itthrough the message system interface on the PC.</P><P>To send a message from the PC, ES: BX should contain a far pointerto the <code>MsgPBlk</code>. AH should contain the function ID for <code>sendMessage</code>(1). Then the application should make the INT 5Fh call. The messagewill be queued and the <code>msgResult</code> field will be set to 1. Once themessage has been sent, the completion routine will be called.</P><P>Your completion routine can be done in C code as well as assembly,but you must remember to use the __loadds keyword in your functionprototype in order to have access to globals within your functionsdata segment.</P><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The completion routine specified will be called witha far call, so your completion routine must return with a RETFinstruction (if you are writing your completion routine in C, this isusually not an issue). Interrupts are also turned off when thecompletion routine is called and the function <I>should not </I>turninterrupts on for any reason. The completion routine can use the AX,BX, CX, DX, DI, SI, ES, and DS registers. When the completion routineis called ES: BX contains a pointer to the <code>MsgPBlk</code>.</P></TD></TR></TABLE></CENTER><BR><P>See the Test.c and Mesg.asm files for the PC <code>MsgTest</code> tool thataccompanies this Technote for sample code.</P><H3>Receiving a Message</H3><P>To receive a message, your application must install a messagehandler function. A message handler function must be unique to everymessage selector that has been registered with the messaging system,but is the same function for every message type that belongs to aparticular selector. In other words, if your application registers amessage selector <code>'abcd'</code> which has 15 message types associated withit, your application only has to install one message handler thatwill know how to process all 15 types of messages. The receivefunction can determine the message type by subtracting the <code>cmdBaseID</code>from the <code>msgCmd</code> value in the <code>MsgRecElem</code>.</P><P>The purpose of a message handler is to examine the <code>msgCmd</code>,<code>msgParam1</code> and <code>msgParam2</code> fields of the message that has been sent todetermine if there is any data to be retrieved from the message. Ifthere is data the receiving application wants to get, it must providea pointer to a <code>MsgPBlk</code> with space allocated for the msgBuffer fieldfor receiving the data. The <code>msgReqCount</code> field of the <code>MsgPBlk</code> shouldalso contain the number of bytes the application expects to receiveor the absolute size in bytes of the <code>msgBuffer</code> (i.e., 0 &lt;<code>msgReqCount</code> &lt;= size of msgBuffer). The messaging system will onlywrite a maximum of <code>msgReqCount</code> bytes or less of data to the <code>msgBuffer</code>block.</P><P>Once a <code>MsgPBlk</code> has been provided, the messaging system will thenretrieve the data into the <code>msgBuffer</code> field and update the <code>msgActCount</code>field of the <code>MsgPBlk</code> with the actual number of bytes transferred. If<code>msgReqCount</code> == <code>msgActCount</code>, <code>msgResult</code> equals <code>noErr</code> (0). If<code>msgReqCount</code> &lt; <code>msgActCount</code>, <code>msgResult</code> will equal -1 (<code>msgOverrun</code>).If <code>msgReqCount</code> &gt; <code>msgActCount</code>, <code>msgResult</code> will equal -2(<code>msgUnderrun</code>). If <code>msgResult</code> equals -3 (<code>msgTimeout</code>), a time out erroroccurred and the transferal of data may not be complete. After thedata has been received, the completion routine specified in the<code>MsgPBlk</code> will be called.</P><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The <code>msgBuffer</code> pointer will be advanced <code>msgActCount</code>bytes after the data transfer has been made (i.e., the pointer willpoint the end of the <code>msgBuffer</code>) and needs to be reset back to thestart of the buffer after the completion routine is called in orderto access the transfered data. This behavior is consistent for theMac and the PC.</P></TD></TR></TABLE></CENTER><BR><H3>Receiving a Message on the Mac</H3><P>To establish the ability for the Mac application to receivemessages, the <code>MsgRecElem</code> should be built and installed. Typically,this should be done before the application sends a message so it isable to receive an acknowledge from the receiving application. Builda <code>MsgRecElem</code> as follows: </P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>--&gt;  recFlags =  0;  // not used, init to zero.--&gt;  recProc =       &lt;pointer to msg receive handler function&gt;;--&gt;  recCmdBase =    &lt;cmdBaseID for this app's msg Selector&gt;;--&gt;  recCmdCount =   &lt;Number of msgTypes for this msg selector&gt;;--&gt;  recUserData =   &lt;any 32-bit value or pointer&gt;;</pre>	</TD></TR></TABLE></CENTER><P>To install the msg receive handler, build the <code>MsgRecElem</code> and thenbuild an <code>SBParamBlcokRec</code> as follows: </P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>--&gt;  ioCRefNum =         &lt;refNum of the .Symbiosis driver&gt;;--&gt;  ioVRefNum =         0;--&gt;  ioCompletion =      0;&lt;--  ioResult =          0;--&gt;  csCode =            eInstallMsgHandler ;--&gt;  csPtr =             &lt;pointer to MsgRecElem&gt;;--&gt;  csData =            0;--&gt;  csData2 =           0;</pre>	</TD></TR></TABLE></CENTER><P>Then install the msg handler by passing the built <code>SBParamBlock</code> to<code>PBControlImmed</code>.</P><P>When the Mac receives a message from the PC, the message handlerfunction pointed to by <code>recProc</code> in the <code>MsgRecElem</code> will be called. Yourhandler is called at interrupt time with interrupts masked at theslot interrupt level. When the handler is called, D0.w contains the<code>msgCmd</code>, D1 contains <code>msgParam1</code>, and D2 contains <code>msgParam2</code> from thesending applications <code>MsgPBlk</code>.</P><P>Based on these three values passed to the message handler, it mustdetermine whether there is data to be received or whether it wants toreceive the data. If the handler decides to receive the message data,it must return a pointer to a <code>MsgPBlk</code> that has an allocated <code>msgBuffer</code>and where the <code>msgReqCount</code> field is set to the number of bytes itexpects to or is able to receive (see the previous section). The<code>MsgPBlk</code> should be returned in A0. If the <code>MsgHandler</code> decides not toreceive the data, it should return 0 in A0.</P><P>The completion routine specified in the <code>MsgPBlk</code> will be calledafter the data has finished transmitting through the message system.The completion routine is called at deferred task time and can useregisters A0, A1, D0, D1, and D2. All other registers must be savedand restored. A0 will contain a pointer to the <code>MsgPBlk</code>. (Theuniversal procedure prototypes automatically handle moving the<code>MsgPBlk</code> into the function for PPC Native C functions.)</P><H3>Receiving a Message on the PC</H3><P>The process for receiving a message on the PC is much the same ason the Mac. Build a <code>MsgRecElem</code> just as was shown in the previoussection. To install the message handler, place a pointer to<code>MsgRecElem</code> in ES: BX, set AH to <code>installMsgHandler</code> (2) and call INT5Fh.</P><P>The installed message handler routine is called at interrupt timewith interrupts turned off. The AX, BX, CX, DX, SI, DI, ES, and DSregisters are available for use. When it is called, AX contains the<code>msgCmd</code> from the sending application's <code>MsgPBlk</code>. ECX contains <code>msgParam1</code>and EDX contains msgParam2 from the sending application's <code>MsgPBlk</code>.DS: DI contains a pointer to the <code>MsgRecElem</code>.</P><P>Just the same as in the Mac message handler, the PC messagehandler must determine whether there is data to be received orwhether it wants to receive the data in the message. If it does, itmust return a pointer to a MsgPBlk in ES: BX, otherwise it should setES: BX to NULL.</P><P>After the data has been received by the PC, the completion routinespecified in the <code>MsgPBlk</code> will be called. ES: BX will contain thepointer the <code>MsgPBlk</code> and the function can use the AX, BX, CX, DX, DI,SI, ES, and DS registers. All other registers must be saved andrestored.</P><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Both the message handling routine and the completionroutine are called at interrupt time with interrupts turned off. Bothfunctions should adhere to any rules of execution during interrupttime for a PC system and <I>should not </I>at any time turninterrupts back on.</P></TD></TR></TABLE></CENTER><BR><H3>Removing the Message Handlers</H3><P>Message handlers must be removed when applications that installedthem are no longer active. If the message handler is not removed, themessaging system could attempt to call the handler again. If theapplication has been terminated, it's a good bet that both the PC andMac will crash.</P><P>To remove a message handler on the Mac, create a <code>SBParamBlockRec</code>and specify the <code>eRemoveMsgHandler</code> function code for the csCode. The<code>csPtr</code> field would be a pointer to the <code>MsgRecElem</code> that was used toinstall the message handler. Pass the <code>SBParamBlockRec</code> to themessaging system using a <code>PBControl</code> call.</P><P>To remove a message handler on the PC, set the AH register to<code>removeMsgHandler</code> (3), set ES: BX to a pointer to the <code>MsgRecElem</code> usedto install the handler, and make an INT 5Fh call.</P><H3>Advanced Messaging System Techniques</H3><P>As described in the <CITE>Basic Messaging Concepts</CITE> sectionof this Technote, the goal here is introduce developers to simplemethods of performing Mac &lt;--&gt; PC communication using the PCCompatibility Card's messaging system interface. That basic level ofcommunications means two applications send information to each onemessage at a time (i.e., the sending application does not send asecond message to a receiving application until the receivingapplication has acknowledged it actually received the data of thesent message). Some applications may have a need to send multiplethreads of messages back and forth before awaiting a reply, however.The good news is that this can be done. The bad news is that thedeveloper is responsible for managing all of the message types andbasic send/acknowledge protocols the applications should adhere to.</P><P>This management of messages is primarily performed in the messagehandler function which would be required to maintain a list of<code>MsgPBlk</code>'s to grab all of the data being sent in. The only limit beinghow much memory the application can allocate to hold on to thisincoming data and how well the message parameters and data aredefined so acknowledging messages can be adequately returned to thesending application.</P><P align=center><img src="images/tn1076_003.gif" width=395 height=315 alt="Figure 2"><BR><B>Figure 2.</B> Basic data flow for multiple messagecommunication.</P><P>As shown in Figure 2, a message installer can install a <code>MsgRecElem</code>and some number of n <code>MsgPBlk</code>'s with <code>msgBuffer</code>'s allocated. When the<code>MsgHandler</code> is called, it searches the list for an available <code>MsgPBlk</code>(one in which the <code>msgResult</code> field &lt;= 0, and the <code>msgActCount</code> = 0,so it knows the <code>msgBuffer</code> is empty) and returns it to the messagingsystem. Each <code>MsgPBlk</code> may have its own completion routine (if, forinstance, one type of <code>MsgPBlk</code> was to be used for a specific messagetype) or can use one particular completion routine. So the number ofcompletion routines &lt;= the number of <code>MsgPBlk</code>'s in the list.</P><P>After a <code>MsgPBlk</code>'s completion routine is called, it can handle thedata in any method needed, but then needs to notify the applicationthat the data is ready. Either the <code>msgBuffer</code> needs to be detachedfrom the <code>MsgPBlk</code> (and a new buffer attached) or the application musthave some way of marking the <code>MsgPBlk</code> as busy until the applicationcan retrieve and process the data. The <code>MsgPBlk</code> can then be reset andthe <code>MsgHandler</code> can use it again for other incoming messages.</P><P>The application message handler is then responsible for sendingthe acknowledge message back to the sending application after it hasverified the length and/or quality of the data.</P><P>What is described here is one possible methodology for handlingmultiple message communication. Simpler methods or more complexmethods may be needed based on the complexity of data to beexchanged. The level of this complexity is left to the developer,however. As long as the basic criteria are met as to when themessaging system has access to the <code>paramBlock</code>'s and when theapplication has access to them, any system should work.</P><P>Similar messaging algorithms should be maintained for both the Macand the PC applications that communicate information. Alltransactions between the Mac and the PC are made asynchronously atinterrupt time.</P><H3>Limitations</H3><P>As stated earlier, the messaging system is capable of sendingindividual data packets of up to 64K. All data transfers between theMac and the PC occur at interrupt time. This can sometimes have aneffect on other software that may rely on processing data duringinterrupt time. Therefore, it is highly recommended that if softwaredesigned to use this messaging system requires transmission of largeblocks of data, the packet size used for each message sent should bereduced.</P><P>There is no absolute rule to follow here and the effect on otherinterrupt dependent software running at the same time as the datapackets being transmitted to and from the PC Compatibility Card alsodepends on the capability of the hardware being used. As a generalrule, however, it is advised that if the software being developedneeds to transmit more than 1 MB of data at any particular time, themessage packet size should be reduced to 32K or 16K. This will allowinterrupts to not be turned off for as long a period of time toprocess the data transfers and allow other interrupts to execute andcatch up.</P><P><A HREF="#top">Back to top</A></P><A NAME="RTFToC4"></A><H2>Summary of the Messaging System</H2><P><B>Note: </B>All of the Macintosh constants, data types, universalprocedure pointers, and universal procedure definitions can be foundin the "Messaging.h" file in <code>MacMsgTest</code> tool that accompanies thistechnote.</P><H3>Constants (Mac)</H3><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>#define kDriverName "\p.Symbiosis"  // The name of the driverenum {    eSendMessage            = 800,      // Send a message    eInstallMsgHandler      = 801,      // Install a message handler    eRemoveMsgHandler       = 802,      // Remove message handler    eRegisterMessage        = 803       // Register message type};enum {    msgNoError      = 0,            // No error    msgOverrun      = -1,           // More data was available    msgUnderrun     = -2,           // Less data was available    msgTimeout      = -3            // Timeout error};Data Types (Mac)typedef struct {    QElemPtr    qLink;    SInt16      qType;    SInt16      ioTrap;    Ptr         ioCmdAddr;    ProcPtr     ioCompletion;           // always NULL    OSErr       ioResult;               // error result info.    StringPtr   ioNamePtr;    SInt16      ioVRefNum;    SInt16      ioCRefNum;              // refNum of Symbiosis driver.    SInt16      csCode;                 // messaging system function    void *      csPtr;                  // pointer to procedure or data    SInt32      csData;                 // data    SInt32      csData2;                // data}SBParamBlockRec, *SBParamBlockRecPtr;typedef struct MsgPBlk {    struct MsgPBlk* msgQLink;           // Pointer to next MsgPBlk    SInt16              msgQType;       // Queue Flags    SInt16              msgCmd;         // The message type or command    SInt32              msgParam1;      // Message parameter 1    SInt32              msgParam2;      // Message parameter 2    void*               msgBuffer;      // Ptr to the msg data buffer    SInt32              msgReqCount;    // Requested data length    SInt32              msgActCount;    // Actual data length    MsgCompletionUPP    msgCompletion;  // Ptr to comp. rtn. or NULL    SInt16              msgResult;      // The result of msg operation    UInt16              msgFlags;       // Message flags    UInt32              msgUserData;    // refCon (a5, etc)}MsgPBlk, *MsgPBlkPtr;typedef struct MsgRecElem {    struct MsgRecElem*  recQLink;           // Next queue element    SInt16                  recQType;       // queue flags    SInt16                  recFlags;       // Not used...Set to zero    MsgReceiveUPP           recProc;        // Ptr to the receive proc.    SInt16                  recCmdBase;     // Msg Selector base.    SInt16                  recCmdCount;    // # of msgTypes    UInt32                  recUserData;    // refCon (could be A5...)}MsgRecElem, *MsgRecElemPtr;</pre>	</TD></TR></TABLE></CENTER><H3>Universal ProcPtr and Procedure Definitions</H3><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>#if GENERATINGCFMtypedef UniversalProcPtr MsgCompletionUPP;typedef UniversalProcPtr MsgReceiveUPP;#elsetypedef ProcPtr MsgCompletionUPP;typedef ProcPtr MsgReceiveUPP;#endifenum {    uppMsgReceiveProcInfo = kRegisterBased        | REGISTER_ROUTINE_PARAMETER(1, kRegisterA1,                                    SIZE_CODE(sizeof(MsgRecElemPtr)))        | REGISTER_ROUTINE_PARAMETER(2, kRegisterD0, SIZE_CODE(sizeof(short)))        | REGISTER_ROUTINE_PARAMETER(3, kRegisterD1, SIZE_CODE(sizeof(long)))        | REGISTER_ROUTINE_PARAMETER(4, kRegisterD2, SIZE_CODE(sizeof(long)))        | REGISTER_RESULT_LOCATION(kRegisterA0)        | RESULT_SIZE(kFourByteCode),    uppMsgCompletionProcInfo = kRegisterBased        | REGISTER_ROUTINE_PARAMETER(1, kRegisterA0,                                     SIZE_CODE(sizeof(MsgPBlkPtr)))        | REGISTER_RESULT_LOCATION(kRegisterA0)        | RESULT_SIZE(kFourByteCode)};#if GENERATINGCFM#define NewMsgReceiveProc(userRoutine) \        (MsgReceiveUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), \                                         uppMsgReceiveProcInfo, \                                         GetCurrentArchitecture())#else#define NewMsgReceiveProc(userRoutine) \        ((MsgReceiveUPP) (userRoutine))#endif#if GENERATINGCFM#define NewMsgCompletionProc(userRoutine) \        (MsgCompletionUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), \                                            uppMsgCompletionProcInfo, \                                            GetCurrentArchitecture())#else#define NewMsgCompletionProc(userRoutine) \        ((MsgCompletionUPP) (userRoutine))#endif</pre>	</TD></TR></TABLE></CENTER><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>All of the PC constants and data types for assemblylanguage programming can be found in the "PCMesg.inc" file that ispart of the <code>PCMsgTst</code> tool that accompanies this Technote. Constantsand data types for C programming can be found in the PCMesg.h filethat is included.</P></TD></TR></TABLE></CENTER><BR><H3>Constants (PC)</H3><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>enum {    eIsAvailable = 0            // Index for is available    eSendMessage = 1            // Index for Send func    eInstallMsgHandler = 2      // Index for Install Msg Handler func    eRemoveMsgHandler = 3       // Index for Remove Msg Handler func    eRegisterMessage = 4        // Index for Register Msg    eVersionCheck = 5           // Index to get the version numbers};</pre>	</TD></TR></TABLE></CENTER><H3>Data Types (PC)</H3><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>// some basic types used for the MsgPBlk and MsgRecElem structures.typedef char    SInt8;typedef short   SInt16;typedef long    SInt32;typedef unsigned char  UInt8;typedef unsigned short UInt16;typedef unsigned long  UInt32;typedef char __far* Ptr32;typedef struct MsgPBlk {   struct MsgPBlk*      link;       // Pointer to the next MsgPBlk.   SInt16           msgCmd;         // The message command or type   SInt32           msgParam1;      // Param 1   SInt32           msgParam2;      // Param 2   UInt32           msgCompletion;  // Ptr to the completion routine   Ptr32            msgBuffer;      // Ptr to the data buffer   SInt32           msgReqCount;    // Length of the data   SInt32           msgActCount;    // # of bytes actually transfered   SInt8            msgResult;      // The err code after complete or 1   UInt8            msgFlags;       // Not used, init to zero.   UInt32           msgUserData;    // for caller's use   UInt32           msgVXD;         // Used by VxD}MsgPBlk, *MsgPBlkPtr;typedef struct MsgRecElem {   struct MsgRecElem*   Link;   SInt32                   Code;   SInt16               cmdBase;   // the base message number for this proc   SInt16               cmdCount;  // the # of message numbers for this proc   UInt32               userData;  // for caller's use   UInt32               recVXD;    // reserved - Used by VxD}MsgRecElem, *MsgRecElemPtr;</pre>	</TD></TR></TABLE></CENTER><P><A HREF="#top">Back to top</A></P><A NAME="RTFToC5"></A><H2>Summary</H2><P>The Messaging System Architecture described in this Technote iscompatible with the PC Compatibility Software v1.5 or later, which isinstallable on all DOS Compatible and PC Compatible products shippedby Apple. This includes the Centris 610 DOS Compatible, the Quadra630 DOS Compatible, the PowerMac 6100 DOS Compatible, the 7200 PCCompatible, and all PCI based Macintoshes which support the 12" 100MHz Pentium and 7" 100MHz Cyrix 5x86 PC Compatibility Cards.</p><P>Future releases of the PC Compatibility Software may havemodifications to Messaging System Architectures that will requireupdates of the software Interface described in this Technote.</P> <H3>The MacMsgTest and PCMsgTst Tools</H3><P>This Technote is accompanied by two tools, one for the Mac and onefor the PC, that perform very simple messaging. MacMsgTest is writtenentirely in C and is designed and compiled to run PPC Native.PCMsgTst is written in C and x86 assembly. Source code, header files,and makefiles are included for each tool. The necessary buildenvironments are not included.</P><P>The tools are available on Apple's Developer web site(<A HREF = "http://www.developer.apple.com/">http://www.developer.apple.com/</A>)and on the Developer CD. Please see each tool's individual ReadMefiles for further information on executing and building MacMsgTestand PCMsgTst.</P><P><A HREF="#top">Back to top</A></p> <A NAME=Downloads></A>                  <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="500">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (240K)</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/tn1076.pdf">Download</A></P>               </TD>            </TR>             <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/bluebook.gif" width=22 height=23 align=bottom alt="Bluebook gif"></P>               </TD>               <td align="left">                  <P>MsgTest Folder (110K)</P>               </TD>               <td width=60 align=left>                  <P><A HREF="downloads/tn_1076.1.hqx">Download</A></P>               </TD>            </TR></TABLE><P><A HREF="#top">Back to top</A></P></TD></TR></table></center><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1076.html%3Fid%3DDTS10002917-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1076.html%3Fid%3DDTS10002917-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1076.html%3Fid%3DDTS10002917-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>