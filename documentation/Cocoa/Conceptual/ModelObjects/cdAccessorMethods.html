<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Model Object Implementation Guide: Managed Object Accessor Methods</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Managed Object Accessor Methods"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="toc.html"/>
	<meta id="RESOURCES" content="../../../Resources" />
	<meta name="ROBOTS" content="NOINDEX"/>
	<link rel="stylesheet" type="text/css" href="../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40002154" title="Managed Object Accessor Methods"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../DesignGuidelines-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000556" target="_top">Design Guidelines</a> &gt; <a href="index.html" target="_top">Model Object Implementation Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="Articles/moAccessorMethods.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="Articles/moIntegrating.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>
        
        
        <a name="//apple_ref/doc/uid/TP40002154-SW1" title="Managed Object Accessor Methods"></a><hr /><H1>Managed Object Accessor Methods</H1><p>This article explains why you might want to implement custom accessor methods for managed objects, and how to implement them for attributes and for relationships. It also illustrates how to implement primitive accessor methods. </p>
<!-- This template is being used for both PDF and HTML. -->

    
    <!-- TopicBook.pm uses this template for its miniTOCs, but needs a different title. -->
    <h4>Contents:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="cdAccessorMethods.html#//apple_ref/doc/uid/TP40002154-SW10">Overview</a>
				
			<br/>
			
        
			
			
				<a href="cdAccessorMethods.html#//apple_ref/doc/uid/TP40002154-SW9">Dynamically-Generated Accessor Methods</a>
				
			<br/>
			
        
			
			
				<a href="cdAccessorMethods.html#//apple_ref/doc/uid/TP40002154-SW14">Custom Attribute and To-One Relationship Accessor Methods</a>
				
			<br/>
			
        
			
			
				<a href="cdAccessorMethods.html#//apple_ref/doc/uid/TP40002154-SW6">Custom To-Many Relationship Accessor Methods</a>
				
			<br/>
			
        
			
			
				<a href="cdAccessorMethods.html#//apple_ref/doc/uid/TP40002154-SW5">Custom Primitive Accessor Methods</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40002154-SW10" title="Overview"></a><h2>Overview</h2><p>On Mac OS X v10.5, Core Data dynamically generates efficient public and primitive get and set attribute accessor methods and relationship accessor methods for managed object classes. Typically, therefore, there’s no need to for you to write accessor methods for properties that are defined in the entity of a managed object’s corresponding managed object model—although you may use the  Objective-C 2 properties feature to declare properties to suppress compiler warnings. To get the best performance—and to benefit from type-checking—you use the accessor methods directly, although they are also key-value coding (KVC) compliant so if necessary you can use standard key-value coding methods such as <code><a href="../../Reference/Foundation/Protocols/NSKeyValueCoding_Protocol/Reference/Reference.html#//apple_ref/occ/instm/NSObject/valueForKey:" target="_top">valueForKey:</a></code>. You do need to write custom accessor methods if you use transient properties to support non-standard data types (see “Non-Standard Persistent Attributes” in <em><a href="../CoreData/index.html#//apple_ref/doc/uid/TP40001075" target="_top">Core Data Programming Guide</a></em>) or if you use scalar instance variables to represent an attribute.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002154-SW16" title="Mac OS X v10.4"></a><p><strong>Mac OS X v10.4:</strong>&nbsp;This article describes accessor methods for Mac OS X v10.5; if you are using Mac OS X v10.4, see “Mac OS X v10.4: Managed Object Accessor Methods” in <em><a href="../CoreData/index.html#//apple_ref/doc/uid/TP40001075" target="_top">Core Data Programming Guide</a></em>.</p></div><a name="//apple_ref/doc/uid/TP40002154-SW15" title="Custom implementation"></a><h3>Custom implementation</h3><p>The implementation of accessor methods you write for subclasses of <code>NSManagedObject</code> is typically different from those you write for other classes.</p><ul class="spaceabove"><li class="li"><p>If you do not provide custom instance variables, you retrieve property values from and save values into the internal store using primitive accessor methods. </p></li><li class="li"><p>You must ensure that you invoke the relevant access and change notification methods (<code><a href="../../Reference/CoreDataFramework/Classes/NSManagedObject_Class/Reference/NSManagedObject.html#//apple_ref/occ/instm/NSManagedObject/willAccessValueForKey:" target="_top">willAccessValueForKey:</a></code>, <code><a href="../../Reference/CoreDataFramework/Classes/NSManagedObject_Class/Reference/NSManagedObject.html#//apple_ref/occ/instm/NSManagedObject/didAccessValueForKey:" target="_top">didAccessValueForKey:</a></code>, <code><a href="../../Reference/Foundation/Protocols/NSKeyValueObserving_Protocol/Reference/Reference.html#//apple_ref/occ/instm/NSObject/willChangeValueForKey:" target="_top">willChangeValueForKey:</a></code>, <code><a href="../../Reference/Foundation/Protocols/NSKeyValueObserving_Protocol/Reference/Reference.html#//apple_ref/occ/instm/NSObject/didChangeValueForKey:" target="_top">didChangeValueForKey:</a></code>, <code><a href="../../Reference/Foundation/Protocols/NSKeyValueObserving_Protocol/Reference/Reference.html#//apple_ref/occ/instm/NSObject/willChangeValueForKey:withSetMutation:usingObjects:" target="_top">willChangeValueForKey:withSetMutation:usingObjects:</a></code>, and <code><a href="../../Reference/Foundation/Protocols/NSKeyValueObserving_Protocol/Reference/Reference.html#//apple_ref/occ/instm/NSObject/didChangeValueForKey:" target="_top">didChangeValueForKey:</a></code>).</p><p><code>NSManagedObject</code> disables automatic key-value observing (KVO, see <em><a href="../KeyValueObserving/index.html#//apple_ref/doc/uid/10000177i" target="_top">Key-Value Observing Programming Guide</a></em>) change notifications, and the primitive accessor methods do not invoke the access and change notification methods.</p></li><li class="li"><p>In accessor methods for properties that are <em>not</em> defined in the entity model, you can either enable automatic change notifications or invoke the appropriate change notification methods.</p></li></ul><p>You can use the Xcode data modeling tool to generate the code for accessor methods for any modeled property.</p><a name="//apple_ref/doc/uid/TP40002154-SW13" title="Key-value coding access pattern"></a><h3>Key-value coding access pattern</h3><p>The access pattern key-value coding uses for managed objects is largely the same as that used for subclasses of <code>NSObject</code>—see <code><a href="../../Reference/Foundation/Protocols/NSKeyValueCoding_Protocol/Reference/Reference.html#//apple_ref/occ/instm/NSObject/valueForKey:" target="_top">valueForKey:</a></code>. The difference is that, if after checking the normal resolutions <code>valueForKey:</code> would throw an unbound key exception, the key-value coding mechanism for <code>NSManagedObject</code> checks whether the key is a modeled property. If the key matches an entity's property, the mechanism looks first for an accessor method of the form <code>primitive</code><em>Key</em>, and if that is not found then looks for a value for <em>key</em> in the managed object's internal storage. If these fail, <code>NSManagedObject</code> throws an unbound key exception (just like <code>valueForKey:</code>). </p><a name="//apple_ref/doc/uid/TP40002154-SW9" title="Dynamically-Generated Accessor Methods"></a><h2>Dynamically-Generated Accessor Methods</h2><p>By default, Core Data dynamically creates efficient public and primitive get and set accessor methods for modeled properties (attributes <em>and</em> relationships) of managed object classes. This includes the key-value coding mutable proxy methods such as <code>add&lt;Key>Object:</code> and <code>remove&lt;Key>s:</code>, as detailed in the documentation for <code><a href="../../Reference/Foundation/Protocols/NSKeyValueCoding_Protocol/Reference/Reference.html#//apple_ref/occ/instm/NSObject/mutableSetValueForKey:" target="_top">mutableSetValueForKey:</a></code>—managed objects are effectively mutable proxies for all their to-many relationships.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002154-SW17" title="Note"></a><p><strong>Note:</strong>&nbsp;If you choose to implement your own accessors, the dynamically-generated methods never replace your own code.</p></div><p>For example, given an entity with an attribute <code>firstName</code>, Core Data automatically generates <code>firstName</code>, <code>setFirstName:</code>, <code>primitiveFirstName</code>, and <code>setPrimitiveFirstName:</code>. <em>Core Data does this even for entities represented by</em>  <code>NSManagedObject</code>. To suppress compiler warnings when you invoke these methods, you should use the Objective-C 2.0 declared properties feature (see <span class="content_text"><a href="../ObjectiveC/Articles/ocProperties.html#//apple_ref/doc/uid/TP30001163-CH17" target="_top">Declared Properties</a></span>), as described in <span class="content_text"><a href="cdAccessorMethods.html#//apple_ref/doc/uid/TP40002154-SW7">“Declaration.”</a></span></p><p>The property accessor methods Core Data generates are by default <code>(nonatomic, retain)</code>—<em>this is the recommended configuration</em>. The methods are <code>nonatomic</code> because non-atomic accessors are more efficient than atomic accessors, and in general it is not possible to assure thread safety in a Core Data application at the level of accessor methods. (To understand how to use Core Data in a multi-threaded environment, see <span class="content_text"><a href="../CoreData/Articles/cdMultiThreading.html#//apple_ref/doc/uid/TP40003385" target="_top">Multi-Threading with Core Data</a></span>.)</p><p>In addition to always being <code>nonatomic</code>, dynamic properties only honor <code>retain</code> or <code>copy</code> attributes—<code>assign</code> is treated as <code>retain</code>. You should use <code>copy</code> sparingly as it increases overhead. You cannot use <code>copy</code> for relationships because <code>NSManagedObject</code> does not adopt the <code>NSCopying</code> protocol, and it's irrelevant to the behavior of to-many relationships.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40002154-DontLinkElementID_8" title="Important:"></a><p><strong>Important:</strong>&nbsp;If you specify <code>copy</code> for a to-one relationship, you will generate a <em>run-time</em> error.</p><p></p></div><a name="//apple_ref/doc/uid/TP40002154-SW7" title="Declaration"></a><h3>Declaration</h3><p>You can use Objective-C 2 properties to declare properties of managed object classes—you typically do this so that you can use the default accessors Core Data provides without generating compiler warnings. <em>The easiest way to generate the declarations is to select the relationship in the Xcode modeling tool and choose Design > Data Model > Copy Obj-C 2.0 Method Declarations to Clipboard.</em> and then modify the code if necessary.</p><p>You declare attributes and relationships as you would properties for any other object, as illustrated in the following example. When you declare a to-many relationship, the property type should be <code>NSSet *</code>. (The value returned from the get accessor is <em>not</em> a KVO-compliant mutable proxy—for more details, see “To-many relationships” in <em><a href="../CoreData/index.html#//apple_ref/doc/uid/TP40001075" target="_top">Core Data Programming Guide</a></em>.) </p><div class="codesample"><table><tr><td scope="row"><pre>@interface Employee : NSManagedObject<span></span></pre></td></tr><tr><td scope="row"><pre>{ }<span></span></pre></td></tr><tr><td scope="row"><pre>@property(nonatomic, retain) NSString* firstName, lastName;<span></span></pre></td></tr><tr><td scope="row"><pre>@property(nonatomic, retain) Department* department;<span></span></pre></td></tr><tr><td scope="row"><pre>@property(nonatomic, retain) Employee* manager;<span></span></pre></td></tr><tr><td scope="row"><pre>@property(nonatomic, retain) NSSet* directReports;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>If you are not using a custom class, you can declare properties in a category of <code>NSManagedObject</code>:</p><div class="codesample"><table><tr><td scope="row"><pre>@interface NSManagedObject (EmployeeAccessors)<span></span></pre></td></tr><tr><td scope="row"><pre>{ }<span></span></pre></td></tr><tr><td scope="row"><pre>@property(nonatomic, retain) NSString* firstName, lastName;<span></span></pre></td></tr><tr><td scope="row"><pre>@property(nonatomic, retain) Department* department;<span></span></pre></td></tr><tr><td scope="row"><pre>@property(nonatomic, retain) Employee* manager;<span></span></pre></td></tr><tr><td scope="row"><pre>@property(nonatomic, retain) NSSet* directReports;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>You can use the same techniques to suppress compiler warnings for the automatically-generated to-many relationship mutator methods, for example: </p><div class="codesample"><table><tr><td scope="row"><pre>@interface Employee (DirectReportsAccessors)<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)addDirectReportsObject:(Employee *)value;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)removeDirectReportsObject:(Employee *)value;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)addDirectReports:(NSSet *)value;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)removeDirectReports:(NSSet *)value;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>You typically retain attributes, although to preserve encapsulation where the attribute class has a mutable subclass and it implements the <code><a href="../../Reference/Foundation/Protocols/NSCopying_Protocol/Reference/Reference.html#//apple_ref/occ/intf/NSCopying" target="_top">NSCopying</a></code> protocol you can also use <code>copy</code>, for example:</p><div class="codesample"><table><tr><td scope="row"><pre>@property(nonatomic, copy) NSString* firstName, lastName;<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002154-SW11" title="Implementation"></a><h3>Implementation</h3><p>You can specify an implementation using the <code>@dynamic</code> keyword, as shown in the following example—although since <code>@dynamic</code> is the default, there is no need to do so:</p><div class="codesample"><table><tr><td scope="row"><pre>@dynamic firstName, lastName;<span></span></pre></td></tr><tr><td scope="row"><pre>@dynamic department, manager;<span></span></pre></td></tr><tr><td scope="row"><pre>@dynamic directReports;<span></span></pre></td></tr></table></div><p>There should typically be no need for you to provide your own implementation of these methods, unless you want to support scalar values. The methods that Core Data generates at runtime are more efficient than those you can implement yourself.</p><a name="//apple_ref/doc/uid/TP40002154-SW12" title="Inheritance"></a><h3>Inheritance</h3><p>If you have two subclasses of <code>NSManagedObject</code> where the parent class implements a dynamic property and its subclass (the grandchild of <code>NSManagedObject</code>) overrides the methods for the property, those overrides cannot call <code>super</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>@interface Parent : NSManagedObject<span></span></pre></td></tr><tr><td scope="row"><pre>@property(nonatomic, retain) NSString* parentString;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@implementation Parent<span></span></pre></td></tr><tr><td scope="row"><pre>@dynamic parentString;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@interface Child : Parent<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@implementation Child<span></span></pre></td></tr><tr><td scope="row"><pre>- (NSString *)parentString<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // this throws a "selector not found" exception<span></span></pre></td></tr><tr><td scope="row"><pre>    return parentString.foo;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div>	<a name="//apple_ref/doc/uid/TP40002154-SW14" title="Custom Attribute and To-One Relationship Accessor Methods"></a><h2>Custom Attribute and To-One Relationship Accessor Methods</h2><div class="importantbox"><a name="//apple_ref/doc/uid/TP40002154-DontLinkElementID_9" title="Important:"></a><p><strong>Important:</strong>&nbsp;You are strongly encouraged to use dynamic properties (that is, properties whose implementation you specify as <code>@dynamic</code>) instead of creating custom implementations for standard or primitive accessor methods. </p><p></p></div><p>If you want to implement your own attribute or to-one relationship accessor methods, you use the primitive accessor methods to get and set values from and to the managed object's private internal store. You must invoke the relevant access and change notification methods, as illustrated in <span class="content_text"><a href="cdAccessorMethods.html#//apple_ref/doc/uid/TP40002154-SW2">Listing 1</a></span>. <code>NSManagedObject</code>'s implementation of the primitive set accessor method handles memory management for you. </p><a name="//apple_ref/doc/uid/TP40002154-SW2" title="Listing 1Implementation of a custom managed object class illustrating attribute accessor methods"></a><p class="codesample"><strong>Listing 1&nbsp;&nbsp;</strong>Implementation of a custom managed object class illustrating attribute accessor methods</p><div class="codesample"><table><tr><td scope="row"><pre>@interface Department : NSManagedObject<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@property(nonatomic, retain) NSString *name;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@interface Department (PrimitiveAccessors)<span></span></pre></td></tr><tr><td scope="row"><pre>- (NSString *)primitiveName;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setPrimitiveName:(NSString *)newName;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@implementation Department<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@dynamic name;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (NSString *)name<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [self willAccessValueForKey:@"name"];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSString *myName = [self primitiveName];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self didAccessValueForKey:@"name"];<span></span></pre></td></tr><tr><td scope="row"><pre>    return myName;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setName:(NSString *)newName<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [self willChangeValueForKey:@"name"];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self setPrimitiveName:newName];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self didChangeValueForKey:@"name"];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>The default implementation does not copy attribute values. If the attribute value may be mutable and implements the <code>NSCopying</code> protocol (as is the case with <code>NSString</code>, for example), you can copy the value in a custom accessor to help preserve encapsulation (for example, in the case where an instance of <code>NSMutableString</code> is passed as a value). This is illustrated in <span class="content_text"><a href="cdAccessorMethods.html#//apple_ref/doc/uid/TP40002154-SW8">Listing 2</a></span>. Notice also that (for the purposes of illustration) in this example the get accessor is not implemented—since it’s not implemented, Core Data will generate it automatically.</p><a name="//apple_ref/doc/uid/TP40002154-SW8" title="Listing 2Implementation of a custom managed object class illustrating copying setter"></a><p class="codesample"><strong>Listing 2&nbsp;&nbsp;</strong>Implementation of a custom managed object class illustrating copying setter</p><div class="codesample"><table><tr><td scope="row"><pre>@interface Department : NSManagedObject<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@property(nonatomic, copy) NSString *name;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@implementation Department<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@dynamic name;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setName:(NSString *)newName<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [self willChangeValueForKey:@"name"];<span></span></pre></td></tr><tr><td scope="row"><pre>    // NSString implements NSCopying, so copy the attribute value<span></span></pre></td></tr><tr><td scope="row"><pre>    NSString *newNameCopy = [newName copy];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self setPrimitiveName:newNameCopy];<span></span></pre></td></tr><tr><td scope="row"><pre>    [newNameCopy release];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self didChangeValueForKey:@"name"];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>If you choose to represent an attribute using a scalar type (such as <code>NSInteger</code> or <code>CGFloat</code>), or as one of the structures supported by <code>NSKeyValueCoding</code> (<code>NSRect</code>, <code>NSPoint</code>, <code>NSSize</code>, <code>NSRange</code>), then you should implement accessor methods as illustrated in <span class="content_text"><a href="cdAccessorMethods.html#//apple_ref/doc/uid/TP40002154-SW3">Listing 3</a></span>. If you want to use any other attribute type, then you should use a different pattern, described in <span class="content_text"><a href="../CoreData/Articles/cdNSAttributes.html#//apple_ref/doc/uid/TP40001919" target="_top">Non-Standard Persistent Attributes</a></span>.</p><a name="//apple_ref/doc/uid/TP40002154-SW3" title="Listing 3Implementation of a custom managed object class illustrating a scalar attribute value"></a><p class="codesample"><strong>Listing 3&nbsp;&nbsp;</strong>Implementation of a custom managed object class illustrating a scalar attribute value</p><div class="codesample"><table><tr><td scope="row"><pre>@interface Circle : NSManagedObject<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CGFloat radius;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@property CGFloat radius;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@implementation Circle<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (CGFloat)radius<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [self willAccessValueForKey:@"radius"];<span></span></pre></td></tr><tr><td scope="row"><pre>    float f = radius;<span></span></pre></td></tr><tr><td scope="row"><pre>    [self didAccessValueForKey:@"radius"];<span></span></pre></td></tr><tr><td scope="row"><pre>    return f;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setRadius:(CGFloat)newRadius<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [self willChangeValueForKey:@"radius"];<span></span></pre></td></tr><tr><td scope="row"><pre>    radius = newRadius;<span></span></pre></td></tr><tr><td scope="row"><pre>    [self didChangeValueForKey:@"radius"];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002154-SW6" title="Custom To-Many Relationship Accessor Methods"></a><h2>Custom To-Many Relationship Accessor Methods</h2><div class="importantbox"><a name="//apple_ref/doc/uid/TP40002154-DontLinkElementID_10" title="Important:"></a><p><strong>Important:</strong>&nbsp;You are strongly encouraged to use dynamic properties (that is, properties whose implementation you specify as <code>@dynamic</code>) instead of creating custom implementations for standard or primitive accessor methods. </p><p></p></div><p>You usually access to-many relationships using <code><a href="../../Reference/Foundation/Protocols/NSKeyValueCoding_Protocol/Reference/Reference.html#//apple_ref/occ/instm/NSObject/mutableSetValueForKey:" target="_top">mutableSetValueForKey:</a></code>, which returns a proxy object that both mutates the relationship and sends appropriate key-value observing notifications for you. There should typically be little reason to implement your own collection accessor methods for to-many relationships. If they are present, however, the framework calls the mutator methods (such as <code>add&lt;Key>Object:</code> and <code>remove&lt;Key>Object:</code>) when modifying a collection that represents a persistent relationship. (Note that fetched properties do not support the mutable collection accessor methods.) In order for this to work correctly, you must implement an <code>add&lt;Key>Object:</code>/<code>remove&lt;Key>Object:</code> pair, an <code>add&lt;Key>:</code>/<code>remove&lt;Key>:</code> pair, or both pairs. You may also implement other get accessors (such as <code>countOf&lt;Key>:</code>, <code>enumeratorOf&lt;Key>:</code>, and <code>memberOf&lt;Key>:</code>) and use these in your own code, however these are not guaranteed to be called by the framework.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40002154-DontLinkElementID_11" title="Important:"></a><p><strong>Important:</strong>&nbsp;For performance reasons, the proxy object returned by managed objects for <code>mutableSetValueForKey:</code> does not support <code>set&lt;Key>:</code> style setters for relationships. For example, if you have a to-many relationship <code>employees</code> of a Department class and implement accessor methods <code>employees</code> and <code>setEmployees:</code>, then manipulate the relationship using the proxy object returned by <code>mutableSetValueForKey:@"employees"</code>,  <code>setEmployees:</code> is <em>not</em> invoked. You should implement the other mutable proxy accessor overrides instead.</p><p></p></div><p>If you do implement collection accessors for model properties, they must invoke the relevant KVO notification methods. <span class="content_text"><a href="cdAccessorMethods.html#//apple_ref/doc/uid/TP40002154-SW4">Listing 4</a></span> illustrates the implementation of accessor methods for a to-many relationship—<code>employees</code>—of a Department class. <em>The easiest way to generate the implementation is to select the relationship in the Xcode modeling tool and choose Design > Data Model > Copy Obj-C 2.0 Method {Declarations/Implementations} to Clipboard.</em></p><a name="//apple_ref/doc/uid/TP40002154-SW4" title="Listing 4A managed object class illustrating implementation of custom accessors for a to-many relationship"></a><p class="codesample"><strong>Listing 4&nbsp;&nbsp;</strong>A managed object class illustrating implementation of custom accessors for a to-many relationship</p><div class="codesample"><table><tr><td scope="row"><pre>@interface Department : NSManagedObject<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@property (nonatomic, retain) NSString * name;<span></span></pre></td></tr><tr><td scope="row"><pre>@property (nonatomic, retain) NSSet *employees;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@interface Department (DirectReportsAccessors)<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)addEmployeesObject:(Employee *)value;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)removeEmployeesObject:(Employee *)value;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)addEmployees:(NSSet *)value;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)removeEmployees:(NSSet *)value;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (NSMutableSet*)primitiveEmployees;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setPrimitiveEmployees:(NSMutableSet*)value;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@implementation Department<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@dynamic name;<span></span></pre></td></tr><tr><td scope="row"><pre>@dynamic employees;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)addEmployeesObject:(Employee *)value<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSSet *changedObjects = [[NSSet alloc] initWithObjects:&amp;value count:1];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [self willChangeValueForKey:@"employees"<span></span></pre></td></tr><tr><td scope="row"><pre>          withSetMutation:NSKeyValueUnionSetMutation<span></span></pre></td></tr><tr><td scope="row"><pre>          usingObjects:changedObjects];<span></span></pre></td></tr><tr><td scope="row"><pre>    [[self primitiveEmployees] addObject:value];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self didChangeValueForKey:@"employees"<span></span></pre></td></tr><tr><td scope="row"><pre>          withSetMutation:NSKeyValueUnionSetMutation<span></span></pre></td></tr><tr><td scope="row"><pre>          usingObjects:changedObjects];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [changedObjects release];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)removeEmployeesObject:(Employee *)value<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSSet *changedObjects = [[NSSet alloc] initWithObjects:&amp;value count:1];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [self willChangeValueForKey:@"employees"<span></span></pre></td></tr><tr><td scope="row"><pre>          withSetMutation:NSKeyValueMinusSetMutation<span></span></pre></td></tr><tr><td scope="row"><pre>          usingObjects:changedObjects];<span></span></pre></td></tr><tr><td scope="row"><pre>    [[self primitiveEmployees] removeObject:value];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self didChangeValueForKey:@"employees"<span></span></pre></td></tr><tr><td scope="row"><pre>          withSetMutation:NSKeyValueMinusSetMutation<span></span></pre></td></tr><tr><td scope="row"><pre>          usingObjects:changedObjects];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [changedObjects release];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)addEmployees:(NSSet *)value<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [self willChangeValueForKey:@"employees"<span></span></pre></td></tr><tr><td scope="row"><pre>          withSetMutation:NSKeyValueUnionSetMutation<span></span></pre></td></tr><tr><td scope="row"><pre>          usingObjects:value];<span></span></pre></td></tr><tr><td scope="row"><pre>    [[self primitiveEmployees] unionSet:value];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self didChangeValueForKey:@"employees"<span></span></pre></td></tr><tr><td scope="row"><pre>          withSetMutation:NSKeyValueUnionSetMutation<span></span></pre></td></tr><tr><td scope="row"><pre>          usingObjects:value];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)removeEmployees:(NSSet *)value<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [self willChangeValueForKey:@"employees"<span></span></pre></td></tr><tr><td scope="row"><pre>          withSetMutation:NSKeyValueMinusSetMutation<span></span></pre></td></tr><tr><td scope="row"><pre>          usingObjects:value];<span></span></pre></td></tr><tr><td scope="row"><pre>    [[self primitiveEmployees] minusSet:value];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self didChangeValueForKey:@"employees"<span></span></pre></td></tr><tr><td scope="row"><pre>          withSetMutation:NSKeyValueMinusSetMutation<span></span></pre></td></tr><tr><td scope="row"><pre>          usingObjects:value];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002154-SW5" title="Custom Primitive Accessor Methods"></a><h2>Custom Primitive Accessor Methods</h2><p>Primitive accessor methods are similar to "normal" or public key-value coding compliant accessor methods, except that Core Data uses them as the most basic data methods to access data, consequently they do <em>not</em> issue key-value access or observing notifications. Put another way, they are to <code><a href="../../Reference/CoreDataFramework/Classes/NSManagedObject_Class/Reference/NSManagedObject.html#//apple_ref/occ/instm/NSManagedObject/primitiveValueForKey:" target="_top">primitiveValueForKey:</a></code> and <code><a href="../../Reference/CoreDataFramework/Classes/NSManagedObject_Class/Reference/NSManagedObject.html#//apple_ref/occ/instm/NSManagedObject/setPrimitiveValue:forKey:" target="_top">setPrimitiveValue:forKey:</a></code> what public accessor methods are to <code><a href="../../Reference/Foundation/Protocols/NSKeyValueCoding_Protocol/Reference/Reference.html#//apple_ref/occ/instm/NSObject/valueForKey:" target="_top">valueForKey:</a></code> and <code><a href="../../Reference/Foundation/Protocols/NSKeyValueCoding_Protocol/Reference/Reference.html#//apple_ref/occ/instm/NSObject/setValue:forKey:" target="_top">setValue:forKey:</a></code>.</p><p>Typically there should be little reason to implement primitive accessor methods. They are, however, useful if you want custom methods to provide direct access to instance variables for persistent Core Data properties. The example below contrasts public and primitive accessor methods for an attribute, <code>int16</code>, of type <code>Integer 16</code>, stored in a custom instance variable, <code>nonCompliantKVCivar</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>// primitive get accessor<span></span></pre></td></tr><tr><td scope="row"><pre>- (short)primitiveInt16 {<span></span></pre></td></tr><tr><td scope="row"><pre>    return nonCompliantKVCivar;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// primitive set accessor<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setPrimitiveInt16:(short)newInt16 {<span></span></pre></td></tr><tr><td scope="row"><pre>    nonCompliantKVCivar = newInt16;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// public get accessor<span></span></pre></td></tr><tr><td scope="row"><pre>- (short)int16 {<span></span></pre></td></tr><tr><td scope="row"><pre>    short tmpValue;<span></span></pre></td></tr><tr><td scope="row"><pre>    [self willAccessValueForKey: @"int16"];<span></span></pre></td></tr><tr><td scope="row"><pre>    tmpValue = nonCompliantKVCivar;<span></span></pre></td></tr><tr><td scope="row"><pre>    [self didAccessValueForKey: @"int16"];<span></span></pre></td></tr><tr><td scope="row"><pre>    return tmpValue;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// public set accessor<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setInt16:(short)int16 {<span></span></pre></td></tr><tr><td scope="row"><pre>    [self willChangeValueForKey: @"int16"];<span></span></pre></td></tr><tr><td scope="row"><pre>    nonCompliantKVCivar = int16;<span></span></pre></td></tr><tr><td scope="row"><pre>    [self didChangeValueForKey:@"int16"];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	

        <br/><br/> 

        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="Articles/moAccessorMethods.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="Articles/moIntegrating.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-02-08<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/ModelObjects/cdAccessorMethods.html%3Fid%3DTP40001931-2.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/ModelObjects/cdAccessorMethods.html%3Fid%3DTP40001931-2.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/ModelObjects/cdAccessorMethods.html%3Fid%3DTP40001931-2.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>
