<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>HID Explorer - /HID Utilities/HID_Utilities.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/Games/index.html">Games</a> &gt; <a href="../../samplecode/Games/idxHumanInterfaceDeviceForceFeedback-date.html">Human Interface Device & Force Feedback</a> &gt; <A HREF="javascript:location.replace('index.html');">HID Explorer</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->


	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">HID Explorer</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/HID Utilities/HID_Utilities.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/HID Explorer-Read Me.txt</option>
<option value="listing2.html">/HID Utilities/HID_Utilities.c</option>
<option value="listing3.html">/HID Utilities/HID_Utilities.h</option>
<option value="listing4.html">/HID Utilities/ImmrHIDUtilAddOn.c</option>
<option value="listing5.html">/HID Utilities/ImmrHIDUtilAddOn.h</option>
<option value="listing6.html">/HID Utilities/IOHIDDevice_.c</option>
<option value="listing7.html">/HID Utilities/IOHIDDevice_.h</option>
<option value="listing8.html">/HID Utilities/IOHIDElement_.c</option>
<option value="listing9.html">/HID Utilities/IOHIDElement_.h</option>
<option value="listing10.html">/HID Utilities/IOHIDLib_.h</option>
<option value="listing11.html">/main.c</option></select>
				</p>
				</form>
				<p><strong><a href="HID_Explorer.zip">Download Sample</a></strong> (&#147;HID_Explorer.zip&#148;, 106.9K)<BR>
<strong><a href="HID_Explorer.dmg">Download Sample</a></strong> (&#147;HID_Explorer.dmg&#148;, 164.5K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">//
//    File:        HID_Utilities.c
//
//    Contains:     Implementation of the HID configuration utilities
//
//    Copyright:  Copyright (c) 2007 Apple Inc., All Rights Reserved
//
//    Disclaimer:    IMPORTANT:  This Apple software is supplied to you by 
//                Apple Inc. (&quot;Apple&quot;) in consideration of your agreement to the
//                following terms, and your use, installation, modification or
//                redistribution of this Apple software constitutes acceptance of these
//                terms.  If you do not agree with these terms, please do not use,
//                install, modify or redistribute this Apple software.
//
//                In consideration of your agreement to abide by the following terms, and
//                subject to these terms, Apple grants you a personal, non-exclusive
//                license, under Apple's copyrights in this original Apple software (the
//                &quot;Apple Software&quot;), to use, reproduce, modify and redistribute the Apple
//                Software, with or without modifications, in source and/or binary forms;
//                provided that if you redistribute the Apple Software in its entirety and
//                without modifications, you must retain this notice and the following
//                text and disclaimers in all such redistributions of the Apple Software. 
//                Neither the name, trademarks, service marks or logos of Apple Inc. 
//                may be used to endorse or promote products derived from the Apple
//                Software without specific prior written permission from Apple.  Except
//                as expressly stated in this notice, no other rights or licenses, express
//                or implied, are granted by Apple herein, including but not limited to
//                any patent rights that may be infringed by your derivative works or by
//                other works in which the Apple Software may be incorporated.
//
//                The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE
//                MAKES NO WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION
//                THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS
//                FOR A PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND
//                OPERATION ALONE OR IN COMBINATION WITH YOUR PRODUCTS.
//
//                IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL
//                OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
//                SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
//                INTERRUPTION) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION,
//                MODIFICATION AND/OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED
//                AND WHETHER UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE),
//                STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE
//                POSSIBILITY OF SUCH DAMAGE.
//
//***************************************************
#pragma mark - includes &amp; imports
//-----------------------------------------------------
//#include &lt;CoreServices/../Frameworks/CarbonCore.framework/Headers/MacTypes.h&gt;

#include &lt;stdlib.h&gt; // malloc
#include &lt;time.h&gt; // clock

#include &lt;AssertMacros.h&gt;

#include &quot;HID_Utilities.h&quot;

//***************************************************
#pragma mark - typedefs, enums, defines, etc.
//-----------------------------------------------------
#define FAKE_MISSING_NAMES    1    // set this to true while debuging to get more explicit element names; false for the generic ones

#define kPercentMove        10                    // precent of overall range a element must move to register
#define kNameKeyCFStringRef CFSTR( &quot;Name&quot; )        // dictionary key

//***************************************************
#pragma mark - local ( static ) function prototypes
//-----------------------------------------------------

static void CFSetApplierFunctionCopyToCFArray(const void *value, void *context);
static CFComparisonResult CFDeviceArrayComparatorFunction(const void *val1, const void *val2, void *context);
static CFMutableDictionaryRef hu_SetUpMatchingDictionary( UInt32 inUsagePage, UInt32 inUsage );
static CFPropertyListRef hu_XMLLoad( CFStringRef inResourceName, CFStringRef inResourceExtension );
static CFPropertyListRef hu_LoadFromXMLFile( CFURLRef inCFURLRef );

//***************************************************
#pragma mark - exported globals
//-----------------------------------------------------

IOHIDManagerRef            gIOHIDManagerRef = NULL;
CFMutableArrayRef        gDeviceCFArrayRef = NULL;
CFArrayRef                gElementCFArrayRef = NULL;

//***************************************************
#pragma mark - local ( static ) globals
//-----------------------------------------------------

//***************************************************
#pragma mark - exported function implementations
//-----------------------------------------------------

//*************************************************************************
//
// HIDBuildMultiDeviceList( inUsagePages, inUsages, inNumDeviceTypes )
//
// Purpose:    builds list of devices with elements
//
// Inputs:    inUsagePages        - inNumDeviceTypes sized array of matching usage pages
//            inUsages            - inNumDeviceTypes sized array of matching usages
//            inNumDeviceTypes    - number of usage pages &amp; usages
//
// Returns:    Boolean        - if successful
//
Boolean HIDBuildMultiDeviceList( UInt32 inUsagePages[], UInt32 inUsages[], UInt32 inNumDeviceTypes )
{
    Boolean result = FALSE;        // assume failure ( pessimist! )
    Boolean first = (!gIOHIDManagerRef); // not yet created?
    
    if ( first ) {
        // create the manager
        gIOHIDManagerRef = IOHIDManagerCreate( kCFAllocatorDefault, kIOHIDOptionsTypeNone );
    }
    
    if ( gIOHIDManagerRef ) {
        CFMutableArrayRef hidMatchingCFMutableArrayRef = NULL;
        if ( inUsages &amp;&amp; inUsagePages &amp;&amp; inNumDeviceTypes ) {
            hidMatchingCFMutableArrayRef = CFArrayCreateMutable( kCFAllocatorDefault, 0, &amp; kCFTypeArrayCallBacks );
            if ( hidMatchingCFMutableArrayRef ) {
                int idx;
                for ( idx = 0; idx &lt; inNumDeviceTypes; idx++ ) {    // for all usage and usage page types
                    // Set up matching dictionary. returns NULL on error.
                    CFMutableDictionaryRef hidMatchingCFDictRef = hu_SetUpMatchingDictionary( inUsagePages[idx], inUsages[idx] );
                    if ( hidMatchingCFDictRef ) {
                        CFArrayAppendValue( hidMatchingCFMutableArrayRef, (void*) hidMatchingCFDictRef );
                        CFRelease( hidMatchingCFDictRef );
                    } else {
                        fprintf( stderr, &quot;%s: Couldn't create a matching dictionary.&quot;, __PRETTY_FUNCTION__ );
                    }
                }
            } else {
                fprintf( stderr, &quot;%s: Couldn't create a matching array.&quot;, __PRETTY_FUNCTION__ );
            }
        }
        
        // set it for IOHIDManager to use to match against
        IOHIDManagerSetDeviceMatchingMultiple( gIOHIDManagerRef, hidMatchingCFMutableArrayRef );

        if ( hidMatchingCFMutableArrayRef ) {
            CFRelease( hidMatchingCFMutableArrayRef );
        }

        if ( first ) {
            // open it
            IOReturn tIOReturn = IOHIDManagerOpen( gIOHIDManagerRef, kIOHIDOptionsTypeNone );
            if ( kIOReturnSuccess != tIOReturn ) {
                fprintf( stderr, &quot;%s: Couldn't open IOHIDManager.&quot;, __PRETTY_FUNCTION__ );
                goto Oops;
            }
        }
        HIDRebuildDevices( );
        result = TRUE;
    } else {
        fprintf( stderr, &quot;%s: Couldn't create a IOHIDManager.&quot;, __PRETTY_FUNCTION__ );
    }
Oops:    ;
    return result;
}    // HIDBuildMultiDeviceList

//*************************************************************************
//
// HIDRebuildDevices(  )
//
// Purpose:    rebuilds the (internal) list of IOHIDDevices
//
// Inputs:    none
//
// Returns:    none
//

void HIDRebuildDevices( void ) {
    // get the set of devices from the IOHID manager
    CFSetRef devCFSetRef = IOHIDManagerCopyDevices( gIOHIDManagerRef );
    if ( devCFSetRef ) {
        // if the existing array isn't empty...
        if ( gDeviceCFArrayRef ) {
            // release it
            CFRelease( gDeviceCFArrayRef );
        }
        // create an empty array
        gDeviceCFArrayRef = CFArrayCreateMutable( kCFAllocatorDefault, 0, &amp;kCFTypeArrayCallBacks );
        // now copy the set to the array
        CFSetApplyFunction( devCFSetRef, CFSetApplierFunctionCopyToCFArray, ( void * ) gDeviceCFArrayRef );
        // now sort the array by location ID's
        CFIndex cnt = CFArrayGetCount( gDeviceCFArrayRef );
        CFArraySortValues( gDeviceCFArrayRef, CFRangeMake( 0, cnt ), CFDeviceArrayComparatorFunction, NULL );

        // and release the set we copied from the IOHID manager
        CFRelease( devCFSetRef );
    }
}    // HIDRebuildDevices

//*************************************************************************
//
// HIDConfigureAction( outIOHIDDeviceRef, outIOHIDElementRef, inTimeout )
//
// Purpose:    polls all devices and elements for a change greater than kPercentMove.
//            Times out after given time returns 1 and pointer to device and element
//            if found; returns 0 and NULL for both parameters if not found
//
// Inputs:    outIOHIDDeviceRef    - address where to store the device
//            outIOHIDElementRef    - address where to store the element
//            inTimeout    - the timeout
// Returns:    Boolean        - if successful
//            outIOHIDDeviceRef    - the device
//            outIOHIDElementRef    - the element
//

Boolean HIDConfigureAction( IOHIDDeviceRef* outIOHIDDeviceRef, IOHIDElementRef *outIOHIDElementRef, float inTimeout )
{
    if ( !outIOHIDDeviceRef || !outIOHIDElementRef ) {
        return FALSE;
    }
    
    if ( !gDeviceCFArrayRef ) {    // if we do not have a device list
        // and  we can't build another list
        if ( !HIDBuildMultiDeviceList( nil, nil, 0 ) || ! gDeviceCFArrayRef ) {
            return FALSE;
        }
    }
    
    // duration timers
    clock_t start, stop;
    
    // determine the maximum number of elements
    CFIndex maxElements = 0;
    CFIndex devIndex, devCount = CFArrayGetCount( gDeviceCFArrayRef );
    for ( devIndex = 0; devIndex &lt; devCount; devIndex++ ) {
        IOHIDDeviceRef tIOHIDDeviceRef = ( IOHIDDeviceRef ) CFArrayGetValueAtIndex( gDeviceCFArrayRef, devIndex );
        if ( !tIOHIDDeviceRef) continue;
        gElementCFArrayRef = IOHIDDeviceCopyMatchingElements( tIOHIDDeviceRef, NULL, 0 );
        if ( gElementCFArrayRef ) {
            CFIndex numElements = CFArrayGetCount( gElementCFArrayRef );
            if ( numElements &gt; maxElements ) {
                maxElements = numElements;
            }
            CFRelease( gElementCFArrayRef );
            gElementCFArrayRef = NULL;
        }
    }
    
    // allocate an array of doubles to store devCount * maxElements values
    double* saveValueArray = ( double * ) calloc( sizeof( double ), devCount * maxElements ); // clear 2D array to save values
    
    // on the first pass store the initial values
    Boolean found = FALSE, done = FALSE, first = TRUE;
    
    // poll all devices and elements, compare current value to the initial values
    while ( !found &amp;&amp; !done ) {
        for ( devIndex = 0; devIndex &lt; devCount; devIndex++ ) {
            IOHIDDeviceRef tIOHIDDeviceRef = ( IOHIDDeviceRef ) CFArrayGetValueAtIndex( gDeviceCFArrayRef, devIndex );
            if ( !tIOHIDDeviceRef) continue;
            
            gElementCFArrayRef = IOHIDDeviceCopyMatchingElements( tIOHIDDeviceRef, NULL, 0 );
            if ( gElementCFArrayRef ) {
                CFIndex eleIndex, eleCount = CFArrayGetCount( gElementCFArrayRef );
                for ( eleIndex = 0; eleIndex &lt; eleCount; eleIndex++ ) {
                    IOHIDElementRef tIOHIDElementRef = ( IOHIDElementRef ) CFArrayGetValueAtIndex( gElementCFArrayRef, eleIndex );
                    
                    IOHIDElementType tIOHIDElementType = IOHIDElementGetType( tIOHIDElementRef );
                    // only care about inputs (no outputs or features)
                    if ( tIOHIDElementType &lt;= kIOHIDElementTypeInput_ScanCodes ) {
                        uint32_t usagePage = IOHIDElementGetUsagePage( tIOHIDElementRef );
                        uint32_t usage = IOHIDElementGetUsage( tIOHIDElementRef );
                        
                        // ignore PID elements and arrays
                        if ( ( kHIDPage_PID != usagePage ) &amp;&amp; ( -1 != usage ) ) {
                            IOHIDValueRef tIOHIDValueRef;
                            IOHIDDeviceGetValue( tIOHIDDeviceRef, tIOHIDElementRef, &amp;tIOHIDValueRef );
                            double value = IOHIDValueGetScaledValue( tIOHIDValueRef, kIOHIDValueScaleTypePhysical );
                            
                            if ( first ) {
                                saveValueArray[( devIndex * maxElements ) + eleIndex] = value;
                            } else {
                                double initialValue = saveValueArray[( devIndex * maxElements ) + eleIndex];
                                
                                CFIndex valueMin = IOHIDElementGetPhysicalMin( tIOHIDElementRef );
                                CFIndex valueMax = IOHIDElementGetPhysicalMax( tIOHIDElementRef );
                                
                                double delta = fabs( ( valueMax - valueMin ) * kPercentMove * 0.01f );
                                if ( fabs( initialValue - value ) &gt; delta ) {
                                    found = TRUE;
                                    *outIOHIDDeviceRef = tIOHIDDeviceRef;
                                    *outIOHIDElementRef = tIOHIDElementRef;
                                    break;
                                }
                            }    // if first
                        }    // if usage
                    }    // if type
                }    // for elements...
                CFRelease( gElementCFArrayRef );
                gElementCFArrayRef = NULL;
            }    // for devices
        }    // while !( found || done)
        if ( first ) {
            start = clock( );
            first = FALSE;
        } else {
            // are we done?
            stop = clock( );
            double secs;
            secs = ( double ) ( stop - start ) / CLOCKS_PER_SEC;
            if ( secs &gt; inTimeout ) {
                done = TRUE;
                break;
            }
        }
    }    // while ( !found &amp;&amp; !done );
    
    // return device and element moved
    if ( !found ) {
        *outIOHIDDeviceRef = NULL;
        *outIOHIDElementRef = NULL;
    }
    return found;
}    // HIDConfigureAction

//*************************************************************************
//
// HIDSaveElementPref( inKeyCFStringRef, inAppCFStringRef, inIOHIDDeviceRef, inIOHIDElementRef )
//
// Purpose:    Save the device &amp; element values into the specified key in the specified applications preferences
//
// Inputs:    inKeyCFStringRef    - the preference key
//            inAppCFStringRef    - the application identifier
//            inIOHIDDeviceRef            - the device
//            inIOHIDElementRef            - the element
// Returns:    Boolean                - if successful
//

Boolean HIDSaveElementPref( const CFStringRef inKeyCFStringRef, CFStringRef inAppCFStringRef, IOHIDDeviceRef inIOHIDDeviceRef, IOHIDElementRef inIOHIDElementRef )
{
    Boolean success = FALSE;
    
    if ( inKeyCFStringRef &amp;&amp; inAppCFStringRef &amp;&amp; inIOHIDDeviceRef &amp;&amp; inIOHIDElementRef ) {
        
        long vendorID = IOHIDDevice_GetVendorID( inIOHIDDeviceRef );
        require( vendorID, Oops);
        
        long productID = IOHIDDevice_GetProductID( inIOHIDDeviceRef );
        require( productID, Oops);
        
        long locID = IOHIDDevice_GetLocationID( inIOHIDDeviceRef );
        require( locID, Oops);
        
        uint32_t devUsagePage = IOHIDDevice_GetUsagePage( inIOHIDDeviceRef );
        uint32_t devUsage = IOHIDDevice_GetUsage( inIOHIDDeviceRef );
        
        if ( !devUsagePage || !devUsage ) {
            devUsagePage = IOHIDDevice_GetPrimaryUsagePage( inIOHIDDeviceRef );
            devUsage = IOHIDDevice_GetPrimaryUsage( inIOHIDDeviceRef );
        }
        require( devUsagePage &amp;&amp; devUsage, Oops);
        
        IOHIDElementType eleType = IOHIDElementGetType( inIOHIDElementRef );
        uint32_t eleUsagePage = IOHIDElementGetUsagePage( inIOHIDElementRef );
        uint32_t eleUsage = IOHIDElementGetUsage( inIOHIDElementRef );
        IOHIDElementCookie eleCookie = IOHIDElementGetCookie( inIOHIDElementRef );
        
        CFStringRef prefCFStringRef = CFStringCreateWithFormat( kCFAllocatorDefault, NULL, 
                                                               CFSTR( &quot;d:{v:%ld, p:%ld, l:%ld, p:%ld, u:%ld}, e:{t:%ld, p:%ld, u:%ld, c:%ld}&quot; ), 
                                                               vendorID, 
                                                               productID, 
                                                               locID,
                                                               devUsagePage, 
                                                               devUsage, 
                                                               eleType, 
                                                               eleUsagePage, 
                                                               eleUsage, 
                                                               eleCookie );
        
        if ( prefCFStringRef ) {
            CFPreferencesSetAppValue( inKeyCFStringRef, prefCFStringRef, inAppCFStringRef );
            CFRelease( prefCFStringRef );
            success = TRUE;
        }
    }
    Oops:    ;
    return success;
}    // HIDSaveElementPref

//*************************************************************************
//
// HIDRestoreElementPref( inKeyCFStringRef, inAppCFStringRef, outIOHIDDeviceRef, outIOHIDElementRef )
//
// Purpose:    Find the specified preference in the specified application
//
// Inputs:    inKeyCFStringRef    - the preference key
//            inAppCFStringRef    - the application identifier
//            outIOHIDDeviceRef        - address where to restore the device
//            outIOHIDElementRef        - address where to restore the element
// Returns:    Boolean                - if successful
//            outIOHIDDeviceRef        - the device
//            outIOHIDElementRef        - the element
//

Boolean HIDRestoreElementPref( CFStringRef inKeyCFStringRef, CFStringRef inAppCFStringRef, IOHIDDeviceRef* outIOHIDDeviceRef, IOHIDElementRef *outIOHIDElementRef )
{
    Boolean found = FALSE;
    
    if ( inKeyCFStringRef &amp;&amp; inAppCFStringRef &amp;&amp; outIOHIDDeviceRef &amp;&amp; outIOHIDElementRef ) {
        CFPropertyListRef prefCFPropertyListRef = CFPreferencesCopyAppValue( inKeyCFStringRef, inAppCFStringRef );
        
        if ( prefCFPropertyListRef ) {
            if ( CFStringGetTypeID( ) == CFGetTypeID( prefCFPropertyListRef ) ) {
                char buffer[256];
                
                if ( CFStringGetCString( ( CFStringRef ) prefCFPropertyListRef, buffer, sizeof( buffer ), kCFStringEncodingUTF8 ) ) {
                    hu_InfoRec_t searchInfo;
                    
                    int count = sscanf( buffer, &quot;d:{v:%ld, p:%ld, l:%ld, p:%d, u:%d}, e:{t:%ld, p:%d, u:%d, c:%ld}&quot;,
                                       &amp;searchInfo.vendorID, &amp;searchInfo.productID, &amp;searchInfo.locID, &amp;searchInfo.devUsagePage, &amp;searchInfo.devUsage,
                                       &amp;searchInfo.type, &amp;searchInfo.eleUsagePage, &amp;searchInfo.eleUsage,( long* ) &amp;searchInfo.cookie );
                    
                    if ( 9 == count ) {    // if we found all nine parameters\xC9
                        // and can find a device &amp; element that matches these\xC9
                        if ( HIDFindDeviceAndElement( &amp;searchInfo, outIOHIDDeviceRef, outIOHIDElementRef ) ) {
                            found = TRUE;
                        }
                    }
                }
            } else {
                // We found the entry with this key but it's the wrong type; delete it.
                CFPreferencesSetAppValue( inKeyCFStringRef, NULL, inAppCFStringRef );
                ( void ) CFPreferencesAppSynchronize( inAppCFStringRef );
            }
            CFRelease( prefCFPropertyListRef );
        }
    }
    return found;
}    // HIDRestoreElementPref

//*************************************************************************
//
// HIDFindDeviceAndElement( inSearchInfo, outFoundDevice, outFoundElement )
//
// Purpose:    find the closest matching device and element for this action
//
// Notes:    matches device: serial, vendorID, productID, location, inUsagePage, usage
//            matches element: cookie, inUsagePage, usage,
//
// Inputs:    inSearchInfo    - the device &amp; element info we searching for
//            outFoundDevice    - the address of the best matching device
//            outFoundElement    - the address of the best matching element
//
// Returns:    Boolean            - TRUE if we find a match
//            outFoundDevice    - the best matching device
//            outFoundElement    - the best matching element
//

Boolean HIDFindDeviceAndElement( const hu_InfoRec_t* inSearchInfo, IOHIDDeviceRef* outFoundDevice, IOHIDElementRef *outFoundElement )
{
    Boolean result = FALSE;
    
    IOHIDDeviceRef    bestIOHIDDeviceRef = NULL;
    IOHIDElementRef    bestIOHIDElementRef = NULL;
    long bestScore = 0;
    
    CFIndex devIndex, devCount = CFArrayGetCount( gDeviceCFArrayRef );
    for ( devIndex = 0; devIndex &lt; devCount; devIndex++ ) {
        long deviceScore = 1;
        
        IOHIDDeviceRef tIOHIDDeviceRef = ( IOHIDDeviceRef ) CFArrayGetValueAtIndex( gDeviceCFArrayRef, devIndex );
        if ( !tIOHIDDeviceRef) continue;
        
        // match vendorID, productID (+10, +8)
        if ( inSearchInfo-&gt;vendorID ) {
            long vendorID =  IOHIDDevice_GetVendorID( tIOHIDDeviceRef);
            if ( vendorID ) {
                if ( inSearchInfo-&gt;vendorID == vendorID ) {
                    deviceScore += 10;
                    if ( inSearchInfo-&gt;productID ) {
                        long productID =  IOHIDDevice_GetProductID( tIOHIDDeviceRef);
                        if ( productID ) {
                            if ( inSearchInfo-&gt;productID == productID ) {
                                deviceScore += 8;
                            }    // if ( inSearchInfo-&gt;productID == productID )
                        }    // if ( productID )
                    }    // if ( inSearchInfo-&gt;productID )
                }    // if (inSearchInfo-&gt;vendorID == vendorID)
            }    // if vendorID
        }    // if search-&gt;vendorID
        
        // match usagePage &amp; usage (+9)
        if ( inSearchInfo-&gt;devUsagePage &amp;&amp; inSearchInfo-&gt;devUsage ) {
            uint32_t usagePage =  IOHIDDevice_GetUsagePage( tIOHIDDeviceRef ) ;
            uint32_t usage =  IOHIDDevice_GetUsage( tIOHIDDeviceRef );
            
            if ( !usagePage || ! usage ) {
                usagePage = IOHIDDevice_GetPrimaryUsagePage( tIOHIDDeviceRef );
                usage = IOHIDDevice_GetPrimaryUsage( tIOHIDDeviceRef );
            }
            
            if ( usagePage ) {
                if ( inSearchInfo-&gt;devUsagePage == usagePage ) {
                    if ( usage ) {
                        if ( inSearchInfo-&gt;devUsage == usage ) {
                            deviceScore += 9;
                        }    // if ( inSearchInfo-&gt;usage == usage )
                    }    // if ( usage )
                }    // if ( inSearchInfo-&gt;usagePage == usagePage )
            }    // if ( usagePage )
        }    // if ( inSearchInfo-&gt;usagePage &amp;&amp; inSearchInfo-&gt;usage )
        
        // match location ID (+5)
        if ( inSearchInfo-&gt;locID ) {
            long locID =  IOHIDDevice_GetLocationID( tIOHIDDeviceRef );
            if ( locID ) {
                if ( inSearchInfo-&gt;locID == locID ) {
                    deviceScore += 5;
                }
            }
        }
        
        // iterate over all elements of this device
        gElementCFArrayRef = IOHIDDeviceCopyMatchingElements( tIOHIDDeviceRef, NULL, 0 );
        if ( gElementCFArrayRef ) {
            CFIndex eleIndex, eleCount = CFArrayGetCount( gElementCFArrayRef );
            for ( eleIndex = 0; eleIndex &lt; eleCount; eleIndex++ ) {
                IOHIDElementRef tIOHIDElementRef = ( IOHIDElementRef ) CFArrayGetValueAtIndex( gElementCFArrayRef, eleIndex );
                if ( !tIOHIDElementRef ) continue;
                
                long score = deviceScore;
                
                // match type, usage page, usage &amp; cookie
                if ( inSearchInfo-&gt;type == IOHIDElementGetType( tIOHIDElementRef ) ) {
                    if ( inSearchInfo-&gt;eleUsagePage &amp;&amp; inSearchInfo-&gt;eleUsage ) {
                        uint32_t usagePage = IOHIDElementGetUsagePage( tIOHIDElementRef );
                        if ( inSearchInfo-&gt;eleUsagePage == usagePage ) {
                            uint32_t usage = IOHIDElementGetUsage( tIOHIDElementRef );
                            if ( inSearchInfo-&gt;eleUsage == usage ) {
                                score += 5;
                                IOHIDElementCookie cookie = IOHIDElementGetCookie( tIOHIDElementRef );
                                if ( inSearchInfo-&gt;cookie == cookie ) {
                                    score += 4;
                                }    // cookies match
                            } else {
                                score = 0;
                            }    // usages match
                        } else {
                            score = 0;
                        }    // usage pages match
                    }    // if ( search usage page &amp; usage )
                }    // if type
#if LOG_SCORING
                if ( kHIDPage_KeyboardOrKeypad != tElementRef-&gt;usagePage ) {    // skip keyboards here
                    printf( &quot;%s: ( %ld:%ld )-I-Debug, score: %ld\t&quot;, __PRETTY_FUNCTION__, inSearchInfo-&gt;eleUsagePage, inSearchInfo-&gt;eleUsage, score );
                    HIDPrintElement( tIOHIDElementRef );
                }
#endif LOG_SCORING
                if ( score &gt; bestScore ) {
                    bestIOHIDDeviceRef = tIOHIDDeviceRef;
                    bestIOHIDElementRef = tIOHIDElementRef;
                    bestScore = score;
#if LOG_SCORING
                    printf( &quot;%s: ( %ld:%ld )-I-Debug, better score: %ld\t&quot;, __PRETTY_FUNCTION__, inSearchInfo-&gt;eleUsagePage, inSearchInfo-&gt;eleUsage, score );
                    HIDPrintElement( bestIOHIDElementRef );
#endif LOG_SCORING
                }
            }    // for elements...
            CFRelease( gElementCFArrayRef );
            gElementCFArrayRef = NULL;
            
        }    // if ( gElementCFArrayRef )
    }    // for ( devIndex = 0; devIndex &lt; devCount; devIndex++ )
    
    if ( bestIOHIDDeviceRef || bestIOHIDElementRef ) {
        *outFoundDevice = bestIOHIDDeviceRef;
        *outFoundElement = bestIOHIDElementRef;
#if LOG_SCORING
        printf( &quot;%s: ( %ld:%ld )-I-Debug, best score: %ld\t&quot;, __PRETTY_FUNCTION__, inSearchInfo-&gt;eleUsagePage, inSearchInfo-&gt;eleUsage, bestScore );
        HIDPrintElement( bestIOHIDElementRef );
#endif LOG_SCORING
        result = TRUE;
    }
    return result;
}    // HIDFindDeviceAndElement

//*************************************************************************
//
// HIDGetUsageName( inUsagePage, inUsage )
//
// Purpose:    return a CFStringRef string for a given usage page &amp; usage( see IOUSBHIDParser.h )
//
// Notes:    returns usage page and usage values in CFString form for unknown values
//
// Inputs:    inUsagePage    - the usage page
//            inUsage        - the usage
//
// Returns:    CFStringRef    - the resultant string
//

CFStringRef HIDCopyUsageName( long inUsagePage, long inUsage )
{
    static CFPropertyListRef tCFPropertyListRef = NULL;
    CFStringRef result = NULL;
    
    if ( !tCFPropertyListRef )
        tCFPropertyListRef = hu_XMLLoad( CFSTR( &quot;HID_usage_strings&quot; ), CFSTR( &quot;plist&quot; ) );
    
    if ( tCFPropertyListRef ) {
        if ( CFDictionaryGetTypeID( ) == CFGetTypeID( tCFPropertyListRef ) ) {
            CFStringRef    pageKeyCFStringRef = CFStringCreateWithFormat( kCFAllocatorDefault, NULL, CFSTR( &quot;0x%4.4lX&quot; ), inUsagePage );
            if ( pageKeyCFStringRef ) {
                CFDictionaryRef pageCFDictionaryRef;
                if ( CFDictionaryGetValueIfPresent( tCFPropertyListRef, pageKeyCFStringRef, ( const void** ) &amp;pageCFDictionaryRef ) ) {
                    CFStringRef    pageCFStringRef;
                    if ( CFDictionaryGetValueIfPresent( pageCFDictionaryRef, kNameKeyCFStringRef, ( const void** ) &amp;pageCFStringRef ) ) {
                        CFStringRef    usageKeyCFStringRef = CFStringCreateWithFormat( kCFAllocatorDefault, NULL, CFSTR( &quot;0x%4.4lX&quot; ), inUsage );
                        if ( usageKeyCFStringRef ) {
                            CFStringRef    usageCFStringRef;
                            if ( CFDictionaryGetValueIfPresent( pageCFDictionaryRef, usageKeyCFStringRef, ( const void** ) &amp;usageCFStringRef ) ) {
                                result = CFStringCreateWithFormat( kCFAllocatorDefault, NULL, CFSTR( &quot;%@ %@&quot; ), pageCFStringRef, usageCFStringRef );
                            }
#if FAKE_MISSING_NAMES
                            else {
                                result = CFStringCreateWithFormat( kCFAllocatorDefault, NULL, CFSTR( &quot;%@ #%@&quot; ), pageCFStringRef, usageKeyCFStringRef );
                            }
#endif
                            CFRelease( usageKeyCFStringRef );
                        }
                    } else {
                        // no name data for this page
                    }
                } else {
                    // no data for this page
                }
                CFRelease( pageKeyCFStringRef );
            }
        }
        // CFRelease( tCFPropertyListRef );    // Leak this!
        // tCFPropertyListRef = NULL;
    }
    return result;
}    // HIDCopyUsageName

// utility routine to dump device info
void HIDDumpDeviceInfo( IOHIDDeviceRef inIOHIDDeviceRef )
{
    printf( &quot;Device: %p = { &quot;, inIOHIDDeviceRef );

    char manufacturer[256] = &quot;&quot;;    // name of manufacturer
    CFStringRef tCFStringRef = IOHIDDevice_GetManufacturer( inIOHIDDeviceRef );
    if ( tCFStringRef ) {
        verify( CFStringGetCString( tCFStringRef, manufacturer, sizeof( manufacturer ), kCFStringEncodingUTF8 ) );
    }
    
    char product[256] = &quot;&quot;;        // name of product
    tCFStringRef = IOHIDDevice_GetProduct( inIOHIDDeviceRef );
    if ( tCFStringRef ) {
        verify( CFStringGetCString( tCFStringRef, product, sizeof( product ), kCFStringEncodingUTF8 ) );
    }
    
    printf( &quot;%s - %s, &quot;, manufacturer, product );
    
    long vendorID = IOHIDDevice_GetVendorID( inIOHIDDeviceRef );
    if ( vendorID ) {
#if 1
        printf( &quot;    vendorID:    0x%04lX, &quot;, vendorID );
#else
        char string[256];
        if ( HIDGetVendorNameFromVendorID( vendorID, string ) ) {
            printf( &quot;    vendorID:    0x%04lX (\&quot;%s\&quot;), &quot;, vendorID, string );
        } else {
            printf( &quot;    vendorID:    0x%04lX, &quot;, vendorID );
        }
#endif
    }
    
    long productID = IOHIDDevice_GetProductID( inIOHIDDeviceRef );
    if ( productID ) {
#if 1
        printf( &quot;    productID:    0x%04lX, &quot;, productID );
#else
        if ( HIDGetProductNameFromVendorProductID( vendorID, productID, string ) ) {
            printf( &quot;    productID:    0x%04lX (\&quot;%s\&quot;), &quot;, productID, string );
        } else {
            printf( &quot;    productID:    0x%04lX, &quot;, productID );
        }
#endif
    }
    
    uint32_t devUsagePage = IOHIDDevice_GetUsagePage( inIOHIDDeviceRef );
    uint32_t devUsage = IOHIDDevice_GetUsage( inIOHIDDeviceRef );
    
    if ( !devUsagePage || !devUsage ) {
        devUsagePage = IOHIDDevice_GetPrimaryUsagePage( inIOHIDDeviceRef );
        devUsage = IOHIDDevice_GetPrimaryUsage( inIOHIDDeviceRef );
    }

    printf( &quot;usage: 0x%04lX:0x%04lX, &quot;, (long unsigned int) devUsagePage, (long unsigned int) devUsage );

#if 1
    tCFStringRef = HIDCopyUsageName( devUsagePage, devUsage );
    if ( tCFStringRef ) {
        char usageString[256] = &quot;&quot;;
        verify( CFStringGetCString( tCFStringRef, usageString, sizeof( usageString ), kCFStringEncodingUTF8 ) );
        printf( &quot;\&quot;%s\&quot;&quot;, usageString );
        CFRelease( tCFStringRef );
    }
#endif
    printf( &quot;\n&quot; );
    fflush( stdout );
}    // HIDDumpDeviceInfo

// utility routine to dump element info
void HIDDumpElementInfo( IOHIDElementRef inIOHIDElementRef )
{
    if ( inIOHIDElementRef ) {
        printf( &quot;Element: %p = { &quot;, inIOHIDElementRef );
        
        IOHIDDeviceRef tIOHIDDeviceRef = IOHIDElementGetDevice( inIOHIDElementRef );
        printf( &quot;Device: %p, &quot;, tIOHIDDeviceRef );
        
        IOHIDElementRef parentIOHIDElementRef = IOHIDElementGetParent( inIOHIDElementRef );
        printf( &quot;parent: %p, &quot;, parentIOHIDElementRef );
#if 0
        CFArrayRef childrenCFArrayRef = IOHIDElementGetChildren( inIOHIDElementRef );
        printf( &quot;children: %p: { &quot;, childrenCFArrayRef ); fflush( stdout );
        CFShow( childrenCFArrayRef ); fflush( stdout );
        printf( &quot; }, &quot; );
#endif
        IOHIDElementCookie tIOHIDElementCookie = IOHIDElementGetCookie( inIOHIDElementRef );
        printf( &quot;cookie: %p, &quot;, tIOHIDElementCookie );
        
        IOHIDElementType tIOHIDElementType = IOHIDElementGetType( inIOHIDElementRef );
        switch ( tIOHIDElementType ) {
            case kIOHIDElementTypeInput_Misc: {
                printf( &quot;type: Misc, &quot; );
                break;
            }
                
            case kIOHIDElementTypeInput_Button: {
                printf( &quot;type: Button, &quot; );
                break;
            }
                
            case kIOHIDElementTypeInput_Axis: {
                printf( &quot;type: Axis, &quot; );
                break;
            }
                
            case kIOHIDElementTypeInput_ScanCodes: {
                printf( &quot;type: ScanCodes, &quot; );
                break;
            }
                
            case kIOHIDElementTypeOutput: {
                printf( &quot;type: Output, &quot; );
                break;
            }
                
            case kIOHIDElementTypeFeature: {
                printf( &quot;type: Feature, &quot; );
                break;
            }
                
            case kIOHIDElementTypeCollection: {
                printf( &quot;type: Collection, &quot; );
                break;
            }
                
            default: {
                printf( &quot;type: %p, &quot;, (void*) tIOHIDElementType );
                break;
            }
        }
        
        IOHIDElementCollectionType tIOHIDElementCollectionType = IOHIDElementGetCollectionType( inIOHIDElementRef );
        printf( &quot;collection: %p, &quot;, (void*) tIOHIDElementCollectionType );
        
        uint32_t usagePage = IOHIDElementGetUsagePage( inIOHIDElementRef );
        uint32_t usage = IOHIDElementGetUsage( inIOHIDElementRef );
        printf( &quot;usage: 0x%04lX:0x%04lX, &quot;, (long unsigned int) usagePage, (long unsigned int) usage );
#if 1
        CFStringRef tCFStringRef = HIDCopyUsageName( usagePage, usage );
        if ( tCFStringRef ) {
            char usageString[256] = &quot;&quot;;
            verify( CFStringGetCString( tCFStringRef, usageString, sizeof( usageString ), kCFStringEncodingUTF8 ) );
            printf( &quot;\&quot;%s\&quot;, &quot;, usageString );
            CFRelease( tCFStringRef );
        }
#endif
        CFStringRef nameCFStringRef = IOHIDElementGetName( inIOHIDElementRef );
        char buffer[256];
        if ( nameCFStringRef &amp;&amp; CFStringGetCString( nameCFStringRef, buffer, sizeof( buffer ), kCFStringEncodingUTF8 ) ) {
            printf( &quot;name: %s, &quot;, buffer );
        }
        
        uint32_t reportID = IOHIDElementGetReportID( inIOHIDElementRef );
        printf( &quot;report: { ID: %08lX, &quot;, (long unsigned int) reportID );
        
        uint32_t reportSize = IOHIDElementGetReportSize( inIOHIDElementRef );
        printf( &quot;Size: %lu, &quot;, (long unsigned int) reportSize );
        
        uint32_t reportCount = IOHIDElementGetReportCount( inIOHIDElementRef );
        printf( &quot;Count: %lu }, &quot;, (long unsigned int) reportCount );
        
        uint32_t unit = IOHIDElementGetUnit( inIOHIDElementRef );
        printf( &quot;unit: %lu, &quot;, (long unsigned int) unit );
        
        uint32_t unitExp = IOHIDElementGetUnitExponent( inIOHIDElementRef );
        printf( &quot;unitExp: %lu, &quot;, (long unsigned int) unitExp );
        
        CFIndex logicalMin = IOHIDElementGetLogicalMin( inIOHIDElementRef );
        printf( &quot;logicalMin: %ld, &quot;, logicalMin );
        
        CFIndex logicalMax = IOHIDElementGetLogicalMax( inIOHIDElementRef );
        printf( &quot;logicalMax: %ld, &quot;, logicalMax );
        
        CFIndex physicalMin = IOHIDElementGetPhysicalMin( inIOHIDElementRef );
        printf( &quot;physicalMin: %ld, &quot;, physicalMin );
        
        CFIndex physicalMax = IOHIDElementGetPhysicalMax( inIOHIDElementRef );
        printf( &quot;physicalMax: %ld, &quot;, physicalMax );
#if 1
        Boolean isVirtual = IOHIDElementIsVirtual( inIOHIDElementRef );
        if ( isVirtual ) printf( &quot;isVirtual, &quot; );
        
        Boolean isRelative = IOHIDElementIsRelative( inIOHIDElementRef );
        if ( isRelative ) printf( &quot;isRelative, &quot; );
        
        Boolean isWrapping = IOHIDElementIsWrapping( inIOHIDElementRef );
        if ( isWrapping ) printf( &quot;isWrapping, &quot; );
        
        Boolean isArray = IOHIDElementIsArray( inIOHIDElementRef );
        if ( isArray ) printf( &quot;isArray, &quot; );
        
        Boolean isNonLinear = IOHIDElementIsNonLinear( inIOHIDElementRef );
        if ( isNonLinear ) printf( &quot;isNonLinear, &quot; );
        
        Boolean hasPreferredState = IOHIDElementHasPreferredState( inIOHIDElementRef );
        if ( hasPreferredState ) printf( &quot;hasPreferredState, &quot; );
        
        Boolean hasNullState = IOHIDElementHasNullState( inIOHIDElementRef );
        if ( hasNullState ) printf( &quot;hasNullState, &quot; );
#else
        Boolean isVirtual = IOHIDElementIsVirtual( inIOHIDElementRef );
        printf( &quot;isVirtual: %s, &quot;, isVirtual ? &quot;YES&quot; : &quot;NO&quot; );
        
        Boolean isRelative = IOHIDElementIsRelative( inIOHIDElementRef );
        printf( &quot;isRelative: %s, &quot;, isRelative ? &quot;YES&quot; : &quot;NO&quot; );
        
        Boolean isWrapping = IOHIDElementIsWrapping( inIOHIDElementRef );
        printf( &quot;isWrapping: %s, &quot;, isWrapping ? &quot;YES&quot; : &quot;NO&quot; );
        
        Boolean isArray = IOHIDElementIsArray( inIOHIDElementRef );
        printf( &quot;isArray: %s, &quot;, isArray ? &quot;YES&quot; : &quot;NO&quot; );
        
        Boolean isNonLinear = IOHIDElementIsNonLinear( inIOHIDElementRef );
        printf( &quot;isNonLinear: %s, &quot;, isNonLinear ? &quot;YES&quot; : &quot;NO&quot; );
        
        Boolean hasPreferredState = IOHIDElementHasPreferredState( inIOHIDElementRef );
        printf( &quot;hasPreferredState: %s, &quot;, hasPreferredState ? &quot;YES&quot; : &quot;NO&quot; );
        
        Boolean hasNullState = IOHIDElementHasNullState( inIOHIDElementRef );
        printf( &quot;hasNullState: %s, &quot;, hasNullState ? &quot;YES&quot; : &quot;NO&quot; );
#endif
        printf( &quot; }\n&quot; );
    }
}    // HIDDumpElementInfo

//***************************************************
#pragma mark - local ( static ) function implementations
//-----------------------------------------------------

//*************************************************************************
//
// CFSetApplierFunctionCopyToCFArray( value, context )
//
// Purpose:    CFSetApplierFunction to copy the CFSet to a CFArray
//
// Notes:    called one time for each item in the CFSet
//
// Inputs:    value             - the current element of the CFSet
//            context            - the CFMutableArrayRef we're adding the CFSet elements to
//
// Returns:    nothing
//
static void CFSetApplierFunctionCopyToCFArray(const void *value, void *context)
{
    // printf( &quot;%s: 0x%08lX\n&quot;, __PRETTY_FUNCTION__, (long unsigned int) value );
    CFArrayAppendValue( ( CFMutableArrayRef ) context, value );
}    // CFSetApplierFunctionCopyToCFArray

// ---------------------------------
// used to sort the CFDevice array after copying it from the (unordered) (CF)set.
// we compare based on the location ID's since they're consistant (across boots &amp; launches).
//
static CFComparisonResult CFDeviceArrayComparatorFunction(const void *val1, const void *val2, void *context)
{
#pragma unused( context )
    CFComparisonResult result = kCFCompareEqualTo;
    
    long loc1 = IOHIDDevice_GetLocationID( ( IOHIDDeviceRef ) val1 );
    long loc2 = IOHIDDevice_GetLocationID( ( IOHIDDeviceRef ) val2 );
    
    if ( loc1 &lt; loc2 ) {
        result = kCFCompareLessThan;
    } else if ( loc1 &gt; loc2 ) {
        result = kCFCompareGreaterThan;
    }
    return result;
}    // CFDeviceArrayComparatorFunction

//*************************************************************************
//
// hu_SetUpMatchingDictionary( inUsagePage, inUsage )
//
// Purpose:    builds a matching dictionary based on usage page and usage
//
// Notes:    Only called by HIDBuildMultiDeviceList
//
// Inputs:    inUsagePage                - usage page
//            inUsage                    - usages
//
// Returns:    CFMutableDictionaryRef  - the matching dictionary
//

static CFMutableDictionaryRef hu_SetUpMatchingDictionary( UInt32 inUsagePage, UInt32 inUsage )
{
    // create a dictionary to add usage page/usages to
    CFMutableDictionaryRef refHIDMatchDictionary = CFDictionaryCreateMutable( kCFAllocatorDefault, 0,
                                    &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks );
    if ( refHIDMatchDictionary ) {
        if ( inUsagePage ) {
            // Add key for device type to refine the matching dictionary.
            CFNumberRef pageCFNumberRef = CFNumberCreate( kCFAllocatorDefault, kCFNumberIntType, &amp;inUsagePage );
            if ( pageCFNumberRef ) {
                CFDictionarySetValue( refHIDMatchDictionary, 
                        CFSTR( kIOHIDPrimaryUsagePageKey ), pageCFNumberRef );
                CFRelease( pageCFNumberRef );
                
                // note: the usage is only valid if the usage page is also defined
                if ( inUsage ) {
                    CFNumberRef usageCFNumberRef = CFNumberCreate( 
                                    kCFAllocatorDefault, kCFNumberIntType, &amp;inUsage );
                    if ( usageCFNumberRef ) {
                        CFDictionarySetValue( refHIDMatchDictionary, 
                            CFSTR( kIOHIDPrimaryUsageKey ), usageCFNumberRef );
                        CFRelease( usageCFNumberRef );
                    } else {
                        fprintf( stderr, &quot;%s: CFNumberCreate( usage ) failed.&quot;, __PRETTY_FUNCTION__ );
                    }
                }
            } else {
                fprintf( stderr, &quot;%s: CFNumberCreate( usage page ) failed.&quot;, __PRETTY_FUNCTION__ );
            }
        }
    } else {
        fprintf( stderr, &quot;%s: CFDictionaryCreateMutable failed.&quot;, __PRETTY_FUNCTION__ );
    }
    return refHIDMatchDictionary;
}    // hu_SetUpMatchingDictionary

//*************************************************************************
//
// hu_XMLLoad( inResourceName, inResourceExtension )
//
// Purpose:    Load a resource( XML ) file into a CFPropertyListRef
//
// Inputs:    inResourceName        - name of the resource file
//            inResourceExtension  - extension of the resource file
//
// Returns:    CFPropertyListRef   - the data
//
static CFPropertyListRef hu_XMLLoad( CFStringRef inResourceName, CFStringRef inResourceExtension )
{
    CFURLRef resFileCFURLRef;
    CFPropertyListRef tCFPropertyListRef = NULL;
    
    resFileCFURLRef = CFBundleCopyResourceURL( CFBundleGetMainBundle( ), inResourceName, inResourceExtension, NULL );
    if ( resFileCFURLRef ) {
        tCFPropertyListRef = hu_LoadFromXMLFile( resFileCFURLRef );
        CFRelease( resFileCFURLRef );
    }
    return tCFPropertyListRef;
}    // hu_XMLLoad


//*************************************************************************
//
// hu_LoadFromXMLFile( inCFURLRef )
//
// Purpose:    load a property list from an XML file
//
// Inputs:    inCFURLRef            - URL for the file
//
// Returns:    CFPropertyListRef   - the data
//
static CFPropertyListRef hu_LoadFromXMLFile( CFURLRef inCFURLRef )
{
    CFDataRef xmlCFDataRef;
    CFPropertyListRef myCFPropertyListRef = NULL;
    
    // Read the XML file.
    SInt32 error;
    if ( CFURLCreateDataAndPropertiesFromResource( kCFAllocatorDefault, inCFURLRef, &amp;xmlCFDataRef, NULL, NULL, &amp;error ) ) {
        CFStringRef errorString;
        // Reconstitute the dictionary using the XML data.
        myCFPropertyListRef = CFPropertyListCreateFromXMLData( kCFAllocatorDefault, xmlCFDataRef, kCFPropertyListImmutable, &amp;errorString );
        // Release the XML data
        CFRelease( xmlCFDataRef );
    }
    return myCFPropertyListRef;
}    // hu_LoadFromXMLFile
</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/HID_Explorer/listing2.html%3Fid%3DDTS10000443-2.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/HID_Explorer/listing2.html%3Fid%3DDTS10000443-2.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/HID_Explorer/listing2.html%3Fid%3DDTS10000443-2.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>