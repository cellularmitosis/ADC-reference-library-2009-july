<html><head><title>Mac OS X
 Manual Page For Class::Struct(3pm)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3pm/Class::Struct" title="Mac OS X
 Manual Page for Class::Struct(3pm)"><a name="//apple_ref/doc/man/3/Class::Struct" title="Mac OS X
 Manual Page for Class::Struct(3pm)"><!-- headerDoc=man; indexgroup=Section 3pm; uid="//apple_ref/doc/man/3pm/Class::Struct"; name=Class::Struct(3pm) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
Class::Struct(3pm)                    Perl Programmers Reference Guide                    Class::Struct(3pm)



<b>NAME</b>
       Class::Struct - declare struct-like datatypes as Perl classes

<b>SYNOPSIS</b>
           use Class::Struct;
                   # declare struct, based on array:
           struct( CLASS_NAME =&gt; [ ELEMENT_NAME =&gt; ELEMENT_TYPE, ... ]);
                   # declare struct, based on hash:
           struct( CLASS_NAME =&gt; { ELEMENT_NAME =&gt; ELEMENT_TYPE, ... });

           package CLASS_NAME;
           use Class::Struct;
                   # declare struct, based on array, implicit class name:
           struct( ELEMENT_NAME =&gt; ELEMENT_TYPE, ... );

           # Declare struct at compile time
           use Class::Struct CLASS_NAME =&gt; [ ELEMENT_NAME =&gt; ELEMENT_TYPE, ... ];
           use Class::Struct CLASS_NAME =&gt; { ELEMENT_NAME =&gt; ELEMENT_TYPE, ... };

           # declare struct at compile time, based on array, implicit class name:
           package CLASS_NAME;
           use Class::Struct ELEMENT_NAME =&gt; ELEMENT_TYPE, ... ;

           package Myobj;
           use Class::Struct;
                   # declare struct with four types of elements:
           struct( s =&gt; '$', a =&gt; '@', h =&gt; '%', c =&gt; 'My_Other_Class' );

           $obj = new Myobj;               # constructor

                                           # scalar type accessor:
           $element_value = $obj-&gt;s;           # element value
           $obj-&gt;s('new value');               # assign to element

                                           # array type accessor:
           $ary_ref = $obj-&gt;a;                 # reference to whole array
           $ary_element_value = $obj-&gt;a(2);    # array element value
           $obj-&gt;a(2, 'new value');            # assign to array element

                                           # hash type accessor:
           $hash_ref = $obj-&gt;h;                # reference to whole hash
           $hash_element_value = $obj-&gt;h('x'); # hash element value
           $obj-&gt;h('x', 'new value');          # assign to hash element

                                           # class type accessor:
           $element_value = $obj-&gt;c;           # object reference
           $obj-&gt;c-&gt;method(...);               # call method of object
           $obj-&gt;c(new My_Other_Class);        # assign a new object

<b>DESCRIPTION</b>
       "Class::Struct" exports a single function, "struct".  Given a list of element names and types, and
       optionally a class name, "struct" creates a Perl 5 class that implements a "struct-like" data struc-<font color="#ffffff" class="whiteout">ture.&nbsp;structure.</font>
       ture.

       The new class is given a constructor method, "new", for creating struct objects.

       Each element in the struct data has an accessor method, which is used to assign to the element and to
       fetch its value.  The default accessor can be overridden by declaring a "sub" of the same name in the
       package.  (See Example 2.)

       Each element's type can be scalar, array, hash, or class.

       <b>The</b> <b>"struct()"</b> <b>function</b>

       The "struct" function has three forms of parameter-list.

           struct( CLASS_NAME =&gt; [ ELEMENT_LIST ]);
           struct( CLASS_NAME =&gt; { ELEMENT_LIST });
           struct( ELEMENT_LIST );

       The first and second forms explicitly identify the name of the class being created.  The third form
       assumes the current package name as the class name.

       An object of a class created by the first and third forms is based on an array, whereas an object of
       a class created by the second form is based on a hash. The array-based forms will be somewhat faster
       and smaller; the hash-based forms are more flexible.

       The class created by "struct" must not be a subclass of another class other than "UNIVERSAL".

       It can, however, be used as a superclass for other classes. To facilitate this, the generated con-<font color="#ffffff" class="whiteout">structor&nbsp;constructor</font>
       structor method uses a two-argument blessing.  Furthermore, if the class is hash-based, the key of
       each element is prefixed with the class name (see <u>Perl</u> <u>Cookbook</u>, Recipe 13.12).

       A function named "new" must not be explicitly defined in a class created by "struct".

       The <u>ELEMENT</u><b>_</b><u>LIST</u> has the form

           NAME =&gt; TYPE, ...

       Each name-type pair declares one element of the struct. Each element name will be defined as an
       accessor method unless a method by that name is explicitly defined; in the latter case, a warning is
       issued if the warning flag (<b>-w</b>) is set.

       <b>Class</b> <b>Creation</b> <b>at</b> <b>Compile</b> <b>Time</b>

       "Class::Struct" can create your class at compile time.  The main reason for doing this is obvious, so
       your class acts like every other class in Perl.  Creating your class at compile time will make the
       order of events similar to using any other class ( or Perl module ).

       There is no significant speed gain between compile time and run time class creation, there is just a
       new, more standard order of events.

       <b>Element</b> <b>Types</b> <b>and</b> <b>Accessor</b> <b>Methods</b>

       The four element types -- scalar, array, hash, and class -- are represented by strings -- '$', '@',
       '%', and a class name -- optionally preceded by a '*'.

       The accessor method provided by "struct" for an element depends on the declared type of the element.

       Scalar ('$' or '*$')
           The element is a scalar, and by default is initialized to "undef" (but see "Initializing with
           new").

           The accessor's argument, if any, is assigned to the element.

           If the element type is '$', the value of the element (after assignment) is returned. If the ele-<font color="#ffffff" class="whiteout">ment&nbsp;element</font>
           ment type is '*$', a reference to the element is returned.

       Array ('@' or '*@')
           The element is an array, initialized by default to "()".

           With no argument, the accessor returns a reference to the element's whole array (whether or not
           the element was specified as '@' or '*@').

           With one or two arguments, the first argument is an index specifying one element of the array;
           the second argument, if present, is assigned to the array element.  If the element type is '@',
           the accessor returns the array element value.  If the element type is '*@', a reference to the
           array element is returned.

           As a special case, when the accessor is called with an array reference as the sole argument, this
           causes an assignment of the whole array element.  The object reference is returned.

       Hash ('%' or '*%')
           The element is a hash, initialized by default to "()".

           With no argument, the accessor returns a reference to the element's whole hash (whether or not
           the element was specified as '%' or '*%').

           With one or two arguments, the first argument is a key specifying one element of the hash; the
           second argument, if present, is assigned to the hash element.  If the element type is '%', the
           accessor returns the hash element value.  If the element type is '*%', a reference to the hash
           element is returned.

           As a special case, when the accessor is called with a hash reference as the sole argument, this
           causes an assignment of the whole hash element.  The object reference is returned.

       Class ('Class_Name' or '*Class_Name')
           The element's value must be a reference blessed to the named class or to one of its subclasses.
           The element is not initialized by default.

           The accessor's argument, if any, is assigned to the element. The accessor will "croak" if this is
           not an appropriate object reference.

           If the element type does not start with a '*', the accessor returns the element value (after
           assignment). If the element type starts with a '*', a reference to the element itself is
           returned.

       <b>Initializing</b> <b>with</b> <b>"new"</b>

       "struct" always creates a constructor called "new". That constructor may take a list of initializers
       for the various elements of the new struct.

       Each initializer is a pair of values: <u>element</u> <u>name</u>" =&gt; "<u>value</u>.  The initializer value for a scalar
       element is just a scalar value. The initializer for an array element is an array reference. The ini-<font color="#ffffff" class="whiteout">tializer&nbsp;initializer</font>
       tializer for a hash is a hash reference.

       The initializer for a class element is an object of the corresponding class, or of one of it's sub-<font color="#ffffff" class="whiteout">classes,&nbsp;subclasses,</font>
       classes, or a reference to a hash containing named arguments to be passed to the element's construc-<font color="#ffffff" class="whiteout">tor.&nbsp;constructor.</font>
       tor.

       See Example 3 below for an example of initialization.

<b>EXAMPLES</b>
       Example 1
           Giving a struct element a class type that is also a struct is how structs are nested.  Here,
           "Timeval" represents a time (seconds and microseconds), and "Rusage" has two elements, each of
           which is of type "Timeval".

               use Class::Struct;

               struct( Rusage =&gt; {
                   ru_utime =&gt; 'Timeval',  # user time used
                   ru_stime =&gt; 'Timeval',  # system time used
               });

               struct( Timeval =&gt; [
                   tv_secs  =&gt; '$',        # seconds
                   tv_usecs =&gt; '$',        # microseconds
               ]);

                   # create an object:
               my $t = Rusage-&gt;new(ru_utime=&gt;Timeval-&gt;new(), ru_stime=&gt;Timeval-&gt;new());

                   # $t-&gt;ru_utime and $t-&gt;ru_stime are objects of type Timeval.
                   # set $t-&gt;ru_utime to 100.0 sec and $t-&gt;ru_stime to 5.0 sec.
               $t-&gt;ru_utime-&gt;tv_secs(100);
               $t-&gt;ru_utime-&gt;tv_usecs(0);
               $t-&gt;ru_stime-&gt;tv_secs(5);
               $t-&gt;ru_stime-&gt;tv_usecs(0);

       Example 2
           An accessor function can be redefined in order to provide additional checking of values, etc.
           Here, we want the "count" element always to be nonnegative, so we redefine the "count" accessor
           accordingly.

               package MyObj;
               use Class::Struct;

               # declare the struct
               struct ( 'MyObj', { count =&gt; '$', stuff =&gt; '%' } );

               # override the default accessor method for 'count'
               sub count {
                   my $self = shift;
                   if ( @_ ) {
                       die 'count must be nonnegative' if $_[0] &lt; 0;
                       $self-&gt;{'MyObj::count'} = shift;
                       warn "Too many args to count" if @_;
                   }
                   return $self-&gt;{'MyObj::count'};
               }

               package main;
               $x = new MyObj;
               print "\$x-&gt;count(5) = ", $x-&gt;count(5), "\n";
                                       # prints '$x-&gt;count(5) = 5'

               print "\$x-&gt;count = ", $x-&gt;count, "\n";
                                       # prints '$x-&gt;count = 5'

               print "\$x-&gt;count(-5) = ", $x-&gt;count(-5), "\n";
                                       # dies due to negative argument!

       Example 3
           The constructor of a generated class can be passed a list of <u>element</u>=&gt;<u>value</u> pairs, with which to
           initialize the struct.  If no initializer is specified for a particular element, its default ini-<font color="#ffffff" class="whiteout">tialization&nbsp;initialization</font>
           tialization is performed instead. Initializers for non-existent elements are silently ignored.

           Note that the initializer for a nested class may be specified as an object of that class, or as a
           reference to a hash of initializers that are passed on to the nested struct's constructor.

               use Class::Struct;

               struct Breed =&gt;
               {
                   name  =&gt; '$',
                   cross =&gt; '$',
               };

               struct Cat =&gt;
               [
                   name     =&gt; '$',
                   kittens  =&gt; '@',
                   markings =&gt; '%',
                   breed    =&gt; 'Breed',
               ];

               my $cat = Cat-&gt;new( name     =&gt; 'Socks',
                                   kittens  =&gt; ['Monica', 'Kenneth'],
                                   markings =&gt; { socks=&gt;1, blaze=&gt;"white" },
                                   breed    =&gt; Breed-&gt;new(name=&gt;'short-hair', cross=&gt;1),
                              or:  breed    =&gt; {name=&gt;'short-hair', cross=&gt;1},
                                 );

               print "Once a cat called ", $cat-&gt;name, "\n";
               print "(which was a ", $cat-&gt;breed-&gt;name, ")\n";
               print "had two kittens: ", join(' and ', @{$cat-&gt;kittens}), "\n";

<b>Author</b> <b>and</b> <b>Modification</b> <b>History</b>
       Modified by Damian Conway, 2001-09-10, v0.62.

          Modified implicit construction of nested objects.
          Now will also take an object ref instead of requiring a hash ref.
          Also default initializes nested object attributes to undef, rather
          than calling object constructor without args
          Original over-helpfulness was fraught with problems:
              * the class's constructor might not be called 'new'
              * the class might not have a hash-like-arguments constructor
              * the class might not have a no-argument constructor
              * "recursive" data structures didn't work well:
                        package Person;
                        struct { mother =&gt; 'Person', father =&gt; 'Person'};

       Modified by Casey West, 2000-11-08, v0.59.

           Added the ability for compile time class creation.

       Modified by Damian Conway, 1999-03-05, v0.58.

           Added handling of hash-like arg list to class ctor.

           Changed to two-argument blessing in ctor to support
           derivation from created classes.

           Added classname prefixes to keys in hash-based classes
           (refer to "Perl Cookbook", Recipe 13.12 for rationale).

           Corrected behaviour of accessors for '*@' and '*%' struct
           elements.  Package now implements documented behaviour when
           returning a reference to an entire hash or array element.
           Previously these were returned as a reference to a reference
           to the element.

       Renamed to "Class::Struct" and modified by Jim Miner, 1997-04-02.

           members() function removed.
           Documentation corrected and extended.
           Use of struct() in a subclass prohibited.
           User definition of accessor allowed.
           Treatment of '*' in element types corrected.
           Treatment of classes as element types corrected.
           Class name to struct() made optional.
           Diagnostic checks added.

       Originally "Class::Template" by Dean Roehrich.

           # Template.pm   --- struct/member template builder
           #   12mar95
           #   Dean Roehrich
           #
           # changes/bugs fixed since 28nov94 version:
           #  - podified
           # changes/bugs fixed since 21nov94 version:
           #  - Fixed examples.
           # changes/bugs fixed since 02sep94 version:
           #  - Moved to Class::Template.
           # changes/bugs fixed since 20feb94 version:
           #  - Updated to be a more proper module.
           #  - Added "use strict".
           #  - Bug in build_methods, was using @var when @$var needed.
           #  - Now using my() rather than local().
           #
           # Uses perl5 classes to create nested data types.
           # This is offered as one implementation of Tom Christiansen's "structs.pl"
           # idea.



perl v5.8.8                                      2001-09-21                               Class::Struct(3pm)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/Class__Struct.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/Class__Struct.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/Class__Struct.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
