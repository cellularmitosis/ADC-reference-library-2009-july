<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>ZAM - /GameSource/GameAEvents.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGames-date.html">Games</a> &gt; <A HREF="javascript:location.replace('index.html');">ZAM</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Games/index.html" target="_blank">Reference Library > Games</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">ZAM</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/GameSource/GameAEvents.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/CoreHeaders/CoreGlobals.h</option>
<option value="listing2.html">/CoreHeaders/EventLoop.h</option>
<option value="listing3.html">/CoreHeaders/MenuDispatch.h</option>
<option value="listing4.html">/CoreHeaders/WindowDispatch.h</option>
<option value="listing5.html">/CoreSource/AdjustMenus.c</option>
<option value="listing6.html">/CoreSource/AEventCoreDisp.c</option>
<option value="listing7.html">/CoreSource/Document.c</option>
<option value="listing8.html">/CoreSource/ErrMsg.c</option>
<option value="listing9.html">/CoreSource/EventLoop.c</option>
<option value="listing10.html">/CoreSource/GetBackTime.c</option>
<option value="listing11.html">/CoreSource/InitMac.c</option>
<option value="listing12.html">/CoreSource/Main.c</option>
<option value="listing13.html">/CoreSource/MenuDispatch.c</option>
<option value="listing14.html">/CoreSource/WindowDispatch.c</option>
<option value="listing15.html">/Dude #includes.c</option>
<option value="listing16.html">/GameHeaders/Document.h</option>
<option value="listing17.html">/GameHeaders/FixGraf.h</option>
<option value="listing18.html">/GameHeaders/GameAEvents.h</option>
<option value="listing19.html">/GameHeaders/GameDef.h</option>
<option value="listing20.html">/GameHeaders/GameSounds.h</option>
<option value="listing21.html">/GameHeaders/MissileSprite.h</option>
<option value="listing22.html">/GameHeaders/Sprite.h</option>
<option value="listing23.html">/GameHeaders/SpriteFrameRates.h</option>
<option value="listing24.html">/GameHeaders/TankSprite.h</option>
<option value="listing25.html">/GameHeaders/xqueue.h</option>
<option value="listing26.html">/GameHeaders/xthing.h</option>
<option value="listing27.html">/GameHeaders/ZAM.h</option>
<option value="listing28.html">/GameSource/DirectionTable.c</option>
<option value="listing29.html">/GameSource/ExplosionSprites.c</option>
<option value="listing30.html">/GameSource/FixGraf.c</option>
<option value="listing31.html">/GameSource/GameAEvents.c</option>
<option value="listing32.html">/GameSource/GameMenu.c</option>
<option value="listing33.html">/GameSource/GameSounds.c</option>
<option value="listing34.html">/GameSource/IncidentalSounds.c</option>
<option value="listing35.html">/GameSource/InitGame.c</option>
<option value="listing36.html">/GameSource/MissileAEvents.c</option>
<option value="listing37.html">/GameSource/MissileSprite.c</option>
<option value="listing38.html">/GameSource/pixiZAM - direct blitter/pixiZAM.c</option>
<option value="listing39.html">/GameSource/pixiZAM - direct blitter/pixiZAM.h</option>
<option value="listing40.html">/GameSource/SlamPixels.c</option>
<option value="listing41.html">/GameSource/Sprite.c</option>
<option value="listing42.html">/GameSource/Sprite.proto.h</option>
<option value="listing43.html">/GameSource/SpriteColission.c</option>
<option value="listing44.html">/GameSource/SpriteFrameSet.c</option>
<option value="listing45.html">/GameSource/SpriteLayer.c</option>
<option value="listing46.html">/GameSource/TankSprite.c</option>
<option value="listing47.html">/GameSource/xqueue.c</option>
<option value="listing48.html">/GameSource/xthing.c</option>
<option value="listing49.html">/GameSource/ZAMProtos.h</option>
<option value="listing50.html">/UtilCode/CoreAssertion.c</option>
<option value="listing51.html">/UtilCode/CoreAssertion.h</option>
<option value="listing52.html">/UtilCode/DialogUtil.c</option>
<option value="listing53.html">/UtilCode/GrafUtils.c</option>
<option value="listing54.html">/UtilCode/GrafUtils.h</option>
<option value="listing55.html">/UtilCode/GWorldUtils.c</option>
<option value="listing56.html">/UtilCode/GWorldUtils.h</option>
<option value="listing57.html">/UtilCode/IsPressed.c</option>
<option value="listing58.html">/UtilCode/WindowUtil.c</option></select>
				</p>
				</form>
				<p><strong><a href="ZAM.zip">Download Sample</a></strong> (&#147;ZAM.zip&#148;, 73.3K)<BR>
<strong><a href="ZAM.dmg">Download Sample</a></strong> (&#147;ZAM.dmg&#148;, 125.6K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">#include &quot;GameAEvents.h&quot;#include &quot;ZAM.h&quot;#include &quot;WindowDispatch.h&quot;#include &quot;TankSprite.h&quot;#include &quot;MissileSprite.h&quot;#include &quot;CoreGlobals.h&quot;#include &quot;ZAMProtos.h&quot;#define rNotifySICN 128#define rWakeUpSND  128#define kDiamondMark 1#define rReqGameAlert 130#define AcceptBtnItem 1pascal OSErr AERequestGame ( AppleEvent *theAE, AppleEvent *reply, long rfCon);pascal OSErr AEAcceptGame ( AppleEvent *theAE, AppleEvent *reply, long rfCon);pascal OSErr AERefuseGame ( AppleEvent *theAE, AppleEvent *reply, long rfCon);pascal OSErr AEAnswer (AppleEvent *theAE, AppleEvent *reply, long rfCon);pascal OSErr AEGoodbye (AppleEvent *theAE, AppleEvent *reply, long rfCon);pascal OSErr AEAckTime(AppleEvent *theAE, AppleEvent *reply, long rfCon);pascal OSErr AESynchTank ( AppleEvent *theAE, AppleEvent *reply, long rfCon);Boolean  gByeNeeded;long  gLastSynchTime;long  gLocalTime;long  gLastReturnTime;void InstallCustomEvents(gamePtr game)/*  This installs the apple event handlers used by the game.  */{  OSErr      err = noErr;  gByeNeeded = false;  gLastSynchTime = 0;  gLastReturnTime = 0;  gLocalTime = 0;  err = AEInstallEventHandler (kCoreEventClass, kAEAnswer, AEAnswer, (long)game, false);  if(err) {    ErrMsgCode(&quot;\pCould not install AE handler.&quot;,err);    ExitToShell();  }  err = AEInstallEventHandler (kZAMEventClass, kRequestGameID, AERequestGame,(long)game, false);  if(err) {    ErrMsgCode(&quot;\pCould not install AE handler.&quot;,err);    ExitToShell();  }  err = AEInstallEventHandler (kZAMEventClass, kGoodByeID, AEGoodbye,(long)game, false);  if(err) {    ErrMsgCode(&quot;\pCould not install AE handler.&quot;,err);    ExitToShell();  }  err = AEInstallEventHandler (kZAMEventClass, kTankSynchID, AESynchTank, (long)game, false);  if(err) {    ErrMsgCode(&quot;\pCould not install AE handler.&quot;,err);    ExitToShell();  }}void SendGoodBye(void)/*  When quit is selected it calls this function, which sends a message to the other player,  letting them know you are no longer around.    It would be nice if the quit handler displayed even a simple dialog,  but this was a pain for my testing, so I made it just quit.  Of course a real  application would not behave this way.*/{  AppleEvent    goodByeEvt;  AppleEvent    reply;  OSErr      err = noErr;  Boolean      disposeNeeded = false;#ifdef NO_NET  return;#endif    if(gByeNeeded) {        err = AECreateAppleEvent(kZAMEventClass, kGoodByeID, &amp;gGame-&gt;oppAddr,           kAnyTransactionID, gGame-&gt;gameID, &amp;goodByeEvt);    if(err != noErr) {      ErrMsgCode(&quot;\p Failure: SendGoodBye AECreateAppleEvent&quot;,err);    }          if(err == noErr) {      disposeNeeded = true;      err = AESend(&amp;goodByeEvt, &amp;reply, kAENoReply + kAECanInteract,           kAEHighPriority, 60 * 60, nil, nil);      if(err != noErr) {        ErrMsgCode(&quot;\p SendGoodBye: AESend goodByeEvt&quot;,err);      }    }            if(disposeNeeded) {      AEDisposeDesc(&amp;goodByeEvt);    }  }}pascal OSErr AEGoodbye (AppleEvent *theAE, AppleEvent *reply, long rfCon)/*  This is the handler for when the remote mac has quit.  It does not display any warning dialog box, because as I mentioned before,  in a code-build-test cycle, it was too much to be navigating dialogs and stuff.  So, it just causes the program to quit without warning.*/{  gDone = true;  gByeNeeded = false;}pascal OSErr AEAnswer(AppleEvent *theAE, AppleEvent *reply, long rfCon)/*  This handler is used for the apple events that return a result asynchronously.  The type of reply is stored in the keyReturnIDAttr.  The only events that require  a reply are the request game event, and the synch event.  Another synch event will  not be sent until an ack is received.*/{  long      actType,actSize;  short      retID;  OSErr      err= noErr;      err = AEGetAttributePtr(theAE, keyReturnIDAttr,  typeShortInteger, &amp;actType,              &amp;retID, sizeof(short), &amp;actSize);  if(err != noErr) {    ErrMsgCode(&quot;\pAEAnswer: AEGetAttr keyReturnIDAttr&quot;,err);  }  if(err == noErr) {    switch(retID) {      case  kAcceptID:  err = AEAcceptGame(theAE, reply, rfCon);      break;            case  kTimeID:  err = AEAckTime(theAE, reply, rfCon);      break;            default:  ErrMsgCode(&quot;\pUnknown Return ID.&quot;,retID);      break;    }      }    return err;}pascal OSErr AEAckTime(AppleEvent *theAE, AppleEvent *reply, long rfCon)/*  just grab the time so the synch event will not flood the wire with  unhandled events.  This is not a REAL appleevent handler, it just  looks like one, because it was easier that way.  This is actually called  by the return event handler, above.*/{  OSErr    err = 0;  long    len;  DescType  actualType;  long    synchTime;  err = AEGetParamPtr(theAE, keySynchTime, typeLongInteger, &amp;actualType,       &amp;gLastReturnTime, sizeof(long), &amp;len);        if(err != noErr) {    ErrMsgCode(&quot;\p Failed: AEAckTime keySynchTime, typeLongInteger&quot;,err);  }  return err;}pascal OSErr AEAcceptGame(AppleEvent *theAE, AppleEvent *reply, long rfCon)/*  This event comes back when the other player accepts the game.  Any ZAM game will  accept if it is not already playing.  I used to have code to allow you to type in  a name, and request a game, and the other player would be able to decide if they  wanted to or not.  Again, this really hampered my code-compile-test cycle, so I stripped  or commented it out.  You could probably revive it if you wanted to.    This is not a REAL appleevent handler, it just  looks like one, because it was easier that way.  This is actually called  by the return event handler, above.*/{  OSErr      err = noErr;  long      actualType,longSize;  Boolean      acceptFlag;    if(gGame == nil) {    ErrMsg(&quot;\pReceived accept when never made window&quot;);    err = paramErr;  }      if(gGame-&gt;gameState == kWaitingForAccept) {    err = AEGetParamPtr(theAE, keyAnswer, typeBoolean, &amp;actualType,         &amp;acceptFlag, sizeof(Boolean), &amp;longSize);    if(err != noErr) {      ErrMsgCode(&quot;\p Failed: AEAcceptGame AEGetParamPtr typeBoolean&quot;,err);    }        if(err == noErr)      if(acceptFlag) {        gGame-&gt;gameState = kGameInProgress;        /* Set up tank indexes here */        gGame-&gt;localTankIndex = 0;        gGame-&gt;remoteTankIndex = 1;        PlaceTankSprites(gGame);        gByeNeeded = true;      } else {        /* display rejection notice */        ParamText(&quot;\pThat person has refused your challenge. Try another.&quot;,nil,nil,nil);        (void) Alert(131,nil);    // evil numbers must go        gGame-&gt;gameState = kWaitingForRequest;      }  }      return err;}pascal OSErr AERequestGame( AppleEvent *theAE, AppleEvent *reply, long rfCon)/*  This BIG ugly function handles requests for a game from another player  and starts things rolling.  It changes the game state flag, but  this flag is mostly ignored by the rest of the program.  At one time  I was using it, but I was not setting it properly all the time, and there  were more important bugs to fix so I just crippled it.    */{  OSErr      err = noErr;  short      itemHit;  DescType    returnedType;  Size      length;  long      replyID;  Str255      nameStr;  AEAddressDesc  targetAddress;  AppleEvent    replyEvent;  Boolean      acceptFlag = true;  ulong      tranID;  if(err == noErr) {    if(gGame-&gt;gameState != kWaitingForRequest) {      /* just automagically refuse the game cause we are busy */      acceptFlag = false;      err = AEPutParamPtr(reply, keyAnswer, typeBoolean, &amp;acceptFlag, sizeof(Boolean));      if(err != noErr)  {        ErrMsgCode(&quot;\p AERequestGame: AEPutParamPtr keyAnswer FALSE&quot;,err);      }    } else {          /* get the address of the person requesting we play */      if(err == noErr) {        err = AEGetAttributeDesc ( theAE, keyAddressAttr, typeWildCard, &amp;targetAddress);        if(err != noErr) {          ErrMsgCode(&quot;\p AERequestGame: AEGetAttr keyAddressAttr&quot;,err);        }      }            if(err == noErr) {        err = AEGetAttributePtr(theAE, keyTransactionIDAttr, typeLongInteger, &amp;returnedType,                  &amp;tranID, sizeof(long), &amp;length);        if(err != noErr) {          ErrMsgCode(&quot;\p AEGetAttr keyTransactionIDAttr&quot;,err);        }            }            if(err == noErr) {        /* ask user if they want to play */        /* NOTE:  this is where I used to display the dialog asking */        /* if a game was wanted or not */        /* now it always accepts */          acceptFlag = true;          if(err == noErr) {            gGame-&gt;oppAddr = targetAddress;            gGame-&gt;gameID = tranID;            gGame-&gt;localTankIndex = 1;            gGame-&gt;remoteTankIndex = 0;            gGame-&gt;gameState = kGameInProgress;            PlaceTankSprites(gGame);            gByeNeeded = true;          }          else if(err == paramErr) {            acceptFlag = false;            err = noErr;          }          if(err == noErr) {          err = AEPutParamPtr(reply, keyAnswer, typeBoolean, &amp;acceptFlag, sizeof(Boolean));          if(err != noErr)  {            ErrMsgCode(&quot;\p AERequestGame: AEPutParamPtr keyAnswer&quot;,err);          }                  }      }    }  }            return err;}pascal OSErr AESynchTank ( AppleEvent *theAE, AppleEvent *reply, long rfCon)/*  This is the network heartbeat of the game.  It recieves the state of the remote machine.    It does some things with AppleEvents for speed  reasons that a normal application would not want to do.  I send large structures  and arrays, instead of building platform independant AEDescLists and that sort of thing.  I send the current state of the tank, and the current state of all the missiles (from  a subroutine call, see the code).*/{  OSErr    err = 0;  long    len;  DescType  actualType;  long    synchTime;  TankStatus  tStatus;  /* first thing is to get the synch time to see if this one     should be ignored.  The synch time is saved off each time    so the network is not flooded with synch events.    It is very easy to flood a network with these things.    Sometimes a mac may be busy and miss a few events, and then when it gets back    to it, it caused a hyper-spurt of animation while the mac caught up    and processed the apple events.  This was undesireable for my sample, so    I implemented this strategy of synching */       if(err == noErr) {    /* get the synch time to see if we should ignore this or not*/    err = AEGetParamPtr(theAE, keySynchTime, typeLongInteger, &amp;actualType,         &amp;synchTime, sizeof(long), &amp;len);    if(err != noErr) {      ErrMsgCode(&quot;\p Failed: AESynchTank keyTankPosition, typefixPt&quot;,err);    }  }    if(err == noErr) {    /* send the synch time back */    err = AEPutParamPtr(reply, keySynchTime, typeLongInteger,               &amp;synchTime, sizeof(long));    if(err != noErr) {      ErrMsgCode(&quot;\p Failure: AESynchTank AEPutParamPtr reply&quot;,err);    }  }    if(err == noErr) {    if(gLastSynchTime &gt; synchTime)      err = 1;    else      gLastSynchTime = synchTime;  }  /*    this gets the status of the tank from the event */  if(err == noErr) {    err = AEGetParamPtr(theAE, keyTankStatus, typeTankStatus, &amp;actualType,         &amp;tStatus, sizeof(TankStatus), &amp;len);    if(err != noErr) {      ErrMsgCode(&quot;\p Failed: AESynchTank keyTankStatus typeTankStatus&quot;,err);    }  }    /* if we got the status of the tank ok, then we call the Synch. Tank function    (See TankSprites.c) to make sure the tank is in the right place doin the right    thing.        After that, the remote missiles are updated by passing the whole applevent    to  MissileSprites.c via ProcessMissilePositions.  */  if(err == noErr) {    SynchronizeTank(gGame, &amp;tStatus.position, tStatus.direction, tStatus.speed);    err = ProcessMissilePositions(theAE);  }  /* eat the synch time errors */  if(err == 1) err = noErr;  return err;}Boolean TankSynchTask(xthing *xtp, spritePtr spr)/*  This is a timed task managed by the xthing time manager.  It sends the state of the tank and the state of the missiles  to the remote mac.    See the notes above about abusing and sending structures using AppleEvents.    Good.  Now that you have read that, I'll elaborate more.  One of the key concepts with scriptable AppleEvent programs is to  use tagged data so that any application can determine the format of  parameters and send them along in a happy manner.  This may require many  calls to AEPutParamPtr and such, which may also cause the AppleEvent record  to grow multiple times, and can cause a slow down for a real time application  like this.  So, to minimize this, I kind go against the grain of AppleEvents and  just send a big block of data.  The good design thing for me to have done, which I  didn't, would have been to isolate the network code a little more, so that any layer could  be plugged in.*/{  OSErr      err = noErr;  AppleEvent    tankSynchEvent;  AppleEvent    reply;  tankInfoRec    *tInfo;  Boolean      disposeNeeded = false;  long      tickTime;  TankStatus    tStatus;    if(gLastReturnTime != gLocalTime)  return true;  tInfo = (tankInfoRec*)spr-&gt;refCon;    err = AECreateAppleEvent(kZAMEventClass, kTankSynchID, &amp;gGame-&gt;oppAddr,         kTimeID, gGame-&gt;gameID, &amp;tankSynchEvent);  if(err != noErr) {    ErrMsgCode(&quot;\p Failure: FireNetworkMissile AECreateAppleEvent&quot;,err);  }      /*    This is where the time stamp is incremented, and placed into the appleevnet.    This is sent back in the reply event */      if(err == noErr) {    disposeNeeded = true;    gLocalTime++;    err = AEPutParamPtr(&amp;tankSynchEvent, keySynchTime, typeLongInteger,               &amp;gLocalTime, sizeof(long));    if(err != noErr) {      ErrMsgCode(&quot;\p Failure: AEPutParamPtr&quot;,err);    }  }  /* load up the tank info and stuff it into the event */  tStatus.position = spr-&gt;loc;  tStatus.direction = tInfo-&gt;dir;  tStatus.speed = tInfo-&gt;speed;    if(err == noErr) {    err = AEPutParamPtr(&amp;tankSynchEvent, keyTankStatus, typeTankStatus,               &amp;tStatus, sizeof(TankStatus));    if(err != noErr) {      ErrMsgCode(&quot;\p Failure: AEPutParamPtr keyTankStatus, typeTankStatus&quot;,err);    }  }    /* getting a little more structured here, I call out to add the missile information */  /* to the event.  CAn you tell that I did the tank stuff first, and missile stuff     later? */  if(err == noErr) {    err = AppendMissilePositions(&amp;tankSynchEvent);    if(err != noErr) {      ErrMsgCode(&quot;\pError appending missile positions.&quot;,err);    }  }  if(err == noErr) {    err = AESend(&amp;tankSynchEvent, &amp;reply, kAEQueueReply + kAECanInteract,         kAEHighPriority, kNoTimeOut, nil, nil);    if(err != noErr) {      ErrMsgCode(&quot;\p Failure: AESend&quot;,err);    }  }  if(disposeNeeded) {    AEDisposeDesc(&amp;tankSynchEvent);  }  return true;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/ZAM/listing31.html%3Fid%3DDTS10000063-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/ZAM/listing31.html%3Fid%3DDTS10000063-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/ZAM/listing31.html%3Fid%3DDTS10000063-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>