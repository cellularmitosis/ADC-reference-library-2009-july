<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><html><head><LINK REL="stylesheet" HREF="../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../style.css" TYPE="text/css"><title>Technical Note QT05: Component Manager version 3.0</title><meta name="keywords" content="Mac OS 7 QuickTime Component Manager features 3 PowerPc RegisterComponentResourceFile "><meta name="Description" content="Technical Note QT05: This Technical Note contains informationregarding the version of the Component Manager that shippedwith QuickTime 1.6 and the changes necessary to support nativePowerPC components.">                                       <meta name="categories" content="QuickTime"><meta name="week-posted" content="Feb 28, 1994 - Mar 4, 1994"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002747" title="Component Manager version 3.0"></a><a name="top"></A><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxQuickTime-date.html">QuickTime</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/QuickTime/index.html" target="_blank">Reference Library > QuickTime</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note QT05</div>
<div id="pageheadsub">Component Manager version 3.0</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->										<p id="menutext"><A HREF="#Section1">Introduction</A><BR><BR><A HREF="#Section2">Component Manager version 3 routines</A><BR><BR><A HREF="#Section3">How to create a PowerPC ComponentResource</A><BR><BR><A HREF="#Section4">Component Manager interfaces</A><BR><BR><A HREF="#References">References</A><BR><BR><A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><P id = "introtext">This note contains information regarding the version of the Component Managerthat shipped with QuickTime 1.6 and the changes necessary to support nativePowerPC components.</p><!-- end_intro_text --><!-- begin_date --><h3 align=center>[Mar 01 1994]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR>          <!-- begin_content -->            <a name="Section1"></a><H2>Introduction</h2><p>The Component Manager in QuickTime 1.6.x and for the Power Macintosh (PowerPC) release has some new features. It has added the ability to automaticallyresolve conflicts between different versions of the same component. It will ensure that only the most recent version of a given component is actually registered. The Component Manager now supports Icon Suites for a component, so a component's icon no longer has to be just black and white. In addition, the Component Manager can support code written in the native format of the PowerPC.</p><p>The result returned for the <code>Gestalt</code> selector <code>gestaltComponentMgr</code> will be 3,indicating version number 3 of the Component Manager. This is the version beingdiscussed in this note. To insure that you have the features discussed here,check that version 3 is installed.</p><p>For support of the Power Macintosh, the Component Manager has been extended toallow use of native PowerPC components. When the Component Manager loads anative component on the Power Macintosh, it calls uses the Code FragmentManager and calls <code>GetMemFragment</code> and then later <code>CloseConnection</code> when it unloadsyour code resource (specified in a <code>ComponentPlatformInfo</code>). This is how theComponent Manager supports a native code fragment.</p><p>A component can support multiple platforms such as the 68K and PowerPC.Existing 68K code is always supported on the Power Macintosh through emulation.But you can also have native PowerPC code for your component to support betterperformance. The Component Manager will allow you to create a component thatcontains both code formats, so that you can support all platforms with a singlecomponent. The Component Manager also was extended in a way that allows fornative PowerPC only components (without any 68K code support).</p><h3>Extended ComponentResource</h3><p>The <code>ComponentResource</code> data structure (the <code>'thng'</code> resource) has been extended.These extensions define additional information about the component. Thecomplete data structure is shown below. The first portion is the same as theexisting <code>ComponentResource</code>, with the new fields added at the end. The ComponentManager determines if it is present by examining the size of the 'thng' resource.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>struct ExtComponentResource {    ComponentDescription cd; /* Registration parameters */    ResourceSpec component;    /* resource where Component code is found */    ResourceSpec componentName; /* name string resource */    ResourceSpec componentInfo; /* info string resource */    ResourceSpec componentIcon; /* icon resource */    // new data for Component Manager version 3    long componentVersion; /* version of Component */    long componentRegisterFlags; /* flags for registration */    short componentIconFamily; /* resource id of Icon Family */    long count; /* elements in platformArray */    ComponentPlatformInfo platformArray[1];};</pre>	</TD></TR></TABLE></CENTER><h3>componentVersion </h3><p>The componentVersion field contains the version number of the component. Thisshould be identical to the value returned by <code>GetComponentVersion</code>. For convenience, if this value is set to 0, the component is called to get the version. This is useful during development. The version number stored in the <code>ComponentResourceExtension</code> is used by the Component Manager to avoid having to load and call the component to retrieve the component's version during startup.</p><h3>componentRegisterFlags </h3><p>The <code>componentRegisterFlags</code> allow you to define additional register information.These flags are discussed below.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>/* Component Resource Extension flags */componentDoAutoVersion = (1&lt;&lt;0)componentWantsUnregister = (1&lt;&lt;1)componentAutoVersionIncludeFlags = (1&lt;&lt;2)componentHasMultiplePlatforms = (1&lt;&lt;3)</pre>	</TD></TR></TABLE></CENTER><p>The <code>componentDoAutoVersion</code> flag tells the Component Manager that you want yourcomponent registered only if there is no later version available. If there isan older version of the component installed, it will be unregistered. If anolder version of the same component attempts to register after you, it will beimmediately unregistered. Further, if a newer version of the same componentregisters after you, you will automatically be unregistered. Using theautomatic version control feature of the Component Manager allows you to makesure that only the most recent version of your software is running on a givenmachine, regardless of how many versions may be installed.</p><p>The <code>componentWantsUnregister</code> flag indicates that your component wants to becalled when it is unregistered. This is useful if your component allocatesglobal memory at register time, for example. The prototype of the unregistermessage is identical to the register message. If your component has never beenopened, its unregister message is not be called. The routine selector forunregister is given below.</p><p>The <code>componentAutoVersionIncludeFlags</code> flag tells the Component Manager to usethe component flags as criteria for its component search. If a component wantsautomatic version control, the Component Manager has to search for similarcomponents. Normally, the Component Manager searches only for another componentusing the type, subType, and manufacturer fields of a <code>ComponentDescription</code>record. This flag tells the Component Manager to include the componentFlags inits search.</p><p>The <code>componentHasMultiplePlatforms</code> flag indicates that your component containsmultiple versions of the code for different platforms. If you plan onsupporting the PowerPC native code format, then you need to use the<code>ComponentPlatformInfo</code> within the component resource structure. Then set thisbit in the <code>componentRegisterFlags</code> field. If this bit is not set then the codeis assumed to be 68K format. Without this flag being set, the Component Managerwill ignore any <code>ComponentPlatformInfo</code>.</p><h3>componentIconFamily </h3><p>Finally, the componentIconFamily field allows you to provide the resource ID ofa System 7 Icon Suite. If this field is 0, it indicates that there is no icon suite.</p><h3>count</h3><p>This is the number of elements contained in the ComponentPlatformInfo array.</p><h3>platformArray</h3><p>This is an array of elements that describe the code to be used for differentplatforms. If the platform is for 68K, then the information within this elementis a copy from the <code>componentFlags</code> of the <code>ComponentDescription</code> and ResourceSpecof the original <code>ComponentResource</code> structure. This insures backwardscompatibility with older Component Managers. If the component contains nativecode support for the PowerPC, then an element of the array will contain theinformation about its <code>componentFlags</code>, resource type, and resource ID.</p><p>The <code>platformType</code> field is a value that represents which platform the componentcode is to support. The Gestalt result for selector <code>gestaltSysArchitecture</code> willbe matched with the value in platformType of the <code>ComponentResource</code>. If a matchis found, then that code is used to support the given platform.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    gestalt68k        = 1, /* Motorola MC68K architecture    */    gestaltPowerPC    = 2, /* IBM PowerPC architecture        */</pre>	</TD></TR></TABLE></CENTER><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>struct ComponentPlatformInfo{    long            componentFlags; /* flags of Component */    ResourceSpec    component; /* resource where Component code is found */    short            platformType; /* gestaltSysArchitecture result */};</pre>	</TD></TR></TABLE></CENTER><a name="Section2"></a><P><A HREF="#top">Back to top</A></p><H2>Component Manager version 3 routines</h2><h3>GetComponentIconSuite</h3><p><code>GetComponentIconSuite</code> returns an Icon Suite for the given component. This callworks only under System 7 or later. If called on System 6, it returns an error.If the component doesn't have an Icon Suite but does have a Component Icon (asreturned by <code>GetComponentInfo</code>), <code>GetComponentIconSuite</code> creates an Icon Suitecontaining just the black-and-white Component Icon. In this way, you can use<code>GetComponentIconSuite</code> whether or not a component has an Icon Suite.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal OSErr GetComponentIconSuite(Component aComponent, Handle *iconSuite)aComponent        Component ID, retrieved with FindNextComponent.iconSuite        Pointer to the Icon Suite you will receive.</pre>	</TD></TR></TABLE></CENTER><h3>RegisterComponent</h3><h3>RegisterComponentResource</h3><h3>RegisterComponentResourceFile</h3><p>The only change made to these routines was to modify the use of the globalparameter. The upper byte now contains the platform ID to be used by thecomponent being registered. This change is necessary because these calls do nothave access to the <code>ComponentResource</code> which contains the <code>ComponentPlatformInfo</code>.If the upper byte of the global parameter is zero, then the platform is assumedto be the platform68k.</p><a name="Section3"></a><P><A HREF="#top">Back to top</A></p><H2>How to create a PowerPC ComponentResource</h2><p>The basics step for running on a Power Macintosh with a native component are:</p><ul type="disc">	<li>Create component code fragment with native PowerPC code</li>	<li>Main entry point to code is a mixed mode routine descriptor</li>	<li>Package component code fragment as a resource</li>	<li>If you supply an interface for the component to be called directly, then for PowerPC code to call your component you must provide custom glue to make the call.</li>	<li>Create the extended <code>'thng'</code> resource using the <code>ComponentPlatformInfo</code></li></ul><p>Each of these steps are discussed in more detail below:</p><h3>Creating the component code fragment</h3><p>The first step in creating a native PowerPC component is to port your code.For complete details on porting to PowerPC, see <i>Inside Macintosh: PowerPCSystem Software.</i>  Especially important for the following discussion is anunderstanding of the Mixed Mode and Code Fragment Managers.</p><p>Like other code ported for PowerPC, anytime your code uses a callback function(<code>ProcPtr</code>), it must be converted to a <code>UniversalProcPtr</code>.  But unlike callbacksdefined by the system, callbacks to your component have their own functionprototypes.  With the exception of some callbacks defined for QuickTimecomponents, there are no system supplied function prototypes orUniversalProcPtrs, so you must create these yourself.</p><p>If, in response to a request code, your component dispatches to internalfunctions using <code>CallComponentFunction</code> or <code>CallComponentFunctionWithStorage</code>, thenthis is a place where you must use a <code>UniversalProcPtr</code>.</p><p>Suppose your component currently responds to an open request as follows:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>        switch (params-&gt;what)        {            case kComponentOpenSelect: /* Open request */            {            result = CallComponentFunctionWithStorage (storage, params, MyOpen);            break;            }</pre>	</TD></TR></TABLE></CENTER><p><code>MyOpen</code> is an internal function callback, so you must create a<code>RoutineDescriptor/UniversalProcPtr</code> for it.  <code>MyOpen</code> is declared as follows:</p><p>The first step is to create a ProcInfo value for this function:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>enum {    uppMyOpenProcInfo = kPascalStackBased        | RESULT_SIZE(SIZE_CODE(sizeof(ComponentResult)))        | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(Handle)))        | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(ComponentInstance)))};</pre>	</TD></TR></TABLE></CENTER><p>Next you must update your source to build a <code>UniversalProcPtr</code> and use it.  Youcould use <code>NewRoutineDescriptor</code> for this purpose, but the disadvantage is thatcreates a heap object which your component must dispose of properly.</p><p>An alternate approach is to declare a global <code>RoutineDescriptor</code> (globalvariables are not a problem for a native PowerPC component, since a codefragment automatically has global variables):</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>#ifdef powercRoutineDescriptor MyOpenRD = BUILD_ROUTINE_DESCRIPTOR (uppMyOpenProcInfo, MyOpen);#endif</pre>	</TD></TR></TABLE></CENTER><p>If you want your code to be compilable for both 68K and PowerPC, using theUniversal Interfaces, then to avoid a lot of conditional compilation, thefollowing macros may be useful:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>#ifdef powerc#define CallComponentFunctionWithStorageUniv(storage, params, funcName) \    CallComponentFunctionWithStorage(storage, params, &amp;funcName##RD)#define CallComponentFunctionUniv(params, funcName) \    CallComponentFunction(params, &amp;funcName##RD)#define INSTANTIATE_ROUTINE_DESCRIPTOR(funcName) RoutineDescriptor funcName##RD = \    BUILD_ROUTINE_DESCRIPTOR (upp##funcName##ProcInfo, funcName)#else#define CallComponentFunctionWithStorageUniv(storage, params, funcName) \    CallComponentFunctionWithStorage(storage, params, (ComponentFunctionUPP)funcName)#define CallComponentFunctionUniv(params, funcName) \    CallComponentFunction(params, (ComponentFunctionUPP)funcName)#endif</pre>	</TD></TR></TABLE></CENTER><p>These macros, exactly analogous to <code>CallComponentFunction</code> and <code>CallComponentFunctionWithStorage</code>, generate the appropriate code when compiled for 68K and PowerPC.  Note that the PowerPC macro expansion depends on the global <code>RoutineDescriptor</code> name being <code>FuncNameRD</code>, i.e. the name of the function with RD appended.  The INSTANTIATE_ROUTINE_DESCRIPTOR macro can be used for that purpose:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>#ifdef powercINSTANTIATE_ROUTINE_DESCRIPTOR(MyOpen);#endif</pre>	</TD></TR></TABLE></CENTER><p>This is identical to the declaration of <code>MyOpenRD</code> earlier, but simplifies the editing.</p><p>With all the conditional stuff out of the way, then the original code cansimply be updated by replacing <code>CallComponentFunctionWithStorage</code> with<code>CallComponentFunctionWithStorageUniv</code>:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>        switch (params-&gt;what)        {            case kComponentOpenSelect: // Open request            {            result = CallComponentFunctionWithStorageUniv(storage, params, MyOpen);            break;            }</pre>	</TD></TR></TABLE></CENTER><p>Repeat the above steps for all internal component dispatches you make.</p><h3>Setting the main entry point</h3><p>Lastly, you must set up the entry point into your component correctly.  Unlikea 68K code resource, a PowerPC code fragment (which your component will be) hasa well defined entry point.  The Component Manager, rather than just jumping tothe start of the code resource, will call the main entry point, as defined whenlinking, instead.</p><p>But the Component Manager is 68K code, which means your main entry point mustbe a <code>RoutineDescriptor</code>.  You can set that up as follows:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal    ComponentResult    main (ComponentParameters *params,                                 Handle    storage);#ifdef powercenum {  uppMainProcInfo = kPascalStackBased| RESULT_SIZE(SIZE_CODE(sizeof(ComponentResult)))| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(ComponentParameters *)))| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(Handle)))};RoutineDescriptor MainRD = BUILD_ROUTINE_DESCRIPTOR(uppMainProcInfo, main);#endif</pre>	</TD></TR></TABLE></CENTER><p>When you link the component, you must then specify MainRD as the entry point.</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Your development environment may issue a warning because your mainentry point is in a data section, not a code section.  You may ignore the warning.</P></TD></TR></TABLE></CENTER><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>If your code is dependent on C or C++ runtime initializations, thenyour main entry point would be <code>__start</code> or <code>__cplusstart</code>, respectively, ratherthan main.  Modify the previous example accordingly.</P></TD></TR></TABLE></CENTER><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Some components rely on a "fast dispatching" mechanism for callingcomponent functions.  This mechanism is dependent on the 68K architecture andis unsupported for native components, although it will work for emulatedcomponents running on the Power Macintosh.</P></TD></TR></TABLE></CENTER><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Last Note:</B><BR>In all these modifications for PowerPC, the most difficult thingto get right is the <code>ProcInfo</code> value.  It's very easy to make a "cut and paste"error, or get a type wrong (short instead of short *).  If your component iscrashing the first thing to check (and check and check and check!) are the<code>ProcInfo</code> values.</P></TD></TR></TABLE></CENTER><BR><h3>Packaging the PowerPC component into a resource</h3><p>PowerPC development tools create your PowerPC code in a code fragment in thedata fork of the file.  Your component code must be a resource (the resource type and id are specified in the <code>'thng'</code> resource described below).  You can use the MPW Rez "read" command to read from the data fork into a resource. For example:</p><p>reads the code fragment from the file mycomponent.pef and creates the resource 'mycp'(130).</p><h3>Providing an interface to the component</h3><p>If you wish your component to be called directly, you must also supply aninterface so callers know how to call it.  For standard functions, such asOpen, Close, Version, etc., this is not a problem as the Component Managersupplies functions to do this for you.  Nor is this a problem if you arewriting QuickTime components, as QuickTime supplies standard interfaces andlibraries for calling components.</p><p>But one of the advantages of the Component Manager is it lets you define yourown routines with their own parameter lists, and for these routines you mustsupply an interface.  Typically, for 68K this involved providing callers aninterface file with function prototypes for your calls and inline 68K assemblyto actually make the call.</p><p>Obviously, the inline 68K code is a problem for a native PowerPC caller, so youmust provide glue to accomplish the same thing.  The following discussion alsoapplies to calling a 68K component from PowerPC code.  The interface is thesame, either way.</p><p>To take the example for Inside Macintosh: More Macintosh Toolbox, page 6-30,you might have a call like:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal ComponentResult DrawerSetup (ComponentInstance myInstance, Rect *r) =    ComponentCallNow (kDrawerSetUpSelect, 4);</pre>	</TD></TR></TABLE></CENTER><p><code>ComponentCallNow</code> is a macro that expands to inline 68K code that pushesadditional parameters and then executes an A-trap to call the Component Manager.</p><p>The first thing when using the new Universal Headers, is that the definition of<code>ComponentCallNow</code> has changed slightly.  The above declaration would change to:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal ComponentResult DrawerSetup (ComponentInstance myInstance, Rect *r)</pre>	</TD></TR></TABLE></CENTER><p>The only difference in this declaration is that the '=' character is missing.This is necessary to allow the code to compile for both 68K and PowerPC.</p><p>For 68K code, <code>ComponentCallNow</code> continues to expand to inline 68K code, but forPowerPC, the <code>ComponentCallNow</code> macro expands to nothing, which means the abovedeclaration reduces to:</p><p>You must now supply glue for <code>DrawerSetup</code> that does the same thing on PowerPC asthe 68K inlines would do.</p><p>The strategy here is to mimic what 68K code calling your component would do.Namely, push a bunch of parameters on the stack, then call the component.  Youdo that by building a struct that looks like the parameters <b>as they wouldappear on the 68K stack</b>.  Each call will require a different struct becauseeach call can have different parameters.</p><p>Use the struct below (<code>DrawerSetupGluePB</code>) as a template.  The first threefields, <code>componentFlags</code>, <code>componentParamSize</code>, and <code>componentWhat</code> are required, asis the last field, which is the component instance.</p><p><code>componentFlags</code> is unused and should be zero.</p><p><code>componentParamSize</code> is the size, in bytes, of the parameters to the call, notcounting the component instance.  This is the same number that is passed as thesecond parameter in a <code>ComponentCallNow</code> macro call, and should be the same asthe size of the params struct, discussed below.</p><p><code>componentWhat</code> is the selector for your component call.  Its the same as thefirst parameter to a <code>ComponentCallNow</code> macro call.</p><p>The params field is a separate struct that exactly mirrors your parameters.This must be customized for your call.  A separate struct is used here becauseit simplifies the <code>sizeof</code> calculation for the <code>componentParamSize</code> field. Parameters in this struct are specified in <i>reverse</i> order from the parameter list.</p>  <BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Remember that the struct mirrors 68K stack alignment, <i>not</i> 68Kstruct alignment.  This means that byte parameters, e.g., char or Boolean, getpassed as two bytes, not one. The struct must mirror that fact, so you mustdeclare byte fields to be a byte field followed by a pad byte field and take itinto account in your parameter size calculations.</P></TD></TR></TABLE></CENTER><BR><p>Once you have the struct, initialize it as shown in the example, and call thecomponent via <code>CallUniversalProc</code> with the <code>CallComponentUPP</code>.  <code>CallComponentUPP</code> isdeclared for you and is part of the InterfaceLib.  You don't need to doanything special to use it.</p><p><code>uppCallComponentProcInfo</code> should have been in the interfaces, because the callis always the same, but it's not, so it's defined below.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>enum {    uppCallComponentProcInfo = kPascalStackBased            | RESULT_SIZE(kFourByteCode)            | STACK_ROUTINE_PARAMETER(1, kFourByteCode)};</pre>	</TD></TR></TABLE></CENTER><p>Here's the code for the glue function.  Once you have the structure defined,create an instantiation of it, and initialize it.  Finally, call the component using <code>CallUniversalProc</code> as shown in the example.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal  ComponentResult DrawerSetup (ComponentInstance myInstance, Rect *r){#define kDrawerSetupParamSize (sizeof (DrawerSetupParams))#ifdef powerc#pragma options align=mac68k#endif struct DrawerSetupParams {   Rect    *theRect; /* Your parameters go here!!   In reverse order from parameter list. */    };   typedef struct DrawerSetupParams DrawerSetupParams;  struct DrawerSetupGluePB {   unsigned char componentFlags; /* Flags - set to zero */   unsigned char componentParamSize; /* Size of the params struct */   short componentWhat; /* The component request selector */   DrawerSetupParams params; /* The parameters, see above */   ComponentInstance instance; /* This component instance */    };   typedef struct DrawerSetupGluePB DrawerSetupGluePB;#ifdef powerc#pragma options align=reset#endif    DrawerSetupGluePB myDrawerSetupGluePB;    myDrawerSetupGluePB.componentFlags = 0;    myDrawerSetupGluePB.componentParamSize = kDrawerSetupParamSize;    myDrawerSetupGluePB.componentWhat = kDrawerSetUpSelect;    myDrawerSetupGluePB.params.theRect = r;    myDrawerSetupGluePB.instance = myInstance;    return CallUniversalProc(CallComponentUPP,            uppCallComponentProcInfo,  &amp;myDrawerSetupGluePB);}</pre>	</TD></TR></TABLE></CENTER><p>Repeat the above steps for all the public functions for your component. To allow for future updating, the best way to make this glue available to yourclients is to build the glue into a Code Fragment Manager shared library thatis built into your component.  Provide your client with an XCOFF file to linkagainst.  That way, if the glue changes, the client applications will not haveto be relinked.  Be sure you choose a unique name for the glue library to avoidpossible name conflicts.</p><h3>Creating the extended thng' ComponentResource</h3><p>Here is how to create the <code>'thng'</code> <code>ComponentResource</code> for a component thatsupports both <code>platform68k</code> and <code>platformPowerPC</code>. This is the source for MPW Rezusing the latest version of Types.r that supports the <code>UseExtendedThingResource</code>template. Before using the new Types.r you need to define the <code>UseExtendedThingResource</code>conditional with the value 1. A  component defined with this resource will work for all previous versions of the Component Manager. By keeping the original portions of the <code>ComponentResource</code> setup for the <code>platform68k</code> information, it allows your component to work on all 68K Macintosh computers. Adding the new information about your code fragment forthe Power Macintosh allows the Component Manager for that machine to use your native code.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>resource 'thng' (128, purgeable) {    kComponentType,    kComponentSubType,    kComponentCreator,    cmpWantsRegisterMessage,    kAnyComponentFlagsMask,    k68KCodeType, k68KCodeID,    'STR ', kComponentNameStringID,    'STR ', kComponentInfoStringID,    'ICON', kComponentIconID,#if UseExtendedThingResource    0x00010001, /* version 1.1 */    componentHasMultiplePlatforms,    kComponentIconFamilyID,    {        cmpWantsRegisterMessage, k68KCodeType, k68KCodeID, platform68k,        cmpWantsRegisterMessage, kPowerPCCodeType, kPowerPCCodeID, platformPowerPC    };#endif};</pre>	</TD></TR></TABLE></CENTER><p>If you have a component that only supports the 68K Macintosh, then you do notneed to use the extended <code>ComponentResource</code> structure. However, if you wish toutilize Icon Families and automatic version registration, then use the extended<code>ComponentResource</code> without the <code>ComponentPlatformInfo</code> and do not set the<code>componentHasMultiplePlatforms</code> flag of the <code>componentRegisterFlags</code>. You may alsoinclude the <code>ComponentPlatformInfo</code> if you wish to and just have a single elementthat describes your 68K component code.</p><p>If you have a "fat" component, with both 68K and PowerPC code, set thecomponent flags as you would for the 68K only case and duplicate thatinformation in the <code>ComponentPlatformInfo</code> portion of the extended resource.That will allow your component to work correctly for versions of the ComponentManager that are not aware of the extended <code>'thng'</code> resource.</p><p>If you have a component that only supports the PowerPC in native mode, then youmust use the extended <code>ComponentResource</code>. In this case, some care must be takenso that the component will not be registered on 68K machines.  Set the<code>ResourceSpec</code> field in the non-extended part of the <code>'thng'</code> resource to zero. Inaddition, set the component flags in the non-extended part  of the resource to<code>cmpWantsRegisterMessage</code>, <i>regardless of whether or not you handle theregister message.</i>  This will cause the 68K Component Manager to attempt toregister your component, it will fail, because there is no 68K code resourceand your component will not be registered.</p><p>For the PowerPC case, you need to include a single <code>ComponentPlatformInfo</code>element that describes your PowerPC native component code for PowerPCimplementations of your component to be registered.  Set the component flags inthe extended portion of the resource as you would normally.</p><a name="Section4"></a><P><A HREF="#top">Back to top</A></p><H2>Component Manager interfaces</h2><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>/* MPW Rez interfaces */#define cmpWantsRegisterMessage (1&lt;&lt;31) /* bits for component flags */#define componentDoAutoVersion (1&lt;&lt;0) /* bits for registration flags */#define componentWantsUnregister (1&lt;&lt;1)#define componentAutoVersionIncludeFlags (1&lt;&lt;2)#define componentHasMultiplePlatforms (1&lt;&lt;3)type 'thng' {    literal longint; /* Type */    literal longint; /* Subtype */    literal longint; /* Manufacturer */    unsigned hex longint; /* component flags */    unsigned hex longint kAnyComponentFlagsMask = 0;    /* component flags Mask */    literal longint; /* Code Type */    integer; /* Code ID */    literal longint; /* Name Type */    integer; /* Name ID */    literal longint; /* Info Type */    integer; /* Info ID */    literal longint; /* Icon Type */    integer; /* Icon ID */#if UseExtendedThingResource    unsigned hex longint; /* version of Component */    longint; /* flags for registration */    integer; /* resource id of Icon Family */    longint = $$CountOf(ComponentPlatformInfo);    wide array ComponentPlatformInfo {        unsigned hex longint; /* component  flags */        literal longint; /* Code Type */        integer; /* Code ID */        integer platform68k = 1, platformPowerPC = 2;        /* platform type */        };#endif};/* MPW C interfaces */enum {#define gestaltComponentMgr 'cpnt' /* Component Mgr version */#define gestaltQuickTimeFeatures 'qtrs' /* QuickTime features */    gestaltPPCQuickTimeLibPresent = 0,    /* PowerPC QuickTime glue library is present */#define gestaltSysArchitecture 'sysa' /* Native System Architecture */    gestalt68k = 1, /* Motorola MC68K architecture */    gestaltPowerPC = 2, /* IBM PowerPC architecture */    /* componentRegisterFlags flags for ComponentResourceExtension */    componentDoAutoVersion             = (1&lt;&lt;0),    componentWantsUnregister             = (1&lt;&lt;1),    componentAutoVersionIncludeFlags     = (1&lt;&lt;2),    componentHasMultiplePlatforms         = (1&lt;&lt;3)};struct ComponentPlatformInfo{    long            componentFlags; /* flags of Component */    ResourceSpec     component; /* resource where Component code is found */    short            platformType; /* gestaltSysArchitecture result */};typedef struct ComponentPlatformInfo ComponentPlatformInfo;struct ExtComponentResource {    ComponentDescription    cd; /* Registration parameters */    ResourceSpec     component; /* resource where Component code is found */    ResourceSpec    componentName; /* name string resource */    ResourceSpec    componentInfo; /* info string resource */    ResourceSpec    componentIcon; /* icon resource */    // new data for Component Manager version 3    long            componentVersion; /* version of Component */    long            componentRegisterFlags; /* flags for registration */    short            componentIconFamily; /* resource id of Icon Family */    long            count; /* elements in platformArray */    ComponentPlatformInfo platformArray[1];};typedef struct ExtComponentResource ExtComponentResource;</pre>	</TD></TR></TABLE></CENTER><a name="References"></a><P><A HREF="#top">Back to top</A></p><H2>References</h2><p><i>Inside Macintosh: More Macintosh Toolbox</i> (Component Manager)</p><p><i>Inside Macintosh: PowerPC System Software</i> (Mixed Mode Manager and Code Fragment Manager)</p><p>Macintosh Technical Note, <A HREF = "../qd/qd_18.html">Drawing Icons the System 7 Way</a> (M.IM.IconDrawing).</p>         <a name="Downloads"></a>       <P><A HREF="#top">Back to top</A></p><H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (72K).</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/qt_05.pdf">Download</A></P>               </TD>            </TR>                    </TABLE>         <BR></TD></TR></table></center><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/qt/qt_05.html%3Fid%3DDTS10002747-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/qt/qt_05.html%3Fid%3DDTS10002747-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/qt/qt_05.html%3Fid%3DDTS10002747-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>