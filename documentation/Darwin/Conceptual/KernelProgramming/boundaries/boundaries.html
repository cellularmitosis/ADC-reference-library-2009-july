<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Kernel Programming Guide: Boundary Crossings</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Boundary Crossings"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30000905-CH217" title="Boundary Crossings"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000422" target="_top">Darwin</a> &gt; <a href="../../../Kernel-date.html#//apple_ref/doc/uid/TP30000440-TP30000422-TP30000532" target="_top">Kernel</a> &gt; <a href="../About/About.html#//apple_ref/doc/uid/TP30000905-CH204-TPXREF101">Kernel Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Networking/Networking.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../synchronization/synchronization.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30000905-CH217-BEHJDFCA" title="Boundary Crossings"></a><h1>Boundary Crossings</h1><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_214"></a><p>Two applications can communicate in a number of ways—for example, by using pipes<a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_215"></a> or sockets<a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_216"></a>. The applications themselves are unaware of the underlying mechanisms that provide this communication. However this communication occurs by sending data from one program into the kernel, which then sends the data to the second program.</p>
<p>As a kernel programmer, it is your job to create the underlying mechanisms responsible for communication between your kernel code and applications. This communication is known as crossing the user-kernel boundary<a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_217"></a>. This chapter explains various ways of crossing that boundary.</p>
<p>In a protected memory environment, each process is given its own address space<a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_218"></a>. This means that no program can modify another program’s data unless that data also resides in its own memory space (shared memory<a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_219"></a>). The same applies to the kernel. It resides in its own address space. When a program communicates with the kernel, data cannot simply be passed from one address space to the other as you might between threads (or between programs in environments like Mac OS 9 and most real-time operating systems, which do not have protected memory).</p>
<p>We refer to the kernel’s address space as <strong>kernel space</strong><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_220"></a>, and collectively refer to applications’ address spaces as <strong>user space</strong><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_221"></a>. For this reason, applications are also commonly referred to as <strong>user-space programs</strong>, or <strong>user programs</strong> for short.</p>
<p>When the kernel needs a small amount of data from an application, the kernel cannot just dereference a pointer passed in from that application, since that pointer is relative to the application’s address space. Instead, the kernel generally copies that information into storage within its own address space. When a large region of data needs to be moved, it may map entire pages into kernel space for efficiency. The same behavior can be seen in reverse when moving data from the kernel to an application.</p>
<p>Because it is difficult to move data back and forth between the kernel and an application, this separation is called a <strong>boundary</strong>. It is inherently time consuming to copy data, even if that data is just the user-space address of a shared region. Thus, there is a performance penalty whenever a data exchange occurs. If this penalty is a serious problem, it may affect which method you choose for crossing the user-kernel boundary. Also, by trying to minimize the number of boundary crossings, you may find ways to improve the overall design of your code. This is particularly significant if your code is involved in communication between two applications, since the user-kernel boundary must be crossed twice in that case.</p>
<p>There are a number of ways to cross the user-kernel boundary. Some of them are covered in this chapter in the following sections:</p>
<ul class="ul"><li class="li"><p><span class="content_text"><a href="boundaries.html#//apple_ref/doc/uid/TP30000905-CH217-BABDECEG">“Mach Messaging and Mach Interprocess Communication (IPC)”</a></span></p></li>
<li class="li"><p><span class="content_text"><a href="boundaries.html#//apple_ref/doc/uid/TP30000905-CH217-BABCEGBF">“BSD syscall API ”</a></span></p></li>
<li class="li"><p><span class="content_text"><a href="boundaries.html#//apple_ref/doc/uid/TP30000905-CH217-BABGJBFJ">“BSD ioctl  API”</a></span></p></li>
<li class="li"><p><span class="content_text"><a href="boundaries.html#//apple_ref/doc/uid/TP30000905-CH217-BABJJBHG">“BSD sysctl API ”</a></span></p></li>
<li class="li"><p><span class="content_text"><a href="boundaries.html#//apple_ref/doc/uid/TP30000905-CH217-BABEDGJJ">“Memory Mapping and Block Copying”</a></span></p></li></ul>
<p>In addition, the I/O Kit uses the user-client/device-interface API for most communication. Because that API is specific to the I/O Kit, it is not covered in this chapter. The user client API is covered in <em><a href="../../../../DeviceDrivers/Conceptual/IOKitFundamentals/index.html#//apple_ref/doc/uid/TP0000011" target="_top">I/O Kit Fundamentals</a></em>, <em><a href="../../../../DeviceDrivers/Conceptual/AccessingHardware/index.html#//apple_ref/doc/uid/TP30000376" target="_top">Accessing Hardware From Applications</a></em>, and <em><a href="../../../../DeviceDrivers/Conceptual/WritingDeviceDriver/index.html#//apple_ref/doc/uid/TP30000694" target="_top">I/O Kit Device Driver Design Guidelines</a></em>.</p>
<p>The <code>ioctl</code> API is also specific to the construction of device drivers, and is largely beyond the scope of this document. However, since <code>ioctl</code> is a BSD API, it is covered at a glance for your convenience.</p>
<p>This chapter covers one subset of Mach IPC—the Mach remote procedure call (RPC) API. It also covers the <code>syscall</code>, <code>sysctl</code>, memory mapping, and block copying APIs. </p>

<a name="//apple_ref/doc/uid/TP30000905-CH217-TPXREF109" title="Security Considerations"></a><h2>Security Considerations</h2><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_222"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_223"></a>
<p>Crossing the user-kernel boundary represents a security risk if the kernel code operates on the data in any substantial way (beyond writing it to disk or passing it to another application). You must carefully perform bounds checking on any data passed in, and you must also make sure your code does not dereference memory that no longer belongs to the client application. Also, under <em>no circumstances</em> should you run unverified program code passed in from user space within the kernel. See <span class="content_text"><a href="../security/security.html#//apple_ref/doc/uid/TP30000905-CH206-BEHJDFCA">“Security Considerations”</a></span> for further information.</p>
<a name="//apple_ref/doc/uid/TP30000905-CH217-TPXREF110" title="Choosing a Boundary Crossing Method"></a><h2>Choosing a Boundary Crossing Method</h2><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_224"></a>
<p>The first step in setting up user-kernel data exchange is choosing a means to do that exchange. First, you must consider the purpose for the communication. Some crucial factors are latency<a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_225"></a>, bandwidth<a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_226"></a>, and the kernel subsystem involved. Before choosing a method of communication, however, you should first understand at a high-level each of these forms of communication.</p>
<p>Mach messaging<a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_227"></a> and Mach interprocess<a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_228"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_229"></a> communication (IPC) are relatively low-level ways of communicating between two Mach tasks (processes), as well as between a Mach task and the kernel. These form the basis for most communication outside of BSD and the I/O Kit. The Mach remote procedure call<a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_230"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_231"></a> (RPC) API is a high level procedural abstraction built on top of Mach IPC. Mach RPC is the most common use of IPC.</p>
<p>The BSD <code>syscall</code> API<a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_232"></a> is an API for calling kernel functions from user space. It is used extensively when writing file systems and networking protocols, in ways that are very subsystem-dependent. Developers are strongly discouraged from using the <code>syscall</code> API outside of file-system and network extensions, as no plug-in API exists for registering a new system call with the <code>syscall</code> mechanism.</p>
<p>The BSD <code>sysctl</code> API (in its revised form) supersedes the <code>syscall</code> API and also provides a relatively painless way to change individual kernel variables from user space. It has a straightforward plug-in architecture, making it a good choice where possible.</p>
<p>Memory mapping and block copying are used in conjunction with one of the other APIs mentioned, and provide ways of moving large amounts of data (more than a few bytes) or variably sized data to and from kernel space.</p>
<a name="//apple_ref/doc/uid/TP30000905-CH217-TPXREF111" title="Kernel Subsystems"></a><h3>Kernel Subsystems</h3>
<p>The choice of boundary crossing methods depends largely on the part of the kernel into which you are adding code. In particular, the boundary crossing method preferred for the I/O Kit is different from that preferred for BSD, which is different from that preferred for Mach.</p>
<p>If you are writing a device driver or other related code, you are probably dealing with the I/O Kit. In that case, you should instead read appropriate sections in <em><a href="../../../../DeviceDrivers/Conceptual/IOKitFundamentals/index.html#//apple_ref/doc/uid/TP0000011" target="_top">I/O Kit Fundamentals</a></em>, <em><a href="../../../../DeviceDrivers/Conceptual/AccessingHardware/index.html#//apple_ref/doc/uid/TP30000376" target="_top">Accessing Hardware From Applications</a></em>, and <em><a href="../../../../DeviceDrivers/Conceptual/WritingDeviceDriver/index.html#//apple_ref/doc/uid/TP30000694" target="_top">I/O Kit Device Driver Design Guidelines</a></em>.</p>
<p>If you are writing code that resides in the BSD subsystem (for example, a file system), you should generally use BSD APIs such as <code>syscall</code> or <code>sysctl</code> unless you require high bandwidth or exceptionally low latency.</p>
<p>If you are writing code that resides anywhere else, you will probably have to use Mach messaging.</p>
<a name="//apple_ref/doc/uid/TP30000905-CH217-TPXREF112" title="Bandwidth and Latency"></a><h3>Bandwidth and Latency</h3><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_233"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_234"></a>
<p>The guidelines in the previous section apply to most communication between applications and kernel code. The methods mentioned, however, are somewhat lacking where high bandwidth or low latency are concerns.</p>
<p>If you require high bandwidth, but latency is not an issue, you should probably consider doing memory-mapped communication. For large messages this is handled somewhat transparently by Mach RPC, making it a reasonable choice. For BSD portions of the kernel, however, you must explicitly pass pointers and use <code><!--a-->copyin<!--/a--></code> and <code><!--a-->copyout<!--/a--></code> to move large quantities of data. This is discussed in more detail in <span class="content_text"><a href="boundaries.html#//apple_ref/doc/uid/TP30000905-CH217-BABEDGJJ">“Memory Mapping and Block Copying.”</a></span></p>
<p>If you require low latency but bandwidth is not an issue, <code>sysctl</code> and <code>syscall</code> are not good choices. Mach RPC, however, may be an acceptable solution. Another possibility is to actually wire a page of memory (see <span class="content_text"><a href="boundaries.html#//apple_ref/doc/uid/TP30000905-CH217-BABEDGJJ">“Memory Mapping and Block Copying”</a></span> for details), start an asynchronous Mach RPC <code>simpleroutine</code> (to process the data), and use either locks or high/low water marks (buffer fullness) to determine when to read and write data. This can work for high-bandwidth communication as well.</p>
<p>If you require both high bandwidth and low latency, you should also look at the user client/device interface model used in the I/O Kit, since that model has similar requirements.</p>
<a name="//apple_ref/doc/uid/TP30000905-CH217-BABDECEG" title="Mach Messaging and Mach Interprocess Communication (IPC)"></a><h2>Mach Messaging and Mach Interprocess Communication (IPC)</h2><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_235"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_236"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_237"></a>
<p>Mach IPC and Mach messaging are the basis for much of the communication in Mac OS X. In many cases, however, these facilities are used indirectly by services implemented on top of one of them. Mach messaging and IPC are fundamentally similar except that Mach messaging is stateless, which prevents certain types of error recovery, as explained later. Except where explicitly stated, this section treats the two as equivalent.</p>
<p>The fundamental unit of Mach IPC is the <strong>port</strong><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_238"></a>. The concept of Mach ports can be difficult to explain in isolation, so instead this section assumes a passing knowledge of a similar concept, that of ports in TCP/IP.</p>
<p>In TCP/IP, a server listens for incoming connections over a network on a particular port. Multiple clients can connect to the port and send and receive data in word-sized or multiple-word–sized blocks. However, only one server process can be bound to the port at a time.</p>
<p>In Mach IPC, the concept is the same, but the players are different. Instead of multiple hosts connecting to a TCP/IP port, you have multiple Mach tasks on the same computer connecting to a Mach port. Instead of firewall rules on a port, you have <strong>port rights</strong><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_239"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_240"></a> that specify what tasks can send data to a particular Mach port.</p>
<p>Also, TCP/IP ports are bidirectional, while Mach ports are unidirectional, much like UNIX pipes. This means that when a Mach task connects to a port, it generally allocates a reply port and sends a message containing send rights<a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_241"></a> to that reply port so that the receiving task can send messages back to the sending task.</p>
<p>As with TCP/IP, multiple client tasks can open connections to a Mach port, but only one task can be listening on that port at a time. Unlike TCP/IP, however, the IPC mechanism itself provides an easy means for one task to hand off the right to listen to an arbitrary task. The term <strong>receive rights</strong><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_242"></a> refers to a task’s ability to listen on a given port. Receive rights can be sent from task to task in a Mach message. In the case of Mach IPC (but <em>not</em> Mach messaging), receive rights can even be configured to automatically return to the original task if the new task crashes or becomes unreachable (for example, if the new task is running on another computer and a router crashes).</p>
<p>In addition to specifying receive rights, Mach ports can specify which tasks have the right to send data. A task with send rights may be able to send once, or may be able to arbitrarily send data to a given port, depending on the nature of the rights.</p>
<a name="//apple_ref/doc/uid/TP30000905-CH217-TPXREF108" title="Using Well-Defined Ports"></a><h3>Using Well-Defined Ports</h3>
<p>Before you can use Mach IPC for task communication, the sending task must be able to obtain send rights on the receiving task’s <strong>task port</strong><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_243"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_244"></a>. Historically, there are several ways of doing this, not all of which are supported by Mac OS X. For example, in Mac OS X, unlike most other Mach derivatives, there is no service server<a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_245"></a> or name server<a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_246"></a>. Instead, the bootstrap task<a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_247"></a> and <strong>mach_init</strong><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_248"></a> subsume this functionality.</p>
<p>When a task is created, it is given send rights to a bootstrap port<a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_249"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_250"></a> for sending messages to the bootstrap task. Normally a task would use this port to send a message that gives the bootstrap task send rights on another port so that the bootstrap task can then return data to the calling task. Various routines exist in <code>bootstrap.h </code>that abstract this process. Indeed, most users of Mach IPC or Mach messaging actually use Mach remote procedure calls (RPC), which are implemented on top of Mach IPC.</p>
<p>Since direct use of IPC is rarely desirable (because it is not easy to do correctly), and because the underlying IPC implementation has historically changed on a regular basis, the details are not covered here. You can find more information on using Mach IPC directly in the <em>Mach 3 Server Writer’s Guide</em> from Silicomp (formerly the Open Group, formerly the Open Software Foundation Research Institute), which can be obtained from the developer section of Apple’s website. While much of the information contained in that book is not fully up-to-date with respect to Mac OS X, it should still be a relatively good resource on using Mach IPC.</p>
<a name="//apple_ref/doc/uid/TP30000905-CH217-TPXREF113" title="Remote Procedure Calls (RPC)"></a><h3>Remote Procedure Calls (RPC)</h3>
<p>Mach RPC<a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_251"></a> is the most common use for Mach IPC. It is frequently used for user-kernel communication, but can also be used for task to task or even computer-to-computer communication. Programmers frequently use Mach RPC for setting certain kernel parameters such as a given thread’s scheduling policy.</p>
<p>RPC is convenient because it is relatively transparent to the programmer. Instead of writing long, complex functions that handle ports directly, you have only to write the function to be called and a small <strong>RPC definition</strong><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_252"></a> to describe how to export the function as an RPC interface. After that, any application with appropriate permissions can call those functions as if they were local functions, and the compiler will convert them to RPC calls.</p>
<p>In the directory <code>osfmk/mach</code> (relative to your checkout of the xnu module from CVS), there are a number of files ending in <code>.defs</code>; these files contain the RPC definitions. When the kernel (or a kernel module) is compiled, the <strong>Mach Interface Generator (MIG)</strong><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_253"></a> uses these definitions to create IPC code to support the functions exported via RPC. Normally, if you want to add a new remote procedure call, you should do so by adding a definition to one of these existing files. (See <span class="content_text"><a href="../build/build.html#//apple_ref/doc/uid/TP30000905-CH221-BEHJDFCA">“Building and Debugging Kernels”</a></span> for more information on obtaining kernel sources.) </p>
<p>What follows is an example of the definition for a <strong>routine</strong><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_254"></a>, one of the more common uses of RPC.</p>
<div class="codesample"><table><tr><td scope="row"><pre>routine thread_policy_get(<span></span></pre></td></tr><tr><td scope="row"><pre>                    thread      : thread_act_t;<span></span></pre></td></tr><tr><td scope="row"><pre>                    flavor      : thread_policy_flavor_t;<span></span></pre></td></tr><tr><td scope="row"><pre>            out     policy_info : thread_policy_t, CountInOut;<span></span></pre></td></tr><tr><td scope="row"><pre>            inout   get_default : boolean_t);<span></span></pre></td></tr></table></div>
<p>Notice the C-like syntax of the definition. Each parameter in the routine roughly maps onto a parameter in the C function. The C prototype for this function follows.</p>
<div class="codesample"><table><tr><td scope="row"><pre>kern_return_t thread_policy_get(<span></span></pre></td></tr><tr><td scope="row"><pre>    thread_act_t            act,<span></span></pre></td></tr><tr><td scope="row"><pre>    thread_policy_flavor_t  flavor,<span></span></pre></td></tr><tr><td scope="row"><pre>    thread_policy_t         policy_info,<span></span></pre></td></tr><tr><td scope="row"><pre>    mach_msg_type_number_t  *count,<span></span></pre></td></tr><tr><td scope="row"><pre>    boolean_t               get_default);<span></span></pre></td></tr></table></div>
<p>The first two parameters are integers, and are passed as call-by-value<a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_255"></a>. The third is a <code>struct</code> containing integers. It is an outgoing parameter, which means that the values stored in that variable will <em>not</em> be received by the function, but <em>will</em> be overwritten on return.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000905-CH217-SW1" title="Note"></a><p><strong>Note:</strong>&nbsp;The parameters are all word-sized or multiples of the word size. Smaller data are impossible because of limitations inherent to the underlying Mach IPC mechanisms.</p></div>
<p>From there it becomes more interesting. The fourth parameter in the C prototype is a representation of the size of the third. In the definition file, this is represented by an added option, <code>CountInOut<a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_256"></a></code>.</p>
<p>The MIG<a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_257"></a> option <code>CountInOut</code> specifies that there is to be an <code>inout</code><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_258"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_259"></a> parameter called <code>count</code>. An <code>inout</code> parameter is one in which the original value can be read by the function being called, and its value is replaced on return from that function. Unlike a separate <code>inout</code> parameter, however, the value initially passed through this parameter is not directly set by the calling function. Instead, it is tied to the <code>policy_info</code> parameter so that the number of integers in <code>policy_info</code> is transparently passed in through this parameter.</p>
<p>In the function itself, the function checks the count parameter to verify that the buffer size is at least the size of the data to be returned to prevent exceeding array bounds. The function changes the value stored in count to be the desired size and returns an error if the buffer is not large enough (unless the buffer pointer is null, in which case it returns success). Otherwise, it dereferences the various fields of the <code>policy_info</code> parameter and in so doing, stores appropriate values into it, then returns.</p>
<div class="notebox"><a name="//apple_ref/doc/uid/TP30000905-CH217-SW2" title="Note"></a><p><strong>Note:</strong>&nbsp;Since Mach RPC is done via message passing, <code>inout</code> parameters are technically call-by-value-return<a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_260"></a> and <em>not</em> call-by-reference. For more realistic call-by-reference, you need to pass a pointer. The distinction is not particularly significant except when aliasing occurs. (Aliasing means having a single variable visible in the same scope under two or more different names.)</p></div>
<p>In addition to the <code>routine</code>, Mach RPC also has a <strong>simpleroutine</strong><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_261"></a>. A <code>simpleroutine</code> is a routine that is, by definition, asynchronous. It can have no <code>out</code> or <code>inout</code> parameters and no return value. The caller does not wait for the function to return. One possible use for this might be to tell an I/O device to send data as soon as it is ready. In that use, the <code>simpleroutine</code> might simply wait for data, then send a message to the calling task to indicate the availability of data.</p>
<p>Another important feature of MIG is that of the <strong>subsystem</strong><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_262"></a>. In MIG, a subsystem is a group of <code>routines</code> and <code>simpleroutines</code> that are related in some way. For example, the semaphore subsystem contains related routines that operate on semaphores. There are also subsystems for various timers, parts of the virtual memory (VM) system, and dozens of others in various places throughout the kernel.</p>
<p>Most of the time, if you need to use RPC, you will be doing it within an existing subsystem. The details of creating a new subsystem are beyond the scope of this document. Developers needing to add a new Mach subsystem should consult the <em>Mach 3 Server Writer’s Guide</em> from The Open Group (TOG), which can be obtained from various locations on the internet.</p>
<p>Another feature of MIG is the type. A type in MIG<a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_263"></a> is exactly the same thing as it is in programming languages. However, the construction of aggregate types differs somewhat.</p>
<div class="codesample"><table><tr><td scope="row"><pre>type clock_flavor_t     = int;<span></span></pre></td></tr><tr><td scope="row"><pre>type clock_attr_t       = array[*:1] of int;<span></span></pre></td></tr><tr><td scope="row"><pre>type mach_timespec_t    = struct[2] of int;<span></span></pre></td></tr></table></div>
<p>Data of type <code>array</code> is passed as the user-space address of what is assumed to be a contiguous array of the base type, while a struct is passed by copying all of the individual values of an array of the base type. Otherwise, these are treated similarly. A “struct” is not like a C struct, as elements of a MIG struct must all be of the same base type.</p>
<p>The declaration syntax is similar to Pascal, where <code>*:1</code> and <code>2</code> represent sizes for the array or structure, respectively. The <code>*:1</code> construct indicates a variable-sized array, where the size can be up to 1, inclusive, but no larger.</p>
<a name="//apple_ref/doc/uid/TP30000905-CH217-BABDAJGG" title="Calling RPC From User Applications"></a><h3>Calling RPC From User Applications</h3>
<p>RPC<a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_264"></a>, as mentioned previously, is virtually transparent to the client. The procedure call looks like any other C function call, and no additional library linkage is needed. You need only to bring the appropriate headers in with a <code>#include</code> directive. The compiler automatically recognizes the call as a remote procedure call and handles the underlying MIG aspects for you.</p>
<a name="//apple_ref/doc/uid/TP30000905-CH217-BABCEGBF" title="BSD syscall API "></a><h2>BSD <code>syscall</code> API </h2><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_265"></a>
<p>The <code><a href="../../../Reference/ManPages/man2/syscall.2.html#//apple_ref/doc/man/2/syscall" target="_top">syscall</a></code> API is the traditional UNIX way of calling kernel functions from user space. Its implementation varies from one part of the kernel to the next, however, and it is completely unsupported for loadable modules. For this reason, it is not a recommended way of getting data into or out of the kernel in Mac OS X unless you are writing a file system.</p>
<p>File systems have to support a number of standard system calls (for example, <code><a href="../../../Reference/ManPages/man2/mount.2.html#//apple_ref/doc/man/2/mount" target="_top">mount</a></code>), but do so by means of generic file system routines that call the appropriate file-system functions. Thus, if you are writing a file system, you need to implement those functions, but you do not need to write the code that handles the system calls directly. For more information on implementing <code><a href="../../../Reference/ManPages/man2/syscall.2.html#//apple_ref/doc/man/2/syscall" target="_top">syscall</a></code> support in file systems, see the chapter <span class="content_text"><a href="../Filesystem/Filesystem.html#//apple_ref/doc/uid/TP30000905-CH215-BABEEHFF">“File Systems Overview.”</a></span></p>
<a name="//apple_ref/doc/uid/TP30000905-CH217-BABGJBFJ" title="BSD ioctl  API"></a><h2>BSD <code>ioctl</code>  API</h2><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_266"></a>
<p>The <code><a href="../../../Reference/ManPages/man2/ioctl.2.html#//apple_ref/doc/man/2/ioctl" target="_top">ioctl</a></code> interface provides a way for an application to send certain commands or information to a device driver. These can be used for parameter tuning (though this is more commonly done with <code><a href="../../../Reference/ManPages/man3/sysctl.3.html#//apple_ref/doc/man/3/sysctl" target="_top">sysctl</a></code>), but can also be used for sending instructions for the driver to perform a particular task (for example, rewinding a tape drive).</p>
<p>The use of the <code><a href="../../../Reference/ManPages/man2/ioctl.2.html#//apple_ref/doc/man/2/ioctl" target="_top">ioctl</a></code> interface is essentially the same under Mac OS X as it is in other BSD-derived operating systems, except in the way that device drivers register themselves with the system. In Mac OS X, unlike most BSDs, the contents of the <code>/dev</code> directory are created dynamically by the kernel. This file system mounted on <code>/dev</code> is referred to as <strong>devfs</strong>. You can, of course, still manually create device nodes with <code><a href="../../../Reference/ManPages/man2/mknod.2.html#//apple_ref/doc/man/2/mknod" target="_top">mknod</a></code>, because devfs is union mounted over the root file system.</p>
<p>The I/O Kit automatically registers some types of devices with devfs, creating a node in <code>/dev</code>. If your device family does not do that, you can manually register yourself in devfs using <code><!--a-->cdevsw_add<!--/a--></code> or <code><!--a-->bdevsw_add<!--/a--></code> (for character and block devices, respectively).</p>
<p>When registering a device manually with devfs, you create a <code>struct cdevsw</code> or <code>struct bdevsw</code> yourself. In that device structure, one of the function pointers is to an <code><a href="../../../Reference/ManPages/man2/ioctl.2.html#//apple_ref/doc/man/2/ioctl" target="_top">ioctl</a></code> function. You must define the particular values passed to the <code><a href="../../../Reference/ManPages/man2/ioctl.2.html#//apple_ref/doc/man/2/ioctl" target="_top">ioctl</a></code> function in a header file accessible to the person compiling the application.</p>
<p>A user application can also look up the device using the I/O Kit function call <code><!--a target="_top" -->getMatchingServices<!--/a--></code> and then use various I/O Kit calls to tune parameter instead. For more information on looking up a device driver from an application, see the document <em><a href="../../../../DeviceDrivers/Conceptual/AccessingHardware/index.html#//apple_ref/doc/uid/TP30000376" target="_top">Accessing Hardware From Applications</a></em>.</p>
<p>You can also find additional information about writing an <code><a href="../../../Reference/ManPages/man2/ioctl.2.html#//apple_ref/doc/man/2/ioctl" target="_top">ioctl</a></code> in <em>The Design and Implementation of the 4.4 BSD Operating System</em>. See the bibliography at the end of this document for more information.</p>
<a name="//apple_ref/doc/uid/TP30000905-CH217-BABJJBHG" title="BSD sysctl API "></a><h2>BSD <code>sysctl</code> API </h2><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_267"></a>
<p>The system control (<code><a href="../../../Reference/ManPages/man3/sysctl.3.html#//apple_ref/doc/man/3/sysctl" target="_top">sysctl</a></code>) API is specifically designed for kernel parameter tuning. This functionality supersedes the <code><a href="../../../Reference/ManPages/man2/syscall.2.html#//apple_ref/doc/man/2/syscall" target="_top">syscall</a></code> API, and also provides an easy way to tune simple kernel parameters without actually needing to write a handler routine in the kernel. The <code><a href="../../../Reference/ManPages/man3/sysctl.3.html#//apple_ref/doc/man/3/sysctl" target="_top">sysctl</a></code> namespace is divided into several broad categories corresponding to the purpose of the parameters in it. Some of these areas include</p>
<ul class="ul"><li class="li"><p>kern—general kernel parameters</p></li>
<li class="li"><p>vm—virtual memory options</p></li>
<li class="li"><p>fs—filesystem options</p></li>
<li class="li"><p>machdep—machine dependent settings</p></li>
<li class="li"><p>net—network stack settings</p></li>
<li class="li"><p>debug—debugging settings</p></li>
<li class="li"><p>hw—hardware parameters (generally read-only)</p></li>
<li class="li"><p>user—parameters affecting user programs</p></li>
<li class="li"><p>ddb—kernel debugger</p></li></ul>
<p>Most of the time, programs use the <code><a href="../../../Reference/ManPages/man3/sysctl.3.html#//apple_ref/doc/man/3/sysctl" target="_top">sysctl</a></code> call to retrieve the current value of a kernel parameter. For example, in Mac OS X, the hw <code><a href="../../../Reference/ManPages/man3/sysctl.3.html#//apple_ref/doc/man/3/sysctl" target="_top">sysctl</a></code> group includes the option <code>ncpu</code>, which returns the number of processors in the current computer (or the maximum number of processors supported by the kernel on that particular computer, whichever is less).</p>
<p>The <code><a href="../../../Reference/ManPages/man3/sysctl.3.html#//apple_ref/doc/man/3/sysctl" target="_top">sysctl</a></code> API can also be used to modify parameters (though most parameters can only be changed by the root). For example, in the net hierarchy, <code>net.inet.ip.forwarding</code> can be set to 1 or 0, to indicate whether the computer should forward packets between multiple interfaces (basic routing).</p>
<a name="//apple_ref/doc/uid/TP30000905-CH217-TPXREF114" title="General Information on Adding a sysctl"></a><h3>General Information on Adding a <code>sysctl</code></h3><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_268"></a>
<p>When adding a sysctl, you must do all of the following <em>first</em>:</p>
<ul class="spaceabove"><li class="li"><p>add the following includes:</p><p><code>#include &lt;mach/mach_types.h></code></p><p><code>#include
&lt;sys/systm.h></code></p><p><code>#include
&lt;sys/types.h></code></p><p><code>#include
&lt;sys/sysctl.h></code></p></li>
<li class="li"><p>add <code>-no-cpp-precomp</code> to your compiler options in Project Builder (or to <code>CFLAGS</code> in your makefile if building by hand).</p></li></ul>
<a name="//apple_ref/doc/uid/TP30000905-CH217-TPXREF115" title="Adding a sysctl Procedure Call"></a><h3>Adding a <code>sysctl</code> Procedure Call</h3>
<p>Adding a system control (<code><a href="../../../Reference/ManPages/man3/sysctl.3.html#//apple_ref/doc/man/3/sysctl" target="_top">sysctl</a></code>) was once a daunting task requiring changes to dozens of files. With the current implementation, a system control can be added simply by writing the appropriate handler functions and then registering the handler with the system at runtime. The old-style <code><a href="../../../Reference/ManPages/man3/sysctl.3.html#//apple_ref/doc/man/3/sysctl" target="_top">sysctl</a></code>, which used fixed numbers for each control, is deprecated.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000905-CH217-SW3" title="Note"></a><p><strong>Note:</strong>&nbsp;Because this is largely a construct of the BSD subsystem, all path names in this section can be assumed to be from /path/to/xnu-version/bsd/. </p>Also, you may safely assume that all program code snippets should go into the main source file for your subsystem or module unless otherwise noted, and that in the case of modules, function calls should be made from your <code><!--a-->start<!--/a--></code> or <code><!--a-->stop<!--/a--></code> routines unless otherwise noted.</p></div>
<p>The preferred way of adding a <code><a href="../../../Reference/ManPages/man3/sysctl.3.html#//apple_ref/doc/man/3/sysctl" target="_top">sysctl</a></code> looks something like the following:</p>
<div class="codesample"><table><tr><td scope="row"><pre>SYSCTL_PROC(_hw, OID_AUTO, l2cr, CTLTYPE_INT|CTLFLAG_RW,<span></span></pre></td></tr><tr><td scope="row"><pre>    &amp;L2CR, 0, &amp;sysctl_l2cr, "I", "L2 Cache Register");<span></span></pre></td></tr></table></div>
<p><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_269"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_270"></a>The <code>_PROC</code> part indicates that you are registering a procedure to provide the value (as opposed to simply reading from a static address in kernel memory). <code>_hw</code> is the top level category (in this case, hardware), and <code><!--a  -->OID_AUTO<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_271"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_272"></a> indicates that you should be assigned the next available control ID in that category (as opposed to the old-style, fixed ID controls). <code>l2cr</code> is the name of your control, which will be used by applications to look up the number of your control using <code><a href="../../../Reference/ManPages/man3/sysctlbyname.3.html#//apple_ref/doc/man/3/sysctlbyname" target="_top">sysctlbyname</a></code>.</p>
<div class="notebox"><a name="//apple_ref/doc/uid/TP30000905-CH217-SW4" title="Note"></a><p><strong>Note:</strong>&nbsp;Not all top level categories will necessarily accept the addition of a user-specified new-style <code><a href="../../../Reference/ManPages/man3/sysctl.3.html#//apple_ref/doc/man/3/sysctl" target="_top">sysctl</a></code>. If you run into problems, you should try a different top-level category.</p></div>
<p><code><!--a  -->CTLTYPE_INT<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_273"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_274"></a> indicates that the value being changed is an integer. Other legal values are <code><!--a  -->CTLTYPE_NODE<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_275"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_276"></a>, <code><!--a  -->CTLTYPE_STRING<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_277"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_278"></a>, <code><!--a  -->CTLTYPE_QUAD<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_279"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_280"></a>, and <code><!--a  -->CTLTYPE_OPAQUE<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_281"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_282"></a> (also known as <code><!--a  -->CTLTYPE_STRUCT<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_283"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_284"></a>). <code><!--a  -->CTLTYPE_NODE<!--/a--></code> is the only one that isn’t somewhat obvious. It refers to a node in the <code><a href="../../../Reference/ManPages/man3/sysctl.3.html#//apple_ref/doc/man/3/sysctl" target="_top">sysctl</a></code> hierarchy that isn’t directly usable, but instead is a parent to other entries. Two examples of nodes are <code>hw</code> and <code>kern</code>.</p>
<p><code><!--a  -->CTLFLAG_RW<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_285"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_286"></a> indicates that the value can be read and written. Other legal values are <code><!--a  -->CTLFLAG_RD<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_287"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_288"></a>, <code><!--a  -->CTLFLAG_WR<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_289"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_290"></a>, <code><!--a  -->CTLFLAG_ANYBODY<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_291"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_292"></a>, and <code><!--a  -->CTLFLAG_SECURE<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_293"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_294"></a>. <code><!--a  -->CTLFLAG_ANYBODY<!--/a--></code> means that the value should be modifiable by anybody. (The default is for variables to be changeable only by root.) <code><!--a  -->CTLFLAG_SECURE<!--/a--></code> means that the variable can be changed only when running at <code>securelevel
&lt;= 0</code> (effectively, in single-user mode).</p>
<p><code>L2CR</code> is the location where the sysctl will store its data. Since the address is set at compile time, however, this must be a global variable or a static local variable. In this case, <code>L2CR</code> is a global of type <code>unsigned int</code>.</p>
<p>The number <code>0</code> is a second argument that is passed to your function. This can be used, for example, to identify which <code><a href="../../../Reference/ManPages/man3/sysctl.3.html#//apple_ref/doc/man/3/sysctl" target="_top">sysctl</a></code> was used to call your handler function if the same handler function is used for more than one control. In the case of strings, this is used to store the maximum allowable length for incoming values.</p>
<p><code><!--a-->sysctl_l2cr<!--/a--></code> is the handler function for this <code><a href="../../../Reference/ManPages/man3/sysctl.3.html#//apple_ref/doc/man/3/sysctl" target="_top">sysctl</a></code>. The prototype for these functions is of the form</p>
<div class="codesample"><table><tr><td scope="row"><pre>static int sysctl_l2cr SYSCTL_HANDLER_ARGS;<span></span></pre></td></tr></table></div>
<p>If the <code><a href="../../../Reference/ManPages/man3/sysctl.3.html#//apple_ref/doc/man/3/sysctl" target="_top">sysctl</a></code> is writable, the function may either use <code><!--a-->sysctl_handle_int<!--/a--></code> to obtain the value passed in from user space and store it in the default location or use the <code><!--a-->SYSCTL_IN<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_295"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_296"></a> macro to store it into an alternate buffer. This function must also use the <code><!--a-->SYSCTL_OUT<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_297"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_298"></a> macro to return a value to user space.</p>
<p><code>"I"</code> indicates that the argument should refer to a variable of type <code>integer</code> (or a constant, pointer, or other piece of data of equivalent width), as opposed to <code>"L"</code> for a <code>long</code>, <code>"A"</code> for a <code>string</code>, <code>"N"</code> for a <code>node</code> (a <code>sysctl</code> that is the parent of a <code>sysctl</code> category or subcategory), or <code>"S"</code> for a <code>struct</code>. <code>"L2 Cache
Register"</code> is a human-readable description of your <code><a href="../../../Reference/ManPages/man3/sysctl.3.html#//apple_ref/doc/man/3/sysctl" target="_top">sysctl</a></code>.</p>
<p>In order for a control to be accessible from an application, it must be registered. To do this, you do the following:<a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_299"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_300"></a></p>
<div class="codesample"><table><tr><td scope="row"><pre>sysctl_register_oid(&amp;sysctl__hw_l2cr);<span></span></pre></td></tr></table></div>
<p>You should generally do this in an init routine for a loadable module. If your code is not part of a loadable module, you should add your <code><a href="../../../Reference/ManPages/man3/sysctl.3.html#//apple_ref/doc/man/3/sysctl" target="_top">sysctl</a></code> to the list of built-in OID<a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_301"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_302"></a>s in the file <code>kern/sysctl_init.c</code>.</p>
<p>If you study the <code><!--a-->SYSCTL_PROC<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_303"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_304"></a> constructor macro, you will notice that <code>sysctl__hw_l2cr</code> is the name of a variable created by that macro. This means that the <code><!--a-->SYSCTL_PROC<!--/a--></code> line must be before <code><!--a-->sysctl_register_oid<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_305"></a> in the file, and must be in the same (or broader) scope. This name is in the form of <code>sysctl_</code> followed by the name of it’s parent node, followed by another underscore ( <code>_</code> ) followed by the name of your <code>sysctl</code>.</p>
<p>A similar function, <code><!--a-->sysctl_unregister_oid<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_306"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_307"></a> exists to remove a <code>sysctl</code> from the registry. If you are writing a loadable module, you should be certain to do this when your module is unloaded.</p>
<p>In addition to registering your handler function, you also have to write the function. The following is a typical example</p>
<div class="codesample"><table><tr><td scope="row"><pre>static int myhandler SYSCTL_HANDLER_ARGS<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    int error, retval;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    error = sysctl_handle_int(oidp, oidp->oid_arg1, oidp->oid_arg2,  req);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!error &amp;&amp; req->newptr) {<span></span></pre></td></tr><tr><td scope="row"><pre>        /* We have a new value stored in the standard location.*/<span></span></pre></td></tr><tr><td scope="row"><pre>        /* Do with it as you see fit here. */<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("sysctl_test: stored %d\n", SCTEST);<span></span></pre></td></tr><tr><td scope="row"><pre>    } else if (req->newptr) {<span></span></pre></td></tr><tr><td scope="row"><pre>        /* Something was wrong with the write request */<span></span></pre></td></tr><tr><td scope="row"><pre>        /* Do something here if you feel like it.... */<span></span></pre></td></tr><tr><td scope="row"><pre>    } else {<span></span></pre></td></tr><tr><td scope="row"><pre>        /* Read request. Always return 763, just for grins. */<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("sysctl_test: read %d\n", SCTEST);<span></span></pre></td></tr><tr><td scope="row"><pre>        retval=763;<span></span></pre></td></tr><tr><td scope="row"><pre>        error=SYSCTL_OUT(req, &amp;retval, sizeof retval);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    /* In any case, return success or return the reason for failure  */<span></span></pre></td></tr><tr><td scope="row"><pre>    return error;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<p>This demonstrates the use of <code><!--a-->SYSCTL_OUT<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_308"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_309"></a> to send an arbitrary value out to user space from the <code>sysctl</code> handler. The “phantom” <code>req</code> argument is part of the function prototype when the <code>SYSCTL_HANDLER_ARGS</code><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_310"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_311"></a> macro is expanded, as is the <code>oidp</code> variable used elsewhere. The remaining arguments are a pointer (type indifferent) and the length of data to copy (in bytes).</p>
<p>This code sample also introduces a new function, <code><!--a-->sysctl_handle_int<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_312"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_313"></a>, which takes the arguments passed to the <code>sysctl</code>, and writes the integer into the usual storage area (<code>L2CR</code> in the earlier example, <code>SCTEST</code> in this one). If you want to see the new value without storing it (to do a sanity check, for example), you should instead use the <code><!--a-->SYSCTL_IN<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_314"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_315"></a> macro, whose arguments are the same as <code><!--a-->SYSCTL_OUT<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_316"></a>.</p>
<a name="//apple_ref/doc/uid/TP30000905-CH217-TPXREF116" title="Registering a New Top Level  sysctl"></a><h3>Registering a New Top Level  <code>sysctl</code></h3>
<p>In addition to adding new <code><a href="../../../Reference/ManPages/man3/sysctl.3.html#//apple_ref/doc/man/3/sysctl" target="_top">sysctl</a></code> options, you can also add a new category or subcategory. The macro <code><!--a-->SYSCTL_DECL<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_317"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_318"></a> can be used to declare a node that can have children. This requires modifying one additional file to create the child list. For example, if your main C file does this:</p>
<div class="codesample"><table><tr><td scope="row"><pre>SYSCTL_DECL(_net_newcat);<span></span></pre></td></tr><tr><td scope="row"><pre>SYSCTL_NODE(_net, OID_AUTO, newcat, CTLFLAG_RW, handler, "new  category");<span></span></pre></td></tr></table></div>
<p><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_319"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_320"></a>then this is basically the same thing as declaring <code>extern
sysctl_oid_list<a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_321"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_322"></a> sysctl__net_newcat_children</code> in your program. In order for the kernel to compile, or the module to link, you must then add this line:</p>
<div class="codesample"><table><tr><td scope="row"><pre>struct sysctl_oid_list sysctl__net_newcat_children;<span></span></pre></td></tr></table></div>
<p>If you are not writing a module, this should go in the file <code>kern/kern_newsysctl.c</code>. Otherwise, it should go in one of the files of your module. Once you have created this variable, you can use <code>_net_newcat</code> as the parent when creating a new control. As with any <code><a href="../../../Reference/ManPages/man3/sysctl.3.html#//apple_ref/doc/man/3/sysctl" target="_top">sysctl</a></code>, the node (<code>sysctl__net_newcat</code>) must be registered with <code><!--a-->sysctl_register_oid<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_323"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_324"></a> and can be unregistered with <code><!--a-->sysctl_unregister_oid<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_325"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_326"></a>.</p>
<div class="notebox"><a name="//apple_ref/doc/uid/TP30000905-CH217-SW5" title="Note"></a><p><strong>Note:</strong>&nbsp;When creating a top level <code>sysctl</code>, parent is simply left blank, for example, </p><code>SYSCTL_NODE<a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_327"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_328"></a>(
, OID_AUTO, _topname, flags, handler_fn, "desc");</code></p></div>
<a name="//apple_ref/doc/uid/TP30000905-CH217-TPXREF117" title="Adding a Simple  sysctl"></a><h3>Adding a Simple  <code>sysctl</code></h3>
<p>If your <code><a href="../../../Reference/ManPages/man3/sysctl.3.html#//apple_ref/doc/man/3/sysctl" target="_top">sysctl</a></code> only needs to read a value out of a variable, then you do not need to write a function to provide access to that variable. Instead, you can use one of the following macros:</p>
<ul class="spaceabove"><li class="li"><p><code>SYSCTL_INT<a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_329"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_330"></a>(parent,
nbr, name, access, ptr, val, descr)</code></p></li>
<li class="li"><p><code>SYSCTL_LONG<a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_331"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_332"></a>(parent,
nbr, name, access, ptr, descr)</code></p></li>
<li class="li"><p><code>SYSCTL_STRING<a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_333"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_334"></a>(parent,
nbr, name, access, arg, len, descr)</code></p></li>
<li class="li"><p><code>SYSCTL_OPAQUE<a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_335"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_336"></a>(parent,
nbr, name, access, ptr, len, descr)</code></p></li>
<li class="li"><p><code>SYSCTL_STRUCT<a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_337"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_338"></a>(parent,
nbr, name, access, arg, type, descr)</code></p></li></ul>
<p>The first four parameters for each macro are the same as for <code><!--a-->SYSCTL_PROC<!--/a--></code> (described in the previous section) as is the last parameter. The <code>len</code> parameter (where applicable) gives a length of the string or opaque object in bytes.</p>
<p>The <code>arg</code> parameters are pointers just like the <code>ptr</code> parameters. However, the parameters named <code>ptr</code> are explicitly described as pointers because you must explicitly use the “address of” (<code>&amp;</code>) operator unless you are already working with a pointer. Parameters called arg either operate on base types that are implicitly pointers or add the &amp; operator in the appropriate place during macro expansion. In both cases, the argument should refer to the integer, character, or other object that the <code>sysctl</code> will use to store the current value.</p>
<p>The <code>type</code> parameter is the name of the type minus the “<code>struct</code>”. For example, if you have an object of type <code>struct scsipi</code>, then you would use <code>scsipi</code> as that argument. The <code><!--a-->SYSCTL_STRUCT<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_339"></a> macro is functionally equivalent to <code><!--a-->SYSCTL_OPAQUE<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_340"></a>, except that it hides the use of <code><!--a-->sizeof<!--/a--></code>.</p>
<p>Finally, the <code>val</code> parameter for <code><!--a-->SYSCTL_INT<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_341"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_342"></a> is a default value. If the value passed in <code>ptr</code> is <code><!--a  -->NULL<!--/a--></code>, this value is returned when the <code>sysctl</code> is used. You can use this, for example, when adding a <code><a href="../../../Reference/ManPages/man3/sysctl.3.html#//apple_ref/doc/man/3/sysctl" target="_top">sysctl</a></code> that is specific to certain hardware or certain compile options. One possible example of this might be a special value for <code>feature.version</code> that means “not present.” If that feature became available (for example, if a module were loaded by some user action), it could then update that pointer. If that module were subsequently unloaded, it could set the pointer back to <code>NULL</code>.<a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_343"></a></p>
<a name="//apple_ref/doc/uid/TP30000905-CH217-TPXREF118" title="Calling a sysctl  From User Space"></a><h3>Calling a <code>sysctl</code>  From User Space</h3><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_344"></a>
<p>Unlike RPC, <code><a href="../../../Reference/ManPages/man3/sysctl.3.html#//apple_ref/doc/man/3/sysctl" target="_top">sysctl</a></code> requires explicit intervention on the part of the programmer. To complicate things further, there are two different ways of calling <code><a href="../../../Reference/ManPages/man3/sysctl.3.html#//apple_ref/doc/man/3/sysctl" target="_top">sysctl</a></code> functions, and neither one works for every control. The old-style <code><a href="../../../Reference/ManPages/man3/sysctl.3.html#//apple_ref/doc/man/3/sysctl" target="_top">sysctl</a></code> call can only invoke a control if it is listed in a static OID<a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_345"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_346"></a> table in the kernel. The new-style <code><a href="../../../Reference/ManPages/man3/sysctlbyname.3.html#//apple_ref/doc/man/3/sysctlbyname" target="_top">sysctlbyname</a></code> call will work for any user-added <code><a href="../../../Reference/ManPages/man3/sysctl.3.html#//apple_ref/doc/man/3/sysctl" target="_top">sysctl</a></code>, but not for those listed in the static table. Occasionally, you will even find a control that is registered in both ways, and thus available to both calls. In order to understand the distinction, you must first consider the functions used.</p>
<a name="//apple_ref/doc/uid/TP30000905-CH217-TPXREF119" title="The sysctlbyname   System Call"></a><h4>The <code>sysctlbyname</code>   System Call</h4><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_347"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_348"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_349"></a>
<p>If you are calling a <code>sysctl</code> that was added using the new sysctl method (including any sysctl that you may have added), then your sysctl does not have a fixed number that identifies it, since it was added dynamically to the system. Since there is no approved way to get this number from user space, and since the underlying implementation is not guaranteed to remain the same in future releases, you cannot call a dynamically added control using the <code><a href="../../../Reference/ManPages/man3/sysctl.3.html#//apple_ref/doc/man/3/sysctl" target="_top">sysctl</a></code> function. Instead, you must use <code><a href="../../../Reference/ManPages/man3/sysctlbyname.3.html#//apple_ref/doc/man/3/sysctlbyname" target="_top">sysctlbyname</a></code>.</p>
<div class="codesample"><table><tr><td scope="row"><pre>sysctlbyname(char *name, void *oldp, size_t *oldlenp,<span></span></pre></td></tr><tr><td scope="row"><pre>        void *newp, u_int newlen)<span></span></pre></td></tr></table></div>
<p>The parameter <code>name</code> is the name of the <code>sysctl</code>, encoded as a standard C string.</p>
<p>The parameter <code>oldp</code> is a pointer to a buffer where the old value will be stored. The <code>oldlenp</code> parameter is a pointer to an integer-sized buffer that holds the current size of the <code>oldp</code> buffer. If the <code>oldp</code> buffer is not large enough to hold the returned data, the call will fail with errno set to <code><a href="../../../../Carbon/Reference/Open_Transport/Reference/reference.html#//apple_ref/doc/c_ref/ENOMEM" target="_top">ENOMEM</a></code>, and the value pointed to by <code>oldlenp</code> will be changed to indicate the buffer size needed for a future call to succeed.</p>
<p>Here is an example for reading an integer, in this case a buffer size.</p>
<div class="codesample"><table><tr><td scope="row"><pre>int get_debug_bufsize()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>char *name="debug.bpf_bufsize";<span></span></pre></td></tr><tr><td scope="row"><pre>int bufsize, retval;<span></span></pre></td></tr><tr><td scope="row"><pre>size_t len;<span></span></pre></td></tr><tr><td scope="row"><pre>len=4;<span></span></pre></td></tr><tr><td scope="row"><pre>retval=sysctlbyname(name, &amp;bufsize, &amp;len, NULL, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>/* Check retval here */<span></span></pre></td></tr><tr><td scope="row"><pre>return bufsize;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<a name="//apple_ref/doc/uid/TP30000905-CH217-TPXREF120" title="The sysctl  System Call"></a><h4>The <code>sysctl</code>  System Call</h4><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_350"></a>
<p>The <code><a href="../../../Reference/ManPages/man3/sysctlbyname.3.html#//apple_ref/doc/man/3/sysctlbyname" target="_top">sysctlbyname</a></code> system call is the recommended way to call system calls. However, not every built-in system control is registered in the kernel in such a way that it can be called with <code><a href="../../../Reference/ManPages/man3/sysctlbyname.3.html#//apple_ref/doc/man/3/sysctlbyname" target="_top">sysctlbyname</a></code><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_351"></a>. For this reason, you should also be aware of the <code><a href="../../../Reference/ManPages/man3/sysctl.3.html#//apple_ref/doc/man/3/sysctl" target="_top">sysctl</a></code> system call.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000905-CH217-SW6" title="Note"></a><p><strong>Note:</strong>&nbsp;If you are adding a <code>sysctl</code>, it will be accessible using <code><a href="../../../Reference/ManPages/man3/sysctlbyname.3.html#//apple_ref/doc/man/3/sysctlbyname" target="_top">sysctlbyname</a></code>. You should use this system call only if the <code>sysctl</code> you need cannot be retrieved using <code><a href="../../../Reference/ManPages/man3/sysctlbyname.3.html#//apple_ref/doc/man/3/sysctlbyname" target="_top">sysctlbyname</a></code>. In particular, you should not assume that future versions of <code>sysctl</code> will be backed by traditional numeric OID<a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_352"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_353"></a>s except for the existing legacy OIDs, which will be retained for compatibility reasons.</p></div>
<p>The <code><a href="../../../Reference/ManPages/man3/sysctl.3.html#//apple_ref/doc/man/3/sysctl" target="_top">sysctl</a></code> system call is part of the original historical BSD implementation of system controls. You should not depend on its use for any control that you might add to the system. The classic usage of <code><a href="../../../Reference/ManPages/man3/sysctl.3.html#//apple_ref/doc/man/3/sysctl" target="_top">sysctl</a></code> looks like the following</p>
<div class="codesample"><table><tr><td scope="row"><pre>sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp,<span></span></pre></td></tr><tr><td scope="row"><pre>        void *newp, u_int newlen)<span></span></pre></td></tr></table></div>
<p>System controls, in this form, are based on the <strong>MIB</strong><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_354"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_355"></a>, or Management Information Base architecture. A MIB is a list of objects and identifiers for those objects. Each object identifier, or OID<a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_356"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_357"></a>, is a list of integers that represent a tokenization of a path through the <code><a href="../../../Reference/ManPages/man3/sysctl.3.html#//apple_ref/doc/man/3/sysctl" target="_top">sysctl</a></code> tree. For example, if the <code>hw</code> class of <code><a href="../../../Reference/ManPages/man3/sysctl.3.html#//apple_ref/doc/man/3/sysctl" target="_top">sysctl</a></code> is number 3, the first integer in the OID would be the number 3. If the <code>l2cr</code> option is built into the system and assigned the number 75, then the second integer in the OID would be 75. To put it another way, each number in the OID is an index into a node’s list of children.</p>
<p>Here is a short example of a call to get the bus speed of the current computer:</p>
<div class="codesample"><table><tr><td scope="row"><pre>int get_bus_speed()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>int mib[2], busspeed, retval;<span></span></pre></td></tr><tr><td scope="row"><pre>unsigned int miblen;<span></span></pre></td></tr><tr><td scope="row"><pre>size_t len;<span></span></pre></td></tr><tr><td scope="row"><pre>mib[0]=CTL_HW;<span></span></pre></td></tr><tr><td scope="row"><pre>mib[1]=HW_BUS_FREQ;<span></span></pre></td></tr><tr><td scope="row"><pre>miblen=2;<span></span></pre></td></tr><tr><td scope="row"><pre>len=4;<span></span></pre></td></tr><tr><td scope="row"><pre>retval=sysctl(mib, miblen, &amp;busspeed, &amp;len, NULL, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>/* Check retval here */<span></span></pre></td></tr><tr><td scope="row"><pre>return busspeed;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<p>For more information on the <code><a href="../../../Reference/ManPages/man3/sysctl.3.html#//apple_ref/doc/man/3/sysctl" target="_top">sysctl</a></code> system call, see the manual page <code><a href="../../../Reference/ManPages/man3/sysctl.3.html#//apple_ref/doc/man/3/sysctl" target="_top">sysctl</a></code>.</p>
<a name="//apple_ref/doc/uid/TP30000905-CH217-BABEDGJJ" title="Memory Mapping and Block Copying"></a><h2>Memory Mapping and Block Copying</h2><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_358"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_359"></a>
<p>Memory mapping is one of the more common means of communicating between two applications or between an application and the kernel. While occasionally used by itself, it is usually used in conjunction with one of the other means of boundary crossing.</p>
<p>One way of using memory mapping is known as <a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_360"></a><strong>shared memory</strong><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_361"></a>. In this form, one or more pages of memory are mapped into the address space of two processes. Either process can then access or modify the data stored in those shared pages. This is useful when moving large quantities of data between processes, as it allows direct communication without multiple user-kernel boundary crossings. Thus, when moving large amounts of data between processes, this is preferable to traditional message passing.</p>
<p>The same holds true with memory mapping between an application and the kernel. The BSD <code><a href="../../../Reference/ManPages/man3/sysctl.3.html#//apple_ref/doc/man/3/sysctl" target="_top">sysctl</a></code> and <code><a href="../../../Reference/ManPages/man2/syscall.2.html#//apple_ref/doc/man/2/syscall" target="_top">syscall</a></code> interfaces (and to an extent, Mach IPC) were designed to transfer small units of data of known size, such as an array of four integers. In this regard, they are much like a traditional C function call. If you need to pass a large amount of data to a function in C, you should pass a pointer. This is also true when passing data between an application and the kernel, with the addition of memory mapping or copying to allow that pointer to be dereferenced in the kernel.</p>
<p>There are a number of limitations to the way that memory mapping can be used to exchange data between an application and the kernel. For one, memory allocated in the kernel cannot be written to by applications, including those running as root (unless the kernel is running in an insecure mode, such as single user mode). For this reason, if a buffer must be modified by an application, the buffer must be allocated by that program, <em>not</em> by the kernel.</p>
<p>When you use memory mapping for passing data to the kernel, the application allocates a block of memory and fills it with data. It then performs a system call that passes the address to the appropriate function in kernel space. It should be noted, however, that the address being passed is a virtual address, not a physical address, and more importantly, it is relative to the address space of the program, which is <em>not</em> the same as the address space of the kernel.</p>
<p>Since the address is a user-space virtual address, the kernel must call special functions to copy the block of memory into a kernel buffer or to map the block of memory into the kernel’s address space.</p>
<p>In the Mac OS X kernel, data is most easily copied into kernel space with the BSD <code><!--a-->copyin<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_362"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_363"></a> function, and back out to user space with the <code><!--a-->copyout<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_364"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_365"></a> function. For large blocks of data, entire pages will be memory mapped using copy-on-write<a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_366"></a>. For this reason, it is generally not useful to do memory mapping by hand.</p>
<p>Getting data from the kernel <em>to</em> an application can be done in a number of ways. The most common method is the reverse of the above, in which the application passes in a buffer pointer, the kernel scribbles on a chunk of data, uses <code><!--a-->copyout<!--/a--></code> to copy the buffer data into the address space of the application, and returns <code><!--a  -->KERN_SUCCESS<!--/a--></code>. Note that this is really using the buffer allocated in the application, even though the physical memory may have actually been allocated by the kernel. Assuming the kernel frees its reference to the buffer, no memory is wasted.</p>
<p>A special case of memory mapping occurs when doing I/O to a device from user space. Since I/O operations can, in some cases, be performed by DMA hardware that operates based on physical addressing, it is vital that the memory associated with I/O buffers not be paged out while the hardware is copying data to or from the buffer.</p>
<p>For this reason, when a driver or other kernel entity needs a buffer for I/O, it must take steps to mark it as not pageable. This step is referred to as <strong>wiring</strong><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_367"></a> the pages in memory.</p>
<p>Wiring pages into memory can also be helpful where high bandwidth, low latency communication is desired, as it prevents shared buffers from being paged out to disk. In general, however, this sort of workaround should be unnecessary, and is considered to be bad programming practice.</p>
<p>Pages can be wired in two ways. When a memory region is allocated, it may be allocated in a nonpageable fashion. The details of allocating memory for I/O differ, depending on what part of the kernel you are modifying. This is described in more detail in the appropriate sections of this document, or in the case of the I/O Kit, in the API reference documentation (available from the developer section of Apple’s web site). Alternately, individual pages may be wired after allocation.</p>
<p>The recommended way to do this is through a call to <code><!--a-->vm_wire<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_368"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_369"></a> in BSD parts of the kernel, with <code><a href="../../../Reference/ManPages/man2/mlock.2.html#//apple_ref/doc/man/2/mlock" target="_top">mlock</a></code> from applications (but only by processes running as root), or with <code><a href="../../../Reference/KernelIOKitFramework/IOMemoryDescriptor_h/Classes/IOMemoryDescriptor/index.html#//apple_ref/cpp/cl/IOMemoryDescriptor" target="_top">IOMemoryDescriptor</a></code>::<code><!--a target="_top" -->prepare<!--/a--></code><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_370"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_371"></a> in the I/O Kit. Because this can fail for a number of reasons, it is particularly crucial to check return values when wiring memory. The <code><!--a-->vm_wire<!--/a--></code> call and other virtual memory topics are discussed in more detail in <span class="content_text"><a href="../vm/vm.html#//apple_ref/doc/uid/TP30000905-CH210-BEHJDFCA">“Memory and Virtual Memory.”</a></span> The <code><a href="../../../Reference/KernelIOKitFramework/IOMemoryDescriptor_h/Classes/IOMemoryDescriptor/index.html#//apple_ref/cpp/cl/IOMemoryDescriptor" target="_top">IOMemoryDescriptor</a></code><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_372"></a><a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_373"></a> class is described in more detail in the I/O Kit API reference available from the developer section of Apple’s web site.</p>
<a name="//apple_ref/doc/uid/TP30000905-CH217-TPXREF121" title="Summary"></a><h2>Summary</h2>
<p>Crossing the user-kernel boundary is not a trivial task. Many mechanisms exist for this communication, and each one has specific advantages and disadvantages, depending on the environment and bandwidth requirements. Security is a constant concern to prevent inadvertently allowing one program to access data or files from another program or user. It is every kernel programmer’s personal responsibility to take security into account any time that data crosses the user-kernel boundary<a name="//apple_ref/doc/uid/TP30000905-CH217-DontLinkElementID_374"></a>.</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Networking/Networking.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../synchronization/synchronization.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2002, 2006 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2006-11-07<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Conceptual/KernelProgramming/boundaries/boundaries.html%3Fid%3DTP30000905-5.7&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Conceptual/KernelProgramming/boundaries/boundaries.html%3Fid%3DTP30000905-5.7&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Conceptual/KernelProgramming/boundaries/boundaries.html%3Fid%3DTP30000905-5.7&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>