/*	File:		MyApplication.c		Contains:	My Application Shell.	Written by:	John Wang	Copyright:	© 1994 by Apple Computer, Inc., all rights reserved.	Change History (most recent first):		<1>		03/14/94	JW		Re-Created for Universal Headers.	To Do:	*/#ifdef THINK_C#define		applec#endif#include	<Types.h>#include	<Memory.h>#include	<QuickDraw.h>#include	<Palettes.h>#include	<QDOffscreen.h>#include	<Errors.h>#include	<Fonts.h>#include	<Dialogs.h>#include	<Windows.h>#include	<Menus.h>#include	<Events.h>#include	<Desk.h>#include	<DiskInit.h>#include	<OSUtils.h>#include	<Resources.h>#include	<ToolUtils.h>#include	<AppleEvents.h>#include	<EPPC.h>#include	<GestaltEqu.h>#include	<Processes.h>#include	<Balloons.h>#include	<Aliases.h>#include	<MixedMode.h>#include	<Scrap.h>#include	<LowMem.h>#include	<Movies.h>#include	<QuickTimeComponents.h>#include	"MyApplication Shell (2.0).h"#include	"MyApplication.h"/* ------------------------------------------------------------------------- *///	These globals are used by the shell and must be defined:Str255		gMyAboutTitle = "\pSample Application";Str255		gMyAboutDesc = "\pThis is a sample application shell.";//	Add your own globals here:struct WindowInfo {	long			stuff;};typedef		struct WindowInfo WindowInfo, *WindowInfoPtr, **WindowInfoHandle;/* ------------------------------------------------------------------------- *///	MyInitialize is called at init time after the toolbox is initialized.  This routine is//	called only once.OSErr MyInitialize(){	OSErr		err;	long		QDfeature;		//	We require QuickTime so make sure it is available.	if (err = Gestalt(gestaltQuickTime, &QDfeature))		return(err);			if (err = EnterMovies())		return(err);	else		return(noErr);}//	Depending on the value of the constant MYEVENTDEF, this routine may have different//	calling frequency.//	If MYEVENTDEF == 2, then this routine gets called for every//	   window owned by the application of type MAS_WINDOWDOC per iteration of the event loop//	   if the event is NOT a null event.  MyEvent can assume that the grafport and gdevice//	   are set to the window being passed.//	If MYEVENTDEF == 1, then this routine gets called once per event loop is the//	   event is NOT a null event.  theWindow will be nil.//	If MYEVENTDEF == 0, this routine never gets called.//	Returning true indicates that the event was handled and can be ignored by the normal//	event handler.Boolean MyEvent(WindowPtr theWindow, EventRecord *myEvent){	return ( false );}//	Depending on the value of the constant MYIDLEDEF, this routine may have different//	calling frequency.//	If MYIDLEDEF == 2, then this routine gets called for every//	   window owned by the application of type MAS_WINDOWDOC per iteration of//	   the event loop.  You can assume that the port and gdevice are set to the window.//	If MYIDLEDEF == 1, then this routine gets called once per event loop.  theWindow will be nil.//	If MYIDLEDEF == 0, this routine never gets called.void MyIdle(WindowPtr theWindow){}//	MyDraw is called when redrawing the window is needed.  The port and gdevice//	is already set and begin and end update are called for MyDraw.void MyDraw(WindowPtr theWindow){}//	This routine gets called once when the application is quitting.//	This gives the app the chance to clean up.void MyFinishup(){}//	This routine is called whenever the app receives a suspend or resume event.  This//	allows the yield time (passed to WaitNextEvent) to be changed.  I.e., if you don't//	do much processing the in background, you should set the yield to a high value//	when the suspend message is received.long MyYieldTime(long message){	if ( message )		//	Resume message		return ( 0 );	else		//	Suspend message		return ( 30 );}//	If the shell's doCommand routine can not process the menu selection, then this routine is//	called.  Do not call HiliteMenu because it is called by the shell.//	If the command can not be handled, this it must be an error and the shell will//	present a FATAL error to the user.OSErr MyDoCommand(short theMenu, short theItem){	switch ( theMenu ) {		case kMENU_NEXTID:			switch ( theItem ) {				case kMENU_NEXT1stITEM:					break;				default:					return ( theItem );			}			break;					default:			return ( theItem );	}		return ( noErr );}void MyDoKeyDown(EventRecord *myEvent){}void MyInContent(WindowPtr foundWindow, Point where){}void MyZoomWindow(WindowPtr foundWindow, short windowPart){	if ( windowPart == 8 ) {	} else {	}	ZoomWindow(foundWindow, windowPart, true);}void MyAdjustMenus(){}/* ------------------------------------------------------------------------- */void MyNew(){	WindowPtr				myWindow;	Rect					myBounds = {42, 4, 522, 644};	WindowInfoHandle		myWinfo;	Component				vThing;	ComponentDescription	vThingDesc;	ComponentInstance		vThingInst;	Rect					maxSrcRect, activeRect, globalRect;	PixMapHandle			videoPixMapH;		myWindow = NewCWindow(0L, &myBounds, "\pWindow!", 1, documentProc, (WindowPtr) -1, true, 0L);	SetMyWindow(myWindow);	SetPort(myWindow);	SetGDevice(GetMainDevice());	myWinfo = (WindowInfoHandle) NewHandle(sizeof(WindowInfo));	SetWRefCon(myWindow, (long) myWinfo);	(**myWinfo).stuff = 0;		vThingDesc.componentType = 'vdig';	vThingDesc.componentSubType = 0;	vThingDesc.componentManufacturer = 0;	vThingDesc.componentFlags = 0;	vThingDesc.componentFlagsMask = 0;	vThing = FindNextComponent((Component) 0, &vThingDesc);	vThingInst = OpenComponent(vThing);		VDGetMaxSrcRect(vThingInst, ntscIn, &maxSrcRect);	VDGetActiveSrcRect(vThingInst, ntscIn, &activeRect);	VDSetDigitizerRect(vThingInst, &activeRect);		globalRect = myWindow->portRect;	videoPixMapH = (PixMapHandle) NewHandle(sizeof(PixMap));	**videoPixMapH = **((* (CGrafPort *) myWindow).portPixMap);	VDSetPlayThruOnOff(vThingInst, vdPlayThruOff);	VDSetPlayThruDestination(vThingInst, videoPixMapH, &globalRect, nil, nil);	VDSetPlayThruOnOff(vThingInst, vdPlayThruOn);	do {	} while ( !Button() );	VDGrabOneFrame(vThingInst);}//	If theFSS is not nil, then the file to be opened is specified in the FSSpec.//	MyOpen must make window frontmost so that it can be printed from finder.void MyOpen(FSSpec *theFSS){	SysBeep(50);}void MyClose(){	WindowPtr			closeWindow;	WindowInfoHandle	myWinfo;		closeWindow = FrontWindow();	if ( closeWindow == nil )		return;			myWinfo = (WindowInfoHandle) GetWRefCon(closeWindow);	DisposHandle((Handle) myWinfo);	DisposeWindow(closeWindow);}void MySave(){	SysBeep(50);}void MySaveAs(){	SysBeep(50);}void MyPageSetup(){	SysBeep(50);}void MyPrint(){	SysBeep(50);}/* ------------------------------------------------------------------------- */void MyUndo(void){	SysBeep(50);}void MyCut(void){	SysBeep(50);}void MyCopy(void){	SysBeep(50);}void MyPaste(void){	SysBeep(50);}void MyClear(void){	SysBeep(50);}void MySelectAll(void){	SysBeep(50);}