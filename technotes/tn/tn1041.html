<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"        "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd"><HTML><!-- Template 03-24-01 --><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css">   <title>Technical Note TN1041: Inside Macintosh: Files Errata</title>    <meta name="keywords" content="Macintosh OS 8 Inside Files errata omissions Alias Manager PBGetXCatInfo">    <meta name="Description" content="Technical Note TN1041: This Technical Note discusses knownerrors and omissions in Inside Macintosh: Files. Topics thatwere corrected include: File Management and the File Manager,the Standard File Package, the Alias Manager, and the DiskInitialization Manager."><meta name="categories" content="Inside Macintosh Errata and Files"><meta name="week-posted" content="Nov 1, 1999 - Nov 5, 1999"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002883" title="Inside Macintosh: Files Errata"></a><A NAME="top"></A><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxCarbon-date.html">Carbon</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/Carbon/idxFileManagement-date.html" target="_blank">Carbon > File Management</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1041</div>
<div id="pageheadsub">Inside Macintosh: Files Errata</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><center><table width="600" cellpadding="0" cellspacing="0" border="0"> <tr> <td align="left" scope="row"><!-- begin_header_box --> <A HREF="#top"></a><hr width=500 align=center><BR><BR><table border="0" width="600" cellpadding="0" cellspacing="0">	<tr>		<td width=600 align=left> <img src="images/mtop600.gif" alt="" align="bottom" width=600 height=7></td>	</tr>		<tr bgcolor="#e6e6e6">	<td background="images/mbody600.gif" width=600 align=left><span id="menutitle">    CONTENTS   <br>  <br></span>    </td></tr><tr bgcolor="#e6e6e6">	<td background="images/mbody600.gif" width=600 align=left>							<table border="0" width="590" cellpadding="0" cellspacing="0">	<tr> 	<td width=295 align=left scope="row"><!-- begin_toc -->			<p id="menutext"><A HREF = "#Chapter1">Chapter 1 - Introduction to         File Management</A><BR>  <BR>                           <A HREF = "#Ch1-53"><CODE>FSpExchangeFiles</CODE> and            <CODE>PBExchangeFiles</CODE> - What is exchanged</A> <BR>                        <A HREF = "#Ch1-56">Additional Considerations for            <CODE>GetVInfo</CODE></A><BR><BR>                   <A HREF = "#Chapter2">Chapter 2 - File         Manager</A><BR><BR>                               <A HREF = "#Ch2-27">Pathname rules are not fully            explained</A><BR>                        <A HREF = "#Ch2-35">Missing Row in Table 2-10</A><BR>                        <A HREF = "#Ch2-36">Description of default directory            upon launch wrong</A><BR>                        <A HREF = "#Ch2-62">Master Directory Blocks <CODE>drXTFlSize</CODE>            and <CODE>drCTFlSize</CODE> field descriptions are wrong</A><BR>                        <A HREF = "#Ch2-69">Map records in map nodes occupy 492            bytes (not 494 bytes)</A><BR>                        <A HREF = "#Ch2-79">Volume cache control bit in            <CODE>vcbAtrb</CODE></A><BR>                        <A HREF = "#Ch2-81">Volume Control Blocks <CODE>vcbXTAlBks</CODE>            and <CODE>vcbCTAlBks</CODE> field descriptions are wrong</A><BR>                        <A HREF = "#Ch2-85"><CODE>dQDrvSiz</CODE> fields not used on 3.5"            floppy disks</A><BR>                        <A HREF = "#Ch2-90">Clarification of <CODE>ioFlAttrib</CODE> bits in            <CODE>ParamBlockRec, HParamBlockRec,</CODE> and <CODE>CInfoPBRec</CODE></A><BR>                        <A HREF = "#Ch2-100"><CODE>ioACUser</CODE> is <CODE>filler2</CODE> in some interface files</A><BR>                        <A HREF = "#Ch2-110">The <CODE>VolMountInfoHeader</CODE> data            structure includes flags word</A><BR>                        <A HREF = "#Ch2-121"><CODE>ioPosMode</CODE> usage by <CODE>PBRead</CODE> and <CODE>PBWrite</CODE> requests</A><BR>                        <A HREF = "#Ch2-137">Additional Considerations for            <CODE>GetVInfo</CODE></A><BR>                        <A HREF = "#Ch2-142">Parameter blocks have unnecessary            <CODE>ioCompletion</CODE> field</A><BR>                        <A HREF = "#Ch2-145">Additional Special Considerations            for <CODE>PBHGetVInfo</CODE></A><BR>                        <A HREF = "#Ch2-160.1"><CODE>FSpGetFInfo</CODE> does not work with            directories</A><BR>                        <A HREF = "#Ch2-160.2"><CODE>FSpSetFInfo</CODE> does not work with            directories</A><BR>                        <A HREF = "#Ch2-165"><CODE>FSpExchangeFiles</CODE> and            <CODE>PBExchangeFiles</CODE> - What is exchanged</A><BR>                        <A HREF = "#Ch2-169"><CODE>HOpenDF</CODE>, <CODE>PBHOpenDF</CODE> and the <CODE>paramErr</CODE> result code</A><BR>                        <A HREF = "#Ch2-183.1">Parameter blocks missing            <CODE>ioFVersNum</CODE> field</A><BR>                        <A HREF = "#Ch2-183.2">Parameter blocks missing <CODE>ioMisc</CODE>            field</A><BR>                        <A HREF = "#Ch2-191"><CODE>PBGetCatInfo</CODE> <CODE>ioFDirIndex</CODE> usage rules</A><BR>                        <A HREF = "#Ch2-219">Parameter blocks missing <CODE>ioNamePtr</CODE>            field</A><BR>                        <A HREF = "#Ch2-233"><CODE>ioForeignPrivIDirID</CODE> is <CODE>LongInt</CODE> in            <CODE>PBGetForeignPrivs</CODE> and <CODE>PBSetForeignPrivs</CODE></A><BR>                        <A HREF = "#Ch2-239">Request execution order</A><BR>                        <A HREF = "#Ch2-293">Volume Parameter Variant offsets            are off by 2</A><BR>                        <A HREF = "#volumeSignature">Detecting if a volume is            formatted Macintosh File System (MFS), Hierarchical File            System (HFS), or HFS Plus</A><BR>                        <A HREF = "#Ch2-PBXGetVolInfo"><CODE>PBXGetVolInfo</CODE></A><BR>                        <A HREF = "#Ch2-PBGetXCatInfo"><CODE>PBGetXCatInfo</CODE></A><BR><BR>                           <A HREF = "#Chapter3">Chapter 3 - Standard File         Package</A><BR><BR>                               <A HREF = "#Ch3-30">Activation Procedures Need to call            <CODE>TECalText</CODE></A><BR>                        <A HREF = "#Ch3-31">Default Standard File current            directory</A><BR>                        <A HREF = "#Ch3-33">Listing 3-15 does not set <CODE>sfScript</CODE>            field</A><BR><BR>                           <A HREF = "#Chapter4">Chapter 4 - Alias         Manager</A><BR><BR>                               <A HREF = "#Ch4-19"><CODE>ResolveAlias</CODE> updates minimal            aliases</A><BR>                        <A HREF = "#Ch4-20"><CODE>usrCanceledErr</CODE> should be            userCanceledErr</A><BR>                        <A HREF = "#Ch4-23"><CODE>kARMSearchMore</CODE> and memory available            to <CODE>AliasFilterProc</CODE> warning</A><BR><BR>                           <A HREF = "#Chapter5">Chapter 5 - Disk Initialization         Manager</A><BR><BR>                               <A HREF = "#Ch5-ExtDiskInitPack">Extended Disk            Initialization Package</A><BR>                        <A HREF = "#Ch5-ExtDiskInitUI">Extended Disk            Initialization User Interface</A><BR>                        <A HREF = "#Ch5-ExtDiskInitRoutines">Extended Low-Level            Disk Initialization Routines</A><BR>                        <A HREF = "#Ch5-DIXFormat"><CODE>DIXFormat</CODE></A><BR>                        <A HREF = "#Ch5-DIXZero"><CODE>DIXZero</CODE></A><BR>                        <A HREF = "#Ch5-DIReformat"><CODE>DIReformat</CODE></A><BR>                        <A HREF = "#Formatting">Formatting HFS and HFS Plus            Volumes</A><BR><BR>                  <A HREF = "#FurtherReferences">Further         References</A><BR><BR>                  <A HREF = "#Downloads">Downloadables</A></p>      <!-- end_toc -->	</td>	</tr></table>		</td>	</tr>	<tr>		<td width=600 align=left scope="row"><img src="images/mbot600.gif" alt="menubot600" width=600 height=16>		</td>	</tr></table>            <BR><!-- begin_intro_text --><P id = "menutext">This Technote discusses known errors and omissions in <B><I>Inside Macintosh: Files</I></B>.</p><!-- end_intro_text --><!-- begin_date --><h3>&nbsp;Updated: [Feb 1 1999]</h3><!-- end_date --> <!-- end_header_box --><BR><BR><hr width=500 align=center>          <BR><BR> <!-- begin_content -->         <A NAME=Chapter1></A>                  <H2>Chapter 1 - Introduction to File Management</H2>                                  <H3><A NAME="Ch1-53"></A><CODE>FSpExchangeFiles</CODE> and         <CODE>PBExchangeFiles</CODE> - What is exchanged</H3>                  <P>Page 1-53, FSpExchangeFiles</P>                  <P>See the <A HREF = "#Ch2-165">discussion of this topic</A>         in the corrections for Chapter 2.</P>                  <H3><A NAME="Ch1-56"></A>Additional Considerations for         <CODE>GetVInfo</CODE></H3>                  <P>Page 1-56, GetVInfo</P>                  <P>See the <A HREF = "#Ch2-137">discussion of this topic</A>         in the corrections for Chapter 2.</P>                 <P><A HREF="#top">Back to top</A></P><A NAME=Chapter2></A>                  <H2>Chapter 2 - File Manager</H2>                                  <H3><A NAME="Ch2-27"></A>Pathname rules are not fully         explained</H3>                  <P>Pages 2-27 through 2-28, Names and Pathnames</P>                  <P>The following characteristics of Macintosh pathnames         should be noted: </P>                  <UL>            <LI>A full pathname never begins with a colon, but must            contain at least one colon.</LI>                        <LI>A partial pathname always begins with a colon            separator except in the case where the file partial            pathname is a simple file or directory name.</LI>                        <LI>Single trailing separator colons in full or partial            pathnames are ignored except in the case of full            pathnames to volumes.</LI>                        <LI>In full pathnames to volumes, the trailing separator            colon is required.</LI>                        <LI>Consecutive separator colons can be used to ascend a            level from a directory to its parent directory. Two            consecutive separator colons will ascend one level, three            consecutive separator colons will ascend two levels, and            so on. Ascending can only occur from a directory; not a            file.</LI>         </UL>                  <P>To summarize, if the first character of a pathname is a         colon, or if the pathname contains no colons, it must be a         partial pathname; otherwise, it is a full pathname.</P>                  <H3><A NAME="Ch2-35"></A>Missing Row in Table 2-10</H3>                  <P>Page 2-35, Creating File System Specification Records</P>                  <P>Add the following row to Table 2-10: </P>                  <TABLE BORDER=1>            <TR>               <td align="left">                  <P>Working directory reference number</P>               </TD>               <td align="left">                  <P>Directory ID</P>               </TD>               <td align="left">                  <P>Empty string or NIL</P>               </TD>               <td align="left">                  <P>The target object is the directory specified by                  the directory ID in <CODE>dirID</CODE></P>               </TD>            </TR>         </TABLE>                  <H3><A NAME="Ch2-36"></A>Description of default directory         upon launch wrong</H3>                  <P>Page 2-36, Manipulating the Default Volume and         Directory</P>                  <P>Replace the last sentence in the first paragraph with the         following: </P>                  <P>"When an application starts up, its default directory is         set to the directory in which the application resides.         Thereafter, the application can designate any directory as         its default directory."</P>                  <H3><A NAME="Ch2-62"></A>Master Directory Blocks <CODE>drXTFlSize</CODE>         and <CODE>drCTFlSize</CODE> field descriptions are wrong</H3>                  <P>Page 2-62, Master Directory Blocks</P>                  <P>Change the field descriptions to: </P>                  <TABLE BORDER=1>            <TR>               <td align="left">                  <P><CODE>drXTFlSize</CODE></P>               </TD>               <td align="left">                  <P>The size (in bytes) of the extents overflow                  file.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>drCTFlSize</CODE></P>               </TD>               <td align="left">                  <P>The size (in bytes) of the catalog file.</P>               </TD>            </TR>         </TABLE>                  <H3><A NAME="Ch2-69"></A>Map records in map nodes occupy 492         bytes (not 494 bytes)</H3>                  <P>Page 2-69, Map Nodes</P>                  <P>Replace the second and third paragraphs in the Map Nodes         section with the following: </P>                  <P>"A map node consists of a node descriptor and a single         map record. The map record is a continuation of the map         record contained in the header node and occupies 492 bytes         (512 bytes in the node, less 14 bytes for the node         descriptor, 2 bytes for each of the two record offsets at         the end of the node, and rounded down to a multiple of a         longword). (Note: The HFS file system's B*-tree manager         reads the bitmap information a longword at a time.) A map         node can therefore contain mapping information for an         additional 3936 nodes.</P>                  <P>If a B*-tree contains more than 5984 nodes (that is, 2048         + 3936, enough for around 25,000 files), the File Manager         uses a second map node, the node number of which is stored         in the ndFLink field of the node descriptor of the first map         node. If more map nodes are required, each additional map         node is similarly linked to the previous one."</P>                  <H3><A NAME="Ch2-79"></A>Volume cache control bit in         vcbAtrb</H3>                  <P>Page 2-79, Volume Control Blocks</P>                  <P>Add the following bit definition to <CODE>vcbAtrb</CODE> for System         7.5 or later: </P>                  <TABLE BORDER=1>            <TR>               <TH>                  <P ALIGN=left>Bit</P>               </TH>               <TH>                  <P ALIGN=left>Meaning</P>               </TH>            </TR>            <TR>               <td align="left">                  <P>10</P>               </TD>               <td align="left">                  <P>Set if the volume's blocks should not be cached                  (System 7.5 and later only). This allows access to                  RAM disk volumes to bypass the File Manager cache.                  It has the same affect as setting the <CODE>noCache</CODE> bit                  (bit 5 of <CODE>ioPosMode</CODE>) for all File Manager reads and                  writes to the volume. Non-block aligned requests                  may still be accessed through the cache.</P>               </TD>            </TR>         </TABLE>                                   <P>When a HFS volume is mounted with System 7.5 or later,         the File Manager calls the disk driver with a "Return Drive         Info" <CODE>_Control</CODE> call (<CODE>csCode</CODE>=23). Then if there are no         errors, it looks at the low-byte (bits 0-7) of <CODE>csParam</CODE> to         see if the drive type is <CODE>ramDiskType</CODE> (16, $10) or         <CODE>romDiskType</CODE> (17, $11) and if so, sets the <CODE>vcbAtDontCache</CODE> bit         in the VCB's <CODE>vcbAtrb</CODE> field. This allows access to RAM or ROM         disk volumes to bypass the File Manager cache. It has the         same affect as setting the <CODE>noCache</CODE> bit (bit 5 of <CODE>ioPosMode</CODE>)         for all File Manager reads and writes to the volume.         Non-block aligned requests may still be accessed through the         cache.</P>                  <P>Driver Note: Drivers should not directly modify the         <CODE>vcbAtDontCache</CODE> bit in <CODE>vcbAtrb</CODE>. If the driver is for a RAM or         ROM disk, it should support <CODE>_Control</CODE> <CODE>csCode</CODE> 23 and say that         it is a RAM or ROM disk by returning <CODE>ramDiskType</CODE> (16, $10)         or <CODE>romDiskType</CODE> (17, $11) in the low-byte of <CODE>csParam</CODE>. Other         disk drivers should not set the <CODE>vcbAtDontCache</CODE> bit because         any future improvements made to the File Manager cache will         be lost on those drives.</P>                  <H3><A NAME="Ch2-81"></A>Volume Control Blocks <CODE>vcbXTAlBks</CODE>         and <CODE>vcbCTAlBks</CODE> field descriptions are wrong</H3>                  <P>Page 2-81, Volume Control Blocks</P>                  <P>Change the field descriptions to: </P>                  <TABLE BORDER=1>            <TR>               <td align="left">                  <P><CODE>vcbXTAlBks</CODE></P>               </TD>               <td align="left">                  <P>The size (in allocation blocks) of the extents                  overflow file.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>vcbCTAlBks</CODE></P>               </TD>               <td align="left">                  <P>The size (in allocation blocks) of the catalog                  file.</P>               </TD>            </TR>         </TABLE>                  <H3><A NAME="Ch2-85"></A><CODE>dQDrvSiz</CODE> fields not used on 3.5"         floppy disks</H3>                  <P>Page 2-85, The Drive Queue</P>         <BR>        <CENTER><TABLE BORDER=0 CELLPADDING=1 WIDTH=500>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <P><B>Note: </B><BR>                  If the volume is a 3 1/2-inch floppy disk owned by            the .Sony driver, the <CODE>dQDrvSiz</CODE> and <CODE>dQDrvSiz2</CODE> fields are not valid. To get the size of a 3 1/2-inch floppy disk            owned by the .Sony driver, first try the Return Format            List (<CODE>csCode</CODE>= 6) Status call and if Return Format List            fails with a <CODE>statusErr</CODE> (-18), use <CODE>DriveStatus</CODE>            and check the <CODE>twoSideFmt</CODE> field of the <CODE>DrvSts</CODE>            record to determine if the disk has 800 blocks (<CODE>twoSideFmt</CODE> =            0) or 1600 blocks (<CODE>twoSideFmt</CODE> = -1). See the Technical Note            "DV 17 - Sony Driver : What Your Sony Drives For You" for more            information concerning the Return Format List Status            call.</p></TD>         </TR>         </table></center><BR>         <BR>         <H3><A NAME="Ch2-90"></A>Clarification of <CODE>ioFlAttrib</CODE> bits in         <CODE>ParamBlockRec</CODE>, <CODE>HParamBlockRec</CODE>, and <CODE>CInfoPBRec</CODE></H3>                  <P>Page 2-90, Basic File Manager Parameter Block, field         descriptions for the <CODE>fileParam</CODE> variant.<BR>         Page 2-96, HFS Parameter Block, field descriptions for the         <CODE>fileParam</CODE> variant.<BR>         Page 2-102, Catalog Information Parameter Blocks, field         descriptions common to both variants.</P>                  <P>For files, the bits in <CODE>ioFlAttrib</CODE> have the following         meanings: </P>                  <TABLE BORDER=1>            <TR>               <TH>                  <P ALIGN=left>Bit</P>               </TH>               <TH>                  <P ALIGN=left>Meaning</P>               </TH>            </TR>            <TR>               <td align="left">                  <P>0</P>               </TD>               <td align="left">                  <P>Set if file is locked. Can be changed with the                  <CODE>PBHSetFLock</CODE> or <CODE>PBHRstFLock</CODE> functions.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>1</P>               </TD>               <td align="left">                  <P>Reserved.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>2</P>               </TD>               <td align="left">                  <P>Set if resource fork is open.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>3</P>               </TD>               <td align="left">                  <P>Set if data fork is open.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>4</P>               </TD>               <td align="left">                  <P>Set if directory. (Always clear for files.)</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>5</P>               </TD>               <td align="left">                  <P>Reserved.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>6</P>               </TD>               <td align="left">                  <P>Set if AppleShare server "copy-protects" the                  file. Set by the AppleShare foreign file system                  code when the server sets the <CODE>CopyProtect</CODE> bit                  returned by <CODE>afpGetFileDirParms</CODE>.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>7</P>               </TD>               <td align="left">                  <P>Set if file (either fork) is open.</P>               </TD>            </TR>         </TABLE>                                   <P>For directories, the bits in <CODE>ioFlAttrib</CODE> have the         following meanings: </P>                  <TABLE BORDER=1>            <TR>               <TH>                  <P ALIGN=left>Bit</P>               </TH>               <TH>                  <P ALIGN=left>Meaning</P>               </TH>            </TR>            <TR>               <td align="left">                  <P>0</P>               </TD>               <td align="left">                  <P>Set if the directory is locked. Can be changed                  with the <CODE>PBHSetFLock</CODE> or <CODE>PBHRstFLock</CODE> functions when                  volume is shared.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>1</P>               </TD>               <td align="left">                  <P>Reserved.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>2</P>               </TD>               <td align="left">                  <P>Set if the directory is within a shared area of                  the directory hierarchy.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>3</P>               </TD>               <td align="left">                  <P>Set if the directory is a share point that is                  mounted by some user.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>4</P>               </TD>               <td align="left">                  <P>Set if directory. (Always set for                  directories.)</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>5</P>               </TD>               <td align="left">                  <P>Set if the directory is a share point. Can be                  set or cleared by <CODE>PBShare</CODE> and <CODE>PBUnshare</CODE>.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>6</P>               </TD>               <td align="left">                  <P>Reserved.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>7</P>               </TD>               <td align="left">                  <P>Reserved.</P>               </TD>            </TR>         </TABLE>                  <H3><A NAME="Ch2-100"></A><CODE>ioACUser</CODE> is filler2 in some         interface files</H3>                  <P>Page 2-100 and 2-103, Catalog Information Parameter         Blocks<BR>         Page 2-191, <CODE>PBGetCatInfo</CODE></P>         <BR>        <CENTER><TABLE BORDER=0 CELLPADDING=1 WIDTH=500>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <P><B>Note: </B><BR>                  The <CODE>ioACUser</CODE> field is at offset 31 <CODE>($1F)</CODE>                  in the <CODE>CInfoPBRec</CODE> parameter block. In most versions of                  the Files interfaces (Files.h, Files.p, etc.), the field at offset                  31 is <CODE>filler2</CODE>. This problem is fixed in newer versions                  of the Files interfaces.</p></TD>         </TR>         </table></center><BR>         <hr width=500 align=center>         <H3><A NAME="Ch2-110"></A>The <CODE>VolMountInfoHeader</CODE> data         structure includes flags word</H3>                  <P>Page 2-110, Volume Mounting Information Records</P>                  <P>The <CODE>VolMountInfoHeader</CODE> data structure has been extended         to include a flags word. The data structure is now defined         as: </P>                  <TABLE BORDER=0>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <pre>struct VolMountInfoHeader{    short       length;  /* length of location data (including self) */    VolumeType  media;   /* type of media */    short       flags;   /* high-byte reserved for Apple, */                         /* low-byte reserved for file system                            specific use */    /* Variable length data follows */};</pre>               </TD>            </TR>         </TABLE>                                   <P>In the flags word, bits 14 and 15 have been defined. All         other bits in the high-byte of the flags word should be left         clear. Bits in the low-byte of the flags word are file-         system specific. For example, the AppleShare foreign file         system uses bit 0 to determine if server greeting messages         should be shown or suppressed.</P>                  <P>Bit 15 in the flags word tells the file system that         accepts a <CODE>VolumeMount</CODE> request if user interaction can be         performed. If Bit 15 is set, the file system must not         perform user interaction. If Bit 15 is clear, the file         system may perform user interaction through the mechanism         supplied by the File System Manager (FSM).</P>                  <P>Bit 14 in the flags word allows a file system to indicate         to the caller of <CODE>VolumeMount</CODE> that although the <CODE>VolumeMount</CODE>         request was successful, the <CODE>VolMountInfo</CODE> record passed needs         to be updated. Programs should ensure bit 14 of the flags         word is clear before calling <CODE>VolumeMount</CODE> and if bit 14 is         returned set, the <CODE>VolMountInfo</CODE> record should be updated by         calling <CODE>PBGetVolMountInfoSize</CODE> and <CODE>PBGetVolMountInfo</CODE>. If         <CODE>VolumeMount</CODE> is unsuccessful, bit 14 in the flags word should         be ignored.</P>                  <P>Observant readers will note that the Alias Manager needs         to use bits 14 and 15 in the flags word to interact with         file systems when responding to a <CODE>MatchAlias</CODE> function         call.</P>                  <H3><A NAME="Ch2-121"></A><CODE>ioPosMode</CODE> usage by <CODE>PBRead</CODE> and         <CODE>PBWrite</CODE> requests</H3>                  <P>Page 2-121, PBRead<BR>         Page 2-122, PBWrite</P>                  <P>The <CODE>PBRead</CODE> and <CODE>PBWrite</CODE> functions give programs much more         control over read and write operations than the high-level         <CODE>FSRead</CODE> and <CODE>FSWrite</CODE> functions because <CODE>PBRead</CODE> and <CODE>PBWrite</CODE>         allow access to the ioPosMode field.</P>                  <P>Bits 0 and 1 of ioPosMode indicate where to start reading         or writing data in the file. The values allowed in <CODE>ioPosMode</CODE>         to set bits 0 and 1 are: </P>                  <TABLE BORDER=1>            <TR>               <TH>                  <P ALIGN=left>constant</P>               </TH>               <TH>                  <P ALIGN=left>value</P>               </TH>               <TH>                  <P ALIGN=left>description</P>               </TH>            </TR>            <TR>               <td align="left">                  <P><CODE>fsAtMark</CODE></P>               </TD>               <td align="left">                  <P>0</P>               </TD>               <td align="left">                  <P><CODE>ioPosOffset</CODE> is ignored. Operation starts at                  current mark.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>fsFromStart</CODE></P>               </TD>               <td align="left">                  <P>1</P>               </TD>               <td align="left">                  <P><CODE>ioPosOffset</CODE> is an offset from the beginning of                  file.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>fsFromLEOF</CODE></P>               </TD>               <td align="left">                  <P>2</P>               </TD>               <td align="left">                  <P><CODE>ioPosOffset</CODE> is an offset from the logical                  end-of-file.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>fsFromMark</CODE></P>               </TD>               <td align="left">                  <P>3</P>               </TD>               <td align="left">                  <P><CODE>ioPosOffset</CODE> is an offset from the current                  mark.</P>               </TD>            </TR>         </TABLE>                                   <P>Bits 4 and 5 of <CODE>ioPosMode</CODE> are cache usage hints passed on         to the file system that handles requests to the volume the         file is on. Bit 4 is a request that the data be cached         (i.e., please cache this). Bit 5 is a request that the data         not be cached (i.e., please do not cache this). Bits 4 and 5         are mutually exclusive - only one should be set at a time.         However, if neither is set, then the program has indicated         that it doesn't care if the data is cached or not. The         values allowed in <CODE>ioPosMode</CODE> to set bits 4 and 5 are: </P>                  <TABLE BORDER=1>            <TR>               <TH>                  <P ALIGN=left>constant</P>               </TH>               <TH>                  <P ALIGN=left>value</P>               </TH>               <TH>                  <P ALIGN=left>description</P>               </TH>            </TR>            <TR>               <td align="left">                  <P>(no constant)</P>               </TD>               <td align="left">                  <P>0</P>               </TD>               <td align="left">                  <P>I don't care if this request is cached or not                  cached.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>pleaseCacheMask</CODE></P>               </TD>               <td align="left">                  <P>16</P>               </TD>               <td align="left">                  <P>Please, cache this request if possible.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>noCacheMask</CODE></P>               </TD>               <td align="left">                  <P>32</P>               </TD>               <td align="left">                  <P>Please, I'd rather you didn't cache this                  request.</P>               </TD>            </TR>         </TABLE>                          <BR>                  <CENTER><TABLE BORDER=0 CELLPADDING=1 WIDTH=500>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <P><B>Note: </B><BR>                  A particular file system may choose to ignore one or            both of the cache usage hint bits. File systems may cache            when you set the <CODE>noCache</CODE> bit, may not cache when you set            the <CODE>pleaseCache</CODE> bit, may cache everything, or may cache            nothing. However, if a program leaves both bits clear,            then file systems which do respect these bits have no way            of knowing if the data being read or written will be            needed again by your program.</p>               </TD></TR>         </TABLE></center><BR>               <BR>         <P>Bit 6 (<CODE>rdVerify</CODE>) of <CODE>ioPosMode</CODE> is a request that         reads (not writes) come directly from the source of the data and         be verified against the data in memory. So, if a file system         gets a read request with <CODE>rdVerify</CODE> set, it should flush any         cache it might have of that data and ask its data source (in         the case of local volumes, that would be the disk driver)         for the data again. If the data source is a disk driver,         then the file system should pass the <CODE>rdVerify</CODE> request on to         the disk driver and the disk driver should do the same thing         --flush any cache it has of that data (including any cache         on the disk hardware) and ask its source (the disk hardware)         for the data again. The idea behind <CODE>rdVerify</CODE> is that a         program could write data to a volume, then ask the file         system to compare the data from the disk volume to the data         in the write buffer. The Finder uses this technique when         copying files only when copying files to floppy disks.</P>                  <CENTER><TABLE BORDER=0 CELLPADDING=1 WIDTH=500>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <P><B>WARNING: </B><BR>                  There's a bug in current version of the HFS file            system that affects <CODE>rdVerify</CODE> requests. Instead of just            comparing the data from a disk to the data in memory, the            HFS file system actually reads any full 512-byte blocks            in the request from the source device into the buffer            overwriting the original data instead of comparing it. In            most cases, this is exactly the same data that was just            written to the device, but if any data corruption occurs            because of media or hardware failures, your original            write data buffer could be corrupted. Your code can            work around this problem by first making a copy of the            write data buffer, then performing the <CODE>rdVerify</CODE> operation            against the copy instead of the original data buffer, and            finally comparing the copy and original data buffers to            ensure the data written is the same as the data just            read.</p></TD>         </TR>         </table></center><BR>         <BR>                  <P>Bit 7 of <CODE>ioPosMode</CODE> is a request for <CODE>newLine</CODE> mode. If bit         7 is set, then the high-byte of <CODE>ioPosMode</CODE> is the <CODE>newLine</CODE>         character - even if that character is null (<CODE>$00</CODE>). When bit 7         is set, the read should stop when any one of these         conditions is met: </P>                  <UL>            <LI><CODE>ioReqCount</CODE> bytes have been read.</LI>                        <LI>End-of-file is reached.</LI>                        <LI>The <CODE>newLine</CODE> character has been read. If the <CODE>newLine</CODE>            character is found, it will be the last character put            into <CODE>ioBuffer</CODE> and <CODE>ioActCount</CODE> will include it.</LI>         </UL>                  <P>When using <CODE>newLine</CODE> mode, the HFS file system reads the         file one block (512-bytes) at a time into a file system         cache block (not the user buffer pointed to by <CODE>ioBuffer</CODE>) and         then copies the data into the user buffer one byte at a time         looking at each byte for the <CODE>newLine</CODE> character. Since a file         read with <CODE>newLine</CODE> mode is read one block at a time, <CODE>newLine</CODE>         mode is about the slowest way you can read a file.</P>                  <H3><A NAME="Ch2-137"></A>Additional Considerations for         GetVInfo</H3>                  <P>Page 2-137, <CODE>GetVInfo</CODE></P>                  <P>The <CODE>drvNum</CODE> parameter, which specifies the volume, can be         a drive number, volume reference number, 0 (the default         volume), or a working directory number. The <CODE>volName</CODE>         parameter must point to a <CODE>Str27</CODE> buffer or must be set to         NIL. The <CODE>freeBytes</CODE> parameter will not be accurate on volumes         with over 2 GB of free space.</P>                  <H3><A NAME="Ch2-142"></A>Parameter blocks have unnecessary         <CODE>ioCompletion</CODE> field</H3>                  <P>Page 2-142, <CODE>PBOffLine</CODE><BR>         Page 2-219, <CODE>PBGetVolMountInfoSize</CODE><BR>         Page 2-220, <CODE>PBGetVolMountInfo</CODE><BR>         Page 2-223, <CODE>PBVolumeMount</CODE></P>                  <P>The parameter blocks for these routines unnecessarily         list the <CODE>ioCompletion</CODE> field as an input field. These         routines can only be executed synchronously, so the         <CODE>ioCompletion</CODE> field is always ignored.</P>                  <H3><A NAME="Ch2-145"></A>Additional Special Considerations         for <CODE>PBHGetVInfo</CODE></H3>                  <P>Page 2-145, <CODE>PBHGetVInfo</CODE></P>                  <P>Add these "Special Considerations": </P>                  <P>If the value of <CODE>ioVolIndex</CODE> is negative, the File Manager         uses <CODE>ioNamePtr</CODE> and <CODE>ioVRefNum</CODE> in the standard way to         determine the volume. However, because <CODE>PBHGetVInfo</CODE> returns         the volume name in the buffer whose address you passed in         <CODE>ioNamePtr</CODE>, your input pathname will be modified. If you         don't want your input pathname modified, make a copy of it         and pass the copy to <CODE>PBHGetVInfo</CODE>.</P>                  <P>The volume name returned by <CODE>PBHGetVInfo</CODE> is not a full         pathname to the volume because it does not contain a         colon.</P>                  <P>For compatibility with older programs, some values         returned by <CODE>PBHGetVInfo</CODE> are not what is stored in the         volume's Volume Control Block (VCB). Specifically: </P>                  <UL>            <LI><CODE>ioVNmAlBlks</CODE> and <CODE>ioVFrBlk</CODE> are pinned to values which            when multiplied by <CODE>ioVAlBlkSiz</CODE> always are less than 2            Gigabytes.</LI>                        <LI><CODE>ioVNmAlBlks</CODE> may not include the allocation blocks            used by the catalog and extents overflow files.</LI>                        <LI><CODE>$4244</CODE> is returned in <CODE>ioVSigWord</CODE> for both HFS and HFS            Plus volumes.</LI>         </UL>                  <P>For unpinned total and free byte counts, and for the real         <CODE>ioVSigWord</CODE>, use <A HREF = "#Ch2-PBXGetVolInfo">PBXGetVolInfo</A>         instead of <CODE>PBHGetVInfo</CODE>.</P>                  <H3><A NAME="Ch2-160.1"></A><CODE>FSpGetFInfo</CODE> does not work with         directories</H3>                  <P>Page 2-160, <CODE>FSpGetFInfo</CODE></P>                  <P>You can use the <CODE>FSpGetFInfo</CODE> function to obtain the Finder         information about a file, but not a directory.</P>                  <H3><A NAME="Ch2-160.2"></A><CODE>FSpSetFInfo</CODE> does not work with         directories</H3>                  <P>Page 2-160, <CODE>FSpSetFInfo</CODE></P>                  <P>You can use the <CODE>FSpSetFInfo</CODE> function to set the Finder         information about a file, but not a directory.</P>                  <H3><A NAME="Ch2-165"></A><CODE>FSpExchangeFiles</CODE> and         <CODE>PBExchangeFiles</CODE> - What is exchanged</H3>                  <P>Page 2-165, <CODE>FSpExchangeFiles</CODE><BR>         Page 2-206, <CODE>PBExchangeFiles</CODE></P>                  <P>The <CODE>FSpExchangeFiles</CODE> function swaps the data in two files         by changing the information in the volume's catalog and, if         either of the files are open, in the file control blocks.         Specifically, the following changes are made: </P>                  <P>The following fields in the two files' volume catalog         entries are exchanged (as seen by <CODE>PBGetCatInfo</CODE>): </P>                  <TABLE BORDER=1>            <TR>               <td align="left">                  <P><CODE>ioFlStBlk</CODE></P>               </TD>               <td align="left">                  <P>The first allocation block of the data fork</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>ioFlLgLen</CODE></P>               </TD>               <td align="left">                  <P>The logical end-of-file of the data fork</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>ioFlPyLen</CODE></P>               </TD>               <td align="left">                  <P>The physical end-of-file of the data fork</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>ioFlRStBlk</CODE></P>               </TD>               <td align="left">                  <P>The first allocation block of the resource                  fork</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>ioFlRLgLen</CODE></P>               </TD>               <td align="left">                  <P>The logical end-of-file of the resource fork</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>ioFlRPyLen</CODE></P>               </TD>               <td align="left">                  <P>The physical end-of-file of the resource                  fork</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>ioFlMdDat</CODE></P>               </TD>               <td align="left">                  <P>The date and time of the last modification</P>               </TD>            </TR>         </TABLE>                                   <P>Both the data and resource forks of the two files are         exchanged.</P>                  <P>The following fields in any open file control blocks to         the two files are exchanged: </P>                  <TABLE BORDER=1>            <TR>               <td align="left">                  <P><CODE>fcbFlNum</CODE></P>               </TD>               <td align="left">                  <P>The file ID number</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>fcbDirID</CODE></P>               </TD>               <td align="left">                  <P>The file's parent directory ID</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>fcbCName</CODE></P>               </TD>               <td align="left">                  <P>The file's name</P>               </TD>            </TR>         </TABLE>         <BR>                             <CENTER><TABLE BORDER=0 CELLPADDING=1 WIDTH=500>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <P><B>Note: </B><BR>                  Your application will have to swap any open reference            numbers to the two files because the file's name and            parent directory ID are exchanged in the file control            blocks.</p>               </TD></TR>         </TABLE></center><BR>                       <BR>         <P>Because other programs may have access paths open to one         or both of the files exchanged, your application should have         exclusive read/write access permission (<CODE>fsRdWrPerm</CODE>) to both         files before calling <CODE>FSpExchangeFiles</CODE>. Exclusive read/write         access to both files will ensure that <CODE>FSpExchangeFiles</CODE>         doesn't affect another application because it prevents other         applications from obtaining write access to one or both of         the files exchanged.</P>         <BR>         <CENTER><TABLE BORDER=0 CELLPADDING=1 WIDTH=500>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <P><B>Note: </B><BR>                  <CODE>FSpExchangeFiles</CODE> does not respect the file-locked            attribute; it will perform the exchange even if one or            both of the files are locked. Obtaining exclusive            read/write access to both files before calling            <CODE>FSpExchangeFiles</CODE> ensures that the files are unlocked            because locked files cannot be opened with write            access.</p></TD></TR>         </TABLE></center><BR>         <BR>         <H3><A NAME="Ch2-169"></A><CODE>HOpenDF</CODE>, <CODE>PBHOpenDF</CODE> and         the <CODE>paramErr</CODE> result code</H3>                  <P>Page 2-169, <CODE>HOpenDF</CODE><BR>         Page 2-169, <CODE>PBHOpenDF</CODE></P>                  <P>If the <CODE>HOpenDF</CODE> or <CODE>PBHOpenDF</CODE> function fail with a <CODE>paramErr</CODE>         result code (indicating that the <CODE>HOpenDF</CODE> or <CODE>PBHOpenDF</CODE>         function is not available), you should retry your request         passing the same parameters to <CODE>HOpen</CODE> or <CODE>PBHOpen</CODE>. For         example: </P>                  <TABLE BORDER=0>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <pre>    error = HOpenDF(vRefNum, dirID, fileName, permission, &amp;refNum);    if ( error == paramErr )    {        /* HOpenDF not supported, so try HOpen */        error = HOpen(vRefNum, dirID, fileName, permission, &amp;refNum);    }</pre>               </TD>            </TR>         </TABLE>                  <H3><A NAME="Ch2-183.1"></A>Parameter blocks missing         <CODE>ioFVersNum</CODE> field</H3>                  <P>Page 2-183, <CODE>PBHOpenDF</CODE><BR>         Page 2-184, <CODE>PBHOpenRF</CODE><BR>         Page 2-185, <CODE>PBHOpen</CODE><BR>         Page 2-187, <CODE>PBHCreate</CODE><BR>         Page 2-189, <CODE>PBHDelete</CODE><BR>         Page 2-194, <CODE>PBHGetFInfo</CODE><BR>         Page 2-196, <CODE>PBHSetFInfo</CODE><BR>         Page 2-197, <CODE>PBHSetFLock</CODE><BR>         Page 2-198, <CODE>PBHRstFLock</CODE><BR>         Page 2-199, <CODE>PBHRename</CODE></P>                  <P>The parameter blocks are missing the <CODE>ioFVersNum</CODE> field.         <CODE>ioFVersNum</CODE> should be initialized to zero because these calls         will fall through to the now-obsolete Macintosh File System         (MFS) code if the volume accessed is an MFS volume.</P>                  <H3><A NAME="Ch2-183.2"></A>Parameter blocks missing ioMisc         field</H3>                  <P>Page 2-183, <CODE>PHHOpenDF</CODE><BR>         Page 2-184, <CODE>PHHOpenRF</CODE><BR>         Page 2-185, <CODE>PBHOpen</CODE></P>                  <P>The parameter blocks are missing the <CODE>ioMisc</CODE> field. <CODE>ioMisc</CODE>         must be initialized to zero before calling <CODE>PHHOpenDF</CODE>,         <CODE>PHHOpenRF</CODE>, or <CODE>PBHOpen</CODE>. Failure to initialize <CODE>ioMisc</CODE> to zero         on some Macintosh models will cause the system to crash.</P>                  <H3><A NAME="Ch2-191"></A><CODE>PBGetCatInfo</CODE> <CODE>ioFDirIndex</CODE> usage         rules</H3>                  <P>Page 2-191, <CODE>PBGetCatInfo</CODE></P>                  <P>Change the description of <CODE>PBGetCatInfo</CODE>'s <CODE>ioFDirIndex</CODE>         usage rules to: </P>                  <P>The <CODE>PBGetCatInfo</CODE> function selects a file or directory         according to these rules: </P>                  <UL>            <LI>If the value of <CODE>ioFDirIndex</CODE> is positive, <CODE>ioNamePtr</CODE> is            not used as an input parameter and <CODE>PBGetCatInfo</CODE> returns            information about the file or directory whose directory            index is <CODE>ioFDirIndex</CODE> in the directory specified by            <CODE>ioVRefNum</CODE> and <CODE>ioDirID</CODE> (this will be the root directory if            <CODE>ioVRefNum</CODE> is a volume reference number or a drive number            and <CODE>ioDirID</CODE> is 0). If <CODE>ioNamePtr</CODE> is not NIL, then it must            point to a <CODE>Str31</CODE> buffer where the file or directory name            will be returned.</LI>                        <LI>If the value of <CODE>ioFDirIndex</CODE> is 0, <CODE>PBGetCatInfo</CODE>            returns information about the file or directory specified            by <CODE>ioNamePtr</CODE> in the directory specified by <CODE>ioVRefNum</CODE> and            <CODE>ioDirID</CODE> (again, this will be the root directory if            <CODE>ioVRefNum</CODE> is a volume reference number or a drive number            and <CODE>ioDirID</CODE> is 0).</LI>                        <LI>If the value of <CODE>ioFDirIndex</CODE> is negative, <CODE>ioNamePtr</CODE> is            not used as an input parameter and <CODE>PBGetCatInfo</CODE> returns            information about the directory specified by <CODE>ioVRefNum</CODE>            and <CODE>ioDrDirID</CODE> (again, this will be the root directory if            <CODE>ioVRefNum</CODE> is a volume reference number or a drive number            and <CODE>ioDrDirID</CODE> is 0). If <CODE>ioNamePtr</CODE> is not NIL, then it            must point to a <CODE>Str31</CODE> buffer where the directory name            will be returned.</LI>         </UL>                  <H3><A NAME="Ch2-219"></A>Parameter blocks missing <CODE>ioNamePtr</CODE>         field</H3>                  <P>Page 2-219, <CODE>PBGetVolMountInfoSize</CODE><BR>         Page 2-220, <CODE>PBGetVolMountInfo</CODE><BR>         Page 2-223,<CODE>PBHGetLogInInfo</CODE></P>                  <P>The parameter block is missing the <CODE>ioNamePtr</CODE> field.         <CODE>ioNamePtr</CODE> and <CODE>ioVRefNum</CODE> are both used to specify the         volume.</P>                  <H3><A NAME="Ch2-233"></A><CODE>ioForeignPrivIDirID</CODE> is <CODE>LongInt</CODE> in         <CODE>PBGetForeignPrivs</CODE> and <CODE>PBSetForeignPrivs</CODE></H3>                  <P>Pages 2-233 and 2-234</P>                  <P>The parameter blocks shows <CODE>ioForeignPrivIDirID</CODE> as a         Integer when it is really a <CODE>LongInt</CODE>.</P>                  <H3><A NAME="Ch2-239"></A>Request execution order</H3>                  <P>Page 2-239, new information after <CODE>MyCompletionProc</CODE></P>                  <P>The File Manager, when the File Sharing or AppleShare         file server is active, will execute requests in arbitrary         order. That means that if there is a request that depends on         the completion of a previous request, it is an error for         your program to issue the second request until the         completion of the first request. For example, issuing a         write request and then issuing a read request for the same         data isn't guaranteed to read back what was written unless         the read request isn't made until after the write request         completes.</P>                  <P>Request order can also change if a call results in a disk         switch dialog to bring an offline volume back online.</P>                  <H3><A NAME="Ch2-293"></A>Volume Parameter Variant offsets         are off by 2</H3>                  <P>Page 2-293, Assembly-Language Summary, Data         Structures</P>                  <P>The offsets for the Volume Parameter Variant are off by 2         starting at <CODE>ioVClpSiz</CODE> because <CODE>ioVAlBlkSiz</CODE> is a long, not a         word. So, the offset for <CODE>ioVClpSiz</CODE> should be 52, the offset         for <CODE>ioAlBlSt</CODE> should be 56, etc.</P>                  <H3><A NAME=volumeSignature></A>Detecting if a volume is         formatted Macintosh File System (MFS), Hierarchical File         System (HFS), or HFS Plus</H3>                  <P>Three volume formats have been supported by the Mac OS         file system: MFS, HFS, and HFS Plus. System software 7.0         through Mac OS 8.0 supported the MFS and HFS volume formats.         Mac OS 8.1 and later support HFS and HFS Plus volumes. All         three volume formats use the local File System ID, zero (0).         So how do you tell them apart? By the volume's signature         word returned by <A HREF = "#Ch2-PBXGetVolInfo">PBXGetVolInfo</A>         (or <CODE>PBHGetVInfo</CODE> if <CODE>PBXGetVolInfo</CODE> is not available) in the         <CODE>ioVSigWord</CODE> field. MFS volumes have a signature of <CODE>$D2D7</CODE>; HFS         volumes have a signature of <CODE>$4244</CODE>; HFS Plus volumes have a         signature of <CODE>$482B</CODE>.</P>                  <BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Important:</B><BR>For compatibility with some programs, <CODE>PBGetVInfo</CODE> and            <CODE>PBHGetVInfo</CODE> return <CODE>$4244</CODE> in <CODE>ioVSigWord</CODE> for both HFS and            HFS Plus volumes. You should always use <CODE>PBXGetVolInfo</CODE> if it is available.</p></TD></TR></TABLE></center><BR><BR>                             <P>The following code can be used to get the volume         signature and file system ID: </P>                  <TABLE BORDER=0>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <pre>OSErr GetVSigWord(short vRefNum, short *vSigWord, short *fsid){   OSErr         result;   long          response;   XVolumeParam  pb;   pb.ioVRefNum = vRefNum;   pb.ioXVersion = 0;      // this XVolumeParam version (0)   pb.ioNamePtr = NULL;   pb.ioVolIndex = 0;      // use ioVRefNum only   // Is PBXGetVolInfo available?   if ( ( Gestalt(gestaltFSAttr, &amp;amp;response) == noErr ) &amp;&amp;        ((response &amp; (1L &lt;&lt; gestaltFSSupports2TBVols)) != 0) )   {      // Yes, so use it      result = PBXGetVolInfoSync(&amp;pb);   }   else   {      // No, fall back on PBHGetVInfo      result = PBHGetVInfoSync((HParmBlkPtr)&amp;pb);   }   // return the volume's signature word and FSID   *vSigWord = pb.ioVSigWord;   *fsid = pb.ioVFSID;   // return the File Manager's result   return ( result );}</pre>               </TD>            </TR>         </TABLE>                                   <H3><A NAME="Ch2-PBXGetVolInfo"></A><CODE>PBXGetVolInfo</CODE></H3>                  <P>You can use the <CODE>PBXGetVolInfo</CODE> function to get detailed         information about a volume. It can report volume size         information for volumes up to 2 terabytes.</P>                  <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal OSErr PBXGetVolInfoSync(XVolumeParamPtr paramBlock);pascal OSErr PBXGetVolInfoAsync(XVolumeParamPtr paramBlock);paramBlock    A pointer to an extended volume parameter block.</pre>	</TD></TR></TABLE></center><BR><BR>                                   <TABLE BORDER=1>            <TR>               <TH>                  <P ALIGN=left><CODE>XVolumeParam</CODE></P>               </TH>               <td align="left">                  <P></P>               </TD>               <td align="left">                  <P></P>               </TD>               <td align="left">                  <P></P>               </TD>            </TR>            <TR>               <td align="left">                  <P>-&gt;</P>               </TD>               <td align="left">                  <P><CODE>ioCompletion</CODE></P>               </TD>               <td align="left">                  <P><CODE>ProcPtr</CODE></P>               </TD>               <td align="left">                  <P>Pointer to a completion routine</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>&lt;-</P>               </TD>               <td align="left">                  <P><CODE>ioResult</CODE></P>               </TD>               <td align="left">                  <P><CODE>OSErr</CODE></P>               </TD>               <td align="left">                  <P>Result code of the function</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>&lt;-&gt;</P>               </TD>               <td align="left">                  <P><CODE>ioNamePtr</CODE></P>               </TD>               <td align="left">                  <P><CODE>StringPtr</CODE></P>               </TD>               <td align="left">                  <P>Pointer to the volume's name.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>&lt;-&gt;</P>               </TD>               <td align="left">                  <P><CODE>ioVRefNum</CODE></P>               </TD>               <td align="left">                  <P>short</P>               </TD>               <td align="left">                  <P>On input, a volume specification; on output, the                  volume reference number.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>-&gt;</P>               </TD>               <td align="left">                  <P><CODE>ioXVersion</CODE></P>               </TD>               <td align="left">                  <P>unsigned long</P>               </TD>               <td align="left">                  <P>Version of <CODE>XVolumeParam</CODE><BR>                  (value = 0).</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>-&gt;</P>               </TD>               <td align="left">                  <P><CODE>ioVolIndex</CODE></P>               </TD>               <td align="left">                  <P>short</P>               </TD>               <td align="left">                  <P>Index used for indexing through all mounted                  volumes.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>&lt;-</P>               </TD>               <td align="left">                  <P><CODE>ioVCrDate</CODE></P>               </TD>               <td align="left">                  <P>unsigned long</P>               </TD>               <td align="left">                  <P>Date and time of initialization.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>&lt;-</P>               </TD>               <td align="left">                  <P><CODE>ioVLsMod</CODE></P>               </TD>               <td align="left">                  <P>unsigned long</P>               </TD>               <td align="left">                  <P>Date and time of last modification.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>&lt;-</P>               </TD>               <td align="left">                  <P><CODE>ioVAtrb</CODE></P>               </TD>               <td align="left">                  <P>short</P>               </TD>               <td align="left">                  <P>Volume attributes.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>&lt;-</P>               </TD>               <td align="left">                  <P><CODE>ioVNmFls</CODE></P>               </TD>               <td align="left">                  <P>unsigned short</P>               </TD>               <td align="left">                  <P>Number of files in the root directory.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>&lt;-</P>               </TD>               <td align="left">                  <P><CODE>ioVBitMap</CODE></P>               </TD>               <td align="left">                  <P>unsigned short</P>               </TD>               <td align="left">                  <P>First block of the volume bitmap.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>&lt;-</P>               </TD>               <td align="left">                  <P><CODE>ioVAllocPtr</CODE></P>               </TD>               <td align="left">                  <P>unsigned short</P>               </TD>               <td align="left">                  <P>Block where the next new file starts.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>&lt;-</P>               </TD>               <td align="left">                  <P><CODE>ioVNmAlBlks</CODE></P>               </TD>               <td align="left">                  <P>unsigned short</P>               </TD>               <td align="left">                  <P>Number of allocation blocks.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>&lt;-</P>               </TD>               <td align="left">                  <P><CODE>ioVAlBlkSiz</CODE></P>               </TD>               <td align="left">                  <P>unsigned long</P>               </TD>               <td align="left">                  <P>Size of allocation blocks.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>&lt;-</P>               </TD>               <td align="left">                  <P><CODE>ioVClpSiz</CODE></P>               </TD>               <td align="left">                  <P>unsigned long</P>               </TD>               <td align="left">                  <P>Default clump size.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>&lt;-</P>               </TD>               <td align="left">                  <P><CODE>ioAlBlSt</CODE></P>               </TD>               <td align="left">                  <P>unsigned short</P>               </TD>               <td align="left">                  <P>First block in the volume block map.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>&lt;-</P>               </TD>               <td align="left">                  <P><CODE>ioVNxtCNID</CODE></P>               </TD>               <td align="left">                  <P>unsigned long</P>               </TD>               <td align="left">                  <P>Next unused catalog node ID.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>&lt;-</P>               </TD>               <td align="left">                  <P><CODE>ioVFrBlk</CODE></P>               </TD>               <td align="left">                  <P>unsigned short</P>               </TD>               <td align="left">                  <P>Number of unused allocation blocks.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>&lt;-</P>               </TD>               <td align="left">                  <P><CODE>ioVSigWord</CODE></P>               </TD>               <td align="left">                  <P>unsigned short</P>               </TD>               <td align="left">                  <P>Volume signature.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>&lt;-</P>               </TD>               <td align="left">                  <P><CODE>ioVDrvInfo</CODE></P>               </TD>               <td align="left">                  <P>short</P>               </TD>               <td align="left">                  <P>Drive number.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>&lt;-</P>               </TD>               <td align="left">                  <P><CODE>ioVDRefNum</CODE></P>               </TD>               <td align="left">                  <P>short</P>               </TD>               <td align="left">                  <P>Driver reference number.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>&lt;-</P>               </TD>               <td align="left">                  <P><CODE>ioVFSID</CODE></P>               </TD>               <td align="left">                  <P>short</P>               </TD>               <td align="left">                  <P>File system ID for the file system handling this                  volume.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>&lt;-</P>               </TD>               <td align="left">                  <P><CODE>ioVBkUp</CODE></P>               </TD>               <td align="left">                  <P>unsigned long</P>               </TD>               <td align="left">                  <P>Date and time of last backup.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>&lt;-</P>               </TD>               <td align="left">                  <P><CODE>ioVSeqNum</CODE></P>               </TD>               <td align="left">                  <P>short</P>               </TD>               <td align="left">                  <P>Used internally.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>&lt;-</P>               </TD>               <td align="left">                  <P><CODE>ioVWrCnt</CODE></P>               </TD>               <td align="left">                  <P>unsigned long</P>               </TD>               <td align="left">                  <P>Volume write count.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>&lt;-</P>               </TD>               <td align="left">                  <P><CODE>ioVFilCnt</CODE></P>               </TD>               <td align="left">                  <P>unsigned long</P>               </TD>               <td align="left">                  <P>Number of files on the volume.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>&lt;-</P>               </TD>               <td align="left">                  <P><CODE>ioVDirCnt</CODE></P>               </TD>               <td align="left">                  <P>unsigned long</P>               </TD>               <td align="left">                  <P>Number of directories on the volume.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>&lt;-</P>               </TD>               <td align="left">                  <P><CODE>ioVFndrInfo</CODE></P>               </TD>               <td align="left">                  <P>[8] long</P>               </TD>               <td align="left">                  <P>Used by the Finder.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>&lt;-</P>               </TD>               <td align="left">                  <P><CODE>ioVTotalBytes</CODE></P>               </TD>               <td align="left">                  <P><CODE>UnsignedWide</CODE></P>               </TD>               <td align="left">                  <P>Total number of bytes on the volume.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>&lt;-</P>               </TD>               <td align="left">                  <P><CODE>ioVFreeBytes</CODE></P>               </TD>               <td align="left">                  <P><CODE>UnsignedWide</CODE></P>               </TD>               <td align="left">                  <P>Number of free bytes on the volume.</P>               </TD>            </TR>         </TABLE>                                   <P>The <CODE>PBXGetVolInfo</CODE> function returns information about the         specified volume. It is similar to the <CODE>PBHGetVInfo</CODE> function         described in <CITE>Inside Macintosh: Files</CITE> except that it returns         additional volume space information in 64-bit integers and         does not modify the information copied from the volume's         Volume Control Block (VCB). Systems that support         <CODE>PBXGetVolInfo</CODE> will have the <CODE>gestaltFSSupports2TBVols</CODE> bit set         in the response returned by the <CODE>gestaltFSAttr</CODE> <CODE>Gestalt</CODE>         selector.</P>                  <H4>Assembly-Language Information</H4>                  <P>The trap macro and routine selector for <CODE>PBXGetVolInfo</CODE>         are: </P>                  <TABLE BORDER=1>            <TR>               <TH>                  <P ALIGN=left>Trap macro</P>               </TH>               <TH>                  <P ALIGN=left>Selector</P>               </TH>            </TR>            <TR>               <td align="left">                  <P><CODE>_HFSDispatch</CODE></P>               </TD>               <td align="left">                  <P><CODE>$0012</CODE></P>               </TD>            </TR>         </TABLE>                  <H4>Result Codes</H4>                  <TABLE BORDER=1>            <TR>               <td align="left">                  <P><CODE>noErr</CODE></P>               </TD>               <td align="left">                  <P>0</P>               </TD>               <td align="left">                  <P>Successful completion, no error occurred</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>nsvErr</CODE></P>               </TD>               <td align="left">                  <P>&endash;35</P>               </TD>               <td align="left">                  <P>No such volume</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>paramErr</CODE></P>               </TD>               <td align="left">                  <P>&endash;50</P>               </TD>               <td align="left">                  <P>No default volume</P>               </TD>            </TR>         </TABLE>                  <H3><A NAME="Ch2-PBGetXCatInfo"></A><CODE>PBGetXCatInfo</CODE></H3>                  <P>You can use the <CODE>PBGetXCatInfo</CODE> function to get the short         name (MS-DOS format name) and ProDOS information for files         and directories.</P>                  <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal OSErr PBGetXCatInfoSync(XCInfoPBPtr paramBlock);pascal OSErr PBGetXCatInfoAsync(XCInfoPBPtr paramBlock);paramBlock    Contains a pointer to a XCInfoPBRec.</pre>	</TD></TR></TABLE></center><BR>                                   <TABLE BORDER=1>            <TR>               <TH>                  <P ALIGN=left><CODE>XCInfoPBRec</CODE></P>               </TH>               <td align="left">                  <P></P>               </TD>               <td align="left">                  <P></P>               </TD>               <td align="left">                  <P></P>               </TD>            </TR>            <TR>               <td align="left">                  <P>-&gt;</P>               </TD>               <td align="left">                  <P><CODE>ioCompletion</CODE></P>               </TD>               <td align="left">                  <P><CODE>ProcPtr</CODE></P>               </TD>               <td align="left">                  <P>Contains a pointer to <CODE>PBGetXCatInfoAsync</CODE>'s                  completion routine.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>&lt;-</P>               </TD>               <td align="left">                  <P><CODE>ioResult</CODE></P>               </TD>               <td align="left">                  <P><CODE>OSErr</CODE></P>               </TD>               <td align="left">                  <P><CODE>PBGetXCatInfo</CODE> places its result code into this                  field.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>-&gt;</P>               </TD>               <td align="left">                  <P><CODE>ioNamePtr</CODE></P>               </TD>               <td align="left">                  <P><CODE>StringPtr</CODE></P>               </TD>               <td align="left">                  <P>Contains a pointer to the object name, or nil                  when <CODE>ioDirID</CODE> specifies a directory that's the                  object.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>-&gt;</P>               </TD>               <td align="left">                  <P><CODE>ioVRefNum</CODE></P>               </TD>               <td align="left">                  <P>short</P>               </TD>               <td align="left">                  <P>Contains a volume specification.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>&lt;-&gt;</P>               </TD>               <td align="left">                  <P><CODE>ioShortNamePtr</CODE></P>               </TD>               <td align="left">                  <P><CODE>StringPtr</CODE></P>               </TD>               <td align="left">                  <P>Contains a pointer to a Pascal string buffer                  (minimum 13 bytes). <CODE>PBGetXCatInfo</CODE> places the short                  name into the field referred to by this parameter.                  <CODE>ioShortNamePtr</CODE> cannot be nil.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>&lt;-</P>               </TD>               <td align="left">                  <P><CODE>ioPDType</CODE></P>               </TD>               <td align="left">                  <P>short</P>               </TD>               <td align="left">                  <P><CODE>PBGetXCatInfo</CODE> places the ProDOS file type into                  this field.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>&lt;-</P>               </TD>               <td align="left">                  <P><CODE>ioPDAuxType</CODE></P>               </TD>               <td align="left">                  <P>long</P>               </TD>               <td align="left">                  <P><CODE>PBGetXCatInfo</CODE> places the ProDOS auxiliary type                  into this field.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P>-&gt;</P>               </TD>               <td align="left">                  <P><CODE>ioDirID</CODE></P>               </TD>               <td align="left">                  <P>long</P>               </TD>               <td align="left">                  <P>Contains a directory ID.</P>               </TD>            </TR>         </TABLE>                                   <P><CODE>PBGetXCatInfo</CODE> returns the short name (MS-DOS format name)         and ProDOS file/auxiliary type information for files and         directories on volumes that support this function. Volumes         that support <CODE>PBGetXCatInfo</CODE> will have the <CODE>bHasShortName</CODE> bit         set in the <CODE>vMAttrib</CODE> field returned by <CODE>PBHGetVolParms</CODE>.</P>                  <P>For more information about short names and ProDOS         file/auxiliary types, see <CITE>Inside AppleTalk</CITE>, second edition,         Chapter 13 AppleTalk Filing Protocol, and the Apple II File         Type Notes.</P>                  <H4>Assembly-Language Information</H4>                  <P>The trap macro and routine selector for <CODE>PBXGetVolInfo</CODE>         are: </P>                  <TABLE BORDER=1>            <TR>               <TH>                  <P ALIGN=left>Trap macro</P>               </TH>               <TH>                  <P ALIGN=left>Selector</P>               </TH>            </TR>            <TR>               <td align="left">                  <P><CODE>_HFSDispatch</CODE></P>               </TD>               <td align="left">                  <P><CODE>$003A</CODE></P>               </TD>            </TR>         </TABLE>                  <H4>Result Codes</H4>                  <TABLE BORDER=1>            <TR>               <td align="left">                  <P><CODE>noErr</CODE></P>               </TD>               <td align="left">                  <P>0</P>               </TD>               <td align="left">                  <P>Successful completion, no error occurred</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>nsvErr</CODE></P>               </TD>               <td align="left">                  <P>&endash;35</P>               </TD>               <td align="left">                  <P>No such volume</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>fnfErr</CODE></P>               </TD>               <td align="left">                  <P>&endash;43</P>               </TD>               <td align="left">                  <P>File not found</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>paramErr</CODE></P>               </TD>               <td align="left">                  <P>&endash;50</P>               </TD>               <td align="left">                  <P>No default volume</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>dirNFErr</CODE></P>               </TD>               <td align="left">                  <P>-120</P>               </TD>               <td align="left">                  <P>Directory not found</P>               </TD>            </TR>         </TABLE>                 <P><A HREF="#top">Back to top</A></P><A NAME=Chapter3></A>                  <H2>Chapter 3 - Standard File Package</H2>                                  <H3><A NAME="Ch3-30"></A>Activation Procedures Need to call         <CODE>TECalText</CODE></H3>                  <P>Pages 3-30 to 3-31, Writing an Activation Procedure<BR>         Page 3-59, <CODE>MyActivateProc</CODE></P>                  <P>Pages 3-30 to 3-31 and 3-59 discuss activation of         additional user interface elements in custom standard file         dialogs. The parts of that discussion that refer to having         multiple edit-text items omit mention that it is necessary         for the activation procedure to call <CODE>TECalText</CODE>, set         <CODE>myTEHandle^^.crOnly</CODE> to 1, and call <CODE>TESetSelect</CODE> to work         properly, as in the code snippet below: </P>                  <TABLE BORDER=0>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <pre>IF (activating) THEN    BEGIN        {Note DialogPeek not WindowPeek used}        dlgPeek : = DialogPeek(theDialog);        {Access TEHandle shared in common by all the editText }        { items in the dialog. This field current at activate time.}        myTEHandle: = dlgPeek^.textH;        {Must redo lineStarts on activation}        TECalText(myTEHandle);        {Must set crOnly on activation}        myTEHandle^^.crOnly : = 1;        {Ensure proper setting of selection}        myTECharLength : = myTEHandle^^.teLength;        selectionLen : = myTEHandle^^.selEnd - myTEHandle^^.selStart                        + 1;        If (myTECharLength &gt; selectionLen) THEN        TESetSelect(0,myTECharLength,myTEHandle);    END;</pre>               </TD>            </TR>         </TABLE>                                   <H3><A NAME="Ch3-31"></A>Default Standard File current         directory</H3>                  <P>Page 3-31, Setting the Current Directory</P>                  <P>Replace the two bullet points with the following three         bullet points: </P>                  <UL>            <LI>If the user launched your application directly            (perhaps by double-clicking its icon in the Finder), the            default directory is the directory in which your            application is located.</LI>                        <LI>If the user launched your application indirectly            (perhaps by double-clicking one of your application's            document icons) and your application is high-level event            aware, your application is passed the list of documents            to open or print in a <CODE>kAEOpenDocument</CODE> or <CODE>kAEPrintDocument</CODE>            Apple event; there is no Finder information            (<CODE>AppParmHandle</CODE> will be NIL) and the default directory is            the directory in which your application is located.</LI>                        <LI>If the user launched your application indirectly            (perhaps by double-clicking one of your application's            document icons) and your application is not high-level            event aware, your application is passed Finder            information and the default directory is the directory of            the last document in listed in the Finder information.            The Finder information is the data referenced by            <CODE>AppParmHandle</CODE> and accessed by the Segment Loader routines            <CODE>CountAppFiles</CODE>, <CODE>GetAppFiles</CODE>, <CODE>ClrAppFiles</CODE>, and            <CODE>GetAppParms</CODE>.</LI>         </UL>                  <H3><A NAME="Ch3-33"></A>Listing 3-15 does not set <CODE>sfScript</CODE>         field</H3>                  <P>Page 3-33, Listing 3-15, Setting the current         directory</P>                  <P>The code listing does not set the <CODE>sfScript</CODE> field of the         <CODE>StandardFileReply</CODE> record when returning the pseudo-item         <CODE>sfHookChangeSelection</CODE>. This can cause Standard File to         always set the selection to the last file in the directory.         Adding the line: </P>                  <TABLE BORDER=0>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <pre>myReplyPtr^.sfScript : = smSystemScript;</pre>               </TD>            </TR>         </TABLE>                                   <P>before the line: </P>                  <TABLE BORDER=0>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <pre>MyDlgHook : = sfHookChangeSelection;</pre>               </TD>            </TR>         </TABLE>                                   <P>will fix the problem.</P>                <P><A HREF="#top">Back to top</A></P><A NAME=Chapter4></A>                  <H2>Chapter 4 - Alias Manager</H2>                                  <H3><A NAME="Ch4-19"></A><CODE>ResolveAlias</CODE> updates minimal         aliases</H3>                  <P>Page 4-19</P>                  <P>At the bottom of page 4-19, it is stated that         <CODE>ResolveAlias</CODE> never updates a minimal alias. This is not         true.</P>                  <P><CODE>ResolveAlias</CODE> calls <CODE>MatchAlias</CODE> to resolve the alias and if         <CODE>MatchAlias</CODE> returns with <CODE>needsUpdate</CODE> set to true, then         <CODE>ResolveAlias</CODE> updates the alias by calling <CODE>UpdateAlias</CODE> (which         makes it a full alias) and returns with <CODE>wasChanged</CODE> set to         true. If you require that minimal aliases stay minimal         aliases, you can either call <CODE>MatchAlias</CODE> (which does not         update aliases),or you can create a copy of the alias record         with <CODE>HandToHand</CODE>, pass the copy of the alias record to         <CODE>ResolveAlias</CODE>, and then dispose of the (possibly updated)         copy of the alias record.</P>                  <H3><A NAME="Ch4-20"></A><CODE>usrCanceledErr</CODE> should be         <CODE>userCanceledErr</CODE></H3>                  <P>Page 4-20, <CODE>ResolveAlias</CODE> 4-23, <CODE>MatchAlias</CODE></P>                  <P>Just a typo... the title of this says it all.</P>                  <H3><A NAME="Ch4-23"></A><CODE>kARMSearchMore</CODE> and memory available         to <CODE>AliasFilterProc</CODE> warning</H3>                  <P>Page 4-23, <CODE>MatchAlias</CODE><BR>         Page 4-25, <CODE>MyMatchAliasFilter</CODE></P>                  <P>Add this warning: </P>                  <CENTER><TABLE BORDER=0 CELLPADDING=1 WIDTH=500>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <P><B>WARNING: </B><BR>            <BR>            A call to <CODE>MatchAlias</CODE> using the <CODE>kARMSearchMore</CODE>            rule will result in a recursive search using <CODE>PBGetCatInfo</CODE> if            the volume being searched doesn't support <CODE>PBCatSearch</CODE>.            Your application should insure there is a reasonable            amount of stack space available before calling <CODE>MatchAlias</CODE>            using the <CODE>kARMSearchMore</CODE> rule, and if a <CODE>AliasFilterProc</CODE>            is used, the <CODE>AliasFilterProc</CODE> should not use large amounts            of stack space. You can eliminate most stack usage in            your <CODE>AliasFilterProc</CODE> by passing a structure containing            any large data structures the <CODE>AliasFilterProc</CODE> might need            in the <CODE>yourDataPtr</CODE> parameter to <CODE>MatchAlias</CODE>.</p></TD>         </TR>         </table></center><BR>                  <P><A HREF="#top">Back to top</A></P><A NAME=Chapter5></A>                  <H2>Chapter 5 - Disk Initialization Manager</H2>                                   <H3><A NAME="Ch5-ExtDiskInitPack"></A>Extended Disk         Initialization Package</H3>                  <P>An extended Disk Initialization Package is available with         System Software 7.5, with Macintosh PC Exchange 2.0 or         later, and with the File System Manager. The extended Disk         Initialization Package includes three functions not found in         Chapter 5 of <CITE>Inside Macintosh: Files</CITE>.</P>                  <P>The existing application program interface to the Disk         Initialization Package as described in <CITE>Inside Macintosh:          Files</CITE> will continue to be supported by the enhanced Disk         Initialization Package. Applications which wish to         initialize only Macintosh disks will continue to work and         will require no changes. However, if an application wants to         initialize non-Macintosh disks, it must use the new extended         <CODE>DIXFormat</CODE> and <CODE>DIXZero</CODE> calls.</P>                  <H3><A NAME="Ch5-ExtDiskInitUI"></A>The Extended Disk         Initialization User Interface</H3>                  <P>The Finder and the Standard File Package both handle         disk-inserted events for uninitialized disks by presenting a         disk initialization dialog box asking the user whether the         disk should be ejected or initialized. Your application too         can easily call a Disk Initialization Manager routine that         generates such a dialog box when the user inserts an invalid         disk. Figure 5-1 illustrates the dialog box: </P>                                    <CENTER><P><img src="images/tn1041_001.gif" alt="" width=371 height=183 align=bottom><BR><B>Figure 5-1</B>. The disk initialization dialog box</P></center><BR>                                   <P>The disk initialization dialog box allows the user to         name and specify the format of the new disk. The appearance         of the disk initialization dialog box changes to reflect         changing conditions. For example, the icon changes to show         which drive contains the disk. The Format menu items change         to show what disk formats can be used with the disk and disk         drive combination. Also, the text of the dialog box changes         according to what is wrong with the disk. The text might         read "This disk's format cannot be read by this drive" if         the Disk Initialization Manager detects that the disk drive         cannot use a disk's format (for example, if a double-sided         disk is inserted in a single-sided disk drive, or a         high-density disk formatted using GCR instead of MFM is         inserted in an Apple SuperDrive).</P>                  <P>Regardless of the initial appearance of the disk         initialization dialog box, it disappears if the user clicks         Eject or Cancel. If, however, the user decides to initialize         the disk, the text in the dialog box changes to warn the         user that initialization erases any previous data on the         disk, as illustrated in Figure 5-2.</P>                  <center><P><img src="images/tn1041_002.gif" alt="" width=298 height=104 align=bottom><BR><B>Figure 5-2</B>. The disk initialization warning</P></center><BR>                                   <P>If the user selects continue, the Disk Initialization         Manager attempts to initialize it. If an error occurs and         the initialization fails, an alert box notifies the user,         and the disk is ejected.</P>                  <P>The extended Disk Initialization Manager also provides a         mechanism for using the standard interface to reinitialize         (reformat) disks that are already formatted. (This mechanism         is useful, for example, when the user wants to reinitialize         a disk with a different disk format.) The Finder takes         advantage of this mechanism with its Erase Disk command,         illustrated in Figure 5-3. After the user selects the erase         operation from this dialog box, the reinitialization begins         immediately, without further warnings. If desired, your         application can use this same standard interface to allow         users to reinitialize mounted disks (other than the startup         volume). Your application can customize the text to be         displayed in such a dialog box. Note that only a few utility         applications actually need to provide users with this         capability.</P>                                    <center><P><img src="images/tn1041_003.gif" alt="" width=371 height=183 align=bottom><BR><B>Figure 5-3</B>. The Reformat dialog box</P></center><BR>                                   <P>If you are writing a utility program such as a         disk-copying application, you might wish to initialize new         disks or reinitialize valid disks without displaying the         standard disk initialization dialog box. For example, your         application might allow users to initialize multiple disks         without having to respond to the standard dialog box each         time. The Disk Initialization Manager provides low-level         routines that allow you to do so. Unless you are writing a         utility program of this type, you don't need to use these         routines.</P>                  <H3><A NAME="Ch5-ExtDiskInitRoutines"></A>Extended Low-Level         Disk Initialization Routines</H3>                  <P>Extended programmatic interfaces to media formatting and         volume initialization functions are required such that         applications may specify additional information for the         overall formatting operation. This information corresponds         to the file system type and disk size information presented         in the "Format" menu in the disk initialization dialog box         described above. The extended programmatic interface adds         three new functions to the Disk Initialization Package:          <CODE>DIXFormat</CODE> and <CODE>DIXZero</CODE> (for extended <CODE>DIFormat</CODE> and <CODE>DIZero</CODE>), and <CODE>DIReformat</CODE>.</P>                  <CENTER><TABLE BORDER=0 CELLPADDING=1 WIDTH=500>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <P><B>WARNING: </B><BR>                        <BR>Applications should insure that the extended Disk            Initialization Package functions are present before            making the <CODE>DIXFormat</CODE>, <CODE>DIXZero</CODE>, or <CODE>DIReformat</CODE> calls. This            is done by calling <CODE>Gestalt</CODE> with the <CODE>gestaltFSAttr</CODE>            selector. The extended Disk Initialization Package            functions is available if the <CODE>Gestalt</CODE> function returns a            result of <CODE>noErr</CODE> and the <CODE>gestaltHasExtendedDiskInitbit</CODE>            (bit 6) is set in the response parameter. Due to the            nature of older versions of the Disk Initialization            Package, making the extended requests when they are not            available may cause a system crash.</p></TD>         </TR>         </table></center><BR>         <BR>                  <P>The following code illustrates how you use <CODE>Gestalt</CODE> to         determine if the extended Disk Initialization Package         functions are available.</P>                  <TABLE BORDER=0>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <pre>Boolean  HasExtendedDIFunctions(void){   long response;   if (Gestalt(gestaltFSAttr, &amp;response) == noErr)      return ((response &amp; (1L &lt;&lt; gestaltHasExtendedDiskInit)) != 0);   else      return (false);}</pre>               </TD>            </TR>         </TABLE>                                   <H3><A NAME="Ch5-DIXFormat"></A><CODE>DIXFormat</CODE></H3>                  <P>The <CODE>DIXFormat</CODE> function performs the same function as the         <CODE>DIFormat</CODE> function except that drive size may be         specified.</P>                  <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal OSErr DIXFormat(short drvNum, Boolean fmtFlag,<BR>                       unsigned long fmtArg, unsigned long *actSize);         </pre>	</TD></TR></TABLE></center><BR>                  <TABLE BORDER=1>            <TR>               <td align="left">                  <P><CODE>drvNum</CODE></P>               </TD>               <td align="left">                  <P>Contains the driver number of the drive to                  format.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>fmtFlag</CODE></P>               </TD>               <td align="left">                  <P>Contains a boolean value which specifies the                  meaning of the <CODE>fmtArg</CODE> parameter.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>fmtArg</CODE></P>               </TD>               <td align="left">                  <P>If <CODE>fmtFlag</CODE> is true, <CODE>fmtArg</CODE> specifies the actual                  value to be passed to the disk driver in the                  <CODE>csParam</CODE> field of the parameter block when the                  "format" <CODE>_Control</CODE> call is made to initialize the                  disk media. (The value is an index into the size                  list. For an explanation of appropriate values for                  this parameter, see the Technical Note "What Your                  Sony Drives For You".)</P>                                    <P>If <CODE>fmtFlag</CODE> is false, <CODE>fmtArg</CODE> specifies                  the desired size of the media in number of 512-byte                  blocks. The disk driver is called to get possible                  sizes and the values in an to attempt to match the                  requested size. If more than one size list entry                  exists for the same size, the first entry in the                  list returned by the driver that best matches the                  <CODE>fmtArg</CODE> parameter will be used. For more information                  about the size list, see the Technical Note "What                  Your Sony Drives For You". If the specified size is                  larger than the largest size in the size list                  returned by the driver, then the largest size will                  be used and that size is returned in <CODE>actSize</CODE>. If                  the specified size is smaller than the smallest                  size in the size list returned by the driver, then                  the smallest size will be used and that size is                  returned in <CODE>actSize</CODE>. For a specified value that is                  in between and without an exact match, the value                  closest to and smaller than the requested size is                  used.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>actSize</CODE></P>               </TD>               <td align="left">                  <P>Contains a pointer to an unsigned long. Upon                  completion of a successful formatting operation,                  <CODE>DIXFormat</CODE> places the actual size of the formatted                  media in number of 512-byte blocks into the field                  referred to by this parameter.</P>               </TD>            </TR>         </TABLE>                                   <P>The formatting of file systems requiring specific media         formats should be done by specifying those media formats         explicitly and not by counting on disk size alone. Foreign         file systems with specific media requirements should use the         driver specific information in the size list or should make         appropriate driver <CODE>_Status</CODE> calls for additional information         when called upon to "evaluate the size list".</P>                  <P>As in <CODE>DIFormat</CODE>, <CODE>DIXFormat</CODE> does not unmount the         volume. You have to unmount the volume before issuing this call if         necessary. If the volume has not been unmounted, then         <CODE>DIXFormat</CODE> will return <CODE>volOnLinErr</CODE> error.</P>                  <H4>Result Codes</H4>                  <TABLE BORDER=1>            <TR>               <td align="left">                  <P><CODE>noErr</CODE></P>               </TD>               <td align="left">                  <P>0</P>               </TD>               <td align="left">                  <P>No error</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>volOnLinErr</CODE></P>               </TD>               <td align="left">                  <P>&endash;55</P>               </TD>               <td align="left">                  <P>Volume is online</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>lastDskErr...firstDskErr</CODE></P>               </TD>               <td align="left">                  <P>&endash;64...-84</P>               </TD>               <td align="left">                  <P>Range of low-level disk errors</P>               </TD>            </TR>         </TABLE>                  <H3><A NAME="Ch5-DIXZero"></A><CODE>DIXZero</CODE></H3>                  <P>The <CODE>DIXZero</CODE> function performs the same function as the         <CODE>DIZero</CODE> function except that the file system, format result,         volume type, volume size and extended formatting information         may be specified.</P>                  <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal OSErr DIXZero(short drvNum, ConstStr255Param volName,                     short fsid, short mediaStatus,                     short volTypeSelector, unsigned long volSize,                     void *extendedInfoPtr);</pre>	</TD></TR></TABLE></center><BR>                  <TABLE BORDER=1>            <TR>               <td align="left">                  <P><CODE>drvNum</CODE></P>               </TD>               <td align="left">                  <P>Contains the driver number of the drive to                  initialize.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>volName</CODE></P>               </TD>               <td align="left">                  <P>Contains a pointer to a Pascal string which                  specifies the name of the volume.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>fsid</CODE></P>               </TD>               <td align="left">                  <P>Contains the ID of the file system whose format                  should be written to the disk. The file system ID                  can be obtained using the File System Manager                  <CODE>GetFSInfo</CODE> function.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>mediaStatus</CODE></P>               </TD>               <td align="left">                  <P>Contains a flag to indicate the status of the                  disk media. Its value is the result code returned                  from the <CODE>DIVerify</CODE> function. If <CODE>mediaStatus</CODE> is                  non-zero, then the disk contains bad sectors and                  needs to be spared. If the file system specified                  doesn't support bad block sparing, the Disk                  Initialization Package will just return this value                  as the function result. If the file system supports                  bad block sparing, then the Disk Initialization                  Package will gather the defect list and pass it to                  the file system.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>volTypeSelector</CODE></P>               </TD>               <td align="left">                  <P>Contains the volume type selector if the foreign                  file system supports more than one volume type.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>volSize</CODE></P>               </TD>               <td align="left">                  <P>Contains the size in 512-byte blocks of the                  drive specified by <CODE>drvNum</CODE>. This is the size                  returned in the <CODE>actSize</CODE> field by <CODE>DIXFormat</CODE>--the                  amount of space usable by a file system on the                  specified drive as it is currently formatted. If                  the specified size doesn't match with the current                  disk format size, <CODE>DIXZero</CODE> will return                  <CODE>diCIVolSizeMismatchErr</CODE>.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>fsParams</CODE></P>               </TD>               <td align="left">                  <P>Contains a pointer to the foreign file system's                  extended formatting information, or nil.</P>               </TD>            </TR>         </TABLE>                                   <CENTER><TABLE BORDER=0 CELLPADDING=1 WIDTH=500>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <P><B>WARNING: </B><BR>                        <BR>Early versions of the <CODE>DIXZero</CODE> code calls the Dialog            Manager with a nil <CODE>DialogPtr</CODE> when the value passed in the            <CODE>mediaStatus</CODE> parameter is not noErr. This will almost            always cause a system crash.                        You must check to ensure <CODE>DIXZero</CODE> supports bad block            sparing before passing anything except <CODE>noErr</CODE> as the            <CODE>mediaStatus</CODE> parameter. The following function,            <CODE>DIXZeroSupportsBadBlocks</CODE>, shows how to make sure <CODE>DIXZero</CODE>            supports bad block sparing.</p></TD>         </TR>         </table></center><BR>                  <TABLE BORDER=0>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <pre>Boolean  DIXZeroSupportsBadBlocks(void){   enum   {      gestaltBugFixAttrsThree = 'bugx',      gestaltDIXZeroSupportsBadBlocks = 9   };   long response;   if (Gestalt(gestaltBugFixAttrsThree , &amp;response) == noErr)      return ((response &amp; (1L &lt;&lt; gestaltDIXZeroSupportsBadBlocks))              != 0);   else      return (false);}</pre>               </TD>            </TR>         </TABLE>                                   <P>As in <CODE>DIZero</CODE>, <CODE>DIXZero</CODE> does not unmount the volume but it         will, however, mount the volume if the operation is         successful. You have to unmount the volume before issuing         this call if necessary. If the volume is mounted when <CODE>DIZero</CODE>         or <CODE>DIXZero</CODE> is called, then a <CODE>volOnLinErr</CODE> error will be         returned.</P>                  <H4>Result Codes</H4>                  <TABLE BORDER=1>            <TR>               <td align="left">                  <P><CODE>noErr</CODE></P>               </TD>               <td align="left">                  <P>0</P>               </TD>               <td align="left">                  <P>No error</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>diCIVolSizeMismatchErr</CODE></P>               </TD>               <td align="left">                  <P>24</P>               </TD>               <td align="left">                  <P>Specified volume size doesn't match with                  formatted disk size</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>ioErr</CODE></P>               </TD>               <td align="left">                  <P>&endash;36</P>               </TD>               <td align="left">                  <P>I/O error</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>paramErr</CODE></P>               </TD>               <td align="left">                  <P>-50</P>               </TD>               <td align="left">                  <P>Drive number specified is bad</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>volOnLinErr</CODE></P>               </TD>               <td align="left">                  <P>-55</P>               </TD>               <td align="left">                  <P>Volume is already online</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>nsDrvErr</CODE></P>               </TD>               <td align="left">                  <P>-56</P>               </TD>               <td align="left">                  <P>No such drive</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>firstDskErr...lastDskErr</CODE></P>               </TD>               <td align="left">                  <P>-84...-64</P>               </TD>               <td align="left">                  <P>Range of low-level disk errors</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>memFullErr</CODE></P>               </TD>               <td align="left">                  <P>-108</P>               </TD>               <td align="left">                  <P>Not enough memory</P>               </TD>            </TR>         </TABLE>                                   <H3><A NAME="Ch5-DIReformat"></A><CODE>DIReformat</CODE></H3>                  <P>The <CODE>DIReformat</CODE> function reformats disk volume.</P>                  <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal OSErr DIReformat(short drvNum, short fsid,                        ConstStr255Param volName,                        ConstStr255Param msgText);</pre>	</TD></TR></TABLE></center><BR>                  <TABLE BORDER=1>            <TR>               <td align="left">                  <P><CODE>drvNum</CODE></P>               </TD>               <td align="left">                  <P>Contains the driver number of the drive to                  format.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>fsid</CODE></P>               </TD>               <td align="left">                  <P>Contains the ID of the file system whose format                  should be written to the disk. The file system ID                  can be obtained using the File System Manager                  <CODE>GetFSInfo</CODE> function. (Use <CODE>$0000</CODE> for the                  Macintosh HFS volume format.)</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>volName</CODE></P>               </TD>               <td align="left">                  <P>Contains a pointer to a Pascal string which                  specifies the name of the volume.</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>msgText</CODE></P>               </TD>               <td align="left">                  <P>Contains a pointer to a Pascal string which                  specifies the explanatory text to be displayed in                  the disk initialization dialog box.</P>               </TD>            </TR>         </TABLE>                                   <P>In the past, reformatting disk was accomplished by         calling the <CODE>DIBadMount</CODE> function with the high word of the         <CODE>evtMessage</CODE> parameter set to <CODE>noErr</CODE> and the explanatory text         was set with the <CODE>ParamText</CODE> function. The <CODE>DIReformat</CODE> function         provides the caller the ability to provide the explanatory         text, the default file system ID, and the default name for         the reformatted disk.</P>         <BR>        <CENTER><TABLE BORDER=0 CELLPADDING=1 WIDTH=500>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <P><B>Note: </B><BR>                  The volume in the drive specified by <CODE>drvNum</CODE> must be            mounted when calling <CODE>DIReformat</CODE>.</p></TD>         </TR>         </table></center><BR>         <BR>                  <H4>Result Codes</H4>                  <TABLE BORDER=1>            <TR>               <td align="left">                  <P><CODE>noErr</CODE></P>               </TD>               <td align="left">                  <P>0</P>               </TD>               <td align="left">                  <P>No error</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>diCINoMessageTextErr</CODE></P>               </TD>               <td align="left">                  <P>28</P>               </TD>               <td align="left">                  <P><CODE>msgText</CODE> was not provided</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>ioErr</CODE></P>               </TD>               <td align="left">                  <P>&endash;36</P>               </TD>               <td align="left">                  <P>I/O error</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>paramErr</CODE></P>               </TD>               <td align="left">                  <P>-50</P>               </TD>               <td align="left">                  <P>Drive number specified is bad</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>nsDrvErr</CODE></P>               </TD>               <td align="left">                  <P>-56</P>               </TD>               <td align="left">                  <P>No such drive</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>firstDskErr...lastDskErr</CODE></P>               </TD>               <td align="left">                  <P>-84...-64</P>               </TD>               <td align="left">                  <P>Range of low-level disk errors</P>               </TD>            </TR>            <TR>               <td align="left">                  <P><CODE>memFullErr</CODE></P>               </TD>               <td align="left">                  <P>-108</P>               </TD>               <td align="left">                  <P>Not enough memory</P>               </TD>            </TR>         </TABLE>                                   <H3><A NAME=Formatting></A>Formatting HFS and HFS Plus         Volumes</H3>                  <P>The Disk Initialization Package provides several ways a         program can initialize a disk drive for use by a file         system. If the drive is not a mounted file system volume, a         program can call <CODE>DIBadMount</CODE> and let the Disk Initialization         Package provide the user interface with the disk         initialization dialog box (see <A HREF = "#Ch5-ExtDiskInitUI">The         Extended Disk Initialization User Interface</A>). If the         drive is already formatted and mounted by the file system, a         program can call <A HREF = "#Ch5-DIReformat"><CODE>DIReformat</CODE></A>         and let the Disk Initialization Package provide the user         interface with the Reformat dialog box. If a program wants         to initialize or reinitialize a volume's data structures         with no user interface, if can use either <CODE>DIZero</CODE> or         <A HREF = "#Ch5-DIXZero">DIXZero</A>. <CODE>DIZero</CODE> always formats         the disk as an HFS volume. If you want to initialize a disk         as an HFS Plus volume, or initialize a disk for use by a         foreign file system, you must use <CODE>DIXZero</CODE>. The rest of topic         describes how to initialize a disk as an HFS or HFS Plus         volume using <CODE>DIXZero</CODE>.</P>                  <P>The <CODE>fsid</CODE> parameter tells <CODE>DIXZero</CODE> which file         system to use         to initialize a volume. For both HFS and HFS Plus volumes,         pass <CODE>$0000</CODE> (the file system ID of the local file system) as         the <CODE>fsid</CODE> parameter.</P>                  <P>The <CODE>volTypeSelector</CODE> parameter is used to select between         different volume types supported by a single file system.         Pass 1 as the <CODE>volTypeSelector</CODE> parameter to create an HFS         volume; pass 2 as the <CODE>volTypeSelector</CODE> parameter to create an         HFS Plus volume.</P>                  <P>The <CODE>extendedInfoPtr</CODE> parameter is a pointer to an optional         structure that adjusts how the volume is formatted. When         formatting an HFS volume, this should point to a structure         of type <CODE>HFSDefaults</CODE>; for an HFS Plus volume, this should         point to a structure of type <CODE>HFSPlusDefaults</CODE>. Passing NIL as         the <CODE>extendedInfoPtr</CODE> parameter will cause the file system's         default values to be used.</P>                  <H4><CODE>HFSDefaults</CODE></H4>                  <TABLE BORDER=0>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <pre>struct HFSDefaults {  char   sigWord[2];  /* signature word */  long   abSize;      /* allocation block size in bytes */  long   clpSize;     /* clump size in bytes */  long   nxFreeFN;    /* next free file number */  long   btClpSize;   /* B-Tree clump size in bytes */  short  rsrv1;       /* reserved */  short  rsrv2;       /* reserved */  short  rsrv3;       /* reserved */};typedef struct HFSDefaults HFSDefaults;</pre>               </TD>            </TR>         </TABLE>                                   <P>The <CODE>HFSDefaults</CODE> structure allows you to change several of         the parameters used when formatting an HFS volume. For each         of the fields, a value of zero or an invalid value indicates         that the default value should be used.</P>                  <P>Set <CODE>sigWord</CODE> to the bytes <CODE>$4244</CODE> ('BD').</P>                  <P>The <CODE>abSize</CODE> field sets the volume's allocation block size.         This value must be a multiple of 512 bytes. The default and         minimum value is the smallest multiple of 512 bytes greater         than or equal to the volume size (in bytes) divided by 65535         (<CODE>$FFFF</CODE>).</P>                  <P>The <CODE>clpSize</CODE> field sets the volume's default clump size.         This value is used when allocating space to extend a file;         the allocated space is rounded up to a multiple of the clump         size if sufficient free space is available. The clump size         should be a multiple of the allocation block size. The         default value is 4 times the allocation block size if the         allocation block size is 256K or less, or equal to the         allocation block size for larger allocation blocks.</P>                  <P>The <CODE>nxFreeFN</CODE> field sets the <CODE>drNxtCNID</CODE> field of the MDB.         It is the starting value for catalog node IDs allocated to         files and folders on that volume. This value is actually an         unsigned 32-bit integer. The default and minimum value is         <CODE>fsUsrCNID</CODE> (16), the minimum valid catalog node ID for user         files and folders.</P>                  <P>The <CODE>btClpSize</CODE> field sets both the clump size and initial         space allocated to the catalog and extents B-trees. This         clump size should be a multiple of the allocation block         size. The default value varies by volume size, but is         typically 1/128 of the volume size.</P>                  <H4><CODE>HFSPlusDefaults</CODE></H4>                  <TABLE BORDER=0>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <pre>enum {  kHFSPlusDefaultsVersion = 1};struct HFSPlusDefaults {  UInt16  version;             /* version of this structure */  UInt16  flags;               /* currently undefined; pass zero */  UInt32  blockSize;           /* allocation block size in bytes */  UInt32  rsrcClumpSize;       /* clump size for resource forks */  UInt32  dataClumpSize;       /* clump size for data forks */  UInt32  nextFreeFileID;      /* next free file number */  UInt32  catalogClumpSize;    /* clump size for catalog B-tree */  UInt32  catalogNodeSize;     /* node size for catalog B-tree */  UInt32  extentsClumpSize;    /* clump size for extents B-tree */  UInt32  extentsNodeSize;     /* node size for extents B-tree */  UInt32  attributesClumpSize; /* clump size for attributes B-tree */  UInt32  attributesNodeSize;  /* node size for attributes B-tree */  UInt32  allocationClumpSize; /* clump size for allocation bitmap                                  file */};typedef struct HFSPlusDefaults HFSPlusDefaults;</pre>               </TD>            </TR>         </TABLE>                                   <P>The <CODE>HFSPlusDefaults</CODE> structure allows you to change         several of the parameters used when formatting a Sequoia         volume. For each of the fields, a value of zero or an         invalid value indicates that the default value should be         used.</P>                  <P>The version field indicates the version of the         <CODE>HFSPlusDefaults</CODE> structure you are passing. The current         version is <CODE>kHFSPlusDefaultsVersion</CODE>. If the value passed is         larger than that recognized by the current implementation,         <CODE>paramErr</CODE> will be returned. Implementations will typically         support older versions of <CODE>HFSPlusDefaults</CODE>.</P>                  <P>The flags field is currently reserved. If you pass a         value other than zero, <CODE>paramErr</CODE> will be returned.</P>                  <P>The <CODE>blockSize</CODE> field sets the volume's allocation block         size. Valid values are powers of two, and at least 512. The         default value varies with the volumes size &endash; 512         bytes for volumes 256 MB or smaller, up to 4KB for volumes         over 1 GB. If the volume's device supports the <CODE>GetMediaInfo</CODE>         control call, then the default size will be greater than or         equal to the device's block size.</P>         <BR>       <CENTER><TABLE BORDER=0 CELLPADDING=1 WIDTH=500>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <P><B>Note: </B><BR>                  Future versions of the HFS Plus file system will be            performance-optimized for 4KB allocation blocks, so the            default should be used unless there's a really good            reason to override it.</p></TD></TR>         </TABLE></center><BR>         <BR>         <P>The <CODE>rsrcClumpSize</CODE> and <CODE>dataClumpSize</CODE> fields set         the default values for clump sizes for resource and data forks,         respectively. The value must be a multiple of the allocation         block size. For both, the default value is four times the         allocation block size.</P>                  <P>The <CODE>nextFreeFileID</CODE> field sets the first catalog node ID         to be assigned to newly created files and folders. The         default and minimum value is <CODE>fsUsrCNID</CODE> (16), the minimum         valid catalog node ID for user files and folders.</P>                  <P>The <CODE>catalogClumpSize</CODE> and <CODE>extentsClumpSize</CODE> fields set the         clump size and initially allocated space for the catalog and         extents B-trees, respectively. For both, the default value         varies by volume size, but is typically 1/128 of the volume         size.</P>                  <P>The <CODE>catalogNodeSize</CODE> and <CODE>extentsNodeSize</CODE> fields set the         size of the B-tree nodes for the catalog and extents         B-trees, respectively. Valid values are powers of two, up to         and including 32,768 (32 K). The minimum and default size for         <CODE>catalogNodeSize</CODE> is 4 KB. The minimum size for         <CODE>extentsNodeSize</CODE> is 512; the default is 1024.</P>                  <H4>Some Sample Code</H4>                  <P>This sample shows how to use <CODE>DIReformat</CODE> to reinitialize a         disk using the standard interface. When <CODE>DIReformat</CODE> is         available, this code can be used instead of the code shown         in Listing 5-2 on page 5-11 of <CITE>Inside Macintosh: Files</CITE>.</P>                  <TABLE BORDER=0>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <pre>// Reinitializing a valid disk using the standard interfaceOSErr ReformatDisk(short drvNum, ConstStr255Param msgText){  OSErr  result;  Str255  volName;  short  vRefNum;  long  freeBytes;  DILoad();  // Get the current volume name  result = GetVInfo(drvNum, volName, &amp;vRefNum, &amp;freeBytes);  if ( result == noErr )  {    // Reformat using FSID $0000 (HFS or HFS Plus)    result = DIReformat(drvNum, 0x0000, volName, msgText);  }  DIUnload();  return ( result );}</pre>               </TD>            </TR>         </TABLE>                                   <P>This sample shows how to use <CODE>DIXZero</CODE> to reinitialize a         disk without using the standard interface. It uses <CODE>DIXZero</CODE>         so that the volume can be initialized with HFS Plus if possible.</P>                  <TABLE BORDER=0>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <pre>// Reinitializing a valid disk without using the standard interfaceOSErr ReinitializeDisk(short drvNum, Boolean tryHFSPlus){  OSErr  result;  Str255  volName;  short  vRefNum;  long  freeBytes;  short  mediaStatus;  UInt32  actSize;  DILoad();  // Get the current volume name  result = GetVInfo(drvNum, volName, &amp;vRefNum, &amp;freeBytes);  if ( result == noErr )  {    // Unmount the volume    result = UnmountVol(NULL, vRefNum);    if ( result == noErr )    {      // Format the disk. (note: the actual disk size      result = DIXFormat(drvNum, false, 0, &amp;actSize);      if ( result == noErr )      {        // Verify the disk and use the result as the mediaStatus        mediaStatus = (short)DIVerify(drvNum);        // Should we try formatting HFS Plus?        if ( tryHFSPlus )        {          // Yes, initialize using HFS Plus          // (fsid = 0; volTypeSelector = 2)          // The extendedInfoPtr is NULL so the default volume          // characteristics are used.         result = DIXZero(drvNum, volName, 0x0000, mediaStatus, 2,                   actSize, NULL);        }        // If HFS Plus wasn't requested or the attempt with HFS Plus        // failed because the disk was too small (paramErr)        if ( !tryHFSPlus || (result == paramErr) )        {          // Initialize using HFS (fsid = 0; volTypeSelector = 1)          // The extendedInfoPtr is NULL so the default volume          // characteristics are used.          result = DIXZero(drvNum, volName, 0x0000, mediaStatus, 1,                   actSize, NULL);        }      }    }  }  DIUnload();  return ( result );}</pre>               </TD>            </TR>         </TABLE>                                   <P>This sample shows how to use <CODE>DIXZero</CODE> to initialize a disk         without using the standard interface. It uses <CODE>DIXZero</CODE> so         that the volume can be initialized with HFS Plus if possible.</P>                  <TABLE BORDER=0>            <TR>               <td bgcolor="#E6E6E6" align=left>                  <pre>// Initializing an uninitialized disk without using the// standard interfaceOSErr InitializeDisk(short drvNum, ConstStr255Param volName,                     Boolean tryHFSPlus){  OSErr  result;  short  mediaStatus;  UInt32  actSize;  DILoad();  // Format the disk  result = DIXFormat(drvNum, false, 0, &amp;actSize);  if ( result == noErr )  {    // Verify the disk and use the result as the mediaStatus    mediaStatus = (short)DIVerify(drvNum);    // Should we try formatting HFS Plus?    if ( tryHFSPlus )    {      // Yes, initialize using HFS Plus      // (fsid = 0; volTypeSelector = 2)      // The extendedInfoPtr is NULL so the default volume      // characteristics are used.      result = DIXZero(drvNum, volName, 0x0000, mediaStatus, 2,               actSize, NULL);    }    // If HFS Plus wasn't requested or the attempt with HFS Plus    // failed because the disk was too small (paramErr)    if ( !tryHFSPlus || (result == paramErr) )    {      // Initialize using HFS (fsid = 0; volTypeSelector = 1)      // The extendedInfoPtr is NULL so the default volume      // characteristics are used.      result = DIXZero(drvNum, volName, 0x0000, mediaStatus, 1,               actSize, NULL);    }  }  DIUnload();  return ( result );}</pre>               </TD>            </TR>         </TABLE>        <P><A HREF="#top">Back to top</A></P><A NAME=References></A><H2>References</h2><P><a href="../../documentation/Carbon/Files/FileManager/filemanager.html">File Manager Reference</A></p>                        <p>Guide to the File System Manager</p>      <P><A HREF="#top">Back to top</A></P>          <A NAME=Downloads></A>                  <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (220K).</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/tn1041.pdf">Download</A></P>               </TD>            </TR>         </TABLE>         <BR><BR><P><A HREF="#top">Back to top</A></P><H3>Change History</H3><H4>Overview</H4><UL>   <LI>Originally written in February 1995, as Technote 1041 --   Inside Macintosh: Files Errata.<BR>   <BR>   </LI>      <LI>In June 1995, this Technote was updated to   document more known errors and omissions.<BR>   <BR>   </LI>      <LI>In February 1996, this Technote was updated to document more known errors and omissions.<BR>   <BR>   </LI>      <LI>In February 1999, this Technote was reformated and updated to include additional HFS Plus information.<BR>   </LI></UL><H4>Specific</H4>Chapter 1 - Introduction to File Management<ul><li><CODE>FSpExchangeFiles</CODE> and <CODE>PBExchangeFiles</CODE>-- What is exchanged, February 1995</li><li>Additional Considerations for <CODE>GetVInfo</CODE>, February 1995</li></ul>Chapter 2 - File Manager<ul><li>Pathname rules are not fully explained, February 1995</li><li>Missing Row in Table 2-10, February 1995</li><li>Description of default directory upon launch wrong, February 1996</li><li>Master Directory Blocks <CODE>drXTFlSize</CODE> and <CODE>drCTFlSize</CODE> field descriptions are wrong, February 1995</li><li>Map records in map nodes occupy 492 bytes (not 494 bytes), February 1995</li><li>Volume cache control bit in <CODE>vcbAtrb</CODE>, June 1995</li><li>Volume Control Blocks <CODE>vcbXTAlBks</CODE> and <CODE>vcbCTAlBks</CODE> field descriptions are wrong, <CODE>dQDrvSiz</CODE> fields not used on 3.5" floppy disks, June 1995</li><LI>February 1996</li><li>Clarification of <CODE>ioFlAttrib</CODE> bits in <CODE>ParamBlockRec</CODE>, <CODE>HParamBlockRec</CODE>, and <CODE>CInfoPBRec</CODE>, June 1995</li><li><CODE>ioACUser</CODE> is <CODE>filler2</CODE> in some interface files, June 1995</li><li>The <CODE>VolMountInfoHeader</CODE> data structure includes flags word, February 1995</li><li><CODE>ioPosMode</CODE> usage by <CODE>PBRead</CODE> and <CODE>PBWrite</CODE> requests, June 1995</li><li>Additional Considerations for <CODE>GetVInfo</CODE>, February 1995</li><li>Additional Special Considerations for <CODE>PBHGetVInfo</CODE>, February 1995</li><li><CODE>FSpGetFInfo</CODE> does not work with directories, February 1995</li><li><CODE>FSpSetFInfo</CODE> does not work with directories, February 1995</li><li><CODE>HOpenDF</CODE>, <CODE>PBHOpenDF</CODE> and the <CODE>paramErr</CODE> result code, February 1995</li><li>Parameter blocks missing <CODE>ioFVersNum</CODE> field, February 1995</li><li>Parameter blocks missing <CODE>ioMisc</CODE> field, February 1995</li><li><CODE>PBGetCatInfo</CODE> <CODE>ioFDirIndex</CODE> usage rules, February 1995</li><li>Parameter blocks missing <CODE>ioNamePtr</CODE> field, February 1995</li><li><CODE>ioForeignPrivIDirID</CODE> is <CODE>LongInt</CODE> in <CODE>PBGetForeignPrivs</CODE> and <CODE>PBSetForeignPrivs</CODE>, February 1995</li><li>Request execution order, February 1995</li><li>Volume Parameter Variant offsets are off by 2, February 1995</li><li>Detecting if a volume is formatted Macintosh File System (MFS), Hierarchical File System (HFS), or HFS Plus, February 1999</li><li><CODE>PBXGetVolInfo</CODE>, February 1999</li><li><CODE>PBGetXCatInfo</CODE>, February 1999</li></ul>Chapter 3 - Standard File Package<ul><li>Activation Procedures Need to call <CODE>TECalText</CODE>, February 1995</li><li>Default Standard File current directory, February 1995</li><li>Listing 3-15 does not set <CODE>sfScript</CODE> field, February 1995</li></ul>Chapter 4 - Alias Manager<ul><li><CODE>ResolveAlias</CODE> updates minimal aliases, February 1995</li><li><CODE>usrCanceledErr</CODE> should be <CODE>userCanceledErr</CODE>, February 1995</li><li><CODE>kARMSearchMore</CODE> and memory available to <CODE>AliasFilterProc</CODE> warning, February 1995</li></ul>Chapter 5 - Disk Initialization Manager<ul><li>Extended Disk Initialization Package, February 1995</li><li>Extended Disk Initialization User Interface, February 1999</li><li>Extended Low-Level Disk Initialization Routines, February 1999</li><li><CODE>DIXFormat</CODE>, February 1999</li><li><CODE>DIXZero</CODE>, February 1999</li><li><CODE>DIReformat</CODE>, February 1999</li><li>Formatting HFS and HFS Plus Volumes, February 1999</li></ul></TD></TR></TABLE></center><BR><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1041.html%3Fid%3DDTS10002883-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1041.html%3Fid%3DDTS10002883-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1041.html%3Fid%3DDTS10002883-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>