<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Manipulating List Cells (IM: MTb)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING215></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="MoreToolbox-214.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MoreToolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MoreToolbox-513.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MoreToolbox-216.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="MoreToolbox-2.html"><B>More Macintosh Toolbox</B></A> / <BR><DD><A HREF="MoreToolbox-202.html"><B>Chapter 4 - List Manager</B></A> / <A HREF="MoreToolbox-209.html"><B>Using the List Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING215-0></A>
<H2>Manipulating List Cells</H2>
 In addition to the <CODE>LSetCell</CODE> procedure, the List Manager provides four procedures, <CODE>LAddToCell</CODE>, <CODE>LClrCell</CODE>, <CODE>LGetCellDataLocation</CODE>, and <CODE>LGetCell</CODE>, that allow you to manipulate cell item data. You can use the <CODE>LAddToCell</CODE> procedure to append data to list items and the <CODE>LClrCell</CODE> procedure to remove all data from a list item. The <CODE>LGetCellDataLocation</CODE> procedure indicates the location of the beginning of a cell's data within the <CODE>cells</CODE> field of the list record as well as the length of that data, and the <CODE>LGetCell</CODE> procedure copies a cell's data to a buffer that your application specifies.<P>
 <A NAME=MARKER-2-16></A><A HREF=#MARKER-9-208>Listing 4-11</A> illustrates the use of <CODE>LClrCell</CODE> to clear the data from all cells in a list.<P>
<B>Listing 4-11  <A NAME=MARKER-9-208></A>Clearing all cell data<A NAME=MARKER-2-209></A></B><P>
<PRE>
PROCEDURE MyClearAllCellData (myList: ListHandle);
VAR
   aCell: Cell;
BEGIN
   SetPt(aCell, 0, 0);
   REPEAT
      LClrCell(aCell, myList);
   UNTIL NOT LNextCell(TRUE, TRUE, aCell, myList);
END;
</PRE>
 Because <CODE>LClrCell</CODE> simply does nothing if passed a cell not in the list, the <CODE>MyClearAllCellData</CODE> procedure defined in <A HREF=#MARKER-9-208>Listing 4-11</A> will not crash when attempting to clear the first cell even if there are no cells in the list.<A NAME=MARKER-2-380></A><P>
 <A HREF=#MARKER-9-211>Listing 4-12</A> uses the <CODE>LGetCell</CODE> procedure to return the data of a specific cell.<P>
<B>Listing 4-12  <A NAME=MARKER-9-211></A>Getting a copy of the data of a cell<A NAME=MARKER-2-212></A></B><P>
<PRE>
PROCEDURE MyGetCellData (dataPtr: Ptr; VAR dataLen: Integer;
                         aCell: Cell; myList: ListHandle);
BEGIN
   LGetCell(dataPtr, dataLen, aCell, myList);
END;
</PRE>
 The <CODE>LGetCell</CODE> procedure copies cell data to memory beginning at the location specified by <CODE>dataPtr</CODE>. It copies only the number of bytes specified by the value passed in the <CODE>dataLen</CODE> parameter; it returns in that parameter the number of bytes actually copied.<A NAME=MARKER-9-278></A><P>
 Because the <CODE>LGetCell</CODE> procedure duplicates existing bytes of memory, if your application needs to access a cell's data but does not need to manipulate the data, then it should use the <CODE>LGetCellDataLocation</CODE> procedure to access cell data directly. <BR><A HREF=#MARKER-9-214>Listing 4-13</A> uses the <CODE>LGetCellDataLocation</CODE> procedure to get a cell's data.<P>
<B>Listing 4-13  <A NAME=MARKER-9-214></A>Directly accessing a cell's data<A NAME=MARKER-2-368></A></B><P>
<PRE>
PROCEDURE MyGetDirectAccessToCellData
                  (VAR offset: Integer; VAR len: Integer;
                   aCell: Cell; myList: ListHandle);
BEGIN
   LGetCellDataLocation(offset, len, aCell, myList);
END;
</PRE>
 The <CODE>LGetCellDataLocation</CODE> procedure simply returns in the <CODE>offset</CODE> and <CODE>len</CODE> parameters the offset and length of the appropriate cell's data within the <CODE>cells</CODE> field of the list record. <P>
 <A NAME=MARKER-2-206></A><A HREF=#MARKER-9-217>Listing 4-14</A> shows an application-defined procedure that uses <CODE>LGetCellDataLocation</CODE> in conjunction with the <CODE>LSetCell</CODE> procedure <BR>and the <CODE>LAddRow</CODE> function to add a new string to a one-column, alphabetical text-only list. To compare two strings, the procedure uses the Text Utilities <CODE>CompareText</CODE> function, which requires that data be specified by a pointer and length, thus making <CODE>LGetCellDataLocation</CODE> perfect for this purpose. For more information on the <CODE>CompareText</CODE> function, see <I><A HREF="../Text/Text-2.html">Inside Macintosh: Text</A></I>.<P>
<B>Listing 4-14  <A NAME=MARKER-9-217></A>Adding an item to a one-column, alphabetical text list<A NAME=MARKER-2-218></A></B><P>
<PRE>
PROCEDURE MyAddItemAlphabetically (myList: ListHandle; myString: Str255);
VAR
   found:      Boolean;                      {flag variable}
   myRows:     Integer;                      {number of rows in list}
   currentRow: Integer;                      {row being examined}
   cellDataOffset, cellDataLength: Integer;  {data being compared to string}
   aCell:      Cell;                         {cell coordinates}
BEGIN
   found := FALSE;                           {initialize flag variable}
   WITH myList^^.dataBounds DO
      myRows := bottom - top;                {compute number of rows}
   currentRow := -1;                         {start before first row}
   WHILE NOT found DO
   BEGIN                                     {try to insert before next row}
      currentRow := currentRow + 1;          {move to next row}
      IF currentRow = myRows THEN            {past the end of the list?}
         found := TRUE                       {insert string at this row}
      ELSE
      BEGIN
         SetPt(aCell, 0, currentRow);        {prepare to check cell data}
                                             {find location of data}
         LGetCellDataLocation(cellDataOffset, cellDataLength, aCell, myList);
         HLockHi(Handle(myList^^.cells));    {lock list data in memory}
         IF CompareText(@myString[1],        {skip length byte of string}
                        Ptr(ORD4(myList^^.cells^) + cellDataOffset),
                        Length(myString), cellDataLength, gitl2Hdl) = -1 THEN
            found := TRUE;                   {new string should precede }
                                             { this row's string}
         HUnlock(Handle(myList^^.cells));    {unlock list data}
      END;
   END;
                                             {add new row for string}
   currentRow := LAddRow(1, currentRow, myList);
   SetPt(aCell, 0, currentRow);              {prepare to set cell data}
                                             {set data}
   LSetCell(@myString[1], Length(myString), aCell, myList);
END;
</PRE>
 The <CODE>MyAddItemAlphabetically</CODE> procedure defined in <A HREF=#MARKER-9-217>Listing 4-14</A> simply compares a string to the text in each row of a list, until the string follows the row text alphabetically or until there are no more rows, that is, the row number (which is 0-based) is equal to the number of rows, in which case the string is appended to the end of the list.<A NAME=MARKER-2-192></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="MoreToolbox-214.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MoreToolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MoreToolbox-513.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MoreToolbox-216.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="MoreToolbox-3.html">&copy; Apple Computer, Inc.</A><br>6 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>   
