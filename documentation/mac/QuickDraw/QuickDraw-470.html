<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Using Graphics Picture Comments (IM: Im)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING470></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!--end of header -->

<center>
<A HREF="QuickDraw-469.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="QuickDraw-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="QuickDraw-476.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="QuickDraw-471.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="QuickDraw-2.html"><B>Imaging With QuickDraw</B></A> / <BR><DD><A HREF="QuickDraw-465.html"><B>Appendix B - Using Picture Comments for Printing</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING470-0></A>
<H1><A NAME=MARKER-9-120></A>Using Graphics Picture Comments</H1>
 <A NAME=MARKER-2-121></A>Graphics picture comments, listed in <A HREF=QuickDraw-466.html#MARKER-9-1>Table B-1 on page B-8</A>, provide your application with the ability to render smoothed polygons (as described in the next section) and to rotate graphics (as described in <A HREF=#MARKER-9-147>"Rotating Graphics" on page B-31</A>).<P>
 In general, you cannot use one set of graphics picture comments (for instance, the polygon-drawing picture comments) with another (graphics rotation comments). When using these two types of comments, you should simply rotate the points of the polygon before drawing.<P>
 The graphics comments for drawing dashed lines and for rotating graphics require the use of the <CODE>PenMode</CODE> procedure (described in the chapter "QuickDraw Drawing" in this book) to set the pattern mode to a value of 23. Normally this value is undefined, but it is handled specially by PostScript printer drivers, which treat it like the <CODE>srcCopy</CODE> Boolean transfer mode (described in the chapters "QuickDraw Drawing" and "Color QuickDraw"). All QuickDraw drivers ignore this pattern mode. Your application can use this pattern mode to draw objects in a picture and, if the picture is printed on a QuickDraw printer, these objects are not visible. <A NAME=MARKER-2-122></A><P>
<A NAME=HEADING470-4></A>
<H2><A NAME=MARKER-9-123></A>Drawing Polygons</H2>
 <A NAME=MARKER-2-124></A>By using picture comments, you can draw high-resolution polygons on PostScript printing devices. PostScript supports four types of polygons: open, framed, filled, and smoothed. (QuickDraw supports all of these types except smoothed.)
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Type<TH>Description<TR>
<TD>Open<TD>A polygon whose endpoints do not join. This type of polygon cannot be filled.<TR>
<TD>Framed<TD>A closed polygon that is not filled. Framed and filled polygons are exclusive to one another.<TR>
<TD>Filled<TD>A closed polygon whose interior is entirely covered with a pattern.<TR>
<TD>Smoothed<TD>A polygon (open, framed, or filled) whose edges have been rounded.</TABLE>
<P>
 <A HREF=#MARKER-9-125>Figure B-7</A> shows these four types of polygons.<P>
<B>Figure B-7  <A NAME=MARKER-9-125></A>Types of polygons</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/AppB-L-08.jpg"><BR>
 To draw polygons, perform the following steps:<P>
<OL>
<LI>Use the <CODE>PolyBegin</CODE> picture comment to alert the PostScript driver that you are drawing a polygon.<A NAME=MARKER-2-126></A>
<LI>Optionally, you can use the <CODE>PolyClose</CODE> picture comment to use "closed" smoothing between the first and last vertices of the polygon.<A NAME=MARKER-2-127></A>
<LI>Use the <CODE>PolySmooth</CODE> picture comment to tell the PostScript driver to draw a B&eacute;zier curve.<A NAME=MARKER-2-128></A>
<LI>Use the <CODE>GetClip</CODE> procedure to save the current clipping region; then use the <CODE>ClipRect</CODE> procedure to hide your polygon's drawing commands from QuickDraw.
<LI>Draw your polygon. The PostScript driver renders it smoothly.
<LI>Use the <CODE>SetClip</CODE> procedure to restore the previous clipping region.
<LI>Use the <CODE>PolyIgnore</CODE> picture comment to make the printer driver ignore the line-drawing commands for your QuickDraw representation of the polygon.<A NAME=MARKER-2-129></A>
<LI>Draw your QuickDraw representation of the polygon.
<LI>Use the <CODE>PolyEnd</CODE> picture comment.<A NAME=MARKER-2-130></A><P>
</OL>
 The <CODE>PolyBegin</CODE> and <CODE>PolyEnd</CODE> picture comments surround the polygon description. Note that the printer driver draws the polygon at the location of the pen when it receives the <CODE>PolyBegin</CODE> picture comment, so you must set the pen's location before using the <CODE>PolyBegin</CODE> picture comment. For polygons that are smoothed, you must set the pen size to 0 after the <CODE>PolyBegin</CODE> picture comment to prevent the unsmoothed polygon from being drawn on printers that do not support the polygon comments.<P>
 All QuickDraw routines called between <CODE>PolyBegin</CODE> and <CODE>PolyEnd</CODE> that are processed by the low-level <CODE>StdLine</CODE> routine are part of the polygon--that is, the endpoints of each of the lines become vertices of the polygons.<A NAME=MARKER-9-335></A><P>
 You should use the <CODE>PolyClose</CODE>, <CODE>PolySmooth</CODE>, and <CODE>PolyIgnore</CODE> picture comments between the <CODE>PolyBegin</CODE> and <CODE>PolyEnd</CODE> picture comments.<A NAME=MARKER-2-132></A> <A NAME=MARKER-2-133></A><P>
 The <CODE>PolyClose</CODE> comment specifies that the printer driver should treat all vertices of the polygon in the same manner; in particular, this affects the shape of the smooth curve between the polygon's first and last vertices, which might otherwise be distinguishable as separate points. The <CODE>PolyClose</CODE> comment, however, does not automatically close the polygon as the PostScript operator <CODE>closepath</CODE> does. <A NAME=MARKER-2-134></A><P>
 To render high-resolution B-splines when PostScript is available, use the <CODE>PolySmooth</CODE> picture comment, which directs the PostScript printer driver to interpret the polygon vertices as control nodes for a quadratic B&eacute;zier spline. PostScript has a direct facility for cubic B-splines, and the PostScript printer driver translates the quadratic B-spline nodes into the appropriate nodes for a cubic B-spline that will emulate the original quadratic. This allows you to use this PostScript feature without having to call PostScript routines directly. <A NAME=MARKER-2-135></A><P>
<DL>
<DT><B>Note</B>
<DD>PostScript Level 1 has some problems with very large polygons that have more than 1500 points. For this reason, you may want to avoid doubling the points on large smoothed polygons, even though a greater number of points might aid in making the polygon smoother.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 <A NAME=MARKER-2-136></A>When you use the <CODE>PolySmooth</CODE> picture comment, pass a <CODE>TPolyVerbHdl</CODE> handle, which is a handle to a <CODE>TPolyVerbRec</CODE> record, in the <CODE>dataHandle</CODE> parameter of the <CODE>PicComment</CODE> procedure. You use a <CODE>TPolyVerbRec</CODE> record to tell the printer driver to interpret the polygon vertices as control nodes for a quadratic B&eacute;zier spline. Here is how you should declare these as Pascal data structures in your application:<P>
<PRE>
Type 
   TPolyVerbHdl   = ^TPolyVerbPtr;
   TPolyVerbPtr   = ^TPolyVerbRec;
   TPolyVerbRec   =
   PACKED RECORD
      f7,f6,f5,f4,f3:   Boolean;    {reserved; set to 0}
      fPolyClose:       Boolean;    {TRUE is same as PolyClose }
                                    { picture comment}
      fPolyFill:     Boolean;       {TRUE means fill polygon}
      fPolyframe:    Boolean;       {TRUE means frame polygon}
   END;
</PRE>
 The <CODE>f7</CODE>, <CODE>f6</CODE>, <CODE>f5</CODE>, <CODE>f4</CODE>, and <CODE>f3</CODE> fields are reserved bits; you should set them to 0.<P>
 Setting the <CODE>fPolyClose</CODE> field to 1 achieves the same result as the <CODE>PolyClose</CODE> picture comment. The <CODE>PolyClose</CODE> comment specifies that the printer driver should treat all vertices of the polygon in the same manner; in particular, this affects the shape of the smooth curve between the polygon's first and last vertices, which might otherwise be distinguishable as separate points. The <CODE>PolyClose</CODE> comment does not automatically close the polygon as the PostScript operator <CODE>closepath</CODE> does.<A NAME=MARKER-2-137></A><P>
 Set the <CODE>fPolyFill</CODE> field to 1 if you want the printer driver to fill the polygon, or set it to 0 if not.<A NAME=MARKER-2-138></A><P>
 Set the <CODE>fPolyFrame</CODE> field to 1 if you want the printer driver to frame the polygon, or set it to 0 if not.<A NAME=MARKER-2-139></A><A NAME=MARKER-2-140></A><P>
 In <A HREF=#MARKER-9-141>Listing B-5</A>, the polygon coordinates are defined through arrays of points, initialized using an application-defined procedure, <CODE>MyDefineVertices</CODE>. The procedure <CODE>MyDefineVertices</CODE> specifies the points for two polygons. The array referenced through the parameter <CODE>p</CODE> defines the points used for the PostScript representation of the polygon. The array referenced through the parameter <CODE>q</CODE> defines the points used for the QuickDraw representation of the polygon.<P>
<B>Listing B-5  <A NAME=MARKER-9-141></A>Creating polygons</B><P>
<PRE>
PROCEDURE MyDefineVertices(VAR p,q: PointArrayPtr);
CONST
   cx = 280;   {x coordinate for center point}
   cy = 280;   {y coordinate for center point}
   r0 = 200;   {radius}
   kN = 4;     {number of vertices for PostScript}
   kM = 6;     {number of vertices for QuickDraw approximation}
BEGIN
   {the array p^ contains the control points for the B&eacute;zier curve}
   SetPt(p^[0],cx + r0,cy);
   SetPt(p^[1],cx,cy + r0);
   SetPt(p^[2],cx - r0,cy);
   SetPt(p^[3],cx,cy - r0);
   p^[4] := p^[0];
   {q^ contains the points for a QuickDraw approximation of the curve}
   q^[0] := p^[0];
   SetPt(q^[1],cx,cy + round(0.7 * (p^[1].v - cy)));
   SetPt(q^[2],(p^[1].h + p^[2].h) DIV 2,
         (p^[1].v + p^[2].v) DIV 2);
   SetPt(q^[3],cx + round(0.8 * (p^[2].h - cx)),cy);
   SetPt(q^[4],q^[2].h,cy + cy - q^[2].v);
   SetPt(q^[5],q^[1].h,cy + cy - q^[1].v);
   q^[6] := q^[0];
END;
</PRE>
 <A NAME=MARKER-2-142></A>Use the <CODE>PolyIgnore</CODE> comment before drawing your QuickDraw version of the polygon; between <CODE>PolyIgnore</CODE> and <CODE>PolyEnd</CODE>, drivers that support these two comments ignore all QuickDraw routines processed through the low-level procedure <CODE>StdLine</CODE>. You can enclose the application-defined procedure <CODE>MyPolygonDemo</CODE>, shown in <A HREF=#MARKER-9-144>Listing B-6</A>, between <CODE>OpenPicture</CODE> and <CODE>ClosePicture</CODE> calls to create a picture containing both QuickDraw and PostScript representations of the polygon. Alternatively, you can call <CODE>MyPolygonDemo</CODE> when drawing directly into a printing graphics port.<A NAME=MARKER-2-143></A><P>
<B>Listing B-6  <A NAME=MARKER-9-144></A>Drawing polygons</B><P>
<PRE>
PROCEDURE MyPolygonDemo;
VAR
   p, q:                PointArrayPtr;
   aPolyVerbH:          TPolyVerbHdl;
   i:                   Integer;
   clipRgn, polyRgn:    RgnHandle;
   zeroRect:            Rect;
BEGIN
   p := PointArrayPtr(NewPtr(SizeOf(Point) * (kN + 1)));
   q := PointArrayPtr(NewPtr(SizeOf(Point) * (kM + 1)));
   IF (p = NIL) OR (q = NIL) THEN DoErr(kMemError);
   MyDefineVertices(p,q);
   PenNormal;  {first show the standard QuickDraw polygon}
   MoveTo(p^[0].h,p^[0].v);
   FOR i := 1 TO kN DO
      LineTo(p^[i].h,p^[i].v);
   PenSize(2,2);  {now show the same polygon &quot;smoothed&quot;}
   PenPat(gray);
   {first, the PostScript representation, clipped from QuickDraw}
   aPolyVerbH:= 
      TPolyVerbHdl(NewHandle(SizeOf(TPolyVerbRec)));
   IF aPolyVerbH&lt;&gt; NIL THEN
      WITH aPolyRecH^^ DO
      BEGIN             
         fPolyFrame := TRUE;
         fPolyFill  := FALSE;
         fPolyClose := FALSE;






         {compare with the result for TRUE!}
         f3 := FALSE;
         f4 := FALSE;
         f5 := FALSE;
         f6 := FALSE;
         f7 := FALSE;
      END;
   MoveTo(p^[0].h,p^[0].v);
   PicComment(PolyBegin,0,NIL);
   {picComment(PolyClose,0,NIL); only if }
   { fPolyClose = TRUE, above!}
   PicComment(PolySmooth,SizeOf(TPolyVerbRec),
               Handle(aPolyVerbH));
   clipRgn := NewRgn;
   GetClip(clipRgn);
   ClipRect(zeroRect);
   FOR i := 1 TO kN DO
      LineTo(p^[i].h,p^[i].v);
   {next, the QuickDraw approximation of the smoothed }
   { polygon, invisible for PostScript because of PolyIgnore}
   SetClip(clipRgn);
   PicComment(PolyIgnore,0,NIL);
   polyRgn := NewRgn;
   OpenRgn;
   MoveTo(q^[0].h,q^[0].v);
   FOR i := 1 TO kM DO
      LineTo(q^[i].h,q^[i].v);
   CloseRgn(polyRgn);
   FrameRgn(polyRgn);   {or FillRgn, if fPolyFill above is TRUE}
   PicComment(PolyEnd,0,NIL);
   DisposeHandle(Handle(aPolyVerbH));
   DisposeRgn(polyRgn);
   DisposePtr(Ptr(p));
   DisposePtr(Ptr(q));
END;
</PRE>
 The two versions of the drawn polygon are shown in <A HREF=#MARKER-9-145>Figure B-8</A>.<P>
<B>Figure B-8  <A NAME=MARKER-9-145></A>QuickDraw and PostScript polygons</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/AppB-L-09.jpg"><BR>
 Note that you do not need to open a region, collect the line segments in the region, and draw the polygon through the <CODE>FrameRgn</CODE> procedure (described in the chapter "QuickDraw Drawing" in this book). This method is demonstrated in <A HREF=#MARKER-9-144>Listing B-6</A> only to prepare you for situations where you want to fill the polygon with a pattern. You cannot open a polygon and use the <CODE>FillPoly</CODE> procedure (also described in the chapter "QuickDraw Drawing" in this book), because the PostScript driver "owns" the polygon concept at this point and captures--and ignores--all line drawing between the <CODE>PolyIgnore</CODE> and <CODE>PolyEnd</CODE> comments. Regions do not interfere with polygons, however, and they can be used to paint or fill the polygonal shape.<A NAME=MARKER-2-146></A><P>
<A NAME=HEADING470-41></A>
<H2><A NAME=MARKER-9-147></A>Rotating Graphics</H2>
 <A NAME=MARKER-2-148></A><A NAME=MARKER-2-149></A>You can rotate QuickDraw objects on PostScript printers. The printer driver rotates the entire PostScript coordinate space before drawing the objects, which then appear rotated. All objects that you want to rotate must be contained between the <CODE>RotateBegin</CODE> and <CODE>RotateEnd</CODE> picture comments. <A NAME=MARKER-2-150></A><P>
 You specify the center of rotation with the <CODE>RotateCenter</CODE> picture comment. Unlike text rotation, where you pass the <CODE>TextBegin</CODE> picture comment first and then the <CODE>RotateCenter</CODE> picture comment, you must pass the offset (which is relative to the center of rotation) with the <CODE>RotateCenter</CODE> picture comment <I>before</I> you use the <CODE>RotateBegin</CODE> picture comment. When you specify the <CODE>RotateCenter</CODE> picture comment in the <CODE>kind</CODE> parameter of the <CODE>PicComment</CODE> procedure, you also supply in the <CODE>dataHandle</CODE> parameter a <CODE>TCenterHdl</CODE> handle, which is a handle to a <CODE>TCenterRec</CODE> record. You can use this record to specify the center of rotation for graphics or text. See <A HREF=QuickDraw-469.html#MARKER-9-98>"Rotating Text" beginning on page B-20</A> for a description of the fields of a <CODE>TCenterRec</CODE> record.<A NAME=MARKER-2-151></A><P>
 <A NAME=MARKER-2-152></A>When you specify the <CODE>RotateBegin</CODE> picture comment in the <CODE>kind</CODE> parameter of the <CODE>PicComment</CODE> procedure, you also supply in the <CODE>dataHandle</CODE> parameter a <CODE>TRotationHdl</CODE> handle, which is a handle to a <CODE>TRotationRec</CODE> record. You use a <CODE>TRotationRec</CODE> record to specify the rotation of a graphic. Here's how you should declare these as Pascal data structures:<P>
<PRE>
TYPE 
   TRotationHdl = ^TRotationPtr;
   TRotationPtr = ^TRotationRec;
   TRotationRec =
   RECORD
      rFlip:         Integer; {horizontal/vertical flipping}
      rAngle:        Integer; {0..360 clockwise rotation in }
                              { integer format}
      rAngleFixed:   Fixed;   {0..360 clockwise rotation in }
                              { fixed-number format}
   END;
</PRE>
 You use the <CODE>rFlip</CODE> field to specify whether to flip the graphic horizontally or vertically in addition to rotating it. Here are the possible values for this field:
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Value<TH>Description<TR>
<TD>0<TD>No coordinate flip<TR>
<TD>1<TD>Horizontal coordinate flip<TR>
<TD>2<TD>Vertical coordinate flip<A NAME=MARKER-2-38></A></TABLE>
<P>
 You supply the <CODE>rAngleFixed</CODE> field with a fixed-point number to specify the number of degrees by which the printer driver should rotate the graphic. <P>
 You can provide the degrees of rotation both as an integer (in the <CODE>rAngle</CODE> field) and as a fixed-point number (in the <CODE>rAngleFixed</CODE> field). You should always specify the rotation in both fields, even for drivers that support only integral rotation. <A NAME=MARKER-2-153></A><A NAME=MARKER-2-154></A><A NAME=MARKER-2-155></A><P>
 <A NAME=MARKER-2-156></A>Once you set up the rotation with the <CODE>RotateCenter</CODE> and <CODE>RotateBegin</CODE> picture comments, you draw the graphics objects you want to rotate. Before drawing the objects, use the <CODE>PenMode</CODE> procedure to set the pattern mode to a value of 23, which represents a special pattern mode for PostScript printer drivers. You should draw the QuickDraw image, using the <CODE>CopyBits</CODE> procedure, inside its own pair of <CODE>PostScriptBegin</CODE> and <CODE>PostScriptEnd</CODE> comments so that the QuickDraw representation will not show up on PostScript devices. (You should also use the <CODE>PrGeneral</CODE> procedure with the <CODE>getRslDataOp</CODE> opcode, described in the chapter "Printing Manager" in this book, to determine and use the maximum printer resolution.) <P>
 In <A HREF=#MARKER-9-157>Listing B-7</A>, the application-defined procedure <CODE>MyRotateDemo</CODE> rotates the same image for both QuickDraw and PostScript printers. <P>
<A NAME=MARKER-9-157></A><B>Listing B-7  Using picture comments to rotate graphics</B><P>
<PRE>
PROCEDURE MyRotateDemo;
CONST
   angle = 30;
VAR
   spinRect:   Rect;
   delta:      Point;
BEGIN
   SetRect(spinRect,100,100,300,200);
   WITH spinRect DO SetPt(delta,(right - left) DIV 2,
                         (bottom - top) DIV 2);
   PenSize(2,2);
   PenPat(ltGray);
   FrameRect(spinRect); {show the unrotated square}
   PenNormal;
   MyPSRotatedRect(spinRect,delta,angle);
   {QuickDraw equivalent of the rotated object, hidden from the PostScript }
   { driver because of PostScriptBegin and PostScriptEnd}
   PicComment(PostScriptBegin, 0, NIL);
   MyQDRotatedRect(spinRect, delta, angle);
   PicComment(PostScriptEnd, 0, NIL);
END;
</PRE>
 The application-defined procedure <CODE>MyQDRotatedRect</CODE> rotates the four points of the rectangle by an angle around the center and draws the rotated rectangle. To include this QuickDraw representation of the rotated objects (in case the <CODE>RotateCenter</CODE> and <CODE>RotateBegin</CODE> picture comments are not supported), the code in <A HREF=#MARKER-9-157>Listing B-7</A> assumes that only PostScript drivers implement these comments. The only way to hide from the driver the application-defined procedure that provides a QuickDraw representation of the rotated objects is to surround it by <CODE>PostScriptBegin</CODE> and <CODE>PostScriptEnd</CODE> comments.<P>
 To hide from QuickDraw the graphics rotation for a PostScript printer, <A HREF=#MARKER-9-158>Listing B-8</A> uses pattern mode 23.<P>
<B>Listing B-8  <A NAME=MARKER-9-158></A>Using the <CODE>RotateCenter</CODE>, <CODE>RotateBegin</CODE>, and <CODE>RotateEnd</CODE> picture comments</B><P>
<PRE>
PROCEDURE MyPSRotatedRect(r: Rect; offset: Point; angle: Integer);
{does the rectangle rotation for the PostScript LaserWriter driver}
{uses the RotateCenter, RotateBegin, and RotateEnd picture comments, }
{ and the &quot;magic&quot; pattern mode 23 to hide the drawing from QuickDraw}
CONST
   magicPen = 23;
VAR
   rInfo:      TRotationHdl;
   rCenter:    TCenterHdl;
   oldPenMode: Integer;
BEGIN
   rInfo := TRotationHdl(NewHandle(SizeOf(TRotationRec)));
   rCenter := TCenterHdl(NewHandle(SizeOf(TCenterRec)));
   IF (rInfo = NIL) OR (rCenter = NIL)
      THEN DebugStr('NewHandle failed');
   WITH rInfo^^ DO
   BEGIN
      rFlip := 0;
      rAngle := - angle;
      rAngleFixed := BitShift(LongInt(rAngle),16);
   END;
   WITH rCenter^^ DO
   BEGIN
      x := Long2Fix(offset.h);
      y := Long2Fix(offset.v);
   END;
   MoveTo(r.left,r.top);
   MyFlushGrafPortState;   {see Listing B-1 on page B-10}
   PicComment(RotateCenter,SizeOf(TCenterRec),Handle(rCenter));
   PicComment(RotateBegin,SizeOf(TRotationRec),Handle(rInfo));
   oldPenMode := thePort^.pnMode;
   PenMode(magicPen);
   FrameRect(r);
   PenMode(oldPenMode);
   PicComment(RotateEnd,0,NIL);
   DisposeHandle(Handle(rInfo));
   DisposeHandle(Handle(rCenter));
END;
</PRE>

</BLOCKQUOTE>
<HR>
<center>
<A HREF="QuickDraw-469.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="QuickDraw-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="QuickDraw-476.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="QuickDraw-471.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="QuickDraw-3.html">&copy; Apple Computer, Inc.</A><br>7 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
