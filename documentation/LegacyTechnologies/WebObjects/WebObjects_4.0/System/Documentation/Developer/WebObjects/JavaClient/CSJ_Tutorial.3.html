<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML EXPERIMENTAL 970324//EN">
<HTML>
<HEAD>
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter">

<TITLE> Data Synchronization Between Client and Server</TITLE></HEAD>
<body bgcolor="#ffffff">

<!--start of banner -->
<!--#include virtual="/includes/framesetheader" -->
<!-- end of banner -->

<!--start of path -->
<font face="Geneva,Helvetica,Arial" size="1">
<b>PATH<spacer type="horizontal" size="5">&nbsp;</b>
 <a href="../../../../../webobjects.html" target="_top">WebObjects 4.0 Documentation</a> <b>&gt;</b>
 <a href="JavaClientTOC.html" target="_top">JavaClient Tutorial</a>
</font>
<br><br>
<!--end of path -->


<DIV>
<P><I>Creating a Java Client WebObjects Application</I><P><A HREF="CSJ_Tutorial.2.html">Previous</A> | <A HREF="CSJ_Tutorial.2.html">Back Up One Level</A> | <A HREF="CSJ_Tutorial.4.html">Next</A></P></DIV>
<H3 CLASS="2HeadSplit">
<A NAME="pgfId=998956">
 </A>
Data Synchronization Between Client and Server</H3>
<P CLASS="Body">
<A NAME="pgfId=999715">
 </A>
In a Java Client application, when the user makes a query, the fetch specification is passed through the layers on the client (EOInterface to EOControl to EODistribution), largely through successive invocations of <TT><B>
objectsWithFetchSpecification</TT></B>
. The distribution layer on the client forwards the fetch specification to the server's distribution layer--in the default WebObjects case, synchronously via HTTP. From there the normal mechanisms take over and a SQL call is eventually made to the database server. The database server returns the rows of requested data and, as usual, this data is converted to enterprise objects and is registered with the EOControl layer on the server. The server's distribution layer then sends <EM CLASS="Italic">
copies</EM>
 of the requested objects back to the client. When the EODistribution layer on the server receives the objects, it registers them with the editing context in the control layer and, through the interface layer's display-group and association mechanisms, the user interface is updated with the requested data.</P>
<P CLASS="Body">
<A NAME="pgfId=999323">
 </A>
Although requested objects are copied from the server to the client, and these objects exist in parallel object graphs on both server and client, the enterprise objects on the client usually do not exactly mirror the enterprise objects on the server. The objects on the client usually have a subset of the properties of the objects on the server (although the reverse can be true). You can partition your application's enterprise objects so that the objects that exist on the client (or the server) have a restricted set of data and behaviors.</P>
<P CLASS="Body">
<A NAME="pgfId=999333">
 </A>
Once the client has fetched data, this data is cached and is represented internally by the client's object graph. As users modify the data (or delete or add &quot;rows&quot; of data), the client's object graph is updated to reflect the new state. When users request that this data be saved, the changed objects are &quot;pushed&quot; to the server. If the business logic on the server validates these changes, the changes are committed to the database. </P>
<P CLASS="Body">
<A NAME="pgfId=999372">
 </A>
Note that Java Client automatically pushes updates from the server to the client. It also, by default, pushes changes before client-side objects remotely invoke methods on server-side objects.</P>
<HR>© 1999 Apple Computer, Inc. <P><A HREF="CSJ_Tutorial.2.html">Previous</A> | <A HREF="CSJ_Tutorial.2.html">Back Up One Level</A> | <A HREF="CSJ_Tutorial.4.html">Next</A></P>

<!-- start of footer -->
<!--#include virtual="/includes/framesetfooter" -->
<!-- end of footer -->

</body>
</HTML>
