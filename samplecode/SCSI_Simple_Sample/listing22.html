<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>SCSI Simple Sample - /Src/SCSISimpleSampleMain.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxHardwareDrivers-date.html">Hardware & Drivers</a> &gt; <A HREF="javascript:location.replace('index.html');">SCSI Simple Sample</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/HardwareDrivers/idxSCSI-date.html" target="_blank">Hardware & Drivers > SCSI</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">SCSI Simple Sample</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Src/SCSISimpleSampleMain.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Src/AsyncSCSI.c</option>
<option value="listing2.html">/Src/AsyncSCSIPresent.c</option>
<option value="listing3.html">/Src/DoGetDriveInfo.c</option>
<option value="listing4.html">/Src/DoListSCSIDevices.c</option>
<option value="listing5.html">/Src/DoReadBlockZero.c</option>
<option value="listing6.html">/Src/DoSCSICommandWithSense.c</option>
<option value="listing7.html">/Src/DoTestUnitReady.c</option>
<option value="listing8.html">/Src/LogManager.c</option>
<option value="listing9.html">/Src/LogManager.h</option>
<option value="listing10.html">/Src/MacSCSICommand.h</option>
<option value="listing11.html">/Src/OriginalSCSI.c</option>
<option value="listing12.html">/Src/scsi.h</option>
<option value="listing13.html">/Src/SCSIBusAPI.c</option>
<option value="listing14.html">/Src/SCSICheckForDevicePresent.c</option>
<option value="listing15.html">/Src/SCSIGetCommandLength.c</option>
<option value="listing16.html">/Src/SCSIGetHighHostBusAdaptor.c</option>
<option value="listing17.html">/Src/SCSIGetInitiatorID.c</option>
<option value="listing18.html">/Src/SCSIGetMaxTargetID.c</option>
<option value="listing19.html">/Src/SCSISimpleSample.h</option>
<option value="listing20.html">/Src/SCSISimpleSample.r</option>
<option value="listing21.html">/Src/SCSISimpleSampleDisplay.c</option>
<option value="listing22.html">/Src/SCSISimpleSampleMain.c</option>
<option value="listing23.html">/Src/StringFormat.c</option>
<option value="listing24.html">/Src/WindowUtilities.c</option></select>
				</p>
				</form>
				<p><strong><a href="SCSI_Simple_Sample.zip">Download Sample</a></strong> (&#147;SCSI_Simple_Sample.zip&#148;, 108.1K)<BR>
<strong><a href="SCSI_Simple_Sample.dmg">Download Sample</a></strong> (&#147;SCSI_Simple_Sample.dmg&#148;, 170.5K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*                SCSISimpleSampleMain.c              *//* * SCSISimpleSampleMain.c * Copyright &copy; 1992-94 Apple Computer Inc. All Rights Reserved. * * This is a &quot;simple sample&quot; that illustrates calls to the original and the * asynchronous SCSI Managers. In particular, it contains &quot;definitive&quot; * algorithms for determining the number of SCSI devices attached to a * Macintosh system. */#define EXTERN#include  &quot;SCSISimpleSample.h&quot;#include  &lt;Packages.h&gt;#include  &lt;Desk.h&gt;#include  &lt;OSEvents.h&gt;#pragma segment MainCode#ifdef __powerc/* * Power PC does not automatically define the QuickDraw globals. This is because * only &quot;application&quot; code-fragments need these globals, and this cannot be * determined before the code fragment is constructed. */QDGlobals      qd;    /* This is not automatically defined on PowerPC    */#endifvoid                main(void);void                EventLoop(void);void                DoMouseEvent(void);void                DoContentClick(    WindowPtr            theWindow  );void                DoCommand(    WindowPtr            theWindow,    long              menuChoice  );void                DoWindowKeyDown(    WindowPtr            theWindow  );void                SetupEverything(void);void                AdjustMenus(void);void                AdjustEditMenu(    Boolean              isDeskAccessory  );void                SetupMenus(void);void                BuildWindow(void);void                DecorateDisplay(    WindowPtr            theWindow,    Boolean              redraw  );void                DrawWindow(    WindowPtr            theWindow  );void                DoAbout(void);void                DoPageSetup(void);void                HexToString(    unsigned long          value,    short              hexDigits,    Str255              result  );Boolean                HexToNum(    ConstStr255Param        hexString,    unsigned long          *result  );    #define IsOurWindow(theWindow)  ((theWindow) == gMainWindow)/* * This preserves the currently-chosen host bus ID in case the user switches * between &quot;old&quot; and &quot;new&quot; SCSI Managers. */static unsigned short        gOldHostBusID;voidmain(void){    SetupEverything();    BuildWindow();    gUpdateMenusNeeded = TRUE;    gInForeground = TRUE;    gEnableNewSCSIManager = AsyncSCSIPresent();    if (gEnableNewSCSIManager)      LOG(&quot;\pHas asynchronous SCSI Manager&quot;);    else {      LOG(&quot;\pAsynchronous SCSI Manager not present&quot;);    }    gEnableSelectWithATN = gEnableNewSCSIManager;    InitCursor();    while (gQuitNow == FALSE) {      EventLoop();    }    ExitToShell();}/* * BuildWindow creates a document window and stores a text log * as its content. */voidBuildWindow(){    short          fontSize;    short          fontNumber;    Rect          viewRect;        fontSize = 10;    GetFNum(&quot;\pCourier&quot;, &amp;fontNumber);    if (RealFont(fontNumber, fontSize) == FALSE)      fontNumber = applFont;    viewRect = qd.screenBits.bounds;    viewRect.top += (GetMBarHeight() * 2);    viewRect.bottom -= 4;    viewRect.left += 4;    viewRect.right = (width(viewRect) / 2);    gMainWindow = NewWindow(            NULL,            &amp;viewRect,            &quot;\pSCSI Scan Bus Sample&quot;,            TRUE,            zoomDocProc,            (WindowPtr) -1L,            TRUE,        /* Has GoAway box    */            0          /* No refCon      */          );    if (gMainWindow == NULL) {      SysBeep(10);      ExitToShell();    }    SetPort(gMainWindow);    viewRect = gMainWindow-&gt;portRect;    viewRect.right -= kScrollBarOffset;    viewRect.bottom -= kScrollBarOffset;    gLogListHandle = CreateLog(          &amp;viewRect,          fontNumber,          fontSize,          kLogLines        );    if (gLogListHandle == NULL) {      SysBeep(10);      ExitToShell();    }}voidEventLoop(void){    long              menuChoice;    register WindowPtr        theWindow;    GrafPtr              savePort;    Boolean              isActivating;        if (gUpdateMenusNeeded) {      gUpdateMenusNeeded = FALSE;      AdjustMenus();    }    WaitNextEvent(      everyEvent,      &amp;EVENT,      (gInForeground) ? 10L : 60L,      NULL    );    theWindow = FrontWindow();    switch (EVENT.what) {    case nullEvent:      break;    case keyDown:    case autoKey:      if ((EVENT.message &amp; charCodeMask) == '.'       &amp;&amp; (EVENT.modifiers &amp; cmdKey) != 0) {        FlushEvents(keyDown | autoKey, 0);        gQuitNow = TRUE;      }      else if ((EVENT.modifiers &amp; cmdKey) != 0) {        if (EVENT.what == keyDown) {          menuChoice = MenuKey(EVENT.message &amp; charCodeMask);          if (HiWord(menuChoice) != 0)            DoCommand(theWindow, menuChoice);          else if (IsOurWindow(theWindow)) {            DoWindowKeyDown(theWindow);          }        }      }      else if (IsOurWindow(theWindow)) {        DoWindowKeyDown(theWindow);      }      break;    case mouseDown:      DoMouseEvent();      break;    case updateEvt:      theWindow = (WindowPtr) EVENT.message;      GetPort(&amp;savePort);      SetPort(theWindow);      BeginUpdate(theWindow);      EraseRect(&amp;theWindow-&gt;portRect);      DrawControls(theWindow);      DrawGrowIcon(theWindow);      if (IsOurWindow(theWindow))        DrawWindow(theWindow);      EndUpdate(theWindow);      SetPort(savePort);      break;    case activateEvt:      theWindow = (WindowPtr) EVENT.message;      isActivating = ((EVENT.modifiers &amp; activeFlag) != 0);      goto activateEvent;      break;    case osEvt:      switch (((unsigned long) EVENT.message) &gt;&gt; 24) {      case mouseMovedMessage:        break;      case suspendResumeMessage:        isActivating = ((EVENT.message &amp; 0x01) != 0);activateEvent:    if (isActivating) {          /*           * Activate this window. Activate events define theWindow           * from the event record, while suspend/resume uses the           * pre-set FrontWindow value.           */          SelectWindow(theWindow);          (void) TEFromScrap();        }        if (IsOurWindow(theWindow) &amp;&amp; gLogListHandle != NULL)          LActivate(isActivating, gLogListHandle);        else {          /* Desk accessory or what? */        }        gInForeground = isActivating;        gUpdateMenusNeeded = TRUE;        break;      }      break;    }}/* * DoMouseEvent * The user clicked on something. Handle application-wide processing here, or call * a Catalog Browser function for specific action. */voidDoMouseEvent(void){    WindowPtr    theWindow;    short      whichPart;        whichPart = FindWindow(EVENT.where, &amp;theWindow);    if (theWindow == NULL)      theWindow = FrontWindow();    if (whichPart == inMenuBar &amp;&amp; IsOurWindow(theWindow) == FALSE)      theWindow = FrontWindow();    switch (whichPart) {    case inDesk:      break;    case inMenuBar:      InitCursor();      DoCommand(theWindow, MenuSelect(EVENT.where));      break;    case inDrag:      DragWindow(theWindow, EVENT.where, &amp;qd.screenBits.bounds);      break;    case inGoAway:      if (TrackGoAway(theWindow, EVENT.where)) {        if (IsOurWindow(theWindow)) {          /*           * Not quite so simple: we need to handle open files, too.           */          gQuitNow = TRUE;        }      }      break;    case inZoomIn:    case inZoomOut:      if (IsOurWindow(theWindow)       &amp;&amp; TrackBox(theWindow, EVENT.where, whichPart)) {        DoZoomWindow(theWindow, whichPart);        goto resizeWindow;      }      break;    case inGrow:      if (IsOurWindow(theWindow)) {        if (DoGrowWindow(              theWindow,              EVENT.where,              kMinWindowWidth,              kMinWindowHeight            )) {resizeWindow:    DecorateDisplay(theWindow, TRUE);        }      }      break;    case inContent:      if (theWindow != FrontWindow())        SelectWindow(theWindow);      else if (IsOurWindow(theWindow)) {        DoContentClick(theWindow);      }      else {        /* Nothing happens here    */      }      break;    default:      break;    }    /*     * Do not touch theWindow here.     */}voidDoContentClick(    WindowPtr        theWindow  ){    if (0) {        /* Touch unused variables  */      theWindow;    }    DoClickInLog(gLogListHandle, &amp;EVENT);}voidDoWindowKeyDown(    WindowPtr            theWindow  ){    if (0) {        /* Touch unused variables  */      theWindow;    }    /* Nothing happens here */}voidDrawWindow(    WindowPtr            theWindow  ){    if (0) {        /* Touch unused variables  */      theWindow;    }    UpdateLog(gLogListHandle);}voidDecorateDisplay(    WindowPtr            theWindow,    Boolean              redraw  ){    Rect              viewRect;        if (0) {        /* Touch unused variables  */      redraw;    }    viewRect = theWindow-&gt;portRect;    viewRect.right -= kScrollBarOffset;    viewRect.bottom -= kScrollBarOffset;    if (gLogListHandle != NULL) {      MoveLog(gLogListHandle, viewRect.left, viewRect.top);      SizeLog(gLogListHandle, width(viewRect), height(viewRect));    }}voidDoCommand(    WindowPtr            theWindow,    long              menuChoice  ){    short              menuItem;    Str255              menuText;    GrafPtr              savePort;    OSErr              status;    Boolean              useAsynchManager;    menuItem = LoWord(menuChoice);    switch (HiWord(menuChoice)) {    case MENU_Apple:      if (menuItem == kAppleAbout)        DoAbout();      else {        GetItem(gAppleMenu, menuItem, menuText);        AdjustEditMenu(TRUE);        GetPort(&amp;savePort);        OpenDeskAcc(menuText);        SetPort(savePort);        AdjustEditMenu(IsOurWindow(theWindow) == FALSE);      }      break;    case MENU_File:      switch (menuItem) {      case kFileCreateLogFile:        status = SaveLogFile(              gLogListHandle,              &quot;\pSave Log&quot;,              &quot;\pSCSI Test Log&quot;,              'ttxt'            );        break;      case kFileCloseLogFile:        status = CloseLogFile(gLogListHandle);        break;      case kFilePageSetup:        DoPageSetup();        break;      case kFilePrint:        PrintLog(gLogListHandle, gPrintHandle);        break;      case kFileDebug:        Debugger();        break;      case kFileQuit:        gQuitNow = TRUE;        break;      }      break;    case MENU_Test:      switch (menuItem) {      case kTestEnableNewManager:        /*         * Note that this menu option is disabled if the asynchronous         * SCSI Manager is not present. This means that, if it is         * not present at application start, it can't be enabled later.         */        gEnableNewSCSIManager = (!gEnableNewSCSIManager);        if (gEnableNewSCSIManager)          gCurrentDevice.bus = gOldHostBusID;        else {          gOldHostBusID = gCurrentDevice.bus;          gCurrentDevice.bus = 0;        }        gUpdateMenusNeeded = TRUE;        break;      case kTestEnableAllLogicalUnits:        /*         * The ROM SCSI Manager on the Quadra 660-AV and 840-AV has         * a bug that will hang the machine if it tries to access         * a non-zero logical unit. This menu option makes that error         * harder to elicit.         */        gMaxLogicalUnit = (gMaxLogicalUnit == 0) ? 7 : 0;        if (gCurrentDevice.LUN &gt; gMaxLogicalUnit)          gCurrentDevice.LUN = gMaxLogicalUnit;        gUpdateMenusNeeded = TRUE;        break;      case kTestEnableSelectWithATN:        gEnableSelectWithATN = !gEnableSelectWithATN;        gUpdateMenusNeeded = TRUE;        break;      case kTestDoDisconnect:        gDoDisconnect = !gDoDisconnect;        gUpdateMenusNeeded = TRUE;        break;      case kTestDontDisconnect:        gDontDisconnect = !gDontDisconnect;        gUpdateMenusNeeded = TRUE;        break;      case kTestVerboseDisplay:        gVerboseDisplay = (!gVerboseDisplay);        gUpdateMenusNeeded = TRUE;        break;      case kTestListSCSIDevices:        DoListSCSIDevices();        break;      case kTestGetDriveInfo:        status = SCSIBusAPI(gCurrentDevice, &amp;useAsynchManager);        if (status != noErr)          useAsynchManager = FALSE;        DoGetDriveInfo(gCurrentDevice, FALSE, useAsynchManager);        break;      case kTestUnitReady:        DoTestUnitReady(gCurrentDevice);        break;      case kTestReadBlockZero:        DoReadBlockZero(gCurrentDevice);        break;      default:        break;      }      break;    case MENU_CurrentBus:      gCurrentDevice.bus = menuItem - 1;      gUpdateMenusNeeded = TRUE;      break;    case MENU_CurrentTarget:      gCurrentDevice.targetID = menuItem - 1;      gUpdateMenusNeeded = TRUE;      break;    case MENU_CurrentLUN:      gCurrentDevice.LUN = menuItem - 1;      gUpdateMenusNeeded = TRUE;      break;    }    HiliteMenu(0);}voidSetupEverything(){    int          i;        MaxApplZone();    InitGraf(&amp;qd.thePort);    InitFonts();    InitWindows();    InitMenus();    TEInit();    InitDialogs(0);    for (i = 0; i &lt; 8; i++)      MoreMasters();    HNoPurge((Handle) GetCursor(watchCursor));    SetCursor(*GetCursor(watchCursor));    SetupMenus();}voidSetupMenus(){    register Handle    menuBarHdl;    /*     * We ought to do some error checking here.     */    menuBarHdl = GetNewMBar(MBAR_MenuBar);    SetMenuBar(menuBarHdl);    gAppleMenu = GetMHandle(MENU_Apple);    AddResMenu(gAppleMenu, 'DRVR');    gFileMenu = GetMHandle(MENU_File);    gEditMenu = GetMHandle(MENU_Edit);    gTestMenu = GetMHandle(MENU_Test);    gCurrentBusMenu = GetMHandle(MENU_CurrentBus);    gCurrentTargetMenu = GetMHandle(MENU_CurrentTarget);    gCurrentLUNMenu = GetMHandle(MENU_CurrentLUN);    DrawMenuBar();    gUpdateMenusNeeded = TRUE;}voidAdjustMenus(void){    short          i;    short          nItems;    unsigned short      maxTarget;    unsigned short      lastHostBus;    OSErr          status;        EnableItem(gFileMenu, kFileQuit);    EnableItem(gFileMenu, kFileDebug);    if (IsOurWindow(FrontWindow())) {      EnableItem(gFileMenu, kFilePageSetup);      EnableItem(gFileMenu, kFilePrint);      EnableItem(gTestMenu, kTestListSCSIDevices);      EnableItem(gTestMenu, kTestGetDriveInfo);      EnableItem(gTestMenu, kTestUnitReady);      EnableItem(gTestMenu, kTestVerboseDisplay);      CheckItem(gTestMenu, kTestVerboseDisplay, gVerboseDisplay);        EnableItem(gTestMenu, kTestEnableAllLogicalUnits);      CheckItem(gTestMenu, kTestEnableAllLogicalUnits, (gMaxLogicalUnit == 7));      if (AsyncSCSIPresent()) {        EnableItem(gTestMenu, kTestEnableNewManager);      }      else {        DisableItem(gTestMenu, kTestEnableNewManager);      }      if (gEnableNewSCSIManager) {        EnableItem(gCurrentBusMenu, 0);        EnableItem(gTestMenu, kTestEnableSelectWithATN);        EnableItem(gTestMenu, kTestDoDisconnect);        EnableItem(gTestMenu, kTestDontDisconnect);      }      else {        DisableItem(gCurrentBusMenu, 0);        DisableItem(gTestMenu, kTestEnableSelectWithATN);        DisableItem(gTestMenu, kTestDoDisconnect);        DisableItem(gTestMenu, kTestDontDisconnect);      }      CheckItem(gTestMenu, kTestEnableNewManager, gEnableNewSCSIManager);      CheckItem(gTestMenu, kTestEnableSelectWithATN, gEnableSelectWithATN);      CheckItem(gTestMenu, kTestDoDisconnect, gDoDisconnect);      CheckItem(gTestMenu, kTestDontDisconnect, gDontDisconnect);      EnableItem(gTestMenu, kTestEnableAllLogicalUnits);      CheckItem(gTestMenu, kTestEnableAllLogicalUnits, (gMaxLogicalUnit == 7));      /* */      status = SCSIGetMaxTargetID(gCurrentDevice, &amp;maxTarget);      if (status != noErr)        maxTarget = 7;      nItems = CountMItems(gCurrentTargetMenu);      for (i = 1; i &lt;= nItems; i++) {        if ((i - 1) &lt;= maxTarget)          EnableItem(gCurrentTargetMenu, i);        else {          DisableItem(gCurrentTargetMenu, i);        }      }      for (i = 1; i &lt;= nItems; i++)        CheckItem(gCurrentTargetMenu, i, (gCurrentDevice.targetID == (i - 1)) ? TRUE : FALSE);      status = SCSIGetHighHostBusAdaptor(&amp;lastHostBus);      nItems = CountMItems(gCurrentBusMenu);      for (i = 1; i &lt;= nItems; i++) {        if ((i - 1) &lt;= lastHostBus)          EnableItem(gCurrentBusMenu, i);        else {          DisableItem(gCurrentBusMenu, i);        }      }      for (i = 1; i &lt;= nItems; i++)        CheckItem(gCurrentBusMenu, i, (gCurrentDevice.bus == (i - 1)) ? TRUE : FALSE);      nItems = CountMItems(gCurrentLUNMenu);      for (i = 1; i &lt;= nItems; i++) {        if ((i - 1) &lt;= gMaxLogicalUnit)          EnableItem(gCurrentLUNMenu, i);        else {          DisableItem(gCurrentLUNMenu, i);        }        CheckItem(gCurrentLUNMenu, i, (gCurrentDevice.LUN == (i - 1)) ? TRUE : FALSE);      }      /* */      if (HasLogFile(gLogListHandle)) {        EnableItem(gFileMenu, kFileCloseLogFile);        DisableItem(gFileMenu, kFileCreateLogFile);      }      else {        EnableItem(gFileMenu, kFileCreateLogFile);        DisableItem(gFileMenu, kFileCloseLogFile);      }    }    AdjustEditMenu(IsOurWindow(FrontWindow()) == FALSE);}/* * AdjustEditMenu * Enable/disable Edit Menu options. */voidAdjustEditMenu(    Boolean        isDeskAcc  ){    if (isDeskAcc) {      EnableItem(gEditMenu, kEditUndo);      EnableItem(gEditMenu, kEditCut);      EnableItem(gEditMenu, kEditCopy);      EnableItem(gEditMenu, kEditPaste);      EnableItem(gEditMenu, kEditClear);    }    else {      DisableItem(gEditMenu, kEditUndo);      DisableItem(gEditMenu, kEditCut);      DisableItem(gEditMenu, kEditCopy);      DisableItem(gEditMenu, kEditPaste);      DisableItem(gEditMenu, kEditClear);    }}voidDoAbout(){    GrafPtr              savePort;    DialogPtr            dialog;    short              item;        GetPort(&amp;savePort);    dialog = GetNewDialog(DLOG_About, NULL, (WindowPtr) -1L);    ShowWindow(dialog);    SetPort(dialog);    ModalDialog(NULL, &amp;item);    DisposDialog(dialog);    SetPort(savePort);}voidHexToString(    unsigned long          value,    short              hexDigits,    Str255              result  ){    register unsigned short      digit;    register char          *text;        text = (char *) result;    text[0] = hexDigits;    for (; hexDigits &gt; 0; --hexDigits) {      digit = value &amp; 0xF;      if (digit &gt;= 10)        text[hexDigits] = digit - 10 + 'a';      else {        text[hexDigits] = digit + '0';      }      value &gt;&gt;= 4;    }}BooleanHexToNum(    ConstStr255Param        hexString,    unsigned long          *result  ){    register short          i;    register unsigned short      digit;        *result = 0;    for (i = 1; i &lt;= hexString[0]; i++) {      digit = hexString[i];      if (digit &gt;= '0' &amp;&amp; digit &lt;= '9')        digit -= '0';      else if (digit &gt;= 'a' &amp;&amp; digit &lt;= 'f')        digit = digit - 'a' + 10;      else if (digit &gt;= 'A' &amp;&amp; digit &lt;= 'F')        digit = digit - 'A' + 10;      else {        return (FALSE);      }      *result &lt;&lt;= 4;      *result |= digit;    }    return (TRUE);}voidDoPageSetup(void){    PrOpen();    if (PrError() == noErr) {      if (gPrintHandle == NULL) {        gPrintHandle = (THPrint) NewHandle(sizeof (TPrint));        if (gPrintHandle != NULL)          PrintDefault(gPrintHandle);      }      if (gPrintHandle != NULL)        (void) PrStlDialog(gPrintHandle);      PrClose();    }}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/SCSI_Simple_Sample/listing22.html%3Fid%3DDTS10000027-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/SCSI_Simple_Sample/listing22.html%3Fid%3DDTS10000027-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/SCSI_Simple_Sample/listing22.html%3Fid%3DDTS10000027-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>