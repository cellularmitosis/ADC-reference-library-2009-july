<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>GLUT - /macx_dstr.m</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/GraphicsImaging/index.html">Graphics & Imaging</a> &gt; <a href="../../samplecode/GraphicsImaging/idxOpenGL-date.html">OpenGL</a> &gt; <A HREF="javascript:location.replace('index.html');">GLUT</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->


	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">GLUT</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/macx_dstr.m</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/gle/copy.h</option>
<option value="listing2.html">/gle/ex_angle.c</option>
<option value="listing3.html">/gle/ex_cut_round.c</option>
<option value="listing4.html">/gle/ex_raw.c</option>
<option value="listing5.html">/gle/extrude.c</option>
<option value="listing6.html">/gle/extrude.h</option>
<option value="listing7.html">/gle/gle_osx.h</option>
<option value="listing8.html">/gle/gutil.h</option>
<option value="listing9.html">/gle/intersect.c</option>
<option value="listing10.html">/gle/intersect.h</option>
<option value="listing11.html">/gle/port.h</option>
<option value="listing12.html">/gle/rot.h</option>
<option value="listing13.html">/gle/rot_prince.c</option>
<option value="listing14.html">/gle/rotate.c</option>
<option value="listing15.html">/gle/round_cap.c</option>
<option value="listing16.html">/gle/segment.c</option>
<option value="listing17.html">/gle/segment.h</option>
<option value="listing18.html">/gle/texgen.c</option>
<option value="listing19.html">/gle/tube.h</option>
<option value="listing20.html">/gle/tube_gc.h</option>
<option value="listing21.html">/gle/urotate.c</option>
<option value="listing22.html">/gle/view.c</option>
<option value="listing23.html">/gle/vvector.h</option>
<option value="listing24.html">/glsmap/glsmap.h</option>
<option value="listing25.html">/glsmap/glsmapint.h</option>
<option value="listing26.html">/glsmap/smap_buildsmap.c</option>
<option value="listing27.html">/glsmap/smap_context.c</option>
<option value="listing28.html">/glsmap/smap_create.c</option>
<option value="listing29.html">/glsmap/smap_destroy.c</option>
<option value="listing30.html">/glsmap/smap_drawmesh.c</option>
<option value="listing31.html">/glsmap/smap_flag.c</option>
<option value="listing32.html">/glsmap/smap_get.c</option>
<option value="listing33.html">/glsmap/smap_getfunc.c</option>
<option value="listing34.html">/glsmap/smap_gettexdim.c</option>
<option value="listing35.html">/glsmap/smap_gettexobj.c</option>
<option value="listing36.html">/glsmap/smap_getvec.c</option>
<option value="listing37.html">/glsmap/smap_makemesh.c</option>
<option value="listing38.html">/glsmap/smap_nearfar.c</option>
<option value="listing39.html">/glsmap/smap_origin.c</option>
<option value="listing40.html">/glsmap/smap_render.c</option>
<option value="listing41.html">/glsmap/smap_rvec2st.c</option>
<option value="listing42.html">/glsmap/smap_set.c</option>
<option value="listing43.html">/glsmap/smap_setfunc.c</option>
<option value="listing44.html">/glsmap/smap_setvec.c</option>
<option value="listing45.html">/glsmap/smap_texdim.c</option>
<option value="listing46.html">/glsmap/smap_texobj.c</option>
<option value="listing47.html">/glut.h</option>
<option value="listing48.html">/glut_8x13.c</option>
<option value="listing49.html">/glut_9x15.c</option>
<option value="listing50.html">/glut_bitmap.c</option>
<option value="listing51.html">/glut_bwidth.c</option>
<option value="listing52.html">/glut_cindex.c</option>
<option value="listing53.html">/glut_ext.c</option>
<option value="listing54.html">/glut_hel10.c</option>
<option value="listing55.html">/glut_hel12.c</option>
<option value="listing56.html">/glut_hel18.c</option>
<option value="listing57.html">/glut_mroman.c</option>
<option value="listing58.html">/glut_roman.c</option>
<option value="listing59.html">/glut_shapes.c</option>
<option value="listing60.html">/glut_stroke.c</option>
<option value="listing61.html">/glut_swidth.c</option>
<option value="listing62.html">/glut_teapot.c</option>
<option value="listing63.html">/glut_tr10.c</option>
<option value="listing64.html">/glut_tr24.c</option>
<option value="listing65.html">/glut_vidresize.c</option>
<option value="listing66.html">/GLUTApplication.h</option>
<option value="listing67.html">/GLUTApplication.m</option>
<option value="listing68.html">/glutbitmap.h</option>
<option value="listing69.html">/GLUTClipboardController.h</option>
<option value="listing70.html">/GLUTClipboardController.m</option>
<option value="listing71.html">/glutf90.h</option>
<option value="listing72.html">/GLUTMenu.h</option>
<option value="listing73.html">/GLUTMenu.m</option>
<option value="listing74.html">/GLUTMenuItem.h</option>
<option value="listing75.html">/GLUTMenuItem.m</option>
<option value="listing76.html">/GLUTPreferencesController.h</option>
<option value="listing77.html">/GLUTPreferencesController.m</option>
<option value="listing78.html">/glutstroke.h</option>
<option value="listing79.html">/GLUTView.h</option>
<option value="listing80.html">/GLUTView.m</option>
<option value="listing81.html">/GLUTWindow.h</option>
<option value="listing82.html">/GLUTWindow.m</option>
<option value="listing83.html">/HID_Config_Utilities.c</option>
<option value="listing84.html">/HID_Config_Utilities.h</option>
<option value="listing85.html">/HID_Error_Handler.c</option>
<option value="listing86.html">/HID_Error_Handler.h</option>
<option value="listing87.html">/HID_Name_Lookup.c</option>
<option value="listing88.html">/HID_Name_Lookup.h</option>
<option value="listing89.html">/HID_Queue_Utilities.c</option>
<option value="listing90.html">/HID_Queue_Utilities.h</option>
<option value="listing91.html">/HID_Utilities.c</option>
<option value="listing92.html">/HID_Utilities.h</option>
<option value="listing93.html">/HID_Utilities_External.h</option>
<option value="listing94.html">/HID_Utilities_Internal.h</option>
<option value="listing95.html">/libForeground.a</option>
<option value="listing96.html">/macx_cursor.m</option>
<option value="listing97.html">/macx_dials.m</option>
<option value="listing98.html">/macx_dstr.m</option>
<option value="listing99.html">/macx_event.m</option>
<option value="listing100.html">/macx_fortran.m</option>
<option value="listing101.html">/macx_gamemode.m</option>
<option value="listing102.html">/macx_get.m</option>
<option value="listing103.html">/macx_glut.h</option>
<option value="listing104.html">/macx_init.m</option>
<option value="listing105.html">/macx_input.m</option>
<option value="listing106.html">/macx_joy.m</option>
<option value="listing107.html">/macx_key.m</option>
<option value="listing108.html">/macx_menu.m</option>
<option value="listing109.html">/macx_modifier.m</option>
<option value="listing110.html">/macx_overlay.m</option>
<option value="listing111.html">/macx_space.m</option>
<option value="listing112.html">/macx_swap.m</option>
<option value="listing113.html">/macx_tablet.m</option>
<option value="listing114.html">/macx_util.m</option>
<option value="listing115.html">/macx_utilities.h</option>
<option value="listing116.html">/macx_warp.m</option>
<option value="listing117.html">/macx_win.m</option>
<option value="listing118.html">/ReadMe.txt</option></select>
				</p>
				</form>
				<p><strong><a href="glut.zip">Download Sample</a></strong> (&#147;glut.zip&#148;, 374.3K)<BR>
<strong><a href="glut.dmg">Download Sample</a></strong> (&#147;glut.dmg&#148;, 680.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">
/* Copyright (c) Mark J. Kilgard, 1994. */
/* Copyright (c) Dietmar Planitzer, 2002 */

/* This program is freely distributable without licensing fees 
   and is provided without guarantee or warrantee expressed or 
   implied. This program is -not- in the public domain. */

#import &lt;OpenGL/OpenGL.h&gt;
#import &lt;OpenGL/CGLTypes.h&gt;
#import &quot;macx_glut.h&quot;


char *__glutDisplayString = NULL;

// #define TEST    1
#ifdef TEST
static int verbose = 0;

static char *compstr[] =
{
  &quot;none&quot;, &quot;=&quot;, &quot;!=&quot;, &quot;&lt;=&quot;, &quot;&gt;=&quot;, &quot;&gt;&quot;, &quot;&lt;&quot;, &quot;~&quot;
};
static char *capstr[] =
{
  &quot;rgba&quot;, &quot;bufsize&quot;, &quot;double&quot;, &quot;stereo&quot;, &quot;auxbufs&quot;, &quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;alpha&quot;,
  &quot;depth&quot;, &quot;stencil&quot;, &quot;acred&quot;, &quot;acgreen&quot;, &quot;acblue&quot;, &quot;acalpha&quot;, &quot;level&quot;, &quot;xvisual&quot;,
  &quot;transparent&quot;, &quot;samples&quot;, &quot;xstaticgray&quot;, &quot;xgrayscale&quot;, &quot;xstaticcolor&quot;, &quot;xpseudocolor&quot;,
  &quot;xtruecolor&quot;, &quot;xdirectcolor&quot;, &quot;slow&quot;, &quot;conformant&quot;, &quot;num&quot;
};

static void printCriteria(Criterion *criteria, int ncriteria)
{
   int    i;
   
   printf(&quot;Criteria: %d\n&quot;, ncriteria);
   for (i = 0; i &lt; ncriteria; i++) {
      printf(&quot;  %s %s %d\n&quot;,
         capstr[criteria[i].capability],
         compstr[criteria[i].comparison],
         criteria[i].value);
   }
}
#endif /* TEST */

//////////////////////////

static int    gWeightsLoaded = 0;
static int    gMinStencil = INT_MAX, gMaxStencil = 0;
static int    gMinDepth = INT_MAX, gMaxDepth = 0;
static int    gMaxAuxBufs = 0;
static int    gMinSamples = INT_MAX, gMaxSamples = 0;
static int    gMaxColor = 0, gMaxAlpha = 0;
static int    gMaxAccumColor = 0, gMaxAccumAlpha = 0;

#define MAX_BITS 17
static char    gBitTable[MAX_BITS] = {
   0, 1, 2, 3, 4, 5, 6, 8, 10, 12, 16, 24, 32, 48, 64,
   96, 128
};
#define MAX_BITS2 24
#define COLOR_BITS 0
#define ALPHA_BITS 1
static char gBitTable2[MAX_BITS2][2] = {
{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {4,0}, {4,4},
{4,8}, {5,0}, {5,1}, {5,8}, {6,0}, {6,8}, {8,0}, {8,8},
{8,8}, {10,0}, {10,2}, {10,8}, {12,0}, {12,12}, {16,0},
{16,16}
};

static int maskToMinWeight(int mask)
{
   int    i;
   int                n = INT_MAX;
   
   for(i = 0; i &lt; MAX_BITS; i++) {
      if(mask &amp; (1L &lt;&lt; i)) {
         n = MIN(n, (int) gBitTable[i]);
      }
   }
   return n;
}

static int maskToMaxWeight(int mask)
{
   int    i;
   int                n = 0;
   
   for(i = 0; i &lt; MAX_BITS; i++) {
      if(mask &amp; (1L &lt;&lt; i)) {
         n = MAX(n, (int) gBitTable[i]);
      }
   }
   return n;
}

static void maskToMaxWeight2(int mask, int *clr, int *alp)
{
   int    i;
   int                n = 0;
   
   for(i = 0; i &lt; MAX_BITS2; i++) {
      if(mask &amp; (1L &lt;&lt; i)) {
         n = MAX(n, (int) gBitTable2[i][COLOR_BITS]);
      }
   }
   *clr = n;
   n = 0;
   for(i = 0; i &lt; MAX_BITS2; i++) {
      if(mask &amp; (1L &lt;&lt; i)) {
         n = MAX(n, (int) gBitTable2[i][ALPHA_BITS]);
      }
   }
   *alp = n;
}

static void loadMinMaxWeights(void)
{
   int                        n, color, alpha;
   CGLError                    err;
   CGLRendererInfoObj    rend;
   int                        i, nrend, value;
   
   /* get renderer info */
   err = CGLQueryRendererInfo(CGDisplayIDToOpenGLDisplayMask(kCGDirectMainDisplay), &amp;rend, &amp;nrend);
   if(err) {
      __glutFatalError(&quot;failed to acquire renderer infos (%d)&quot;, err);
   }
   
   /* determine min and max weights for stencil, depth, aux buffers... */
   n = 0;
   for(i = 0; i &lt; nrend; i++) {
      CGLDescribeRenderer(rend, i, kCGLRPWindow, &amp;value);
      
      if(value) {
         CGLDescribeRenderer(rend, i, kCGLRPColorModes, &amp;value);
         maskToMaxWeight2(value, &amp;color, &amp;alpha);
         gMaxColor = MAX(color, gMaxColor);
         gMaxAlpha = MAX(alpha, gMaxAlpha);
         
         CGLDescribeRenderer(rend, i, kCGLRPAccumModes, &amp;value);
         maskToMaxWeight2(value, &amp;color, &amp;alpha);
         gMaxAccumColor = MAX(color, gMaxAccumColor);
         gMaxAccumAlpha = MAX(alpha, gMaxAccumAlpha);
         
         CGLDescribeRenderer(rend, i, kCGLRPDepthModes, &amp;value);
         gMinDepth = MIN(maskToMinWeight(value), gMinDepth);
         gMaxDepth = MAX(maskToMaxWeight(value), gMaxDepth);
         
         CGLDescribeRenderer(rend, i, kCGLRPStencilModes, &amp;value);
         gMinStencil = MIN(maskToMinWeight(value), gMinStencil);
         gMaxStencil = MAX(maskToMaxWeight(value), gMaxStencil);
         
         CGLDescribeRenderer(rend, i, kCGLRPMaxAuxBuffers, &amp;value);
         gMaxAuxBufs = MAX(value, gMaxAuxBufs);
         
         CGLDescribeRenderer(rend, i, kCGLRPMaxSampleBuffers, &amp;value);
         if(value &gt; 0) {
            CGLDescribeRenderer(rend, i, kCGLRPMaxSamples, &amp;value);
            gMinSamples = MIN(value, gMinSamples);
            gMaxSamples = MAX(value, gMaxSamples);
         }
      }
   }   
   
   if(gMinSamples == INT_MAX) {
      gMinSamples = 0;
      gMaxSamples = 0;
   }
      
   /* free renderer info */
   CGLDestroyRendererInfo(rend);
}

//////////////////////////

static BOOL requestsBestFormat(Criterion *criteria)
{
   switch(criteria-&gt;comparison) {
      case CMP_EQ:
      case CMP_LTE:
            return (1 == criteria-&gt;value);
      case CMP_LT:
            return (2 == criteria-&gt;value);
   }
   return NO;
}

static int weightForCriterion(Criterion *criteria, int minWeight, int maxWeight)
{
   switch(criteria-&gt;comparison) {
      case CMP_EQ:
            return criteria-&gt;value;
      case CMP_NEQ:
            return maxWeight - criteria-&gt;value;
      case CMP_LT:
      case CMP_LTE:
            return minWeight;
      case CMP_GT:
      case CMP_GTE:
            return maxWeight;
      case CMP_MIN:
            return criteria-&gt;value;
   }
   return 0;
}

static NSOpenGLPixelFormat *findMatch(Criterion *criteria, int ncriteria, int mask, BOOL gameMode)
{
   NSOpenGLPixelFormatAttribute    list[64];
   int                            i, n;
   int                            redWeight = 0, greenWeight = 0, blueWeight = 0, alphaWeight = 0;
   int                            redWeightA = 0, greenWeightA = 0, blueWeightA = 0, alphaWeightA = 0;
   
   if((mask &amp; (1 &lt;&lt; CI_MODE)) || (mask &amp; (1 &lt;&lt; LUMINANCE_MODE)))
      return nil;
   if(!(mask &amp; (1 &lt;&lt; RGBA_MODE)))
      return nil;

   /* Build a pixel format attribute list based on criterion weights */   
   n = 0;
   for(i = 0; i &lt; ncriteria; i++) {
      switch(criteria[i].capability) {
         case DOUBLEBUFFER:
               if(weightForCriterion(&amp;criteria[i], 0, 1) &gt; 0)
                  list[n++] = NSOpenGLPFADoubleBuffer;
               break;
         case STEREO:
               if(weightForCriterion(&amp;criteria[i], 0, 1) &gt; 0)
                  list[n++] = NSOpenGLPFAStereo;
               break;
         case AUX_BUFFERS:
               list[n++] = NSOpenGLPFAAuxBuffers;
               list[n++] = weightForCriterion(&amp;criteria[i], 0, gMaxAuxBufs);
               break;
         case RED_SIZE:
               redWeight = weightForCriterion(&amp;criteria[i], 0, gMaxColor);
               break;
         case GREEN_SIZE:
               greenWeight = weightForCriterion(&amp;criteria[i], 0, gMaxColor);
               break;
         case BLUE_SIZE:
               blueWeight = weightForCriterion(&amp;criteria[i], 0, gMaxColor);
               break;
         case ALPHA_SIZE:
               alphaWeight = weightForCriterion(&amp;criteria[i], 0, gMaxAlpha);
               break;
         case DEPTH_SIZE:
               list[n++] = NSOpenGLPFADepthSize;
               list[n++] = weightForCriterion(&amp;criteria[i], gMinDepth, gMaxDepth);
               break;
         case STENCIL_SIZE:
               list[n++] = NSOpenGLPFAStencilSize;
               list[n++] = weightForCriterion(&amp;criteria[i], gMinStencil, gMaxStencil);
               break;
         case ACCUM_RED_SIZE:
               redWeightA = weightForCriterion(&amp;criteria[i], 0, gMaxAccumColor);
               break;
         case ACCUM_GREEN_SIZE:
               greenWeightA = weightForCriterion(&amp;criteria[i], 0, gMaxAccumColor);
               break;
         case ACCUM_BLUE_SIZE:
               blueWeightA = weightForCriterion(&amp;criteria[i], 0, gMaxAccumColor);
               break;
         case ACCUM_ALPHA_SIZE:
               alphaWeightA = weightForCriterion(&amp;criteria[i], 0, gMaxAccumAlpha);
               break;
         case SAMPLES:
               if(weightForCriterion(&amp;criteria[i], gMinSamples, gMaxSamples) &gt; 0) {
                  list[n++] = kCGLPFASampleBuffers; // since app kit does not export these yet
                  list[n++] = 1;
                  list[n++] = kCGLPFASamples; // since app kit does not export these yet
                  list[n++] = weightForCriterion(&amp;criteria[i], gMinSamples, gMaxSamples);
                  list[n++] = NSOpenGLPFANoRecovery;
               }
               break;
         case SLOW:
               if(weightForCriterion(&amp;criteria[i], 0, 1) == 0)
                  list[n++] = NSOpenGLPFAAccelerated;
               break;
         case CONFORMANT:
               if(weightForCriterion(&amp;criteria[i], 0, 1) &gt; 0)
                  list[n++] = NSOpenGLPFACompliant;
               break;
         case NUM:
               /* We only accept framebuffer config 1 (best) */
               if(!requestsBestFormat(&amp;criteria[i]))
                  return nil;
         case NO_RECOVERY:
               if(weightForCriterion(&amp;criteria[i], 0, 1) &gt; 0)
                  list[n++] = NSOpenGLPFANoRecovery;
               break;
         default:
               /* do nothing */
               break;
      }
   }
   if (redWeight || greenWeight || blueWeight || alphaWeight) { // if they are trying to set any color or alpha size
      list[n++] = NSOpenGLPFAColorSize;
      if ((redWeight &gt; 5) || (greenWeight &gt; 5) || (blueWeight&gt; 5) || (alphaWeight &gt; 1)) {
         list[n++] = 32;
      } else {
         list[n++] = 16;    
      }
      list[n++] = NSOpenGLPFAClosestPolicy;
   }
   if (redWeightA || greenWeightA || blueWeightA || alphaWeightA) { // if they are trying to set any color or alpha size
      list[n++] = NSOpenGLPFAAccumSize;
      if ((redWeightA &gt; 8) || (greenWeightA &gt; 8) || (blueWeightA &gt; 8) || (alphaWeightA &gt; 8)) {
         list[n++] = 64;
      } else {
         list[n++] = 32;    
      }
   }
   if(gameMode)  {
      list[n++] = NSOpenGLPFAScreenMask;
      list[n++] = CGDisplayIDToOpenGLDisplayMask(kCGDirectMainDisplay);
      list[n++] = NSOpenGLPFAColorSize;
      list[n++] = __glutGetCurrentDMDepth ();
      list[n++] = NSOpenGLPFAClosestPolicy; // add any time color depth is used
   }

   list[n] = 0;
   
#ifdef TEST
   __glutDumpPixelFormatAttributes(list);
#endif
   
   return [[[NSOpenGLPixelFormat alloc] initWithAttributes: list] autorelease];
}

///////////////////////////////////

static int parseCriteria(char *word, Criterion *criterion, int *mask, BOOL *allowDoubleAsSingle)
{
   char *    cstr, *vstr, *response;
   int        comparator, value = 0;
   int        rgb, rgba, acc, acca, count, i;
   
   cstr = strpbrk(word, &quot;=&gt;&lt;!~&quot;);
   if (cstr) {
      switch (cstr[0]) {
         case '=':
            comparator = CMP_EQ;
            vstr = &amp;cstr[1];
            break;
         case '~':
            comparator = CMP_MIN;
            vstr = &amp;cstr[1];
            break;
         case '&gt;':
            if (cstr[1] == '=') {
               comparator = CMP_GTE;
               vstr = &amp;cstr[2];
            } else {
               comparator = CMP_GT;
               vstr = &amp;cstr[1];
            }
            break;
         case '&lt;':
            if (cstr[1] == '=') {
               comparator = CMP_LTE;
               vstr = &amp;cstr[2];
            } else {
               comparator = CMP_LT;
               vstr = &amp;cstr[1];
            }
            break;
         case '!':
            if (cstr[1] == '=') {
               comparator = CMP_NEQ;
               vstr = &amp;cstr[2];
            } else {
               return -1;
            }
            break;
         default:
            return -1;
      }
      value = (int) strtol(vstr, &amp;response, 0);
      if (response == vstr) {
         /* Not a valid number. */
         return -1;
      }
      *cstr = '\0';
   } else {
      comparator = CMP_NONE;
   }
   switch (word[0]) {
      case 'a':
         if (!strcmp(word, &quot;alpha&quot;)) {
            criterion[0].capability = ALPHA_SIZE;
            if (comparator == CMP_NONE) {
               criterion[0].comparison = CMP_GTE;
               criterion[0].value = 1;
            } else {
               criterion[0].comparison = comparator;
               criterion[0].value = value;
            }
            *mask |= (1 &lt;&lt; RGBA);
            *mask |= (1 &lt;&lt; ALPHA_SIZE);
            *mask |= (1 &lt;&lt; RGBA_MODE);
            return 1;
         }
         acca = !strcmp(word, &quot;acca&quot;);
         acc = !strcmp(word, &quot;acc&quot;);
         if (acc || acca) {
            criterion[0].capability = ACCUM_RED_SIZE;
            criterion[1].capability = ACCUM_GREEN_SIZE;
            criterion[2].capability = ACCUM_BLUE_SIZE;
            criterion[3].capability = ACCUM_ALPHA_SIZE;
            if (acca) {
               count = 4;
            } else {
               count = 3;
               criterion[3].comparison = CMP_MIN;
               criterion[3].value = 0;
            }
            if (comparator == CMP_NONE) {
               comparator = CMP_GTE;
               value = 8;
            }
            for (i = 0; i &lt; count; i++) {
               criterion[i].comparison = comparator;
               criterion[i].value = value;
            }
            *mask |= (1 &lt;&lt; ACCUM_RED_SIZE);
            return 4;
         }
         if (!strcmp(word, &quot;auxbufs&quot;)) {
            criterion[0].capability = AUX_BUFFERS;
            if (comparator == CMP_NONE) {
               criterion[0].comparison = CMP_MIN;
               criterion[0].value = 1;
            } else {
               criterion[0].comparison = comparator;
               criterion[0].value = value;
            }
            *mask |= (1 &lt;&lt; AUX_BUFFERS);
            return 1;
         }
         return -1;
      case 'b':
         if (!strcmp(word, &quot;blue&quot;)) {
            criterion[0].capability = BLUE_SIZE;
            if (comparator == CMP_NONE) {
               criterion[0].comparison = CMP_GTE;
               criterion[0].value = 1;
            } else {
               criterion[0].comparison = comparator;
               criterion[0].value = value;
            }
            *mask |= (1 &lt;&lt; RGBA);
            *mask |= (1 &lt;&lt; RGBA_MODE);
            return 1;
         }
         if (!strcmp(word, &quot;buffer&quot;)) {
            criterion[0].capability = BUFFER_SIZE;
            if (comparator == CMP_NONE) {
               criterion[0].comparison = CMP_GTE;
               criterion[0].value = 1;
            } else {
               criterion[0].comparison = comparator;
               criterion[0].value = value;
            }
            return 1;
         }
         return -1;
      case 'c':
         if (!strcmp(word, &quot;conformant&quot;)) {
            criterion[0].capability = CONFORMANT;
            if (comparator == CMP_NONE) {
               criterion[0].comparison = CMP_EQ;
               criterion[0].value = 1;
            } else {
               criterion[0].comparison = comparator;
               criterion[0].value = value;
            }
            *mask |= (1 &lt;&lt; CONFORMANT);
            return 1;
         }
         return -1;
      case 'd':
         if (!strcmp(word, &quot;depth&quot;)) {
            criterion[0].capability = DEPTH_SIZE;
            if (comparator == CMP_NONE) {
               criterion[0].comparison = CMP_GTE;
               criterion[0].value = 12;
            } else {
               criterion[0].comparison = comparator;
               criterion[0].value = value;
            }
            *mask |= (1 &lt;&lt; DEPTH_SIZE);
            return 1;
         }
         if (!strcmp(word, &quot;double&quot;)) {
            criterion[0].capability = DOUBLEBUFFER;
            if (comparator == CMP_NONE) {
               criterion[0].comparison = CMP_EQ;
               criterion[0].value = 1;
            } else {
               criterion[0].comparison = comparator;
               criterion[0].value = value;
            }
            *mask |= (1 &lt;&lt; DOUBLEBUFFER);
            return 1;
         }
         return -1;
      case 'g':
         if (!strcmp(word, &quot;green&quot;)) {
            criterion[0].capability = GREEN_SIZE;
            if (comparator == CMP_NONE) {
               criterion[0].comparison = CMP_GTE;
               criterion[0].value = 1;
            } else {
               criterion[0].comparison = comparator;
               criterion[0].value = value;
            }
            *mask |= (1 &lt;&lt; RGBA);
            *mask |= (1 &lt;&lt; RGBA_MODE);
            return 1;
         }
         return -1;
      case 'i':
         if (!strcmp(word, &quot;index&quot;)) {
            criterion[0].capability = RGBA;
            criterion[0].comparison = CMP_EQ;
            criterion[0].value = 0;
            *mask |= (1 &lt;&lt; RGBA);
            *mask |= (1 &lt;&lt; CI_MODE);
            criterion[1].capability = BUFFER_SIZE;
            if (comparator == CMP_NONE) {
               criterion[1].comparison = CMP_GTE;
               criterion[1].value = 1;
            } else {
               criterion[1].comparison = comparator;
               criterion[1].value = value;
            }
            return 2;
         }
         return -1;
      case 'l':
         if (!strcmp(word, &quot;luminance&quot;)) {
            criterion[0].capability = RGBA;
            criterion[0].comparison = CMP_EQ;
            criterion[0].value = 1;
            
            criterion[1].capability = RED_SIZE;
            if (comparator == CMP_NONE) {
               criterion[1].comparison = CMP_GTE;
               criterion[1].value = 1;
            } else {
               criterion[1].comparison = comparator;
               criterion[1].value = value;
            }
            
            criterion[2].capability = GREEN_SIZE;
            criterion[2].comparison = CMP_EQ;
            criterion[2].value = 0;
            
            criterion[3].capability = BLUE_SIZE;
            criterion[3].comparison = CMP_EQ;
            criterion[3].value = 0;
            
            *mask |= (1 &lt;&lt; RGBA);
            *mask |= (1 &lt;&lt; RGBA_MODE);
            *mask |= (1 &lt;&lt; LUMINANCE_MODE);
            return 4;
         }
         return -1;
      case 'n':
         if (!strcmp(word, &quot;num&quot;)) {
            criterion[0].capability = NUM;
            if (comparator == CMP_NONE) {
               return -1;
            } else {
               criterion[0].comparison = comparator;
               criterion[0].value = value;
               return 1;
            }
         }
         else if(!strcmp(word, &quot;no_recovery&quot;)) {
             criterion[0].capability = NO_RECOVERY;
             if (comparator == CMP_NONE) {
                 criterion[0].comparison = CMP_EQ;
                 criterion[0].value = 1;
                 } else {
                     criterion[0].comparison = comparator;
                     criterion[0].value = value;
                     }
             *mask |= (1 &lt;&lt; NO_RECOVERY);
             return 1;
             }
         return -1;
      case 'r':
         if (!strcmp(word, &quot;red&quot;)) {
            criterion[0].capability = RED_SIZE;
            if (comparator == CMP_NONE) {
               criterion[0].comparison = CMP_GTE;
               criterion[0].value = 1;
            } else {
               criterion[0].comparison = comparator;
               criterion[0].value = value;
            }
            *mask |= (1 &lt;&lt; RGBA);
            *mask |= (1 &lt;&lt; RGBA_MODE);
            return 1;
         }
         rgba = !strcmp(word, &quot;rgba&quot;);
         rgb = !strcmp(word, &quot;rgb&quot;);
         if (rgb || rgba) {
            criterion[0].capability = RGBA;
            criterion[0].comparison = CMP_EQ;
            criterion[0].value = 1;
/*   do not add color sizes         
            criterion[1].capability = RED_SIZE;
            criterion[2].capability = GREEN_SIZE;
            criterion[3].capability = BLUE_SIZE;
            criterion[4].capability = ALPHA_SIZE;
            if (rgba) {
               count = 5;
            } else {
               count = 4;
               criterion[4].comparison = CMP_MIN;
               criterion[4].value = 0;
            }
            if (comparator == CMP_NONE) {
               comparator = CMP_GTE;
               value = 1;
            }
            for (i = 1; i &lt; count; i++) {
               criterion[i].comparison = comparator;
               criterion[i].value = value;
            }
*/
            *mask |= (1 &lt;&lt; RGBA);
            *mask |= (1 &lt;&lt; RGBA_MODE);
            return 1;
         }
         return -1;
      case 's':
         if (!strcmp(word, &quot;stencil&quot;)) {
            criterion[0].capability = STENCIL_SIZE;
            if (comparator == CMP_NONE) {
               criterion[0].comparison = CMP_MIN;
               criterion[0].value = 1;
            } else {
               criterion[0].comparison = comparator;
               criterion[0].value = value;
            }
            *mask |= (1 &lt;&lt; STENCIL_SIZE);
            return 1;
         }
         if (!strcmp(word, &quot;single&quot;)) {
            criterion[0].capability = DOUBLEBUFFER;
            if (comparator == CMP_NONE) {
               criterion[0].comparison = CMP_EQ;
               criterion[0].value = 0;
               *allowDoubleAsSingle = YES;
               *mask |= (1 &lt;&lt; DOUBLEBUFFER);
               return 1;
            } else {
               return -1;
            }
         }
         if (!strcmp(word, &quot;stereo&quot;)) {
            criterion[0].capability = STEREO;
            if (comparator == CMP_NONE) {
               criterion[0].comparison = CMP_EQ;
               criterion[0].value = 1;
            } else {
               criterion[0].comparison = comparator;
               criterion[0].value = value;
            }
            *mask |= (1 &lt;&lt; STEREO);
            return 1;
         }
         if (!strcmp(word, &quot;samples&quot;)) {
            criterion[0].capability = SAMPLES;
            if (comparator == CMP_NONE) {
               criterion[0].comparison = CMP_LTE;
               criterion[0].value = 4;
            } else {
               criterion[0].comparison = comparator;
               criterion[0].value = value;
            }
            *mask |= (1 &lt;&lt; SAMPLES);
            return 1;
         }
         if (!strcmp(word, &quot;slow&quot;)) {
            criterion[0].capability = SLOW;
            if (comparator == CMP_NONE) {
               /* Just &quot;slow&quot; means permit fast visuals, but accept
                  slow ones in preference. Presumably the slow ones
                  must be higher quality or something else desirable. */
               criterion[0].comparison = CMP_GTE;
               criterion[0].value = 0;
            } else {
               criterion[0].comparison = comparator;
               criterion[0].value = value;
            }
            *mask |= (1 &lt;&lt; SLOW);
            return 1;
         }
         return -1;
      default:
         return -1;
   }
}

static Criterion *parseModeString(char *mode, int *ncriteria, BOOL *allowDoubleAsSingle, int *pmask)
{
   Criterion *    criteria = NULL;
   int            n = 0, mask = 0, parsed;
   char *        copy, *word;
   
   *allowDoubleAsSingle = NO;
   copy = __glutStrdup(mode);
   /* Attempt to estimate how many criteria entries should be
      needed. */
   n = 0;
   word = strtok(copy, &quot; \t&quot;);
   while (word) {
      n++;
      word = strtok(NULL, &quot; \t&quot;);
   }
   /* Overestimate by 4 times (&quot;rgba&quot; might add four criteria
      entries) plus add in possible defaults plus space for
      required criteria. */
   criteria = (Criterion *) malloc((4 * n + 30) * sizeof(Criterion));
   if (!criteria) {
      __glutFatalError(&quot;out of memory.&quot;);
   }
   
   /* Re-copy the copy of the mode string. */
   strcpy(copy, mode);
   
   n = 0;
   word = strtok(copy, &quot; \t&quot;);
   while (word) {
      parsed = parseCriteria(word, &amp;criteria[n], &amp;mask, allowDoubleAsSingle);
      if (parsed &gt;= 0) {
         n += parsed;
      } else {
         __glutWarning(&quot;Unrecognized display string word: %s (ignoring)\n&quot;, word);
      }
      word = strtok(NULL, &quot; \t&quot;);
   }
   /* do not add &quot;default&quot; criteria */
/*
   if (!(mask &amp; (1 &lt;&lt; SAMPLES))) {
      criteria[n].capability = SAMPLES;
      criteria[n].comparison = CMP_EQ;
      criteria[n].value = 0;
      n++;
   }
   if (!(mask &amp; (1 &lt;&lt; ACCUM_RED_SIZE))) {
      criteria[n].capability = ACCUM_RED_SIZE;
      criteria[n].comparison = CMP_MIN;
      criteria[n].value = 0;
      criteria[n + 1].capability = ACCUM_GREEN_SIZE;
      criteria[n + 1].comparison = CMP_MIN;
      criteria[n + 1].value = 0;
      criteria[n + 2].capability = ACCUM_BLUE_SIZE;
      criteria[n + 2].comparison = CMP_MIN;
      criteria[n + 2].value = 0;
      criteria[n + 3].capability = ACCUM_ALPHA_SIZE;
      criteria[n + 3].comparison = CMP_MIN;
      criteria[n + 3].value = 0;
      n += 4;
   }
   if (!(mask &amp; (1 &lt;&lt; AUX_BUFFERS))) {
      criteria[n].capability = AUX_BUFFERS;
      criteria[n].comparison = CMP_MIN;
      criteria[n].value = 0;
      n++;
   }
   if (!(mask &amp; (1 &lt;&lt; RGBA))) {
      criteria[n].capability = RGBA;
      criteria[n].comparison = CMP_EQ;
      criteria[n].value = 1;
      criteria[n + 1].capability = RED_SIZE;
      criteria[n + 1].comparison = CMP_GTE;
      criteria[n + 1].value = 1;
      criteria[n + 2].capability = GREEN_SIZE;
      criteria[n + 2].comparison = CMP_GTE;
      criteria[n + 2].value = 1;
      criteria[n + 3].capability = BLUE_SIZE;
      criteria[n + 3].comparison = CMP_GTE;
      criteria[n + 3].value = 1;
      criteria[n + 4].capability = ALPHA_SIZE;
      criteria[n + 4].comparison = CMP_MIN;
      criteria[n + 4].value = 0;
      n += 5;
      mask |= (1 &lt;&lt; RGBA_MODE);
   }
   if (!(mask &amp; (1 &lt;&lt; STEREO))) {
      criteria[n].capability = STEREO;
      criteria[n].comparison = CMP_EQ;
      criteria[n].value = 0;
      n++;
   }
   if (!(mask &amp; (1 &lt;&lt; DOUBLEBUFFER))) {
      criteria[n].capability = DOUBLEBUFFER;
      criteria[n].comparison = CMP_EQ;
      criteria[n].value = 0;
      *allowDoubleAsSingle = YES;
      n++;
   }
   if (!(mask &amp; (1 &lt;&lt; DEPTH_SIZE))) {
      criteria[n].capability = DEPTH_SIZE;
      criteria[n].comparison = CMP_MIN;
      criteria[n].value = 0;
      n++;
   }
   if (!(mask &amp; (1 &lt;&lt; STENCIL_SIZE))) {
      criteria[n].capability = STENCIL_SIZE;
      criteria[n].comparison = CMP_MIN;
      criteria[n].value = 0;
      n++;
   }
*/
   /* Since over-estimated the size needed; squeeze it down to
      reality. */
   criteria = (Criterion *) realloc(criteria, n * sizeof(Criterion));
   if (!criteria) {
      /* Should never happen since should be shrinking down! */
      __glutFatalError(&quot;out of memory.&quot;);
   }
   
   free(copy);
   *ncriteria = n;
   *pmask = mask;
   return criteria;
}

NSOpenGLPixelFormat *__glutDeterminePixelFormatFromString(char *string, BOOL *treatAsSingle, BOOL gameMode)
{
   Criterion *                criteria;
   NSOpenGLPixelFormat *    pixFmt = nil;
   BOOL                        allowDoubleAsSingle;
   int                        ncriteria, i, mask;
   
   if(!gWeightsLoaded) {
      loadMinMaxWeights();
      gWeightsLoaded = 1;
   }
   
   criteria = parseModeString(string, &amp;ncriteria, &amp;allowDoubleAsSingle, &amp;mask);
   if (criteria == NULL) {
      __glutWarning(&quot;failed to parse mode string&quot;);
      return NULL;
   }
#ifdef TEST
   printCriteria(criteria, ncriteria);
#endif
   pixFmt = findMatch(criteria, ncriteria, mask, gameMode);
   if(pixFmt) {
      *treatAsSingle = NO;
   } else {
      if(allowDoubleAsSingle) {
         /* Rewrite criteria so that we now look for a double
            buffered visual which will then get treated as a
            single buffered visual. */
         for(i = 0; i &lt; ncriteria; i++) {
            if(criteria[i].capability == DOUBLEBUFFER
               &amp;&amp; criteria[i].comparison == CMP_EQ
               &amp;&amp; criteria[i].value == 0) {
                  criteria[i].value = 1;
            }
         }
         pixFmt = findMatch(criteria, ncriteria, mask, gameMode);
         if(pixFmt) {
            *treatAsSingle = YES;
         }
      }
   }
   free(criteria);
   
   return pixFmt;
}

/* CENTRY */
void APIENTRY glutInitDisplayString(const char *string)
{
   if (__glutDisplayString) {
      free(__glutDisplayString);
   }
   if (string) {
      __glutDisplayString = __glutStrdup(string);
      if (!__glutDisplayString)
         __glutFatalError(&quot;out of memory.&quot;);
   } else {
      __glutDisplayString = NULL;
   }
}
/* ENDCENTRY */
</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/glut/listing98.html%3Fid%3DDTS10000528-2.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/glut/listing98.html%3Fid%3DDTS10000528-2.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/glut/listing98.html%3Fid%3DDTS10000528-2.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>