<html><head><title>Mac OS X
 Manual Page For zshzle(1)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/1/zshzle" title="Mac OS X
 Manual Page for zshzle(1)"><!-- headerDoc=man; indexgroup=Section 1; uid="//apple_ref/doc/man/1/zshzle"; name=zshzle(1) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
ZSHZLE(1)                                                                                          ZSHZLE(1)



<b>NAME</b>
       zshzle - zsh command line editor

<b>DESCRIPTION</b>
       If  the  <b>ZLE</b>  option  is  set  (which  it is by default in interactive shells) and the shell input is
       attached to the terminal, the user is able to edit command lines.

       There are two display modes.  The first, multiline mode, is the default.  It only works if  the  <b>TERM</b>
       parameter is set to a valid terminal type that can move the cursor up.  The second, single line mode,
       is used if <b>TERM</b> is invalid or incapable of moving the cursor up, or if the <b>SINGLE_LINE_ZLE</b> option  is
       set.  This mode is similar to <b>ksh</b>, and uses no termcap sequences.  If <b>TERM</b> is "emacs", the <b>ZLE</b> option
       will be unset by default.

       The parameters <b>BAUD</b>, <b>COLUMNS</b>, and <b>LINES</b> are also used by the line editor.  See <u>Parameters</u> <u>Used</u> <u>By</u> <u>The</u>
       <u>Shell</u> in <a href="zshparam.1.html#//apple_ref/doc/man/1/zshparam"><u>zshparam</u>(1)</a>.



<b>KEYMAPS</b>
       A  keymap  in  ZLE  contains a set of bindings between key sequences and ZLE commands.  The empty key
       sequence cannot be bound.

       There can be any number of keymaps at any time, and each keymap has one or more names.  If all  of  a
       keymap's names are deleted, it disappears.  <b>bindkey</b> can be used to manipulate keymap names.

       Initially, there are four keymaps:

       <b>emacs</b>  EMACS emulation
       <b>viins</b>  vi emulation - insert mode
       <b>vicmd</b>  vi emulation - command mode
       <b>.safe</b>  fallback keymap

       The `<b>.safe</b>' keymap is special.  It can never be altered, and the name can never be removed.  However,
       it can be linked to other names, which can be removed.  In the future other special  keymaps  may  be
       added; users should avoid using names beginning with `<b>.</b>' for their own keymaps.

       In addition to these four names, either `<b>emacs</b>' or `<b>viins</b>' is also linked to the name `<b>main</b>'.  If one
       of the <b>VISUAL</b> or <b>EDITOR</b> environment variables contain the string `<b>vi</b>' when the shell starts  up  then
       it  will  be `<b>viins</b>', otherwise it will be `<b>emacs</b>'.  <b>bindkey</b>'s <b>-e</b> and <b>-v</b> options provide a convenient
       way to override this default choice.

       When the editor starts up, it will select the `<b>main</b>' keymap.  If that keymap doesn't exist,  it  will
       use `<b>.safe</b>' instead.

       In  the  `<b>.safe</b>'  keymap,  each  single key is bound to <b>self-insert</b>, except for ^J (line feed) and ^M
       (return) which are bound to <b>accept-line</b>.  This is deliberately not pleasant to use; if you are  using
       it, it means you deleted the main keymap, and you should put it back.

   <b>Reading</b> <b>Commands</b>
       When ZLE is reading a command from the terminal, it may read a sequence that is bound to some command
       and is also a prefix of a longer bound string.  In this case ZLE will wait a certain time to  see  if
       more  characters  are  typed,  and if not (or they don't match any longer string) it will execute the
       binding.  This timeout is defined by the <b>KEYTIMEOUT</b> parameter; its default is 0.4 sec.  There  is  no
       timeout if the prefix string is not itself bound to a command.

       The  key timeout is also applied when ZLE is reading the bytes from a multibyte character string when
       it is in the appropriate mode.  (This requires that  the  shell  was  compiled  with  multibyte  mode
       enabled;  typically  also  the  locale has characters with the UTF-8 encoding, although any multibyte
       encoding known to the operating system is supported.)  If the second or a subsequent byte is not read
       within the timeout period, the shell acts as if <b>?</b> were typed and resets the input state.

       As  well  as  ZLE commands, key sequences can be bound to other strings, by using `<b>bindkey</b> <b>-s</b>'.  When
       such a sequence is read, the replacement string is pushed back as  input,  and  the  command  reading
       process  starts  again using these fake keystrokes.  This input can itself invoke further replacement
       strings, but in order to detect loops the process will be stopped if there are twenty  such  replace-<font color="#ffffff" class="whiteout">ments&nbsp;replacements</font>
       ments without a real command being read.

       A  key  sequence  typed by the user can be turned into a command name for use in user-defined widgets
       with the <b>read-command</b> widget, described below.


<b>ZLE</b> <b>BUILTINS</b>
       The ZLE module contains three related builtin commands. The <b>bindkey</b> command manipulates  keymaps  and
       key  bindings;  the  <b>vared</b> command invokes ZLE on the value of a shell parameter; and the <b>zle</b> command
       manipulates editing widgets and allows command line access to ZLE commands from  within  shell  func-<font color="#ffffff" class="whiteout">tions.&nbsp;functions.</font>
       tions.

       <b>bindkey</b> [ <u>options</u> ] <b>-l</b>
       <b>bindkey</b> [ <u>options</u> ] <b>-d</b>
       <b>bindkey</b> [ <u>options</u> ] <b>-D</b> <u>keymap</u> ...
       <b>bindkey</b> [ <u>options</u> ] <b>-A</b> <u>old-keymap</u> <u>new-keymap</u>
       <b>bindkey</b> [ <u>options</u> ] <b>-N</b> <u>new-keymap</u> [ <u>old-keymap</u> ]
       <b>bindkey</b> [ <u>options</u> ] <b>-m</b>
       <b>bindkey</b> [ <u>options</u> ] <b>-r</b> <u>in-string</u> ...
       <b>bindkey</b> [ <u>options</u> ] <b>-s</b> <u>in-string</u> <u>out-string</u> ...
       <b>bindkey</b> [ <u>options</u> ] <u>in-string</u> <u>command</u> ...
       <b>bindkey</b> [ <u>options</u> ] [ <u>in-string</u> ]
              <b>bindkey</b>'s options can be divided into three categories: keymap selection, operation selection,
              and others.  The keymap selection options are:

              <b>-e</b>     Selects keymap `<b>emacs</b>', and also links it to `<b>main</b>'.

              <b>-v</b>     Selects keymap `<b>viins</b>', and also links it to `<b>main</b>'.

              <b>-a</b>     Selects keymap `<b>vicmd</b>'.

              <b>-M</b> <u>keymap</u>
                     The <u>keymap</u> specifies a keymap name.

              If a keymap selection is required and none of the options above are used, the `<b>main</b>' keymap is
              used.  Some operations do not permit a keymap to be selected, namely:

              <b>-l</b>     List  all  existing  keymap  names.  If the <b>-L</b> option is also used, list in the form of
                     <b>bindkey</b> commands to create the keymaps.

              <b>-d</b>     Delete all existing keymaps and reset to the default state.

              <b>-D</b> <u>keymap</u> ...
                     Delete the named <u>keymap</u>s.

              <b>-A</b> <u>old-keymap</u> <u>new-keymap</u>
                     Make the <u>new-keymap</u> name an alias for <u>old-keymap</u>, so that both names refer to the  same
                     keymap.   The  names  have equal standing; if either is deleted, the other remains.  If
                     there is already a keymap with the <u>new-keymap</u> name, it is deleted.

              <b>-N</b> <u>new-keymap</u> [ <u>old-keymap</u> ]
                     Create a new keymap, named <u>new-keymap</u>.  If a  keymap  already  has  that  name,  it  is
                     deleted.   If an <u>old-keymap</u> name is given, the new keymap is initialized to be a dupli-<font color="#ffffff" class="whiteout">cate&nbsp;duplicate</font>
                     cate of it, otherwise the new keymap will be empty.

              To use a newly created keymap, it should be linked to <b>main</b>.  Hence the sequence of commands to
              create  and  use  a  new  keymap  `<b>mymap</b>'  initialized  from  the  <b>emacs</b> keymap (which remains
              unchanged) is:

                     <b>bindkey</b> <b>-N</b> <b>mymap</b> <b>emacs</b>
                     <b>bindkey</b> <b>-A</b> <b>mymap</b> <b>main</b>

              Note that while `<b>bindkey</b> <b>-A</b> <u>newmap</u> <b>main</b>' will work when <u>newmap</u> is <b>emacs</b> or <b>viins</b>, it will  not
              work for <b>vicmd</b>, as switching from vi insert to command mode becomes impossible.

              The following operations act on the `<b>main</b>' keymap if no keymap selection option was given:

              <b>-m</b>     Add  the  built-in set of meta-key bindings to the selected keymap.  Only keys that are
                     unbound or bound to <b>self-insert</b> are affected.

              <b>-r</b> <u>in-string</u> ...
                     Unbind the specified <u>in-string</u>s in the selected keymap.  This is exactly equivalent  to
                     binding the strings to <b>undefined-key</b>.

                     When <b>-R</b> is also used, interpret the <u>in-string</u>s as ranges.

                     When  <b>-p</b> is also used, the <u>in-string</u>s specify prefixes.  Any binding that has the given
                     <u>in-string</u> as a prefix, not including the binding for the <u>in-string</u> itself, if any, will
                     be removed.  For example,

                            <b>bindkey</b> <b>-rpM</b> <b>viins</b> <b>'^['</b>

                     will  remove  all  bindings  in the vi-insert keymap beginning with an escape character
                     (probably cursor keys), but leave the binding for the escape character itself (probably
                     <b>vi-cmd-mode</b>).  This is incompatible with the option <b>-R</b>.

              <b>-s</b> <u>in-string</u> <u>out-string</u> ...
                     Bind  each  <u>in-string</u>  to each <u>out-string</u>.  When <u>in-string</u> is typed, <u>out-string</u> will be
                     pushed back and treated as input to the line editor.  When <b>-R</b> is also  used,  interpret
                     the <u>in-string</u>s as ranges.

              <u>in-string</u> <u>command</u> ...
                     Bind  each  <u>in-string</u>  to  each  <u>command</u>.  When <b>-R</b> is used, interpret the <u>in-string</u>s as
                     ranges.

              [ <u>in-string</u> ]
                     List key bindings.  If an <u>in-string</u> is specified, the binding of  that  string  in  the
                     selected  keymap  is displayed.  Otherwise, all key bindings in the selected keymap are
                     displayed.  (As a special case, if the <b>-e</b> or <b>-v</b> option is used alone, the keymap is <u>not</u>
                     displayed - the implicit linking of keymaps is the only thing that happens.)

                     When the option <b>-p</b> is used, the <u>in-string</u> must be present.  The listing shows all bind-<font color="#ffffff" class="whiteout">ings&nbsp;bindings</font>
                     ings which have the given key sequence as a prefix, not including any bindings for  the
                     key sequence itself.

                     When  the  <b>-L</b> option is used, the list is in the form of <b>bindkey</b> commands to create the
                     key bindings.

       When the <b>-R</b> option is used as noted above, a valid range consists of two characters, with an optional
       `<b>-</b>' between them.  All characters between the two specified, inclusive, are bound as specified.

       For either <u>in-string</u> or <u>out-string</u>, the following escape sequences are recognised:

       <b>\a</b>     bell character
       <b>\b</b>     backspace
       <b>\e</b>, <b>\E</b> escape
       <b>\f</b>     form feed
       <b>\n</b>     linefeed (newline)
       <b>\r</b>     carriage return
       <b>\t</b>     horizontal tab
       <b>\v</b>     vertical tab
       <b>\</b><u>NNN</u>   character code in octal
       <b>\x</b><u>NN</u>   character code in hexadecimal
       <b>\M</b>[<b>-</b>]<u>X</u> character with meta bit set
       <b>\C</b>[<b>-</b>]<u>X</u> control character
       <b>^</b><u>X</u>     control character

       In  all  other  cases,  `<b>\</b>'  escapes  the following character.  Delete is written as `<b>^?</b>'.  Note that
       `<b>\M^?</b>' and `<b>^\M?</b>' are not the same, and that (unlike  emacs),  the  bindings  `<b>\M-</b><u>X</u>'  and  `<b>\e</b><u>X</u>'  are
       entirely distinct, although they are initialized to the same bindings by `<b>bindkey</b> <b>-m</b>'.

       <b>vared</b> [ <b>-Aache</b> ] [ <b>-p</b> <u>prompt</u> ] [ <b>-r</b> <u>rprompt</u> ]
         [ -M <u>main-keymap</u> ] [ -m <u>vicmd-keymap</u> ] <u>name</u>
              The  value  of  the  parameter  <u>name</u>  is  loaded  into the edit buffer, and the line editor is
              invoked.  When the editor exits, <u>name</u> is set to the string value returned by the editor.  When
              the  <b>-c</b>  flag is given, the parameter is created if it doesn't already exist.  The <b>-a</b> flag may
              be given with <b>-c</b> to create an array parameter, or the <b>-A</b> flag to create an associative  array.
              If  the  type of an existing parameter does not match the type to be created, the parameter is
              unset and recreated.

              If an array or array slice is being edited, separator characters as defined in  <b>$IFS</b>  will  be
              shown  quoted  with  a backslash, as will backslashes themselves.  Conversely, when the edited
              text is split into an array, a backslash quotes an immediately following  separator  character
              or  backslash;  no  other  special handling of backslashes, or any handling of quotes, is per-<font color="#ffffff" class="whiteout">formed.&nbsp;performed.</font>
              formed.

              Individual elements of existing array or associative array parameters may be edited  by  using
              subscript syntax on <u>name</u>.  New elements are created automatically, even without <b>-c</b>.

              If  the  <b>-p</b>  flag is given, the following string will be taken as the prompt to display at the
              left.  If the <b>-r</b> flag is given, the following string gives the prompt to display at the right.
              If  the  <b>-h</b>  flag is specified, the history can be accessed from ZLE. If the <b>-e</b> flag is given,
              typing <b>^D</b> (Control-D) on an empty line causes <b>vared</b> to exit immediately with a non-zero return
              value.

              The  <b>-M</b>  option  gives  a  keymap to link to the <b>main</b> keymap during editing, and the <b>-m</b> option
              gives a keymap to link to the <b>vicmd</b> keymap during editing.  For vi-style editing, this  allows
              a  pair  of keymaps to override <b>viins</b> and <b>vicmd</b>.  For emacs-style editing, only <b>-M</b> is normally
              needed but the <b>-m</b> option may still be used.  On exit, the previous keymaps will be restored.

       <b>zle</b>
       <b>zle</b> <b>-l</b> [ <b>-L</b> | <b>-a</b> ] [ <u>string</u> ... ]
       <b>zle</b> <b>-D</b> <u>widget</u> ...
       <b>zle</b> <b>-A</b> <u>old-widget</u> <u>new-widget</u>
       <b>zle</b> <b>-N</b> <u>widget</u> [ <u>function</u> ]
       <b>zle</b> <b>-C</b> <u>widget</u> <u>completion-widget</u> <u>function</u>
       <b>zle</b> <b>-R</b> [ <b>-c</b> ] [ <u>display-string</u> ] [ <u>string</u> ... ]
       <b>zle</b> <b>-M</b> <u>string</u>
       <b>zle</b> <b>-U</b> <u>string</u>
       <b>zle</b> <b>-K</b> <u>keymap</u>
       <b>zle</b> <b>-F</b> [ <b>-L</b> ] [ <u>fd</u> [ <u>handler</u> ] ]
       <b>zle</b> <b>-I</b>
       <b>zle</b> <u>widget</u> <b>[</b> <b>-n</b> <u>num</u> <b>]</b> <b>[</b> <b>-Nw</b> <b>]</b> <b>[</b> <b>-K</b> <u>keymap</u> <b>]</b> <u>args</u> ...
              The <b>zle</b> builtin performs a number of different actions concerning ZLE.

              With no options and no arguments, only the return status will be set.  It is zero  if  ZLE  is
              currently  active  and widgets could be invoked using this builtin command and non-zero other-<font color="#ffffff" class="whiteout">wise.&nbsp;otherwise.</font>
              wise.  Note that even if non-zero status is returned, zle may still be active as part  of  the
              completion system; this does not allow direct calls to ZLE widgets.

              Otherwise, which operation it performs depends on its options:

              <b>-l</b> [ <b>-L</b> | <b>-a</b> ]
                     List  all existing user-defined widgets.  If the <b>-L</b> option is used, list in the form of
                     <b>zle</b> commands to create the widgets.

                     When combined with the <b>-a</b> option, all widget names are listed,  including  the  builtin
                     ones. In this case the <b>-L</b> option is ignored.

                     If  at least one <u>string</u> is given, nothing will be printed but the return status will be
                     zero if all <u>string</u>s are names of existing widgets (or of user-defined widgets if the <b>-a</b>
                     flag is not given) and non-zero if at least one <u>string</u> is not a name of an defined wid-<font color="#ffffff" class="whiteout">get.&nbsp;widget.</font>
                     get.

              <b>-D</b> <u>widget</u> ...
                     Delete the named <u>widget</u>s.

              <b>-A</b> <u>old-widget</u> <u>new-widget</u>
                     Make the <u>new-widget</u> name an alias for <u>old-widget</u>, so that both names refer to the  same
                     widget.   The  names  have equal standing; if either is deleted, the other remains.  If
                     there is already a widget with the <u>new-widget</u> name, it is deleted.

              <b>-N</b> <u>widget</u> [ <u>function</u> ]
                     Create a user-defined widget.  If there is already a widget with the specified name, it
                     is  overwritten.   When the new widget is invoked from within the editor, the specified
                     shell <u>function</u> is called.  If no function name is specified, it defaults  to  the  same
                     name as the widget.  For further information, see the section <u>Widgets</u> in <u>zshzle</u>(1).

              <b>-C</b> <u>widget</u> <u>completion-widget</u> <u>function</u>
                     Create a user-defined completion widget named <u>widget</u>. The completion widget will behave
                     like the built-in completion-widget whose name is given as <u>completion-widget</u>. To gener-<font color="#ffffff" class="whiteout">ate&nbsp;generate</font>
                     ate  the completions, the shell function <u>function</u> will be called.  For further informa-<font color="#ffffff" class="whiteout">tion,&nbsp;information,</font>
                     tion, see <a href="zshcompwid.1.html#//apple_ref/doc/man/1/zshcompwid"><u>zshcompwid</u>(1)</a>.

              <b>-R</b> [ <b>-c</b> ] [ <u>display-string</u> ] [ <u>string</u> ... ]
                     Redisplay the command line; this is to be called from within a user-defined  widget  to
                     allow  changes  to become visible.  If a <u>display-string</u> is given and not empty, this is
                     shown in the status line (immediately below the line being edited).

                     If the optional <u>string</u>s are given they are listed below the prompt in the same  way  as
                     completion  lists are printed. If no <u>string</u>s are given but the <b>-c</b> option is used such a
                     list is cleared.

                     Note that this option is only useful for widgets that do  not  exit  immediately  after
                     using it because the strings displayed will be erased immediately after return from the
                     widget.

                     This command can safely be called outside user defined widgets; if zle is  active,  the
                     display  will  be refreshed, while if zle is not active, the command has no effect.  In
                     this case there will usually be no other arguments.

                     The status is zero if zle was active, else one.

              <b>-M</b> <u>string</u>
                     As with the <b>-R</b> option, the <u>string</u> will be displayed below the command line; unlike  the
                     <b>-R</b>  option, the string will not be put into the status line but will instead be printed
                     normally below the prompt.  This means that the <u>string</u> will still  be  displayed  after
                     the widget returns (until it is overwritten by subsequent commands).

              <b>-U</b> <u>string</u>
                     This pushes the characters in the <u>string</u> onto the input stack of ZLE.  After the widget
                     currently executed finishes ZLE will behave as if the characters  in  the  <u>string</u>  were
                     typed by the user.

                     As  ZLE uses a stack, if this option is used repeatedly the last string pushed onto the
                     stack will be processed first.  However, the characters in each  <u>string</u>  will  be  pro-<font color="#ffffff" class="whiteout">cessed&nbsp;processed</font>
                     cessed in the order in which they appear in the string.

              <b>-K</b> <u>keymap</u>
                     Selects  the  keymap  named  <u>keymap</u>.  An error message will be displayed if there is no
                     such keymap.

                     This keymap selection affects the interpretation of following  keystrokes  within  this
                     invocation  of  ZLE.  Any following invocation (e.g., the next command line) will start
                     as usual with the `<b>main</b>' keymap selected.

              <b>-F</b> [ <b>-L</b> ] [ <u>fd</u> [ <u>handler</u> ] ]
                     Only available if your system supports one of the `poll' or `select' system calls; most
                     modern systems do.

                     Installs  <u>handler</u>  (the  name of a shell function) to handle input from file descriptor
                     <u>fd</u>.  When zle is attempting to read data, it will examine both  the  terminal  and  the
                     list of handled <u>fd</u>'s.  If data becomes available on a handled <u>fd</u>, zle will call <u>handler</u>
                     with the fd which is ready for reading as the only argument.  If the  handler  produces
                     output  to the terminal, it should call `<b>zle</b> <b>-I</b>' before doing so (see below).  The han-<font color="#ffffff" class="whiteout">dler&nbsp;handler</font>
                     dler should not attempt to read from the terminal.  Note that zle makes no  attempt  to
                     check  whether this fd is actually readable when installing the handler.  The user must
                     make their own arrangements for handling the file descriptor when zle is not active.

                     Any number of handlers for any number of readable file descriptors  may  be  installed.
                     Installing  a handler for an <u>fd</u> which is already handled causes the existing handler to
                     be replaced.

                     If no <u>handler</u> is given, but an <u>fd</u> is present, any handler for that <u>fd</u> is  removed.   If
                     there is none, an error message is printed and status 1 is returned.

                     If  no arguments are given, or the <b>-L</b> option is supplied, a list of handlers is printed
                     in a form which can be stored for later execution.

                     An <u>fd</u> (but not a <u>handler</u>) may optionally be given with the <b>-L</b> option; in this case, the
                     function will list the handler if any, else silently return status 1.

                     Note  that this feature should be used with care.  Activity on one of the <u>fd</u>'s which is
                     not properly handled can cause the terminal to become unusable.

                     Here is a simple example of using this feature.  A connection to a remote TCP  port  is
                     created  using  the ztcp command; see the description of the <b>zsh/net/tcp</b> module in <a href="zshmodules.1.html#//apple_ref/doc/man/1/zshmodules"><u>zsh</u></a>-<font color="#ffffff" class="whiteout">modules(1).&nbsp;zshmodules(1).</font>
                     <a href="zshmodules.1.html#//apple_ref/doc/man/1/zshmodules"><u>modules</u>(1)</a>.  Then a handler is installed which simply prints out any data which arrives
                     on  this  connection.   Note that `select' will indicate that the file descriptor needs
                     handling if the remote side has closed the connection; we handle that by testing for  a
                     failed read.
                            <b>if</b> <b>ztcp</b> <b>pwspc</b> <b>2811;</b> <b>then</b>
                              <b>tcpfd=$REPLY</b>
                              <b>handler()</b> <b>{</b>
                                <b>zle</b> <b>-I</b>
                                <b>local</b> <b>line</b>
                                <b>if</b> <b>!</b> <b>read</b> <b>-r</b> <b>line</b> <b>&lt;&amp;$1;</b> <b>then</b>
                                  <b>#</b> <b>select</b> <b>marks</b> <b>this</b> <b>fd</b> <b>if</b> <b>we</b> <b>reach</b> <b>EOF,</b>
                                  <b>#</b> <b>so</b> <b>handle</b> <b>this</b> <b>specially.</b>
                                  <b>print</b> <b>"[Read</b> <b>on</b> <b>fd</b> <b>$1</b> <b>failed,</b> <b>removing.]"</b> <b>&gt;&amp;2</b>
                                  <b>zle</b> <b>-F</b> <b>$1</b>
                                  <b>return</b> <b>1</b>
                                <b>fi</b>
                                <b>print</b> <b>-r</b> <b>-</b> <b>$line</b>
                              <b>}</b>
                              <b>zle</b> <b>-F</b> <b>$tcpfd</b> <b>handler</b>
                            <b>fi</b>

              <b>-I</b>     Unusually,  this option is most useful outside ordinary widget functions, though it may
                     be used within if normal output to the terminal is required.  It invalidates  the  cur-<font color="#ffffff" class="whiteout">rent&nbsp;current</font>
                     rent  zle  display  in preparation for output; typically this will be from a trap func-<font color="#ffffff" class="whiteout">tion.&nbsp;function.</font>
                     tion.  It has no effect if zle is not active.  When a trap exits, the shell  checks  to
                     see if the display needs restoring, hence the following will print output in such a way
                     as not to disturb the line being edited:

                            <b>TRAPUSR1()</b> <b>{</b>
                                <b>#</b> <b>Invalidate</b> <b>zle</b> <b>display</b>
                              <b>[[</b> <b>-o</b> <b>zle</b> <b>]]</b> <b>&amp;&amp;</b> <b>zle</b> <b>-I</b>
                                <b>#</b> <b>Show</b> <b>output</b>
                              <b>print</b> <b>Hello</b>
                            <b>}</b>

                     In general, the trap function may need to test whether zle is active before using  this
                     method  (as  shown in the example), since the <b>zsh/zle</b> module may not even be loaded; if
                     it is not, the command can be skipped.

                     It is possible to call `<b>zle</b> <b>-I</b>' several times before control is returned to the editor;
                     the display will only be invalidated the first time to minimise disruption.

                     Note  that  there  are normally better ways of manipulating the display from within zle
                     widgets; see, for example, `<b>zle</b> <b>-R</b>' above.

                     The returned status is zero if zle was invalidated, even though this may have been by a
                     previous  call to `<b>zle</b> <b>-I</b>' or by a system notification.  To test if a zle widget may be
                     called at this point, execute <b>zle</b> with no arguments and examine the return status.

              <u>widget</u> <b>[</b> <b>-n</b> <u>num</u> <b>]</b> <b>[</b> <b>-Nw</b> <b>]</b> <b>[</b> <b>-K</b> <u>keymap</u> <b>]</b> <u>args</u> ...
                     Invoke the specified widget.  This can only be done when ZLE is active;  normally  this
                     will be within a user-defined widget.

                     With  the  options  <b>-n</b>  and  <b>-N</b>,  the current numerical argument will be saved and then
                     restored after the call to <b>widget</b>; `<b>-n</b> <u>num</u>' sets the numerical argument temporarily  to
                     <u>num</u>, while `<b>-N</b>' sets it to the default, i.e. as if there were none.

                     With  the  option <b>-K</b>, <u>keymap</u> will be used as the current keymap during the execution of
                     the widget.  The previous keymap will be restored when the widget exits.

                     Normally, calling a widget in this way does not set the special  parameter  <b>WIDGET</b>  and
                     related  parameters,  so that the environment appears as if the top-level widget called
                     by the user were still active.  With the option <b>-w</b>, <b>WIDGET</b> and related  parameters  are
                     set to reflect the widget being executed by the <b>zle</b> call.

                     Any  further  arguments will be passed to the widget.  If it is a shell function, these
                     are passed down as positional parameters; for builtin widgets it is up to the widget in
                     question what it does with them.  Currently arguments are only handled by the incremen-<font color="#ffffff" class="whiteout">tal-search&nbsp;incremental-search</font>
                     tal-search commands, the <b>history-search-forward</b> and  <b>-backward</b>  and  the  corresponding
                     functions  prefixed by <b>vi-</b>, and by <b>universal-argument</b>.  No error is flagged if the com-<font color="#ffffff" class="whiteout">mand&nbsp;command</font>
                     mand does not use the arguments, or only uses some of them.

                     The return status reflects the success or failure of the operation carried out  by  the
                     widget, or if it is a user-defined widget the return status of the shell function.

                     A  non-zero  return  status  causes the shell to beep when the widget exits, unless the
                     <b>BEEP</b> options was unset or the widget was called via the <b>zle</b> command.  Thus  if  a  user
                     defined widget requires an immediate beep, it should call the <b>beep</b> widget directly.


<b>WIDGETS</b>
       All actions in the editor are performed by `widgets'.  A widget's job is simply to perform some small
       action.  The ZLE commands that key sequences in keymaps are bound to are in  fact  widgets.   Widgets
       can be user-defined or built in.

       The  standard  widgets  built in to ZLE are listed in Standard Widgets below.  Other built-in widgets
       can be defined by other modules (see <a href="zshmodules.1.html#//apple_ref/doc/man/1/zshmodules"><u>zshmodules</u>(1)</a>).  Each built-in widget has two names: its  normal
       canonical name, and the same name preceded by a `<b>.</b>'.  The `<b>.</b>' name is special: it can't be rebound to
       a different widget.  This makes the widget available even when its usual name has been redefined.

       User-defined widgets are defined using `<b>zle</b> <b>-N</b>', and implemented as shell functions.  When the widget
       is  executed,  the  corresponding  shell  function  is  executed,  and can perform editing (or other)
       actions.  It is recommended that user-defined widgets should not have names starting with `<b>.</b>'.

<b>USER\-DEFINED</b> <b>WIDGETS</b>
       User-defined widgets, being implemented as shell functions, can execute  any  normal  shell  command.
       They  can  also  run  other widgets (whether built-in or user-defined) using the <b>zle</b> builtin command.
       The standard input of the function is closed to prevent external commands from unintentionally block-<font color="#ffffff" class="whiteout">ing&nbsp;blocking</font>
       ing  ZLE  by  reading  from  the  terminal,  but  <b>read</b>  <b>-k</b> or <b>read</b> <b>-q</b> can be used to read characters.
       Finally, they can examine and edit the ZLE buffer being edited by reading  and  setting  the  special
       parameters described below.

       These  special  parameters  are  always available in widget functions, but are not in any way special
       outside ZLE.  If they have some normal value outside ZLE, that value is temporarily inaccessible, but
       will  return when the widget function exits.  These special parameters in fact have local scope, like
       parameters created in a function using <b>local</b>.

       Inside completion widgets and traps called while  ZLE  is  active,  these  parameters  are  available
       read-only.

       <b>BUFFER</b> (scalar)
              The  entire  contents of the edit buffer.  If it is written to, the cursor remains at the same
              offset, unless that would put it outside the buffer.

       <b>BUFFERLINES</b> (integer)
              The number of screen lines needed for the edit buffer  currently  displayed  on  screen  (i.e.
              without any changes to the preceding parameters done after the last redisplay); read-only.

       <b>CONTEXT</b> (scalar)
              The context in which zle was called to read a line; read-only.  One of the values:
       start  The start of a command line (at prompt <b>PS1</b>).

       cont   A continuation to a command line (at prompt <b>PS2</b>).

       select In a <b>select</b> loop.

       vared  Editing a variable in <b>vared</b>.

       <b>CURSOR</b> (integer)
              The  offset of the cursor, within the edit buffer.  This is in the range 0 to <b>$#BUFFER</b>, and is
              by definition equal to <b>$#LBUFFER</b>.  Attempts to move the cursor outside the buffer will  result
              in the cursor being moved to the appropriate end of the buffer.

       <b>CUTBUFFER</b> (scalar)
              The  last  item  to  be  cut using one of the `<b>kill-</b>' commands; the string which the next yank
              would insert in the line.  Later entries in the kill ring are in the array <b>killring</b>.

       <b>HISTNO</b> (integer)
              The current history number.  Setting this has the same effect as moving up or down in the his-<font color="#ffffff" class="whiteout">tory&nbsp;history</font>
              tory  to  the  corresponding history line.  An attempt to set it is ignored if the line is not
              stored in the history.  Note this is not the same as the parameter <b>HISTCMD</b>, which always gives
              the  number of the history line being added to the main shell's history.  <b>HISTNO</b> refers to the
              line being retrieved within zle.

       <b>KEYMAP</b> (scalar)
              The name of the currently selected keymap; read-only.

       <b>KEYS</b> (scalar)
              The keys typed to invoke this widget, as a literal string; read-only.

       <b>killring</b> (array)
              The array of previously killed items, with the most recently killed  first.   This  gives  the
              items  that  would be retrieved by a <b>yank-pop</b> in the same order.  Note, however, that the most
              recently killed item is in <b>$CUTBUFFER</b>; <b>$killring</b> shows the array of previous entries.

              The default size for the kill ring is eight, however the length may be changed by normal array
              operations.   Any  empty string in the kill ring is ignored by the <b>yank-pop</b> command, hence the
              size of the array effectively sets the maximum length of the kill ring, while  the  number  of
              non-zero strings gives the current length, both as seen by the user at the command line.


       <b>LASTSEARCH</b> (scalar)
              The last search string used by an interactive search ; read-only.

       <b>LASTWIDGET</b> (scalar)
              The name of the last widget that was executed; read-only.

       <b>LBUFFER</b> (scalar)
              The  part  of  the buffer that lies to the left of the cursor position.  If it is assigned to,
              only that part of the buffer is replaced, and the cursor remains between the new <b>$LBUFFER</b>  and
              the old <b>$RBUFFER</b>.

       <b>MARK</b> (integer)
              Like <b>CURSOR</b>, but for the mark.

       <b>NUMERIC</b> (integer)
              The  numeric argument. If no numeric argument was given, this parameter is unset. When this is
              set inside a widget function, builtin widgets called with the <b>zle</b> builtin command will use the
              value  assigned.  If it is unset inside a widget function, builtin widgets called behave as if
              no numeric argument was given.

       <b>PENDING</b> (integer)
              The number of bytes pending for input, i.e. the number of bytes which have already been  typed
              and  can  immediately be read. On systems where the shell is not able to get this information,
              this parameter will always have a value of zero.  Read-only.

       <b>PREBUFFER</b> (scalar)
              In a multi-line input at the secondary prompt, this read-only parameter contains the  contents
              of the lines before the one the cursor is currently in.

       <b>PREDISPLAY</b> (scalar)
              Text to be displayed before the start of the editable text buffer.  This does not have to be a
              complete line; to display a complete line, a newline must be appended explicitly.    The  text
              is reset on each new invocation (but not recursive invocation) of zle.

       <b>POSTDISPLAY</b> (scalar)
              Text  to  be  displayed after the end of the editable text buffer.  This does not have to be a
              complete line; to display a complete line, a newline must be prepended explicitly.   The  text
              is reset on each new invocation (but not recursive invocation) of zle.

       <b>RBUFFER</b> (scalar)
              The  part  of the buffer that lies to the right of the cursor position.  If it is assigned to,
              only that part of the buffer is replaced, and the cursor remains between the old <b>$LBUFFER</b>  and
              the new <b>$RBUFFER</b>.

       <b>WIDGET</b> (scalar)
              The name of the widget currently being executed; read-only.

       <b>WIDGETFUNC</b> (scalar)
              The  name of the shell function that implements a widget defined with either <b>zle</b> <b>-N</b> or <b>zle</b> <b>-C</b>.
              In the former case, this is the second argument to the <b>zle</b> <b>-N</b> command that defined the widget,
              or  the  first  argument  if there was no second argument.  In the latter case this is the the
              third argument to the <b>zle</b> <b>-C</b> command that defined the widget.  Read-only.

       <b>WIDGETSTYLE</b> (scalar)
              Describes the implementation behind the completion widget currently being executed; the second
              argument that followed <b>zle</b> <b>-C</b> when the widget was defined.  This is the name of a builtin com-<font color="#ffffff" class="whiteout">pletion&nbsp;completion</font>
              pletion widget.  For widgets defined with <b>zle</b> <b>-N</b> this is set to the empty string.   Read-only.


   <b>Special</b> <b>Widget</b>
       There  are  a few user-defined widgets which are special to the shell.  If they do not exist, no spe-<font color="#ffffff" class="whiteout">cial&nbsp;special</font>
       cial action is taken.  The environment provided is identical to that for any other editing widget.

       <b>zle-line-init</b>
              Executed every time the line editor is started to read a new line  of  input.   The  following
              example puts the line editor into vi command mode when it starts up.

                     <b>zle-line-init()</b> <b>{</b> <b>zle</b> <b>-K</b> <b>vicmd;</b> <b>}</b>
                     <b>zle</b> <b>-N</b> <b>zle-line-init</b>

              (The  command  inside  the  function  sets  the  keymap  directly;  it  is  equivalent  to <b>zle</b>
              <b>vi-cmd-mode</b>.)

       <b>zle-keymap-select</b>
              Executed every time the keymap changes, i.e. the special parameter <b>KEYMAP</b> is set to a  differ-<font color="#ffffff" class="whiteout">ent&nbsp;different</font>
              ent  value,  while  the  line  editor is active.  Initialising the keymap when the line editor
              starts does not cause the widget to be called.

              The value <b>$KEYMAP</b> within the function reflects the new keymap.  The old keymap  is  passed  as
              the sole argument.

              This  can  been used for detecting switches between the vi command (<b>vicmd</b>) and insert (usually
              <b>main</b>) keymaps.


<b>STANDARD</b> <b>WIDGETS</b>
       The following is a list of all the standard widgets, and their default bindings  in  emacs  mode,  vi
       command mode and vi insert mode (the `<b>emacs</b>', `<b>vicmd</b>' and `<b>viins</b>' keymaps, respectively).

       Note  that  cursor  keys  are bound to movement keys in all three keymaps; the shell assumes that the
       cursor keys send the key sequences reported by the terminal-handling library (termcap  or  terminfo).
       The  key  sequences  shown in the list are those based on the VT100, common on many modern terminals,
       but in fact these are not necessarily bound.  In the case of the <b>viins</b>  keymap,  the  initial  escape
       character  of the sequences serves also to return to the <b>vicmd</b> keymap: whether this happens is deter-<font color="#ffffff" class="whiteout">mined&nbsp;determined</font>
       mined by the <b>KEYTIMEOUT</b> parameter, see <a href="zshparam.1.html#//apple_ref/doc/man/1/zshparam"><u>zshparam</u>(1)</a>.

   <b>Movement</b>
       <b>vi-backward-blank-word</b> (unbound) (B) (unbound)
              Move backward one word, where a word is defined as a series of non-blank characters.

       <b>backward-char</b> (^B ESC-[D) (unbound) (unbound)
              Move backward one character.

       <b>vi-backward-char</b> (unbound) (^H h ^?) (ESC-[D)
              Move backward one character, without changing lines.

       <b>backward-word</b> (ESC-B ESC-b) (unbound) (unbound)
              Move to the beginning of the previous word.

       <b>emacs-backward-word</b>
              Move to the beginning of the previous word.

       <b>vi-backward-word</b> (unbound) (b) (unbound)
              Move to the beginning of the previous word, vi-style.

       <b>beginning-of-line</b> (^A) (unbound) (unbound)
              Move to the beginning of the line.  If already at the beginning  of  the  line,  move  to  the
              beginning of the previous line, if any.

       <b>vi-beginning-of-line</b>
              Move to the beginning of the line, without changing lines.

       <b>end-of-line</b> (^E) (unbound) (unbound)
              Move  to  the end of the line.  If already at the end of the line, move to the end of the next
              line, if any.

       <b>vi-end-of-line</b> (unbound) ($) (unbound)
              Move to the end of the line.  If an argument is given to this  command,  the  cursor  will  be
              moved to the end of the line (argument - 1) lines down.

       <b>vi-forward-blank-word</b> (unbound) (W) (unbound)
              Move forward one word, where a word is defined as a series of non-blank characters.

       <b>vi-forward-blank-word-end</b> (unbound) (E) (unbound)
              Move  to the end of the current word, or, if at the end of the current word, to the end of the
              next word, where a word is defined as a series of non-blank characters.

       <b>forward-char</b> (^F ESC-[C) (unbound) (unbound)
              Move forward one character.

       <b>vi-forward-char</b> (unbound) (space l) (ESC-[C)
              Move forward one character.

       <b>vi-find-next-char</b> (^X^F) (f) (unbound)
              Read a character from the keyboard, and move to the next occurrence of it in the line.

       <b>vi-find-next-char-skip</b> (unbound) (t) (unbound)
              Read a character from the keyboard, and move to the position just before the  next  occurrence
              of it in the line.

       <b>vi-find-prev-char</b> (unbound) (F) (unbound)
              Read a character from the keyboard, and move to the previous occurrence of it in the line.

       <b>vi-find-prev-char-skip</b> (unbound) (T) (unbound)
              Read  a  character  from the keyboard, and move to the position just after the previous occur-<font color="#ffffff" class="whiteout">rence&nbsp;occurrence</font>
              rence of it in the line.

       <b>vi-first-non-blank</b> (unbound) (^) (unbound)
              Move to the first non-blank character in the line.

       <b>vi-forward-word</b> (unbound) (w) (unbound)
              Move forward one word, vi-style.

       <b>forward-word</b> (ESC-F ESC-f) (unbound) (unbound)
              Move to the beginning of the next word.  The editor's idea of a word  is  specified  with  the
              <b>WORDCHARS</b> parameter.

       <b>emacs-forward-word</b>
              Move to the end of the next word.

       <b>vi-forward-word-end</b> (unbound) (e) (unbound)
              Move to the end of the next word.

       <b>vi-goto-column</b> (ESC-|) (|) (unbound)
              Move to the column specified by the numeric argument.

       <b>vi-goto-mark</b> (unbound) (`) (unbound)
              Move to the specified mark.

       <b>vi-goto-mark-line</b> (unbound) (') (unbound)
              Move to beginning of the line containing the specified mark.

       <b>vi-repeat-find</b> (unbound) (;) (unbound)
              Repeat the last <b>vi-find</b> command.

       <b>vi-rev-repeat-find</b> (unbound) (,) (unbound)
              Repeat the last <b>vi-find</b> command in the opposite direction.

   <b>History</b> <b>Control</b>
       <b>beginning-of-buffer-or-history</b> (ESC-&lt;) (unbound) (unbound)
              Move  to the beginning of the buffer, or if already there, move to the first event in the his-
              tory list.

       <b>beginning-of-line-hist</b>
              Move to the beginning of the line.  If already at the beginning of the  buffer,  move  to  the
              previous history line.

       <b>beginning-of-history</b>
              Move to the first event in the history list.

       <b>down-line-or-history</b> (^N ESC-[B) (j) (ESC-[B)
              Move  down  a  line in the buffer, or if already at the bottom line, move to the next event in
              the history list.

       <b>vi-down-line-or-history</b> (unbound) (+) (unbound)
              Move down a line in the buffer, or if already at the bottom line, move to the  next  event  in
              the history list.  Then move to the first non-blank character on the line.

       <b>down-line-or-search</b>
              Move  down  a line in the buffer, or if already at the bottom line, search forward in the his-<font color="#ffffff" class="whiteout">tory&nbsp;history</font>
              tory for a line beginning with the first word in the buffer.

              If called from a function by the <b>zle</b> command with arguments, the first argument  is  taken  as
              the string for which to search, rather than the first word in the buffer.

       <b>down-history</b> (unbound) (^N) (unbound)
              Move to the next event in the history list.

       <b>history-beginning-search-backward</b>
              Search  backward  in  the history for a line beginning with the current line up to the cursor.
              This leaves the cursor in its original position.

       <b>end-of-buffer-or-history</b> (ESC-&gt;) (unbound) (unbound)
              Move to the end of the buffer, or if already there, move to the  last  event  in  the  history
              list.

       <b>end-of-line-hist</b>
              Move  to  the  end of the line.  If already at the end of the buffer, move to the next history
              line.

       <b>end-of-history</b>
              Move to the last event in the history list.

       <b>vi-fetch-history</b> (unbound) (G) (unbound)
              Fetch the history line specified by the numeric argument.  This defaults to the  current  his-<font color="#ffffff" class="whiteout">tory&nbsp;history</font>
              tory line (i.e. the one that isn't history yet).

       <b>history-incremental-search-backward</b> (^R ^Xr) (unbound) (unbound)
              Search  backward  incrementally for a specified string.  The search is case-insensitive if the
              search string does not have uppercase letters and no numeric argument was given.   The  string
              may begin with `<b>^</b>' to anchor the search to the beginning of the line.

              A  restricted  set of editing functions is available in the mini-buffer.  An interrupt signal,
              as defined by the stty setting, will stop the search and go back to  the  original  line.   An
              undefined  key  will  have the same effect. The supported functions are: <b>backward-delete-char</b>,
              <b>vi-backward-delete-char</b>,    <b>clear-screen</b>,    <b>redisplay</b>,    <b>quoted-insert</b>,    <b>vi-quoted-insert</b>,
              <b>accept-and-hold</b>,  <b>accept-and-infer-next-history</b>, <b>accept-line</b> and <b>accept-line-and-down-history</b>.

              <b>magic-space</b> just inserts a space.  <b>vi-cmd-mode</b> toggles between the `<b>main</b>' and `<b>vicmd</b>' keymaps;
              the  `<b>main</b>' keymap (insert mode) will be selected initially.  <b>history-incremental-search-back</b>-<font color="#ffffff" class="whiteout">ward&nbsp;history-incremental-search-backward</font>
              <b>ward</b> will get the next occurrence of  the  contents  of  the  mini-buffer.   <b>history-incremen</b>-<font color="#ffffff" class="whiteout">tal-search-forward&nbsp;history-incremental-search-forward</font>
              <b>tal-search-forward</b> inverts the sense of the search.  <b>vi-repeat-search</b> and <b>vi-rev-repeat-search</b>
              are similarly supported.  The direction of the search is indicated in the mini-buffer.

              Any multi-character string that is not bound to one of  the  above  functions  will  beep  and
              interrupt  the search, leaving the last found line in the buffer. Any single character that is
              not bound to one of the above functions, or <b>self-insert</b> or <b>self-insert-unmeta</b>, will  have  the
              same effect but the function will be executed.

              When  called  from  a  widget function by the <b>zle</b> command, the incremental search commands can
              take a string argument.  This will be treated as a string of keys, as  for  arguments  to  the
              <b>bindkey</b>  command,  and  used  as  initial input for the command.  Any characters in the string
              which are unused by the incremental search will be silently ignored.  For example,

                     <b>zle</b> <b>history-incremental-search-backward</b> <b>forceps</b>

              will search backwards for <b>forceps</b>, leaving the minibuffer containing the string `<b>forceps</b>'.

       <b>history-incremental-search-forward</b> (^S ^Xs) (unbound) (unbound)
              Search forward incrementally for a specified string.  The search is  case-insensitive  if  the
              search  string  does not have uppercase letters and no numeric argument was given.  The string
              may begin with `<b>^</b>' to anchor the search to the beginning of the line.  The functions available
              in the mini-buffer are the same as for <b>history-incremental-search-backward</b>.

       <b>history-search-backward</b> (ESC-P ESC-p) (unbound) (unbound)
              Search backward in the history for a line beginning with the first word in the buffer.

              If  called  from  a function by the <b>zle</b> command with arguments, the first argument is taken as
              the string for which to search, rather than the first word in the buffer.

       <b>vi-history-search-backward</b> (unbound) (/) (unbound)
              Search backward in the history for a specified string.  The  string  may  begin  with  `<b>^</b>'  to
              anchor the search to the beginning of the line.

              A  restricted  set of editing functions is available in the mini-buffer.  An interrupt signal,
              as defined by the stty setting,  will  stop  the  search.   The  functions  available  in  the
              mini-buffer    are:    <b>accept-line</b>,   <b>backward-delete-char</b>,   <b>vi-backward-delete-char</b>,   <b>back</b>-<font color="#ffffff" class="whiteout">ward-kill-word,&nbsp;backward-kill-word,</font>
              <b>ward-kill-word</b>,   <b>vi-backward-kill-word</b>,   <b>clear-screen</b>,    <b>redisplay</b>,    <b>quoted-insert</b>    and
              <b>vi-quoted-insert</b>.

              <b>vi-cmd-mode</b>  is  treated  the same as accept-line, and <b>magic-space</b> is treated as a space.  Any
              other character that is not bound to  self-insert  or  self-insert-unmeta  will  beep  and  be
              ignored.  If  the  function is called from vi command mode, the bindings of the current insert
              mode will be used.

              If called from a function by the <b>zle</b> command with arguments, the first argument  is  taken  as
              the string for which to search, rather than the first word in the buffer.

       <b>history-search-forward</b> (ESC-N ESC-n) (unbound) (unbound)
              Search forward in the history for a line beginning with the first word in the buffer.

              If  called  from  a function by the <b>zle</b> command with arguments, the first argument is taken as
              the string for which to search, rather than the first word in the buffer.

       <b>vi-history-search-forward</b> (unbound) (?) (unbound)
              Search forward in the history for a specified string.  The string may begin with `<b>^</b>' to anchor
              the  search  to  the beginning of the line. The functions available in the mini-buffer are the
              same as for <b>vi-history-search-backward</b>.  Argument handling is also the same as for  that  com-<font color="#ffffff" class="whiteout">mand.&nbsp;command.</font>
              mand.

       <b>infer-next-history</b> (^X^N) (unbound) (unbound)
              Search  in  the history list for a line matching the current one and fetch the event following
              it.

       <b>insert-last-word</b> (ESC-_ ESC-.) (unbound) (unbound)
              Insert the last word from the previous history event at the cursor position.   If  a  positive
              numeric  argument  is  given, insert that word from the end of the previous history event.  If
              the argument is zero or negative insert that word from the left  (zero  inserts  the  previous
              command word).  Repeating this command replaces the word just inserted with the last word from
              the history event prior to the one just used; numeric arguments can be used in the same way to
              pick a word from that event.

              When called from a shell function invoked from a user-defined widget, the command can take one
              to three arguments.  The first argument specifies a history offset which applies to successive
              calls  to  this  widget: if is -1, the default behaviour is used, while if it is 1, successive
              calls will move forwards through the history.  The value 0 can be used to  indicate  that  the
              history  line examined by the previous execution of the command will be reexamined.  Note that
              negative numbers should be preceded with a `<b>--</b>' argument to avoid confusing them with options.

              If  two arguments are given, the second specifies the word on the command line in normal array
              index notation (as a more natural alternative to the prefix argument).  Hence 1 is  the  first
              word, and -1 (the default) is the last word.

              If a third argument is given, its value is ignored, but it is used to signify that the history
              offset is relative to the current history line, rather than the one remembered after the  pre-<font color="#ffffff" class="whiteout">vious&nbsp;previous</font>
              vious invocations of <b>insert-last-word</b>.

              For example, the default behaviour of the command corresponds to

                     <b>zle</b> <b>insert-last-word</b> <b>--</b> <b>-1</b> <b>-1</b>

              while the command

                     <b>zle</b> <b>insert-last-word</b> <b>--</b> <b>-1</b> <b>1</b> <b></b>-<font color="#ffffff" class="whiteout">always&nbsp;1always</font>

              always  copies  the  first  word  of the line in the history immediately before the line being
              edited.  This has the side effect that later invocations of the widget  will  be  relative  to
              that line.

       <b>vi-repeat-search</b> (unbound) (n) (unbound)
              Repeat the last vi history search.

       <b>vi-rev-repeat-search</b> (unbound) (N) (unbound)
              Repeat the last vi history search, but in reverse.

       <b>up-line-or-history</b> (^P ESC-[A) (k) (ESC-[A)
              Move up a line in the buffer, or if already at the top line, move to the previous event in the
              history list.

       <b>vi-up-line-or-history</b> (unbound) (-) (unbound)
              Move up a line in the buffer, or if already at the top line, move to the previous event in the
              history list.  Then move to the first non-blank character on the line.

       <b>up-line-or-search</b>
              Move  up  a  line in the buffer, or if already at the top line, search backward in the history
              for a line beginning with the first word in the buffer.

              If called from a function by the <b>zle</b> command with arguments, the first argument  is  taken  as
              the string for which to search, rather than the first word in the buffer.

       <b>up-history</b> (unbound) (^P) (unbound)
              Move to the previous event in the history list.

       <b>history-beginning-search-forward</b>
              Search  forward  in  the  history for a line beginning with the current line up to the cursor.
              This leaves the cursor in its original position.

   <b>Modifying</b> <b>Text</b>
       <b>vi-add-eol</b> (unbound) (A) (unbound)
              Move to the end of the line and enter insert mode.

       <b>vi-add-next</b> (unbound) (a) (unbound)
              Enter insert mode after the current cursor position, without changing lines.

       <b>backward-delete-char</b> (^H ^?) (unbound) (unbound)
              Delete the character behind the cursor.

       <b>vi-backward-delete-char</b> (unbound) (X) (^H)
              Delete the character behind the cursor, without changing lines.  If in insert mode, this won't
              delete past the point where insert mode was last entered.

       <b>backward-delete-word</b>
              Delete the word behind the cursor.

       <b>backward-kill-line</b>
              Kill from the beginning of the line to the cursor position.

       <b>backward-kill-word</b> (^W ESC-^H ESC-^?) (unbound) (unbound)
              Kill the word behind the cursor.

       <b>vi-backward-kill-word</b> (unbound) (unbound) (^W)
              Kill  the  word  behind  the  cursor,  without going past the point where insert mode was last
              entered.

       <b>capitalize-word</b> (ESC-C ESC-c) (unbound) (unbound)
              Capitalize the current word and move past it.

       <b>vi-change</b> (unbound) (c) (unbound)
              Read a movement command from the keyboard, and kill from the cursor position to  the  endpoint
              of  the  movement.   Then  enter insert mode.  If the command is <b>vi-change</b>, change the current
              line.

       <b>vi-change-eol</b> (unbound) (C) (unbound)
              Kill to the end of the line and enter insert mode.

       <b>vi-change-whole-line</b> (unbound) (S) (unbound)
              Kill the current line and enter insert mode.

       <b>copy-region-as-kill</b> (ESC-W ESC-w) (unbound) (unbound)
              Copy the area from the cursor to the mark to the kill buffer.

       <b>copy-prev-word</b> (ESC-^_) (unbound) (unbound)
              Duplicate the word to the left of the cursor.

       <b>copy-prev-shell-word</b>
              Like <b>copy-prev-word</b>, but the word is found by  using  shell  parsing,  whereas  <b>copy-prev-word</b>
              looks for blanks. This makes a difference when the word is quoted and contains spaces.

       <b>vi-delete</b> (unbound) (d) (unbound)
              Read  a  movement command from the keyboard, and kill from the cursor position to the endpoint
              of the movement.  If the command is <b>vi-delete</b>, kill the current line.

       <b>delete-char</b>
              Delete the character under the cursor.

       <b>vi-delete-char</b> (unbound) (x) (unbound)
              Delete the character under the cursor, without going past the end of the line.

       <b>delete-word</b>
              Delete the current word.

       <b>down-case-word</b> (ESC-L ESC-l) (unbound) (unbound)
              Convert the current word to all lowercase and move past it.

       <b>kill-word</b> (ESC-D ESC-d) (unbound) (unbound)
              Kill the current word.

       <b>gosmacs-transpose-chars</b>
              Exchange the two characters behind the cursor.

       <b>vi-indent</b> (unbound) (&gt;) (unbound)
              Indent a number of lines.

       <b>vi-insert</b> (unbound) (i) (unbound)
              Enter insert mode.

       <b>vi-insert-bol</b> (unbound) (I) (unbound)
              Move to the first non-blank character on the line and enter insert mode.

       <b>vi-join</b> (^X^J) (J) (unbound)
              Join the current line with the next one.

       <b>kill-line</b> (^K) (unbound) (unbound)
              Kill from the cursor to the end of the line.  If already on the end of the line, kill the new-<font color="#ffffff" class="whiteout">line&nbsp;newline</font>
              line character.

       <b>vi-kill-line</b> (unbound) (unbound) (^U)
              Kill from the cursor back to wherever insert mode was last entered.

       <b>vi-kill-eol</b> (unbound) (D) (unbound)
              Kill from the cursor to the end of the line.

       <b>kill-region</b>
              Kill from the cursor to the mark.

       <b>kill-buffer</b> (^X^K) (unbound) (unbound)
              Kill the entire buffer.

       <b>kill-whole-line</b> (^U) (unbound) (unbound)
              Kill the current line.

       <b>vi-match-bracket</b> (^X^B) (%) (unbound)
              Move to the bracket character (one of <b>{}</b>, <b>()</b> or <b>[]</b>) that matches the one under the cursor.  If
              the cursor is not on a bracket character, move forward without going past the end of the  line
              to find one, and then go to the matching bracket.

       <b>vi-open-line-above</b> (unbound) (O) (unbound)
              Open a line above the cursor and enter insert mode.

       <b>vi-open-line-below</b> (unbound) (o) (unbound)
              Open a line below the cursor and enter insert mode.

       <b>vi-oper-swap-case</b>
              Read a movement command from the keyboard, and swap the case of all characters from the cursor
              position to the endpoint of the movement.  If the movement command is <b>vi-oper-swap-case</b>,  swap
              the case of all characters on the current line.

       <b>overwrite-mode</b> (^X^O) (unbound) (unbound)
              Toggle between overwrite mode and insert mode.

       <b>vi-put-before</b> (unbound) (P) (unbound)
              Insert  the  contents  of  the  kill  buffer before the cursor.  If the kill buffer contains a
              sequence of lines (as opposed to characters), paste it above the current line.

       <b>vi-put-after</b> (unbound) (p) (unbound)
              Insert the contents of the kill buffer after the  cursor.   If  the  kill  buffer  contains  a
              sequence of lines (as opposed to characters), paste it below the current line.

       <b>quoted-insert</b> (^V) (unbound) (unbound)
              Insert the next character typed into the buffer literally.  An interrupt character will not be
              inserted.

       <b>vi-quoted-insert</b> (unbound) (unbound) (^Q ^V)
              Display a `<b>^</b>' at the cursor position, and insert the next character typed into the buffer lit-<font color="#ffffff" class="whiteout">erally.&nbsp;literally.</font>
              erally.  An interrupt character will not be inserted.

       <b>quote-line</b> (ESC-') (unbound) (unbound)
              Quote the current line; that is, put a `<b>'</b>' character at the beginning and the end, and convert
              all `<b>'</b>' characters to `<b>'\''</b>'.

       <b>quote-region</b> (ESC-") (unbound) (unbound)
              Quote the region from the cursor to the mark.

       <b>vi-replace</b> (unbound) (R) (unbound)
              Enter overwrite mode.

       <b>vi-repeat-change</b> (unbound) (.) (unbound)
              Repeat the last vi mode text modification.  If a count was used with the modification,  it  is
              remembered.   If  a  count is given to this command, it overrides the remembered count, and is
              remembered for future uses of this command.  The cut buffer specification is similarly  remem-<font color="#ffffff" class="whiteout">bered.&nbsp;remembered.</font>
              bered.

       <b>vi-replace-chars</b> (unbound) (r) (unbound)
              Replace the character under the cursor with a character read from the keyboard.

       <b>self-insert</b> (printable characters) (unbound) (printable characters and some control characters)
              Insert a character into the buffer at the cursor position.

       <b>self-insert-unmeta</b> (ESC-^I ESC-^J ESC-^M) (unbound) (unbound)
              Insert a character into the buffer after stripping the meta bit and converting ^M to ^J.

       <b>vi-substitute</b> (unbound) (s) (unbound)
              Substitute the next <!-- a -->character(s)<!-- /a -->.

       <b>vi-swap-case</b> (unbound) (~) (unbound)
              Swap the case of the character under the cursor and move past it.

       <b>transpose-chars</b> (^T) (unbound) (unbound)
              Exchange  the  two  characters  to the left of the cursor if at end of line, else exchange the
              character under the cursor with the character to the left.

       <b>transpose-words</b> (ESC-T ESC-t) (unbound) (unbound)
              Exchange the current word with the one before it.

       <b>vi-unindent</b> (unbound) (&lt;) (unbound)
              Unindent a number of lines.

       <b>up-case-word</b> (ESC-U ESC-u) (unbound) (unbound)
              Convert the current word to all caps and move past it.

       <b>yank</b> (^Y) (unbound) (unbound)
              Insert the contents of the kill buffer at the cursor position.

       <b>yank-pop</b> (ESC-y) (unbound) (unbound)
              Remove the text just yanked, rotate the kill-ring, and yank the new top.  Only works following
              <b>yank</b> or <b>yank-pop</b>.

       <b>vi-yank</b> (unbound) (y) (unbound)
              Read a movement command from the keyboard, and copy the region from the cursor position to the
              endpoint of the movement into the kill buffer.  If the command is <b>vi-yank</b>,  copy  the  current
              line.

       <b>vi-yank-whole-line</b> (unbound) (Y) (unbound)
              Copy the current line into the kill buffer.

       <b>vi-yank-eol</b>
              Copy  the  region  from  the  cursor  position  to  the  end of the line into the kill buffer.
              Arguably, this is what Y should do in vi, but it isn't what it actually does.

   <b>Arguments</b>
       <b>digit-argument</b> (ESC-0..ESC-9) (1-9) (unbound)
              Start a new numeric argument,  or  add  to  the  current  one.   See  also  <b>vi-digit-or-begin-</b>
              <b>ning-of-line</b>.  This only works if bound to a key sequence ending in a decimal digit.

              Inside  a  widget  function,  a  call to this function treats the last key of the key sequence
              which called the widget as the digit.

       <b>neg-argument</b> (ESC--) (unbound) (unbound)
              Changes the sign of the following argument.

       <b>universal-argument</b>
              Multiply the argument of the next command by 4.  Alternatively, if this command is followed by
              an integer (positive or negative), use that as the argument for the next command.  Thus digits
              cannot be repeated using this command.  For example, if this command  occurs  twice,  followed
              immediately  by  <b>forward-char</b>,  move  forward sixteen spaces; if instead it is followed by <b>-2</b>,
              then <b>forward-char</b>, move backward two spaces.

              Inside a widget function, if passed an argument, i.e. `<b>zle</b> <b>universal-argument</b> <u>num</u>', the numer-<font color="#ffffff" class="whiteout">ical&nbsp;numerical</font>
              ical argument will be set to <u>num</u>; this is equivalent to `<b>NUMERIC=</b><u>num</u>'.

       <b>argument-base</b>
              Use the existing numeric argument as a numeric base, which must be in the range 2 to 36 inclu-<font color="#ffffff" class="whiteout">sive.&nbsp;inclusive.</font>
              sive.  Subsequent use of <b>digit-argument</b> and <b>universal-argument</b> will input a new prefix in  the
              given  base.   The  usual hexadecimal convention is used: the letter <b>a</b> or <b>A</b> corresponds to 10,
              and so on.  Arguments in bases requiring digits from 10 upwards are  more  conveniently  input
              with <b>universal-argument</b>, since <b>ESC-a</b> etc. are not usually bound to <b>digit-argument</b>.

              The  function can be used with a command argument inside a user-defined widget.  The following
              code sets the base to 16 and lets the user input a hexadecimal argument until a key out of the
              digit range is typed:

                     <b>zle</b> <b>argument-base</b> <b>16</b>
                     <b>zle</b> <b>universal-argument</b>

   <b>Completion</b>
       <b>accept-and-menu-complete</b>
              In  a  menu completion, insert the current completion into the buffer, and advance to the next
              possible completion.

       <b>complete-word</b>
              Attempt completion on the current word.

       <b>delete-char-or-list</b> (^D) (unbound) (unbound)
              Delete the character under the cursor.  If the cursor is at the end of the line, list possible
              completions for the current word.

       <b>expand-cmd-path</b>
              Expand the current command to its full pathname.

       <b>expand-or-complete</b> (TAB) (unbound) (TAB)
              Attempt shell expansion on the current word.  If that fails, attempt completion.

       <b>expand-or-complete-prefix</b>
              Attempt shell expansion on the current word up to cursor.

       <b>expand-history</b> (ESC-space ESC-!) (unbound) (unbound)
              Perform history expansion on the edit buffer.

       <b>expand-word</b> (^X*) (unbound) (unbound)
              Attempt shell expansion on the current word.

       <b>list-choices</b> (ESC-^D) (^D =) (^D)
              List possible completions for the current word.

       <b>list-expand</b> (^Xg ^XG) (^G) (^G)
              List the expansion of the current word.

       <b>magic-space</b>
              Perform history expansion and insert a space into the buffer.  This is intended to be bound to
              space.

       <b>menu-complete</b>
              Like <b>complete-word</b>, except that menu completion is used.  See the <b>MENU_COMPLETE</b> option.

       <b>menu-expand-or-complete</b>
              Like <b>expand-or-complete</b>, except that menu completion is used.

       <b>reverse-menu-complete</b>
              Perform menu completion, like <b>menu-complete</b>, except that if a menu completion  is  already  in
              progress, move to the <u>previous</u> completion rather than the next.

       <b>end-of-list</b>
              When  a previous completion displayed a list below the prompt, this widget can be used to move
              the prompt below the list.

   <b>Miscellaneous</b>
       <b>accept-and-hold</b> (ESC-A ESC-a) (unbound) (unbound)
              Push the contents of the buffer on the buffer stack and execute it.

       <b>accept-and-infer-next-history</b>
              Execute the contents of the buffer.  Then search the history list for a line matching the cur-<font color="#ffffff" class="whiteout">rent&nbsp;current</font>
              rent one and push the event following onto the buffer stack.

       <b>accept-line</b> (^J ^M) (^J ^M) (^J ^M)
              Finish editing the buffer.  Normally this causes the buffer to be executed as a shell command.

       <b>accept-line-and-down-history</b> (^O) (unbound) (unbound)
              Execute the current line, and push the next history event on the the buffer stack.

       <b>auto-suffix-remove</b>
              If the previous action added a suffix (space, slash, etc.) to the word on  the  command  line,
              remove it.  Otherwise do nothing.  Removing the suffix ends any active menu completion or menu
              selection.

              This widget is intended to be called from user-defined  widgets  to  enforce  a  desired  suf-<font color="#ffffff" class="whiteout">fix-removal&nbsp;suffix-removal</font>
              fix-removal behavior.

       <b>auto-suffix-retain</b>
              If  the  previous  action added a suffix (space, slash, etc.) to the word on the command line,
              force it to be preserved.  Otherwise do nothing.  Retaining the suffix ends  any  active  menu
              completion or menu selection.

              This  widget  is  intended  to  be  called from user-defined widgets to enforce a desired suf-<font color="#ffffff" class="whiteout">fix-preservation&nbsp;suffix-preservation</font>
              fix-preservation behavior.

       <b>beep</b>   Beep, unless the <b>BEEP</b> option is unset.

       <b>vi-cmd-mode</b> (^X^V) (unbound) (^[)
              Enter command mode; that is, select the `<b>vicmd</b>' keymap.  Yes, this  is  bound  by  default  in
              emacs mode.

       <b>vi-caps-lock-panic</b>
              Hang  until any lowercase key is pressed.  This is for vi users without the mental capacity to
              keep track of their caps lock key (like the author).

       <b>clear-screen</b> (^L ESC-^L) (^L) (^L)
              Clear the screen and redraw the prompt.

       <b>describe-key-briefly</b>
              Reads a key sequence, then prints the function bound to that sequence.

       <b>exchange-point-and-mark</b> (^X^X) (unbound) (unbound)
              Exchange the cursor position with the position of the mark.

       <b>execute-named-cmd</b> (ESC-x) (unbound) (unbound)
              Read the name of an editor command and execute it.  A restricted set of editing  functions  is
              available in the mini-buffer.  An interrupt signal, as defined by the stty setting, will abort
              the  function.  The  allowed  functions  are:  <b>backward-delete-char</b>,  <b>vi-backward-delete-char</b>,
              <b>clear-screen</b>,   <b>redisplay</b>,   <b>quoted-insert</b>,   <b>vi-quoted-insert</b>,  <b>backward-kill-word</b>,  <b>vi-back</b>-<font color="#ffffff" class="whiteout">ward-kill-word,&nbsp;vi-backward-kill-word,</font>
              <b>ward-kill-word</b>,    <b>kill-whole-line</b>,    <b>vi-kill-line</b>,     <b>backward-kill-line</b>,     <b>list-choices</b>,
              <b>delete-char-or-list</b>,   <b>complete-word</b>,   <b>accept-line</b>,   <b>expand-or-complete</b>  and  <b>expand-or-com</b>-<font color="#ffffff" class="whiteout">plete-prefix.&nbsp;expand-or-complete-prefix.</font>
              <b>plete-prefix</b>.

              <b>kill-region</b> kills the last word, and vi-cmd-mode is treated  the  same  as  accept-line.   The
              space  and  tab characters, if not bound to one of these functions, will complete the name and
              then list the possibilities if the <b>AUTO_LIST</b> option is set.  Any other character that  is  not
              bound to <b>self-insert</b> or <b>self-insert-unmeta</b> will beep and be ignored.  The bindings of the cur-<font color="#ffffff" class="whiteout">rent&nbsp;current</font>
              rent insert mode will be used.

              Currently this command may not be redefined or called by name.

       <b>execute-last-named-cmd</b> (ESC-z) (unbound) (unbound)
              Redo the last function executed with <b>execute-named-cmd</b>.

              Currently this command may not be redefined or called by name.

       <b>get-line</b> (ESC-G ESC-g) (unbound) (unbound)
              Pop the top line off the buffer stack and insert it at the cursor position.

       <b>pound-insert</b> (unbound) (#) (unbound)
              If there is no # character at the beginning of the buffer, add one to the  beginning  of  each
              line.   If  there  is one, remove a # from each line that has one.  In either case, accept the
              current line.  The <b>INTERACTIVE_COMMENTS</b> option must be set for this to have any usefulness.

       <b>vi-pound-insert</b>
              If there is no # character at the beginning of the current line, add one.  If  there  is  one,
              remove it.  The <b>INTERACTIVE_COMMENTS</b> option must be set for this to have any usefulness.

       <b>push-input</b>
              Push  the entire current multiline construct onto the buffer stack and return to the top-level
              (<b>PS1</b>) prompt.  If the current parser construct is only a single line,  this  is  exactly  like
              <b>push-line</b>.   Next  time the editor starts up or is popped with <b>get-line</b>, the construct will be
              popped off the top of the buffer stack and loaded into the editing buffer.

       <b>push-line</b> (^Q ESC-Q ESC-q) (unbound) (unbound)
              Push the current buffer onto the buffer stack and clear the  buffer.   Next  time  the  editor
              starts up, the buffer will be popped off the top of the buffer stack and loaded into the edit-<font color="#ffffff" class="whiteout">ing&nbsp;editing</font>
              ing buffer.

       <b>push-line-or-edit</b>
              At the top-level (<b>PS1</b>) prompt, equivalent to <b>push-line</b>.  At a secondary (<b>PS2</b>) prompt, move the
              entire  current  multiline  construct  into  the  editor  buffer.  The latter is equivalent to
              <b>push-input</b> followed by <b>get-line</b>.

       <b>read-command</b>
              Only useful from a user-defined widget.  A keystroke is read just as in normal operation,  but
              instead of the command being executed the name of the command that would be executed is stored
              in the shell parameter <b>REPLY</b>.  This can be used as the argument of a future <b>zle</b>  command.   If
              the key sequence is not bound, status 1 is returned; typically, however, <b>REPLY</b> is set to <b>unde</b>-<font color="#ffffff" class="whiteout">fined-key&nbsp;undefined-key</font>
              <b>fined-key</b> to indicate a useless key sequence.

       <b>recursive-edit</b>
              Only useful from a user-defined widget.  At this point in the  function,  the  editor  regains
              control until one of the standard widgets which would normally cause zle to exit (typically an
              <b>accept-line</b> caused by hitting the return key) is executed.  Instead, control  returns  to  the
              user-defined  widget.   The  status returned is non-zero if the return was caused by an error,
              but the function still continues executing and hence may tidy up.  This makes it safe for  the
              user-defined widget to alter the command line or key bindings temporarily.

              The following widget, <b>caps-lock</b>, serves as an example.
                     <b>self-insert-ucase()</b> <b>{</b>
                       <b>LBUFFER+=${(U)KEYS[-1]}</b>
                     <b>}</b>

                     integer stat

                     zle -N self-insert self-insert-ucase
                     zle -A caps-lock save-caps-lock
                     zle -A accept-line caps-lock

                     zle recursive-edit
                     stat=$?

                     zle -A .self-insert self-insert
                     zle -A save-caps-lock caps-lock
                     zle -D save-caps-lock

                     (( stat )) &amp;&amp; zle send-break

                     return $stat
              This  causes typed letters to be inserted capitalised until either <b>accept-line</b> (i.e. typically
              the return key) is typed or the <b>caps-lock</b> widget is invoked again; the  later  is  handled  by
              saving  the  old  definition  of  <b>caps-lock</b>  as <b>save-caps-lock</b> and then rebinding it to invoke
              <b>accept-line</b>.  Note that an error from the recursive edit is detected as a non-zero return sta-<font color="#ffffff" class="whiteout">tus&nbsp;status</font>
              tus and propagated by using the <b>send-break</b> widget.

       <b>redisplay</b> (unbound) (^R) (^R)
              Redisplays the edit buffer.

       <b>reset-prompt</b> (unbound) (unbound) (unbound)
              Force  the  prompts on both the left and right of the screen to be re-expanded, then redisplay
              the edit buffer.  This reflects changes both to the prompt variables themselves and changes in
              the  expansion  of  the  values  (for example, changes in time or directory, or changes to the
              value of variables referred to by the prompt).

              Otherwise, the prompt is only expanded each time zle starts, and  when  the  display  as  been
              interrupted by output from another part of the shell (such as a job notification) which causes
              the command line to be reprinted.

       <b>send-break</b> (^G ESC-^G) (unbound) (unbound)
              Abort the current editor function, e.g. <b>execute-named-command</b>, or the editor itself,  e.g.  if
              you are in <b>vared</b>. Otherwise abort the parsing of the current line.

       <b>run-help</b> (ESC-H ESC-h) (unbound) (unbound)
              Push  the  buffer  onto the buffer stack, and execute the command `<b>run-help</b> <u>cmd</u>', where <u>cmd</u> is
              the current command.  <b>run-help</b> is normally aliased to <b>man</b>.

       <b>vi-set-buffer</b> (unbound) (") (unbound)
              Specify a buffer to be used in the following command.  There are 35 buffers that can be speci-<font color="#ffffff" class="whiteout">fied:&nbsp;specified:</font>
              fied:  the  26  `named'  buffers  <b>"a</b>  to <b>"z</b> and the nine `queued' buffers <b>"1</b> to <b>"9</b>.  The named
              buffers can also be specified as <b>"A</b> to <b>"Z</b>.

              When a buffer is specified for a cut command, the text being cut replaces  the  previous  con-<font color="#ffffff" class="whiteout">tents&nbsp;contents</font>
              tents  of the specified buffer.  If a named buffer is specified using a capital, the newly cut
              text is appended to the buffer instead of overwriting it.

              If no buffer is specified for a cut command, <b>"1</b> is used, and the contents of <b>"1</b> to <b>"8</b> are each
              shifted along one buffer; the contents of <b>"9</b> is lost.

       <b>vi-set-mark</b> (unbound) (m) (unbound)
              Set the specified mark at the cursor position.

       <b>set-mark-command</b> (^@) (unbound) (unbound)
              Set the mark at the cursor position.

       <b>spell-word</b> (ESC-$ ESC-S ESC-s) (unbound) (unbound)
              Attempt spelling correction on the current word.

       <b>undefined-key</b>
              This  command  is  executed when a key sequence that is not bound to any command is typed.  By
              default it beeps.

       <b>undo</b> (^_ ^Xu ^X^U) (unbound) (unbound)
              Incrementally undo the last text modification.

       <b>redo</b>   Incrementally redo undone text modifications.

       <b>vi-undo-change</b> (unbound) (u) (unbound)
              Undo the last text modification.  If repeated, redo the modification.

       <b>what-cursor-position</b> (^X=) (unbound) (unbound)
              Print the character under the cursor, its code as an octal, decimal  and  hexadecimal  number,
              the  current  cursor  position  within  the buffer and the column of the cursor in the current
              line.

       <b>where-is</b>
              Read the name of an editor command and and print the listing of key sequences that invoke  the
              specified command.

       <b>which-command</b> (ESC-?) (unbound) (unbound)
              Push  the buffer onto the buffer stack, and execute the command `<b>which-command</b> <u>cmd</u>'. where <u>cmd</u>
              is the current command.  <b>which-command</b> is normally aliased to <u>whence</u>.

       <b>vi-digit-or-beginning-of-line</b> (unbound) (0) (unbound)
              If the last command executed was a digit as part of an argument, continue the argument.   Oth-<font color="#ffffff" class="whiteout">erwise,&nbsp;Otherwise,</font>
              erwise, execute vi-beginning-of-line.



zsh 4.3.4                                      April 19, 2006                                      ZSHZLE(1)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man1/zshzle.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man1/zshzle.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man1/zshzle.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
