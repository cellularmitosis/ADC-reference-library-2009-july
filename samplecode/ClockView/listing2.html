<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>ClockView - /TClockView.cp</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/Carbon/index.html">Carbon</a> &gt; <a href="../../samplecode/Carbon/idxHumanInterfaceToolbox-date.html">Human Interface Toolbox</a> &gt; <A HREF="javascript:location.replace('index.html');">ClockView</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">ClockView</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/TClockView.cp</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/main.cp</option>
<option value="listing2.html">/TClockView.cp</option>
<option value="listing3.html">/TClockView.h</option></select>
				</p>
				</form>
				<p><strong><a href="ClockView.zip">Download Sample</a></strong> (&#147;ClockView.zip&#148;, 17.6K)<BR>
<strong><a href="ClockView.dmg">Download Sample</a></strong> (&#147;ClockView.dmg&#148;, 77.0K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*
    File:    TClockView.cp
    
    Version:  1.0

  Disclaimer:  IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc.
        (&quot;Apple&quot;) in consideration of your agreement to the following terms, and your
        use, installation, modification or redistribution of this Apple software
        constitutes acceptance of these terms.  If you do not agree with these terms,
        please do not use, install, modify or redistribute this Apple software.

        In consideration of your agreement to abide by the following terms, and subject
        to these terms, Apple grants you a personal, non-exclusive license, under Apple's
        copyrights in this original Apple software (the &quot;Apple Software&quot;), to use,
        reproduce, modify and redistribute the Apple Software, with or without
        modifications, in source and/or binary forms; provided that if you redistribute
        the Apple Software in its entirety and without modifications, you must retain
        this notice and the following text and disclaimers in all such redistributions of
        the Apple Software.  Neither the name, trademarks, service marks or logos of
        Apple Computer, Inc. may be used to endorse or promote products derived from the
        Apple Software without specific prior written permission from Apple.  Except as
        expressly stated in this notice, no other rights or licenses, express or implied,
        are granted by Apple herein, including but not limited to any patent rights that
        may be infringed by your derivative works or by other works in which the Apple
        Software may be incorporated.

        The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE MAKES NO
        WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED
        WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR
        PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN
        COMBINATION WITH YOUR PRODUCTS.

        IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR
        CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
        GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
        ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION
        OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT
        (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN
        ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  Copyright &copy; 2002 Apple Computer, Inc., All Rights Reserved
*/

#include &lt;Carbon/Carbon.h&gt;

#include &quot;TClockView.h&quot;

#ifndef M_PI
  #define  M_PI    3.14159265358979323846
#endif

//-----------------------------------------------------------------------------------
//  types
//-----------------------------------------------------------------------------------
//
typedef struct
{
  float  red;
  float  green;
  float  blue;
} CGRGB;

//-----------------------------------------------------------------------------------
//  prototypes
//-----------------------------------------------------------------------------------
//
HIPoint RotatePoint(
  HIPoint        inPoint,
  HIPoint        inRotationCenter,
  float        inAngle );  // radians
void RotateLine(
  HIPoint*      inStart,
  HIPoint*      inEnd,
  const HIPoint*    inRotationCenter,
  float        inAngle );
void DrawShadowPath(
  CGContextRef    inContext,
  CGPathRef      inPath,
  float        inLineWidth,
  float        inBaseGray );
void DrawPath(
  CGContextRef    inContext,
  CGPathRef      inPath,
  float        inLineWidth,
  float        inRed,
  float        inGreen,
  float        inBlue );
void CGPathAddLine(
  CGMutablePathRef  inPath,
  const CGPoint*    inStart,
  const CGPoint*    inEnd );

//-----------------------------------------------------------------------------------
//  macros
//-----------------------------------------------------------------------------------
//
#define kTViewClassID  CFSTR( &quot;com.apple.sample.TClockView&quot; )
#define MIN(A,B)    ((A)&lt;(B)?(A):(B))

//-----------------------------------------------------------------------------------
//  constants
//-----------------------------------------------------------------------------------
//  Wow!  That's a lot of constants!  Wait until you see where they get used!
//
const float        kDegree            = M_PI/180;
const float        kShadowAlpha        = 0.5;
const float        kShadowX          = 0;
const float        kShadowY          = 1;
const float        kInnerFrameInset      = 3;
const float        kHourTickInset        = 3;
const float        kMinuteTickInset      = 5;
const float        kMinuteTickHeight      = 1;
const float        kHourHandRatio        = 1.0/2;
const float        kHourHandExtraRatio      = 1.0/12;
const float        kMinuteHandInset      = 8;
const float        kMinuteHandExtra      = 0;
const float        kSecondHandInset      = 5;
const SInt16      kDigitsBoxWidth        = 30;
const SInt16      kDigitsBoxHeight      = kDigitsBoxWidth;
const CGRGB        kHourColor          = { 76.0/255, 47.0/255, 177.0/255 };
const CGRGB        kMinuteColor        = kHourColor;
const SInt16      kBaseDigitFontSize      = 10;
const float        kFontPointsPerPixel      = 1.0/6;
const float        kDigitOffsetPerPixel    = 1.0/7;
const float        kSecondHandExtraRatio    = 1.0/12;
const float        kMinimumRadiusWithDigits  = 50;
const float        kMinimumRadiusWithMinuteTicks = 25;
const float        kMinimumRadiusWithDot    = 35;
const float        kMinimumRadiusWithInnerFrame = 15;
const float        kBaseHandWidth        = 1;
const float        kHandWidthPerPixel      = 1.0/40;
const float        kBaseHourTickHeight      = 2;
const float        kHourTickSizePerPixel    = 1.0/30;
const float        kBaseDigitInset        = 16;

enum
{
            kAMPMLocTopLeft    = 1,
            kAMPMLocBotLeft,
            kAMPMLocTopRight,
            kAMPMLocBotRight,
            kAMPMLocation    = kAMPMLocBotRight
};

//-----------------------------------------------------------------------------------
//  TClockView constructor
//-----------------------------------------------------------------------------------
//
TClockView::TClockView(
  HIViewRef      inControl )
  :  TView( inControl ),
    fTimer( NULL )
{
  ChangeAutoInvalidateFlags( kAutoInvalidateOnHilite, 0 );
}

//-----------------------------------------------------------------------------------
//  TClockView destructor
//-----------------------------------------------------------------------------------
//  Clean up after yourself.
//
TClockView::~TClockView()
{
  if ( fTimer )
    RemoveEventLoopTimer( fTimer );
}

//-----------------------------------------------------------------------------------
//  GetKind
//-----------------------------------------------------------------------------------
//
ControlKind TClockView::GetKind()
{
  const ControlKind kMyKind = { 'TtsV', 'TtsV' };
  
  return kMyKind;
}

//-----------------------------------------------------------------------------------
//  Create
//-----------------------------------------------------------------------------------
//
OSStatus TClockView::Create(
  HIViewRef*      outControl,
  const HIRect*    inBounds,
  WindowRef      inWindow )
{
  OSStatus      err;
  EventRef      event = CreateInitializationEvent();
  ControlRef      root;
  
  RegisterClass();

  err = HIObjectCreate( kTViewClassID, event, (HIObjectRef*) outControl );
  
  ReleaseEvent( event );

  if ( err == noErr )
  {
    if ( inWindow != NULL )
    {
      GetRootControl( inWindow, &amp;root );
      HIViewAddSubview( root, *outControl );
    }

    HIViewSetFrame( *outControl, inBounds );
  }
  
  return err;
}

//-----------------------------------------------------------------------------------
//  RegisterClass
//-----------------------------------------------------------------------------------
//
void TClockView::RegisterClass()
{
  static bool sRegistered;
  
  if ( !sRegistered )
  {
    TView::RegisterSubclass( kTViewClassID, Construct );
    sRegistered = true;
  }
}

//-----------------------------------------------------------------------------------
//  Construct
//-----------------------------------------------------------------------------------
//
OSStatus TClockView::Construct(
  ControlRef    inControl,
  TView**      outView )
{
  *outView = new TClockView( inControl );
  
  return noErr;
}

//-----------------------------------------------------------------------------------
//  Initialize
//-----------------------------------------------------------------------------------
//  The control is set up.  Do the last minute stuff that needs to be done like
//  installing an EventLoopTimer.
//
OSStatus TClockView::Initialize(
  TCarbonEvent&amp;    inEvent )
{
  OSStatus      err;
  
  err = TView::Initialize( inEvent );
  require_noerr( err, CantInitializeParent );

  // Install a timer that gets called once per second to update the clock
  err = InstallEventLoopTimer( GetCurrentEventLoop(), 1 * kEventDurationSecond,
      kEventDurationSecond, ClockAnimationTimer, GetViewRef(), &amp;fTimer );

CantInitializeParent:
  return err;
}

//-----------------------------------------------------------------------------------
//  DrawFace
//-----------------------------------------------------------------------------------
//  Draws the background of the clock.
//
void TClockView::DrawFace(
  CGContextRef    inContext,
  float        inFrameShade,
  float        inFillShade )
{
  TRect        bounds = Bounds();
  TRect        digitBounds;
  float        radius;
  HIPoint        center, start, end, digitCenter;
  int          i;
  CGMutablePathRef  path;
  GrafPtr        port;
  SInt16        savedFont, savedSize;
  CFStringRef      string;
  Rect        qdBounds;
  Point        dimensions = { kDigitsBoxWidth, kDigitsBoxHeight };
  SInt16        baseline;
  float        innerFrameInset = 0;
  
  CGContextSetRGBFillColor( inContext, inFillShade, inFillShade, inFillShade, 1 );
  CGContextSetRGBStrokeColor( inContext, inFrameShade, inFrameShade, inFrameShade, 1 );

  // The border and the face fill
  bounds.Inset( 0.5, 0.5 );
  center = bounds.Center();
  radius = MIN( bounds.Width(), bounds.Height() ) / 2;
  CGContextAddArc( inContext, center.x, center.y, radius, 0, 360 * kDegree, 1 );
  CGContextDrawPath( inContext, kCGPathFillStroke );

  if ( radius &gt;= kMinimumRadiusWithInnerFrame )
  {
    // The inner frame
    innerFrameInset = kInnerFrameInset;
    bounds = Bounds();
    bounds.Inset( innerFrameInset, innerFrameInset );
    radius = MIN( bounds.Width(), bounds.Height() ) / 2;
    CGContextSetLineWidth( inContext, 2 );
    CGContextBeginPath( inContext );
    CGContextAddArc( inContext, center.x, center.y, radius, 0, 360 * kDegree, 1 );
    CGContextStrokePath( inContext );
  }

  // The hour ticks, hour hand, minute hand and second hand are drawn with
  // a kShadowY pixel drop shadow.  To achieve this, a path is calculated
  // for the element and it is drawn twice -- once as a shadow and once as
  // the actual element.  CGPaths are cool.
  
  // The hour ticks
  path = CGPathCreateMutable();
  check( path );
  start = CGPointMake( center.x, center.y - radius + kHourTickInset );
  end = CGPointMake( start.x, start.y + kBaseHourTickHeight + radius * kHourTickSizePerPixel );
  for ( i = 0; i &lt; 12; i++ )
  {
    CGPathAddLine( path, &amp;start, &amp;end );
    RotateLine( &amp;start, &amp;end, &amp;center, 360.0/12 * kDegree );
  }
  DrawShadowPath( inContext, path, 1, inFrameShade );
  DrawPath( inContext, path, 1, inFrameShade, inFrameShade, inFrameShade );
  CFRelease( path );

  if ( radius &lt; kMinimumRadiusWithMinuteTicks )
    return;
    
  // The minute ticks
  path = CGPathCreateMutable();
  check( path );
  start = CGPointMake( center.x, center.y - radius + kMinuteTickInset );
  end = CGPointMake( start.x, start.y + kMinuteTickHeight );
  for ( i = 0; i &lt; 60; i++ )
  {
    // Don't draw over the hour ticks, which are 1 in every 5 ticks
    if ( i % 5 != 0 )
      CGPathAddLine( path, &amp;start, &amp;end );
    RotateLine( &amp;start, &amp;end, &amp;center, 360.0/60 * kDegree );
  }
  // Minute ticks don't have shadows
  DrawPath( inContext, path, 1, inFrameShade, inFrameShade, inFrameShade );
  CFRelease( path );

  // Don't draw the digits if they are going to be all squished together
  if ( radius &lt; kMinimumRadiusWithDigits )
    return;

  GetPort( &amp;port );
  savedFont = GetPortTextFont( port );
  savedSize = GetPortTextSize( port );
  SetPortTextFont( port, systemFont );
  SetPortTextSize( port, kBaseDigitFontSize + (int) ( (radius - kMinimumRadiusWithDigits) * kFontPointsPerPixel ) );

  // The digits
  digitCenter = CGPointMake( center.x, center.y - radius + kBaseDigitInset + ((int) radius - kMinimumRadiusWithDigits) * kDigitOffsetPerPixel );
  // Text is drawn with the fill color
  CGContextSetRGBFillColor( inContext, 0, 0, 1, 1 );
  for ( i = 12; i &gt; 0; i-- )
  {
    // Draw the text
    string = CFStringCreateWithFormat( NULL, NULL, CFSTR( &quot;%d&quot; ), i );
    check( string );
    verify_noerr( GetThemeTextDimensions( string, kThemeCurrentPortFont, kThemeStateActive, false, &amp;dimensions, &amp;baseline ) );

    // Make the text rectangle centered around the text center point
    digitBounds.SetAroundCenter( digitCenter.x, digitCenter.y, dimensions.h, dimensions.v );
    qdBounds = digitBounds;

    verify_noerr( DrawThemeTextBox( string, kThemeCurrentPortFont, kThemeStateActive, false, &amp;qdBounds, teCenter, inContext ) );
    CFRelease( string );

    // Rotate to next position (counter-clockwise to make counting eaasier)
    digitCenter = RotatePoint( digitCenter, center, -360.0/12 * kDegree );
  }
  
  SetPortTextFont( port, savedFont );
  SetPortTextSize( port, savedSize );
}

//-----------------------------------------------------------------------------------
//  DrawTime
//-----------------------------------------------------------------------------------
//  Draws the hands on the clock (and the AM/PM display).
//
void TClockView::DrawTime(
  CGContextRef      inContext,
  float          inFrameShade )
{
  TRect          bounds = Bounds();
  float          radius;
  HIPoint          center, start, end;
  CFGregorianDate      time;
  CFTimeZoneRef      timezone;
  float          fractional;
  RGBColor        color;
  CGMutablePathRef    path;
  
  bounds.Inset( kInnerFrameInset, kInnerFrameInset );
  radius = MIN( bounds.Width(), bounds.Height() ) / 2;
  center = bounds.Center();

  // Get the time -- clocks aren't much use if they don't tell the time
  timezone = CFTimeZoneCopySystem();
  check( timezone != NULL );
  time = CFAbsoluteTimeGetGregorianDate( CFAbsoluteTimeGetCurrent(), timezone );
  CFRelease( timezone );

  // The hour hand
  // - the fractional calculation might seem confusing, but it makes the clock look
  //   better.  It adds a bit of rotation depending on how much of the hour has gone
  //   by so that the hour hand doesn't just point directly at the current hour.
  path = CGPathCreateMutable();
  check( path );
  start = CGPointMake( center.x, center.y - radius * kHourHandRatio );
  end = CGPointMake( center.x, center.y + radius * kHourHandExtraRatio );
  fractional = (int) ((360.0/12*time.hour) + (360.0/12)/60*time.minute);
  RotateLine( &amp;start, &amp;end, &amp;center, fractional * kDegree );
  CGPathAddLine( path, &amp;start, &amp;end );
  DrawShadowPath( inContext, path, kBaseHandWidth + radius * kHandWidthPerPixel, inFrameShade );
  DrawPath( inContext, path, kBaseHandWidth + radius * kHandWidthPerPixel,
      kHourColor.red, kHourColor.green, kHourColor.blue );
  CFRelease( path );

  // The minute hand
  // - the fractional calculation here is the same as above, but for seconds so that
  //   the minute hand doesn't just point at the current minute and moves nice and
  //   smoothly.
  path = CGPathCreateMutable();
  check( path );
  CGContextBeginPath( inContext );
  start = CGPointMake( center.x, center.y - radius + kMinuteHandInset );
  end = CGPointMake( center.x, center.y + kMinuteHandExtra );
  fractional = (int) ((360.0/60*time.minute) + (360.0/60)/60*time.second);
  RotateLine( &amp;start, &amp;end, &amp;center, fractional * kDegree );
  CGPathAddLine( path, &amp;start, &amp;end );
  DrawShadowPath( inContext, path, 2, inFrameShade );
  DrawPath( inContext, path, kBaseHandWidth + radius * kHandWidthPerPixel,
      kMinuteColor.red, kMinuteColor.green, kMinuteColor.blue );
  CFRelease( path );

  // The second hand
  path = CGPathCreateMutable();
  check( path );
  CGContextBeginPath( inContext );
  start = CGPointMake( center.x, center.y - radius + kSecondHandInset );
  end = CGPointMake( center.x, center.y + kSecondHandExtraRatio );
  RotateLine( &amp;start, &amp;end, &amp;center, 360.0/60 * ((int)time.second%60) * kDegree );
  CGPathAddLine( path, &amp;start, &amp;end );
  DrawShadowPath( inContext, path, 1, inFrameShade );
  GetThemeBrushAsColor( kThemeBrushPrimaryHighlightColor, 32, true, &amp;color );
  DrawPath( inContext, path, 1, (float) color.red / 65536,
      (float) color.green / 65536, (float) color.blue / 65536 );
  CFRelease( path );

  // A dot in the middle
  if ( radius &gt;= kMinimumRadiusWithDot )
  {
    CGContextAddArc( inContext, center.x, center.y, 3, 0, 360 * kDegree, 1 );
    CGContextSetRGBFillColor( inContext, 0, 1, 0, 1 );
    CGContextFillPath( inContext );
  }

  // Draw the AM/PM text -- don't if there isn't enough room
  if ( radius &gt;= kMinimumRadiusWithDigits )
  {
    CFStringRef    string = ( time.hour &lt; 12 ) ? CFSTR( &quot;AM&quot; ) : CFSTR( &quot;PM&quot; );
    Rect      qdBounds;
    Point      dimensions;
    SInt16      baseline;
    SInt16      just;
    GrafPtr      port;
    SInt16      savedFont, savedSize;
    float      bestSize;

    GetPort( &amp;port );
    savedFont = GetPortTextFont( port );
    savedSize = GetPortTextSize( port );
    SetPortTextFont( port, systemFont );
    SetPortTextSize( port, kBaseDigitFontSize + ((int) radius - 50) / 6 );

    bounds = Bounds();
    
    verify_noerr( GetThemeTextDimensions( string, kThemeCurrentPortFont, kThemeStateActive, false, &amp;dimensions, &amp;baseline ) );
    bestSize = MIN( bounds.Width(), bounds.Height() );
    bounds.MoveBy( bounds.Width() / 2 - bestSize / 2, bounds.Height() / 2 - bestSize / 2 );
    bounds.SetSize( bestSize, bestSize );
    switch( kAMPMLocation )
    {
      case kAMPMLocTopLeft:
        just = teFlushLeft;
        break;
      case kAMPMLocBotLeft:
        bounds.MoveBy( 0, bounds.Height() - dimensions.v );
        just = teFlushLeft;
        break;
      case kAMPMLocTopRight:
        just = teFlushRight;
        break;
      case kAMPMLocBotRight:
        bounds.MoveBy( 0, bounds.Height() - dimensions.v );
        just = teFlushRight;
        break;
    }
    qdBounds = bounds;
    CGContextSetRGBFillColor( inContext, inFrameShade, inFrameShade, inFrameShade, 1 );
    verify_noerr( DrawThemeTextBox( string, kThemeCurrentPortFont, kThemeStateActive, false, &amp;qdBounds, just, inContext ) );

    SetPortTextFont( port, savedFont );
    SetPortTextSize( port, savedSize );
  }
}

//-----------------------------------------------------------------------------------
//  Draw
//-----------------------------------------------------------------------------------
//  The fun part of the control
//
void TClockView::Draw(
  RgnHandle        inLimitRgn,
  CGContextRef      inContext )
{
#pragma unused( inLimitRgn )
  float          fillShade, frameShade;
  
  // Draw the frame elements and face fill differently depending on
  // the hilite state.
  switch ( GetControlHilite( GetViewRef() ) )
  {
    case 1:
      fillShade = 0.9;
      frameShade = 0.4;
      break;

    case kControlNoPart:
    default:
      fillShade = 1;
      frameShade = 0.5;
      break;
  }

  DrawFace( inContext, frameShade, fillShade );
  DrawTime( inContext, frameShade );
}

//-----------------------------------------------------------------------------------
//  HitTest
//-----------------------------------------------------------------------------------
//  Determine whether a click was in the control or not
//
ControlPartCode TClockView::HitTest(
  const HIPoint&amp;    inWhere )
{
  ControlPartCode    part = kControlNoPart;
  TRect        bounds( Bounds() );
  float        radius;
  HIPoint        center;
  float        deltaX, deltaY;

  // If it's in the control's bounds
  if ( CGRectContainsPoint( bounds, inWhere ) )
  {
    // Add a check here to see if the AMPM was hit?
  
    // Set up to calculate distance from center
    radius = MIN( bounds.Width(), bounds.Height() ) / 2;
    center = bounds.Center();
    deltaX = inWhere.x - center.x;
    deltaY = inWhere.y - center.y;

    // If within the clock radius
    if ( sqrt( deltaX * deltaX + deltaY * deltaY ) &lt;= radius )
      part = 1;
  }

  return part;
}

//-----------------------------------------------------------------------------------
//  GetRegion
//-----------------------------------------------------------------------------------
//
OSStatus TClockView::GetRegion(
  ControlPartCode    inPart,
  RgnHandle      outRgn )
{
  OSStatus      err = noErr;
  TRect        bounds;
  Rect        qdBounds;
  
  if ( inPart == kControlContentMetaPart
      || inPart == kControlStructureMetaPart
      /* || inPart == kControlOpaqueRegionMetaPart */ )
  {
    bounds = Bounds();
    qdBounds = bounds;
  
    RectRgn( outRgn, &amp;qdBounds );
  }
  
  return err;
}

//-----------------------------------------------------------------------------------
//  RotatePoint
//-----------------------------------------------------------------------------------
//  Rotate inPoint about inRotationCenter by inAngle radians
//
HIPoint RotatePoint(
  HIPoint    inPoint,
  HIPoint    inRotationCenter,
  float    inAngle )  // radians
{
  HIPoint        point;
  CGAffineTransform  transform;
  
  // Move to origin
  point.x = inPoint.x - inRotationCenter.x;
  point.y = inPoint.y - inRotationCenter.y;
  
  // Rotate
  transform = CGAffineTransformMakeRotation( inAngle );
  point = CGPointApplyAffineTransform( point, transform );
  
  // Restore from origin
  point.x += inRotationCenter.x;
  point.y += inRotationCenter.y;
  
  return point;
}

//-----------------------------------------------------------------------------------
//  RotateLine
//-----------------------------------------------------------------------------------
//  Rotate line segment from inStart to inEnd about inRotationCenter by inAngle
//  radians
//
void RotateLine(
  HIPoint*      inStart,
  HIPoint*      inEnd,
  const HIPoint*    inRotationCenter,
  float        inAngle )
{
  *inStart = RotatePoint( *inStart, *inRotationCenter, inAngle );
  *inEnd = RotatePoint( *inEnd, *inRotationCenter, inAngle );
}

//-----------------------------------------------------------------------------------
//  ClockAnimationTimer
//-----------------------------------------------------------------------------------
//  This timer tells the clock it needs to update itself.  It should be called once
//  every second.
//
pascal void TClockView::ClockAnimationTimer(
  EventLoopTimerRef      inTimer,
  void*            inUserData )
{
#pragma unused( inTimer )
  HIViewSetNeedsDisplay( (HIViewRef) inUserData, true );
}

//-----------------------------------------------------------------------------------
//  DrawShadowPath
//-----------------------------------------------------------------------------------
//  Strokes inPath in inContext with inLineWidth in RGB( inBaseGray, inBaseGray,
//  inBaseGray ) with partial transparency
//
void DrawShadowPath(
  CGContextRef    inContext,
  CGPathRef      inPath,
  float        inLineWidth,
  float        inBaseGray )
{
  CGContextSetLineWidth( inContext, inLineWidth );
  CGContextSetRGBStrokeColor( inContext, inBaseGray, inBaseGray, inBaseGray, kShadowAlpha );
  CGContextTranslateCTM( inContext, kShadowX, kShadowY );
  CGContextBeginPath( inContext );
  CGContextAddPath( inContext, inPath );
  CGContextStrokePath( inContext );
  CGContextTranslateCTM( inContext, -kShadowX, -kShadowY ); // restore the CTM
}

//-----------------------------------------------------------------------------------
//  DrawPath
//-----------------------------------------------------------------------------------
//  Strokes inPath in inContext with inLineWidth in RGB( inRed, inGreen, inBlue )
//
void DrawPath(
  CGContextRef    inContext,
  CGPathRef      inPath,
  float        inLineWidth,
  float        inRed,
  float        inGreen,
  float        inBlue )
{
  CGContextSetLineWidth( inContext, inLineWidth );
  CGContextBeginPath( inContext );
  CGContextAddPath( inContext, inPath );
  CGContextSetRGBStrokeColor( inContext, inRed, inGreen, inBlue, 1 );
  CGContextStrokePath( inContext );
}

//-----------------------------------------------------------------------------------
//  CGPathAddLine
//-----------------------------------------------------------------------------------
//  Adds a line segment from inStart to inEnd to a CGPath
//
void CGPathAddLine(
  CGMutablePathRef  inPath,
  const CGPoint*    inStart,
  const CGPoint*    inEnd )
{
  CGPathMoveToPoint( inPath, NULL, inStart-&gt;x, inStart-&gt;y );
  CGPathAddLineToPoint( inPath, NULL, inEnd-&gt;x, inEnd-&gt;y );
}

</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/ClockView/listing2.html%3Fid%3DDTS10000629-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/ClockView/listing2.html%3Fid%3DDTS10000629-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/ClockView/listing2.html%3Fid%3DDTS10000629-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>