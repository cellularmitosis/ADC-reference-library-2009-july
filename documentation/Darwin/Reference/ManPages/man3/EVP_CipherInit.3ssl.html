<html><head><title>Mac OS X Developer Tools
 Manual Page For EVP_CipherInit(3ssl)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3ssl/EVP_CipherInit" title="Mac OS X Developer Tools
 Manual Page for EVP_CipherInit(3ssl)"><a name="//apple_ref/doc/man/3/EVP_CipherInit" title="Mac OS X Developer Tools
 Manual Page for EVP_CipherInit(3ssl)"><!-- headerDoc=man; indexgroup=Section 3ssl; uid="//apple_ref/doc/man/3ssl/EVP_CipherInit"; name=EVP_CipherInit(3ssl) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac&nbsp;OS&nbsp;X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>

<p style='text-align:justify;'>This manual page is associated with the Mac&nbsp;OS&nbsp;X
developer tools.  The software or headers described may not be present on your
Mac&nbsp;OS&nbsp;X installation until you install the developer tools
package.  This package is available on your Mac&nbsp;OS&nbsp;X installation DVD,
and the latest versions can be downloaded from
<a href="http://developer.apple.com/tools/download/">developer.apple.com</a>.</p>

<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
EVP_EncryptInit(3)                                 OpenSSL                                <a href="EVP_EncryptInit.3ssl.html#//apple_ref/doc/man/3/EVP_EncryptInit">EVP_EncryptInit(3)</a>



<b>NAME</b>
       EVP_CIPHER_CTX_init, EVP_EncryptInit_ex, EVP_EncryptUpdate, EVP_EncryptFinal_ex, EVP_DecryptInit_ex,
       EVP_DecryptUpdate, EVP_DecryptFinal_ex, EVP_CipherInit_ex, EVP_CipherUpdate, EVP_CipherFinal_ex,
       EVP_CIPHER_CTX_set_key_length, EVP_CIPHER_CTX_ctrl, EVP_CIPHER_CTX_cleanup, EVP_EncryptInit,
       EVP_EncryptFinal, EVP_DecryptInit, EVP_DecryptFinal, EVP_CipherInit, EVP_CipherFinal,
       EVP_get_cipherbyname, EVP_get_cipherbynid, EVP_get_cipherbyobj, EVP_CIPHER_nid,
       EVP_CIPHER_block_size, EVP_CIPHER_key_length, EVP_CIPHER_iv_length, EVP_CIPHER_flags,
       EVP_CIPHER_mode, EVP_CIPHER_type, EVP_CIPHER_CTX_cipher, EVP_CIPHER_CTX_nid,
       EVP_CIPHER_CTX_block_size, EVP_CIPHER_CTX_key_length, EVP_CIPHER_CTX_iv_length,
       EVP_CIPHER_CTX_get_app_data, EVP_CIPHER_CTX_set_app_data, EVP_CIPHER_CTX_type, EVP_CIPHER_CTX_flags,
       EVP_CIPHER_CTX_mode, EVP_CIPHER_param_to_asn1, EVP_CIPHER_asn1_to_param, EVP_CIPHER_CTX_set_padding -<font color="#ffffff" class="whiteout">EVP&nbsp;EVP_CIPHER_CTX_set_paddingEVP</font>
       EVP cipher routines

<b>SYNOPSIS</b>
        #include &lt;openssl/evp.h&gt;

        void EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *a);

        int EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
                ENGINE *impl, unsigned char *key, unsigned char *iv);
        int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
                int *outl, unsigned char *in, int inl);
        int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out,
                int *outl);

        int EVP_DecryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
                ENGINE *impl, unsigned char *key, unsigned char *iv);
        int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
                int *outl, unsigned char *in, int inl);
        int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm,
                int *outl);

        int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
                ENGINE *impl, unsigned char *key, unsigned char *iv, int enc);
        int EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
                int *outl, unsigned char *in, int inl);
        int EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm,
                int *outl);

        int EVP_EncryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
                unsigned char *key, unsigned char *iv);
        int EVP_EncryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out,
                int *outl);

        int EVP_DecryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
                unsigned char *key, unsigned char *iv);
        int EVP_DecryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm,
                int *outl);

        int EVP_CipherInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
                unsigned char *key, unsigned char *iv, int enc);
        int EVP_CipherFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm,
                int *outl);

        int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *x, int padding);
        int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *x, int keylen);
        int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr);
        int EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *a);

        const EVP_CIPHER *EVP_get_cipherbyname(const char *name);
        #define <!-- a -->EVP_get_cipherbynid(a)<!-- /a --> EVP_get_cipherbyname(OBJ_nid2sn(a))
        #define <!-- a -->EVP_get_cipherbyobj(a)<!-- /a --> EVP_get_cipherbynid(OBJ_obj2nid(a))

        #define <!-- a -->EVP_CIPHER_nid(e)<!-- /a -->              ((e)-&gt;nid)
        #define <!-- a -->EVP_CIPHER_block_size(e)<!-- /a -->       ((e)-&gt;block_size)
        #define <!-- a -->EVP_CIPHER_key_length(e)<!-- /a -->       ((e)-&gt;key_len)
        #define <!-- a -->EVP_CIPHER_iv_length(e)<!-- /a -->                ((e)-&gt;iv_len)
        #define <!-- a -->EVP_CIPHER_flags(e)<!-- /a -->            ((e)-&gt;flags)
        #define <!-- a -->EVP_CIPHER_mode(e)<!-- /a -->             ((e)-&gt;flags) &amp; EVP_CIPH_MODE)
        int EVP_CIPHER_type(const EVP_CIPHER *ctx);

        #define <!-- a -->EVP_CIPHER_CTX_cipher(e)<!-- /a -->       ((e)-&gt;cipher)
        #define <!-- a -->EVP_CIPHER_CTX_nid(e)<!-- /a -->          ((e)-&gt;cipher-&gt;nid)
        #define <!-- a -->EVP_CIPHER_CTX_block_size(e)<!-- /a -->   ((e)-&gt;cipher-&gt;block_size)
        #define <!-- a -->EVP_CIPHER_CTX_key_length(e)<!-- /a -->   ((e)-&gt;key_len)
        #define <!-- a -->EVP_CIPHER_CTX_iv_length(e)<!-- /a -->    ((e)-&gt;cipher-&gt;iv_len)
        #define <!-- a -->EVP_CIPHER_CTX_get_app_data(e)<!-- /a --> ((e)-&gt;app_data)
        #define EVP_CIPHER_CTX_set_app_data(e,d) ((e)-&gt;app_data=(char *)(d))
        #define <!-- a -->EVP_CIPHER_CTX_type(c)<!-- /a -->         EVP_CIPHER_type(EVP_CIPHER_CTX_cipher(c))
        #define <!-- a -->EVP_CIPHER_CTX_flags(e)<!-- /a -->                ((e)-&gt;cipher-&gt;flags)
        #define <!-- a -->EVP_CIPHER_CTX_mode(e)<!-- /a -->         ((e)-&gt;cipher-&gt;flags &amp; EVP_CIPH_MODE)

        int EVP_CIPHER_param_to_asn1(EVP_CIPHER_CTX *c, ASN1_TYPE *type);
        int EVP_CIPHER_asn1_to_param(EVP_CIPHER_CTX *c, ASN1_TYPE *type);

<b>DESCRIPTION</b>
       The EVP cipher routines are a high level interface to certain symmetric ciphers.

       <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>CTX</u><b>_</b><u>init()</u> initializes cipher contex <b>ctx</b>.

       <u>EVP</u><b>_</b><u>EncryptInit</u><b>_</b><u>ex()</u> sets up cipher context <b>ctx</b> for encryption with cipher <b>type</b> from ENGINE <b>impl</b>. <b>ctx</b>
       must be initialized before calling this function. <b>type</b> is normally supplied by a function such as
       <u>EVP</u><b>_</b><u>des</u><b>_</b><u>cbc()</u>. If <b>impl</b> is NULL then the default implementation is used. <b>key</b> is the symmetric key to
       use and <b>iv</b> is the IV to use (if necessary), the actual number of bytes used for the key and IV
       depends on the cipher. It is possible to set all parameters to NULL except <b>type</b> in an initial call
       and supply the remaining parameters in subsequent calls, all of which have <b>type</b> set to NULL. This is
       done when the default cipher parameters are not appropriate.

       <u>EVP</u><b>_</b><u>EncryptUpdate()</u> encrypts <b>inl</b> bytes from the buffer <b>in</b> and writes the encrypted version to <b>out</b>.
       This function can be called multiple times to encrypt successive blocks of data. The amount of data
       written depends on the block alignment of the encrypted data: as a result the amount of data written
       may be anything from zero bytes to (inl + cipher_block_size - 1) so <b>outl</b> should contain sufficient
       room. The actual number of bytes written is placed in <b>outl</b>.

       If padding is enabled (the default) then <u>EVP</u><b>_</b><u>EncryptFinal</u><b>_</b><u>ex()</u> encrypts the "final" data, that is any
       data that remains in a partial block.  It uses standard block padding (aka PKCS padding). The
       encrypted final data is written to <b>out</b> which should have sufficient space for one cipher block. The
       number of bytes written is placed in <b>outl</b>. After this function is called the encryption operation is
       finished and no further calls to <u>EVP</u><b>_</b><u>EncryptUpdate()</u> should be made.

       If padding is disabled then <u>EVP</u><b>_</b><u>EncryptFinal</u><b>_</b><u>ex()</u> will not encrypt any more data and it will return
       an error if any data remains in a partial block: that is if the total data length is not a multiple
       of the block size.

       <u>EVP</u><b>_</b><u>DecryptInit</u><b>_</b><u>ex()</u>, <u>EVP</u><b>_</b><u>DecryptUpdate()</u> and <u>EVP</u><b>_</b><u>DecryptFinal</u><b>_</b><u>ex()</u> are the corresponding decryption
       operations. <u>EVP</u><b>_</b><u>DecryptFinal()</u> will return an error code if padding is enabled and the final block is
       not correctly formatted. The parameters and restrictions are identical to the encryption operations
       except that if padding is enabled the decrypted data buffer <b>out</b> passed to <u>EVP</u><b>_</b><u>DecryptUpdate()</u> should
       have sufficient room for (<b>inl</b> + cipher_block_size) bytes unless the cipher block size is 1 in which
       case <b>inl</b> bytes is sufficient.

       <u>EVP</u><b>_</b><u>CipherInit</u><b>_</b><u>ex()</u>, <u>EVP</u><b>_</b><u>CipherUpdate()</u> and <u>EVP</u><b>_</b><u>CipherFinal</u><b>_</b><u>ex()</u> are functions that can be used for
       decryption or encryption. The operation performed depends on the value of the <b>enc</b> parameter. It
       should be set to 1 for encryption, 0 for decryption and -1 to leave the value unchanged (the actual
       value of 'enc' being supplied in a previous call).

       <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>CTX</u><b>_</b><u>cleanup()</u> clears all information from a cipher context and free up any allocated
       memory associate with it. It should be called after all operations using a cipher are complete so
       sensitive information does not remain in memory.

       <u>EVP</u><b>_</b><u>EncryptInit()</u>, <u>EVP</u><b>_</b><u>DecryptInit()</u> and <u>EVP</u><b>_</b><u>CipherInit()</u> behave in a similar way to
       <u>EVP</u><b>_</b><u>EncryptInit</u><b>_</b><u>ex()</u>, EVP_DecryptInit_ex and <u>EVP</u><b>_</b><u>CipherInit</u><b>_</b><u>ex()</u> except the <b>ctx</b> paramter does not
       need to be initialized and they always use the default cipher implementation.

       <u>EVP</u><b>_</b><u>EncryptFinal()</u>, <u>EVP</u><b>_</b><u>DecryptFinal()</u> and <u>EVP</u><b>_</b><u>CipherFinal()</u> behave in a similar way to
       <u>EVP</u><b>_</b><u>EncryptFinal</u><b>_</b><u>ex()</u>, <u>EVP</u><b>_</b><u>DecryptFinal</u><b>_</b><u>ex()</u> and <u>EVP</u><b>_</b><u>CipherFinal</u><b>_</b><u>ex()</u> except <b>ctx</b> is automatically
       cleaned up after the call.

       <u>EVP</u><b>_</b><u>get</u><b>_</b><u>cipherbyname()</u>, <u>EVP</u><b>_</b><u>get</u><b>_</b><u>cipherbynid()</u> and <u>EVP</u><b>_</b><u>get</u><b>_</b><u>cipherbyobj()</u> return an EVP_CIPHER
       structure when passed a cipher name, a NID or an ASN1_OBJECT structure.

       <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>nid()</u> and <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>CTX</u><b>_</b><u>nid()</u> return the NID of a cipher when passed an <b>EVP_CIPHER</b> or
       <b>EVP_CIPHER_CTX</b> structure.  The actual NID value is an internal value which may not have a
       corresponding OBJECT IDENTIFIER.

       <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>CTX</u><b>_</b><u>set</u><b>_</b><u>padding()</u> enables or disables padding. By default encryption operations are padded
       using standard block padding and the padding is checked and removed when decrypting. If the <b>pad</b>
       parameter is zero then no padding is performed, the total amount of data encrypted or decrypted must
       then be a multiple of the block size or an error will occur.

       <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>key</u><b>_</b><u>length()</u> and <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>CTX</u><b>_</b><u>key</u><b>_</b><u>length()</u> return the key length of a cipher when passed
       an <b>EVP_CIPHER</b> or <b>EVP_CIPHER_CTX</b> structure. The constant <b>EVP_MAX_KEY_LENGTH</b> is the maximum key length
       for all ciphers. Note: although <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>key</u><b>_</b><u>length()</u> is fixed for a given cipher, the value of
       <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>CTX</u><b>_</b><u>key</u><b>_</b><u>length()</u> may be different for variable key length ciphers.

       <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>CTX</u><b>_</b><u>set</u><b>_</b><u>key</u><b>_</b><u>length()</u> sets the key length of the cipher ctx.  If the cipher is a fixed
       length cipher then attempting to set the key length to any value other than the fixed value is an
       error.

       <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>iv</u><b>_</b><u>length()</u> and <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>CTX</u><b>_</b><u>iv</u><b>_</b><u>length()</u> return the IV length of a cipher when passed an
       <b>EVP_CIPHER</b> or <b>EVP_CIPHER_CTX</b>.  It will return zero if the cipher does not use an IV.  The constant
       <b>EVP_MAX_IV_LENGTH</b> is the maximum IV length for all ciphers.

       <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>block</u><b>_</b><u>size()</u> and <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>CTX</u><b>_</b><u>block</u><b>_</b><u>size()</u> return the block size of a cipher when passed
       an <b>EVP_CIPHER</b> or <b>EVP_CIPHER_CTX</b> structure. The constant <b>EVP_MAX_IV_LENGTH</b> is also the maximum block
       length for all ciphers.

       <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>type()</u> and <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>CTX</u><b>_</b><u>type()</u> return the type of the passed cipher or context. This
       "type" is the actual NID of the cipher OBJECT IDENTIFIER as such it ignores the cipher parameters and
       40 bit RC2 and 128 bit RC2 have the same NID. If the cipher does not have an object identifier or
       does not have ASN1 support this function will return <b>NID_undef</b>.

       <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>CTX</u><b>_</b><u>cipher()</u> returns the <b>EVP_CIPHER</b> structure when passed an <b>EVP_CIPHER_CTX</b> structure.

       <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>mode()</u> and <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>CTX</u><b>_</b><u>mode()</u> return the block cipher mode: EVP_CIPH_ECB_MODE,
       EVP_CIPH_CBC_MODE, EVP_CIPH_CFB_MODE or EVP_CIPH_OFB_MODE. If the cipher is a stream cipher then
       EVP_CIPH_STREAM_CIPHER is returned.

       <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>param</u><b>_</b><u>to</u><b>_</b><u>asn1()</u> sets the AlgorithmIdentifier "parameter" based on the passed cipher. This
       will typically include any parameters and an IV. The cipher IV (if any) must be set when this call is
       made. This call should be made before the cipher is actually "used" (before any <u>EVP</u><b>_</b><u>EncryptUpdate()</u>,
       <u>EVP</u><b>_</b><u>DecryptUpdate()</u> calls for example). This function may fail if the cipher does not have any ASN1
       support.

       <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>asn1</u><b>_</b><u>to</u><b>_</b><u>param()</u> sets the cipher parameters based on an ASN1 AlgorithmIdentifier
       "parameter". The precise effect depends on the cipher In the case of RC2, for example, it will set
       the IV and effective key length.  This function should be called after the base cipher type is set
       but before the key is set. For example <u>EVP</u><b>_</b><u>CipherInit()</u> will be called with the IV and key set to
       NULL, <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>asn1</u><b>_</b><u>to</u><b>_</b><u>param()</u> will be called and finally <u>EVP</u><b>_</b><u>CipherInit()</u> again with all
       parameters except the key set to NULL. It is possible for this function to fail if the cipher does
       not have any ASN1 support or the parameters cannot be set (for example the RC2 effective key length
       is not supported.

       <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>CTX</u><b>_</b><u>ctrl()</u> allows various cipher specific parameters to be determined and set. Currently
       only the RC2 effective key length and the number of rounds of RC5 can be set.

<b>RETURN</b> <b>VALUES</b>
       <u>EVP</u><b>_</b><u>EncryptInit</u><b>_</b><u>ex()</u>, <u>EVP</u><b>_</b><u>EncryptUpdate()</u> and <u>EVP</u><b>_</b><u>EncryptFinal</u><b>_</b><u>ex()</u> return 1 for success and 0 for
       failure.

       <u>EVP</u><b>_</b><u>DecryptInit</u><b>_</b><u>ex()</u> and <u>EVP</u><b>_</b><u>DecryptUpdate()</u> return 1 for success and 0 for failure.
       <u>EVP</u><b>_</b><u>DecryptFinal</u><b>_</b><u>ex()</u> returns 0 if the decrypt failed or 1 for success.

       <u>EVP</u><b>_</b><u>CipherInit</u><b>_</b><u>ex()</u> and <u>EVP</u><b>_</b><u>CipherUpdate()</u> return 1 for success and 0 for failure.
       <u>EVP</u><b>_</b><u>CipherFinal</u><b>_</b><u>ex()</u> returns 0 for a decryption failure or 1 for success.

       <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>CTX</u><b>_</b><u>cleanup()</u> returns 1 for success and 0 for failure.

       <u>EVP</u><b>_</b><u>get</u><b>_</b><u>cipherbyname()</u>, <u>EVP</u><b>_</b><u>get</u><b>_</b><u>cipherbynid()</u> and <u>EVP</u><b>_</b><u>get</u><b>_</b><u>cipherbyobj()</u> return an <b>EVP_CIPHER</b>
       structure or NULL on error.

       <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>nid()</u> and <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>CTX</u><b>_</b><u>nid()</u> return a NID.

       <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>block</u><b>_</b><u>size()</u> and <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>CTX</u><b>_</b><u>block</u><b>_</b><u>size()</u> return the block size.

       <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>key</u><b>_</b><u>length()</u> and <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>CTX</u><b>_</b><u>key</u><b>_</b><u>length()</u> return the key length.

       <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>CTX</u><b>_</b><u>set</u><b>_</b><u>padding()</u> always returns 1.

       <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>iv</u><b>_</b><u>length()</u> and <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>CTX</u><b>_</b><u>iv</u><b>_</b><u>length()</u> return the IV length or zero if the cipher does
       not use an IV.

       <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>type()</u> and <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>CTX</u><b>_</b><u>type()</u> return the NID of the cipher's OBJECT IDENTIFIER or
       NID_undef if it has no defined OBJECT IDENTIFIER.

       <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>CTX</u><b>_</b><u>cipher()</u> returns an <b>EVP_CIPHER</b> structure.

       <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>param</u><b>_</b><u>to</u><b>_</b><u>asn1()</u> and <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>asn1</u><b>_</b><u>to</u><b>_</b><u>param()</u> return 1 for success or zero for failure.

<b>CIPHER</b> <b>LISTING</b>
       All algorithms have a fixed key length unless otherwise stated.

       <u>EVP</u><b>_</b><u>enc</u><b>_</b><u>null()</u>
           Null cipher: does nothing.

       EVP_des_cbc(void), EVP_des_ecb(void), EVP_des_cfb(void), EVP_des_ofb(void)
           DES in CBC, ECB, CFB and OFB modes respectively.

       EVP_des_ede_cbc(void), <u>EVP</u><b>_</b><u>des</u><b>_</b><u>ede()</u>, EVP_des_ede_ofb(void),  EVP_des_ede_cfb(void)
           Two key triple DES in CBC, ECB, CFB and OFB modes respectively.

       EVP_des_ede3_cbc(void), <u>EVP</u><b>_</b><u>des</u><b>_</b><u>ede3()</u>, EVP_des_ede3_ofb(void),  EVP_des_ede3_cfb(void)
           Three key triple DES in CBC, ECB, CFB and OFB modes respectively.

       EVP_desx_cbc(void)
           DESX algorithm in CBC mode.

       EVP_rc4(void)
           RC4 stream cipher. This is a variable key length cipher with default key length 128 bits.

       EVP_rc4_40(void)
           RC4 stream cipher with 40 bit key length. This is obsolete and new code should use <u>EVP</u><b>_</b><u>rc4()</u> and
           the <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>CTX</u><b>_</b><u>set</u><b>_</b><u>key</u><b>_</b><u>length()</u> function.

       <u>EVP</u><b>_</b><u>idea</u><b>_</b><u>cbc()</u> EVP_idea_ecb(void), EVP_idea_cfb(void), EVP_idea_ofb(void), EVP_idea_cbc(void)
           IDEA encryption algorithm in CBC, ECB, CFB and OFB modes respectively.

       EVP_rc2_cbc(void), EVP_rc2_ecb(void), EVP_rc2_cfb(void), EVP_rc2_ofb(void)
           RC2 encryption algorithm in CBC, ECB, CFB and OFB modes respectively. This is a variable key
           length cipher with an additional parameter called "effective key bits" or "effective key length".
           By default both are set to 128 bits.

       EVP_rc2_40_cbc(void), EVP_rc2_64_cbc(void)
           RC2 algorithm in CBC mode with a default key length and effective key length of 40 and 64 bits.
           These are obsolete and new code should use <u>EVP</u><b>_</b><u>rc2</u><b>_</b><u>cbc()</u>, <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>CTX</u><b>_</b><u>set</u><b>_</b><u>key</u><b>_</b><u>length()</u> and
           <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>CTX</u><b>_</b><u>ctrl()</u> to set the key length and effective key length.

       EVP_bf_cbc(void), EVP_bf_ecb(void), EVP_bf_cfb(void), EVP_bf_ofb(void);
           Blowfish encryption algorithm in CBC, ECB, CFB and OFB modes respectively. This is a variable key
           length cipher.

       EVP_cast5_cbc(void), EVP_cast5_ecb(void), EVP_cast5_cfb(void), EVP_cast5_ofb(void)
           CAST encryption algorithm in CBC, ECB, CFB and OFB modes respectively. This is a variable key
           length cipher.

       EVP_rc5_32_12_16_cbc(void), EVP_rc5_32_12_16_ecb(void), EVP_rc5_32_12_16_cfb(void),
       EVP_rc5_32_12_16_ofb(void)
           RC5 encryption algorithm in CBC, ECB, CFB and OFB modes respectively. This is a variable key
           length cipher with an additional "number of rounds" parameter. By default the key length is set
           to 128 bits and 12 rounds.

<b>NOTES</b>
       Where possible the <b>EVP</b> interface to symmetric ciphers should be used in preference to the low level
       interfaces. This is because the code then becomes transparent to the cipher used and much more
       flexible.

       PKCS padding works by adding <b>n</b> padding bytes of value <b>n</b> to make the total length of the encrypted
       data a multiple of the block size. Padding is always added so if the data is already a multiple of
       the block size <b>n</b> will equal the block size. For example if the block size is 8 and 11 bytes are to be
       encrypted then 5 padding bytes of value 5 will be added.

       When decrypting the final block is checked to see if it has the correct form.

       Although the decryption operation can produce an error if padding is enabled, it is not a strong test
       that the input data or key is correct. A random block has better than 1 in 256 chance of being of the
       correct format and problems with the input data earlier on will not produce a final decrypt error.

       If padding is disabled then the decryption operation will always succeed if the total amount of data
       decrypted is a multiple of the block size.

       The functions <u>EVP</u><b>_</b><u>EncryptInit()</u>, <u>EVP</u><b>_</b><u>EncryptFinal()</u>, <u>EVP</u><b>_</b><u>DecryptInit()</u>, <u>EVP</u><b>_</b><u>CipherInit()</u> and
       <u>EVP</u><b>_</b><u>CipherFinal()</u> are obsolete but are retained for compatibility with existing code. New code should
       use <u>EVP</u><b>_</b><u>EncryptInit</u><b>_</b><u>ex()</u>, <u>EVP</u><b>_</b><u>EncryptFinal</u><b>_</b><u>ex()</u>, <u>EVP</u><b>_</b><u>DecryptInit</u><b>_</b><u>ex()</u>, <u>EVP</u><b>_</b><u>DecryptFinal</u><b>_</b><u>ex()</u>,
       <u>EVP</u><b>_</b><u>CipherInit</u><b>_</b><u>ex()</u> and <u>EVP</u><b>_</b><u>CipherFinal</u><b>_</b><u>ex()</u> because they can reuse an existing context without
       allocating and freeing it up on each call.

<b>BUGS</b>
       For RC5 the number of rounds can currently only be set to 8, 12 or 16. This is a limitation of the
       current RC5 code rather than the EVP interface.

       EVP_MAX_KEY_LENGTH and EVP_MAX_IV_LENGTH only refer to the internal ciphers with default key lengths.
       If custom ciphers exceed these values the results are unpredictable. This is because it has become
       standard practice to define a generic key as a fixed unsigned char array containing
       EVP_MAX_KEY_LENGTH bytes.

       The ASN1 code is incomplete (and sometimes inaccurate) it has only been tested for certain common
       S/MIME ciphers (RC2, DES, triple DES) in CBC mode.

<b>EXAMPLES</b>
       Get the number of rounds used in RC5:

        int nrounds;
        EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GET_RC5_ROUNDS, 0, &amp;nrounds);

       Get the RC2 effective key length:

        int key_bits;
        EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GET_RC2_KEY_BITS, 0, &amp;key_bits);

       Set the number of rounds used in RC5:

        int nrounds;
        EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_SET_RC5_ROUNDS, nrounds, NULL);

       Set the effective key length used in RC2:

        int key_bits;
        EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_SET_RC2_KEY_BITS, key_bits, NULL);

       Encrypt a string using blowfish:

        int do_crypt(char *outfile)
               {
               unsigned char outbuf[1024];
               int outlen, tmplen;
               /* Bogus key and IV: we'd normally set these from
                * another source.
                */
               unsigned char key[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
               unsigned char iv[] = {1,2,3,4,5,6,7,8};
               char intext[] = "Some Crypto Text";
               EVP_CIPHER_CTX ctx;
               FILE *out;
               EVP_CIPHER_CTX_init(&amp;ctx);
               EVP_EncryptInit_ex(&amp;ctx, EVP_bf_cbc(), NULL, key, iv);

               if(!EVP_EncryptUpdate(&amp;ctx, outbuf, &amp;outlen, intext, strlen(intext)))
                       {
                       /* Error */
                       return 0;
                       }
               /* Buffer passed to EVP_EncryptFinal() must be after data just
                * encrypted to avoid overwriting it.
                */
               if(!EVP_EncryptFinal_ex(&amp;ctx, outbuf + outlen, &amp;tmplen))
                       {
                       /* Error */
                       return 0;
                       }
               outlen += tmplen;
               EVP_CIPHER_CTX_cleanup(&amp;ctx);
               /* Need binary mode for fopen because encrypted data is
                * binary data. Also cannot use strlen() on it because
                * it wont be null terminated and may contain embedded
                * nulls.
                */
               out = fopen(outfile, "wb");
               fwrite(outbuf, 1, outlen, out);
               fclose(out);
               return 1;
               }

       The ciphertext from the above example can be decrypted using the <b>openssl</b> utility with the command
       line:

        S&lt;openssl bf -in cipher.bin -K 000102030405060708090A0B0C0D0E0F -iv 0102030405060708 -d&gt;

       General encryption, decryption function example using FILE I/O and RC2 with an 80 bit key:

        int do_crypt(FILE *in, FILE *out, int do_encrypt)
               {
               /* Allow enough space in output buffer for additional block */
               inbuf[1024], outbuf[1024 + EVP_MAX_BLOCK_LENGTH];
               int inlen, outlen;
               /* Bogus key and IV: we'd normally set these from
                * another source.
                */
               unsigned char key[] = "0123456789";
               unsigned char iv[] = "12345678";
               /* Don't set key or IV because we will modify the parameters */
               EVP_CIPHER_CTX_init(&amp;ctx);
               EVP_CipherInit_ex(&amp;ctx, EVP_rc2(), NULL, NULL, NULL, do_encrypt);
               EVP_CIPHER_CTX_set_key_length(&amp;ctx, 10);
               /* We finished modifying parameters so now we can set key and IV */
               EVP_CipherInit_ex(&amp;ctx, NULL, NULL, key, iv, do_encrypt);

               for(;;)
                       {
                       inlen = fread(inbuf, 1, 1024, in);
                       if(inlen &lt;= 0) break;
                       if(!EVP_CipherUpdate(&amp;ctx, outbuf, &amp;outlen, inbuf, inlen))
                               {
                               /* Error */
                               EVP_CIPHER_CTX_cleanup(&amp;ctx);
                               return 0;
                               }
                       fwrite(outbuf, 1, outlen, out);
                       }
               if(!EVP_CipherFinal_ex(&amp;ctx, outbuf, &amp;outlen))
                       {
                       /* Error */
                       EVP_CIPHER_CTX_cleanup(&amp;ctx);
                       return 0;
                       }
               fwrite(outbuf, 1, outlen, out);

               EVP_CIPHER_CTX_cleanup(&amp;ctx);
               return 1;
               }

<b>SEE</b> <b>ALSO</b>
       <a href="evp.3ssl.html#//apple_ref/doc/man/3/evp"><u>evp</u>(3)</a>

<b>HISTORY</b>
       <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>CTX</u><b>_</b><u>init()</u>, <u>EVP</u><b>_</b><u>EncryptInit</u><b>_</b><u>ex()</u>, <u>EVP</u><b>_</b><u>EncryptFinal</u><b>_</b><u>ex()</u>, <u>EVP</u><b>_</b><u>DecryptInit</u><b>_</b><u>ex()</u>,
       <u>EVP</u><b>_</b><u>DecryptFinal</u><b>_</b><u>ex()</u>, <u>EVP</u><b>_</b><u>CipherInit</u><b>_</b><u>ex()</u>, <u>EVP</u><b>_</b><u>CipherFinal</u><b>_</b><u>ex()</u> and <u>EVP</u><b>_</b><u>CIPHER</u><b>_</b><u>CTX</u><b>_</b><u>set</u><b>_</b><u>padding()</u>
       appeared in OpenSSL 0.9.7.



0.9.7l                                           2005-04-15                               <a href="EVP_EncryptInit.3ssl.html#//apple_ref/doc/man/3/EVP_EncryptInit">EVP_EncryptInit(3)</a>
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/EVP_CipherInit.3ssl.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/EVP_CipherInit.3ssl.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/EVP_CipherInit.3ssl.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
