<HTML>		<HEAD>		<TITLE>			EOFaultHandler		</TITLE>		</HEAD>	<body bgcolor="#ffffff"><!--start of banner --><!--#include virtual="/includes/framesetheader" --><!-- end of banner --><!--start of path --><font face="Geneva,Helvetica,Arial" size="1"><b>PATH<spacer type="horizontal" size="5">&nbsp;</b> <a href="../../../../../../../index.html" target="_top">Documentation</a> <b>&gt;</b> <a href="../../../../../../webobjects.html" target="_top">WebObjects 4.5</a> <b>&gt;</b>EOControl Reference</font><br><br><!--end of path --><a href="../EOControlTOC.html"><img src="../../../../../../images/up.gif" border="0" alt="Table of Contents"></a> <a name = "EOFaultHandler"><BR><h1><FONT COLOR="#000066"><a name="//apple_ref/occ/cl/EOFaultHandler">EOFaultHandler</a></FONT></h1><br></a><blockquote><dl><dt><b>Inheritsfrom: </b></dt><dd> NSObject</dd></dl></blockquote><blockquote><dl><dt><b>Conforms to: </b></dt><dd> NSObject</dd><dd>(NSObject)</dd></dl></blockquote><blockquote><dl><b>Declared in: </b><dd>EOControl/EOFault.h</dd></dl></blockquote><br><br><HR SIZE=4><br><h2>Class Description</h2><hr><p>EOFaultHandler is an abstract class that defines the mechanismsthat create faults (EOFault objects) and help them to fire. <em>Faults</em> areused as placeholders for an enterprise object's relationship destinations.For example, suppose an Employee object has a <b>department</b> relationshipto the employee's department. When an employee is fetched, faultsare created for its relationship destinations. In the case of the <b>department</b> relationship,an empty Department object is created. The Department object'sdata isn't fetched until the Department is accessed, at whichtime the fault is said to <em>fire</em>.</p><p>Subclasses of EOFaultHandler perform the specific steps necessaryto get data for the fault and fire it. The Access Layer, for example,uses private subclasses to fetch data using an EODatabaseContext (definedin EOAccess). Most of EOFaultHandler's methods are properly defined;you need only override  <a frame= "conv" href="#//apple_ref/occ/instm/EOFaultHandler/completeInitializationOfObject:">completeInitializationOfObject:</a> toprovide appropriate behavior. In Yellow Box applications, you canoptionally implement  <a frame= "conv" href="#//apple_ref/occ/instm/EOFaultHandler/faultWillFire:">faultWillFire:</a> toprepare for conversion, and  <a frame= "conv" href="#//apple_ref/occ/instm/EOFaultHandler/shouldPerformInvocation:">shouldPerformInvocation:</a> tointercept particular messages sent to the fault without causingit to fire.</p><p>In a Yellow Box application you create an EOFaultHandler usingthe standard <b>alloc and init methods, possibly usinga more specific init method with your subclass</b>. Tocreate a fault you invoke EOFault's  <a frame= "conv" href="../Classes/EOFault.html#//apple_ref/occ/clm/EOFault/makeObjectIntoFault:withHandler:">makeObjectIntoFault:withHandler:</a> classmethod with the object to turn into a fault and the EOFaultHandler.An EOFaultHandler belongs exclusively to a single fault, and shouldn'tbe shared or used by any other object.</p><br><h2>Firing a Fault</h2><p>When a fault receives a message that requires it to fire,it sends a  <a frame= "conv" href="#//apple_ref/occ/instm/EOFaultHandler/completeInitializationOfObject:">completeInitializationOfObject:</a> methodto its EOFaultHandler. This method is responsible for invoking EOFault's  <a frame= "conv" href="../Classes/EOFault.html#//apple_ref/occ/clm/EOFault/clearFault:">clearFault:</a>class method to revertthe fault to its original state, and then do whatever is necessaryto complete initialization of the object. Doing so typically involvesfetching data from an external repository and passing it to theobject.</p><p>As a trivial example, consider a subclass called FileFaultHandler,that simply stores a filename whose contents it reads from disk.Its initialization and  <a frame= "conv" href="#//apple_ref/occ/instm/EOFaultHandler/completeInitializationOfObject:">completeInitializationOfObject:</a> methodsmight look like these:</p><blockquote><pre>- (id)initWithFile:(NSString *)path{    self = [super init];    filename = [path copy];    return self;}- (void)completeInitializationOfObject:(id)anObject{    NSString *fileContents;    [self retain];      // retain self so we won't get released by clearing the                        // fault. Otherwise, accessing "filename" will cause a crash.    [EOFault clearFault:anObject];    fileContents = [NSString stringWithContentsOfFile:filename];    [anObject takeValue:fileContents forKey:@"fileContents"];    [self release];    return;}</pre></blockquote><br><p><b>initWithFile:</b> just stores the pathof the file to read in the instance variable <b>filename</b>.  <a frame= "conv" href="#//apple_ref/occ/instm/EOFaultHandler/completeInitializationOfObject:">completeInitializationOfObject:</a> invokesEOFault's <b>clearFault:</b> method, which revertsthe fault into its original state (and also releases the fault handler,so references to <b>self</b> after this are illegal).It then gets the contents of the file it was created with and passesthem to the reverted object. Note that this implementation doesn'tassume the class of the cleared EOFault, instead using the generic <b>takeValue:forKey:</b> methodto assign the file contents to it.</p><br><br><br><h2>Method Types</h2><hr><blockquote><dl><dt>Creating and examiningfaults</dt><dd> <a frame= "conv" href="#//apple_ref/occ/instm/EOFaultHandler/createFaultForDeferredFault:sourceObject:">- createFaultForDeferredFault:sourceObject:</a></dd></dl><dl><dt>Setting the target classand extra data</dt><dd> <a frame= "conv" href="#//apple_ref/occ/instm/EOFaultHandler/setTargetClass:extraData:">- setTargetClass:extraData:</a></dd><dd> <a frame= "conv" href="#//apple_ref/occ/instm/EOFaultHandler/targetClass">- targetClass</a></dd><dd> <a frame= "conv" href="#//apple_ref/occ/instm/EOFaultHandler/extraData">- extraData</a></dd></dl><dl><dt>Reference counting</dt><dd> <a frame= "conv" href="#//apple_ref/occ/instm/EOFaultHandler/incrementExtraRefCount">- incrementExtraRefCount</a></dd><dd> <a frame= "conv" href="#//apple_ref/occ/instm/EOFaultHandler/decrementExtraRefCountIsZero">- decrementExtraRefCountIsZero</a></dd><dd> <a frame= "conv" href="#//apple_ref/occ/instm/EOFaultHandler/extraRefCount">- extraRefCount</a></dd></dl><dl><dt>Getting the originalclass</dt><dd> <a frame= "conv" href="#//apple_ref/occ/instm/EOFaultHandler/classForFault:">- classForFault:</a></dd></dl><dl><dt>Firing a fault</dt><dd> <a frame= "conv" href="#//apple_ref/occ/instm/EOFaultHandler/completeInitializationOfObject:">- completeInitializationOfObject:</a></dd><dd> <a frame= "conv" href="#//apple_ref/occ/instm/EOFaultHandler/faultWillFire:">- faultWillFire:</a></dd><dd> <a frame= "conv" href="#//apple_ref/occ/instm/EOFaultHandler/shouldPerformInvocation:">- shouldPerformInvocation:</a></dd></dl><dl><dt>Getting a description</dt><dd> <a frame= "conv" href="#//apple_ref/occ/instm/EOFaultHandler/descriptionForObject:">- descriptionForObject:</a></dd></dl><dl><dt>Checking class information</dt><dd> <a frame= "conv" href="#//apple_ref/occ/instm/EOFaultHandler/isKindOfClass:forFault:">- isKindOfClass:forFault:</a></dd><dd> <a frame= "conv" href="#//apple_ref/occ/instm/EOFaultHandler/isMemberOfClass:forFault:">- isMemberOfClass:forFault:</a></dd><dd> <a frame= "conv" href="#//apple_ref/occ/instm/EOFaultHandler/conformsToProtocol:forFault:">- conformsToProtocol:forFault:</a></dd><dd> <a frame= "conv" href="#//apple_ref/occ/instm/EOFaultHandler/methodSignatureForSelector:forFault:">- methodSignatureForSelector:forFault:</a></dd><dd> <a frame= "conv" href="#//apple_ref/occ/instm/EOFaultHandler/respondsToSelector:forFault:">- respondsToSelector:forFault:</a></dd></dl></blockquote><BR><BR><h2>Instance Methods</h2><hr><a name = "CHBCIDGC"><BR><h3><a name="//apple_ref/occ/instm/EOFaultHandler/classForFault:">classForFault:</a></h3></a><p><code>- (Class)<b>classForFault:</b>(id)<em>fault</em></code></p>Returns the target class of the receiver's EOFault,which must be passed as <em>aFault</em> incase the receiver needs to fire it (EOFaultHandlers don't storeback pointers to their faults). For example, to support entity inheritance,the Access layer fires faults for entities with subentities to confirmtheir precise class membership.<p><b>See Also: </b>  <a frame= "conv" href="#//apple_ref/occ/instm/EOFaultHandler/targetClass">- targetClass</a></p><hr WIDTH=25% ALIGN=LEFT><a name = "completeInitializationOfObject_"><BR><h3><a name="//apple_ref/occ/instm/EOFaultHandler/completeInitializationOfObject:">completeInitializationOfObject:</a></h3></a><p><code>- (void)<b>completeInitializationOfObject:</b>(id)<em>aFault</em></code></p>Implemented by subclasses to revert <em>aFault</em> toits original state and complete its initialization in whatever meansis appropriate to the subclass. For example, the Access layer subclassesof EOFaultHandler fetch data from the database and pass it to theobject. This method is invoked automatically by a fault when it'ssent a message it can't handle without fetching its data. EOFaultHandler'simplementation merely throws an exception.<hr WIDTH=25% ALIGN=LEFT><a name = "conformsToProtocol_forFault_"><BR><h3><a name="//apple_ref/occ/instm/EOFaultHandler/conformsToProtocol:forFault:">conformsToProtocol:forFault:</a></h3></a><p><code>- (BOOL)<b>conformsToProtocol:</b>(Protocol*)<em>aProtocol</em><b>forFault:</b>(id)<em>aFault</em></code></p>Returns YES if the target class of the receiver'sEOFault conforms to <em>aProtocol</em>. ThisEOFault must be passed as <em>aFault</em> incase the receiver needs to fire it (EOFaultHandlers don't storeback pointers to their faults). For example, to support entity inheritance,the Access layer fires faults for entities with subentities to confirmtheir precise class membership.<p><b>See Also: </b>  <a frame= "conv" href="#//apple_ref/occ/instm/EOFaultHandler/completeInitializationOfObject:">- completeInitializationOfObject:</a></p><hr WIDTH=25% ALIGN=LEFT><a name = "DAJBDIHG"><BR><h3><a name="//apple_ref/occ/instm/EOFaultHandler/createFaultForDeferredFault:sourceObject:">createFaultForDeferredFault:sourceObject:</a></h3></a><p><code>- (id)<b>createFaultForDeferredFault:</b>(id)<em>fault</em><b>sourceObject:</b>(id)<em>eo</em></code></p>Invoked by  <a frame= "conv" href="../Protocols/EODeferredFaulting.html#//apple_ref/java/intfm/EODeferredFaulting/willReadRelationship">willReadRelationship</a> to ensure that <em>fault</em> isn'ta deferred fault, and to replace it with a normal fault if it is.EOFaultHandler's implementation simply returns its fault. A privatesubclass that handles deferred faulting implements this method toreturn a normal fault if <em>fault</em> isa deferred fault, so you should never need to override this method.<hr WIDTH=25% ALIGN=LEFT><a name = "decrementExtraRefCountWasZero"><BR><h3><a name="//apple_ref/occ/instm/EOFaultHandler/decrementExtraRefCountIsZero">decrementExtraRefCountIsZero</a></h3></a><p><code>- (BOOL)<b>decrementExtraRefCountIsZero</b></code></p>Decrements the reference count for the receiver'sfault. An object's reference count is the number of objects thatare accessing it. Newly created objects have a reference count ofone. If another object is referencing an object, the object is saidto have an extra reference count. <p>If, after decrementing thereference count, the fault's new reference count is zero, thismethod returns YES, If the reference count has not become zero,this method returns NO. Objects that have a zero reference countare released at the end of the current event loop.</p><p>Thismethod is used by EOFaultHandler's internal reference countingmechanism-it functions as the Foundation function <code>NSDecrementExtraRefCountWasZero()</code> forthe receiver's EOFault.</p><hr WIDTH=25% ALIGN=LEFT><a name = "descriptionForObject_"><BR><h3><a name="//apple_ref/occ/instm/EOFaultHandler/descriptionForObject:">descriptionForObject:</a></h3></a><p><code>- (NSString *)<b>descriptionForObject:</b>(id)<em>aFault</em></code></p>Returns a string naming the original class ofthe receiver's fault and giving <em>aFault</em>'s id,and also noting that it's a fault; for example: "&lt;Employee(Fault 0x3a07)&gt;". (The fault must be passed as <em>aFault</em> because EOFaultHandlersdon't store back pointers to their faults.)<hr WIDTH=25% ALIGN=LEFT><a name = "extraData"><BR><h3><a name="//apple_ref/occ/instm/EOFaultHandler/extraData">extraData</a></h3></a><p><code>- (void *)<b>extraData</b></code></p>Returns the bytes replaced by the receiver's <b>id</b> inthe original object's state, as a pointer to <b>void</b>.When the receiver's EOFault is reverted to its original state,both its <b>isa</b> pointer and this data arereplaced.<hr WIDTH=25% ALIGN=LEFT><a name = "extraRefCount"><BR><h3><a name="//apple_ref/occ/instm/EOFaultHandler/extraRefCount">extraRefCount</a></h3></a><p><code>- (unsigned int)<b>extraRefCount</b></code></p>Returns the receiver's current reference count.This method is used by EOFaultHandler's internal reference countingmechanism and functions as the Foundation function NSExtraRefCount()for the receiver's EOFault.<hr WIDTH=25% ALIGN=LEFT><a name = "faultWillFire_"><BR><h3><a name="//apple_ref/occ/instm/EOFaultHandler/faultWillFire:">faultWillFire:</a></h3></a><p><code>- (void)<b>faultWillFire:</b>(id)<em>aFault</em></code></p>Informs the receiver that <em>aFault</em> isabout to be reverted to its original state. EOFaultHandler's implementationdoes nothing. This method is invoked by EOFault's  <a frame= "conv" href="../Classes/EOFault.html#//apple_ref/occ/clm/EOFault/clearFault:">clearFault:</a> method.<hr WIDTH=25% ALIGN=LEFT><a name = "incrementExtraRefCount"><BR><h3><a name="//apple_ref/occ/instm/EOFaultHandler/incrementExtraRefCount">incrementExtraRefCount</a></h3></a><p><code>- (void)<b>incrementExtraRefCount</b></code></p>Increments the reference count for the receiver'sfault. An object's reference count is the number of objects thatare accessing it. Newly created objects have a reference count ofone. If another object is referencing an object, the object is saidto have an extra reference count. <p>This method is used by EOFaultHandler'sinternal reference counting mechanism and functions as the Foundationfunction NSIncrementExtraRefCount() for the receiver's EOFault.</p><p><b>SeeAlso: </b>  <a frame= "conv" href="#//apple_ref/occ/instm/EOFaultHandler/extraRefCount">- extraRefCount</a></p><hr WIDTH=25% ALIGN=LEFT><a name = "isKindOfClass_forFault_"><BR><h3><a name="//apple_ref/occ/instm/EOFaultHandler/isKindOfClass:forFault:">isKindOfClass:forFault:</a></h3></a><p><code>- (BOOL)<b>isKindOfClass:</b>(Class)<em>aClass</em><b>forFault:</b>(id)<em>aFault</em></code></p>Returns YES if the target class of the receiver'sfault is <em>aClass</em> or a subclass of <em>aClass</em>.The fault must be passed in as <em>aFault</em> incase the receiver needs to fire it (EOFaultHandlers don't storeback pointers to their faults). For example, to support entity inheritance,the Access layer fires faults for entities with subentities to confirmtheir precise class membership.<p><b>See Also: </b>  <a frame= "conv" href="#//apple_ref/occ/instm/EOFaultHandler/completeInitializationOfObject:">- completeInitializationOfObject:</a></p><hr WIDTH=25% ALIGN=LEFT><a name = "isMemberOfClass_forFault_"><BR><h3><a name="//apple_ref/occ/instm/EOFaultHandler/isMemberOfClass:forFault:">isMemberOfClass:forFault:</a></h3></a><p><code>- (BOOL)<b>isMemberOfClass:</b>(Class)<em>aClass</em><b>forFault:</b>(id)<em>aFault</em></code></p>Returns YES if the target class of the receiver'sfault is <em>aClass</em>. This fault mustbe passed as <em>aFault</em> in case the receiverneeds to fire it (EOFaultHandlers don't store back pointers totheir faults). For example, to support entity inheritance, the Accesslayer fires faults for entities with subentities to confirm their preciseclass membership.<p><b>See Also: </b>  <a frame= "conv" href="#//apple_ref/occ/instm/EOFaultHandler/completeInitializationOfObject:">- completeInitializationOfObject:</a></p><hr WIDTH=25% ALIGN=LEFT><a name = "methodSignatureForSelector_forFault_"><BR><h3><a name="//apple_ref/occ/instm/EOFaultHandler/methodSignatureForSelector:forFault:">methodSignatureForSelector:forFault:</a></h3></a><p><code>- (NSMethodSignature *)<b>methodSignatureForSelector:</b>(SEL)<em>aSelector</em><b>forFault:</b>(id)<em>aFault</em></code></p>Returns the NSMethodSignature for <em>aSelector</em> inthe target class of the receiver's EOFault, which must be passedas <em>aFault</em> in case the receiver needsto fire it (EOFaultHandlers don't store back pointers to theirfaults). For example, to support entity inheritance, the Accesslayer fires faults for entities with subentities to confirm theirprecise class membership.<p><b>See Also: </b>  <a frame= "conv" href="#//apple_ref/occ/instm/EOFaultHandler/completeInitializationOfObject:">- completeInitializationOfObject:</a></p><hr WIDTH=25% ALIGN=LEFT><a name = "respondsToSelector_forFault_"><BR><h3><a name="//apple_ref/occ/instm/EOFaultHandler/respondsToSelector:forFault:">respondsToSelector:forFault:</a></h3></a><p><code>- (BOOL)<b>respondsToSelector:</b>(SEL)<em>aSelector</em><b>forFault:</b>(id)<em>aFault</em></code></p>Returns YES if the target class of the receiver'sfault responds to <em>aSelector</em>. Thisfault must be passed as <em>aFault</em> incase the receiver needs to fire it (EOFaultHandlers don't store backpointers to their faults). For example, to support entity inheritance,the Access layer fires faults for entities with subentities to confirmtheir precise class membership.<p><b>See Also: </b>  <a frame= "conv" href="#//apple_ref/occ/instm/EOFaultHandler/completeInitializationOfObject:">- completeInitializationOfObject:</a></p><hr WIDTH=25% ALIGN=LEFT><a name = "setTargetClass_extraData_"><BR><h3><a name="//apple_ref/occ/instm/EOFaultHandler/setTargetClass:extraData:">setTargetClass:extraData:</a></h3></a><p><code>- (void)<b>setTargetClass:</b>(Class)<em>targetClass</em><b>extraData:</b>(void *)<em>extraData</em></code></p>Stores <em>targetClass</em> and <em>extraData</em> asstate of the original object overwritten when an EOFault is created byEOFault's  <a frame= "conv" href="../Classes/EOFault.html#//apple_ref/occ/clm/EOFault/makeObjectIntoFault:withHandler:">makeObjectIntoFault:withHandler:</a> method,which replaces <em>targetClass</em> with theEOFault class, and <em>extraData</em> withthe EOFaultHandler's <code>id</code>.<hr WIDTH=25% ALIGN=LEFT><a name = "shouldPerformInvocation_"><BR><h3><a name="//apple_ref/occ/instm/EOFaultHandler/shouldPerformInvocation:">shouldPerformInvocation:</a></h3></a><p><code>- (BOOL)<b>shouldPerformInvocation:</b>(NSInvocation*)<em>anInvocation</em></code></p>Overridden by subclasses to circumvent reversionof an EOFault to its original state. Returns YES if the EOFaultshould revert and perform <em>anInvocation</em>,NO if it shouldn't. If this method returns NO, the receiver shouldset <em>anInvocation</em>'s return valueappropriately. EOFaultHandler's implementation returns YES.<p><b>SeeAlso: </b> <b>- setReturnValue:</b> (NSInvocationclass of the Foundation Framework)</p><hr WIDTH=25% ALIGN=LEFT><a name = "targetClass"><BR><h3><a name="//apple_ref/occ/instm/EOFaultHandler/targetClass">targetClass</a></h3></a><p><code>- (Class)<b>targetClass</b></code></p>Returns the target class of the receiver'sfault. The fault may, however, be converted to a member of this classor of a subclass of this class. For example, to support entity inheritance,the Access layer fires faults for entities with subentities intothe appropriate class on fetching their data.<hr WIDTH=25% ALIGN=LEFT><BR><br><a href="../EOControlTOC.html"><img src="../../../../../../images/up.gif" border="0" alt="Table of Contents"></a> </BODY></HTML>