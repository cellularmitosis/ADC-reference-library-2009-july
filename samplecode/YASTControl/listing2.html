<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>YASTControl - /YASTControl.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/Carbon/index.html">Carbon</a> &gt; <a href="../../samplecode/Carbon/idxUserExperience-date.html">User Experience</a> &gt; <A HREF="javascript:location.replace('index.html');">YASTControl</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">YASTControl</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/YASTControl.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/main.c</option>
<option value="listing2.html">/YASTControl.c</option>
<option value="listing3.html">/YASTControl.h</option></select>
				</p>
				</form>
				<p><strong><a href="YASTControl.zip">Download Sample</a></strong> (&#147;YASTControl.zip&#148;, 56.4K)<BR>
<strong><a href="YASTControl.dmg">Download Sample</a></strong> (&#147;YASTControl.dmg&#148;, 112.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    YASTControl.c    Description:        Yet Another Scrolling Text (YAST) Control.      Yast, it lets you edit Unicode text.  Author:    JM  Copyright:   &copy; Copyright 2003 Apple Computer, Inc. All rights reserved.    Disclaimer:  IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc.        (&quot;Apple&quot;) in consideration of your agreement to the following terms, and your        use, installation, modification or redistribution of this Apple software        constitutes acceptance of these terms.  If you do not agree with these terms,        please do not use, install, modify or redistribute this Apple software.        In consideration of your agreement to abide by the following terms, and subject        to these terms, Apple grants you a personal, non-exclusive license, under Apple's        copyrights in this original Apple software (the &quot;Apple Software&quot;), to use,        reproduce, modify and redistribute the Apple Software, with or without        modifications, in source and/or binary forms; provided that if you redistribute        the Apple Software in its entirety and without modifications, you must retain        this notice and the following text and disclaimers in all such redistributions of        the Apple Software.  Neither the name, trademarks, service marks or logos of        Apple Computer, Inc. may be used to endorse or promote products derived from the        Apple Software without specific prior written permission from Apple.  Except as        expressly stated in this notice, no other rights or licenses, express or implied,        are granted by Apple herein, including but not limited to any patent rights that        may be infringed by your derivative works or by other works in which the Apple        Software may be incorporated.        The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE MAKES NO        WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED        WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR        PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN        COMBINATION WITH YOUR PRODUCTS.        IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR        CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE        GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)        ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION        OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT        (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN        ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.          Change History (most recent first):        Fri, Jan 28, 2000 -- created        Fri, Jan 14, 2003 -- carbon event based, removed wne codes        Fri, Apr 17, 2003 -- added data accessors*/#include &quot;YASTControl.h&quot;  /* YASTControlVars is a structure used for storing the the YASTControl's  internal variables and state information.  A reference to this structure  is maintained by the carbon event manager and accessed in the control's  carbon event handler by way of the userData parameter. */typedef struct YASTControlVars YASTControlVars;typedef YASTControlVars *YASTControlVarsPtr;struct YASTControlVars {    /* OS records referenced */  TXNObject fTXNObject; /* the txn record */  TXNFrameID fTXNFrameID; /* the txn frame ID */  ControlRef fControl;  /* handle to the user pane control */  WindowRef fWindow; /* window containing control */  CGrafPtr fGrafPtr; /* grafport where control is drawn */    /* flags */  Boolean fInFocus; /* true while the focus rect is drawn around the control */  Boolean fIsActive; /* true while the control is drawn in the active state */  Boolean fTXNObjectActive; /* reflects the activation state of the text edit record */   Boolean fTabMovesFocus; /* true if tab moves focus (default: true) */   Boolean fDrawFocusBox; /* true if focus is drawn (default: true) */   Boolean fFocusDrawState; /* true if focus is drawn (default: true) */   Boolean fIsReadOnly; /* true if control is read only (default: false) */    /* calculated locations */  Rect fRBounds; /* complete bounds of control */  Rect fRTextArea; /* where the fTXNObject lives */  Rect fRFocusOutline;  /* where the focus rectangle is drawn */  Rect fRTextOutline; /* where the text box border is drawn */  RgnHandle fRTextOutlineRegion; /* fRTextOutline stored as a region handle */    /* event handler refs */  EventHandlerRef fControlEvents; /* handlers we install for this control */  EventHandlerRef fWindowEvents; /* handlers we install in the control's window */};  /* SetTextActivation activates or deactivates the text edit record  according to the value of setActive.  This routine ensures the activation  switching call is only performed once for any particular activation state. */static void SetTextActivation(YASTControlVars *varsp, Boolean setActive) {  OSStatus err;  if (varsp-&gt;fTXNObjectActive != setActive) {      varsp-&gt;fTXNObjectActive = setActive;        err = TXNActivate(varsp-&gt;fTXNObject, varsp-&gt;fTXNFrameID, varsp-&gt;fTXNObjectActive);        if (varsp-&gt;fInFocus)      TXNFocus( varsp-&gt;fTXNObject, varsp-&gt;fTXNObjectActive);  }}  /* RedrawFocusOutline redraws the focus rectangle as appropriate  for the current focus, activation, and drawing state.  This routine  ensures the focus rectangle drawing is only performed once in any  particular focus state. */static void RedrawFocusOutline(YASTControlVars *varsp) {  if (varsp-&gt;fDrawFocusBox) { /* drawing is on */    if (varsp-&gt;fFocusDrawState != (varsp-&gt;fIsActive &amp;&amp; varsp-&gt;fInFocus)) { /* state changed */      varsp-&gt;fFocusDrawState = (varsp-&gt;fIsActive &amp;&amp; varsp-&gt;fInFocus);      SetPort(varsp-&gt;fGrafPtr);      DrawThemeFocusRect(&amp;varsp-&gt;fRFocusOutline, varsp-&gt;fFocusDrawState);    }  } else if (varsp-&gt;fFocusDrawState) { /* was drawn, but drawing has been turned off */    varsp-&gt;fFocusDrawState = false;    SetPort(varsp-&gt;fGrafPtr);    DrawThemeFocusRect(&amp;varsp-&gt;fRFocusOutline, false);  }}  /* YASTControlCalculateBounds is called to recalculate all of the internal rectangles  in the YASTControl's internal structures.  bounds is the control's rectangle, the  coordinates calculated in this routine are used to place the TXNObject, draw the focus  rectangle, and draw the text box outline. */static void YASTControlCalculateBounds(YASTControlVars *varsp, Rect* bounds) {  SetRect(&amp;varsp-&gt;fRBounds, bounds-&gt;left, bounds-&gt;top, bounds-&gt;right, bounds-&gt;bottom);  SetRect(&amp;varsp-&gt;fRFocusOutline, bounds-&gt;left, bounds-&gt;top, bounds-&gt;right, bounds-&gt;bottom);  SetRect(&amp;varsp-&gt;fRTextOutline, bounds-&gt;left+1, bounds-&gt;top+1, bounds-&gt;right-1, bounds-&gt;bottom-1);  SetRect(&amp;varsp-&gt;fRTextArea, bounds-&gt;left+2, bounds-&gt;top+3, bounds-&gt;right-3, bounds-&gt;bottom-2);  RectRgn(varsp-&gt;fRTextOutlineRegion, &amp;varsp-&gt;fRTextOutline);}  /* control events we handle.  We use this array of EventTypeSpec  records to attach a carbon event handler to the control's event  handling target. */static const EventTypeSpec gYASTControlEvents[] = {  { kEventClassMouse, kEventMouseDown },  { kEventClassControl, kEventControlClick },  { kEventClassCommand, kEventProcessCommand },  { kEventClassCommand, kEventCommandUpdateStatus },  { kEventClassTextInput, kEventUnicodeForKeyEvent },  { kEventClassControl, kEventControlSetCursor },  { kEventClassControl, kEventControlDispose },  { kEventClassControl, kEventControlSetData },  { kEventClassControl, kEventControlGetData },  { kEventClassControl, kEventControlBoundsChanged },  { kEventClassControl, kEventControlActivate },  { kEventClassControl, kEventControlDeactivate },  { kEventClassControl, kEventControlHitTest },  { kEventClassControl, kEventControlDraw },  { kEventClassControl, kEventControlSetCursor },  { kEventClassControl, kEventControlSetFocusPart }};  /* window events we handle.  We use this array of EventTypeSpec  records to attach a carbon event handler to the control's window's  event handling target. */static const EventTypeSpec gYASTControlWindowEvents[] = {  { kEventClassWindow, kEventWindowCursorChange },};  /* YASTControlSetData is dispatched from our control event handler.  It is where  we handle all calls to SetControlData directed to our control. */static OSStatus YASTControlSetData(            YASTControlVarsPtr varsp,             ResType inTagName,            void * inBuffer,            Size inBufferSize) {  OSStatus err, returnedResult;    /* default result */  returnedResult = eventNotHandledErr;    /* dispatch according to the tag */  switch (inTagName) {      case kYASTControlAllTextTag: /* char* */    case kYASTControlSelectedTextTag: /* char* */      {  TXNOffset oStartOffset, oEndOffset;          /* pick the range of chars we want to replace */        if (inTagName == kYASTControlSelectedTextTag)           TXNGetSelection( varsp-&gt;fTXNObject, &amp;oStartOffset, &amp;oEndOffset);        else { oStartOffset = kTXNStartOffset; oEndOffset = kTXNEndOffset; }          /* get the new text */        err = TXNSetData( varsp-&gt;fTXNObject, kTXNTextData,            inBuffer, inBufferSize, oStartOffset, oEndOffset );      }      returnedResult = err;      break;        case kYASTControlAllUnicodeTextTag: /* CFStringRef */    case kYASTControlSelectedUnicodeTextTag: /* CFStringRef */      if (inBufferSize != sizeof(CFStringRef)) {        err = paramErr;      } else {        CFStringRef theString;        CFIndex length;        UniChar *buffer;        TXNOffset oStartOffset, oEndOffset;          /* pick the range of chars we want to replace */        if (inTagName == kYASTControlSelectedUnicodeTextTag)           TXNGetSelection( varsp-&gt;fTXNObject, &amp;oStartOffset, &amp;oEndOffset);        else { oStartOffset = kTXNStartOffset; oEndOffset = kTXNEndOffset; }        theString = * (CFStringRef*) inBuffer;          /* get the new text */        length = CFStringGetLength(theString);        buffer = (UniChar *) malloc(length*sizeof(UniChar));        if (buffer != NULL) {          CFRange range;          range.location = 0;          range.length = length;          CFStringGetCharacters(theString, range, buffer);            /* add the new text */          err = TXNSetData( varsp-&gt;fTXNObject, kTXNUnicodeTextData,                  buffer, length*2, oStartOffset, oEndOffset);          free(buffer);        } else {          err = memFullErr;        }      }      returnedResult = err;      break;        case kYASTControlSelectionRangeTag: /* YASTControlEditTextSelectionRec */      if (inBufferSize != sizeof(CFRange)) {        err = paramErr;      } else {        YASTControlEditTextSelectionPtr range;        range = (YASTControlEditTextSelectionPtr) inBuffer;        err = TXNSetSelection( varsp-&gt;fTXNObject, range-&gt;selStart, range-&gt;selEnd);        if (err == noErr) {          TXNShowSelection( varsp-&gt;fTXNObject, false);        }      }      returnedResult = err;      break;    case kYASTControlTabsAdvanceFocusTag: /* Boolean (default true) */      if (inBufferSize != sizeof(Boolean)) {        err = paramErr;      } else {        varsp-&gt;fTabMovesFocus = * (Boolean*) inBuffer;        err = noErr;      }      returnedResult = err;      break;          case kYASTControlDoDrawFocusTag: /* Boolean (default true) */      if (inBufferSize != sizeof(Boolean)) {        err = paramErr;      } else {        varsp-&gt;fDrawFocusBox = * (Boolean*) inBuffer;        RedrawFocusOutline(varsp);        err = noErr;      }      returnedResult = err;      break;          case kYASTControlReadOnlyTag:      if (inBufferSize != sizeof(Boolean)) {        err = paramErr;      } else {        TXNControlData txnCControlData;        TXNControlTag txnControlTag;        txnControlTag = kTXNIOPrivilegesTag;        if ( * (Boolean*) inBuffer )          txnCControlData.uValue = kTXNReadOnly;         else txnCControlData.uValue = kTXNReadWrite;         err = TXNSetTXNObjectControls( varsp-&gt;fTXNObject,                false, 1, &amp;txnControlTag, &amp;txnCControlData );        if (err == noErr) {          varsp-&gt;fIsReadOnly = * (Boolean*) inBuffer;        }      }      returnedResult = err;      break;          case kYASTControlTabSizeTag:      if (inBufferSize != sizeof(SInt16)) {        err = paramErr;      } else {        TXNControlData txnTabData;        TXNControlTag txnControlTag;        txnControlTag = kTXNTabSettingsTag;        txnTabData.tabValue.value = * (SInt16*) inBuffer;        txnTabData.tabValue.tabType = kTXNRightTab;        txnTabData.tabValue.filler = 0;        err = TXNSetTXNObjectControls( varsp-&gt;fTXNObject,              false, 1, &amp;txnControlTag, &amp;txnTabData );      }      returnedResult = err;      break;  }  return returnedResult;}  /* YASTControlGetData is dispatched from our control event handler.  It is where  we handle all calls to GetControlData directed to our control. */static OSStatus YASTControlGetData(          YASTControlVarsPtr varsp,          ResType inTagName,          void * inBuffer,          Size inBufferSize,          Size *outBufferSize) {  OSStatus err, returnedResult;    /* default result */  returnedResult = eventNotHandledErr;    /* dispatch event */  switch (inTagName) {        case kYASTControlAllTextTag:    case kYASTControlSelectedTextTag:      {  Handle oDataHandle;        Size bytesCopied;        TXNOffset oStartOffset, oEndOffset;        if (inTagName == kYASTControlSelectedTextTag)           TXNGetSelection( varsp-&gt;fTXNObject, &amp;oStartOffset, &amp;oEndOffset);        else { oStartOffset = kTXNStartOffset; oEndOffset = kTXNEndOffset; }        err = TXNGetDataEncoded( varsp-&gt;fTXNObject, oStartOffset,                  oEndOffset, &amp;oDataHandle, kTXNTextData);        if (err == noErr) {          bytesCopied = GetHandleSize(oDataHandle);          if (bytesCopied &gt; inBufferSize) bytesCopied = inBufferSize;          BlockMoveData(*oDataHandle, inBuffer, bytesCopied);          if (outBufferSize != NULL) *outBufferSize = bytesCopied;          DisposeHandle(oDataHandle);        }      }      returnedResult = err;      break;    case kYASTControlAllUnicodeTextTag: /* CFStringRef */    case kYASTControlSelectedUnicodeTextTag: /* CFStringRef */      if (inBufferSize != sizeof(CFStringRef)) {        err = paramErr;      } else {        TXNOffset oStartOffset, oEndOffset;        Handle oDataHandle;        if (inTagName == kYASTControlSelectedUnicodeTextTag)           TXNGetSelection( varsp-&gt;fTXNObject, &amp;oStartOffset, &amp;oEndOffset);        else { oStartOffset = kTXNStartOffset; oEndOffset = kTXNEndOffset; }        err = TXNGetDataEncoded( varsp-&gt;fTXNObject, oStartOffset,                oEndOffset, &amp;oDataHandle, kTXNUnicodeTextData);        if (err == noErr) {          CFStringRef theString;          HLock(oDataHandle);          theString = CFStringCreateWithCharacters(NULL,              (UniChar *) (*oDataHandle), GetHandleSize(oDataHandle)/sizeof(UniChar));          if (theString != NULL) {            * (CFStringRef*) inBuffer = theString;            if (outBufferSize != NULL) *outBufferSize = sizeof(CFStringRef);            err = noErr;          } else {            err = memFullErr;          }          DisposeHandle(oDataHandle);        }      }      returnedResult = err;      break;        case kYASTControlSelectionRangeTag: /* YASTControlEditTextSelectionRec */      if (inBufferSize != sizeof(YASTControlEditTextSelectionRec)) {        err = paramErr;      } else {        YASTControlEditTextSelectionPtr range;        range = (YASTControlEditTextSelectionPtr) inBuffer;        TXNGetSelection( varsp-&gt;fTXNObject, &amp;range-&gt;selStart, &amp;range-&gt;selEnd);        if (outBufferSize != NULL) *outBufferSize = sizeof(YASTControlEditTextSelectionRec);        err = noErr;      }      returnedResult = err;      break;    case kYASTControlTXNObjectTag: /* fTXNObject - GetControlData only */      if (inBufferSize != sizeof(TXNObject)) {        err = paramErr;      } else {        * (TXNObject*) inBuffer = varsp-&gt;fTXNObject;        if (outBufferSize != NULL) *outBufferSize = sizeof(TXNObject);        err = noErr;      }      returnedResult = err;      break;        case kYASTControlTabsAdvanceFocusTag: /* Boolean (default true) */      if (inBufferSize != sizeof(Boolean)) {        err = paramErr;      } else {        * (Boolean*) inBuffer = varsp-&gt;fTabMovesFocus;        if (outBufferSize != NULL) *outBufferSize = sizeof(Boolean);        err = noErr;      }      returnedResult = err;      break;          case kYASTControlDoDrawFocusTag: /* Boolean (default true) */      if (inBufferSize != sizeof(Boolean)) {        err = paramErr;      } else {        * (Boolean*) inBuffer = varsp-&gt;fDrawFocusBox;        if (outBufferSize != NULL) *outBufferSize = sizeof(Boolean);        err = noErr;      }      returnedResult = err;      break;      case kYASTControlReadOnlyTag:      if (inBufferSize != sizeof(Boolean)) {        err = paramErr;      } else {        * (Boolean*) inBuffer = varsp-&gt;fIsReadOnly;        if (outBufferSize != NULL) *outBufferSize = sizeof(Boolean);        err = noErr;      }      returnedResult = err;      break;          case kYASTControlTabSizeTag:      if (inBufferSize != sizeof(SInt16)) {        err = paramErr;      } else {        TXNControlData txnTabData;        TXNControlTag txnControlTag;        txnControlTag = kTXNTabSettingsTag;        err = TXNGetTXNObjectControls( varsp-&gt;fTXNObject, 1, &amp;txnControlTag, &amp;txnTabData );        if (err == noErr) {          * (SInt16*) inBuffer = txnTabData.tabValue.value;          if (outBufferSize != NULL) *outBufferSize = sizeof(SInt16);        }      }      returnedResult = err;      break;  }  return returnedResult;}    /* YASTControlCarbonEventHandler defines the main entry point for all  of the carbon event handlers installed for the YASTControl. */static pascal OSStatus YASTControlCarbonEventHandler(                  EventHandlerCallRef myHandler,                  EventRef event,                  void* userData) {  #pragma unused ( myHandler )    OSStatus err, returnedResult;  YASTControlVarsPtr varsp;  UInt32 eclass, ekind;    /* set up locals */  eclass = GetEventClass(event);  ekind = GetEventKind(event);  varsp = (YASTControlVarsPtr) userData;  returnedResult = eventNotHandledErr;    /* dispatch the event by class*/  switch (eclass) {      case kEventClassWindow:      if ( ekind == kEventWindowCursorChange ) {        Point where;        UInt32 modifiers;        Boolean cursorWasSet;          /* get the mouse position */        err = GetEventParameter( event, kEventParamMouseLocation,             typeQDPoint,  NULL, sizeof(where), NULL, &amp;where);        if (err == noErr) {          err = GetEventParameter( event, kEventParamKeyModifiers,               typeUInt32,  NULL, sizeof(modifiers), NULL, &amp;modifiers);          if (err == noErr) {            SetPort(varsp-&gt;fGrafPtr);            GlobalToLocal(&amp;where);            if (PtInRect(where, &amp;varsp-&gt;fRBounds)) {              err = HandleControlSetCursor( varsp-&gt;fControl, where, modifiers, &amp;cursorWasSet);              if (err != noErr) cursorWasSet = false;              if ( ! cursorWasSet ) InitCursor();              returnedResult = noErr;            }          }        }      }      break;      case kEventClassMouse:        /* handle mouse downs in the control, but only if the        control is in focus. */      if ( ekind == kEventMouseDown ) {        EventRecord outEvent;        if ( varsp-&gt;fInFocus ) {          if (ConvertEventRefToEventRecord( event, &amp;outEvent)) {            TXNClick( varsp-&gt;fTXNObject,  &amp;outEvent);          }          returnedResult = noErr;        }      }      break;    case kEventClassTextInput:      if ( ekind == kEventUnicodeForKeyEvent      &amp;&amp; varsp-&gt;fTabMovesFocus) {        UniChar mUnicodeText[8];        UInt32 bytecount, nchars;          /* get the character */        err = GetEventParameter(event, kEventParamTextInputSendText,               typeUnicodeText, NULL, sizeof(mUnicodeText),              &amp;bytecount, (char*) mUnicodeText);        if ((err == noErr)        &amp;&amp; (bytecount &gt;= sizeof(UniChar))) {          nchars = ( bytecount / sizeof(UniChar) );            /* if it's not the tab key, forget it... */          if ( mUnicodeText[0] == '\t' ) {            EventRef rawKeyEvent;            Boolean shiftDown;              /* is the shift key held down? */            shiftDown = false;            err = GetEventParameter(event, kEventParamTextInputSendKeyboardEvent,                   typeEventRef, NULL, sizeof(rawKeyEvent), NULL, &amp;rawKeyEvent);            if (err == noErr) {              UInt32 modifiers;              err = GetEventParameter(rawKeyEvent, kEventParamKeyModifiers,                   typeUInt32, NULL, sizeof(modifiers), NULL, &amp;modifiers);              if (err == noErr) {                shiftDown = ( (modifiers &amp; shiftKey) != 0 );              }            }              /* advance the keyboard focus, backwards if shift is down */            if (shiftDown)              ReverseKeyboardFocus( varsp-&gt;fWindow );            else AdvanceKeyboardFocus( varsp-&gt;fWindow );              /* noErr lets the CEM know we handled the event */            returnedResult = noErr;          }        }      }      break;    case kEventClassControl:      switch (ekind) {        case kEventControlSetFocusPart:          {  ControlPartCode thePart;            err = GetEventParameter(event, kEventParamControlPart,               typeControlPartCode, NULL, sizeof(thePart), NULL, &amp;thePart);            if (err == noErr) {              switch (thePart) {                default:                case kControlFocusNoPart: /* turn off focus */                  if ( varsp-&gt;fInFocus ) {                    TXNFocus( varsp-&gt;fTXNObject, false);                    varsp-&gt;fInFocus = false;                  }                  thePart = kControlFocusNoPart;                  break;                case kYASTControlOnlyPart: /* turn on focus */                  if ( !  varsp-&gt;fInFocus ) {                    TXNFocus( varsp-&gt;fTXNObject, true);                    varsp-&gt;fInFocus = true;                  }                  thePart = kYASTControlOnlyPart;                  break;                case kControlFocusPrevPart: /* toggle focus on/off */                case kControlFocusNextPart:                  varsp-&gt;fInFocus = ! varsp-&gt;fInFocus;                  TXNFocus( varsp-&gt;fTXNObject, varsp-&gt;fInFocus);                  thePart = (varsp-&gt;fInFocus ? kYASTControlOnlyPart : kControlFocusNoPart);                  break;              }              SetPort(varsp-&gt;fGrafPtr);                /* calculate the next highlight state */              SetTextActivation(varsp, varsp-&gt;fIsActive &amp;&amp; varsp-&gt;fInFocus);                /* redraw the text fram and focus rectangle to indicate the                new focus state */              DrawThemeEditTextFrame(&amp;varsp-&gt;fRTextOutline,                varsp-&gt;fIsActive ? kThemeStateActive: kThemeStateInactive);              RedrawFocusOutline(varsp);            }              /* pass back the foocus part code */            err = SetEventParameter( event, kEventParamControlPart,                typeControlPartCode, sizeof(thePart), &amp;thePart);            returnedResult = err;          }          break;        case kEventControlHitTest:            /* this event does not necessairly mean that a mouse click            has occured.  Here we are simply testing to see if a particular            point is located inside of the control.  More complicated controls            would return different part codes for different parts of            themselves;  but, since YASTControls only advertise one part, the            hit test here is more or less a boolean test. */          {  ControlPartCode thePart;            Point where;            err = GetEventParameter(event, kEventParamMouseLocation,               typeQDPoint, NULL, sizeof(where), NULL, &amp;where);            if (err == noErr) {              if (PtInRect(where, &amp;varsp-&gt;fRTextArea)) {                thePart = kYASTControlOnlyPart;              } else thePart = 0;              err = SetEventParameter( event, kEventParamControlPart,                    typeControlPartCode, sizeof(thePart), &amp;thePart);            }            returnedResult = err;          }          break;        case kEventControlClick:            /* here we handle focus switching on the control.  Actual tracking            of mouse down events in the control is performed in the kEventClassMouse            mouse down handler above. */          if ( ! varsp-&gt;fInFocus ) {            SetKeyboardFocus(varsp-&gt;fWindow, varsp-&gt;fControl, kYASTControlOnlyPart);            returnedResult = noErr;          }          break;                  case kEventControlBoundsChanged:            /* we moved, or switched size - recalculate our rectangles */          {  Rect bounds;            err = GetEventParameter(event, kEventParamCurrentBounds,               typeQDRectangle, NULL, sizeof(bounds), NULL, &amp;bounds);            if (err == noErr) {              YASTControlCalculateBounds(varsp, &amp;bounds);              TXNSetFrameBounds( varsp-&gt;fTXNObject,                varsp-&gt;fRTextArea.top, varsp-&gt;fRTextArea.left,                varsp-&gt;fRTextArea.bottom, varsp-&gt;fRTextArea.right,                varsp-&gt;fTXNFrameID);            }          }          break;                    case kEventControlActivate:        case kEventControlDeactivate:          {  SetPort(varsp-&gt;fGrafPtr);            varsp-&gt;fIsActive = (ekind == kEventControlActivate);            SetTextActivation(varsp, varsp-&gt;fIsActive &amp;&amp; varsp-&gt;fInFocus);              /* redraw the frame */            DrawThemeEditTextFrame(&amp;varsp-&gt;fRTextOutline,              varsp-&gt;fIsActive ? kThemeStateActive: kThemeStateInactive);            RedrawFocusOutline(varsp);            returnedResult = noErr;          }          break;                  case kEventControlDraw:            /* redraw the control */          SetPort(varsp-&gt;fGrafPtr);            /* update the text region */          TXNDraw(varsp-&gt;fTXNObject, NULL);            /* restore the drawing environment */            /* draw the text frame and focus frame (if necessary) */          DrawThemeEditTextFrame(&amp;varsp-&gt;fRTextOutline,            varsp-&gt;fIsActive ? kThemeStateActive: kThemeStateInactive);          RedrawFocusOutline(varsp);          returnedResult = noErr;          break;                  case kEventControlSetCursor:            /* cursor adjustment */          {  SetPortWindowPort(varsp-&gt;fWindow);            TXNAdjustCursor( varsp-&gt;fTXNObject, varsp-&gt;fRTextOutlineRegion);            returnedResult = noErr;          }          break;                  case kEventControlDispose:            /* RemoveEventHandler(varsp-&gt;fControlEvents); -- this call has been            left out on purpose because it will be called automatically when the            control is disposed. */          RemoveEventHandler(varsp-&gt;fWindowEvents);          TXNDeleteObject(varsp-&gt;fTXNObject);          DisposeRgn(varsp-&gt;fRTextOutlineRegion);          free(varsp);            /* returnedResult = noErr; -- this has been left out on purpose            because we want the dispatching to continue and dispose of the control */          break;                  case kEventControlSetData:          {  ResType inTagName;            Size inBufferSize;            void * inBuffer;            err = GetEventParameter( event, kEventParamControlDataTag, typeEnumeration,               NULL, sizeof(inTagName), NULL, &amp;inTagName);            if (err == noErr) {              err = GetEventParameter( event, kEventParamControlDataBuffer, typePtr,                 NULL, sizeof(inBuffer), NULL, &amp;inBuffer);              if (err == noErr) {                err = GetEventParameter( event, kEventParamControlDataBufferSize, typeLongInteger,                   NULL, sizeof(inBufferSize), NULL, &amp;inBufferSize);                if (err == noErr) {                  err = YASTControlSetData(varsp, inTagName, inBuffer, inBufferSize);                }              }            }            returnedResult = err;          }          break;                  case kEventControlGetData:          {  ResType inTagName;            Size inBufferSize, outBufferSize;            void * inBuffer;            err = GetEventParameter( event, kEventParamControlDataTag, typeEnumeration,               NULL, sizeof(inTagName), NULL, &amp;inTagName);            if (err == noErr) {              err = GetEventParameter( event, kEventParamControlDataBuffer, typePtr,                 NULL, sizeof(inBuffer), NULL, &amp;inBuffer);              if (err == noErr) {                err = GetEventParameter( event, kEventParamControlDataBufferSize, typeLongInteger,                   NULL, sizeof(inBufferSize), NULL, &amp;inBufferSize);                if (err == noErr) {                  err = YASTControlGetData(varsp, inTagName, inBuffer, inBufferSize, &amp;outBufferSize);                  if (err == noErr) {                    err = SetEventParameter( event, kEventParamControlDataBufferSize,                          typeLongInteger, sizeof(outBufferSize), &amp;outBufferSize);                  }                }              }            }            returnedResult = err;          }          break;                }      break;    case kEventClassCommand:      if ( ekind == kEventProcessCommand ) {        HICommand command;        err = GetEventParameter( event, kEventParamDirectObject,                    typeHICommand, NULL, sizeof(command), NULL, &amp;command);        if (err == noErr) {          switch (command.commandID) {            case kHICommandUndo:              TXNUndo(varsp-&gt;fTXNObject);              returnedResult = noErr;              break;            case kHICommandRedo:              TXNRedo(varsp-&gt;fTXNObject);              returnedResult = noErr;              break;            case kHICommandCut:              ClearCurrentScrap();              err = TXNCut(varsp-&gt;fTXNObject);               if (err == noErr)                err = TXNConvertToPublicScrap();              returnedResult = err;              break;            case kHICommandCopy:              ClearCurrentScrap();              err = TXNCopy(varsp-&gt;fTXNObject);              if (err == noErr)                err = TXNConvertToPublicScrap();              returnedResult = err;              break;            case kHICommandPaste:              err = TXNConvertFromPublicScrap();              if (err == noErr)                err = TXNPaste(varsp-&gt;fTXNObject);              returnedResult = err;              break;            case kHICommandClear:              err = TXNClear(varsp-&gt;fTXNObject);              returnedResult = err;              break;            case kHICommandSelectAll:              err = TXNSetSelection(varsp-&gt;fTXNObject, kTXNStartOffset, kTXNEndOffset);              returnedResult = err;              break;          }        }      } else if ( ekind == kEventCommandUpdateStatus ) {        HICommand command;        TXNOffset oStartOffset, oEndOffset;        TXNActionKey oActionKey;        err = GetEventParameter( event, kEventParamDirectObject, typeHICommand,                     NULL, sizeof(command), NULL, &amp;command);                if ((err == noErr)        &amp;&amp; ((command.attributes &amp; kHICommandFromMenu) != 0)) {          switch (command.commandID) {            case kHICommandUndo:              if (TXNCanUndo(varsp-&gt;fTXNObject, &amp;oActionKey)) {                EnableMenuItem(command.menu.menuRef, 0); /* required pre OS 10.2 */                EnableMenuItem(command.menu.menuRef, command.menu.menuItemIndex);              } else DisableMenuItem(command.menu.menuRef, command.menu.menuItemIndex);              returnedResult = noErr;              break;            case kHICommandRedo:              if (TXNCanRedo(varsp-&gt;fTXNObject, &amp;oActionKey)) {                EnableMenuItem(command.menu.menuRef, 0); /* required pre OS 10.2 */                EnableMenuItem(command.menu.menuRef, command.menu.menuItemIndex);              } else DisableMenuItem(command.menu.menuRef, command.menu.menuItemIndex);              returnedResult = noErr;              break;            case kHICommandCut:            case kHICommandCopy:            case kHICommandClear:              TXNGetSelection(varsp-&gt;fTXNObject, &amp;oStartOffset, &amp;oEndOffset);              if (oStartOffset != oEndOffset) {                EnableMenuItem(command.menu.menuRef, 0); /* required pre OS 10.2 */                EnableMenuItem(command.menu.menuRef, command.menu.menuItemIndex);              } else DisableMenuItem(command.menu.menuRef, command.menu.menuItemIndex);              returnedResult = noErr;              break;            case kHICommandPaste:              if (TXNIsScrapPastable()) {                EnableMenuItem(command.menu.menuRef, 0); /* required pre OS 10.2 */                EnableMenuItem(command.menu.menuRef, command.menu.menuItemIndex);              } else DisableMenuItem(command.menu.menuRef, command.menu.menuItemIndex);              returnedResult = noErr;              break;            case kHICommandSelectAll:              if(TXNDataSize(varsp-&gt;fTXNObject) &gt; 0) {                EnableMenuItem(command.menu.menuRef, 0); /* required pre OS 10.2 */                EnableMenuItem(command.menu.menuRef, command.menu.menuItemIndex);              } else DisableMenuItem(command.menu.menuRef, command.menu.menuItemIndex);              returnedResult = noErr;              break;          }        }      }      break;  }    return returnedResult;}  /* YASTControlAttachToExistingControl initializes Yet Another  Scrolling Text (YAST) control on top of an existing control - preferably  a user pane control created in interface builder.  Once set up, carbon  event handlers installed by this routine take care of everything else,  including any necessary internal storage cleanup operations when the  control is disposed.  */  OSStatus YASTControlAttachToExistingControl(ControlRef theControl) {  OSStatus err;  YASTControlVars *varsp;  UInt32 outCommandID;  EventHandlerRef controlEvents, windowEvents;  TXNObject theTXNObject;  RgnHandle outlineRegion;      /* set up our locals */  controlEvents = windowEvents = NULL;  theTXNObject = NULL;  outlineRegion = NULL;  varsp = NULL;  err = noErr;      /* allocate our private storage and set up initial settings*/  varsp = (YASTControlVars *) malloc(sizeof(YASTControlVars));  if (varsp == NULL) {    err = memFullErr;  } else {    varsp-&gt;fInFocus = false;    varsp-&gt;fIsActive = true;    varsp-&gt;fTXNObjectActive = false;    varsp-&gt;fControl = theControl;    varsp-&gt;fTabMovesFocus = true;    varsp-&gt;fDrawFocusBox = true;    varsp-&gt;fFocusDrawState = false;    varsp-&gt;fIsReadOnly = false;    varsp-&gt;fRTextOutlineRegion = NULL;    varsp-&gt;fWindow = GetControlOwner(theControl);    varsp-&gt;fGrafPtr = GetWindowPort(varsp-&gt;fWindow);  }      /* set our control's command id.  we don't actually use it, but it must    be non-zero for our control to be sent command events.  only set it    if it has not already been set.  */  err = GetControlCommandID(theControl, &amp;outCommandID);  if (err == noErr) {    if (outCommandID == 0) {      err = SetControlCommandID(theControl, 1);    }  }    /* calculate the rectangles used by the control */  if (err == noErr) {    outlineRegion = NewRgn();    if (outlineRegion == NULL) {      err = memFullErr;    } else {      Rect bounds;      varsp-&gt;fRTextOutlineRegion = outlineRegion;      GetControlBounds(theControl, &amp;bounds);      YASTControlCalculateBounds(varsp, &amp;bounds);    }  }    /* create the new edit field */  if (err == noErr) {    err = TXNNewObject(NULL, varsp-&gt;fWindow, &amp;varsp-&gt;fRTextArea,      kTXNWantVScrollBarMask | kTXNAlwaysWrapAtViewEdgeMask,      kTXNTextEditStyleFrameType, kTXNTextensionFile, kTXNSystemDefaultEncoding,       &amp;theTXNObject, &amp;varsp-&gt;fTXNFrameID, (TXNObjectRefcon) varsp);    if (err == noErr) {      varsp-&gt;fTXNObject = theTXNObject;    }  }      /* set the field's background */  if (err == noErr) {    RGBColor rgbWhite = {0xFFFF, 0xFFFF, 0xFFFF};    TXNBackground tback;    tback.bgType = kTXNBackgroundTypeRGB;    tback.bg.color = rgbWhite;    TXNSetBackground( varsp-&gt;fTXNObject, &amp;tback);  }      /* set the margins for easier selection and display */  if (err == noErr) {    TXNControlData txnCControlData;    TXNControlTag txnControlTag = kTXNMarginsTag;    TXNMargins txnMargins = { 2, 3, 2, 1 };  /* t,l,b,r */    txnCControlData.marginsPtr  = &amp;txnMargins;     (void) TXNSetTXNObjectControls( varsp-&gt;fTXNObject, false, 1, &amp;txnControlTag, &amp;txnCControlData );  }      /* install our carbon event handlers */  if (err == noErr) {    static EventHandlerUPP gTPEventHandlerUPP = NULL;    if (gTPEventHandlerUPP == NULL)      gTPEventHandlerUPP = NewEventHandlerUPP(YASTControlCarbonEventHandler);        /* carbon event handlers for the control */    err = InstallEventHandler( GetControlEventTarget( theControl ),      gTPEventHandlerUPP,      (sizeof(gYASTControlEvents)/sizeof(EventTypeSpec)),      gYASTControlEvents,      varsp, &amp;controlEvents);    if (err == noErr) {       varsp-&gt;fControlEvents = windowEvents;              /* carbon event handlers for the control's window */      err = InstallEventHandler( GetWindowEventTarget( varsp-&gt;fWindow ),        gTPEventHandlerUPP, (sizeof(gYASTControlWindowEvents)/sizeof(EventTypeSpec)),        gYASTControlWindowEvents, varsp, &amp;windowEvents);      if (err == noErr) {        varsp-&gt;fWindowEvents = windowEvents;      }    }  }      /* perform final activations and setup for our text field.  Here,    we assume that the window is going to be the 'active' window. */  if (err == noErr) {    SetTextActivation(varsp, (varsp-&gt;fIsActive &amp;&amp; varsp-&gt;fInFocus));  }      /* clean up on error */  if (err != noErr) {    if (controlEvents != NULL) RemoveEventHandler(controlEvents);    if (windowEvents != NULL) RemoveEventHandler(windowEvents);    if (theTXNObject != NULL) TXNDeleteObject(theTXNObject);    if (outlineRegion != NULL) DisposeRgn(outlineRegion);    if (varsp != NULL) free((void*) varsp);  }      /* all done */  return err;}  /* CreateYASTControl creates Yet Another Scrolling Text (YAST) control for  use in theWindow.  Specifically, this routine creates a new user pane control  and then calls YASTControlAttachToExistingControl to finish the job. */OSStatus CreateYASTControl(WindowRef theWindow, Rect *bounds, ControlRef *theControl) {  UInt32 featurSet;  ControlRef theNewControl;  OSStatus err;      /* feature flags for our control. */  featurSet = kControlSupportsEmbedding | kControlSupportsFocus | kControlWantsIdle      | kControlWantsActivate | kControlHasSpecialBackground      | kControlGetsFocusOnClick | kControlSupportsLiveFeedback;          /* create the control */  err = CreateUserPaneControl( theWindow,  bounds, featurSet, &amp;theNewControl);  if (err == noErr) {      /* set up the txn features */    err = YASTControlAttachToExistingControl(theNewControl);    if (err == noErr) {      *theControl = theNewControl;    } else {      DisposeControl(theNewControl);    }  }    /* all done.... */  return err;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/YASTControl/listing2.html%3Fid%3DDTS10000626-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/YASTControl/listing2.html%3Fid%3DDTS10000626-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/YASTControl/listing2.html%3Fid%3DDTS10000626-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>