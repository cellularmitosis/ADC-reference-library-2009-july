<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Tumbler and Podium - /TumblerSource/Tumbler_drag.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">Tumbler and Podium</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Tumbler and Podium</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/TumblerSource/Tumbler_drag.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/TumblerSource/Tumbler_AEVT.c</option>
<option value="listing2.html">/TumblerSource/Tumbler_AEVT.h</option>
<option value="listing3.html">/TumblerSource/Tumbler_camera.c</option>
<option value="listing4.html">/TumblerSource/Tumbler_camera.h</option>
<option value="listing5.html">/TumblerSource/Tumbler_cursor.c</option>
<option value="listing6.html">/TumblerSource/Tumbler_cursor.h</option>
<option value="listing7.html">/TumblerSource/Tumbler_document.c</option>
<option value="listing8.html">/TumblerSource/Tumbler_document.h</option>
<option value="listing9.html">/TumblerSource/Tumbler_drag.c</option>
<option value="listing10.html">/TumblerSource/Tumbler_drag.h</option>
<option value="listing11.html">/TumblerSource/Tumbler_ErrorHandler.c</option>
<option value="listing12.html">/TumblerSource/Tumbler_ErrorHandler.h</option>
<option value="listing13.html">/TumblerSource/Tumbler_event.c</option>
<option value="listing14.html">/TumblerSource/Tumbler_event.h</option>
<option value="listing15.html">/TumblerSource/Tumbler_file.c</option>
<option value="listing16.html">/TumblerSource/Tumbler_file.h</option>
<option value="listing17.html">/TumblerSource/Tumbler_globals.h</option>
<option value="listing18.html">/TumblerSource/Tumbler_HideMenuBar.c</option>
<option value="listing19.html">/TumblerSource/Tumbler_HideMenuBar.h</option>
<option value="listing20.html">/TumblerSource/Tumbler_initialize.c</option>
<option value="listing21.html">/TumblerSource/Tumbler_initialize.h</option>
<option value="listing22.html">/TumblerSource/Tumbler_main.c</option>
<option value="listing23.html">/TumblerSource/Tumbler_main.h</option>
<option value="listing24.html">/TumblerSource/Tumbler_menus.c</option>
<option value="listing25.html">/TumblerSource/Tumbler_menus.h</option>
<option value="listing26.html">/TumblerSource/Tumbler_offscreen.c</option>
<option value="listing27.html">/TumblerSource/Tumbler_offscreen.h</option>
<option value="listing28.html">/TumblerSource/Tumbler_PICTImport.c</option>
<option value="listing29.html">/TumblerSource/Tumbler_PICTImport.h</option>
<option value="listing30.html">/TumblerSource/Tumbler_podium.c</option>
<option value="listing31.html">/TumblerSource/Tumbler_podium.h</option>
<option value="listing32.html">/TumblerSource/Tumbler_prototypes.h</option>
<option value="listing33.html">/TumblerSource/Tumbler_resources.h</option>
<option value="listing34.html">/TumblerSource/Tumbler_teutilities.c</option>
<option value="listing35.html">/TumblerSource/Tumbler_teutilities.h</option>
<option value="listing36.html">/TumblerSource/Tumbler_traps.c</option>
<option value="listing37.html">/TumblerSource/Tumbler_traps.h</option>
<option value="listing38.html">/TumblerSource/Tumbler_utility.c</option>
<option value="listing39.html">/TumblerSource/Tumbler_utility.h</option>
<option value="listing40.html">/TumblerSource/Tumbler_windows.c</option>
<option value="listing41.html">/TumblerSource/Tumbler_windows.h</option></select>
				</p>
				</form>
				<p><strong><a href="Tumbler_and_Podium.zip">Download Sample</a></strong> (&#147;Tumbler_and_Podium.zip&#148;, 1.07M)<BR>
<strong><a href="Tumbler_and_Podium.dmg">Download Sample</a></strong> (&#147;Tumbler_and_Podium.dmg&#148;, 1.15M)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">// Tumbler_drag.c//// Dragging routines. The code in this file implements the geometry// dragging features of this program.  The last function in this file,// DoDragObjects is called when a mouseDown is detected in the hilite region// of the current object.//  // Here's some background from Nick for debugging this mess.  First off the drag manager // is not a simple animal.//// High-level or source-level debuggers won't work with Drag Manager callback routines.  // That's because of the way the Drag Manager performs process switching.  The only // high-level debugger that does work with the Drag Manager is VoodooMonkey, an &quot;experimental // prototype&quot; debugger you can find on the November Developer CD.  Note that VoodooMonkey // is unsupported by Apple.  The other more-supportable option is to use MacsBug (or your // favorite low-level debugger) for real-time debugging.  But since this 3d stuff will only// work on power macintosh cpu's (unless you have the souce code, which developers don't :0&gt;)// MacsBug won't help you much.  And I was using a version of CodeWarrior that didn't seem to // want to put any symbols in, which means Macsbug is not really an option (debugging what// MB thinks is the 68k equivalent of the actual PPC instructions, with no symbols, ain't// my idea of fun.  And don't think DebugStr will help you any - if you are running with // the MetroWerks (MW) high level debugger, your mAchine will crash big time.  MW debugger// wants to display the debugstr in a nice little dialog, which means it has to do a context// switch.  Why is this bad... read on McDuff://// The Drag Manager is actually making full context switches for each process that has  // tracking/receive handlers as an object is dragged over a valid drag region.  While this // may sound a bit drastic or scary, it isn't really that bad because a drag is a modal operation,  // and as long as the user is dragging an object, the System (namely the Drag Manager) is in  // control to call tracking and receive handlers as appropriate.  So when your receive handler  // is called and all events pending for your process have been handled, your application is  // eliglble for a context switch the next time WaitNextEvent is called.  And when WNE is called  // and a context switch occurs, the Drag Manager has lost track over what process is currently  // the context.  This is also why you cannot use source-level debuggers to debug drag handlers,  // because context switches are controlled by those debuggers, and once you're in a Drag you  // cannot change the Process Manager state.//  // In case you're interested, one technique that works well for receive handlers is to send an  // Apple event to yourself with the relevant information about the drag, and process it at  // WaitNextEvent time.  Sending an Apple event to yourself can be done even if you're not the  // frontmost application, and it allows you to process the Drag at WaitNextEvent time, meaning  // you can call your Alert routine and change process states without any problems.  Another  // benefit to this approach is that you'll be able to use source level debuggers to work on  // your receive handlers.//// The only thing to beware of if you do this (and this is what do here) is to get the PSN // directly - AppleEvents.h gives a constant (kCurrentProcess) that you can stick in the low// longword of the PSN that will cause the event to essentially be dispatched as a function// call, and that is not what we want here.  By getting the process serial number (PSN) of// our own process and using that in the AppleEvent we ensure that the event is dispatched // to our process so we can deal with it in the main event loop, rather than being mapped into// and unwanted funtion call (which since we would still be in the drag managers context would// prevent us from being able to debug using anything reasonable).  Check out Tumbler_AEVT for// more details on this.//// Nitin Gantatra whined so much that I'd stolen the comments above, that I feel compelled to // add:////  Author of lame gratuitous drag manager comments: Jim Luther////  Author:    Nick Thompson, based on the original by//        Pablo Fernicola, based on Rob Johnson's drag text sample,//        with extensive stealing from grobbins SimpleDrag sample.////  Modification history:////  11/26/94  nick  removed dead code, tightened up the drag code, based on//            grobbins' excellent simpledrag sample//  11/25/94  nick  added events for dragging, this lets us do//            source level debugging of the drag receiver, see Tumbler_aevt.////  Copyright &copy; 1992-95 Apple Computer, Inc., All Rights Reserved//// to do: store the document reference as a handle in the window's refcon//#define NAGELS_DEMO    // pre-allocate handles#include &lt;QDOffscreen.h&gt;#include &lt;Folders.h&gt;#include &lt;Drag.h&gt;#include &lt;SegLoad.h&gt;#include &lt;Types.h&gt;#include &quot;Tumbler_globals.h&quot;#include &quot;QD3D.h&quot;#include &quot;QD3DGroup.h&quot;#include &quot;QD3DStorage.h&quot;#include &quot;QD3DIO.h&quot;#include &quot;QD3DView.h&quot;#include &quot;QD3DDrawContext.h&quot;#include &quot;QD3DPick.h&quot;#include &quot;QD3DShader.h&quot;#include &quot;QD3DTransform.h&quot;#include &quot;QD3DGroup.h&quot;#include &quot;Tumbler_prototypes.h&quot;#include &quot;Tumbler_file.h&quot;#include &quot;Tumbler_resources.h&quot;#include &quot;Tumbler_offscreen.h&quot;#include &quot;Tumbler_AEVT.h&quot;      // grab our apleEvent handlers and data structures                  // used for debugging#include &quot;Tumbler_drag.h&quot;//  Can use custom drawing procedure. Just uncomment out this line://  #define USE_CUSTOM_DRAWING// global data for my Drag Manager handlerstypedef struct DragHandlerGlobals {  Boolean     acceptableDragFlag;  Boolean     windowIsHilightedFlag;} ;typedef struct DragHandlerGlobals  DragHandlerGlobals, *DragHandlerGlobalsPtr;static DragHandlerGlobals pDragHandlerGlobals;//-----------------------------------------------------------------------//  MyDrawingProc////  Simple drawing proc for dragging objects. This drawing procedure is very similar to//  the Drag Manager's built in drawing proc, except that it uses a solid black pattern//  to draw the region instead of using the dithered gray pattern.//// DONT USE THIS ON POWERPC as there is a quickdraw bug that leaves artifacts// everywhere (talk to Nitin Ganatra for the gory details).staticpascal OSErr MyDrawingProc(DragRegionMessage message,               RgnHandle showRgn, Point showOrigin,               RgnHandle hideRgn, Point hideOrigin,               void *dragDrawingRefCon, DragReference theDragRef){  OSErr      result = paramErr;  RgnHandle    tempRgn;  switch(message) {    case dragRegionBegin:      //      //  No initialization necessary for our drawing proc. Make sure noErr      //  is returned, otherwise the Drag Manager will revert back to it's      //  built in drawing proc.      //      result = noErr;      break;    case dragRegionDraw:      //      //  Find the difference between the region needed to be shown and the      //  region needed to be hidden. Inverting the difference removes the pixels      //  that must be hidden and shows the pixels that must be shown in one step.      //      XorRgn(showRgn, hideRgn, tempRgn = NewRgn());      InvertRgn(tempRgn);      DisposeRgn(tempRgn);      result = noErr;      break;    case dragRegionHide:      //      //  Simply hide the region given to us by inverting it.      //      InvertRgn(hideRgn);      result = noErr;      break;  }  return(result);}//------------------------------------------------------------------------------------//  MySendDataProc - provides data for the drag when requested.static pascal OSErr MySendDataProc(FlavorType theType, void *refCon,              ItemReference theItem, DragReference theDrag){  DocumentPtr theDocument = (DocumentPtr ) refCon;  unsigned long  validSize;    // so what do they want??    if (theType == '3DMF') {    if( theDocument-&gt;documentGroup ) {          Handle        theData;      TQ3StorageObject    storage;      TQ3FileObject    fd;      TQ3TransformObject   xform;      TQ3GroupPosition    position;      Boolean        didAllocate = false;    // set to true if we did allocate memory            if( Q3Object_IsType(theDocument-&gt;documentGroup, kQ3DisplayGroupTypeOrdered)) {        Q3Group_GetFirstPositionOfType(theDocument-&gt;documentGroup, kQ3ShapeTypeTransform,&amp;position);      } else {        Q3Group_GetFirstPosition(theDocument-&gt;documentGroup, &amp;position);      }      xform = Q3MatrixTransform_New( &amp;theDocument-&gt;modelRotation);            position = Q3Group_AddObjectBefore(theDocument-&gt;documentGroup, position, xform);        Q3Object_Dispose(xform);      #ifdef NAGELS_DEMO      // HO HO HO.  Actually we *do* need a way to approximate the       // size this handle needs to be so we can preflight                  if((theData = NewHandle(1024 * 1024 )) != nil)   {    // ask for 1M              MoveHHi( theData ) ;        HLock( theData ) ;        didAllocate = true ;        storage = Q3HandleStorage_New( theData, GetHandleSize( theData ) );              }      else {              storage = Q3HandleStorage_New( nil, 0 );              }#else      storage = Q3HandleStorage_New(nil,0);#endif            if (storage == nil)        goto bail;            fd = Q3File_New();            if (fd == nil)        goto bail;      Q3File_SetStorage(fd, storage);                  Tumbler_WriteScene(fd,                 false,                theDocument) ;        Q3HandleStorage_Get(storage, &amp;theData, &amp;validSize);      HLock(theData);      SetDragItemFlavorData(theDrag, theItem, '3DMF', (Ptr) *theData,                  validSize, 0L);      HUnlock(theData);      Q3Object_Dispose(storage);      Q3Object_Dispose(fd);      #ifdef NAGELS_DEMO      if( didAllocate == true ) {        DisposeHandle(theData);      }#endif    }     else {      return(badDragFlavorErr);    }  }    else {    return(badDragFlavorErr);  }  return(noErr);  bail:  return(badDragFlavorErr);}//-----------------------------------------------------------------------// DragItemsAreAcceptable returns true if the contents (data) of// the drag are acceptable by a window of this application//// DragItemsAreAcceptable is called by the tracking and // receive handlersBoolean DragItemsAreAcceptable(DragReference theDrag) ;Boolean DragItemsAreAcceptable(DragReference theDrag){  OSErr      retCode;  unsigned short  totalItems;  ItemReference  itemRef;  Boolean      acceptableFlag;  HFSFlavor     currHFSFlavor;  Size      flavorDataSize;  FlavorFlags    currFlavorFlags;    acceptableFlag = false;  // this app can only accept the drag of a single item  retCode = CountDragItems(theDrag, &amp;totalItems);  if (retCode == noErr &amp;&amp; totalItems == 1) {      // get the reference number of the dragged item    retCode = GetDragItemReferenceNumber(theDrag, 1, &amp;itemRef);    if (retCode == noErr) {            // use GetFlavorFlags to check on flavor existence of PICT data      // without forcing translation            if (GetFlavorFlags (theDrag, itemRef, 'PICT', &amp;currFlavorFlags) == noErr) {        acceptableFlag = true;      }      else if (GetFlavorFlags (theDrag, itemRef, '3DMF', &amp;currFlavorFlags) == noErr) {        acceptableFlag = true;      }      else {              // check if the item is a file spec for a PICT file        flavorDataSize = sizeof(HFSFlavor);        retCode = GetFlavorData(theDrag, itemRef, flavorTypeHFS, &amp;currHFSFlavor,          &amp;flavorDataSize, 0);                if (retCode == noErr &amp;&amp;  (currHFSFlavor.fileType == 'PICT'                 || currHFSFlavor.fileType == '3DMF'                || currHFSFlavor.fileType == 'TEXT' ))           acceptableFlag = true;      }    }  }  return acceptableFlag;}//-----------------------------------------------------------------------// DragIsNotInSourceWindow returns true if the drag in progress// is not in the same window it originated in//// DragIsNotInSourceWindow is called by the tracking and receive handlers//// Note that, if this application allowed items to be dragged within// its windows, this function would not be appropriate.// Instead, hilighting would probably occur in the source window// when the dragHasLeftSourceWindow flag is set, and the receive// handler wouldn't check this at allstaticBoolean DragIsNotInSourceWindow(DragReference theDrag){  DragAttributes currDragFlags;    (void) GetDragAttributes(theDrag, &amp;currDragFlags);  return ((currDragFlags &amp; dragInsideSenderWindow) == 0);}//-----------------------------------------------------------------------// MouseInContentRgn returns true if the current mouse is in the content// area of the window (but not necessarily in the visible rgn)staticBoolean MouseIsInContentRgn(DragReference theDrag, WindowPtr theWindow){  Point mousePt;    (void) GetDragMouse(theDrag, &amp;mousePt, nil);  return PtInRgn(mousePt, ((WindowPeek) theWindow)-&gt;contRgn);}//-----------------------------------------------------------------------//  MyReceiveDropHandler////  Called by the Drag Manager when a drop occurs over one of the DoDragObjects document windows.pascal OSErr MyReceiveDropHandler(WindowPtr theWindow, unsigned long handlerRefCon,                  DragReference theDrag);pascal OSErr MyReceiveDropHandler(WindowPtr theWindow, unsigned long handlerRefCon,                  DragReference theDrag){  OSErr        result;  Rect        theRect, srcRect;  unsigned short    items, index;  ItemReference    theItem;  DragAttributes    attributes;  StScrpHandle    stylHandle;  Size        dataSize, pictSize;  short        offset, selStart, selEnd, mouseDownModifiers, mouseUpModifiers, moveText;  DocumentPtr     theDocument = (DocumentPtr ) handlerRefCon;  Point        thePoint;  TQ3Object       objects = nil;  Boolean        dataObtainedFlag;  OSErr        retCode;    OSType        theDragFlavor ;  Point        mouseLoc ;      dataObtainedFlag = false;  if (!DragItemsAreAcceptable(theDrag) ||      !MouseIsInContentRgn(theDrag, theWindow) ||      !DragIsNotInSourceWindow(theDrag))     return dragNotAcceptedErr;          // We will only support one item, so get its reference number.  result = GetDragItemReferenceNumber(theDrag, 1, &amp;theItem);  if (result != noErr)    return result;  GetDragAttributes(theDrag, &amp;attributes);  GetDragModifiers(theDrag, 0L, &amp;mouseDownModifiers, &amp;mouseUpModifiers);    //  Loop through all of the drag items contained in this drag    SetRect(&amp;theRect, 0, 0, 0, 0);  // we ensured above that we only deal with one item being dragged to us...  //  CountDragItems(theDrag, &amp;items);  //  Get the item's reference, so we can refer to it.  GetDragItemReferenceNumber(theDrag, 1, &amp;theItem);    // get the location the user dropped the data  GetDragMouse(theDrag, &amp;mouseLoc, nil ) ;  //  Try to get the flags for a '3DMF' flavor. If this returns noErr,  //  then we know that a '3DMF' flavor exists in the item.  result = GetFlavorDataSize(theDrag, theItem, '3DMF', &amp;dataSize);  if (result == noErr) {    theDragFlavor = '3DMF' ;  }  else if((result = GetFlavorDataSize(theDrag, theItem, 'PICT', &amp;dataSize)) == noErr) {    theDragFlavor = 'PICT' ;  }   else {    // Couldn't get 3DMF or PICT data so try to get HFS-flavor data.    HFSFlavor    theHFSFlavor;    dataSize = sizeof(HFSFlavor);    result = GetFlavorData(theDrag, theItem, flavorTypeHFS,                         &amp;theHFSFlavor, &amp;dataSize, 0);                            if(theHFSFlavor.fileType != 'PICT'       || theHFSFlavor.fileType != '3DMF'      || theHFSFlavor.fileType != 'TEXT' ) {      result = paramErr ;    }  }    // so we either have nothing or something (in the form of 3DMF or PICT data)  if (result == noErr) {        // create a new data handle to hold the data the user just dragged in    // this needs to be the size of the data, plus the size of the     myPrivateDataHdl    thePrivateData = nil ;    long          recordSize ;      recordSize = sizeof( myPrivateDataRec ) ;        // create a handle large enough for the data    thePrivateData = (myPrivateDataHdl)NewHandle( (long)(dataSize +  recordSize)) ;        if( thePrivateData == nil )      return MemError() ;          (**thePrivateData).myTypeOfData = theDragFlavor ;    (**thePrivateData).myDocument = theDocument ;    // ideally we should store the doc in the windows refcon, this is hacky ???    (**thePrivateData).myDataSize = dataSize ;    (**thePrivateData).myWindow = theWindow ;    (**thePrivateData).myLocation = mouseLoc ;    // Lock and load, I dunno if GetFlavorData moves memory, I'm just assuming it may...        MoveHHi( (Handle)thePrivateData ) ;    HLock( (Handle)thePrivateData ) ;    //  passing (**thePrivateData) in dereferenced - ASSUMES the hnadle is locked    GetFlavorData(theDrag, theItem, theDragFlavor, &amp;(**thePrivateData).myData[0], &amp;dataSize, 0L);    HUnlock( (Handle)thePrivateData ) ;    // package this puppy up and send it to ourselves    SendDragRecv( thePrivateData ) ;        // and dispose of the data    DisposeHandle((Handle)thePrivateData ) ;    if (attributes &amp; dragHasLeftSenderWindow) {      HideDragHilite(theDrag);    }  }    return(noErr);  bail:  return(memFullErr);}//-----------------------------------------------------------------------//  MyTrackingHandler////  This is the drag tracking handler for windows in the Dragging application.pascal OSErr MyTrackingHandler(short theMessage, WindowPtr theWindow,                 void *handlerRefCon, DragReference theDrag);pascal OSErr MyTrackingHandler(short theMessage, WindowPtr theWindow,                 void *handlerRefCon, DragReference theDrag){  RgnHandle  tempRgn;  Boolean    mouseInContentFlag;  OSErr    retCode;    retCode = noErr;    switch (theMessage) {      case dragTrackingEnterHandler:            // determine if the items are acceptable and store      // that flag in the globals, plus reset the      // hilighted global flag            pDragHandlerGlobals.acceptableDragFlag =         DragItemsAreAcceptable(theDrag);      pDragHandlerGlobals.windowIsHilightedFlag = false;            // let the drag manager know if we can't accept this drag      if (!pDragHandlerGlobals.acceptableDragFlag)        retCode = dragNotAcceptedErr;      break;          case dragTrackingEnterWindow:     case dragTrackingInWindow:    case dragTrackingLeaveWindow:            // highlighting of the window during a drag is done      // here.  Do it only if we can accept these items      // and we're not in the source window...            if (pDragHandlerGlobals.acceptableDragFlag &amp;&amp;        DragIsNotInSourceWindow(theDrag)) {                // unless the mouse is leaving the visible area of the        // window, check if it's in the window's content region                if (theMessage == dragTrackingLeaveWindow)          mouseInContentFlag = false;        else          mouseInContentFlag = MouseIsInContentRgn(theDrag, theWindow);                // if the mouse is in the content area and the window        // is not yet hilighted, then do the hilighting                if (mouseInContentFlag &amp;&amp;          !pDragHandlerGlobals.windowIsHilightedFlag) {                    // set the proper clip          ClipRect(&amp;theWindow-&gt;portRect);                    // make a region bordering the window content          tempRgn = NewRgn();          RectRgn(tempRgn, &amp;theWindow-&gt;portRect);                    // draw the hilight          if (ShowDragHilite(theDrag, tempRgn, true) == noErr) {            // remember that hilighting is now on            pDragHandlerGlobals.windowIsHilightedFlag = true;          }                              // free up the region          DisposeRgn(tempRgn);        }                // else if the mouse is not in the content region        // and the window is hilighted, erase the hilight                else if (!mouseInContentFlag &amp;&amp;          pDragHandlerGlobals.windowIsHilightedFlag) {                    // set the proper clip          ClipRect(&amp;theWindow-&gt;portRect);                    // erase the hilight and restore the port          if (HideDragHilite(theDrag) == noErr)                      // remember that hilighting is now off            pDragHandlerGlobals.windowIsHilightedFlag = false;        }      }      break;    // do nothing for the leaveHandler message    case dragTrackingLeaveHandler:      break;        // let the drag manager know if we didn't recognize the message    default:      retCode = paramErr;  }    return retCode;}////  DropLocationIsFinderTrash////  Returns true if the given dropLocation AEDesc is a descriptor of the Finder's Trash.//static Boolean DropLocationIsFinderTrash(AEDesc *dropLocation){  OSErr      result;  AEDesc      dropSpec;  FSSpec      *theSpec;  CInfoPBRec    thePB;  short      trashVRefNum;  long      trashDirID;  //  //  Coerce the dropLocation descriptor to an FSSpec. If there's no dropLocation or  //  it can't be coerced into an FSSpec, then it couldn't have been the Trash.  //  if ((dropLocation-&gt;descriptorType != typeNull) &amp;&amp;    (AECoerceDesc(dropLocation, typeFSS, &amp;dropSpec) == noErr)) {    HLock(dropSpec.dataHandle);    theSpec = (FSSpec *) *dropSpec.dataHandle;    //    //  Get the directory ID of the given dropLocation object.    //    thePB.dirInfo.ioCompletion = 0L;    thePB.dirInfo.ioNamePtr = (StringPtr) &amp;theSpec-&gt;name;    thePB.dirInfo.ioVRefNum = theSpec-&gt;vRefNum;    thePB.dirInfo.ioFDirIndex = 0;    thePB.dirInfo.ioDrDirID = theSpec-&gt;parID;    result = PBGetCatInfo(&amp;thePB, false);    HUnlock(dropSpec.dataHandle);    AEDisposeDesc(&amp;dropSpec);    if (result != noErr)      return(false);    //    //  If the result is not a directory, it must not be the Trash.    //    if (!(thePB.dirInfo.ioFlAttrib &amp; (1 &lt;&lt; 4)))      return(false);    //    //  Get information about the Trash folder.    //    FindFolder(theSpec-&gt;vRefNum, kTrashFolderType, kCreateFolder, &amp;trashVRefNum, &amp;trashDirID);    //    //  If the directory ID of the dropLocation object is the same as the directory ID    //  returned by FindFolder, then the drop must have occurred into the Trash.    //    if (thePB.dirInfo.ioDrDirID == trashDirID)      return(true);  }  return(false);}////  DoDragObjects////  Drag the selected text in the given document.//short DoDragObjects(DocumentPtr theDocument, EventRecord *theEvent, RgnHandle hiliteRgn){  short        result;  RgnHandle      dragRegion, tempRgn;  Point        theLoc;  DragReference    theDrag;  StScrpHandle    theStyl;  AEDesc        dropLocation;  DragAttributes    attributes;  short        mouseDownModifiers, mouseUpModifiers, copyText;  unsigned long    validSize;  if( theDocument-&gt;documentGroup ) {    Handle        theData;    TQ3StorageObject    storage;    TQ3FileObject    fd;    TQ3GroupPosition    position;    TQ3TransformObject   xform;        DragSendDataUPP    mySendDataProcUPP ;        //Q3Object_Dispose(pickObject);    CopyRgn(hiliteRgn, dragRegion = NewRgn());    SetPt(&amp;theLoc, 0, 0);    LocalToGlobal(&amp;theLoc);    OffsetRgn(dragRegion, theLoc.h, theLoc.v);      //    //  Wait for the mouse to move to the mouse button to be released. If the mouse button was    //  released before the mouse moves, return false. Returing false from DoDragObjects means that    //  a drag operation did not occur.    //      if (! WaitMouseMoved(theEvent-&gt;where)) {      return(false);    }      // create a new reference for a track to pass to track drag    NewDrag(&amp;theDrag);      //  We promise '3DMF' and 'PICT'.  If a receiver requests either, the Drag Manager    //  will call our MySendDataProc to provide the data at drop time. The MySendDataProc    //  is specified by calling SetDragSendProc.    AddDragItemFlavor(theDrag, 1, '3DMF', nil, 0L, 0L);//    AddDragItemFlavor(theDrag, 1, 'PICT', nil, 0L, 0L);        mySendDataProcUPP = NewDragSendDataProc(MySendDataProc) ;    SetDragSendProc(theDrag, mySendDataProcUPP, (void *) theDocument);      //  Set the item's bounding rectangle in global coordinates.    SetDragItemBounds(theDrag, 1, &amp;(**dragRegion).rgnBBox);      //  Prepare the drag region.    tempRgn = NewRgn();    CopyRgn(dragRegion, tempRgn);    InsetRgn(tempRgn, 1, 1);    DiffRgn(dragRegion, tempRgn, dragRegion);    DisposeRgn(tempRgn);      // on PPC the drawing proc leaves artifacts on the display when     // highlighting and upon removal of highlighting for a window, so    // although I may prefer the drawing that my custom proc does, I    // just use the default.  This may be a bug in the drag manager    // or it may be us, but right now we'll just a void doing this and fix later//      SetDragDrawingProc(theDrag,NewDragDrawingProc(MyDrawingProc), 0L);      //  Drag the stuff. TrackDrag will return userCanceledErr if the drop zoomed-back    //  for any reason.    result = TrackDrag(theDrag, theEvent, dragRegion);        // get rid of the UPP    DisposeRoutineDescriptor( mySendDataProcUPP ) ;      if (result != noErr &amp;&amp; result != userCanceledErr) {      return(true);    }      //  Check to see if the drop occurred in the Finder's Trash. If the drop occurred    //  in the Finder's Trash and a copy operation wasn't specified, delete the    //  source selection. Note that we can continute to get the attributes, drop location    //  modifiers, etc. of the drag until we dispose of it using DisposeDrag.    GetDragAttributes(theDrag, &amp;attributes);    if (!(attributes &amp; dragInsideSenderApplication)) {        GetDropLocation(theDrag, &amp;dropLocation);        GetDragModifiers(theDrag, 0L, &amp;mouseDownModifiers, &amp;mouseUpModifiers);      copyText = (mouseDownModifiers | mouseUpModifiers) &amp; optionKey;        if ((!copyText) &amp;&amp; (DropLocationIsFinderTrash(&amp;dropLocation))) {        theDocument-&gt;dirty = true;        Q3Object_Dispose(theDocument-&gt;documentGroup);        theDocument-&gt;documentGroup = nil;      }        AEDisposeDesc(&amp;dropLocation);    }    //  Dispose of the drag.    DisposeDrag(theDrag);    DisposeRgn(dragRegion);    return(true);  }bail:  return(false);}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Tumbler_and_Podium/listing9.html%3Fid%3DDTS10000127-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Tumbler_and_Podium/listing9.html%3Fid%3DDTS10000127-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Tumbler_and_Podium/listing9.html%3Fid%3DDTS10000127-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>