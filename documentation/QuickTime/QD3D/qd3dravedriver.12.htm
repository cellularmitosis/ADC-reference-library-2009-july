<HTML><HEAD><META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter"><script language="JavaScript" src="frametest.js"></script><TITLE> Supporting OpenGL Hardware</TITLE></HEAD><BODY BGCOLOR="#ffffff"><!-- start of header --><!--#include virtual="/includes/framesetheader" --><!-- end of header --><!-- path goes here --><H1 CLASS="H2.Heading2"><A NAME="pgfId=51336"> </A><A NAME="28624"> </A>Supporting OpenGL Hardware</H1><P CLASS="T1.Text1"><A NAME="pgfId=52345"> </A><A NAME="marker=53118"> </A>This section contains information that is useful if you are implementing a drawing engine to support hardware that is based on an OpenGL rasterization model. It describes special considerations for handling transparency and texture mapping.</P><DIV><H2 CLASS="H3.Heading3"><A NAME="pgfId=51337"> </A>Transparency</H2><P CLASS="T1.Text1"><A NAME="pgfId=52461"> </A><A NAME="marker=53116"> </A>QuickDraw&nbsp;3D RAVE supports three transparency models: the premultiplied, interpolated, and OpenGL transparency models. Support for the OpenGL transparency model (indicated by the <TT CLASS="cv">kQABlend_OpenGL</TT> constant) should be automatic for hardware that is based on the OpenGL rasterization model. The other two models, indicated by the <TT CLASS="cv">kQABlend_PreMultiply</TT> and <TT CLASS="cv">kQABlend_Interpolate</TT> constants) may require emulation by your drawing engine.</P><P CLASS="T1.Text1"><A NAME="pgfId=52464"> </A>For example, consider the premultiplied blending function, specified by these equations:</P><DIV><IMG SRC="qd3dravedriver-2.gif"></DIV><P CLASS="T1.Text1"><A NAME="pgfId=52314"> </A>(Here, the factors <EM CLASS="Subscript">s</EM>, <EM CLASS="Subscript">s</EM>, <EM CLASS="Subscript">s</EM>, and <EM CLASS="Subscript">s</EM> represent the alpha, red, green and blue components of a source pixel; the factors <EM CLASS="Subscript">d</EM>, <EM CLASS="Subscript">d</EM>, <EM CLASS="Subscript">d</EM>, and <EM CLASS="Subscript">d</EM> represent the alpha, red, green and blue components of a destination pixel.)</P><P CLASS="Note"><A NAME="pgfId=52428"> </A>A complete description of how transparent objects are blended together with each of these models is provided in <A HREF="qd3dravedriver.1d.htm#22734" CLASS="XRef">&quot;Blending Operations&quot;</A>. </P><P CLASS="T1.Text1"><A NAME="pgfId=52472"> </A>OpenGL directly supports the premultiplied transparency blending function (and the interpolated transparency blending function) for the RGB components only. In other words, the alpha channel component (which is the same for both blending operations) cannot be directly implemented in OpenGL-compliant hardware. It is possible, however, to emulate these two transparency modes on OpenGL hardware, using several different methods. You can blend the RGB values only, or you can blend the ARGB values using a multipass algorithm. Which of these emulations you use depends on whether your drawing engine is associated with a frame buffer that stores an alpha channel or not.</P><P CLASS="T1.Text1"><A NAME="pgfId=52506"> </A>If your drawing engine is associated with a frame buffer that doesn't store an alpha channel value, you can implement the premultiplied and interpolated blending functions by simply ignoring the alpha channel component. These functions are then equivalent to OpenGL blending modes. The premulitplied blending function, with its alpha channel ignored, can be emulated by this function:</P><CODE CLASS="Cv.Code"><A NAME="pgfId=64038"> </A>gBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=52507"> </A>Similarly, the interpolated blending function, with its alpha channel ignored, can be emulated by this function:</P><CODE CLASS="Cv.Code"><A NAME="pgfId=64042"> </A>gBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);<BR></CODE><P CLASS="I.Important"><A NAME="pgfId=54018"> </A>A drawing engine that uses this method of emulating the QuickDraw&nbsp;3D RAVE blending functions on OpenGL hardware should not set the <TT CLASS="cv">kQAOptional_BlendAlpha</TT> flag of the <TT CLASS="cv">kQAGestalt_OptionalFeatures</TT> selector to the <TT CLASS="cv">QAEngineGestalt</TT> function. </P><P CLASS="T1.Text1"><A NAME="pgfId=52591"> </A>To achieve a more complete blending, you can have your drawing engine rasterize each transparent object more than once, altering in each pass the blending mode, object alpha channel, and buffer write masks. The first pass should perform RGB blending. Accordingly, you should disable writing any alpha channel or z buffer data during this pass.</P><CODE CLASS="Cv.Code"><A NAME="pgfId=64046"> </A>/*first pass*/<BR>glColorMask(TRUE, TRUE, TRUE, FALSE);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*disable alpha channel*/<BR>glDepthMask(FALSE);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*disable Z buffer*/<BR>if (premultpliedTransparency)<BR>&nbsp;&nbsp;&nbsp;&nbsp;glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);<BR>else<BR>&nbsp;&nbsp;&nbsp;&nbsp;glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);<BR>/*render the object here*/<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=52714"> </A>On the second pass, you should set the frame buffer alpha channel value to (1-<I CLASS="italics">a</I><EM CLASS="Subscript">s</EM>)(1-<I CLASS="italics">a</I><EM CLASS="Subscript">d</EM>). To do this, you need to render the object again, with a different alpha value, as follows:</P><CODE CLASS="Cv.Code"><A NAME="pgfId=64050"> </A>/*second pass*/<BR>glColorMask(FALSE, FALSE, FALSE, TRUE);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*enable alpha channel*/<BR>glDepthMask(FALSE);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*disable Z buffer*/<BR>glBlendFunc(GL_ONE_MINUS_DST_ALPHA, GL_ZERO);<BR>/*render the object with alpha replaced with 1-a*/<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=52709"> </A>Finally, the third pass should replace the value in the alpha channel with the final value 1-((1-<I CLASS="italics">a</I><EM CLASS="Subscript">s</EM>)(1-<I CLASS="italics">a</I><EM CLASS="Subscript">d</EM>)). To do this, you need to render the object again, with its alpha value set to 1, as follows:</P><CODE CLASS="Cv.Code"><A NAME="pgfId=64054"> </A>/*third pass*/<BR>glColorMask(FALSE, FALSE, FALSE, TRUE);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*enable alpha channel*/<BR>glDepthMask(TRUE);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*enable Z buffer*/<BR>glBlendFunc(GL_ONE_MINUS_DST_ALPHA, GL_ZERO);<BR>/*render the object with alpha replaced with 1*/<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=52843"> </A>After the third pass, the frame buffer contains the correctly blended object.<A NAME="marker=53117"> </A></P></DIV><DIV><H2 CLASS="H3.Heading3"><A NAME="pgfId=51342"> </A>Texture Mapping</H2><P CLASS="T1.Text1"><A NAME="pgfId=52863"> </A><A NAME="marker=53121"> </A>QuickDraw&nbsp;3D RAVE supports several texture mapping operations, which are controlled by the flags in the <TT CLASS="cv">kQATag_TextureOp</TT> state variable. Currently these flags are defined:</P><CODE CLASS="Cv.Code"><A NAME="pgfId=64058"> </A>#define kQATextureOp_Modulate&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 0)<BR>#define kQATextureOp_Highlight&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 1)<BR>#define kQATextureOp_Decal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 2)<BR>#define kQATextureOp_Shrink&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 3)<BR></CODE><P CLASS="Note"><A NAME="pgfId=52963"> </A>A complete description of texture mapping operations is provided in <A HREF="qd3dravedriver.20.htm#29338" CLASS="XRef">&quot;Texture Operations&quot;</A>. </P><P CLASS="T1.Text1"><A NAME="pgfId=52893"> </A>To support the <TT CLASS="cv">kQATextureOp_Modulate</TT> mode on an OpenGL-compliant rasterizer, you can use the <TT CLASS="cv">GL_MODULATE</TT> mode, where the <TT CLASS="cv">kd_r</TT>, <TT CLASS="cv">kd_g</TT>, and <TT CLASS="cv">kd_b</TT> fields of a texture vertex specify the modulating color. Note, however, that <TT CLASS="cv">GL_MODULATE</TT> does not allow these color values to be greater than 1.0, whereas QuickDraw&nbsp;3D RAVE does allow them to be greater than 1.0. Values greater than 1.0 can provide improved image realism, and new hardware should support them. A more reasonable maximum modulation amplitude is 2.0.</P><P CLASS="T1.Text1"><A NAME="pgfId=52894"> </A>You can support the <TT CLASS="cv">kQATextureOp_Highlight</TT> mode by performing two rendering passes. The first pass should render the texture-mapped object (possibly also with modulation, as just described), and the second pass should add the specular highlight value.</P><CODE CLASS="Cv.Code"><A NAME="pgfId=64062"> </A>/*first pass*/<BR>glDepthMask(FALSE);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*disable Z buffer*/<BR>/*render the texture-mapped object here*/<BR><BR>/*second pass*/<BR>glDepthMask(TRUE);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*enable Z buffer*/<BR>glBlendFunc(GL_ONE, GL_ONE);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*add highlight color*/<BR>/*render the highlight color as a Gouraud-shaded object here*/<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=52984"> </A>On the second pass, you should render the highlight color, using the <TT CLASS="cv">ks_r</TT>, <TT CLASS="cv">ks_g</TT>, and <TT CLASS="cv">ks_b</TT> fields of a texture vertex, as a Gouraud-shaded object.</P><P CLASS="T1.Text1"><A NAME="pgfId=53038"> </A>If the <TT CLASS="cv">kQATextureOp_Modulate</TT> flag is clear (that is, is no texture map color modulation is to be performed), you can support the <TT CLASS="cv">kQATextureOp_Decal</TT> mode using the OpenGL <TT CLASS="cv">GL_DECAL</TT> mode. If, in addition, the <TT CLASS="cv">kQATextureOp_Highlight</TT> flag is set, you need to perform two rendering passes, as just described.</P><P CLASS="I.Important"><A NAME="pgfId=53083"> </A>There is currently no known method of accurately rendering to OpenGL-compliant hardware when <I CLASS="italics">both</I> the <TT CLASS="cv">kQATextureOp_Decal</TT> and the <TT CLASS="cv">kQATextureOp_Modulate</TT> flags are set. You should determine the best method of implementing this mode correctly on your hardware. If your hardware cannot handle both modes at once, you should ignore the <TT CLASS="cv">kQATextureOp_Modulate</TT> mode whenever <TT CLASS="cv">kQATextureOp_Decal</TT> is set. <A NAME="marker=53107"> </A><A NAME="marker=53119"> </A><A NAME="marker=53122"> </A></P></DIV><hr>&#169; 1997 Apple Computer, Inc.</DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV><!-- start of footer --><!--#include virtual="/includes/framesetfooter" --><!-- end of footer --></BODY></HTML>