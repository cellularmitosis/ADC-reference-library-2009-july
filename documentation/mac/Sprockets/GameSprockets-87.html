<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Using DrawSprocket (GameSprockets)</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" ="A" NAME="HEADING87"></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="GameSprockets-86.html"><IMG ALIGN="BOTTOM" SRC="prev.gif" BORDER="none" HSPACE="20" ALT="Previous"></A> <A HREF="GameSprockets-2.html"><IMG ALIGN="BOTTOM" SRC="content.gif" BORDER="none" HSPACE="20" ALT="Book Contents"></A> <A HREF="GameSprockets-318.html"><IMG ALIGN="BOTTOM" SRC="index.gif" BORDER="none" HSPACE="20" ALT="Book Index"></A> <A HREF="GameSprockets-88.html"><IMG ALIGN="BOTTOM" SRC="next.gif" BORDER="none" HSPACE="20" ALT="Next"></A> </CENTER><P>
<FONT SIZE="-1"><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="GameSprockets-2.html"><B>Apple Game Sprockets Guide</B></A> / <BR><DD><A HREF="GameSprockets-85.html"><B>Chapter 2 - DrawSprocket</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME="HEADING87-0"></A>
<H1>Using DrawSprocket</H1>
 To use DrawSprocket in a game, you need to find the context that best matches the display configuration requested by the game and then reserve and activate the context. When activating the context, you should use the gamma fade capabilities to avoid flicker. During game play you can designate alternate buffers as underlays or overlays to avoid redrawing repeated graphic elements. Finally, you will probably want to take advantage of DrawSprocket's hardware or software page flipping. This section gives code examples of these tasks, as well as an example of cleaning up before quitting and using DrawSprocket's debug mode.<P>
<A NAME="HEADING87-2"></A>
<H2><A NAME="MARKER-2-27"></A><A NAME="MARKER-9-28"></A>Choosing a Context</H2>
 <A NAME="MARKER-2-29"></A>One of your game's first tasks is to find the best available context. You can use the <CODE>DSpFindBestContext</CODE> function to have DrawSprocket find a context that matches the attributes the game requests.<P>
 When you call <CODE>DSpFindBestContext</CODE>, passing in a DSpContextAttributes structure, DrawSprocket interprets the attributes specified in the attributes structure as requirements. This insures that the game can search for only those contexts that meet a specific criteria, and know that any matches found will meet those specifications. This is in contrast to what happens when you call <CODE>DSpContext_Reserve</CODE>, where the specified attributes are interpreted as requests. This makes it easy for the game to request a feature at reservation time, knowing that the context will be reserved even  if that feature is not available. <P>
 For example, if the <CODE>kDSpContextOption_PageFlip</CODE> bit is set in the attributes structure's <CODE>contextOptions</CODE> field when you call <CODE>DSpFindBestContext</CODE>, only contexts with hardware page flipping will be considered in the search. However, when you call <CODE>DSpContext_Reserve</CODE> to reserve the context and the <CODE>contextOptions</CODE> field has the <CODE>kDSpContextOption_PageFlip</CODE> bit set, if page flipping is not available for the context being reserved, DrawSprocket will reserve it anyway and use software buffering. <P>
<A NAME="HEADING87-6"></A>
<H3>Initializing the Context Attributes Structure</H3>
 <A NAME="MARKER-2-30"></A>Before beginning, you should initialize the DSpContextAttributes structure you will pass to <CODE>DSpFindBestContext</CODE> so that the fields contain no garbage that could cause DrawSprocket to return an error. This is especially important for fields that DrawSprocket can't check, such as the <CODE>colorTable</CODE> field. If there is a bad value in the <CODE>colorTable</CODE> field when a call to reserve a context is made, DrawSprocket will try to use that color table (causing unpleasant visits to the debugger). The context attributes structure is described on <A HREF="GameSprockets-97.html#MARKER-9-98">(page 2-27)</A>.<P>
<B>Listing 2-1  Initializing a context attributes structure</B><P>
<PRE>
void MyInitAttributes (DSpContextAttributes *inAttributes)
{
   if (NULL == inAttributes)
      DebugStr(&quot;\pStimpy! You Idiot!&quot;);
   
   inAttributes-&gt;frequency = 0;
   inAttributes-&gt;displayWidth = 0;
   inAttributes-&gt;displayHeight = 0;
   inAttributes-&gt;reserved1 = 0;
   inAttributes-&gt;reserved2 = 0;
   inAttributes-&gt;colorNeeds = 0;
   inAttributes-&gt;colorTable = NULL;
   inAttributes-&gt;contextOptions = 0;
   inAttributes-&gt;backBufferDepthMask = 0;
   inAttributes-&gt;displayDepthMask = 0;
   inAttributes-&gt;backBufferBestDepth = 0;
   inAttributes-&gt;displayBestDepth = 0;
   inAttributes-&gt;pageCount = 0;
   inAttributes-&gt;gameMustConfirmSwitch = false;
   inAttributes-&gt;reserved3[0] = 0;
   inAttributes-&gt;reserved3[1] = 0;
   inAttributes-&gt;reserved3[2] = 0;
   inAttributes-&gt;reserved3[3] = 0;
}
</PRE>
<A NAME="HEADING87-10"></A>
<H3>Finding a Context</H3>
 <A NAME="MARKER-2-31"></A>This section shows how to find a context that matches attributes required by the game. <A HREF="#MARKER-9-32">Listing 2-2</A> shows how to use DSpFindBestContext <A HREF="GameSprockets-103.html#MARKER-9-105">(page 2-31)</A> to tell DrawSprocket to find a 320x200 color display with a pixel depth of 8.<P>
<B>Listing 2-2  <A NAME="MARKER-9-32"></A>Finding the best context </B><P>
<PRE>
DSpContextAttributes theDesiredAttributes;
DSpContextReference theContext;
OSStatus theError;

MyInitAttributes(&amp;theDesiredAttributes);
theDesiredAttributes.displayWidth = 320;
theDesiredAttributes.displayHeight = 200;
theDesiredAttributes.colorNeeds = kDSpColorNeeds_Require;
theDesiredAttributes.backBufferDepthMask = kDSpDepthMask_8;
theDesiredAttributes.displayDepthMask = kDSpDepthMask_8;
theDesiredAttributes.backBufferBestDepth = 8;
theDesiredAttributes.displayBestDepth = 8;
theError = DSpFindBestContext(&amp;theDesiredAttributes,
   &amp;theContext);
</PRE>
<A NAME="HEADING87-14"></A>
<H2><A NAME="MARKER-2-33"></A><A NAME="MARKER-9-34"></A>Reserving and Activating a Context</H2>
 <A NAME="MARKER-2-35"></A>Once you have found the best context, you reserve it and then activate it. Follow these steps:<P>
<OL>
<LI>Call the DSpContext_Reserve function <A HREF="GameSprockets-114.html#MARKER-9-121">(page 2-41)</A>. Reserving a context does not result in any change to the user's display because the play state of the context is initially inactive. At this point, the user is still interacting with the system in a normal fashion.
<LI>Set the play state of your context to active with the DSpContext_SetState function <A HREF="GameSprockets-116.html#MARKER-9-125">(page 2-43)</A>. This causes the display to change to the resolution you have chosen, and causes a blanking window to cover the entire screen, giving your game complete control over the display. <P>
(Before activating the context, however, you may want to fade the screen display; see <A HREF="#MARKER-9-45">"Fading the Display" (page 2-17)</A> for an example.)<P>
</OL>
 Prior to reserving the context be sure to request any features you would like to use that were not requirements passed to the <CODE>DSpFindBestContext </CODE>call. For example, if you want page flipping, request<P>
<PRE>
theDesiredAttributes.contextOptions |= kDSpContextOption_PageFlip;
</PRE>
 DrawSprocket will use software buffering if hardware page flipping is not available. <P>
 You can also request that DrawSprocket use double or triple buffering by setting the <CODE>kDSpContextOption_TripleBuffer</CODE> flag. If you want only double buffering, perhaps because of memory constraints, you should turn off the <CODE>kDSpContextOption_TripleBuffer</CODE> option bit. <P>
 If both the triple-buffering option bit and the page-flipping option bit are set, and hardware page flipping is available but there are only two video pages --not three--DrawSprocket considers page flipping to be a more important option than triple buffering and drops you down to two VRAM pages, maintaining page flipping. <P>
<B>Listing 2-3  Reserving and activating a context</B><P>
<PRE>
theError = DSpContext_Reserve(theContext, &amp;theDesiredAttributes);

theError = DSpContext_SetState(theContext, kDSpContextState_Active);
</PRE>
<A NAME="HEADING87-26"></A>
<H2><A NAME="MARKER-9-36"></A>Creating Underlays and Overlays </H2>
 <A NAME="MARKER-2-37"></A><A NAME="MARKER-2-38"></A>You can allocate alternate buffers to use for underlays and overlays. An underlay is useful in games that need to restore from a static background. An overlay is useful for things such as a cockpit view that is superimposed on the back buffer before it is displayed. <P>
<A NAME="HEADING87-28"></A>
<H3>How Underlays Work</H3>
 <A NAME="MARKER-2-39"></A>To create an underlay you first create an alternate buffer and draw into it. Then you designate the alternate buffer as the current underlay. <A HREF="#MARKER-9-40">Listing 2-4</A> shows how to use the DSpAltBuffer_New function <A HREF="GameSprockets-136.html#MARKER-9-170">(page 2-60)</A> to create an alternate buffer and the DSpContext_SetUnderlayAltBuffer <A HREF="GameSprockets-141.html#MARKER-9-179">(page 2-63)</A> to designate the new buffer as the underlay for a context.<P>
<B>Listing 2-4  <A NAME="MARKER-9-40"></A>Creating an underlay</B><P>
<PRE>
theError = DSpAltBuffer_New(theContext, false, &amp;theUnderlay);

theError = DSpContext_SetUnderlayAltBuffer(theContext, theUnderlay);
</PRE>
 Once you establish an underlay, every time you call <CODE>DSpContext_GetBackBuffer</CODE>, the invalid rectangles associated with the returned back buffer are used to copy the image data from the underlay into the back buffer (the first time you get the back buffer, the entire buffer is invalid). In a game with sprites overlaid on the background (the underlay), the sprites are erased when the buffer's invalid rectangles are used to copy the underlay data into the back buffer.<P>
 You can make changes in the underlay image, but you must invalidate the underlay rectangles that have been modified in order for the data to be updated to each back buffer (otherwise the back buffer will only have its own invalid rectangles restored). To do this call the <CODE>DSpAltBuffer_InvalRect</CODE> function <A HREF="GameSprockets-143.html#MARKER-9-183">(page 2-65)</A>.<P>
 You can also have several underlays and switch between them with additional calls to <CODE>DSpContext_SetUnderlayAltBuffer</CODE>. However, each underlay change forces a full update in the back buffer unless you immediately invalidate the unique portions of the new underlay with a call to <CODE>DSpAltBuffer_InvalRect</CODE>. For example, in a scroller game with a constant horizon area (such as a mountain range), after you switched underlays you would invalidate the areas in the new underlay that differed from the previous one to avoid the full back buffer update. See <A HREF="#MARKER-9-55">"Improving Performance With Dirty Rectangles" (page 2-20)</A>.<P>
<A NAME="HEADING87-35"></A>
<H3>How Overlays Work</H3>
 <A NAME="MARKER-2-41"></A><A NAME="MARKER-2-42"></A><A NAME="MARKER-2-43"></A>As with underlays, you first create a buffer and draw into it. <A HREF="#MARKER-9-44">Listing 2-5</A> shows how to allocate an alternate buffer to use as an overlay using DSpContext_SetOverlayAltBuffer <A HREF="GameSprockets-139.html#MARKER-9-175">(page 2-62)</A>. <P>
<B>Listing 2-5  <A NAME="MARKER-9-44"></A>Creating an overlay</B><P>
<PRE>
theError = pAltBuffer_New(theContext, false, &amp;theOverlay);

theError = DSpContext_SetOverlayAltBuffer(theContext, theOverlay);
</PRE>
 To create the transparency mask that allows the back buffer to show through, DrawSprocket provides the <CODE>DSpAltBuffer_RebuildTransparencyMask</CODE> function <A HREF="GameSprockets-144.html#MARKER-9-185">(page 2-66)</A>. Building the transparency mask is a CPU intensive operation and shouldn't be done during game play. Build or rebuild your masks at game startup or at a point in the game where a pause is acceptable (such as between levels).<P>
 As with underlays, you can change an overlay or designate a different buffer to serve as the overlay during the game's execution. For example, if you have a cockpit image that changes during game play, as when the user looks out the side of a plane, you can set up multiple overlays and switch them between frames. <P>
 You should call <CODE>DSpAltBuffer_InvalRect</CODE> on the new overlay if only portions of the overlay have changed (such as a bullet hole appearing in a window); otherwise, the entire buffer is updated. See <A HREF="#MARKER-9-55">"Improving Performance With Dirty Rectangles" (page 2-20)</A>.<P>
<A NAME="HEADING87-42"></A>
<H2><A NAME="MARKER-9-45"></A>Fading the Display</H2>
 <A NAME="MARKER-2-46"></A><A NAME="MARKER-2-47"></A><A NAME="MARKER-2-48"></A>When you first make your context's play state active, and then subsequently deactivate it when quitting, that is likely to cause a resolution change and an accompanying annoying flicker or flash. Therefore, you will probably want to fade your display out before the change occurs, and then fade it back in afterward.<P>
 The gamma fading supported by DrawSprocket is sophisticated and versatile; you may want to use it at other times as well as during resolution changes. See <A HREF="GameSprockets-86.html#MARKER-9-16">"Gamma Fading" (page 2-9)</A> for more information.<P>
 <A HREF="#MARKER-9-49">Listing 2-6</A> shows how to use DSpContext_FadeGammaOut to automatically fade out all displays to black, put a context in the active state with DSpContext_SetState, and then fade back in using DSpContext_FadeGammaIn. You must have at least one reserved context to automatically fade in or out or you will get an error. <P>
 The automatic gamma fade functions allow you to specify a zero-intensity color other than black and to fade only specified displays. For details see the DSpContext_FadeGammaOut function <A HREF="GameSprockets-121.html#MARKER-9-137">(page 2-47)</A> and the DSpContext_FadeGammaIn function <A HREF="GameSprockets-122.html#MARKER-9-139">(page 2-48)</A>. DrawSprocket also provides another function for manual fading--you can fade partway in or out at a speed you choose. See the <CODE>DSpContext_FadeGamma</CODE> function <A HREF="GameSprockets-120.html#MARKER-9-133">(page 2-45)</A>.<P>
<B>Listing 2-6  <A NAME="MARKER-9-49"></A>Automatically fading the display</B><P>
<PRE>
/* fade out all displays */
theError = DSpContext_FadeGammaOut(NULL, NULL);

/* put the context into the active state */
theError = DSpContext_SetState(theContext, kDSpContextState_Active);

/* fade back in */
theError = DSpContext_FadeGammaIn(NULL, NULL);
</PRE>
<A NAME="HEADING87-49"></A>
<H2>Double-Buffered Drawing</H2>
 <A NAME="MARKER-2-50"></A><A NAME="MARKER-2-51"></A>If you want to use double-buffering (or hardware-supported page flipping) for your drawing, DrawSprocket facilitates easy access to your offscreen buffer. Here are the steps required for double-buffered drawing:<P>
<OL>
<LI>For each frame you draw, call the DSpContext_GetBackBuffer function to obtain a pointer to the graphics port you render to. 
<LI>Draw the portions of the frame that need updating.
<LI>Call the DSpContext_InvalBackBufferRect function for each rectangular area that you have invalidated. This step can greatly enhance performance (see <A HREF="#MARKER-9-55">"Improving Performance With Dirty Rectangles" (page 2-20)</A>.
<LI>Call the DSpContext_SwapBuffers function. At the next vertical retrace DrawSprocket copies the invalidated portions of the back buffer to the device's display.<P>
</OL>
 <A HREF="#MARKER-9-52">Listing 2-7</A> shows how to get the back buffer and set it up as the current port, ready to draw into.<P>
<B>Listing 2-7  <A NAME="MARKER-9-52"></A>Getting the back buffer</B><P>
<PRE>
/* get the back buffer */
theError = DSpContext_GetBackBuffer(theContext, kDSpBufferKind_Normal,
   &amp;theBackBuffer);

/* set the back buffer to be the current port */
SetPort((GrafPtr)theBackBuffer);
</PRE>
 The code in <A HREF="#MARKER-9-53">Listing 2-8</A> draws a rectangle into the back buffer. If you are using an underlay, there is no need to erase the back buffer before drawing; the buffer is automatically filled with the underlay image.<P>
<B>Listing 2-8  <A NAME="MARKER-9-53"></A>Drawing into the buffer</B><P>
<PRE>
if (!inUseUnderlay)
   EraseRect(&amp;theBackBuffer-&gt;portRect);

/* fill the display with a rectangle */
RGBForeColor(&amp;theColor);
PaintRect(&amp;theRectangleRect);
</PRE>
 After invalidating the changed parts of the buffer, you are ready to draw the back buffer to the display by calling DSpContext_SwapBuffers, as shown in <A HREF="#MARKER-9-54">Listing 2-9</A>. <P>
<B>Listing 2-9  <A NAME="MARKER-9-54"></A>Swapping buffers  </B><P>
<PRE>
theError = DSpContext_SwapBuffers(theContext, NULL, 0);
</PRE>
<A NAME="HEADING87-64"></A>
<H2><A NAME="MARKER-9-55"></A>Improving Performance With Dirty Rectangles</H2>
 <A NAME="MARKER-2-56"></A>Using dirty rectangles is crucial to achieving optimum performance for your game. A dirty rectangle is an area of the back buffer that has been invalidated so that DrawSprocket knows it has been changed. When you draw into a back buffer, always call <CODE>DSpContext_InvalBackBufferRect</CODE> to let DrawSprocket know the bounding rectangle of the area that has been altered. If you do not invalidate the rectangles you use, the entire buffer must be transferred at the next swap.<P>
 Invalidating rectangles is most important with software buffering, but it also affects performance with page flipping if you are using underlays or overlays in your game. In any event, you won't pay a performance penalty for telling DrawSprocket about the invalid rectangles--you will only pay a penalty for not doing so.<P>
 DrawSprocket provides a separate call for invalidating rectangles in the buffer designated as the current underlay or overlay. If you change pixel data for a current underlay or overlay, you must call <CODE>DSpAltBuffer_InvalRect</CODE> in order for the change to be brought into the back buffer. Furthermore, if you change an overlay in such a way that the transparency mask changes, after invalidating the rectangle where the change occurred, you must call <CODE>DSpAltBuffer_RebuildTransparencyMask</CODE> in order to re-create the mask. This is a slow process and it is not advisable to do it at runtime.<P>
 A "dirty grid" overlays the back buffer and alternate buffers, dividing them into tiles. When you invalidate areas of a buffer, each grid tile that overlaps the dirty rectangle is marked as dirty, even if only a small part of the rectangle intersects with the grid tile. In other words, each grid tile is either all valid or all dirty. The size of the grid is determined in part by the hardware your game is running on and in part by the game itself. DrawSprocket provides functions for adjusting the size of the dirty grid: the <CODE>DSpContext_SetDirtyRectGridSize</CODE> function <A HREF="GameSprockets-127.html#MARKER-9-149">(page 2-53)</A>, the <CODE>DSpContext_GetDirtyRectGridSize</CODE> function <A HREF="GameSprockets-128.html#MARKER-9-151">(page 2-54)</A>, and <CODE>theDSpContext_GetDrityRectGridUnits</CODE> function <A HREF="GameSprockets-129.html#MARKER-9-154">(page 2-55)</A>. <P>
<A NAME="HEADING87-69"></A>
<H2>Cleaning Up Before Quitting DrawSprocket</H2>
 <A NAME="MARKER-2-57"></A><A HREF="#MARKER-9-58">Listing 2-10</A> illustrates the typical tasks your game must perform before quitting DrawSprocket: <P>
<UL>
<LI>Fade to black to avoid flicker when you switch contexts.
<LI>Dispose of all alternate buffers.
<LI>Inactivate the context and release it.
<LI>Fade back in.<P>
</UL>
<B>Listing 2-10  <A NAME="MARKER-9-58"></A>Cleaning up</B><P>
<PRE>
/* fade to black */
theError = DSpContext_FadeGammaOut(NULL, NULL);

/* remove the underlay and release it */
if (inUseUnderlay)
{
   DSpContext_SetUnderlayAltBuffer(theContext, NULL);
   DSpAltBuffer_Dispose(theUnderlay);
   theUnderlay = NULL;
}

/* remove the overlay and release it */
if (inUseOverlay)
{
   DSpContext_SetOverlayAltBuffer(theContext, NULL);
   DSpAltBuffer_Dispose(theOverlay);
   theOverlay = NULL;
}

/* put the context into the inactive state */
theError = DSpContext_SetState(theContext, kDSpContextState_Inactive);

/* fade back in */
theError = DSpContext_FadeGammaIn(NULL, NULL);

/* release the context */
theError = DSpContext_Release(theContext);
</PRE>
<A NAME="HEADING87-77"></A>
<H2>Debugging</H2>
 <A NAME="MARKER-2-59"></A>If you are in a debug cycle, you may want to enable debugging mode in DrawSprocket so that a fade out, followed by a break in the debugger, won't leave you with nothing to see. <A HREF="#MARKER-9-60">Listing 2-11</A> shows how to enable debug mode. You must call DSpSetDebugMode before activating the context in order for the call to take effect. For more information see the <CODE>DSpSetDebugMode</CODE> function <A HREF="GameSprockets-156.html#MARKER-9-206">(page 2-73)</A>.<P>
<B>Listing 2-11  <A NAME="MARKER-9-60"></A>Enabling debug mode</B><P>
<PRE>
DSpSetDebugMode(true);
</PRE>
 You can also cause DrawSprocket to enter debug mode by creating a folder in the same folder as your game and naming it &quot;DSpSetDebugMode&quot;. This method is handy if you don't want to rebuild your game with the call just to debug it. <P>
<HR>

</BLOCKQUOTE>
<HR>
<CENTER>
<A HREF="GameSprockets-86.html"><IMG ALIGN="BOTTOM" SRC="prev.gif" BORDER="none" HSPACE="20" ALT="Previous"></A> <A HREF="GameSprockets-2.html"><IMG ALIGN="BOTTOM" SRC="content.gif" BORDER="none" HSPACE="20" ALT="Book Contents"></A> <A HREF="GameSprockets-318.html"><IMG ALIGN="BOTTOM" SRC="index.gif" BORDER="none" HSPACE="20" ALT="Book Index"></A> <A HREF="GameSprockets-88.html"><IMG ALIGN="BOTTOM" SRC="next.gif" BORDER="none" HSPACE="20" ALT="Next"></A> </CENTER><P>
<CENTER><FONT SIZE="-1"><A HREF="GameSprockets-3.html">&copy; Apple Computer, Inc.</A><BR>2 JUL 1996</CENTER></FONT><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML> 
