<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Recipes--Events and Commands (MacApp PG)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING90></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="MacAppProgGuide-89.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-91.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="MacAppProgGuide-2.html"><B>Programmer's Guide to MacApp</B></A> / <A HREF="MacAppProgGuide-78.html"><B>Part 2 - Working With MacApp</B></A><BR><DD><A HREF="MacAppProgGuide-88.html"><B>Chapter 13 - Working With Events and Commands</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING90-0></A>
<H1><A NAME=MARKER-2-28></A>Recipes--Events and Commands</H1>
 The recipes and sample code in this section describe how to create command objects to respond to events, how to implement an undoable command, how to change the current target object, how to ensure idle time for an event-handler object, and how to use a behavior object to modify the operation of an event-handler object.<P>
<A NAME=HEADING90-2></A>
<H2>Creating a Command Object to Perform an Action--A General Overview</H2>
 When the application object receives an event that specifies an action, it dispatches the event by calling a method of an event-handler object. The application dispatches mouse-down events by calling the <CODE>DoMouseCommand</CODE> method, menu commands by calling <CODE>DoMenuCommand</CODE>, Apple events by calling <CODE>DoScriptCommand</CODE>, and so on. In any of those methods, the event-handler object can create and post a command object to perform the required action. Command objects are capable of doing, undoing, and redoing the action, as well as sending an Apple event to record the action or to allow an attached script to handle the operation.<P>
 For information on handling menu commands, see <A HREF=MacAppProgGuide-121.html#MARKER-9-30>"Working With Menus--A General Outline," beginning on page 313</A>.<P>
 To create a command object to perform an action, you follow these general steps:<P>
<OL>
<LI>Define a command class to perform the action:<P>
<UL>
<LI>Define a subclass of <CODE>TCommand</CODE> or one of its subclasses. 
<LI>Implement constructor, destructor, and initialization methods for the command class. 
<LI>Override the <CODE>DoIt</CODE> method to perform the command action. If the command is undoable, override the <CODE>UndoIt</CODE> and <CODE>RedoIt</CODE> methods.
<LI>If the command needs to perform an action only if it is completed in the done state, override the <CODE>Commit</CODE> method.
<LI>If the command allocates storage, free it in the destructor. If the storage must be freed before the destructor is called, override the <CODE>Free</CODE> method.
<LI>If the command is recordable or can be handled by an attached script, set the <CODE>fUseAppleEvent</CODE> field to <CODE>TRUE</CODE> (usually in the routine that creates the command) and override the <CODE>MakeAppleEvent</CODE> method to create an Apple event that describes the command action.<P>
</UL>
<LI>Decide which of your event-handling classes will create the command object.
<LI>If a view class will create the command object and the view is created as part of a view hierarchy defined in a view resource, you may need to specify which view in the hierarchy is the target view. 
<LI>To create and initialize the command object and post it to the MacApp command queue, you override the appropriate method in your event-handling class:<P>
<UL>
<LI><CODE>DoMenuCommand</CODE> to respond to a menu choice
<LI><CODE>DoMouseCommand</CODE> to respond to a mouse event
<LI><CODE>DoKeyEvent</CODE> or <CODE>DoCommandKeyEvent</CODE> to respond to a key event
<LI><CODE>DoScriptCommand</CODE> to respond to an Apple event<P>
</UL>
</OL>
<A NAME=HEADING90-20></A>
<H2><A NAME=MARKER-2-29></A><A NAME=MARKER-9-34></A>Recipe--Implementing an Undoable Zoom In Menu Command</H2>
 This recipe is based on the IconEdit application, which displays an icon and allows the user to zoom in to any desired magnification. In IconEdit, the Zoom In menu command appears on the Icon menu and is handled by the <CODE>TIconDocument</CODE> class.<P>
 To add a Zoom In menu command to a menu and respond when a user chooses that menu command, you perform these steps:<P>
<OL>
<LI>Define a command-number constant for the Zoom In menu item.
<LI>Add the Zoom In menu item to a <CODE>'CMNU'</CODE> resource in your resource file.
<LI>Implement a command class that handles zoom in.<P>
<UL>
<LI>Override the <CODE>DoIt</CODE>, <CODE>UndoIt</CODE>, and <CODE>RedoIt</CODE> methods.<P>
</UL>
<LI> Override the <CODE>DoSetupMenus</CODE> method in the view class to enable the Zoom In menu item when appropriate.
<LI> Override the <CODE>DoMenuCommand</CODE> method in the document class to create and post a command object to perform the zoom operation.<P>
</OL>
<DL>
<DT><B>Note</B>
<DD>The steps for adding a Zoom Out menu command are nearly identical.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 The sample code shown in this recipe is from the IconEdit application. For information on making the Zoom In command recordable, see <A HREF=MacAppProgGuide-93.html#MARKER-9-32>"Recipe--Defining a Recordable Command Class," beginning on page 353</A>.<P>
<A NAME=HEADING90-31></A>
<H3>Define a Command-Number Constant for the Zoom In Menu Item</H3>
 The IconEdit application defines a constant for the Zoom In item in both its resource file and its implementation file. The resource file, <CODE>IconEdit.r</CODE>, contains the following line:<P>
<PRE>
#define cZoomIn1000
</PRE>
 The implementation file, <CODE>UIconEdit.cp</CODE>, contains the following line:<P>
<PRE>
const CommandNumber cZoomIn = 1000; // Zoom In menu command.
</PRE>
 The constants defined in the resource file and implementation file must match or your application will not be able to respond to the menu choice correctly.<P>
<A NAME=HEADING90-37></A>
<H3>Add the Zoom In Menu Item to a 'CMNU' Resource</H3>
 The <CODE>'CMNU'</CODE> resource for the Icon menu is located in the file <CODE>IconEdit.r</CODE>. It contains the following line:<P>
<PRE>
/* [1] */&quot;Zoom In&quot;, noIcon, &quot;M&quot;, noMark, plain, cZoomIn;
</PRE>
  This line specifies that the Zoom In item is the first item in the menu, it has no icon associated with it, it has the Command-key equivalent of Command-M, it is not marked with a checkmark, it is displayed in plain text, and it has the command number cZoomIn.<P>
<A NAME=HEADING90-41></A>
<H3><A NAME=MARKER-9-31></A>Implement a Command Class That Handles Zoom In</H3>
 The IconEdit application defines the <CODE>TZoomInCommand</CODE> to implement zooming in. The class is defined as follows:<P>
<PRE>
class TZoomInCommand : public TCommand
{
   MA_DECLARE_CLASS;       // Generate RTTI information.
   
  public:
    TIconDocument * fIconDocument;// The document that is zoomed.

   TZoomInCommand();       // Constructor.
   virtual ~TZoomInCommand();// Destructor.
   virtual void IZoomInCommand(TIconDocument* itsIconDocument);
   virtual void DoIt();    // Override.
   virtual void RedoIt();  // Override.
   virtual void UndoIt();  // Override.
   virtual TAppleEvent* MakeAppleEvent();// Override.
};
</PRE>
 The constructor, TZoomInCommand, sets the fIconDocument field to <CODE>NULL</CODE>. The destructor, ~TZoomInCommand, does nothing. The MakeAppleEvent method creates an Apple event that specifies the Zoom In command. MakeAppleEvent is not shown in this recipe but is described in <A HREF=MacAppProgGuide-93.html#MARKER-9-32>"Recipe--Defining a Recordable Command Class," beginning on page 353</A>. All the other methods of the TZoomInCommand class are shown below.<P>
<A NAME=HEADING90-45></A>
<H4>The IZoomInCommand Method</H4>
 The initialization method for the Zoom In command class sets a reference to the icon document and calls the initialization method of its parent class, <CODE>TCommand</CODE>:<P>
<PRE>
void  TZoomInCommand::IZoomInCommand(TIconDocument* itsIconDocument)
{
   // Save a reference to the icon document.
   fIconDocument = itsIconDocument;

   // Initialize the inherited command.
   this-&gt;ICommand(cZoomIn,
               itsIconDocument, 
               kCanUndo, 
               kCausesChange, 
               itsIconDocument); // No view or scroller to track.
}
</PRE>
 The kCanUndo constant specifies that the command is undoable, while the kCausesChange constant specifies that the command changes its object to notify. A command's <CODE>fObjectToNotify</CODE> field may point to an object, such as a document, to notify when the command operation is completed. For example, a document might update its change count to show it has been modified.<P>
<A NAME=HEADING90-49></A>
<H4>The DoIt Method</H4>
 The <CODE>DoIt</CODE> method for the TZoomInCommand command gets the icon view from the icon document and increases the magnification value by 2.<P>
<PRE>
void TZoomInCommand::DoIt()
{ 
   TIconView * theIconView = fIconDocument-&gt;GetIconView();
   if (theIconView != NULL)
   {
      short currentMagnification = theIconView-&gt;GetMagnification();
      theIconView-&gt;SetMagnification(currentMagnification + 2);
   }
}
</PRE>
<A NAME=HEADING90-52></A>
<H4>The RedoIt Method</H4>
 The <CODE>RedoIt</CODE> method for the TZoomInCommand command is identical to the DoIt method--it gets the icon view from the icon document and increases the magnification value by 2. In fact, the <CODE>RedoIt</CODE> method could just call the DoIt method, as many command classes do in similar circumstances.<P>
<A NAME=HEADING90-54></A>
<H4>The UndoIt Method</H4>
 The <CODE>UndoIt</CODE> method for the TZoomInCommand command is similar to the DoIt method--it gets the icon view from the icon document and decreases the magnification value by 2:<P>
<PRE>
void TZoomInCommand::UndoIt()
{ 
   TIconView * theIconView = fIconDocument-&gt;GetIconView();
   if (theIconView != NULL)
   {
      short currentMagnification = theIconView-&gt;GetMagnification();
      theIconView-&gt;SetMagnification(currentMagnification - 2);
   }
}
</PRE>
<A NAME=HEADING90-57></A>
<H3> Override DoSetupMenus in the View Class</H3>
 The following is the DoSetupMenus method for the <CODE>TIconEditView</CODE> class:<P>
<PRE>
void TIconEditView::DoSetupMenus()
{
   // Set up inherited menus.
   Inherited::DoSetupMenus();

   // Can always zoom in.
   Enable(cZoomIn, TRUE);

   // Can zoom out if not at smallest size.
   Enable(cZoomOut, fMagnification &gt; 1);

   // Can always cut, copy, and clear, or set the color.
   Enable(cSetColor, TRUE);
   Enable(cCut, TRUE);
   Enable(cCopy, TRUE);
   Enable(cClear, TRUE);

   // Can paste if 'ICON' data is available.
   gClipboardMgr-&gt;CanPaste(kIconClipType);

}  // TIconEditView::DoSetupMenus
</PRE>
 The IconEdit application uses the icon view class to enable Zoom In because whenever the icon view is present, the user can zoom in on the icon. The DoSetupMenus method for <CODE>TIconEditView</CODE> calls <CODE>Inherited</CODE> to allow other classes in the view hierarchy to enable command items. It then calls MacApp's <CODE>Enable</CODE> routine to enable various menu items, including Zoom In. The <CODE>Enable</CODE> routine calls the Toolbox routine <CODE>EnableItem</CODE>.<P>
<DL>
<DT><B>Note</B>
<DD>A <CODE>DoSetupMenus</CODE> method doesn't normally disable any menu items, because MacApp disables all menu items before calling <CODE>DoSetupMenus</CODE>.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING90-62></A>
<H3> Override DoMenuCommand in the Document Class</H3>
 The IconEdit application handles the Zoom In menu command in the document class because the document owns the view where zooming takes place. When the DoMenuCommand method is called with the command number <CODE>cZoomIn</CODE>, it creates, initializes, and posts a TZoomInCommand object:<P>
<PRE>
void TIconDocument::DoMenuCommand (CommandNumber aCommandNumber) 
{
   switch (aCommandNumber)
   {
      // Handling for some command numbers not shown.

      case cZoomIn:
         TZoomInCommand * theZoomInCommand = new TZoomInCommand();
         theZoomInCommand-&gt;IZoomInCommand(this);
         theZoomInCommand-&gt;fUseAppleEvent = TRUE;
         this-&gt;PostCommand(theZoomInCommand);
      break;
      
      default:
         Inherited::DoMenuCommand(aCommandNumber);  
      break;  
   }
}
</PRE>
 The DoMenuCommand method sets the fUseAppleEvent field to <CODE>TRUE</CODE>, indicating that when MacApp executes the Zoom In command it should send an Apple event describing the operation. This makes the operation recordable and gives any attached script a chance to handle the command. For more information, see <A HREF=MacAppProgGuide-93.html#MARKER-9-32>"Recipe--Defining a Recordable Command Class," beginning on page 353</A>.<A NAME=MARKER-2-32></A><P>
<A NAME=HEADING90-66></A>
<H2><A NAME=MARKER-2-33></A><A NAME=MARKER-9-34></A>Recipe--Changing the Current Target Object and <BR>Performing Validation </H2>
 MacApp's target chain mechanism is described in <A HREF=MacAppProgGuide-42.html#MARKER-9-80>"Target Chain Dispatching," beginning on page 107</A>. The <I>current target object</I> is the object that gets the first chance to handle user actions such as mouse clicks and menu command choices. A typical target chain consists of the application object, an open document, the document's window, and one or more nested subviews in the window, with a view designated as the current target object. <P>
 MacApp automatically changes the target object for standard operations such as switching between application windows. This recipe describes how you can set the target object directly in your code and how you can validate view data when a target change is attempted.<P>
<A NAME=HEADING90-69></A>
<H3>Changing the Current Target Object</H3>
 To change the current target object, you call the <CODE>BecomeTarget</CODE> method of the window or view object that you want to set as the current target object.<P>
 The DemoDialogs sample application uses the <CODE>TMonthlyDialog</CODE> view class to display a window containing 12 number-entry views labeled with the months of the year. To demonstrate setting the target object, the <CODE>DoKeyEvent</CODE> method of the <CODE>TMonthlyDialog</CODE> class sets the target to the view's window whenever the Option-Tab combination is pressed. Although DemoDialogs does this merely for show, your application can use similar code to set the target view.<P>
<PRE>
void TMonthlyDialog::DoKeyEvent(TToolboxEvent* event) // Override.
{
   TWindow * theWindow = NULL;
   Boolean dummy;
   
   // If Option-Tab is pressed, make the view's window the current
   // target. This is for test purposes only.
   if ((event-&gt;fCharacter == chTab) &amp;&amp; (event-&gt;IsOptionKeyPressed()))
   {
      // Get the view's window and make it the current target.
      // The return value indicates whether the window actually
      // became the target. Since we're just testing, ignore the
      // return value.
      theWindow = this-&gt;GetWindow();
      if (theWindow != NULL)
         dummy = theWindow-&gt;BecomeTarget();
   }
   else
      Inherited::DoKeyEvent(event);
}
</PRE>
 The <CODE>BecomeTarget</CODE> method belongs to the view's <CODE>TEventHandler</CODE> ancestor. It does nothing if the view is already the current target object. If the view is <I>not</I> already the current target, <CODE>BecomeTarget</CODE> calls the <CODE>ResignTarget</CODE> method of the current target.<P>
 If the current target object is willing to resign, <CODE>ResignTarget</CODE> returns <CODE>TRUE</CODE> and <CODE>BecomeTarget</CODE> sets the event handler (in this case the view) to be the current target. If the current target is <I>not</I> willing to resign, <CODE>ResignTarget</CODE> returns <CODE>FALSE</CODE> and the view does not become the target.<P>
<A NAME=HEADING90-75></A>
<H3>Performing Validation When a Target Change Is Attempted</H3>
 The <CODE>TEventHandler::ResignTarget</CODE> method calls the <CODE>WillingToResignTarget</CODE> method. MacApp's <CODE>TDialogTEView::WillingToResignTarget</CODE> method gives a text-editing view an opportunity to validate its data and refuse to resign as target if it contains invalid data:<P>
<PRE>
long TDialogTEView::WillingToResignTarget() // Override.
{
   long result = 0;

   // Give the current edit text view a chance to validate its data.
   if (fEditText)
   {
      // Some code not shown.
      result = fEditText-&gt;GetValidationError();
   }
   return result;
}
</PRE>
 This code shows that when the target view changes from a <CODE>TDialogTEView</CODE> view to another view, a <CODE>TEditText</CODE> or <CODE>TNumberText</CODE> view within the <CODE>TDialogTEView</CODE> view gets a chance to validate its data. The <CODE>TEditText::</CODE>GetValidationError method checks for too many characters. The <CODE>TNumberText::GetValidationError</CODE> method checks for a valid numeric value. Your subclass of either of these views can provide additional checking.<A NAME=MARKER-2-35></A><P>
<A NAME=HEADING90-79></A>
<H2><A NAME=MARKER-2-36></A><A NAME=MARKER-9-37></A>Recipe--Ensuring Idle Time for an Event-Handler Object</H2>
 When a MacApp application isn't busy, it distributes idle time as described in <A HREF=MacAppProgGuide-60.html#MARKER-9-59>"MacApp's Idling Mechanism," beginning on page 134</A>. MacApp automatically gives idle time to the event-handler objects (objects based on classes that descend from the <CODE>TEventhandler</CODE> class) in the target chain.<P>
 An event-handler object performs idle operations in its <CODE>DoIdle</CODE> method. To specify how often the <CODE>DoIdle</CODE> method should be called, you set the <CODE>fIdleFreq</CODE> field. The smaller the value of <CODE>fIdleFreq</CODE>, the more frequently the <CODE>DoIdle</CODE> method is called. A value of 0 indicates that the <CODE>DoIdle</CODE> method should be called as often as possible, while the default value of LONG_MAX (231 - 1, or 2,147,483,647) essentially disables idling.<P>
 MacApp also distributes idle time to event-handler objects in the cohandler chain (a list of event-handler objects pointed to by the application object's <CODE>fHeadCohandler</CODE> field). To ensure that an event-handler object gets idle time, even if it isn't always (or ever) part of the target chain, you install the object in the cohandler chain. An event-handler object used in the cohandler chain is referred to as a <I>cohandler</I>.<P>
 To install a cohandler, you call the <CODE>TApplication::InstallCohandler</CODE> method; you use the same method to remove the cohandler when it has finished its task. You specify how often a cohandler's <CODE>DoIdle</CODE> method should be called by setting the <CODE>fIdleFreq</CODE> field, as described above.<P>
 To guarantee that an event-handler object will get idle time, you perform these steps:<P>
<OL>
<LI>Override the <CODE>DoIdle</CODE> method.
<LI>Install the object in the cohandler chain.
<LI>Set the <CODE>fIdleFreq</CODE> field to specify how often the <CODE>DoIdle</CODE> method should be called.
<LI>When the object has completed its task, remove it from the cohandler chain.<P>
</OL>
 The sample code in this recipe is for a hypothetical application.<P>
<A NAME=HEADING90-90></A>
<H3>Override the DoIdle Method</H3>
 Your cohandler class that performs a background or polling task during idle time must override the <CODE>DoIdle</CODE> method. You add the following line to the class definition:<P>
<PRE>
virtual Boolean DoIdle (IdlePhase aPhase);
</PRE>
 The <CODE>DoIdle</CODE> method is a Boolean routine. If it doesn't complete its task, it returns <CODE>FALSE</CODE>. If it does complete its task, it removes itself from the cohandler chain and returns <CODE>TRUE</CODE>. The <CODE>DoIdle</CODE> method for your cohandler class should look something like the following:<P>
<PRE>
Boolean TYourCohandler::DoIdle ( IdlePhase  aPhase )
{
   Boolean taskComplete = FALSE;

   // Your cohandler code--the code that you want executed
   // periodically--goes here.
   // If the task is completed, set taskComplete to TRUE.

   // If the cohandler has completed its task, remove it.
   if (taskComplete)
      gApplication-&gt;InstallCohandler(this, FALSE);

   return taskComplete;
}
</PRE>
<A NAME=HEADING90-95></A>
<H3>Install the Object in the Cohandler Chain</H3>
 A cohandler object can install itself in the cohandler chain with a line like the following:<P>
<PRE>
gApplication-&gt;InstallCohandler (this, TRUE);
</PRE>
<A NAME=HEADING90-98></A>
<H3>Set the fIdleFreq Field to Specify How Often DoIdle Should Be Called</H3>
 A cohandler object that needs to be called as often as possible sets its fIdleFreq field with code like the following:<P>
<PRE>
this-&gt;SetIdleFreq(0);
</PRE>
 If your cohandler's DoIdle method should be called less often, pass a larger value to SetIdleFreq.<P>
<A NAME=HEADING90-102></A>
<H3>Remove the Object From the Cohandler Chain</H3>
 You call the same application method to remove a cohandler that you call to install one, InstallCohandler. The following code, from the <CODE>DoIdle</CODE> method shown above, demonstrates how to remove a cohandler from the cohandler chain:<P>
<PRE>
// If the cohandler has completed its task, remove it.
if (taskComplete)
   gApplication-&gt;InstallCohandler(this, FALSE);
</PRE>
<A NAME=HEADING90-105></A>
<H2><A NAME=MARKER-9-38></A><A NAME=MARKER-2-39></A>Recipe--Using a Behavior Object to Implement Alphabetic Type-Ahead</H2>
 The Dialogs menu of the DemoDialogs application has a Format Dialog menu choice that displays a format dialog box. The dialog box includes a font list implemented with a <CODE>TFontListView</CODE> object. When the font list view is active, you can use alphabetic type-ahead to specify a font in the list. The <CODE>TFontListView</CODE> class provides this service by adding a <CODE>TKeySelectionBehavior</CODE> behavior object.<P>
 To use a behavior object to add alphabetic type-ahead to a view, you perform these steps:<P>
<OL>
<LI>Define a view class that descends from MacApp's <CODE>TTextListView</CODE> class.
<LI>Add a <CODE>TKeySelectionBehavior</CODE> behavior object to the view object.<P>
</OL>
 The sample code shown in this recipe is from the DemoDialogs application.<P>
 For another recipe that uses behavior objects, see <A HREF=MacAppProgGuide-138.html#MARKER-9-27>"Recipe--Using Dependencies and Behaviors to Synchronize Control Views," beginning on page 588</A>.<P>
<A NAME=HEADING90-112></A>
<H3>Define a View Class That Descends From TTextListView</H3>
 The class definition for the TFontListView class in the DemoDialogs application includes the following code:<P>
<PRE>
class TFontListView : public TTextListView
{
   MA_DECLARE_CLASS;
   
public:
   FontListPtr fFontList;// Font resource IDs.
   .
   .
   .
   // Build an array of font resource IDs whose names are
   // in alphabetical order.
   virtual void InitFontList();
   .
   .
   .
}
</PRE>
 The TFontListView class descends from MacApp's TTextListView class, a class designed to display text items in a one-dimensional list. TFontListView defines the InitFontList method to initialize the font list and put the items in the list into alphabetical order.<P>
<A NAME=HEADING90-116></A>
<H3>Add a TKeySelectionBehavior Behavior to the View Object</H3>
 Your view class adds a <CODE>TKeySelectionBehavior</CODE> behavior object in its initialization method. The TFontListView class does so with the following code, taken from the <CODE>InitFontList</CODE> method:<P>
<PRE>
TKeySelectionBehavior *behavior;
behavior = new TKeySelectionBehavior;
behavior-&gt;IKeySelectionBehavior('KYSL');
this-&gt;AddBehavior(behavior);
</PRE>
 The value passed to the IKeySelectionBehavior method, <CODE>'KYSL'</CODE>, is an arbitrary identifier for the behavior object. Once the behavior is added to the view by the call to <CODE>AddBehavior</CODE>, it works together with the view to supply alphabetic type-ahead.<A NAME=MARKER-2-40></A><A NAME=MARKER-2-41></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="MacAppProgGuide-89.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-91.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="MacAppProgGuide-3.html">&copy; Apple Computer, Inc.</A><br>25 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
