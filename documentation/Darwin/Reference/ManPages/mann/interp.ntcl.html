<html><head><title>Mac OS X
 Manual Page For interp(ntcl)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/ntcl/interp" title="Mac OS X
 Manual Page for interp(ntcl)"><a name="//apple_ref/doc/man/n/interp" title="Mac OS X
 Manual Page for interp(ntcl)"><!-- headerDoc=man; indexgroup=Section ntcl; uid="//apple_ref/doc/man/ntcl/interp"; name=interp(ntcl) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
interp(n)                                   Tcl Built-In Commands                                  interp(n)



____________________________________________________________________________________________________________

<b>NAME</b>
       interp - Create and manipulate Tcl interpreters

<b>SYNOPSIS</b>
       <b>interp</b> <u>option</u> ?<u>arg</u> <u>arg</u> <u>...</u>?
____________________________________________________________________________________________________________


<b>DESCRIPTION</b>
       This command makes it possible to create one or more new Tcl interpreters that co-exist with the cre-<font color="#ffffff" class="whiteout">ating&nbsp;creating</font>
       ating interpreter in the same application.  The creating interpreter is called the <u>master</u> and the new
       interpreter  is  called a <u>slave</u>.  A master can create any number of slaves, and each slave can itself
       create additional slaves for which it is master, resulting in a hierarchy of interpreters.

       Each interpreter is independent from the others: it has its own name space for commands,  procedures,
       and  global  variables.   A  master  interpreter may create connections between its slaves and itself
       using a mechanism called an <u>alias</u>.  An <u>alias</u> is a command in a slave interpreter which, when invoked,
       causes  a  command to be invoked in its master interpreter or in another slave interpreter.  The only
       other connections between interpreters are through environment variables (the  <b>env</b>  variable),  which
       are  normally  shared  among  all interpreters in the application. Note that the name space for files
       (such as the names returned by the <b>open</b> command) is no longer shared between  interpreters.  Explicit
       commands are provided to share files and to transfer references to open files from one interpreter to
       another.

       The <b>interp</b> command also provides support for <u>safe</u> interpreters.  A safe interpreter is a slave  whose
       functions  have been greatly restricted, so that it is safe to execute untrusted scripts without fear
       of them damaging other interpreters or the application's environment. For  example,  all  IO  channel
       creation  commands  and subprocess creation commands are made inaccessible to safe interpreters.  See |
       SAFE INTERPRETERS below for more information on what features are present in a safe interpreter.  The |
       dangerous functionality is not removed from the safe interpreter; instead, it is <u>hidden</u>, so that only |
       trusted interpreters can obtain access to it. For a detailed explanation of hidden commands, see HID- |
       DEN  COMMANDS,  below.   The  alias mechanism can be used for protected communication (analogous to a |
       kernel call) between a slave interpreter and its  master.  See  ALIAS  INVOCATION,  below,  for  more |
       details on how the alias mechanism works.

       A qualified interpreter name is a proper Tcl lists containing a subset of its ancestors in the inter-<font color="#ffffff" class="whiteout">preter&nbsp;interpreter</font>
       preter hierarchy, terminated by the string naming the interpreter in  its  immediate  master.  Inter-<font color="#ffffff" class="whiteout">preter&nbsp;Interpreter</font>
       preter  names are relative to the interpreter in which they are used. For example, if <b>a</b> is a slave of
       the current interpreter and it has a slave <b>a1</b>, which in turn has a slave <b>a11</b>, the qualified  name  of
       <b>a11</b> in <b>a</b> is the list <b>a1</b> <b>a11</b>.

       The  <b>interp</b>  command,  described  below, accepts qualified interpreter names as arguments; the inter-<font color="#ffffff" class="whiteout">preter&nbsp;interpreter</font>
       preter in which the command is being evaluated can always be referred to as <b>{}</b>  (the  empty  list  or
       string).  Note  that  it is impossible to refer to a master (ancestor) interpreter by name in a slave
       interpreter except through aliases. Also, there is no global name by which one can refer to the first
       interpreter created in an application.  Both restrictions are motivated by safety concerns.


<b>THE</b> <b>INTERP</b> <b>COMMAND</b>                                                                                           |
       The  <b>interp</b>  command  is  used  to create, delete, and manipulate slave interpreters, and to share or
       transfer channels between interpreters.  It can have any of several forms, depending  on  the  <u>option</u>
       argument:

       <b>interp</b> <b>alias</b> <u>srcPath</u> <u>srcCmd</u>
              Returns  a  Tcl list whose elements are the <u>targetCmd</u> and <u>arg</u>s associated with the alias named
              <u>srcCmd</u> (all of these are the values specified when the alias was created; it is possible  that
              the actual source command in the slave is different from <u>srcCmd</u> if it was renamed).

       <b>interp</b> <b>alias</b> <u>srcPath</u> <u>srcCmd</u> <b>{}</b>
              Deletes the alias for <u>srcCmd</u> in the slave interpreter identified by <u>srcPath</u>.  <u>srcCmd</u> refers to
              the name under which the alias was created;  if the  source  command  has  been  renamed,  the
              renamed command will be deleted.

       <b>interp</b> <b>alias</b> <u>srcPath</u> <u>srcCmd</u> <u>targetPath</u> <u>targetCmd</u> ?<u>arg</u> <u>arg</u> <u>...</u>?
              This command creates an alias between one slave and another (see the <b>alias</b> slave command below
              for creating aliases between a slave and its master).  In this command, either  of  the  slave
              interpreters  may  be anywhere in the hierarchy of interpreters under the interpreter invoking
              the command.  <u>SrcPath</u> and <u>srcCmd</u> identify the source of the alias.   <u>SrcPath</u>  is  a  Tcl  list
              whose  elements  select  a  particular interpreter.  For example, ``<b>a</b> <b>b</b>'' identifies an inter-<font color="#ffffff" class="whiteout">preter&nbsp;interpreter</font>
              preter <b>b</b>, which is a slave of interpreter <b>a</b>, which is a slave of the invoking interpreter.  An
              empty  list  specifies  the  interpreter invoking the command.  <u>srcCmd</u> gives the name of a new
              command, which will be created in the source interpreter.  <u>TargetPath</u> and <u>targetCmd</u> specify  a
              target interpreter and command, and the <u>arg</u> arguments, if any, specify additional arguments to
              <u>targetCmd</u> which are prepended to any arguments specified in the invocation  of  <u>srcCmd</u>.   <u>Tar</u>-<font color="#ffffff" class="whiteout">getCmd&nbsp;TargetCmd</font>
              <u>getCmd</u>  may  be undefined at the time of this call, or it may already exist; it is not created
              by this command.  The alias arranges for the given target command to be invoked in the  target
              interpreter whenever the given source command is invoked in the source interpreter.  See ALIAS
              INVOCATION below for more details.

       <b>interp</b> <b>aliases</b> ?<u>path</u>?
              This command returns a Tcl list of the names of all the source commands for aliases defined in
              the interpreter identified by <u>path</u>.

       <b>interp</b> <b>create</b> ?<b>-safe</b>? ?<b>--</b>? ?<u>path</u>?
              Creates  a slave interpreter identified by <u>path</u> and a new command, called a <u>slave</u> <u>command</u>. The
              name of the slave command is the last component of <u>path</u>. The new  slave  interpreter  and  the
              slave  command  are created in the interpreter identified by the path obtained by removing the
              last component from <u>path</u>. For example, if <u>path</u> <u>is</u> <b>a</b> <b>b</b> <b>c</b> then a new slave interpreter and slave
              command  named <b>c</b> are created in the interpreter identified by the path <b>a</b> <b>b</b>.  The slave command
              may be used to manipulate the new interpreter as described below. If <u>path</u> is omitted, Tcl cre-<font color="#ffffff" class="whiteout">ates&nbsp;creates</font>
              ates a unique name of the form <b>interp</b><u>x</u>, where <u>x</u> is an integer, and uses it for the interpreter
              and the slave command. If the <b>-safe</b> switch is specified (or if the  master  interpreter  is  a
              safe  interpreter),  the new slave interpreter will be created as a safe interpreter with lim-<font color="#ffffff" class="whiteout">ited&nbsp;limited</font>
              ited functionality; otherwise the slave will include the full set of Tcl built-in commands and
              variables. The <b>--</b> switch can be used to mark the end of switches;  it may be needed if <u>path</u> is
              an unusual value such as <b>-safe</b>. The result of the command is the name of the new  interpreter.
              The  name of a slave interpreter must be unique among all the slaves for its master;  an error
              occurs if a slave interpreter by the given name already exists in this  master.   The  initial
              recursion  limit  of the slave interpreter is set to the current recursion limit of its parent
              interpreter.

       <b>interp</b> <b>delete</b> ?<u>path</u> <u>...?</u>
              Deletes zero or more interpreters given by the optional <u>path</u> arguments, and  for  each  inter-<font color="#ffffff" class="whiteout">preter,&nbsp;interpreter,</font>
              preter, it also deletes its slaves. The command also deletes the slave command for each inter-<font color="#ffffff" class="whiteout">preter&nbsp;interpreter</font>
              preter deleted.  For each <u>path</u> argument, if no interpreter by that name  exists,  the  command
              raises an error.

       <b>interp</b> <b>eval</b> <u>path</u> <u>arg</u> ?<u>arg</u> <u>...</u>?
              This  command concatenates all of the <u>arg</u> arguments in the same fashion as the <b>concat</b> command,
              then evaluates the resulting string as a Tcl script in the  slave  interpreter  identified  by
              <u>path</u>.  The  result  of  this evaluation (including error information such as the <b>errorInfo</b> and
              <b>errorCode</b> variables, if an error occurs) is returned to the invoking interpreter.

       <b>interp</b> <b>exists</b> <u>path</u>
              Returns  <b>1</b> if a slave interpreter by the specified <u>path</u> exists in this master, <b>0</b> otherwise. If
              <u>path</u> is omitted, the invoking interpreter is used.

       <b>interp</b> <b>expose</b> <u>path</u> <u>hiddenName</u> ?<u>exposedCmd-</u>                                                            |
       <u>Name</u>?                                                        |                                        |
              Makes the hidden command <u>hiddenName</u> exposed, eventually bringing it back under a new  <u>exposed-</u> |
              <u>CmdName</u>  name  (this  name  is currently accepted only if it is a valid global name space name |
              without any ::), in the interpreter denoted by <u>path</u>.  If an exposed command with the  targeted |
              name already exists, this command fails.  Hidden commands are explained in more detail in HID- |
              DEN COMMANDS, below.                                                                           |

       <b>interp</b> <b>hide</b> <u>path</u> <u>exposedCmdName</u> ?<u>hiddenCmd-</u>                                                           |
       <u>Name</u>?                                                       |                                         |
              Makes  the exposed command <u>exposedCmdName</u> hidden, renaming it to the hidden command <u>hiddenCmd-</u> |
              <u>Name</u>, or keeping the same name if <u>hiddenCmdName</u> is not given, in the  interpreter  denoted  by |
              <u>path</u>.   If  a  hidden command with the targeted name already exists, this command fails.  Cur- |
              rently both <u>exposedCmdName</u> and <u>hiddenCmdName</u> can not contain namespace qualifiers, or an error |
              is raised.  Commands to be hidden by <b>interp</b> <b>hide</b> are looked up in the global namespace even if |
              the current namespace is not the global one. This prevents slaves from fooling a master inter- |
              preter  into  hiding  the wrong command, by making the current namespace be different from the |
              global one.  Hidden commands are explained in more detail in HIDDEN COMMANDS, below.           |

       <b>interp</b> <b>hidden</b>                                                                                         |
       <u>path</u>                                                                                    |             |
              Returns a list of the names of all hidden commands in the interpreter identified by <u>path</u>.      |

       <b>interp</b> <b>invokehidden</b> <u>path</u> ?<b>-global</b>? <u>hiddenCmdName</u> ?<u>arg</u>                                                 |
       <u>...</u>?                                            |                                                     |
              Invokes the hidden command <u>hiddenCmdName</u>  with  the  arguments  supplied  in  the  interpreter |
              denoted  by <u>path</u>. No substitutions or evaluation are applied to the arguments.  If the <b>-global</b> |
              flag is present, the hidden command is invoked at the global level in the target  interpreter; |
              otherwise  it  is invoked at the current call frame and can access local variables in that and |
              outer call frames.  Hidden commands are explained in more detail in HIDDEN COMMANDS, below.

       <b>interp</b> <b>issafe</b> ?<u>path</u>?
              Returns <b>1</b> if the interpreter identified by the specified <u>path</u> is safe, <b>0</b> otherwise.

       <b>interp</b> <b>marktrusted</b>                                                                                    |
       <u>path</u>                                                                               |                  |
              Marks the interpreter identified by <u>path</u> as trusted. Does not expose the hidden commands. This |
              command can only be invoked from a trusted interpreter.  The command  has  no  effect  if  the |
              interpreter identified by <u>path</u> is already trusted.

       <b>interp</b> <b>recursionlimit</b> <u>path</u> ?<u>newlimit</u>?
              Returns  the  maximum  allowable  nesting  depth  for  the  interpreter specified by <u>path</u>.  If
              <u>newlimit</u> is specified, the interpreter recursion limit will be set so  that  nesting  of  more
              than  <u>newlimit</u>  calls  to <b>Tcl_Eval()</b> and related procedures in that interpreter will return an
              error.  The <u>newlimit</u> value is also returned.  The <u>newlimit</u> value must be  a  positive  integer
              between 1 and the maximum value of a non-long integer on the platform.

              The  command  sets  the  maximum  size of the Tcl call stack only. It cannot by itself prevent
              stack overflows on the C stack being used by the application. If your machine has a  limit  on
              the size of the C stack, you may get stack overflows before reaching the limit set by the com-<font color="#ffffff" class="whiteout">mand.&nbsp;command.</font>
              mand. If this happens, see if there is a mechanism in your system for increasing  the  maximum
              size of the C stack.

       <b>interp</b> <b>share</b> <u>srcPath</u> <u>channelId</u> <u>destPath</u>
              Causes the IO channel identified by <u>channelId</u> to become shared between the interpreter identi-<font color="#ffffff" class="whiteout">fied&nbsp;identified</font>
              fied by <u>srcPath</u> and the interpreter identified by <u>destPath</u>. Both interpreters  have  the  same
              permissions  on  the  IO  channel.  Both interpreters must close it to close the underlying IO
              channel; IO channels accessible in an interpreter are automatically closed when an interpreter
              is destroyed.

       <b>interp</b> <b>slaves</b> ?<u>path</u>?
              Returns  a Tcl list of the names of all the slave interpreters associated with the interpreter
              identified by <u>path</u>. If <u>path</u> is omitted, the invoking interpreter is used.

       <b>interp</b> <b>target</b> <u>path</u> <u>alias</u>
              Returns a Tcl list describing the target interpreter for an alias. The alias is specified with
              an  interpreter  path  and source command name, just as in <b>interp</b> <b>alias</b> above. The name of the
              target interpreter is returned as an interpreter path, relative to the  invoking  interpreter.
              If  the  target  interpreter  for  the alias is the invoking interpreter then an empty list is
              returned. If the target interpreter for the alias is not the invoking interpreter  or  one  of
              its descendants then an error is generated.  The target command does not have to be defined at
              the time of this invocation.

       <b>interp</b> <b>transfer</b> <u>srcPath</u> <u>channelId</u> <u>destPath</u>
              Causes the IO channel identified by <u>channelId</u> to become available in the  interpreter  identi-<font color="#ffffff" class="whiteout">fied&nbsp;identified</font>
              fied by <u>destPath</u> and unavailable in the interpreter identified by <u>srcPath</u>.


<b>SLAVE</b> <b>COMMAND</b>
       For  each slave interpreter created with the <b>interp</b> command, a new Tcl command is created in the mas-<font color="#ffffff" class="whiteout">ter&nbsp;master</font>
       ter interpreter with the same name as the new interpreter. This command may be used to invoke various
       operations on the interpreter.  It has the following general form:
              <u>slave</u> <u>command</u> ?<u>arg</u> <u>arg</u> <u>...</u>?
       <u>Slave</u>  is  the  name of the interpreter, and <u>command</u> and the <u>arg</u>s determine the exact behavior of the
       command.  The valid forms of this command are:

       <u>slave</u> <b>aliases</b>
              Returns a Tcl list whose elements are the names of  all  the  aliases  in  <u>slave</u>.   The  names
              returned  are  the <u>srcCmd</u> values used when the aliases were created (which may not be the same
              as the current names of the commands, if they have been renamed).

       <u>slave</u> <b>alias</b> <u>srcCmd</u>
              Returns a Tcl list whose elements are the <u>targetCmd</u> and <u>arg</u>s associated with the  alias  named
              <u>srcCmd</u>  (all of these are the values specified when the alias was created; it is possible that
              the actual source command in the slave is different from <u>srcCmd</u> if it was renamed).

       <u>slave</u> <b>alias</b> <u>srcCmd</u> <b>{}</b>
              Deletes the alias for <u>srcCmd</u> in the slave interpreter.  <u>srcCmd</u> refers to the name under  which
              the  alias  was  created;  if the source command has been renamed, the renamed command will be
              deleted.

       <u>slave</u> <b>alias</b> <u>srcCmd</u> <u>targetCmd</u> ?<u>arg</u> <u>..</u>?
              Creates an alias such that whenever <u>srcCmd</u> is invoked in <u>slave</u>, <u>targetCmd</u> is  invoked  in  the
              master.   The  <u>arg</u>  arguments  will  be passed to <u>targetCmd</u> as additional arguments, prepended
              before any arguments passed in the invocation of  <u>srcCmd</u>.   See  ALIAS  INVOCATION  below  for
              details.

       <u>slave</u> <b>eval</b> <u>arg</u> ?<u>arg</u> <u>..</u>?
              This  command concatenates all of the <u>arg</u> arguments in the same fashion as the <b>concat</b> command,
              then evaluates the resulting string as a Tcl script in <u>slave</u>.  The result of  this  evaluation
              (including  error  information  such  as  the  <b>errorInfo</b>  and <b>errorCode</b> variables, if an error
              occurs) is returned to the invoking interpreter.

       <u>slave</u> <b>expose</b> <u>hiddenName</u> ?<u>exposedCmd-</u>                                                                  |
       <u>Name</u>?                                                              |                                  |
              This  command  exposes  the hidden command <u>hiddenName</u>, eventually bringing it back under a new |
              <u>exposedCmdName</u> name (this name is currently accepted only if it is a valid global  name  space |
              name  without any ::), in <u>slave</u>.  If an exposed command with the targeted name already exists, |
              this command fails.  For more details on hidden commands, see HIDDEN COMMANDS, below.          |

       <u>slave</u> <b>hide</b> <u>exposedCmdName</u> ?<u>hiddenCmd-</u>                                                                 |
       <u>Name</u>?                                                             |                                   |
              This  command hides the exposed command <u>exposedCmdName</u>, renaming it to the hidden command <u>hid-</u> |
              <u>denCmdName</u>, or keeping the same name if the the argument is not given,  in  the  <u>slave</u>  inter- |
              preter.   If a hidden command with the targeted name already exists, this command fails.  Cur- |
              rently both <u>exposedCmdName</u> and <u>hiddenCmdName</u> can not contain namespace qualifiers, or an error |
              is  raised.   Commands  to be hidden are looked up in the global namespace even if the current |
              namespace is not the global one. This prevents slaves from fooling a master  interpreter  into |
              hiding  the  wrong  command, by making the current namespace be different from the global one. |
              For more details on hidden commands, see HIDDEN COMMANDS, below.                               |

       <u>slave</u> <b>hid-</b>                                                                                            |
       <b>den</b>                                                                                          |        |
              Returns a list of the names of all hidden commands in <u>slave</u>.                                   |

       <u>slave</u> <b>invokehidden</b> ?<b>-global</b> <u>hiddenName</u> ?<u>arg</u>                                                           |
       <u>..</u>?                                                       |                                           |
              This command invokes the hidden command <u>hiddenName</u> with the supplied arguments, in  <u>slave</u>.  No |
              substitutions  or evaluations are applied to the arguments.  If the <b>-global</b> flag is given, the |
              command is invoked at the global level in the slave; otherwise it is invoked  at  the  current |
              call  frame  and can access local variables in that or outer call frames.  For more details on |
              hidden commands, see HIDDEN COMMANDS, below.

       <u>slave</u> <b>issafe</b>
              Returns  <b>1</b> if the slave interpreter is safe, <b>0</b> otherwise.

       <u>slave</u> <b>mark-</b>                                                                                           |
       <b>trusted</b>                                                                                     |         |
              Marks  the  slave  interpreter  as trusted. Can only be invoked by a trusted interpreter. This |
              command does not expose any hidden commands in the  slave  interpreter.  The  command  has  no |
              effect if the slave is already trusted.

       <u>slave</u> <b>recursionlimit</b> ?<u>newlimit</u>?
              Returns  the maximum allowable nesting depth for the <u>slave</u> interpreter.  If <u>newlimit</u> is speci-<font color="#ffffff" class="whiteout">fied,&nbsp;specified,</font>
              fied, the recursion limit in <u>slave</u> will be set so that nesting of more than <u>newlimit</u> calls  to
              <b>Tcl_Eval()</b>  and  related procedures in <u>slave</u> will return an error.  The <u>newlimit</u> value is also
              returned.  The <u>newlimit</u> value must be a positive integer between 1 and the maximum value of  a
              non-long integer on the platform.

              The  command  sets  the  maximum  size of the Tcl call stack only. It cannot by itself prevent
              stack overflows on the C stack being used by the application. If your machine has a  limit  on
              the size of the C stack, you may get stack overflows before reaching the limit set by the com-<font color="#ffffff" class="whiteout">mand.&nbsp;command.</font>
              mand. If this happens, see if there is a mechanism in your system for increasing  the  maximum
              size of the C stack.

<b>SAFE</b> <b>INTERPRETERS</b>
       A  safe  interpreter  is  one  with restricted functionality, so that is safe to execute an arbitrary
       script from your worst enemy without fear of that script damaging the enclosing  application  or  the
       rest of your computing environment.  In order to make an interpreter safe, certain commands and vari-<font color="#ffffff" class="whiteout">ables&nbsp;variables</font>
       ables are removed from the interpreter.  For example, commands to create files on disk  are  removed,
       and  the  <b>exec</b> command is removed, since it could be used to cause damage through subprocesses.  Lim-<font color="#ffffff" class="whiteout">ited&nbsp;Limited</font>
       ited access to these facilities can be provided, by creating aliases to the master interpreter  which
       check  their  arguments  carefully and provide restricted access to a safe subset of facilities.  For
       example, file creation might be allowed in a particular subdirectory and subprocess invocation  might
       be allowed for a carefully selected and fixed set of programs.

       A  safe interpreter is created by specifying the <b>-safe</b> switch to the <b>interp</b> <b>create</b> command.  Further-<font color="#ffffff" class="whiteout">more,&nbsp;Furthermore,</font>
       more, any slave created by a safe interpreter will also be safe.

       A safe interpreter is created with exactly the following set of built-in commands:

              <b>after</b>       <b>append</b>      <b>array</b>       <b>binary</b>
              <b>break</b>       <b>case</b>        <b>catch</b>       <b>clock</b>
              <b>close</b>       <b>concat</b>      <b>continue</b>    <b>eof</b>
              <b>error</b>       <b>eval</b>        <b>expr</b>        <b>fblocked</b>
              <b>fcopy</b>       <b>fileevent</b>   <b>flush</b>       <b>for</b>
              <b>foreach</b>     <b>format</b>      <b>gets</b>        <b>global</b>
              <b>if</b>          <b>incr</b>        <b>info</b>        <b>interp</b>
              <b>join</b>        <b>lappend</b>     <b>lindex</b>      <b>linsert</b>
              <b>list</b>        <b>llength</b>     <b>lrange</b>      <b>lreplace</b>
              <b>lsearch</b>     <b>lsort</b>       <b>namespace</b>   <b>package</b>
              <b>pid</b>         <b>proc</b>        <b>puts</b>        <b>read</b>
              <b>regexp</b>      <b>regsub</b>      <b>rename</b>      <b>return</b>
              <b>scan</b>        <b>seek</b>        <b>set</b>         <b>split</b>
              <b>string</b>      <b>subst</b>       <b>switch</b>      <b>tell</b>
              <b>time</b>        <b>trace</b>       <b>unset</b>       <b>update</b>
              <b>uplevel</b>     <b>upvar</b>       <b>variable</b>    <b>vwait</b>
              <b>while</b>

       The following commands are hidden by <b>interp</b> <b>create</b> when it creates a safe interpreter:                |

              <b>cd</b>          <b>encoding</b>    <b>exec</b>        <b>exit</b>                                                       |
              <b>fconfigure</b> <b>file</b>         <b>glob</b>        <b>load</b>                                                       |
              <b>open</b>        <b>pwd</b>         <b>socket</b>      <b>source</b>                                                     |

       These commands can be recreated later as Tcl procedures or aliases, or re-exposed by <b>interp</b> <b>expose</b>.   |

       The following commands from Tcl's library of support procedures are not  present  in  a  safe  inter- |
       preter:                                                                                               |

              <b>auto_exec_ok</b>    <b>auto_import</b>     <b>auto_load</b>                                                      |
              <b>auto_load_index</b> <b>auto_qualify</b>    <b>unknown</b>                                                        |

       Note in particular that safe interpreters have no default <b>unknown</b> command, so Tcl's default autoload- |
       ing facilities are not available.  Autoload access to Tcl's commands that are normally autoloaded:    |

              <b>auto_mkindex</b>         <b>auto_mkindex_old</b>                                                          |
              <b>auto_reset</b>           <b>history</b>                                                                   |
              <b>parray</b>               <b>pkg_mkIndex</b>                                                               |
              <b>::pkg::create</b>        <b>::safe::interpAddToAccessPath</b>                                             |
              <b>::safe::interpCreate</b> <b>::safe::interpConfigure</b>                                                   |
              <b>::safe::interpDelete</b> <b>::safe::interpFindInAccessPath</b>                                            |
              <b>::safe::interpInit</b>   <b>::safe::setLogCmd</b>                                                         |
              <b>tcl_endOfWord</b>        <b>tcl_findLibrary</b>                                                           |
              <b>tcl_startOfNextWord</b>  <b>tcl_startOfPreviousWord</b>                                                   |
              <b>tcl_wordBreakAfter</b>   <b>tcl_wordBreakBefore</b>                                                       |

       can only be provided by explicit definition of an <b>unknown</b> command in the safe interpreter.  This will |
       involve  exposing  the  <b>source</b> command.  This is most easily accomplished by creating the safe inter- |
       preter with Tcl's <b>Safe-Tcl</b> mechanism.  <b>Safe-Tcl</b> provides safe versions of <b>source</b>, <b>load</b>, and other Tcl |
       commands needed to support autoloading of commands and the loading of packages.

       In  addition,  the  <b>env</b> variable is not present in a safe interpreter, so it cannot share environment
       variables with other interpreters. The <b>env</b> variable poses a security risk, because  users  can  store
       sensitive  information in an environment variable. For example, the PGP manual recommends storing the
       PGP private key protection password in the environment variable <u>PGPPASS</u>. Making this variable  avail-<font color="#ffffff" class="whiteout">able&nbsp;available</font>
       able to untrusted code executing in a safe interpreter would incur a security risk.

       If  extensions  are loaded into a safe interpreter, they may also restrict their own functionality to
       eliminate unsafe commands. For a discussion of management of extensions for  safety  see  the  manual
       entries for <b>Safe-Tcl</b> and the <b>load</b> Tcl command.

       A safe interpreter may not alter the recursion limit of any interpreter, including itself.


<b>ALIAS</b> <b>INVOCATION</b>
       The  alias  mechanism  has  been  carefully  designed so that it can be used safely when an untrusted
       script is executing in a safe slave and the target of the alias is a trusted master.  The most impor-<font color="#ffffff" class="whiteout">tant&nbsp;important</font>
       tant  thing  in guaranteeing safety is to ensure that information passed from the slave to the master
       is never evaluated or substituted in the master;  if this were to occur,  it  would  enable  an  evil
       script in the slave to invoke arbitrary functions in the master, which would compromise security.

       When  the  source  for  an alias is invoked in the slave interpreter, the usual Tcl substitutions are
       performed when parsing that command.  These substitutions are carried out in the  source  interpreter
       just  as  they would be for any other command invoked in that interpreter.  The command procedure for
       the source command takes its arguments and merges them with the <u>targetCmd</u> and <u>arg</u>s for the  alias  to
       create  a new array of arguments.  If the words of <u>srcCmd</u> were ``<u>srcCmd</u> <u>arg1</u> <u>arg2</u> <u>...</u> <u>argN</u>'', the new
       set of words will be ``<u>targetCmd</u> <u>arg</u> <u>arg</u> <u>...</u> <u>arg</u> <u>arg1</u> <u>arg2</u> <u>...</u> <u>argN</u>'', where <u>targetCmd</u> and  <u>arg</u>s  are
       the values supplied when the alias was created.  <u>TargetCmd</u> is then used to locate a command procedure
       in the target interpreter, and that command procedure is invoked with the new set of  arguments.   An
       error occurs if there is no command named <u>targetCmd</u> in the target interpreter.  No additional substi-<font color="#ffffff" class="whiteout">tutions&nbsp;substitutions</font>
       tutions are performed on the words:  the target command procedure is invoked directly, without  going
       through  the  normal Tcl evaluation mechanism.  Substitutions are thus performed on each word exactly
       once: <u>targetCmd</u> and <u>args</u> were substituted when parsing the command that created the alias, and <u>arg1</u> <u></u>-<font color="#ffffff" class="whiteout">argN&nbsp;arg1argN</font>
       <u>argN</u> are substituted when the alias's source command is parsed in the source interpreter.

       When writing the <u>targetCmd</u>s for aliases in safe interpreters, it is very important that the arguments
       to that command never be evaluated or substituted, since  this  would  provide  an  escape  mechanism
       whereby the slave interpreter could execute arbitrary code in the master.  This in turn would compro-<font color="#ffffff" class="whiteout">mise&nbsp;compromise</font>
       mise the security of the system.


<b>HIDDEN</b> <b>COMMANDS</b>                                                                                              |
       Safe interpreters greatly restrict the functionality available to Tcl programs executing within them. |
       Allowing  the untrusted Tcl program to have direct access to this functionality is unsafe, because it |
       can be used for a variety of attacks on the environment.  However, there are times when  there  is  a |
       legitimate  need to use the dangerous functionality in the context of the safe interpreter. For exam- |
       ple, sometimes a program must be <b>source</b>d into the interpreter.  Another example is Tk, where  windows |
       are  bound  to  the hierarchy of windows for a specific interpreter; some potentially dangerous func- |
       tions, e.g.  window management, must be performed on these windows within the interpreter context.    |

       The <b>interp</b> command provides a solution to this problem in the form of  <u>hidden</u>  <u>commands</u>.  Instead  of |
       removing  the  dangerous commands entirely from a safe interpreter, these commands are hidden so they |
       become unavailable to Tcl scripts executing in the interpreter. However, such hidden commands can  be |
       invoked  by  any  trusted  ancestor  of the safe interpreter, in the context of the safe interpreter, |
       using <b>interp</b> <b>invoke</b>. Hidden commands and exposed commands reside in separate name spaces. It is  pos- |
       sible to define a hidden command and an exposed command by the same name within one interpreter.      |

       Hidden  commands in a slave interpreter can be invoked in the body of procedures called in the master |
       during alias invocation. For example, an alias for <b>source</b> could be created in  a  slave  interpreter. |
       When it is invoked in the slave interpreter, a procedure is called in the master interpreter to check |
       that the operation is allowable (e.g. it asks to source a file that the slave interpreter is  allowed |
       to access). The procedure then it invokes the hidden <b>source</b> command in the slave interpreter to actu- |
       ally source in the contents of the file. Note that two commands  named  <b>source</b>  exist  in  the  slave |
       interpreter: the alias, and the hidden command.                                                       |

       Because  a  master  interpreter  may invoke a hidden command as part of handling an alias invocation, |
       great care must be taken to avoid evaluating any arguments passed in through  the  alias  invocation. |
       Otherwise, malicious slave interpreters could cause a trusted master interpreter to execute dangerous |
       commands on their behalf. See the section on ALIAS INVOCATION for a more complete discussion of  this |
       topic.   To  help  avoid  this  problem,  no substitutions or evaluations are applied to arguments of |
       <b>interp</b> <b>invokehidden</b>.                                                                                  |

       Safe interpreters are not allowed to invoke hidden commands in themselves or  in  their  descendants. |
       This  prevents safe slaves from gaining access to hidden functionality in themselves or their descen- |
       dants.                                                                                                |

       The set of hidden commands in an interpreter can be manipulated by a trusted interpreter using <b>interp</b> |
       <b>expose</b>  and  <b>interp</b> <b>hide</b>. The <b>interp</b> <b>expose</b> command moves a hidden command to the set of exposed com- |
       mands in the interpreter identified by <u>path</u>, potentially renaming the command in the process.  If  an |
       exposed  command  by  the  targeted  name already exists, the operation fails. Similarly, <b>interp</b> <b>hide</b> |
       moves an exposed command to the set of hidden commands in that interpreter. Safe interpreters are not |
       allowed  to  move  commands  between  the set of hidden and exposed commands, in either themselves or |
       their descendants.                                                                                    |

       Currently, the names of hidden commands cannot contain  namespace  qualifiers,  and  you  must  first |
       rename  a command in a namespace to the global namespace before you can hide it.  Commands to be hid- |
       den by <b>interp</b> <b>hide</b> are looked up in the global namespace even if the current  namespace  is  not  the |
       global  one. This prevents slaves from fooling a master interpreter into hiding the wrong command, by |
       making the current namespace be different from the global one.

<b>CREDITS</b>
       This mechanism is based on the Safe-Tcl prototype implemented by Nathaniel  Borenstein  and  Marshall
       Rose.


<b>SEE</b> <b>ALSO</b>
       <a href="load.ntcl.html#//apple_ref/doc/man/n/load">load(n)</a>, <a href="safe.ntcl.html#//apple_ref/doc/man/n/safe">safe(n)</a>, <a href="../man3/Tcl_CreateSlave.3tcl.html#//apple_ref/doc/man/3/Tcl_CreateSlave">Tcl_CreateSlave(3)</a>


<b>KEYWORDS</b>
       alias, master interpreter, safe interpreter, slave interpreter



Tcl                                                  7.6                                           interp(n)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/mann/interp.ntcl.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/mann/interp.ntcl.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/mann/interp.ntcl.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
