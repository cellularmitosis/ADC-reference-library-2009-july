<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/1998/REC-html40-19980424/loose.dtd">
<html>
<head>
<title>IOFramebuffer</title>
<meta http-equiv="Content-Type" content="text/html; charset=ascii">
<meta name="generator" content="HeaderDoc">
<style><!--
#tocMenu {
		display: block;
		position:fixed;
		top:0px;
		left:0px;
		width:210px;
		height:100%;
		background:transparent;
}
#bodyText {
		margin-left: 210px;
}
--></style>
<meta id="toc-file" name="toc-file" content="toc.html">
<script language="JavaScript" src="../../../../../../Resources/JavaScript/page.js" type="text/javascript"></script><link rel="stylesheet" type="text/css" href="../../../../../../Resources/CSS/frameset_styles.css">
<style type="text/css"><!--.keyword {background:#ffffff; color:#761550;}.template {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.function {background:#ffffff; color:#000000;}.string {background: #ffffff; color:#891315;}.preprocessor {background:#ffffff; color:#236e25}.comment {background:#ffffff; color:#236e25}.char {background: #ffffff; color:#0000ff;}.var {background:#ffffff; color:#000000;}.type {background:#ffffff; color:#761550;}.param {background:#ffffff; color:#000000;}.graybox {         border-top: 1px solid #919699;         border-left: 1px solid #919699;         margin-bottom: 10px;         }  .graybox th {         padding: 4px 8px 4px 8px;         background: #E2E2E2;         font-size: 12px;         font-weight: bold;         border-bottom: 1px solid #919699;         border-right: 1px solid #919699;         }  .graybox td {         padding: 8px;         font-size: 12px;         text-align: left;         vertical-align: top;         border-bottom: 1px solid #919699;         border-right: 1px solid #919699;         }  --></style>
</head>
<body bgcolor="#ffffff" onload="initialize_page();">
<noscript>
<div id="tocMenu">
<iframe id="toc_content" name="toc_content" src="toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
</div>
</noscript>
<div id="bodyText">
<!-- start of header -->

<!-- start of header -->
<!--#include virtual="/includes/framesetheader"-->
<!-- end of header -->

<table width="600"><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <a href="../../../../../../../reference/Darwin/index.html#//apple_ref/doc/uid/TP30001281-TP30000422" target="_top">Darwin</a> <b>&gt;</b> <a href="../../../index.html#//apple_ref/doc/framework/kernel_fw_leo" target="_top">Kernel Framework Reference</a></font>
<!-- end breadcrumb insert request -->
<p>&#160;</p>
</td></tr></table>
<!-- end of header --><a name="top"></a>
<a name="//apple_ref/doc/class/IOFramebuffer" title="IOFramebuffer"></a>
<hr>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h1><a name="IOFramebuffer">IOFramebuffer</a></h1>
</td></tr></table>
<div class="spec_sheet_info_box"><table cellspacing="0" class="specbox">
<tr>
<td scope="row"><b>Inherits from:</b></td>
<td><div style="margin-bottom:1px"><div class="content_text">
<!-- a -->IOGraphicsDevice<!-- /a -->
</div></div></td>
</tr>
<tr>
<td scope="row"><b>Declared In:</b></td>
<td><div style="margin-bottom:1px"><div class="content_text"><a href="../../index.html" target="_top">IOFramebuffer.h</a></div></div></td>
</tr>
</table></div>
<h2>Overview</h2>
<p><!-- begin abstract --></p>
<p>The base class for graphics devices to be made available as part of the desktop.
<!-- end abstract --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>The IOFramebuffer base class defines APIs used to publish a linear framebuffer device. Device driver writers should subclass this class to provide a X native driver. Mac OS X will also utilize 'ndrv' drivers via a subclass of IOFramebuffer IONDRVFramebuffer that does not require device driver writers to provide a X native driver.
</p>
<p>There are no in kernel clients of IOFramebuffer aside from rudimentary console and panic UI supported by the IOFramebuffer class. The IOFramebuffer class provides the IOUserClient implementation to allow the CoreGraphics server to provide the user accessible interface to all displays on a Mac OS X system, and this is further layered underneath application frameworks. Device driver writers should not need any knowledge of this part of the interfaces. Similarly the instance variables of IOFramebuffer are mostly used for cursor rendering which is handled by the IOFramebuffer class, and should be avoided by subclass implementors. Only IOFramebuffer methods with header documentation in this header are designed for subclasses to implement.
</p>
<p>IOFramebuffer provides simple dumb framebuffer operation - accceleration for 2D, 3D and video may be provided by a separate implementation of the IOAccelerator class.
<!-- end discussion -->
</p>
<hr>
<br><h2>Functions</h2>
<a name="HeaderDoc_functions"></a>
<dl>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/connectFlags/IOReturn/(IOIndex,IODisplayModeID,IOOptionBits*)" target="_top">connectFlags</a></tt></dt>
<dd><p>Return display sense information for legacy Apple sensing.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/convertCursorImage/bool/(void*,IOHardwareCursorDescriptor*,IOHardwareCursorInfo*)" target="_top">convertCursorImage</a></tt></dt>
<dd><p>Utility method of IOFramebuffer to convert cursor image to a hardware cursor format.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/doI2CRequest/IOReturn/(UInt32,structIOI2CBusTiming*,structIOI2CRequest*)" target="_top">doI2CRequest</a></tt></dt>
<dd><p>Carry out an I2C request.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/enableController/IOReturn/()" target="_top">enableController</a></tt></dt>
<dd><p>Perform first time setup of the framebuffer.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/flushCursor/void/()" target="_top">flushCursor</a></tt></dt>
<dd><p>Perform any needed cache flushing after software cursor rendering.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/getApertureRange/IODeviceMemory*/(IOPixelAperture)" target="_top">getApertureRange</a></tt></dt>
<dd><p>Return reference to IODeviceMemory object representing memory range of framebuffer.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/getAppleSense/IOReturn/(IOIndex,UInt32*,UInt32*,UInt32*,UInt32*)" target="_top">getAppleSense</a></tt></dt>
<dd><p>Return display sense information for legacy Apple sensing.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/getAttribute/IOReturn/(IOSelect,UInt32*)" target="_top">getAttribute</a></tt></dt>
<dd><p>Generic method to retrieve some attribute of the framebuffer device.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/getAttributeForConnection/IOReturn/(IOIndex,IOSelect,UInt32*)" target="_top">getAttributeForConnection</a></tt></dt>
<dd><p>Generic method to retrieve some attribute of the framebuffer device, specific to one display connection.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/getConnectionCount/IOItemCount/()" target="_top">getConnectionCount</a></tt></dt>
<dd><p>Reports the number of display connections the device supports, driven from one framebuffer.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/getCurrentDisplayMode/IOReturn/(IODisplayModeID*,IOIndex*)" target="_top">getCurrentDisplayMode(IODisplayModeID *, IOIndex *)</a></tt></dt>
<dd><p>Return the framebuffers current display mode and depth.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/doc/title:instm/IOFramebuffer/getCurrentDisplayMode/IOReturn/(IODisplayModeID*,IOIndex*)" target="_top">getCurrentDisplayMode(IODisplayModeID *, IOIndex *)</a></tt></dt>
<dd><p>Return the framebuffers display mode and depth to be used during boot and at startup.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/getDDCBlock/IOReturn/(IOIndex,UInt32,IOSelect,IOOptionBits,UInt8*,IOByteCount*)" target="_top">getDDCBlock</a></tt></dt>
<dd><p>Return display EDID data.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/getDisplayModeCount/IOItemCount/()" target="_top">getDisplayModeCount</a></tt></dt>
<dd><p>Return the number of display modes the framebuffer supports.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/getDisplayModes/IOReturn/(IODisplayModeID*)" target="_top">getDisplayModes</a></tt></dt>
<dd><p>Return the number of display modes the framebuffer supports.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/getInformationForDisplayMode/IOReturn/(IODisplayModeID,IODisplayModeInformation*)" target="_top">getInformationForDisplayMode</a></tt></dt>
<dd><p>Return information about a given display mode.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/getPixelFormats/constchar*/()" target="_top">getPixelFormats</a></tt></dt>
<dd><p>List the pixel formats the framebuffer supports.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/getPixelFormatsForDisplayMode/UInt64/(IODisplayModeID,IOIndex)" target="_top">getPixelFormatsForDisplayMode</a></tt></dt>
<dd><p>Obsolete.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/getPixelInformation/IOReturn/(IODisplayModeID,IOIndex,IOPixelAperture,IOPixelInformation*)" target="_top">getPixelInformation</a></tt></dt>
<dd><p>Return information about the framebuffer format for a given display mode and depth.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/getStartupDisplayMode/IOReturn/(IODisplayModeID*,IOIndex*)" target="_top">getStartupDisplayMode</a></tt></dt>
<dd><p>Return the framebuffers display mode and depth to be used during boot and at startup.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/getTimingInfoForDisplayMode/IOReturn/(IODisplayModeID,IOTimingInformation*)" target="_top">getTimingInfoForDisplayMode</a></tt></dt>
<dd><p>Returns a timing description for a display mode.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/getVRAMRange/IODeviceMemory*/()" target="_top">getVRAMRange</a></tt></dt>
<dd><p>Return reference to IODeviceMemory object representing memory range of all the cards vram.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/handleEvent/IOReturn/(IOIndex,void*)" target="_top">handleEvent</a></tt></dt>
<dd><p>Notify IOFramebuffer superclass code of events.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/hasDDCConnect/bool/(IOIndex)" target="_top">hasDDCConnect</a></tt></dt>
<dd><p>Return display DDC connect state.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/readDDCClock/bool/(IOIndex)" target="_top">readDDCClock</a></tt></dt>
<dd><p>Reads the input state of the I2C clock line on a bus.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/readDDCData/bool/(IOIndex)" target="_top">readDDCData</a></tt></dt>
<dd><p>Reads the input state of the I2C data line on a bus.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/registerForInterruptType/IOReturn/(IOSelect,IOFBInterruptProc,OSObject*,void*,void**)" target="_top">registerForInterruptType</a></tt></dt>
<dd><p>Set callbacks for driver to call on interrupt events.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/setApertureEnable/IOReturn/(IOPixelAperture,IOOptionBits)" target="_top">setApertureEnable</a></tt></dt>
<dd><p>Enable an aperture on the framebuffer (usually unimplemented, no OS usage).
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/setAttribute/IOReturn/(IOSelect,UInt32)" target="_top">setAttribute</a></tt></dt>
<dd><p>Generic method to set some attribute of the framebuffer device.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/setAttributeForConnection/IOReturn/(IOIndex,IOSelect,UInt32)" target="_top">setAttributeForConnection</a></tt></dt>
<dd><p>Generic method to set some attribute of the framebuffer device, specific to one display connection.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/setCLUTWithEntries/IOReturn/(IOColorEntry*,UInt32,UInt32,IOOptionBits)" target="_top">setCLUTWithEntries</a></tt></dt>
<dd><p>Set the color lookup table to be used by the framebuffer in indexed modes.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/doc/title:instm/IOFramebuffer/setCurrentDisplayMode/IOReturn/(IODisplayModeID,IOIndex)" target="_top">setCurrentDisplayMode</a></tt></dt>
<dd><p>Set the framebuffers current display mode and depth.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/setCursorImage/IOReturn/(void*)" target="_top">setCursorImage</a></tt></dt>
<dd><p>Set a new image for the hardware cursor.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/setCursorState/IOReturn/(SInt32,SInt32,bool)" target="_top">setCursorState</a></tt></dt>
<dd><p>Set a new position and visibility for the hardware cursor.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/setDDCClock/void/(IOIndex,UInt32)" target="_top">setDDCClock</a></tt></dt>
<dd><p>Sets the state of the I2C clock line on a bus.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/setDDCData/void/(IOIndex,UInt32)" target="_top">setDDCData</a></tt></dt>
<dd><p>Sets the state of the I2C data line on a bus.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/setDetailedTimings/IOReturn/(OSArray*)" target="_top">setDetailedTimings</a></tt></dt>
<dd><p>Installs an array of OS programmed detailed timings to be made available by the driver.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/setDisplayMode/IOReturn/(IODisplayModeID,IOIndex)" target="_top">setDisplayMode</a></tt></dt>
<dd><p>Set the framebuffers current display mode and depth.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/setGammaTable/IOReturn/(UInt32,UInt32,UInt32,void*)" target="_top">setGammaTable</a></tt></dt>
<dd><p>Set the gamma table to be used by the framebuffer.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/setInterruptState/IOReturn/(void*,UInt32)" target="_top">setInterruptState</a></tt></dt>
<dd><p>Enable or disable a callback previously installed by registerForInterruptType().
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/setStartupDisplayMode/IOReturn/(IODisplayModeID,IOIndex)" target="_top">setStartupDisplayMode</a></tt></dt>
<dd><p>Set the framebuffers display mode and depth to be used during boot and at startup.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/unregisterInterrupt/IOReturn/(void*)" target="_top">unregisterInterrupt(void *)</a></tt></dt>
<dd><p>Remove a callback previously installed by registerForInterruptType().
</p></dd>
<dt><tt><a href="index.html#//apple_ref/doc/title:instm/IOFramebuffer/unregisterInterrupt/IOReturn/(void*,UInt32)" target="_top">unregisterInterrupt(void *, UInt32)</a></tt></dt>
<dd><p>Enable or disable a callback previously installed by registerForInterruptType().
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOFramebuffer/validateDetailedTiming/IOReturn/(void*,IOByteCount)" target="_top">validateDetailedTiming</a></tt></dt>
<dd><p>Reports whether a detailed timing is able to be programmed with the device.
</p></dd>
</dl>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/connectFlags/IOReturn/(IOIndex,IODisplayModeID,IOOptionBits*);  indexgroup=Graphics ;   name=IOFramebuffer::connectFlags --><a name="//apple_ref/cpp/instm/IOFramebuffer/connectFlags/IOReturn/(IOIndex,IODisplayModeID,IOOptionBits*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="connectFlags">connectFlags</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Return display sense information for legacy Apple sensing.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">connectFlags</span><!-- /a -->(
    <!-- a --><span class="type">IOIndex</span><!-- /a --> <span class="param">connectIndex</span>, 
    <!-- a --><span class="type">IODisplayModeID</span><!-- /a --> <span class="param">displayMode</span>,
    <a href="../../../USB_h/index.html#//apple_ref/c/tag/IOOptionBits" target="_top" class="type"><span class="type">IOOptionBits</span></a> <span class="type">*</span><span class="param">flags</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>connectIndex</code></dt>
<dd><p>Index of the display connection, from zero to the value of getConnectionCount().</p></dd>
<dt><code>displayMode</code></dt>
<dd><p>A display mode ID.</p></dd>
<dt><code>flags</code></dt>
<dd><p>Return the flags value for the given mode with the connected display. Flags are:<br>
kDisplayModeValidFlag - mode is considered valid for the connected display by the driver.
kDisplayModeSafeFlag - mode is considered safe (not requiring mode change confirmation) for the connected display by the driver.
kDisplayModeDefaultFlag - mode is considered default for the connected display by the driver.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->An IOReturn code.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Hardware that supports simple display sensing, or the classic 3 pin Apple sensing described in Designing Cards and Drivers, should implement this method to return mode flags relative to the sensed display. If this method is unimplemented, all modes have are given the flags kDisplayModeValidFlag | kDisplayModeSafeFlag.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/convertCursorImage/bool/(void*,IOHardwareCursorDescriptor*,IOHardwareCursorInfo*);  indexgroup=Graphics ;   name=IOFramebuffer::convertCursorImage --><a name="//apple_ref/cpp/instm/IOFramebuffer/convertCursorImage/bool/(void*,IOHardwareCursorDescriptor*,IOHardwareCursorInfo*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="convertCursorImage">convertCursorImage</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Utility method of IOFramebuffer to convert cursor image to a hardware cursor format.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">convertCursorImage</span><!-- /a -->(
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><span class="param">cursorImage</span>, 
    <a href="../../../IOGraphicsTypes_h/index.html#//apple_ref/c/tag/IOHardwareCursorDescriptor" target="_top" class="type"><span class="type">IOHardwareCursorDescriptor</span></a> <span class="type">*</span><span class="param">description</span>, 
    <a href="../../index.html#//apple_ref/c/tag/IOHardwareCursorInfo" target="_top" class="type"><span class="type">IOHardwareCursorInfo</span></a> <span class="type">*</span><span class="param">cursor</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>cursorImage</code></dt>
<dd><p>Opaque cursor parameter from the setCursorImage() call.</p></dd>
<dt><code>description</code></dt>
<dd><p>Describes the cursor format supported by the driver.</p></dd>
<dt><code>cursor</code></dt>
<dd><p>Structure describing the drivers allocated buffer to receive the converted image.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->a bool indicating the conversion was successful.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOFramebuffer subclasses may implement hardware cursor functionality, if so they should pass the cursor image given by the  setCursorImage() method, with a description of their hardware cursor format, to this helper function to this routine to convert the image to one suitable for the hardware.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/doI2CRequest/IOReturn/(UInt32,structIOI2CBusTiming*,structIOI2CRequest*);  indexgroup=Graphics ;   name=IOFramebuffer::doI2CRequest --><a name="//apple_ref/cpp/instm/IOFramebuffer/doI2CRequest/IOReturn/(UInt32,structIOI2CBusTiming*,structIOI2CRequest*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="doI2CRequest">doI2CRequest</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Carry out an I2C request.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">doI2CRequest</span><!-- /a -->(
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">bus</span>,
    <span class="keyword">struct</span> <a href="../../../IOI2CInterface_h/index.html#//apple_ref/c/tag/IOI2CBusTiming" target="_top" class="type"><span class="type">IOI2CBusTiming</span></a> <span class="type">*</span><span class="param">timing</span>,
    <span class="keyword">struct</span> <a href="../../../IOI2CInterface_h/index.html#//apple_ref/c/tag/IOI2CRequest" target="_top" class="type"><span class="type">IOI2CRequest</span></a> <span class="type">*</span><span class="param">request</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>timing</code></dt>
<dd><p>Subclasses may pass timing parameters tuned for the specific bus, otherwise if NULL, VESA DDC defaults will apply.</p></dd>
<dt><code>request</code></dt>
<dd><p>An IOI2CRequest structure. The request should be carried out synchronously if the completion routine is NULL, otherwise it may optionally be carried out asynchronously. The completion routine should be called if supplied.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->an IOReturn code. If kIOReturnSuccces, the result of the transaction is returned in the requests result field.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOFramebuffer subclasses may optionally implement this method to perform I2C bus requests on one of the buses they support. Alternatively they may implement the setDDCClock(), setDDCData(), readDDCClock(), readDDCData() methods and respond from getAttributeForConnection() to the kConnectionSupportsLLDDCSense attribute with success, in which case IOFramebuffer::doI2CRequest() will carry out a software implementation of I2C using the low level routines and conforming to the timing constraints passed in the timing parameter. Subclasses may pass timing parameters tuned for the specific bus, otherwise VESA DDC defaults will apply.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/enableController/IOReturn/();  indexgroup=Graphics ;   name=IOFramebuffer::enableController --><a name="//apple_ref/cpp/instm/IOFramebuffer/enableController/IOReturn/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="enableController">enableController</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Perform first time setup of the framebuffer.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">enableController</span><!-- /a -->(
    <span class="param">void</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->an IOReturn code. A return other than kIOReturnSuccess will prevent the system from using the device.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOFramebuffer subclasses should perform their initialization of the hardware here. The IOService start() method is not called at a time appropriate for this initialization.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/flushCursor/void/();  indexgroup=Graphics ;   name=IOFramebuffer::flushCursor --><a name="//apple_ref/cpp/instm/IOFramebuffer/flushCursor/void/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="flushCursor">flushCursor</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Perform any needed cache flushing after software cursor rendering.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <!-- a --><span class="function">flushCursor</span><!-- /a -->(
    <span class="param">void</span> ); </pre>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOFramebuffer implements software cursor functionality when a hardware cursor is unavailable. Some hardware may need to flush a cache after the processor has finished lifting and dropping the software cursor.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/getApertureRange/IODeviceMemory*/(IOPixelAperture);  indexgroup=Graphics ;   name=IOFramebuffer::getApertureRange --><a name="//apple_ref/cpp/instm/IOFramebuffer/getApertureRange/IODeviceMemory*/(IOPixelAperture)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getApertureRange">getApertureRange</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Return reference to IODeviceMemory object representing memory range of framebuffer.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IODeviceMemory_h/Classes/IODeviceMemory/index.html#//apple_ref/cpp/cl/IODeviceMemory" target="_top" class="type"><span class="type">IODeviceMemory</span></a> <span class="type">*</span> <!-- a --><span class="function">getApertureRange</span><!-- /a -->(
    <!-- a --><span class="type">IOPixelAperture</span><!-- /a --> <span class="param">aperture</span> ) = <span class="number">0</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>aperture</code></dt>
<dd><p>The system will only access the aperture kIOFBSystemAperture.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->an IODeviceMemory instance. A reference will be consumed by the caller for each call of this method - the implementatation should create a new instance of IODeviceMemory for each call, or return one instance with a retain for each call.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOFramebuffer subclasses must implement this method to describe the memory used by the framebuffer in the current mode. The OS will map this memory range into user space for client access - the range should only include vram memory not hardware registers.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/getAppleSense/IOReturn/(IOIndex,UInt32*,UInt32*,UInt32*,UInt32*);  indexgroup=Graphics ;   name=IOFramebuffer::getAppleSense --><a name="//apple_ref/cpp/instm/IOFramebuffer/getAppleSense/IOReturn/(IOIndex,UInt32*,UInt32*,UInt32*,UInt32*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getAppleSense">getAppleSense</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Return display sense information for legacy Apple sensing.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">getAppleSense</span><!-- /a -->(
    <!-- a --><span class="type">IOIndex</span><!-- /a --> <span class="param">connectIndex</span>, 
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="type">*</span><span class="param">senseType</span>, 
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="type">*</span><span class="param">primary</span>, 
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="type">*</span><span class="param">extended</span>, 
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="type">*</span><span class="param">displayType</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>connectIndex</code></dt>
<dd><p>Index of the display connection, from zero to the value of getConnectionCount().</p></dd>
<dt><code>senseType</code></dt>
<dd><p>Return zero to indicate legacy Apple sensing.</p></dd>
<dt><code>primary</code></dt>
<dd><p>Return the value of the primary Apple sense code.</p></dd>
<dt><code>extended</code></dt>
<dd><p>Return the value of the secondary Apple sense code.</p></dd>
<dt><code>displayType</code></dt>
<dd><p>Return an Apple defined constant for the type of display sensed. For example, kVGAConnect, kNTSCConnect, kPALConnect etc.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->An IOReturn code.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Hardware that supports simple display sensing, or the classic 3 pin Apple sensing described in Designing Cards and Drivers, should implement this method to return sense information.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/getAttribute/IOReturn/(IOSelect,UInt32*);  indexgroup=Graphics ;   name=IOFramebuffer::getAttribute --><a name="//apple_ref/cpp/instm/IOFramebuffer/getAttribute/IOReturn/(IOSelect,UInt32*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getAttribute">getAttribute</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Generic method to retrieve some attribute of the framebuffer device.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">getAttribute</span><!-- /a -->(
    <!-- a --><span class="type">IOSelect</span><!-- /a --> <span class="param">attribute</span>,
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="type">*</span><span class="param">value</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>attribute</code></dt>
<dd><p>Defines the attribute to be set. Some defined attributes are:<br> 
kIOHardwareCursorAttribute If the device supports a hardware cursor and implements the setCursorImage() and setCursorState() calls it should return true for this attribute.</p></dd>
<dt><code>value</code></dt>
<dd><p>Returns the value for the attribute.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->an IOReturn code.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOFramebuffer subclasses may implement this method to allow arbitrary attribute/value pairs to be returned. 
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/getAttributeForConnection/IOReturn/(IOIndex,IOSelect,UInt32*);  indexgroup=Graphics ;   name=IOFramebuffer::getAttributeForConnection --><a name="//apple_ref/cpp/instm/IOFramebuffer/getAttributeForConnection/IOReturn/(IOIndex,IOSelect,UInt32*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getAttributeForConnection">getAttributeForConnection</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Generic method to retrieve some attribute of the framebuffer device, specific to one display connection.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">getAttributeForConnection</span><!-- /a -->(
    <!-- a --><span class="type">IOIndex</span><!-- /a --> <span class="param">connectIndex</span>, 
    <!-- a --><span class="type">IOSelect</span><!-- /a --> <span class="param">attribute</span>,
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="type">*</span><span class="param">value</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>attribute</code></dt>
<dd><p>Defines the attribute to be returned. Some defined attributes are:<br> 
kConnectionSupportsHLDDCSense If the framebuffer supports the DDC methods hasDDCConnect() and getDDCBlock() it should return success (and no value) for this attribute.<br>
kConnectionSupportsLLDDCSense If the framebuffer wishes to make use of IOFramebuffer::doI2CRequest software implementation of I2C it should implement the I2C methods setDDCClock(), setDDCData(), readDDCClock(), readDDCData(), and it should return success (and no value) for this attribute.<br></p></dd>
<dt><code>value</code></dt>
<dd><p>Returns the value for the attribute.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->an IOReturn code.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOFramebuffer subclasses may implement this method to allow arbitrary attribute/value pairs to be returned, specific to one display connection. 
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/getConnectionCount/IOItemCount/();  indexgroup=Graphics ;   name=IOFramebuffer::getConnectionCount --><a name="//apple_ref/cpp/instm/IOFramebuffer/getConnectionCount/IOItemCount/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getConnectionCount">getConnectionCount</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Reports the number of display connections the device supports, driven from one framebuffer.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">IOItemCount</span><!-- /a --> <!-- a --><span class="function">getConnectionCount</span><!-- /a -->(
    <span class="param">void</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->A count of the number of display connections reported by the framebuffer. Current versions of OS X only support one connection completely.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOFramebuffer subclasses may implement functionality where a single framebuffer drives multiple displays. This is not recommended or fully supported and instead multihead cards should implement multiple instances of IOFramebuffer objects to provide full functionality.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/getCurrentDisplayMode/IOReturn/(IODisplayModeID*,IOIndex*);  indexgroup=Graphics ;   name=IOFramebuffer::getCurrentDisplayMode --><a name="//apple_ref/cpp/instm/IOFramebuffer/getCurrentDisplayMode/IOReturn/(IODisplayModeID*,IOIndex*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getCurrentDisplayMode(IODisplayModeID*,IOIndex*)">getCurrentDisplayMode(IODisplayModeID *, IOIndex *)</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Return the framebuffers current display mode and depth.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">getCurrentDisplayMode</span><!-- /a -->(
    <!-- a --><span class="type">IODisplayModeID</span><!-- /a --> <span class="type">*</span><span class="param">displayMode</span>, 
    <!-- a --><span class="type">IOIndex</span><!-- /a --> <span class="type">*</span><span class="param">depth</span> ) = <span class="number">0</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>displayMode</code></dt>
<dd><p>A display mode ID representing the current mode.</p></dd>
<dt><code>depth</code></dt>
<dd><p>An index indicating the depth configuration of the framebuffer. The index should range from zero to the value of the maxDepthIndex field from the IODisplayModeInformation structure for the display mode.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->an IOReturn code. A return other than kIOReturnSuccess will prevent the system from using the device.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOFramebuffer subclasses must implement this method to return the current mode and depth.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=title:instm;  uid=//apple_ref/doc/title:instm/IOFramebuffer/getCurrentDisplayMode/IOReturn/(IODisplayModeID*,IOIndex*);  indexgroup=Graphics ;   name=IOFramebuffer::getCurrentDisplayMode --><a name="//apple_ref/doc/title:instm/IOFramebuffer/getCurrentDisplayMode/IOReturn/(IODisplayModeID*,IOIndex*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getCurrentDisplayMode(IODisplayModeID*,IOIndex*)">getCurrentDisplayMode(IODisplayModeID *, IOIndex *)</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Return the framebuffers display mode and depth to be used during boot and at startup.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">getStartupDisplayMode</span><!-- /a -->(
    <!-- a --><span class="type">IODisplayModeID</span><!-- /a --> <span class="type">*</span><span class="param">displayMode</span>, 
    <!-- a --><span class="type">IOIndex</span><!-- /a --> <span class="type">*</span><span class="param">depth</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>displayMode</code></dt>
<dd><p>A display mode ID representing the mode used during startup.</p></dd>
<dt><code>depth</code></dt>
<dd><p>An index indicating the depth configuration of the framebuffer used during startup. The index should range from zero to the value of the maxDepthIndex field from the IODisplayModeInformation structure for the display mode.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->an IOReturn code.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOFramebuffer subclasses should implement this method to return the current mode and depth.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/getDDCBlock/IOReturn/(IOIndex,UInt32,IOSelect,IOOptionBits,UInt8*,IOByteCount*);  indexgroup=Graphics ;   name=IOFramebuffer::getDDCBlock --><a name="//apple_ref/cpp/instm/IOFramebuffer/getDDCBlock/IOReturn/(IOIndex,UInt32,IOSelect,IOOptionBits,UInt8*,IOByteCount*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getDDCBlock">getDDCBlock</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Return display EDID data.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">getDDCBlock</span><!-- /a -->(
    <!-- a --><span class="type">IOIndex</span><!-- /a --> <span class="param">connectIndex</span>,
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">blockNumber</span>, 
    <!-- a --><span class="type">IOSelect</span><!-- /a --> <span class="param">blockType</span>,
    <a href="../../../USB_h/index.html#//apple_ref/c/tag/IOOptionBits" target="_top" class="type"><span class="type">IOOptionBits</span></a> <span class="param">options</span>, 
    <!-- a --><span class="type">UInt8</span><!-- /a --> <span class="type">*</span><span class="param">data</span>,
    <!-- a --><span class="type">IOByteCount</span><!-- /a --> <span class="type">*</span><span class="param">length</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>connectIndex</code></dt>
<dd><p>Index of the display connection, from zero to the value of getConnectionCount().</p></dd>
<dt><code>blockNumber</code></dt>
<dd><p>Block number, ranging from one to the number of blocks return by the display.</p></dd>
<dt><code>blockType</code></dt>
<dd><p>kIODDCBlockTypeEDID will be passed.</p></dd>
<dt><code>options</code></dt>
<dd><p>No options are currently defined.</p></dd>
<dt><code>data</code></dt>
<dd><p>Caller allocated buffer to receive the blocks data.</p></dd>
<dt><code>length</code></dt>
<dd><p>In/out parameter - callers allocated buffer size, driver returns actual size.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->An IOReturn code.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Hardware that supports DDC/EDID display sensing should implement this method to return EDID data in 128 byte blocks.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/getDisplayModeCount/IOItemCount/();  indexgroup=Graphics ;   name=IOFramebuffer::getDisplayModeCount --><a name="//apple_ref/cpp/instm/IOFramebuffer/getDisplayModeCount/IOItemCount/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getDisplayModeCount">getDisplayModeCount</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Return the number of display modes the framebuffer supports.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">IOItemCount</span><!-- /a --> <!-- a --><span class="function">getDisplayModeCount</span><!-- /a -->(
    <span class="param">void</span> ) = <span class="number">0</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->A count of the display modes available.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOFramebuffer subclasses must implement this method to return a count of the display modes available. This count should change unless a connection change is posted for the device indicated the framebuffer and/or display configuration has changed.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/getDisplayModes/IOReturn/(IODisplayModeID*);  indexgroup=Graphics ;   name=IOFramebuffer::getDisplayModes --><a name="//apple_ref/cpp/instm/IOFramebuffer/getDisplayModes/IOReturn/(IODisplayModeID*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getDisplayModes">getDisplayModes</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Return the number of display modes the framebuffer supports.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">getDisplayModes</span><!-- /a -->(
    <!-- a --><span class="type">IODisplayModeID</span><!-- /a --> <span class="type">*</span><span class="param">allDisplayModes</span> ) = <span class="number">0</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>allDisplayModes</code></dt>
<dd><p>A caller allocated buffer with the size given by the result of getDisplayModeCount().</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->an IOReturn code. A return other than kIOReturnSuccess will prevent the system from using the device.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOFramebuffer subclasses must implement this method to return an array of display mode IDs available for the framebuffer. The IDs are defined by the driver in the range 0x00000001 - 0x7fffffff, and should be constant for a given display mode. 
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/getInformationForDisplayMode/IOReturn/(IODisplayModeID,IODisplayModeInformation*);  indexgroup=Graphics ;   name=IOFramebuffer::getInformationForDisplayMode --><a name="//apple_ref/cpp/instm/IOFramebuffer/getInformationForDisplayMode/IOReturn/(IODisplayModeID,IODisplayModeInformation*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getInformationForDisplayMode">getInformationForDisplayMode</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Return information about a given display mode.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">getInformationForDisplayMode</span><!-- /a -->(
    <!-- a --><span class="type">IODisplayModeID</span><!-- /a --> <span class="param">displayMode</span>, 
    <a href="../../../IOGraphicsTypes_h/index.html#//apple_ref/c/tag/IODisplayModeInformation" target="_top" class="type"><span class="type">IODisplayModeInformation</span></a> <span class="type">*</span><span class="param">info</span> ) = <span class="number">0</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>displayMode</code></dt>
<dd><p>A display mode ID previously returned by getDisplayModes().</p></dd>
<dt><code>info</code></dt>
<dd><p>Pointer to a structure of type IODisplayModeInformation to be filled out by the driver. IODisplayModeInformation is documented in IOGraphicsTypes.h.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->an IOReturn code. A return other than kIOReturnSuccess will prevent the system from using the device.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOFramebuffer subclasses must implement this method to return information in the IODisplayModeInformation structure for the display mode with the passed ID. 
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/getPixelFormats/constchar*/();  indexgroup=Graphics ;   name=IOFramebuffer::getPixelFormats --><a name="//apple_ref/cpp/instm/IOFramebuffer/getPixelFormats/constchar*/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getPixelFormats">getPixelFormats</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>List the pixel formats the framebuffer supports.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <span class="keyword">const</span> <!-- a --><span class="var">char</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">getPixelFormats</span><!-- /a -->( <!-- a --><span class="var">void</span><!-- /a --> ) = <span class="number">0</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->A const char * pointer. The string consists of a concatenation of each pixel format string separated by the NULL character. The commonly supported pixel formats for Mac OS X are defined as IO8BitIndexedPixels, IO16BitDirectPixels, IO32BitDirectPixels.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOFramebuffer subclasses must implement this method to return an array of strings representing the possible pixel formats available in the framebuffer.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/getPixelFormatsForDisplayMode/UInt64/(IODisplayModeID,IOIndex);  indexgroup=Graphics ;   name=IOFramebuffer::getPixelFormatsForDisplayMode --><a name="//apple_ref/cpp/instm/IOFramebuffer/getPixelFormatsForDisplayMode/UInt64/(IODisplayModeID,IOIndex)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getPixelFormatsForDisplayMode">getPixelFormatsForDisplayMode</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Obsolete.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">UInt64</span><!-- /a --> <!-- a --><span class="function">getPixelFormatsForDisplayMode</span><!-- /a -->(
    <!-- a --><span class="type">IODisplayModeID</span><!-- /a --> <span class="param">displayMode</span>, 
    <!-- a --><span class="type">IOIndex</span><!-- /a --> <span class="param">depth</span> ) = <span class="number">0</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>displayMode</code></dt>
<dd><p>Ignored.</p></dd>
<dt><code>depth</code></dt>
<dd><p>Ignored.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Return zero.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOFramebuffer subclasses must implement this method to return zero. 
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/getPixelInformation/IOReturn/(IODisplayModeID,IOIndex,IOPixelAperture,IOPixelInformation*);  indexgroup=Graphics ;   name=IOFramebuffer::getPixelInformation --><a name="//apple_ref/cpp/instm/IOFramebuffer/getPixelInformation/IOReturn/(IODisplayModeID,IOIndex,IOPixelAperture,IOPixelInformation*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getPixelInformation">getPixelInformation</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Return information about the framebuffer format for a given display mode and depth.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">getPixelInformation</span><!-- /a -->( 
    <!-- a --><span class="type">IODisplayModeID</span><!-- /a --> <span class="param">displayMode</span>,
    <!-- a --><span class="type">IOIndex</span><!-- /a --> <span class="param">depth</span>, 
    <!-- a --><span class="type">IOPixelAperture</span><!-- /a --> <span class="param">aperture</span>,
    <a href="../../../IOGraphicsTypes_h/index.html#//apple_ref/c/tag/IOPixelInformation" target="_top" class="type"><span class="type">IOPixelInformation</span></a> <span class="type">*</span><span class="param">pixelInfo</span> ) = <span class="number">0</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>displayMode</code></dt>
<dd><p>A display mode ID previously returned by getDisplayModes().</p></dd>
<dt><code>depth</code></dt>
<dd><p>An index from zero to the value of the maxDepthIndex field from the IODisplayModeInformation structure (inclusive).</p></dd>
<dt><code>info</code></dt>
<dd><p>Pointer to a structure of type IOPixelInformation to be filled out by the driver. IOPixelInformation is documented in IOGraphicsTypes.h.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->an IOReturn code. A return other than kIOReturnSuccess will prevent the system from using the device.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOFramebuffer subclasses must implement this method to return information in the IOPixelInformation structure for the display mode with the passed ID, depth index and aperture. The aperture utilized by the system is always kIOFBSystemAperture. Drivers may define alternative apertures, being a view of the framebuffer in a different pixel format from the default.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/getStartupDisplayMode/IOReturn/(IODisplayModeID*,IOIndex*);  indexgroup=Graphics ;   name=IOFramebuffer::getStartupDisplayMode --><a name="//apple_ref/cpp/instm/IOFramebuffer/getStartupDisplayMode/IOReturn/(IODisplayModeID*,IOIndex*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getStartupDisplayMode">getStartupDisplayMode</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Return the framebuffers display mode and depth to be used during boot and at startup.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">getStartupDisplayMode</span><!-- /a -->(
    <!-- a --><span class="type">IODisplayModeID</span><!-- /a --> <span class="type">*</span><span class="param">displayMode</span>, 
    <!-- a --><span class="type">IOIndex</span><!-- /a --> <span class="type">*</span><span class="param">depth</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>displayMode</code></dt>
<dd><p>A display mode ID representing the mode used during startup.</p></dd>
<dt><code>depth</code></dt>
<dd><p>An index indicating the depth configuration of the framebuffer used during startup. The index should range from zero to the value of the maxDepthIndex field from the IODisplayModeInformation structure for the display mode.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->an IOReturn code.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOFramebuffer subclasses should implement this method to return the current mode and depth.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/getTimingInfoForDisplayMode/IOReturn/(IODisplayModeID,IOTimingInformation*);  indexgroup=Graphics ;   name=IOFramebuffer::getTimingInfoForDisplayMode --><a name="//apple_ref/cpp/instm/IOFramebuffer/getTimingInfoForDisplayMode/IOReturn/(IODisplayModeID,IOTimingInformation*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getTimingInfoForDisplayMode">getTimingInfoForDisplayMode</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Returns a timing description for a display mode.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">getTimingInfoForDisplayMode</span><!-- /a -->( 
    <!-- a --><span class="type">IODisplayModeID</span><!-- /a --> <span class="param">displayMode</span>,
    <!-- a --><span class="type">IOTimingInformation</span><!-- /a --> <span class="type">*</span><span class="param">info</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>displayMode</code></dt>
<dd><p>A display mode ID representing the mode to examine.</p></dd>
<dt><code>info</code></dt>
<dd><p>The driver returns the information for the display mode in this structure.<br>
If the mode has an Apple defined constant, such as timingVESA_1024x768_75hz, it should be returned in the appleTimingID field. Otherwise the field should be set to timingInvalid.<br>
If the driver is able to supply detailed timing information, it should return it in the detailedInfo.v2 field of the structure, otherwise the driver should clear the kIODetailedTimingValid flag from the flags field.<br>
The IODetailedTimingInformationV2 structure is documented in IOGraphicsTypes.h</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->an IOReturn code. A return other than kIOReturnSuccess will prevent the system from using the device.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOFramebuffer subclasses should implement this method to return timing information for a display mode. This allows the OS to enable display modes based on its knowledge of the connected display type. Two types of timing information are defined, by Apple defined constant, or by a detailed description of the timing parameters of the mode. 
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/getVRAMRange/IODeviceMemory*/();  indexgroup=Graphics ;   name=IOFramebuffer::getVRAMRange --><a name="//apple_ref/cpp/instm/IOFramebuffer/getVRAMRange/IODeviceMemory*/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getVRAMRange">getVRAMRange</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Return reference to IODeviceMemory object representing memory range of all the cards vram.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IODeviceMemory_h/Classes/IODeviceMemory/index.html#//apple_ref/cpp/cl/IODeviceMemory" target="_top" class="type"><span class="type">IODeviceMemory</span></a> <span class="type">*</span> <!-- a --><span class="function">getVRAMRange</span><!-- /a -->(
    <span class="param">void</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->an IODeviceMemory instance. A reference will be consumed by the caller for each call of this method - the implementatation should create a new instance of IODeviceMemory for each call, or return one instance with a retain for each call.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOFramebuffer subclasses should implement this method to describe all the vram memory available on the card. The OS will map this memory range into user space for client access - the range should only include vram memory not hardware registers.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/handleEvent/IOReturn/(IOIndex,void*);  indexgroup=Graphics ;   name=IOFramebuffer::handleEvent --><a name="//apple_ref/cpp/instm/IOFramebuffer/handleEvent/IOReturn/(IOIndex,void*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="handleEvent">handleEvent</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Notify IOFramebuffer superclass code of events.
<!-- end abstract --></p>
<p></p>
<pre><tt>protected</tt>
<br><a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">handleEvent</span><!-- /a -->(
    <!-- a --><span class="type">IOIndex</span><!-- /a --> <span class="param">event</span>,
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><!-- a --><span class="type">info</span><!-- /a --> = <span class="number">0</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>event</code></dt>
<dd><p>The event that has occurred:<br>
kIOFBNotifyWillPowerOff call before entering a state other than the maximum.<br>
kIOFBNotifyDidPowerOn call after entering the maximum power state.<br>
kIOFBNotifyWillPowerOff call before entering a state other than the maximum.<br>
kIOFBNotifyDidPowerOn call after entering a state other than the maximum.<br></p></dd>
<dt><code>info</code></dt>
<dd><p>None of the above events require additional info, pass zero.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->an IOReturn code, safely ignored.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOFramebuffer subclasses should call this IOFramebuffer method on certain power state changes.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/hasDDCConnect/bool/(IOIndex);  indexgroup=Graphics ;   name=IOFramebuffer::hasDDCConnect --><a name="//apple_ref/cpp/instm/IOFramebuffer/hasDDCConnect/bool/(IOIndex)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="hasDDCConnect">hasDDCConnect</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Return display DDC connect state.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">hasDDCConnect</span><!-- /a -->(
    <!-- a --><span class="type">IOIndex</span><!-- /a --> <span class="param">connectIndex</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>connectIndex</code></dt>
<dd><p>Index of the display connection, from zero to the value of getConnectionCount().</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->True if a DDC display is detected.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Hardware that supports DDC/EDID display sensing should implement this method to return true if a DDC display is detected. They should also return success for the connection attribute kConnectionSupportsHLDDCSense (from getAttributeForConnection()).
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/readDDCClock/bool/(IOIndex);  indexgroup=Graphics ;   name=IOFramebuffer::readDDCClock --><a name="//apple_ref/cpp/instm/IOFramebuffer/readDDCClock/bool/(IOIndex)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="readDDCClock">readDDCClock</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Reads the input state of the I2C clock line on a bus.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">readDDCClock</span><!-- /a -->(
    <!-- a --><span class="type">IOIndex</span><!-- /a --> <span class="param">bus</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>bus</code></dt>
<dd><p>Index of the bus.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->A boolean reflecting the current state of the clock line on the given bus.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Framebuffers making use of the IOFramebuffer::doI2CRequest() software implementation of I2C should implement this method to return the input state of the I2C clock line on the given bus. Otherwise may be unimplemented.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/readDDCData/bool/(IOIndex);  indexgroup=Graphics ;   name=IOFramebuffer::readDDCData --><a name="//apple_ref/cpp/instm/IOFramebuffer/readDDCData/bool/(IOIndex)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="readDDCData">readDDCData</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Reads the input state of the I2C data line on a bus.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">readDDCData</span><!-- /a -->(
    <!-- a --><span class="type">IOIndex</span><!-- /a --> <span class="param">bus</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>bus</code></dt>
<dd><p>Index of the bus.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->A boolean reflecting the current state of the data line on the given bus.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Framebuffers making use of the IOFramebuffer::doI2CRequest() software implementation of I2C should implement this method to return the input state of the I2C data line on the given bus. Otherwise may be unimplemented.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/registerForInterruptType/IOReturn/(IOSelect,IOFBInterruptProc,OSObject*,void*,void**);  indexgroup=Graphics ;   name=IOFramebuffer::registerForInterruptType --><a name="//apple_ref/cpp/instm/IOFramebuffer/registerForInterruptType/IOReturn/(IOSelect,IOFBInterruptProc,OSObject*,void*,void**)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="registerForInterruptType">registerForInterruptType</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Set callbacks for driver to call on interrupt events.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">registerForInterruptType</span><!-- /a -->(
    <!-- a --><span class="type">IOSelect</span><!-- /a --> <span class="param">interruptType</span>, 
    <!-- a --><span class="type">IOFBInterruptProc</span><!-- /a --> <span class="param">proc</span>,
    <a href="../../../OSObject_h/Classes/OSObject/index.html#//apple_ref/cpp/cl/OSObject" target="_top" class="type"><span class="type">OSObject</span></a> <span class="type">*</span><span class="param">target</span>,
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><span class="param">ref</span>, 
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><span class="type">*</span><span class="param">interruptRef</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>interruptType</code></dt>
<dd><p>One of these constants:<br>
kIOFBVBLInterruptType Specifying a vertical blanking interrupt.
kIOFBConnectInterruptType Specify the display connection should be resensed.</p></dd>
<dt><code>proc</code></dt>
<dd><p>C callback to be called by the driver when the specified event occurs.</p></dd>
<dt><code>target</code></dt>
<dd><p>Target parameter for the callback proc.</p></dd>
<dt><code>ref</code></dt>
<dd><p>Ref parameter for the callback proc.</p></dd>
<dt><code>interruptRef</code></dt>
<dd><p>The subclass should return an opaque reference to the installed interrupt handler, for use with unregisterInterrupt() and setInterruptState().</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->An IOReturn code.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>The IOFramebuffer class will call its subclasses to set callbacks to be called on interrupt events generated by hardware events. Only two are currently in use - vertical blank interrupts and connection changed interrupts.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/setApertureEnable/IOReturn/(IOPixelAperture,IOOptionBits);  indexgroup=Graphics ;   name=IOFramebuffer::setApertureEnable --><a name="//apple_ref/cpp/instm/IOFramebuffer/setApertureEnable/IOReturn/(IOPixelAperture,IOOptionBits)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="setApertureEnable">setApertureEnable</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Enable an aperture on the framebuffer (usually unimplemented, no OS usage).
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">setApertureEnable</span><!-- /a -->(
    <!-- a --><span class="type">IOPixelAperture</span><!-- /a --> <span class="param">aperture</span>, 
    <a href="../../../USB_h/index.html#//apple_ref/c/tag/IOOptionBits" target="_top" class="type"><span class="type">IOOptionBits</span></a> <span class="param">enable</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>aperture</code></dt>
<dd><p>A device specific aperture index.</p></dd>
<dt><code>enable</code></dt>
<dd><p>Device specific mask of options.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->an IOReturn code.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOFramebuffer subclasses may implement this method to set enable a non standard aperture. The system does not call this method.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/setAttribute/IOReturn/(IOSelect,UInt32);  indexgroup=Graphics ;   name=IOFramebuffer::setAttribute --><a name="//apple_ref/cpp/instm/IOFramebuffer/setAttribute/IOReturn/(IOSelect,UInt32)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="setAttribute">setAttribute</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Generic method to set some attribute of the framebuffer device.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">setAttribute</span><!-- /a -->(
    <!-- a --><span class="type">IOSelect</span><!-- /a --> <span class="param">attribute</span>,
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">value</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>attribute</code></dt>
<dd><p>Defines the attribute to be set. Some defined attributes are:<br> 
kIOPowerAttribute The IOFramebuffer class implements most power management (IOService) methods. It calls the subclass to carry out the power management state change with this attribute. When carrying out power state changes, the subclass should call IOFramebuffer::handleEvent for certain changes - set that method for more information.</p></dd>
<dt><code>value</code></dt>
<dd><p>The new value for the attribute.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->an IOReturn code.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOFramebuffer subclasses may implement this method to allow arbitrary attribute/value pairs to be set. 
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/setAttributeForConnection/IOReturn/(IOIndex,IOSelect,UInt32);  indexgroup=Graphics ;   name=IOFramebuffer::setAttributeForConnection --><a name="//apple_ref/cpp/instm/IOFramebuffer/setAttributeForConnection/IOReturn/(IOIndex,IOSelect,UInt32)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="setAttributeForConnection">setAttributeForConnection</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Generic method to set some attribute of the framebuffer device, specific to one display connection.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">setAttributeForConnection</span><!-- /a -->(
    <!-- a --><span class="type">IOIndex</span><!-- /a --> <span class="param">connectIndex</span>, 
    <!-- a --><span class="type">IOSelect</span><!-- /a --> <span class="param">attribute</span>,
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">value</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>attribute</code></dt>
<dd><p>Defines the attribute to be set. Some defined attributes are:<br> 
kIOCapturedAttribute If the device supports hotplugging displays, it should disable the generation of hot plug interrupts when the attribute kIOCapturedAttribute is set to true.</p></dd>
<dt><code>value</code></dt>
<dd><p>The new value for the attribute.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->an IOReturn code.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOFramebuffer subclasses may implement this method to allow arbitrary attribute/value pairs to be set, specific to one display connection. 
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/setCLUTWithEntries/IOReturn/(IOColorEntry*,UInt32,UInt32,IOOptionBits);  indexgroup=Graphics ;   name=IOFramebuffer::setCLUTWithEntries --><a name="//apple_ref/cpp/instm/IOFramebuffer/setCLUTWithEntries/IOReturn/(IOColorEntry*,UInt32,UInt32,IOOptionBits)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="setCLUTWithEntries">setCLUTWithEntries</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Set the color lookup table to be used by the framebuffer in indexed modes.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">setCLUTWithEntries</span><!-- /a -->(
    <a href="../../../IOGraphicsTypes_h/index.html#//apple_ref/c/tag/IOColorEntry" target="_top" class="type"><span class="type">IOColorEntry</span></a> <span class="type">*</span><span class="param">colors</span>,
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">index</span>, 
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">numEntries</span>,
    <a href="../../../USB_h/index.html#//apple_ref/c/tag/IOOptionBits" target="_top" class="type"><span class="type">IOOptionBits</span></a> <span class="param">options</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>colors</code></dt>
<dd><p>A pointer to an array of numEntries RGB color entries.</p></dd>
<dt><code>index</code></dt>
<dd><p>The index of the first entry to set.</p></dd>
<dt><code>numEntries</code></dt>
<dd><p>The number of entries in the table.</p></dd>
<dt><code>options</code></dt>
<dd><p>Options controlling the operation. <br>
kSetCLUTByValue is set if the index field of each entry should be used to set the table sparsely, otherwise consecutive entries from the index parameter should be set.<br>
kSetCLUTImmediately is set if the CLUT set should not be synchronized with the vertical blank, otherwise it should.<br>
kSetCLUTWithLuminance is set if the CLUT should be set to a gray value equivalent in luminance to the passed color entry.<br></p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->an IOReturn code.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOFramebuffer subclasses may implement this method to allow a palette to be set for indexed display modes. It will not be called on framebuffers in direct display modes.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=title:instm;  uid=//apple_ref/doc/title:instm/IOFramebuffer/setCurrentDisplayMode/IOReturn/(IODisplayModeID,IOIndex);  indexgroup=Graphics ;   name=IOFramebuffer::setCurrentDisplayMode --><a name="//apple_ref/doc/title:instm/IOFramebuffer/setCurrentDisplayMode/IOReturn/(IODisplayModeID,IOIndex)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="setCurrentDisplayMode">setCurrentDisplayMode</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Set the framebuffers current display mode and depth.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">setDisplayMode</span><!-- /a -->(
    <!-- a --><span class="type">IODisplayModeID</span><!-- /a --> <span class="param">displayMode</span>, 
    <!-- a --><span class="type">IOIndex</span><!-- /a --> <span class="param">depth</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>displayMode</code></dt>
<dd><p>A display mode ID representing the new mode.</p></dd>
<dt><code>depth</code></dt>
<dd><p>An index indicating the new depth configuration of the framebuffer. The index should range from zero to the value of the maxDepthIndex field from the IODisplayModeInformation structure for the display mode.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->an IOReturn code. A return other than kIOReturnSuccess will prevent the system from using the device.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOFramebuffer subclasses should implement this method to set the current mode and depth. Other than at enableController() time, this is the only method that should change the framebuffer format and is synchronized with clients and attached accelerators to make sure access to the device is disallowed during the change.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/setCursorImage/IOReturn/(void*);  indexgroup=Graphics ;   name=IOFramebuffer::setCursorImage --><a name="//apple_ref/cpp/instm/IOFramebuffer/setCursorImage/IOReturn/(void*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="setCursorImage">setCursorImage</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Set a new image for the hardware cursor.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">setCursorImage</span><!-- /a -->(
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><span class="param">cursorImage</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>cursorImage</code></dt>
<dd><p>Opaque cursor description. This should be passed to the convertCursorImage() method to convert to a format specific to the hardware.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->An IOReturn code.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOFramebuffer subclasses may implement hardware cursor functionality, if so they should implement this method to change the hardware cursor image. The image should be passed to the convertCursorImage() method with each type of cursor format the hardware supports until success, if all fail the hardware cursor should be hidden and kIOReturnUnsupported returned.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/setCursorState/IOReturn/(SInt32,SInt32,bool);  indexgroup=Graphics ;   name=IOFramebuffer::setCursorState --><a name="//apple_ref/cpp/instm/IOFramebuffer/setCursorState/IOReturn/(SInt32,SInt32,bool)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="setCursorState">setCursorState</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Set a new position and visibility for the hardware cursor.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">setCursorState</span><!-- /a -->(
    <!-- a --><span class="type">SInt32</span><!-- /a --> <span class="param">x</span>,
    <!-- a --><span class="type">SInt32</span><!-- /a --> <span class="param">y</span>,
    <!-- a --><span class="type">bool</span><!-- /a --> <span class="param">visible</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>x</code></dt>
<dd><p>Left coordinate of the cursor image. A signed value, will be negative if the cursor's hot spot and position place it partly offscreen.</p></dd>
<dt><code>y</code></dt>
<dd><p>Top coordinate of the cursor image. A signed value, will be negative if the cursor's hot spot and position place it partly offscreen.</p></dd>
<dt><code>visible</code></dt>
<dd><p>Visible state of the cursor.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->An IOReturn code.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOFramebuffer subclasses may implement hardware cursor functionality, if so they should implement this method to change the position and visibility of the cursor.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/setDDCClock/void/(IOIndex,UInt32);  indexgroup=Graphics ;   name=IOFramebuffer::setDDCClock --><a name="//apple_ref/cpp/instm/IOFramebuffer/setDDCClock/void/(IOIndex,UInt32)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="setDDCClock">setDDCClock</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Sets the state of the I2C clock line on a bus.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <!-- a --><span class="function">setDDCClock</span><!-- /a -->(
    <!-- a --><span class="type">IOIndex</span><!-- /a --> <span class="param">bus</span>,
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">value</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>bus</code></dt>
<dd><p>Index of the bus.</p></dd>
<dt><code>value</code></dt>
<dd><p>One of kIODDCLow, kIODDCHigh, kIODDCTristate.</p></dd>
</dl>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Framebuffers making use of the IOFramebuffer::doI2CRequest() software implementation of I2C should implement this method to set the state of the I2C clock line on the given bus. Otherwise may be unimplemented.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/setDDCData/void/(IOIndex,UInt32);  indexgroup=Graphics ;   name=IOFramebuffer::setDDCData --><a name="//apple_ref/cpp/instm/IOFramebuffer/setDDCData/void/(IOIndex,UInt32)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="setDDCData">setDDCData</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Sets the state of the I2C data line on a bus.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <!-- a --><span class="function">setDDCData</span><!-- /a -->(
    <!-- a --><span class="type">IOIndex</span><!-- /a --> <span class="param">bus</span>,
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">value</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>bus</code></dt>
<dd><p>Index of the bus.</p></dd>
<dt><code>value</code></dt>
<dd><p>One of kIODDCLow, kIODDCHigh, kIODDCTristate.</p></dd>
</dl>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Framebuffers making use of the IOFramebuffer::doI2CRequest() software implementation of I2C should implement this method to set the state of the I2C data line on the given bus. Otherwise may be unimplemented.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/setDetailedTimings/IOReturn/(OSArray*);  indexgroup=Graphics ;   name=IOFramebuffer::setDetailedTimings --><a name="//apple_ref/cpp/instm/IOFramebuffer/setDetailedTimings/IOReturn/(OSArray*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="setDetailedTimings">setDetailedTimings</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Installs an array of OS programmed detailed timings to be made available by the driver.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">setDetailedTimings</span><!-- /a -->(
    <a href="../../../OSArray_h/Classes/OSArray/index.html#//apple_ref/cpp/cl/OSArray" target="_top" class="type"><span class="type">OSArray</span></a> <span class="type">*</span><span class="param">array</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>array</code></dt>
<dd><p>An OSArray of OSData objects. Each OSData contains one IODetailedTimingInformationV2 structure. All the data described by the array should be copied or retained by this call until the next invocation of this method.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->an IOReturn code. A return other than kIOReturnSuccess will prevent the system from installing the programmable modes.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOFramebuffer subclasses may implement programmable mode functionality where the OS is able to install modes described by a detailed timing into the driver. The driver needs to add these modes to its internal mode list if it provides this functionality.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/setDisplayMode/IOReturn/(IODisplayModeID,IOIndex);  indexgroup=Graphics ;   name=IOFramebuffer::setDisplayMode --><a name="//apple_ref/cpp/instm/IOFramebuffer/setDisplayMode/IOReturn/(IODisplayModeID,IOIndex)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="setDisplayMode">setDisplayMode</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Set the framebuffers current display mode and depth.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">setDisplayMode</span><!-- /a -->(
    <!-- a --><span class="type">IODisplayModeID</span><!-- /a --> <span class="param">displayMode</span>, 
    <!-- a --><span class="type">IOIndex</span><!-- /a --> <span class="param">depth</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>displayMode</code></dt>
<dd><p>A display mode ID representing the new mode.</p></dd>
<dt><code>depth</code></dt>
<dd><p>An index indicating the new depth configuration of the framebuffer. The index should range from zero to the value of the maxDepthIndex field from the IODisplayModeInformation structure for the display mode.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->an IOReturn code. A return other than kIOReturnSuccess will prevent the system from using the device.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOFramebuffer subclasses should implement this method to set the current mode and depth. Other than at enableController() time, this is the only method that should change the framebuffer format and is synchronized with clients and attached accelerators to make sure access to the device is disallowed during the change.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/setGammaTable/IOReturn/(UInt32,UInt32,UInt32,void*);  indexgroup=Graphics ;   name=IOFramebuffer::setGammaTable --><a name="//apple_ref/cpp/instm/IOFramebuffer/setGammaTable/IOReturn/(UInt32,UInt32,UInt32,void*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="setGammaTable">setGammaTable</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Set the gamma table to be used by the framebuffer.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">setGammaTable</span><!-- /a -->(
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">channelCount</span>,
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">dataCount</span>, 
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">dataWidth</span>,
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><span class="param">data</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>channelCount</code></dt>
<dd><p>Defines the number of channels in the supplied data. OS X will pass three for separate R, G, B data, or one if the same data should apply to all channels.</p></dd>
<dt><code>dataCount</code></dt>
<dd><p>The number of data entries per channel.</p></dd>
<dt><code>dataWidth</code></dt>
<dd><p>The number of bits in each entry. 8 for Mac OS X 10.1 and earlier, 16 for later releases.</p></dd>
<dt><code>data</code></dt>
<dd><p>The packed array of correction data. Data is passed for the R (or single) channel followed by the G &amp; B channels. Each entry is one or two bytes (if dataWidth &gt; 8).</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->an IOReturn code.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOFramebuffer subclasses should implement this method to allow a gamma table to be set. 
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/setInterruptState/IOReturn/(void*,UInt32);  indexgroup=Graphics ;   name=IOFramebuffer::setInterruptState --><a name="//apple_ref/cpp/instm/IOFramebuffer/setInterruptState/IOReturn/(void*,UInt32)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="setInterruptState">setInterruptState</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Enable or disable a callback previously installed by registerForInterruptType().
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">setInterruptState</span><!-- /a -->(
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><span class="param">interruptRef</span>,
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">state</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>state</code></dt>
<dd><p>True or false to enable the callback.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->An IOReturn code.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Enable or disable a callback previously installed by registerForInterruptType().
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/setStartupDisplayMode/IOReturn/(IODisplayModeID,IOIndex);  indexgroup=Graphics ;   name=IOFramebuffer::setStartupDisplayMode --><a name="//apple_ref/cpp/instm/IOFramebuffer/setStartupDisplayMode/IOReturn/(IODisplayModeID,IOIndex)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="setStartupDisplayMode">setStartupDisplayMode</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Set the framebuffers display mode and depth to be used during boot and at startup.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">setStartupDisplayMode</span><!-- /a -->(
    <!-- a --><span class="type">IODisplayModeID</span><!-- /a --> <span class="param">displayMode</span>, 
    <!-- a --><span class="type">IOIndex</span><!-- /a --> <span class="param">depth</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>displayMode</code></dt>
<dd><p>A display mode ID representing the new startup mode.</p></dd>
<dt><code>depth</code></dt>
<dd><p>An index indicating the new startup depth configuration of the framebuffer. The index should range from zero to the value of the maxDepthIndex field from the IODisplayModeInformation structure for the display mode.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->an IOReturn code.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOFramebuffer subclasses should implement this method to set the mode and depth to be used during boot and at startup, to reduce needed mode changes during boot when the display connection type is the same. If possible this mode should also be used by the OpenFirmware driver for the card.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/unregisterInterrupt/IOReturn/(void*);  indexgroup=Graphics ;   name=IOFramebuffer::unregisterInterrupt --><a name="//apple_ref/cpp/instm/IOFramebuffer/unregisterInterrupt/IOReturn/(void*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="unregisterInterrupt(void*)">unregisterInterrupt(void *)</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Remove a callback previously installed by registerForInterruptType().
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">unregisterInterrupt</span><!-- /a -->(
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><span class="param">interruptRef</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>interruptRef</code></dt>
<dd><p>The interruptRef returned from the registerForInterruptType call that installed the interrupt.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->An IOReturn code.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Remove a callback previously installed by registerForInterruptType().
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=title:instm;  uid=//apple_ref/doc/title:instm/IOFramebuffer/unregisterInterrupt/IOReturn/(void*,UInt32);  indexgroup=Graphics ;   name=IOFramebuffer::unregisterInterrupt --><a name="//apple_ref/doc/title:instm/IOFramebuffer/unregisterInterrupt/IOReturn/(void*,UInt32)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="unregisterInterrupt(void*,UInt32)">unregisterInterrupt(void *, UInt32)</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Enable or disable a callback previously installed by registerForInterruptType().
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">setInterruptState</span><!-- /a -->(
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><span class="param">interruptRef</span>,
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">state</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>state</code></dt>
<dd><p>True or false to enable the callback.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->An IOReturn code.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Enable or disable a callback previously installed by registerForInterruptType().
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOFramebuffer/validateDetailedTiming/IOReturn/(void*,IOByteCount);  indexgroup=Graphics ;   name=IOFramebuffer::validateDetailedTiming --><a name="//apple_ref/cpp/instm/IOFramebuffer/validateDetailedTiming/IOReturn/(void*,IOByteCount)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="validateDetailedTiming">validateDetailedTiming</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Reports whether a detailed timing is able to be programmed with the device.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">validateDetailedTiming</span><!-- /a -->( 
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><span class="param">description</span>,
    <!-- a --><span class="type">IOByteCount</span><!-- /a --> <span class="param">descripSize</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>description</code></dt>
<dd><p>A pointer to a IODetailedTimingInformationV2 structure. The driver should examine this description and change any fields that it cannot implement to reflect its closest possible implementation.</p></dd>
<dt><code>descripSize</code></dt>
<dd><p>sizeof(IODetailedTimingInformationV2)</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->an IOReturn code. A return other than kIOReturnSuccess will prevent the system from installing the programmable mode.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOFramebuffer subclasses may implement programmable mode functionality where the OS is able to install modes described by a detailed timing into the driver. 
<!-- end discussion -->
</p>
<p></p>
<h2>Structs and Unions</h2>
<hr>
<!-- headerDoc=tag;  uid=//apple_ref/cpp/tag/IOFramebuffer/ExpansionData;  indexgroup=Graphics ;   name=IOFramebuffer::ExpansionData --><a name="//apple_ref/cpp/tag/IOFramebuffer/ExpansionData"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="ExpansionData">ExpansionData</a></h3>
</td></tr></table>
<hr>
<p></p>
<pre><tt>protected</tt>
<br><span class="keyword">struct</span> <a href="../../../IOFWAddressSpace_h/index.html#//apple_ref/c/tag/ExpansionData" target="_top" class="type"><span class="type">ExpansionData</span></a> {
}; </pre>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This structure will be used to expand the capablilties of this class in the future.
<!-- end discussion -->
</p>
<p></p>
<h2>Member Data</h2>
<hr>
<!-- headerDoc=data;  uid=//apple_ref/cpp/data/IOFramebuffer/reserved;  indexgroup=Graphics ;   name=IOFramebuffer::reserved --><a name="//apple_ref/cpp/data/IOFramebuffer/reserved"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="reserved">reserved</a></h3>
</td></tr></table>
<hr>
<p></p>
<pre><tt>protected</tt>
<br><a href="../../../IOFWAddressSpace_h/index.html#//apple_ref/c/tag/ExpansionData" target="_top" class="type"><span class="type">ExpansionData</span></a> <span class="type">*</span> <a href="../../../IOFWAddressSpace_h/index.html#//apple_ref/c/data/reserved" target="_top" class="var"><span class="var">reserved</span></a>; </pre>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Reserved for future use.  (Internal use only)<!-- end discussion -->
</p>
<p></p>
<p><!-- start of footer -->

<!-- start of footer --> 
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/KernelIOKitFramework/IOFramebuffer_h/Classes/IOFramebuffer/index.html%3Fid%3DTP30000816-3.4&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/KernelIOKitFramework/IOFramebuffer_h/Classes/IOFramebuffer/index.html%3Fid%3DTP30000816-3.4&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/KernelIOKitFramework/IOFramebuffer_h/Classes/IOFramebuffer/index.html%3Fid%3DTP30000816-3.4&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</p>
<p>&#160;</p>
<!--#include virtual="/footer"-->
<!-- end of footer -->


<!-- end of footer -->
Last Updated: 2008-12-19
</div>
<!-- headerDoc=cl; uid=//apple_ref/cpp/cl/IOFramebuffer; indexgroup=Graphics ; name=IOFramebuffer--><a name="//apple_ref/cpp/cl/IOFramebuffer"></a>
</body>
</html>
