<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>GLUT - /macx_win.m</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/GraphicsImaging/index.html">Graphics & Imaging</a> &gt; <a href="../../samplecode/GraphicsImaging/idxOpenGL-date.html">OpenGL</a> &gt; <A HREF="javascript:location.replace('index.html');">GLUT</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->


	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">GLUT</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/macx_win.m</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/gle/copy.h</option>
<option value="listing2.html">/gle/ex_angle.c</option>
<option value="listing3.html">/gle/ex_cut_round.c</option>
<option value="listing4.html">/gle/ex_raw.c</option>
<option value="listing5.html">/gle/extrude.c</option>
<option value="listing6.html">/gle/extrude.h</option>
<option value="listing7.html">/gle/gle_osx.h</option>
<option value="listing8.html">/gle/gutil.h</option>
<option value="listing9.html">/gle/intersect.c</option>
<option value="listing10.html">/gle/intersect.h</option>
<option value="listing11.html">/gle/port.h</option>
<option value="listing12.html">/gle/rot.h</option>
<option value="listing13.html">/gle/rot_prince.c</option>
<option value="listing14.html">/gle/rotate.c</option>
<option value="listing15.html">/gle/round_cap.c</option>
<option value="listing16.html">/gle/segment.c</option>
<option value="listing17.html">/gle/segment.h</option>
<option value="listing18.html">/gle/texgen.c</option>
<option value="listing19.html">/gle/tube.h</option>
<option value="listing20.html">/gle/tube_gc.h</option>
<option value="listing21.html">/gle/urotate.c</option>
<option value="listing22.html">/gle/view.c</option>
<option value="listing23.html">/gle/vvector.h</option>
<option value="listing24.html">/glsmap/glsmap.h</option>
<option value="listing25.html">/glsmap/glsmapint.h</option>
<option value="listing26.html">/glsmap/smap_buildsmap.c</option>
<option value="listing27.html">/glsmap/smap_context.c</option>
<option value="listing28.html">/glsmap/smap_create.c</option>
<option value="listing29.html">/glsmap/smap_destroy.c</option>
<option value="listing30.html">/glsmap/smap_drawmesh.c</option>
<option value="listing31.html">/glsmap/smap_flag.c</option>
<option value="listing32.html">/glsmap/smap_get.c</option>
<option value="listing33.html">/glsmap/smap_getfunc.c</option>
<option value="listing34.html">/glsmap/smap_gettexdim.c</option>
<option value="listing35.html">/glsmap/smap_gettexobj.c</option>
<option value="listing36.html">/glsmap/smap_getvec.c</option>
<option value="listing37.html">/glsmap/smap_makemesh.c</option>
<option value="listing38.html">/glsmap/smap_nearfar.c</option>
<option value="listing39.html">/glsmap/smap_origin.c</option>
<option value="listing40.html">/glsmap/smap_render.c</option>
<option value="listing41.html">/glsmap/smap_rvec2st.c</option>
<option value="listing42.html">/glsmap/smap_set.c</option>
<option value="listing43.html">/glsmap/smap_setfunc.c</option>
<option value="listing44.html">/glsmap/smap_setvec.c</option>
<option value="listing45.html">/glsmap/smap_texdim.c</option>
<option value="listing46.html">/glsmap/smap_texobj.c</option>
<option value="listing47.html">/glut.h</option>
<option value="listing48.html">/glut_8x13.c</option>
<option value="listing49.html">/glut_9x15.c</option>
<option value="listing50.html">/glut_bitmap.c</option>
<option value="listing51.html">/glut_bwidth.c</option>
<option value="listing52.html">/glut_cindex.c</option>
<option value="listing53.html">/glut_ext.c</option>
<option value="listing54.html">/glut_hel10.c</option>
<option value="listing55.html">/glut_hel12.c</option>
<option value="listing56.html">/glut_hel18.c</option>
<option value="listing57.html">/glut_mroman.c</option>
<option value="listing58.html">/glut_roman.c</option>
<option value="listing59.html">/glut_shapes.c</option>
<option value="listing60.html">/glut_stroke.c</option>
<option value="listing61.html">/glut_swidth.c</option>
<option value="listing62.html">/glut_teapot.c</option>
<option value="listing63.html">/glut_tr10.c</option>
<option value="listing64.html">/glut_tr24.c</option>
<option value="listing65.html">/glut_vidresize.c</option>
<option value="listing66.html">/GLUTApplication.h</option>
<option value="listing67.html">/GLUTApplication.m</option>
<option value="listing68.html">/glutbitmap.h</option>
<option value="listing69.html">/GLUTClipboardController.h</option>
<option value="listing70.html">/GLUTClipboardController.m</option>
<option value="listing71.html">/glutf90.h</option>
<option value="listing72.html">/GLUTMenu.h</option>
<option value="listing73.html">/GLUTMenu.m</option>
<option value="listing74.html">/GLUTMenuItem.h</option>
<option value="listing75.html">/GLUTMenuItem.m</option>
<option value="listing76.html">/GLUTPreferencesController.h</option>
<option value="listing77.html">/GLUTPreferencesController.m</option>
<option value="listing78.html">/glutstroke.h</option>
<option value="listing79.html">/GLUTView.h</option>
<option value="listing80.html">/GLUTView.m</option>
<option value="listing81.html">/GLUTWindow.h</option>
<option value="listing82.html">/GLUTWindow.m</option>
<option value="listing83.html">/HID_Config_Utilities.c</option>
<option value="listing84.html">/HID_Config_Utilities.h</option>
<option value="listing85.html">/HID_Error_Handler.c</option>
<option value="listing86.html">/HID_Error_Handler.h</option>
<option value="listing87.html">/HID_Name_Lookup.c</option>
<option value="listing88.html">/HID_Name_Lookup.h</option>
<option value="listing89.html">/HID_Queue_Utilities.c</option>
<option value="listing90.html">/HID_Queue_Utilities.h</option>
<option value="listing91.html">/HID_Utilities.c</option>
<option value="listing92.html">/HID_Utilities.h</option>
<option value="listing93.html">/HID_Utilities_External.h</option>
<option value="listing94.html">/HID_Utilities_Internal.h</option>
<option value="listing95.html">/libForeground.a</option>
<option value="listing96.html">/macx_cursor.m</option>
<option value="listing97.html">/macx_dials.m</option>
<option value="listing98.html">/macx_dstr.m</option>
<option value="listing99.html">/macx_event.m</option>
<option value="listing100.html">/macx_fortran.m</option>
<option value="listing101.html">/macx_gamemode.m</option>
<option value="listing102.html">/macx_get.m</option>
<option value="listing103.html">/macx_glut.h</option>
<option value="listing104.html">/macx_init.m</option>
<option value="listing105.html">/macx_input.m</option>
<option value="listing106.html">/macx_joy.m</option>
<option value="listing107.html">/macx_key.m</option>
<option value="listing108.html">/macx_menu.m</option>
<option value="listing109.html">/macx_modifier.m</option>
<option value="listing110.html">/macx_overlay.m</option>
<option value="listing111.html">/macx_space.m</option>
<option value="listing112.html">/macx_swap.m</option>
<option value="listing113.html">/macx_tablet.m</option>
<option value="listing114.html">/macx_util.m</option>
<option value="listing115.html">/macx_utilities.h</option>
<option value="listing116.html">/macx_warp.m</option>
<option value="listing117.html">/macx_win.m</option>
<option value="listing118.html">/ReadMe.txt</option></select>
				</p>
				</form>
				<p><strong><a href="glut.zip">Download Sample</a></strong> (&#147;glut.zip&#148;, 374.3K)<BR>
<strong><a href="glut.dmg">Download Sample</a></strong> (&#147;glut.dmg&#148;, 680.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">
/* Copyright (c) Dietmar Planitzer, 2002 */

/* This program is freely distributable without licensing fees 
   and is provided without guarantee or warrantee expressed or 
   implied. This program is -not- in the public domain. */

#import &lt;OpenGL/CGLTypes.h&gt;

#import &quot;macx_glut.h&quot;
#import &quot;GLUTWindow.h&quot;
#import &quot;GLUTView.h&quot;


GLUTView *        __glutCurrentView = nil;
GLUTView **        __glutViewList = NULL;
int                __glutViewListSize = 0;
GLUTWindow *    __glutFullscreenWindows = nil;
BOOL            __glutUseMacOSCoords = kUseMacOSCoords;
BOOL            __glutShouldWindowClose = NO;        /* -windowShouldClose: &amp;&amp; glutDestroyWindow */
BOOL            __glutInsideWindowShouldClose = NO;  /* -windowShouldClose: &amp;&amp; glutDestroyWindow */
BOOL            __glutUseExtendedDesktop = kUseExtendedDesktop;       /* (0, 0) is upper left */
BOOL            __glutSyncToVBL = kSyncToVBL;


GLUTView *__glutGetWindowByNum(int winnum)
{
   if(winnum &lt; 1 || winnum &gt; __glutViewListSize) {
      return nil;
   }
   return __glutViewList[winnum - 1];
}

void __glutEnableVisibilityUpdates(void)
{
   int    i;
   
   for(i = 0; i &lt; __glutViewListSize; i++) {
      GLUTView *    curView = __glutViewList[i];
      
      if(curView)
         [curView enableVisibilityUpdates];
   }
}

static int __glutGetUnusedWindowSlot(void)
{
   int    i;
   
   /* Look for allocated, unused slot. */
   for(i = 0; i &lt; __glutViewListSize; i++) {
      if(!__glutViewList[i]) {
         return i;
      }
   }
   /* Allocate a new slot. */
   __glutViewListSize++;
   __glutViewList = (GLUTView **) realloc(__glutViewList, __glutViewListSize * sizeof(GLUTView *));
   if(!__glutViewList) {
      __glutFatalError(&quot;out of memory.&quot;);
   }
   __glutViewList[__glutViewListSize - 1] = NULL;
   return __glutViewListSize - 1;
}


/* CENTRY */
int APIENTRY glutGetWindow(void)
{
   if(__glutCurrentView) {
      return [__glutCurrentView windowID];
   } else {
      return 0;
   }
}
/* ENDCENTRY */

/* A note on __glutSetWindow() and -lockFocus/-unlockFocus:
   GLUT windows are made current/uncurrent via a call to
   __glutSetWindow(). This function updates the internal
   __glutCurrentView var and makes the OpenGL context of the
   corresponding GLUTView current. It, however, does not
   change the AppKit NSView focus. The NSView focus is only
   changed as the result of a display operation which either
   the OS itself caused (window was shown, exposure events)
   or the GLUT app caused by calling glutPostWindowRedisplay().
   This is so because the NSView focus is maintained by a focus
   stack which implies that it can't support out-of-order ops.
   I.e. GLUT app creates window 1, which is made current, then
   creates window 2, which is made current. Then GLUT app
   destroys window 1, which implies that the current focus,
   currently held by window 2, would be removed via -unlockFocus.
   At this point window 2 would have lost focus, although it
   should have kept it...
*/
void __glutSetWindow(GLUTView *view)
{
    if(__glutCurrentView != view) {
    [__glutCurrentView resignCurrentGLUTView];    
        __glutCurrentView = view;
    }
   
   [__glutCurrentView makeCurrentGLUTView];
   
   MAKE_CURRENT_LAYER(__glutCurrentView);
   
   /* If debugging is enabled, we'll want to check this window
      for any OpenGL errors every iteration through the GLUT
      main loop.  To accomplish this, we post the
      GLUT_DEBUG_WORK to be done on this window. */
   if(__glutDebug) {
      GLUTWorkEvent    event;
      
      INIT_WORK_EVENT(&amp;event);
      event.workMask = GLUT_DEBUG_WORK;
      event.windowNum = [view windowID];
      __glutPostWorkEvent(&amp;event);
   }
}

/* CENTRY */
void APIENTRY glutSetWindow(int win)
{
   GLUTView *    view = __glutGetWindowByNum(win);
   
   GLUTAPI_DECLARATIONS
   GLUTAPI_BEGIN
   if(!view) {
      __glutWarning(&quot;glutSetWindow attempted on bogus window.&quot;);
      GLUTAPI_VOIDRETURN;
   }
   __glutSetWindow(view);
   GLUTAPI_END
}
/* ENDCENTRY */

void __glutDefaultDisplay(void)
{
   /* XXX Remove the warning after GLUT 3.0. */
   __glutWarning(&quot;The following is a new check for GLUT 3.0; update your code.&quot;);
   __glutFatalError(&quot;redisplay needed for window %d, but no display callback.&quot;, [__glutCurrentView windowID]);
}

void __glutDefaultReshape(int width, int height)
{
   /* Adjust the viewport of the window (and overlay if one exists). */
   MAKE_CURRENT_WINDOW(__glutCurrentView);
   glViewport(0, 0, (GLsizei) width, (GLsizei) height);
}

void __glutDefaultWMClose()
{
   /* Do nothing by default on MacOS X */
}

static NSOpenGLPixelFormat *createPixelFormatCI(unsigned int mode, BOOL gameMode)
{
   /* GLUT_INDEX not supported on MacOS X */
   return nil;
}

#if 0 /* deprecated */
static UInt32 _dspyMaskFromDevice(GDHandle hDev)
{
    UInt32     dspyMask = 0;
    if ((hDev != NULL) &amp;&amp; (*hDev != NULL)) {
        // Get all the devices represented by this GDev.
        if ((*hDev)-&gt;gdFlags &amp; (1 &lt;&lt; screenActive)) {
            Rect* pgdRect;
            CGRect cgGDRect;
            unsigned int j;
            CGDirectDisplayID dspys[32];
            CGDisplayCount nDspys;
            // get and match display rect
            pgdRect = &amp;((*hDev)-&gt;gdRect);
            cgGDRect.origin.x = pgdRect-&gt;left;
            cgGDRect.origin.y = pgdRect-&gt;top;
            cgGDRect.size.width = pgdRect-&gt;right - pgdRect-&gt;left;
            cgGDRect.size.height = pgdRect-&gt;bottom - pgdRect-&gt;top;
            CGGetDisplaysWithRect(cgGDRect, 32, dspys, &amp;nDspys);
            if (nDspys == 1) // only one display found 
                dspyMask = (UInt32)CGDisplayIDToOpenGLDisplayMask(dspys[0]); // set display mask (only single case)
            else { // more than one found for rect, likely a mirrored case
                CGDirectDisplayID activeDspys[32];
                CGDisplayCount nActiveDspys;
                UInt32 k;
                
                CGGetActiveDisplayList(32, activeDspys, &amp;nActiveDspys);
                for (j = 0; j &lt; nDspys; j++) { // for all displays found
                    for (k = 0; k &lt; nActiveDspys; k++) { // for all active displays
                        if (activeDspys[k] == dspys[j]) { // if an active display == display found
                            dspyMask |= (UInt32)CGDisplayIDToOpenGLDisplayMask(dspys[j]); // OR into display mask for each match
                            break; // found active so done
                        }
                    }
                }
            }
        }
    }
    return dspyMask;
}
#endif //#if !defined(__LP64__)

static BOOL _PFisFullscreenStereo (NSOpenGLPixelFormat *pf)
{
#ifdef MAC_OS_X_VERSION_10_5
    int stereo = 0, fullscreen = 0;
#else
    long stereo = 0, fullscreen = 0;
#endif

    [pf getValues:&amp;stereo forAttribute:NSOpenGLPFAStereo forVirtualScreen:0];
    [pf getValues:&amp;fullscreen forAttribute:NSOpenGLPFAFullScreen forVirtualScreen:0];
    
    if (stereo &amp;&amp; fullscreen)
        return true;
    
    return false;
}

unsigned int __glutGetDisplayMaskFromMainDevice(void)
{
    return CGDisplayIDToOpenGLDisplayMask(CGMainDisplayID());
}

static NSOpenGLPixelFormat *createPixelFormatRGB(unsigned int mode, BOOL gameMode)
{
   NSOpenGLPixelFormatAttribute    list[64];
   int                            n = 0;
   
  if(gameMode)  {
      list[n++] = NSOpenGLPFAScreenMask;
      list[n++] = CGDisplayIDToOpenGLDisplayMask(kCGDirectMainDisplay);
      list[n++] = NSOpenGLPFAColorSize;
      list[n++] = __glutGetCurrentDMDepth ();
      list[n++] = NSOpenGLPFAClosestPolicy; // add any time color depth is used
   }
   // needed for software renderer
   if(GLUT_WIND_HAS_ALPHA(mode)) {
      list[n++] = NSOpenGLPFAAlphaSize;
      list[n++] = 1; // Find shallowest alpha buffer.
   }
   if(GLUT_WIND_IS_DOUBLE(mode)) {
      list[n++] = NSOpenGLPFADoubleBuffer;
   }
   if(GLUT_WIND_IS_STEREO(mode)) {
        list[n++] = NSOpenGLPFAStereo;

        // stereo is no longer a fullscreen only format but game mode needs to make it a fullscreen mode
        if (gameMode)
        {
           list[n++] = NSOpenGLPFAFullScreen; // this will screw up glut so must be used carefully by apps
           list[n++] = NSOpenGLPFAScreenMask;
           list[n++] = __glutGetDisplayMaskFromMainDevice();
        }
   }
   if(GLUT_WIND_HAS_DEPTH(mode)) {
      list[n++] = NSOpenGLPFADepthSize;
      list[n++] = 1; // Find shallowest depth buffer.
   }
   if(GLUT_WIND_HAS_STENCIL(mode)) {
      list[n++] = NSOpenGLPFAStencilSize;
      list[n++] = 1; // Find shallowest stencil buffer.
   }
   if(GLUT_WIND_HAS_ACCUM(mode)) {
      list[n++] = NSOpenGLPFAAccumSize;
      list[n++] = 1; // Find shallowest accum buffer.
   }
   if(GLUT_WIND_IS_MULTISAMPLE(mode)) {
     list[n++] = kCGLPFASampleBuffers; /* NSOpenGLPFASampleBuffers */
     list[n++] = 1;
     list[n++] = kCGLPFASamples; /* NSOpenGLPFASamples */
     list[n++] = 2; // default
     list[n++] = NSOpenGLPFANoRecovery;
   }
   if(GLUT_WIND_IS_NO_RECOVERY(mode)) {
      list[n++] = NSOpenGLPFANoRecovery;
      list[n++] = 1;
   }
   list[n] = 0;
   
#ifdef __GLUT_LOG_PIXELFORMAT
   __glutDumpPixelFormatAttributes(list);
#endif
   return [[[NSOpenGLPixelFormat alloc] initWithAttributes: list] autorelease];
}

static NSOpenGLPixelFormat *createPixelFormat(unsigned int mode, BOOL gameMode)
{
   /* XXX GLUT_LUMINANCE not implemented for GLUT 3.0. */
   if(GLUT_WIND_IS_LUMINANCE(mode))
      return nil;
   
   if(GLUT_WIND_IS_RGB(mode))
      return createPixelFormatRGB(mode, gameMode);
   else
      return createPixelFormatCI(mode, gameMode);
}

NSOpenGLPixelFormat *__glutDeterminePixelFormat(unsigned int displayMode, BOOL *treatAsSingle,
                           BOOL gameMode, NSOpenGLPixelFormat *(getPixelFormat) (unsigned int, BOOL))
{
   NSOpenGLPixelFormat *    pf = nil;
   
   /* Should not be looking at display mode mask if
      __glutDisplayString is non-NULL. */
   assert(!__glutDisplayString);
   
    *treatAsSingle = GLUT_WIND_IS_SINGLE(displayMode);
   pf = getPixelFormat(displayMode, gameMode);
   if(!pf) {
      /* Fallback cases when can't get exactly what was asked
         for... */
      if(GLUT_WIND_IS_SINGLE(displayMode)) {
         /* If we can't find a single buffered visual, try looking
            for a double buffered visual.  We can treat a double
            buffered visual as a single buffer visual by changing
            the draw buffer to GL_FRONT and treating any swap
            buffers as no-ops. */
         displayMode |= GLUT_DOUBLE;
         pf = getPixelFormat(displayMode, gameMode);
         *treatAsSingle = YES;
      }
      if(!pf &amp;&amp; GLUT_WIND_IS_MULTISAMPLE(displayMode)) {
         /* If we can't seem to get multisampling (ie, not Reality
            Engine class graphics!), go without multisampling.  It
            is up to the application to query how many multisamples
            were allocated (0 equals no multisampling) if the
            application is going to use multisampling for more than
            just antialiasing. */
         displayMode &amp;= ~GLUT_MULTISAMPLE;
         pf = getPixelFormat(displayMode, gameMode);
      }
   }
   return pf;
}

NSOpenGLPixelFormat *__glutDetermineWindowPixelFormat(BOOL *treatAsSingle, BOOL gameMode)
{
   if(__glutDisplayString) {
      return __glutDeterminePixelFormatFromString(__glutDisplayString, treatAsSingle, gameMode);
   } else {
      return __glutDeterminePixelFormat(__glutDisplayMode, treatAsSingle, gameMode, createPixelFormat);
   }
}

GLUTView *__glutCreateWindow(GLUTView *parent, int x, int y, int width, int height, BOOL gameMode)
{
   NSOpenGLPixelFormat *    pixelFormat = nil;
   GLUTWindow *                win = nil;
   GLUTView *                view = nil;
   int                        winnum;
   NSRect                    rect;
   BOOL                        treatAsSingle = NO;
   
   if(__glutGameModeWindow &amp;&amp; !__glutDestoryingGameMode) {
      __glutFatalError(&quot;Cannot create windows in game mode.&quot;);
   }
   
   winnum = __glutGetUnusedWindowSlot();
   pixelFormat = __glutDetermineWindowPixelFormat(&amp;treatAsSingle, gameMode);
   if(!pixelFormat) {
      __glutFatalError(&quot;pixel format with necessary capabilities not found.&quot;);
   }
     
   if (NO == __glutUseMacOSCoords) { // if we are using normal glut coords use default behavior for negatives
     if(x &lt; 0)
         x = 50;
     if(y &lt; 0)
         y = 50;
   }
   rect = NSMakeRect(x, y, ABS(width), ABS(height));
   
   if(!parent) {
      /* Create a top-level window */
      win = [[GLUTWindow alloc]    initWithContentRect: rect
                 pixelFormat: pixelFormat
                 windowID: winnum + 1
                 gameMode: gameMode
                 fullscreenStereo: _PFisFullscreenStereo(pixelFormat)
                 treatAsSingle: treatAsSingle];      
      if(!win) {
         __glutFatalError(&quot;out of memory.&quot;);
      }
      view = [win contentView];
      
      if (YES == __glutUseMacOSCoords) {
         // if we are using normal glut coords use default behavior for negatives
         // fixes appkit issue with windows on other than main screen
         [win setFrameOrigin: NSMakePoint(x, y)];
      }
      
      /* Force creation of the OGL surface now */
      [view lockFocus];
      [view unlockFocus];
   } else {
      /* Create a subwindow */
      view = [[GLUTView alloc]    initWithFrame: rect
                                 pixelFormat: pixelFormat
                                 windowID: winnum + 1
                                 treatAsSingle: treatAsSingle
                                 isSubwindow: YES
                                 fullscreenStereo: _PFisFullscreenStereo(pixelFormat)
                                 isVBLSynced: __glutSyncToVBL];
      if(!view) {
         __glutFatalError(&quot;out of memory.&quot;);
      }
      [parent attachSubview: view];
   }
   
   do {
      /* Setup window to be mapped when glutMainLoop starts. */
      GLUTWorkEvent    event;
      
      INIT_WORK_EVENT(&amp;event);
      event.workMask = GLUT_MAP_WORK;
      event.windowNum = [view windowID];
      if(gameMode) {
         /* When mapping a game mode window, we have to
            move it to the shielding window layer or it
            won't be visible. */
         event.desiredMapState = kGameModeState;
      } else {
         if(!parent &amp;&amp; __glutIconic) {
            event.desiredMapState = kIconicState;
         } else {
            event.desiredMapState = kNormalState;
         }
      }
      __glutPostWorkEvent(&amp;event);
   } while(0);
   
   /* Add this new window to the window list. */
   __glutViewList[winnum] = view;
   
   /* Make the new window the current window. */
   __glutSetWindow(view);
   
   if (__glutSyncToVBL) {
   }
   
    return view;
}

/* CENTRY */
int APIENTRY glutCreateWindow(const char *name)
{
   GLUTView *    view = nil;
   NSString *    title = nil;
   int            winID = -1;
   
   GLUTAPI_DECLARATIONS
   GLUTAPI_BEGIN
   if(__glutGameModeWindow &amp;&amp; !__glutDestoryingGameMode) {
      __glutFatalError(&quot;Cannot create windows in game mode.&quot;);
   }
   
   if(name) {
      title = [NSString stringWithUTF8String: name];
   } else {
      title = [[NSProcessInfo processInfo] processName];
   }
   if(!title) {
      __glutFatalError(&quot;out of memory&quot;);
   }
   
   view = __glutCreateWindow(nil,
      __glutInitX, __glutScreenHeight - (__glutInitY + __glutInitHeight),
      __glutInitWidth, __glutInitHeight,
      /* not game mode */ NO);
   
   [[view window] setTitle: title];
   [[view window] setMiniwindowTitle: title];
   winID = [view windowID];
   GLUTAPI_END
   
   return winID;
}

int APIENTRY glutCreateSubWindow(int win, int x, int y, int width, int height)
{
   GLUTView *    parent = nil;
   GLUTView *    view = nil;
   int            winID = -1;
   
   GLUTAPI_DECLARATIONS
   GLUTAPI_BEGIN
   if(__glutGameModeWindow &amp;&amp; !__glutDestoryingGameMode) {
      __glutFatalError(&quot;Cannot create windows in game mode.&quot;);
   }
   
   parent = __glutGetWindowByNum(win);
   if(!parent) {
      __glutWarning(&quot;glutCreateSubWindow attempted on bogus window.&quot;);
      GLUTAPI_VALUERETURN(int, 0);
   }
   
   view = __glutCreateWindow(parent, x, y, width, height, /* not game mode */ NO);
   winID = [view windowID];
   GLUTAPI_END
   
   return winID;
}
/* ENDCENTRY */

void __glutDestroyWindow(GLUTView *view)
{
   /* Tear down window itself. */
   if(![view isSubwindow]) {
      NSWindow *    glutWin = [view window];
      
      if(!__glutInsideWindowShouldClose) {
         /* A 08/15 window destroy operation */
         [glutWin setReleasedWhenClosed:YES];
         // delay window destruction to ensure we are not in a sendEvent loop
         [glutWin performSelector:@selector(close) withObject:nil afterDelay:0.0f];
      } else {
         /* We were called from inside a window close handler.
            Mark the window for destruction and let the AppKit
            take care of the rest. */
         [glutWin setReleasedWhenClosed:YES];
         __glutShouldWindowClose = YES;
      }
   } else {
      [view detachFromSuperview];
      [view release];
   }   
}

/* CENTRY */
void APIENTRY glutDestroyWindow(int win)
{
   GLUTView *    view = __glutGetWindowByNum(win);
   
   GLUTAPI_DECLARATIONS
   GLUTAPI_BEGIN
   if(!view) {
      __glutWarning(&quot;glutDestroyWindow attempted on bogus window %d.&quot;, win);
      GLUTAPI_VOIDRETURN;
   }
   __glutDestroyWindow(view);
   GLUTAPI_END
}
/* ENDCENTRY */

void __glutChangeWindowEventMask(int eventMask, BOOL add)
{
   int    winEventMask = [__glutCurrentView eventMask];
   
    if(add) {
      /* Add eventMask to window's event mask. */
      if((winEventMask &amp; eventMask) != eventMask) {
         GLUTWorkEvent    event;
         
         [__glutCurrentView setEventMask: (winEventMask | eventMask)];
         INIT_WORK_EVENT(&amp;event);
         event.workMask = GLUT_EVENT_MASK_WORK;
         event.windowNum = [__glutCurrentView windowID];
         __glutPostWorkEvent(&amp;event);
      }
   } else {
      /* Remove eventMask from window's event mask. */
      if(winEventMask &amp; eventMask) {
         GLUTWorkEvent    event;
         
         [__glutCurrentView setEventMask: (winEventMask &amp; ~eventMask)];
         INIT_WORK_EVENT(&amp;event);
         event.workMask = GLUT_EVENT_MASK_WORK;
         event.windowNum = [__glutCurrentView windowID];
         __glutPostWorkEvent(&amp;event);
      }
   }
}

/* CENTRY */
void APIENTRY glutDisplayFunc(void (*func)(void))
{
   GLUTAPI_DECLARATIONS_FAST
   GLUTAPI_BEGIN_FAST
   [__glutCurrentView setDisplayCallback: func];
   GLUTAPI_END_FAST
}

void APIENTRY glutMouseFunc(void (*func)(int button, int state, int x, int y))
{
   GLUTAPI_DECLARATIONS_FAST
   GLUTAPI_BEGIN_FAST
   [__glutCurrentView setMouseCallback: func];
   GLUTAPI_END_FAST
}

void APIENTRY glutMotionFunc(void (*func)(int x, int y))
{
   GLUTAPI_DECLARATIONS_FAST
   GLUTAPI_BEGIN_FAST
   [__glutCurrentView setMotionCallback: func];
   GLUTAPI_END_FAST
}

void APIENTRY glutPassiveMotionFunc(void (*func)(int x, int y))
{
   GLUTAPI_DECLARATIONS_FAST
   GLUTAPI_BEGIN_FAST
   __glutChangeWindowEventMask(kPassiveMotionEvents, func != NULL);
   [__glutCurrentView setPassiveMotionCallback: func];
   GLUTAPI_END_FAST
}

void APIENTRY glutEntryFunc(void (*func)(int state))
{
   GLUTAPI_DECLARATIONS_FAST
   GLUTAPI_BEGIN_FAST
   __glutChangeWindowEventMask(kEntryEvents, func != NULL);
   [__glutCurrentView setEntryCallback: func];
   GLUTAPI_END_FAST
}

void APIENTRY glutWindowStatusFunc(void (*func)(int state))
{
   GLUTAPI_DECLARATIONS_FAST
   GLUTAPI_BEGIN_FAST
   [__glutCurrentView setWindowStatusCallback: func];
   GLUTAPI_END_FAST
}

static void visibilityHelper(int status)
{
   GLUTvisibilityCB    visibility = [__glutCurrentView visibilityCallback];
   
   if(status == GLUT_HIDDEN || status == GLUT_FULLY_COVERED)
      visibility(GLUT_NOT_VISIBLE);
   else
      visibility(GLUT_VISIBLE);
}

void APIENTRY glutVisibilityFunc(GLUTvisibilityCB func)
{
   GLUTAPI_DECLARATIONS_FAST
   GLUTAPI_BEGIN_FAST
   [__glutCurrentView setVisibilityCallback: func];
   if(func)
      glutWindowStatusFunc(visibilityHelper);
   else
      glutWindowStatusFunc(NULL);
   GLUTAPI_END_FAST
}

void APIENTRY glutReshapeFunc(void (*func)(int width, int height))
{
   GLUTAPI_DECLARATIONS_FAST
   GLUTAPI_BEGIN_FAST
   [__glutCurrentView setReshapeCallback: func];
   GLUTAPI_END_FAST
}

void APIENTRY glutWMCloseFunc(void (*func)(void))
{
   GLUTAPI_DECLARATIONS
   GLUTAPI_BEGIN
   if(func) {
      [__glutCurrentView setWMCloseCallback: func];
   } else {
      [__glutCurrentView setWMCloseCallback: __glutDefaultWMClose];
   }
   GLUTAPI_END
}

void APIENTRY glutSetWindowTitle(const char *name)
{
   NSString *    title = nil;
   
   GLUTAPI_DECLARATIONS
   IGNORE_IN_GAME_MODE()
   GLUTAPI_BEGIN
   if(name == NULL)
      name = &quot;&quot;;
   title = [NSString stringWithUTF8String: name];
   if(!title) {
      __glutFatalError(&quot;out of memory&quot;);
   }
   if([__glutCurrentView isSubwindow]) {
      __glutWarning(&quot;glutSetWindowTitle attempted on subwindow %d&quot;, [__glutCurrentView windowID]);
      GLUTAPI_VOIDRETURN;
   }
   [[__glutCurrentView window] setTitle: title];
   GLUTAPI_END
}

void APIENTRY glutSetIconTitle(const char *name)
{
   NSString *    title = nil;
   
   GLUTAPI_DECLARATIONS
   IGNORE_IN_GAME_MODE()
   GLUTAPI_BEGIN
   if(name == NULL)
      name = &quot;&quot;;
   title = [NSString stringWithUTF8String: name];
   if(title == nil) {
      __glutFatalError(&quot;out of memory&quot;);
   }
   if([__glutCurrentView isSubwindow]) {
      __glutWarning(&quot;glutSetIconTitle attempted on subwindow %d&quot;, [__glutCurrentView windowID]);
      GLUTAPI_VOIDRETURN;
   }
   [[__glutCurrentView window] setMiniwindowTitle: title];
   GLUTAPI_END
}

void APIENTRY glutPositionWindow(int x, int y)
{
   GLUTWorkEvent    event;
   
   IGNORE_IN_GAME_MODE();
   INIT_WORK_EVENT(&amp;event);
   event.workMask = GLUT_CONFIGURE_WORK;
   event.windowNum = [__glutCurrentView windowID];
   event.desiredX = x;
   event.desiredY = y;
   event.desiredConfMask = (CWX | CWY);
   __glutPostWorkEvent(&amp;event);
}

void APIENTRY glutReshapeWindow(int width, int height)
{
   GLUTWorkEvent    event;
   
   IGNORE_IN_GAME_MODE();
   if(width &lt;= 0 || height &lt;= 0)
      __glutWarning(&quot;glutReshapeWindow: non-positive width or height not allowed&quot;);
   
   INIT_WORK_EVENT(&amp;event);
   event.workMask = GLUT_CONFIGURE_WORK;
   event.windowNum = [__glutCurrentView windowID];
   event.desiredWidth = ABS(width);
   event.desiredHeight = ABS(height);
   event.desiredConfMask = (CWWidth | CWHeight);
   __glutPostWorkEvent(&amp;event);
}

void APIENTRY glutFullScreen(void)
{
   GLUTWorkEvent    event;
   
   IGNORE_IN_GAME_MODE();
   if([__glutCurrentView isSubwindow]) {
      __glutWarning(&quot;glutFullScreen attempted on subwindow %d&quot;, [__glutCurrentView windowID]);
      return;
   }
   INIT_WORK_EVENT(&amp;event);
   event.workMask = GLUT_CONFIGURE_WORK;
   event.windowNum = [__glutCurrentView windowID];
   event.desiredConfMask = CWFullScreen;
   __glutPostWorkEvent(&amp;event);
}

void APIENTRY glutPopWindow(void)
{
   GLUTWorkEvent    event;
   
   IGNORE_IN_GAME_MODE();
   INIT_WORK_EVENT(&amp;event);
   event.workMask = GLUT_CONFIGURE_WORK;
   event.windowNum = [__glutCurrentView windowID];
   event.desiredStack = kAbove;
   event.desiredConfMask = CWStackMode;
   __glutPostWorkEvent(&amp;event);
}

void APIENTRY glutPushWindow(void)
{
   GLUTWorkEvent    event;
   
   IGNORE_IN_GAME_MODE();
   INIT_WORK_EVENT(&amp;event);
   event.workMask = GLUT_CONFIGURE_WORK;
   event.windowNum = [__glutCurrentView windowID];
   event.desiredStack = kBelow;
   event.desiredConfMask = CWStackMode;
   __glutPostWorkEvent(&amp;event);
}

void APIENTRY glutIconifyWindow(void)
{
   GLUTWorkEvent    event;
   
   IGNORE_IN_GAME_MODE();
   if([__glutCurrentView isSubwindow]) {
      __glutWarning(&quot;glutIconifyWindow attempted on subwindow %d&quot;, [__glutCurrentView windowID]);
      return;
   }
   INIT_WORK_EVENT(&amp;event);
   event.workMask = GLUT_MAP_WORK;
   event.windowNum = [__glutCurrentView windowID];
   event.desiredMapState = kIconicState;
   __glutPostWorkEvent(&amp;event);
}

void APIENTRY glutShowWindow(void)
{
   GLUTWorkEvent    event;
   
   IGNORE_IN_GAME_MODE();
   INIT_WORK_EVENT(&amp;event);
   event.workMask = GLUT_MAP_WORK;
   event.windowNum = [__glutCurrentView windowID];
   event.desiredMapState = kNormalState;
   __glutPostWorkEvent(&amp;event);
}

void APIENTRY glutHideWindow(void)
{
   GLUTWorkEvent    event;
   
   IGNORE_IN_GAME_MODE();
   INIT_WORK_EVENT(&amp;event);
   // hide = map work + kWithdrawnState
   event.workMask = GLUT_MAP_WORK;
   event.windowNum = [__glutCurrentView windowID];
   event.desiredMapState = kWithdrawnState;
   __glutPostWorkEvent(&amp;event);
}

void APIENTRY glutSurfaceTexture (GLenum target, GLenum format, int surfacewin)
{
    GLUTView * surfaceView = __glutGetWindowByNum(surfacewin);

   GLUTAPI_DECLARATIONS
   GLUTAPI_BEGIN
   if(!surfaceView) {
      __glutWarning(&quot;glutSurfaceTexture attempted on bogus window.&quot;);
      GLUTAPI_VOIDRETURN;
   }
    [[__glutCurrentView openGLContext] createTexture:target fromView:surfaceView internalFormat:format];
   GLUTAPI_END
}
/* ENDCENTRY */

</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/glut/listing117.html%3Fid%3DDTS10000528-2.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/glut/listing117.html%3Fid%3DDTS10000528-2.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/glut/listing117.html%3Fid%3DDTS10000528-2.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>