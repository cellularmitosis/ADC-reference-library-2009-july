<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>About the Device Manager(IM: D)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING12></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->




<!-- Main Body -->

<CENTER>
<P>
<A HREF="Devices-11.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Devices-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Devices-328.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Devices-13.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Devices-2.html"><B>Devices</B></A> / <BR><DD><A HREF="Devices-10.html"><B>Chapter 1 - Device Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING12-0></A>
<H1><A NAME=MARKER-9-31></A>About the Device Manager</H1>
 The Device Manager provides a common programming interface for applications and other managers to use when communicating with device drivers. The Device Manager also includes support functions useful for writing your own device drivers. <P>
 Typically, your application won't communicate directly with device drivers; instead, it will call Device Manager functions or call the functions of another manager that calls the Device Manager. For example, your application can communicate with a disk driver by calling the Device Manager directly or by calling the File Manager, which calls the Device Manager. <A HREF=#MARKER-9-32>Figure 1-2</A> shows the relationship between applications, the Device Manager, other managers, device drivers, and devices.<P>
<B>Figure 1-2  <A NAME=MARKER-9-32></A>Communication with devices</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/DEV-L-01.jpg"><p>
 Before the Device Manager allows an application or another manager to communicate with a device driver, the driver must be open, which means the Device Manager has received a request to open the driver, has loaded the driver into memory, if necessary, and has successfully called the driver's open routine. <P>
 Your application opens a device driver using one of the Device Manager functions, <CODE><A NAME=MARKER-2-370></A><A NAME=MARKER-9-369></A><A NAME=MARKER-2-368></A><A NAME=MARKER-2-367></A>OpenDriver</CODE>, <CODE>OpenSlot</CODE>, or <CODE>PBOpen</CODE>. These functions return a <B>driver reference number</B> for the driver. You use the driver reference number to identify the driver in subsequent communication requests.<P>
 <A NAME=MARKER-9-151></A><A NAME=MARKER-8-68></A>Your application communicates with a driver by calling Device Manager functions such as <CODE>FSRead</CODE> or <CODE>PBRead</CODE>, and supplying the driver reference number of the device. The Device Manager then invokes a corresponding routine in the device driver to perform the requested operation. The section <A HREF=Devices-232.html#MARKER-9-108>"Driver Routines" on page 1-12</A> describes these routines and their relationship to the Device Manager functions.<P>
 The Device Manager uses several data structures to locate, manage, and communicate with device drivers. These structures are described in the following sections.<P>
<A NAME=HEADING12-9></A>
<H2>The Device Control Entry</H2>
 <A NAME=MARKER-9-152></A>The Device Manager maintains a data structure called a <B>device control entry</B> (DCE) for each open driver. The device control entry is a relocatable block in the system heap that contains a handle or pointer to the device driver code, and additional information about the driver. Typically, the Device Manager maintains one device control entry for each open device driver, but it is possible for multiple entries to refer to the same driver.<P>
 <A HREF=#MARKER-9-40>Figure 1-3</A> shows the device control entry structure. See <A HREF=Devices-17.html#MARKER-9-216>"Device Manager Reference," beginning on page 1-53</A>, for descriptions of the fields within the device control entry structure.<P>
<B>Figure 1-3  <A NAME=MARKER-9-40></A>The device control entry</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/DEV-L-07.jpg"><p>
<A NAME=HEADING12-14></A>
<H2>The Unit Table</H2>
 <A NAME=MARKER-2-41></A>The Device Manager uses a data structure called the <B>unit table</B> to organize and keep track of device control entries. The unit table is a nonrelocatable block in the system heap, containing an array of handles. Each handle points to the device control entry of an installed device driver. The location of a driver's device control entry handle in the unit table is called the driver's <A NAME=MARKER-2-42></A><B>unit number</B>. If the handle at a given unit number is <CODE>nil</CODE>, there is no device control entry installed in that position.<P>
 When you open a device driver, the Device Manager returns a driver reference number for the driver. The driver reference number is the one's complement (logical <CODE>NOT</CODE>) of the unit number.<P>
 The system global variable <CODE>UTableBase</CODE> points to the first entry of the unit table. The system global variable <A NAME=MARKER-2-371></A><CODE>UnitNtryCnt</CODE> contains the size of the unit table (that is, how many handles it can hold). <A HREF=#MARKER-9-45>Figure 1-4</A> shows the organization of the unit table, including the locations of some of the standard device drivers reserved by Apple Computer, Inc.<P>
<B>Figure 1-4  <A NAME=MARKER-9-45></A>The unit table</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/DEV-L-08.jpg"><p>
<A NAME=HEADING12-20></A>
<H2>The Driver I/O Queue</H2>
 <A NAME=MARKER-2-246></A><A NAME=MARKER-2-47></A><A NAME=MARKER-9-372></A>The Device Manager maintains an I/O queue for each open device driver. An I/O queue is a standard Macintosh Operating System queue of type <CODE>ioQType</CODE>, as described in the chapter "Queue Utilities" in <I><A HREF="../OSUtilities/OSUtilities-2.html">Inside Macintosh: Operating System Utilities</A></I>. <P>
 At the head of a device driver's I/O queue is the request currently being processed by the driver. The rest of the queue contains pending I/O requests--those the Device Manager has received but not yet sent to the device driver. This queue allows your application to request a data transfer with a busy device and accomplish other tasks while the device processes previous requests.<P>
 With respect to the I/O queue, the Device Manager allows you to make three types of requests: asynchronous, synchronous, and immediate.<P>
<UL>
<LI><B>Asynchronous requests.</B> When you make an asynchronous request, the Device Manager places your request at the end of the driver I/O queue and returns control to your application--potentially before the request is processed. Your application is free to perform other tasks while the device driver processes the requests in its queue. The Device Manager provides mechanisms for your application to determine when the driver has processed the request. <A NAME=MARKER-2-205></A><A NAME=MARKER-8-80></A>
<LI><B>Synchronous requests.</B> When you make a synchronous request, the Device Manager places your request at the end of the queue and waits until the device driver has handled every request in the queue, including the synchronous one, before returning control to your application. Notice there can never be more than one synchronous request in a driver I/O queue at any given time. <A NAME=MARKER-2-51></A><A NAME=MARKER-9-157></A>
<LI><B>Immediate requests.</B> The Device Manager sends immediate requests directly to the device driver, bypassing the queue, and returns control to your application when the request is complete. Because the device driver might be in the middle of processing another request, you must make sure the driver is reentrant before making an immediate request. A <A NAME=MARKER-2-247></A><A NAME=MARKER-2-248></A><B>reentrant driver</B> is capable of handling multiple requests simultaneously. As some device drivers are not reentrant, you should always consult a driver's documentation to determine if it supports immediate requests.<A NAME=MARKER-2-206></A><P>
</UL>
<DL>
<DT><B>IMPORTANT</B>
<DD><A NAME=MARKER-9-57></A>The terms <I>synchronous</I> and <I>asynchronous</I> are used here to describe how the Device Manager queues your I/O requests. How a device driver processes these requests (synchronously or asynchronously) depends on the design of the driver. When you make a synchronous request to a device driver, the Device Manager waits for the driver to complete the request, regardless of whether the driver handles the request synchronously or asynchronously.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 <A HREF=#MARKER-9-58>Figure 1-5</A> shows the relationship of the unit table, device control entry, and I/O queue to a device driver.<P>
<B>Figure 1-5  <A NAME=MARKER-9-58></A>Relationship of the Device Manager data structures</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/DEV-L-09.jpg"><p>
<A NAME=HEADING12-31></A>
<H2><A NAME=MARKER-9-108></A>Driver Routines</H2>
 Every device driver must provide a set of routines for handling requests from the Device Manager. When an application or another manager calls a Device Manager function, the Device Manager invokes one of the following routines in the designated device driver: <P>
<UL>
<LI>The <B>open routine</B> allocates memory and initializes the device driver's data structures. It may also initialize a hardware device or perform any other tasks necessary to make the driver operational. All device drivers must implement an open routine.<A NAME=MARKER-2-75></A><A NAME=MARKER-2-61></A>
<LI>The <B>close routine</B> deactivates the device driver, releases any memory allocated by the driver, removes any patches installed by the driver, and performs any other tasks necessary to reverse the actions of the open routine. All drivers must implement a close routine.<A NAME=MARKER-2-85></A>
<LI>The <B>control routine</B> is usually used to send control information to the device driver. The function of this routine is driver-dependent. This routine is optional and need not be implemented.<A NAME=MARKER-8-75></A><A NAME=MARKER-2-87></A>
<LI>The <B>status routine</B> is usually used to return status information from the device driver. The function of this routine is driver-dependent. The status routine is optional and need not be implemented.<A NAME=MARKER-2-119></A>
<LI>The <B>prime routine</B> implements the input and output functions of the driver. This routine is optional. If the prime routine is implemented, it must support either read functions or write functions, or both.<A NAME=MARKER-8-76></A><A NAME=MARKER-2-121></A><P>
</UL>
 Each driver routine is responsible for handling specific types of Device Manager requests. <A HREF=#MARKER-9-1>Table 1-1</A> shows the Device Manager I/O functions and the driver routines responsible for handling them. The Device Manager I/O functions are described in <A HREF=Devices-56.html#MARKER-9-121>"Using the Device Manager," beginning on page 1-14</A>. The section <A HREF=Devices-14.html#MARKER-9-113>"Writing a Device Driver," beginning on page 1-24</A>, describes the driver routines.
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><A NAME=MARKER-9-1></A><B>Table 1-1 Device Manager I/O functions and responsible driver routines</B></CAPTION>
<TH>Device Manager function<TH>Responsible driver routine<TR>
<TD>OpenDriver, PBOpen, OpenSlot<TD>Open<TR>
<TD>FSRead, PBRead<TD>Prime<TR>
<TD>FSWrite, PBWrite<TD>Prime<TR>
<TD>Control, PBControl<TD>Control<TR>
<TD>Status, PBStatus<TD>Status<TR>
<TD>KillIO, PBKillIO<TD>Control<TR>
<TD>CloseDriver, PBClose<TD>Close</TABLE>
<P>
<A NAME=HEADING12-39></A>
<H2>Driver Resources</H2>
 <A NAME=MARKER-9-374></A><A NAME=MARKER-9-161></A>Device drivers are usually stored in driver resources, which can be located in applications, system extension files, or the firmware of expansion cards. A driver resource consists of a header followed by the driver code. The header contains information about the driver such as which driver routines are implemented and where the routines are located within the driver code. The Device Manager copies the relevant information from the header into the device control entry when you open the driver. <A HREF=#MARKER-9-72>Figure 1-6</A> shows the structure of a driver resource. The section <A HREF=Devices-14.html#MARKER-9-116>"Creating a Driver Resource," beginning on page 1-24</A>, describes driver resources in detail.<P>
<B>Figure 1-6  <A NAME=MARKER-9-72></A>Structure of a driver resource<A NAME=MARKER-2-73></A></B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/DEV-L-06.jpg"><p>
<HR>
<B>Subtopics</B>
<B><!-- TOC --><DL>
<DT><A HREF="Devices-12.html#HEADING12-9">The Device Control Entry</A>
<DD>
<DT><A HREF="Devices-12.html#HEADING12-14">The Unit Table</A>
<DD>
<DT><A HREF="Devices-12.html#HEADING12-20">The Driver I/O Queue</A>
<DD>
<DT><A HREF="Devices-12.html#HEADING12-31">Driver Routines</A>
<DD>
<DT><A HREF="Devices-12.html#HEADING12-39">Driver Resources</A>
<DD>
</DL>
</B>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Devices-11.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Devices-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Devices-328.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Devices-13.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Devices-3.html">&copy; Apple Computer, Inc.</A><br>3 JUL 1996</center></font><P>
<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->
</BODY>
</HTML>  
