<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/1998/REC-html40-19980424/loose.dtd">
<html>
<head>
<title>IOService</title>
<meta http-equiv="Content-Type" content="text/html; charset=ascii">
<meta name="generator" content="HeaderDoc">
<style><!--
#tocMenu {
		display: block;
		position:fixed;
		top:0px;
		left:0px;
		width:210px;
		height:100%;
		background:transparent;
}
#bodyText {
		margin-left: 210px;
}
--></style>
<meta id="toc-file" name="toc-file" content="toc.html">
<script language="JavaScript" src="../../../../../../Resources/JavaScript/page.js" type="text/javascript"></script><link rel="stylesheet" type="text/css" href="../../../../../../Resources/CSS/frameset_styles.css">
<style type="text/css"><!--.keyword {background:#ffffff; color:#761550;}.template {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.function {background:#ffffff; color:#000000;}.string {background: #ffffff; color:#891315;}.preprocessor {background:#ffffff; color:#236e25}.comment {background:#ffffff; color:#236e25}.char {background: #ffffff; color:#0000ff;}.var {background:#ffffff; color:#000000;}.type {background:#ffffff; color:#761550;}.param {background:#ffffff; color:#000000;}.graybox {         border-top: 1px solid #919699;         border-left: 1px solid #919699;         margin-bottom: 10px;         }  .graybox th {         padding: 4px 8px 4px 8px;         background: #E2E2E2;         font-size: 12px;         font-weight: bold;         border-bottom: 1px solid #919699;         border-right: 1px solid #919699;         }  .graybox td {         padding: 8px;         font-size: 12px;         text-align: left;         vertical-align: top;         border-bottom: 1px solid #919699;         border-right: 1px solid #919699;         }  --></style>
</head>
<body bgcolor="#ffffff" onload="initialize_page();">
<noscript>
<div id="tocMenu">
<iframe id="toc_content" name="toc_content" src="toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
</div>
</noscript>
<div id="bodyText">
<!-- start of header -->

<!-- start of header -->
<!--#include virtual="/includes/framesetheader"-->
<!-- end of header -->

<table width="600"><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <a href="../../../../../../../reference/Darwin/index.html#//apple_ref/doc/uid/TP30001281-TP30000422" target="_top">Darwin</a> <b>&gt;</b> <a href="../../../index.html#//apple_ref/doc/framework/kernel_fw_leo" target="_top">Kernel Framework Reference</a></font>
<!-- end breadcrumb insert request -->
<p>&#160;</p>
</td></tr></table>
<!-- end of header --><a name="top"></a>
<a name="//apple_ref/doc/class/IOService" title="IOService"></a>
<hr>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h1><a name="IOService">IOService</a></h1>
</td></tr></table>
<div class="spec_sheet_info_box"><table cellspacing="0" class="specbox">
<tr>
<td scope="row"><b>Inherits from:</b></td>
<td><div style="margin-bottom:1px"><div class="content_text">
<a href="../../../IORegistryEntry_h/Classes/IORegistryEntry/index.html#//apple_ref/cpp/cl/IORegistryEntry" target="_top">IORegistryEntry</a>
</div></div></td>
</tr>
<tr>
<td scope="row"><b>Declared In:</b></td>
<td><div style="margin-bottom:1px"><div class="content_text"><a href="../../index.html" target="_top">IOService.h</a></div></div></td>
</tr>
</table></div>
<h2>Overview</h2>
<p><!-- begin abstract --></p>
<p>The base class for most I/O Kit families, devices, and drivers.
<!-- end abstract --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>The IOService base class defines APIs used to publish services, instantiate other services based on the existance of a providing service (ie. driver stacking), destroy a service and its dependent stack, notify interested parties of service state changes, and general utility functions useful across all families. 
</p>
<p>Types of service are specified with a matching dictionary that describes properties of the service. For example, a matching dictionary might describe any IOUSBDevice (or subclass), an IOUSBDevice with a certain class code, or a IOPCIDevice with a set of OpenFirmware matching names or device &amp; vendor IDs. Since the matching dictionary is interpreted by the family which created the service, as well as generically by IOService, the list of properties considered for matching depends on the familiy.
</p>
<p>Matching dictionaries are associated with IOService classes by the catalogue, as driver property tables, and also supplied by clients of the notification APIs.
</p>
<p>IOService provides matching based on C++ class (via OSMetaClass dynamic casting), registry entry name, a registry path to the service (which includes OpenFirmware paths), a name assigned by BSD, or by its location (its point of attachment).
</p>
<p><br><br>Driver Instantiation by IOService<br><br></p>
<p>Drivers are subclasses of IOService, and their availability is managed through the catalogue. They are instantiated based on the publication of an IOService they use (for example, an IOPCIDevice or IOUSBDevice), or when they are added to  the catalogue and the IOService(s) they use are already available.
</p>
<p>When an IOService (the "provider") is published with the <a href="index.html#//apple_ref/cpp/instm/IOService/registerService/void/(IOOptionBits)" target="_top">registerService</a> method, the matching and probing process begins, which is always single threaded per provider. A list of matching dictionaries from the catalog and installed publish notification requests, that successfully match the IOService, is constructed, with ordering supplied by <code>kIOProbeScoreKey</code> ("IOProbeScore") property in the dictionary, or supplied with the notification. 
</p>
<p>Each entry in the list is then processed in order - for notifications, the notification is delivered, for driver property tables a lot more happens.
</p>
<p>The driver class is instantiated and <code>init()</code> called with its property table. The new driver instance is then attached to the provider, and has its <a href="index.html#//apple_ref/cpp/instm/IOService/probe/IOService*/(IOService*,SInt32*)" target="_top">probe</a> method called with the provider as an argument. The default <code>probe</code> method does nothing but return success, but a driver may implement this method to interrogate the provider to make sure it can work with it. It may also modify its probe score at this time. After probe, the driver is detached and the next in the list is considered (ie. attached, probed, and detached).
</p>
<p>When the probing phase is complete, the list consists of successfully probed drivers, in order of their probe score (after adjustment during the <a href="index.html#//apple_ref/cpp/instm/IOService/probe/IOService*/(IOService*,SInt32*)" target="_top">probe</a> call). The list is then divided into categories based on the <code>kIOMatchCategoryKey</code> property ("IOMatchCategory"); drivers without a match category are all considered in one default category. Match categories allow multiple clients of a provider to be attached and started, though the provider may also enforce open/close semantics to gain active access to it.
</p>
<p>For each category, the highest scoring driver in that category is attached to the provider, and its <a href="index.html#//apple_ref/cpp/instm/IOService/start/bool/(IOService*)" target="_top">start</a> method called. If <code>start</code> is successful, the rest of the drivers in the same match category are discarded, otherwise the next highest scoring driver is started, and so on.
</p>
<p>The driver should only consider itself in action when the start method is called, meaning it has been selected for use on the provider, and consuming that particular match category. It should also be prepared to be allocated, probed and freed even if the probe was successful.
</p>
<p>After the drivers have all synchronously been started, the installed "matched" notifications that match the registered IOService are delivered.
</p>
<p><br><br>Properties used by IOService<br><br></p>
<p><code>kIOClassKey, extern const OSSymbol * gIOClassKey, "IOClass"</code>
<br><br>
Class of the driver to instantiate on matching providers.
<br><br><code>kIOProviderClassKey, extern const OSSymbol * gIOProviderClassKey, "IOProviderClass"</code>
<br><br>
Class of the provider(s) to be considered for matching, checked with OSDynamicCast so subclasses will also match.
<br><br><code>kIOProbeScoreKey, extern const OSSymbol * gIOProbeScoreKey, "IOProbeScore"</code>
<br><br>
The probe score initially used to order multiple matching drivers.
<br><br><code>kIOMatchCategoryKey, extern const OSSymbol * gIOMatchCategoryKey, "IOMatchCategory"</code>
<br><br>
A string defining the driver category for matching purposes. All drivers with no <code>IOMatchCategory</code> property are considered to be in the same default category. Only one driver in a category can be started on each provider.
<br><br><code>kIONameMatchKey, extern const OSSymbol * gIONameMatchKey, "IONameMatch"</code>
<br>
A string or collection of strings that match the provider's name. The comparison is implemented with the <!-- a -->IORegistryEntry::compareNames<!-- /a --> method, which supports a single string, or any collection (OSArray, OSSet, OSDictionary etc.) of strings. IOService objects with OpenFirmware device tree properties (eg. IOPCIDevice) will also be matched based on that standard's "compatible", "name", "device_type" properties. The matching name will be left in the driver's property table in the <code>kIONameMatchedKey</code> property.
<br>
Examples
</p>
<pre>

	&lt;key&gt;IONameMatch&lt;/key&gt;
	&lt;string&gt;pci106b,7&lt;/string&gt;

</pre>

<p>For a list of possible matching names, a serialized array of strings should used, eg.
</p>
<pre>

	&lt;key&gt;IONameMatch&lt;/key&gt;
	&lt;array&gt;
		&lt;string&gt;APPL,happy16&lt;/string&gt;
		&lt;string&gt;pci106b,7&lt;/string&gt;
	&lt;/array&gt;

</pre>

<p><br><code>kIONameMatchedKey, extern const OSSymbol * gIONameMatchedKey, "IONameMatched"</code>
<br>
The name successfully matched name from the <code>kIONameMatchKey</code> property will be left in the driver's property table as the <code>kIONameMatchedKey</code> property.
<br><br><code>kIOPropertyMatchKey, extern const OSSymbol * gIOPropertyMatchKey, "IOPropertyMatch"</code>
<br>
A dictionary of properties that each must exist in the matching IOService and compare successfully with the <code>isEqualTo</code> method.
</p>
<pre>

	&lt;key&gt;IOPropertyMatch&lt;/key&gt;
	&lt;dictionary&gt;
		&lt;key&gt;APPL,happy16&lt;/key&gt;
		&lt;string&gt;APPL,meek8&lt;/string&gt;
	&lt;/dictionary&gt;

</pre>

<p><br><code>kIOUserClientClassKey, extern const OSSymbol * gIOUserClientClassKey, "IOUserClientClass"</code>
<br>
The class name that the service will attempt to allocate when a user client connection is requested.  First the device nub is queried, then the nub's provider is queried by default.
<br><br><code>kIOKitDebugKey, extern const OSSymbol * gIOKitDebugKey, "IOKitDebug"</code>
<br>
Set some debug flags for logging the driver loading process. Flags are defined in <code>IOKit/IOKitDebug.h</code>, but <code>65535</code> works well.<!-- end discussion -->
</p>
<hr>
<br><h2>Functions</h2>
<a name="HeaderDoc_functions"></a>
<dl>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/acknowledgePowerChange/IOReturn/(IOService*)" target="_top">acknowledgePowerChange</a></tt></dt>
<dd><p>Acknowledges an in-progress power state change.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/acknowledgeSetPowerState/IOReturn/()" target="_top">acknowledgeSetPowerState</a></tt></dt>
<dd><p>Acknowledges the belated completion of a driver's <code>setPowerState</code> power state change.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/activityTickle/bool/(unsignedlong,unsignedlong)" target="_top">activityTickle</a></tt></dt>
<dd><p>Informs power management when a power-managed device is in use, so that power management can track when it is idle and adjust its power state accordingly.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/clm/IOService/addLocation/OSDictionary*/(OSDictionary*)" target="_top">addLocation</a></tt></dt>
<dd><p>Adds a location matching property to an existing dictionary.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/clm/IOService/addNotification/IONotifier*/(constOSSymbol*,OSDictionary*,IOServiceNotificationHandler,void*,void*,SInt32)" target="_top">addNotification</a></tt></dt>
<dd><p>Adds a persistant notification handler to be notified of IOService events.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/addPowerChild/IOReturn/(IOService*)" target="_top">addPowerChild</a></tt></dt>
<dd><p>Informs a driver that it has a new child. 
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/adjustBusy/void/(SInt32)" target="_top">adjustBusy</a></tt></dt>
<dd><p>Adjusts the <code>busyState</code> of an IOService object.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/attach/bool/(IOService*)" target="_top">attach</a></tt></dt>
<dd><p>Attaches an IOService client to a provider in the I/O Registry.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/callPlatformFunction/IOReturn/(constOSSymbol*,bool,void*,void*,void*,void*)" target="_top">callPlatformFunction</a></tt></dt>
<dd><p>Calls the platform function with the given name.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/causeInterrupt/IOReturn/(int)" target="_top">causeInterrupt</a></tt></dt>
<dd><p>Causes a device interrupt to occur.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/changePowerStateTo/IOReturn/(unsignedlong)" target="_top">changePowerStateTo</a></tt></dt>
<dd><p>Sets a driver's power state.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/changePowerStateToPriv/IOReturn/(unsignedlong)" target="_top">changePowerStateToPriv</a></tt></dt>
<dd><p>Tells a driver's superclass to change the power state of its device.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/clampPowerOn/void/(unsignedlong)" target="_top">clampPowerOn</a></tt></dt>
<dd><p>Deprecated. Do not use.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/close/void/(IOService*,IOOptionBits)" target="_top">close</a></tt></dt>
<dd><p>Releases active access to a provider.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/compareProperties/bool/(OSDictionary*,OSCollection*)" target="_top">compareProperties</a></tt></dt>
<dd><p>Compares a set of properties in a matching dictionary with an IOService object's property table.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/compareProperty/bool/(OSDictionary*,constchar*)" target="_top">compareProperty(OSDictionary *, const char *)</a></tt></dt>
<dd><p>Compares a property in a matching dictionary with an IOService object's property table.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/compareProperty/bool/(OSDictionary*,constOSString*)" target="_top">compareProperty(OSDictionary *, const OSString *)</a></tt></dt>
<dd><p>Compares a property in a matching dictionary with an IOService object's property table.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/currentCapability/IOPMPowerFlags/()" target="_top">currentCapability</a></tt></dt>
<dd><p>Finds out the capability of a device's current power state.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/currentPowerConsumption/unsignedlong/()" target="_top">currentPowerConsumption</a></tt></dt>
<dd><p>Finds out the current power consumption of a device.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/deRegisterInterestedDriver/IOReturn/(IOService*)" target="_top">deRegisterInterestedDriver</a></tt></dt>
<dd><p>De-registers power state interest from a previous call to <code>registerInterestedDriver</code>.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/detach/void/(IOService*)" target="_top">detach</a></tt></dt>
<dd><p>Detaches an IOService client from a provider in the I/O Registry.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/didTerminate/bool/(IOService*,IOOptionBits,bool*)" target="_top">didTerminate</a></tt></dt>
<dd><p>Passes a termination up the stack.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/didYouWakeSystem/bool/()" target="_top">didYouWakeSystem</a></tt></dt>
<dd><p>Asks a driver if its device is the one that just woke the system from sleep. 
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/disableInterrupt/IOReturn/(int)" target="_top">disableInterrupt</a></tt></dt>
<dd><p>Synchronously disables a device interrupt.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/enableInterrupt/IOReturn/(int)" target="_top">enableInterrupt</a></tt></dt>
<dd><p>Enables a device interrupt.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/errnoFromReturn/int/(IOReturn)" target="_top">errnoFromReturn</a></tt></dt>
<dd><p>Translates an IOReturn code to a BSD <code>errno</code>.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/finalize/bool/(IOOptionBits)" target="_top">finalize</a></tt></dt>
<dd><p>Finalizes the destruction of an IOService object.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/free/void/()" target="_top">free</a></tt></dt>
<dd><p>Frees data structures that were allocated when power management was initialized on this service. </p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/getAggressiveness/IOReturn/(unsignedlong,unsignedlong*)" target="_top">getAggressiveness</a></tt></dt>
<dd><p>Returns the current aggressiveness value for the given type. 
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/getBusyState/UInt32/()" target="_top">getBusyState</a></tt></dt>
<dd><p>Returns the <code>busyState</code> of an IOService object.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/getClient/IOService*/()" target="_top">getClient</a></tt></dt>
<dd><p>Returns an IOService object's primary client.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/getClientIterator/OSIterator*/()" target="_top">getClientIterator</a></tt></dt>
<dd><p>Returns an iterator over an IOService object's clients.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/getDeviceMemory/OSArray*/()" target="_top">getDeviceMemory</a></tt></dt>
<dd><p>Returns the array of IODeviceMemory objects representing a device's memory mapped ranges.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/getDeviceMemoryCount/IOItemCount/()" target="_top">getDeviceMemoryCount</a></tt></dt>
<dd><p>Returns a count of the physical memory ranges available for a device.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/getDeviceMemoryWithIndex/IODeviceMemory*/(unsignedint)" target="_top">getDeviceMemoryWithIndex</a></tt></dt>
<dd><p>Returns an instance of IODeviceMemory representing one of a device's memory mapped ranges.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/getInterruptType/IOReturn/(int,int*)" target="_top">getInterruptType</a></tt></dt>
<dd><p>Returns the type of interrupt used for a device supplying hardware interrupts.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/clm/IOService/getMatchingServices/OSIterator*/(OSDictionary*)" target="_top">getMatchingServices</a></tt></dt>
<dd><p>Finds the set of current published IOService objects matching a matching dictionary.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/getOpenClientIterator/OSIterator*/()" target="_top">getOpenClientIterator</a></tt></dt>
<dd><p>Returns an iterator over a provider's clients that currently have opened the provider.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/getOpenProviderIterator/OSIterator*/()" target="_top">getOpenProviderIterator</a></tt></dt>
<dd><p>Returns an iterator over an client's providers that are currently opened by the client.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/clm/IOService/getPlatform/IOPlatformExpert*/()" target="_top">getPlatform</a></tt></dt>
<dd><p>Returns a pointer to the platform expert instance for the computer.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/clm/IOService/getPMRootDomain/classIOPMrootDomain*/()" target="_top">getPMRootDomain</a></tt></dt>
<dd><p>Returns a pointer to the power management root domain instance for the computer.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/getPMworkloop/IOWorkLoop*/()" target="_top">getPMworkloop</a></tt></dt>
<dd><p>Returns a pointer to the system-wide power management work loop.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/getPowerState/UInt32/()" target="_top">getPowerState</a></tt></dt>
<dd><p>Determines a device's power state.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/getProvider/IOService*/()" target="_top">getProvider</a></tt></dt>
<dd><p>Returns an IOService object's primary provider.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/getProviderIterator/OSIterator*/()" target="_top">getProviderIterator</a></tt></dt>
<dd><p>Returns an iterator over an IOService object's providers.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/getResources/IOReturn/()" target="_top">getResources</a></tt></dt>
<dd><p>Allocates any needed resources for a published IOService object before clients attach.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/clm/IOService/getResourceService/IOService*/()" target="_top">getResourceService</a></tt></dt>
<dd><p>Returns a pointer to the IOResources service.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/clm/IOService/getServiceRoot/IOService*/()" target="_top">getServiceRoot</a></tt></dt>
<dd><p>Returns a pointer to the root of the service plane.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/getState/IOOptionBits/()" target="_top">getState</a></tt></dt>
<dd><p>Accessor for IOService state bits, not normally needed or used outside IOService.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/getWorkLoop/IOWorkLoop*/()" target="_top">getWorkLoop</a></tt></dt>
<dd><p>Returns the current work loop or <code>provider-&gt;getWorkLoop</code>.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/handleClose/void/(IOService*,IOOptionBits)" target="_top">handleClose</a></tt></dt>
<dd><p>Controls the open / close behavior of an IOService object (overrideable by subclasses).
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/handleIsOpen/bool/(constIOService*)" target="_top">handleIsOpen</a></tt></dt>
<dd><p>Controls the open / close behavior of an IOService object (overrideable by subclasses).
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/handleOpen/bool/(IOService*,IOOptionBits,void*)" target="_top">handleOpen</a></tt></dt>
<dd><p>Controls the open / close behavior of an IOService object (overrideable by subclasses).
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/initialPowerStateForDomainState/unsignedlong/(IOPMPowerFlags)" target="_top">initialPowerStateForDomainState</a></tt></dt>
<dd><p>Determines which power state a device is in, given the current power domain state.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/clm/IOService/installNotification/IONotifier*/(constOSSymbol*,OSDictionary*,IOServiceNotificationHandler,void*,void*,SInt32,OSIterator**)" target="_top">installNotification</a></tt></dt>
<dd><p>Adds a persistant notification handler to be notified of IOService events.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/isInactive/bool/()" target="_top">isInactive</a></tt></dt>
<dd><p>Checks if the IOService object has been terminated, and is in the process of being destroyed.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/isOpen/bool/(constIOService*)" target="_top">isOpen</a></tt></dt>
<dd><p>Determines whether a specific, or any, client has an IOService object open.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/joinPMtree/void/(IOService*)" target="_top">joinPMtree</a></tt></dt>
<dd><p>Joins the driver into the power plane of the I/O Registry .
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/lockForArbitration/bool/(bool)" target="_top">lockForArbitration</a></tt></dt>
<dd><p>Locks an IOService object against changes in state or ownership.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/makeUsable/IOReturn/()" target="_top">makeUsable</a></tt></dt>
<dd><p>Requests that a device become usable.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/mapDeviceMemoryWithIndex/IOMemoryMap*/(unsignedint,IOOptionBits)" target="_top">mapDeviceMemoryWithIndex</a></tt></dt>
<dd><p>Maps a physical range of a device.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/matchLocation/IOService*/(IOService*)" target="_top">matchLocation</a></tt></dt>
<dd><p>Allows a registered IOService object to direct location matching.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/matchPropertyTable/bool/(OSDictionary*,SInt32*)" target="_top">matchPropertyTable</a></tt></dt>
<dd><p>Allows a registered IOService object to implement family specific matching.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/maxCapabilityForDomainState/unsignedlong/(IOPMPowerFlags)" target="_top">maxCapabilityForDomainState</a></tt></dt>
<dd><p>Determines a driver's highest power state possible for a given power domain state. 
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/message/IOReturn/(UInt32,IOService*,void*)" target="_top">message</a></tt></dt>
<dd><p>Receives a generic message delivered from an attached provider.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/messageClient/IOReturn/(UInt32,OSObject*,void*,vm_size_t)" target="_top">messageClient</a></tt></dt>
<dd><p>Sends a generic message to an attached client.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/messageClients/IOReturn/(UInt32,void*,vm_size_t)" target="_top">messageClients</a></tt></dt>
<dd><p>Sends a generic message to all attached clients.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/clm/IOService/nameMatching/OSDictionary*/(constchar*,OSDictionary*)" target="_top">nameMatching(const char *, OSDictionary *)</a></tt></dt>
<dd><p>Creates a matching dictionary, or adds matching properties to an existing dictionary, that specify an IOService name match.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/clm/IOService/nameMatching/OSDictionary*/(constOSString*,OSDictionary*)" target="_top">nameMatching(const OSString *, OSDictionary *)</a></tt></dt>
<dd><p>Creates a matching dictionary, or adds matching properties to an existing dictionary, that specify an IOService name match.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/newTemperature/IOReturn/(long,IOService*)" target="_top">newTemperature</a></tt></dt>
<dd><p>(Deprecated. Do not use.) Tells a power managed driver that the temperature in the thermal zone has changed.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/newUserClient/IOReturn/(task_t,void*,UInt32,OSDictionary*,IOUserClient**)" target="_top">newUserClient</a></tt></dt>
<dd><p>Creates a connection for a non kernel client.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/nextIdleTimeout/SInt32/(AbsoluteTime,AbsoluteTime,unsignedint)" target="_top">nextIdleTimeout</a></tt></dt>
<dd><p>Allows subclasses to customize idle power management behavior.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/open/bool/(IOService*,IOOptionBits,void*)" target="_top">open</a></tt></dt>
<dd><p>Requests active access to a provider.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/PMinit/void/()" target="_top">PMinit</a></tt></dt>
<dd><p>Initializes power management for a driver.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/PMstop/void/()" target="_top">PMstop</a></tt></dt>
<dd><p>Frees and removes the driver from power management.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/powerChangeDone/void/(unsignedlong)" target="_top">powerChangeDone</a></tt></dt>
<dd>
<p>Tells a driver when a power change is complete.
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/powerDomainDidChangeTo/IOReturn/(IOPMPowerFlags,IOPowerConnection*)" target="_top">powerDomainDidChangeTo</a></tt></dt>
<dd><p>Notifies a driver that its power domain is about to change state.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/powerDomainWillChangeTo/IOReturn/(IOPMPowerFlags,IOPowerConnection*)" target="_top">powerDomainWillChangeTo</a></tt></dt>
<dd><p>Notifies a driver that its power domain is about to change state.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/powerOverrideOffPriv/IOReturn/()" target="_top">powerOverrideOffPriv</a></tt></dt>
<dd>
<p>Allows a driver to disable a power override.
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/powerOverrideOnPriv/IOReturn/()" target="_top">powerOverrideOnPriv</a></tt></dt>
<dd>
<p>Allows a driver to ignore its children's power management requests and only use changePowerStateToPriv to define its own power state.
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/powerStateDidChangeTo/IOReturn/(IOPMPowerFlags,unsignedlong,IOService*)" target="_top">powerStateDidChangeTo</a></tt></dt>
<dd><p>Informs interested parties that a device has changed to a different power state.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/powerStateForDomainState/unsignedlong/(IOPMPowerFlags)" target="_top">powerStateForDomainState</a></tt></dt>
<dd><p>Determines what power state the device would be in for a given power domain state. 
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/powerStateWillChangeTo/IOReturn/(IOPMPowerFlags,unsignedlong,IOService*)" target="_top">powerStateWillChangeTo</a></tt></dt>
<dd><p>Informs interested parties that a device is about to change its power state.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/probe/IOService*/(IOService*,SInt32*)" target="_top">probe</a></tt></dt>
<dd><p>During an IOService object's instantiation, probes a matched service to see if it can be used.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/clm/IOService/propertyMatching/OSDictionary*/(constOSSymbol*,constOSObject*,OSDictionary*)" target="_top">propertyMatching</a></tt></dt>
<dd><p>Creates a matching dictionary, or adds matching properties to an existing dictionary, that specify an IOService phandle match.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/clm/IOService/publishResource/void/(constchar*,OSObject*)" target="_top">publishResource(const char *, OSObject *)</a></tt></dt>
<dd><p>Uses the resource service to publish a property.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/clm/IOService/publishResource/void/(constOSSymbol*,OSObject*)" target="_top">publishResource(const OSSymbol *, OSObject *)</a></tt></dt>
<dd><p>Uses the resource service to publish a property.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/registerInterestedDriver/IOPMPowerFlags/(IOService*)" target="_top">registerInterestedDriver</a></tt></dt>
<dd><p>Allows an IOService object to register interest in the changing power state of a power-managed IOService object.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/registerInterrupt/IOReturn/(int,OSObject*,IOInterruptAction,void*)" target="_top">registerInterrupt</a></tt></dt>
<dd><p>Registers a C function interrupt handler for a device supplying interrupts.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/registerPowerDriver/IOReturn/(IOService*,IOPMPowerState*,unsignedlong)" target="_top">registerPowerDriver</a></tt></dt>
<dd>
<p>Registers a set of power states that the driver supports.
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/registerService/void/(IOOptionBits)" target="_top">registerService</a></tt></dt>
<dd><p>Starts the registration process for a newly discovered IOService object.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/removePowerChild/IOReturn/(IOPowerConnection*)" target="_top">removePowerChild</a></tt></dt>
<dd><p>Informs a power managed driver that one of its power plane childen is disappearing. 
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/requestPowerDomainState/IOReturn/(IOPMPowerFlags,IOPowerConnection*,unsignedlong)" target="_top">requestPowerDomainState</a></tt></dt>
<dd><p>Tells a driver to adjust its power state.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/requestProbe/IOReturn/(IOOptionBits)" target="_top">requestProbe</a></tt></dt>
<dd><p>Requests that hardware be re-scanned for devices.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/requestTerminate/bool/(IOService*,IOOptionBits)" target="_top">requestTerminate</a></tt></dt>
<dd><p>Passes a termination up the stack.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/clm/IOService/resourceMatching/OSDictionary*/(constchar*,OSDictionary*)" target="_top">resourceMatching(const char *, OSDictionary *)</a></tt></dt>
<dd><p>Creates a matching dictionary, or adds matching properties to an existing dictionary, that specify a resource service match.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/clm/IOService/resourceMatching/OSDictionary*/(constOSString*,OSDictionary*)" target="_top">resourceMatching(const OSString *, OSDictionary *)</a></tt></dt>
<dd><p>Creates a matching dictionary, or adds matching properties to an existing dictionary, that specify a resource service match.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/clm/IOService/serviceMatching/OSDictionary*/(constchar*,OSDictionary*)" target="_top">serviceMatching(const char *, OSDictionary *)</a></tt></dt>
<dd><p>Creates a matching dictionary, or adds matching properties to an existing dictionary, that specify an IOService class match.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/clm/IOService/serviceMatching/OSDictionary*/(constOSString*,OSDictionary*)" target="_top">serviceMatching(const OSString *, OSDictionary *)</a></tt></dt>
<dd><p>Creates a matching dictionary, or adds matching properties to an existing dictionary, that specify an IOService class match.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/setAggressiveness/IOReturn/(unsignedlong,unsignedlong)" target="_top">setAggressiveness</a></tt></dt>
<dd>
<p>Broadcasts an aggressiveness factor from the parent of a driver to the driver.
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/setDeviceMemory/void/(OSArray*)" target="_top">setDeviceMemory</a></tt></dt>
<dd><p>Sets the array of IODeviceMemory objects representing a device's memory mapped ranges.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/setIdleTimerPeriod/IOReturn/(unsigned)" target="_top">setIdleTimerPeriod</a></tt></dt>
<dd><p>Sets or changes the idle timer period.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/setPowerParent/IOReturn/(IOPowerConnection*,bool,IOPMPowerFlags)" target="_top">setPowerParent</a></tt></dt>
<dd><p>For internal use only; deprecated; not intended to be called or overridden.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/setPowerState/IOReturn/(unsignedlong,IOService*)" target="_top">setPowerState</a></tt></dt>
<dd>
<p>Requests a power managed driver to change the power state of its device.
</p>
</dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/start/bool/(IOService*)" target="_top">start</a></tt></dt>
<dd><p>During an IOService object's instantiation, starts the IOService object that has been selected to run on the provider.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/stop/void/(IOService*)" target="_top">stop</a></tt></dt>
<dd><p>During an IOService termination, the stop method is called in its clients before they are detached &amp; it is destroyed.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/stringFromReturn/constchar*/(IOReturn)" target="_top">stringFromReturn</a></tt></dt>
<dd><p>Supplies a programmer-friendly string from an IOReturn code.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/systemWake/IOReturn/()" target="_top">systemWake</a></tt></dt>
<dd><p>Tells every driver in the power plane that the system is waking up.  
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/systemWillShutdown/void/(IOOptionBits)" target="_top">systemWillShutdown</a></tt></dt>
<dd><p>Notifies members of the power plane of system shutdown and restart.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/temperatureCriticalForZone/IOReturn/(IOService*)" target="_top">temperatureCriticalForZone</a></tt></dt>
<dd><p>Alerts a driver to a critical temperature in some thermal zone.  
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/temporaryPowerClampOn/IOReturn/()" target="_top">temporaryPowerClampOn</a></tt></dt>
<dd><p>A driver calls this method to hold itself in the highest power state until it has children.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/terminate/bool/(IOOptionBits)" target="_top">terminate</a></tt></dt>
<dd><p>Makes an IOService object inactive and begins its destruction.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/terminateClient/bool/(IOService*,IOOptionBits)" target="_top">terminateClient</a></tt></dt>
<dd><p>Passes a termination up the stack.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/unlockForArbitration/void/()" target="_top">unlockForArbitration</a></tt></dt>
<dd><p>Unlocks an IOService obkect after a successful <a href="index.html#//apple_ref/cpp/instm/IOService/lockForArbitration/bool/(bool)" target="_top">lockForArbitration</a>.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/unregisterInterrupt/IOReturn/(int)" target="_top">unregisterInterrupt</a></tt></dt>
<dd><p>Removes a C function interrupt handler for a device supplying hardware interrupts.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/clm/IOService/waitForService/IOService*/(OSDictionary*,mach_timespec_t*)" target="_top">waitForService</a></tt></dt>
<dd><p>Waits for a matching to service to be published.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/waitQuiet/IOReturn/(mach_timespec_t*)" target="_top">waitQuiet</a></tt></dt>
<dd><p>Waits for an IOService object's <code>busyState</code> to be zero.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/willTerminate/bool/(IOService*,IOOptionBits)" target="_top">willTerminate</a></tt></dt>
<dd><p>Passes a termination up the stack.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOService/youAreRoot/IOReturn/()" target="_top">youAreRoot</a></tt></dt>
<dd><p>Informs the root power domain IOService object that is is the root power domain.
</p></dd>
</dl>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/acknowledgePowerChange/IOReturn/(IOService*);   name=IOService::acknowledgePowerChange --><a name="//apple_ref/cpp/instm/IOService/acknowledgePowerChange/IOReturn/(IOService*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="acknowledgePowerChange">acknowledgePowerChange</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Acknowledges an in-progress power state change.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">acknowledgePowerChange</span><!-- /a --> (
    <a href="index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span><span class="param">whichDriver</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>whichDriver</code></dt>
<dd><p>A pointer to the calling driver. The called object tracks all interested parties to ensure that all have acknowledged the power state change.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --><code>IOPMNoErr</code>. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>When power management informs an interested object (via <a href="index.html#//apple_ref/cpp/instm/IOService/powerStateWillChangeTo/IOReturn/(IOPMPowerFlags,unsignedlong,IOService*)" target="_top">powerStateWillChangeTo</a> or <a href="index.html#//apple_ref/cpp/instm/IOService/powerStateDidChangeTo/IOReturn/(IOPMPowerFlags,unsignedlong,IOService*)" target="_top">powerStateDidChangeTo</a>), the object can return an immediate acknowledgement via a return code, or it may return an indication that it will acknowledge later by calling <code>acknowledgePowerChange</code>. 
</p>
<p>Interested objects are those that have registered as interested drivers, as well as power plane children of the power changing driver. 
</p>
<p>A driver that calls <a href="index.html#//apple_ref/cpp/instm/IOService/registerInterestedDriver/IOPMPowerFlags/(IOService*)" target="_top">registerInterestedDriver</a> must call <code>acknowledgePowerChange</code>, or use an immediate acknowledgement return from <code>powerStateWillChangeTo</code> or <code>powerStateDidChangeTo</code>. 
</p>
<p>Most drivers do not need to override <code>acknowledgePowerChange</code>.
</p>
<!-- end discussion -->
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/acknowledgeSetPowerState/IOReturn/();   name=IOService::acknowledgeSetPowerState --><a name="//apple_ref/cpp/instm/IOService/acknowledgeSetPowerState/IOReturn/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="acknowledgeSetPowerState">acknowledgeSetPowerState</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Acknowledges the belated completion of a driver's <code>setPowerState</code> power state change.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">acknowledgeSetPowerState</span><!-- /a --> (
    <span class="param">void</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --><code>IOPMNoErr</code>.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>After power management instructs a driver to change its state via <a href="index.html#//apple_ref/cpp/instm/IOService/setPowerState/IOReturn/(unsignedlong,IOService*)" target="_top">setPowerState</a>, that driver must acknowledge the change when its device has completed its transition. The acknowledgement may be immediate, via a return code from <code>setPowerState</code>, or delayed, via this call to <code>acknowledgeSetPowerState</code>.
</p>
<p>Any driver that does not return <code>kIOPMAckImplied</code> from its <code>setPowerState</code> implementation must later call <code>acknowledgeSetPowerState</code>. 
</p>
<p>Most drivers do not need to override <code>acknowledgeSetPowerState</code>.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/activityTickle/bool/(unsignedlong,unsignedlong);   name=IOService::activityTickle --><a name="//apple_ref/cpp/instm/IOService/activityTickle/bool/(unsignedlong,unsignedlong)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="activityTickle">activityTickle</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Informs power management when a power-managed device is in use, so that power management can track when it is idle and adjust its power state accordingly.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">activityTickle</span><!-- /a --> ( 
    <span class="keyword">unsigned</span> <!-- a --><span class="type">long</span><!-- /a --> <span class="param">type</span>, 
    <span class="keyword">unsigned</span> <!-- a --><span class="type">long</span><!-- /a --> <!-- a --><span class="type">stateNumber</span><!-- /a -->=<span class="number">0</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>type</code></dt>
<dd><p>When <code>type</code> is <code>kIOPMSubclassPolicy</code>, <code>activityTickle</code> is not handled in IOService and should be intercepted by the subclass. When <code>type</code> is <code>kIOPMSuperclassPolicy1</code>, an activity flag is set and the device state is checked. If the device has been powered down, it is powered up again.</p></dd>
<dt><code>stateNumber</code></dt>
<dd><p>When <code>type</code> is <code>kIOPMSuperclassPolicy1</code>, <code>stateNumber</code> contains the desired power state ordinal for the activity. If the device is in a lower state, the superclass will switch it to this state. This is for devices that can handle some accesses in lower power states; the device is powered up only as far as it needs to be for the activity.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->When <code>type</code> is <code>kIOPMSuperclassPolicy1</code>, the superclass returns <code>true</code> if the device is currently in the state specified by <code>stateNumber</code>. If the device is in a lower state and must be powered up, the superclass returns <code>false</code>; in this case the superclass will initiate a power change to power the device up. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>The <code>activityTickle</code> method is provided for objects in the system (or for the driver itself) to tell a driver that its device is being used.
</p>
<p>The IOService superclass can manage idleness determination with a simple idle timer mechanism and this <code>activityTickle</code> call. To start this up, the driver calls its superclass's <code>setIdleTimerPeriod</code>. This starts a timer for the time interval specified in the call. When the timer expires, the superclass checks to see if there has been any activity since the last timer expiration. (It checks to see if <code>activityTickle</code> has been called). If there has been activity, it restarts the timer, and this process continues. When the timer expires, and there has been no device activity, the superclass lowers the device power state to the next lower state. This can continue until the device is in state zero.
</p>
<p>After the device has been powered down by at least one power state, a subsequent call to <code>activityTickle</code> causes the device to be switched to a higher state required for the activity.
</p>
<p>If the driver is managing the idleness determination totally on its own, the value of the <code>type</code> parameter should be <code>kIOPMSubclassPolicy</code>, and the driver should override the <code>activityTickle</code> method. The superclass IOService implementation of <code>activityTickle</code> does nothing with the <code>kIOPMSubclassPolicy</code> argument.
</p>
<!-- end discussion -->
<p></p>
<hr>
<!-- headerDoc=clm;  uid=//apple_ref/cpp/clm/IOService/addLocation/OSDictionary*/(OSDictionary*);   name=IOService::addLocation --><a name="//apple_ref/cpp/clm/IOService/addLocation/OSDictionary*/(OSDictionary*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="addLocation">addLocation</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Adds a location matching property to an existing dictionary.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">static</span> <a href="../../../OSDictionary_h/Classes/OSDictionary/index.html#//apple_ref/cpp/cl/OSDictionary" target="_top" class="type"><span class="type">OSDictionary</span></a> <span class="type">*</span> <!-- a --><span class="function">addLocation</span><!-- /a -->(
    <a href="../../../OSDictionary_h/Classes/OSDictionary/index.html#//apple_ref/cpp/cl/OSDictionary" target="_top" class="type"><span class="type">OSDictionary</span></a> <span class="type">*</span><span class="param">table</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>table</code></dt>
<dd><p>The matching properties are added to the specified dictionary, which must be non-zero.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->The location matching dictionary created is returned on success, or zero on failure. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This function creates matching properties that specify the location of a IOService object, as an embedded matching dictionary. This matching will be successful on an IOService object that attached to an IOService object which matches this location matching dictionary.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=clm;  uid=//apple_ref/cpp/clm/IOService/addNotification/IONotifier*/(constOSSymbol*,OSDictionary*,IOServiceNotificationHandler,void*,void*,SInt32);   name=IOService::addNotification --><a name="//apple_ref/cpp/clm/IOService/addNotification/IONotifier*/(constOSSymbol*,OSDictionary*,IOServiceNotificationHandler,void*,void*,SInt32)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="addNotification">addNotification</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Adds a persistant notification handler to be notified of IOService events.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">static</span> <a href="../../../IONotifier_h/Classes/IONotifier/index.html#//apple_ref/cpp/cl/IONotifier" target="_top" class="type"><span class="type">IONotifier</span></a> <span class="type">*</span> <!-- a --><span class="function">addNotification</span><!-- /a -->( 
    <span class="keyword">const</span> <!-- a --><span class="var">OSSymbol</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">type</span><!-- /a -->,
    <!-- a --><span class="var">OSDictionary</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">matching</span><!-- /a -->, 
    <!-- a --><span class="var">IOServiceNotificationHandler</span><!-- /a --> <!-- a --><span class="var">handler</span><!-- /a -->, 
    <!-- a --><span class="var">void</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">target</span><!-- /a -->,
    <!-- a --><span class="var">void</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">ref</span><!-- /a --> = <span class="number">0</span>, 
    <!-- a --><span class="type">SInt32</span><!-- /a --> <!-- a --><span class="type">priority</span><!-- /a --> = <span class="number">0</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>type</code></dt>
<dd><p>An OSSymbol identifying the type of notification and IOService state:
<br><code>gIOPublishNotification</code> Delivered when an IOService object is registered.
<br><code>gIOFirstPublishNotification</code> Delivered when an IOService object is registered, but only once per IOService instance. Some IOService objects may be reregistered when their state is changed.
<br><code>gIOMatchedNotification</code> Delivered when an IOService object has been matched with all client drivers, and they have been probed and started.
<br><code>gIOFirstMatchNotification</code> Delivered when an IOService object has been matched with all client drivers, but only once per IOService instance. Some IOService objects may be reregistered when their state is changed.
<br><code>gIOTerminatedNotification</code> Delivered after an IOService object has been terminated, during its finalize stage.</p></dd>
<dt><code>matching</code></dt>
<dd><p>A matching dictionary to restrict notifications to only matching IOService objects. The dictionary will be released when the notification is removed, consuming the passed-in reference.</p></dd>
<dt><code>handler</code></dt>
<dd><p>A C function callback to deliver notifications.</p></dd>
<dt><code>target</code></dt>
<dd><p>An instance reference for the callback's use.</p></dd>
<dt><code>ref</code></dt>
<dd><p>A reference constant for the callback's use.</p></dd>
<dt><code>priority</code></dt>
<dd><p>A constant ordering all notifications of a each type.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->An instance of an IONotifier object that can be used to control or destroy the notification request. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOService will deliver notifications of changes in state of an IOService object to registered clients. The type of notification is specified by a symbol, for example <code>gIOMatchedNotification</code> or <code>gIOTerminatedNotification</code>, and notifications will only include IOService objects that match the supplied matching dictionary. Notifications are ordered by a priority set with <code>addNotification</code>. When the notification is installed, its handler will be called with each of any currently existing IOService objects that are in the correct state (eg. registered) and match the supplied matching dictionary, avoiding races between finding preexisting and new IOService events. The notification request is identified by an instance of an IONotifier object, through which it can be enabled, disabled, or removed. <code>addNotification</code> consumes a retain count on the matching dictionary when the notification is removed.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/addPowerChild/IOReturn/(IOService*);   name=IOService::addPowerChild --><a name="//apple_ref/cpp/instm/IOService/addPowerChild/IOReturn/(IOService*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="addPowerChild">addPowerChild</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Informs a driver that it has a new child. 
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">addPowerChild</span><!-- /a --> (
    <a href="index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span><span class="param">theChild</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>theChild</code></dt>
<dd><p>A pointer to the child IOService object.</p></dd>
</dl>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>The Platform Expert uses this method to call a driver and introduce it to a new child.
</p>
<p>This call is handled internally by power management. It is not intended to be overridden or called by drivers.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/adjustBusy/void/(SInt32);   name=IOService::adjustBusy --><a name="//apple_ref/cpp/instm/IOService/adjustBusy/void/(SInt32)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="adjustBusy">adjustBusy</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Adjusts the <code>busyState</code> of an IOService object.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <!-- a --><span class="function">adjustBusy</span><!-- /a -->(
    <!-- a --><span class="type">SInt32</span><!-- /a --> <span class="param">delta</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>delta</code></dt>
<dd><p>The delta to be applied to the IOService object's <code>busyState</code>.</p></dd>
</dl>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Applies a delta to an IOService object's <code>busyState</code>. A change in the <code>busyState</code> to or from zero will change the IOService object's provider's <code>busyState</code> by one (in the same direction). 
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/attach/bool/(IOService*);   name=IOService::attach --><a name="//apple_ref/cpp/instm/IOService/attach/bool/(IOService*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="attach">attach</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Attaches an IOService client to a provider in the I/O Registry.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">attach</span><!-- /a -->(
    <a href="index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span><span class="param">provider</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>provider</code></dt>
<dd><p>The IOService object which will serve as this object's provider.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --><code>false</code> if the provider is inactive or on a resource failure; otherwise <code>true</code>. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This function called in an IOService client enters the client into the I/O Registry as a child of the provider in the service plane. The provider must be active or the attach will fail. Multiple attach calls to the same provider are no-ops and return success. A client may be attached to multiple providers. Entering an object into the I/O Registry retains both the client and provider until they are detached.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/callPlatformFunction/IOReturn/(constOSSymbol*,bool,void*,void*,void*,void*);   name=IOService::callPlatformFunction --><a name="//apple_ref/cpp/instm/IOService/callPlatformFunction/IOReturn/(constOSSymbol*,bool,void*,void*,void*,void*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="callPlatformFunction">callPlatformFunction</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Calls the platform function with the given name.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">callPlatformFunction</span><!-- /a -->(
    <span class="keyword">const</span> <!-- a --><span class="var">OSSymbol</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">functionName</span><!-- /a -->, 
    <!-- a --><span class="var">bool</span><!-- /a --> <!-- a --><span class="var">waitForFunction</span><!-- /a -->, 
    <!-- a --><span class="var">void</span><!-- /a --> <span class="var">*</span><!-- a --><span class="var">param1</span><!-- /a -->,
    <!-- a --><span class="var">void</span><!-- /a --> <span class="var">*</span><!-- a --><span class="var">param2</span><!-- /a -->, 
    <!-- a --><span class="var">void</span><!-- /a --> <span class="var">*</span><!-- a --><span class="var">param3</span><!-- /a -->,
    <!-- a --><span class="var">void</span><!-- /a --> <span class="var">*</span><!-- a --><span class="var">param4</span><!-- /a --> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>functionName</code></dt>
<dd><p>Name of the function to be called. When <code>functionName</code> is a C string, <code>callPlatformFunction</code> converts the C string to an OSSymbol and calls the OSSymbol version of <code>callPlatformFunction</code>. This process can block and should not be used from an interrupt context.</p></dd>
<dt><code>waitForFunction</code></dt>
<dd><p>If <code>true</code>, <code>callPlatformFunction</code> will not return until the function has been called.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->An IOReturn code; <code>kIOReturnSuccess</code> if the function was successfully executed, <code>kIOReturnUnsupported</code> if a service to execute the function could not be found. Other return codes may be returned by the function.
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>The platform expert or other drivers may implement various functions to control hardware features.  <code>callPlatformFunction</code> allows any IOService object to access these functions. Normally <code>callPlatformFunction</code> is called on a service's provider. The provider services the request or passes it to its provider. The system's IOPlatformExpert subclass catches functions it knows about and redirects them into other parts of the service plane. If the IOPlatformExpert subclass cannot execute the function, the base class is called. The IOPlatformExpert base class attempts to find a service to execute the function by looking up the function name in an IOResources name space. A service may publish a service using <code>publishResource(functionName, this)</code>. If no service can be found to execute the function an error is returned.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/causeInterrupt/IOReturn/(int);   name=IOService::causeInterrupt --><a name="//apple_ref/cpp/instm/IOService/causeInterrupt/IOReturn/(int)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="causeInterrupt">causeInterrupt</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Causes a device interrupt to occur.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">causeInterrupt</span><!-- /a -->(
    <!-- a --><span class="type">int</span><!-- /a --> <span class="param">source</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>source</code></dt>
<dd><p>The index of the interrupt source in the device.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->An IOReturn code (<code>kIOReturnNoInterrupt</code> is returned if the source is not valid). 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Emulates a hardware interrupt, to be called from task level.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/changePowerStateTo/IOReturn/(unsignedlong);   name=IOService::changePowerStateTo --><a name="//apple_ref/cpp/instm/IOService/changePowerStateTo/IOReturn/(unsignedlong)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="changePowerStateTo">changePowerStateTo</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Sets a driver's power state.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">changePowerStateTo</span><!-- /a --> (
    <span class="keyword">unsigned</span> <!-- a --><span class="type">long</span><!-- /a --> <span class="param">ordinal</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>ordinal</code></dt>
<dd><p>The number of the desired power state in the power state array.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->A return code that can be ignored by the caller. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This function is one of several that are used to set a driver's power state. In most circumstances, however, you should call <a href="index.html#//apple_ref/cpp/instm/IOService/changePowerStateToPriv/IOReturn/(unsignedlong)" target="_top">changePowerStateToPriv</a> instead. 
</p>
<p>Calls to <code>changePowerStateTo</code>, <code>changePowerStateToPriv</code>, and a driver's power children all affect the power state of a driver. For legacy design reasons, they have overlapping functionality. Although you should call <code>changePowerStateToPriv</code> to change your device's power state, you might need to call <code>changePowerStateTo</code> in the following circumstances:
</p>
<ul>
<li>If a driver will be using <code>changePowerStateToPriv</code> to change its power state, it should call <code>changePowerStateTo(0)</code> in its <code>start</code> routine to eliminate the influence <code>changePowerStateTo</code> has on power state calculations.

</li>
<li>Call <code>changePowerStateTo</code> in conjunction with <a href="index.html#//apple_ref/cpp/instm/IOService/setIdleTimerPeriod/IOReturn/(unsigned)" target="_top">setIdleTimerPeriod</a> and <a href="index.html#//apple_ref/cpp/instm/IOService/activityTickle/bool/(unsignedlong,unsignedlong)" target="_top">activityTickle</a> to idle a driver into a low power state. For a driver with 3 power states, for example, <code>changePowerStateTo(1)</code> sets a minimum level of power state 1, such that the idle timer period may not set your device's power any lower than state 1.</li>
</ul>
<!-- end discussion --><p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/changePowerStateToPriv/IOReturn/(unsignedlong);   name=IOService::changePowerStateToPriv --><a name="//apple_ref/cpp/instm/IOService/changePowerStateToPriv/IOReturn/(unsignedlong)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="changePowerStateToPriv">changePowerStateToPriv</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Tells a driver's superclass to change the power state of its device.
<!-- end abstract --></p>
<p></p>
<pre><tt>protected</tt>
<br><a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">changePowerStateToPriv</span><!-- /a --> (
    <span class="keyword">unsigned</span> <!-- a --><span class="type">long</span><!-- /a --> <span class="param">ordinal</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>ordinal</code></dt>
<dd><p>The number of the desired power state in the power state array.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->A return code that can be ignored by the caller. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>A driver uses this method to tell its superclass to change the power state of the device. This is the recommended way to change the power state of a device. 
</p>
<p>Three things affect driver power state: <a href="index.html#//apple_ref/cpp/instm/IOService/changePowerStateTo/IOReturn/(unsignedlong)" target="_top">changePowerStateTo</a>, <code>changePowerStateToPriv</code>, and the desires of the driver's power plane children. Power management puts the device into the maximum state governed by those three entities. 
</p>
<p>Drivers may eliminate the influence of the <code>changePowerStateTo</code> method on power state one of two ways. See <a href="index.html#//apple_ref/cpp/instm/IOService/powerOverrideOnPriv/IOReturn/()" target="_top">powerOverrideOnPriv</a> to ignore the method's influence, or call <code>changePowerStateTo(0)</code> in the driver's <code>start</code> routine to remove the <code>changePowerStateTo</code> method's power request.
</p>
<!-- end discussion -->
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/clampPowerOn/void/(unsignedlong);   name=IOService::clampPowerOn --><a name="//apple_ref/cpp/instm/IOService/clampPowerOn/void/(unsignedlong)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="clampPowerOn">clampPowerOn</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Deprecated. Do not use.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <!-- a --><span class="function">clampPowerOn</span><!-- /a --> (
    <span class="keyword">unsigned</span> <!-- a --><span class="type">long</span><!-- /a --> <span class="param">duration</span>); </pre>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/close/void/(IOService*,IOOptionBits);   name=IOService::close --><a name="//apple_ref/cpp/instm/IOService/close/void/(IOService*,IOOptionBits)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="close">close</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Releases active access to a provider.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <!-- a --><span class="function">close</span><!-- /a -->(
    <a href="index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span><span class="param">forClient</span>, 
    <a href="../../../USB_h/index.html#//apple_ref/c/tag/IOOptionBits" target="_top" class="type"><span class="type">IOOptionBits</span></a> <!-- a --><span class="type">options</span><!-- /a --> = <span class="number">0</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>forClient</code></dt>
<dd><p>Designates the client of the provider requesting the close.</p></dd>
<dt><code>options</code></dt>
<dd><p>Options available for the close. The provider family may implement options for close; IOService defines none.</p></dd>
<dt><code>arg</code></dt>
<dd><p>Family specific arguments which are ignored by IOService.</p></dd>
</dl>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOService provides generic open and close semantics to track clients of a provider that have established an active datapath. The use of <a href="index.html#//apple_ref/cpp/instm/IOService/open/bool/(IOService*,IOOptionBits,void*)" target="_top">open</a> and <code>close</code>, and rules regarding ownership are family defined, and defined by the <a href="index.html#//apple_ref/cpp/instm/IOService/handleOpen/bool/(IOService*,IOOptionBits,void*)" target="_top">handleOpen</a> and <a href="index.html#//apple_ref/cpp/instm/IOService/handleClose/void/(IOService*,IOOptionBits)" target="_top">handleClose</a> methods in the provider.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/compareProperties/bool/(OSDictionary*,OSCollection*);   name=IOService::compareProperties --><a name="//apple_ref/cpp/instm/IOService/compareProperties/bool/(OSDictionary*,OSCollection*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="compareProperties">compareProperties</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Compares a set of properties in a matching dictionary with an IOService object's property table.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">compareProperties</span><!-- /a -->(
    <a href="../../../OSDictionary_h/Classes/OSDictionary/index.html#//apple_ref/cpp/cl/OSDictionary" target="_top" class="type"><span class="type">OSDictionary</span></a> <span class="type">*</span><span class="param">matching</span>, 
    <a href="../../../OSCollection_h/Classes/OSCollection/index.html#//apple_ref/cpp/cl/OSCollection" target="_top" class="type"><span class="type">OSCollection</span></a> <span class="type">*</span><span class="param">keys</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>matching</code></dt>
<dd><p>The matching dictionary, which must be non-zero.</p></dd>
<dt><code>keys</code></dt>
<dd><p>A collection (eg. OSSet, OSArray, OSDictionary) which should contain OSStrings (or OSSymbols) that specify the property keys to be compared.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Success if <code>compareProperty</code> returns <code>true</code> for each key in the collection; otherwise failure. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This is a helper function to aid in implementing <a href="index.html#//apple_ref/cpp/instm/IOService/matchPropertyTable/bool/(OSDictionary*,SInt32*)" target="_top">matchPropertyTable</a>. A collection of dictionary keys specifies properties in a matching dictionary to be compared, with <code>compareProperty</code>, with an IOService object's property table, if <code>compareProperty</code> returns <code>true</code> for each key, success is returned; otherwise failure.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/compareProperty/bool/(OSDictionary*,constchar*);   name=IOService::compareProperty --><a name="//apple_ref/cpp/instm/IOService/compareProperty/bool/(OSDictionary*,constchar*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="compareProperty(OSDictionary*,constchar*)">compareProperty(OSDictionary *, const char *)</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Compares a property in a matching dictionary with an IOService object's property table.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">compareProperty</span><!-- /a -->(
    <a href="../../../OSDictionary_h/Classes/OSDictionary/index.html#//apple_ref/cpp/cl/OSDictionary" target="_top" class="type"><span class="type">OSDictionary</span></a> <span class="type">*</span><span class="param">matching</span>, 
    <span class="keyword">const</span> <!-- a --><span class="var">char</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">key</span><!-- /a --> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>matching</code></dt>
<dd><p>The matching dictionary, which must be non-zero.</p></dd>
<dt><code>key</code></dt>
<dd><p>The dictionary key specifying the property to be compared, as a C string.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --><code>true</code> if the property does not exist in the matching table. If the property exists in the matching dictionary but not the IOService property table, failure is returned. Otherwise the result of calling the property from the matching dictionary's <code>isEqualTo</code> method with the IOService property as an argument is returned. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This is a helper function to aid in implementing <a href="index.html#//apple_ref/cpp/instm/IOService/matchPropertyTable/bool/(OSDictionary*,SInt32*)" target="_top">matchPropertyTable</a>. If the property specified by <code>key</code> exists in the matching dictionary, it is compared with a property of the same name in the IOService object's property table. The comparison is performed with the <code>isEqualTo</code> method. If the property does not exist in the matching table, success is returned. If the property exists in the matching dictionary but not the IOService property table, failure is returned.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/compareProperty/bool/(OSDictionary*,constOSString*);   name=IOService::compareProperty --><a name="//apple_ref/cpp/instm/IOService/compareProperty/bool/(OSDictionary*,constOSString*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="compareProperty(OSDictionary*,constOSString*)">compareProperty(OSDictionary *, const OSString *)</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Compares a property in a matching dictionary with an IOService object's property table.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">compareProperty</span><!-- /a -->(
    <a href="../../../OSDictionary_h/Classes/OSDictionary/index.html#//apple_ref/cpp/cl/OSDictionary" target="_top" class="type"><span class="type">OSDictionary</span></a> <span class="type">*</span><span class="param">matching</span>, 
    <span class="keyword">const</span> <!-- a --><span class="var">OSString</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">key</span><!-- /a --> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>matching</code></dt>
<dd><p>The matching dictionary, which must be non-zero.</p></dd>
<dt><code>key</code></dt>
<dd><p>The dictionary key specifying the property to be compared, as an OSString (which includes OSSymbol).</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --><code>true</code> if the property does not exist in the matching table. If the property exists in the matching dictionary but not the IOService property table, failure is returned. Otherwise the result of calling the property from the matching dictionary's <code>isEqualTo</code> method with the IOService property as an argument is returned. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This is a helper function to aid in implementing <a href="index.html#//apple_ref/cpp/instm/IOService/matchPropertyTable/bool/(OSDictionary*,SInt32*)" target="_top">matchPropertyTable</a>. If the property specified by <code>key</code> exists in the matching dictionary, it is compared with a property of the same name in the IOService object's property table. The comparison is performed with the <code>isEqualTo</code> method. If the property does not exist in the matching table, success is returned. If the property exists in the matching dictionary but not the IOService property table, failure is returned.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/currentCapability/IOPMPowerFlags/();   name=IOService::currentCapability --><a name="//apple_ref/cpp/instm/IOService/currentCapability/IOPMPowerFlags/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="currentCapability">currentCapability</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Finds out the capability of a device's current power state.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOPM_h/index.html#//apple_ref/c/tdef/IOPMPowerFlags" target="_top" class="type"><span class="type">IOPMPowerFlags</span></a> <!-- a --><span class="function">currentCapability</span><!-- /a --> (
    <span class="param">void</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->A copy of the <code>capabilityFlags</code> field for the current power state in the power state array. 

<!-- end return value --></p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/currentPowerConsumption/unsignedlong/();   name=IOService::currentPowerConsumption --><a name="//apple_ref/cpp/instm/IOService/currentPowerConsumption/unsignedlong/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="currentPowerConsumption">currentPowerConsumption</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Finds out the current power consumption of a device.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <span class="keyword">unsigned</span> <!-- a --><span class="type">long</span><!-- /a --> <!-- a --><span class="function">currentPowerConsumption</span><!-- /a --> (
    <span class="param">void</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->A copy of the <code>staticPower</code> field for the current power state in the power state array. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Most Mac OS X power managed drivers do not report their power consumption via the <code>staticPower</code> field. Thus this call will not accurately reflect power consumption for most drivers.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/deRegisterInterestedDriver/IOReturn/(IOService*);   name=IOService::deRegisterInterestedDriver --><a name="//apple_ref/cpp/instm/IOService/deRegisterInterestedDriver/IOReturn/(IOService*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="deRegisterInterestedDriver">deRegisterInterestedDriver</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>De-registers power state interest from a previous call to <code>registerInterestedDriver</code>.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">deRegisterInterestedDriver</span><!-- /a --> (
    <a href="index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span><span class="param">theDriver</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>theDriver</code></dt>
<dd><p>The interested driver previously passed into <a href="index.html#//apple_ref/cpp/instm/IOService/registerInterestedDriver/IOPMPowerFlags/(IOService*)" target="_top">registerInterestedDriver</a>.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->A return code that can be ignored by the caller.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Most drivers do not need to override <code>deRegisterInterestedDriver</code>.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/detach/void/(IOService*);   name=IOService::detach --><a name="//apple_ref/cpp/instm/IOService/detach/void/(IOService*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="detach">detach</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Detaches an IOService client from a provider in the I/O Registry.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <!-- a --><span class="function">detach</span><!-- /a -->(
    <a href="index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span><span class="param">provider</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>provider</code></dt>
<dd><p>The IOService object to detach from.</p></dd>
</dl>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This function called in an IOService client removes the client as a child of the provider in the service plane of the I/O Registry. If the provider is not a parent of the client this is a no-op, otherwise the I/O Registry releases both the client and provider.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/didTerminate/bool/(IOService*,IOOptionBits,bool*);   name=IOService::didTerminate --><a name="//apple_ref/cpp/instm/IOService/didTerminate/bool/(IOService*,IOOptionBits,bool*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="didTerminate">didTerminate</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Passes a termination up the stack.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">didTerminate</span><!-- /a -->(
    <a href="index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span><span class="param">provider</span>,
    <a href="../../../USB_h/index.html#//apple_ref/c/tag/IOOptionBits" target="_top" class="type"><span class="type">IOOptionBits</span></a> <span class="param">options</span>,
    <!-- a --><span class="type">bool</span><!-- /a --> <span class="type">*</span><span class="param">defer</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>provider</code></dt>
<dd><p>The terminated provider of this object.</p></dd>
<dt><code>options</code></dt>
<dd><p>Options originally passed to terminate.</p></dd>
<dt><code>defer</code></dt>
<dd><p>If there is pending I/O that requires this object to persist, and the provider is not opened by this object set <code>defer</code> to <code>true</code> and call the <code>IOService::didTerminate()</code> implementation when the I/O completes. Otherwise, leave <code>defer</code> set to its default value of <code>false</code>.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --><code>true</code>. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Notification that a provider has been terminated, sent after recursing up the stack, in leaf-to-root order.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/didYouWakeSystem/bool/();   name=IOService::didYouWakeSystem --><a name="//apple_ref/cpp/instm/IOService/didYouWakeSystem/bool/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="didYouWakeSystem">didYouWakeSystem</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Asks a driver if its device is the one that just woke the system from sleep. 
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">didYouWakeSystem</span><!-- /a --> (
    <span class="param">void</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --><code>true</code> if the driver's device did wake the system and <code>false</code> if it didn't. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Power management calls a power managed driver with this method to ask if its device is the one that just woke the system from sleep. If a device is capable of waking the system from sleep, its driver should implement <code>didYouWakeSystem</code> and return <code>true</code> if its device was responsible for waking the system.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/disableInterrupt/IOReturn/(int);   name=IOService::disableInterrupt --><a name="//apple_ref/cpp/instm/IOService/disableInterrupt/IOReturn/(int)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="disableInterrupt">disableInterrupt</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Synchronously disables a device interrupt.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">disableInterrupt</span><!-- /a -->(
    <!-- a --><span class="type">int</span><!-- /a --> <span class="param">source</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>source</code></dt>
<dd><p>The index of the interrupt source in the device.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->An IOReturn code (<code>kIOReturnNoInterrupt</code> is returned if the source is not valid). 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>If the interrupt routine is running, the call will block until the routine completes. It is the caller's responsiblity to keep track of the enable state of the interrupt source.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/enableInterrupt/IOReturn/(int);   name=IOService::enableInterrupt --><a name="//apple_ref/cpp/instm/IOService/enableInterrupt/IOReturn/(int)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="enableInterrupt">enableInterrupt</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Enables a device interrupt.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">enableInterrupt</span><!-- /a -->(
    <!-- a --><span class="type">int</span><!-- /a --> <span class="param">source</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>source</code></dt>
<dd><p>The index of the interrupt source in the device.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->An IOReturn code (<code>kIOReturnNoInterrupt</code> is returned if the source is not valid). 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>It is the caller's responsiblity to keep track of the enable state of the interrupt source.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/errnoFromReturn/int/(IOReturn);   name=IOService::errnoFromReturn --><a name="//apple_ref/cpp/instm/IOService/errnoFromReturn/int/(IOReturn)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="errnoFromReturn">errnoFromReturn</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Translates an IOReturn code to a BSD <code>errno</code>.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">int</span><!-- /a --> <!-- a --><span class="function">errnoFromReturn</span><!-- /a -->(
    <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <span class="param">rtn</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>rtn</code></dt>
<dd><p>The IOReturn code.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->The BSD <code>errno</code> or <code>EIO</code> if unknown. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>BSD defines its own return codes for its functions in <code>sys/errno.h</code>, and I/O Kit families may need to supply compliant results in BSD shims. Results are available for the standard return codes in <code>IOReturn.h</code> in IOService, while subclasses may implement this method to interpret family dependent return codes.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/finalize/bool/(IOOptionBits);   name=IOService::finalize --><a name="//apple_ref/cpp/instm/IOService/finalize/bool/(IOOptionBits)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="finalize">finalize</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Finalizes the destruction of an IOService object.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">finalize</span><!-- /a -->(
    <a href="../../../USB_h/index.html#//apple_ref/c/tag/IOOptionBits" target="_top" class="type"><span class="type">IOOptionBits</span></a> <span class="param">options</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>options</code></dt>
<dd><p>The options passed to the <a href="index.html#//apple_ref/cpp/instm/IOService/terminate/bool/(IOOptionBits)" target="_top">terminate</a> method of the IOService object are passed on to <code>finalize</code>.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --><code>true</code>. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>The <code>finalize</code> method is called in an inactive (ie. terminated) IOService object after the last client has detached. IOService's implementation will call <a href="index.html#//apple_ref/cpp/instm/IOService/stop/void/(IOService*)" target="_top">stop</a>, <a href="index.html#//apple_ref/cpp/instm/IOService/close/void/(IOService*,IOOptionBits)" target="_top">close</a>, and <a href="index.html#//apple_ref/cpp/instm/IOService/detach/void/(IOService*)" target="_top">detach</a> on each provider. When <code>finalize</code> returns, the object's retain count will have no references generated by IOService's registration process.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/free/void/();   name=IOService::free --><a name="//apple_ref/cpp/instm/IOService/free/void/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="free">free</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Frees data structures that were allocated when power management was initialized on this service. <!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <!-- a --><span class="function">free</span><!-- /a -->(
    <span class="param">void</span> ); </pre>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/getAggressiveness/IOReturn/(unsignedlong,unsignedlong*);   name=IOService::getAggressiveness --><a name="//apple_ref/cpp/instm/IOService/getAggressiveness/IOReturn/(unsignedlong,unsignedlong*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getAggressiveness">getAggressiveness</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Returns the current aggressiveness value for the given type. 
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">getAggressiveness</span><!-- /a --> ( 
    <span class="keyword">unsigned</span> <!-- a --><span class="type">long</span><!-- /a --> <span class="param">type</span>, 
    <span class="keyword">unsigned</span> <!-- a --><span class="type">long</span><!-- /a --> <span class="type">*</span><span class="param">currentLevel</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>type</code></dt>
<dd><p>The aggressiveness factor to query.</p></dd>
<dt><code>currentLevel</code></dt>
<dd><p>Upon successful return, contains the value of aggressiveness factor <code>type</code>.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --><code>kIOReturnSuccess</code> upon success; an I/O Kit error code otherwise.

<!-- end return value --></p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/getBusyState/UInt32/();   name=IOService::getBusyState --><a name="//apple_ref/cpp/instm/IOService/getBusyState/UInt32/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getBusyState">getBusyState</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Returns the <code>busyState</code> of an IOService object.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">UInt32</span><!-- /a --> <!-- a --><span class="function">getBusyState</span><!-- /a -->(
    <span class="param">void</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->The <code>busyState</code> value. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Many activities in IOService are asynchronous. When registration, matching, or termination is in progress on an IOService object, its <code>busyState</code> is increased by one. Change in <code>busyState</code> to or from zero also changes the IOService object's provider's <code>busyState</code> by one, which means that an IOService object is marked busy when any of the above activities is ocurring on it or any of its clients.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/getClient/IOService*/();   name=IOService::getClient --><a name="//apple_ref/cpp/instm/IOService/getClient/IOService*/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getClient">getClient</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Returns an IOService object's primary client.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span> <!-- a --><span class="function">getClient</span><!-- /a -->(
    <span class="param">void</span> ) <span class="keyword">const</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->The first client of the provider, or zero if the IOService object is not attached into the I/O Registry. The client is retained while it is attached, and should not be released by the caller. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This function called in an IOService provider will return the first client to attach to it. For IOService objects which have only only one client, this may be a useful simplification.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/getClientIterator/OSIterator*/();   name=IOService::getClientIterator --><a name="//apple_ref/cpp/instm/IOService/getClientIterator/OSIterator*/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getClientIterator">getClientIterator</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Returns an iterator over an IOService object's clients.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../OSIterator_h/Classes/OSIterator/index.html#//apple_ref/cpp/cl/OSIterator" target="_top" class="type"><span class="type">OSIterator</span></a> <span class="type">*</span> <!-- a --><span class="function">getClientIterator</span><!-- /a -->(
    <span class="param">void</span> ) <span class="keyword">const</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->An iterator over the clients of the provider, or zero if there is a resource failure. The iterator must be released when the iteration is finished. All objects returned by the iteration are retained while the iterator is valid, though they may no longer be attached during the iteration. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>For IOService objects that may have multiple clients, this method supplies an iterator over a provider's clients. 
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/getDeviceMemory/OSArray*/();   name=IOService::getDeviceMemory --><a name="//apple_ref/cpp/instm/IOService/getDeviceMemory/OSArray*/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getDeviceMemory">getDeviceMemory</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Returns the array of IODeviceMemory objects representing a device's memory mapped ranges.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../OSArray_h/Classes/OSArray/index.html#//apple_ref/cpp/cl/OSArray" target="_top" class="type"><span class="type">OSArray</span></a> <span class="type">*</span> <!-- a --><span class="function">getDeviceMemory</span><!-- /a -->(
    <span class="param">void</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->An OSArray of IODeviceMemory objects, or zero if none are available. The array is retained by the provider, so is valid while attached. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method returns an array of IODeviceMemory objects representing the physical memory ranges allocated to a memory mapped device.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/getDeviceMemoryCount/IOItemCount/();   name=IOService::getDeviceMemoryCount --><a name="//apple_ref/cpp/instm/IOService/getDeviceMemoryCount/IOItemCount/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getDeviceMemoryCount">getDeviceMemoryCount</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Returns a count of the physical memory ranges available for a device.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">IOItemCount</span><!-- /a --> <!-- a --><span class="function">getDeviceMemoryCount</span><!-- /a -->(
    <span class="param">void</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->An integer count of the number of ranges available. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method returns the count of physical memory ranges, each represented by an IODeviceMemory instance, that have been allocated for a memory mapped device.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/getDeviceMemoryWithIndex/IODeviceMemory*/(unsignedint);   name=IOService::getDeviceMemoryWithIndex --><a name="//apple_ref/cpp/instm/IOService/getDeviceMemoryWithIndex/IODeviceMemory*/(unsignedint)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getDeviceMemoryWithIndex">getDeviceMemoryWithIndex</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Returns an instance of IODeviceMemory representing one of a device's memory mapped ranges.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IODeviceMemory_h/Classes/IODeviceMemory/index.html#//apple_ref/cpp/cl/IODeviceMemory" target="_top" class="type"><span class="type">IODeviceMemory</span></a> <span class="type">*</span> <!-- a --><span class="function">getDeviceMemoryWithIndex</span><!-- /a -->(
    <span class="keyword">unsigned</span> <!-- a --><span class="type">int</span><!-- /a --> <span class="param">index</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>index</code></dt>
<dd><p>An index into the array of ranges assigned to the device.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->A pointer to an instance of IODeviceMemory, or zero if the index is beyond the count available. The IODeviceMemory is retained by the provider, so is valid while attached, or while any mappings to it exist. It should not be released by the caller. See also <a href="index.html#//apple_ref/cpp/instm/IOService/mapDeviceMemoryWithIndex/IOMemoryMap*/(unsignedint,IOOptionBits)" target="_top">mapDeviceMemoryWithIndex</a>, which creates a device memory mapping. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method returns a pointer to an instance of IODeviceMemory for the physical memory range at the given index for a memory mapped device.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/getInterruptType/IOReturn/(int,int*);   name=IOService::getInterruptType --><a name="//apple_ref/cpp/instm/IOService/getInterruptType/IOReturn/(int,int*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getInterruptType">getInterruptType</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Returns the type of interrupt used for a device supplying hardware interrupts.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">getInterruptType</span><!-- /a -->(
    <!-- a --><span class="type">int</span><!-- /a --> <span class="param">source</span>,
    <!-- a --><span class="type">int</span><!-- /a --> <span class="type">*</span><span class="param">interruptType</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>source</code></dt>
<dd><p>The index of the interrupt source in the device.</p></dd>
<dt><code>interruptType</code></dt>
<dd><p>The interrupt type for the interrupt source will be stored here by <code>getInterruptType</code>.<br><code>kIOInterruptTypeEdge</code> will be returned for edge-trigggered sources.<br><code>kIOInterruptTypeLevel</code> will be returned for level-trigggered sources.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->An IOReturn code (<code>kIOReturnNoInterrupt</code> is returned if the source is not valid). 
<!-- end return value --></p>
<p></p>
<hr>
<!-- headerDoc=clm;  uid=//apple_ref/cpp/clm/IOService/getMatchingServices/OSIterator*/(OSDictionary*);   name=IOService::getMatchingServices --><a name="//apple_ref/cpp/clm/IOService/getMatchingServices/OSIterator*/(OSDictionary*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getMatchingServices">getMatchingServices</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Finds the set of current published IOService objects matching a matching dictionary.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">static</span> <a href="../../../OSIterator_h/Classes/OSIterator/index.html#//apple_ref/cpp/cl/OSIterator" target="_top" class="type"><span class="type">OSIterator</span></a> <span class="type">*</span> <!-- a --><span class="function">getMatchingServices</span><!-- /a -->(
    <a href="../../../OSDictionary_h/Classes/OSDictionary/index.html#//apple_ref/cpp/cl/OSDictionary" target="_top" class="type"><span class="type">OSDictionary</span></a> <span class="type">*</span><span class="param">matching</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>matching</code></dt>
<dd><p>The matching dictionary describing the desired IOService objects.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->An instance of an iterator over a set of IOService objects. To be released by the caller. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Provides a method of finding the current set of published IOService objects matching the supplied matching dictionary.   
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/getOpenClientIterator/OSIterator*/();   name=IOService::getOpenClientIterator --><a name="//apple_ref/cpp/instm/IOService/getOpenClientIterator/OSIterator*/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getOpenClientIterator">getOpenClientIterator</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Returns an iterator over a provider's clients that currently have opened the provider.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../OSIterator_h/Classes/OSIterator/index.html#//apple_ref/cpp/cl/OSIterator" target="_top" class="type"><span class="type">OSIterator</span></a> <span class="type">*</span> <!-- a --><span class="function">getOpenClientIterator</span><!-- /a -->(
    <span class="param">void</span> ) <span class="keyword">const</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->An iterator over the clients that have opened the provider, or zero if there is a resource failure. The iterator must be released when the iteration is finished. All objects returned by the iteration are retained while the iterator is valid, and the current entry in the iteration is locked with <code>lockForArbitration</code>, protecting it from state changes. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>For IOService objects that may have multiple clients, this method supplies an iterator over a provider's clients, locking each in turn with <a href="index.html#//apple_ref/cpp/instm/IOService/lockForArbitration/bool/(bool)" target="_top">lockForArbitration</a> and returning those that have opened the provider. 
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/getOpenProviderIterator/OSIterator*/();   name=IOService::getOpenProviderIterator --><a name="//apple_ref/cpp/instm/IOService/getOpenProviderIterator/OSIterator*/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getOpenProviderIterator">getOpenProviderIterator</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Returns an iterator over an client's providers that are currently opened by the client.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../OSIterator_h/Classes/OSIterator/index.html#//apple_ref/cpp/cl/OSIterator" target="_top" class="type"><span class="type">OSIterator</span></a> <span class="type">*</span> <!-- a --><span class="function">getOpenProviderIterator</span><!-- /a -->(
    <span class="param">void</span> ) <span class="keyword">const</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->An iterator over the providers the client has open, or zero if there is a resource failure. The iterator must be released when the iteration is finished. All objects returned by the iteration are retained while the iterator is valid, and the current entry in the iteration is locked with <code>lockForArbitration</code>, protecting it from state changes. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>For those few IOService objects that obtain service from multiple providers, this method supplies an iterator over a client's providers, locking each in turn with <a href="index.html#//apple_ref/cpp/instm/IOService/lockForArbitration/bool/(bool)" target="_top">lockForArbitration</a> and returning those that have been opened by the client. 
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=clm;  uid=//apple_ref/cpp/clm/IOService/getPlatform/IOPlatformExpert*/();   name=IOService::getPlatform --><a name="//apple_ref/cpp/clm/IOService/getPlatform/IOPlatformExpert*/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getPlatform">getPlatform</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Returns a pointer to the platform expert instance for the computer.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">static</span> <!-- a --><span class="type">IOPlatformExpert</span><!-- /a --> <span class="type">*</span> <!-- a --><span class="function">getPlatform</span><!-- /a -->(
    <span class="param">void</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->A pointer to the IOPlatformExport instance. It should not be released by the caller. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method provides an accessor to the platform expert instance for the computer. 
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=clm;  uid=//apple_ref/cpp/clm/IOService/getPMRootDomain/classIOPMrootDomain*/();   name=IOService::getPMRootDomain --><a name="//apple_ref/cpp/clm/IOService/getPMRootDomain/classIOPMrootDomain*/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getPMRootDomain">getPMRootDomain</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Returns a pointer to the power management root domain instance for the computer.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">static</span> <span class="keyword">class</span> <!-- a --><span class="type">IOPMrootDomain</span><!-- /a --> <span class="type">*</span> <!-- a --><span class="function">getPMRootDomain</span><!-- /a -->(
    <span class="param">void</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->A pointer to the power management root domain instance. It should not be released by the caller. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method provides an accessor to the power management root domain instance for the computer. 
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/getPMworkloop/IOWorkLoop*/();   name=IOService::getPMworkloop --><a name="//apple_ref/cpp/instm/IOService/getPMworkloop/IOWorkLoop*/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getPMworkloop">getPMworkloop</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Returns a pointer to the system-wide power management work loop.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOWorkLoop_h/Classes/IOWorkLoop/index.html#//apple_ref/cpp/cl/IOWorkLoop" target="_top" class="type"><span class="type">IOWorkLoop</span></a> <span class="type">*</span><!-- a --><span class="function">getPMworkloop</span><!-- /a --> (
    <span class="param">void</span> ); </pre>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Most drivers should create their own work loops to synchronize their code; drivers should not run arbitrary code on the power management work loop.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/getPowerState/UInt32/();   name=IOService::getPowerState --><a name="//apple_ref/cpp/instm/IOService/getPowerState/UInt32/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getPowerState">getPowerState</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Determines a device's power state.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><!-- a --><span class="type">UInt32</span><!-- /a --> <!-- a --><span class="function">getPowerState</span><!-- /a -->(); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->The current power state's index into the device's power state array.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>A device's "current power state" is updated at the end of each power state transition (e.g. transition from state 1 to state 0, or state 0 to state 2). This transition includes the time spent powering on or off any power plane children. Thus, if a child calls <code>getPowerState</code> on its power parent during system wake from sleep, the call will return the index to the device's off state rather than its on state.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/getProvider/IOService*/();   name=IOService::getProvider --><a name="//apple_ref/cpp/instm/IOService/getProvider/IOService*/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getProvider">getProvider</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Returns an IOService object's primary provider.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span> <!-- a --><span class="function">getProvider</span><!-- /a -->(
    <span class="param">void</span> ) <span class="keyword">const</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->The first provider of the client, or zero if the IOService object is not attached into the I/O Registry. The provider is retained while the client is attached, and should not be released by the caller. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This function called in an IOService client will return the provider to which it was first attached. Because the majority of IOService objects have only one provider, this is a useful simplification and also supports caching of the provider when the I/O Registry is unchanged.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/getProviderIterator/OSIterator*/();   name=IOService::getProviderIterator --><a name="//apple_ref/cpp/instm/IOService/getProviderIterator/OSIterator*/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getProviderIterator">getProviderIterator</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Returns an iterator over an IOService object's providers.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../OSIterator_h/Classes/OSIterator/index.html#//apple_ref/cpp/cl/OSIterator" target="_top" class="type"><span class="type">OSIterator</span></a> <span class="type">*</span> <!-- a --><span class="function">getProviderIterator</span><!-- /a -->(
    <span class="param">void</span> ) <span class="keyword">const</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->An iterator over the providers of the client, or zero if there is a resource failure. The iterator must be released when the iteration is finished. All objects returned by the iteration are retained while the iterator is valid, though they may no longer be attached during the iteration. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>For those few IOService objects that obtain service from multiple providers, this method supplies an iterator over a client's providers. 
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/getResources/IOReturn/();   name=IOService::getResources --><a name="//apple_ref/cpp/instm/IOService/getResources/IOReturn/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getResources">getResources</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Allocates any needed resources for a published IOService object before clients attach.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">getResources</span><!-- /a -->(
    <span class="param">void</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->An IOReturn code; <code>kIOReturnSuccess</code> is necessary for the IOService object to be successfully used, otherwise the registration process for the object is halted. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method is called during the registration process for an IOService object if there are successful driver matches, before any clients attach. It allows for lazy allocation of resources to an IOService object when a matching driver is found.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=clm;  uid=//apple_ref/cpp/clm/IOService/getResourceService/IOService*/();   name=IOService::getResourceService --><a name="//apple_ref/cpp/clm/IOService/getResourceService/IOService*/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getResourceService">getResourceService</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Returns a pointer to the IOResources service.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">static</span> <a href="index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span> <!-- a --><span class="function">getResourceService</span><!-- /a -->(
    <span class="param">void</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->A pointer to the IOResources instance. It should not be released by the caller. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOService maintains a resource service IOResources that allows objects to be published and found globally in the I/O Kit based on a name, using the standard IOService matching and notification calls.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=clm;  uid=//apple_ref/cpp/clm/IOService/getServiceRoot/IOService*/();   name=IOService::getServiceRoot --><a name="//apple_ref/cpp/clm/IOService/getServiceRoot/IOService*/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getServiceRoot">getServiceRoot</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Returns a pointer to the root of the service plane.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">static</span> <a href="index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span> <!-- a --><span class="function">getServiceRoot</span><!-- /a -->(
    <span class="param">void</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->A pointer to the IOService instance at the root of the service plane. It should not be released by the caller. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method provides an accessor to the root of the service plane for the computer. 
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/getState/IOOptionBits/();   name=IOService::getState --><a name="//apple_ref/cpp/instm/IOService/getState/IOOptionBits/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getState">getState</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Accessor for IOService state bits, not normally needed or used outside IOService.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../USB_h/index.html#//apple_ref/c/tag/IOOptionBits" target="_top" class="type"><span class="type">IOOptionBits</span></a> <!-- a --><span class="function">getState</span><!-- /a -->(
    <span class="param">void</span> ) <span class="keyword">const</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->State bits for the IOService, eg. <code>kIOServiceInactiveState</code>, <code>kIOServiceRegisteredState</code>. 
<!-- end return value --></p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/getWorkLoop/IOWorkLoop*/();   name=IOService::getWorkLoop --><a name="//apple_ref/cpp/instm/IOService/getWorkLoop/IOWorkLoop*/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getWorkLoop">getWorkLoop</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Returns the current work loop or <code>provider-&gt;getWorkLoop</code>.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOWorkLoop_h/Classes/IOWorkLoop/index.html#//apple_ref/cpp/cl/IOWorkLoop" target="_top" class="type"><span class="type">IOWorkLoop</span></a> <span class="type">*</span> <!-- a --><span class="function">getWorkLoop</span><!-- /a -->() <span class="keyword">const</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->A work loop, either the current work loop or it walks up the <a href="index.html#//apple_ref/cpp/instm/IOService/getProvider/IOService*/()" target="_top">getProvider</a> chain calling <code>getWorkLoop</code>. Eventually it will reach a valid work loop-based driver or the root of the I/O tree, where it will return a system-wide work loop. Returns 0 if it fails to find (or create) a work loop.
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This function returns a valid work loop that a client can use to add an IOCommandGate to. The intention is that an IOService client has data that needs to be protected but doesn't want to pay the cost of a dedicated thread. This data has to be accessed from a provider's call-out context as well. So to achieve both of these goals the client creates an IOCommandGate to lock access to his data but he registers it with the provider's work loop, i.e. the work loop which will make the completion call-outs. This avoids a potential deadlock because the work loop gate uses a recursive lock, which allows the same lock to be held multiple times by a single thread.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/handleClose/void/(IOService*,IOOptionBits);   name=IOService::handleClose --><a name="//apple_ref/cpp/instm/IOService/handleClose/void/(IOService*,IOOptionBits)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="handleClose">handleClose</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Controls the open / close behavior of an IOService object (overrideable by subclasses).
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <!-- a --><span class="function">handleClose</span><!-- /a -->(
    <a href="index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span><span class="param">forClient</span>, 
    <a href="../../../USB_h/index.html#//apple_ref/c/tag/IOOptionBits" target="_top" class="type"><span class="type">IOOptionBits</span></a> <span class="param">options</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>forClient</code></dt>
<dd><p>Designates the client of the provider requesting the close.</p></dd>
<dt><code>options</code></dt>
<dd><p>Options for the close, may be interpreted by the implementor of <a href="index.html#//apple_ref/cpp/instm/IOService/handleOpen/bool/(IOService*,IOOptionBits,void*)" target="_top">handleOpen</a>.</p></dd>
</dl>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOService calls this method in its subclasses in response to the <a href="index.html#//apple_ref/cpp/instm/IOService/close/void/(IOService*,IOOptionBits)" target="_top">close</a> method, so the subclass may implement the request. The default implementation provides single owner access to an IOService object via <a href="index.html#//apple_ref/cpp/instm/IOService/open/bool/(IOService*,IOOptionBits,void*)" target="_top">open</a>. The object is locked via <a href="index.html#//apple_ref/cpp/instm/IOService/lockForArbitration/bool/(bool)" target="_top">lockForArbitration</a> before <code>handleClose</code> is called.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/handleIsOpen/bool/(constIOService*);   name=IOService::handleIsOpen --><a name="//apple_ref/cpp/instm/IOService/handleIsOpen/bool/(constIOService*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="handleIsOpen">handleIsOpen</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Controls the open / close behavior of an IOService object (overrideable by subclasses).
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">handleIsOpen</span><!-- /a -->(
    <span class="keyword">const</span> <!-- a --><span class="var">IOService</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">forClient</span><!-- /a --> ) <span class="keyword">const</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>forClient</code></dt>
<dd><p>If non-zero, <code>isOpen</code> returns the open state for that client. If zero is passed, <code>isOpen</code> returns the open state for all clients.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --><code>true</code> if the specific, or any, client has the IOService object open. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOService calls this method in its subclasses in response to the <a href="index.html#//apple_ref/cpp/instm/IOService/open/bool/(IOService*,IOOptionBits,void*)" target="_top">open</a> method, so the subclass may implement the request. The default implementation provides single owner access to an IOService object via <a href="index.html#//apple_ref/cpp/instm/IOService/open/bool/(IOService*,IOOptionBits,void*)" target="_top">open</a>. The object is locked via <a href="index.html#//apple_ref/cpp/instm/IOService/lockForArbitration/bool/(bool)" target="_top">lockForArbitration</a> before <code>handleIsOpen</code> is called.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/handleOpen/bool/(IOService*,IOOptionBits,void*);   name=IOService::handleOpen --><a name="//apple_ref/cpp/instm/IOService/handleOpen/bool/(IOService*,IOOptionBits,void*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="handleOpen">handleOpen</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Controls the open / close behavior of an IOService object (overrideable by subclasses).
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">handleOpen</span><!-- /a -->(
    <a href="index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span><span class="param">forClient</span>, 
    <a href="../../../USB_h/index.html#//apple_ref/c/tag/IOOptionBits" target="_top" class="type"><span class="type">IOOptionBits</span></a> <span class="param">options</span>, 
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><span class="param">arg</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>forClient</code></dt>
<dd><p>Designates the client of the provider requesting the open.</p></dd>
<dt><code>options</code></dt>
<dd><p>Options for the open, may be interpreted by the implementor of <code>handleOpen</code>.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --><code>true</code>if the open was successful; <code>false</code> otherwise. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOService calls this method in its subclasses in response to the <a href="index.html#//apple_ref/cpp/instm/IOService/open/bool/(IOService*,IOOptionBits,void*)" target="_top">open</a> method, so the subclass may implement the request. The default implementation provides single owner access to an IOService object via <code>open</code>. The object is locked via <a href="index.html#//apple_ref/cpp/instm/IOService/lockForArbitration/bool/(bool)" target="_top">lockForArbitration</a> before <code>handleOpen</code> is called.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/initialPowerStateForDomainState/unsignedlong/(IOPMPowerFlags);   name=IOService::initialPowerStateForDomainState --><a name="//apple_ref/cpp/instm/IOService/initialPowerStateForDomainState/unsignedlong/(IOPMPowerFlags)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="initialPowerStateForDomainState">initialPowerStateForDomainState</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Determines which power state a device is in, given the current power domain state.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <span class="keyword">unsigned</span> <!-- a --><span class="type">long</span><!-- /a --> <!-- a --><span class="function">initialPowerStateForDomainState</span><!-- /a --> ( 
    <a href="../../../IOPM_h/index.html#//apple_ref/c/tdef/IOPMPowerFlags" target="_top" class="type"><span class="type">IOPMPowerFlags</span></a> <span class="param">domainState</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>domainState</code></dt>
<dd><p>Flags that describe the character of "domain power"; they represent the <code>outputPowerCharacter</code> field of a state in the power domain's power state array.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->A state number. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Power management calls this method once, when the driver is initializing power management.
</p>
<p>Most drivers do not need to implement this method, and can rely upon the default IOService implementation. The IOService implementation scans the power state array looking for the highest state whose <code>inputPowerRequirement</code> field exactly matches the value of the <code>domainState</code> parameter. If more intelligent determination is required, the power managed driver should implement the method and override the superclass's implementation. 
</p>
<!-- end discussion -->
<p></p>
<hr>
<!-- headerDoc=clm;  uid=//apple_ref/cpp/clm/IOService/installNotification/IONotifier*/(constOSSymbol*,OSDictionary*,IOServiceNotificationHandler,void*,void*,SInt32,OSIterator**);   name=IOService::installNotification --><a name="//apple_ref/cpp/clm/IOService/installNotification/IONotifier*/(constOSSymbol*,OSDictionary*,IOServiceNotificationHandler,void*,void*,SInt32,OSIterator**)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="installNotification">installNotification</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Adds a persistant notification handler to be notified of IOService events.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">static</span> <a href="../../../IONotifier_h/Classes/IONotifier/index.html#//apple_ref/cpp/cl/IONotifier" target="_top" class="type"><span class="type">IONotifier</span></a> <span class="type">*</span> <!-- a --><span class="function">installNotification</span><!-- /a -->( 
    <span class="keyword">const</span> <!-- a --><span class="var">OSSymbol</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">type</span><!-- /a -->,
    <!-- a --><span class="var">OSDictionary</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">matching</span><!-- /a -->, 
    <!-- a --><span class="var">IOServiceNotificationHandler</span><!-- /a --> <!-- a --><span class="var">handler</span><!-- /a -->, 
    <!-- a --><span class="var">void</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">target</span><!-- /a -->,
    <!-- a --><span class="var">void</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">ref</span><!-- /a -->, 
    <!-- a --><span class="var">SInt32</span><!-- /a --> <!-- a --><span class="var">priority</span><!-- /a -->,
    <!-- a --><span class="var">OSIterator</span><!-- /a --> <span class="var">*</span><span class="var">*</span> <!-- a --><span class="var">existing</span><!-- /a --> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>type</code></dt>
<dd><p>See <code>addNotification</code>.</p></dd>
<dt><code>matching</code></dt>
<dd><p>See <code>addNotification</code>.</p></dd>
<dt><code>handler</code></dt>
<dd><p>See <code>addNotification</code>.</p></dd>
<dt><code>self</code></dt>
<dd><p>See <code>addNotification</code>.</p></dd>
<dt><code>ref</code></dt>
<dd><p>See <code>addNotification</code>.</p></dd>
<dt><code>priority</code></dt>
<dd><p>See <code>addNotification</code>.</p></dd>
<dt><code>existing</code></dt>
<dd><p>Returns an iterator over the set of IOService objects that are currently in the specified state and match the matching dictionary.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->See <code>addNotification</code>.  
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>A lower level interface to <a href="index.html#//apple_ref/cpp/clm/IOService/addNotification/IONotifier*/(constOSSymbol*,OSDictionary*,IOServiceNotificationHandler,void*,void*,SInt32)" target="_top">addNotification</a> that installs a handler and returns the current set of IOService objects that are in the specified state and match the matching dictionary.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/isInactive/bool/();   name=IOService::isInactive --><a name="//apple_ref/cpp/instm/IOService/isInactive/bool/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="isInactive">isInactive</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Checks if the IOService object has been terminated, and is in the process of being destroyed.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">isInactive</span><!-- /a -->(
    <span class="param">void</span> ) <span class="keyword">const</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --><code>true</code> if the IOService object has been terminated. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>When an IOService object is successfully terminated, it is immediately made inactive, which blocks further attach()es, matching or notifications occuring on the object. It remains inactive until the last client closes, and is then finalized and destroyed.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/isOpen/bool/(constIOService*);   name=IOService::isOpen --><a name="//apple_ref/cpp/instm/IOService/isOpen/bool/(constIOService*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="isOpen">isOpen</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Determines whether a specific, or any, client has an IOService object open.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">isOpen</span><!-- /a -->(
    <span class="keyword">const</span> <!-- a --><span class="var">IOService</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">forClient</span><!-- /a --> = <span class="number">0</span> ) <span class="keyword">const</span>; </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>forClient</code></dt>
<dd><p>If non-zero, <codeisopen returns the open state for that client if zero is passed all clients></codeisopen></p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --><codetrue if the specific or any client has ioservice object open end return value></codetrue></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Returns the open state of an IOService object with respect to the specified client, or when it is open by any client.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/joinPMtree/void/(IOService*);   name=IOService::joinPMtree --><a name="//apple_ref/cpp/instm/IOService/joinPMtree/void/(IOService*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="joinPMtree">joinPMtree</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Joins the driver into the power plane of the I/O Registry .
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <!-- a --><span class="function">joinPMtree</span><!-- /a --> (
    <a href="index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span><span class="param">driver</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>driver</code></dt>
<dd><p>The driver to be added to the power plane, usually <code>this</code>.</p></dd>
</dl>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>A driver uses this method to call its nub when initializing (usually in its <code>start</code> routine after calling <a href="index.html#//apple_ref/cpp/instm/IOService/PMinit/void/()" target="_top">PMinit</a>), to be attached into the power management hierarchy (i.e., the power plane). A driver usually calls this method on the driver for the device that provides it power (this is frequently the nub).
</p>
<p>Before this call returns, the caller will probably be called at <a href="index.html#//apple_ref/cpp/instm/IOService/setPowerParent/IOReturn/(IOPowerConnection*,bool,IOPMPowerFlags)" target="_top">setPowerParent</a> and <a href="index.html#//apple_ref/cpp/instm/IOService/setAggressiveness/IOReturn/(unsignedlong,unsignedlong)" target="_top">setAggressiveness</a> and possibly at <a href="index.html#//apple_ref/cpp/instm/IOService/addPowerChild/IOReturn/(IOService*)" target="_top">addPowerChild</a> as it is added to the hierarchy. 
</p>
<p>This method may be overridden by a nub subclass.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/lockForArbitration/bool/(bool);   name=IOService::lockForArbitration --><a name="//apple_ref/cpp/instm/IOService/lockForArbitration/bool/(bool)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="lockForArbitration">lockForArbitration</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Locks an IOService object against changes in state or ownership.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">lockForArbitration</span><!-- /a -->(
    <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="type">isSuccessRequired</span><!-- /a --> = <span class="keyword">true</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>isSuccessRequired</code></dt>
<dd><p>If a request for access to an IOService object should be denied if it is terminated, pass <code>false</code>, otherwise pass <code>true</code>.</p></dd>
</dl>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>The registration, termination and open / close functions of IOService use <code>lockForArbtration</code> to single-thread access to an IOService object. <code>lockForArbitration</code> grants recursive access to the same thread.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/makeUsable/IOReturn/();   name=IOService::makeUsable --><a name="//apple_ref/cpp/instm/IOService/makeUsable/IOReturn/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="makeUsable">makeUsable</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Requests that a device become usable.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">makeUsable</span><!-- /a --> (
    <span class="param">void</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->A return code that can be ignored by the caller.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method is called when some client of a device (or the device's own driver) is asking for the device to become usable. Power management responds by telling the object upon which this method is called to change to its highest power state.
</p>
<p><code>makeUsable</code> is implemented using <a href="index.html#//apple_ref/cpp/instm/IOService/changePowerStateToPriv/IOReturn/(unsignedlong)" target="_top">changePowerStateToPriv</a>.
</p>
<p>Subsequent requests for lower power, such as from <code>changePowerStateToPriv</code>, will pre-empt this request.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/mapDeviceMemoryWithIndex/IOMemoryMap*/(unsignedint,IOOptionBits);   name=IOService::mapDeviceMemoryWithIndex --><a name="//apple_ref/cpp/instm/IOService/mapDeviceMemoryWithIndex/IOMemoryMap*/(unsignedint,IOOptionBits)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="mapDeviceMemoryWithIndex">mapDeviceMemoryWithIndex</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Maps a physical range of a device.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOMemoryDescriptor_h/Classes/IOMemoryMap/index.html#//apple_ref/cpp/cl/IOMemoryMap" target="_top" class="type"><span class="type">IOMemoryMap</span></a> <span class="type">*</span> <!-- a --><span class="function">mapDeviceMemoryWithIndex</span><!-- /a -->(
    <span class="keyword">unsigned</span> <!-- a --><span class="type">int</span><!-- /a --> <span class="param">index</span>, 
    <a href="../../../USB_h/index.html#//apple_ref/c/tag/IOOptionBits" target="_top" class="type"><span class="type">IOOptionBits</span></a> <!-- a --><span class="type">options</span><!-- /a --> = <span class="number">0</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>index</code></dt>
<dd><p>An index into the array of ranges assigned to the device.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->An instance of IOMemoryMap, or zero if the index is beyond the count available. The mapping should be released only when access to it is no longer required. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method creates a mapping for the IODeviceMemory at the given index, with <code>IODeviceMemory::map(options)</code>. The mapping is represented by the returned instance of IOMemoryMap, which should not be released until the mapping is no longer required.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/matchLocation/IOService*/(IOService*);   name=IOService::matchLocation --><a name="//apple_ref/cpp/instm/IOService/matchLocation/IOService*/(IOService*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="matchLocation">matchLocation</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Allows a registered IOService object to direct location matching.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span> <!-- a --><span class="function">matchLocation</span><!-- /a -->(
    <a href="index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span><span class="param">client</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>client</code></dt>
<dd><p>The IOService object at which matching is taking place.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns the IOService instance to be used for location matching. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>By default, a location matching property will be applied to an IOService object's provider. This method allows that behavior to be overridden by families.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/matchPropertyTable/bool/(OSDictionary*,SInt32*);   name=IOService::matchPropertyTable --><a name="//apple_ref/cpp/instm/IOService/matchPropertyTable/bool/(OSDictionary*,SInt32*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="matchPropertyTable">matchPropertyTable</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Allows a registered IOService object to implement family specific matching.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">matchPropertyTable</span><!-- /a -->(
    <a href="../../../OSDictionary_h/Classes/OSDictionary/index.html#//apple_ref/cpp/cl/OSDictionary" target="_top" class="type"><span class="type">OSDictionary</span></a> <span class="type">*</span><span class="param">table</span>, 
    <!-- a --><span class="type">SInt32</span><!-- /a --> <span class="type">*</span><span class="param">score</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>table</code></dt>
<dd><p>The dictionary of properties to be matched against.</p></dd>
<dt><code>score</code></dt>
<dd><p>Pointer to the current driver's probe score, which is used to order multiple matching drivers in the same match category. It defaults to the value of the <code>IOProbeScore</code> property in the drivers property table, or <code>kIODefaultProbeScore</code> if none is specified.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --><code>false</code> if the family considers the matching dictionary does not match in properties it understands; <code>true</code> otherwise. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>All matching on an IOService object will call this method to allow a family writer to implement matching in addition to the generic methods provided by IOService. The implementer should examine the matching dictionary passed to see if it contains properties the family understands for matching, and use them to match with the IOService object if so. Note that since matching is also carried out by other parts of the I/O Kit, the matching dictionary may contain properties the family does not understand - these should not be considered matching failures.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/maxCapabilityForDomainState/unsignedlong/(IOPMPowerFlags);   name=IOService::maxCapabilityForDomainState --><a name="//apple_ref/cpp/instm/IOService/maxCapabilityForDomainState/unsignedlong/(IOPMPowerFlags)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="maxCapabilityForDomainState">maxCapabilityForDomainState</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Determines a driver's highest power state possible for a given power domain state. 
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <span class="keyword">unsigned</span> <!-- a --><span class="type">long</span><!-- /a --> <!-- a --><span class="function">maxCapabilityForDomainState</span><!-- /a --> ( 
    <a href="../../../IOPM_h/index.html#//apple_ref/c/tdef/IOPMPowerFlags" target="_top" class="type"><span class="type">IOPMPowerFlags</span></a> <span class="param">domainState</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>domainState</code></dt>
<dd><p>Flags that describe the character of "domain power"; they represent the <code>outputPowerCharacter</code> field of a state in the power domain's power state array.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->A state number. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This happens when the power domain is changing state and power management needs to determine which state the device is capable of in the new domain state. 
</p>
<p>Most drivers do not need to implement this method, and can rely upon the default IOService implementation. The IOService implementation scans the power state array looking for the highest state whose <code>inputPowerRequirement</code> field exactly matches the value of the <code>domainState</code> parameter. If more intelligent determination is required, the driver itself should implement the method and override the superclass's implementation.
</p>
<!-- end discussion -->
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/message/IOReturn/(UInt32,IOService*,void*);   name=IOService::message --><a name="//apple_ref/cpp/instm/IOService/message/IOReturn/(UInt32,IOService*,void*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="message">message</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Receives a generic message delivered from an attached provider.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">message</span><!-- /a -->(
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">type</span>,
    <a href="index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span><span class="param">provider</span>, 
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><!-- a --><span class="type">argument</span><!-- /a --> = <span class="number">0</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>type</code></dt>
<dd><p>A type defined in <code>IOMessage.h</code> or defined by the provider family.</p></dd>
<dt><code>provider</code></dt>
<dd><p>The provider from which the message originates.</p></dd>
<dt><code>argument</code></dt>
<dd><p>An argument defined by the provider family, not used by IOService.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->An IOReturn code defined by the message type. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>A provider may deliver messages via the <code>message</code> method to its clients informing them of state changes, such as <code>kIOMessageServiceIsTerminated</code> or <code>kIOMessageServiceIsSuspended</code>. Certain messages are defined by the I/O Kit in <code>IOMessage.h</code> while others may be family dependent. This method is implemented in the client to receive messages.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/messageClient/IOReturn/(UInt32,OSObject*,void*,vm_size_t);   name=IOService::messageClient --><a name="//apple_ref/cpp/instm/IOService/messageClient/IOReturn/(UInt32,OSObject*,void*,vm_size_t)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="messageClient">messageClient</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Sends a generic message to an attached client.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">messageClient</span><!-- /a -->(
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">messageType</span>,
    <a href="../../../OSObject_h/Classes/OSObject/index.html#//apple_ref/cpp/cl/OSObject" target="_top" class="type"><span class="type">OSObject</span></a> <span class="type">*</span><span class="param">client</span>, 
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><!-- a --><span class="type">messageArgument</span><!-- /a --> = <span class="number">0</span>,
    <!-- a --><span class="type">vm_size_t</span><!-- /a --> <!-- a --><span class="type">argSize</span><!-- /a --> = <span class="number">0</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>type</code></dt>
<dd><p>A type defined in <code>IOMessage.h</code> or defined by the provider family.</p></dd>
<dt><code>client</code></dt>
<dd><p>A client of the IOService to send the message.</p></dd>
<dt><code>argument</code></dt>
<dd><p>An argument defined by the provider family, not used by IOService.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->The return code from the client message call. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>A provider may deliver messages via the <a href="index.html#//apple_ref/cpp/instm/IOService/message/IOReturn/(UInt32,IOService*,void*)" target="_top">message</a> method to its clients informing them of state changes, such as <code>kIOMessageServiceIsTerminated</code> or <code>kIOMessageServiceIsSuspended</code>. Certain messages are defined by the I/O Kit in <code>IOMessage.h</code> while others may be family dependent. This method may be called in the provider to send a message to the specified client, which may be useful for overrides.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/messageClients/IOReturn/(UInt32,void*,vm_size_t);   name=IOService::messageClients --><a name="//apple_ref/cpp/instm/IOService/messageClients/IOReturn/(UInt32,void*,vm_size_t)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="messageClients">messageClients</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Sends a generic message to all attached clients.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">messageClients</span><!-- /a -->(
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">type</span>, 
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><!-- a --><span class="type">argument</span><!-- /a --> = <span class="number">0</span>,
    <!-- a --><span class="type">vm_size_t</span><!-- /a --> <!-- a --><span class="type">argSize</span><!-- /a --> = <span class="number">0</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>type</code></dt>
<dd><p>A type defined in <code>IOMessage.h</code> or defined by the provider family.</p></dd>
<dt><code>argument</code></dt>
<dd><p>An argument defined by the provider family, not used by IOService.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Any non-<code>kIOReturnSuccess</code> return codes returned by the clients, or <code>kIOReturnSuccess</code> if all return <code>kIOReturnSuccess</code>. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>A provider may deliver messages via the <a href="index.html#//apple_ref/cpp/instm/IOService/message/IOReturn/(UInt32,IOService*,void*)" target="_top">message</a> method to its clients informing them of state changes, such as <code>kIOMessageServiceIsTerminated</code> or <code>kIOMessageServiceIsSuspended</code>. Certain messages are defined by the I/O Kit in <code>IOMessage.h</code> while others may be family dependent. This method may be called in the provider to send a message to all the attached clients, via the <a href="index.html#//apple_ref/cpp/instm/IOService/messageClient/IOReturn/(UInt32,OSObject*,void*,vm_size_t)" target="_top">messageClient</a> method.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=clm;  uid=//apple_ref/cpp/clm/IOService/nameMatching/OSDictionary*/(constchar*,OSDictionary*);   name=IOService::nameMatching --><a name="//apple_ref/cpp/clm/IOService/nameMatching/OSDictionary*/(constchar*,OSDictionary*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="nameMatching(constchar*,OSDictionary*)">nameMatching(const char *, OSDictionary *)</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Creates a matching dictionary, or adds matching properties to an existing dictionary, that specify an IOService name match.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">static</span> <a href="../../../OSDictionary_h/Classes/OSDictionary/index.html#//apple_ref/cpp/cl/OSDictionary" target="_top" class="type"><span class="type">OSDictionary</span></a> <span class="type">*</span> <!-- a --><span class="function">nameMatching</span><!-- /a -->(
    <span class="keyword">const</span> <!-- a --><span class="var">char</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">name</span><!-- /a -->, 
    <!-- a --><span class="var">OSDictionary</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">table</span><!-- /a --> = <span class="number">0</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>name</code></dt>
<dd><p>The service's name, as a const C string. Name matching is successful on IOService objects that respond successfully to the <code>IORegistryEntry::compareName</code> method.</p></dd>
<dt><code>table</code></dt>
<dd><p>If zero, <code>nameMatching</code> creates a matching dictionary and returns a reference to it, otherwise the matching properties are added to the specified dictionary.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->The matching dictionary created, or passed in, is returned on success, or zero on failure. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>A very common matching criteria for IOService object is based on its name. <code>nameMatching</code> creates a matching dictionary that specifies any IOService object which responds successfully to the <!-- a -->IORegistryEntry::compareName<!-- /a --> method. An existing dictionary may be passed in, in which case the matching properties will be added to that dictionary rather than creating a new one.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=clm;  uid=//apple_ref/cpp/clm/IOService/nameMatching/OSDictionary*/(constOSString*,OSDictionary*);   name=IOService::nameMatching --><a name="//apple_ref/cpp/clm/IOService/nameMatching/OSDictionary*/(constOSString*,OSDictionary*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="nameMatching(constOSString*,OSDictionary*)">nameMatching(const OSString *, OSDictionary *)</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Creates a matching dictionary, or adds matching properties to an existing dictionary, that specify an IOService name match.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">static</span> <a href="../../../OSDictionary_h/Classes/OSDictionary/index.html#//apple_ref/cpp/cl/OSDictionary" target="_top" class="type"><span class="type">OSDictionary</span></a> <span class="type">*</span> <!-- a --><span class="function">nameMatching</span><!-- /a -->(
    <span class="keyword">const</span> <!-- a --><span class="var">OSString</span><!-- /a --><span class="var">*</span> <!-- a --><span class="var">name</span><!-- /a -->, 
    <!-- a --><span class="var">OSDictionary</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">table</span><!-- /a --> = <span class="number">0</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>name</code></dt>
<dd><p>The service's name, as an OSString (which includes OSSymbol). Name matching is successful on IOService objects that respond successfully to the <code>IORegistryEntry::compareName</code> method.</p></dd>
<dt><code>table</code></dt>
<dd><p>If zero, <code>nameMatching</code> creates a matching dictionary and returns a reference to it, otherwise the matching properties are added to the specified dictionary.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->The matching dictionary created, or passed in, is returned on success, or zero on failure. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>A very common matching criteria for IOService object is based on its name. <code>nameMatching</code> creates a matching dictionary that specifies any IOService object which responds successfully to the <!-- a -->IORegistryEntry::compareName<!-- /a --> method. An existing dictionary may be passed in, in which case the matching properties will be added to that dictionary rather than creating a new one.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/newTemperature/IOReturn/(long,IOService*);   name=IOService::newTemperature --><a name="//apple_ref/cpp/instm/IOService/newTemperature/IOReturn/(long,IOService*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="newTemperature">newTemperature</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>(Deprecated. Do not use.) Tells a power managed driver that the temperature in the thermal zone has changed.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">newTemperature</span><!-- /a --> (
    <!-- a --><span class="type">long</span><!-- /a --> <span class="param">currentTemp</span>,
    <a href="index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span><span class="param">whichZone</span> ); </pre>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>A thermal-zone driver calls a power managed driver with this method to tell it that the temperature in the zone has changed. This method is not intended to be overridden or called by drivers. This method is deprecated.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/newUserClient/IOReturn/(task_t,void*,UInt32,OSDictionary*,IOUserClient**);   name=IOService::newUserClient --><a name="//apple_ref/cpp/instm/IOService/newUserClient/IOReturn/(task_t,void*,UInt32,OSDictionary*,IOUserClient**)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="newUserClient">newUserClient</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Creates a connection for a non kernel client.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">newUserClient</span><!-- /a -->(
    <!-- a --><span class="type">task_t</span><!-- /a --> <span class="param">owningTask</span>,
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><span class="param">securityID</span>, 
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">type</span>,
    <a href="../../../OSDictionary_h/Classes/OSDictionary/index.html#//apple_ref/cpp/cl/OSDictionary" target="_top" class="type"><span class="type">OSDictionary</span></a> <span class="type">*</span><span class="param">properties</span>, 
    <a href="../../../IOUserClient_h/Classes/IOUserClient/index.html#//apple_ref/cpp/cl/IOUserClient" target="_top" class="type"><span class="type">IOUserClient</span></a> <span class="type">*</span><span class="type">*</span><span class="param">handler</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>owningTask</code></dt>
<dd><p>The Mach task of the client thread in the process of opening the user client. Note that in Mac OS X, each process is based on a Mach task and one or more Mach threads. For more information on the composition of a Mach task and its relationship with Mach threads, see <i><a href="../../../../../Conceptual/KernelProgramming/Mach/Mach.html#//apple_ref/doc/uid/TP30000905-CH209-TPXREF103" target="_top">"Tasks and Threads"</a></i>.</p></dd>
<dt><code>securityID</code></dt>
<dd><p>A token representing the access level for the task.</p></dd>
<dt><code>type</code></dt>
<dd><p>A constant specifying the type of connection to be created, specified by the caller of <a href="../../../../IOKit/IOKitLib_h/index.html#//apple_ref/c/func/IOServiceOpen" target="_top">IOServiceOpen</a> and interpreted only by the family.</p></dd>
<dt><code>handler</code></dt>
<dd><p>An instance of an IOUserClient object to represent the connection, which will be released when the connection is closed, or zero if the connection was not opened.</p></dd>
<dt><code>properties</code></dt>
<dd><p>A dictionary of additional properties for the connection.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->A return code to be passed back to the caller of <code>IOServiceOpen</code>. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>A non kernel client may request a connection be opened via the <a href="../../../../IOKit/IOKitLib_h/index.html#//apple_ref/c/func/IOServiceOpen" target="_top">IOServiceOpen</a> library function, which will call this method in an IOService object. The rules and capabilities of user level clients are family dependent, and use the functions of the IOUserClient class for support. IOService's implementation returns <code>kIOReturnUnsupported</code>, so any family supporting user clients must implement this method.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/nextIdleTimeout/SInt32/(AbsoluteTime,AbsoluteTime,unsignedint);   name=IOService::nextIdleTimeout --><a name="//apple_ref/cpp/instm/IOService/nextIdleTimeout/SInt32/(AbsoluteTime,AbsoluteTime,unsignedint)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="nextIdleTimeout">nextIdleTimeout</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Allows subclasses to customize idle power management behavior.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">SInt32</span><!-- /a --> <!-- a --><span class="function">nextIdleTimeout</span><!-- /a -->(
    <!-- a --><span class="type">AbsoluteTime</span><!-- /a --> <span class="param">currentTime</span>, 
    <!-- a --><span class="type">AbsoluteTime</span><!-- /a --> <span class="param">lastActivity</span>,
    <span class="keyword">unsigned</span> <!-- a --><span class="type">int</span><!-- /a --> <span class="param">powerState</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>currentTime</code></dt>
<dd><p>The current time</p></dd>
<dt><code>lastActivity</code></dt>
<dd><p>The time of last activity on this device</p></dd>
<dt><code>powerState</code></dt>
<dd><p>The device's current power state.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns the next time the device should idle off (in seconds, relative to the current time). 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Returns the next time that the device should idle into its next lower power state. Subclasses may override for custom idle behavior.
</p>
<p>A power managed driver might override this method to provide a more sophisticated idle power off algorithm than the one defined by power management.
<!-- end discussion -->
</p>
<p></p>
<dl>
<dt><i>Availability</i></dt>
<dd>Mac OS X v10.4 and later
</dd>
</dl>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/open/bool/(IOService*,IOOptionBits,void*);   name=IOService::open --><a name="//apple_ref/cpp/instm/IOService/open/bool/(IOService*,IOOptionBits,void*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="open">open</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Requests active access to a provider.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">open</span><!-- /a -->(
    <a href="index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span><span class="param">forClient</span>, 
    <a href="../../../USB_h/index.html#//apple_ref/c/tag/IOOptionBits" target="_top" class="type"><span class="type">IOOptionBits</span></a> <!-- a --><span class="type">options</span><!-- /a --> = <span class="number">0</span>, 
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><!-- a --><span class="type">arg</span><!-- /a --> = <span class="number">0</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>forClient</code></dt>
<dd><p>Designates the client of the provider requesting the open.</p></dd>
<dt><code>options</code></dt>
<dd><p>Options for the open. The provider family may implement options for open; IOService defines only <code>kIOServiceSeize</code> to request the device be withdrawn from its current owner.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --><code>true</code> if the open was successful; <code>false</code> otherwise. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOService provides generic open and close semantics to track clients of a provider that have established an active datapath. The use of <code>open</code> and <a href="index.html#//apple_ref/cpp/instm/IOService/close/void/(IOService*,IOOptionBits)" target="_top">close</a>, and rules regarding ownership are family defined, and defined by the <a href="index.html#//apple_ref/cpp/instm/IOService/handleOpen/bool/(IOService*,IOOptionBits,void*)" target="_top">handleOpen</a> and <a href="index.html#//apple_ref/cpp/instm/IOService/handleClose/void/(IOService*,IOOptionBits)" target="_top">handleClose</a> methods in the provider. Some families will limit access to a provider based on its open state.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/PMinit/void/();   name=IOService::PMinit --><a name="//apple_ref/cpp/instm/IOService/PMinit/void/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="PMinit">PMinit</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Initializes power management for a driver.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <!-- a --><span class="function">PMinit</span><!-- /a --> (
    <span class="param">void</span> ); </pre>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p><code>PMinit</code> allocates and initializes the power management instance variables, and it should be called before accessing those variables or calling the power management methods. This method should be called inside the driver's <code>start</code> routine and must be paired with a call to <a href="index.html#//apple_ref/cpp/instm/IOService/PMstop/void/()" target="_top">PMstop</a>.
</p>
<p>Most calls to <code>PMinit</code> are followed by calls to <a href="index.html#//apple_ref/cpp/instm/IOService/joinPMtree/void/(IOService*)" target="_top">joinPMtree</a> and <a href="index.html#//apple_ref/cpp/instm/IOService/registerPowerDriver/IOReturn/(IOService*,IOPMPowerState*,unsignedlong)" target="_top">registerPowerDriver</a>.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/PMstop/void/();   name=IOService::PMstop --><a name="//apple_ref/cpp/instm/IOService/PMstop/void/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="PMstop">PMstop</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Frees and removes the driver from power management.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <!-- a --><span class="function">PMstop</span><!-- /a --> (
    <span class="param">void</span> ); </pre>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>The power managment variables don't exist after this call and the power managment methods in the caller shouldn't be called. 
</p>
<p>Calling <code>PMstop</code> cleans up for the three power management initialization calls: <a href="index.html#//apple_ref/cpp/instm/IOService/PMinit/void/()" target="_top">PMinit</a>, <a href="index.html#//apple_ref/cpp/instm/IOService/joinPMtree/void/(IOService*)" target="_top">joinPMtree</a>, and <a href="index.html#//apple_ref/cpp/instm/IOService/registerPowerDriver/IOReturn/(IOService*,IOPMPowerState*,unsignedlong)" target="_top">registerPowerDriver</a>.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/powerChangeDone/void/(unsignedlong);   name=IOService::powerChangeDone --><a name="//apple_ref/cpp/instm/IOService/powerChangeDone/void/(unsignedlong)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="powerChangeDone">powerChangeDone</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Tells a driver when a power change is complete.
</p>
<!-- end abstract -->
<p></p>
<pre><tt>protected</tt>
<br><span class="keyword">virtual</span> <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <!-- a --><span class="function">powerChangeDone</span><!-- /a --> (
    <span class="keyword">unsigned</span> <!-- a --><span class="type">long</span><!-- /a --> <span class="param">stateNumber</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>stateNumber</code></dt>
<dd><p>The number of the state in the state array that the device has switched from.</p></dd>
</dl>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Power management uses this method to call into a driver when a power change is completely done, when all interested parties have acknowledged the <a href="index.html#//apple_ref/cpp/instm/IOService/powerStateDidChangeTo/IOReturn/(IOPMPowerFlags,unsignedlong,IOService*)" target="_top">powerStateDidChangeTo</a> call. The default implementation of this method is null; the method is meant to be overridden by subclassed power managed drivers. A driver should use this method to find out if a power change it initiated is complete. 
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/powerDomainDidChangeTo/IOReturn/(IOPMPowerFlags,IOPowerConnection*);   name=IOService::powerDomainDidChangeTo --><a name="//apple_ref/cpp/instm/IOService/powerDomainDidChangeTo/IOReturn/(IOPMPowerFlags,IOPowerConnection*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="powerDomainDidChangeTo">powerDomainDidChangeTo</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Notifies a driver that its power domain is about to change state.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">powerDomainDidChangeTo</span><!-- /a --> ( 
    <a href="../../../IOPM_h/index.html#//apple_ref/c/tdef/IOPMPowerFlags" target="_top" class="type"><span class="type">IOPMPowerFlags</span></a> <span class="param">newPowerStateFlags</span>, 
    <a href="../../../IOPowerConnection_h/Classes/IOPowerConnection/index.html#//apple_ref/cpp/cl/IOPowerConnection" target="_top" class="type"><span class="type">IOPowerConnection</span></a> <span class="type">*</span><span class="param">whichParent</span> ); </pre>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This call is handled internally by power management. It is not intended to be overridden or called by drivers.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/powerDomainWillChangeTo/IOReturn/(IOPMPowerFlags,IOPowerConnection*);   name=IOService::powerDomainWillChangeTo --><a name="//apple_ref/cpp/instm/IOService/powerDomainWillChangeTo/IOReturn/(IOPMPowerFlags,IOPowerConnection*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="powerDomainWillChangeTo">powerDomainWillChangeTo</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Notifies a driver that its power domain is about to change state.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">powerDomainWillChangeTo</span><!-- /a --> ( 
    <a href="../../../IOPM_h/index.html#//apple_ref/c/tdef/IOPMPowerFlags" target="_top" class="type"><span class="type">IOPMPowerFlags</span></a> <span class="param">newPowerStateFlags</span>, 
    <a href="../../../IOPowerConnection_h/Classes/IOPowerConnection/index.html#//apple_ref/cpp/cl/IOPowerConnection" target="_top" class="type"><span class="type">IOPowerConnection</span></a> <span class="type">*</span><span class="param">whichParent</span> ); </pre>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This call is handled internally by power management. It is not intended to be overridden or called by drivers.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/powerOverrideOffPriv/IOReturn/();   name=IOService::powerOverrideOffPriv --><a name="//apple_ref/cpp/instm/IOService/powerOverrideOffPriv/IOReturn/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="powerOverrideOffPriv">powerOverrideOffPriv</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Allows a driver to disable a power override.
</p>
<!-- end abstract -->
<p></p>
<pre><tt>protected</tt>
<br><a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">powerOverrideOffPriv</span><!-- /a --> (
    <span class="param">void</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->A return code that can be ignored by the caller.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>When a driver has enabled an override via <a href="index.html#//apple_ref/cpp/instm/IOService/powerOverrideOnPriv/IOReturn/()" target="_top">powerOverrideOnPriv</a>, it can disable it again by calling this method in its superclass. Disabling the override reverts to the default algorithm for determining a device's power state. The superclass will now keep the device at the highest state required by <code>changePowerStateTo</code>, <code>changePowerStateToPriv</code>, and its children.
</p>
<p>Turning off the override will initiate a power change if the driver's desired power state is different from the maximum of the power managed driver's desire and the children's desires. 
</p>
<!-- end discussion -->
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/powerOverrideOnPriv/IOReturn/();   name=IOService::powerOverrideOnPriv --><a name="//apple_ref/cpp/instm/IOService/powerOverrideOnPriv/IOReturn/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="powerOverrideOnPriv">powerOverrideOnPriv</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Allows a driver to ignore its children's power management requests and only use changePowerStateToPriv to define its own power state.
</p>
<!-- end abstract -->
<p></p>
<pre><tt>protected</tt>
<br><a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">powerOverrideOnPriv</span><!-- /a --> (
    <span class="param">void</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->A return code that can be ignored by the caller.


<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Power management normally keeps a device at the highest state required by its requests via <a href="index.html#//apple_ref/cpp/instm/IOService/changePowerStateTo/IOReturn/(unsignedlong)" target="_top">changePowerStateTo</a>, <a href="index.html#//apple_ref/cpp/instm/IOService/changePowerStateToPriv/IOReturn/(unsignedlong)" target="_top">changePowerStateToPriv</a>, and its children. However, a driver may ensure a lower power state than otherwise required by itself and its children using <code>powerOverrideOnPriv</code>.
</p>
<p>When the override is on, power management keeps the device's power state in the state specified by <code>changePowerStateToPriv</code>.
</p>
<p>Turning on the override will initiate a power change if the driver's <code>changePowerStateToPriv</code> desired power state is different from the maximum of the <code>changePowerStateTo</code> desired power state and the children's desires. 
</p>
<!-- end discussion -->
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/powerStateDidChangeTo/IOReturn/(IOPMPowerFlags,unsignedlong,IOService*);   name=IOService::powerStateDidChangeTo --><a name="//apple_ref/cpp/instm/IOService/powerStateDidChangeTo/IOReturn/(IOPMPowerFlags,unsignedlong,IOService*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="powerStateDidChangeTo">powerStateDidChangeTo</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Informs interested parties that a device has changed to a different power state.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">powerStateDidChangeTo</span><!-- /a --> ( 
    <a href="../../../IOPM_h/index.html#//apple_ref/c/tdef/IOPMPowerFlags" target="_top" class="type"><span class="type">IOPMPowerFlags</span></a> <span class="param">capabilities</span>, 
    <span class="keyword">unsigned</span> <!-- a --><span class="type">long</span><!-- /a --> <span class="param">stateNumber</span>, 
    <a href="index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span><span class="param">whatDevice</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>capabilities</code></dt>
<dd><p>Flags that describe the capability of the device in the new power state (they come from the <code>capabilityFlags</code> field of the new state in the power state array).</p></dd>
<dt><code>stateNumber</code></dt>
<dd><p>The number of the state in the state array that the device is switching to.</p></dd>
<dt><code>whatDevice</code></dt>
<dd><p>A pointer to the driver that is changing. It can be used by a driver that is receiving power state change notifications for multiple devices to distinguish between them.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->The driver returns <code>IOPMAckImplied</code> if it has prepared for the power change when it returns. If it has started preparing but not finished, it should return a number of microseconds which is an upper limit of the time it will need to finish preparing. Then, when it has completed its preparations, it should call <a href="index.html#//apple_ref/cpp/instm/IOService/acknowledgePowerChange/IOReturn/(IOService*)" target="_top">acknowledgePowerChange</a>. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Power management informs interested parties that a device has changed to a different power state. Interested parties are those that have registered for this notification via <a href="index.html#//apple_ref/cpp/instm/IOService/registerInterestedDriver/IOPMPowerFlags/(IOService*)" target="_top">registerInterestedDriver</a>. If you have called <code>registerInterestedDriver</code> on a power managed driver, you must implemnt <a href="index.html#//apple_ref/cpp/instm/IOService/powerStateWillChangeTo/IOReturn/(IOPMPowerFlags,unsignedlong,IOService*)" target="_top">powerStateWillChangeTo</a> and <code>powerStateDidChangeTo</code> to receive the notifications.
</p>
<p><code>powerStateDidChangeTo</code> is called in a clean and separate thread context.
</p>
<p><code>powerStateWillChangeTo</code> is called before a power state transition takes place; <code>powerStateDidChangeTo</code> is called after the transition has completed.
</p>
<!-- end discussion -->
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/powerStateForDomainState/unsignedlong/(IOPMPowerFlags);   name=IOService::powerStateForDomainState --><a name="//apple_ref/cpp/instm/IOService/powerStateForDomainState/unsignedlong/(IOPMPowerFlags)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="powerStateForDomainState">powerStateForDomainState</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Determines what power state the device would be in for a given power domain state. 
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <span class="keyword">unsigned</span> <!-- a --><span class="type">long</span><!-- /a --> <!-- a --><span class="function">powerStateForDomainState</span><!-- /a --> (
    <a href="../../../IOPM_h/index.html#//apple_ref/c/tdef/IOPMPowerFlags" target="_top" class="type"><span class="type">IOPMPowerFlags</span></a> <span class="param">domainState</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>domainState</code></dt>
<dd><p>Flags that describe the character of "domain power"; they represent the <code>outputPowerCharacter</code> field of a state in the power domain's power state array.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->A state number. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Power management calls a driver with this method to find out what power state the device would be in for a given power domain state. This happens when the power domain is changing state and power management needs to determine the effect of the change. 
</p>
<p>Most drivers do not need to implement this method, and can rely upon the default IOService implementation. The IOService implementation scans the power state array looking for the highest state whose <code>inputPowerRequirement</code> field exactly matches the value of the <code>domainState</code> parameter. If more intelligent determination is required, the power managed driver should implement the method and override the superclass's implementation.
</p>
<!-- end discussion -->
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/powerStateWillChangeTo/IOReturn/(IOPMPowerFlags,unsignedlong,IOService*);   name=IOService::powerStateWillChangeTo --><a name="//apple_ref/cpp/instm/IOService/powerStateWillChangeTo/IOReturn/(IOPMPowerFlags,unsignedlong,IOService*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="powerStateWillChangeTo">powerStateWillChangeTo</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Informs interested parties that a device is about to change its power state.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">powerStateWillChangeTo</span><!-- /a --> ( 
    <a href="../../../IOPM_h/index.html#//apple_ref/c/tdef/IOPMPowerFlags" target="_top" class="type"><span class="type">IOPMPowerFlags</span></a> <span class="param">capabilities</span>, 
    <span class="keyword">unsigned</span> <!-- a --><span class="type">long</span><!-- /a --> <span class="param">stateNumber</span>, 
    <a href="index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span><span class="param">whatDevice</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>capabilities</code></dt>
<dd><p>Flags that describe the capability of the device in the new power state (they come from the <code>capabilityFlags</code> field of the new state in the power state array).</p></dd>
<dt><code>stateNumber</code></dt>
<dd><p>The number of the state in the state array that the device is switching to.</p></dd>
<dt><code>whatDevice</code></dt>
<dd><p>A pointer to the driver that is changing. It can be used by a driver that is receiving power state change notifications for multiple devices to distinguish between them.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->The driver returns <code>IOPMAckImplied</code> if it has prepared for the power change when it returns. If it has started preparing but not finished, it should return a number of microseconds which is an upper limit of the time it will need to finish preparing. Then, when it has completed its preparations, it should call <a href="index.html#//apple_ref/cpp/instm/IOService/acknowledgePowerChange/IOReturn/(IOService*)" target="_top">acknowledgePowerChange</a>. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Power management informs interested parties that a device is about to change to a different power state. Interested parties are those that have registered for this notification via <a href="index.html#//apple_ref/cpp/instm/IOService/registerInterestedDriver/IOPMPowerFlags/(IOService*)" target="_top">registerInterestedDriver</a>. If you have called <code>registerInterestedDriver</code> on a power managed driver, you must implement <code>powerStateWillChangeTo</code> and <a href="index.html#//apple_ref/cpp/instm/IOService/powerStateDidChangeTo/IOReturn/(IOPMPowerFlags,unsignedlong,IOService*)" target="_top">powerStateDidChangeTo</a> to receive the notifications.
</p>
<p><code>powerStateWillChangeTo</code> is called in a clean and separate thread context.
</p>
<p><code>powerStateWillChangeTo</code> is called before a power state transition takes place; <code>powerStateDidChangeTo</code> is called after the transition has completed.
</p>
<!-- end discussion -->
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/probe/IOService*/(IOService*,SInt32*);   name=IOService::probe --><a name="//apple_ref/cpp/instm/IOService/probe/IOService*/(IOService*,SInt32*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="probe">probe</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>During an IOService object's instantiation, probes a matched service to see if it can be used.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span> <!-- a --><span class="function">probe</span><!-- /a -->(
    <a href="index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span><span class="param">provider</span>, 
    <!-- a --><span class="type">SInt32</span><!-- /a --> <span class="type">*</span><span class="param">score</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>provider</code></dt>
<dd><p>The registered IOService object that matches a driver personality's matching dictionary.</p></dd>
<dt><code>score</code></dt>
<dd><p>Pointer to the current driver's probe score, which is used to order multiple matching drivers in the same match category. It defaults to the value of the <code>IOProbeScore</code> property in the drivers property table, or <code>kIODefaultProbeScore</code> if none is specified. The <code>probe</code> method may alter the score to affect start order.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->An IOService instance or zero when the probe is unsuccessful. In almost all cases the value of <code>this</code> is returned on success. If another IOService object is returned, the probed instance is detached and freed, and the returned instance is used in its stead for <code>start</code>. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>The registration process for an IOService object (the provider) includes instantiating possible driver clients. The <code>probe</code> method is called in the client instance to check the matched service can be used before the driver is considered to be started. Since matching screens many possible providers, in many cases the <code>probe</code> method can be left unimplemented by IOService subclasses. The client is already attached to the provider when <code>probe</code> is called.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=clm;  uid=//apple_ref/cpp/clm/IOService/propertyMatching/OSDictionary*/(constOSSymbol*,constOSObject*,OSDictionary*);   name=IOService::propertyMatching --><a name="//apple_ref/cpp/clm/IOService/propertyMatching/OSDictionary*/(constOSSymbol*,constOSObject*,OSDictionary*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="propertyMatching">propertyMatching</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Creates a matching dictionary, or adds matching properties to an existing dictionary, that specify an IOService phandle match.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">static</span> <a href="../../../OSDictionary_h/Classes/OSDictionary/index.html#//apple_ref/cpp/cl/OSDictionary" target="_top" class="type"><span class="type">OSDictionary</span></a> <span class="type">*</span> <!-- a --><span class="function">propertyMatching</span><!-- /a -->(
    <span class="keyword">const</span> <!-- a --><span class="var">OSSymbol</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">key</span><!-- /a -->,
    <span class="keyword">const</span> <!-- a --><span class="var">OSObject</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">value</span><!-- /a -->, 
    <!-- a --><span class="var">OSDictionary</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">table</span><!-- /a --> = <span class="number">0</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>key</code></dt>
<dd><p>The service's phandle, as a const UInt32. PHandle matching is successful on IOService objects that respond successfully to the IORegistryEntry method compareName.</p></dd>
<dt><code>value</code></dt>
<dd><p>The service's phandle, as a const UInt32. PHandle matching is successful on IOService's which respond successfully to the IORegistryEntry method compareName.</p></dd>
<dt><code>table</code></dt>
<dd><p>If zero, nameMatching will create a matching dictionary and return a reference to it, otherwise the matching properties are added to the specified dictionary.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->The matching dictionary created, or passed in, is returned on success, or zero on failure. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>TODO A very common matching criteria for IOService is based on its name. nameMatching will create a matching dictionary that specifies any IOService which respond successfully to the IORegistryEntry method compareName. An existing dictionary may be passed in, in which case the matching properties will be added to that dictionary rather than creating a new one.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=clm;  uid=//apple_ref/cpp/clm/IOService/publishResource/void/(constchar*,OSObject*);   name=IOService::publishResource --><a name="//apple_ref/cpp/clm/IOService/publishResource/void/(constchar*,OSObject*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="publishResource(constchar*,OSObject*)">publishResource(const char *, OSObject *)</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Uses the resource service to publish a property.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">static</span> <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <!-- a --><span class="function">publishResource</span><!-- /a -->(
    <span class="keyword">const</span> <!-- a --><span class="var">char</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">key</span><!-- /a -->,
    <!-- a --><span class="var">OSObject</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">value</span><!-- /a --> = <span class="number">0</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>key</code></dt>
<dd><p>A C string key that globally identifies the object.</p></dd>
<dt><code>The</code></dt>
<dd><p>object to be published.</p></dd>
</dl>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>The resource service uses IOService object's matching and notification to allow objects to be published and found by any I/O Kit client by a global name. <code>publishResource</code> makes an object available to anyone waiting for it or looking for it in the future.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=clm;  uid=//apple_ref/cpp/clm/IOService/publishResource/void/(constOSSymbol*,OSObject*);   name=IOService::publishResource --><a name="//apple_ref/cpp/clm/IOService/publishResource/void/(constOSSymbol*,OSObject*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="publishResource(constOSSymbol*,OSObject*)">publishResource(const OSSymbol *, OSObject *)</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Uses the resource service to publish a property.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">static</span> <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <!-- a --><span class="function">publishResource</span><!-- /a -->(
    <span class="keyword">const</span> <!-- a --><span class="var">OSSymbol</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">key</span><!-- /a -->,
    <!-- a --><span class="var">OSObject</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">value</span><!-- /a --> = <span class="number">0</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>key</code></dt>
<dd><p>An OSSymbol key that globally identifies the object.</p></dd>
<dt><code>The</code></dt>
<dd><p>object to be published.</p></dd>
</dl>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>The resource service uses IOService's matching and notification to allow objects to be published and found by any I/O Kit client by a global name. <code>publishResource</code> makes an object available to anyone waiting for it or looking for it in the future.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/registerInterestedDriver/IOPMPowerFlags/(IOService*);   name=IOService::registerInterestedDriver --><a name="//apple_ref/cpp/instm/IOService/registerInterestedDriver/IOPMPowerFlags/(IOService*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="registerInterestedDriver">registerInterestedDriver</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Allows an IOService object to register interest in the changing power state of a power-managed IOService object.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOPM_h/index.html#//apple_ref/c/tdef/IOPMPowerFlags" target="_top" class="type"><span class="type">IOPMPowerFlags</span></a> <!-- a --><span class="function">registerInterestedDriver</span><!-- /a --> (
    <a href="index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span><span class="param">theDriver</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>theDriver</code></dt>
<dd><p>The driver of interest adds this pointer to the list of interested drivers. It informs drivers on this list before and after the power change.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Flags describing the capability of the device in its current power state. If the current power state is not yet defined, zero is returned (this is the case when the driver is not yet in the power domain hierarchy or hasn't fully registered with power management yet). 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Call <code>registerInterestedDriver</code> on the IOService object you are interested in receiving power state messages from, and pass a pointer to the interested driver (<code>this</code>) as an argument.
</p>
<p>The interested driver should override <a href="index.html#//apple_ref/cpp/instm/IOService/powerStateWillChangeTo/IOReturn/(IOPMPowerFlags,unsignedlong,IOService*)" target="_top">powerStateWillChangeTo</a> and <a href="index.html#//apple_ref/cpp/instm/IOService/powerStateDidChangeTo/IOReturn/(IOPMPowerFlags,unsignedlong,IOService*)" target="_top">powerStateDidChangeTo</a> to receive these power change messages.
</p>
<p>Interested drivers must acknowledge power changes in <code>powerStateWillChangeTo</code> or <code>powerStateDidChangeTo</code>, either via return value or later calls to <a href="index.html#//apple_ref/cpp/instm/IOService/acknowledgePowerChange/IOReturn/(IOService*)" target="_top">acknowledgePowerChange</a>.
</p>
<p>Most drivers do not need to override <code>registerInterestedDriver</code>.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/registerInterrupt/IOReturn/(int,OSObject*,IOInterruptAction,void*);   name=IOService::registerInterrupt --><a name="//apple_ref/cpp/instm/IOService/registerInterrupt/IOReturn/(int,OSObject*,IOInterruptAction,void*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="registerInterrupt">registerInterrupt</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Registers a C function interrupt handler for a device supplying interrupts.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">registerInterrupt</span><!-- /a -->(
    <!-- a --><span class="type">int</span><!-- /a --> <span class="param">source</span>,
    <a href="../../../OSObject_h/Classes/OSObject/index.html#//apple_ref/cpp/cl/OSObject" target="_top" class="type"><span class="type">OSObject</span></a> <span class="type">*</span><span class="param">target</span>, 
    <!-- a --><span class="type">IOInterruptAction</span><!-- /a --> <span class="param">handler</span>, 
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><!-- a --><span class="type">refCon</span><!-- /a --> = <span class="number">0</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>source</code></dt>
<dd><p>The index of the interrupt source in the device.</p></dd>
<dt><code>target</code></dt>
<dd><p>An object instance to be passed to the interrupt handler.</p></dd>
<dt><code>handler</code></dt>
<dd><p>The C function to be called at primary interrupt time when the interrupt occurs. The handler should process the interrupt by clearing the interrupt, or by disabling the source.</p></dd>
<dt><code>refCon</code></dt>
<dd><p>A reference constant for the handler's use.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->An IOReturn code.<br><code>kIOReturnNoInterrupt</code> is returned if the source is not valid; <code>kIOReturnNoResources</code> is returned if the interrupt already has an installed handler. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method installs a C function interrupt handler to be called at primary interrupt time for a device's interrupt. Only one handler may be installed per interrupt source. IOInterruptEventSource provides a work loop based abstraction for interrupt delivery that may be more appropriate for work loop based drivers.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/registerPowerDriver/IOReturn/(IOService*,IOPMPowerState*,unsignedlong);   name=IOService::registerPowerDriver --><a name="//apple_ref/cpp/instm/IOService/registerPowerDriver/IOReturn/(IOService*,IOPMPowerState*,unsignedlong)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="registerPowerDriver">registerPowerDriver</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Registers a set of power states that the driver supports.
</p>
<!-- end abstract -->
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">registerPowerDriver</span><!-- /a --> ( 
    <a href="index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span><span class="param">controllingDriver</span>, 
    <a href="../../../IOPMpowerState_h/index.html#//apple_ref/c/tag/IOPMPowerState" target="_top" class="type"><span class="type">IOPMPowerState</span></a> <span class="type">*</span><span class="param">powerStates</span>, 
    <span class="keyword">unsigned</span> <!-- a --><span class="type">long</span><!-- /a --> <span class="param">numberOfStates</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>controllingDriver</code></dt>
<dd><p>A pointer to the calling driver, usually <code>this</code>.</p></dd>
<dt><code>powerStates</code></dt>
<dd><p>A driver-defined array of power states that the driver and device support. Power states are defined in <code>pwr_mgt/IOPMpowerState.h</code>.</p></dd>
<dt><code>numberOfStates</code></dt>
<dd><p>The number of power states in the array.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->IOPMNoErr. All errors are logged via <code>kprintf</code>.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>A driver defines its array of supported power states with power management in its power management initialization (its <code>start</code> routine). If successful, power management will call the driver to instruct it to change its power state through <a href="index.html#//apple_ref/cpp/instm/IOService/setPowerState/IOReturn/(unsignedlong,IOService*)" target="_top">setPowerState</a>.
</p>
<p>Most drivers do not need to override <code>registerPowerDriver</code>. A nub may override <code>registerPowerDriver</code> if it needs to arrange its children in the power plane differently than the default placement, but this is uncommon.
</p>
<!-- end discussion -->
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/registerService/void/(IOOptionBits);   name=IOService::registerService --><a name="//apple_ref/cpp/instm/IOService/registerService/void/(IOOptionBits)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="registerService">registerService</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Starts the registration process for a newly discovered IOService object.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <!-- a --><span class="function">registerService</span><!-- /a -->(
    <a href="../../../USB_h/index.html#//apple_ref/c/tag/IOOptionBits" target="_top" class="type"><span class="type">IOOptionBits</span></a> <!-- a --><span class="type">options</span><!-- /a --> = <span class="number">0</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>options</code></dt>
<dd><p>The default zero options mask is recommended and should be used in most cases. The registration process is usually asynchronous, with possible driver probing and notification occurring some time later. <code>kIOServiceSynchronous</code> may be passed to carry out the matching and notification process for currently registered clients before returning to the caller.</p></dd>
</dl>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This function allows an IOService subclass to be published and made available to possible clients, by starting the registration process and delivering notifications to registered clients. The object should be completely setup and ready to field requests from clients before <code>registerService</code> is called.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/removePowerChild/IOReturn/(IOPowerConnection*);   name=IOService::removePowerChild --><a name="//apple_ref/cpp/instm/IOService/removePowerChild/IOReturn/(IOPowerConnection*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="removePowerChild">removePowerChild</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Informs a power managed driver that one of its power plane childen is disappearing. 
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">removePowerChild</span><!-- /a --> (
    <a href="../../../IOPowerConnection_h/Classes/IOPowerConnection/index.html#//apple_ref/cpp/cl/IOPowerConnection" target="_top" class="type"><span class="type">IOPowerConnection</span></a> <span class="type">*</span><span class="param">theChild</span> ); </pre>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This call is handled internally by power management. It is not intended to be overridden or called by drivers.
</p>
<!-- end discussion -->
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/requestPowerDomainState/IOReturn/(IOPMPowerFlags,IOPowerConnection*,unsignedlong);   name=IOService::requestPowerDomainState --><a name="//apple_ref/cpp/instm/IOService/requestPowerDomainState/IOReturn/(IOPMPowerFlags,IOPowerConnection*,unsignedlong)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="requestPowerDomainState">requestPowerDomainState</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Tells a driver to adjust its power state.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">requestPowerDomainState</span><!-- /a --> ( 
    <a href="../../../IOPM_h/index.html#//apple_ref/c/tdef/IOPMPowerFlags" target="_top" class="type"><span class="type">IOPMPowerFlags</span></a> <span class="param">desiredState</span>, 
    <a href="../../../IOPowerConnection_h/Classes/IOPowerConnection/index.html#//apple_ref/cpp/cl/IOPowerConnection" target="_top" class="type"><span class="type">IOPowerConnection</span></a> <span class="type">*</span><span class="param">whichChild</span>, 
    <span class="keyword">unsigned</span> <!-- a --><span class="type">long</span><!-- /a --> <span class="param">specificationFlags</span> ); </pre>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This call is handled internally by power management. It is not intended to be overridden or called by drivers.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/requestProbe/IOReturn/(IOOptionBits);   name=IOService::requestProbe --><a name="//apple_ref/cpp/instm/IOService/requestProbe/IOReturn/(IOOptionBits)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="requestProbe">requestProbe</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Requests that hardware be re-scanned for devices.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">requestProbe</span><!-- /a -->(
    <a href="../../../USB_h/index.html#//apple_ref/c/tag/IOOptionBits" target="_top" class="type"><span class="type">IOOptionBits</span></a> <span class="param">options</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>options</code></dt>
<dd><p>Family defined options, not interpreted by IOService.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->An IOReturn code. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>For bus families that do not usually detect device addition or removal, this method represents an external request (eg. from a utility application) to rescan and publish or remove found devices.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/requestTerminate/bool/(IOService*,IOOptionBits);   name=IOService::requestTerminate --><a name="//apple_ref/cpp/instm/IOService/requestTerminate/bool/(IOService*,IOOptionBits)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="requestTerminate">requestTerminate</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Passes a termination up the stack.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">requestTerminate</span><!-- /a -->(
    <a href="index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span><span class="param">provider</span>,
    <a href="../../../USB_h/index.html#//apple_ref/c/tag/IOOptionBits" target="_top" class="type"><span class="type">IOOptionBits</span></a> <span class="param">options</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>provider</code></dt>
<dd><p>The terminated provider of this object.</p></dd>
<dt><code>options</code></dt>
<dd><p>Options originally passed to terminate, plus <code>kIOServiceRecursing</code>.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --><code>true</code> if this object should be terminated now that its provider has been. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>When an IOService is made inactive the default behavior is to also make any of its clients that have it as their only provider also inactive, in this way recursing the termination up the driver stack. This method allows an IOService object to override this behavior. Returning <code>true</code> from this method when passed a just terminated provider will cause the client to also be terminated.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=clm;  uid=//apple_ref/cpp/clm/IOService/resourceMatching/OSDictionary*/(constchar*,OSDictionary*);   name=IOService::resourceMatching --><a name="//apple_ref/cpp/clm/IOService/resourceMatching/OSDictionary*/(constchar*,OSDictionary*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="resourceMatching(constchar*,OSDictionary*)">resourceMatching(const char *, OSDictionary *)</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Creates a matching dictionary, or adds matching properties to an existing dictionary, that specify a resource service match.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">static</span> <a href="../../../OSDictionary_h/Classes/OSDictionary/index.html#//apple_ref/cpp/cl/OSDictionary" target="_top" class="type"><span class="type">OSDictionary</span></a> <span class="type">*</span> <!-- a --><span class="function">resourceMatching</span><!-- /a -->(
    <span class="keyword">const</span> <!-- a --><span class="var">char</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">name</span><!-- /a -->, 
    <!-- a --><span class="var">OSDictionary</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">table</span><!-- /a --> = <span class="number">0</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>name</code></dt>
<dd><p>The resource name, as a const C string. Resource matching is successful when an object by that name has been published with the <code>publishResource</code> method.</p></dd>
<dt><code>table</code></dt>
<dd><p>If zero, <code>resourceMatching</code> creates a matching dictionary and returns a reference to it, otherwise the matching properties are added to the specified dictionary.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->The matching dictionary created, or passed in, is returned on success, or zero on failure. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOService maintains a resource service IOResources that allows objects to be published and found globally in the I/O Kit based on a name, using the standard IOService matching and notification calls.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=clm;  uid=//apple_ref/cpp/clm/IOService/resourceMatching/OSDictionary*/(constOSString*,OSDictionary*);   name=IOService::resourceMatching --><a name="//apple_ref/cpp/clm/IOService/resourceMatching/OSDictionary*/(constOSString*,OSDictionary*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="resourceMatching(constOSString*,OSDictionary*)">resourceMatching(const OSString *, OSDictionary *)</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Creates a matching dictionary, or adds matching properties to an existing dictionary, that specify a resource service match.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">static</span> <a href="../../../OSDictionary_h/Classes/OSDictionary/index.html#//apple_ref/cpp/cl/OSDictionary" target="_top" class="type"><span class="type">OSDictionary</span></a> <span class="type">*</span> <!-- a --><span class="function">resourceMatching</span><!-- /a -->(
    <span class="keyword">const</span> <!-- a --><span class="var">OSString</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">name</span><!-- /a -->, 
    <!-- a --><span class="var">OSDictionary</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">table</span><!-- /a --> = <span class="number">0</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>name</code></dt>
<dd><p>The resource name, as an OSString (which includes OSSymbol). Resource matching is successful when an object by that name has been published with the <code>publishResource</code> method.</p></dd>
<dt><code>table</code></dt>
<dd><p>If zero, <code>resourceMatching</code> creates a matching dictionary and returns a reference to it, otherwise the matching properties are added to the specified dictionary.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->The matching dictionary created, or passed in, is returned on success, or zero on failure. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>IOService maintains a resource service IOResources that allows objects to be published and found globally in the I/O Kit based on a name, using the standard IOService matching and notification calls.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=clm;  uid=//apple_ref/cpp/clm/IOService/serviceMatching/OSDictionary*/(constchar*,OSDictionary*);   name=IOService::serviceMatching --><a name="//apple_ref/cpp/clm/IOService/serviceMatching/OSDictionary*/(constchar*,OSDictionary*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="serviceMatching(constchar*,OSDictionary*)">serviceMatching(const char *, OSDictionary *)</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Creates a matching dictionary, or adds matching properties to an existing dictionary, that specify an IOService class match.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">static</span> <a href="../../../OSDictionary_h/Classes/OSDictionary/index.html#//apple_ref/cpp/cl/OSDictionary" target="_top" class="type"><span class="type">OSDictionary</span></a> <span class="type">*</span> <!-- a --><span class="function">serviceMatching</span><!-- /a -->(
    <span class="keyword">const</span> <!-- a --><span class="var">char</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">className</span><!-- /a -->, 
    <!-- a --><span class="var">OSDictionary</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">table</span><!-- /a --> = <span class="number">0</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>className</code></dt>
<dd><p>The class name, as a const C string. Class matching is successful on IOService objects of this class or any subclass.</p></dd>
<dt><code>table</code></dt>
<dd><p>If zero, <code>serviceMatching</code> creates a matching dictionary and returns a reference to it, otherwise the matching properties are added to the specified dictionary.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->The matching dictionary created, or passed in, is returned on success, or zero on failure. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>A very common matching criteria for IOService object is based on its class. <code>serviceMatching</code> creates a matching dictionary that specifies any IOService object of a class, or its subclasses. The class is specified by name, and an existing dictionary may be passed in, in which case the matching properties will be added to that dictionary rather than creating a new one.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=clm;  uid=//apple_ref/cpp/clm/IOService/serviceMatching/OSDictionary*/(constOSString*,OSDictionary*);   name=IOService::serviceMatching --><a name="//apple_ref/cpp/clm/IOService/serviceMatching/OSDictionary*/(constOSString*,OSDictionary*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="serviceMatching(constOSString*,OSDictionary*)">serviceMatching(const OSString *, OSDictionary *)</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Creates a matching dictionary, or adds matching properties to an existing dictionary, that specify an IOService class match.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">static</span> <a href="../../../OSDictionary_h/Classes/OSDictionary/index.html#//apple_ref/cpp/cl/OSDictionary" target="_top" class="type"><span class="type">OSDictionary</span></a> <span class="type">*</span> <!-- a --><span class="function">serviceMatching</span><!-- /a -->(
    <span class="keyword">const</span> <!-- a --><span class="var">OSString</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">className</span><!-- /a -->, 
    <!-- a --><span class="var">OSDictionary</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">table</span><!-- /a --> = <span class="number">0</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>className</code></dt>
<dd><p>The class name, as an OSString (which includes OSSymbol). Class matching is successful on IOService objects of this class or any subclass.</p></dd>
<dt><code>table</code></dt>
<dd><p>If zero, <code>serviceMatching</code> creates a matching dictionary and returns a reference to it, otherwise the matching properties are added to the specified dictionary.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->The matching dictionary created, or passed in, is returned on success, or zero on failure. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>A very common matching criteria for IOService object is based on its class. <code>serviceMatching</code> creates a matching dictionary that specifies any IOService of a class, or its subclasses. The class is specified by name, and an existing dictionary may be passed in, in which case the matching properties will be added to that dictionary rather than creating a new one.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/setAggressiveness/IOReturn/(unsignedlong,unsignedlong);   name=IOService::setAggressiveness --><a name="//apple_ref/cpp/instm/IOService/setAggressiveness/IOReturn/(unsignedlong,unsignedlong)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="setAggressiveness">setAggressiveness</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Broadcasts an aggressiveness factor from the parent of a driver to the driver.
</p>
<!-- end abstract -->
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">setAggressiveness</span><!-- /a --> ( 
    <span class="keyword">unsigned</span> <!-- a --><span class="type">long</span><!-- /a --> <span class="param">type</span>, 
    <span class="keyword">unsigned</span> <!-- a --><span class="type">long</span><!-- /a --> <span class="param">newLevel</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>type</code></dt>
<dd><p>The aggressiveness factor type, such as <code>kPMMinutesToDim</code>, <code>kPMMinutesToSpinDown</code>, <code>kPMMinutesToSleep</code>, and <code>kPMPowerSource</code>. (Aggressiveness factors are defined in <code>pwr_mgt/IOPM.h</code>.)</p></dd>
<dt><code>newLevel</code></dt>
<dd><p>The aggressiveness factor's new value.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --><code>IOPMNoErr</code>. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Implement <code>setAggressiveness</code> to receive a notification when an "aggressiveness Aggressiveness factors are a loose set of power management variables that contain values for system sleep timeout, display sleep timeout, whether the system is on battery or AC, and other power management features. There are several aggressiveness factors that can be broadcast and a driver may take action on whichever factors apply to it.
</p>
<p>A driver that has joined the power plane via <a href="index.html#//apple_ref/cpp/instm/IOService/joinPMtree/void/(IOService*)" target="_top">joinPMtree</a> will receive <code>setAgressiveness</code> calls when aggressiveness factors change.
</p>
<p>A driver may override this call if it needs to do something with the new factor (such as change its idle timeout). If overridden, the driver must  call its superclass's <code>setAgressiveness</code> method in its own <code>setAgressiveness</code> implementation.
</p>
<p>Most drivers do not need to implement <code>setAgressiveness</code>.
</p>
<!-- end discussion -->
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/setDeviceMemory/void/(OSArray*);   name=IOService::setDeviceMemory --><a name="//apple_ref/cpp/instm/IOService/setDeviceMemory/void/(OSArray*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="setDeviceMemory">setDeviceMemory</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Sets the array of IODeviceMemory objects representing a device's memory mapped ranges.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <!-- a --><span class="function">setDeviceMemory</span><!-- /a -->(
    <a href="../../../OSArray_h/Classes/OSArray/index.html#//apple_ref/cpp/cl/OSArray" target="_top" class="type"><span class="type">OSArray</span></a> <span class="type">*</span><span class="param">array</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>array</code></dt>
<dd><p>An OSArray of IODeviceMemory objects, or zero if none are available. The array will be retained by the object.</p></dd>
</dl>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method sets an array of IODeviceMemory objects representing the physical memory ranges allocated to a memory mapped device.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/setIdleTimerPeriod/IOReturn/(unsigned);   name=IOService::setIdleTimerPeriod --><a name="//apple_ref/cpp/instm/IOService/setIdleTimerPeriod/IOReturn/(unsigned)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="setIdleTimerPeriod">setIdleTimerPeriod</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Sets or changes the idle timer period.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">setIdleTimerPeriod</span><!-- /a --> (
    <span class="keyword">unsigned</span> <span class="param">long</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>period</code></dt>
<dd><p>The desired idle timer period in seconds.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --><code>kIOReturnSuccess</code> if successful. May return <code>kIOReturnError</code> if there was difficulty creating the timer event or the command queue. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>A driver using the idleness determination provided by IOService calls its superclass with this method to set or change the idle timer period. See <a href="index.html#//apple_ref/cpp/instm/IOService/activityTickle/bool/(unsignedlong,unsignedlong)" target="_top">activityTickle</a> for a description of this type of idleness determination. 
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/setPowerParent/IOReturn/(IOPowerConnection*,bool,IOPMPowerFlags);   name=IOService::setPowerParent --><a name="//apple_ref/cpp/instm/IOService/setPowerParent/IOReturn/(IOPowerConnection*,bool,IOPMPowerFlags)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="setPowerParent">setPowerParent</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>For internal use only; deprecated; not intended to be called or overridden.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">setPowerParent</span><!-- /a --> ( 
    <a href="../../../IOPowerConnection_h/Classes/IOPowerConnection/index.html#//apple_ref/cpp/cl/IOPowerConnection" target="_top" class="type"><span class="type">IOPowerConnection</span></a> <span class="type">*</span><span class="param">theParent</span>, 
    <!-- a --><span class="type">bool</span><!-- /a --> <span class="param">stateKnown</span>, 
    <a href="../../../IOPM_h/index.html#//apple_ref/c/tdef/IOPMPowerFlags" target="_top" class="type"><span class="type">IOPMPowerFlags</span></a> <span class="param">currentState</span> ); </pre>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/setPowerState/IOReturn/(unsignedlong,IOService*);   name=IOService::setPowerState --><a name="//apple_ref/cpp/instm/IOService/setPowerState/IOReturn/(unsignedlong,IOService*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="setPowerState">setPowerState</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Requests a power managed driver to change the power state of its device.
</p>
<!-- end abstract -->
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">setPowerState</span><!-- /a --> ( 
    <span class="keyword">unsigned</span> <!-- a --><span class="type">long</span><!-- /a --> <span class="param">powerStateOrdinal</span>, 
    <a href="index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span><span class="param">whatDevice</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>powerStateOrdinal</code></dt>
<dd><p>The number in the power state array of the state the driver is being instructed to switch to.</p></dd>
<dt><code>whatDevice</code></dt>
<dd><p>A pointer to the power management object which registered to manage power for this device. In most cases, <code>whatDevice</code> will be equal to your driver's own <code>this</code> pointer.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->The driver must return <code>IOPMAckImplied</code> if it has complied with the request when it returns. Otherwise if it has started the process of changing power state but not finished it, the driver should return a number of microseconds which is an upper limit of the time it will need to finish. Then, when it has completed the power switch, it should call <a href="index.html#//apple_ref/cpp/instm/IOService/acknowledgeSetPowerState/IOReturn/()" target="_top">acknowledgeSetPowerState</a>. 

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>A power managed driver must override <code>setPowerState</code> to take part in system power management. After a driver is registered with power management, the system uses <code>setPowerState</code> to power the device off and on for system sleep and wake.
</p>
<p>Calls to <a href="index.html#//apple_ref/cpp/instm/IOService/PMinit/void/()" target="_top">PMinit</a> and <a href="index.html#//apple_ref/cpp/instm/IOService/registerPowerDriver/IOReturn/(IOService*,IOPMPowerState*,unsignedlong)" target="_top">registerPowerDriver</a> enable power management to change a device's power state using <code>setPowerState</code>.
</p>
<p><code>setPowerState</code> is called in a clean and separate thread context.
</p>
<!-- end discussion -->
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/start/bool/(IOService*);   name=IOService::start --><a name="//apple_ref/cpp/instm/IOService/start/bool/(IOService*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="start">start</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>During an IOService object's instantiation, starts the IOService object that has been selected to run on the provider.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">start</span><!-- /a -->(
    <a href="index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span><span class="param">provider</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --><code>true</code> if the start was successful; <code>false</code> otherwise (which will cause the instance to be detached and usually freed). 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>The <code>start</code> method of an IOService instance is called by its provider when it has been selected (due to its probe score and match category) as the winning client. The client is already attached to the provider when <code>start</code> is called.<br>Implementations of <code>start</code> must call <code>start</code> on their superclass at an appropriate point. If an implementation of <code>start</code> has already called <code>super::start</code> but subsequently determines that it will fail, it must call <code>super::stop</code> to balance the prior call to <code>super::start</code> and prevent reference leaks.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/stop/void/(IOService*);   name=IOService::stop --><a name="//apple_ref/cpp/instm/IOService/stop/void/(IOService*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="stop">stop</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>During an IOService termination, the stop method is called in its clients before they are detached &amp; it is destroyed.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <!-- a --><span class="function">stop</span><!-- /a -->(
    <a href="index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span><span class="param">provider</span> ); </pre>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>The termination process for an IOService (the provider) will call stop in each of its clients, after they have closed the provider if they had it open, or immediately on termination. <!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/stringFromReturn/constchar*/(IOReturn);   name=IOService::stringFromReturn --><a name="//apple_ref/cpp/instm/IOService/stringFromReturn/constchar*/(IOReturn)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="stringFromReturn">stringFromReturn</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Supplies a programmer-friendly string from an IOReturn code.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <span class="keyword">const</span> <!-- a --><span class="var">char</span><!-- /a --> <span class="var">*</span> <!-- a --><span class="var">stringFromReturn</span><!-- /a -->( <!-- a --><span class="var">IOReturn</span><!-- /a --> <!-- a --><span class="var">rtn</span><!-- /a --> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>rtn</code></dt>
<dd><p>The IOReturn code.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->A pointer to a constant string, or zero if the return code is unknown. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Strings are available for the standard return codes in <code>IOReturn.h</code> in IOService, while subclasses may implement this method to interpret family dependent return codes.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/systemWake/IOReturn/();   name=IOService::systemWake --><a name="//apple_ref/cpp/instm/IOService/systemWake/IOReturn/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="systemWake">systemWake</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Tells every driver in the power plane that the system is waking up.  
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">systemWake</span><!-- /a --> (
    <span class="param">void</span> ); </pre>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This call is handled internally by power management. It is not intended to be overridden or called by drivers.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/systemWillShutdown/void/(IOOptionBits);   name=IOService::systemWillShutdown --><a name="//apple_ref/cpp/instm/IOService/systemWillShutdown/void/(IOOptionBits)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="systemWillShutdown">systemWillShutdown</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Notifies members of the power plane of system shutdown and restart.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <!-- a --><span class="function">systemWillShutdown</span><!-- /a -->(
    <a href="../../../USB_h/index.html#//apple_ref/c/tag/IOOptionBits" target="_top" class="type"><span class="type">IOOptionBits</span></a> <span class="param">specifier</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>specifier</code></dt>
<dd><p><code>kIOMessageSystemWillPowerOff</code> or <code>kIOMessageSystemWillRestart</code>.</p></dd>
</dl>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This function is called for all members of the power plane in leaf-to-root order. If a subclass needs to wait for a pending I/O, then the call to <code>systemWillShutdown</code> should be postponed until the I/O completes.
</p>
<p>Any power managed driver (which has called <a href="index.html#//apple_ref/cpp/instm/IOService/joinPMtree/void/(IOService*)" target="_top">joinPMtree</a> to join the power plane) interested in taking action at system shutdown or restart should override this method.
<!-- end discussion -->
</p>
<p></p>
<dl>
<dt><i>Availability</i></dt>
<dd>Mac OS X v10.5 and later
</dd>
</dl>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/temperatureCriticalForZone/IOReturn/(IOService*);   name=IOService::temperatureCriticalForZone --><a name="//apple_ref/cpp/instm/IOService/temperatureCriticalForZone/IOReturn/(IOService*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="temperatureCriticalForZone">temperatureCriticalForZone</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Alerts a driver to a critical temperature in some thermal zone.  
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">temperatureCriticalForZone</span><!-- /a --> (
    <a href="index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span><span class="param">whichZone</span> ); </pre>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This call is unused by power management. It is not intended to be called or overridden.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/temporaryPowerClampOn/IOReturn/();   name=IOService::temporaryPowerClampOn --><a name="//apple_ref/cpp/instm/IOService/temporaryPowerClampOn/IOReturn/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="temporaryPowerClampOn">temporaryPowerClampOn</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>A driver calls this method to hold itself in the highest power state until it has children.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">temporaryPowerClampOn</span><!-- /a --> (
    <span class="param">void</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->A return code that can be ignored by the caller.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Use <code>temporaryPowerClampOn</code> to hold your driver in its highest power state while waiting for child devices to attach. After children have attached, the clamp is released and the device's power state is controlled by the children's requirements. 
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/terminate/bool/(IOOptionBits);   name=IOService::terminate --><a name="//apple_ref/cpp/instm/IOService/terminate/bool/(IOOptionBits)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="terminate">terminate</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Makes an IOService object inactive and begins its destruction.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">terminate</span><!-- /a -->(
    <a href="../../../USB_h/index.html#//apple_ref/c/tag/IOOptionBits" target="_top" class="type"><span class="type">IOOptionBits</span></a> <!-- a --><span class="type">options</span><!-- /a --> = <span class="number">0</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>options</code></dt>
<dd><p>In most cases no options are needed. <code>kIOServiceSynchronous</code> may be passed to cause <code>terminate</code> to not return until the service is finalized.</p></dd>
</dl>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Registering an IOService object informs possible clients of its existance and instantiates drivers that may be used with it; <code>terminate</code> involves the opposite process of informing clients that an IOService object is no longer able to be used and will be destroyed. By default, if any client has the service open, <code>terminate</code> fails. If the <code>kIOServiceRequired</code> flag is passed however, <code>terminate</code> will be successful though further progress in the destruction of the IOService object will not proceed until the last client has closed it. The service will be made inactive immediately upon successful termination, and all its clients will be notified via their <a href="index.html#//apple_ref/cpp/instm/IOService/message/IOReturn/(UInt32,IOService*,void*)" target="_top">message</a> method with a message of type <code>kIOMessageServiceIsTerminated</code>. Both these actions take place on the caller's thread. After the IOService object is made inactive, further matching or attach calls will fail on it. Each client has its <a href="index.html#//apple_ref/cpp/instm/IOService/stop/void/(IOService*)" target="_top">stop</a> method called upon their close of an inactive IOService object , or on its termination if they do not have it open. After <code>stop</code>, <a href="index.html#//apple_ref/cpp/instm/IOService/detach/void/(IOService*)" target="_top">detach</a> is called in each client. When all clients have been detached, the <a href="index.html#//apple_ref/cpp/instm/IOService/finalize/bool/(IOOptionBits)" target="_top">finalize</a> method is called in the inactive service. The termination process is inherently asynchronous because it will be deferred until all clients have chosen to close.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/terminateClient/bool/(IOService*,IOOptionBits);   name=IOService::terminateClient --><a name="//apple_ref/cpp/instm/IOService/terminateClient/bool/(IOService*,IOOptionBits)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="terminateClient">terminateClient</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Passes a termination up the stack.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">terminateClient</span><!-- /a -->(
    <a href="index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span><span class="param">client</span>,
    <a href="../../../USB_h/index.html#//apple_ref/c/tag/IOOptionBits" target="_top" class="type"><span class="type">IOOptionBits</span></a> <span class="param">options</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>client</code></dt>
<dd><p>The client of the terminated provider.</p></dd>
<dt><code>options</code></dt>
<dd><p>Options originally passed to <a href="index.html#//apple_ref/cpp/instm/IOService/terminate/bool/(IOOptionBits)" target="_top">terminate</a>, plus <code>kIOServiceRecursing</code>.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->result of the terminate request on the client. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>When an IOService object is made inactive the default behavior is to also make any of its clients that have it as their only provider inactive, in this way recursing the termination up the driver stack. This method allows a terminated  IOService object to override this behavior. Note the client may also override this behavior by overriding its <a href="index.html#//apple_ref/cpp/instm/IOService/terminate/bool/(IOOptionBits)" target="_top">terminate</a> method.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/unlockForArbitration/void/();   name=IOService::unlockForArbitration --><a name="//apple_ref/cpp/instm/IOService/unlockForArbitration/void/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="unlockForArbitration">unlockForArbitration</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Unlocks an IOService obkect after a successful <a href="index.html#//apple_ref/cpp/instm/IOService/lockForArbitration/bool/(bool)" target="_top">lockForArbitration</a>.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <!-- a --><span class="function">unlockForArbitration</span><!-- /a -->(
    <span class="param">void</span> ); </pre>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>A thread granted exclusive access to an IOService object should release it with <code>unlockForArbitration</code>. <!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/unregisterInterrupt/IOReturn/(int);   name=IOService::unregisterInterrupt --><a name="//apple_ref/cpp/instm/IOService/unregisterInterrupt/IOReturn/(int)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="unregisterInterrupt">unregisterInterrupt</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Removes a C function interrupt handler for a device supplying hardware interrupts.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">unregisterInterrupt</span><!-- /a -->(
    <!-- a --><span class="type">int</span><!-- /a --> <span class="param">source</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>source</code></dt>
<dd><p>The index of the interrupt source in the device.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->An IOReturn code (<code>kIOReturnNoInterrupt</code> is returned if the source is not valid). 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method removes a C function interrupt handler previously installed with <a href="index.html#//apple_ref/cpp/instm/IOService/registerInterrupt/IOReturn/(int,OSObject*,IOInterruptAction,void*)" target="_top">registerInterrupt</a>.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=clm;  uid=//apple_ref/cpp/clm/IOService/waitForService/IOService*/(OSDictionary*,mach_timespec_t*);   name=IOService::waitForService --><a name="//apple_ref/cpp/clm/IOService/waitForService/IOService*/(OSDictionary*,mach_timespec_t*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="waitForService">waitForService</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Waits for a matching to service to be published.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">static</span> <a href="index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span> <!-- a --><span class="function">waitForService</span><!-- /a -->(
    <a href="../../../OSDictionary_h/Classes/OSDictionary/index.html#//apple_ref/cpp/cl/OSDictionary" target="_top" class="type"><span class="type">OSDictionary</span></a> <span class="type">*</span><span class="param">matching</span>, 
    <!-- a --><span class="type">mach_timespec_t</span><!-- /a --> <span class="type">*</span><!-- a --><span class="type">timeout</span><!-- /a --> = <span class="number">0</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>matching</code></dt>
<dd><p>The matching dictionary describing the desired IOService object. <code>waitForService</code> consumes one reference of the matching dictionary.</p></dd>
<dt><code>timeout</code></dt>
<dd><p>The maximum time to wait.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->A published IOService object matching the supplied dictionary. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Provides a method of waiting for an IOService object matching the supplied matching dictionary to be registered and fully matched. 
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/waitQuiet/IOReturn/(mach_timespec_t*);   name=IOService::waitQuiet --><a name="//apple_ref/cpp/instm/IOService/waitQuiet/IOReturn/(mach_timespec_t*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="waitQuiet">waitQuiet</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Waits for an IOService object's <code>busyState</code> to be zero.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">waitQuiet</span><!-- /a -->(
    <!-- a --><span class="type">mach_timespec_t</span><!-- /a --> <span class="type">*</span><!-- a --><span class="type">timeout</span><!-- /a --> = <span class="number">0</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>timeout</code></dt>
<dd><p>Specifies a maximum time to wait.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns an error code if Mach synchronization primitives fail, <code>kIOReturnTimeout</code>, or <code>kIOReturnSuccess</code>. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Blocks the caller until an IOService object is non busy.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/willTerminate/bool/(IOService*,IOOptionBits);   name=IOService::willTerminate --><a name="//apple_ref/cpp/instm/IOService/willTerminate/bool/(IOService*,IOOptionBits)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="willTerminate">willTerminate</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Passes a termination up the stack.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">willTerminate</span><!-- /a -->(
    <a href="index.html#//apple_ref/cpp/cl/IOService" target="_top" class="type"><span class="type">IOService</span></a> <span class="type">*</span><span class="param">provider</span>,
    <a href="../../../USB_h/index.html#//apple_ref/c/tag/IOOptionBits" target="_top" class="type"><span class="type">IOOptionBits</span></a> <span class="param">options</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>provider</code></dt>
<dd><p>The terminated provider of this object.</p></dd>
<dt><code>options</code></dt>
<dd><p>Options originally passed to terminate.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value --><code>true</code>. 
<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Notification that a provider has been terminated, sent before recursing up the stack, in root-to-leaf order.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOService/youAreRoot/IOReturn/();   name=IOService::youAreRoot --><a name="//apple_ref/cpp/instm/IOService/youAreRoot/IOReturn/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="youAreRoot">youAreRoot</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Informs the root power domain IOService object that is is the root power domain.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IOReturn_h/index.html#//apple_ref/c/tdef/IOReturn" target="_top" class="type"><span class="type">IOReturn</span></a> <!-- a --><span class="function">youAreRoot</span><!-- /a --> (
    <span class="param">void</span> ); </pre>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>The Platform Expert instantiates the root power domain IOService object and calls it with this method to inform it that it is the root power domain.
</p>
<p>This call is handled internally by power management. It is not intended to be overridden or called by drivers.
<!-- end discussion -->
</p>
<p></p>
<h2>Structs and Unions</h2>
<hr>
<!-- headerDoc=tag;  uid=//apple_ref/cpp/tag/IOService/ExpansionData;   name=IOService::ExpansionData --><a name="//apple_ref/cpp/tag/IOService/ExpansionData"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="ExpansionData">ExpansionData</a></h3>
</td></tr></table>
<hr>
<p></p>
<pre><tt>protected</tt>
<br><span class="keyword">struct</span> <a href="../../../IOFWAddressSpace_h/index.html#//apple_ref/c/tag/ExpansionData" target="_top" class="type"><span class="type">ExpansionData</span></a> {
}; </pre>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This structure will be used to expand the capablilties of this class in the future.
<!-- end discussion -->
</p>
<p></p>
<h2>Member Data</h2>
<hr>
<!-- headerDoc=data;  uid=//apple_ref/cpp/data/IOService/reserved;   name=IOService::reserved --><a name="//apple_ref/cpp/data/IOService/reserved"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="reserved">reserved</a></h3>
</td></tr></table>
<hr>
<p></p>
<pre><tt>protected</tt>
<br><a href="../../../IOFWAddressSpace_h/index.html#//apple_ref/c/tag/ExpansionData" target="_top" class="type"><span class="type">ExpansionData</span></a> <span class="type">*</span> <a href="../../../IOFWAddressSpace_h/index.html#//apple_ref/c/data/reserved" target="_top" class="var"><span class="var">reserved</span></a>; </pre>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>Reserved for future use.  (Internal use only)<!-- end discussion -->
</p>
<p></p>
<p><!-- start of footer -->

<!-- start of footer --> 
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/KernelIOKitFramework/IOService_h/Classes/IOService/index.html%3Fid%3DTP30000816-3.4&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/KernelIOKitFramework/IOService_h/Classes/IOService/index.html%3Fid%3DTP30000816-3.4&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/KernelIOKitFramework/IOService_h/Classes/IOService/index.html%3Fid%3DTP30000816-3.4&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</p>
<p>&#160;</p>
<!--#include virtual="/footer"-->
<!-- end of footer -->


<!-- end of footer -->
Last Updated: 2008-12-19
</div>
<!-- headerDoc=cl; uid=//apple_ref/cpp/cl/IOService;  name=IOService--><a name="//apple_ref/cpp/cl/IOService"></a>
</body>
</html>
