<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 03-24-01 --><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note TN1061: Fundamentals of Open Firmware, Part I: The User Interface</title>    <meta name="keywords" content="Mac OS 8 Open firmware Forth connecting two machine mode">    <meta name="Description" content="Technical Note TN1061: This Technical Note describes theOpen Firmware User Interface and Forth, the Open Firmwarelanguage. This Note addresses how to connect the target machineto a host machine for two machine mode. It explains how touse the interface to go between two and one machine mode.It also provides an explanation of the basics of Forth, anintroduction to the device tree, and some debugging techniques."><meta name="categories" content="Hardware"><meta name="week-posted" content="Jul 1, 1996 - Jul 5, 1996"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002902" title="Fundamentals of Open Firmware, Part I: The User Interface"></a><A NAME="top"></A><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/HardwareDrivers/index.html">Hardware & Drivers</a> &gt; <a href="../../technicalnotes/HardwareDrivers/idxPCIandPCCard-date.html">PCI and PC Card</a> &gt; </p><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1061</div>
<div id="pageheadsub">Fundamentals of Open Firmware, Part I: The User Interface</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"> <!-- begin_header_box --> <table width="600" cellpadding="0" cellspacing="0" border="0">	<tr>		<td width=300 valign="top" align=left scope="row">			<table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>				</tr>				<tr bgcolor="#e6e6e6">					<td background="images/tnmenubody.gif" width=300 align=left>						<span id="menutitle">							CONTENTS                             <br>                            <br>						</span>					</td>				</tr>				<tr bgcolor="#e6e6e6">					<td background="images/tnmenubody.gif" width=300 align=left><!-- begin_toc --><p id="menutext"><A HREF = "#RTFToC1">About the Open Firmware User Interface</a><br><br><A HREF = "#RTFToC2">Connecting for Two-Machine Mode</a><br><br><A HREF = "#RTFToC3">An Introduction to Forth</a><br><br><A HREF = "#RTFToC4">The Device Tree</a><br><br><A HREF = "#Summary">Summary</a><br><br><A HREF = "#References">References</A><BR><BR><A HREF = "#Downloads">Downloadables</A></p><!-- end_toc --> 								</td>				</tr>				<tr>					<td width=300 align=left scope="row">						<img src="images/tnmenubottom.gif" alt="" width=300 height=16>					</td>				</tr>			</table>		</td>		<td width=300 valign="top" align=left>			<!-- begin_intro_text --><P id = "introtext">This Technote describes the Open Firmware User Interface and Forth, the OpenFirmware language. This Note addresses how to connect the target machine to ahost machine for two machine mode. It explains how to use the interface to gobetween two and one machine mode. It also provides an explanation of the basicsof Forth, an introduction to the device tree, and some debugging techniques.</p><P id = "introtext">This Technote is targeted at the expansion device designer and the driverwriter for that device. The reader should have an understanding of OpenFirmware as described by the IEEE 1275-1994 Specification, the PCI Local BusSpecification 2.0+, the PCI Bus Binding Specification 1.5, and <i>Designing PCICards and Drivers for Power Macintosh Computers</i>.</p><P id = "introtext">This purpose of this Technote is to supplement the sparse documentation covering Open Firmware on the Macintosh.</p><CENTER><TABLE BORDER=0 WIDTH=275><TR><td bgcolor="#E6E6E6" align=left><P id = "introtext"><B>Note:</B><BR>A Technote is insufficient to explain all features of Open Firmware thatare required by a driver writer and/or a board designer to comprehend, in orderto complete an expansion device project.</P></TD></TR></TABLE></CENTER><BR><CENTER><TABLE BORDER=0 WIDTH=275><TR><td bgcolor="#E6E6E6" align=left><P id = "introtext"><B>Note:</B><BR>This Note is written using a 9500 Macintosh. Your machine may be somewhatdifferent with respect to display output. For instance, the 9500 PCI seriesmachines are PCI Local Bus Specification 2.0 compliant. Newer machine may becompliant to version 2.1.</P></TD></TR></TABLE></CENTER><!-- end_intro_text --><!-- begin_date --><h3>&nbsp;Updated: [Jul 01 2000]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_header_box --> <BR><BR><hr width=500 align=center>          <BR><BR> <!-- begin_content --><a name = "RTFToC1"></A><H2>About the Open Firmware User Interface</H2><P><b>Open Firmware</b> is the process that controls the microprocessor afterhardware initialization and diagnostics are performed, but before the mainOperating System is passed control. It is responsible, among other things, forbuilding the device tree and probing the expansion slots for I/O devices. OpenFirmware queries PCI devices for its address space needs and dynamicallyassigns this space to each device. It is during this probing process that eachdevice and motherboard ASIC is given a node in the device tree.</p><P><b>Nodes</b>, which are also called <b>packages</b>, contain <b>properties</b>and <b>methods</b>. <b>Properties</b> are attributes that describe the hardwareand driver. <b>Methods</b> do work much like subroutines or procedures. Thehardware and software engineer can use the Open Firmware user interface todebug their device and driver, respectively. See <A HREF = "tn1044.html">Technote 1044,</a><i>Understanding PCI Expansion Choices for Mac OS 8, Part III </i> in the Open FirmwareTechnote Series, for details about properties and methods for variousdevices. You must be able to traverse the device tree to get to your node andthen to edit and debug that node.</p><P><b>Forth</b> is the human interface language to Open Firmware and the devicetree. If you're a board designer, you'll want to directly read and writeregisters on your device, and, therefore, must be able to move throughout thedevice tree, create and delete words, etc. The driver writer has similar needsand must also build an <b>FCode</b> representation of the driver properties andmethods. If the device contains a <b>boot driver</b>, that driver must bedebugged using the Open Firmware user interface.</p><P>A <b>boot driver</b> is written in Forth, then tokenized into FCode anddebugged from the interface. This form of driver is used during the earlieststages of the boot process before an operating system is available. Bootdrivers are typically display, keyboard, network, and block, but are notlimited to these.</p><P>The Open Firmware user interface, therefore, as specified by the IEEE1275-1994Specification, is required to allow board designers and driver writers accessto their hardware and software to build and debug their expansion deviceproject. Let's see how that works.</p><P><A HREF="#top">Back to top</A></P><a name = "RTFToC2"></A><H2>Connecting for Two-Machine Mode</H2><P>The Open Firmware user interface, hereafter called the interface, asimplemented on Macintoshes to date, comes up in two-machine mode. You canconnect the two machines together using the serial ports and cable. Start withthe modem ports for simplicity. Open Firmware defaults to the modem port. Use acommunication application such as Zterm, MacTerminal, or Microphone as thehost. Use these settings:</p><ul><li>38400 baud (typically 38.4 but some versions of OF may use 19.2 also)</li><li>No parity</li><li>8 data bits</li><li>1 stop bit</li><li>XON/XOFF handshake</li><li>ANSI/VT102 terminal protocol</li></ul><ol><li>Start the host and wait for the prompt.</li><li>Start the target machine while holding down the O, F, Option, and Commandkeys. (O, F stands for Open Firmware.) </li><li>Wait until you see: </li></ol><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>Open Firmware, 1.0.5To continue booting the MacOS type:BYETo continue booting from the default boot device type:BOOTok0 &gt;</pre>	</TD></TR></TABLE></CENTER><P>(This prompt will vary depending on the version of  OF running on the machine.For example, some newer machines, OF version is 2.0.x.)</p><P>The O.K. means the interpeter is waiting for keyboard input. The 0 indicatesthe top of the stack.</p><H3>Going between one and two machine modes</H3><P>To move from two machine to one machine mode during an individual session,enter the following redirection words: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>0 &gt; &quot; pci2/@f&quot; output    \ the path must point to your display node0 &gt; &quot; kbd&quot; input</pre>	</TD></TR></TABLE></CENTER><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>" kbd" is standard alias supported on all the machines. But there is nostandard alias for display screen. The redirection of output is specific topower surge machines. You will have to decide what is the display for thetarget machine and use that path name.</P></TD></TR></TABLE></CENTER><BR><P>Now, I must point out that after the output was directed to the target machinewhat you enter at the host for the second word ( i.e., input ) will not appearon your host display but on your target display. You can now enter you sessionon the target machine until you restart your target. Once you restart, yourinput and output capabilities will again be at the host. To make the changepermanent, used the printenv and setenv words. What follows is what theprintenv word displays. Note that there are two untitled columns. The leftcolumn displays current setting and the right diplays the default. You mustchange the environmental variables called input-device and output-device tocontain the path name to your keyboard and display, respectively. Then, when yourestart your target, you'll always be in one machine mode. Of course, sincethese variables are stored in NVRAM, you can reset them using theOption-Command-P-R keys upon restart. I'll leave this procedure to you, butlet's look at one more variable.</p><P><b>Auto-boot?</b> is its name and if you set auto-boot? to false, you no longerhave to hold down the Option-Command-O-F keys upon restart.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>0 &gt; printenvlittle-endian?      false               falsereal-mode?          false               falseauto-boot?          true                truediag-switch?        false               falsefcode-debug?        false               falseoem-banner?         false               falseoem-logo?           false               falseuse-nvramrc?        true                falsereal-base           -1                  -1real-size           100000              100000virt-base           -1                  -1virt-size           100000              100000load-base           4000                4000pci-probe-list      -1                  -1screen-#columns     64                  64screen-#rows        28                  28selftest-#megs      0                   0boot-device         /AAPL,ROM           /AAPL,ROMboot-filediag-device         fd: diags            fd: diagsdiag-fileinput-device        ttya                ttyaoutput-device       ttya                ttyaoem-banneroem-logoboot-command        boot                bootok0 &gt;</pre>	</TD></TR></TABLE></CENTER><p align="center">You are ready to use the interface and at this point and a few words aboutForth are needed.</p><P><A HREF="#top">Back to top</A></P><a name = "RTFToC3"></A><H2>An Introduction to Forth</H2><p align="center">Forth is a stack-based interpretive language that uses reverse Polish notation.You place operands onto the stack and then operate on the operands by enteringwords. Words are delimited by white spaces.</p><H3>Your First Forth Operation</H3><p align="center">Let's look at a simple example using four function arithmitic. We will add 5and 7 to get 12.</p><ol><li>Enter 5 CR (carriage return),</li><li>enter 7 CR</li><li>enter + CR</li><li>enter . CR</li></ol><p align="center">Your display should now look as follows: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>0 &gt; 5  ok1 &gt; 7  ok2 &gt; +  ok1 &gt; . C  ok</pre>	</TD></TR></TABLE></CENTER><p align="center">. . . But where is the correct answer, which is 12?</p><P><B>Setting Forth's Numeric Base</B></p><p>The C means 0xC for hexidecimal. The Open Firmware user interface defaults to ahexidecimal numeric-base. The radix can be hexidecimal, decimal, or octal andcan be changed as follows: </p><TABLE ALIGN=CENTER cellspacing=1 CELLPADDING=4 width=300><TR><td width=180 valign=top align=left>hex</td><td width=420 valign=top align=left>means interpet all input and output in hexidecimal.</td></tr> <TR><td width=180 valign=top align=left>decimal</td><td width=420 valign=top align=left>means interpet all input and output in decimal.</td></tr><TR><td width=180 valign=top align=left>octal </td><td width=420 valign=top align=left>means interpet all input and output in octal.</td></tr></table><p align="center">If you want to change only the next input or output character and then returnto the existing numeric-base, use these words.</p><TABLE ALIGN=CENTER cellspacing=1 CELLPADDING=4 width=300><TR><td width=180 valign=top align=left>h#</td><td width=420 valign=top align=left>means interpet the following number as hexadecimal.</td></tr><TR><td width=180 valign=top align=left>d# </td><td width=420 valign=top align=left>means interpet the following number as decimal.</td></tr><TR><td width=180 valign=top align=left>o# </td><td width=420 valign=top align=left>means interpet the following number as octal.</td></tr></table><p>Also, there is the .d and .h equivalent words for displaying.</p><p>To display the current base, output in decimal, enter: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>0 &gt; base @ .d 16k0 &gt;</pre>	</TD></TR></TABLE></CENTER><p>At this point, all the following numbers in this Technote will be decimal forconvienence.</p><p>Try the above example again, but this time begin by changing the default todecimal, and your results will look like the following: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>0 &gt; decimal  ok0 &gt; 5  ok1 &gt; 7  ok2 &gt; +  ok1 &gt; . 12  ok0 &gt;</pre>	</TD></TR></TABLE></CENTER><p>Since Forth interpets a word using white space delimiters, we can type morethan one word on a line as follows: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>0 &gt; 5 7 + . 12  ok0 &gt;</pre>	</TD></TR></TABLE></CENTER><H3>The .s Word</H3><p>Now try the same commands, substituting the &lt;.&gt; with a &lt;.s&gt;.Actually, you enter a period for &lt;.&gt;. </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>0 &gt; 5 7 + .s 12ok1 &gt;</pre>	</TD></TR></TABLE></CENTER><p>This shows us two things: </p><ol><li>Forth words can be punctuation marks, or even numbers; from now on in thisTechnote, we will surround Forth words with &lt;&gt;, for clarity.</li><li>&lt;.s&gt; displays the entire stack without removing items from the stack,while &lt;.&gt; displays the top item on the stack and removes it.</li></ol><P>For instance, look at the following sequence of numbers and words.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>0 &gt; 1 2 3 4 . 4  ok3 &gt; .s 1 2 3ok3 &gt; . . .  3 2 1  ok0 &gt;</pre>	</TD></TR></TABLE></CENTER><p>1 then 2 then 3 then 4 were put onto the stack, and then the top item, 4, wasdisplayed. &lt;.&gt; removed the 4 and displayed it. This made the stack depthgo to 3. When &lt;.s&gt; was entered, the entire stack was displayed, but noitem was removed. &lt;.s&gt; is very useful when debugging, since it can letyou see what you actually entered onto the stack before executing a word.</p><H3>Unknown Words</H3><p>The Forth Interpeter is not forgiving about clearing the entire stack when youtype a word the interpeter doesn't understand. This can be very frustrating, asshown in the next example.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>0 &gt; 1 2 3 4   ok4 &gt; bad-word bad-word, unknown wordok0 &gt;</pre>	</TD></TR></TABLE></CENTER><p>Since bad-word is not a word in the Forth dictionary, the interpeter clearedthe entire stack. Usually, there are ways to return to a command when thisoccurs.  Open Firmwares terminal emulator allows the use of the arrow keys toreturn to previous lines so that you may edit a line before trying theoffending or unknown word.</p><H3>More Forth Words</H3><p>You can determine the depth of the stack, clear an item, clear the entirestack, rotate an item, etc. All of these commands are detailed in Section 7,User Interface, of the IEEE 1275 Specification. Look at the following: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>0 &gt; 1 2 3 4 depth .s 1 2 3 4 4ok5 &gt; clear .s Emptyok0 &gt;</pre>	</TD></TR></TABLE></CENTER><P>Four numbers were placed on the stack and then the &lt; depth &gt; word wasexecuted. As you might expect, this word determined how deep the stack was andthen placed that number on the top of the stack. &lt;.s&gt; displayed theentire stack, including the result of &lt; depth &gt;. &lt; clear &gt; returnedthe stack depth to zero, as can be seen by its output (i.e., Empty) whendisplayed with the &lt; .s &gt; word.</p><H3>Stack Notation</H3><P>But how do you know what a word does before executing it? Stack notation is theanswer. Forth stack notation is a formal statement of what is on the stackbefore and after the word is executed. It does not report the stack contentsbelow what is needed by the word. Each word has a notation that attempts toclarify what the word does. The stack notations for &lt; + &gt; and &lt; depth&gt; are shown next.</p>+ ( nu1 nu2 -- sum )<br>depth ( -- u )<br><P>Now, let's look at the format of a stack notation. It begins with the &lt; (&gt; led and followed by a white space, so it's a word. It informs the Forthenterpeter to ignore all characters until it sees the &lt; ) &gt; word, whichdoes not need to be delimited by white spaces at the beginning and end ofitself. The -- is a separator of the item on the stack before and afterexecution of a word. Item(s) to the left are on the stack before the word isexecuted and item(s) to the right are placed on the stack by the word.</p>So &lt; + &gt; then takes the two top most values off the stack, adds them, andreturns the sum to the stack. Note that there can be many more values on thestack below the two topmost in this example. &lt; depth &gt; determines thenumber of values on the stack and places an unsigned number on the top of thestack.<H3>Duplication, Rearrangement, and Removal of Stack Items</H3><P>So far we have looked at items or values on the stack. A single stack value maynot be sufficient to describe an item. Some items have two or more values.Let's look at stack duplication, rearrangement, and removal of single anddouble stack items next. Enter the following command line: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>0 &gt; 1 2 3 4  ok4 &gt; dup  ok5 &gt; .s 1 2 3 4 4ok5 &gt;</pre>	</TD></TR></TABLE></CENTER><P>So &lt; dup &gt; duplicated the top item on the stack, which can be seen fromentering the &lt; .s &gt; command.</p><p>Now enter the following: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>5 &gt; clear 1 2 3 2dup .s 1 2 3 2 3ok5 &gt; 3dup .s 1 2 3 2 3 3 2 3ok8 &gt;</pre>	</TD></TR></TABLE></CENTER><P>&lt; clear &gt; emptied the stack, 1 2 3 were entered, and then the 2 and 3were duplicated using the &lt; 2dup &gt; word. The stack then produced 1 2 3 23 when &lt; 3dup &gt; was entered. At this point there were eight items on thestack.</p><P>Next, remove those items: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>8 &gt; drop .s 1 2 3 2 3 3 2ok7 &gt; 2drop .s 1 2 3 2 3ok5 &gt; 3drop .s 1 2ok2 &gt; nip .s 2ok1 &gt;</pre>	</TD></TR></TABLE></CENTER><p>You can drop one, two, or three items from the stack and you can nip it also asshown above. Here are the stack notations for your analysis of the previousexample: </p><TABLE ALIGN=CENTER border=0 cellspacing=1 CELLPADDING=4 width=300><TR><td width=180 valign=top align=left>drop</td><td width=420 valign=top align=left>( x -- )</td></tr> <TR><td width=180 valign=top align=left>2drop</td><td width=420 valign=top align=left>( x1 x2 -- )</td></tr><TR><td width=180 valign=top align=left>3drop </td><td width=420 valign=top align=left>( x1 x2 x3 -- )</td></tr><TR><td width=180 valign=top align=left>nip </td><td width=420 valign=top align=left>( x1 x2 -- x2 )</td></tr></table><p>&lt; nip &gt; removed the second item. Here is the stack notation for clear. </p><TABLE ALIGN=CENTER border=0 cellspacing=1 CELLPADDING=4 width=300><TR><td width=180 valign=top align=left>clear </td><td width=420 valign=top align=left>( ... -- )<br>that is, &lt; clear &gt; removes all items as can be seen above. Sothe elipse means " all items ".</td></tr></table><P>The stack can also be rearranged, as follows: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>0 &gt; 1 2 3 4 .s 1 2 3 4ok4 &gt; rot .s 1 3 4 2ok4 &gt; -rot .s 1 2 3 4ok4 &gt; swap .s 1 2 4 3ok4 &gt; 2swap .s 4 3 1 2ok4 &gt; clear  ok0 &gt;rot         ( x1 x2 x3 -- x2 x3 x1 ) rotated top three items-rot         ( x1 x2 x3 -- x3 x1 x2 ) the other wayswap        ( x1 x2 -- x2 x1 )2swap        ( x1 x2 x3 x4 -- x3 x4 x1 x2 )</pre>	</TD></TR></TABLE></CENTER><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>For a complete list of user interface words, see the IEEE 1275Specification, the PCI Binding for words specific to PCI, and Designing PCICards and Drivers for Power Macintosh Computers for Apple defined words.</P></TD></TR></TABLE></CENTER><BR><P>There are two more words that you will find useful when debugging. One is forcomments and the other is to extend the dictionary with a new or redefinedword.</p><P>Here is the display string word &lt; ." &gt;. When the interpeter sees thisword, it inputs the following text string. When it sees &lt; " &gt; delimiter,it exits this mode and displays the string contained between the &lt; ." &gt;and the delimeter ". Here's an example.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>0 &gt; .&quot; Hello world, I'm an example &quot; Hello world, I'm an example  ok0 &gt;</pre>	</TD></TR></TABLE></CENTER><P>What was entered was echoed. Here is the first word that did not take itsoperand from the stack. It took all characters until a &lt; " &gt; was seen.Here is the stack notation.</p><P>."    ( [text&lt;"&gt;] -- )</p><p>The [ ] pair says to take all text until a ". Can be confusing huh?</p><P>Here is the new or redefine word. It is called a <b>colon definition</b> andlooks like this: </p><P>: + ." I don't do addition " ; Look at ." I don't do addition ". This is just astring. The &lt; : &gt; started the definition of a word called &lt; + &gt;that echoes the string and the &lt; ; &gt; ended the definition. Look at thisexample.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>0 &gt; 1 2 3 + .s 1 5ok2 &gt; : + ( -- ) .&quot; I don't do addition &quot; ;  ok2 &gt; + I don't do addition  ok2 &gt; forget +  ok2 &gt; +  ok1 &gt; . 6  ok0 &gt;</pre>	</TD></TR></TABLE></CENTER><p>Can you tell what happened?</p><ol>    <li>    1 2 3 were entered, and then the contents of the stack were displayed.</li>    <li>    The + operator was redefined to do nothing but type a string to the displayand leave the contents of the stack as it was. That's the reason for the stacknotation ( -- ) which stands for " stack contents unaffected".</li><LI>After the first addition the stack had a 5 on the top with a 1 below it. Thenew definition of &lt; + &gt; did nothing to the stack.</li>    <li>    Here's a new word called &lt; forget &gt; which forgets the most recentdefinition and all words defined since that word.</li></ol><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The old definition of + was not replaced, just superceded. Thisimplies that the dictionary places new definitions at the top and also searchesfor words starting at the top.</P></TD></TR></TABLE></CENTER><BR><p>That's enough general Forth language and stack information to get you startedwith the device tree, which we turn to next.</p><P><A HREF="#top">Back to top</A></P><a name = "RTFToC4"></A><H2>The Device Tree</H2><p>The <b>device tree</b> is constructed by the Open Firmware probing processbefore the main Operating System is given control. It contains nodes for eachASIC on the motherboard, nodes for expansion devices such as yours, and a setof utilities nodes. For example /packages and /aliases.  The root of the treeis /. To get to the root node and list the entire tree, enter the following: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>dev / ls</pre>	</TD></TR></TABLE></CENTER><p>&lt; dev &gt; is a word which opens a node in the tree and the particular nodein this example is the root or /. This is a bus node for the AR bus (AppleRISC). &lt; ls &gt; lists all nodes, if any, under the present node. Let's seehow that works: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>0 &gt; dev / ls86746496: /PowerPC,604@086747184:   /l2-cache@0,086749168: /chosen@086749472: /memory@086749800: /openprom@086749992: /AAPL,ROM@FFC0000086750528: /options@086752280: /aliases@086752856: /packages@086752992:   /deblocker@0,086755040:   /disk-label@0,086756384:   /obp-tftp@0,086765664:   /mac-files@0,086767704:   /mac-parts@0,086769592:   /aix-boot@0,086770736:   /fat-files@0,086776320:   /iso-9660-files@0,086778696:   /xcoff-loader@0,086781192:   /terminal-emulator@0,086781344: /bandit@F200000086785936:   /gc@1086787016:     /53c94@1000086793296:       /sd@0,086796416:       /st@0,086799608:     /mace@1100086803312:     /escc@1300086803656:       /ch-a@1302086805368:       /ch-b@1300086807080:     /awacs@1400086807312:     /swim3@1500086811672:     /via-cuda@1600086814632:       /adb@0,086814872:         /keyboard@0,086816744:         /mouse@1,086816920:       /pram@0,086817096:       /rtc@0,086818320:       /power-mgt@0,086818608:     /mesh@1800086825624:       /sd@0,086828744:       /st@0,086832080:     /nvram@1D00086839664:   /pci106b,1@B86840136:   /ATY,XCLAIM@D86876008:   /wayne.device@E86878936:   /wayne.device@F86832488: /bandit@F400000086882192:   /pci106b,1@B86882664:   /pci1234,5678@D86883440:   /TRUV,TARGA2000PCI@F86837184: /hammerhead@F8000000ok0 &gt;</pre>	</TD></TR></TABLE></CENTER><P>Take a close look at the tree and then go into your Developer Notes for the9500 Macintosh. Notice that this resembles the block diagram on the 9500. It isthe block diagram and more. Note that there are two nodes called bandit. One is/bandit@F2000000 and the other is /bandit@F4000000<tt>. </tt>These are fullpath names. One can deduce that full path names can contain addressinformation, such as @F40000000, when the name is not unique, such as bandit.Bandit is the PCI bridge chip that has the AR bus as a parent and the PCI busas a child. The the device tree listing is from my 9500 and contains debuggingnodes called /wayne.device@E and /wayne.device@F.</p><p>Since we are at the root node, let's look at the pwd, .properties, and wordswords. Enter the following.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>0 &gt; pwd / ok0 &gt; .propertiesname                    device-treemodel                   Power Macintoshcompatible              AAPL,9500MacRISCAAPL,cpu-id             3900A69D#address-cells          00000001#size-cells             00000001clock-frequency         02FAF080ok0 &gt; wordsdma-sync        dma-map-out     dma-map-in      dma-freedma-alloc       map-out map-in          decode-unitclose           openok0 &gt;</pre>	</TD></TR></TABLE></CENTER><P>&lt; pwd &gt; displays the full path name for the current node. In this casepwd displays the root node.</p><P>&lt; .properties &gt; listed all properties under this node (which is the ARbus). Note that although the &lt; pwd &gt; word listed the node name as/, itsproper node name is device-tree. Look at the clock-frequency property, which is0x02FAF080 (or 50MHz).</p><p>&lt; words &gt; listed the words ( methods ) implemented by this node. But whatdo these words do? Well, enter &lt; see &gt; and then the word you want to see,such as &lt; open &gt;.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>0 &gt; see open: opentrue; ok0 &gt;</pre>	</TD></TR></TABLE></CENTER><P>So &lt; open &gt; just places the logical value of &lt; true &gt; onto the topof the stack.</p><p>Now let's look at one last maneuver - traversing the tree to another node. Forthis example, we'll look at the node called wayne at the top location in thetree.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>0 &gt; dev /bandit@F2000000/wayne.device  ok0 &gt; pwd /bandit@F2000000/wayne.device@E ok0 &gt;</pre>	</TD></TR></TABLE></CENTER><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The node chosen was the first of two. </P></TD></TR></TABLE></CENTER><BR><p>What if we had wanted the second node? Replacing the @E with @F would havechosen that node. Also note that the &lt; pwd &gt; word showed the name of thenode. Typing long path names is subject to mistakes, so let's look at analternative method. Enter the word &lt; devalias &gt; to see the following: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>0 &gt; devaliasvci0                /chaos@F0000000pci1                /bandit@F2000000pci2                /bandit@F4000000fd                  /bandit/gc/swim3kbd                 /bandit/gc/via-cuda/adb/keyboardttya                /bandit/gc/escc/ch-attyb                /bandit/gc/escc/ch-benet                /bandit/gc/macescsi                /bandit/gc/53c94scsi-int            /bandit/gc/meshok</pre>	</TD></TR></TABLE></CENTER><P>Look at the second entry called pci1.</p><p>Now enter: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>0 &gt; dev pci1/@e  ok0 &gt; pwd /bandit@F2000000/wayne.device@E ok0 &gt;</pre>	</TD></TR></TABLE></CENTER><P>Cool huh? pci1 is an alias of /bandit@F2000000.</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>@e or @E (not case sensitive) is also a valid name for a node. </P></TD></TR></TABLE></CENTER><BR>        <P><A HREF="#top">Back to top</A></P><a name = "Summary"></A><H2>Summary</H2><p>There is much more yet to be described about using Open Firmware to build anddebug your drivers and devices. The next Technote in this series, <i>Technote1062 - Fundamentals of Open Firmware, Part II: The Device Tree,</i> which will be available soon, addressesdetails of working with the device tree.</p><P><A HREF="#top">Back to top</A></P><A NAME="References"></a><H2>References</h2><p>IEEE 1275-1994 Specification</p><p>PCI Local Bus Specification 2.0</p><p>PCI Bus Binding Specification 1.5</p><p><i>Designing PCI Cards and Drivers for Power Macintosh Computers</i></p><p><A HREF = "tn1044.html"><i>Technote 1044 - Understanding PCI Expansion ROM Choices for Mac OS8</i></A>, Part III in the Open Firmware Technote Series</p><P><A HREF="#top">Back to top</A></P>         <P><A NAME=Downloads></A></P>                  <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="500">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (84K).</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/tn1061.pdf">Download</A></P>               </TD>            </TR></TABLE><P><A HREF="#top">Back to top</A></P></TD></TR></table></center><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1061.html%3Fid%3DDTS10002902-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1061.html%3Fid%3DDTS10002902-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1061.html%3Fid%3DDTS10002902-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>