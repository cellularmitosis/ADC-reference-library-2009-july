{\rtf1\mac\ansicpg10000\cocoartf100
{\fonttbl\f0\fswiss\fcharset77 Helvetica;\f1\fswiss\fcharset77 Helvetica-Bold;\f2\froman\fcharset77 Times-Bold;
\f3\fswiss\fcharset77 Helvetica-Oblique;}
{\colortbl;\red255\green255\blue255;}
\pard\tx1440\tx2880\tx4320\tx5760\tx7200\ql\qnatural

\f0\fs24 \cf0 \

\f1\b\fs36 Polygons\

\f0\b0\fs24 \
This example code demonstrates the use of an Objective-C category to add to the abilities of the NSBezierPath class.  The methods 
\f2\b\fs28 -polygonWithSides: 
\f0\b0\fs24 and 
\f2\b\fs28 -meshedPolygonWithSides:
\f0\b0\fs24 ,  implemented in 
\f1\b NSBezierPath_Polygons.[hm]
\f0\b0 , generate regular polygons in the unit circle.\
\
Since NSBezierPath is able to generate a polygon, the work done in the -drawRect method of the StringArtView class is pretty simple.  All it needs to do is clear the background, and draw the path.  Scaling and rotating the path is done by the StringArtView.   \
\
The general idea here, is for the work to get done in the classes and methods where it makes the most sense.   Since a polygon is a path, I made NSBezierPath generate them.  Since the StringArtView knows where and how big it wants to draw something, I left the scaling/rotation code in the StringArtView class.\
\
You might also be interested in the NSView category implemented in 
\f1\b NSViewExtensions.[hm]
\f0\b0 .  I found that I was repeatedly translating a view's origin to the center of its frame or bounds rectangles, so I went ahead and wrote some methods to make that a trivial operation.  Write it and debug it once, and you'll never need to worry again about writing 
\f3\i bounds.origin.x
\f0\i0  when you meant 
\f3\i bounds.origin.y
\f0\i0 .\
\
One last thing that can be informative, is to look at the file 
\f1\b theHardWay.m, 
\f0\b0 which shows how the StringArtView might have done its drawing before factoring the code out into categories of NSBezierPath and NSView.\
}