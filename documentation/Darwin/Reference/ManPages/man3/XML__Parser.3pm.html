<html><head><title>Mac OS X
 Manual Page For XML::Parser(3pm)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3pm/XML::Parser" title="Mac OS X
 Manual Page for XML::Parser(3pm)"><a name="//apple_ref/doc/man/3/XML::Parser" title="Mac OS X
 Manual Page for XML::Parser(3pm)"><!-- headerDoc=man; indexgroup=Section 3pm; uid="//apple_ref/doc/man/3pm/XML::Parser"; name=XML::Parser(3pm) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
Parser(3)                            User Contributed Perl Documentation                           <!-- a -->Parser(3)<!-- /a -->



<b>NAME</b>
       XML::Parser - A perl module for parsing XML documents

<b>SYNOPSIS</b>
         use XML::Parser;

         $p1 = new XML::Parser(Style =&gt; 'Debug');
         $p1-&gt;parsefile('REC-xml-19980210.xml');
         $p1-&gt;parse('&lt;foo id="me"&gt;Hello World&lt;/foo&gt;');

         # Alternative
         $p2 = new XML::Parser(Handlers =&gt; {Start =&gt; \&amp;handle_start,
                                            End   =&gt; \&amp;handle_end,
                                            Char  =&gt; \&amp;handle_char});
         $p2-&gt;parse($socket);

         # Another alternative
         $p3 = new XML::Parser(ErrorContext =&gt; 2);

         $p3-&gt;setHandlers(Char    =&gt; \&amp;text,
                          Default =&gt; \&amp;other);

         open(FOO, 'xmlgenerator |');
         $p3-&gt;parse(*FOO, ProtocolEncoding =&gt; 'ISO-8859-1');
         close(FOO);

         $p3-&gt;parsefile('junk.xml', ErrorContext =&gt; 3);

<b>DESCRIPTION</b>
       This module provides ways to parse XML documents. It is built on top of XML::Parser::Expat, which is
       a lower level interface to James Clark's expat library. Each call to one of the parsing methods
       creates a new instance of XML::Parser::Expat which is then used to parse the document.  Expat options
       may be provided when the XML::Parser object is created.  These options are then passed on to the
       Expat object on each parse call.  They can also be given as extra arguments to the parse methods, in
       which case they override options given at XML::Parser creation time.

       The behavior of the parser is controlled either by "Style" and/or "Handlers" options, or by
       "setHandlers" method. These all provide mechanisms for XML::Parser to set the handlers needed by
       XML::Parser::Expat.  If neither "Style" nor "Handlers" are specified, then parsing just checks the
       document for being well-formed.

       When underlying handlers get called, they receive as their first parameter the <u>Expat</u> object, not the
       Parser object.

<b>METHODS</b>
       new This is a class method, the constructor for XML::Parser. Options are passed as keyword value
           pairs. Recognized options are:

              Style

               This option provides an easy way to create a given style of parser. The built in styles are:
               "Debug", "Subs", "Tree", "Objects", and "Stream". These are all defined in separate packages
               under "XML::Parser::Style::*", and you can find further documentation for each style both
               below, and in those packages.

               Custom styles can be provided by giving a full package name containing at least one '::'.
               This package should then have subs defined for each handler it wishes to have installed. See
               "STYLES" below for a discussion of each built in style.

              Handlers

               When provided, this option should be an anonymous hash containing as keys the type of handler
               and as values a sub reference to handle that type of event. All the handlers get passed as
               their 1st parameter the instance of expat that is parsing the document. Further details on
               handlers can be found in "HANDLERS". Any handler set here overrides the corresponding handler
               set with the Style option.

              Pkg

               Some styles will refer to subs defined in this package. If not provided, it defaults to the
               package which called the constructor.

              ErrorContext

               This is an Expat option. When this option is defined, errors are reported in context. The
               value should be the number of lines to show on either side of the line in which the error
               occurred.

              ProtocolEncoding

               This is an Expat option. This sets the protocol encoding name. It defaults to none. The
               built-in encodings are: "UTF-8", "ISO-8859-1", "UTF-16", and "US-ASCII". Other encodings may
               be used if they have encoding maps in one of the directories in the @Encoding_Path list.
               Check "ENCODINGS" for more information on encoding maps. Setting the protocol encoding
               overrides any encoding in the XML declaration.

              Namespaces

               This is an Expat option. If this is set to a true value, then namespace processing is done
               during the parse. See "Namespaces" in XML::Parser::Expat for further discussion of namespace
               processing.

              NoExpand

               This is an Expat option. Normally, the parser will try to expand references to entities
               defined in the internal subset. If this option is set to a true value, and a default handler
               is also set, then the default handler will be called when an entity reference is seen in
               text. This has no effect if a default handler has not been registered, and it has no effect
               on the expansion of entity references inside attribute values.

              Stream_Delimiter

               This is an Expat option. It takes a string value. When this string is found alone on a line
               while parsing from a stream, then the parse is ended as if it saw an end of file. The
               intended use is with a stream of xml documents in a MIME multipart format. The string should
               not contain a trailing newline.

              ParseParamEnt

               This is an Expat option. Unless standalone is set to "yes" in the XML declaration, setting
               this to a true value allows the external DTD to be read, and parameter entities to be parsed
               and expanded.

              NoLWP

               This option has no effect if the ExternEnt or ExternEntFin handlers are directly set.
               Otherwise, if true, it forces the use of a file based external entity handler.

              Non-Expat-Options

               If provided, this should be an anonymous hash whose keys are options that shouldn't be passed
               to Expat. This should only be of concern to those subclassing XML::Parser.

       setHandlers(TYPE, HANDLER [, TYPE, HANDLER [...]])
           This method registers handlers for various parser events. It overrides any previous handlers
           registered through the Style or Handler options or through earlier calls to setHandlers. By
           providing a false or undefined value as the handler, the existing handler can be unset.

           This method returns a list of type, handler pairs corresponding to the input. The handlers
           returned are the ones that were in effect prior to the call.

           See a description of the handler types in "HANDLERS".

       parse(SOURCE [, OPT =&gt; OPT_VALUE [...]])
           The SOURCE parameter should either be a string containing the whole XML document, or it should be
           an open IO::Handle. Constructor options to XML::Parser::Expat given as keyword-value pairs may
           follow the SOURCE parameter. These override, for this call, any options or attributes passed
           through from the XML::Parser instance.

           A die call is thrown if a parse error occurs. Otherwise it will return 1 or whatever is returned
           from the <b>Final</b> handler, if one is installed.  In other words, what parse may return depends on
           the style.

       parsestring
           This is just an alias for parse for backwards compatibility.

       parsefile(FILE [, OPT =&gt; OPT_VALUE [...]])
           Open FILE for reading, then call parse with the open handle. The file is closed no matter how
           parse returns. Returns what parse returns.

       parse_start([ OPT =&gt; OPT_VALUE [...]])
           Create and return a new instance of XML::Parser::ExpatNB. Constructor options may be provided. If
           an init handler has been provided, it is called before returning the ExpatNB object. Documents
           are parsed by making incremental calls to the parse_more method of this object, which takes a
           string. A single call to the parse_done method of this object, which takes no arguments,
           indicates that the document is finished.

           If there is a final handler installed, it is executed by the parse_done method before returning
           and the parse_done method returns whatever is returned by the final handler.

<b>HANDLERS</b>
       Expat is an event based parser. As the parser recognizes parts of the document (say the start or end
       tag for an XML element), then any handlers registered for that type of an event are called with
       suitable parameters.  All handlers receive an instance of XML::Parser::Expat as their first argument.
       See "METHODS" in XML::Parser::Expat for a discussion of the methods that can be called on this
       object.

       <b>Init</b>                <b>(Expat)</b>

       This is called just before the parsing of the document starts.

       <b>Final</b>                <b>(Expat)</b>

       This is called just after parsing has finished, but only if no errors occurred during the parse.
       Parse returns what this returns.

       <b>Start</b>                <b>(Expat,</b> <b>Element</b> <b>[,</b> <b>Attr,</b> <b>Val</b> <b>[,...]])</b>

       This event is generated when an XML start tag is recognized. Element is the name of the XML element
       type that is opened with the start tag. The Attr &amp; Val pairs are generated for each attribute in the
       start tag.

       <b>End</b>                <b>(Expat,</b> <b>Element)</b>

       This event is generated when an XML end tag is recognized. Note that an XML empty tag (&lt;foo/&gt;)
       generates both a start and an end event.

       <b>Char</b>                <b>(Expat,</b> <b>String)</b>

       This event is generated when non-markup is recognized. The non-markup sequence of characters is in
       String. A single non-markup sequence of characters may generate multiple calls to this handler.
       Whatever the encoding of the string in the original document, this is given to the handler in UTF-8.

       <b>Proc</b>                <b>(Expat,</b> <b>Target,</b> <b>Data)</b>

       This event is generated when a processing instruction is recognized.

       <b>Comment</b>                <b>(Expat,</b> <b>Data)</b>

       This event is generated when a comment is recognized.

       <b>CdataStart</b>        <b>(Expat)</b>

       This is called at the start of a CDATA section.

       <b>CdataEnd</b>                <b>(Expat)</b>

       This is called at the end of a CDATA section.

       <b>Default</b>                <b>(Expat,</b> <b>String)</b>

       This is called for any characters that don't have a registered handler.  This includes both
       characters that are part of markup for which no events are generated (markup declarations) and
       characters that could generate events, but for which no handler has been registered.

       Whatever the encoding in the original document, the string is returned to the handler in UTF-8.

       <b>Unparsed</b>                <b>(Expat,</b> <b>Entity,</b> <b>Base,</b> <b>Sysid,</b> <b>Pubid,</b> <b>Notation)</b>

       This is called for a declaration of an unparsed entity. Entity is the name of the entity. Base is the
       base to be used for resolving a relative URI.  Sysid is the system id. Pubid is the public id.
       Notation is the notation name. Base and Pubid may be undefined.

       <b>Notation</b>                <b>(Expat,</b> <b>Notation,</b> <b>Base,</b> <b>Sysid,</b> <b>Pubid)</b>

       This is called for a declaration of notation. Notation is the notation name.  Base is the base to be
       used for resolving a relative URI. Sysid is the system id. Pubid is the public id. Base, Sysid, and
       Pubid may all be undefined.

       <b>ExternEnt</b>        <b>(Expat,</b> <b>Base,</b> <b>Sysid,</b> <b>Pubid)</b>

       This is called when an external entity is referenced. Base is the base to be used for resolving a
       relative URI. Sysid is the system id. Pubid is the public id. Base, and Pubid may be undefined.

       This handler should either return a string, which represents the contents of the external entity, or
       return an open filehandle that can be read to obtain the contents of the external entity, or return
       undef, which indicates the external entity couldn't be found and will generate a parse error.

       If an open filehandle is returned, it must be returned as either a glob (*FOO) or as a reference to a
       glob (e.g. an instance of IO::Handle).

       A default handler is installed for this event. The default handler is
       XML::Parser::lwp_ext_ent_handler unless the NoLWP option was provided with a true value, otherwise
       XML::Parser::file_ext_ent_handler is the default handler for external entities. Even without the
       NoLWP option, if the URI or LWP modules are missing, the file based handler ends up being used after
       giving a warning on the first external entity reference.

       The LWP external entity handler will use proxies defined in the environment (http_proxy, ftp_proxy,
       etc.).

       Please note that the LWP external entity handler reads the entire entity into a string and returns
       it, where as the file handler opens a filehandle.

       Also note that the file external entity handler will likely choke on absolute URIs or file names that
       don't fit the conventions of the local operating system.

       The expat base method can be used to set a basename for relative pathnames. If no basename is given,
       or if the basename is itself a relative name, then it is relative to the current working directory.

       <b>ExternEntFin</b>        <b>(Expat)</b>

       This is called after parsing an external entity. It's not called unless an ExternEnt handler is also
       set. There is a default handler installed that pairs with the default ExternEnt handler.

       If you're going to install your own ExternEnt handler, then you should set (or unset) this handler
       too.

       <b>Entity</b>                <b>(Expat,</b> <b>Name,</b> <b>Val,</b> <b>Sysid,</b> <b>Pubid,</b> <b>Ndata,</b> <b>IsParam)</b>

       This is called when an entity is declared. For internal entities, the Val parameter will contain the
       value and the remaining three parameters will be undefined. For external entities, the Val parameter
       will be undefined, the Sysid parameter will have the system id, the Pubid parameter will have the
       public id if it was provided (it will be undefined otherwise), the Ndata parameter will contain the
       notation for unparsed entities. If this is a parameter entity declaration, then the IsParam parameter
       is true.

       Note that this handler and the Unparsed handler above overlap. If both are set, then this handler
       will not be called for unparsed entities.

       <b>Element</b>                <b>(Expat,</b> <b>Name,</b> <b>Model)</b>

       The element handler is called when an element declaration is found. Name is the element name, and
       Model is the content model as an XML::Parser::Content object. See "XML::Parser::ContentModel Methods"
       in XML::Parser::Expat for methods available for this class.

       <b>Attlist</b>                <b>(Expat,</b> <b>Elname,</b> <b>Attname,</b> <b>Type,</b> <b>Default,</b> <b>Fixed)</b>

       This handler is called for each attribute in an ATTLIST declaration.  So an ATTLIST declaration that
       has multiple attributes will generate multiple calls to this handler. The Elname parameter is the
       name of the element with which the attribute is being associated. The Attname parameter is the name
       of the attribute. Type is the attribute type, given as a string. Default is the default value, which
       will either be "#REQUIRED", "#IMPLIED" or a quoted string (i.e. the returned string will begin and
       end with a quote character).  If Fixed is true, then this is a fixed attribute.

       <b>Doctype</b>                <b>(Expat,</b> <b>Name,</b> <b>Sysid,</b> <b>Pubid,</b> <b>Internal)</b>

       This handler is called for DOCTYPE declarations. Name is the document type name. Sysid is the system
       id of the document type, if it was provided, otherwise it's undefined. Pubid is the public id of the
       document type, which will be undefined if no public id was given. Internal is the internal subset,
       given as a string. If there was no internal subset, it will be undefined. Internal will contain all
       whitespace, comments, processing instructions, and declarations seen in the internal subset. The
       declarations will be there whether or not they have been processed by another handler (except for
       unparsed entities processed by the Unparsed handler). However, comments and processing instructions
       will not appear if they've been processed by their respective handlers.

       <b>*</b> <b>DoctypeFin</b>                <b>(Parser)</b>

       This handler is called after parsing of the DOCTYPE declaration has finished, including any internal
       or external DTD declarations.

       <b>XMLDecl</b>                <b>(Expat,</b> <b>Version,</b> <b>Encoding,</b> <b>Standalone)</b>

       This handler is called for xml declarations. Version is a string containg the version. Encoding is
       either undefined or contains an encoding string.  Standalone will be either true, false, or undefined
       if the standalone attribute is yes, no, or not made respectively.

<b>STYLES</b>
       <b>Debug</b>

       This just prints out the document in outline form. Nothing special is returned by parse.

       <b>Subs</b>

       Each time an element starts, a sub by that name in the package specified by the Pkg option is called
       with the same parameters that the Start handler gets called with.

       Each time an element ends, a sub with that name appended with an underscore ("_"), is called with the
       same parameters that the End handler gets called with.

       Nothing special is returned by parse.

       <b>Tree</b>

       Parse will return a parse tree for the document. Each node in the tree takes the form of a tag,
       content pair. Text nodes are represented with a pseudo-tag of "0" and the string that is their
       content. For elements, the content is an array reference. The first item in the array is a (possibly
       empty) hash reference containing attributes. The remainder of the array is a sequence of tag-content
       pairs representing the content of the element.

       So for example the result of parsing:

         &lt;foo&gt;&lt;head id="a"&gt;Hello &lt;em&gt;there&lt;/em&gt;&lt;/head&gt;&lt;bar&gt;Howdy&lt;ref/&gt;&lt;/bar&gt;do&lt;/foo&gt;

       would be:

                    Tag   Content
         ==================================================================
         [foo, [{}, head, [{id =&gt; "a"}, 0, "Hello ",  em, [{}, 0, "there"]],
                     bar, [         {}, 0, "Howdy",  ref, [{}]],
                       0, "do"
               ]
         ]

       The root document "foo", has 3 children: a "head" element, a "bar" element and the text "do". After
       the empty attribute hash, these are represented in it's contents by 3 tag-content pairs.

       <b>Objects</b>

       This is similar to the Tree style, except that a hash object is created for each element. The
       corresponding object will be in the class whose name is created by appending "::" and the element
       name to the package set with the Pkg option. Non-markup text will be in the ::Characters class. The
       contents of the corresponding object will be in an anonymous array that is the value of the Kids
       property for that object.

       <b>Stream</b>

       This style also uses the Pkg package. If none of the subs that this style looks for is there, then
       the effect of parsing with this style is to print a canonical copy of the document without comments
       or declarations.  All the subs receive as their 1st parameter the Expat instance for the document
       they're parsing.

       It looks for the following routines:

          StartDocument

           Called at the start of the parse .

          StartTag

           Called for every start tag with a second parameter of the element type. The $_ variable will
           contain a copy of the tag and the %_ variable will contain attribute values supplied for that
           element.

          EndTag

           Called for every end tag with a second parameter of the element type. The $_ variable will
           contain a copy of the end tag.

          Text

           Called just before start or end tags with accumulated non-markup text in the $_ variable.

          PI

           Called for processing instructions. The $_ variable will contain a copy of the PI and the target
           and data are sent as 2nd and 3rd parameters respectively.

          EndDocument

           Called at conclusion of the parse.

<b>ENCODINGS</b>
       XML documents may be encoded in character sets other than Unicode as long as they may be mapped into
       the Unicode character set. Expat has further restrictions on encodings. Read the xmlparse.h header
       file in the expat distribution to see details on these restrictions.

       Expat has built-in encodings for: "UTF-8", "ISO-8859-1", "UTF-16", and "US-ASCII". Encodings are set
       either through the XML declaration encoding attribute or through the ProtocolEncoding option to
       XML::Parser or XML::Parser::Expat.

       For encodings other than the built-ins, expat calls the function load_encoding in the Expat package
       with the encoding name. This function looks for a file in the path list
       @XML::Parser::Expat::Encoding_Path, that matches the lower-cased name with a '.enc' extension. The
       first one it finds, it loads.

       If you wish to build your own encoding maps, check out the XML::Encoding module from CPAN.

<b>AUTHORS</b>
       Larry Wall &lt;<u>larry@wall.org&gt;</u> wrote version 1.0.

       Clark Cooper &lt;<u>coopercc@netheaven.com&gt;</u> picked up support, changed the API for this version (2.x),
       provided documentation, and added some standard package features.

       Matt Sergeant &lt;<u>matt@sergeant.org&gt;</u> is now maintaining XML::Parser

<b>POD</b> <b>ERRORS</b>
       Hey! <b>The</b> <b>above</b> <b>document</b> <b>had</b> <b>some</b> <b>coding</b> <b>errors,</b> <b>which</b> <b>are</b> <b>explained</b> <b>below:</b>

       Around line 362:
           '=begin' only takes one parameter, not several as in '=begin man .ds PI PI'

       Around line 365:
           =end man without matching =begin.  (Stack: [empty])



perl v5.8.8                                      2003-08-18                                        <!-- a -->Parser(3)<!-- /a -->
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/XML__Parser.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/XML__Parser.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/XML__Parser.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
