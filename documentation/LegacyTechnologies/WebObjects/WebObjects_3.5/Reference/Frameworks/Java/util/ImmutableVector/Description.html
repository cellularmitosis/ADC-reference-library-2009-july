<html>

<body bgcolor="#FFFFFF">

<CENTER><H1>Class next.util.ImmutableVector</H1></CENTER>

<a name="description"></a><CENTER><H2>CLASS DESCRIPTION</H2></CENTER>

<!-- extends:next.util.NextObject -->

<DL>

<DT><B>Extends:</B></DT><DD>next.util.NextObject</DD>

</DL>

<P>

<DL>

<DT><B>Implements:</B></DT>

<!-- implements:next/util/Coding  -->

<DD>next/util/Coding </DD><BR>

</DL>

<P>

ImmutableVector declares the programmatic interface to an object that manages an unchanging array of objects. ImmutableVector's two primitive methods-<B>size</B> and <B>elementAt</B>-provide the basis for all other methods in its interface. The <B>size</B> method returns the number of elements in the array. <B>elementAt</B> gives you access to the array elements by index, with index values starting at 0.
<P>
The <B>elements</B> method also grants sequential access to the elements of the array. This method is provided so that arrays can be traversed in a manner similar to that used for objects of other collection classes such as ImmutableHashtable. 
<P>
ImmutableVector provides methods for querying the elements of the array. <B>indexOf</B> searches the array for the object that matches its argument. 
<P>
ImmutableVector's <B>makeObjectsPerformMethod</B> and <B>makeObjectsPerformMethodWithObject</B> methods let you send messages to all objects in the array.
<P>
You can compare two arrays using the <B>firstObjectCommonWithArray</B> method. 
<hr>

</body>

</html><html>

<body bgcolor="#FFFFFF"><!-- constructors -->

<a name="constructors"><CENTER><H2>CONSTRUCTORS</H2></CENTER></a>

<!-- consKey:ImmutableVector(public) cons:ImmutableVector descr:<TT>public  <B>ImmutableVector</B>(java.lang.Object[] <I>objects</I>)</TT>:<TT>public  <B>ImmutableVector</B>(java.util.Vector <I>aVector</I>)</TT>:<TT>public  <B>ImmutableVector</B>()</TT> -->

<H3><a name="ImmutableVector(public)">ImmutableVector</a></H3>

<TT>public  <B>ImmutableVector</B>()</TT><br>

<TT>public  <B>ImmutableVector</B>(java.lang.Object[] <I>objects</I>)</TT><br>

<TT>public  <B>ImmutableVector</B>(java.util.Vector <I>aVector</I>)</TT>

<P>

Initializes a newly allocated vector. After an immutable vector has been initialized, it can't be modified.
<P>
If <I>objects</I> are supplied, the vector is initialized by placing in it the objects contained in <I>objects</I>.
<P>
If <I>aVector</I> is supplied, the vector is initialized by placing in it the objects contained in the Java vector specified by <I>aVector</I>.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

</body>

</html><html>

<body bgcolor="#FFFFFF"><!-- methods -->

<a name="methods"><CENTER><H2>METHODS</H2></CENTER></a>

<!-- methKey:capacity(public) meth:capacity descr:<TT>public int <B>capacity</B>()</TT> -->

<H3><a name="capacity(public)">capacity</a></H3>

<TT>public int <B>capacity</B>()</TT>

<P>

Returns the number of objects currently in the array.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:contains(public) meth:contains descr:<TT>public boolean <B>contains</B>(java.lang.Object <I>anObject</I>)</TT> -->

<H3><a name="contains(public)">contains</a></H3>

<TT>public boolean <B>contains</B>(java.lang.Object <I>anObject</I>)</TT>

<P>

Returns <B>true</B> if <I>anObject</I> is present in the vector.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:copyInto(public) meth:copyInto descr:<TT>public void <B>copyInto</B>(java.lang.Object[] <I>objects</I>)</TT> -->

<H3><a name="copyInto(public)">copyInto</a></H3>

<TT>public void <B>copyInto</B>(java.lang.Object[] <I>objects</I>)</TT>

<P>

Copies the objects contained in the receiver to <I>objects</I>.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:elementAt(public) meth:elementAt descr:<TT>public java.lang.Object <B>elementAt</B>(int <I>anInt</I>)</TT> -->

<H3><a name="elementAt(public)">elementAt</a></H3>

<TT>public java.lang.Object <B>elementAt</B>(int <I>index</I>)</TT>

<P>

Returns the object located at <I>index</I>. If <I>index</I> is beyond the end of the vector (that is, if <I>index</I> is greater than or equal to the value returned by <B>size</B>), an exception is raised.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:elements(public) meth:elements descr:<TT>public java.util.Enumeration <B>elements</B>()</TT> -->

<H3><a name="elements(public)">elements</a></H3>

<TT>public java.util.Enumeration <B>elements</B>()</TT>

<P>

Returns an enumerator object that lets you access each object in the vector, in order, starting with the element at index 0. When this method is used with mutable subclasses of ImmutableVector, your code shouldn't modify the vector during enumeration.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:encodeWithCoder(public) meth:encodeWithCoder descr:<TT>public void <B>encodeWithCoder</B>(next.util.Coder <I>aCoder</I>)</TT> -->

<H3><a name="encodeWithCoder(public)">encodeWithCoder</a></H3>

<TT>public void <B>encodeWithCoder</B>(next.util.Coder <I>aCoder</I>)</TT>

<P>

Encodes the receiver using <I>aCoder</I>. See the Coding interface description for more information.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:firstElement(public) meth:firstElement descr:<TT>public java.lang.Object <B>firstElement</B>()</TT> -->

<H3><a name="firstElement(public)">firstElement</a></H3>

<TT>public java.lang.Object <B>firstElement</B>()</TT>

<P>

Returns the object located at index 0.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:firstObjectCommonWithArray(public) meth:firstObjectCommonWithArray descr:<TT>public java.lang.Object <B>firstObjectCommonWithArray</B>(next.util.ImmutableVector <I>anImmutableVector</I>)</TT> -->

<H3><a name="firstObjectCommonWithArray(public)">firstObjectCommonWithArray</a></H3>

<TT>public java.lang.Object <B>firstObjectCommonWithArray</B>(next.util.ImmutableVector <I>anImmutableVector</I>)</TT>

<P>

Returns the first object contained in the receiver that's equal to an object in <I>anImmutableVector</I>. If no such object is found, this method returns <B>nil</B>. 
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:indexOf(protected) meth:indexOf descr:<TT>protected int <B>indexOf</B>(java.lang.Object <I>anObject</I>, int <I>anObject</I>, boolean <I>flag</I>)</TT> -->

<H3><a name="indexOf(protected)">indexOf</a></H3>

<TT>protected int <B>indexOf</B>(java.lang.Object <I>start</I>, int <I>anInt</I>, boolean <I>forwards</I>)</TT>

<P>

Searches the receiver for <I>anObject</I> and returns the lowest index whose corresponding vector value is equal to <I>anObject</I>. If none of the objects in the receiver are equal to <I>anObject</I>, <B>indexOf</B> returns -1. The vector is searched beginning with the object at index <I>start</I>. If <I>forwards</I> is <B>true</B>, the search proceeds towards the end of the vector; otherwise, it proceeds towards the beginning of the vector.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:indexOf(public) meth:indexOf descr:<TT>public int <B>indexOf</B>(java.lang.Object <I>anObject</I>)</TT>:<TT>public int <B>indexOf</B>(java.lang.Object <I>anObject</I>, int <I>anInt</I>)</TT> -->

<H3><a name="indexOf(public)">indexOf</a></H3>

<TT>public int <B>indexOf</B>(java.lang.Object <I>anObject</I>)</TT><br>

<TT>public int <B>indexOf</B>(java.lang.Object <I>anObject</I>, int <I>start</I>)</TT>

<P>

Searches the receiver for <I>anObject</I> and returns the lowest index whose corresponding vector value is equal to <I>anObject</I>. If none of the objects in the receiver are equal to <I>anObject</I>, <B>indexOf</B> returns -1.
<P>
If you specify <I>start</I>, the vector is searched beginning with the object at index <I>start</I> and proceeding to the end of the array.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:initWithObjects(protected) meth:initWithObjects descr:<TT>protected void <B>initWithObjects</B>(java.lang.Object[] <I>objects</I>)</TT> -->

<H3><a name="initWithObjects(protected)">initWithObjects</a></H3>

<TT>protected void <B>initWithObjects</B>(java.lang.Object[] <I>objects</I>)</TT>

<P>

Initializes a newly allocated array by placing in it the objects contained in <I>objects</I>. After an ImmutableVector has been initialized in this way, it can't be modified.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:isEmpty(public) meth:isEmpty descr:<TT>public boolean <B>isEmpty</B>()</TT> -->

<H3><a name="isEmpty(public)">isEmpty</a></H3>

<TT>public boolean <B>isEmpty</B>()</TT>

<P>

Returns <B>true</B> if the vector contains no elements.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:lastElement(public) meth:lastElement descr:<TT>public java.lang.Object <B>lastElement</B>()</TT> -->

<H3><a name="lastElement(public)">lastElement</a></H3>

<TT>public java.lang.Object <B>lastElement</B>()</TT>

<P>

Returns the object in the vector with the highest index value. If the vector is empty, <B>lastElement</B> returns <B>nil</B>. 
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:lastIndexOf(public) meth:lastIndexOf descr:<TT>public int <B>lastIndexOf</B>(java.lang.Object <I>anObject</I>)</TT>:<TT>public int <B>lastIndexOf</B>(java.lang.Object <I>anObject</I>, int <I>anInt</I>)</TT> -->

<H3><a name="lastIndexOf(public)">lastIndexOf</a></H3>

<TT>public int <B>lastIndexOf</B>(java.lang.Object <I>anObject</I>)</TT><br>

<TT>public int <B>lastIndexOf</B>(java.lang.Object <I>anObject</I>, int <I>start</I>)</TT>

<P>

Searches the receiver for <I>anObject</I> and returns the highest index whose corresponding vector value is equal to <I>anObject</I>. If none of the objects in the receiver are equal to <I>anObject</I>, <B>indexOf</B> returns -1.
<P>
If you specify <I>start</I>, the vector is searched beginning with the object at index <I>start</I> and proceeding towards the beginning of the array.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:makeObjectsPerformMethod(public) meth:makeObjectsPerformMethod descr:<TT>public void <B>makeObjectsPerformMethod</B>(java.lang.String <I>aString</I>)</TT> -->

<H3><a name="makeObjectsPerformMethod(public)">makeObjectsPerformMethod</a></H3>

<TT>public void <B>makeObjectsPerformMethod</B>(java.lang.String <I>aMethod</I>)</TT>

<P>

Sends the <I>aMethod</I> message to each object in the vector in reverse order (starting with the last object and continuing backwards through the vector to the first object). The <I>aMethod</I> method must be one that takes no arguments. It shouldn't have the side effect of modifying the receiving vector.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:makeObjectsPerformMethodWithObject(public) meth:makeObjectsPerformMethodWithObject descr:<TT>public void <B>makeObjectsPerformMethodWithObject</B>(java.lang.String <I>aString</I>, java.lang.Object <I>anObject</I>)</TT> -->

<H3><a name="makeObjectsPerformMethodWithObject(public)">makeObjectsPerformMethodWithObject</a></H3>

<TT>public void <B>makeObjectsPerformMethodWithObject</B>(java.lang.String <I>aMethod</I>, java.lang.Object <I>anObject</I>)</TT>

<P>

Sends the <I>aMethod</I> message to each object in the vector in reverse order (starting with the last object and continuing backwards through the vector to the first object). The message is sent each time with <I>anObject</I> as an argument, so the <I>aMethod</I> method must be one that takes a single argument of type <B>java.lang.Object</B>. The <I>aMethod</I> method shouldn't, as a side effect, modify the receiving vector.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:size(public) meth:size descr:<TT>public int <B>size</B>()</TT> -->

<H3><a name="size(public)">size</a></H3>

<TT>public int <B>size</B>()</TT>

<P>

Returns the number of objects currently in the array.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:vector(public) meth:vector descr:<TT>public java.util.Vector <B>vector</B>()</TT> -->

<H3><a name="vector(public)">vector</a></H3>

<TT>public java.util.Vector <B>vector</B>()</TT>

<P>

Returns a Java vector that contains each of the elements from the receiver.

<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

</body>

</html>