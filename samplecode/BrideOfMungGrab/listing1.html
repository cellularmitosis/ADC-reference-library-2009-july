<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>BrideOfMungGrab - /main.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/Carbon/index.html">Carbon</a> &gt; <a href="../../samplecode/Carbon/idxQuickTime-date.html">QuickTime</a> &gt; <A HREF="javascript:location.replace('index.html');">BrideOfMungGrab</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">BrideOfMungGrab</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/main.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/main.c</option></select>
				</p>
				</form>
				<p><strong><a href="BrideOfMungGrab.zip">Download Sample</a></strong> (&#147;BrideOfMungGrab.zip&#148;, 77.9K)<BR>
<strong><a href="BrideOfMungGrab.dmg">Download Sample</a></strong> (&#147;BrideOfMungGrab.dmg&#148;, 142.8K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*
  File:        main.c
  
  Description: This example is based on the SGDataProcSamsple code which can be found at the following URL:
                 http://developer.apple.com/samplecode/SGDataProcSample/SGDataProcSample.html
                
                 While the code in SGDataProcSample used an offscreen GWorld and some QuickDraw
                 calls to draw text on top of video, this sample removes the need for the extra
                 GWorld by using Overlay windows and Core Graphics to draw some text and graphics
                 on top of the video image being captured.
                 
                 The graphs in the upper left of the window display the following stats:
                    Number of frames in the queue.
                    Number of skipped frames.
                    Difference between the time base time and the dataProc frame time.
                    Difference between the last frame time and the current frame time.
                
                For each of the above stats, shorter is better.
                
                The status string prints out the time, a min:seconds:frames representation of time, frames per second
                and average frames per second.
                
                The dataProc in this case will also drop frames under certain situations. Namely if there's more than
                one frame in the queue, the capture rate drops below 15fps and we haven't skipped 15 frames in a row
                trying to catch up. There's many different strategies one could use to drop less important frames or
                always display the latest frame captured and so on. These are left as an exercise for the developer.
                
  Author:      QuickTime Engineering, QuickTime DTS

  Copyright:    &copy; Copyright 2000 - 2005 Apple Computer, Inc. All rights reserved.
    
  Disclaimer: IMPORTANT: This Apple software is supplied to you by Apple Computer, Inc. (&quot;Apple&quot;) in 
                consideration of your agreement to the following terms, and your use, installation, modification 
                or redistribution of this Apple software constitutes acceptance of these terms.  If you do 
                not agree with these terms, please do not use, install, modify or redistribute this Apple software.

                In consideration of your agreement to abide by the following terms, and subject to these terms, 
                Apple grants you a personal, non-exclusive license, under Apple's copyrights in this 
                original Apple software (the &quot;Apple Software&quot;), to use, reproduce, modify and redistribute the 
                Apple Software, with or without modifications, in source and/or binary forms; provided that if you 
                redistribute the Apple Software in its entirety and without modifications, you must retain this 
                notice and the following text and disclaimers in all such redistributions of the Apple Software. 
                Neither the name, trademarks, service marks or logos of Apple Computer, Inc. may be used to 
                endorse or promote products derived from the Apple Software without specific prior written 
                permission from Apple.  Except as expressly stated in this notice, no other rights or 
                licenses, express or implied, are granted by Apple herein, including but not limited to any 
                patent rights that may be infringed by your derivative works or by other works in which the 
                Apple Software may be incorporated.

                The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE MAKES NO WARRANTIES, EXPRESS OR 
                IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY 
                AND FITNESS FOR A PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE 
                OR IN COMBINATION WITH YOUR PRODUCTS.

                IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR CONSEQUENTIAL 
                DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS 
                OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) ARISING IN ANY WAY OUT OF THE USE, 
                REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER 
                UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN 
                IF APPLE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                
  Change History (most recent first): 04/01/05 fixed sgchanSound failure check
                                        01/25/05 initial release
*/

// build for carbon
#define TARGET_API_MAC_CARBON 1

#include &lt;Carbon/Carbon.h&gt;
#include &lt;QuickTime/QuickTime.h&gt;

// defines
#define DisplayAndBail(x, y) {pMungData-&gt;err = x; if(x != noErr) { DisplayError(pMungData-&gt;pWindow, y, x); goto bail;}}

// constants
const EventTime kTimerInterval = kEventDurationSecond / 60;  // idle timer interval

const HIViewID kBoxID = {'GBOX', 100};

// mung data struct
typedef struct {
    WindowRef          pWindow;  // windows
    WindowRef      pOverlay;
    CGContextRef    context;
    CGRect        textRect, barRect, offsetRect;
    CGPoint        textPos;
    CGRect        qfRect[25][25];
    CGRect        sfRect[25][25];
    Rect         bounds;    // bounds rect
    SeqGrabComponent   seqGrab;  // sequence grabber
    SGChannel      sgchanVideo;
    ImageSequence      drawSeq;  // unique identifier for our draw sequence
    TimeScale        timeScale;
    TimeBase      timeBase;
    UInt32        duration;
    UInt8         queuedFrameCount;
    UInt8        skipFrameCount;
    TimeValue        lastTime;
    long          frameCount;
    Boolean         isGrabbing;
    Boolean        isAccelerated;
    EventLoopTimerRef  timerRef;
    OSErr         err;
} MungDataRecord, *MungDataPtr;

// globals
static BitMap gScreenbits;

#pragma mark-

OSErr SetupOverlayContext(MungDataPtr inMungData);
void UpdateStaticText(MungDataPtr inMungData);
OSErr MakeWindows(MungDataPtr inMungData, IBNibRef inNibRef);
OSErr MakeSequenceGrabber(MungDataPtr pMungData);
OSErr MakeSequenceGrabChannel(SeqGrabComponent seqGrab, SGChannel *sgchanVideo, SGChannel *sgchanSound);
ComponentResult SetVideoChannelBounds(SGChannel videoChannel, const Rect *scaledSourceBounds, const Rect *scaledVideoBounds);
void DisposeMungData(MungDataPtr inMungData);

#pragma mark-

/*****************************************************
*
* DisplayError(WindowRef inWindow, char inStr[], OSErr inError)
*
* Purpose:   display an error message as the window title
*
* Notes:     
*
*/
static void DisplayError(WindowRef inWindow, char inStr[], OSErr inError)
{
  // set the window title to display the error
  char errMsg[64];
  
  sprintf(errMsg, &quot;%s: %d&quot;, inStr, inError);
  CopyCStringToPascal(errMsg, (unsigned char *)&amp;errMsg);
  SetWTitle(inWindow, (unsigned char *)errMsg);
}

#pragma mark-

/*****************************************************
*
* MungGrabCompressCompleteBottleProc(SGChannel c, UInt8 *queuedFrameCount, SGCompressInfo *ci, TimeRecord *t, long refCon)
*
* Purpose:   used to allow us to figure out how many frames are queued by the vDig
*
* Notes:     the UInt8 *queuedFrameCount replaces Boolean *done. (0 (==false) still means no frames, and 1 (==true) one,
*            but if more than one are available, the number should be returned here - The value 2 previously meant more than
*            one frame, so some VDIGs may return 2 even if more than 2 are available, and some will still return 1 as they are
*            using the original definition.
*
*/
static pascal ComponentResult MungGrabCompressCompleteBottleProc(SGChannel c, UInt8 *queuedFrameCount, SGCompressInfo *ci, TimeRecord *t, long refCon)
{
  OSErr err;
  
  MungDataPtr pMungData = (MungDataPtr)refCon;
    if (NULL == pMungData) return -1;
    
    // call the original proc; you must do this
    err = SGGrabCompressComplete(c, queuedFrameCount, ci, t);
    
    // save the queued frame count so we have it
    pMungData-&gt;queuedFrameCount = *queuedFrameCount;
    
    return err;
}

/*****************************************************
*
* MungGrabDataProc(SGChannel c, Ptr p, long len, long *offset, long chRefCon, TimeValue time, short writeType, long refCon)
*
* Purpose:   sequence grabber data procedure - this is where the work is done
*
* Notes:

   the sequence grabber calls the data function whenever
   any of the grabber&rsquo;s channels write digitized data to the destination movie file.
   
   NOTE: We really mean any, if you have an audio and video channel then the DataProc will
        be called for either channel whenever data has been captured. Be sure to check which
        channel is being passed in. In this example we never create an audio channel so we know
        we're always dealing with video.
   
   This data function does two things, it first decompresses captured video
   data into an offscreen GWorld, draws some status information onto the frame then
   transfers the frame to an onscreen window.
   
   For more information refer to Inside Macintosh: QuickTime Components, page 5-120
   c - the channel component that is writing the digitized data.
   p - a pointer to the digitized data.
   len - the number of bytes of digitized data.
   offset - a pointer to a field that may specify where you are to write the digitized data,
         and that is to receive a value indicating where you wrote the data.
   chRefCon - per channel reference constant specified using SGSetChannelRefCon.
   time  - the starting time of the data, in the channel&rsquo;s time scale.
   writeType - the type of write operation being performed.
       seqGrabWriteAppend - Append new data.
       seqGrabWriteReserve - Do not write data. Instead, reserve space for the amount of data
                   specified in the len parameter.
       seqGrabWriteFill - Write data into the location specified by offset. Used to fill the space
                  previously reserved with seqGrabWriteReserve. The Sequence Grabber may
                  call the DataProc several times to fill a single reserved location.
   refCon - the reference constant you specified when you assigned your data function to the sequence grabber.
*/
static pascal OSErr MungGrabDataProc(SGChannel c, Ptr p, long len, long *offset, long chRefCon, TimeValue time, short writeType, long refCon)
{
#pragma unused(offset,chRefCon,writeType)
    
    ComponentResult err = noErr;
    
    MungDataPtr pMungData = (MungDataPtr)refCon;
    if (NULL == pMungData) return -1;
    
  // reset frame and time counters after a stop/start
  if (time &lt; pMungData-&gt;lastTime) {  
    pMungData-&gt;lastTime = 0;
    pMungData-&gt;frameCount = 0;
  }
    
    // we only care about the video  
    if (c == pMungData-&gt;sgchanVideo) {
    
      TimeValue timeBaseTime, timeBaseDelta, frameTimeDelta;
    
      pMungData-&gt;frameCount++;
          
      if (pMungData-&gt;timeScale == 0) {
        Fixed framesPerSecond;
        long  milliSecPerFrameIgnore, bytesPerSecondIgnore;
        
        // first time here so get the time scale &amp; timebase
        err = SGGetChannelTimeScale(c, &amp;pMungData-&gt;timeScale);
        DisplayAndBail(err, &quot;SGGetChannelTimeScale&quot;);
        
        err = SGGetTimeBase(pMungData-&gt;seqGrab, &amp;pMungData-&gt;timeBase);
        DisplayAndBail(err, &quot;SGGetTimeBase&quot;);
        
        err = VDGetDataRate(SGGetVideoDigitizerComponent(c), &amp;milliSecPerFrameIgnore, &amp;framesPerSecond, &amp;bytesPerSecondIgnore);
        DisplayAndBail(err, &quot;VDGetDataRate&quot;);
        
        pMungData-&gt;duration = pMungData-&gt;timeScale / (framesPerSecond &gt;&gt; 16);
      }
      
       if (pMungData-&gt;drawSeq == 0) {
         
         // set up decompression sequence  
        Rect           sourceRect = { 0, 0 };
            Rect                   scaleRect = pMungData-&gt;bounds;
      MatrixRecord       scaleMatrix;  
      CodecFlags         cFlags = codecNormalQuality;
      ImageDescriptionHandle imageDesc = (ImageDescriptionHandle)NewHandle(0);
            
            // retrieve a channel&rsquo;s current sample description, the channel returns a
            // sample description that is appropriate to the type of data being captured
            err = SGGetChannelSampleDescription(c, (Handle)imageDesc);
            DisplayAndBail(err, &quot;SGGetChannelSampleDescription&quot;);
            
            // make a scaling matrix for the sequence
      sourceRect.right = (**imageDesc).width;
      sourceRect.bottom = (**imageDesc).height;
      
      if (pMungData-&gt;isAccelerated) {
        // if accelerated and DV do high quality
        // 720x480 both fields
        if (kDVCNTSCCodecType == (**imageDesc).cType) {
          cFlags = codecHighQuality;
        }
                UnionRect(&amp;sourceRect, &amp;pMungData-&gt;bounds, &amp;pMungData-&gt;bounds);
                UnionRect(&amp;sourceRect, &amp;pMungData-&gt;bounds, &amp;scaleRect);
                OffsetRect(&amp;scaleRect, short(pMungData-&gt;offsetRect.origin.x + 5), short(pMungData-&gt;offsetRect.origin.y + 5));
                pMungData-&gt;bounds.right += short(pMungData-&gt;offsetRect.size.width + 10);
                pMungData-&gt;bounds.bottom += short(pMungData-&gt;offsetRect.size.height + 10);
      } else {
                MacSetRect(&amp;scaleRect, 0, 0, 320, 240);
                OffsetRect(&amp;scaleRect, short(pMungData-&gt;offsetRect.origin.x + 5), short(pMungData-&gt;offsetRect.origin.y + 5));
            }
            
            RectMatrix(&amp;scaleMatrix, &amp;sourceRect, &amp;scaleRect);
                  
      SetupOverlayContext(pMungData);
      
            // begin the process of decompressing a sequence of frames
            // this is a set-up call and is only called once for the sequence - the ICM will interrogate different codecs
            // and construct a suitable decompression chain, as this is a time consuming process we don't want to do this
            // once per frame (eg. by using DecompressImage)
            // for more information see Ice Floe #8 http://developer.apple.com/quicktime/icefloe/dispatch008.html
            // the destination is specified as the GWorld
      err = DecompressSequenceBeginS(&amp;pMungData-&gt;drawSeq,          // pointer to field to receive unique ID for sequence
                      imageDesc,              // handle to image description structure
                      p,                  // points to the compressed image data
                      len,                                 // size of the data buffer
                      GetWindowPort(pMungData-&gt;pWindow),  // port for the DESTINATION image
                      NULL,                  // graphics device handle, if port is set, set to NULL
                      NULL,                  // decompress the entire source image - no source extraction
                                          &amp;scaleMatrix,              // transformation matrix
                                          srcCopy,                // transfer mode specifier
                                          (RgnHandle)NULL,            // clipping region in dest. coordinate system to use as a mask
                                          0,                  // flags
                                          cFlags,                 // accuracy in decompression
                                          bestSpeedCodec);            // compressor identifier or special identifiers ie. bestSpeedCodec
    
            DisplayAndBail(err, &quot;DSeqBegin&quot;);
            
            DisposeHandle((Handle)imageDesc);
        }
        
        // get the TimeBase time and figure out the delta between that time and this frame time
        timeBaseTime = GetTimeBaseTime(pMungData-&gt;timeBase, pMungData-&gt;timeScale, NULL);
        timeBaseDelta = timeBaseTime - time;
        frameTimeDelta = time - pMungData-&gt;lastTime;
        
        if (timeBaseDelta &lt; 0) goto bail; // probably don't need this
        
        // if we have more than one queued frame and our capture rate drops below 10 frames, skip the frame to try and catch up
    if ((pMungData-&gt;queuedFrameCount &gt; 1) &amp;&amp;  ((pMungData-&gt;timeScale / frameTimeDelta) &lt; 10) &amp;&amp; (pMungData-&gt;skipFrameCount &lt; 15)) {
      ++pMungData-&gt;skipFrameCount;
      --pMungData-&gt;frameCount;
        } else {
          CodecFlags ignore;
          
          // decompress a frame into the window - can queue a frame for async decompression when passed in a completion proc
          err = DecompressSequenceFrameS(pMungData-&gt;drawSeq,  // sequence ID returned by DecompressSequenceBegin
                           p,          // pointer to compressed image data
                           len,          // size of the buffer
                           0,          // in flags
                           &amp;ignore,        // out flags
                           NULL);        // async completion proc
                       
          DisplayAndBail(err, &quot;DSeqFrameS&quot;);
          
           pMungData-&gt;skipFrameCount = 0;
           pMungData-&gt;lastTime = time;
      } 

    // status information -  use CG to draw
         char   status[64];
      float  fps, averagefps;
      UInt8   minutes, seconds, frames, index;
      CGPoint  thePos;
      CGRect  theRect;
      
      fps = (float)pMungData-&gt;timeScale / (float)frameTimeDelta;
         averagefps = ((float)pMungData-&gt;frameCount * (float)pMungData-&gt;timeScale) / (float)time;
         minutes = (time / pMungData-&gt;timeScale) / 60;
         seconds = (time / pMungData-&gt;timeScale) % 60;
         frames = (time % pMungData-&gt;timeScale) / frameTimeDelta; //pMungData-&gt;duration;
         sprintf(status, &quot;t: %ld, %02d:%02d.%02d, fps:%5.1f av:%5.1f&quot;, time, minutes, seconds, frames, fps, averagefps);

        CGContextClearRect(pMungData-&gt;context, pMungData-&gt;barRect);
        CGContextClearRect(pMungData-&gt;context, pMungData-&gt;textRect);
    CGContextBeginPath(pMungData-&gt;context);
    
    // number of frames in the queue
    index = (pMungData-&gt;queuedFrameCount &lt;= 25 ? pMungData-&gt;queuedFrameCount : 25);
    CGContextAddRects(pMungData-&gt;context, pMungData-&gt;qfRect[index-1], index);
    
    // number of skipped frames
    index = (pMungData-&gt;skipFrameCount &lt;= 25 ? pMungData-&gt;skipFrameCount : 25);
    CGContextAddRects(pMungData-&gt;context, pMungData-&gt;sfRect[index-1], index);
    
    // difference between the timeBaseTime and the this frame time
    theRect = CGRectMake(1, 15, 6 * timeBaseDelta / pMungData-&gt;duration, 3);
    CGContextAddRect(pMungData-&gt;context, theRect);
    
    // difference between the last drawn frame and this frame time
    theRect = CGRectMake(1, 20, 6 * frameTimeDelta / pMungData-&gt;duration, 3);
    CGContextAddRect(pMungData-&gt;context, theRect);

    // draw the graph
    pMungData-&gt;barRect = CGContextGetPathBoundingBox(pMungData-&gt;context);
    CGContextClosePath(pMungData-&gt;context);
        CGContextSetRGBFillColor(pMungData-&gt;context, 1.0, 0.0, 0.0, 1.0 );
    CGContextFillPath(pMungData-&gt;context);
    
    // text setup
         CGContextSetTextDrawingMode(pMungData-&gt;context, kCGTextInvisible);
    CGContextShowTextAtPoint(pMungData-&gt;context, pMungData-&gt;textPos.x, pMungData-&gt;textPos.y, status, strlen(status));
    thePos = CGContextGetTextPosition(pMungData-&gt;context);
    pMungData-&gt;textRect.size.width = ((int)(thePos.x + .5) + 2.0) - pMungData-&gt;textRect.origin.x;
    
    // draw the background rect
    CGContextSetRGBFillColor(pMungData-&gt;context, 1.0, 0.0, 0.0, 0.2 ); 
    CGContextFillRect(pMungData-&gt;context, pMungData-&gt;textRect);
    
    // draw the status string
    CGContextSetTextDrawingMode(pMungData-&gt;context, kCGTextFill);
      CGContextSetRGBFillColor(pMungData-&gt;context, 0.0, 1.0, 0.0, 1.0);
      CGContextShowTextAtPoint(pMungData-&gt;context, pMungData-&gt;textPos.x, pMungData-&gt;textPos.y, status, strlen(status));
    
        // mark the context for update
      CGContextSynchronize(pMungData-&gt;context);
  }
            
bail:
  return err;
}

#pragma mark-
/*****************************************************
*
* MGWindowEventHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void *inUserData)
*
* Purpose:   idle timer to idle the sequence grabber
*
* Notes:     timer should call this at least as much as the desired frame rate more if
*            capturing audio as well, we use 1/60th of a second
*
*/
static pascal void MGIdleTimer(EventLoopTimerRef inTimer, void *inUserData)
{
#pragma unused(inTimer)
  
  OSErr err = noErr;
  
  MungDataPtr pMungData = MungDataPtr(inUserData);
  if (NULL == pMungData) return;
  
  if (pMungData-&gt;isGrabbing) err = SGIdle(pMungData-&gt;seqGrab);
  if (err &amp;&amp; err != pMungData-&gt;err) {
      // some error specific to SGIdle occurred - any errors returned from the
      // data proc will also show up here and we don't want to write over them
      
      // in QT 4 you would always encounter a cDepthErr error after a user drags
      // the window, this failure condition has been greatly relaxed in QT 5
      // it may still occur but should only apply to vDigs that really control
      // the screen
      
      // you don't always know where these errors originate from, some may come
      // from the VDig...
      
      DisplayError(pMungData-&gt;pWindow, &quot;SGIdle&quot;, err);
      
      // ...to fix this we simply call SGStop and SGStartRecord again
      // calling stop allows the SG to release and re-prepare for grabbing
      // hopefully fixing any problems, this is obviously a very relaxed
      // approach
      SGStop(pMungData-&gt;seqGrab);
      SGStartRecord(pMungData-&gt;seqGrab);
  }
}

/*****************************************************
*
* MGWindowEventHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void *inUserData)
*
* Purpose:  window event handler
*
* Notes:
*
*/
static pascal OSStatus MGWindowEventHandler(EventHandlerCallRef nextHandler, EventRef theEvent, void *inUserData)
{
  WindowRef theWindow;
    OSErr err;
  
  OSStatus status = eventNotHandledErr;
  
  MungDataPtr pMungData = MungDataPtr(inUserData);
  if (NULL == pMungData) goto Done;
  
  UInt32 eventKind;
  eventKind = GetEventKind(theEvent);
  
  // we need the window ref or bail
  err = GetEventParameter(theEvent, kEventParamDirectObject, typeWindowRef, NULL, sizeof(theWindow), NULL, &amp;theWindow);
    require_noerr(err, Done);
    
  switch (eventKind) {
  case kEventWindowHiding:
    // fall through, same action as kEventWindowCollapsed
        
  case kEventWindowCollapsed:
    // checking this here avoids passible codecNothingToBlitErr later
        if (pMungData-&gt;isGrabbing) {
          SGStop(pMungData-&gt;seqGrab);
          SetEventLoopTimerNextFireTime(pMungData-&gt;timerRef, kEventDurationForever);
          pMungData-&gt;isGrabbing = false;
        }
        
        break;
  case kEventWindowShown:
        // fall through
        
  case kEventWindowExpanded:
        CallNextEventHandler(nextHandler, theEvent);
        
        if (kEventWindowShown == eventKind) {
            ActivateWindow(theWindow, true);
            UpdateStaticText(pMungData);
        }
        
    // we stopped grabbing in the collapsed event so start grabbing on expanded
    if (!pMungData-&gt;isGrabbing) {
          SGStartRecord(pMungData-&gt;seqGrab);
          SetEventLoopTimerNextFireTime(pMungData-&gt;timerRef, kEventDurationNoWait);
          pMungData-&gt;isGrabbing = true;
         }
        
        status = noErr; // we handled the event
    
        break;
  case kEventWindowClickDragRgn:
    Point where;
    ICMAlignmentProcRecord apr;
        
        // we need the 'where' param from the Event for DragAlignedWindow
        err = GetEventParameter(theEvent, kEventParamMouseLocation, typeQDPoint, NULL, sizeof(where), NULL, &amp;where);
        require_noerr(err, Done);
        
        SGGetAlignmentProc(pMungData-&gt;seqGrab, &amp;apr);

        DragAlignedWindow(theWindow, where, &amp;gScreenbits.bounds, NULL, &amp;apr);
        
        status = noErr; // we handled the event
        
    break;
  case kEventWindowClose:
    {
        // we're done
        ProcessSerialNumber psn = { 0, kCurrentProcess };
        AppleEvent quitEvent;
        AEDesc target;
        
        CallNextEventHandler(nextHandler, theEvent);
        
        HideWindow(pMungData-&gt;pOverlay);
        
        // send a Quit apple event to ourselves
        AECreateDesc(typeProcessSerialNumber, (Ptr)&amp;psn, sizeof(ProcessSerialNumber), &amp;target);
        AECreateAppleEvent(kCoreEventClass, kAEQuitApplication, &amp;target, kAutoGenerateReturnID, kAnyTransactionID, &amp;quitEvent);
        AESend(&amp;quitEvent, NULL, kAENoReply, kAENormalPriority, kNoTimeOut, NULL, NULL);
        AEDisposeDesc(&amp;quitEvent);
        AEDisposeDesc(&amp;target);
        
        status = noErr; // we handled the event
    }
    break;
  default:
    break;
  }

Done:
  return status;
}

/*****************************************************
*
* HandleQuitAE(const AppleEvent *theAppleEvent, AppleEvent *reply, long inRefcon)
*
* Purpose:  handle the Quit AppleEvent
*
* Notes:
*
*/
static pascal OSErr HandleQuitAE(const AppleEvent *theAppleEvent, AppleEvent *reply, long inRefcon)
{
#pragma unused (theAppleEvent, reply)

  MungDataPtr pMungData = MungDataPtr(inRefcon);
  
  if (pMungData) {
        // we're done
    SGStop(pMungData-&gt;seqGrab);
    pMungData-&gt;isGrabbing = false;

    RemoveEventLoopTimer(pMungData-&gt;timerRef);
        
        SGRelease(pMungData-&gt;seqGrab);
    }
  
  QuitApplicationEventLoop();
  
  return noErr;
}

/*****************************************************
*
* InstallEvenHandlers(MungDataPtr inMungData)
*
* Purpose:  intalls event handlers and carbon timer
*
* Notes:
*
*/
static OSErr InstallEvenHandlers(MungDataPtr inMungData)
{
  const EventTypeSpec windowEventList[] = { kEventClassWindow, kEventWindowCollapsed,
                         kEventClassWindow, kEventWindowExpanded,
                         kEventClassWindow, kEventWindowClickDragRgn,
                         kEventClassWindow, kEventWindowClose,
                         kEventClassWindow, kEventWindowShown,
                         kEventClassWindow, kEventWindowHiding };

  OSStatus err;
    
    err = InstallEventLoopTimer(GetMainEventLoop(), kEventDurationNoWait, kTimerInterval, MGIdleTimer, inMungData, &amp;inMungData-&gt;timerRef);
    require_noerr(err, CantInstallEventLoopTimer);
      
  err = InstallWindowEventHandler(inMungData-&gt;pWindow, NewEventHandlerUPP(MGWindowEventHandler), 7, windowEventList, inMungData, NULL);
    require_noerr(err, CantInstallWindowEventHandler);
  
  err = AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, NewAEEventHandlerUPP(HandleQuitAE), (long)inMungData, false);

CantInstallEventLoopTimer:
CantInstallWindowEventHandler:
  return err;  
}

#pragma mark-
/*****************************************************
*
* SetupOverlayContext(MungDataPtr inMungData)
*
* Purpose:  creates and sets up the CGContext for our overlay window
*           this is where the text is rendered by the DataProc
*
* Notes:
*
*/
OSErr SetupOverlayContext(MungDataPtr inMungData)
{
  Rect  portRect;
  OSErr err = noErr;
  
    SizeWindow(inMungData-&gt;pWindow, inMungData-&gt;bounds.right, inMungData-&gt;bounds.bottom, false);
    SizeWindow(inMungData-&gt;pOverlay, inMungData-&gt;bounds.right, inMungData-&gt;bounds.bottom, false);
    
    GetPortBounds(GetWindowPort(inMungData-&gt;pWindow), &amp;inMungData-&gt;bounds);
    
    // create a context for the overlay window and transform to QD coordinates
  err = CreateCGContextForPort(GetWindowPort(inMungData-&gt;pOverlay), &amp;inMungData-&gt;context);
    require_noerr(err, CantCreateContext);
    
  GetPortBounds(GetWindowPort(inMungData-&gt;pOverlay), &amp;portRect);
  SyncCGContextOriginWithPort(inMungData-&gt;context, GetWindowPort(inMungData-&gt;pOverlay));    
    CGContextTranslateCTM(inMungData-&gt;context, 0, (float)(portRect.bottom - portRect.top));
    CGContextScaleCTM(inMungData-&gt;context, 1.0, -1.0);

    CGContextClearRect(inMungData-&gt;context, CGRectMake(0,
                                                       0,
                                                       (float)(portRect.right - portRect.left),
                                                       (float)(portRect.bottom - portRect.top)));
  
  CGContextSetTextMatrix(inMungData-&gt;context, CGContextGetCTM(inMungData-&gt;context));
  CGContextSelectFont(inMungData-&gt;context, &quot;Helvetica&quot;, 10.0, kCGEncodingMacRoman);
  CGContextSetLineWidth(inMungData-&gt;context, 1.0);

  // size of the semi-transparent text background rect we draw
    inMungData-&gt;textRect = CGRectMake(inMungData-&gt;offsetRect.origin.x + 8,
                    ((float)(portRect.bottom) - inMungData-&gt;offsetRect.size.height),
                    (float)portRect.right, // this is adjusted during draw              
                    (float)18);
    // position of text we draw
  inMungData-&gt;textPos = CGPointMake(inMungData-&gt;offsetRect.origin.x + 10,
                                      ((float)(portRect.bottom) - inMungData-&gt;offsetRect.size.height + 13));

  UpdateStaticText(inMungData);

CantCreateContext:
  return err;
}

/*****************************************************
*
* UpdateStaticText(MungDataPtr inMungData)
*
* Purpose:  update the static text when needed
*
* Notes:
*
*/
void UpdateStaticText(MungDataPtr inMungData)
{
  char *yes = &quot;Quartz: Acclerated&quot;;
  char *nope = &quot;Quartz: Not Accelerated&quot;;
    
  CGContextSetTextDrawingMode(inMungData-&gt;context, kCGTextFill);
  CGContextSetRGBFillColor(inMungData-&gt;context, 1.0, 0.0, 0.0, 1.0);
  if (inMungData-&gt;isAccelerated) {
    CGContextShowTextAtPoint(inMungData-&gt;context, inMungData-&gt;textPos.x, inMungData-&gt;textPos.y - 15, yes, strlen(yes));
  } else {
    CGContextShowTextAtPoint(inMungData-&gt;context, inMungData-&gt;textPos.x, inMungData-&gt;textPos.y - 15, nope, strlen(nope));
  }
}

#pragma mark-
/*****************************************************
*
* MakeWindows(MungDataPtr inMungData, IBNibRef inNibRef)
*
* Purpose:  create main and overlay windows
*
* Notes:
*
*/
OSErr MakeWindows(MungDataPtr inMungData, IBNibRef inNibRef)
{
    Rect windowRect = {0, 0, 240, 320};
    Rect bestRect;
    HIViewRef control;
    WindowGroupRef windowGroup;
    WindowAttributes oAttributes = kWindowNoShadowAttribute |
                     kWindowIgnoreClicksAttribute | kWindowNoActivatesAttribute;
                                   
  OSErr err = noErr;
    
    // Create a window. &quot;MainWindow&quot; is the name of the window object. This name is set in 
    // InterfaceBuilder when the nib is created.
    err = CreateWindowFromNib(inNibRef, CFSTR(&quot;MainWindow&quot;), &amp;inMungData-&gt;pWindow);
    require_noerr( err, CantCreateWindow);
    
    GetWindowBounds(inMungData-&gt;pWindow, kWindowContentRgn, &amp;windowRect);
    
    // create the overlay window
  err = CreateNewWindow(kOverlayWindowClass, oAttributes, &amp;windowRect, &amp;inMungData-&gt;pOverlay);
    require_noerr(err, CantCreateWindow);
  
    // create the window group and group the two windows together
  CreateWindowGroup(kWindowGroupAttrMoveTogether | 
                    kWindowGroupAttrLayerTogether |
                    kWindowGroupAttrSharedActivation |
                    kWindowGroupAttrHideOnCollapse, &amp;windowGroup);
                    
  SetWindowGroupParent(windowGroup, GetWindowGroup(inMungData-&gt;pWindow));
  SetWindowGroup(inMungData-&gt;pWindow, windowGroup);
  SetWindowGroup(inMungData-&gt;pOverlay, windowGroup);

    // set the port to the new window
    SetPortWindowPort(inMungData-&gt;pWindow);
    
    GetPortBounds(GetWindowPort(inMungData-&gt;pWindow), &amp;inMungData-&gt;bounds);
     AlignWindow(inMungData-&gt;pWindow, true, NULL, NULL);
    
    // get the frame size of the group box, we draw the video at this offset
    HIViewFindByID(HIViewGetRoot(inMungData-&gt;pWindow), kBoxID, &amp;control);
    HIViewGetFrame(control, &amp;inMungData-&gt;offsetRect);
    inMungData-&gt;offsetRect.size.width = inMungData-&gt;bounds.right - inMungData-&gt;offsetRect.size.width;
    inMungData-&gt;offsetRect.size.height = inMungData-&gt;bounds.bottom - inMungData-&gt;offsetRect.size.height;
    
  ShowWindow(inMungData-&gt;pWindow);
  ShowWindow(inMungData-&gt;pOverlay);
     
     inMungData-&gt;isAccelerated = CGDisplayUsesOpenGLAcceleration(kCGDirectMainDisplay);
    
CantCreateWindow:
    return err;
}

/*****************************************************
*
* MakeSequenceGrabber(MungDataPtr inMungData)
*
* Purpose:  open and configure the sequence grabber
*
* Notes:
*
*/
OSErr MakeSequenceGrabber(MungDataPtr inMungData)
{
  OSErr err = couldntGetRequiredComponent;

    // open the default sequence grabber
    inMungData-&gt;seqGrab = OpenDefaultComponent(SeqGrabComponentType, 0);
    require(inMungData-&gt;seqGrab != NULL, CantGetSG);
    
    // initialize the default sequence grabber component
    err = SGInitialize(inMungData-&gt;seqGrab);
    require_noerr(err, Bail);

    // set its graphics world to the specified window
    err = SGSetGWorld(inMungData-&gt;seqGrab, GetWindowPort(inMungData-&gt;pWindow), NULL);
    require_noerr(err, Bail);
      
    // specify the destination data reference for a record operation
    // tell it we're not making a movie
    // if the flag seqGrabDontMakeMovie is used, the sequence grabber still calls
    // your data function, but does not write any data to the movie file
    // writeType will always be set to seqGrabWriteAppend
    err = SGSetDataRef(inMungData-&gt;seqGrab,
                       0,
                       0,
                       seqGrabDontMakeMovie | seqGrabDataProcIsInterruptSafe);

Bail:
    if (err &amp;&amp; (inMungData-&gt;seqGrab != NULL)) { // clean up on failure
      CloseComponent(inMungData-&gt;seqGrab);
        inMungData-&gt;seqGrab = NULL;
    }
    
CantGetSG:
  return err;
}

/*****************************************************
*
* MakeSequenceGrabChannel(SeqGrabComponent seqGrab, SGChannel *sgchanVideo, SGChannel *sgchanSound)
*
* Purpose:  create the channels
*
* Notes:
*
*/
OSErr MakeSequenceGrabChannel(SeqGrabComponent seqGrab, SGChannel *sgchanVideo, SGChannel *sgchanSound)
{
  Rect  srcBounds;
  
    OSErr err = noErr;
    
    err = SGNewChannel(seqGrab, VideoMediaType, sgchanVideo);
    if (err == noErr) {
        err = SGNewChannel(seqGrab, SoundMediaType, sgchanSound);
        if (err) {
            // don't care if we couldn't get a sound channel
            *sgchanSound = NULL;
            err = noErr;
        }
    }
        
    if (err == noErr) {
      // get the active rectangle 
      err = SGGetSrcVideoBounds(*sgchanVideo, &amp;srcBounds);
      if (err == noErr) {
        // we always want all the source
            err = SetVideoChannelBounds(*sgchanVideo, &amp;srcBounds, &amp;srcBounds);
        if (err == noErr) {
          // set usage for new video channel to avoid playthrough
           // note we don't set seqGrabPlayDuringRecord
          err = SGSetChannelUsage(*sgchanVideo, seqGrabRecord |
                              seqGrabLowLatencyCapture |
                              seqGrabAlwaysUseTimeBase);
                if (err == noErr &amp;&amp; NULL != *sgchanSound) {
                    err = SGSetChannelUsage(*sgchanSound, seqGrabRecord |
                                                          //seqGrabPlayDuringRecord |
                                                          seqGrabLowLatencyCapture |
                                                          seqGrabAlwaysUseTimeBase);
                }
            }
    }
        
        if (err != noErr) {
            // clean up on failure
            SGDisposeChannel(seqGrab, *sgchanVideo);
            if (NULL != *sgchanSound) {
                SGDisposeChannel(seqGrab, *sgchanSound);
            }
        }
    }

  return err;
}

/*****************************************************
*
* SetVideoChannelBounds(SGChannel videoChannel, const Rect *scaledSourceBounds, const Rect *scaledVideoBounds)
*
* Purpose:  sets the desired video rect and video channel bounds
*
* Notes:    see Q&amp;A 1250
*
*/
ComponentResult SetVideoChannelBounds(SGChannel videoChannel, const Rect *scaledSourceBounds, const Rect *scaledVideoBounds)
{
    Rect sourceBounds;
    Rect videoBounds;
    Rect channelBounds;
    MatrixRecord scaledSourceBoundsToSourceBounds;
    ComponentResult err;
    
    // calculate the matrix to transform the
    // scaledSourceBounds to the source bounds
    SGGetSrcVideoBounds(videoChannel, &amp;sourceBounds);   
    RectMatrix(&amp;scaledSourceBoundsToSourceBounds,
               scaledSourceBounds, &amp;sourceBounds);
    
    // apply the same transform to the
    // scaledVideoBounds to get the video bounds
    videoBounds = *scaledVideoBounds;
    TransformRect(&amp;scaledSourceBoundsToSourceBounds, &amp;videoBounds, 0);
    
    err = SGSetVideoRect(videoChannel, &amp;videoBounds);
    if (err) {
      // some video digitizers may only be able to capture full frame
      // and will return qtParamErr or possibly digiUnimpErr
      // if they can't handle working with less than full frame
      SGSetVideoRect(videoChannel, &amp;sourceBounds);
    }

    // the channel bounds is scaledVideoBounds offset to (0, 0)
    channelBounds = *scaledVideoBounds;
    OffsetRect(&amp;channelBounds, -channelBounds.left, -channelBounds.top);
   
    // Note: SGSetChannelBounds merely allows the client to
    // specify it's preferred bounds. The actual bounds returned
    // by the vDig in the image description may be different
    err = SGSetChannelBounds(videoChannel, &amp;channelBounds);

    return err;
}

/*****************************************************
*
* DisposeMungData(MungDataPtr inMungData)
*
* Purpose:  end the decompression sequence, close the sequence grabber and
*           dispose of our data pointer
*
* Notes:   
*
*/
void DisposeMungData(MungDataPtr inMungData)
{
    // clean up the bits
    if(inMungData) {
        if (inMungData-&gt;drawSeq)
          CDSequenceEnd(inMungData-&gt;drawSeq);
        if (inMungData-&gt;seqGrab)
        CloseComponent(inMungData-&gt;seqGrab);
        DisposePtr((Ptr)inMungData);
    }
}

#pragma mark-
/*****************************************************
*
* main(argc, argv) 
*
* Purpose:  main program entry point
*
* Notes:    Penguins make up the scientific order Sphenisciformes and the family  Spheniscidae.
*
*/
int main(int argc, char* argv[])
{
    IBNibRef    nibRef;
    MungDataPtr  pMungData = NULL;
    SGChannel    sgchanSound = NULL;
    VideoBottles vb = { 0 };
    
    OSStatus err;

  InitCursor();
    EnterMovies();
    
    GetQDGlobalsScreenBits(&amp;gScreenbits);
    
    // Create a Nib reference passing the name of the nib file (without the .nib extension)
    // CreateNibReference only searches into the application bundle.
    err = CreateNibReference(CFSTR(&quot;main&quot;), &amp;nibRef);
    require_noerr(err, CantGetNibRef);
    
    // Once the nib reference is created, set the menu bar. &quot;MainMenu&quot; is the name of the menu bar
    // object. This name is set in InterfaceBuilder when the nib is created.
    err = SetMenuBarFromNib(nibRef, CFSTR(&quot;MenuBar&quot;));
    require_noerr(err, CantSetMenuBar);
    
    // initialize the data that's going to be passed around
    pMungData = (MungDataPtr)NewPtrClear(sizeof(MungDataRecord));
    err = MemError();
    require_noerr(err, CantCreateMungData);
    
    // create 25 rectangles which will represent our queued frames and skipped frames display
    for (UInt8 i=0; i &lt; 25; ++i) {
      for (UInt8 x=0; x &lt;= i; ++x) {
        pMungData-&gt;qfRect[i][x] = CGRectMake(8*x+1, 5, 6, 3);
        pMungData-&gt;sfRect[i][x] = CGRectMake(8*x+1, 10, 6, 3);
    }
  }
    
    // create the main and overlay windows and group them together
    err = MakeWindows(pMungData, nibRef);
    require_noerr(err, CantCreateWindow);
    
    // We don't need the nib reference anymore.
    DisposeNibReference(nibRef);    
    
    // create and initialize the sequence grabber
    err = MakeSequenceGrabber(pMungData);
    require_noerr(err, CantCreateSequenceGrabber);

    // create the channels
    err = MakeSequenceGrabChannel(pMungData-&gt;seqGrab, &amp;pMungData-&gt;sgchanVideo, &amp;sgchanSound);
    require_noerr(err, CantCreateVideoChannel);
    
    // specify a sequence grabber data function
  err = SGSetDataProc(pMungData-&gt;seqGrab, NewSGDataUPP(MungGrabDataProc), (long)pMungData);
    require_noerr(err, CantSetDataProc);
    
  SGSetChannelRefCon(pMungData-&gt;sgchanVideo, (long)pMungData);
  
    // set up the video bottlenecks so we can get our queued frame count
  err = SGGetVideoBottlenecks(pMungData-&gt;sgchanVideo, &amp;vb);
    require_noerr(err, CantGetBottlenecks);
    
    vb.procCount = 9; // there are 9 bottleneck procs; this must be filled in
    vb.grabCompressCompleteProc = NewSGGrabCompressCompleteBottleUPP(MungGrabCompressCompleteBottleProc);
  
    err = SGSetVideoBottlenecks(pMungData-&gt;sgchanVideo, &amp;vb);
    require_noerr(err, CantSetBottlenecks);
  
    if (pMungData-&gt;isAccelerated) {
        SGSetFrameRate(pMungData-&gt;sgchanVideo, FixRatio(30, 1));
    } else {
        SGSetFrameRate(pMungData-&gt;sgchanVideo, FixRatio(15, 1));
    }
    
  // install carbon event handlers
  err = InstallEvenHandlers(pMungData);
  require_noerr(err, CantInstallEventHandlers);
  
  // lights...camera...
  err = SGPrepare(pMungData-&gt;seqGrab, false, true);
    require_noerr(err, PrepareFailed);
    
    // make sure the timebase used by the video channel is being driven by
    // the sound clock if there is a sound channel, this has to be done
    // after calling SGPrepare - see Q&amp;A 1314
    if (NULL != sgchanSound) {
    TimeBase soundTimeBase = NULL, sgTimeBase = NULL;
    err = SGGetTimeBase(pMungData-&gt;seqGrab, &amp;sgTimeBase);
    if(noErr == err)
         err = SGGetChannelTimeBase(sgchanSound, &amp;soundTimeBase);
    if (noErr == err &amp;&amp; NULL != soundTimeBase)
        SetTimeBaseMasterClock(sgTimeBase, (Component)GetTimeBaseMasterClock(soundTimeBase), NULL);
  }
  
    // ...action
  err = SGStartRecord(pMungData-&gt;seqGrab);
    require_noerr(err, StartRecordFailed);
  
  pMungData-&gt;isGrabbing = true;
  
  // run the application
  RunApplicationEventLoop();

CantCreateMungData:
CantCreateSequenceGrabber:
CantCreateVideoChannel:
CantSetDataProc:
CantGetBottlenecks:
CantSetBottlenecks:
CantInstallEventHandlers:
PrepareFailed:
StartRecordFailed:
CantCreateWindow:
CantSetMenuBar:
CantGetNibRef:

    // clean up 
    if (pMungData-&gt;context)
        CGContextRelease(pMungData-&gt;context);  

    if (pMungData-&gt;pOverlay)
        DisposeWindow(pMungData-&gt;pOverlay);
        
    if (pMungData-&gt;pWindow)
        DisposeWindow(pMungData-&gt;pWindow);

    DisposeMungData(pMungData);

    return err;
}

</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/BrideOfMungGrab/listing1.html%3Fid%3DDTS10003504-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/BrideOfMungGrab/listing1.html%3Fid%3DDTS10003504-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/BrideOfMungGrab/listing1.html%3Fid%3DDTS10003504-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>