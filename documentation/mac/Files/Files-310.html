<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Selecting a Directory (IM: F)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING310></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Files-309.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Files-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Files-390.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Files-311.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Files-2.html"><B>Files</B></A> / <BR><DD><A HREF="Files-302.html"><B>Chapter 3 - Standard File Package</B></A> / <A HREF="Files-306.html"><B>Using the Standard File Package</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING310-0></A>
<H2><A NAME=MARKER-9-198></A>Selecting a Directory</H2>
 <A NAME=MARKER-2-199></A>You can present the recommended user interface for selecting a directory by calling the <CODE>CustomGetFile</CODE> procedure and passing it the addresses of a custom file filter function and a dialog hook function. See <A HREF=Files-305.html#MARKER-9-51>"Selecting Volumes and Directories" on page 3-10</A> for a description of the appearance and behavior of the directory selection dialog box.<P>
 The file filter function used to select directories is quite simple; it ensures that only directories, not files, are listed in the dialog box displayed by <CODE>CustomGetFile</CODE>. <BR><A HREF=Files-311.html#MARKER-9-209>Listing 3-16</A> defines a file filter function you can use for this purpose.<P>
<B>Listing 3-16  <A NAME=MARKER-9-209></A>A file filter function that lists only directories</B><P>
<PRE>
FUNCTION MyCustomFileFilter (pb: CInfoPBPtr; myDataPtr: Ptr): Boolean;
CONST
   kFolderBit = 4;                  {bit set in ioFlAttrib for a directory}
BEGIN                               {list directories only}
   MyCustomFileFilter := NOT BTst(pb^.ioFlAttrib, kFolderBit);
END;
</PRE>
 The function <CODE>MyCustomFileFilter</CODE> simply inspects the appropriate bit in the file attributes (<CODE>ioFlAttrib</CODE>) field of the catalog information parameter block passed to it. If the directory bit is set, the file filter function returns <CODE>FALSE</CODE>, indicating that the item should appear in the list; otherwise, the file filter function returns <CODE>TRUE</CODE> to exclude the item from the list. Because a volume is identified via its root directory, volumes also appear in the list of items in the dialog box.<P>
 The title of the Select button should identify which directory is available for selection. You can use the <CODE>SetButtonTitle</CODE> procedure defined in <A HREF=#MARKER-9-201>Listing 3-17</A> to set the title <BR>of a button.<P>
 Your dialog hook function calls the <CODE>SetButtonTitle</CODE> procedure to copy the truncated title of the selected item into the Select button. This title eliminates possible user confusion about which directory is available for selection. If no item in the list is selected, the dialog hook function uses the name of the directory shown in the pop-up menu as the title of the Select button.<P>
<B>Listing 3-17  <A NAME=MARKER-9-201></A>Setting a button's title</B><P>
<PRE>
PROCEDURE SetButtonTitle (ButtonHdl: Handle; name: Str255; ButtonRect: Rect);
VAR
   result:  Integer;    {result of TruncString}
   width:   Integer;    {width available for name of directory}
BEGIN
   gPrevSelectedName := name;
   WITH ButtonRect DO
      width := (right - left) - (StringWidth('Select &quot;&quot;') + CharWidth('\xA0'));
   result := TruncString(width, name, smTruncMiddle);
   SetCTitle(ControlHandle(ButtonHdl), CONCAT('Select &quot;', name, '&quot;'));
   ValidRect(ButtonRect);
END;
</PRE>
 The <CODE>SetButtonTitle</CODE> procedure is passed a handle to the button whose title is to be changed, the name of the directory available for selection, and the button's enclosing rectangle. The global variable <CODE>gPrevSelectedName</CODE> holds the full directory name, before truncation.<P>
 <A NAME=MARKER-2-192></A>A dialog hook function manages most of the process of letting the user select a director. <A HREF=#MARKER-9-203>Listing 3-18</A> defines a dialog hook function that handles user selections in the dialog box.<P>
<B>Listing 3-18  <A NAME=MARKER-9-203></A>Handling user selections in the directory selection dialog box</B><P>
<PRE>
FUNCTION MyDlgHook (item: Integer; theDialog: DialogPtr; myDataPtr: Ptr):
                   Integer;
CONST
   kGetDirBTN     = 10;          {Select directory button}
TYPE
   SFRPtr         = ^StandardFileReply;
VAR
   myType:        Integer;       {menu item selected}
   myHandle:      Handle;        {needed for GetDItem}
   myRect:        Rect;          {needed for GetDItem}
   myName:        Str255;
   myPB:          CInfoPBRec;
   mySFRPtr:      SFRPtr;
   myErr:         OSErr;
BEGIN
   MyDlgHook := item;      {default, except in special cases below}
   IF GetWRefCon(WindowPtr(theDialog)) &lt;&gt; LongInt(sfMainDialogRefCon) THEN
      Exit(MyDlgHook);     {this function is only for main dialog box}

   GetDItem(theDialog, kGetDirBTN, myType, myHandle, myRect);
   IF item = sfHookFirstCall THEN
      BEGIN
         {Determine current folder name and set title of Select button.}
         WITH myPB DO
            BEGIN
               ioCompletion := NIL;
               ioNamePtr := @myName;
               ioVRefNum := GetSFCurVol;
               ioFDirIndex := - 1;
               ioDirID := GetSFCurDir;
            END;
         myErr := PBGetCatInfo(@myPB, FALSE);
         SetButtonTitle(myHandle, myName, myRect);
      END
   ELSE
      BEGIN
         {Get mySFRPtr from 3rd parameter to hook function.}
         mySFRPtr := SFRPtr(myDataPtr);
         {Track name of folder that can be selected.}
         IF (mySFRPtr^.sfIsFolder) OR (mySFRPtr^.sfIsVolume) THEN
            myName := mySFRPtr^.sfFile.name
         ELSE
            BEGIN
               WITH myPB DO
                  BEGIN
                     ioCompletion := NIL;
                     ioNamePtr := @myName;
                     ioVRefNum := mySFRPtr^.sfFile.vRefNum;
                     ioFDirIndex := -1;
                     ioDrDirID := mySFRPtr^.sfFile.parID;
                  END;
               myErr := PBGetCatInfo(@myPB, FALSE);
            END;
         {Change directory name in button title as needed.}
         IF myName &lt;&gt; gPrevSelectedName THEN
            SetButtonTitle(myHandle, myName, myRect);

         CASE item OF
            kGetDirBTN:                   {force return by faking a cancel}
               MyDlgHook := sfItemCancelButton;
            sfItemCancelButton:
               gDirSelectionFlag := FALSE;{flag no directory was selected}
            OTHERWISE
               ;
         END; {CASE}
      END;
END;
</PRE>
 The <CODE>MyDlgHook</CODE> dialog hook function defined in <A HREF=#MARKER-9-203>Listing 3-18</A> calls the File Manager function <CODE>PBGetCatInfo</CODE> to retrieve the name of the directory to be selected. When the dialog hook function is first called (that is, when <CODE>item</CODE> is set to <CODE>sfHookFirstCall</CODE>), <CODE>MyDlgHook</CODE> determines the current volume and directory by calling the functions <CODE>GetSFCurVol</CODE> and <CODE>GetSFCurDir</CODE>. When <CODE>MyDlgHook</CODE> is called each subsequent time, <CODE>MyDlgHook</CODE> calls <CODE>PBGetCatInfo</CODE> with the volume reference number and directory ID <BR>of the previously opened directory.<P>
 When the user clicks the Select button, <CODE>MyDlgHook</CODE> returns the item <CODE>sfItemCancelButton</CODE>. When the user clicks the real Cancel button, <CODE>MyDlgHook</CODE> <BR>sets the global variable gDirSelectionFlag to <CODE>FALSE</CODE>, indicating that the user <BR>didn't select a directory. The function <CODE>DoGetDirectory</CODE> uses that variable to distinguish between clicks of Cancel and clicks of Select.<P>
 The function <CODE>DoGetDirectory</CODE> defined in <A HREF=#MARKER-9-204>Listing 3-19</A> uses the file filter function <BR>and the dialog hook functions defined above to manage the directory selection dialog box. On exit, <CODE>DoGetDirectory</CODE> returns a standard file reply record describing the selected directory.<P>
<B>Listing 3-19  Presenting the directory selection dialog box<A NAME=MARKER-9-204></A></B><P>
<PRE>
FUNCTION DoGetDirectory: StandardFileReply;
VAR
   myReply:          StandardFileReply;
   myTypes:          SFTypeList;          {types of files to display}
   myPoint:          Point;               {upper-left corner of box}
   myNumTypes:       Integer;
   myModalFilter:    ModalFilterYDProcPtr;
   myActiveList:     Ptr;
   myActivateProc:   ActivateYDProcPtr;
   myName:           Str255;
CONST
   rGetDirectoryDLOG = 128;               {resource ID of custom dialog box}
BEGIN
   gPrevSelectedName := '';         {initialize name of previous selection}
   gDirSelectionFlag := TRUE;       {initialize directory selection flag}
   myNumTypes := -1;                {pass all types of files to file filter}
   myPoint.h := -1;                 {center dialog box on screen}
   myPoint.v := -1;
   myModalFilter := NIL;
   myActiveList := NIL;
   myActivateProc := NIL;

   CustomGetFile(@MyCustomFileFilter, myNumTypes, myTypes, myReply,
                  rGetDirectoryDLOG, myPoint, @MyDlgHook, myModalFilter, 
                  myActiveList, myActivateProc, @myReply);
   {Get the name of the directory.}
   IF gDirSelectionFlag AND myReply.sfIsVolume THEN
      myName := Concat(myReply.sfFile.name, ':')
   ELSE 
      myName := myReply.sfFile.name;

   IF gDirSelectionFlag AND myReply.sfIsVolume THEN
      myReply.sfFile.name := myName
   ELSE IF gDirSelectionFlag THEN
      myReply.sfFile.name := gPrevSelectedName;
   gDirSelectionFlag := FALSE;
   DoGetDirectory := myReply;
END;
</PRE>
 The <CODE>DoGetDirectory</CODE> function initializes the two global variables gPrevSelectedName and gDirSelectionFlag. As you have seen, these two variables are used by the custom dialog hook function. Then <CODE>DoGetDirectory</CODE> <BR>calls <CODE>CustomGetFile</CODE> to display the directory selection dialog box and handle user selections. When the user selects a directory or clicks the Cancel button, the dialog <BR>hook function returns sfItemCancelButton and <CODE>CustomGetFile</CODE> exits. At that <BR>point, the reply record contains information about the last item selected in the list of available items.<A NAME=MARKER-2-205></A><A NAME=MARKER-9-501></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Files-309.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Files-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Files-390.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Files-311.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Files-3.html">&copy; Apple Computer, Inc.</A><br>2 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
