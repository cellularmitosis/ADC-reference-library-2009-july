<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>GLUT - /gle/ex_cut_round.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/GraphicsImaging/index.html">Graphics & Imaging</a> &gt; <a href="../../samplecode/GraphicsImaging/idxOpenGL-date.html">OpenGL</a> &gt; <A HREF="javascript:location.replace('index.html');">GLUT</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->


	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">GLUT</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/gle/ex_cut_round.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/gle/copy.h</option>
<option value="listing2.html">/gle/ex_angle.c</option>
<option value="listing3.html">/gle/ex_cut_round.c</option>
<option value="listing4.html">/gle/ex_raw.c</option>
<option value="listing5.html">/gle/extrude.c</option>
<option value="listing6.html">/gle/extrude.h</option>
<option value="listing7.html">/gle/gle_osx.h</option>
<option value="listing8.html">/gle/gutil.h</option>
<option value="listing9.html">/gle/intersect.c</option>
<option value="listing10.html">/gle/intersect.h</option>
<option value="listing11.html">/gle/port.h</option>
<option value="listing12.html">/gle/rot.h</option>
<option value="listing13.html">/gle/rot_prince.c</option>
<option value="listing14.html">/gle/rotate.c</option>
<option value="listing15.html">/gle/round_cap.c</option>
<option value="listing16.html">/gle/segment.c</option>
<option value="listing17.html">/gle/segment.h</option>
<option value="listing18.html">/gle/texgen.c</option>
<option value="listing19.html">/gle/tube.h</option>
<option value="listing20.html">/gle/tube_gc.h</option>
<option value="listing21.html">/gle/urotate.c</option>
<option value="listing22.html">/gle/view.c</option>
<option value="listing23.html">/gle/vvector.h</option>
<option value="listing24.html">/glsmap/glsmap.h</option>
<option value="listing25.html">/glsmap/glsmapint.h</option>
<option value="listing26.html">/glsmap/smap_buildsmap.c</option>
<option value="listing27.html">/glsmap/smap_context.c</option>
<option value="listing28.html">/glsmap/smap_create.c</option>
<option value="listing29.html">/glsmap/smap_destroy.c</option>
<option value="listing30.html">/glsmap/smap_drawmesh.c</option>
<option value="listing31.html">/glsmap/smap_flag.c</option>
<option value="listing32.html">/glsmap/smap_get.c</option>
<option value="listing33.html">/glsmap/smap_getfunc.c</option>
<option value="listing34.html">/glsmap/smap_gettexdim.c</option>
<option value="listing35.html">/glsmap/smap_gettexobj.c</option>
<option value="listing36.html">/glsmap/smap_getvec.c</option>
<option value="listing37.html">/glsmap/smap_makemesh.c</option>
<option value="listing38.html">/glsmap/smap_nearfar.c</option>
<option value="listing39.html">/glsmap/smap_origin.c</option>
<option value="listing40.html">/glsmap/smap_render.c</option>
<option value="listing41.html">/glsmap/smap_rvec2st.c</option>
<option value="listing42.html">/glsmap/smap_set.c</option>
<option value="listing43.html">/glsmap/smap_setfunc.c</option>
<option value="listing44.html">/glsmap/smap_setvec.c</option>
<option value="listing45.html">/glsmap/smap_texdim.c</option>
<option value="listing46.html">/glsmap/smap_texobj.c</option>
<option value="listing47.html">/glut.h</option>
<option value="listing48.html">/glut_8x13.c</option>
<option value="listing49.html">/glut_9x15.c</option>
<option value="listing50.html">/glut_bitmap.c</option>
<option value="listing51.html">/glut_bwidth.c</option>
<option value="listing52.html">/glut_cindex.c</option>
<option value="listing53.html">/glut_ext.c</option>
<option value="listing54.html">/glut_hel10.c</option>
<option value="listing55.html">/glut_hel12.c</option>
<option value="listing56.html">/glut_hel18.c</option>
<option value="listing57.html">/glut_mroman.c</option>
<option value="listing58.html">/glut_roman.c</option>
<option value="listing59.html">/glut_shapes.c</option>
<option value="listing60.html">/glut_stroke.c</option>
<option value="listing61.html">/glut_swidth.c</option>
<option value="listing62.html">/glut_teapot.c</option>
<option value="listing63.html">/glut_tr10.c</option>
<option value="listing64.html">/glut_tr24.c</option>
<option value="listing65.html">/glut_vidresize.c</option>
<option value="listing66.html">/GLUTApplication.h</option>
<option value="listing67.html">/GLUTApplication.m</option>
<option value="listing68.html">/glutbitmap.h</option>
<option value="listing69.html">/GLUTClipboardController.h</option>
<option value="listing70.html">/GLUTClipboardController.m</option>
<option value="listing71.html">/glutf90.h</option>
<option value="listing72.html">/GLUTMenu.h</option>
<option value="listing73.html">/GLUTMenu.m</option>
<option value="listing74.html">/GLUTMenuItem.h</option>
<option value="listing75.html">/GLUTMenuItem.m</option>
<option value="listing76.html">/GLUTPreferencesController.h</option>
<option value="listing77.html">/GLUTPreferencesController.m</option>
<option value="listing78.html">/glutstroke.h</option>
<option value="listing79.html">/GLUTView.h</option>
<option value="listing80.html">/GLUTView.m</option>
<option value="listing81.html">/GLUTWindow.h</option>
<option value="listing82.html">/GLUTWindow.m</option>
<option value="listing83.html">/HID_Config_Utilities.c</option>
<option value="listing84.html">/HID_Config_Utilities.h</option>
<option value="listing85.html">/HID_Error_Handler.c</option>
<option value="listing86.html">/HID_Error_Handler.h</option>
<option value="listing87.html">/HID_Name_Lookup.c</option>
<option value="listing88.html">/HID_Name_Lookup.h</option>
<option value="listing89.html">/HID_Queue_Utilities.c</option>
<option value="listing90.html">/HID_Queue_Utilities.h</option>
<option value="listing91.html">/HID_Utilities.c</option>
<option value="listing92.html">/HID_Utilities.h</option>
<option value="listing93.html">/HID_Utilities_External.h</option>
<option value="listing94.html">/HID_Utilities_Internal.h</option>
<option value="listing95.html">/libForeground.a</option>
<option value="listing96.html">/macx_cursor.m</option>
<option value="listing97.html">/macx_dials.m</option>
<option value="listing98.html">/macx_dstr.m</option>
<option value="listing99.html">/macx_event.m</option>
<option value="listing100.html">/macx_fortran.m</option>
<option value="listing101.html">/macx_gamemode.m</option>
<option value="listing102.html">/macx_get.m</option>
<option value="listing103.html">/macx_glut.h</option>
<option value="listing104.html">/macx_init.m</option>
<option value="listing105.html">/macx_input.m</option>
<option value="listing106.html">/macx_joy.m</option>
<option value="listing107.html">/macx_key.m</option>
<option value="listing108.html">/macx_menu.m</option>
<option value="listing109.html">/macx_modifier.m</option>
<option value="listing110.html">/macx_overlay.m</option>
<option value="listing111.html">/macx_space.m</option>
<option value="listing112.html">/macx_swap.m</option>
<option value="listing113.html">/macx_tablet.m</option>
<option value="listing114.html">/macx_util.m</option>
<option value="listing115.html">/macx_utilities.h</option>
<option value="listing116.html">/macx_warp.m</option>
<option value="listing117.html">/macx_win.m</option>
<option value="listing118.html">/ReadMe.txt</option></select>
				</p>
				</form>
				<p><strong><a href="glut.zip">Download Sample</a></strong> (&#147;glut.zip&#148;, 374.3K)<BR>
<strong><a href="glut.dmg">Download Sample</a></strong> (&#147;glut.dmg&#148;, 680.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">
/*
 * MODULE NAME: ex_cut_round.c
 *
 * FUNCTION:
 * This module contains code that draws extrusions with cut or round
 * join styles. The cut join style is a beveled edge.
 * The code also inserts colors and normals if appropriate.
 *
 * HISTORY:
 * written by Linas Vepstas August/September 1991
 * split into multiple compile units, Linas, October 1991
 * added normal vectors Linas, October 1991
 * Fixed filleting problem, Linas February 1993
 * Modified to handle round joins as well (based on common code),
 *                           Linas, March 1993
 * work around OpenGL's lack of support for concave polys, June 1994
 */
#ifdef __APPLE__
#include &quot;gle_osx.h&quot;
#endif

#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;    /* for the memcpy() subroutine */
#include &lt;tube.h&gt;
#include &quot;port.h&quot; 
#include &quot;gutil.h&quot;
#include &quot;vvector.h&quot;
#include &quot;tube_gc.h&quot;
#include &quot;extrude.h&quot;
#include &quot;intersect.h&quot;
#include &quot;segment.h&quot;


#ifdef NONCONCAVE_CAPS

/* ============================================================ */
/* 
 * This subroutine draws a flat cap, to close off the cut ends 
 * of the cut-style join.  Because OpenGL doe not natively handle 
 * concave polygons, this will cause some artifacts to appear on the
 * screen.
 */

void draw_cut_style_cap_callback (int iloop,
                                  double cap[][3], 
                                  float face_color[3],
                                  gleDouble cut_vector[3],
                                  gleDouble bisect_vector[3],
                                  double norms[][3], 
                                  int frontwards)
{
   int i;

   if (face_color != NULL) C3F (face_color);

   if (frontwards) {

      /* if lighting is on, specify the endcap normal */
      if (cut_vector != NULL) {
         /* if normal pointing in wrong direction, flip it. */
         if (cut_vector[2] &lt; 0.0) { 
            VEC_SCALE (cut_vector, -1.0, cut_vector); 
         }
         N3F_D (cut_vector);
      }
      BGNPOLYGON();
      for (i=0; i&lt;iloop; i++) {
         V3F_D (cap[i], i, FRONT_CAP);
      }
      ENDPOLYGON();
   } else {

      /* if lighting is on, specify the endcap normal */
      if (cut_vector != NULL) {
         /* if normal pointing in wrong direction, flip it. */
         if (cut_vector[2] &gt; 0.0) 
           { VEC_SCALE (cut_vector, -1.0, cut_vector); }
         N3F_D (cut_vector);
      }
      /* the sense of the loop is reversed for backfacing culling */
      BGNPOLYGON();
      for (i=iloop-1; i&gt;-1; i--) {
         V3F_D (cap[i], i, BACK_CAP);
      }
      ENDPOLYGON();
   }

}

#else /* NONCONCAVE_CAPS */

/* ============================================================ */
/* 
 * This subroutine draws a flat cap, to close off the cut ends 
 * of the cut-style join.  Properly handles concave endcaps.
 */

/* ARGSUSED4 */
static void draw_cut_style_cap_callback (int iloop,
                                  double cap[][3], 
                                  float face_color[3],
                                  gleDouble cut_vector[3],
                                  gleDouble bisect_vector[3],
                                  double norms[][3], 
                                  int frontwards)
{
   int i;
#ifdef OPENGL_10
   GLUtriangulatorObj *tobj;
   tobj = gluNewTess ();
   gluTessCallback (tobj, GLU_BEGIN, glBegin);
   gluTessCallback (tobj, GLU_VERTEX, glVertex3dv);
   gluTessCallback (tobj, GLU_END, glEnd);
#endif /* OPENGL_10 */

   if (face_color != NULL) C3F (face_color);

   if (frontwards) {

      /* if lighting is on, specify the endcap normal */
      if (cut_vector != NULL) {
         /* if normal pointing in wrong direction, flip it. */
         if (cut_vector[2] &lt; 0.0) { 
            VEC_SCALE (cut_vector, -1.0, cut_vector); 
         }
         N3F_D (cut_vector);
      }
#ifdef GL_32
      BGNPOLYGON();
      for (i=0; i&lt;iloop; i++) {
         V3F_D (cap[i], i, FRONT_CAP);
      }
      ENDPOLYGON();
#endif /* GL_32 */
#ifdef OPENGL_10
      gluBeginPolygon (tobj);
      for (i=0; i&lt;iloop; i++) {
         gluTessVertex (tobj, cap[i], cap[i]);
      }
      gluEndPolygon (tobj);
#endif /* OPENGL_10 */
   } else {

      /* if lighting is on, specify the endcap normal */
      if (cut_vector != NULL) {
         /* if normal pointing in wrong direction, flip it. */
         if (cut_vector[2] &gt; 0.0) {
            VEC_SCALE (cut_vector, -1.0, cut_vector); 
         }
         N3F_D (cut_vector);
      }
      /* the sense of the loop is reversed for backfacing culling */
#ifdef GL_32
      BGNPOLYGON();
      for (i=iloop-1; i&gt;-1; i--) {
         V3F_D (cap[i], i, BACK_CAP);
      }
      ENDPOLYGON();
#endif /* GL_32 */
#ifdef OPENGL_10
      gluBeginPolygon (tobj);
      for (i=iloop-1; i&gt;-1; i--) {
         gluTessVertex (tobj, cap[i], cap[i]);
      }
      gluEndPolygon (tobj);
#endif /* OPENGL_10 */
   }

#ifdef OPENGL_10
   gluDeleteTess (tobj);
#endif /* OPENGL_10 */

}
#endif /* NONCONCAVE_ENDCAPS */

/* ============================================================ */
/* 
 * This subroutine matchs the cap callback template, but is a no-op
 */

/* ARGSUSED */
void null_cap_callback (int iloop,
                        double cap[][3], 
                        float face_color[3],
                        gleDouble cut_vector[3],
                        gleDouble bisect_vector[3],
                        double norms[][3], 
                        int frontwards)
{}

/* ============================================================ */
/* 
 * This little routine draws the little idd-biddy fillet triangle with
 * the right  color, normal, etc.
 *
 * HACK ALERT -- there are two aspects to this routine/interface that
 * are &quot;unfinished&quot;.
 * 1) the third point of the triangle should get a color thats
 *    interpolated beween the front and back color.  The interpolant
 *    is not currently being computed.  The error introduced by not 
 *    doing this should be tiny and/or non-exitant in almost all 
 *    expected uses of this code.
 *
 * 2) additional normal vectors should be supplied, and these should
 *    be interpolated to fit.  Currently, this is not being done.  As
 *    above, the expected error of not doing this should be tiny and/or
 *    non-existant in almost all expected uses of this code.
 */
/* ARGSUSED6 */
static void draw_fillet_triangle_plain
                          (gleDouble va[3],
                           gleDouble vb[3],
                           gleDouble vc[3],
                           int face,
                           float front_color[3],
                           float back_color[3])
{

   if (front_color != NULL) C3F (front_color);
   BGNTMESH (-5, 0.0);
   if (face) {
      V3F (va, -1, FILLET);
      V3F (vb, -1, FILLET);
   } else {
      V3F (vb, -1, FILLET);
      V3F (va, -1, FILLET);
   }
   V3F (vc, -1, FILLET);
   ENDTMESH ();

}

/* ============================================================ */
/* 
 * This little routine draws the little idd-biddy fillet triangle with
 * the right  color, normal, etc.
 *
 * HACK ALERT -- there are two aspects to this routine/interface that
 * are &quot;unfinished&quot;.
 * 1) the third point of the triangle should get a color thats
 *    interpolated beween the front and back color.  The interpolant
 *    is not currently being computed.  The error introduced by not 
 *    doing this should be tiny and/or non-exitant in almost all 
 *    expected uses of this code.
 *
 * 2) additional normal vectors should be supplied, and these should
 *    be interpolated to fit.  Currently, this is not being done.  As
 *    above, the expected error of not doing this should be tiny and/or
 *    non-existant in almost all expected uses of this code.
 */
/* ARGSUSED5 */
static void draw_fillet_triangle_n_norms
                          (gleDouble va[3],
                           gleDouble vb[3],
                           gleDouble vc[3],
                           int face,
                           float front_color[3],
                           float back_color[3],
                           double na[3],
                           double nb[3])
{

   if (front_color != NULL) C3F (front_color);
   BGNTMESH (-5, 0.0);
   if (__TUBE_DRAW_FACET_NORMALS) {
      N3F_D (na);
      if (face) {
         V3F (va, -1, FILLET);
         V3F (vb, -1, FILLET);
      } else {
         V3F (vb, -1, FILLET);
         V3F (va, -1, FILLET);
      }
      V3F (vc, -1, FILLET);
   } else {
      if (face) {
         N3F_D (na);
         V3F (va, -1, FILLET);
         N3F_D (nb);
         V3F (vb, -1, FILLET);
      } else {
         N3F_D (nb);
         V3F (vb, -1, FILLET);
         N3F_D (na);
         V3F (va, -1, FILLET);
         N3F_D (nb);
      }
      V3F (vc, -1, FILLET);
   }
   ENDTMESH ();

}

/* ============================================================ */

static void draw_fillets_and_join_plain
                    (int ncp, 
                    gleDouble trimmed_loop[][3],
                    gleDouble untrimmed_loop[][3], 
                    int is_trimmed[],
                    gleDouble bis_origin[3], 
                    gleDouble bis_vector[3], 
                    float front_color[3],
                    float back_color[3],
                    gleDouble cut_vector[3], 
                    int face,
                    void ((*cap_callback) (int iloop,
                                  double cap[][3],
                                  float face_color[3],
                                  gleDouble cut_vector[3],
                                  gleDouble bisect_vector[3],
                                  double norms[][3],
                                  int frontwards)))
{
   int istop;
   int icnt, icnt_prev = 0, iloop;
   double *cap_loop;
   gleDouble sect[3];
   gleDouble tmp_vec[3];
   int save_style;
   int was_trimmed = FALSE;

   cap_loop = (double *) malloc ((ncp+3)*3*sizeof (double));
   
   /* if the first point on the contour isn't trimmed, go ahead and
    * drop an edge down to the bisecting plane, (thus starting the 
    * join).  (Only need to do this for cut join, its bad if done for
    * round join).
    *
    * But if the first point is trimmed, keep going until one
    * is found that is not trimmed, and start join there.  */

   icnt = 0;
   iloop = 0;
   if (!is_trimmed[0]) {
      if (__TUBE_CUT_JOIN) {
         VEC_SUM (tmp_vec, trimmed_loop[0], bis_vector);
         INNERSECT (sect, 
                    bis_origin,
                    bis_vector,
                    trimmed_loop[0],
                    tmp_vec);
         VEC_COPY ( (&amp;cap_loop[3*iloop]), sect);
         iloop ++;
      }
      VEC_COPY ( (&amp;cap_loop[3*iloop]), (trimmed_loop[0])); 
      iloop++;
      icnt_prev = icnt;
      icnt ++;
   } else {

      /* else, loop until an untrimmed point is found */
      was_trimmed = TRUE;
      while (is_trimmed[icnt]) {
         icnt_prev = icnt;
         icnt ++;
         if (icnt &gt;= ncp) { 
            free (cap_loop);
            return;    /* oops - everything was trimmed */
         }
      }
   }

   /* Start walking around the end cap.  Every time the end loop is
    * trimmed, we know we'll need to draw a fillet triangle.  In
    * addition, after every pair of visibility changes, we draw a cap. */
   if (__TUBE_CLOSE_CONTOUR) {
      istop = ncp;
   } else {
      istop = ncp-1;
   }

   /* save the join style, and disable a closed contour.
    * Need to do this so partial contours don't close up. */
   save_style = gleGetJoinStyle ();
   gleSetJoinStyle (save_style &amp; ~TUBE_CONTOUR_CLOSED);

   for (; icnt_prev &lt; istop; icnt_prev ++, icnt ++, icnt %= ncp) {

      /* There are four interesting cases for drawing caps and fillets:
       *    1) this &amp; previous point were trimmed.  Don't do anything, 
       *       advance counter.
       *    2) this point trimmed, previous not -- draw fillet, and 
       *       draw cap.
       *    3) this point not trimmed, previous one was -- compute
       *       intersection point, draw fillet with it, and save 
       *       point for cap contour.
       *    4) this &amp; previous point not trimmed -- save for endcap.
       */

      /* Case 1 -- noop, just advance pointers */
      if (is_trimmed[icnt_prev] &amp;&amp; is_trimmed[icnt]) {
      }

      /* Case 2 --  Hah! first point! compute intersect &amp; draw fillet! */
      if (is_trimmed[icnt_prev] &amp;&amp; !is_trimmed[icnt]) {

         /* important note: the array &quot;untrimmed&quot; contains valid
          * untrimmed data ONLY when is_trim is TRUE.  Otherwise, 
          * only &quot;trim&quot; containes valid data */

         /* compute intersection */
         INNERSECT (sect, 
                    bis_origin,
                    bis_vector,
                    untrimmed_loop[icnt_prev],
                    trimmed_loop[icnt]);

         /* Draw Fillet */
         draw_fillet_triangle_plain (trimmed_loop[icnt_prev],
                               trimmed_loop[icnt],
                               sect,
                               face,
                               front_color,
                               back_color);

         VEC_COPY ( (&amp;cap_loop[3*iloop]), sect);
         iloop ++;
         VEC_COPY ( (&amp;cap_loop[3*iloop]), (trimmed_loop[icnt])); 
         iloop++;
      }

      /* Case 3 -- add to collection of points */
      if (!is_trimmed[icnt_prev] &amp;&amp; !is_trimmed[icnt]) {
         VEC_COPY ( (&amp;cap_loop[3*iloop]), (trimmed_loop[icnt])); 
         iloop++; 
      } 

      /* Case 4 -- Hah! last point!  draw fillet &amp; draw cap!  */
      if (!is_trimmed[icnt_prev] &amp;&amp; is_trimmed[icnt]) {
         was_trimmed = TRUE;

         /* important note: the array &quot;untrimmed&quot; contains valid
          * untrimmed data ONLY when is_trim is TRUE.  Otherwise, 
          * only &quot;trim&quot; containes valid data */

         /* compute intersection */
         INNERSECT (sect, 
                    bis_origin,
                    bis_vector,
                    trimmed_loop[icnt_prev],
                    untrimmed_loop[icnt]);

         /* Draw Fillet */
         draw_fillet_triangle_plain (trimmed_loop[icnt_prev],
                               trimmed_loop[icnt],
                               sect,
                               face,
                               front_color,
                               back_color);

         VEC_COPY ( (&amp;cap_loop[3*iloop]), sect);
         iloop ++;

         /* draw cap */
         if (iloop &gt;= 3) (*cap_callback) (iloop, 
                                          (gleDouble (*)[3]) cap_loop, 
                                          front_color,
                                          cut_vector,
                                          bis_vector,
                                          NULL,
                                          face);

         /* reset cap counter */
         iloop = 0;
      }
   }

   /* now, finish up in the same way that we started.  If the last
    * point of the contour is visible, drop an edge to the bisecting 
    * plane, thus finishing the join, and then, draw the join! */

   icnt --;  /* decrement to make up for loop exit condititons */
   icnt += ncp;
   icnt %= ncp;
   if ((!is_trimmed[icnt]) &amp;&amp; (iloop &gt;= 2))  {
   
      VEC_SUM (tmp_vec, trimmed_loop[icnt], bis_vector);
      INNERSECT (sect, 
                 bis_origin,
                 bis_vector,
                 trimmed_loop[icnt],
                 tmp_vec);
      VEC_COPY ( (&amp;cap_loop[3*iloop]), sect);
      iloop ++;

      /* if nothing was ever trimmed, then we want to draw the 
       * cap the way the user asked for it -- closed or not closed.
       * Therefore, reset the closure flag to its original state.
       */
      if (!was_trimmed) {
         gleSetJoinStyle (save_style);
      }

      /* draw cap */
      (*cap_callback) (iloop, 
                       (gleDouble (*)[3]) cap_loop, 
                       front_color,
                       cut_vector,
                       bis_vector,
                       NULL,
                       face);
   }

   /* rest to the saved style */
   gleSetJoinStyle (save_style);
   free (cap_loop);
}

/* ============================================================ */

void draw_fillets_and_join_n_norms
                    (int ncp, 
                    gleDouble trimmed_loop[][3],
                    gleDouble untrimmed_loop[][3], 
                    int is_trimmed[],
                    gleDouble bis_origin[3], 
                    gleDouble bis_vector[3], 
                    double normals[][3],
                    float front_color[3],
                    float back_color[3],
                    gleDouble cut_vector[3], 
                    int face,
                    void ((*cap_callback) (int iloop,
                                  double cap[][3],
                                  float face_color[3],
                                  gleDouble cut_vector[3],
                                  gleDouble bisect_vector[3],
                                  double norms[][3],
                                  int frontwards)))
{
   int istop;
   int icnt, icnt_prev = 0, iloop;
   double *cap_loop, *norm_loop;
   gleDouble sect[3];
   gleDouble tmp_vec[3];
   int save_style;
   int was_trimmed = FALSE;

   cap_loop = (double *) malloc ((ncp+3)*3*2*sizeof (double));
   norm_loop = cap_loop + (ncp+3)*3;
   
   /* if the first point on the contour isn't trimmed, go ahead and
    * drop an edge down to the bisecting plane, (thus starting the 
    * join).  (Only need to do this for cut join, its bad if done for
    * round join).
    *
    * But if the first point is trimmed, keep going until one
    * is found that is not trimmed, and start join there.  */

   icnt = 0;
   iloop = 0;
   if (!is_trimmed[0]) {
      if (__TUBE_CUT_JOIN) {
         VEC_SUM (tmp_vec, trimmed_loop[0], bis_vector);
         INNERSECT (sect, 
                    bis_origin,
                    bis_vector,
                    trimmed_loop[0],
                    tmp_vec);
         VEC_COPY ( (&amp;cap_loop[3*iloop]), sect);
         VEC_COPY ( (&amp;norm_loop[3*iloop]), normals[0]);
         iloop ++;
      }
      VEC_COPY ( (&amp;cap_loop[3*iloop]), (trimmed_loop[0])); 
      VEC_COPY ( (&amp;norm_loop[3*iloop]), normals[0]);
      iloop++;
      icnt_prev = icnt;
      icnt ++;
   } else {

      /* else, loop until an untrimmed point is found */
      was_trimmed = TRUE;
      while (is_trimmed[icnt]) {
         icnt_prev = icnt;
         icnt ++;
         if (icnt &gt;= ncp) {
            free (cap_loop);
            return;    /* oops - everything was trimmed */
         }
      }
   }

   /* Start walking around the end cap.  Every time the end loop is
    * trimmed, we know we'll need to draw a fillet triangle.  In
    * addition, after every pair of visibility changes, we draw a cap. */
   if (__TUBE_CLOSE_CONTOUR) {
      istop = ncp;
   } else {
      istop = ncp-1;
   }

   /* save the join style, and disable a closed contour.
    * Need to do this so partial contours don't close up. */
   save_style = gleGetJoinStyle ();
   gleSetJoinStyle (save_style &amp; ~TUBE_CONTOUR_CLOSED);

   for (; icnt_prev &lt; istop; icnt_prev ++, icnt ++, icnt %= ncp) {

      /* There are four interesting cases for drawing caps and fillets:
       *    1) this &amp; previous point were trimmed.  Don't do anything, 
       *       advance counter.
       *    2) this point trimmed, previous not -- draw fillet, and 
       *       draw cap.
       *    3) this point not trimmed, previous one was -- compute
       *       intersection point, draw fillet with it, and save 
       *       point for cap contour.
       *    4) this &amp; previous point not trimmed -- save for endcap.
       */

      /* Case 1 -- noop, just advance pointers */
      if (is_trimmed[icnt_prev] &amp;&amp; is_trimmed[icnt]) {
      }

      /* Case 2 --  Hah! first point! compute intersect &amp; draw fillet! */
      if (is_trimmed[icnt_prev] &amp;&amp; !is_trimmed[icnt]) {

         /* important note: the array &quot;untrimmed&quot; contains valid
          * untrimmed data ONLY when is_trim is TRUE.  Otherwise, 
          * only &quot;trim&quot; containes valid data */

         /* compute intersection */
         INNERSECT (sect, 
                    bis_origin,
                    bis_vector,
                    untrimmed_loop[icnt_prev],
                    trimmed_loop[icnt]);

         /* Draw Fillet */
         draw_fillet_triangle_n_norms (trimmed_loop[icnt_prev],
                               trimmed_loop[icnt],
                               sect,
                               face,
                               front_color,
                               back_color,
                               normals[icnt_prev],
                               normals[icnt]);
         VEC_COPY ( (&amp;cap_loop[3*iloop]), sect);
         VEC_COPY ( (&amp;norm_loop[3*iloop]), normals[icnt_prev]);
         iloop ++;
         VEC_COPY ( (&amp;cap_loop[3*iloop]), (trimmed_loop[icnt])); 
         VEC_COPY ( (&amp;norm_loop[3*iloop]), normals[icnt]);
         iloop++;
      }

      /* Case 3 -- add to collection of points */
      if (!is_trimmed[icnt_prev] &amp;&amp; !is_trimmed[icnt]) {
         VEC_COPY ( (&amp;cap_loop[3*iloop]), (trimmed_loop[icnt])); 
         VEC_COPY ( (&amp;norm_loop[3*iloop]), normals[icnt]);
         iloop++; 
      } 

      /* Case 4 -- Hah! last point!  draw fillet &amp; draw cap!  */
      if (!is_trimmed[icnt_prev] &amp;&amp; is_trimmed[icnt]) {
         was_trimmed = TRUE;

         /* important note: the array &quot;untrimmed&quot; contains valid
          * untrimmed data ONLY when is_trim is TRUE.  Otherwise, 
          * only &quot;trim&quot; containes valid data */

         /* compute intersection */
         INNERSECT (sect, 
                    bis_origin,
                    bis_vector,
                    trimmed_loop[icnt_prev],
                    untrimmed_loop[icnt]);

         /* Draw Fillet */
         draw_fillet_triangle_n_norms (trimmed_loop[icnt_prev],
                               trimmed_loop[icnt],
                               sect,
                               face,
                               front_color,
                               back_color,
                               normals[icnt_prev],
                               normals[icnt]);

         VEC_COPY ( (&amp;cap_loop[3*iloop]), sect);

         /* OK, maybe phong normals are wrong, but at least facet
          * normals will come out OK. */
         if (__TUBE_DRAW_FACET_NORMALS) {
            VEC_COPY ( (&amp;norm_loop[3*iloop]), normals[icnt_prev]);
         } else {
            VEC_COPY ( (&amp;norm_loop[3*iloop]), normals[icnt]);
         }
         iloop ++;

         /* draw cap */
         if (iloop &gt;= 3) (*cap_callback) (iloop, 
                                          (gleDouble (*)[3]) cap_loop, 
                                          front_color,
                                          cut_vector,
                                          bis_vector,
                                          (gleDouble (*)[3]) norm_loop,
                                          face);

         /* reset cap counter */
         iloop = 0;
      }
   }

   /* now, finish up in the same way that we started.  If the last
    * point of the contour is visible, drop an edge to the bisecting 
    * plane, thus finishing the join, and then, draw the join! */

   icnt --;  /* decrement to make up for loop exit condititons */
   icnt += ncp;
   icnt %= ncp;
   if ((!is_trimmed[icnt]) &amp;&amp; (iloop &gt;= 2))  {
   
      if (__TUBE_CUT_JOIN) {
         VEC_SUM (tmp_vec, trimmed_loop[icnt], bis_vector);
         INNERSECT (sect, 
                    bis_origin,
                    bis_vector,
                    trimmed_loop[icnt],
                    tmp_vec);
         VEC_COPY ( (&amp;cap_loop[3*iloop]), sect);
         VEC_COPY ( (&amp;norm_loop[3*iloop]), normals[icnt]);
         iloop ++;
      }

      /* if nothing was ever trimmed, then we want to draw the 
       * cap the way the user asked for it -- closed or not closed.
       * Therefore, reset the closure flag to its original state.
       */
      if (!was_trimmed) {
         gleSetJoinStyle (save_style);
      }

      /* draw cap */
      (*cap_callback) (iloop, 
                       (gleDouble (*)[3]) cap_loop, 
                       front_color,
                       cut_vector,
                       bis_vector,
                       (gleDouble (*)[3]) norm_loop,
                       face);
   }

   /* rest to the saved style */
   gleSetJoinStyle (save_style);
   free (cap_loop);
}

/* ============================================================ */
/* This routine draws &quot;cut&quot; style extrusions.  
 */

void extrusion_round_or_cut_join (int ncp,    /* number of contour points */
                           gleDouble contour[][2],    /* 2D contour */
                           gleDouble cont_normal[][2],/* 2D normal vecs */
                           gleDouble up[3],    /* up vector for contour */
                           int npoints,        /* numpoints in poly-line */
                           gleDouble point_array[][3],    /* polyline */
                           float color_array[][3],    /* color of polyline */
                           gleDouble xform_array[][2][3])   /* 2D contour xforms */
{
   int i, j;
   int inext, inextnext;
   gleDouble m[4][4];
   gleDouble tube_len, seg_len;
   gleDouble diff[3];
   gleDouble bi_0[3], bi_1[3];        /* bisecting plane */
   gleDouble bisector_0[3], bisector_1[3];        /* bisecting plane */
   gleDouble cut_0[3], cut_1[3];    /* cutting planes */
   gleDouble lcut_0[3], lcut_1[3];    /* cutting planes */
   int valid_cut_0, valid_cut_1;    /* flag -- cut vector is valid */
   gleDouble end_point_0[3], end_point_1[3]; 
   gleDouble torsion_point_0[3], torsion_point_1[3]; 
   gleDouble isect_point[3] = {0.0, 0.0, 0.0};
   gleDouble origin[3], neg_z[3];
   gleDouble yup[3];        /* alternate up vector */
   gleDouble *front_cap, *back_cap;    /* arrays containing the end caps */
   gleDouble *front_loop, *back_loop; /* arrays containing the tube ends */
   double *front_norm, *back_norm; /* arrays containing normal vecs */
   double *norm_loop = NULL, *tmp; /* normal vectors, cast into 3d from 2d */
   int *front_is_trimmed, *back_is_trimmed;   /* T or F */
   float *front_color, *back_color;  /* pointers to segment colors */
   void ((*cap_callback) ());  /* function callback to draw cap */
   void ((*tmp_cap_callback) ()) = NULL;  /* function callback to draw cap */
   int join_style_is_cut;      /* TRUE if join style is cut */
   double dot;                  /* partial dot product */
   char *mem_anchor;
   int first_time = TRUE;
   gleDouble *cut_vec;

   /* create a local, block scope copy of of the join style.
    * this will alleviate wasted cycles and register write-backs */
   /* choose the right callback, depending on the choosen join style */
   if (__TUBE_CUT_JOIN) {
      join_style_is_cut = TRUE;
      cap_callback =  draw_cut_style_cap_callback;
   } else {
      join_style_is_cut = FALSE;
      cap_callback =  draw_round_style_cap_callback;
   }

   /* By definition, the contour passed in has its up vector pointing in
    * the y direction */
   if (up == NULL) {
      yup[0] = 0.0;
      yup[1] = 1.0;
      yup[2] = 0.0;
   } else {
      VEC_COPY (yup, up);
   }

   /* ========== &quot;up&quot; vector sanity check ========== */
   (void) up_sanity_check (yup, npoints, point_array);

   /* the origin is at the origin */
   origin [0] = 0.0;
   origin [1] = 0.0;
   origin [2] = 0.0;

   /* and neg_z is at neg z */
   neg_z[0] = 0.0;
   neg_z[1] = 0.0;
   neg_z[2] = 1.0;

   /* malloc the data areas that we'll need to store the end-caps */
   mem_anchor = malloc (4 * 3*ncp*sizeof(gleDouble)
                      + 2 * 3*ncp*sizeof(double)
                      + 2 * 1*ncp*sizeof(int));
   front_norm = (double *) mem_anchor;
   back_norm = front_norm + 3*ncp;
   front_loop = (gleDouble *) (back_norm + 3*ncp);
   back_loop = front_loop + 3*ncp;
   front_cap = back_loop + 3*ncp;
   back_cap  = front_cap + 3*ncp;
   front_is_trimmed = (int *) (back_cap + 3*ncp);
   back_is_trimmed = front_is_trimmed + ncp;

   /* ======================================= */

   /* |-|-|-|-|-|-|-|-| SET UP FOR FIRST SEGMENT |-|-|-|-|-|-|-| */

   /* ignore all segments of zero length */
   i = 1;
   inext = i;
   FIND_NON_DEGENERATE_POINT (inext, npoints, seg_len, diff, point_array);
   tube_len = seg_len;    /* store for later use */

   /* may as well get the normals set up now */
   if (cont_normal != NULL) {
      if (xform_array == NULL) {
         norm_loop = front_norm;
         back_norm = norm_loop;
         for (j=0; j&lt;ncp; j++) {
            norm_loop[3*j] = cont_normal[j][0];
            norm_loop[3*j+1] = cont_normal[j][1];
            norm_loop[3*j+2] = 0.0;
         }
      } else {
         for (j=0; j&lt;ncp; j++) {
            NORM_XFORM_2X2 ( (&amp;front_norm[3*j]),
                              xform_array[inext-1],
                              cont_normal [j]);
            front_norm[3*j+2] = 0.0;
            back_norm[3*j+2] = 0.0;
         }
      }
   } else {
      front_norm = back_norm = norm_loop = NULL;
   }

   /* get the bisecting plane */
   bisecting_plane (bi_0, point_array[i-1], 
                          point_array[i], 
                          point_array[inext]);

   /* compute cutting plane */
   CUTTING_PLANE (valid_cut_0, cut_0, point_array[i-1], 
                         point_array[i], 
                         point_array[inext]);
   
   /* reflect the up vector in the bisecting plane */
   VEC_REFLECT (yup, yup, bi_0);

   /* |-|-|-|-|-|-|-|-| START LOOP OVER SEGMENTS |-|-|-|-|-|-|-| */

   /* draw tubing, not doing the first segment */
   while (inext&lt;npoints-1) {

      inextnext = inext;
      /* ignore all segments of zero length */
      FIND_NON_DEGENERATE_POINT (inextnext, npoints, 
                                 seg_len, diff, point_array);

      /* get the far bisecting plane */
      bisecting_plane (bi_1, point_array[i], 
                             point_array[inext], 
                             point_array[inextnext]);


      /* compute cutting plane */
      CUTTING_PLANE (valid_cut_1, cut_1, point_array[i], 
                            point_array[inext], 
                            point_array[inextnext]);  

      /* rotate so that z-axis points down v2-v1 axis, 
       * and so that origen is at v1 */
      uviewpoint (m, point_array[i], point_array[inext], yup);
      PUSHMATRIX ();
      MULTMATRIX (m);

      /* rotate the cutting planes into the local coordinate system */
      MAT_DOT_VEC_3X3 (lcut_0, m, cut_0);
      MAT_DOT_VEC_3X3 (lcut_1, m, cut_1);

      /* rotate the bisecting planes into the local coordinate system */
      MAT_DOT_VEC_3X3 (bisector_0, m, bi_0);
      MAT_DOT_VEC_3X3 (bisector_1, m, bi_1);


      neg_z[2] = -tube_len;

      /* draw the tube */
      /* --------- START OF TMESH GENERATION -------------- */
      for (j=0; j&lt;ncp; j++) {

         /* set up the endpoints for segment clipping */
         if (xform_array == NULL) {
            VEC_COPY_2 (end_point_0, contour[j]);
            VEC_COPY_2 (end_point_1, contour[j]);
            VEC_COPY_2 (torsion_point_0, contour[j]);
            VEC_COPY_2 (torsion_point_1, contour[j]);
         } else {
            /* transform the contour points with the local xform */
            MAT_DOT_VEC_2X3 (end_point_0,
                             xform_array[inext-1], contour[j]);
            MAT_DOT_VEC_2X3 (torsion_point_0,
                             xform_array[inext], contour[j]);
            MAT_DOT_VEC_2X3 (end_point_1,
                             xform_array[inext], contour[j]);
            MAT_DOT_VEC_2X3 (torsion_point_1,
                             xform_array[inext-1], contour[j]);

            /* if there are normals and there are affine xforms,
             * then compute local coordinate system normals.
             * Set up the back normals. (The front normals we inherit
             * from previous pass through the loop).  */
            if (cont_normal != NULL) {
               /* do up the normal vectors with the inverse transpose */
               NORM_XFORM_2X2 ( (&amp;back_norm[3*j]),
                                xform_array[inext],
                                cont_normal [j]);
            }
         }
         end_point_0 [2] = 0.0;
         torsion_point_0 [2] = 0.0;
         end_point_1 [2] = - tube_len;
         torsion_point_1 [2] = - tube_len;

         /* The two end-points define a line.  Intersect this line
          * against the clipping plane defined by the PREVIOUS
          * tube segment.  */

         /* if this and the last tube are co-linear, don't cut the angle
          * if you do, a divide by zero will result.  This and last tube
          * are co-linear when the cut vector is of zero length */
         if (valid_cut_0 &amp;&amp; join_style_is_cut) {
             INNERSECT (isect_point,  /* isect point (returned) */
                       origin,        /* point on intersecting plane */
                       lcut_0,        /* normal vector to plane */
                       end_point_0,    /* point on line */
                       end_point_1);    /* another point on the line */    

            /* determine whether the raw end of the extrusion would have
             * been cut, by checking to see if the raw and is on the 
             * far end of the half-plane defined by the cut vector.
             * If the raw end is not &quot;cut&quot;, then it is &quot;trimmed&quot;.
             */
            if (lcut_0[2] &lt; 0.0) { VEC_SCALE (lcut_0, -1.0, lcut_0); }
            dot = lcut_0[0] * end_point_0[0];
            dot += lcut_0[1] * end_point_0[1];

            VEC_COPY ((&amp;front_loop[3*j]), isect_point);
         } else {
            /* actual value of dot not interseting; need 
             * only be positive so that if test below failes */
            dot = 1.0;   
            VEC_COPY ((&amp;front_loop[3*j]), end_point_0);
         }

         INNERSECT (isect_point,     /* intersection point (returned) */
                    origin,        /* point on intersecting plane */
                    bisector_0,        /* normal vector to plane */
                    end_point_0,    /* point on line */
                    torsion_point_1);    /* another point on the line */    

         /* trim out interior of intersecting tube */
         /* ... but save the untrimmed version for drawing the endcaps */
         /* ... note that cap contains valid data ONLY when is_trimmed
          * is TRUE. */
         if ((dot &lt;= 0.0) || (isect_point[2] &lt; front_loop[3*j+2])) {
/*
         if ((dot &lt;= 0.0) || (front_loop[3*j+2] &gt; 0.0)) {
*/
            VEC_COPY ((&amp;front_cap[3*j]), (&amp;front_loop [3*j]));
            VEC_COPY ((&amp;front_loop[3*j]), isect_point);
            front_is_trimmed[j] = TRUE;
         } else {
            front_is_trimmed[j] = FALSE;
         }

         /* if intersection is behind the end of the segment, 
          * truncate to the end of the segment
          * Note that coding front_loop [3*j+2] = -tube_len;
          * doesn't work when twists are involved, */
         if (front_loop[3*j+2] &lt; -tube_len) {
            VEC_COPY( (&amp;front_loop[3*j]), end_point_1);
         } 

         /* --------------------------------------------------- */
         /* The two end-points define a line.  We did one endpoint 
          * above. Now do the other.Intersect this line
          * against the clipping plane defined by the NEXT
          * tube segment.  */

         /* if this and the last tube are co-linear, don't cut the angle
          * if you do, a divide by zero will result.  This and last tube
          * are co-linear when the cut vector is of zero length */
         if (valid_cut_1 &amp;&amp; join_style_is_cut) {
            INNERSECT (isect_point,  /* isect point (returned) */
                       neg_z,        /* point on intersecting plane */
                       lcut_1,        /* normal vector to plane */
                       end_point_1,    /* point on line */
                       end_point_0);    /* another point on the line */    

            if (lcut_1[2] &gt; 0.0) { VEC_SCALE (lcut_1, -1.0, lcut_1); }
            dot = lcut_1[0] * end_point_1[0];
            dot += lcut_1[1] * end_point_1[1];

   
            VEC_COPY ((&amp;back_loop[3*j]), isect_point);
         } else {
            /* actual value of dot not interseting; need 
             * only be positive so that if test below failes */
            dot = 1.0;   
            VEC_COPY ((&amp;back_loop[3*j]), end_point_1);
         }

         INNERSECT (isect_point,     /* intersection point (returned) */
                    neg_z,        /* point on intersecting plane */
                    bisector_1,        /* normal vector to plane */
                    torsion_point_0,    /* point on line */
                    end_point_1);    /* another point on the line */    

         /* cut out interior of intersecting tube */
         /* ... but save the uncut version for drawing the endcaps */
         /* ... note that cap contains valid data ONLY when is
          *_trimmed is TRUE. */
/*
        if ((dot &lt;= 0.0) || (back_loop[3*j+2] &lt; -tube_len)) {
*/
        if ((dot &lt;= 0.0) || (isect_point[2] &gt; back_loop[3*j+2])) {
            VEC_COPY ((&amp;back_cap[3*j]), (&amp;back_loop [3*j]));
            VEC_COPY ((&amp;back_loop[3*j]), isect_point);
            back_is_trimmed[j] = TRUE;
         } else {
            back_is_trimmed[j] = FALSE;
         }

         /* if intersection is behind the end of the segment, 
          * truncate to the end of the segment 
          * Note that coding back_loop [3*j+2] = 0.0;
          * doesn't work when twists are involved, */
         if (back_loop[3*j+2] &gt; 0.0) {
            VEC_COPY( (&amp;back_loop[3*j]), end_point_0);
         } 
      }

      /* --------- END OF TMESH GENERATION -------------- */

      /* |||||||||||||||||| START SEGMENT DRAW |||||||||||||||||||| */
      /* There are six different cases we can have for presence and/or
       * absecnce of colors and normals, and for interpretation of
       * normals. The blechy set of nested if statements below
       * branch to each of the six cases */
      if (xform_array == NULL) {
         if (color_array == NULL) {
            if (cont_normal == NULL) {
               draw_segment_plain (ncp, (gleVector *) front_loop, (gleVector *) back_loop, inext, seg_len);
            } else
            if (__TUBE_DRAW_FACET_NORMALS) {
               draw_segment_facet_n (ncp, (gleVector *) front_loop, (gleVector *) back_loop, (gleVector *) norm_loop, 
                                     inext, seg_len);
            } else {
               draw_segment_edge_n (ncp, (gleVector *) front_loop, (gleVector *) back_loop, (gleVector *) norm_loop,
                                    inext, seg_len);
            }
         } else {
            if (cont_normal == NULL) {
               draw_segment_color (ncp, (gleVector *) front_loop, (gleVector *) back_loop, 
                                   color_array[inext-1],
                                   color_array[inext], inext, seg_len);
            } else
            if (__TUBE_DRAW_FACET_NORMALS) {
               draw_segment_c_and_facet_n (ncp, 
                                   (gleVector *) front_loop, (gleVector *) back_loop, (gleVector *) norm_loop,
                                   color_array[inext-1],
                                   color_array[inext], inext, seg_len);
            } else {
               draw_segment_c_and_edge_n (ncp, 
                                   (gleVector *) front_loop, (gleVector *) back_loop, (gleVector *) norm_loop,
                                   color_array[inext-1],
                                   color_array[inext], inext, seg_len);
             }
          }
      } else {
         if (color_array == NULL) {
            if (cont_normal == NULL) {
               draw_segment_plain (ncp, (gleVector *) front_loop, (gleVector *) back_loop, inext, seg_len);
            } else 
            if (__TUBE_DRAW_FACET_NORMALS) {
               draw_binorm_segment_facet_n (ncp, (gleVector *) front_loop, (gleVector *) back_loop,
                                                 (gleVector *) front_norm, (gleVector *) back_norm, 
                                                 inext, seg_len);
            } else {
               draw_binorm_segment_edge_n (ncp, (gleVector *) front_loop, (gleVector *) back_loop,
                                                (gleVector *) front_norm, (gleVector *) back_norm,
                                                inext, seg_len);
            }
         } else {
            if (cont_normal == NULL) {
               draw_segment_color (ncp, (gleVector *) front_loop, (gleVector *) back_loop, 
                                   color_array[inext-1],
                                   color_array[inext], inext, seg_len);
            } else
            if (__TUBE_DRAW_FACET_NORMALS) {
               draw_binorm_segment_c_and_facet_n (ncp, 
                                   (gleVector *) front_loop, (gleVector *) back_loop, 
                                   (gleVector *) front_norm, (gleVector *) back_norm, 
                                   color_array[inext-1],
                                   color_array[inext], inext, seg_len);
            } else {
               draw_binorm_segment_c_and_edge_n (ncp, 
                                   (gleVector *) front_loop, (gleVector *) back_loop,
                                   (gleVector *) front_norm, (gleVector *) back_norm, 
                                   color_array[inext-1],
                                   color_array[inext], inext, seg_len);
             }
          }
      }
      /* |||||||||||||||||| END SEGMENT DRAW |||||||||||||||||||| */

      /* v^v^v^v^v^v^v^v^v  BEGIN END CAPS v^v^v^v^v^v^v^v^v^v^v^v */

      /* if end caps are required, draw them. But don't draw any
       * but the very first and last caps */
      if (first_time) {
         first_time = FALSE;
         tmp_cap_callback = cap_callback;
         cap_callback = null_cap_callback;
         if (__TUBE_DRAW_CAP) {
            if (color_array != NULL) C3F (color_array[inext-1]);
            draw_angle_style_front_cap (ncp, bisector_0, (gleDouble (*)[3]) front_loop);
         }
      }
      /* v^v^v^v^v^v^v^v^v  END END CAPS v^v^v^v^v^v^v^v^v^v^v^v */

      /* $$$$$$$$$$$$$$$$ BEGIN -1, FILLET &amp; JOIN DRAW $$$$$$$$$$$$$$$$$ */
      /* 
       * Now, draw the fillet triangles, and the join-caps.
       */
      if (color_array != NULL) {
         front_color = color_array[inext-1];
         back_color = color_array[inext];
      } else {
         front_color = NULL;
         back_color = NULL;
      }

      if (cont_normal == NULL) {
         /* the flag valid-cut is true if the cut vector has a valid 
          * value (i.e. if a degenerate case has not occured). 
          */
         if (valid_cut_0) {
            cut_vec = lcut_0;
         } else {
            cut_vec = NULL;
         }
         draw_fillets_and_join_plain (ncp, 
                                  (gleVector *) front_loop,
                                  (gleVector *) front_cap, 
                                  front_is_trimmed,
                                  origin,
                                  bisector_0, 
                                  front_color,
                                  back_color,
                                  cut_vec,
                                  TRUE,
                                  cap_callback);

         /* v^v^v^v^v^v^v^v^v  BEGIN END CAPS v^v^v^v^v^v^v^v^v^v^v^v */
         if (inext == npoints-2) {
            if (__TUBE_DRAW_CAP) {
               if (color_array != NULL) C3F (color_array[inext]);
               draw_angle_style_back_cap (ncp, bisector_1, (gleDouble (*)[3]) back_loop);
               cap_callback = null_cap_callback;
            }
         } else {
            /* restore ability to draw cap */
            cap_callback = tmp_cap_callback;
         }
         /* v^v^v^v^v^v^v^v^v  END END CAPS v^v^v^v^v^v^v^v^v^v^v^v */
   
         /* the flag valid-cut is true if the cut vector has a valid 
          * value (i.e. if a degenerate case has not occured). 
          */
         if (valid_cut_1) {
            cut_vec = lcut_1;
         } else {
            cut_vec = NULL;
         }
         draw_fillets_and_join_plain (ncp, 
                                  (gleVector *) back_loop,
                                  (gleVector *) back_cap, 
                                  back_is_trimmed,
                                  neg_z,
                                  bisector_1, 
                                  back_color,
                                  front_color,
                                  cut_vec,
                                  FALSE,
                                  cap_callback);
      } else {
   
         /* the flag valid-cut is true if the cut vector has a valid 
          * value (i.e. if a degenerate case has not occured). 
          */
         if (valid_cut_0) {
            cut_vec = lcut_0;
         } else {
            cut_vec = NULL;
         }
         draw_fillets_and_join_n_norms (ncp, 
                                  (gleVector *) front_loop,
                                  (gleVector *) front_cap, 
                                  front_is_trimmed,
                                  origin,
                                  bisector_0, 
                                  (gleVector *) front_norm,
                                  front_color,
                                  back_color,
                                  cut_vec,
                                  TRUE,
                                  cap_callback);
   
         /* v^v^v^v^v^v^v^v^v  BEGIN END CAPS v^v^v^v^v^v^v^v^v^v^v^v */
         if (inext == npoints-2) {
            if (__TUBE_DRAW_CAP) {
               if (color_array != NULL) C3F (color_array[inext]);
               draw_angle_style_back_cap (ncp, bisector_1, (gleDouble (*)[3]) back_loop);
               cap_callback = null_cap_callback;
            }
         } else {
            /* restore ability to draw cap */
            cap_callback = tmp_cap_callback;
         }
         /* v^v^v^v^v^v^v^v^v  END END CAPS v^v^v^v^v^v^v^v^v^v^v^v */

         /* the flag valid-cut is true if the cut vector has a valid 
          * value (i.e. if a degenerate case has not occured). 
          */
         if (valid_cut_1) {
            cut_vec = lcut_1;
         } else {
            cut_vec = NULL;
         }
         draw_fillets_and_join_n_norms (ncp, 
                                  (gleVector *) back_loop,
                                  (gleVector *) back_cap, 
                                  back_is_trimmed,
                                  neg_z,
                                  bisector_1, 
                                  (gleVector *) back_norm,
                                  back_color,
                                  front_color,
                                  cut_vec,
                                  FALSE,
                                  cap_callback);
      }

      /* $$$$$$$$$$$$$$$$ END FILLET &amp; JOIN DRAW $$$$$$$$$$$$$$$$$ */

      /* pop this matrix, do the next set */
      POPMATRIX ();

      /* slosh stuff over to next vertex */
      tmp = front_norm;
      front_norm = back_norm;
      back_norm = tmp;

      tube_len = seg_len;
      i = inext;
      inext = inextnext;
      VEC_COPY (bi_0, bi_1);
      VEC_COPY (cut_0, cut_1);
      valid_cut_0 = valid_cut_1;

      /* reflect the up vector in the bisecting plane */
      VEC_REFLECT (yup, yup, bi_0);
   }
   /* |-|-|-|-|-|-|-|-| END LOOP OVER SEGMENTS |-|-|-|-|-|-|-| */

   free (mem_anchor);

}
   
/* =================== END OF FILE =============================== */
</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/glut/listing3.html%3Fid%3DDTS10000528-2.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/glut/listing3.html%3Fid%3DDTS10000528-2.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/glut/listing3.html%3Fid%3DDTS10000528-2.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>