<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Overview</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING28></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="RTArch-27.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="RTArch-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="RTArch-147.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="RTArch-29.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="RTArch-2.html"><B>Mac OS Runtime Architectures</B></A> / <BR><DD><A HREF="RTArch-27.html"><B>Chapter 2 - Indirect Addressing in the CFM-Based Architecture</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING28-0></A>
<H1>Overview</H1>
 <A NAME=MARKER-2-48></A>Two methods exist for addressing data: direct addressing and indirect addressing. The choice of addressing method for any particular data item is determined by the compiler. Direct addressing is accomplished by using a base registe<B>r</B> to access an area of memory called the<A NAME=MARKER-2-21></A> direct data area. Direct data items can be referenced as an offset from the address stored in the base register. <A HREF=#MARKER-9-22>Figure 2-1</A> shows an example of direct addressing.<P>
<DL>
<DT><B>Note</B>
<DD>The term direct addressing as used in this chapter actually assumes one level of indirection (using the base register) and is therefore not the same as absolute addressing in assembly-language terminology. Similarly, indirect addressing actually possesses two traditional levels of indirection.<EM></EM><EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<B>Figure 2-1  <A NAME=MARKER-9-22></A>Direct addressing of data</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/RUN-95.jpg"> <P>
 Direct addressing is simple and efficient, but since the offset bits in a given instruction can address only a certain amount of memory (typically \xB132 KB), space limitations can occur if you have large data items or many data items.<P>
 If you are writing a compiler, you should store as many items as possible in the direct data area because this reduces access time. Small data items (that is, equal to or smaller than pointers) should always be placed in the direct data area. <P>
 <A NAME=MARKER-2-23></A>The alternative is indirect addressing, where the item in the direct data area is not the data itself, but a pointer to that data. Since you are no longer restricted by addressing limitations, you can access large data structures. <A HREF=#MARKER-9-24>Figure 2-2</A> shows an example of indirect addressing.<P>
<B>Figure 2-2  <A NAME=MARKER-9-24></A>Indirect addressing of data</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/RUN-96.jpg"> <P>
 The additional advantage of accessing symbols indirectly through pointers is that the symbols being referenced do not need to be present at build time. The components that make up a functional program can be stored separately if you can fix up the pointers to point to the correct symbols at runtime. In the CFM-based architecture, indirect addressing makes the use of imported and exported symbols possible. <P>
 Before preparation by the Code Fragment Manager, a fragment contains only a reference for each imported symbol. During the fragment preparation process, the Code Fragment Manager resolves all these references by searching for the code and data they refer to and replacing the references with relevant addresses.<P>
 Indirect addressing also provides the following benefits:<P>
<UL>
<LI>Symbols external to a fragment can be specified by name, not by address. This allows the symbols to be grouped into import libraries.
<LI>Data can be specified by name, not by address.
<LI>Callback routines can be specified by name, not by address.
<LI>Using the base register allows multiple connections with independent data sections in the same address space. For example, in System 7, all applications share the same address space, so allowing a fragment to have multiple connections in that space makes it possible to have shared libraries. 
<LI>An import library can have multiple connections associated with it, each linked to a different application. <A NAME=MARKER-2-25></A><P>
</UL>
 <A NAME=MARKER-2-26></A>Indirect addressing of data items is simple. Knowing the address stored in the base register and the offset into the direct data area, you can access the pointer to the data and consequently the data itself. For example, to find the proper address of an imported data item, a fragment adds the offset of the pointer to the import within the direct data area (determined at compile time) to the value stored in the base register. The result is the address of a pointer to the data item. <P>
<DL>
<DT><B>Note</B>
<DD>The same indirect method is used to access global variables; the pointer merely points to the current fragment rather than a different one.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 <A NAME=MARKER-2-27></A>Indirect addressing of routines is a little more complicated, but it is essentially similar. Indirect calls to routines must pass through the routine's transition vector. A <A NAME=MARKER-2-28></A>transition vector is a data structure in the called fragment's data section whose first element is the address of the routine to be called. Any pointer to a routine (such as those used by C++ virtual method calls) actually points to the routine's transition vector, whether or not the routine is in the same fragment. <P>
 Indirect calls branch to the routine address (the first element of the transition vector) and store the address of the transition vector in a specific register (the details vary depending on the platform). This allows the called routine to access other elements in the transition vector (if any). The generated code usually also varies slightly for named calls (such as calls to imported routines) versus pointer-based calls (C function pointers or C++ virtual functions, for example).<P>
 The basic structure of a transition vector is shown in <A HREF=#MARKER-9-29>Figure 2-3</A>.<P>
<B>Figure 2-3  <A NAME=MARKER-9-29></A>A transition vector</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/RUN-68.jpg"> <P>
 A routine's transition vector is accessed through the base register, just like any other piece of data. As with other data, it is generally more efficient to place the transition vector in the direct data area. Control can then pass from the transition vector to the called routine. <P>
 The transition vector can contain any number of elements in addition to the routine address. These other elements may be used by the called routine in any way useful. For example, the PowerPC and CFM-68K implementations typically store a pointer to the called fragment's direct data area in a routine's transition vector; this method of storing the pointer allows the called routine to access its own da<A NAME=MARKER-2-30></A>ta. <A NAME=MARKER-2-31></A><P>
<HR>
<center>
<A HREF="RTArch-27.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="RTArch-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="RTArch-147.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="RTArch-29.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="RTArch-3.html">&copy; Apple Computer, Inc.</A><br>11 MARCH 1997<P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML> 
