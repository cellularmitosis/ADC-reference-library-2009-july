<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>OOPTESample - /ProgStrucMacs.d</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">OOPTESample</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/index.html" target="_blank">Reference Library</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">OOPTESample</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/ProgStrucMacs.d</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/FlowCtlMacs.d</option>
<option value="listing2.html">/MTESample.p</option>
<option value="listing3.html">/ProgStrucMacs.d</option>
<option value="listing4.html">/TECommon.h</option>
<option value="listing5.html">/TESample.r</option>
<option value="listing6.html">/TESampleGlue.a</option>
<option value="listing7.html">/UApplication.inc1.p</option>
<option value="listing8.html">/UApplication.p</option>
<option value="listing9.html">/UDocument.inc1.p</option>
<option value="listing10.html">/UDocument.p</option>
<option value="listing11.html">/UTEDocument.inc1.p</option>
<option value="listing12.html">/UTEDocument.p</option>
<option value="listing13.html">/UTESample.inc1.p</option>
<option value="listing14.html">/UTESample.p</option></select>
				</p>
				</form>
				<p><strong><a href="OOPTESample.zip">Download Sample</a></strong> (&#147;OOPTESample.zip&#148;, 62.2K)<BR>
<strong><a href="OOPTESample.dmg">Download Sample</a></strong> (&#147;OOPTESample.dmg&#148;, 121.6K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">  &yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml;&yuml; RETURN           Return  &amp;Result     PRINT  Push,NoMDir,NoMCall3    GBLC    &amp;SaveRegs#    ; Regs saved and to be restored2    GBLC    &amp;DbgName#      ; name to generate for MacsBug&amp;    GBLC    &amp;FSz#      ; function result size&amp;    GBLA    &amp;Link#      ; 1 ==&gt; generate LINK=    GBLA    &amp;ArgSize#      ; nbr of bytes of stack space for formals!    GBLA    &amp;C#        ; 1 ==&gt; C function     LCLC    &amp;S,&amp;Rslt[2]
    LCLA    &amp;i    IF &amp;SaveRegs# &shy; '' THEN4     IF &amp;Substr(&amp;Type(&amp;SaveRegs#), 1, 3) = 'REG' THEN$          MOVE.L    (A7)+,&amp;SaveRegs#      ELSE$          MOVEM.L   (A7)+,&amp;SaveRegs#     ENDIF   ENDIF    IF &amp;Link# THEN           UNLK      A6   ENDIF*   IF &amp;C# THEN          ; Just RTS if C function           RTSH   ELSEIF (&amp;Result = '') AND (&amp;ArgSize# = 4) THEN ;special Pascal case...     MOVE.L  (A7)+,(A7)     RTS    ELSE              ; If Pascal...9     IF &amp;ArgSize# &gt; 8 THEN      ; Pop stack if there are args           MOVEA.L   (A7)+,A0$          LEA       &amp;ArgSize#(A7),A7      ELSEIF &amp;ArgSize# THEN           MOVEA.L   (A7)+,A0!          ADD.W     #&amp;ArgSize#,A7      ELSEIF &amp;Result &shy; '' THEN           MOVEA.L   (A7)+,A0     ENDIF?     IF &amp;Result &shy; '' THEN      ; Returning a result to a function ?=       IF &amp;FSz# = '' THEN      ; Yes, we better be in a function!B        AERROR 'Attempt to return a function result in a procedure'!       ELSE            ; So far, so good9     &amp;i: SETA &amp;List(&amp;Result, '&amp;Rslt', ':')    ; Split &amp;ResultL     &amp;S: SETC &amp;Default(&amp;UC(&amp;Trim(&amp;Rslt[2])), &amp;FSz#)  ; Use size override if any?      IF &amp;Pos(&amp;S, 'BWL') THEN    ; B | W | L ==&gt; assume normal MOVE(          MOVE.&amp;S   &amp;Trim(&amp;Rslt[1]),(A7)/      ELSE          ; S | D | X | P ==&gt; floating point)          FMOVE.&amp;S   &amp;Trim(&amp;Rslt[1]),(A7)      ENDIF
      ENDIF     ENDIF'     IF &amp;ArgSize# OR (&amp;Result &shy; '') THEN           JMP       (A0)      ELSE          RTS     ENDIF   ENDIFA   IF &amp;DbgName# &shy; '' THEN      ; &amp;DbgName# indicates we have a symbol8    &amp;S: SETC &amp;Setting('STRING')    ; Preserve STRING status&gt;     IF &amp;S &shy; 'ASIS' THEN      ; Only change it if not already ASIS           STRING    ASIS           DC.B      '&amp;DbgName#'           STRING    &amp;S      ELSE           DC.B      '&amp;DbgName#'     ENDIF!    DC.W    0        ; Fake literal size   ENDIF     PRINT  Pop&yuml; ENTER       &amp;Lbl    Enter  &amp;Prelude,&amp;With==     PRINT  Push,NoMDir,NoMCall3    GBLC    &amp;SaveRegs#    ; Regs saved and to be restored&amp;    GBLA    &amp;Link#      ; 1 ==&gt; generate LINK           BRA.S     %L%&amp;SysNdx &amp;Lbl ;    IF &amp;With &shy; '' THEN      IF &amp;With[1:1] = '(' THEN*          WITH      &amp;With[2:&amp;Len(&amp;With)-2]      ELSE           WITH      &amp;With     ENDIF   ENDIF    IF &amp;Link# THEN      IF &amp;Prelude = '' THEN!          LINK      A6,#LocalSize     ENDIF   ENDIF    IF &amp;SaveRegs# &shy; '' THEN4     IF &amp;Substr(&amp;Type(&amp;SaveRegs#), 1, 3) = 'REG' THEN$          MOVE.L    &amp;SaveRegs#,-(A7)      ELSE$          MOVEM.L   &amp;SaveRegs#,-(A7)     ENDIF   ENDIF
%L%&amp;SysNdx     PRINT  Pop&yuml; DCL1VAR#           Dcl1Var#  &amp;Opnd,&amp;Align:A=0     LCLC    &amp;Var,&amp;Size,&amp;UCSize,&amp;A[2]     LCLA    &amp;VarLen,&amp;i,&amp;j,&amp;Dim&lt;  &amp;Var:    SETC &amp;Trim(&amp;Opnd)    ; Assume there is anly an &lt;id&gt; =  &amp;VarLen: SETA &amp;Len(&amp;Opnd)    ; To be sure we look at last char                                                     D   IF &amp;Var[&amp;VarLen] &shy; ']' THEN    ; Have &quot;]&quot; indicating we have &lt;dim&gt; ?1    &amp;Dim: SETA 1          ; No, the &lt;dim&gt; defaults to 1$   ELSE              ; If we have a &lt;dim&gt;...H    &amp;i: SETA -&amp;ScanEQ('[', &amp;Var, -&amp;VarLen) ; Find &quot;[&quot; preceding the &lt;dim&gt;:     IF &amp;i = &amp;VarLen THEN      ; Did we find it ? (we better!)       AERROR '&quot;[&quot; missing.'    '      &amp;Dim: SETA 1        ; No, default to 1J      &amp;Var: SETA &amp;Var[1:&amp;VarLen-1]  ; Remove the invalid &lt;dim&gt; from the &lt;id&gt;      ELSE6      &amp;j:   SETA &amp;VarLen-&amp;i    ; If we have a valid &lt;dim&gt;0      &amp;Dim: SETA &amp;Eval(&amp;Var[&amp;j+1:&amp;i]); Extract it=      &amp;Var: SETC &amp;Trim(&amp;Var[1:&amp;j-1]) ; Remove it from the &lt;id&gt;     ENDIF   ENDIFB  &amp;i:      SETA &amp;List(&amp;Var, '&amp;A', ':')    ; Split &lt;size&gt; off the &lt;id&gt;1  &amp;Var:    SETC &amp;Trim(&amp;A[1])        ; Put &lt;id&gt; in &amp;Var@  &amp;Size:   SETC &amp;Default(&amp;Trim(&amp;A[2]), 'W')  ; Put &lt;size&gt; in &amp;Size&lt;  &amp;UCSize: SETC &amp;UC(&amp;Size)          ; Need upper case copy to test#   IF &amp;Type(&amp;Size) = 'TEMPLATE' THEN      IF &amp;Dim &shy; 1 THEN4      AERROR 'Dimension must be 1 for template types'     ENDIF &amp;Var      DS.W      &amp;Size=   ELSEIF (&amp;UCSize = 'W') OR (&amp;Align AND (&amp;UCSize = 'B')) THEN &amp;Var      DS.W      &amp;DimC   ELSEIF (&amp;Len(&amp;UCSize) = 1) AND (&amp;Pos(&amp;UCSize, 'BLSDXP') &gt; 0) THEN &amp;Var      DS.&amp;Size  &amp;Dim    ELSE     &amp;i: SETA &amp;Ord(&amp;Eval(&amp;Size))      IF &amp;Align THEN%&amp;Var      DS.B      &amp;Dim*(&amp;i+(&amp;i**1))      ELSE &amp;Var      DS.B      &amp;Dim*&amp;i     ENDIF   ENDIF&yuml; FUNCTION      ,&amp;Scope  Function  &amp;ArgList,&amp;C,&amp;Link==,&amp;Main==N     PRINT  Push,NoMDir,NoMCall2&amp;Scope  Procedure  &amp;ArgList,&amp;C,Link=&amp;Link,Main=&amp;Main     PRINT  Pop&yuml;  SCANARGS#           ScanArgs#  &amp;ArgList     GBLC    &amp;ModName#      ; &lt;modname&gt;     GBLC    &amp;FInfo#      ; &lt;result&gt;#    GBLC    &amp;Args#[50]    ; argument list6    GBLA    &amp;NbrOfArgs#    ; number of args in argument list6    GBLC    &amp;Areg      ; &quot;A&quot; ==&gt; call (An)[(arglist...)] case     LCLC    &amp;S,&amp;F[2]    LCLA    &amp;i,&amp;j&lt;  &amp;S: SETC &amp;Trim(&amp;ArgList)      ; Ignore leading/trailing blanks6  &amp;i: SETA &amp;Pos('(', &amp;S)      ; Find left-most &quot;(&quot;, if any?   IF &amp;Areg = 'A' THEN        ; But if we are doing a CALL.A (An)...4    &amp;j:  SETA &amp;Pos('(', &amp;S[&amp;i+1:255]); ...find 2nd &quot;(&quot;8     IF &amp;j &shy; 0 THEN        ; If there is one, we got arg list4      &amp;i:  SETA &amp;i + &amp;j      ; Adjust to point at 2nd &quot;(&quot;-     ELSE            ; If there isn't an arg list...*      &amp;i:  SETA 0        ; Set index accordingly     ENDIF   ENDIF$   IF &amp;i = 0 THEN          ; If no args...%    &amp;NbrOfArgs#: SETA 0      ; ...say so!)    &amp;i:          SETA &amp;List(&amp;S, '&amp;F', ':')I    &amp;ModName#:   SETC &amp;Trim(&amp;F[1])  ; Set &amp;ModName# to stuff before any &quot;:&quot;I    &amp;FInfo#:     SETC  &amp;Trim(&amp;F[2])  ; &amp;FInfo# is everything to right of &quot;:&quot;0   ELSE              ; If there are args, set up globals,    &amp;ModName#:   SETC &amp;Trim(&amp;ArgList[1:&amp;i-1])8    &amp;NbrOfArgs#: SETA &amp;List(&amp;ArgList[&amp;i+1:255], '&amp;Args#'):    &amp;i:          SETA &amp;List(&amp;Args#[&amp;NbrOfArgs#], '&amp;F', ')'))    &amp;Args#[&amp;NbrOfArgs#]: SETC &amp;Trim(&amp;F[1])0    &amp;FInfo#:    SETC &amp;SubStr(&amp;Trim(&amp;F[2]), 2, 255)   ENDIF&yuml;  PROCEDURE      -&amp;Scope  Procedure  &amp;ArgList,&amp;C,&amp;Link==,&amp;Main==N     PRINT  Push,NoMDir,NoMCall     GBLC    &amp;ModName#      ; &lt;modname&gt;%    GBLC    &amp;FInfo#      ; function &lt;result&gt;#    GBLC    &amp;Args#[50]    ; argument list6    GBLA    &amp;NbrOfArgs#    ; number of args in argument list                                1    GBLC    &amp;StFrame#      ; name of current stack frame2    GBLC    &amp;DbgName#      ; name to generate for MacsBug&amp;    GBLC    &amp;FSz#      ; function result size&amp;    GBLA    &amp;Link#      ; 1 ==&gt; generate LINK0    GBLA    &amp;HaveDcls#    ; 1 ==&gt; have local variables!    GBLA    &amp;C#        ; 1 ==&gt; C function6    GBLC    &amp;Areg      ; &quot;A&quot; ==&gt; call (An)[(arglist...)] case     LCLA    &amp;Func,&amp;Arg     LCLC    &amp;LinkOpt     LCLC    &amp;DbgTempI   IF &amp;Type('LinkAll') = 'UNDEFINED' THEN ; Initialize LinkAll if required     PRINT Push,Off     LinkAll: SET 0    PRINT Pop   ENDIFE   IF &amp;Type('Debug') = 'UNDEFINED' THEN ; Initialize Debug if required     PRINT Push,Off     Debug: SET 0    PRINT Pop   ENDIF3  &amp;Areg: SETC ''          ; Set switch for normal arglist7  ScanArgs#  &amp;ArgList        ; Set &amp;ModName#, &amp;Args#, &amp;FInfo#3  &amp;Func: SETA &amp;Len(&amp;FInfo#)    ; &amp;Func &shy; 0 if function=  &amp;C#:   SETA &amp;UC(&amp;C)='C'      ; Remember if we have a C function8     IF &amp;NbrOfArgs# = 1 THEN      ; Correct for the case F();         IF &amp;Args#[1] = '' THEN      ; One arg but it's null...B      &amp;NbrOfArgs#: SETA 0      ; ...treat as if there are no arguments        ENDIF     ENDIF    IF &amp;UC(&amp;Scope) = 'LOCAL' THEN           ALIGN      IF &amp;ModName# &shy; '' THEN
&amp;ModName#:     ENDIF#   ELSEIF &amp;UC(&amp;Main[1:1]) = 'Y' THEN &amp;ModName# MAIN      &amp;Scope    ELSEIF &amp;Func THEN &amp;ModName# FUNC      &amp;Scope    ELSE &amp;ModName# PROC      &amp;Scope   ENDIF(  &amp;StFrame#: SETC &amp;Concat('SF#', &amp;SysNdx)#&amp;StFrame# RECORD    {FramePtr},Decr    IF &amp;Func THEN?     IF (&amp;Func = 1) AND (&amp;Pos(&amp;UC(&amp;FInfo#), 'BWLSDXP') &gt; 0) THEN       &amp;FSz#: SETC &amp;UC(&amp;FInfo#) &amp;ModName# DS.&amp;FSz#  0      ELSE       &amp;FSz#: SETC 'W' &amp;FInfo#   DS.W    0     ENDIF    ELSE     &amp;FSz#: SETC ''   ENDIF    IF &amp;C# THEN          ; C ?!    &amp;Arg: SETA &amp;NbrOfArgs#      ; Yes;     WHILE &amp;Arg &gt; 0 DO        ; Declare formals in reverse order       Dcl1Var# &amp;Args#[&amp;Arg],1       &amp;Arg: SETA &amp;Arg-1     ENDW    ELSE              ; PascalF     WHILE &amp;Arg &lt; &amp;NbrOfArgs# DO    ; Declare formals in the &quot;normal&quot; way       &amp;Arg: SETA &amp;Arg+1       Dcl1Var# &amp;Args#[&amp;Arg],1         ENDW   ENDIF RetAddr   DS.L      15  &amp;Link#:   SETA 0        ; Assume LINK will not be needed   &amp;LinkOpt: SETC &amp;UC(&amp;Link)*   IF Debug THEN          ; If Debug &shy; 0 then...D    &amp;LinkOpt: SETC 'DEBUG'      ; ...we will gen LINK and MacsBug symbol1   ELSEIF LinkAll THEN        ; If LinkAll &shy; 0 then...K     IF &amp;LinkOpt &shy; 'DEBUG' THEN    ; ...if user didn't specify DEBUG for &amp;Link5      &amp;LinkOpt: SETC 'Y'      ; indicate we need the LINK     ENDIF   ENDIFA   IF &amp;LinkOpt &shy; '' THEN      ; Any &amp;Link or global control setting ?8    &amp;Link#: SETA 1        ; Yes, set switch to gen LINK later4     IF (&amp;LinkOpt &shy; 'DEBUG') OR (&amp;ModName# = '') THENC      &amp;DbgName#: SETC ''      ; If no MacsBug symbol, set global &lt;null&gt;6     ELSE            ; If MacsBug symbol, set it to gen later:      &amp;DbgTemp: SETC  &amp;ModName#    ; Generate new type symbols&gt;       IF &amp;Len(&amp;ModName#) &lt; 32 THEN  ; If module name &lt; 32 charsC      IF &amp;Len(&amp;ModName#) // 2 = 0 THEN ; Add space if even so that...N       &amp;DbgTemp: SETC &amp;Concat(&amp;ModName#,' ') ; string length plus length byte....        ENDIF          ; will align to word boundaryE        &amp;DbgName#: SETC &amp;Concat(&amp;Chr($80 + &amp;Len(&amp;ModName#)), &amp;DbgTemp)                                       6       ELSE            ; Length is greater than 32 charactersA      IF &amp;Len(&amp;ModName#) // 2 = 1 THEN ; Add space if length is odd*       &amp;DbgTemp: SETC &amp;Concat(&amp;ModName#,' ')      ENDIFF     &amp;DbgName#: SETC &amp;Concat(&amp;Chr($80), &amp;Chr(&amp;Len(&amp;ModName#)), &amp;DbgTemp)
      ENDIF     ENDIF   ENDIF   &amp;HaveDcls#: SETA 0     PRINT  Pop&yuml; VAR           Var     PRINT  Push,NoMDir,NoMCall&amp;    GBLA    &amp;Link#      ; 1 ==&gt; generate LINK0    GBLA    &amp;HaveDcls#    ; 1 ==&gt; have local variables    LCLA    &amp;i,&amp;NB   IF NOT &amp;HaveDcls# THEN      ; Is this the first local declaration ?6    &amp;HaveDcls#: SETA 1      ; Yes, indicate we have locals LinkA6    DS.L      1 FramePtr  EQU       *   ENDIF   &amp;N: SETA &amp;Nbr(&amp;SysLst)2   WHILE &amp;i &lt; &amp;N DO        ; Around and around we go...     &amp;i: SETA &amp;i+1     Dcl1Var# &amp;SysLst[&amp;i],0   ENDW0  &amp;Link#: SETA 1          ; Now we will require a LINK     PRINT  Pop&yuml; BEGIN           Begin  &amp;Prelude,&amp;Save==,&amp;With==     PRINT  Push,NoMDir,NoMCall%    GBLC    &amp;FInfo#      ; function &lt;result&gt;1    GBLC    &amp;StFrame#      ; name of current stack frame3    GBLC    &amp;SaveRegs#    ; Regs saved and to be restored6    GBLA    &amp;NbrOfArgs#    ; number of args in argument list&amp;    GBLA    &amp;Link#      ; 1 ==&gt; generate LINK0    GBLA    &amp;HaveDcls#    ; 1 ==&gt; have local variables=    GBLA    &amp;ArgSize#      ; nbr of bytes of stack space for formalsH   IF &amp;Link# OR (((&amp;FInfo#&shy;'') OR (&amp;NbrOfArgs# &shy; 0)) AND (&amp;Save&shy;'')) THEN'    &amp;Link#: SETA 1        ; Link is requiredF     IF NOT &amp;HaveDcls# THEN      ; Gen field for LINK address if no locals LinkA6    DS.L      1     ENDIF   ENDIF    IF NOT &amp;HaveDcls# THEN FramePtr  EQU       *   ENDIF LocalSize DS.W      0           ENDR    IF &amp;With &shy; '' THEN      IF &amp;With[1:1] = '(' THEN4          WITH      &amp;With[2:&amp;Len(&amp;With)-2],&amp;StFrame#      ELSE#          WITH      &amp;With,&amp;StFrame#     ENDIF    ELSE           WITH      &amp;StFrame#   ENDIF    IF &amp;Link# THEN      IF &amp;Prelude = '' THEN!          LINK      A6,#LocalSize     ENDIF FP        SET       A6    ELSE FP        SET       A7   ENDIF,  &amp;ArgSize#:  SETA &amp;Eval(&amp;StFrame#)-RetAddr-4   &amp;SaveRegs#: SETC &amp;Save    IF &amp;Save &shy; '' THEN/     IF &amp;Substr(&amp;Type(&amp;Save), 1, 3) = 'REG' THEN           MOVE.L    &amp;Save,-(A7)      ELSE           MOVEM.L   &amp;Save,-(A7)     ENDIF   ENDIF     PRINT  Pop&yuml; CALL           Call.&amp;Ext  &amp;CallSpec,&amp;Result     PRINT  Push,NoMDir,NoMCall     GBLC    &amp;ModName#      ; &lt;modname&gt;#    GBLC    &amp;Args#[50]    ; argument list6    GBLA    &amp;NbrOfArgs#    ; number of args in argument list8    GBLC    &amp;FInfo#      ; Function type if parameterless funct6    GBLC    &amp;Areg      ; &quot;A&quot; ==&gt; call (An)[(arglist...)] case     LCLA    &amp;i,&amp;Arg)    LCLC    &amp;A[2],&amp;Sz,&amp;Param,&amp;T,&amp;Rslt,&amp;RsltSzO   IF &amp;Type('AutoImport') = 'UNDEFINED' THEN ; Initialize AutoImport if required     PRINT Push,Off     AutoImport: SET 0    PRINT Pop   ENDIFD  &amp;Areg: SETC &amp;UC(&amp;Ext)      ; Set sw to &quot;A&quot; for (An)[(arglist...)] case&lt;  ScanArgs# &amp;CallSpec        ; Set &amp;ModName#, &amp;Args#, &amp;NbrOfArgs#    IF &amp;NbrOfArgs# = 0 THEN,    &amp;RsltSz: SETC &amp;Default(&amp;UC(&amp;FInfo#), 'W')      IF &amp;FInfo# &shy; '' THEN        IF &amp;RsltSz = 'L' THEN           SUBQ.W    #4,A7
       ELSE           SUBQ.W    #2,A7
      ENDIF     ENDIF    ELSE*    &amp;i:     SETA &amp;List(&amp;ModName#, '&amp;A', ':')     &amp;ModName#: SETC &amp;Trim(&amp;A[1])                         3    &amp;RsltSz:   SETC &amp;Default(&amp;UC(&amp;Trim(&amp;A[2])), 'W')      IF &amp;i = 2 THEN        IF &amp;RsltSz = 'L' THEN           SUBQ.W    #4,A7
       ELSE           SUBQ.W    #2,A7
      ENDIF     ENDIF   ENDIF9   WHILE &amp;Arg &lt; &amp;NbrOfArgs# DO      ; Loop through all of 'em     &amp;Arg:   SETA &amp;Arg+1     &amp;A[2]:  SETC ''I    &amp;i:     SETA &amp;List(&amp;Args#[&amp;Arg], '&amp;A', ':'); Split arg to get its size/    &amp;Param: SETC &amp;Trim(&amp;A[1])      ; Here's the arg5     IF &amp;Param &shy; '' THEN        ; I hope, it could be null=      &amp;Sz: SETC &amp;Default(&amp;UC(&amp;Trim(&amp;A[2])), 'W'); Get arg size5       IF &amp;Sz = 'A' THEN        ; Should we push address ?           PEA       &amp;ParamK       ELSEIF &amp;SubStr(&amp;Type(&amp;Sz), 1, 3) = 'REG' THEN ; Pushing a reg value ?           MOVEQ     &amp;Param,&amp;Sz           MOVE.L    &amp;Sz,-(A7)
       ELSE           IF &amp;A[2] = '' THEN        &amp;T: SETC &amp;UC(&amp;Param).           IF &amp;T = 'NIL' THEN      ; Pushing NIL ?           CLR.L     -(A7)3           ELSEIF &amp;T = 'TRUE' THEN    ; Pushing TRUE ?           ST        -(A7)1        ELSEIF &amp;T = 'FALSE' THEN    ; Pushing FALSE ?           CLR.B     -(A7)+           ELSE            ; Pushing a simple &lt;ea&gt;           MOVE.&amp;Sz  &amp;Param,-(A7)
       ENDIF%      ELSE            ; Pushing a simple &lt;ea&gt;           MOVE.&amp;Sz  &amp;Param,-(A7)      ENDIF
      ENDIF     ENDIF   ENDW   &amp;Sz: SETC &amp;UC(&amp;Ext)    IF &amp;Sz = 'A' THEN     JSR    &amp;ModName#(   ELSEIF (&amp;Sz &shy; '*') AND (&amp;Sz &shy; '') THEN           BSR.&amp;Sz   &amp;ModName#    ELSE,    &amp;T: SETC &amp;SubStr(&amp;Type(&amp;ModName#), 1, 11)      IF &amp;Sz = '*' THEN           JSR       &amp;ModName#`     ELSEIF (&amp;T = 'OPWORD') OR (&amp;T = 'MACRO') OR ((&amp;T='UNDEFINED') AND (&amp;ModName#[1] = '_')) THEN           &amp;ModName#L     ELSEIF (&amp;T='CODE MODULE') OR (&amp;T='CODE IMPORT') OR (&amp;T='UNDEFINED') THEN/       IF AutoImport AND (&amp;T = 'UNDEFINED') THEN      Import  &amp;ModName#
      ENDIF           JSR       &amp;ModName#      ELSE           BSR       &amp;ModName#     ENDIF   ENDIF&gt;  &amp;Rslt: SETC &amp;Default(&amp;Result, 'PASS'); Default result to PASS9   IF &amp;UC(&amp;Rslt) &shy; 'PASS' THEN  ; Should we pop the stack ?A    &amp;i: SETA &amp;Nbr(&amp;Result)    ; Maybe...see how &amp;Result is specifiedN     IF (&amp;i&gt;0) AND (&amp;UC(&amp;Result[1]) = 'PASS') THEN ; Copy result -- do not pop!       &amp;Rslt:   SETC &amp;Result[2]  ;        &amp;A[2]:   SETC ''=      &amp;i:      SETA &amp;List(&amp;Rslt, '&amp;A', ':') ; Split the result$      &amp;Rslt:   SETC &amp;UC(&amp;Trim(&amp;A[1]))7      &amp;RsltSz: SETC &amp;Default(&amp;UC(&amp;Trim(&amp;A[2])), &amp;RsltSz)&lt;       IF &amp;Rslt = 'CC' THEN    ; Use result as condition code ?           TST.&amp;RsltSz (A7)8       ELSEIF &amp;Rslt = 'POP' THEN  ; Simply pop the stack ?5        AERROR 'Cannot PASS and POP at the same time!''       ELSE          ; Copy stack into result!          MOVE.&amp;RsltSz (A7),&amp;A[1]
      ENDIF'     ELSE          ; Pop result off the stack       &amp;A[2]:   SETC ''      =      &amp;i:      SETA &amp;List(&amp;Rslt, '&amp;A', ':') ; Split the result$      &amp;Rslt:   SETC &amp;UC(&amp;Trim(&amp;A[1]))7      &amp;RsltSz: SETC &amp;Default(&amp;UC(&amp;Trim(&amp;A[2])), &amp;RsltSz)&lt;       IF &amp;Rslt = 'CC' THEN    ; Use result as condition code ?            TST.&amp;RsltSz (A7)+8       ELSEIF &amp;Rslt = 'POP' THEN  ; Simply pop the stack ?       IF &amp;RsltSz = 'L' THEN           ADDQ.W    #4,A7       ELSE           ADDQ.W    #2,A7      ENDIF                            &amp;       ELSE          ; Pop stack into result&quot;          MOVE.&amp;RsltSz (A7)+,&amp;A[1]
      ENDIF     ENDIF   ENDIF     PRINT  Pop&yuml;                                                                                                                                                                                                                                                                                                                                                                                                              </pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/OOPTESample/listing3.html%3Fid%3DDTS10000278-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/OOPTESample/listing3.html%3Fid%3DDTS10000278-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/OOPTESample/listing3.html%3Fid%3DDTS10000278-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>