<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Compiling and Executing Source Data(IM:IC)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING334></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="IAC-333.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="IAC-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="IAC-529.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="IAC-335.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="IAC-2.html"><B>Interapplication Communication</B></A> / <BR><DD><A HREF="IAC-331.html"><B>Chapter 10 - Scripting Components</B></A> / <A HREF="IAC-333.html"><B>Using Scripting Component Routines</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING334-0></A>
<H2><A NAME=MARKER-9-87></A>Compiling and Executing Source Data</H2>
 <A NAME=MARKER-9-222></A><A NAME=MARKER-2-420></A>This section describes how you can use scripting component routines to obtain source data from users, compile the source data, and execute the compiled script. To create and execute a script using the Script Editor application, a user can type the script, then click the Run button to execute it. Your application can provide similar capabilities.<P>
 To allow users to write a new script and then execute it, your application must use scripting component routines to compile and execute the source data. To compile source data in a new script with a new script ID, pass the constant <CODE>kOSANullScript</CODE> (rather than an existing script ID) in the last parameter of the <CODE>OSACompile</CODE> function. This causes <CODE>OSACompile</CODE> to return a new script ID in the same parameter.<P>
 To execute a compiled script, your application must specify, in addition to the script ID for the compiled script, a script context: either the corresponding scripting component's default context or a script ID for the global context created by that scripting component. Script contexts maintain state information for the execution of scripts. Your application can use script contexts to control the binding of variables used in scripts that it executes. For example, if your application saves its own global context and reuses it every time a script is executed, the binding of variables used in the script is maintained after the user restarts the computer. If your application does not specify a script context, the AppleScript component uses a single default context whenever it executes the script. A scripting component's default context binds the variables used in the script only until the user quits the application.<P>
 To specify a scripting component's default context, pass the constant <CODE>kOSANullScript</CODE> in the third parameter of the <CODE>OSAExecute</CODE> function; to specify some other global context, pass its script ID in the third parameter. <A NAME=MARKER-2-90></A> <P>
 The <CODE>MyDoNewScript</CODE> procedure in <A HREF=#MARKER-9-91>Listing 10-2</A> allows a user to type a script in the appropriate scripting language, then compiles the script, executes the compiled script using a global context provided by the application, and displays the result to the user.<P>
 The <CODE>MyDoNewScript</CODE> procedure begins by calling the <CODE>OSAScriptingComponentName</CODE> function to obtain the name of the scripting component specified by <CODE>gScriptingComponent</CODE>. This name is passed to the application-defined function <CODE>MyGetUserScriptText</CODE>.<P>
<DL>
<DT><B>Note</B>
<DD>If you are using the generic scripting component, you can use the <CODE>OSAGetDefaultComponent</CODE> function to get the subtype code for the default scripting component (that is, the scripting component used by the generic scripting component for new scripts). You can then get an instance of the default scripting component by passing its subtype code to <CODE>OSAGetScriptingComponent</CODE>. Finally, you can pass that instance to <CODE>OSAScriptingComponentName</CODE> to obtain the default scripting component's name. For more information about the default scripting component and routines you can use with the generic scripting component, see <A HREF=IAC-403.html#MARKER-9-271>"Generic Scripting Component Routines,"</A> which begins on <A HREF=IAC-403.html#MARKER-9-271>page 10-83</A>.<EM></EM>   <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 The <CODE>MyGetUserScriptText</CODE> function displays the name of the scripting language to use in a script-editing window or message box that allows the user to type and execute a new script. After it obtains the source data for the new script, the <CODE>MyDoNewScript</CODE> procedure sets the <CODE>scriptID</CODE> variable to <CODE>kOSANullScript</CODE>. The procedure then passes the source data and <CODE>scriptID</CODE> to the <CODE>OSACompile</CODE> function. When the script ID passed to <CODE>OSACompile</CODE> is <CODE>kOSANullScript</CODE>, <CODE>OSACompile</CODE> returns, in the same parameter, a new script ID for the resulting compiled script. The <CODE>MyDoNewScript</CODE> procedure then passes the new script ID to the <CODE>OSAExecute</CODE> function.<P>
 In addition to a component instance and the script ID for the compiled script to be executed, <CODE>OSAExecute</CODE> takes a script ID for a script context and a parameter that contains the mode flags, if any, for script execution. In <A HREF=#MARKER-9-91>Listing 10-2</A>, the script ID passed to <CODE>OSAExecute</CODE> for the script context is <CODE>gContext</CODE>, a global context provided by the application. The constant kOSAModeNull in the next parameter indicates that no mode flags are set for script execution. <P>
<B>Listing 10-2  <A NAME=MARKER-9-91></A>A routine that compiles and executes source data<A NAME=MARKER-21-449></A></B><P>
<PRE>
PROCEDURE MyDoNewScript;
VAR
   componentName, scriptText, resultText: AEDesc;
   scriptID, resultID:                    OSAID;
   myOSAErr, ignoreErr:                   OSAError;
BEGIN
   {get the scripting component's name so you can show }
   { the user which scripting language to use}
   myOSAErr := OSAScriptingComponentName(gScriptingComponent, 
                                          componentName);
   IF myOSAErr = noErr THEN
   BEGIN       {get the user's script text, then compile it}
      MyGetUserScriptText(componentName, scriptText);
      {to create a new compiled script using the user's script }
      { text, pass kOSANullScript to OSACompile as the script ID }
      { for the script to be compiled}
      scriptID := kOSANullScript;
      myOSAErr := OSACompile(gScriptingComponent, scriptText, 
                              kOSAModeNull, scriptID);
      ignoreErr := AEDisposeDesc(scriptText);
   END;
   IF myOSAErr = noErr THEN
   BEGIN
      {execute the script in a global context}
      myOSAErr := OSAExecute(gScriptingComponent, scriptID, 
                              gContext, kOSAModeNull, resultID);
      ignoreErr := OSADispose(gScriptingComponent, scriptID);
      IF myOSAErr = noErr THEN
      BEGIN
         {convert the script value returned by OSAExecute to }
         { text that can be displayed to the user}
         myOSAErr := OSADisplay(gScriptingComponent, resultID, 
                              typeChar, kOSAModeNull, resultText);
         ignoreErr := OSADispose(gScriptingComponent, resultID);
         {show result to user}
         MyShowUserResult(resultText);
         ignoreErr := AEDisposeDesc(resultText);
      END;
   END;
   IF myOSAErr = errOSAScriptError THEN 
      MyGetScriptErrorInfo;
END;  
</PRE>
 If script execution is successful, the <CODE>MyDoNewScript</CODE> procedure passes the script ID for the resulting script value to the <CODE>OSADisplay</CODE> function and calls the <CODE>MyShowUserResult</CODE> procedure to display the script value to the user. It also disposes of the script data for the compiled script. If <CODE>OSAExecute</CODE> or <CODE>OSACompile</CODE> returns the result code <CODE>errOSAScriptError</CODE>, the <CODE>MyDoNewScript</CODE> procedure calls the <CODE>MyGetScriptErrorInfo</CODE> procedure shown in <A HREF=#MARKER-9-96>Listing 10-3</A>, which uses the <CODE>OSAScriptError</CODE> function to obtain more information about the error.<P>
 Whenever a scripting component routine returns the result code <CODE>errOSAScriptError</CODE>, you can use <CODE>OSAScriptError</CODE> to obtain more information about the error. The second parameter of the <CODE>OSAScriptError</CODE> function is a constant that specifies the kind of error information to be returned, and the third parameter is the descriptor type for the descriptor record in which the additional error information will be returned.<P>
 The <CODE>MyGetScriptErrorInfo</CODE> procedure in <A HREF=#MARKER-9-96>Listing 10-3</A> calls <CODE>OSAScriptError</CODE> three times: once to obtain an error number for either a system error or a scripting component error, once to obtain a text description of the error, and once to obtain error-range information. (For more information about specifying descriptor types for <CODE>OSAScriptError</CODE>, see <A HREF=IAC-353.html#MARKER-9-181>page 10-36</A>.) Finally, the <CODE>MyGetScriptErrorInfo</CODE> procedure extracts the starting and ending positions of the error range in the source data and calls the application-defined procedure <CODE>MyIndicateError</CODE> to display the error information to the user. Note that your application is responsible for disposing of any descriptor records that are created. <A NAME=MARKER-2-93></A><P>
 You should use the <CODE>OSACompile</CODE> and <CODE>OSAExecute</CODE> functions as shown in <A HREF=#MARKER-9-91>Listing 10-2</A> if you expect the user to execute the compiled script several times or manipulate it in some other way. If you want to compile and execute a script just one time and don't need to keep the compiled script in memory after it has been executed, you can use either <CODE>OSACompileExecute</CODE> or <CODE>OSADoScript</CODE> if these functions are supported by the scripting component you specify. <A NAME=MARKER-2-94></A> <P>
 The <CODE>OSACompileExecute</CODE> function takes a component instance, a descriptor record for the source data to be compiled and executed, a context ID, and a <CODE>modeFlags</CODE> parameter. It executes the resulting compiled script, disposes of the compiled script, and returns the script ID for the resulting script value. <P>
 The <CODE>OSADoScript</CODE> function takes a component instance, a descriptor record for source data, a context ID, a text descriptor type, and a <CODE>modeFlags</CODE> parameter. It compiles and executes the script, returns a descriptor record for the text that corresponds to the resulting script value, and disposes of both the compiled script and the script value. <A NAME=MARKER-2-95></A><P>
<B>Listing 10-3  <A NAME=MARKER-9-96></A>A procedure that uses <CODE>OSAScriptError</CODE> to get information about an execution error<A NAME=MARKER-2-97></A></B><P>
<PRE>
PROCEDURE MyGetScriptErrorInfo; 
TYPE
   OSErrPtr       = ^OSErr;
   OSErrHandle    = ^OSErrPtr;
VAR
   errorMessage:                 Handle;
   startPos, endPos:             Integer;
   desc, recordDesc:             AEDesc;
   actualType:                   DescType;
   actualSize:                   Size;
   scriptErr, myErr, ignoreErr:  OSErr;
   myOSAErr:                     OSAError; 
BEGIN
   myOSAErr := OSAScriptError(gScriptingComponent, 
                           kOSAErrorNumber, typeShortInteger, 
                           desc);
   scriptErr := OSErrHandle(desc.dataHandle)^^;
   ignoreErr := AEDisposeDesc(desc);
   myOSAErr := OSAScriptError(gScriptingComponent, 
                           kOSAErrorMessage, typeChar, desc);
   errorMessage := desc.dataHandle;
   myOSAErr := OSAScriptError(gScriptingComponent, 
                           kOSAErrorRange, typeOSAErrorRange, 
                           desc);
   myErr := AECoerceDesc (desc, typeAERecord, recordDesc);
   ignoreErr := AEDisposeDesc(desc);
   myErr := AEGetKeyPtr(recordDesc, keySourceStart, 
                        typeShortInteger, actualType,
                        Ptr(@startPos), sizeOf(startPos),
                        actualSize);
   myErr := AEGetKeyPtr(recordDesc, keySourceEnd, 
                        typeShortInteger, actualType,
                        Ptr(@endPos), sizeOf(endPos),
                        actualSize);
   ignoreErr := AEDisposeDesc(recordDesc);
   MyIndicateError(scriptErr, errorMessage, startPos, endPos);
   {add your own error checking}
END;  
</PRE>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="IAC-333.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="IAC-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="IAC-529.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="IAC-335.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="IAC-3.html">&copy; Apple Computer, Inc.</A><br>7 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
