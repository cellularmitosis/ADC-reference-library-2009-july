<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Cocoa Drawing Guide: Images</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Images"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40003290-CH208" title="Images"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../GraphicsImaging-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000450" target="_top">Graphics &amp; Imaging</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP40003290-CH201-SW1">Cocoa Drawing Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Paths/Paths.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../Text/Text.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40003290-CH208-BCIBBFGJ" title="Images"></a><h1>Images</h1><p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_419"></a>Images are an important part of any Mac OS X application. In Cocoa, images play a very important, but flexible, role in your user interface. You can use images to render preexisting content or act as a buffer for your application's drawing commands. At the heart of Cocoa's image manipulation code is the <code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/cl/NSImage" target="_top">NSImage</a></code> class. This class manages everything related to image data and is used for the following tasks:</p><ul class="ul"><li class="li"><p>Loading existing images from disk.</p></li><li class="li"><p>Drawing image data into your views.</p></li><li class="li"><p>Creating new images.</p></li><li class="li"><p>Scaling and resizing images.</p></li><li class="li"><p>Converting images to any of several different formats.</p></li></ul>
<p>You can use images in your program for a variety of tasks. You can load images from existing image files (such as JPEG, GIF, PDF, and EPS files) to draw elements of your user interface that might be too difficult (or too inefficient) to draw using primitive shapes. You can also use images as offscreen or temporary buffers and capture a sequence of drawing commands that you want to use at a later time.</p><p>Although bitmaps are one of the most common types of image, it is important not to think of the <code>NSImage</code> class as simply managing photographic or bitmap data. The <code>NSImage</code> class in Cocoa is capable of displaying a variety of image types and formats. It provides support for photograph and bitmap data in many standard formats. It also provides support for vector, or command-based data, such as PDF, EPS, and PICT. You can even use the <code>NSImage</code> class to represent an image created with the Core Image framework. </p>


<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="Images.html#//apple_ref/doc/uid/TP40003290-CH208-SW8">Image Basics</a>
				
			<br/>
			
        
			
			
				<a href="Images.html#//apple_ref/doc/uid/TP40003290-CH208-BCIIFBJG">Supported Image File Formats</a>
				
			<br/>
			
        
			
			
				<a href="Images.html#//apple_ref/doc/uid/TP40003290-CH208-SW19">Guidelines for Using Images</a>
				
			<br/>
			
        
			
			
				<a href="Images.html#//apple_ref/doc/uid/TP40003290-CH208-SW20">Creating NSImage Objects</a>
				
			<br/>
			
        
			
			
				<a href="Images.html#//apple_ref/doc/uid/TP40003290-CH208-SW25">Working with Images</a>
				
			<br/>
			
        
			
			
				<a href="Images.html#//apple_ref/doc/uid/TP40003290-CH208-BCIFJBGC">Creating New Image Representation Classes</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40003290-CH208-SW8" title="Image Basics"></a><h2>Image Basics</h2>
<p>The <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_420"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/cl/NSImage" target="_top">NSImage</a></code> class provides the high-level interface for manipulating images in many different formats. Because it provides the high-level interface, <code>NSImage</code> knows almost nothing about managing the actual <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_421"></a>image data. Instead, the <code>NSImage</code> class manages one or more image representation objects—objects derived from the <code><a href="../../../Reference/ApplicationKit/Classes/NSImageRep_Class/Reference/Reference.html#//apple_ref/occ/cl/NSImageRep" target="_top">NSImageRep</a></code> class. Each image representation object understands the image data for a particular format and is capable of rendering that data to the current context. </p><p>The following sections provide insight into the relationship between image objects and image representations.  </p>
<a name="//apple_ref/doc/uid/TP40003290-CH208-SW9" title="Image Representations"></a><h3>Image Representations</h3>
<p>An <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_422"></a>image representation object  represents an image at a specific size, using a specific color space, and in a specific data format. Image representations are used by an <code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/cl/NSImage" target="_top">NSImage</a></code> object to manage image data. An image representation object knows how to read image data from a file, write that data back to a file, and convert the image data to a raw bitmap that can then be rendered to the current context. Some image representations also provide an interface for manipulating the image data directly. </p><p>For file-based images, <code>NSImage</code> creates an image representation object for each separate image stored in the file. Although most image formats support only a single image, formats such as TIFF allow multiple images to be stored. For example, a TIFF file might store both a full size version of an image and a thumbnail. </p>
<p>If you are creating images dynamically, you are responsible for creating the image representation objects you need for your image. As with file-based images, most of the images you create need only a single image representation. Because <code>NSImage</code> is adept at scaling and adjusting images to fit the target canvas, it is usually not necessary to create different image representations at different resolutions. You might create multiple representations in the following situations, however: </p>
<ul class="spaceabove"><li class="li"><p>For printing, you might want to create a PDF representation or high-resolution bitmap of your image.</p></li>
<li class="li"><p>You want to provide different content for your image when it is scaled to different sizes. </p></li></ul>
<p>When you draw an <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_423"></a>image, the <code>NSImage</code> object chooses the representation that is best suited for the target canvas. This choice is based on several factors, which are explained in <span class="content_text"><a href="Images.html#//apple_ref/doc/uid/TP40003290-CH208-BCIGEIFF">“How an Image Representation Is Chosen.”</a></span> If you want to ensure that a specific image representation is used, you can use the <code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/instm/NSImage/drawRepresentation:inRect:" target="_top">drawRepresentation:inRect:</a></code> method of <code>NSImage</code>. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH208-SW10" title="Image Representation Classes"></a><h4>Image Representation Classes</h4>
<p>Every <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_424"></a>image representation object is based on a subclass of <code><a href="../../../Reference/ApplicationKit/Classes/NSImageRep_Class/Reference/Reference.html#//apple_ref/occ/cl/NSImageRep" target="_top">NSImageRep</a></code>. Cocoa defines several specific subclasses to handle commonly used formats. <span class="content_text">Table 6-1</span> lists the class and the image types it supports. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH208-BCIGFFCD" title="Table 6-1Image representation classes"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">
<caption class="tablecaption"><strong>Table 6-1&nbsp;&nbsp;</strong>Image representation classes</caption>

<tr>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Class</p></th>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Supported types</p></th>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th>
</tr>


<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_425"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBitmapImageRep_Class/Reference/Reference.html#//apple_ref/occ/cl/NSBitmapImageRep" target="_top">NSBitmapImageRep</a></code></p></td>
<td ><p>TIFF, BMP, JPEG, GIF, PNG, DIB, ICO, among others</p></td>
<td ><p>Handles bitmap data. Several common bitmap formats are supported directly. For custom <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_426"></a><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_427"></a>image formats, you may have to decode the image data yourself before creating your image representation. An <code>NSBitmapImageRep</code> object uses any available color profile data (ICC or ColorSync) when rendering. </p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_428"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSCachedImageRep_Class/Reference/Reference.html#//apple_ref/occ/cl/NSCachedImageRep" target="_top">NSCachedImageRep</a></code></p></td>
<td ><p>Rendered data</p></td>
<td ><p>This class is used internally by Cocoa to <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_429"></a>cache images for drawing to the screen. You should not need to use this class directly. </p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_430"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSCIImageRep_Class/Reference/Reference.html#//apple_ref/occ/cl/NSCIImageRep" target="_top">NSCIImageRep</a></code></p></td>
<td ><p>N/A</p></td>
<td ><p>Provides a representation for a <code><a href="../../../../GraphicsImaging/Reference/QuartzCoreFramework/Classes/CIImage_Class/Reference/Reference.html#//apple_ref/occ/cl/CIImage" target="_top">CIImage</a></code> object, which itself supports most bitmap formats. </p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_431"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSPDFImageRep_Class/Reference/Reference.html#//apple_ref/occ/cl/NSPDFImageRep" target="_top">NSPDFImageRep</a></code></p></td>
<td ><p>PDF</p></td>
<td ><p>Handles the display of <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_432"></a>PDF data. </p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_433"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSEPSImageRep_Class/Reference/Reference.html#//apple_ref/occ/cl/NSEPSImageRep" target="_top">NSEPSImageRep</a></code></p></td>
<td ><p>EPS</p></td>
<td ><p>Handles the display of PostScript or encapsulated <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_434"></a><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_435"></a>PostScript data.</p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_436"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSCustomImageRep_Class/Reference/Reference.html#//apple_ref/occ/cl/NSCustomImageRep" target="_top">NSCustomImageRep</a></code></p></td>
<td ><p>Custom</p></td>
<td ><p>Handles custom image data by passing it to a delegate object you provide. </p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_437"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSPICTImageRep_Class/Reference/Reference.html#//apple_ref/occ/cl/NSPICTImageRep" target="_top">NSPICTImageRep</a></code></p></td>
<td ><p>PICT</p></td>
<td ><p>Handles the display of PICT format version 1, version 2, and extended version 2 pictures. The <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_438"></a>PICT format is a legacy format described in the Carbon QuickDraw Manager documentation.</p></td>
</tr>

</table></div>
<p>In most situations, you do not need to know how an image representation is created. For example, if you load an existing image from a file, <code>NSImage</code> automatically determines which type of image representation to create based on the file data. All you have to do is draw the image in your view. </p>
<p>If you want to support new image formats, you can create a new image representation class. The <code>NSImage</code> class and its <code>NSImageRep</code> subclasses do not follow the class cluster model found in several other Cocoa classes. Creating new image representations is relatively straightforward and is explained in <span class="content_text"><a href="Images.html#//apple_ref/doc/uid/TP40003290-CH208-BCIFJBGC">“Creating New Image Representation Classes.”</a></span> </p>
<a name="//apple_ref/doc/uid/TP40003290-CH208-BCIGEIFF" title="How an Image Representation Is Chosen"></a><h4>How an Image Representation Is Chosen</h4>
<p>When you tell an <code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/cl/NSImage" target="_top">NSImage</a></code> object to draw itself, it searches its list of <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_439"></a><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_440"></a>image representations for the one that best matches the attributes of the destination device. In determining which image representation to choose, it follows a set of ordered rules that compare the color space, image resolution, bit depth, and image size to the corresponding values in the destination device. The rules are applied in the following order:</p>
<ol class="ol"><li class="li"><p>Choose an image representation whose <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_441"></a>color space most closely matches the color space of the device. If the device is color, choose a color image representation. If the device is monochrome, choose a gray-scale image representation. </p></li>
<li class="li"><p>Choose an image representation whose resolution (pixels per inch) matches the resolution of the device. If no image representation matches exactly, choose the one with the highest resolution.</p><p>By default, any image representation with a resolution that’s an integer multiple of the device resolution is considered a match. If more than one representation matches, <code>NSImage</code> chooses the one that’s closest to the device resolution. You can force resolution matches to be exact by passing <code>NO</code> to the <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_442"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/instm/NSImage/setMatchesOnMultipleResolution:" target="_top">setMatchesOnMultipleResolution:</a></code> method.</p><p>This rule prefers TIFF and bitmap representations, which have a defined resolution, over EPS representations, which do not. You can use the <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_443"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/instm/NSImage/setUsesEPSOnResolutionMismatch:" target="_top">setUsesEPSOnResolutionMismatch:</a></code> method to cause <code>NSImage</code> to choose an EPS representation in case a resolution match is not possible.</p></li>
<li class="li"><p>Choose a representation whose <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_444"></a><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_445"></a>bit depth (bits per sample) matches the depth of the device. If no representation matches, choose the one with the highest number of bits per sample.</p></li></ol>
<p>You can change the order in which these rules are applied using the methods of <code>NSImage</code>. For example, if you want to invert the first and second rules, pass <code>NO</code> to the <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_446"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/instm/NSImage/setPrefersColorMatch:" target="_top">setPrefersColorMatch:</a></code> method. Doing so causes <code>NSImage</code> to match the resolution before the color space. </p>
<p>If these rules fail to narrow the choice to a single representation—for example, if the <code>NSImage</code> object has two color TIFF representations with the same resolution and depth—the chosen representation is operating-system dependent.</p>
<a name="//apple_ref/doc/uid/TP40003290-CH208-SW11" title="Images and Caching"></a><h3>Images and Caching</h3>
<p>The <code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/cl/NSImage" target="_top">NSImage</a></code> class incorporates an internal <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_447"></a>caching scheme aimed at improving your application’s drawing performance. This caching scheme is an important part of image management and is enabled by default for all image objects; however, you can change the caching options for a particular image using the <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_448"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/instm/NSImage/setCacheMode:" target="_top">setCacheMode:</a></code> method of <code>NSImage</code>. <span class="content_text">Table 6-2</span> lists the available caching modes. </p><a name="//apple_ref/doc/uid/TP40003290-CH208-BCIFEFJC" title="Table 6-2Image caching modes"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">
<caption class="tablecaption"><strong>Table 6-2&nbsp;&nbsp;</strong>Image caching modes</caption>

<tr>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Mode</p></th>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th>
</tr>


<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_449"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/c/econst/NSImageCacheDefault" target="_top">NSImageCacheDefault</a></code></p></td>
<td ><p>Use the default caching mode appropriate for the image representation. This is the default value. For more information, see <span class="content_text"><a href="Images.html#//apple_ref/doc/uid/TP40003290-CH208-BCIGGBCD">Table 6-3</a></span>.</p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_450"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/c/econst/NSImageCacheAlways" target="_top">NSImageCacheAlways</a></code></p></td>
<td ><p>Always caches a version of the image.</p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_451"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/c/econst/NSImageCacheBySize" target="_top">NSImageCacheBySize</a></code></p></td>
<td ><p>Creates a cached version of the image if the size set for the image is smaller than the size of the actual image data. </p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_452"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/c/econst/NSImageCacheNever" target="_top">NSImageCacheNever</a></code></p></td>
<td ><p>Does not cache the image. The image data is rasterized every time it is drawn. </p></td>
</tr>

</table></div>
<p><span class="content_text">Table 6-3</span> lists the behavior of each image representation when its cache mode is set to <code>NSImageCacheDefault</code>. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH208-BCIGGBCD" title="Table 6-3Implied cache settings"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">
<caption class="tablecaption"><strong>Table 6-3&nbsp;&nbsp;</strong>Implied cache settings</caption>

<tr>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Image representation</p></th>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Cache behavior</p></th>
</tr>


<tr>
<td  scope="row"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSBitmapImageRep_Class/Reference/Reference.html#//apple_ref/occ/cl/NSBitmapImageRep" target="_top">NSBitmapImageRep</a></code></p></td>
<td ><p>Behaves as if the <code>NSImageCacheBySize</code> setting were in effect. Creates a cached copy if the bitmap depth does not match the screen depth or if the bitmap resolution is greater than 72 dpi. </p></td>
</tr>
<tr>
<td  scope="row"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSCachedImageRep_Class/Reference/Reference.html#//apple_ref/occ/cl/NSCachedImageRep" target="_top">NSCachedImageRep</a></code></p></td>
<td ><p>Not applicable. This class is used to implement caching. </p></td>
</tr>
<tr>
<td  scope="row"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSCIImageRep_Class/Reference/Reference.html#//apple_ref/occ/cl/NSCIImageRep" target="_top">NSCIImageRep</a></code></p></td>
<td ><p>Behaves as if the <code>NSImageCacheBySize</code> setting were in effect. Creates a cached copy if the bitmap depth does not match the screen depth or if the bitmap resolution is greater than 72 dpi. </p></td>
</tr>
<tr>
<td  scope="row"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSPDFImageRep_Class/Reference/Reference.html#//apple_ref/occ/cl/NSPDFImageRep" target="_top">NSPDFImageRep</a></code></p></td>
<td ><p>Behaves as if the <code>NSImageCacheAlways</code> setting were in effect. </p></td>
</tr>
<tr>
<td  scope="row"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSEPSImageRep_Class/Reference/Reference.html#//apple_ref/occ/cl/NSEPSImageRep" target="_top">NSEPSImageRep</a></code></p></td>
<td ><p>Behaves as if the <code>NSImageCacheAlways</code> setting were in effect.</p></td>
</tr>
<tr>
<td  scope="row"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSCustomImageRep_Class/Reference/Reference.html#//apple_ref/occ/cl/NSCustomImageRep" target="_top">NSCustomImageRep</a></code></p></td>
<td ><p>Behaves as if the <code>NSImageCacheAlways</code> setting were in effect. </p></td>
</tr>
<tr>
<td  scope="row"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSPICTImageRep_Class/Reference/Reference.html#//apple_ref/occ/cl/NSPICTImageRep" target="_top">NSPICTImageRep</a></code></p></td>
<td ><p>Behaves as if the <code>NSImageCacheBySize</code> setting were in effect. Creates a cached copy of the PICT image if it contains a bitmap whose depth does not match the screen depth or if that bitmap resolution is greater than 72 dpi. </p></td>
</tr>

</table></div>
<p>Caching is a useful step toward preparing an image for display on the screen. When first loaded, the data for an image representation may not be in a format that can be rendered directly to the screen. For example, PDF data, when loaded into a PDF image representation, must be rasterized before it can be sent to the graphics card for display. With caching enabled, a <code>NSPDFImageRep</code> object rasterizes the PDF data before drawing it to the screen. The image representation then saves the raster data to alleviate the need to recreate it later. If you disable caching for such images, the rasterization process occurs each time you render the image, which can lead to a considerable performance penalty.</p>
<p>For bitmap image representations, the decision to cache is dependent on the bitmap image data. If the bitmap’s color space, resolution, and bit depth match the corresponding attributes in the destination device, the bitmap may be used directly without any caching. If any of these attributes varies, however, the bitmap image representation may create a cached version instead.</p>
<div class="importantbox"><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_12" title="Important:"></a><p><strong>Important:</strong>&nbsp;

It is important to remember that caching is aimed at improving performance during screen updates. During printing, Cocoa uses the native image data and resolution whenever possible and uses cached versions of the image only as a last resort.</p><p></p></div><p>If you change the contents of an image representation object directly, you should invoke the <code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/instm/NSImage/recache" target="_top">recache</a></code> method of the owning <code>NSImage</code> object when you are done and want the changes to be reflected on the screen. Cocoa does not automatically track the changes you make to your image representation objects. Instead, it continues to use the cached version of your image representation until you explicitly clear that cache using the <code>recache</code> method.  </p>
<a name="//apple_ref/doc/uid/TP40003290-CH208-SW12" title="Caching and Image Data Retention"></a><h4>Caching and Image Data Retention</h4>
<p>Because caching can lead to multiple copies of the <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_453"></a>image data in memory, <code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/cl/NSImage" target="_top">NSImage</a></code> usually dismisses the original image data once a cached copy is created. Dismissing the original image data saves memory and improves performance and is appropriate in situations where you do not plan on changing the <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_454"></a>image size or attributes. If you do plan on changing the image size or attributes, you may want to disable this behavior. Enabling data retention prevents image degradation by basing changes on the original image data, as opposed to the currently cached copy. </p>
<p>To retain image data for a specific image, you must send a <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_455"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/instm/NSImage/setDataRetained:" target="_top">setDataRetained:</a></code> message to the <code>NSImage</code> object. Preferably, you should send this message immediately after creating the image object. If you send the message after rendering the image or locking focus on it, Cocoa may need to read the image data more than once. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH208-SW13" title="Caching Images Separately"></a><h4>Caching Images Separately</h4>
<p>To improve <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_456"></a>performance, most caching of an application’s images occurs in one or more offscreen windows. These windows act as image repositories for the application and are not shared by other applications. Cocoa manages them automatically and assigns images to them based on the current image attributes. </p>
<p>By default, Cocoa tries to reduce the number of offscreen windows by putting multiple images into a single window. For images whose size does not change frequently, this technique is usually faster than storing each image in its own window. For images whose size does change frequently, it may be better to cache the image separately by sending a <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_457"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/instm/NSImage/setCachedSeparately:" target="_top">setCachedSeparately:</a></code> message to the image object. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH208-SW2" title="Image Size and Resolution"></a><h3>Image Size and Resolution</h3>
<p>Both <code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/cl/NSImage" target="_top">NSImage</a></code> and <code><a href="../../../Reference/ApplicationKit/Classes/NSImageRep_Class/Reference/Reference.html#//apple_ref/occ/cl/NSImageRep" target="_top">NSImageRep</a></code> define methods for getting and setting the size of an <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_458"></a>image. The meaning of sizes can differ for each type of object, however. For <code>NSImage</code>, the size is always specified in units of the user coordinate space. Thus, an image that is 72 by 72 points is always rendered in a 1-inch square. For <code>NSImageRep</code>, the size is generally tied to the size of the native or cached bitmap. For resolution-independent image representations, a cached bitmap is created whose size matches that returned by <code>NSImage</code>. For true bitmap images, however, the size is equal to the width and height (in pixels) of the bitmap image. </p>
<p>If you create your image from a data object or file, the <code>NSImage</code> object takes its image size information from the provided data. For example, with EPS data, the size is taken from the bounding rectangle, whereas with TIFF data, the size is taken from the <code>ImageLength</code> and <code>ImageWidth</code> fields. If you create a blank image, you must set the image size yourself when you initialize the <code>NSImage</code> object. </p>
<p>You can change the <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_459"></a>size of an image at any time using the <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_460"></a><code>setSize:</code> method of either <code>NSImage</code> or <code>NSImageRep</code>. The size returned by the <code>NSImage</code> version of the method represents the dimensions of the image in the user coordinate space. Changing this value therefore changes the size of the image as it is drawn in one of your views. This change typically affects only the cached copy of the image data, if one exists. Changing the size of an image representation object changes the actual number of bits used to hold the image data. This change primarily affects bitmap images, and can result in a loss of data for your in-memory copy of the image. </p>
<p>If the size of the data in an image representation is smaller than the rectangle into which it will be rendered, the image must be <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_461"></a>scaled to fit the target rectangle. For resolution-independent images, such as PDF images, scaling is less of an issue. For bitmap images, however, pixel values in the bitmap must be interpolated to fill in the extra space. <span class="content_text">Table 6-4</span> lists the available <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_462"></a>interpolation settings.</p><a name="//apple_ref/doc/uid/TP40003290-CH208-BCIIGEED" title="Table 6-4Image interpolation constants"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">
<caption class="tablecaption"><strong>Table 6-4&nbsp;&nbsp;</strong>Image interpolation constants</caption>

<tr>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Interpolation constant</p></th>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th>
</tr>


<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_463"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSGraphicsContext_Class/Reference/Reference.html#//apple_ref/c/econst/NSImageInterpolationDefault" target="_top">NSImageInterpolationDefault</a></code></p></td>
<td ><p>Use the context’s default interpolation.</p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_464"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSGraphicsContext_Class/Reference/Reference.html#//apple_ref/c/econst/NSImageInterpolationNone" target="_top">NSImageInterpolationNone</a></code></p></td>
<td ><p>No interpolation.</p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_465"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSGraphicsContext_Class/Reference/Reference.html#//apple_ref/c/econst/NSImageInterpolationLow" target="_top">NSImageInterpolationLow</a></code></p></td>
<td ><p>Fast, low-quality interpolation.</p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_466"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSGraphicsContext_Class/Reference/Reference.html#//apple_ref/c/econst/NSImageInterpolationHigh" target="_top">NSImageInterpolationHigh</a></code></p></td>
<td ><p>Slower, higher-quality interpolation.</p></td>
</tr>

</table></div>
<p>The preceding interpolation settings control both the quality and the speed of the interpolation algorithm. To change the current interpolation setting, use the <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_467"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSGraphicsContext_Class/Reference/Reference.html#//apple_ref/occ/instm/NSGraphicsContext/setImageInterpolation:" target="_top">setImageInterpolation:</a></code> method of <code>NSGraphicsContext</code>.</p>
<div class="notebox"><a name="//apple_ref/doc/uid/TP40003290-CH208-SW14" title="Note"></a><p><strong>Note:</strong>&nbsp;Scaling affects the in-memory copy of image data only. It does not change data stored on-disk.</p></div>
<p>With data retention disabled in an image, scaling the image multiple times can seriously degrade the resulting image quality. Making an image smaller through scaling is a lossy operation. If you subsequently make the image larger again by scaling, the results are based on the scaled-down version of the image. </p>
<p>If you need several different sizes of an image, you might want to create multiple image representation objects, one for each size, to avoid any lossy behavior. Alternatively, you can use the <code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/instm/NSImage/setDataRetained:" target="_top">setDataRetained:</a></code> method to ensure that the caching system has access to the original image data. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH208-BCIBCHBA" title="Image Coordinate Systems"></a><h3>Image Coordinate Systems</h3><p>Like views, <code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/cl/NSImage" target="_top">NSImage</a></code> objects use their own coordinate system to manage their content, which in this case is the image data itself. This internal coordinate system is independent of any containing views into which the image is drawn. Although you might think understanding this coordinate system is important for drawing images in your views, it actually is not. The purpose of the internal coordinate system is to orient the image data itself. As a result, the only time you should ever need to know about this internal coordinate system is when you create a new image by locking focus on an <code>NSImage</code> object and drawing into it.</p><p>Image objects have two possible orientations: standard and flipped. When you create a new, empty <code>NSImage</code> object, you can set the orientation based on how you want to draw the image data. By default, images use the standard Cartesian (unflipped) coordinate system, but you can force them to use a flipped coordinate system by calling the <code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/instm/NSImage/setFlipped:" target="_top">setFlipped:</a></code> method of <code>NSImage</code> prior to drawing. You must always set the image orientation before you lock focus on the image and start drawing though. Changing the orientation of the coordinate system after a <code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/instm/NSImage/lockFocus" target="_top">lockFocus</a></code> call has no effect. In addition, calling the <code>setFlipped:</code> method after you unlock focus again may not have the desired results and should be avoided.</p><p>When drawing images in your view, you can think of the image as just a rectangle with some data in it. Regardless of the orientation of its internal coordinate system, you always place an image relative to the current view’s coordinate system. <span class="content_text">Figure 6-1</span> shows two images drawn in an unflipped view. The code used to draw each image uses the coordinate points shown in the figure, which are in the view’s (unflipped) coordinate system. Because the first image uses a flipped coordinate system internally, however, it draws its content upside down. </p><br/><div><a name="//apple_ref/doc/uid/TP40003290-CH208-BCIEJDCJ" title="Figure 6-1Image orientation in an unflipped view"></a><p><strong>Figure 6-1&nbsp;&nbsp;</strong>Image orientation in an unflipped view</p><img src = "../art/flipped_images.jpg" alt = "Image orientation in an unflipped view" ></div><br/><a name="//apple_ref/doc/uid/TP40003290-CH208-SW7" title="Drawing Versus Compositing"></a><h3>Drawing Versus Compositing</h3><p>The <code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/cl/NSImage" target="_top">NSImage</a></code> class offers different groups of methods to facilitate drawing your images to the current context. The two main groups of methods can be generally categorized as the “drawing” versus “compositing” methods. There are three “drawing” methods of <code>NSImage</code>:</p><ul class="spaceabove"><li class="li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/instm/NSImage/drawAtPoint:fromRect:operation:fraction:" target="_top">drawAtPoint:fromRect:operation:fraction:</a></code></p></li><li class="li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/instm/NSImage/drawInRect:fromRect:operation:fraction:" target="_top">drawInRect:fromRect:operation:fraction:</a></code></p></li><li class="li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/instm/NSImage/drawRepresentation:inRect:" target="_top">drawRepresentation:inRect:</a></code></p></li></ul><p>The drawing methods are among the most commonly-used methods of <code>NSImage</code> because of their basic safety. Images are typically rendered in offscreen windows and then copied to the screen as needed. In some cases, several images may be composited into the same window for efficiency reasons. The draw methods use extra safety checking to ensure that only the contents of the current image are ever drawn in one of your views. The same is not true of compositing methods, of which there are the following:</p><ul class="spaceabove"><li class="li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/instm/NSImage/compositeToPoint:operation:" target="_top">compositeToPoint:operation:</a></code></p></li><li class="li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/instm/NSImage/compositeToPoint:fromRect:operation:" target="_top">compositeToPoint:fromRect:operation:</a></code></p></li><li class="li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/instm/NSImage/compositeToPoint:fromRect:operation:fraction:" target="_top">compositeToPoint:fromRect:operation:fraction:</a></code></p></li><li class="li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/instm/NSImage/compositeToPoint:operation:fraction:" target="_top">compositeToPoint:operation:fraction:</a></code></p></li></ul><p>These methods can be more efficient than the drawing methods because they perform fewer checks on the image bounds. These methods do have other behaviors that you need to understand, however. The most important behavior is that the compositing methods undo any scale or rotation factors (but not translation factors) applied to the CTM prior to drawing. If you are drawing in a flipped view or manually applied scaling or rotation values to the current context, these methods will ignore those transformations. Although this might seem like a problem, it actually can be a very useful tool. For example, if your program is scaling a graphic element, you might want to add a scale value to your transform to do the scaling (at least temporarily). If your element uses image-based selection handles, you could use the compositing methods to prevent those handles from being scaled along with the rest of your graphic element.</p><p>The other thing to remember about the compositing methods is that none of them allow you to scale your image to a target rectangle. Cocoa composites the entire image (or designated portion thereof) bit-for-bit to the specified location. This is in contrast to the <code>drawInRect:fromRect:operation:fraction:</code> method, which lets you scale all or part of your image to the designated target rectangle in your view. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40003290-CH208-SW15" title="Note"></a><p><strong>Note:</strong>&nbsp;The <code>dissolveToPoint:fraction:</code> and <code>dissolveToPoint:fromRect:fraction:</code> methods behave in a similar manner as the corresponding compositing methods. Their use is generally more limited though and better support for dissolving images is available through Core Image.</p></div>
<a name="//apple_ref/doc/uid/TP40003290-CH208-BCIIFBJG" title="Supported Image File Formats"></a><h2>Supported Image File Formats</h2>
<p>Cocoa supports many common <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_468"></a>image formats internally and can import <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_469"></a><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_470"></a>image data from many more formats through the use of the Image I/O framework (<code>ImageIO.framework</code>). </p>
<a name="//apple_ref/doc/uid/TP40003290-CH208-SW16" title="Basic Formats"></a><h3>Basic Formats</h3>
<p><span class="content_text">Table 6-5</span> lists the formats supported natively by Cocoa. (Uppercase versions of the filename extensions are also recognized.)</p>
<a name="//apple_ref/doc/uid/TP40003290-CH208-BCICJBDE" title="Table 6-5Cocoa supported file formats"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">
<caption class="tablecaption"><strong>Table 6-5&nbsp;&nbsp;</strong>Cocoa supported file formats</caption>

<tr>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Format</p></th>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Filename extensions</p></th>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>UTI</p></th>
</tr>


<tr>
<td  scope="row"><p>Portable Document Format (<a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_471"></a>PDF)</p></td>
<td ><p><code>.pdf</code></p></td>
<td ><p><code>com.adobe.pdf</code></p></td>
</tr>
<tr>
<td  scope="row"><p>Encapsulated PostScript (<a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_472"></a>EPS)</p></td>
<td ><p><code>.eps</code>, <code>.epi</code>, <code>.epsf</code>, <code>.epsi</code>, <code>.ps</code></p></td>
<td ><p></p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_473"></a>Tagged Image File Format (<a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_474"></a>TIFF)</p></td>
<td ><p><code>.tiff</code>, <code>.tif</code></p></td>
<td ><p><code>public.tiff</code></p></td>
</tr>
<tr>
<td  scope="row"><p>Joint Photographic Experts Group (<a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_475"></a>JPEG), JPEG-2000</p></td>
<td ><p><code>.jpg</code>, <code>.jpeg</code>, <code>.jpe</code></p></td>
<td ><p><code>public.jpeg</code>, <code>public.jpeg-2000</code></p></td>
</tr>
<tr>
<td  scope="row"><p>Graphic Interchange Format (<a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_476"></a>GIF)</p></td>
<td ><p><code>.gif</code></p></td>
<td ><p><code>com.compuserve.gif</code></p></td>
</tr>
<tr>
<td  scope="row"><p>Portable Network Graphic (<a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_477"></a>PNG)</p></td>
<td ><p><code>.png</code></p></td>
<td ><p><code>public.png</code></p></td>
</tr>
<tr>
<td  scope="row"><p>Macintosh Picture Format (<a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_478"></a>PICT)</p></td>
<td ><p><code>.pict</code>, <code>.pct</code>, <code>.pic</code></p></td>
<td ><p><code>com.apple.pict</code></p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_479"></a>Windows Bitmap Format (<a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_480"></a>DIB)</p></td>
<td ><p><code>.bmp</code>, <code>.BMPf</code></p></td>
<td ><p><code>com.microsoft.bmp</code></p></td>
</tr>
<tr>
<td  scope="row"><p>Windows <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_481"></a>Icon Format </p></td>
<td ><p><code>.ico</code></p></td>
<td ><p><code>com.microsoft.ico</code></p></td>
</tr>
<tr>
<td  scope="row"><p>Icon File Format</p></td>
<td ><p><code>.icns</code></p></td>
<td ><p><code>com.apple.icns</code></p></td>
</tr>

</table></div>
<a name="//apple_ref/doc/uid/TP40003290-CH208-SW17" title="TIFF Compression"></a><h3>TIFF Compression</h3>
<p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_482"></a>TIFF images can be read from compressed data, as long as the compression algorithm is one of the four schemes described in <span class="content_text">Table 6-6</span>. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH208-SW3" title="Table 6-6TIFF compression settings"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">
<caption class="tablecaption"><strong>Table 6-6&nbsp;&nbsp;</strong>TIFF compression settings</caption>

<tr>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Compression</p></th>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th>
</tr>


<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_483"></a>LZW</p></td>
<td ><p>Compresses and decompresses without information loss, achieving compression ratios up to 5:1. It may be somewhat slower to compress and decompress than the PackBits scheme.</p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_484"></a>PackBits</p></td>
<td ><p>Compresses and decompresses without information loss, but may not achieve the same compression ratios as LZW.</p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_485"></a>JPEG</p></td>
<td ><p>JPEG compression is no longer supported in TIFF files, and this factor is ignored.</p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_486"></a>CCITTFAX</p></td>
<td ><p>Compresses and decompresses 1 bit gray-scale images using international fax compression standards CCITT3 and CCITT4.</p></td>
</tr>

</table></div>
<p>An <code>NSImage</code> object can also produce compressed TIFF data using any of these schemes. To get the TIFF data, use the <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_487"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/instm/NSImage/TIFFRepresentationUsingCompression:factor:" target="_top">TIFFRepresentationUsingCompression:factor:</a></code> method of <code>NSImage</code>. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH208-SW18" title="Support for Other File Formats"></a><h3>Support for Other File Formats</h3>
<p>In Mac OS X v10.4 and later, <code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/cl/NSImage" target="_top">NSImage</a></code> supports many additional file formats using the <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_488"></a>Image I/O framework. To get a complete list of supported filename extensions, use the <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_489"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/clm/NSImage/imageFileTypes" target="_top">imageFileTypes</a></code> class method of <code>NSImage</code>. The list of supported file formats continues to grow but <span class="content_text">Table 6-7</span> lists some of the more common formats that can be imported. </p><a name="//apple_ref/doc/uid/TP40003290-CH208-BCIICCCC" title="Table 6-7Additional formats supported by Cocoa"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5">
<caption class="tablecaption"><strong>Table 6-7&nbsp;&nbsp;</strong>Additional formats supported by Cocoa</caption>

<tr>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Type</p></th>
<th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Filename extension</p></th>
</tr>


<tr>
<td  scope="row"><p>Adobe <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_490"></a>RAW</p></td>
<td ><p><code>.dng</code></p></td>
</tr>
<tr>
<td  scope="row"><p>Canon 2 RAW</p></td>
<td ><p><code>.cr2</code></p></td>
</tr>
<tr>
<td  scope="row"><p>Canon RAW</p></td>
<td ><p><code>.crw</code></p></td>
</tr>
<tr>
<td  scope="row"><p>FlashPix</p></td>
<td ><p><code>.fpx</code>, <code>.fpix</code></p></td>
</tr>
<tr>
<td  scope="row"><p>Fuji RAW</p></td>
<td ><p><code>.raf</code></p></td>
</tr>
<tr>
<td  scope="row"><p>Kodak RAW</p></td>
<td ><p><code>.dcr</code></p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_491"></a>MacPaint</p></td>
<td ><p><code>.ptng</code>, <code>.pnt</code>, <code>.mac</code></p></td>
</tr>
<tr>
<td  scope="row"><p>Minolta RAW</p></td>
<td ><p><code>.mrw</code></p></td>
</tr>
<tr>
<td  scope="row"><p>Nikon RAW</p></td>
<td ><p><code>.nef</code></p></td>
</tr>
<tr>
<td  scope="row"><p>Olympus RAW</p></td>
<td ><p><code>.orf</code></p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_492"></a>OpenEXR</p></td>
<td ><p><code>.exr</code></p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_493"></a>Photoshop</p></td>
<td ><p><code>.psd</code></p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_494"></a>QuickTime Import Format</p></td>
<td ><p><code>.qti</code>, <code>.qtif</code></p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_495"></a>Radiance</p></td>
<td ><p><code>.hdr</code></p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_496"></a>SGI</p></td>
<td ><p><code>.sgi</code></p></td>
</tr>
<tr>
<td  scope="row"><p>Sony RAW</p></td>
<td ><p><code>.srf</code></p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_497"></a>Targa</p></td>
<td ><p><code>.targa</code>, <code>.tga</code></p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_498"></a>Windows Cursor</p></td>
<td ><p><code>.cur</code></p></td>
</tr>
<tr>
<td  scope="row"><p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_499"></a>XWindow bitmap</p></td>
<td ><p><code>.xbm</code></p></td>
</tr>

</table></div>
<p>The Image I/O framework is part of Quartz, although the actual framework is part of the <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_500"></a>Application Services framework. Image I/O handles the importing and exporting of many file formats. To use Quartz directly, you read image data using the <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_501"></a><code><a href="../../../../GraphicsImaging/Reference/CGImageSource/Reference/reference.html#//apple_ref/c/tdef/CGImageSourceRef" target="_top">CGImageSourceRef</a></code> opaque type and write using the <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_502"></a><code><a href="../../../../GraphicsImaging/Reference/CGImageDestination/Reference/reference.html#//apple_ref/c/tdef/CGImageDestinationRef" target="_top">CGImageDestinationRef</a></code> type. For more information on using the Image I/O framework to read and write images, see <em><a href="../../../../GraphicsImaging/Reference/CGImageSource/index.html#//apple_ref/doc/uid/TP40001399" target="_top">CGImageSource Reference</a></em> and <em><a href="../../../../GraphicsImaging/Reference/CGImageDestination/index.html#//apple_ref/doc/uid/TP40001400" target="_top">CGImageDestination Reference</a></em>. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH208-SW19" title="Guidelines for Using Images"></a><h2>Guidelines for Using Images</h2>
<p>Here are some guidelines to help you work with <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_503"></a>images more effectively:</p>
<ul class="ul"><li class="li"><p>Use the <code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/cl/NSImage" target="_top">NSImage</a></code> interface whenever possible. The goal of <code>NSImage</code> is to simplify your interactions with image data. Working directly with image representations should be done only as needed.</p></li>
<li class="li"><p>Treat <code>NSImage</code> and its image representations as immutable objects. The goal of <code>NSImage</code> is to provide an efficient way to display images on the target canvas. Avoid manipulating the data of an <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_504"></a>image representation directly, especially if there are alternatives to manipulating the data, such as compositing the image and some other content into a new image object. </p></li>
<li class="li"><p>For screen-based drawing, it is best to use the built-in caching mechanism of <code>NSImage</code>. Using an <code>NSCachedImageRep</code> object is more efficient than an <code>NSBitmapImageRep</code> object with the same data. Cached image representations store image data using a <code>CGImageRef</code> object, which can be stored directly on the video card by Quartz. </p></li>
<li class="li"><p>There is little benefit to storing multiple <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_505"></a>representations of the same image (possibly at different sizes) in a single <code>NSImage</code>. Modern hardware is powerful enough to resize and scale images quickly. The only reason to consider storing multiple representations is if each of those representations contains a customized version of the image. </p></li><li class="li"><p>If caching is enabled and you modify an image representation object directly, be sure to invoke the <code>recache</code> method of the owning <code>NSImage</code> object. Cocoa relies on cached content wherever possible to improve performance and does not automatically recreate its caches when you modify image representations. You must tell the image object to recreate its caches explicitly. </p></li><li class="li"><p>Avoid recreating art that is already provided by the system. Mac OS X makes several standard<a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_506"></a><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_507"></a> pieces of artwork available for inclusion in your own interfaces. This artwork ranges from standard icons to other elements you can integrate into your controls. You load standard images using the <code>imageNamed:</code> method. For a list of standard artwork, see the constants section in <em><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/index.html#//apple_ref/doc/uid/TP40004051" target="_top">NSImage Class Reference</a></em>. </p></li></ul><p>Mac OS X defines several technologies for working with images. Although the <code>NSImage</code> class is a good general purpose class for creating, manipulating, and drawing images, there may be times when it might be easier or more efficient to use other imaging technologies. For example, rather than manually dissolving from one image to another by drawing partially transparent versions of each image over time, it would be more efficient to use Core Image to perform the dissolve operation for you. For information about other image technologies, and when you might use them, see <span class="content_text"><a href="../QuartzOpenGL/QuartzOpenGL.html#//apple_ref/doc/uid/TP40003290-CH211-SW2">“Choosing the Right Imaging Technology.”</a></span> </p>
<a name="//apple_ref/doc/uid/TP40003290-CH208-SW20" title="Creating NSImage Objects"></a><h2>Creating NSImage Objects</h2>
<p>Before you can draw an image, you have to create or load the image data. Cocoa supports several techniques for creating new images and loading existing images. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH208-SW21" title="Loading an Existing Image"></a><h3>Loading an Existing Image</h3>
<p>For existing <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_508"></a>images, you can load the image directly from a file or URL using the methods of <code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/cl/NSImage" target="_top">NSImage</a></code>. When you open an image file, <code>NSImage</code> automatically creates an image representation that best matches the type of data in that file. Cocoa supports numerous file formats internally. In Mac OS X v10.4 and later, Cocoa supports even more file formats using the Image I/O framework. For information on supported file types, see <span class="content_text"><a href="Images.html#//apple_ref/doc/uid/TP40003290-CH208-BCIIFBJG">“Supported Image File Formats.”</a></span> </p>
<p>The following example shows how to load an existing image from a file. It is important to remember that images loaded from an existing file are intended primarily for rendering. If you want to manipulate the data directly, copy it to an offscreen window or other local data structure and manipulate it there. </p>
<div class="codesample"><table><tr><td scope="row"><pre>NSString* imageName = [[NSBundle mainBundle]<span></span></pre></td></tr><tr><td scope="row"><pre>                    pathForResource:@"image1" ofType:@"JPG"];<span></span></pre></td></tr><tr><td scope="row"><pre>NSImage* tempImage = [[NSImage alloc] initWithContentsOfFile:imageName];<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40003290-CH208-SW22" title="Loading a Named Image"></a><h3>Loading a Named Image</h3><p>For frequently used <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_509"></a><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_510"></a>images, you can use the Application Kit’s named image registry to load and store them. This registry provides a fast and convenient way to retrieve images without creating a new <code>NSImage</code> object each time. You can add images to this registry explicitly or you can use the registry itself to load known system or application-specific images, such as the following:</p><ul class="spaceabove"><li class="li"><p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_511"></a>System images stored in the <code>Resources</code> directory of the Application Kit framework </p></li><li class="li"><p>Your <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_512"></a>application’s icon or other images located in the <code>Resources</code> directory of your main bundle.</p></li></ul><p>To retrieve images from the registry, you use the <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_513"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/clm/NSImage/imageNamed:" target="_top">imageNamed:</a></code> class method of <code>NSImage</code>. This method looks in the registry for an image associated with the name you provide. If none is found, it looks for the image among the Application Kit's shared resources. After that, it looks for a file in the <code>Resources</code> directory of your application bundle, and finally it checks the Application Kit bundle. If it finds an image file, it loads the image, adds it to the registry, and returns the corresponding <code>NSImage</code> object. As long as the corresponding image object is retained somewhere by your code, subsequent attempts to retrieve the same image file return the already-loaded <code>NSImage</code> object.</p><p>To retrieve your application icon, ask for an image with the name <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_514"></a><code>NSApplicationIcon</code>. Your application's custom icon is returned, if it has one; otherwise, Cocoa returns the generic application icon provided by the system. For a list of image names you can use to load other standard system images, see the constants section in <em><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/index.html#//apple_ref/doc/uid/TP40004051" target="_top">NSImage Class Reference</a></em>. </p><p>In addition to loading existing image files, you can also add <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_515"></a>images to the registry explicitly by sending a <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_516"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/instm/NSImage/setName:" target="_top">setName:</a></code> message to an <code>NSImage</code> object. The <code>setName:</code> method adds the image to the registry under the designated name. You might use this method in cases where the image was created dynamically or is not located in your application bundle. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40003290-CH208-SW23" title="Note"></a><p><strong>Note:</strong>&nbsp;When adding images to the <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_517"></a>registry explicitly, choose a name that does not match the name of any image in your application bundle. If you choose a name that is used by a bundle resource, the explicitly added image supersedes that resource. You can still load the resource using the methods of <code><a href="../../../Reference/Foundation/Classes/NSBundle_Class/Reference/Reference.html#//apple_ref/occ/cl/NSBundle" target="_top">NSBundle</a></code>, however.</p></div>
<a name="//apple_ref/doc/uid/TP40003290-CH208-BCIBFFII" title="Drawing to an Image"></a><h3>Drawing to an Image</h3>
<p>It is possible to create <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_518"></a><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_519"></a>images programmatically by locking focus on an <code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/cl/NSImage" target="_top">NSImage</a></code> object and drawing other images or paths into the image context. This technique is most useful for creating images that you intend to render to the screen, although you can also save the resulting image data to a file. </p>
<p><span class="content_text">Listing 6-1</span> shows you how to create a new empty image and configure it for drawing. When creating a blank image, you must specify the size of the new image in pixels. If you <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_520"></a><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_521"></a>lock focus on an image that contains existing content, the new content is composited with the old content. When drawing, you can use any routines that you would normally use when drawing to a view. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH208-BCIDJAJF" title="Listing 6-1Drawing to an image"></a><p class="codesample"><strong>Listing 6-1&nbsp;&nbsp;</strong>Drawing to an image</p><div class="codesample"><table><tr><td scope="row"><pre>NSImage* anImage = [[NSImage alloc] initWithSize:NSMakeSize(100.0,  100.0)];<span></span></pre></td></tr><tr><td scope="row"><pre>[anImage lockFocus];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Do your drawing here...<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>[anImage unlockFocus];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Draw the image in the current context.<span></span></pre></td></tr><tr><td scope="row"><pre>[anImage drawAtPoint:NSMakePoint(0.0, 0.0)<span></span></pre></td></tr><tr><td scope="row"><pre>            fromRect: NSMakeRect(0.0, 0.0, 100.0, 100.0)<span></span></pre></td></tr><tr><td scope="row"><pre>            operation: NSCompositeSourceOver<span></span></pre></td></tr><tr><td scope="row"><pre>            fraction: 1.0];<span></span></pre></td></tr></table></div>
<p>Drawing to an image creates an <code><a href="../../../Reference/ApplicationKit/Classes/NSCachedImageRep_Class/Reference/Reference.html#//apple_ref/occ/cl/NSCachedImageRep" target="_top">NSCachedImageRep</a></code> object or uses an existing cached image representation, if one exists. Even when you use the <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_522"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/instm/NSImage/lockFocusOnRepresentation:" target="_top">lockFocusOnRepresentation:</a></code> method to lock onto a specific image representation, you do not lock onto the representation itself. Instead, you lock onto the cached offscreen window associated with that image representation. This behavior might seem confusing but reinforces the notion of the immutability of images and their image representations. </p>
<p>Images and their representations are considered <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_523"></a>immutable for efficiency and safety reasons. If you consider the image files stored in your application bundle, would you really want to make permanent changes to the original image? Rather than change the original image data, <code>NSImage</code> and its image representations modify a copy of that data. Modifying a cached copy of the data is also more efficient for screen-based drawing because the data is already in a format ready for display on the screen.</p>
<a name="//apple_ref/doc/uid/TP40003290-CH208-BCICHFGA" title="Creating a Bitmap"></a><h3>Creating a Bitmap</h3>
<p>There are a few different ways to create <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_524"></a><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_525"></a>bitmaps in Cocoa. Some of these techniques are more convenient than others and some may not be available in all versions of Mac OS X, so you should consider each one carefully. The following list summarizes the most common techniques and the situations in which you might use them:</p>
<ul class="spaceabove"><li class="li"><p>To create a bitmap from the contents of an existing <code>CIImage</code> object (in Mac OS X v10.5 and later), use the <code><a href="../../../Reference/ApplicationKit/Classes/NSBitmapImageRep_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBitmapImageRep/initWithCIImage:" target="_top">initWithCIImage:</a></code> method of <code>NSBitmapImageRep</code>.</p></li><li class="li"><p>To create a bitmap from the contents of a Quartz image (in Mac OS X v10.5 and later), use the <code><a href="../../../Reference/ApplicationKit/Classes/NSBitmapImageRep_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBitmapImageRep/initWithCGImage:" target="_top">initWithCGImage:</a></code> method of <code>NSBitmapImageRep</code>. When initializing bitmaps using this method, you should treat the returned bitmap as a read-only object. In addition, you should avoid accessing the bitmap data directly, as doing so requires the unpacking of the <code><a href="../../../../GraphicsImaging/Reference/CGImage/Reference/reference.html#//apple_ref/c/tdef/CGImageRef" target="_top">CGImageRef</a></code> data into a separate set of buffers.</p></li><li class="li"><p>To capture the contents of an existing view or image, use one of the following techniques: </p><ul class="nested"><li class="nested li"><p>Lock focus on the desired object and use the <code><a href="../../../Reference/ApplicationKit/Classes/NSBitmapImageRep_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBitmapImageRep/initWithFocusedViewRect:" target="_top">initWithFocusedViewRect:</a></code> method of <code>NSBitmapImageRep</code>.</p></li><li class="nested li"><p>In Mac OS X v10.4 and later, use the <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/bitmapImageRepForCachingDisplayInRect:" target="_top">bitmapImageRepForCachingDisplayInRect:</a></code> and <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_526"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/cacheDisplayInRect:toBitmapImageRep:" target="_top">cacheDisplayInRect:toBitmapImageRep:</a></code> methods of <code>NSView</code>. The first method creates a bitmap image representation suitable for use in capturing the view's contents while the second draws the view contents to the bitmap. You can reuse the bitmap image representation object to update the view contents periodically, as long as you remember to clear the old bitmap before capturing a new one. </p></li></ul></li>
<li class="li"><p>To draw directly into a bitmap, create a new <code>NSBitmapImageRep</code> object with the parameters you want and use the <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_527"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSGraphicsContext_Class/Reference/Reference.html#//apple_ref/occ/clm/NSGraphicsContext/graphicsContextWithBitmapImageRep:" target="_top">graphicsContextWithBitmapImageRep:</a></code> method of <code>NSGraphicsContext</code> to create a drawing context. Make the new context the current context and draw. This technique is available only in Mac OS X v10.4 and later.</p><p>Alternatively, you can create an <code>NSImage</code> object (or an offscreen window), draw into it, and then capture the image contents. This technique is supported in all versions of Mac OS X.</p></li>
<li class="li"><p>To create the bitmap bit-by-bit, create a new <code>NSBitmapImageRep</code> object with the parameters you want and manipulate the pixels directly. You can use the <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_528"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBitmapImageRep_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBitmapImageRep/bitmapData" target="_top">bitmapData</a></code> method to get the raw pixel buffer. <code>NSBitmapImageRep</code> also defines methods for getting and setting individual pixel values. This technique is the most labor intensive but gives you the most control over the bitmap contents. For example, you might use it if you want to decode the raw image data yourself and transfer it to the bitmap image representation.</p></li></ul>
<p>The sections that follow provide examples on how to use the first two techniques from the preceding list. For information on how to manipulate a bitmap, see <em><a href="../../../Reference/ApplicationKit/Classes/NSBitmapImageRep_Class/index.html#//apple_ref/doc/uid/TP40004009" target="_top">NSBitmapImageRep Class Reference</a></em>. </p>
<div class="importantbox"><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_13" title="Important:"></a><p><strong>Important:</strong>&nbsp;
In many operating systems, offscreen bitmaps are used to buffer the actual content of a view or window. In Mac OS X, you should generally not use <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_529"></a>offscreen bitmaps in this way. Most Mac OS X windows are already double-buffered to prevent rendering artifacts caused by drawing during a refresh cycle. Adding your own offscreen bitmap would result in your window being triple-buffered, which is a waste of memory.</p><p></p></div>
<a name="//apple_ref/doc/uid/TP40003290-CH208-BCIIIJFB" title="Capturing the Contents of a View or Image"></a><h4>Capturing the Contents of a View or Image</h4>
<p>A simple way to create a bitmap is to capture the contents of an existing <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_530"></a>view or <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_531"></a>image. When capturing a view, the view can either belong to an onscreen window or be completely detached and not onscreen at all. When capturing an image, Cocoa chooses the image representation that provides the best match for your target bitmap.</p><p>Before attempting to capture the contents of a view, you should consider invoking the view’s <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/canDraw" target="_top">canDraw</a></code> method to see if the view should be drawn. Cocoa views return <code>NO</code> from this method in situations where the view is currently hidden or not associated with a valid window. If you are trying to capture the current state of a view, you might use the <code>canDraw</code> method to prevent your code from capturing the view when it is hidden.  </p>
<p>Once you have your view or image, lock focus on it and use the <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_532"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSBitmapImageRep_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBitmapImageRep/initWithFocusedViewRect:" target="_top">initWithFocusedViewRect:</a></code> method of <code>NSBitmapImageRep</code> to capture the contents. When using this method, you specify the exact rectangle you want to capture from the view or image. Thus, you can capture all of the contents or only a portion; you cannot scale the content you capture. The <code>initWithFocusedViewRect:</code> method captures the bits exactly as they appear in the focused image or view. </p>
<p><span class="content_text">Listing 6-2</span> shows how to create a bitmap representation from an existing image. The example gets the image to capture from a custom routine, locks focus on it, and creates the <code>NSBitmapImageRep</code> object. Your own implementation would need to replace the call to <code>myGetCurrentImage</code> with the code to create or get the image used by your program.</p>
<a name="//apple_ref/doc/uid/TP40003290-CH208-BCIBJDDC" title="Listing 6-2Capturing the contents of an existing image"></a><p class="codesample"><strong>Listing 6-2&nbsp;&nbsp;</strong>Capturing the contents of an existing image</p><div class="codesample"><table><tr><td scope="row"><pre>NSImage* image = [self myGetCurrentImage];<span></span></pre></td></tr><tr><td scope="row"><pre>NSSize size = [image size];<span></span></pre></td></tr><tr><td scope="row"><pre>[image lockFocus];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>NSBitmapImageRep* rep = [[NSBitmapImageRep alloc] initWithFocusedViewRect:<span></span></pre></td></tr><tr><td scope="row"><pre>                        NSMakeRect(0,0,size.width,size.height)];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>[image unlockFocus];<span></span></pre></td></tr></table></div>
<p>To capture the content of an onscreen view, you would use code very much like the preceding example. After locking focus on the view, you would create your <code>NSBitmapImageRep</code> object using the <code>initWithFocusedViewRect:</code> method.</p>
<p>To capture the content of a detached (<a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_533"></a>offscreen) view, you must create an <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_534"></a>offscreen window for the view before you try to capture its contents. The window object provides a backing buffer in which to hold the view’s rendered content. As long as you do not order the window onto the screen, the origin you specify for your window does not really matter. The example in <span class="content_text">Listing 6-3</span> uses large negative values for the origin coordinates (just to make sure the window is not visible) but could just as easily use the coordinate (0, 0). </p>
<a name="//apple_ref/doc/uid/TP40003290-CH208-BCIIHCCE" title="Listing 6-3Drawing to an offscreen window"></a><p class="codesample"><strong>Listing 6-3&nbsp;&nbsp;</strong>Drawing to an offscreen window</p><div class="codesample"><table><tr><td scope="row"><pre>NSRect offscreenRect = NSMakeRect(-10000.0, -10000.0,<span></span></pre></td></tr><tr><td scope="row"><pre>                            windowSize.width, windowSize.height);<span></span></pre></td></tr><tr><td scope="row"><pre>NSWindow* offscreenWindow = [[NSWindow alloc]<span></span></pre></td></tr><tr><td scope="row"><pre>                initWithContentRect:offscreenRect<span></span></pre></td></tr><tr><td scope="row"><pre>                styleMask:NSBorderlessWindowMask<span></span></pre></td></tr><tr><td scope="row"><pre>                backing:NSBackingStoreRetained<span></span></pre></td></tr><tr><td scope="row"><pre>                defer:NO];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>[offscreenWindow setContentView:myView];<span></span></pre></td></tr><tr><td scope="row"><pre>[[offscreenWindow contentView] display]; // Draw to the backing  buffer<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Create the NSBItmapImageRep<span></span></pre></td></tr><tr><td scope="row"><pre>[[offscreenWindow contentView] lockFocus];<span></span></pre></td></tr><tr><td scope="row"><pre>NSBitmapImageRep* rep = [[NSBitmapImageRep alloc] initWithFocusedViewRect:<span></span></pre></td></tr><tr><td scope="row"><pre>                NSMakeRect(0, 0, windowSize.width, windowSize.height)];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Clean up and delete the window, which is no longer needed.<span></span></pre></td></tr><tr><td scope="row"><pre>[[offscreenWindow contentView] unlockFocus];<span></span></pre></td></tr><tr><td scope="row"><pre>[offscreenWindow release];<span></span></pre></td></tr></table></div>
<a name="//apple_ref/doc/uid/TP40003290-CH208-BCIIAECF" title="Drawing Directly to a Bitmap"></a><h4>Drawing Directly to a Bitmap</h4>
<p>In Mac OS X v10.4 and later, it is possible to create a <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_535"></a>bitmap image representation object and draw to it directly. This technique is simple and does not require the creation of any extraneous objects, such as an image or window. If your code needs to run in earlier versions of Mac OS X, however, you cannot use this technique.</p>
<p><span class="content_text">Listing 6-4</span>, creates a new <code>NSBitmapImageRep</code> object with the desired bit depth, resolution, and color space. It then creates a new graphics context object using the bitmap and makes that context the current context. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH208-BCIJGFIE" title="Listing 6-4Drawing directly to a bitmap"></a><p class="codesample"><strong>Listing 6-4&nbsp;&nbsp;</strong>Drawing directly to a bitmap</p><div class="codesample"><table><tr><td scope="row"><pre>NSRect offscreenRect = NSMakeRect(0.0, 0.0, 500.0, 500.0);<span></span></pre></td></tr><tr><td scope="row"><pre>NSBitmapImageRep* offscreenRep = nil;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>offscreenRep = [[NSBitmapImageRep alloc] initWithBitmapDataPlanes:nil<span></span></pre></td></tr><tr><td scope="row"><pre>                        pixelsWide:offscreenRect.size.width<span></span></pre></td></tr><tr><td scope="row"><pre>                        pixelsHigh:offscreenRect.size.height<span></span></pre></td></tr><tr><td scope="row"><pre>                        bitsPerSample:8<span></span></pre></td></tr><tr><td scope="row"><pre>                        samplesPerPixel:4<span></span></pre></td></tr><tr><td scope="row"><pre>                        hasAlpha:YES<span></span></pre></td></tr><tr><td scope="row"><pre>                        isPlanar:NO<span></span></pre></td></tr><tr><td scope="row"><pre>                        colorSpaceName:NSCalibratedRGBColorSpace<span></span></pre></td></tr><tr><td scope="row"><pre>                        bitmapFormat:0<span></span></pre></td></tr><tr><td scope="row"><pre>                        bytesPerRow:(4 * offscreenRect.size.width)<span></span></pre></td></tr><tr><td scope="row"><pre>                        bitsPerPixel:32];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>[NSGraphicsContext saveGraphicsState];<span></span></pre></td></tr><tr><td scope="row"><pre>[NSGraphicsContext setCurrentContext:[NSGraphicsContext<span></span></pre></td></tr><tr><td scope="row"><pre>                        graphicsContextWithBitmapImageRep:offscreenRep]];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Draw your content...<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>[NSGraphicsContext restoreGraphicsState];<span></span></pre></td></tr></table></div>
<p>Once drawing is complete, you can add the bitmap image representation object to an <code>NSImage</code> object and display it like any other image. You can use this image representation object as a texture in your OpenGL code or examine the bits of the bitmap using the methods of <code>NSBitmapImageRep</code>. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH208-SW1" title="Creating a PDF or EPS Image Representation"></a><h3>Creating a PDF or EPS Image Representation</h3>
<p>The process for creating an image representation for <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_536"></a>PDF or <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_537"></a>EPS data is the same for both. In both cases, you use a custom <code>NSView</code> object together with the Cocoa printing system to generate the desired data. From the generated data, you then create an image representation of the desired type. </p>
<p>The <code>NSView</code> class defines two convenience methods for generating data based on the contents of the view: </p>
<ul class="spaceabove"><li class="li"><p>For PDF data, use the <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_538"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/dataWithPDFInsideRect:" target="_top">dataWithPDFInsideRect:</a></code> method of <code>NSView</code>. </p></li>
<li class="li"><p>For EPS data, use the <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_539"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/dataWithEPSInsideRect:" target="_top">dataWithEPSInsideRect:</a></code> method of <code>NSView</code>.</p></li></ul>
<p>When you send one of these messages to your view, Cocoa launches the <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_540"></a><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_541"></a>printing system, which drives the data generation process. The printing system handles most of the data generation process, sending appropriate messages to your view object as needed. For example, Cocoa sends a <code>drawRect:</code> message to your view for each page that needs to be drawn. The printing system also invokes other methods to compute page ranges and boundaries. </p>
<div class="notebox"><a name="//apple_ref/doc/uid/TP40003290-CH208-SW24" title="Note"></a><p><strong>Note:</strong>&nbsp;The <code>NSView</code> class provides a default pagination scheme. To provide a custom scheme, your view must override the <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/knowsPageRange:" target="_top">knowsPageRange:</a></code> and <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/rectForPage:" target="_top">rectForPage:</a></code> methods at a minimum. For more information about printing and pagination, see <em><a href="../../Printing/index.html#//apple_ref/doc/uid/10000083i" target="_top">Printing Programming Topics for Cocoa</a></em>. </p></div>
<p>After the printing system finishes, the code that called either <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/dataWithPDFInsideRect:" target="_top">dataWithPDFInsideRect:</a></code> or <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/dataWithEPSInsideRect:" target="_top">dataWithEPSInsideRect:</a></code> receives an <code>NSData</code> object with the PDF or EPS data. You must then pass this object to the <code>imageRepWithData:</code> method of either <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_542"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSEPSImageRep_Class/Reference/Reference.html#//apple_ref/occ/cl/NSEPSImageRep" target="_top">NSEPSImageRep</a></code> or <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_543"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSPDFImageRep_Class/Reference/Reference.html#//apple_ref/occ/cl/NSPDFImageRep" target="_top">NSPDFImageRep</a></code> to initialize a new image representation object, which you can then add to your <code>NSImage</code> object.</p>
<p><span class="content_text">Listing 6-5</span> shows the basic steps for creating a PDF image from some view content. The view itself must be one that knows how to draw the desired content. This can be a detached view designed solely for drawing the desired content with any desired pagination, or it could be an existing view in one of your windows. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH208-SW4" title="Listing 6-5Creating PDF data from a view"></a><p class="codesample"><strong>Listing 6-5&nbsp;&nbsp;</strong>Creating PDF data from a view</p><div class="codesample"><table><tr><td scope="row"><pre>MyPDFView* myView = GetMyPDFRenderView();<span></span></pre></td></tr><tr><td scope="row"><pre>NSRect viewBounds = [myView bounds];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>NSData* theData = [myView dataWithPDFInsideRect:viewBounds];<span></span></pre></td></tr><tr><td scope="row"><pre>NSPDFImageRep* pdfRep = [NSPDFImageRep imageRepWithData:theData];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Create a new image to hold the PDF representation.<span></span></pre></td></tr><tr><td scope="row"><pre>NSImage* pdfImage = [[NSImage alloc] initWithSize:viewBounds.size];<span></span></pre></td></tr><tr><td scope="row"><pre>[pdfImage addRepresentation:pdfRep];<span></span></pre></td></tr></table></div>
<p>If you choose to use an existing onscreen view, your view’s drawing code should distinguish between content drawn for the screen or for the printing system and adjust content accordingly. Use the <code><a href="../../../Reference/ApplicationKit/Classes/NSGraphicsContext_Class/Reference/Reference.html#//apple_ref/occ/clm/NSGraphicsContext/currentContextDrawingToScreen" target="_top">currentContextDrawingToScreen</a></code> class method or the <code><a href="../../../Reference/ApplicationKit/Classes/NSGraphicsContext_Class/Reference/Reference.html#//apple_ref/occ/instm/NSGraphicsContext/isDrawingToScreen" target="_top">isDrawingToScreen</a></code> instance method of <code>NSGraphicsContext</code> to determine whether the current context is targeted for the screen or a print-based canvas. These methods return <code>NO</code> for operations that generate PDF or EPS data. </p>
<div class="importantbox"><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_14" title="Important:"></a><p><strong>Important:</strong>&nbsp;
When drawing in a <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_544"></a><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_545"></a>printing context, the only supported <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_546"></a>compositing operators are <code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/c/econst/NSCompositeCopy" target="_top">NSCompositeCopy</a></code> and <code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/c/econst/NSCompositeSourceOver" target="_top">NSCompositeSourceOver</a></code>. If you need to render content using any other operators, you must composite them to an image or offscreen window first and then render the resulting image to the printing context using one of the supported operators. </p><p></p></div>
<a name="//apple_ref/doc/uid/TP40003290-CH208-BCIJIGIG" title="Using a Quartz Image to Create an NSImage"></a><h3>Using a Quartz Image to Create an NSImage</h3>
<p>The <code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/cl/NSImage" target="_top">NSImage</a></code> class does not provide any direct means for wrapping data from a <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_547"></a>Quartz <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_548"></a>image object. If you have a <code><a href="../../../../GraphicsImaging/Reference/CGImage/Reference/reference.html#//apple_ref/c/tdef/CGImageRef" target="_top">CGImageRef</a></code> object, the simplest way to create a corresponding Cocoa image is to lock focus on an <code>NSImage</code> object and draw your Quartz image using the <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextDrawImage" target="_top">CGContextDrawImage</a></code> function. The basic techniques for how to do this are covered in <span class="content_text"><a href="Images.html#//apple_ref/doc/uid/TP40003290-CH208-BCIBFFII">“Drawing to an Image.”</a></span> </p>
<a name="//apple_ref/doc/uid/TP40003290-CH208-SW25" title="Working with Images"></a><h2>Working with Images</h2>
<p>Once you have an image, there are many ways you can use it. The simplest thing you can do is draw it into a view as part of your program’s user interface. You can also process the image further by modifying it in any number of ways. The following sections show you how to perform several common tasks associated with images. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH208-BCIIBDAD" title="Drawing Images into a View"></a><h3>Drawing Images into a View</h3>
<p>The <code>NSImage</code> class defines several methods for <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_549"></a><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_550"></a>drawing an image into the current context. The two most commonly used methods are:</p>
<ul class="spaceabove"><li class="li"><p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_551"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/instm/NSImage/drawAtPoint:fromRect:operation:fraction:" target="_top">drawAtPoint:fromRect:operation:fraction:</a></code></p></li>
<li class="li"><p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_552"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/instm/NSImage/drawInRect:fromRect:operation:fraction:" target="_top">drawInRect:fromRect:operation:fraction:</a></code></p></li></ul>
<p>These methods offer a simple interface for rendering your images, but more importantly, they ensure that only your image content is drawn. Other methods, such as the <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_553"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/instm/NSImage/compositeToPoint:operation:" target="_top">compositeToPoint:operation:</a></code> method and its variants, are fast at drawing images but they do not check the image’s boundaries before drawing. If the drawing rectangle strays outside of the image bounds, it is possible to draw content not belonging to your image. If the image resides on a shared offscreen window, which many do, it is even possible to draw portions of other images. For more information about the differences between these methods, see <span class="content_text"><a href="Images.html#//apple_ref/doc/uid/TP40003290-CH208-SW7">“Drawing Versus Compositing.”</a></span>  </p>
<p>With one exception, all of the drawing and compositing methods choose the image representation that is best suited for the target canvas—see <span class="content_text"><a href="Images.html#//apple_ref/doc/uid/TP40003290-CH208-BCIGEIFF">“How an Image Representation Is Chosen.”</a></span> The one exception is the <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_554"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/instm/NSImage/drawRepresentation:inRect:" target="_top">drawRepresentation:inRect:</a></code> method, which uses the image representation object you specify. For more information about the use of these methods, see the <code>NSImage</code> reference. </p>
<p>Images support the same set of compositing options as other Cocoa content, with the same results. For a complete list of compositing options and an illustration of their effects, see <span class="content_text"><a href="../GraphicsContexts/GraphicsContexts.html#//apple_ref/doc/uid/TP40003290-CH203-BCIDBEEB">“Setting Compositing Options.”</a></span> </p><a name="//apple_ref/doc/uid/TP40003290-CH208-SW35" title="Drawing Resizable Textures Using Images"></a><h3>Drawing Resizable Textures Using Images</h3><p>If you are implementing a resizable custom control and want the control to have a textured background that does not distort as the control is resized, you would typically break up the background portion into several different images and composite them together. Although some of the images would contain fixed size content, others would need to be designed to present a smooth texture even after being resized or tiled. When it comes time to draw the images, however, you should avoid doing the drawing yourself. Instead, you should use the following AppKit functions, which were introduced in Mac OS X v10.5:</p><ul class="spaceabove"><li class="li"><p><code><a href="../../../Reference/ApplicationKit/Miscellaneous/AppKit_Functions/Reference/reference.html#//apple_ref/c/func/NSDrawThreePartImage" target="_top">NSDrawThreePartImage</a></code></p></li><li class="li"><p><code><a href="../../../Reference/ApplicationKit/Miscellaneous/AppKit_Functions/Reference/reference.html#//apple_ref/c/func/NSDrawNinePartImage" target="_top">NSDrawNinePartImage</a></code></p></li></ul><p>Drawing multipart images cleanly on high resolution screens can be very challenging. If you are not careful about aligning images correctly on integral boundaries, the resulting texture might contain pixel cracks or other visual artifacts. The AppKit functions take into account all of the factors required to draw multipart images correctly in any situation, including situations where resolution independence scale factors other than 1.0 are in use. </p><p><span class="content_text">Figure 6-2</span> shows how you assemble a three-part image for a horizontally resizable control. The two end caps are fixed size images that provide the needed decoration for the edges of the background. The center fill portion then resizes appropriately to fit the bounding rectangle you pass into the <code>NSDrawThreePartImage</code> function.  (If you wanted the control to be resizable in the vertical direction, you would stack these images vertically instead of horizontally.) After drawing the background with this function, you would then layer any additional content on top of the background as needed.</p><br/><div><a name="//apple_ref/doc/uid/TP40003290-CH208-SW33" title="Figure 6-2Drawing a three-part image"></a><p><strong>Figure 6-2&nbsp;&nbsp;</strong>Drawing a three-part image</p><img src = "../art/NSDrawThree.jpg" alt = "Drawing a three-part image" ></div><br/><p><span class="content_text">Figure 6-3</span> shows you how to assemble a nine-part image for a control that can be resized both vertically and horizontally. In this case, the size of the corner pieces stays fixed but the five remaining fill images vary in size to fit the current bounding rectangle. </p><br/><div><a name="//apple_ref/doc/uid/TP40003290-CH208-SW34" title="Figure 6-3Drawing a nine-part image"></a><p><strong>Figure 6-3&nbsp;&nbsp;</strong>Drawing a nine-part image</p><img src = "../art/NSDrawNine.jpg" alt = "Drawing a nine-part image" ></div><br/><p>For more information about these functions, see their descriptions in <em><a href="../../../Reference/ApplicationKit/Miscellaneous/AppKit_Functions/index.html#//apple_ref/doc/uid/TP40004154" target="_top">Application Kit Functions Reference</a></em>. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH208-SW26" title="Creating an OpenGL Texture"></a><h3>Creating an OpenGL Texture</h3>
<p>In <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_555"></a>OpenGL, a <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_556"></a>texture is one way to paint the surface of an object. For complex or photorealistic surfaces, it may be easier to apply a texture than render the same content using primitive shapes. Almost any view or image in Cocoa can be used to create an OpenGL texture. From a view or image, you create a <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_557"></a>bitmap image representation object (as described in <span class="content_text"><a href="Images.html#//apple_ref/doc/uid/TP40003290-CH208-BCIIIJFB">“Capturing the Contents of a View or Image”</a></span>) and then use that object to create your texture. </p>
<p><span class="content_text">Listing 6-6</span> shows a self-contained method for creating a texture from an <code>NSImage</code> object. After creating the <code>NSBitmapImageRep</code> object, this method configures some texture-related parameters, creates a new texture object, and then associates the bitmap data with that object. This method handles 24-bit RGB and 32-bit RGBA images, but you could readily modify it to support other image formats. You must pass in a pointer to a valid <code>GLuint</code> variable for <code>texName</code> but the value stored in that parameter can be <code>0</code>. If you specify a nonzero value, your identifier is associated with the texture object and can be used to identify the texture later; otherwise, an identifier is returned to you in the <code>texName</code> parameter. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH208-BCIIADDA" title="Listing 6-6Creating an OpenGL texture from an image"></a><p class="codesample"><strong>Listing 6-6&nbsp;&nbsp;</strong>Creating an OpenGL texture from an image</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)textureFromImage:(NSImage*)theImg textureName:(GLuint*)texName<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSBitmapImageRep* bitmap = [NSBitmapImageRep alloc];<span></span></pre></td></tr><tr><td scope="row"><pre>    int samplesPerPixel = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    NSSize imgSize = [theImg size];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [theImg lockFocus];<span></span></pre></td></tr><tr><td scope="row"><pre>    [bitmap initWithFocusedViewRect:<span></span></pre></td></tr><tr><td scope="row"><pre>                    NSMakeRect(0.0, 0.0, imgSize.width, imgSize.height)];<span></span></pre></td></tr><tr><td scope="row"><pre>    [theImg unlockFocus];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Set proper unpacking row length for bitmap.<span></span></pre></td></tr><tr><td scope="row"><pre>    glPixelStorei(GL_UNPACK_ROW_LENGTH, [bitmap pixelsWide]);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Set byte aligned unpacking (needed for 3 byte per pixel bitmaps).<span></span></pre></td></tr><tr><td scope="row"><pre>    glPixelStorei (GL_UNPACK_ALIGNMENT, 1);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Generate a new texture name if one was not provided.<span></span></pre></td></tr><tr><td scope="row"><pre>    if (*texName == 0)<span></span></pre></td></tr><tr><td scope="row"><pre>        glGenTextures (1, texName);<span></span></pre></td></tr><tr><td scope="row"><pre>    glBindTexture (GL_TEXTURE_RECTANGLE_EXT, *texName);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Non-mipmap filtering (redundant for texture_rectangle).<span></span></pre></td></tr><tr><td scope="row"><pre>    glTexParameteri(GL_TEXTURE_RECTANGLE_EXT, GL_TEXTURE_MIN_FILTER,  GL_LINEAR);<span></span></pre></td></tr><tr><td scope="row"><pre>    samplesPerPixel = [bitmap samplesPerPixel];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Nonplanar, RGB 24 bit bitmap, or RGBA 32 bit bitmap.<span></span></pre></td></tr><tr><td scope="row"><pre>    if(![bitmap isPlanar] &amp;&amp;<span></span></pre></td></tr><tr><td scope="row"><pre>        (samplesPerPixel == 3 || samplesPerPixel == 4))<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        glTexImage2D(GL_TEXTURE_RECTANGLE_EXT, 0,<span></span></pre></td></tr><tr><td scope="row"><pre>            samplesPerPixel == 4 ? GL_RGBA8 : GL_RGB8,<span></span></pre></td></tr><tr><td scope="row"><pre>            [bitmap pixelsWide],<span></span></pre></td></tr><tr><td scope="row"><pre>            [bitmap pixelsHigh],<span></span></pre></td></tr><tr><td scope="row"><pre>            0,<span></span></pre></td></tr><tr><td scope="row"><pre>            samplesPerPixel == 4 ? GL_RGBA : GL_RGB,<span></span></pre></td></tr><tr><td scope="row"><pre>            GL_UNSIGNED_BYTE,<span></span></pre></td></tr><tr><td scope="row"><pre>            [bitmap bitmapData]);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Handle other bitmap formats.<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Clean up.<span></span></pre></td></tr><tr><td scope="row"><pre>    [bitmap release];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<p>In the preceding code, there are some additional points worth mentioning:</p>
<ul class="spaceabove"><li class="li"><p><code>GL_TEXTURE_RECTANGLE_EXT</code> is used for non–power-of-two texture support, which is not supported on the Rage 128 hardware.</p></li>
<li class="li"><p> The <code>gluScaleImage()</code> function can be used to scale non-PoT textures into PoT dimensions for hardware that doesn't support <code>GL_TEXTURE_RECTANGLE_EXT</code>.</p></li>
<li class="li"><p> When you call this method, the current context must be a valid OpenGL context. For more information about OpenGL graphics contexts, see <span class="content_text"><a href="../QuartzOpenGL/QuartzOpenGL.html#//apple_ref/doc/uid/TP40003290-CH211-BAAECJDJ">“Using OpenGL in Your Application.”</a></span> </p></li><li class="li"><p>Upon completion, the texture is bound to the value in <code>texName</code>. If you specified 0 for the <code>texName</code> parameter, a new texture ID is generated for you and returned in <code>texName</code>. </p></li></ul><p>For more information on Apple's support for OpenGL, see <em><a href="../../../../GraphicsImaging/Conceptual/OpenGL-MacProgGuide/index.html#//apple_ref/doc/uid/TP40001987" target="_top">OpenGL Programming Guide for Mac OS X</a></em>. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH208-BCICGCBI" title="Applying Core Image Filters"></a><h3>Applying Core Image Filters</h3>
<p>In Mac OS X v10.4 and later, <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_558"></a>Core Image <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_559"></a>filters are a fast and efficient way to modify an image without changing the image itself. Core Image filters use graphics acceleration to apply real-time effects such as <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_560"></a>Gaussian blurs, <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_561"></a>distortions, and <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_562"></a>color corrections to an image. Because the filters are applied when content is composited to the screen, they do not modify the actual image data. </p>
<p>Core Image filters operate on <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_563"></a><code><a href="../../../../GraphicsImaging/Reference/QuartzCoreFramework/Classes/CIImage_Class/Reference/Reference.html#//apple_ref/occ/cl/CIImage" target="_top">CIImage</a></code> objects. If you have an existing <code>CIImage</code> object, you can simply apply any desired filters to it and use it to create an <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_564"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSCIImageRep_Class/Reference/Reference.html#//apple_ref/occ/cl/NSCIImageRep" target="_top">NSCIImageRep</a></code> object. You can then add this image representation object to an <code>NSImage</code> object and draw the results in your view. In Mac OS X v10.5 and later, you can also use the <code><a href="../../../Reference/ApplicationKit/Classes/NSBitmapImageRep_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBitmapImageRep/initWithCIImage:" target="_top">initWithCIImage:</a></code> method of <code>NSBitmapImageRep</code> to render already-processed images directly to a bitmap representation. </p>
<p>If you do not already have a <code>CIImage</code> object, you need to create one using your program’s existing content. The first step is to create a bitmap image representation for the content you want to modify, the process for which is described in <span class="content_text"><a href="Images.html#//apple_ref/doc/uid/TP40003290-CH208-BCICHFGA">“Creating a Bitmap.”</a></span> Once you have an <code>NSBitmapImageRep</code> object, use the <code><a href="../../../Reference/ApplicationKit/Classes/CIImage_AppKitAdditions/Reference/Reference.html#//apple_ref/occ/instm/CIImage/initWithBitmapImageRep:" target="_top">initWithBitmapImageRep:</a></code> method of <code>CIImage</code> to create a Core Image image object. </p>
<p>For information on how to apply Core Image filters to a <code>CIImage</code> object, see <span class="content_text"><a href="../../../../GraphicsImaging/Conceptual/CoreImaging/ci_tasks/ci_tasks.html#//apple_ref/doc/uid/TP30001185-CH203" target="_top">Using Core Image Filters</a></span> in <em><a href="../../../../GraphicsImaging/Conceptual/CoreImaging/index.html#//apple_ref/doc/uid/TP30001185" target="_top">Core Image Programming Guide</a></em>. </p><a name="//apple_ref/doc/uid/TP40003290-CH208-SW36" title="Getting and Setting Bitmap Properties"></a><h3>Getting and Setting Bitmap Properties</h3><p>Every <code>NSBitmapImageRep</code> object contains a dictionary that defines the bitmap’s associated properties. These properties identify important information about the bitmap, such as how it was compressed, its color profile (if any), its current gamma level, its associated EXIF data, and so on. When you create a new <code>NSBitmapImageRep</code> from an existing image file, many of these properties are set automatically. You can also access and modify these properties using the <code><a href="../../../Reference/ApplicationKit/Classes/NSBitmapImageRep_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBitmapImageRep/valueForProperty:" target="_top">valueForProperty:</a></code> and <code><a href="../../../Reference/ApplicationKit/Classes/NSBitmapImageRep_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBitmapImageRep/setProperty:withValue:" target="_top">setProperty:withValue:</a></code> methods of <code>NSBitmapImageRep</code>. </p><p>For a complete list of properties you can get and set for a bitmap, see <em><a href="../../../Reference/ApplicationKit/Classes/NSBitmapImageRep_Class/index.html#//apple_ref/doc/uid/TP40004009" target="_top">NSBitmapImageRep Class Reference</a></em>. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH208-SW27" title="Converting a Bitmap to a Different Format"></a><h3>Converting a Bitmap to a Different Format</h3>
<p>The <code>NSBitmapImageRep</code> class provides built-in support for <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_565"></a><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_566"></a>converting <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_567"></a>bitmap data to several standard formats. To convert bitmap images to other formats, you can use any of the following methods:</p>
<ul class="spaceabove"><li class="li"><p> <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_568"></a>+<code><a href="../../../Reference/ApplicationKit/Classes/NSBitmapImageRep_Class/Reference/Reference.html#//apple_ref/occ/clm/NSBitmapImageRep/TIFFRepresentationOfImageRepsInArray:" target="_top">TIFFRepresentationOfImageRepsInArray:</a></code></p></li>
<li class="li"><p> <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_569"></a>+<code><a href="../../../Reference/ApplicationKit/Classes/NSBitmapImageRep_Class/Reference/Reference.html#//apple_ref/occ/clm/NSBitmapImageRep/TIFFRepresentationOfImageRepsInArray:usingCompression:factor:" target="_top">TIFFRepresentationOfImageRepsInArray:usingCompression:factor:</a></code></p></li>
<li class="li"><p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_570"></a>-<code><a href="../../../Reference/ApplicationKit/Classes/NSBitmapImageRep_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBitmapImageRep/TIFFRepresentation" target="_top">TIFFRepresentation</a></code></p></li>
<li class="li"><p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_571"></a>-<code><a href="../../../Reference/ApplicationKit/Classes/NSBitmapImageRep_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBitmapImageRep/TIFFRepresentationUsingCompression:factor:" target="_top">TIFFRepresentationUsingCompression:factor:</a></code></p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_572"></a>+<code><a href="../../../Reference/ApplicationKit/Classes/NSBitmapImageRep_Class/Reference/Reference.html#//apple_ref/occ/clm/NSBitmapImageRep/representationOfImageRepsInArray:usingType:properties:" target="_top">representationOfImageRepsInArray:usingType:properties:</a></code></p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_573"></a>-<code><a href="../../../Reference/ApplicationKit/Classes/NSBitmapImageRep_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBitmapImageRep/representationUsingType:properties:" target="_top">representationUsingType:properties:</a></code></p></li></ul>
<p>The first set of methods generate TIFF data for the bitmap. For all other supported formats, you use the  <code><a href="../../../Reference/ApplicationKit/Classes/NSBitmapImageRep_Class/Reference/Reference.html#//apple_ref/occ/clm/NSBitmapImageRep/representationOfImageRepsInArray:usingType:properties:" target="_top">representationOfImageRepsInArray:usingType:properties:</a></code> and <code><a href="../../../Reference/ApplicationKit/Classes/NSBitmapImageRep_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBitmapImageRep/representationUsingType:properties:" target="_top">representationUsingType:properties:</a></code> methods. These methods support the conversion of bitmap data to BMP, GIF, JPEG, PNG, and TIFF file formats.  </p><p>All of the preceding methods return an <code>NSData</code> object with the formatted image data. You can write this data out to a file or use it to create a new<code>NSBitmapImageRep</code> object. </p><a name="//apple_ref/doc/uid/TP40003290-CH208-SW28" title="Associating a Custom Color Profile With an Image"></a><h3>Associating a Custom Color Profile With an Image</h3><p>You can associate a custom <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_574"></a>ColorSync profile with a <code>NSBitmapImageRep</code> object containing pixel data produced by decoding a TIFF, JPEG, GIF or PNG file. To associate the data with the bitmap image representation, you use the <code><a href="../../../Reference/ApplicationKit/Classes/NSBitmapImageRep_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBitmapImageRep/setProperty:withValue:" target="_top">setProperty:withValue:</a></code> method of <code>NSBitmapImageRep</code> and the <code><a href="../../../Reference/ApplicationKit/Classes/NSBitmapImageRep_Class/Reference/Reference.html#//apple_ref/c/data/NSImageColorSyncProfileData" target="_top">NSImageColorSyncProfileData</a></code> property. <span class="content_text">Listing 6-7</span> shows an example of how to load the ColorSync data and associate it with a bitmap image representation. </p><a name="//apple_ref/doc/uid/TP40003290-CH208-SW6" title="Listing 6-7Adding a ColorSync profile to an image"></a><p class="codesample"><strong>Listing 6-7&nbsp;&nbsp;</strong>Adding a ColorSync profile to an image</p><div class="codesample"><table><tr><td scope="row"><pre>@implementation NSBitmapImageRep (MoreColorMethods)<span></span></pre></td></tr><tr><td scope="row"><pre>- (NSBitmapImageRep *) imageRepWithProfileAtPath:(NSString *) pathToProfile<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    id result = [self copy];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Build an NSData object using the specified ColorSync profile<span></span></pre></td></tr><tr><td scope="row"><pre>    id profile = [NSData dataWithContentsOfFile: pathToProfile];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Set the ColorSync profile for the object<span></span></pre></td></tr><tr><td scope="row"><pre>    [result setProperty:NSImageColorSyncProfileData withValue:profile];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return [result autorelease];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>In Mac OS X v10.5, it is also possible to associate a custom <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_575"></a>ICC color profile with an <code>NSBitmapImageRep</code> object. To do so, you must initialize your <code>NSBitmapImageRep</code> instance using the calibrated RGB colorspace (<code><a href="../../../Reference/ApplicationKit/Miscellaneous/AppKit_Constants/Reference/reference.html#//apple_ref/c/data/NSCalibratedRGBColorSpace" target="_top">NSCalibratedRGBColorSpace</a></code>). After that, you load the profile and associate the corresponding data object with the <code>NSImageColorSyncProfileData</code> key exactly as you would for a ColorSync profile.</p>
<a name="//apple_ref/doc/uid/TP40003290-CH208-SW5" title="Converting Between Color Spaces"></a><h3>Converting Between Color Spaces</h3>
<p>Cocoa does not provide any direct ways to convert <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_576"></a>images from one <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_577"></a>color space to another. Although Cocoa fully supports color spaces included with existing image files, there is no way to convert image data directly using <code>NSImage</code>. Instead, you must use a combination of Quartz and Cocoa to convert the image data. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH208-SW29" title="Creating the Target Image"></a><h4>Creating the Target Image</h4>
<p>Converting the color space of an existing image requires the use of Quartz to establish a drawing context that uses the target color space. Once you have a <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/tdef/CGContextRef" target="_top">CGContextRef</a></code> object with the desired color space, you can use it to configure the Cocoa drawing environment and draw your image. </p>
<p><span class="content_text">Listing 6-8</span> shows you how to create a Quartz bitmap context using a custom color space. This function receives a <code><a href="../../../../GraphicsImaging/Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/c/tdef/CMProfileRef" target="_top">CMProfileRef</a></code> object, which you can get from the ColorSync Manager or from the <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_578"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSColorSpace_Class/Reference/Reference.html#//apple_ref/occ/instm/NSColorSpace/colorSyncProfile" target="_top">colorSyncProfile</a></code> method of <code>NSColorSpace</code>. It uses the color profile to determine the number of channels in the color space. Once it knows the total number of channels (including alpha) needed for the bitmap, it creates and returns a matching bitmap context. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH208-BCIIGBCF" title="Listing 6-8Creating a bitmap with a custom color profile"></a><p class="codesample"><strong>Listing 6-8&nbsp;&nbsp;</strong>Creating a bitmap with a custom color profile</p><div class="codesample"><table><tr><td scope="row"><pre>CGContextRef CreateCGBitmapContextWithColorProfile(size_t width,<span></span></pre></td></tr><tr><td scope="row"><pre>                size_t height,<span></span></pre></td></tr><tr><td scope="row"><pre>                CMProfileRef profile,<span></span></pre></td></tr><tr><td scope="row"><pre>                CGImageAlphaInfo alphaInfo)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    size_t bytesPerRow = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    size_t alphaComponent = 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Get the type of the color space.<span></span></pre></td></tr><tr><td scope="row"><pre>    CMAppleProfileHeader header;<span></span></pre></td></tr><tr><td scope="row"><pre>    if (noErr != CMGetProfileHeader(profile, &amp;header))<span></span></pre></td></tr><tr><td scope="row"><pre>        return nil;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Get the color space info from the profile.<span></span></pre></td></tr><tr><td scope="row"><pre>    CGColorSpaceRef csRef = CGColorSpaceCreateWithPlatformColorSpace(profile);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (csRef == NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>        return NULL;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Add 1 channel if there is an alpha component.<span></span></pre></td></tr><tr><td scope="row"><pre>    if (alphaInfo != kCGImageAlphaNone)<span></span></pre></td></tr><tr><td scope="row"><pre>        alphaComponent = 1;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Check the major color spaces.<span></span></pre></td></tr><tr><td scope="row"><pre>    OSType space = header.cm2.dataColorSpace;<span></span></pre></td></tr><tr><td scope="row"><pre>    switch (space)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        case cmGrayData:<span></span></pre></td></tr><tr><td scope="row"><pre>            bytesPerRow = width;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            // Quartz doesn’t support alpha for grayscale bitmaps.<span></span></pre></td></tr><tr><td scope="row"><pre>            alphaInfo = kCGImageAlphaNone;<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        case cmRGBData:<span></span></pre></td></tr><tr><td scope="row"><pre>            bytesPerRow = width * (3 + alphaComponent);<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        case cmCMYKData:<span></span></pre></td></tr><tr><td scope="row"><pre>            bytesPerRow = width * 4;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            // Quartz doesn’t support alpha for CMYK bitmaps.<span></span></pre></td></tr><tr><td scope="row"><pre>            alphaInfo = kCGImageAlphaNone;<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        default:<span></span></pre></td></tr><tr><td scope="row"><pre>            return NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Allocate the memory for the bitmap.<span></span></pre></td></tr><tr><td scope="row"><pre>    void*   bitmapData = malloc(bytesPerRow * height);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextRef    theRef = CGBitmapContextCreate(bitmapData, width,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    height, 8,  bytesPerRow,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    csRef, alphaInfo);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Cleanup if an error occurs; otherwise, the caller is responsible<span></span></pre></td></tr><tr><td scope="row"><pre>    // for releasing the bitmap data.<span></span></pre></td></tr><tr><td scope="row"><pre>    if ((!theRef) &amp;&amp; bitmapData)<span></span></pre></td></tr><tr><td scope="row"><pre>        free(bitmapData);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    CGColorSpaceRelease(csRef);<span></span></pre></td></tr><tr><td scope="row"><pre>    return theRef;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<p>Once you have a <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_579"></a>Quartz bitmap context, you can create a new Cocoa graphics context object and use it for drawing. To create the <code>NSGraphicsContext</code> object, you use the <code><a href="../../../Reference/ApplicationKit/Classes/NSGraphicsContext_Class/Reference/Reference.html#//apple_ref/occ/clm/NSGraphicsContext/graphicsContextWithGraphicsPort:flipped:" target="_top">graphicsContextWithGraphicsPort:flipped:</a></code> method, which takes a <code>CGContextRef</code> object as a parameter. You then use the <code>setCurrentContext:</code> method to make it current and begin drawing. When you are done drawing, you use <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_580"></a><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_581"></a>Quartz to create a <code>CGImageRef</code> object containing the results. <span class="content_text">Listing 6-9</span> shows this process.</p>
<a name="//apple_ref/doc/uid/TP40003290-CH208-BCIDCBIF" title="Listing 6-9Converting a bitmap to a different color space"></a><p class="codesample"><strong>Listing 6-9&nbsp;&nbsp;</strong>Converting a bitmap to a different color space</p><div class="codesample"><table><tr><td scope="row"><pre>- (CGImageRef) convertBitmapImageRep:(NSBitmapImageRep*)theRep toColorSpace:(NSColorSpace*)colorspace<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!theRep)<span></span></pre></td></tr><tr><td scope="row"><pre>        return nil;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Map the Cocoa constants returned by -bitmapFormat to their<span></span></pre></td></tr><tr><td scope="row"><pre>    // Quartz equivalents.<span></span></pre></td></tr><tr><td scope="row"><pre>    CGImageAlphaInfo alphaInfo = GetAlphaInfoFromBitmapImageRep(theRep);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Get the rest of the image info.<span></span></pre></td></tr><tr><td scope="row"><pre>    NSSize imageSize = [theRep size];<span></span></pre></td></tr><tr><td scope="row"><pre>    size_t width = imageSize.width;<span></span></pre></td></tr><tr><td scope="row"><pre>    size_t height = imageSize.height;<span></span></pre></td></tr><tr><td scope="row"><pre>    CMProfileRef profile = (CMProfileRef)[colorspace colorSyncProfile];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Create a new 8-bit bitmap context based on the image info.<span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextRef cgContext = CreateCGBitmapContextWithColorProfile(width,<span></span></pre></td></tr><tr><td scope="row"><pre>                                     height, profile, alphaInfo);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (cgContext == NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>        return NULL;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Create an NSGraphicsContext that draws into the CGContext.<span></span></pre></td></tr><tr><td scope="row"><pre>    NSGraphicsContext *graphicsContext = [NSGraphicsContext<span></span></pre></td></tr><tr><td scope="row"><pre>             graphicsContextWithGraphicsPort:cgContext flipped:NO];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Make the NSGraphicsContext current and draw into it.<span></span></pre></td></tr><tr><td scope="row"><pre>    [NSGraphicsContext saveGraphicsState];<span></span></pre></td></tr><tr><td scope="row"><pre>    [NSGraphicsContext setCurrentContext:graphicsContext];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Create a new image for rendering the original bitmap.<span></span></pre></td></tr><tr><td scope="row"><pre>    NSImage*  theImage = [[[NSImage alloc] initWithSize:imageSize] autorelease];<span></span></pre></td></tr><tr><td scope="row"><pre>    [theImage addRepresentation:theRep];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Draw the original image in the Quartz bitmap context.<span></span></pre></td></tr><tr><td scope="row"><pre>    NSRect imageRect = NSMakeRect(0.0, 0.0, imageSize.width, imageSize.height);<span></span></pre></td></tr><tr><td scope="row"><pre>    [theImage drawAtPoint:NSMakePoint(0.0, 0.0)<span></span></pre></td></tr><tr><td scope="row"><pre>                fromRect:imageRect<span></span></pre></td></tr><tr><td scope="row"><pre>                operation: NSCompositeSourceOver<span></span></pre></td></tr><tr><td scope="row"><pre>                fraction: 1.0];<span></span></pre></td></tr><tr><td scope="row"><pre>    [NSGraphicsContext restoreGraphicsState];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Create a CGImage from the CGContext's contents.<span></span></pre></td></tr><tr><td scope="row"><pre>    CGImageRef cgImage = CGBitmapContextCreateImage(cgContext);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Release the context. Note that this does not release the bitmap data.<span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextRelease(cgContext);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return cgImage;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<p>There are two ways to get an <code>NSImage</code> object from a <code>CGImageRef</code> type. In Mac OS X v10.5 and later, you can <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_582"></a>create an <code><a href="../../../Reference/ApplicationKit/Classes/NSBitmapImageRep_Class/Reference/Reference.html#//apple_ref/occ/cl/NSBitmapImageRep" target="_top">NSBitmapImageRep</a></code> object using its <code><a href="../../../Reference/ApplicationKit/Classes/NSBitmapImageRep_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBitmapImageRep/initWithCGImage:" target="_top">initWithCGImage:</a></code> method and then add that image representation to an <code>NSImage</code> object. If your code needs to run in versions of Mac OS X v10.4 or earlier, however, you can lock focus on an <code>NSImage</code> object and use the <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_583"></a><code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextDrawImage" target="_top">CGContextDrawImage</a></code> function to draw the Quartz image into the image. This latter technique creates a copy of the image data and requires more effort than using the <code>initWithCGImage:</code> method but is available on all versions of Mac OS X. <span class="content_text">Listing 6-10</span> shows a sample method that demonstrates both approaches but always uses the best approach available for the target platform. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH208-BCIDDCDD" title="Listing 6-10Using a CGImageRef object to create an NSImage object"></a><p class="codesample"><strong>Listing 6-10&nbsp;&nbsp;</strong>Using a CGImageRef object to create an NSImage object</p><div class="codesample"><table><tr><td scope="row"><pre>- (NSImage*)imageFromCGImageRef:(CGImageRef)image<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSImage* newImage = nil;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5<span></span></pre></td></tr><tr><td scope="row"><pre>    NSBitmapImageRep*    newRep = [[NSBitmapImageRep alloc] initWithCGImage:image];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSSize imageSize;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Get the image dimensions.<span></span></pre></td></tr><tr><td scope="row"><pre>    imageSize.height = CGImageGetHeight(image);<span></span></pre></td></tr><tr><td scope="row"><pre>    imageSize.width = CGImageGetWidth(image);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    newImage = [[NSImage alloc] initWithSize:imageSize];<span></span></pre></td></tr><tr><td scope="row"><pre>    [newImage addRepresentation:newRep];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#else<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    NSRect imageRect = NSMakeRect(0.0, 0.0, 0.0, 0.0);<span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextRef imageContext = nil;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Get the image dimensions.<span></span></pre></td></tr><tr><td scope="row"><pre>    imageRect.size.height = CGImageGetHeight(image);<span></span></pre></td></tr><tr><td scope="row"><pre>    imageRect.size.width = CGImageGetWidth(image);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Create a new image to receive the Quartz image data.<span></span></pre></td></tr><tr><td scope="row"><pre>    newImage = [[NSImage alloc] initWithSize:imageRect.size];<span></span></pre></td></tr><tr><td scope="row"><pre>    [newImage lockFocus];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Get the Quartz context and draw.<span></span></pre></td></tr><tr><td scope="row"><pre>    imageContext = (CGContextRef)[[NSGraphicsContext currentContext] graphicsPort];<span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextDrawImage(imageContext, *(CGRect*)&amp;imageRect, image);<span></span></pre></td></tr><tr><td scope="row"><pre>    [newImage unlockFocus];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#endif<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return [newImage autorelease];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<a name="//apple_ref/doc/uid/TP40003290-CH208-SW30" title="Using a Custom Color Profile"></a><h4>Using a Custom Color Profile</h4>
<p>If you have an existing ICC profile and want to associate that <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_584"></a>profile with an <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_585"></a>image, you must do so using the ColorSync Manager. If you are working with Quartz graphic contexts, you use the ICC profile to obtain the color space information needed to create a <code>CGImageRef</code> object. You can then use that color space information to create an appropriate context for rendering your image. </p>
<p><span class="content_text">Listing 6-11</span> shows you how to create a <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_586"></a><code><a href="../../../../GraphicsImaging/Reference/CGColorSpace/Reference/reference.html#//apple_ref/c/tdef/CGColorSpaceRef" target="_top">CGColorSpaceRef</a></code> object from an <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_587"></a>ICC profile. This code uses several <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_588"></a>ColorSync Manager functions to create a <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_589"></a><code><a href="../../../../GraphicsImaging/Reference/ColorSync_Manager/Reference/reference.html#//apple_ref/c/tdef/CMProfileRef" target="_top">CMProfileRef</a></code> object, from which you can then extract the color space object. Mac OS X includes several standard ICC profiles in the <code>/System/Library/ColorSync/Profiles/</code> directory. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH208-BCIEDHJG" title="Listing 6-11Creating a color space from a custom color profile"></a><p class="codesample"><strong>Listing 6-11&nbsp;&nbsp;</strong>Creating a color space from a custom color profile</p><div class="codesample"><table><tr><td scope="row"><pre>CGColorSpaceRef CreateColorSpaceForProfileAtPath(NSString* path)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CMProfileLocation profileLoc;<span></span></pre></td></tr><tr><td scope="row"><pre>    CMProfileRef profileRef;<span></span></pre></td></tr><tr><td scope="row"><pre>    CGColorSpaceRef csRef = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Specify where the ICC profile data file is located.<span></span></pre></td></tr><tr><td scope="row"><pre>    profileLoc.locType = cmPathBasedProfile;<span></span></pre></td></tr><tr><td scope="row"><pre>    strncpy(profileLoc.u.pathLoc.path, [path fileSystemRepresentation],  255);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Get the ColorSync profile information from the data file.<span></span></pre></td></tr><tr><td scope="row"><pre>    CMOpenProfile(&amp;profileRef, &amp;profileLoc);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Use the profile to create the color space object.<span></span></pre></td></tr><tr><td scope="row"><pre>    csRef = CGColorSpaceCreateWithPlatformColorSpace(profileRef);<span></span></pre></td></tr><tr><td scope="row"><pre>    CMCloseProfile(profileRef);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return csRef;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>
<p>For more information on ColorSync and its functions, see <em><a href="../../../../GraphicsImaging/Reference/ColorSync_Manager/index.html#//apple_ref/doc/uid/TP30000259" target="_top">ColorSync Manager Reference</a></em>. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH208-SW31" title="Premultiplying Alpha Values for Bitmaps"></a><h3>Premultiplying Alpha Values for Bitmaps</h3>
<p>Although <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_590"></a><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_591"></a><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_592"></a>premultiplying <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_593"></a>alpha values used to be a common way to improve performance when rendering bitmaps, the technique is not recommended for programs running in Mac OS X. Premultiplication involves multiplying values in the bitmap’s alpha channel with the corresponding pixel values and storing the results back to the bitmap’s source file. The goal of premultiplicaton is to reduce the number of calculations performed when the bitmap is composited with other content. In Mac OS X, premultiplication can actually result in more calculations. </p>
<p>In Mac OS X, <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_594"></a><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_595"></a><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_596"></a>color correction is integral to the operating system. In order to process colors correctly, ColorSync needs the original pixel color values. If a bitmap contains premultiplied color values, ColorSync must undo the premultiplication before it can check the colors. This extra step adds a significant amount of work to the system because it must be performed every time the colors are checked.</p>
<p>The only reason to consider premultiplication of alpha values for your bitmaps is if your data is already premultiplied and leaving it that way is beneficial to your program’s data model. Even so, you should do some performance tests to see if using premultiplied bitmaps hurts your overall application performance. Cocoa incorporates color management into many parts of the framework. If your code paths use these parts of the framework, you might find it beneficial to change your model. </p>
<a name="//apple_ref/doc/uid/TP40003290-CH208-BCIFJBGC" title="Creating New Image Representation Classes"></a><h2>Creating New Image Representation Classes</h2>
<p>If you want to add support for new <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_597"></a><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_598"></a><a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_599"></a>image formats or generate images from other types of source information, you may want to subclass <code><a href="../../../Reference/ApplicationKit/Classes/NSImageRep_Class/Reference/Reference.html#//apple_ref/occ/cl/NSImageRep" target="_top">NSImageRep</a></code>. Although Cocoa supports many image formats directly, and many more indirectly through the Image IO framework, subclassing <code>NSImageRep</code> gives you control over the handling of image data while at the same time maintaining a tight integration with the <code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/cl/NSImage" target="_top">NSImage</a></code> class. If you decide to subclass, you should provide implementations for the following methods:</p>
<ul class="ul"><li class="li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSImageRep_Class/Reference/Reference.html#//apple_ref/occ/clm/NSImageRep/imageUnfilteredTypes" target="_top">imageUnfilteredTypes</a></code></p></li>
<li class="li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSImageRep_Class/Reference/Reference.html#//apple_ref/occ/clm/NSImageRep/canInitWithData:" target="_top">canInitWithData:</a></code></p></li>
<li class="li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/instm/NSImage/initWithData:" target="_top">initWithData:</a></code></p></li>
<li class="li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSImageRep_Class/Reference/Reference.html#//apple_ref/occ/instm/NSImageRep/draw" target="_top">draw</a></code></p></li></ul>
<p>These methods provide the basic interface that the parent <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_600"></a><code>NSImageRep</code> class needs to interact with your subclass. The methods provide information about what image data formats your class supports along with entry points for initializing your object and drawing the image.</p>
<p>Before your subclass can be used, it must be registered with the Application Kit. You should do this early in your application’s execution by invoking the <a name="//apple_ref/doc/uid/TP40003290-CH208-DontLinkElementID_601"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSImageRep_Class/Reference/Reference.html#//apple_ref/occ/clm/NSImageRep/registerImageRepClass:" target="_top">registerImageRepClass:</a></code> class method of <code>NSImageRep</code>. Registering your class lets Cocoa know that your class exists and that it can handle a specific set of file types. Your implementation of the <code><a href="../../../Reference/ApplicationKit/Classes/NSImageRep_Class/Reference/Reference.html#//apple_ref/occ/clm/NSImageRep/imageUnfilteredTypes" target="_top">imageUnfilteredTypes</a></code> method should return an array of UTI types corresponding to the image file types your class supports directly.</p>
<p>Another method you should always override is the <code>canInitWithData:</code> method. Once your image representation class has been identified as handling a particular type of data, Cocoa may notify it when data of the appropriate type is received. At that time, Cocoa passes a data object to your <code>canInitWithData:</code> method. Your implementation of this method should examine the data quickly and verify that it can really handle the format. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40003290-CH208-SW32" title="Note"></a><p><strong>Note:</strong>&nbsp;If your subclass is capable of reading multiple images from a single file, you should also implement the <code><a href="../../../Reference/ApplicationKit/Classes/NSBitmapImageRep_Class/Reference/Reference.html#//apple_ref/occ/clm/NSBitmapImageRep/imageRepsWithData:" target="_top">imageRepsWithData:</a></code> method. This method must parse the image data and check to see if it indeed contains multiple images. For each separate image, you should create an instance of your subclass and initialize it with the appropriate subset of the image data. </p></div>
<p>Once your class is chosen to handle the image data, Cocoa looks for an <code>initWithData:</code> method and uses it to initialize your object with the image data. Your implementation of this method should retain the data and use it to initialize the object. At some point later, your <code><a href="../../../Reference/ApplicationKit/Classes/NSImageRep_Class/Reference/Reference.html#//apple_ref/occ/instm/NSImageRep/draw" target="_top">draw</a></code> method may be called to render the data in the current context. Your <code>draw</code> method should render the data at the current origin point and with the current size and settings specified by the <code>NSImageRep</code> parent class. </p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Paths/Paths.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../Text/Text.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2005, 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-01-06<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/CocoaDrawingGuide/Images/Images.html%3Fid%3DTP40003290-2.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/CocoaDrawingGuide/Images/Images.html%3Fid%3DTP40003290-2.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/CocoaDrawingGuide/Images/Images.html%3Fid%3DTP40003290-2.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>