<html><head><title>Mac OS X
 Manual Page For el_parse(3)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3/el_parse" title="Mac OS X
 Manual Page for el_parse(3)"><!-- headerDoc=man; indexgroup=Section 3; uid="//apple_ref/doc/man/3/el_parse"; name=el_parse(3) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
EDITLINE(3)              BSD Library Functions Manual              <!-- a -->EDITLINE(3)<!-- /a -->

<b>NAME</b>
     <b>editline</b>, <b>el_init</b>, <b>el_end</b>, <b>el_reset</b>, <b>el_gets</b>, <b>el_getc</b>, <b>el_push</b>, <b>el_parse</b>, <b>el_set</b>, <b>el_get</b>, <b>el_source</b>,
     <b>el_resize</b>, <b>el_line</b>, <b>el_insertstr</b>, <b>el_deletestr</b>, <b>history_init</b>, <b>history_end</b>, <b>history</b>, <b>tok_init</b>, <b>tok_end</b>,
     <b>tok_reset</b>, <b>tok_line</b>, <b>tok_str</b> -- line editor, history and tokenization functions

<b>LIBRARY</b>
     Command Line Editor Library (libedit, -ledit)

<b>SYNOPSIS</b>
     <b>#include</b> <b>&lt;histedit.h&gt;</b>

     <u>EditLine</u> <u>*</u>
     <b>el_init</b>(<u>const</u> <u>char</u> <u>*prog</u>, <u>FILE</u> <u>*fin</u>, <u>FILE</u> <u>*fout</u>, <u>FILE</u> <u>*ferr</u>);

     <u>void</u>
     <b>el_end</b>(<u>EditLine</u> <u>*e</u>);

     <u>void</u>
     <b>el_reset</b>(<u>EditLine</u> <u>*e</u>);

     <u>const</u> <u>char</u> <u>*</u>
     <b>el_gets</b>(<u>EditLine</u> <u>*e</u>, <u>int</u> <u>*count</u>);

     <u>int</u>
     <b>el_getc</b>(<u>EditLine</u> <u>*e</u>, <u>char</u> <u>*ch</u>);

     <u>void</u>
     <b>el_push</b>(<u>EditLine</u> <u>*e</u>, <u>const</u> <u>char</u> <u>*str</u>);

     <u>int</u>
     <b>el_parse</b>(<u>EditLine</u> <u>*e</u>, <u>int</u> <u>argc</u>, <u>const</u> <u>char</u> <u>*argv[]</u>);

     <u>int</u>
     <b>el_set</b>(<u>EditLine</u> <u>*e</u>, <u>int</u> <u>op</u>, <u>...</u>);

     <u>int</u>
     <b>el_get</b>(<u>EditLine</u> <u>*e</u>, <u>int</u> <u>op</u>, <u>void</u> <u>*result</u>);

     <u>int</u>
     <b>el_source</b>(<u>EditLine</u> <u>*e</u>, <u>const</u> <u>char</u> <u>*file</u>);

     <u>void</u>
     <b>el_resize</b>(<u>EditLine</u> <u>*e</u>);

     <u>const</u> <u>LineInfo</u> <u>*</u>
     <b>el_line</b>(<u>EditLine</u> <u>*e</u>);

     <u>int</u>
     <b>el_insertstr</b>(<u>EditLine</u> <u>*e</u>, <u>const</u> <u>char</u> <u>*str</u>);

     <u>void</u>
     <b>el_deletestr</b>(<u>EditLine</u> <u>*e</u>, <u>int</u> <u>count</u>);

     <u>History</u> <u>*</u>
     <b>history_init</b>();

     <u>void</u>
     <b>history_end</b>(<u>History</u> <u>*h</u>);

     <u>int</u>
     <b>history</b>(<u>History</u> <u>*h</u>, <u>HistEvent</u> <u>*ev</u>, <u>int</u> <u>op</u>, <u>...</u>);

     <u>Tokenizer</u> <u>*</u>
     <b>tok_init</b>(<u>const</u> <u>char</u> <u>*IFS</u>);

     <u>void</u>
     <b>tok_end</b>(<u>Tokenizer</u> <u>*t</u>);

     <u>void</u>
     <b>tok_reset</b>(<u>Tokenizer</u> <u>*t</u>);

     <u>int</u>
     <b>tok_line</b>(<u>Tokenizer</u> <u>*t</u>, <u>const</u> <u>LineInfo</u> <u>*li</u>, <u>int</u> <u>*argc</u>, <u>const</u> <u>char</u> <u>**argv[]</u>, <u>int</u> <u>*cursorc</u>, <u>int</u> <u>*cursoro</u>);

     <u>int</u>
     <b>tok_str</b>(<u>Tokenizer</u> <u>*t</u>, <u>const</u> <u>char</u> <u>*str</u>, <u>int</u> <u>*argc</u>, <u>const</u> <u>char</u> <u>**argv[]</u>);

<b>DESCRIPTION</b>
     The <b>editline</b> library provides generic line editing, history and tokenization functions, similar to
     those found in <a href="../man1/sh.1.html#//apple_ref/doc/man/1/sh">sh(1)</a>.

     These functions are available in the <b>libedit</b> library (which needs the <b>libcurses</b> library).  Programs
     should be linked with <b>-ledit</b> <b>-lcurses</b>.

<b>LINE</b> <b>EDITING</b> <b>FUNCTIONS</b>
     The line editing functions use a common data structure, <u>EditLine</u>, which is created by <b>el_init</b>() and
     freed by <b>el_end</b>().

     The following functions are available:

     <b>el_init</b>()
           Initialise the line editor, and return a data structure to be used by all other line editing
           functions.  <u>prog</u> is the name of the invoking program, used when reading the <a href="../man5/editrc.5.html#//apple_ref/doc/man/5/editrc">editrc(5)</a> file to
           determine which settings to use.  <u>fin</u>, <u>fout</u> and <u>ferr</u> are the input, output, and error streams
           (respectively) to use.  In this documentation, references to ``the tty'' are actually to this
           input/output stream combination.

     <b>el_end</b>()
           Clean up and finish with <u>e</u>, assumed to have been created with <b>el_init</b>().

     <b>el_reset</b>()
           Reset the tty and the parser.  This should be called after an error which may have upset the
           tty's state.

     <b>el_gets</b>()
           Read a line from the tty.  <u>count</u> is modified to contain the number of characters read.  Returns
           the line read if successful, or NULL if no characters were read or if an error occurred.

     <b>el_getc</b>()
           Read a character from the tty.  <u>ch</u> is modified to contain the character read.  Returns the number
           of characters read if successful, -1 otherwise.

     <b>el_push</b>()
           Pushes <u>str</u> back onto the input stream.  This is used by the macro expansion mechanism.  Refer to
           the description of <b>bind</b> <b>-s</b> in <a href="../man5/editrc.5.html#//apple_ref/doc/man/5/editrc">editrc(5)</a> for more information.

     <b>el_parse</b>()
           Parses the <u>argv</u> array (which is <u>argc</u> elements in size) to execute builtin <b>editline</b> commands.  If
           the command is prefixed with ``prog'': then <b>el_parse</b>() will only execute the command if ``prog''
           matches the <u>prog</u> argument supplied to <b>el_init</b>().  The return value is -1 if the command is
           unknown, 0 if there was no error or ``prog'' didn't match, or 1 if the command returned an error.
           Refer to <a href="../man5/editrc.5.html#//apple_ref/doc/man/5/editrc">editrc(5)</a> for more information.

     <b>el_set</b>()
           Set <b>editline</b> parameters.  <u>op</u> determines which parameter to set, and each operation has its own
           parameter list.

           The following values for <u>op</u> are supported, along with the required argument list:

           EL_PROMPT, <u>char</u> <u>*(*f)(EditLine</u> <u>*)</u>
                 Define prompt printing function as <u>f</u>, which is to return a string that contains the prompt.

           EL_RPROMPT, <u>char</u> <u>*(*f)(EditLine</u> <u>*)</u>
                 Define right side prompt printing function as <u>f</u>, which is to return a string that contains
                 the prompt.

           EL_TERMINAL, <u>const</u> <u>char</u> <u>*type</u>
                 Define terminal type of the tty to be <u>type</u>, or to TERM if <u>type</u> is NULL.

           EL_EDITOR, <u>const</u> <u>char</u> <u>*mode</u>
                 Set editing mode to <u>mode</u>, which must be one of ``emacs'' or ``vi''.

           EL_SIGNAL, <u>int</u> <u>flag</u>
                 If <u>flag</u> is non-zero, <b>editline</b> will install its own signal handler for the following signals
                 when reading command input: SIGCONT, SIGHUP, SIGINT, SIGQUIT, SIGSTOP, SIGTERM, SIGTSTP,
                 and SIGWINCH.  Otherwise, the current signal handlers will be used.

           EL_BIND, <u>const</u> <u>char</u> <u>*</u>, <u>...</u>, NULL
                 Perform the <b>bind</b> builtin command.  Refer to <a href="../man5/editrc.5.html#//apple_ref/doc/man/5/editrc">editrc(5)</a> for more information.

           EL_ECHOTC, <u>const</u> <u>char</u> <u>*</u>, <u>...</u>, NULL
                 Perform the <b>echotc</b> builtin command.  Refer to <a href="../man5/editrc.5.html#//apple_ref/doc/man/5/editrc">editrc(5)</a> for more information.

           EL_SETTC, <u>const</u> <u>char</u> <u>*</u>, <u>...</u>, NULL
                 Perform the <b>settc</b> builtin command.  Refer to <a href="../man5/editrc.5.html#//apple_ref/doc/man/5/editrc">editrc(5)</a> for more information.

           EL_SETTY, <u>const</u> <u>char</u> <u>*</u>, <u>...</u>, NULL
                 Perform the <b>setty</b> builtin command.  Refer to <a href="../man5/editrc.5.html#//apple_ref/doc/man/5/editrc">editrc(5)</a> for more information.

           EL_TELLTC, <u>const</u> <u>char</u> <u>*</u>, <u>...</u>, NULL
                 Perform the <b>telltc</b> builtin command.  Refer to <a href="../man5/editrc.5.html#//apple_ref/doc/man/5/editrc">editrc(5)</a> for more information.

           EL_ADDFN, <u>const</u> <u>char</u> <u>*name</u>, <u>const</u> <u>char</u> <u>*help</u>, <u>unsigned</u> <u>char</u> <u>(*func)(EditLine</u> <u>*e,</u> <u>int</u> <u>ch)</u>
                 Add a user defined function, <b>func</b>(), referred to as <u>name</u> which is invoked when a key which
                 is bound to <u>name</u> is entered.  <u>help</u> is a description of <u>name</u>.  At invocation time, <u>ch</u> is the
                 key which caused the invocation.  The return value of <b>func</b>() should be one of:

                 CC_NORM       Add a normal character.

                 CC_NEWLINE    End of line was entered.

                 CC_EOF        EOF was entered.

                 CC_ARGHACK    Expecting further command input as arguments, do nothing visually.

                 CC_REFRESH    Refresh display.

                 CC_REFRESH_BEEP
                               Refresh display, and beep.

                 CC_CURSOR     Cursor moved, so update and perform CC_REFRESH.

                 CC_REDISPLAY  Redisplay entire input line.  This is useful if a key binding outputs extra
                               information.

                 CC_ERROR      An error occurred.  Beep, and flush tty.

                 CC_FATAL      Fatal error, reset tty to known state.

           EL_HIST, <u>History</u> <u>*(*func)(History</u> <u>*,</u> <u>int</u> <u>op,</u> <u>...)</u>, <u>const</u> <u>char</u> <u>*ptr</u>
                 Defines which history function to use, which is usually <b>history</b>().  <u>ptr</u> should be the value
                 returned by <b>history_init</b>().

           EL_EDITMODE, <u>int</u> <u>flag</u>
                 If <u>flag</u> is non-zero, editing is enabled (the default).  Note that this is only an indica-<font color="#ffffff" class="whiteout">tion,&nbsp;indication,</font>
                 tion, and does not affect the operation of <b>editline</b>.  At this time, it is the caller's
                 responsibility to check this (using <b>el_get</b>()) to determine if editing should be enabled or
                 not.

           EL_GETCFN, <u>int</u> <u>(*f)(EditLine</u> <u>*,</u> <u>char</u> <u>*c)</u>
                 Define the character reading function as <u>f</u>, which is to return the number of characters
                 read and store them in <u>c</u>.  This function is called internally by <b>el_gets</b>() and <b>el_getc</b>().
                 The builtin function can be set or restored with the special function name
                 ``EL_BUILTIN_GETCFN''.

           EL_CLIENTDATA, <u>void</u> <u>*data</u>
                 Register <u>data</u> to be associated with this EditLine structure.  It can be retrieved with the
                 corresponding <b>el_get</b>() call.

     <b>el_get</b>()
           Get <b>editline</b> parameters.  <u>op</u> determines which parameter to retrieve into <u>result</u>.  Returns 0 if
           successful, -1 otherwise.

           The following values for <u>op</u> are supported, along with actual type of <u>result</u>:

           EL_PROMPT, <u>char</u> <u>*(*f)(EditLine</u> <u>*)</u>
                 Return a pointer to the function that displays the prompt.

           EL_RPROMPT, <u>char</u> <u>*(*f)(EditLine</u> <u>*)</u>
                 Return a pointer to the function that displays the rightside prompt.

           EL_EDITOR, <u>const</u> <u>char</u> <u>*</u>
                 Return the name of the editor, which will be one of ``emacs'' or ``vi''.

           EL_SIGNAL, <u>int</u> <u>*</u>
                 Return non-zero if <b>editline</b> has installed private signal handlers (see <b>el_get</b>() above).

           EL_EDITMODE, <u>int</u> <u>*</u>
                 Return non-zero if editing is enabled.

           EL_GETCFN, <u>int</u> <u>(**f)(EditLine</u> <u>*,</u> <u>char</u> <u>*)</u>
                 Return a pointer to the function that read characters, which is equal to
                 ``EL_BUILTIN_GETCFN'' in the case of the default builtin function.

           EL_CLIENTDATA, <u>void</u> <u>**data</u>
                 Retrieve <u>data</u> previously registered with the corresponding <b>el_set</b>() call.

           EL_UNBUFFERED, <u>int</u>
                 Sets or clears unbuffered mode.  In this mode, <b>el_gets</b>() will return immediately after pro-<font color="#ffffff" class="whiteout">cessing&nbsp;processing</font>
                 cessing a single character.

           EL_PREP_TERM, <u>int</u>
                 Sets or clears terminal editing mode.

     <b>el_source</b>()
           Initialise <b>editline</b> by reading the contents of <u>file</u>.  <b>el_parse</b>() is called for each line in <u>file</u>.
           If <u>file</u> is NULL, try <u>$PWD/.editrc</u> then <u>$HOME/.editrc</u>.  Refer to <a href="../man5/editrc.5.html#//apple_ref/doc/man/5/editrc">editrc(5)</a> for details on the for-<font color="#ffffff" class="whiteout">mat&nbsp;format</font>
           mat of <u>file</u>.

     <b>el_resize</b>()
           Must be called if the terminal size changes.  If EL_SIGNAL has been set with <b>el_set</b>(), then this
           is done automatically.  Otherwise, it's the responsibility of the application to call <b>el_resize</b>()
           on the appropriate occasions.

     <b>el_line</b>()
           Return the editing information for the current line in a <u>LineInfo</u> structure, which is defined as
           follows:

           typedef struct lineinfo {
               const char *buffer;    /* address of buffer */
               const char *cursor;    /* address of cursor */
               const char *lastchar;  /* address of last character */
           } LineInfo;

           <u>buffer</u> is not NUL terminated.  This function may be called after <b>el_gets</b>() to obtain the <u>LineInfo</u>
           structure pertaining to line returned by that function, and from within user defined functions
           added with EL_ADDFN.

     <b>el_insertstr</b>()
           Insert <u>str</u> into the line at the cursor.  Returns -1 if <u>str</u> is empty or won't fit, and 0 other-<font color="#ffffff" class="whiteout">wise.&nbsp;otherwise.</font>
           wise.

     <b>el_deletestr</b>()
           Delete <u>num</u> characters before the cursor.

<b>HISTORY</b> <b>LIST</b> <b>FUNCTIONS</b>
     The history functions use a common data structure, <u>History</u>, which is created by <b>history_init</b>() and
     freed by <b>history_end</b>().

     The following functions are available:

     <b>history_init</b>()
           Initialise the history list, and return a data structure to be used by all other history list
           functions.

     <b>history_end</b>()
           Clean up and finish with <u>h</u>, assumed to have been created with <b>history_init</b>().

     <b>history</b>()
           Perform operation <u>op</u> on the history list, with optional arguments as needed by the operation.  <u>ev</u>
           is changed accordingly to operation.  The following values for <u>op</u> are supported, along with the
           required argument list:

           H_SETSIZE, <u>int</u> <u>size</u>
                 Set size of history to <u>size</u> elements.

           H_GETSIZE
                 Get number of events currently in history.

           H_END
                 Cleans up and finishes with <u>h</u>, assumed to be created with <b>history_init</b>().

           H_CLEAR
                 Clear the history.

           H_FUNC, <u>void</u> <u>*ptr</u>, <u>history</u><b>_</b><u>gfun</u><b>_</b><u>t</u> <u>first</u>, <u>history</u><b>_</b><u>gfun</u><b>_</b><u>t</u> <u>next</u>, <u>history</u><b>_</b><u>gfun</u><b>_</b><u>t</u> <u>last</u>, <u>history</u><b>_</b><u>gfun</u><b>_</b><u>t</u>
                 <u>prev</u>, <u>history</u><b>_</b><u>gfun</u><b>_</b><u>t</u> <u>curr</u>, <u>history</u><b>_</b><u>sfun</u><b>_</b><u>t</u> <u>set</u>, <u>history</u><b>_</b><u>vfun</u><b>_</b><u>t</u> <u>clear</u>, <u>history</u><b>_</b><u>efun</u><b>_</b><u>t</u> <u>enter</u>,
                 <u>history</u><b>_</b><u>efun</u><b>_</b><u>t</u> <u>add</u>
                 Define functions to perform various history operations.  <u>ptr</u> is the argument given to a
                 function when it's invoked.

           H_FIRST
                 Return the first element in the history.

           H_LAST
                 Return the last element in the history.

           H_PREV
                 Return the previous element in the history.

           H_NEXT
                 Return the next element in the history.

           H_CURR
                 Return the current element in the history.

           H_SET
                 Set the cursor to point to the requested element.

           H_ADD, <u>const</u> <u>char</u> <u>*str</u>
                 Append <u>str</u> to the current element of the history, or perform the H_ENTER operation with
                 argument <u>str</u> if there is no current element.

           H_APPEND, <u>const</u> <u>char</u> <u>*str</u>
                 Append <u>str</u> to the last new element of the history.

           H_ENTER, <u>const</u> <u>char</u> <u>*str</u>
                 Add <u>str</u> as a new element to the history, and, if necessary, removing the oldest entry to
                 keep the list to the created size.  If H_SETUNIQUE was has been called with a non-zero
                 arguments, the element will not be entered into the history if its contents match the ones
                 of the current history element.  If the element is entered <b>history</b>() returns 1, if it is
                 ignored as a duplicate returns 0.  Finally <b>history</b>() returns -1 if an error occurred.

           H_PREV_STR, <u>const</u> <u>char</u> <u>*str</u>
                 Return the closest previous event that starts with <u>str</u>.

           H_NEXT_STR, <u>const</u> <u>char</u> <u>*str</u>
                 Return the closest next event that starts with <u>str</u>.

           H_PREV_EVENT, <u>int</u> <u>e</u>
                 Return the previous event numbered <u>e</u>.

           H_NEXT_EVENT, <u>int</u> <u>e</u>
                 Return the next event numbered <u>e</u>.

           H_LOAD, <u>const</u> <u>char</u> <u>*file</u>
                 Load the history list stored in <u>file</u>.

           H_SAVE, <u>const</u> <u>char</u> <u>*file</u>
                 Save the history list to <u>file</u>.

           H_SETUNIQUE, <u>int</u> <u>unique</u>
                 Set flag that adjacent identical event strings should not be entered into the history.

           H_GETUNIQUE
                 Retrieve the current setting if adjacent identical elements should be entered into the his-<font color="#ffffff" class="whiteout">tory.&nbsp;history.</font>
                 tory.

           H_DEL, <u>int</u> <u>num</u>
                 Delete the event numbered <u>e</u>.  This function is only provided for <!-- a -->readline(3)<!-- /a --> compatibility.
                 The caller is responsible for free'ing the string in the returned <u>HistEvent</u>.

           <b>history</b>() returns &gt;= 0 if the operation <u>op</u> succeeds.  Otherwise, -1 is returned and <u>ev</u> is updated
           to contain more details about the error.

<b>TOKENIZATION</b> <b>FUNCTIONS</b>
     The tokenization functions use a common data structure, <u>Tokenizer</u>, which is created by <b>tok_init</b>() and
     freed by <b>tok_end</b>().

     The following functions are available:

     <b>tok_init</b>()
           Initialise the tokenizer, and return a data structure to be used by all other tokenizer func-<font color="#ffffff" class="whiteout">tions.&nbsp;functions.</font>
           tions.  <u>IFS</u> contains the Input Field Separators, which defaults to &lt;space&gt; , &lt;tab&gt; , and
           &lt;newline&gt; if NULL.

     <b>tok_end</b>()
           Clean up and finish with <u>t</u>, assumed to have been created with <b>tok_init</b>().

     <b>tok_reset</b>()
           Reset the tokenizer state.  Use after a line has been successfully tokenized by <b>tok_line</b>() or
           <b>tok_str</b>() and before a new line is to be tokenized.

     <b>tok_line</b>()
           Tokenize <u>li</u>, If successful, modify: <u>argv</u> to contain the words, <u>argc</u> to contain the number of
           words, <u>cursorc</u> (if not NULL) to contain the index of the word containing the cursor, and <u>cursoro</u>
           (if not NULL) to contain the offset within <u>argv[cursorc]</u> of the cursor.

           Returns 0 if successful, -1 for an internal error, 1 for an unmatched single quote, 2 for an
           unmatched double quote, and 3 for a backslash quoted &lt;newline&gt;.  A positive exit code indicates
           that another line should be read and tokenization attempted again.

     <b>tok_str</b>()
           A simpler form of <b>tok_line</b>(); <u>str</u> is a NUL terminated string to tokenize.

<b>SEE</b> <b>ALSO</b>
     <a href="../man1/sh.1.html#//apple_ref/doc/man/1/sh">sh(1)</a>, <a href="signal.3.html#//apple_ref/doc/man/3/signal">signal(3)</a>, <!-- a -->curses(3)<!-- /a -->, <a href="../man5/editrc.5.html#//apple_ref/doc/man/5/editrc">editrc(5)</a>

<b>HISTORY</b>
     The <b>editline</b> library first appeared in 4.4BSD.  CC_REDISPLAY appeared in NetBSD 1.3.  CC_REFRESH_BEEP,
     EL_EDITMODE and the readline emulation appeared in NetBSD 1.4.  EL_RPROMPT appeared in NetBSD 1.5.

<b>AUTHORS</b>
     The <b>editline</b> library was written by Christos Zoulas.  Luke Mewburn wrote this manual and implemented
     CC_REDISPLAY, CC_REFRESH_BEEP, EL_EDITMODE, and EL_RPROMPT.  Jaromir Dolecek implemented the readline
     emulation.

<b>BUGS</b>
     At this time, it is the responsibility of the caller to check the result of the EL_EDITMODE operation
     of <b>el_get</b>() (after an <b>el_source</b>() or <b>el_parse</b>()) to determine if <b>editline</b> should be used for further
     input.  I.e., EL_EDITMODE is purely an indication of the result of the most recent <a href="../man5/editrc.5.html#//apple_ref/doc/man/5/editrc">editrc(5)</a> <b>edit</b> com-<font color="#ffffff" class="whiteout">mand.&nbsp;command.</font>
     mand.

BSD                            September 9, 2005                           BSD
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/el_parse.3.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/el_parse.3.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/el_parse.3.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
