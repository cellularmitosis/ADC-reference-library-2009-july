<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Cocoa Fundamentals Guide: Communicating With Objects</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Communicating With Objects"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40002974-CH7" title="Communicating With Objects"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../DesignGuidelines-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000556" target="_top">Design Guidelines</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP40002974-CH1-SW1">Cocoa Fundamentals Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../CocoaDesignPatterns/CocoaDesignPatterns.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../CoreAppArchitecture/CoreAppArchitecture.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40002974-CH7-SW15" title="Communicating With Objects"></a><h1>Communicating With Objects</h1><p>Several of the Cocoa adaptations of design patterns assist communication between objects in an application. These mechanisms and paradigms include delegation, notification, target-action, and the bindings technology. This chapter describes those mechanisms and paradigms.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="CommunicateWithObjects.html#//apple_ref/doc/uid/TP40002974-CH7-SW25">Communication in Object-Oriented Programs</a>
				
			<br/>
			
        
			
			
				<a href="CommunicateWithObjects.html#//apple_ref/doc/uid/TP40002974-CH7-SW3">Outlets</a>
				
			<br/>
			
        
			
			
				<a href="CommunicateWithObjects.html#//apple_ref/doc/uid/TP40002974-CH7-SW18">Delegates and Data Sources</a>
				
			<br/>
			
        
			
			
				<a href="CommunicateWithObjects.html#//apple_ref/doc/uid/TP40002974-CH7-SW14">The Target-Action Mechanism</a>
				
			<br/>
			
        
			
			
				<a href="CommunicateWithObjects.html#//apple_ref/doc/uid/TP40002974-CH7-SW17">Bindings (Mac OS X)</a>
				
			<br/>
			
        
			
			
				<a href="CommunicateWithObjects.html#//apple_ref/doc/uid/TP40002974-CH7-SW7">Notifications</a>
				
			<br/>
			
        
			
			
				<a href="CommunicateWithObjects.html#//apple_ref/doc/uid/TP40002974-CH7-SW16">Ownership of Delegates, Observers, and Targets</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40002974-CH7-SW25" title="Communication in Object-Oriented Programs"></a><h2>Communication in Object-Oriented Programs</h2><p>With Cocoa and Objective-C, the object-oriented language for Cocoa, one way of adding the behavior that is specific to your program is through inheritance. You create a subclass of an existing class that either augments the attributes and behavior of an instance of that class or modifies them in some way. But there are other ways of adding the special logic that characterizes your program. There are other mechanisms for reusing and extending the capabilities of Cocoa objects.</p><p>The relationships between objects in a program exist in more than one dimension. There is the hierarchical structure of inheritance, but objects in a program also exist dynamically, in a network of other objects that must communicate with one another at runtime to get the work of the program done. In a fashion similar to a musician in orchestra, each object in a program has a role, a limited set of behaviors it contributes to the program. It displays an oval surface that responds to mouse clicks, or it manages a collection of objects, or it coordinates the major events in the life of a window. It does what it is designed to do, and nothing more. But for its contributions to be realized in the program, it must be able to communicate them to other objects. It must be able to send messages to other objects or be able to receive messages from other objects.</p><p>Before your object can send a message to another object, it must either have a reference to it or have some delivery mechanism it can rely on. Cocoa gives objects many ways to communicate with each other. These mechanisms and techniques, which are based on design patterns described in <span class="content_text"><a href="../CocoaDesignPatterns/CocoaDesignPatterns.html#//apple_ref/doc/uid/TP40002974-CH6-SW6">“Cocoa Design Patterns,”</a></span> make it possible to construct robust applications efficiently. They range from the simple to the slightly more elaborate, and often are a preferable alternative to subclassing. You can configure them programmatically and sometimes graphically in <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_551"></a>Interface Builder.</p><a name="//apple_ref/doc/uid/TP40002974-CH7-SW3" title="Outlets"></a><h2>Outlets</h2><p><a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_552"></a><a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_553"></a>Object composition is a dynamic pattern that requires an object to somehow acquire references to its constituent objects so that it can send messages to them. It typically holds these other objects as instance variables. These variables must be initialized with the appropriate references at some point during the execution of the program. </p><p>An outlet is such an object instance variable, but it is special in that the reference is configured and archived through Interface Builder. The connections between the containing object and its outlets are reestablished every time the containing object is unarchived from its nib file. The containing object holds an outlet as an instance variable with the type qualifier of <code>IBOutlet</code>. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>@interface AppController : NSObject<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    IBOutlet NSArray *keywords;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Because it is an instance variable, an outlet becomes part of an object’s encapsulated data. But an outlet is more than a simple instance variable. The connection between an object and its outlets is archived in a nib file; when the nib file is loaded, each connection is unarchived and reestablished, and is thus always available whenever it becomes necessary to send messages to the other object. The type qualifier <code>IBOutlet</code> is a tag applied to an instance-variable declaration so that the Interface Builder application can recognize the instance variable as an outlet and synchronize the display and connection of it with Xcode. </p><p>You connect an outlet in Interface Builder, but the procedure starts in Xcode. The following steps describe the procedure:</p><ol class="ol"><li class="li"><p>When defining your custom class, declare an outlet by tagging the instance variable with the <code>IBOutlet</code> qualifier.</p></li><li class="li"><p>In Interface Builder, drag a generic object into the top level of the nib file window (if one doesn’t already exist for your custom class).</p><p>If an instance of your custom class is to be the File’s Owner for the nib file, this step is not necessary. Also, if you’re defining a custom NSView object, select that object instead.</p></li><li class="li"><p>Import the custom class into Interface Builder.</p><p>With the generic object (or File’s Owner) selected, type the name of your custom class in the Class field of the Identity pane of the Interface Builder inspector. This assigns your custom class as the class of the selected object. This step has to be done only once.</p></li><li class="li"><p>Select your custom instance (or File’s Owner).</p></li><li class="li"><p>Right-click or Control-click this object to display the connections panel.</p></li><li class="li"><p>Find your outlet under Outlets and drag a connection line <em>from</em> the circle next to the outlet <em>to</em> the object on the user interface that you want that outlet to reference. </p></li></ol><p><span class="content_text">Figure 5-1</span> illustrates what an outlet connection looks like in the connections panel when you’ve completed these steps. (Note that the circle next to the outlet is filled in and the type of the object is specified.)</p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH7-SW11" title="Figure 5-1Connecting an outlet in Interface Builder"></a><p><strong>Figure 5-1&nbsp;&nbsp;</strong>Connecting an outlet in Interface Builder</p><img src = "../Art/outlets1.jpg" alt = "Connecting an outlet in Interface Builder" ></div><br/><p>An application typically sets outlet connections between its custom controller objects and objects on the user interface, but they can be made between any objects that can be represented as instances in Interface Builder, even between two custom objects. As with any instance variable, you should be able to justify its inclusion in a class; the more instance variables an object has, the more memory it takes up. If there are other ways to obtain a reference to an object, such as finding it through its index position in a matrix, or through its inclusion as a function parameter, or through use of a tag (an assigned numeric identifier), you should do that instead.</p><a name="//apple_ref/doc/uid/TP40002974-CH7-SW18" title="Delegates and Data Sources"></a><h2>Delegates and Data Sources</h2><p>A <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_554"></a><a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_555"></a>delegate is an object that acts on behalf of, or in coordination with, another object when that object encounters an event in a program. The <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_556"></a>delegating object is often a responder object—that is, an object inheriting from <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_557"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/cl/NSResponder" target="_top">NSResponder</a></code> in Application Kit or <code><!--a target="_top" -->UIResponder<!--/a--></code> in UIKit—that is responding to a user event. The delegate is an object that is delegated control of the user interface for that event, or is at least asked to interpret the event in an application-specific manner. </p><p>To better appreciate the value of delegation, it helps to consider an off-the-shelf Cocoa object such as a window (an instance of <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/cl/NSWindow" target="_top">NSWindow</a></code> or <code><!--a target="_top" -->UIWindow<!--/a--></code> ) or a table view (an instance of <code><a href="../../../Reference/ApplicationKit/Classes/NSTableView_Class/Reference/Reference.html#//apple_ref/occ/cl/NSTableView" target="_top">NSTableView</a></code> or <code><!--a target="_top" -->UITableView<!--/a--></code> ). These objects are designed to fulfill a specific role in a generic fashion; a window object in the Application Kit, for example, responds to mouse manipulations of its controls and handles such things as closing, resizing, and moving the physical window. This restricted and generic behavior necessarily limits what the object can know about how an event affects (or will affect) something elsewhere in the application, especially when the affected behavior is specific to your application. Delegation provides a way for your custom object to communicate application-specific behavior to the off-the-shelf object.</p><p>The programming mechanism of delegation gives objects a chance to coordinate their appearance and state with changes occurring elsewhere in a program, changes usually brought about by user actions. More importantly, delegation makes it possible for one object to alter the behavior of another object without the need to inherit from it. The delegate is almost always one of your custom objects, and by definition it incorporates application-specific logic that the generic and delegating object cannot possibly know itself.</p><a name="//apple_ref/doc/uid/TP40002974-CH7-SW26" title="How Delegation Works"></a><h3>How Delegation Works</h3><p>The design of the delegation mechanism is simple (<span class="content_text">Figure 5-2</span>). The delegating class has an outlet or property, usually one that is named <code>delegate</code>; if it is an outlet, it includes methods for setting and accessing the value of the outlet. It also declares, without implementing, one or more methods that constitute a formal protocol or an informal protocol. A formal protocol that uses optional methods—a new feature of Objective-C 2.0—is the preferred approach, but both kinds of protocols are used by the Cocoa frameworks for delegation.</p><p>In the <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_558"></a>informal protocol approach, the delegating class declares methods on a category of <code>NSObject</code>, and the delegate implements only those methods where it has an interest in coordinating itself with the delegating object or affecting that object’s default behavior. If the delegating class declares a formal protocol, the delegate may choose to implement those methods marked optional, but it must implement the required ones. </p><p>After this detail, delegation follows a common design, illustrated by <span class="content_text">Figure 5-2</span>.</p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH7-SW10" title="Figure 5-2The mechanism of delegation"></a><p><strong>Figure 5-2&nbsp;&nbsp;</strong>The mechanism of delegation</p><img src = "../Art/delegation1.jpg" alt = "The mechanism of delegation" ></div><br/><p>The methods of the protocol mark significant events handled or anticipated by the delegating object. This object wants either to communicate these events to the delegate or, for impending events, to request input or approval from the delegate. For example, when a user clicks the close button of a window in Mac OS X, the window object sends the <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/instm/NSObject/windowShouldClose:" target="_top">windowShouldClose:</a></code> message to its delegate; this gives the delegate the opportunity to veto or defer the closing of the window if, for example, the window has associated data that must be saved (see <span class="content_text">Figure 5-3</span>). </p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH7-SW9" title="Figure 5-3A more realistic sequence involving a delegate"></a><p><strong>Figure 5-3&nbsp;&nbsp;</strong>A more realistic sequence involving a delegate</p><img src = "../Art/delegation2.jpg" alt = "A more realistic sequence involving a delegate" ></div><br/><p>The delegating object sends a message only if the delegate implements the method. It makes this discovery by invoking the <code>NSObject</code> <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_559"></a>method <code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/respondsToSelector:" target="_top">respondsToSelector:</a></code> in the delegate first. </p><a name="//apple_ref/doc/uid/TP40002974-CH7-SW22" title="The Form of Delegation Messages"></a><h3>The Form of Delegation Messages</h3><p><a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_560"></a>Delegation methods have a conventional form. They begin with the name of the Application Kit or UIKit object doing the delegating—application, window, control, and so on; this name is in lower-case and without the “NS” or “UI” prefix. Usually (but not always) this object name is followed by an auxiliary verb indicative of the temporal status of the reported event. This verb, in other words, indicates whether the event is about to occur (“Should” or “Will”) or whether it has just occurred (“Did” or “Has”). This temporal distinction helps to categorize those messages that expect a return value and those that don’t. <span class="content_text">Listing 5-1</span> includes a few Application Kit delegation methods that expect a return value.</p><a name="//apple_ref/doc/uid/TP40002974-CH7-SW5" title="Listing 5-1Sample delegation methods with return values"></a><p class="codesample"><strong>Listing 5-1&nbsp;&nbsp;</strong>Sample delegation methods with return values</p><div class="codesample"><table><tr><td scope="row"><pre>- (BOOL)application:(NSApplication *)sender openFile:(NSString *)filename; // NSApplication<span></span></pre></td></tr><tr><td scope="row"><pre>- (BOOL)application:(UIApplication *)application handleOpenURL:(NSURL *)url; // UIApplicationDelegate<span></span></pre></td></tr><tr><td scope="row"><pre>- (NSApplicationTerminateReply)applicationShouldTerminate:(NSApplication *)sender; // NSApplication<span></span></pre></td></tr><tr><td scope="row"><pre>- (UITableRowIndexSet *)tableView:(NSTableView *)tableView willSelectRows:(UITableRowIndexSet *)selection; // UITableViewDelegate<span></span></pre></td></tr><tr><td scope="row"><pre>- (NSRect)windowWillUseStandardFrame:(NSWindow *)window defaultFrame:(NSRect)newFrame; // NSWindow<span></span></pre></td></tr></table></div>	<p>The delegate that implements these methods can block the impending event (by returning <code>NO</code> in the first two methods), defer the impending event (by returning <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/c/econst/NSTerminateLater" target="_top">NSTerminateLater</a></code> in the <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/instm/NSObject/applicationShouldTerminate:" target="_top">applicationShouldTerminate:</a></code> <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_561"></a>method), or alter a suggested value (the frame rectangle and the index set in the last two methods).</p><p>Other delegation methods are invoked by messages that don’t expect a return value and so are typed to return <code>void</code>. These messages are purely informational, and the method names often contain “Did” or some other indication of a transpired event. <span class="content_text">Listing 5-2</span> shows a few examples of this kind of delegation method.</p><a name="//apple_ref/doc/uid/TP40002974-CH7-SW8" title="Listing 5-2Sample delegation methods returning void"></a><p class="codesample"><strong>Listing 5-2&nbsp;&nbsp;</strong>Sample delegation methods returning <code>void</code></p><div class="codesample"><table><tr><td scope="row"><pre>- (void) tableView:(NSTableView*)tableView mouseDownInHeaderOfTableColumn:(NSTableColumn *)tableColumn; // NSTableView<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)windowDidMove:(NSNotification *)notification; // NSWindow<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)application:(UIApplication *)application willChangeStatusBarFrame:(CGRect)newStatusBarFrame; // UIApplication<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)applicationWillBecomeActive:(NSNotification *)notification; // NSApplication<span></span></pre></td></tr></table></div>	<p>There are couple of things to note about this last group of messages. The first is that an auxiliary verb of “Will” (as in the third method) does not necessarily mean that a return value is expected. In this case, the event is imminent and cannot be blocked, but the message gives the delegate an opportunity to prepare the program for the event. </p><p>The other point of interest concerns the second and last method declarations in <span class="content_text">Listing 5-2</span> . The sole parameter of each of these methods is an <code><a href="../../../Reference/Foundation/Classes/NSNotification_Class/Reference/Reference.html#//apple_ref/occ/cl/NSNotification" target="_top">NSNotification</a></code> object, which means that these methods are invoked as the result of the posting of a particular notification. For example, the <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/instm/NSObject/windowDidMove:" target="_top">windowDidMove:</a></code> method is associated with the <code>NSWindow</code> method <code><!--a target="_top" -->NSWindowDidMoveNotification<!--/a--></code>. The section <span class="content_text"><a href="CommunicateWithObjects.html#//apple_ref/doc/uid/TP40002974-CH7-SW7">“Notifications”</a></span> discusses <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_562"></a>notifications in detail, but here it’s important to understand the relation of notifications to delegation messages in the Application Kit. The delegating object automatically makes its delegate an observer of all notifications it posts. All the delegate needs to do is implement the associated method to get the notification.</p><p>To make an instance of your custom class the <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_563"></a>delegate of an Application Kit object, simply connect the instance to the <code>delegate</code> outlet or property in Interface Builder. Or you can set it programmatically through the delegating object’s <code>setDelegate:</code> method or <code>delegate</code> property, preferably early on, such as in the <code><a href="../../../Reference/ApplicationKit/Protocols/NSNibAwaking_Protocol/Reference/Reference.html#//apple_ref/occ/instm/NSObject/awakeFromNib" target="_top">awakeFromNib</a></code> <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_564"></a> or <code><!--a target="_top" -->applicationDidFinishLaunching:<!--/a--></code> method.</p><a name="//apple_ref/doc/uid/TP40002974-CH7-SW27" title="Delegation and the Cocoa Application Frameworks"></a><h3>Delegation and the Cocoa Application Frameworks</h3><p>The <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_565"></a>delegating object in a Cocoa application is often a responder object such as a <code><!--a target="_top" -->UIApplication<!--/a--></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/cl/NSWindow" target="_top">NSWindow</a></code>, or <code><a href="../../../Reference/ApplicationKit/Classes/NSTableView_Class/Reference/Reference.html#//apple_ref/occ/cl/NSTableView" target="_top">NSTableView</a></code> object. The delegate object itself is typically, but not necessarily, an object, often a custom object, that controls some part of the application (that is, a <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_566"></a>coordinating controller object). <span class="content_text">Table 5-1</span> lists the Application Kit classes that define a delegate.</p><a name="//apple_ref/doc/uid/TP40002974-CH7-SW1" title="Table 5-1Application Kit classes with delegates"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 5-1&nbsp;&nbsp;</strong>Application Kit classes with delegates</caption><tr><td  scope="row"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/cl/NSApplication" target="_top">NSApplication</a></code></p></td><td ><p><code><a href="../../../Reference/ApplicationKit/Classes/NSFontManager_Class/Reference/Reference.html#//apple_ref/occ/cl/NSFontManager" target="_top">NSFontManager</a></code></p></td><td ><p><code><a href="../../../Reference/ApplicationKit/Classes/NSSplitView_Class/Reference/Reference.html#//apple_ref/occ/cl/NSSplitView" target="_top">NSSplitView</a></code></p></td><td ><p><code><a href="../../../Reference/ApplicationKit/Classes/NSTextField_Class/Reference/Reference.html#//apple_ref/occ/cl/NSTextField" target="_top">NSTextField</a></code></p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSBrowser_Class/Reference/Reference.html#//apple_ref/occ/cl/NSBrowser" target="_top">NSBrowser</a></code></p></td><td ><p><code><a href="../../../Reference/ApplicationKit/Classes/NSFontPanel_Class/Reference/Reference.html#//apple_ref/occ/cl/NSFontPanel" target="_top">NSFontPanel</a></code></p></td><td ><p><code><a href="../../../Reference/ApplicationKit/Classes/NSTableView_Class/Reference/Reference.html#//apple_ref/occ/cl/NSTableView" target="_top">NSTableView</a></code></p></td><td ><p><code><a href="../../../Reference/ApplicationKit/Classes/NSTextView_Class/Reference/Reference.html#//apple_ref/occ/cl/NSTextView" target="_top">NSTextView</a></code></p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSControl_Class/Reference/Reference.html#//apple_ref/occ/cl/NSControl" target="_top">NSControl</a></code></p></td><td ><p><code><a href="../../../Reference/ApplicationKit/Classes/NSMatrix_Class/Reference/Reference.html#//apple_ref/occ/cl/NSMatrix" target="_top">NSMatrix</a></code></p></td><td ><p><code><a href="../../../Reference/ApplicationKit/Classes/NSTabView_Class/Reference/Reference.html#//apple_ref/occ/cl/NSTabView" target="_top">NSTabView</a></code></p></td><td ><p><code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/cl/NSWindow" target="_top">NSWindow</a></code></p></td></tr><tr><td  scope="row"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSDrawer_Class/Reference/Reference.html#//apple_ref/occ/cl/NSDrawer" target="_top">NSDrawer</a></code></p></td><td ><p><code><a href="../../../Reference/ApplicationKit/Classes/NSOutlineView_Class/Reference/Reference.html#//apple_ref/occ/cl/NSOutlineView" target="_top">NSOutlineView</a></code></p></td><td ><p><code><a href="../../../Reference/ApplicationKit/Classes/NSText_Class/Reference/Reference.html#//apple_ref/occ/cl/NSText" target="_top">NSText</a></code></p></td><td ><p></p></td></tr></table></div><p>The UIKit framework also uses delegation extensively and always implements it using formal protocols. The application delegate is extremely important in an application running on iPhone OS, as it must respond to application-launch, application-quit, low-memory, and other messages from the application object. The application delegate must adopt the <code><!--a target="_top" -->UIApplicationDelegate<!--/a--></code> protocol.</p><p>Delegating objects do not (and should not) retain their <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_567"></a>delegates. However, clients of delegating objects (applications, usually) are responsible for ensuring that their delegates are around to receive delegation messages. To do this, they may have to retain the delegate in memory-managed code. This precaution applies equally to data sources, notification observers, and targets of action messages.</p><p>Some Application Kit classes have a more restricted type of delegate called a <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_568"></a>modal delegate. Objects of these classes (<code><a href="../../../Reference/ApplicationKit/Classes/NSOpenPanel_Class/Reference/Reference.html#//apple_ref/occ/cl/NSOpenPanel" target="_top">NSOpenPanel</a></code>, for example) run modal dialogs that invoke a handler method in the designated delegate when the user clicks the dialog’s OK button. Modal delegates are limited in scope to the operation of the modal dialog.</p><p>The existence of delegates has other programmatic uses. For example, with delegates it is easy for two coordinating controllers in the same program to find and communicate with each other. For example, the object controlling the application overall can find the controller of the application’s inspector window (assuming it’s the current key window) using code similar to the following:</p><div class="codesample"><table><tr><td scope="row"><pre>id winController = [[NSApp keyWindow] delegate];<span></span></pre></td></tr></table></div><p>And your code can find the application-controller object—by definition, the delegate of the global application instance—by doing something similar to the following:</p><div class="codesample"><table><tr><td scope="row"><pre>id appController = [NSApp delegate];<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002974-CH7-SW28" title="Data Sources"></a><h3>Data Sources</h3><p>A <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_569"></a>data source is like a delegate except that, instead of being delegated control of the user interface, it is delegated control of data. A data source is an outlet held by <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/cl/NSView" target="_top">NSView</a></code> and <code><!--a target="_top" -->UIView<!--/a--></code> objects such as table views and outline views that require a source from which to populate their rows of visible data. The data source for a view is usually the same object that acts as its delegate, but it can be any object. As with the delegate, the data source must implement one or more methods of an informal protocol to supply the view with the data it needs and, in more advanced implementations, to handle data that users directly edit in such views.</p><p>As with delegates, data sources are objects that must be present to receive messages from the objects requesting data. The application that uses them must ensure their persistence, retaining them if necessary in memory-managed code.</p><p>Data sources are responsible for the persistence of the objects they hand out to user-interface objects. In other words, they are responsible for the memory management of those objects. However, whenever a view object such as an outline view or table view accesses the data from a data source, it retains the objects as long as it uses the data. But it does not use the data very long. Typically it holds on to the data only long enough to display it. </p><a name="//apple_ref/doc/uid/TP40002974-CH7-SW29" title="Implementing a Delegate for a Custom Class"></a><h3>Implementing a Delegate for a Custom Class</h3><p>To implement a <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_570"></a>delegate for your custom class, complete the following steps:</p><ul class="spaceabove"><li class="li"><p>Declare the delegate accessor methods in your class header file.</p><div class="codesample"><table><tr><td scope="row"><pre>- (id)delegate;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setDelegate:(id)newDelegate;<span></span></pre></td></tr></table></div></li><li class="li"><p>Implement the accessor methods. In a memory-managed program, to avoid retain cycles, the setter method should not retain or copy your delegate.</p><div class="codesample"><table><tr><td scope="row"><pre>- (id)delegate {<span></span></pre></td></tr><tr><td scope="row"><pre>    return delegate;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setDelegate:(id)newDelegate {<span></span></pre></td></tr><tr><td scope="row"><pre>    delegate = newDelegate;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>In a garbage-collected environment, where retain cycles are not a problem, you should not make the delegate a weak reference (by using the <code>__weak</code> type modifier). For more on retain cycles, see “<span class="content_text"><a href="../../MemoryMgmt/Articles/mmObjectOwnership.html#//apple_ref/doc/uid/20000043" target="_top">Object Ownership and Disposal</a></span>“ in <em><a href="../../MemoryMgmt/index.html#//apple_ref/doc/uid/10000011i" target="_top">Memory Management Programming Guide for Cocoa</a></em>. For more on weak references in garbage collection, see “<span class="content_text"><a href="../../GarbageCollection/Articles/gcEssentials.html#//apple_ref/doc/uid/TP40002452" target="_top">Garbage Collection for Cocoa Essentials</a></span>.“</p></li><li class="li"><p>Declare a formal or informal protocol containing the programmatic interface for the delegate. Informal protocols are categories on the <code>NSObject</code> class. If you declare a formal protocol for your delegate, make sure you mark groups of optional methods with the <code>@optional</code> directive.</p><p><span class="content_text"><a href="CommunicateWithObjects.html#//apple_ref/doc/uid/TP40002974-CH7-SW22">“The Form of Delegation Messages”</a></span> gives advice for naming your own delegation methods.</p></li><li class="li"><p>Before invoking a delegation method make sure the delegate implements it by sending it a <code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/respondsToSelector:" target="_top">respondsToSelector:</a></code> message.</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)someMethod {<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( [delegate respondsToSelector:@selector(operationShouldProceed)] ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        if ( [delegate operationShouldProceed] ) {<span></span></pre></td></tr><tr><td scope="row"><pre>            // do something appropriate<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The precaution is necessary only for optional methods in a formal protocol or methods of an informal protocol.</p></li></ul><p><a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_571"></a></p><a name="//apple_ref/doc/uid/TP40002974-CH7-SW14" title="The Target-Action Mechanism"></a><h2>The Target-Action Mechanism</h2><p><a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_572"></a>While delegation, bindings, and notification are useful for handling certain forms of communication between objects in a program, they are not particularly suitable for the most visible sort of communication. A typical application's user interface consists of a number of graphical objects, and perhaps the most common of these objects are controls. A <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_573"></a>control is a graphical analogue of a real-world or logical device (button, slider, check boxes, and so on); as with a real-world control, such as a radio tuner, you use it to convey your intent to some system of which it is a part—in our case, an application. </p><p>The role of a control on a user interface is simple: It interprets the intent of the user and instructs some other object to carry out that request. When a user acts on the control by, say, clicking it or pressing the Return key, the hardware device generates a raw event. The control accepts the event (as appropriately packaged for Cocoa) and translates it into an instruction that is specific to the application. However, events by themselves don't give much information about the user's intent; they merely tell you that the user clicked a mouse button or pressed a key. So some mechanism must be called upon to provide the translation between event and instruction. This mechanism is called target-action.</p><p>Cocoa uses the target-action mechanism for communication between a control and another object. This mechanism allows the control and, in Mac OS X, its cell or cells, to encapsulate the information necessary to send an application-specific instruction to the appropriate object. The receiving object—typically an instance of a custom class—is called the <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_574"></a>target. The <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_575"></a>action is the message that the control sends to the target. The object that is interested in the user event—the target—is the one that imparts significance to it, and this significance is usually reflected in the name it gives to the action. </p><a name="//apple_ref/doc/uid/TP40002974-CH7-SW31" title="The Target"></a><h3>The Target</h3><p>A <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_576"></a>target is a receiver of an action message. A control or, more frequently, its cell holds the target of its action message as an outlet (see <span class="content_text"><a href="CommunicateWithObjects.html#//apple_ref/doc/uid/TP40002974-CH7-SW3">“Outlets”</a></span>). The target usually is an instance of one of your custom classes, although it can be any Cocoa object whose class implements the appropriate action method. </p><p>You can also set a cell's or control's target outlet to <code>nil</code> and let the target object be determined at run time. When the target is <code>nil</code>, the application object (<code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/cl/NSApplication" target="_top">NSApplication</a></code> or <code><!--a target="_top" -->UIApplication<!--/a--></code>) searches for an appropriate receiver in a prescribed order:</p><ol class="ol"><li class="li"><p>It begins with the first <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_577"></a><a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_578"></a>responder in the key window and follows <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/nextResponder" target="_top">nextResponder</a></code> links up the responder chain to the window object’s (<code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/cl/NSWindow" target="_top">NSWindow</a></code> or <code><!--a target="_top" -->UIWindow<!--/a--></code>) content view.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH7-SW46" title="Note"></a><p><strong>Note:</strong>&nbsp;A key window in Mac OS X responds to key presses for an application and is the receiver of messages from menus and dialogs. An application’s main window is the principal focus of user actions and often has key status as well. </p></div></li><li class="li"><p>It tries the window object and then the window object’s delegate.</p></li><li class="li"><p>If the main window is different from the key window, it then starts over with the first responder in the main window and works its way up the main window’s responder chain to the window object and its delegate. </p></li><li class="li"><p>Next, the application <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_579"></a>object tries to respond itself. If it can’t respond, it tries its own delegate. The application object and its delegate are the receivers of last resort. </p></li></ol><p>Control objects do not (and should not) retain their targets. However, clients of controls sending action messages (applications, usually) are responsible for ensuring that their targets are available to receive action messages. To do this, they may have to retain their targets in memory-managed environments. This precaution applies equally to delegates and data sources.</p><a name="//apple_ref/doc/uid/TP40002974-CH7-SW32" title="The Action"></a><h3>The Action</h3><p>An <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_580"></a>action is the message a control sends to the target or, from the perspective of the target, the method it implements to respond to the action. A control or— as is frequently the case in the Application Kit—a control’s cell stores an action as an instance variable of <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_581"></a>type <code>SEL</code>. <code>SEL</code> is an Objective-C data type used to specify the <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_582"></a>signature of a message. An action message must have a simple, distinct signature. The method it invokes returns nothing and has a sole argument of type <code>id</code>. This argument, by convention, is named <code>sender</code>. Here is an example from the <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/cl/NSResponder" target="_top">NSResponder</a></code> class, which defines a number of action methods: </p><div class="codesample"><table><tr><td scope="row"><pre>- (void)capitalizeWord:(id)sender;<span></span></pre></td></tr></table></div><p>Action methods declared by Cocoa classes can also have the equivalent signature: </p><div class="codesample"><table><tr><td scope="row"><pre>- (IBAction) deleteRecord:(id)sender;<span></span></pre></td></tr></table></div><p>In this case, <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_583"></a><code>IBAction</code> does not designate a data type for a return value; no value is returned. <code>IBAction</code> is a type qualifier that <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_584"></a>Interface Builder notices during application development to synchronize actions added programmatically with its internal list of action methods defined for a project.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH7-SW47" title="iPhone OS Note"></a><p><strong>iPhone OS Note:</strong>&nbsp;In UIKit, action selectors can also take two other forms. See <span class="content_text"><a href="CommunicateWithObjects.html#//apple_ref/doc/uid/TP40002974-CH7-SW44">“Target-Action in UIKit”</a></span> for details. </p></div><p>The <code>sender</code> <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_585"></a>parameter usually identifies the control sending the action message (although it can be another object substituted by the actual sender). The idea behind this is similar to a return address on a postcard. The target can query the sender for more information if it needs to. If the actual sending object substitutes another object as sender, you should treat that object in the same way. For example, say you have a text field and when the user enters text, the (arbitrarily named) action method <code>nameEntered:</code> is invoked in the target:</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)nameEntered:(id) sender {<span></span></pre></td></tr><tr><td scope="row"><pre>    NSString *name = [sender stringValue];<span></span></pre></td></tr><tr><td scope="row"><pre>    if (![name isEqualToString:@""]) {<span></span></pre></td></tr><tr><td scope="row"><pre>        NSMutableArray *names = [self nameList];<span></span></pre></td></tr><tr><td scope="row"><pre>        [names addObject:name];<span></span></pre></td></tr><tr><td scope="row"><pre>        [sender setStringValue:@""];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here the responding method extracts the contents of the text field, adds the string to an array cached as an instance variable, and clears the field. Other possible queries to sender would be asking an <code>NSMatrix</code> object for its selected row (<code>[sender selectedRow]</code>), asking an <code>NSButton</code> object for its state (<code>[sender state]</code>), and asking any cell associated with a control for its tag (<code>[[sender cell] tag]</code>), a tag being an arbitrary identifier.</p><a name="//apple_ref/doc/uid/TP40002974-CH7-SW48" title="Target-Action in the Application Kit"></a><h3>Target-Action in the Application Kit</h3><a name="//apple_ref/doc/uid/TP40002974-CH7-SW30" title="Controls, Cells, and Menu Items"></a><h4>Controls, Cells, and Menu Items</h4><p>Most controls in the Application Kit are objects that inherit from the <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_586"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSControl_Class/Reference/Reference.html#//apple_ref/occ/cl/NSControl" target="_top">NSControl</a></code> class. Although a control has the initial responsibility for sending an action message to its target, it rarely carries the information needed to send the message. For this, it usually relies on its <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_587"></a>cell or cells.</p><p>A control almost always has one or more cells—objects that inherit from <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_588"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSCell_Class/Reference/NSCell.html#//apple_ref/occ/cl/NSCell" target="_top">NSCell</a></code>—associated with it. Why is there this association? A control is a relatively “heavy” object because it inherits all the combined instance variables of its ancestors, which include the <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/cl/NSView" target="_top">NSView</a></code> and <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/cl/NSResponder" target="_top">NSResponder</a></code> classes. Because controls are expensive, cells are used to subdivide the screen real estate of a control into various functional areas. Cells are lightweight objects that can be thought of as overlaying all or part of the control. But it's not only a division of area, it's a division of labor. Cells do some of the drawing that controls would otherwise have to do, and cells hold some of the data that controls would otherwise have to carry. Two items of this data are the instance variables for target and action. <span class="content_text"><a href="CommunicateWithObjects.html#//apple_ref/doc/uid/TP40002974-CH7-SW2">Figure 5-4</a></span> depicts the <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_589"></a>control-cell mechanism.</p><p>Being abstract classes, <code>NSControl</code> and <code>NSCell</code> both incompletely handle the setting of the target and action instance variables. By default, <code>NSControl</code> simply sets the information in its associated cell, if one exists. (<code>NSControl</code> itself supports only a one-to-one mapping between itself and a cell; subclasses of <code>NSControl</code> such as <code><a href="../../../Reference/ApplicationKit/Classes/NSMatrix_Class/Reference/Reference.html#//apple_ref/occ/cl/NSMatrix" target="_top">NSMatrix</a></code> support multiple cells.) In its default implementation, <code>NSCell</code> simply raises an exception. You must go one step further down the inheritance chain to find the class that really implements the setting of target and action: <code><a href="../../../Reference/ApplicationKit/Classes/NSActionCell_Class/Reference/Reference.html#//apple_ref/occ/cl/NSActionCell" target="_top">NSActionCell</a></code>.</p><p>Objects derived from <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_590"></a><code>NSActionCell</code> provide target and action values to their controls so the controls can compose and send an action message to the proper receiver. An <code>NSActionCell</code> object handles mouse (cursor) tracking by highlighting its area and assisting its control in sending action messages to the specified target. In most cases, the responsibility for an <code>NSControl</code> object’s appearance and behavior is completely given over to a corresponding <code>NSActionCell</code> object. (<code>NSMatrix</code>, and its subclass <code><a href="../../../Reference/ApplicationKit/Classes/NSForm_Class/Reference/Reference.html#//apple_ref/occ/cl/NSForm" target="_top">NSForm</a></code>, are subclasses of NSControl that don’t follow this rule.) </p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH7-SW2" title="Figure 5-4How the target&acirc;&#128;&#147;action mechanism works"></a><p><strong>Figure 5-4&nbsp;&nbsp;</strong>How the target–action mechanism works</p><img src = "../Art/target_action.gif" alt = "How the target–action mechanism works" width="494" height="253"></div><br/><p>When users choose an item from a menu, an <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_591"></a>action is sent to a <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_592"></a>target. Yet menus (<a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_593"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSMenu_Class/Reference/Reference.html#//apple_ref/occ/cl/NSMenu" target="_top">NSMenu</a></code> objects) and their items (<a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_594"></a><code><a href="../../../Reference/ApplicationKit/Classes/NSMenuItem_Class/Reference/Reference.html#//apple_ref/occ/cl/NSMenuItem" target="_top">NSMenuItem</a></code> objects) are completely separate, in an architectural sense, from controls and cells. The NSMenuItem class implements the target–action mechanism for its own instances; an NSMenuItem object has both target and action instance variables (and related accessor methods) and sends the action message to the target when a user chooses it.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH7-SW49" title="Note"></a><p><strong>Note:</strong>&nbsp;<span class="content_text"><a href="../CoreAppArchitecture/CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8-SW13">“Controls and Menus”</a></span> discusses control-cell and menu architecture in greater detail. Also see <em><a href="../../ControlCell/index.html#//apple_ref/doc/uid/10000015i" target="_top">Control and Cell Programming Topics for Cocoa</a></em> and <em><a href="../../MenuList/index.html#//apple_ref/doc/uid/10000032i" target="_top">Application Menu and Pop-up List Programming Topics for Cocoa</a></em>.</p></div><a name="//apple_ref/doc/uid/TP40002974-CH7-SW34" title="Setting the Target and Action"></a><h4>Setting the Target and Action</h4><p>You can set the <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_595"></a>targets and <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_596"></a>actions of cells and controls programmatically or by using Interface Builder. For most developers and most situations, Interface Builder is the preferred approach. When you use it to set controls and targets, Interface Builder provides visual confirmation, allows you to lock the connections, and archives the connections to a nib file. The procedure, which is covered in more detail in the development-tools documentation, is simple:</p><ol class="ol"><li class="li"><p>When defining your custom class in Xcode, declare an action method using the <code>IBAction</code> qualifier.</p></li><li class="li"><p>In Interface Builder, drag a generic object into the top level of the nib file window (if one doesn’t already exist for your custom class). </p><p>If an instance of your custom class is to be the File’s Owner for the nib file, this step is not necessary. Also, if you’re defining a custom <code>NSView</code> object, select that object instead.</p></li><li class="li"><p>Import the custom class into Interface Builder.</p><p>With the generic object (or File’s Owner) selected, type the name of your custom class in the Class field of the Identify pane of the Interface Builder inspector. This assigns your custom class as the class of the selected object. This step is performed once.</p></li><li class="li"><p>Select the control or cell that is to send the action message to your custom object.</p></li><li class="li"><p>Right-click or Control-click this object to display the connections panel.</p></li><li class="li"><p>Find your action method under Sent Actions. Then drag a connection line <em>from</em> the circle next to the action method <em>to</em> the icon representing the instance of your custom class. </p></li></ol><p><span class="content_text">Figure 5-5</span> illustrates what an action connection looks like in the connections panel when you’ve completed these steps.</p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH7-SW24" title="Figure 5-5Setting target and action in Interface Builder"></a><p><strong>Figure 5-5&nbsp;&nbsp;</strong>Setting target and action in Interface Builder</p><img src = "../Art/actions_1.jpg" alt = "Setting target and action in Interface Builder" ></div><br/><p>If the action is handled by a superclass of your custom class or by an off-the-shelf Application Kit or UIKit class, you can make the connection without declaring any action method. Of course, if you declare an action method yourself, you must be sure to implement it.</p><p>To set the action and the target programmatically, use the following methods to send messages to a control or cell object:</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)setTarget:(id)anObject;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setAction:(SEL)aSelector;<span></span></pre></td></tr></table></div><p>The following example shows how you might use these methods:</p><div class="codesample"><table><tr><td scope="row"><pre>[aCell setTarget:myController];<span></span></pre></td></tr><tr><td scope="row"><pre>[aControl setAction:@selector(deleteRecord:)];<span></span></pre></td></tr><tr><td scope="row"><pre>[aMenuItem setAction:@selector(showGuides:)];<span></span></pre></td></tr></table></div><p>Programmatically setting the target and action does have its advantages and indeed in certain situations it is the only possible approach. For example, you might want the target or action to vary according to some runtime condition, such as whether a network connection exists or whether an inspector window has been loaded. Another example is when you are dynamically populating the items of a pop-up menu, and you want each pop-up item to have its own action.<a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_597"></a></p><a name="//apple_ref/doc/uid/TP40002974-CH7-SW33" title="Actions Defined by the Application Kit"></a><h4>Actions Defined by the Application Kit</h4><p>The Application Kit not only includes many <code>NSActionCell</code>-based controls for sending action messages, it defines action methods in many of its classes. Some of these actions are connected to default targets when you create a Cocoa application project. For example, the Quit command in the application menu is connected to the <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/instm/NSApplication/terminate:" target="_top">terminate:</a></code> method in the <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_598"></a>global application object (<code>NSApp</code>).</p><p>The <code>NSResponder</code> class also defines many default <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_599"></a>action messages (also known as standard commands) for common operations on text. This allows the Cocoa text system to send these action messages up an application's responder chain—a hierarchical sequence of event-handling objects—where it can be handled by the first <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/cl/NSView" target="_top">NSView</a></code>, <code>NSWindow</code>, or <code>NSApplication</code> object that implements the corresponding method. </p><a name="//apple_ref/doc/uid/TP40002974-CH7-SW44" title="Target-Action in UIKit"></a><h3>Target-Action in UIKit</h3><p>The UIKit framework also declares and implements a suite of control classes; the control classes in this framework inherit from the <code><!--a target="_top" -->UIControl<!--/a--></code> class, which defines most of the target-action mechanism for iPhone OS. However there are some fundamental differences in how the two frameworks implement target-action. One of these differences is that UIKit does not have any true cell classes. Controls in UIKit do not rely upon their cells for target and action information.</p><p>A larger difference in how the two frameworks implement target-action lies in the nature of the event model. In the Application Kit, the user typically uses a mouse and keyboard to register events for handling by the system. These events—such as the click of a mouse pointer on a button—are limited and discrete. Consequently, a control object in the Application Kit usually recognizes a single physical event as the trigger for the action it sends to its target. (In the case of buttons, this is a mouse-up event.) On iPhone OS, the user’s fingers are what originate events instead of mouse clicks, mouse drags, or physical keystrokes. There can be more than one of these fingers touching an object on the screen at one time, and these “touches” can even be going in different directions.</p><p>To account for this Multi-Touch event model, UIKit declares a set of “control event" constants in <code>UIControl.h</code> that specify various physical gestures that users can make on controls, such as lifting a finger from a control, dragging a finger into a control, and touching down within a text field. You can configure a control object so that it responds to one or more of these touch events by sending an action message to a target. Many of the control classes in UIKit are implemented to generate certain control events; for example, instances of the <code><!--a target="_top" -->UISlider<!--/a--></code> class generate a <code><!--a target="_top" -->UIControlEventValueChanged<!--/a--></code> control event, which you can use to send an action message to a target object.</p><p>You set up a control so that it sends an action message to a target object by associating both target and action with one or more control events. To do this, send <code><!--a target="_top" -->addTarget:action:forControlEvents:<!--/a--></code> to the control for each target-action pair you wish to specify. When the user touches the control in a designated fashion, the control forwards the action message to the global <code>UIApplication</code> object in a <code><!--a target="_top" -->sendAction:to:from:forEvent:<!--/a--></code> message. As in the Application Kit, the global application object is the centralized dispatch point for action messages. If the control specifies a <code>nil</code> target for an action message, the application queries objects in the responder chain until it finds one that is willing to handle the action message—that is, one implementing a method corresponding to the action selector. </p><p>In contrast with the Application Kit, where an action method may have only one or perhaps two valid signatures, the UIKit framework allows three different forms of action selector:</p><ul class="simple"><li><p><code>- (void)action</code></p></li><li><p><code>- (void)action:(id)sender</code></p></li><li><p><code>- (void)action:(id)sender forEvent:(UIEvent *)event</code></p></li></ul><p>To learn more about the target-action mechanism in UIKit, read <em><!--a target="_top" -->UIControl Class Reference<!--/a--></em>.</p><a name="//apple_ref/doc/uid/TP40002974-CH7-SW17" title="Bindings (Mac OS X)"></a><h2>Bindings (Mac OS X)</h2><p><a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_600"></a>Bindings are a Cocoa technology that you can use to synchronize the display and storage of data in a Cocoa application created for Mac OS X. They are an important tool in the Cocoa toolbox for enabling communication between objects. The technology is an adaptation of both the <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_601"></a>Model-View-Controller and <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_602"></a>object modeling design patterns. (<span class="content_text"><a href="../CocoaDesignPatterns/CocoaDesignPatterns.html#//apple_ref/doc/uid/TP40002974-CH6-SW1">“The Model-View-Controller Design Pattern”</a></span> introduced bindings in its discussion of <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_603"></a>controller objects.) It allows you to establish a mediated connection—a binding—between the attribute of a view object that displays a value and a model-object property that stores that value; when a change occurs in the value in one side of the connection, it is automatically reflected in the other. The controller object that mediates the connection provides additional support, including selection management, placeholder values, and sortable tables. </p><a name="//apple_ref/doc/uid/TP40002974-CH7-SW35" title="How Bindings Work"></a><h3>How Bindings Work</h3><p>Bindings inhabit the conceptual space defined by the Model-View-Controller (MVC) and object modeling design patterns. An MVC application assigns objects general roles and maintains separation between objects based on these roles. Objects can be view objects, model objects, or controller objects whose roles can be briefly stated as follows: </p><ul class="spaceabove"><li class="li"><p>View objects display the data of the application.</p></li><li class="li"><p>Model objects encapsulate and operate on application data. They are typically the persistent objects that your users create and save while an application is running.</p></li><li class="li"><p>Controller objects mediate the exchange of data between view and model objects and also perform "command and control" services for the application.</p></li></ul><p>All objects, but most importantly model objects, have defining components or characteristics called properties. Properties can be of two sorts: attributes—values such as strings, scalars, and data structures—and relationships to other objects. Relationships can be of two sorts: one-to-one and one-to-many. They can also be bidirectional and reflexive. The objects of an application thus have various relationships with each other, and this web of objects is called an <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_604"></a><a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_605"></a>object graph. A property has an identifying name called a key. Using key paths—period-separated sequences of keys—one can traverse the relationships in an object graph to access the attributes of related objects.  </p><p>The <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_606"></a>bindings technology makes use of this object model to establish bindings among the view, model, and controller objects of an application. With bindings you can extend the web of relationships from the object graph of model objects to the controller and view objects of an application. You can establish a binding between an attribute of a view object and a property of a model object (typically through a mediating property of a controller object). Any change in the displayed attribute value is automatically propagated through the binding to the property where the value is stored. And any internal change in the value of the property is communicated back to the view for display. </p><p>For example, <span class="content_text"><a href="CommunicateWithObjects.html#//apple_ref/doc/uid/TP40002974-CH7-SW21">Figure 5-6</a></span> shows a simplified set of bindings between the displayed values of a slider and a text field (attributes of those view objects) and the <code>number</code> attribute of a model object (<code>MyObject</code>) through the <code>content</code> property of a controller object. With these bindings established, if a user moves the slider, the change in value would be applied to the <code>number</code> attribute and communicated back to the text field for display. </p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH7-SW21" title="Figure 5-6Bindings between view, controller, and model objects"></a><p><strong>Figure 5-6&nbsp;&nbsp;</strong>Bindings between view, controller, and model objects</p><img src = "../Art/sliderbindings.gif" alt = "Bindings between view, controller, and model objects" width="438" height="220"></div><br/><p>The implementation of bindings rests on the enabling mechanisms of <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_607"></a>key-value coding, <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_608"></a>key-value observing, and <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_609"></a>key-value binding. See <span class="content_text"><a href="../AddingBehaviortoaCocoaProgram/AddingBehaviorCocoa.html#//apple_ref/doc/uid/TP40002974-CH5-SW4">“Key-Value Mechanisms”</a></span> for overviews of these mechanisms and their associated informal protocols. The discussion of the Observer pattern in <span class="content_text"><a href="../CocoaDesignPatterns/CocoaDesignPatterns.html#//apple_ref/doc/uid/TP40002974-CH6-SW6">“Cocoa Design Patterns”</a></span> also describes key-value observing.</p><p>You can establish a binding between any two objects. The only requirement is that the objects comply with the conventions of key-value coding and key-value observing. However, you generally want to establish the binding <em>through</em> a mediating controller because such controller objects offer bindings-related services such as selection management, placeholder values, and the ability to commit or discard pending changes. Mediating controllers are <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_610"></a><a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_611"></a>instances of several  <code><a href="../../../Reference/ApplicationKit/Classes/NSController_Class/Reference/Reference.html#//apple_ref/occ/cl/NSController" target="_top">NSController</a></code> subclasses; they are available on the Interface Builder Controllers palette (see <span class="content_text">“How You Establish Bindings,”</span> below). You can also create custom mediating-controller classes to acquire more specialized behavior. For a discussion of mediating controllers and <code>NSController</code> objects, see <span class="content_text"><a href="../CocoaDesignPatterns/CocoaDesignPatterns.html#//apple_ref/doc/uid/TP40002974-CH6-SW8">“Types of Cocoa Controller Objects”</a></span> in <span class="content_text">“The Model-View-Controller Design Pattern”</span> and the section on the Mediator pattern in <span class="content_text"><a href="../CocoaDesignPatterns/CocoaDesignPatterns.html#//apple_ref/doc/uid/TP40002974-CH6-SW6">“Cocoa Design Patterns.”</a></span></p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH7-SW50" title="Further Reading"></a><p><strong>Further Reading:</strong>&nbsp;To learn more about the design patterns summarized above, see <span class="content_text"><a href="../CocoaDesignPatterns/CocoaDesignPatterns.html#//apple_ref/doc/uid/TP40002974-CH6-SW1">“The Model-View-Controller Design Pattern”</a></span> and <span class="content_text"><a href="../CocoaDesignPatterns/CocoaDesignPatterns.html#//apple_ref/doc/uid/TP40002974-CH6-SW2">“Object Modeling.”</a></span> </p></div><a name="//apple_ref/doc/uid/TP40002974-CH7-SW19" title="How You Establish Bindings"></a><h3>How You Establish Bindings</h3><p>If the only custom classes of your application are model classes, the only requirement for establishing <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_612"></a>bindings is that those classes  be compliant with key-value coding conventions for any properties you want to bind. If you are using a custom view or custom controller, you should also ensure that it is key-value observing compliant.  See <span class="content_text"><a href="../AddingBehaviortoaCocoaProgram/AddingBehaviorCocoa.html#//apple_ref/doc/uid/TP40002974-CH5-SW4">“Key-Value Mechanisms”</a></span> for a summary of the requirements for compliance with both key-value coding and key-value observing.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH7-SW51" title="Note"></a><p><strong>Note:</strong>&nbsp;Most of the classes of the Cocoa frameworks are compliant with key-value coding. Some are compliant with key-value observing; check the reference documentation for details.</p></div><p>You can also establish bindings programmatically but for most situations you use the <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_613"></a>Interface Builder application to establish bindings. In Interface Builder, you start by dragging <code><a href="../../../Reference/ApplicationKit/Classes/NSController_Class/Reference/Reference.html#//apple_ref/occ/cl/NSController" target="_top">NSController</a></code> objects from a palette into your nib file. Then you use the Bindings pane of the Info window to specify the relationships between the properties of the view, controller, and model objects of your application and the attributes you want bound.  </p> <p><span class="content_text">Figure 5-7</span> gives an example of a binding. It shows the "Tax?" column of the top table view bound to the model attribute <code>taxable</code> through the property <code>arrangedObjects</code> of the Entrees controller (an <code><a href="../../../Reference/ApplicationKit/Classes/NSArrayController_Class/Reference/Reference.html#//apple_ref/occ/cl/NSArrayController" target="_top">NSArrayController</a></code> object), which itself is bound to an array of model objects (not shown). </p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH7-SW20" title="Figure 5-7Establishing a binding in Interface Builder"></a><p><strong>Figure 5-7&nbsp;&nbsp;</strong>Establishing a binding in Interface Builder</p><img src = "../Art/bindings_in_ib.jpg" alt = "Establishing a binding in Interface Builder" ></div><br/><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH7-SW52" title="Further Reading"></a><p><strong>Further Reading:</strong>&nbsp;Read <em><a href="../../CocoaBindings/index.html#//apple_ref/doc/uid/10000167i" target="_top">Cocoa Bindings Programming Topics</a></em> to learn more about the bindings technology and how to use Interface Builder to establish bindings. Also see <em><a href="../../KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i" target="_top">Key-Value Coding Programming Guide</a></em> and <em><a href="../../KeyValueObserving/index.html#//apple_ref/doc/uid/10000177i" target="_top">Key-Value Observing Programming Guide</a></em> for complete descriptions of these mechanisms.<a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_614"></a> </p></div><a name="//apple_ref/doc/uid/TP40002974-CH7-SW7" title="Notifications"></a><h2>Notifications</h2><p><a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_615"></a>The standard way to pass information between objects is message passing—one object invokes the method of another object. However, message passing requires that the object sending the message know who the receiver is and what messages it responds to. This requirement is true of delegation messages as well as other types of messages. At times, this tight coupling of two objects is undesirable—most notably because it would join together what might be two otherwise independent subsystems. And it is impractical, because it would require hard-coded connections between many disparate objects in an application. </p><p>For cases where standard message-passing just won’t do, Cocoa offers the broadcast model of notification. By using the notification mechanism, one object can keep other objects informed of what it is doing. In this sense, it is similar to delegation, but the differences are important. The key distinction between delegation and notification is that the former is a one-to-one communication path (between the delegating object and its delegate). But notification is a potentially one-to-many form of communication—it is a broadcast. An object can have only one delegate, but it can have many <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_616"></a><a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_617"></a><em>observers</em>, as the recipients of notification are known. And the object doesn’t have to know what those observers are. Any object can observe an event indirectly via notification and adjust its own appearance, behavior, and state in response to the event. Notification is a powerful mechanism for attaining coordination and cohesion in a program.</p><p>How the notification mechanism works is conceptually straightforward. A process has an object called a <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_618"></a>notification center, which kind of acts as a clearing house and broadcast center for notifications. Objects that need to know about an event elsewhere in the application <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_619"></a>register with the notification center to let it know they want to be notified when that event happens. An example of this is a controller object that needs to know when a pop-up selection is made so it can reflect this change in the user interface. When the event does happen, the object handling the event posts a notification to the notification center, which then dispatches it to all of its observers. <span class="content_text">Figure 5-8</span> depicts this mechanism. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH7-SW53" title="Note"></a><p><strong>Note:</strong>&nbsp;The notification center delivers a notification to its observers synchronously. The posting object does not get back control until all notifications are sent. To post notifications <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_620"></a>asynchronously, you must use a <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_621"></a>notification queue (see <span class="content_text"><a href="CommunicateWithObjects.html#//apple_ref/doc/uid/TP40002974-CH7-SW4">“Notification Queues”</a></span>). A notification queue posts notifications to the notification center after it delays specified notifications and coalesces notifications that are similar according to some specified criteria.</p></div><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH7-SW13" title="Figure 5-8Posting and broadcasting a notification"></a><p><strong>Figure 5-8&nbsp;&nbsp;</strong>Posting and broadcasting a notification</p><img src = "../Art/notificationcenter.gif" alt = "Posting and broadcasting a notification" width="420" height="264"></div><br/><p>Any object can post a notification and any object can register itself with the notification center as an observer of a notification. The object posting the notification, the object that the posting object includes in the notification, and the observer of the notification may all be different objects or the same object. (Having the posting and observing object be the same does have its uses, such as in <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_622"></a>idle-time processing.) Objects that post notifications need not know anything about the observers. On the other hand, observers need to know at least the notification name and the keys to any dictionary encapsulated by the notification object. (<span class="content_text"><a href="CommunicateWithObjects.html#//apple_ref/doc/uid/TP40002974-CH7-SW12">“The Notification Object”</a></span> describes what a notification object consists of.)</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH7-SW54" title="Further Reading"></a><p><strong>Further Reading:</strong>&nbsp;For a thorough discussion of the notification mechanism, see <em><a href="../../Notifications/index.html#//apple_ref/doc/uid/10000043i" target="_top">Notification Programming Topics for Cocoa</a></em>.</p></div><a name="//apple_ref/doc/uid/TP40002974-CH7-SW36" title="When and How to Use Notifications"></a><h3>When and How to Use Notifications</h3><p>As with <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_623"></a>delegation, the <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_624"></a><a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_625"></a>notification mechanism is a great tool for enabling communication between objects in an application. Notifications allow objects within an application to learn about changes that occur elsewhere in that application. Generally, an object registers to be an observer of a notification because it wants to make adjustments when a certain event occurs or is about to occur. For example, if a custom view wants to change its appearance when its window is resized, it can observe the <code>NSWindowDidResizeNotification</code> posted by that window object. Notifications also permit information to be passed between objects because a notification can include a dictionary of data related to the event.</p><p>But there are differences between notification and delegation, and these differences dictate what these mechanisms should be used for. As noted earlier, the main difference between the notification model and the delegation model is that the former is a broadcast mechanism whereas delegation is a one-to-one relationship. Each model has its advantages; with notifications they include the following: </p><ul class="spaceabove"><li class="li"><p>The posting object does not have to know the identity of the observing objects.</p></li><li class="li"><p>An application is not limited to the notifications declared by the Cocoa frameworks; any class can declare notifications for its instances to post.</p></li><li class="li"><p>Notifications are not limited to intra-application communication; with <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_626"></a>distributed notifications, one process can notify another process about events that occur.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH7-SW55" title="iPhone OS Note"></a><p><strong>iPhone OS Note:</strong>&nbsp;Distributed notifications are not available on iPhone OS.</p></div></li></ul><p>But the one-to-one model of delegation has its advantages too. A delegate is given the opportunity to affect an event by returning a value to the delegating object. A notification observer, on the other hand, must play a more passive role; it can affect only itself and its environment in response to the event. Notification methods must have the following <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_627"></a><a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_628"></a>signature:</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)notificationHandlerName:(NSNotification *);<span></span></pre></td></tr></table></div><p>This requirement precludes the observing object from affecting the original event in any direct way. A delegate, however, can often affect how the delegating object will handle an event. Moreover, the delegate of an Application Kit object is automatically registered as an observer of its notifications. All it need do is implement the notification methods defined by the framework class for its notifications.</p><p>The notification mechanism is not the only Cocoa alternative for observing changes in object state, and indeed for many situations should not be the preferred one. The Cocoa <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_629"></a><a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_630"></a>bindings technology, and specifically its enabling <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_631"></a>key-value observing (KVO) and <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_632"></a>key-value binding (KVB) protocols, also allow objects in an application to observe changes in the properties of other objects. The bindings mechanism accomplishes this function more efficiently than do notifications. In bindings, the communication between observed and observing object is direct, and does not require an intermediary object such as the notification center. Moreover, the bindings mechanism imposes no performance penalty for unobserved changes, as do regular notifications. </p><p>However, there can be situations where it makes sense to prefer notifications over bindings. You may want to observe events other than a change in object properties. Or it might be impractical to implement KVO and KVB compliance, especially when the notifications to be posted and observed are few.</p><p>Even if the situation warrants the use of notifications, you should be aware of the <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_633"></a><a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_634"></a>performance implications. When you post a notification, it is eventually dispatched to observing objects synchronously by the local notification center. This occurs regardless of whether the posting was done synchronously or asynchronously. If there are many observers or each observer does a lot of work while handling the notification, your program could experience a significant delay. Therefore you should be careful about overusing notifications or using them inefficiently. The following guidelines for notification usage should help toward this end:</p><ul class="spaceabove"><li class="li"><p>Be selective about which notifications your application should observe.</p></li><li class="li"><p>Be specific about notification names and posting objects when you register for notifications.</p></li><li class="li"><p>Implement the methods that handle notifications to be as efficient as possible.</p></li><li class="li"><p>Refrain from adding and removing numerous observers; it is much better to have a few "intermediary" observers that can communicate the results of notifications to the objects they have access to. </p></li></ul><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH7-SW56" title="Further Reading"></a><p><strong>Further Reading:</strong>&nbsp;For detailed information about the efficient use of notifications, see "<span class="content_text"><a href="../../CocoaPerformance/Articles/Notifications.html#//apple_ref/doc/uid/TP40001446" target="_top">Notifications</a></span>" in  <em><a href="../../CocoaPerformance/index.html#//apple_ref/doc/uid/TP40001448" target="_top">Cocoa Performance Guidelines</a></em>.</p></div><a name="//apple_ref/doc/uid/TP40002974-CH7-SW12" title="The Notification Object"></a><h3>The Notification Object</h3><p>A <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_635"></a>notification is an object, an instance of <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_636"></a><code><a href="../../../Reference/Foundation/Classes/NSNotification_Class/Reference/Reference.html#//apple_ref/occ/cl/NSNotification" target="_top">NSNotification</a></code>. This object encapsulates information about an event, such as a window gaining focus or a network connection closing. When the event does happen, the object handling the event posts the notification to the notification center, which immediately broadcasts the notification to all registered objects. </p><p>An <code>NSNotification</code> object contains a name, an object, and an optional dictionary. The name is a tag identifying the notification. The object is any object that the poster of the notification wants to send to observers of that notification (typically it is the object that posted the notification). It is similar to the sender object in delegation messages, allowing the receiver to query the object for more information. The dictionary stores any information related to the event. </p><a name="//apple_ref/doc/uid/TP40002974-CH7-SW37" title="Notification Centers"></a><h3>Notification Centers</h3><p>A <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_637"></a>notification center manages the sending and receiving of notifications. It notifies all observers of notifications meeting specific criteria. The notification information is encapsulated in <code>NSNotification</code> objects. Client objects register themselves with the notification center as observers of specific notifications posted by other objects. When an event occurs, an object posts an appropriate notification to the notification center. The notification center dispatches a message to each registered observer, passing the notification as the sole argument. It is possible for the posting object and the observing object to be the same.</p><p>Cocoa includes two types of notification centers: </p><ul class="spaceabove"><li class="li"><p>A notification center (an instance of <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_638"></a><code><a href="../../../Reference/Foundation/Classes/NSNotificationCenter_Class/Reference/Reference.html#//apple_ref/occ/cl/NSNotificationCenter" target="_top">NSNotificationCenter</a></code>) manages notifications within a single task. </p></li><li class="li"><p>A distributed notification center (an instance of <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_639"></a><code><a href="../../../Reference/Foundation/Classes/NSDistributedNotificationCenter_Class/Reference/Reference.html#//apple_ref/occ/cl/NSDistributedNotificationCenter" target="_top">NSDistributedNotificationCenter</a></code>) manages notifications across multiple tasks on a single computer.</p></li></ul><p>Note that in contrast to many other Foundation classes, <code>NSNotificationCenter</code> is not toll-free bridged to its Core Foundation counterpart (<code><a href="../../../../CoreFoundation/Reference/CFNotificationCenterRef/Reference/reference.html#//apple_ref/c/tdef/CFNotificationCenterRef" target="_top">CFNotificationCenterRef</a></code>).</p><a name="//apple_ref/doc/uid/TP40002974-CH7-SW38" title="NSNotificationCenter"></a><h4>NSNotificationCenter</h4><p>Each task has a default notification center that you access with the <code>NSNotificationCenter</code> class method <code><a href="../../../Reference/Foundation/Classes/NSNotificationCenter_Class/Reference/Reference.html#//apple_ref/occ/clm/NSNotificationCenter/defaultCenter" target="_top">defaultCenter</a></code>. The notification center handles notifications within a single task. For communication between tasks on the same machine, use a distributed notification center (see <span class="content_text"><a href="CommunicateWithObjects.html#//apple_ref/doc/uid/TP40002974-CH7-SW6">“NSDistributedNotificationCenter”</a></span>)). </p><p>A notification center delivers notifications to observers synchronously. In other words, when posting a notification, control does not return to the poster until all observers have received and processed the notification. To send notifications asynchronously use a notification queue, which is described in <span class="content_text"><a href="CommunicateWithObjects.html#//apple_ref/doc/uid/TP40002974-CH7-SW4">“Notification Queues.”</a></span></p><p>In a multithreaded application, <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_640"></a>notifications are always delivered in the thread in which the notification was posted, which may not be the same thread in which an observer registered itself.</p><a name="//apple_ref/doc/uid/TP40002974-CH7-SW6" title="NSDistributedNotificationCenter"></a><h4>NSDistributedNotificationCenter</h4><p>Each task has a default distributed notification center that you access with the <code>NSDistributedNotificationCenter</code> class method <code><a href="../../../Reference/Foundation/Classes/NSDistributedNotificationCenter_Class/Reference/Reference.html#//apple_ref/occ/clm/NSDistributedNotificationCenter/defaultCenter" target="_top">defaultCenter</a></code>. This distributed notification center handles notifications that can be sent between tasks on a single machine. For communication between tasks on different machines, use distributed objects (see <em><a href="../../DistrObjects/index.html#//apple_ref/doc/uid/10000102i" target="_top">Distributed Objects Programming Topics</a></em>). </p><p>Posting a <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_641"></a>distributed notification is an expensive operation. The notification gets sent to a system-wide server that then distributes it to all the tasks that have objects registered for distributed notifications. The latency between posting the notification and the notification's arrival in another task is unbounded. In fact, if too many notifications are being posted and the server's queue fills up, notifications can be dropped. </p><p>Distributed notifications are delivered via a task's run loop. A task must be running a run loop in one of the “common” modes, such as <code><a href="../../../Reference/Foundation/Classes/NSRunLoop_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSDefaultRunLoopMode" target="_top">NSDefaultRunLoopMode</a></code>, to receive a distributed notification. If the receiving task is multithreaded, do not depend on the notification arriving on the main thread. The notification is usually delivered to the main thread's run loop, but other threads could also receive the notification. </p><p>Whereas a regular notification center allows any object to be the notification object (that is, the object encapsulated by the notification), a distributed notification center is restricted to having an <code><a href="../../../Reference/Foundation/Classes/NSString_Class/Reference/NSString.html#//apple_ref/occ/cl/NSString" target="_top">NSString</a></code> object as its notification object. Because the posting object and the observer may be in different tasks, notifications cannot contain pointers to arbitrary objects. Therefore, a distributed notification center requires notifications to use a string as the notification object. Notification matching is done based on this string, rather than an object pointer.</p><a name="//apple_ref/doc/uid/TP40002974-CH7-SW4" title="Notification Queues"></a><h3>Notification Queues</h3><p><a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_642"></a><code><a href="../../../Reference/Foundation/Classes/NSNotificationQueue_Class/Reference/Reference.html#//apple_ref/occ/cl/NSNotificationQueue" target="_top">NSNotificationQueue</a></code> objects (or simply, <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_643"></a>notification queues) act as buffers for notification centers (instances of <code>NSNotificationCenter</code>). A notification queue maintains notifications (instances of <code>NSNotification</code>) generally in a First In First Out (FIFO) order. When a notification rises to the front of the queue, the queue posts it to the notification center, which in turn dispatches the notification to all objects registered as observers. </p><p>Every thread has a default notification queue, which is associated with the default notification center for the task. <span class="content_text">Figure 5-9</span> illustrates this association. You can create your own notification queues and have multiple queues per center and thread.</p><br/><div><a name="//apple_ref/doc/uid/TP40002974-CH7-SW23" title="Figure 5-9A notification queue and notification center"></a><p><strong>Figure 5-9&nbsp;&nbsp;</strong>A notification queue and notification center</p><img src = "../Art/notificationqueue.gif" alt = "A notification queue and notification center" width="420" height="264"></div><br/><a name="//apple_ref/doc/uid/TP40002974-CH7-SW39" title="Coalescing Notifications"></a><h4>Coalescing Notifications</h4><p>The <code>NSNotificationQueue</code> class contributes two important features to the Foundation Kit’s notification mechanism: the <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_644"></a><a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_645"></a>coalescing of notifications and asynchronous posting. Coalescing is a process that removes notifications in the queue that are similar to the notification just queued. If the new item is similar to a notification already queued, the new one isn’t queued and all similar notifications (except the first one in the queue) are removed. However, you should not depend on this particular coalescing behavior. </p><p>You indicate the criteria for similarity by specifying one or more of the following constants in the third argument of the <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_646"></a><code><a href="../../../Reference/Foundation/Classes/NSNotificationQueue_Class/Reference/Reference.html#//apple_ref/occ/instm/NSNotificationQueue/enqueueNotification:postingStyle:coalesceMask:forModes:" target="_top">enqueueNotification:postingStyle:coalesceMask:forModes:</a></code> method. </p><ul class="simple"><li><p><code><a href="../../../Reference/Foundation/Classes/NSNotificationQueue_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSNotificationNoCoalescing" target="_top">NSNotificationNoCoalescing</a></code></p></li><li><p><code><a href="../../../Reference/Foundation/Classes/NSNotificationQueue_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSNotificationCoalescingOnName" target="_top">NSNotificationCoalescingOnName</a></code></p></li><li><p><code><a href="../../../Reference/Foundation/Classes/NSNotificationQueue_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSNotificationCoalescingOnSender" target="_top">NSNotificationCoalescingOnSender</a></code></p></li></ul><p>You can perform a bitwise-OR operation with the <code><a href="../../../Reference/Foundation/Classes/NSNotificationQueue_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSNotificationCoalescingOnName" target="_top">NSNotificationCoalescingOnName</a></code> and <code><a href="../../../Reference/Foundation/Classes/NSNotificationQueue_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSNotificationCoalescingOnSender" target="_top">NSNotificationCoalescingOnSender</a></code> constants to specify coalescing using both the notification name and notification object. In this case, all notifications having the same name and sender as the one enqueued are coalesced.</p><a name="//apple_ref/doc/uid/TP40002974-CH7-SW40" title="Asynchronously Posting Notifications"></a><h4>Asynchronously Posting Notifications</h4><p><a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_647"></a><a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_648"></a>With the <code>NSNotificationCenter</code> method <code><a href="../../../Reference/Foundation/Classes/NSNotificationCenter_Class/Reference/Reference.html#//apple_ref/occ/instm/NSNotificationCenter/postNotification:" target="_top">postNotification:</a></code> and its variants, you can post a notification immediately to a notification center. However, the invocation of the method is <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_649"></a>synchronous: Before the posting object can resume its thread of execution, it must wait until the notification center dispatches the notification to all observers and returns. With the <code>NSNotificationQueue</code> methods <code><a href="../../../Reference/Foundation/Classes/NSNotificationQueue_Class/Reference/Reference.html#//apple_ref/occ/instm/NSNotificationQueue/enqueueNotification:postingStyle:" target="_top">enqueueNotification:postingStyle:</a></code> and <code><a href="../../../Reference/Foundation/Classes/NSNotificationQueue_Class/Reference/Reference.html#//apple_ref/occ/instm/NSNotificationQueue/enqueueNotification:postingStyle:coalesceMask:forModes:" target="_top">enqueueNotification:postingStyle:coalesceMask:forModes:</a></code> methods, however, you can post a notification asynchronously by putting it in a queue. These methods immediately return to the invoking object after putting the notification in the queue. </p><p>The notification queue is emptied and its notifications posted based on the posting style and <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_650"></a>run loop mode specified in the enqueuing method. The mode argument specifies the run loop mode in which the queue will be emptied. For example, if you specify <code><!--a target="_top" -->NSModalPanelRunLoopMode<!--/a--></code>, the notifications will be posted only when the run loop is in this mode. If the run loop is not currently in this mode, the notifications wait until the next time that mode is entered. </p><p>Posting to a notification queue can occur in one of three different styles: <code><a href="../../../Reference/Foundation/Classes/NSNotificationQueue_Class/Reference/Reference.html#//apple_ref/c/econst/NSPostASAP" target="_top">NSPostASAP</a></code>,<code><a href="../../../Reference/Foundation/Classes/NSNotificationQueue_Class/Reference/Reference.html#//apple_ref/c/econst/NSPostWhenIdle" target="_top">NSPostWhenIdle</a></code>, and <code><a href="../../../Reference/Foundation/Classes/NSNotificationQueue_Class/Reference/Reference.html#//apple_ref/c/econst/NSPostNow" target="_top">NSPostNow</a></code>. These styles are described in the following sections.</p><a name="//apple_ref/doc/uid/TP40002974-CH7-SW41" title="Posting As Soon As Possible"></a><h5>Posting As Soon As Possible</h5><p>Any notification queued with the <code><a href="../../../Reference/Foundation/Classes/NSNotificationQueue_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSPostASAP" target="_top">NSPostASAP</a></code> style is posted to the notification center when the current iteration of the run loop completes, assuming the current run loop mode matches the requested mode. (If the requested and current modes are different, the notification is posted when the requested mode is entered.) Because the run loop can make multiple callouts during each iteration, the notification may or may not get delivered as soon as the current callout exits and control returns to the run loop. Other callouts may take place first, such as a timer or source firing or other asynchronous notifications delivered. </p><p>You typically use the <code><a href="../../../Reference/Foundation/Classes/NSNotificationQueue_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSPostASAP" target="_top">NSPostASAP</a></code> posting style for an expensive resource, such as the display server. When many clients draw on the window buffer during a callout from the run loop, it is expensive to flush the buffer to the display server after every draw operation. In this situation, each <code>draw...</code> method enqueues some notification such as “FlushTheServer” with coalescing on name and object specified and with a posting style of <code><a href="../../../Reference/Foundation/Classes/NSNotificationQueue_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSPostASAP" target="_top">NSPostASAP</a></code>. As a result, only one of those notifications is dispatched at the end of the run loop and the window buffer is flushed only once.</p><a name="//apple_ref/doc/uid/TP40002974-CH7-SW42" title="Posting When Idle"></a><h5>Posting When Idle</h5><p><a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_651"></a>A notification queued with the <code>NSPostWhenIdle</code> style is posted only when the run loop is in a wait state. In this state, there’s nothing in the run loop’s input channels, be it timers or other asynchronous events. Note that a run loop that is about to exit (which occurs when all of the input channels have expired) is not in a wait state and thus will not post a notification.</p><a name="//apple_ref/doc/uid/TP40002974-CH7-SW43" title="Posting Immediately"></a><h5>Posting Immediately</h5><p>A notification queued with <code>NSPostNow</code> is posted immediately after coalescing to the notification center. You queue a notification with <code><a href="../../../Reference/Foundation/Classes/NSNotificationQueue_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSPostNow" target="_top">NSPostNow</a></code> (or post one with the NSNotificationCenter method <code>postNotification:</code>) when you do not require asynchronous calling behavior. For many programming situations, synchronous behavior is not only allowable but desirable: You want the notification center to return after dispatching so you can be sure that observing objects have received and processed the notification. Of course, you should use <code>enqueueNotification</code>... with <code><a href="../../../Reference/Foundation/Classes/NSNotificationQueue_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSPostNow" target="_top">NSPostNow</a></code> rather than use <code>postNotification:</code> when there are similar notifications in the queue that you want to remove through coalescing<a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_652"></a>.</p><a name="//apple_ref/doc/uid/TP40002974-CH7-SW16" title="Ownership of Delegates, Observers, and Targets"></a><h2>Ownership of Delegates, Observers, and Targets</h2><p><a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_653"></a><a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_654"></a><a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_655"></a>Delegating objects are not considered to own their <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_656"></a>delegates or <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_657"></a>data sources. Similarly, controls and cells are not considered to own their <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_658"></a>targets, and the notification center does not own the <a name="//apple_ref/doc/uid/TP40002974-CH7-DontLinkElementID_659"></a>observers of notifications. Consequently, for memory-managed code these framework objects follow the convention of <em>not</em> retaining their targets, observers, delegates, and data sources; instead, they simply store a pointer to the object. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH7-SW57" title="Note"></a><p><strong>Note:</strong>&nbsp;In memory management, a non-retained object reference is known as a weak reference, which is something altogether different from a weak reference in a garbage-collected environment. In the latter, all references to objects are considered strong by default and are thus visible to the garbage collector; weak references, which must be marked with the <code>__weak</code> type modifier, are not visible. In garbage collection, retain cycles are not a problem.</p></div><p>The object-ownership policy in memory management recommends that owned objects should be retained and archived unconditionally, and that referenced (but not owned) objects should not be retained and should be archived conditionally. The practical intent of this ownership policy is to avoid circular references, a situation where two objects retain each other. (This is often called a “retain cycle.“) Retaining an object creates a strong reference, and an object cannot be deallocated until all of its strong references are released. If two objects retain each other, neither object ever gets deallocated because the connection between them cannot be broken. </p><p>If you create a subclass from a Cocoa framework class with a delegate, data source, observer, or target, you should never explicitly retain the object in your subclass. You should create a non-retained reference to it and archive it conditionally.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002974-CH7-SW58" title="Further Reading"></a><p><strong>Further Reading:</strong>&nbsp;For more on the ownership policy, weak references, and circular references in memory management, see "<span class="content_text"><a href="../../MemoryMgmt/Articles/mmObjectOwnership.html#//apple_ref/doc/uid/20000043" target="_top">Object Ownership and Disposal</a></span>" in <em><a href="../../MemoryMgmt/index.html#//apple_ref/doc/uid/10000011i" target="_top">Memory Management Programming Guide for Cocoa</a></em>. For a summary of strong references and weak references in garbage collection, see “<span class="content_text"><a href="../../GarbageCollection/Articles/gcEssentials.html#//apple_ref/doc/uid/TP40002452" target="_top">Garbage Collection for Cocoa Essentials</a></span>“ in <em><a href="../../GarbageCollection/index.html#//apple_ref/doc/uid/TP40002431" target="_top">Garbage Collection Programming Guide</a></em>.</p></div>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../CocoaDesignPatterns/CocoaDesignPatterns.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../CoreAppArchitecture/CoreAppArchitecture.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-11-19<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/CocoaFundamentals/CommunicatingWithObjects/CommunicateWithObjects.html%3Fid%3DTP40002974-3.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/CocoaFundamentals/CommunicatingWithObjects/CommunicateWithObjects.html%3Fid%3DTP40002974-3.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/CocoaFundamentals/CommunicatingWithObjects/CommunicateWithObjects.html%3Fid%3DTP40002974-3.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>