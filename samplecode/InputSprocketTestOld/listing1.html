<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>InputSprocketTestOld - /InputSprocketSimpleTest.cp</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGames-date.html">Games</a> &gt; <A HREF="javascript:location.replace('index.html');">InputSprocketTestOld</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Games/index.html" target="_blank">Reference Library > Games</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">InputSprocketTestOld</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/InputSprocketSimpleTest.cp</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/InputSprocketSimpleTest.cp</option>
<option value="listing2.html">/InputSprocketSimpleTest.r</option>
<option value="listing3.html">/ISpAutoTest.h</option>
<option value="listing4.html">/ISpDialogTest.h</option>
<option value="listing5.html">/ISpMenuTest.h</option></select>
				</p>
				</form>
				<p><strong><a href="InputSprocketTestOld.zip">Download Sample</a></strong> (&#147;InputSprocketTestOld.zip&#148;, 107.7K)<BR>
<strong><a href="InputSprocketTestOld.dmg">Download Sample</a></strong> (&#147;InputSprocketTestOld.dmg&#148;, 178.4K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    InputSprocketSimpleTest.cp  Contains:  xxx put contents here xxx  Version:  xxx put version here xxx  Copyright:  &copy; 1998-1999 by Apple Computer, Inc., all rights reserved.  File Ownership:    DRI:        xxx put dri here xxx    Other Contact:    xxx put other contact here xxx    Technology:      xxx put technology here xxx  Writers:    (cjd)  Chris De Salvo    (BWS)  Brent Schorsch    (sjb)  Steve Bollinger  Change History (most recent first):    &lt;SP63&gt;   8/16/99  cjd    Fixing a type in the menus.  The event test said to hit Control                  to exit.  It should have said Command.    &lt;SP62&gt;   12/1/98  BWS    Add test item: get element list for device, then count elements                  of certain type bassing null, then get the elements    &lt;SP61&gt;   11/6/98  BWS    Add version in menutest    &lt;SP60&gt;  10/20/98  BWS    Quit and pause now different    &lt;59&gt;   7/17/98  BWS    fix come comments    &lt;58&gt;   7/17/98  BWS    add sample code header    &lt;57&gt;   7/17/98  BWS    fix needs list, other cleanup for GM SDK    &lt;56&gt;   7/16/98  BWS    fix some constants so works with latest header    &lt;55&gt;   6/18/98  sjb    InputSprocket.h comes from &lt;&gt; place*//*************************************************************************************File:      InputSprocketSimpleTest.cpCopyright &copy; 1996, 1997, 1998 Apple Computer, Inc., All Rights ReservedYou may incorporate this sample code into your applications withoutrestriction, though the sample code has been provided &quot;AS IS&quot; and theresponsibility for its operation is 100% yours.  However, what you arenot permitted to do is to redistribute the source as &quot;DSC Sample Code&quot;after having made changes. If you're going to re-distribute the source,we require that you make it clear in the source that the code wasdescended from Apple Sample Code, but that you've made changes.*************************************************************************************/#ifndef DEBUG_DRIVER  #define DEBUG_DRIVER 0#endif#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;DeskBus.h&gt;#include &lt;InputSprocket.h&gt;#include &lt;SIOUX.h&gt;#include &lt;CursorDevices.h&gt;#include &lt;LowMem.h&gt;#include &lt;FixMath.h&gt;// (default menu, if none defined) which test (AUTOTEST, DIALOGTEST or MENUTEST)#ifndef AUTOTEST#ifndef DIALOGTEST#ifndef  MENUTEST#define MENUTEST    1#endif#endif#endif// set the other #defines to 0#ifndef AUTOTEST#define AUTOTEST    0#endif#ifndef DIALOGTEST#define DIALOGTEST  0#endif#ifndef  MENUTEST#define MENUTEST    0#endif#if DEBUG_DRIVER  #include &quot;InputSprocketDriver.h&quot;#endifconst OSType kCreatorCode    = 'ISpT';const OSType kSubCreatorCode  = '0015';#define  kResourceID_setl      128enum{  kNeedIndex_XAxis = 1,  kNeedIndex_YAxis = 2,  kNeedIndex_DeltaAccelerationX = 11,  kNeedIndex_DeltaAccelerationY = 12,  kNeedCount = 13};enum{  kIconSuiteID_XThrust     = 129,   kIconSuiteID_YThrust     = 130,  kIconSuiteID_ZThrust     = 131,  kIconSuiteID_Look       = 159,  kIconSuiteID_Fire      = 141,  kIconSuiteID_SecondaryFire  = 142,  kIconSuiteID_ThrustForward  = 147,  kIconSuiteID_ThrustBackward  = 148,  kIconSuiteID_Pause      = 144,  kIconSuiteID_Scroll      = 140,  kIconSuiteID_DeltaX      = 256,  kIconSuiteID_DeltaY      = 257};Boolean gIsSuspended = false;Boolean gKeyboardEnabled = false;ISpElementListReference gVirtualList = NULL;ISpElementReference gVirtualElements[kNeedCount] = {nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil};    static ISpNeed gNeeds[kNeedCount] ={  { &quot;\pForward Thrust&quot;,  kIconSuiteID_ZThrust,     0,  1, kISpElementKind_Axis,    kISpElementLabel_Axis_ZAxis,    kISpNeedFlag_Axis_AlreadyButton,   0, 0, 0  },  { &quot;\pSide Thrust&quot;,     kIconSuiteID_XThrust,    0,  0, kISpElementKind_Axis,    kISpElementLabel_Axis_XAxis,    0, 0, 0, 0  },  { &quot;\pVertical Thrust&quot;,   kIconSuiteID_YThrust,     0,  0, kISpElementKind_Axis,    kISpElementLabel_Axis_YAxis,    0, 0, 0, 0  },  { &quot;\pLook&quot;,       kIconSuiteID_Look,      0,  0, kISpElementKind_Movement,  kISpElementLabel_None,        0, 0, 0, 0  },  { &quot;\pFire&quot;,       kIconSuiteID_Fire,      0,  0, kISpElementKind_Button,    kISpElementLabel_Btn_Fire,      0, 0, 0, 0  },  { &quot;\pSecondary Fire&quot;,  kIconSuiteID_SecondaryFire,  0,  0, kISpElementKind_Button,    kISpElementLabel_Btn_SecondaryFire,  0, 0, 0, 0  },  { &quot;\pThrust Forward&quot;,   kIconSuiteID_ThrustForward, 0,  1, kISpElementKind_Button,    kISpElementLabel_Btn_MoveForward,  kISpNeedFlag_Button_AlreadyAxis,   0, 0, 0  },  { &quot;\pThrust Backward&quot;,   kIconSuiteID_ThrustBackward,0,  1, kISpElementKind_Button,    kISpElementLabel_Btn_MoveBackward,  kISpNeedFlag_Button_AlreadyAxis,   0, 0, 0  },  { &quot;\pPause&quot;,       kIconSuiteID_Pause,     0,  0, kISpElementKind_Button,    kISpElementLabel_Btn_StartPause,  kISpNeedFlag_NoMultiConfig,     0, 0, 0  },  { &quot;\pQuit&quot;,         kIconSuiteID_Pause,     0,  0, kISpElementKind_Button,    kISpElementLabel_Btn_Quit,      kISpNeedFlag_NoMultiConfig,     0, 0, 0  },  { &quot;\pScroll&quot;,       kIconSuiteID_Scroll,    0,  0, kISpElementKind_DPad,    kISpElementLabel_None,        0, 0, 0, 0          },  { &quot;\pDelta X&quot;,      kIconSuiteID_DeltaX,    0,  0, kISpElementKind_Delta,    kISpElementLabel_Delta_Cursor_X,      0, 0, 0, 0          },  { &quot;\pDelta Y&quot;,      kIconSuiteID_DeltaY,    0,  0, kISpElementKind_Delta,    kISpElementLabel_Delta_Cursor_Y,      0, 0, 0, 0          }};SInt32 gStep;char gStepId[255];typedef Boolean (*ISpEventProcPtr) (EventRecord* inEvent);Boolean ISpConfigureFilterProc(EventRecord *inEvent);Boolean ISpConfigureFilterProc(EventRecord *inEvent){  Boolean handled;    handled = SIOUXHandleOneEvent(inEvent);  return handled;}static Boolean Progress(UInt32 inItr, UInt32 inTotal, UInt32 inNumReports, char *string){  UInt32 everyNTimes = inTotal / inNumReports;    if (everyNTimes == 0) { everyNTimes = 1; }    if (inItr == 0) { return false; }    if ((inItr % everyNTimes) == 0)  {    UInt32 percent = (inItr * 100) / inTotal;    sprintf(string, &quot;%d%% [%d of %d]&quot;, percent, inItr, inTotal);    return true;  }    return false;}static void InitStep(char *msg){  gStep = 0;  sprintf(gStepId, &quot;%3d&quot;);    if (msg == nil)  {    printf(&quot;step %s\n&quot;, gStepId);  }  else  {    printf(&quot;step %s %s\n&quot;,gStepId, msg);  }}static void NextStep(char *msg){  long this_app_memory;  long this_sys_memory;  static Boolean first_time = true;  static long last_app_memory;  static long last_sys_memory;  gStep++;  sprintf(gStepId, &quot;%3d&quot;, gStep);  this_app_memory = FreeMem();  this_sys_memory = FreeMemSys();  if (first_time)    {    first_time = false;  }  else  {    long delta_app_memory = last_app_memory - this_app_memory;    long delta_sys_memory = last_sys_memory - this_sys_memory;        printf(&quot;step %s ending app mem = %d sys mem = %d\n&quot;, gStepId, this_app_memory, this_sys_memory);    printf(&quot;step %s delta app mem = %d sys mem = %d\n&quot;, gStepId, delta_app_memory, delta_sys_memory);  }  if (msg == nil)  {    printf(&quot;step %s\n&quot;, gStepId);  }  else  {    printf(&quot;step %s %s\n&quot;,gStepId, msg);  }  printf(&quot;step %s starting app mem = %d sys mem = %d\n&quot;, gStepId, this_app_memory, this_sys_memory);  last_app_memory = this_app_memory;  last_sys_memory = this_sys_memory;}static void FailMsg(char *failure){  printf(&quot;step %s FAILED reason = %s\n&quot;, gStepId, failure);}static void FailCode(OSStatus errorCode){  printf(&quot;step %s FAILED errorCode = %d\n&quot;, gStepId, errorCode);}#define FAILMSG(x) { FailMsg(x); return; }#define FAILCODE(x) { FailCode(x); return; }#define FFAILMSG(x) { FailMsg(x); return false; }#define FFAILCODE(x) { FailCode(x); return false; }static void StatusMsg(char *msg){  printf(&quot;step %s status msg = %s\n&quot;,gStepId, msg);}void ShowFourByte(OSType fourByte);void ShowFourByte(OSType fourByte){  putchar(((fourByte &amp; 0xff000000) &gt;&gt; 24));  putchar(((fourByte &amp; 0x00ff0000) &gt;&gt; 16));  putchar(((fourByte &amp; 0x0000ff00) &gt;&gt; 8));  putchar(((fourByte &amp; 0x000000ff) &gt;&gt; 00));}void ShowStr63(const Str63 &amp;theStr);void ShowStr63(const Str63 &amp;theStr){  int i;  int len = theStr[0];  if (len &gt; 63) { len = 63; }    for(i=1; i &lt;= len; i++)  {    putchar(theStr[i]);  }}static void AppendStr63(char *string, const Str63 &amp;theStr){  char *c = string;  int i;    // find the end of the string  while(*c != nil) { c++; }    for(i = 1; i &lt;= theStr[0]; i++)  {    *c = theStr[i];    c++;  }    *c = 0;}void PrintEvent(ISpElementEventPtr theEvent);void PrintEvent(ISpElementEventPtr theEvent){  ISpElementInfo info;  ISpElement_GetInfo(theEvent-&gt;element, &amp;info);  OSStatus status;  const char* s = &quot;*UNKNOWN*&quot;;    printf(&quot;when = [%lu] [%lu]\n&quot;, theEvent-&gt;when.hi, theEvent-&gt;when.lo);    switch (info.theKind)  {    case kISpElementKind_Delta:      float inches = (Fixed) theEvent-&gt;data;      inches /= 0xffff;              printf(&quot;data = 0x%lx (%f inches) \n&quot;, theEvent-&gt;data, inches);    break;    case kISpElementKind_Button:      switch (theEvent-&gt;data)      {        case 0:          s = &quot;released&quot;;        break;                case 1:          s = &quot;pressed&quot;;        break;      }            printf(&quot;data = 0x%lx (%s)\n&quot;, theEvent-&gt;data, s);    break;        case kISpElementKind_DPad:      switch (theEvent-&gt;data)      {        case kISpPadIdle:          s = &quot;kISpPadIdle&quot;;        break;                case kISpPadLeft:          s = &quot;kISpPadLeft&quot;;        break;                case kISpPadUpLeft:          s = &quot;kISpPadUpLeft&quot;;        break;                case kISpPadUp:          s = &quot;kISpPadUp&quot;;        break;                case kISpPadUpRight:          s = &quot;kISpPadUpRight&quot;;        break;                case kISpPadRight:          s = &quot;kISpPadRight&quot;;        break;                case kISpPadDownRight:          s = &quot;kISpPadDownRight&quot;;        break;                case kISpPadDown:          s = &quot;kISpPadDown&quot;;        break;                case kISpPadDownLeft:          s = &quot;kISpPadDownLeft&quot;;        break;      }            printf(&quot;data = 0x%lx (%s)\n&quot;, theEvent-&gt;data, s);    break;        case kISpElementKind_Axis:      float temp1 = ((float) theEvent-&gt;data)/((float) 0xFFFFFFFFU);      float temp2 = 2.0*temp1-1.0;            printf(&quot;data = 0x%lx (%f%) (%f%)\n&quot;, theEvent-&gt;data, temp1, temp2);    break;        case kISpElementKind_Movement:      printf(&quot;data = 0x%lx\n&quot;, theEvent-&gt;data);            ISpMovementData movementData;      if (ISpElement_GetComplexState(theEvent-&gt;element, sizeof(ISpMovementData), &amp;movementData) == noErr)      {        switch (movementData.direction)        {          case kISpPadIdle:            s = &quot;kISpPadIdle&quot;;          break;                    case kISpPadLeft:            s = &quot;kISpPadLeft&quot;;          break;                    case kISpPadUpLeft:            s = &quot;kISpPadUpLeft&quot;;          break;                    case kISpPadUp:            s = &quot;kISpPadUp&quot;;          break;                    case kISpPadUpRight:            s = &quot;kISpPadUpRight&quot;;          break;                    case kISpPadRight:            s = &quot;kISpPadRight&quot;;          break;                    case kISpPadDownRight:            s = &quot;kISpPadDownRight&quot;;          break;                    case kISpPadDown:            s = &quot;kISpPadDown&quot;;          break;                    case kISpPadDownLeft:            s = &quot;kISpPadDownLeft&quot;;          break;        }                float horz = 2.0*(((float) movementData.xAxis)/((float) 0xFFFFFFFFU))-1.0;        float vert = 2.0*(((float) movementData.yAxis)/((float) 0xFFFFFFFFU))-1.0;                printf(&quot;state = (%f,%f) (%s)\n&quot;, horz, vert, s);      }    break;  }    printf(&quot;element = 0x%lx\n&quot;, theEvent-&gt;element);  printf(&quot;refcon = %lx\n&quot;, theEvent-&gt;refCon);    printf(&quot;label = &quot;);  ShowFourByte(info.theLabel);  printf(&quot;\n&quot;);    printf(&quot;kind = &quot;);  ShowFourByte(info.theKind);  printf(&quot;\n&quot;);    printf(&quot;string = &quot;);  ShowStr63(info.theString);  printf(&quot;\n&quot;);    {    UInt32 data;    status = ISpElement_GetSimpleState(theEvent-&gt;element, &amp;data);    if (status == noErr) { printf(&quot;polled = %x\n&quot;,data); }  }    printf(&quot;\n\n&quot;);}void PrintElementBlock(ISpElementReference *theElementReferences, UInt32 count);void PrintElementBlock(ISpElementReference *theElementReferences, UInt32 count){  printf(&quot;count = %d\n&quot;);  int itr;    for(itr = 0; itr &lt; count; itr++)  {    printf(&quot;    element #%d\n&quot;,itr);        ISpElementInfo info;    ISpElement_GetInfo(theElementReferences[itr], &amp;info);    printf(&quot;        label = &quot;);    ShowFourByte(info.theLabel);    printf(&quot;\n&quot;);    printf(&quot;        kind = &quot;);    ShowFourByte(info.theKind);    printf(&quot;\n&quot;);    printf(&quot;        string = &quot;);    ShowStr63(info.theString);    printf(&quot;\n\n&quot;);  }}// if whichList is NULL then we use the global liststatic void GetAndPrintEvents(ISpElementListReference whichList){  OSErr err;    if (whichList == NULL)  {    err = ISpGetGlobalElementList(&amp;whichList);    if (err)    {      printf(&quot;*** ISpGetGlobalElementList returned error (%ld)\n&quot;,err);      return;    }  }  err = ISpElementList_Flush(whichList);  if (err)  {    printf(&quot;*** ISpElementList_Flush returned error (%ld)\n&quot;,err);    return;  }  printf(&quot;getting events (press command to end)\n&quot;);    while(1)  {    ISpElementEvent event;    Boolean wasEvent;    err = ISpElementList_GetNextEvent(whichList, sizeof(event), &amp;event, &amp;wasEvent);    if (err)    {      printf(&quot;*** ISpElementList_GetNextEvent returned error (%ld)\n&quot;,err);      return;    }    if (wasEvent)    {      PrintEvent(&amp;event);    }        KeyMap theKeys;    GetKeys(theKeys);    if ((theKeys[1] &amp; 0x8000))    {      break;    }        SIOUXHandleOneEvent(nil);    }}static void TestListOfDevices(void){  ISpDeviceReference theDevices[100];  UInt32 deviceCount;  UInt32 deviceBufferSize = 100;  UInt32 deviceItr;  OSErr err;    err = ISpDevices_Extract(deviceBufferSize, &amp;deviceCount, theDevices);  if (err)  {    printf(&quot;*** ISpDevices_Extract returned error (%ld)\n&quot;,err);    return;  }    printf(&quot;# of devices = %ld\n&quot;,deviceCount);  for(deviceItr = 0; deviceItr &lt; deviceCount; deviceItr++)  {    printf(&quot;    device #%ld\n&quot;,deviceItr);    ISpDeviceDefinition theDfn;        err = ISpDevice_GetDefinition(theDevices[deviceItr], sizeof(ISpDeviceDefinition), &amp;theDfn);    if (err)    {      printf(&quot;*** ISpDevice_GetDefinition returned error (%ld)\n&quot;,err);      return;    }        printf(&quot;        name = &quot;);    ShowStr63(theDfn.deviceName);    printf(&quot;\n&quot;);        printf(&quot;        class = &quot;);    ShowFourByte(theDfn.theDeviceClass);    printf(&quot;\n&quot;);    printf(&quot;        device identifier = &quot;);    ShowFourByte(theDfn.theDeviceIdentifier);    printf(&quot;\n&quot;);    printf(&quot;        permanent id = %ld\n&quot;,theDfn.permanentID);        printf(&quot;\n\n&quot;);  }}static void TestElementList_ExtractByKind(void){  ISpDeviceReference theDevices[100];  UInt32 deviceCount;  UInt32 deviceBufferSize = 100;  UInt32 deviceItr;  OSErr err;  err = ISpDevices_Extract(deviceBufferSize, &amp;deviceCount, theDevices);  if (err)  {    printf(&quot;*** ISpDevices_Extract returned error (%ld)\n&quot;,err);    return;  }    printf(&quot;\n\nChoose a device:\n&quot;);  for(deviceItr = 0; deviceItr &lt; deviceCount; deviceItr++)  {    printf(&quot;  %ld) &quot;, deviceItr+1);    ISpDeviceDefinition theDfn;    err = ISpDevice_GetDefinition(theDevices[deviceItr], sizeof(ISpDeviceDefinition), &amp;theDfn);    if (err)       printf(&quot;*** ISpDevice_GetDefinition returned error (%ld)&quot;, err);        ShowStr63(theDfn.deviceName);    printf(&quot;\n&quot;);  }  printf(&quot;Selection: &quot;);  char theString[32];  gets (theString);  UInt32 theChoice = atoi(theString);    if (theChoice &lt; 1 || theChoice &gt; deviceCount)  {    printf(&quot;*** Invalid choice (%ld)\n&quot;, theChoice);    return;  }    ISpElementListReference deviceElementList = 0;  err = ISpDevice_GetElementList(theDevices[theChoice-1], &amp;deviceElementList);  if (err)  {    printf(&quot;*** ISpDevice_GetElementList returned error (%ld)\n&quot;,err);    return;  }  printf(&quot;\nGot the element list for device %ld, (%lx)\n&quot;, theChoice, (UInt32) deviceElementList);  printf(&quot;\nChoose a kind:\n&quot;);  printf(&quot;1) Button ('butn')\n&quot;);  printf(&quot;2) Direction Pad ('dpad')\n&quot;);  printf(&quot;3) Axis ('axis')\n&quot;);  printf(&quot;4) Delta ('dlta')\n&quot;);  printf(&quot;5) Movement ('move')\n&quot;);  printf(&quot;6) Virtual ('virt')\n&quot;);  printf(&quot;Selection: &quot;);    gets (theString);  theChoice = atoi(theString);    ISpElementKind  theKind;  switch (theChoice)  {    case 1:  theKind = kISpElementKind_Button;   break;    case 2:  theKind = kISpElementKind_DPad;   break;    case 3:  theKind = kISpElementKind_Axis;   break;    case 4:  theKind = kISpElementKind_Delta;   break;    case 5:  theKind = kISpElementKind_Movement; break;    case 6:  theKind = kISpElementKind_Virtual;   break;        default:      printf(&quot;*** Invalid choice (%ld)\n&quot;, theChoice);      return;  }    UInt32 elementOfKindCount = 0;    err = ISpElementList_ExtractByKind(deviceElementList, theKind, 0, &amp;elementOfKindCount, nil);  if (err)  {    printf(&quot;*** ISpElementList_ExtractByKind returned error (%ld)\n&quot;,err);    return;  }  printf(&quot;%ld elements counted (with zero count null buffer)\n&quot;, elementOfKindCount);    err = ISpElementList_ExtractByKind(deviceElementList, theKind, 0, &amp;elementOfKindCount, nil);  if (err)  {    printf(&quot;*** ISpElementList_ExtractByKind returned error (%ld)\n&quot;,err);    return;  }  printf(&quot;%ld elements counted (with zero count null buffer)\n&quot;, elementOfKindCount);    const UInt32  kElementListSize = 300;  ISpElementReference  elements[kElementListSize];  err = ISpElementList_ExtractByKind(deviceElementList, theKind, 0, &amp;elementOfKindCount, elements);  if (err)  {    printf(&quot;*** ISpElementList_ExtractByKind returned error (%ld)\n&quot;,err);    return;  }  printf(&quot;%ld elements counted (with zero count)\n&quot;, elementOfKindCount);  err = ISpElementList_ExtractByKind(deviceElementList, theKind, 1, &amp;elementOfKindCount, elements);  if (err)  {    printf(&quot;*** ISpElementList_ExtractByKind returned error (%ld)\n&quot;,err);    return;  }  printf(&quot;%ld elements counted (with one count)\n&quot;, elementOfKindCount);  err = ISpElementList_ExtractByKind(deviceElementList, theKind, kElementListSize, &amp;elementOfKindCount, elements);  if (err)  {    printf(&quot;*** ISpElementList_ExtractByKind returned error (%ld)\n&quot;,err);    return;  }  printf(&quot;%ld elements counted (with %ld count)\n&quot;, elementOfKindCount, kElementListSize);  err = ISpElementList_ExtractByKind(deviceElementList, theKind, kElementListSize, &amp;elementOfKindCount, elements);  if (err)  {    printf(&quot;*** ISpElementList_ExtractByKind returned error (%ld)\n&quot;,err);    return;  }  printf(&quot;%ld elements counted (with %ld count)\n&quot;, elementOfKindCount, kElementListSize);    printf(&quot;\npress return key to continue\n&quot;);  gets (theString);}static void TestListOfElements(void){  ISpElementListReference globalList;  OSErr err;    err = ISpGetGlobalElementList(&amp;globalList);  if (err)  {    printf(&quot;*** ISpGetGlobalElementList returned error (%ld)\n&quot;,err);    return;  }    ISpElementReference theElementReferences[200];  UInt32 bufferSize = 200;  UInt32 count;  err = ISpElementList_Extract(globalList, bufferSize, &amp;count, theElementReferences);  if (err)  {    printf(&quot;*** ISpElementList_Extract returned error (%ld)\n&quot;,err);    return;  }    PrintElementBlock(theElementReferences, count);}static void TestListOfButtons(void){  ISpElementListReference globalList;  OSErr err;    err = ISpGetGlobalElementList(&amp;globalList);  if (err)  {    printf(&quot;*** ISpGetGlobalElementList returned error (%ld)\n&quot;,err);    return;  }    ISpElementReference theElementReferences[200];  UInt32 bufferSize = 200;  UInt32 count;  err = ISpElementList_ExtractByKind(globalList, kISpElementKind_Button, bufferSize, &amp;count, theElementReferences);  if (err)  {    printf(&quot;*** ISpElementList_Extract returned error (%ld)\n&quot;,err);    return;  }    PrintElementBlock(theElementReferences, count);}static void TestListOfDPads(void){  ISpElementListReference globalList;  OSErr err;    err = ISpGetGlobalElementList(&amp;globalList);  if (err)  {    printf(&quot;*** ISpGetGlobalElementList returned error (%ld)\n&quot;,err);    return;  }    ISpElementReference theElementReferences[200];  UInt32 bufferSize = 200;  UInt32 count;  err = ISpElementList_ExtractByKind(globalList, kISpElementKind_DPad, bufferSize, &amp;count, theElementReferences);  if (err)  {    printf(&quot;*** ISpElementList_Extract returned error (%ld)\n&quot;,err);    return;  }    PrintElementBlock(theElementReferences, count);}static void TestListOfAxes(void){  ISpElementListReference globalList;  OSErr err;    err = ISpGetGlobalElementList(&amp;globalList);  if (err)  {    printf(&quot;*** ISpGetGlobalElementList returned error (%ld)\n&quot;,err);    return;  }    ISpElementReference theElementReferences[200];  UInt32 bufferSize = 200;  UInt32 count;  err = ISpElementList_ExtractByKind(globalList, kISpElementKind_Axis, bufferSize, &amp;count, theElementReferences);  if (err)  {    printf(&quot;*** ISpElementList_Extract returned error (%ld)\n&quot;,err);    return;  }    PrintElementBlock(theElementReferences, count);}static void TestListOfXAxes(void){  ISpElementListReference globalList;  OSErr err;    err = ISpGetGlobalElementList(&amp;globalList);  if (err)  {    printf(&quot;*** ISpGetGlobalElementList returned error (%ld)\n&quot;,err);    return;  }    ISpElementReference theElementReferences[200];  UInt32 bufferSize = 200;  UInt32 count;  err = ISpElementList_ExtractByLabel(globalList, kISpElementLabel_Axis_XAxis, bufferSize, &amp;count, theElementReferences);  if (err)  {    printf(&quot;*** ISpElementList_Extract returned error (%ld)\n&quot;,err);    return;  }    PrintElementBlock(theElementReferences, count);}static void TestSuspend(void){  OSErr err;    err = ISpSuspend();  if (err)  {    printf(&quot;*** ISpSuspend returned error (%ld)\n&quot;,err);    return;  }    gIsSuspended = true;}static void TestResume(void){  OSErr err;    err = ISpResume();  if (err)  {    printf(&quot;*** ISpResume returned error (%ld)\n&quot;,err);    return;  }    gIsSuspended = false;}static void TestCreateNeeds(void){  OSErr err;    if (gVirtualList == NULL)  {    printf(&quot;creating virtual elements\n&quot;);          err = ISpElement_NewVirtualFromNeeds(kNeedCount, gNeeds, gVirtualElements, 0);    if (err)    {      printf(&quot;*** ISpElement_NewVirtualFromNeeds returned error (%ld)\n&quot;,err);      return;    }        err = ISpElementList_New(      kNeedCount,        // count      gVirtualElements,    // needs      &amp;gVirtualList,      // virtual elements      0);            // flags    if (err)    {      printf(&quot;*** ISpElementList_New returned error (%ld)\n&quot;,err);      return;    }            err = ISpInit(kNeedCount,  // count        gNeeds,        // needs        gVirtualElements,  // virtual elements        kCreatorCode,    // app        kSubCreatorCode,  // sub (we are using as a versioning)        0,          // flags        kResourceID_setl,  // set list resource id        0);          // reserved    if (err)    {      printf(&quot;*** ISpInit returned error (%ld)\n&quot;,err);      return;    }  }}static void TestDestroyNeeds(void){  OSErr err;    if (gVirtualList != NULL)  {    err = ISpElementList_Dispose(gVirtualList);    gVirtualList = NULL;    if (err)    {      printf(&quot;*** ISpElementList_Dispose returned error (%ld)\n&quot;,err);      return;    }         err = ISpStop();    if (err)    {      printf(&quot;*** ISpStop returned error (%ld)\n&quot;,err);      return;    }        err = ISpElement_DisposeVirtual(kNeedCount, gVirtualElements);    if (err)    {      printf(&quot;*** ISpElement_DisposeVirtual returned error (%ld)\n&quot;,err);      return;    }  }}static void TestNeedsEvents(void){  TestCreateNeeds();    if (gVirtualList != NULL)  {    GetAndPrintEvents(gVirtualList);  }}static void TestConfiguration(void){  OSErr err;    TestCreateNeeds();    err = ISpConfigure(nil);  if (err)  {    printf(&quot;*** ISpConfigure returned error (%ld)\n&quot;,err);    return;  }}static void EnableDeviceClass(OSType deviceClass, Boolean enable){  enum {    kDeviceList_COUNT = 100  };    OSStatus err;  UInt32 count;  ISpDeviceReference deviceList[kDeviceList_COUNT];    // NOTE: This is not the correct way to handle the list count thing.  We  // should actually call once with NULL for the device list, malloc a list of  // that size, and call again.    err = ISpDevices_ExtractByClass(      deviceClass,      kDeviceList_COUNT,      &amp;count,      deviceList);    if (err)  {    printf(&quot;*** ISpDevices_ExtractByClass returned error (%ld)\n&quot;,err);    return;  }    if (count &gt; kDeviceList_COUNT)  {    count = kDeviceList_COUNT;  }    if (enable)  {    err = ISpDevices_Activate(        count,        deviceList);        if (err)    {      printf(&quot;*** ISpDevices_Activate returned error (%ld)\n&quot;,err);      return;    }  }  else  {    err = ISpDevices_Deactivate(        count,        deviceList);        if (err)    {      printf(&quot;*** ISpDevices_Deactivate returned error (%ld)\n&quot;,err);      return;    }  }    if (deviceClass == kISpDeviceClass_Keyboard)  {    gKeyboardEnabled = enable;  }}static void TestAllocateDeallocate(void){  OSErr err = noErr;  UInt32 count = 0;  char theString[32];  UInt32 itr;    ISpElementReference virtuals[kNeedCount];  Boolean done = false;    printf(&quot;allocate/dellocate how many times&gt;&quot;);    gets( theString );  count = atoi( theString );  printf(&quot;allocating/deallocating %ld times\n&quot;,count);    for(itr = 0; itr &lt; count; itr++)  {    if ((itr % 100) == 0) { putchar('.'); fflush(stdout);  }    if ((itr % 1000) == 0)     {      long normal = FreeMem();      long system = FreeMemSys();      printf(&quot;%ld / %ld (app = %ld) (sys = %ld) \n&quot;,itr,count,normal,system);    }      SIOUXHandleOneEvent(nil);          err = ISpElement_NewVirtualFromNeeds(kNeedCount, gNeeds, virtuals, 0);        if (err)    {      printf(&quot;*** itr = %d ISpElement_NewVirtualFromNeeds returned error (%ld)\n&quot;,itr, err);            done = true;    }      err = ISpElement_DisposeVirtual(kNeedCount, virtuals);      if (err)    {      printf(&quot;*** ISpElementList_Dispose returned error (%ld)\n&quot;,err);      return;    }        if (done) { return; }  }}#define MAX_ELEMENTS  1000#define MAX_DATASIZE  1000#if DEBUG_DRIVERstatic void TestAllocatePushData(void){  char theString[32];  OSErr err = noErr;  UInt32 elementCount = 0;  UInt32 dataSize;  UInt32 count;  UInt32 elemItr, itr;  ISpElementReference elements[MAX_ELEMENTS];  UInt8 state[MAX_DATASIZE];    printf(&quot;how many elements&gt;&quot;);  gets( theString );  elementCount = atoi( theString );  printf(&quot;data size&gt;&quot;);  gets( theString );  dataSize = atoi( theString );  printf(&quot;count&gt;&quot;);  gets( theString );  count = atoi( theString );  printf(&quot;%ld elements, data size = %ld, count = %ld\n&quot;, elementCount, dataSize, count);      if ((elementCount &gt; MAX_ELEMENTS) || (dataSize &gt; MAX_DATASIZE))  {    printf(&quot;*** MAX_ELEMENTS = %d MAX_DATASIZE = %d\n&quot;,MAX_ELEMENTS,MAX_DATASIZE);    return;  }  for(elemItr = 0; elemItr &lt; elementCount; elemItr++)  {    err = ISpElement_NewVirtual(dataSize, &amp;(elements[elemItr]), 0);    if (err)    {      printf(&quot;*** ISpElement_NewVirtual returned error (%d)\n&quot;,err);            err = ISpElement_DisposeVirtual(elemItr, elements);      if (err)      {        printf(&quot;*** ISpElement_DisposeVirtual returned error (%d)\n&quot;,err);      }            return;    }  }    for(itr = 0; itr &lt; count; itr++)  {    AbsoluteTime time = {0, TickCount() };        if ((itr % 100) == 0) { printf(&quot;.&quot;); }    if ((itr % 1000) == 0)     {      long normal = FreeMem();      long system = FreeMemSys();      Ptr temp = NewPtr(1000);      DisposePtr(temp);      printf(&quot;%ld / %ld (app = %ld) (sys = %ld) \n&quot;,itr,count,normal,system);          }        SIOUXHandleOneEvent(nil);        for(elemItr = 0; elemItr &lt; elementCount; elemItr++)    {      err = ISpElement_PushComplexData(elements[elemItr], dataSize, &amp;state, &amp;time);            if (err)      {        printf(&quot;*** ISpElement_PushComplexData returned error (%d)\n&quot;,err);        return;      }    }  }  printf(&quot;\ndisposing elements\n&quot;);  err = ISpElement_DisposeVirtual(elementCount, elements);  if (err)  {    printf(&quot;*** ISpElement_DisposeVirtual returned error (%d)\n&quot;,err);  }}#endif /* DEBUG_DRIVER */static void TestArbitraryAllocate(void){  char theString[32];  OSErr err = noErr;  UInt32 elementCount = 0;  UInt32 dataSize;  UInt32 elemItr;  ISpElementReference elements[MAX_ELEMENTS];    printf(&quot;how many elements&gt;&quot;);  gets( theString );  elementCount = atoi( theString );  printf(&quot;data size&gt;&quot;);  gets( theString );  dataSize = atoi( theString );  printf(&quot;%ld elements, data size = %ld\n&quot;, elementCount, dataSize);      if ((elementCount &gt; MAX_ELEMENTS) || (dataSize &gt; MAX_DATASIZE))  {    printf(&quot;*** MAX_ELEMENTS = %d MAX_DATASIZE = %d\n&quot;,MAX_ELEMENTS,MAX_DATASIZE);    return;  }  printf(&quot;allocating elements\n&quot;);  for(elemItr = 0; elemItr &lt; elementCount; elemItr++)  {    err = ISpElement_NewVirtual(dataSize, &amp;(elements[elemItr]), 0);    if (err)    {      printf(&quot;*** ISpElement_NewVirtual returned error (%d)\n&quot;,err);            err = ISpElement_DisposeVirtual(elemItr, elements);      if (err)      {        printf(&quot;*** ISpElement_DisposeVirtual returned error (%d)\n&quot;,err);      }            return;    }  }  printf(&quot;\ndisposing elements\n&quot;);  err = ISpElement_DisposeVirtual(elementCount, elements);  if (err)  {    printf(&quot;*** ISpElement_DisposeVirtual returned error (%d)\n&quot;,err);  }}#define MTemp 0x828#define RawMouse 0x82c#define CrsrNewCouple 0x8cestatic void TestAcceleration(void){  TestCreateNeeds();  ShowCursor();  Point where =  * ( Point * ) RawMouse;  float deltaX = 0;  float deltaY = 0;    while(1)  {    gVirtualElements[kNeedIndex_XAxis];    gVirtualElements[kNeedIndex_YAxis];        UInt32 forward;    UInt32 side;    OSStatus status;    float temp;    SInt8 amt;        status = ISpElement_GetSimpleState(gVirtualElements[kNeedIndex_XAxis], &amp;forward);    if (status == noErr)    {      temp = forward;      temp -= kISpAxisMiddle;      temp /= kISpAxisMiddle;      temp *= 25;            deltaX += temp;            if (deltaX &gt;= 1)       {        amt = deltaX;        where.h += amt;        deltaX -= amt;      }      else if (deltaX &lt;= -1)      {        amt = -deltaX;        where.h -= amt;        deltaX += amt;      }    }        status = ISpElement_GetSimpleState(gVirtualElements[kNeedIndex_YAxis], &amp;side);    if (status == noErr)    {      temp = side;      temp -= kISpAxisMiddle;      temp /= kISpAxisMiddle;      temp *= -25;            deltaY += temp;      if (deltaY &gt;= 1)       {        amt = deltaY;        where.v += amt;        deltaY -= amt;      }      else if (deltaY &lt;= -1)      {        amt = -deltaY;        where.v -= amt;        deltaY += amt;      }    }            HideCursor();          * ( Point * ) RawMouse = where ;      * ( Point * ) MTemp = where ;      * ( short * ) CrsrNewCouple = -1 ;            ShowCursor();      KeyMap theKeys;    GetKeys(theKeys);    if ((theKeys[1] &amp; 0x8000))    {      break;    }        unsigned long aLong = ::TickCount();        while (aLong == TickCount()) { ; }  }}static void TestAcceleration2(void){  TestCreateNeeds();  ShowCursor();    while(1)  {    Point where = * ( Point * ) RawMouse;    Fixed horzPos = where.h * fixed1;    Fixed vertPos = where.v * fixed1;    Fixed horzDelta = 0;    Fixed vertDelta = 0;    OSStatus status;        status = ISpElement_GetSimpleState(gVirtualElements[kNeedIndex_DeltaAccelerationX],  (UInt32 *) &amp;horzDelta);    status = ISpElement_GetSimpleState(gVirtualElements[kNeedIndex_DeltaAccelerationY],  (UInt32 *) &amp;vertDelta);        if ((horzDelta != 0) || (vertDelta != 0))    {      HideCursor();            horzPos += 72 * horzDelta;      vertPos -= 72 * vertDelta;            where.h = horzPos / fixed1;      where.v = vertPos / fixed1;            * ( Point * ) RawMouse = where ;        * ( Point * ) MTemp = where ;        * ( short * ) CrsrNewCouple = -1 ;                ShowCursor();    }      KeyMap theKeys;    GetKeys(theKeys);    if ((theKeys[1] &amp; 0x8000))    {      break;    }  }}#define FVERIFY(x)  if (x) { FailCode(x); return false; }#define FVERIFY2(x, y)  if (x) {  char VERIFY2_DEBUG_STATUS[512]; \                  sprintf(VERIFY2_DEBUG_STATUS,&quot;%s got %d&quot;,y,x); \                   FailMsg(VERIFY2_DEBUG_STATUS); return false; }// true if ExtractByClass works// false otherwise// static Boolean VerifyExtractByClass(void){  ISpDeviceClass deviceClass;  const UInt32 kNumDeviceClass = 8;  ISpDeviceClass kDeviceClassArray[kNumDeviceClass] = { kISpDeviceClass_SpeechRecognition,                  kISpDeviceClass_Mouse,                  kISpDeviceClass_Keyboard,                  kISpDeviceClass_Joystick,                  kISpDeviceClass_Wheel,                  kISpDeviceClass_Pedals,                  kISpDeviceClass_Levers,                  'junk'                  };  UInt32 deviceClassItr;  OSStatus err;  UInt32 result1, result2, result3;  const UInt32 kFixedBufferSize = 100;  ISpDeviceReference fixedBuffer[kFixedBufferSize] = { 0 } ;  ISpDeviceReference *exactBuffer;  UInt32 verifyItr;  char debug_status[255];    NextStep(&quot;broad band ISpDevices_ExtractByClass verification&quot;);    for(deviceClassItr = 0; deviceClassItr &lt; kNumDeviceClass; deviceClassItr++)  {      deviceClass = kDeviceClassArray[deviceClassItr];        sprintf(debug_status, &quot;device class = %c%c%c%c&quot;, (deviceClass &amp; 0xff000000) &gt;&gt; 24, (deviceClass &amp; 0xff0000) &gt;&gt; 16,         (deviceClass &amp; 0xff00) &gt;&gt; 8, (deviceClass &amp; 0xff) &gt;&gt; 0);    StatusMsg(debug_status);        // result 1    err = ISpDevices_ExtractByClass(deviceClass, 0, &amp;result1, NULL);    if (err) { FailMsg(&quot;ISpDevices_ExtractByClass failed with a null buffer&quot;); return false; }        sprintf(debug_status, &quot;found %d devices of that type&quot;,result1);    StatusMsg(debug_status);        // result 2    err = ISpDevices_ExtractByClass(deviceClass, kFixedBufferSize, &amp;result2, fixedBuffer);    if (err) { FailMsg(&quot;ISpDevices_ExtractByClass failed with a fixed buffer&quot;); return false; }    for(verifyItr = 0; ((verifyItr &lt; result2) &amp;&amp; (verifyItr &lt; kFixedBufferSize)); verifyItr ++)    {      StatusMsg(&quot;verifying on list 2&quot;);      if (fixedBuffer[verifyItr] == nil)       {        FailMsg(&quot;ISpDevices_ExtractByClass failed to verify non nil with a fixed buffer&quot;);        return false;      }    }        // result 3    exactBuffer = (ISpDeviceReference *) NewPtrClear(sizeof(ISpDeviceReference) * result1);    if (exactBuffer == nil) { FailMsg(&quot;Problem with test program not the sprocket, test program needs more memory!&quot;); return false; }    err = ISpDevices_ExtractByClass(deviceClass, result1, &amp;result3, exactBuffer);    if (err) { FailMsg(&quot;ISpDevices_ExtractByClass failed with an exact buffer&quot;); return false; }    for(verifyItr = 0; verifyItr &lt; result3; verifyItr ++)    {      StatusMsg(&quot;verifying on list 3&quot;);      if (exactBuffer[verifyItr] == nil)       {        FailMsg(&quot;ISpDevices_ExtractByClass failed to verify non nil with an exact buffer&quot;);        return false;      }    }    DisposePtr((Ptr) exactBuffer);        if ((result1 != result2) || (result1 != result3))    {      FailMsg(&quot;the three results were not all the same!&quot;);      return false;    }  }    return true;}static Boolean VerifyActivateDeactive(void){  const UInt32 kMaxDevices = 100;  ISpDeviceReference devices[kMaxDevices];  OSStatus err;  UInt32 numDevices;  char debug_status[512];  NextStep(&quot;Running Enable/Disable test&quot;);  UInt32 deviceItr;  UInt32 enableDisableItr;  const UInt32 kNumEnableDisableAttempts = 100;    err = ISpDevices_Extract(kMaxDevices, &amp;numDevices, devices);  FVERIFY2(err,&quot;ISpDevices_Extract&quot;)      for(deviceItr = 0; deviceItr &lt; numDevices; deviceItr++)  {    ISpDeviceReference thisDevice = devices[deviceItr];    Boolean wasActive;    ISpDeviceDefinition thisDefinition;        err = ISpDevice_IsActive(thisDevice, &amp;wasActive);    FVERIFY2(err, &quot;ISpDevice_IsActive&quot;);        if (wasActive)    {      err = ISpDevices_Deactivate(1, &amp;thisDevice);      FVERIFY2(err, &quot;ISpDevices_Deactivate&quot;)    }        err = ISpDevice_GetDefinition(thisDevice, sizeof(ISpDeviceDefinition), &amp;thisDefinition);    FVERIFY2(err, &quot;ISpDevice_GetDefinition&quot;)        sprintf(debug_status,&quot;working on device &quot;);    AppendStr63(debug_status, thisDefinition.deviceName);    StatusMsg(debug_status);        for(enableDisableItr = 0; enableDisableItr &lt; kNumEnableDisableAttempts; enableDisableItr++)    {      if (Progress(enableDisableItr, kNumEnableDisableAttempts, 10, debug_status))      {        StatusMsg(debug_status);      }            err = ISpDevices_Activate(1, &amp;thisDevice);      FVERIFY2(err, &quot;ISpDevices_Activate&quot;)      err = ISpDevices_Deactivate(1, &amp;thisDevice);      FVERIFY2(err, &quot;ISpDevices_Deactivate&quot;)          }        StatusMsg(&quot;100%&quot;);        if (wasActive)    {      err = ISpDevices_Activate(1, &amp;thisDevice);      FVERIFY2(err, &quot;ISpDevices_Activate&quot;)    }  }    return true;  }static void WaitForAnyKey(void){  KeyMap theKeyMap;    GetKeys(theKeyMap);    while((theKeyMap[0] == 0) &amp;&amp; (theKeyMap[1] == 0) &amp;&amp; (theKeyMap[2] == 0) &amp;&amp; (theKeyMap[3] == 0))  {    SIOUXHandleOneEvent(nil);    GetKeys(theKeyMap);  }}#define VERIFY(x)  if (x) { FailCode(x); return; }static void AutoTest(void){  OSStatus err;  char debug_status[512];  debug_status;  Boolean success;  InitStep(&quot;press any key to begin AutoTest&quot;);  WaitForAnyKey();  NextStep(&quot;getting the version of input sprocket&quot;);  {    NumVersion version = ISpGetVersion();    sprintf(debug_status, &quot;version = %x %x %x %x\n&quot;,version.majorRev, version.minorAndBugRev, version.stage, version.nonRelRev);    StatusMsg(debug_status);  }      NextStep(&quot;verifying that this is the first initialization&quot;);  {    if (gVirtualList != NULL)    {      FailMsg(&quot;this was not the first time a test was run for this launch of the application&quot;);      return;    }  }    NextStep(&quot;starting up&quot;);  {    err = ISpStartup();    VERIFY(err);  }    NextStep(&quot;looping on startup / shutdown&quot;);  {    const UInt32 kStartShutAttempts = 20;    UInt32 startShutItr;            for(startShutItr = 0; startShutItr &lt; kStartShutAttempts; startShutItr++)    {      err = ISpShutdown();      VERIFY(err)      err = ISpStartup();      VERIFY(err);      if (Progress(startShutItr, kStartShutAttempts, 10, debug_status))      {        StatusMsg(debug_status);      }    }  }      NextStep(&quot;single ISpSuspend (low level)&quot;);  err = ISpSuspend();  VERIFY(err);  NextStep(&quot;single ISpResume (low level)&quot;);  err = ISpResume();  VERIFY(err);  NextStep(&quot;testing suspend/resume repeatedly (low level)&quot;);  {    UInt32 kSuspendResumeLLCount = 1000;    UInt32 suspendResumeLLItr;            for(suspendResumeLLItr = 0; suspendResumeLLItr &lt; kSuspendResumeLLCount;  suspendResumeLLItr++)    {      if (Progress(suspendResumeLLItr, kSuspendResumeLLCount, 5, debug_status))      {        StatusMsg(debug_status);      }      err = ISpSuspend();      VERIFY(err);            err = ISpResume();      VERIFY(err);    }      }  NextStep(&quot;looping on startup / shutdown w/ a suspend in the middle&quot;);  {    const UInt32 kStartShutAttempts = 20;    UInt32 startShutItr;            for(startShutItr = 0; startShutItr &lt; kStartShutAttempts; startShutItr++)    {      if (Progress(startShutItr, kStartShutAttempts, 10, debug_status))      {        StatusMsg(debug_status);      }      err = ISpSuspend();      VERIFY(err);      err = ISpShutdown();      VERIFY(err)      err = ISpStartup();      VERIFY(err);    }  }  NextStep(&quot;creating virtual elements&quot;);    {      err = ISpElement_NewVirtualFromNeeds(kNeedCount, gNeeds, gVirtualElements, 0);    VERIFY(err)  }    NextStep(&quot;looping on disposing/recreating elements&quot;);  {    const UInt32 kDisposeCreateVirtualAttempts = 1000;    UInt32 disposeCreateItr;        for(disposeCreateItr = 0; disposeCreateItr &lt; kDisposeCreateVirtualAttempts; disposeCreateItr++)    {          err = ISpElement_DisposeVirtual(kNeedCount, gVirtualElements);      VERIFY(err)        err = ISpElement_NewVirtualFromNeeds(kNeedCount, gNeeds, gVirtualElements, 0);      VERIFY(err)      if (Progress(disposeCreateItr, kDisposeCreateVirtualAttempts, 10, debug_status))      {        StatusMsg(debug_status);      }    }  }    NextStep(&quot;creating an element list&quot;);  {    err = ISpElementList_New(      kNeedCount,        // count      gVirtualElements,    // needs      &amp;gVirtualList,      // virtual elements      0);            // flags      VERIFY(err)  }    NextStep(&quot;initializing input sprocket once&quot;);  {    err = ISpInit(kNeedCount,  // count        gNeeds,        // needs        gVirtualElements,  // virtual elements        kCreatorCode,    // app        kSubCreatorCode,  // sub        0,          // flags        kResourceID_setl,  // set list resource id        0);          // version    VERIFY(err)  }    NextStep(&quot;looping on ISpInit / ISpStop&quot;);  {    const UInt32 kStartStopAttempts = 20;    UInt32 startStopItr;            err = ISpStop();    VERIFY(err)    for(startStopItr = 0; startStopItr &lt; kStartStopAttempts; startStopItr++)    {      if (Progress(startStopItr, kStartStopAttempts, 10, debug_status))      {        StatusMsg(debug_status);      }      err = ISpInit(kNeedCount, gNeeds, gVirtualElements, kCreatorCode, kSubCreatorCode, 0, kResourceID_setl, 0);      VERIFY(err);      err = ISpStop();      VERIFY(err)    }      err = ISpInit(kNeedCount, gNeeds, gVirtualElements, kCreatorCode, kSubCreatorCode, 0, kResourceID_setl, 0);    VERIFY(err);  }    NextStep(&quot;counting all the devices (verying size buffer) + isActive&quot;);  {    const UInt32 maxExtractBufferSize = 1000;    ISpDeviceReference buffer[maxExtractBufferSize];    UInt32 deviceCount;    UInt32 bufferSizeItr;    UInt32 bufferItr;    Boolean isActive;        for(bufferSizeItr = 0; bufferSizeItr &lt; 1000; bufferSizeItr++)    {      if (Progress(bufferSizeItr, maxExtractBufferSize, 5, debug_status))      {        StatusMsg(debug_status);      }          // step 1 put the buffer into a known state      for(bufferItr = 0; bufferItr &lt; maxExtractBufferSize; bufferItr++)      {        buffer[bufferItr] = (ISpDeviceReference) 0xd0d0babe;      }            // step 2 call extract      err = ISpDevices_Extract(bufferSizeItr, &amp;deviceCount, buffer);      if (!err)      {        for(bufferItr = 0; ((bufferItr &lt; deviceCount) &amp;&amp; (bufferItr &lt; bufferSizeItr)); bufferItr++)        {          if ((UInt32) buffer[bufferItr] == 0xd0d0babe)          {            sprintf(debug_status, &quot;bufferSizeItr = %d deviceCount = %d, bufferItr = %d&quot;,bufferSizeItr, deviceCount, bufferItr);            StatusMsg(debug_status);          }                    err = ISpDevice_IsActive(buffer[bufferItr], &amp;isActive);          if (err) { break; }        }      }      VERIFY(err)        // step 3 verify the buffer contents      for(; bufferItr &lt; maxExtractBufferSize; bufferItr++)      {        if (((UInt32) buffer[bufferItr]) != 0xd0d0babe)         {          sprintf(debug_status,&quot;spilled off the end loc = %d cnt = %d&quot;,bufferItr,deviceCount);          StatusMsg(debug_status);        }      }    }  }        NextStep(&quot;verifying all the devices (100 size buffer) w/ ISpDevice_GetDefinition&quot;);  {    UInt32 deviceCount;    ISpDeviceReference buffer[100];    UInt32 itr;    ISpDeviceDefinition outStruct;        err = ISpDevices_Extract(100, &amp;deviceCount, buffer);        if (!err)    {      for(itr = 0; itr &lt; deviceCount; itr++)      {        err = ISpDevice_GetDefinition(buffer[itr], sizeof(ISpDeviceDefinition), &amp;outStruct);        if (err) { break; }      }    }              VERIFY(err)  }    NextStep(&quot;searching for all the devices of class kISpDeviceClass_Mouse&quot;);  {    UInt32 deviceCount;    ISpDeviceReference buffer[100];        err = ISpDevices_ExtractByClass(kISpDeviceClass_Mouse, 100, &amp;deviceCount, buffer);        VERIFY(err)  }  NextStep(&quot;searching for all the devices of class kISpDeviceClass_Keyboard&quot;);  {    UInt32 deviceCount;    ISpDeviceReference buffer[100];        err = ISpDevices_ExtractByClass(kISpDeviceClass_Keyboard, 100, &amp;deviceCount, buffer);        VERIFY(err)  }  NextStep(&quot;searching for all the devices of class kISpDeviceClass_Joystick&quot;);  {    UInt32 deviceCount;    ISpDeviceReference buffer[100];        err = ISpDevices_ExtractByClass(kISpDeviceClass_Joystick, 100, &amp;deviceCount, buffer);        VERIFY(err)  }    success = VerifyExtractByClass();  if (!success) { return; }    success = VerifyActivateDeactive();  if (!success) { return; }    NextStep(&quot;bringing up the configuration screen (devices disabled, dialog warning you there are no devices is OK)&quot;);  {    err = ISpConfigure(nil);        VERIFY(err)  }    NextStep(&quot;enabling all the devices of class kISpDeviceClass_Mouse&quot;);  {    UInt32 deviceCount;    ISpDeviceReference buffer[100];    err = ISpDevices_ExtractByClass(kISpDeviceClass_Mouse, 100, &amp;deviceCount, buffer);        if (!err)    {      err = ISpDevices_Activate(deviceCount, buffer);    }        VERIFY(err)  }  NextStep(&quot;enabling all the devices of class kISpDeviceClass_Keyboard&quot;);  {    UInt32 deviceCount;    ISpDeviceReference buffer[100];        err = ISpDevices_ExtractByClass(kISpDeviceClass_Keyboard, 100, &amp;deviceCount, buffer);        if (!err)    {      err = ISpDevices_Activate(deviceCount, buffer);    }    VERIFY(err)  }    NextStep(&quot;bringing up the configuration screen&quot;);  {    err = ISpConfigure(nil);        VERIFY(err)  }    NextStep(&quot;bringing up the configuration screen w/ filter proc&quot;);  {    err = ISpConfigure(ISpConfigureFilterProc);        VERIFY(err)  }    NextStep(&quot;getting the global list&quot;);  {    ISpElementListReference globalList;        err = ISpGetGlobalElementList(&amp;globalList);    VERIFY(err)  }    NextStep(&quot;flushing the global list (and pausing)&quot;);  {    ISpElementListReference globalList;    unsigned long ticks;    const number_of_seconds_to_pause = 2;        err = ISpGetGlobalElementList(&amp;globalList);    if (!err)    {      ticks = TickCount();      ticks += number_of_seconds_to_pause * 60;            while(ticks &gt; TickCount())      {        err = ISpElementList_Flush(globalList);        if (err) { break; }      }    }    VERIFY(err)  }    NextStep(&quot;testing getting events, please press a button or move an axis&quot;);  {    ISpElementListReference globalList;    ISpElementEvent event;    Boolean wasEvent;        err = ISpGetGlobalElementList(&amp;globalList);        if (!err)    {      wasEvent = false;            while(!wasEvent)      {        err = ISpElementList_GetNextEvent(globalList, sizeof(ISpElementEvent), &amp;event, &amp;wasEvent);                if (err == kISpBufferToSmallErr) { err = noErr; }                if (err) { break; }      }    }        VERIFY(err)  }  NextStep(&quot;flushing the need list (and pausing)&quot;);  {    unsigned long ticks;    const number_of_seconds_to_pause = 2;        ticks = TickCount();    ticks += number_of_seconds_to_pause * 60;        while(ticks &gt; TickCount())    {      err = ISpElementList_Flush(gVirtualList);      if (err) { break; }    }    VERIFY(err)  }    NextStep(&quot;testing getting need events, please press a configured button or move an axis (escape should always work)&quot;);  {    ISpElementEvent event;    Boolean wasEvent;        wasEvent = false;        while(!wasEvent)    {      err = ISpElementList_GetNextEvent(gVirtualList, sizeof(ISpElementEvent), &amp;event, &amp;wasEvent);            if (err) { break; }    }        VERIFY(err)  }    NextStep(&quot;single ISpSuspend&quot;);  err = ISpSuspend();  VERIFY(err);  NextStep(&quot;single ISpResume&quot;);  err = ISpResume();  VERIFY(err);  NextStep(&quot;testing suspend/resume repeatedly (high level)&quot;);  {    UInt32 kSuspendResumeCount = 1000;    UInt32 suspendResumeItr;            err = ISpSuspend();    VERIFY(err);          err = ISpResume();    VERIFY(err);    for(suspendResumeItr = 0; suspendResumeItr &lt; kSuspendResumeCount;  suspendResumeItr++)    {      if (Progress(suspendResumeItr, kSuspendResumeCount, 5, debug_status))      {        StatusMsg(debug_status);      }      err = ISpSuspend();      VERIFY(err);            err = ISpResume();      VERIFY(err);    }      }  NextStep(&quot;disabling all the devices of class kISpDeviceClass_Mouse&quot;);  {    UInt32 deviceCount;    ISpDeviceReference buffer[100];    err = ISpDevices_ExtractByClass(kISpDeviceClass_Mouse, 100, &amp;deviceCount, buffer);        if (!err)    {      err = ISpDevices_Deactivate(deviceCount, buffer);    }        VERIFY(err)  }  NextStep(&quot;disabling all the devices of class kISpDeviceClass_Keyboard&quot;);  {    UInt32 deviceCount;    ISpDeviceReference buffer[100];        err = ISpDevices_ExtractByClass(kISpDeviceClass_Keyboard, 100, &amp;deviceCount, buffer);        if (!err)    {      err = ISpDevices_Deactivate(deviceCount, buffer);    }        VERIFY(err)  }    NextStep(&quot;stopping input sprocket&quot;);  {    err = ISpStop();        VERIFY(err)  }}#if AUTOTESTvoid main(void){  // tell SIOUX to shut up  SIOUXSettings.autocloseonquit = true;  SIOUXSettings.asktosaveonclose = false;  AutoTest();    UInt32 who_cares;    scanf(&quot;%d&quot;,&amp;who_cares);}#endif#if DIALOGTESTvoid main(void){  OSErr err = noErr;    NextStep(&quot;verifying that this is the first initialization&quot;);  {    if (gVirtualList != NULL)    {      FailMsg(&quot;this was not the first time a test was run for this launch of the application&quot;);      return;    }  }    NextStep(&quot;creating virtual elements&quot;);    {      err = ISpElement_NewVirtualFromNeeds(kNeedCount, gNeeds, gVirtualElements, 0);      VERIFY(err)  }    NextStep(&quot;creating an element list&quot;);  {    err = ISpElementList_New(      kNeedCount,        // count      gVirtualElements,    // needs      &amp;gVirtualList,      // virtual elements      0);            // flags      VERIFY(err)  }    NextStep(&quot;initializing input sprocket once&quot;);  {    err = ISpInit(kNeedCount,  // count        gNeeds,        // needs        gVirtualElements,  // virtual elements        kCreatorCode,    // app        kSubCreatorCode,  // sub        0,          // flags        kResourceID_setl,  // set list resource id        0);          // version    VERIFY(err)  }    NextStep(&quot;enabling all the devices of class kISpDeviceClass_Mouse&quot;);  {    UInt32 deviceCount;    ISpDeviceReference buffer[100];    err = ISpDevices_ExtractByClass(kISpDeviceClass_Mouse, 100, &amp;deviceCount, buffer);        if (!err)    {      err = ISpDevices_Activate(deviceCount, buffer);    }        VERIFY(err)  }  NextStep(&quot;enabling all the devices of class kISpDeviceClass_Keyboard&quot;);  {    UInt32 deviceCount;    ISpDeviceReference buffer[100];        err = ISpDevices_ExtractByClass(kISpDeviceClass_Keyboard, 100, &amp;deviceCount, buffer);        if (!err)    {      err = ISpDevices_Activate(deviceCount, buffer);    }    VERIFY(err)  }    NextStep(&quot;enabling all the devices of class kISpDeviceClass_SpeechRecognition&quot;);  {    UInt32 deviceCount;    ISpDeviceReference buffer[100];        err = ISpDevices_ExtractByClass(kISpDeviceClass_SpeechRecognition, 100, &amp;deviceCount, buffer);        if (!err)    {      err = ISpDevices_Activate(deviceCount, buffer);    }    VERIFY(err)  }  NextStep(&quot;bringing up the configuration screen&quot;);  {    err = ISpConfigure(nil);        VERIFY(err)  }    NextStep(&quot;disabling all the devices of class kISpDeviceClass_Mouse&quot;);  {    UInt32 deviceCount;    ISpDeviceReference buffer[100];    err = ISpDevices_ExtractByClass(kISpDeviceClass_Mouse, 100, &amp;deviceCount, buffer);        if (!err)    {      err = ISpDevices_Deactivate(deviceCount, buffer);    }        VERIFY(err)  }  NextStep(&quot;disabling all the devices of class kISpDeviceClass_Keyboard&quot;);  {    UInt32 deviceCount;    ISpDeviceReference buffer[100];        err = ISpDevices_ExtractByClass(kISpDeviceClass_Keyboard, 100, &amp;deviceCount, buffer);        if (!err)    {      err = ISpDevices_Deactivate(deviceCount, buffer);    }        VERIFY(err)  }  NextStep(&quot;stopping input sprocket&quot;);  {    err = ISpStop();        VERIFY(err)  }    NextStep(&quot;shutting down InputSprocket&quot;);  err = ISpShutdown();  VERIFY(err)}#endif#if MENUTESTvoid main(void){  OSErr err = noErr;    // tell SIOUX to shut up  SIOUXSettings.autocloseonquit = true;  SIOUXSettings.asktosaveonclose = false;    printf(&quot;starting up...\n&quot;);    NumVersion version = ISpGetVersion();  printf(&quot;version = %x %x %x %x\n&quot;,version.majorRev, version.minorAndBugRev, version.stage, version.nonRelRev);  NextStep(&quot;starting up InputSprocket&quot;);  err = ISpStartup();  VERIFY(err);  Boolean theDoneFlag = false;    EnableDeviceClass(kISpDeviceClass_SpeechRecognition, true);    while( !theDoneFlag )  {    UInt32 theChoice;        printf(&quot;\n\n\n############################################################\n&quot;);    if (gIsSuspended)    {      printf(&quot;* SUSPENDED *\n&quot;);    }        if (gVirtualList != NULL)    {      printf(&quot;* NEEDS ARE ACTIVE *\n&quot;);    }        printf(&quot;Please select from the following tests:\n&quot;);        printf(&quot;\t 1. Exit\n&quot;);    printf(&quot;\t 2. Run all tests automatically\n&quot;);    printf(&quot;\t 3. Test ISpElementList_ExtractByKind\n&quot;);    printf(&quot;\t 4. List all devices\n&quot;);    printf(&quot;\t 5. List all elements\n&quot;);    printf(&quot;\t 6. List all buttons\n&quot;);    printf(&quot;\t 7. List all directional pads\n&quot;);    printf(&quot;\t 8. List all axes\n&quot;);    printf(&quot;\t 9. List all X-axes\n&quot;);    printf(&quot;\t10. Get events (stop when Command key pressed)\n&quot;);    printf(&quot;\t11. Suspend\n&quot;);    printf(&quot;\t12. Resume\n&quot;);    printf(&quot;\t13. Create needs\n&quot;);    printf(&quot;\t14. Destroy needs\n&quot;);    printf(&quot;\t15. Get needs events\n&quot;);    printf(&quot;\t16. Configuration dialog\n&quot;);    printf(&quot;\t17. Enable mouse and keyboard\n&quot;);    printf(&quot;\t18. Disable mouse and keyboard\n&quot;);    printf(&quot;\t19. Reinitialize ADB bus\n&quot;);    printf(&quot;\t30. Allocate/Deallocate test\n&quot;);    #if DEBUG_DRIVER      printf(&quot;\t31. TestAllocatePushData test\n&quot;);    #endif    printf(&quot;\t32. TestArbitraryAllocate test\n&quot;);    printf(&quot;\t33. TestAccelration\n&quot;);    printf(&quot;\t34. Enable speech\n&quot;);    printf(&quot;\t35. Disable speech\n&quot;);    printf(&quot;\t36. Acceleration test # 2\n&quot;);        printf(&quot;\n\tSelection: &quot;);        Boolean keyboardEnabled = gKeyboardEnabled;    if (keyboardEnabled)    {      EnableDeviceClass(kISpDeviceClass_Keyboard, false);    }        char theString[32];    gets( theString );    theChoice = atoi( theString );        if (keyboardEnabled)    {      EnableDeviceClass(kISpDeviceClass_Keyboard, true);    }        printf(&quot;\n\n&quot;);        switch( theChoice )    {      case 1:        theDoneFlag = true;        break;              case 2:        AutoTest();        break;              case 3:        TestElementList_ExtractByKind();        break;              case 4:        TestListOfDevices();        break;                  case 5:        TestListOfElements();        break;                  case 6:        TestListOfButtons();        break;                  case 7:        TestListOfDPads();        break;                  case 8:        TestListOfAxes();        break;                  case 9:        TestListOfXAxes();        break;                  case 10:        GetAndPrintEvents(NULL);        break;                  case 11:        TestSuspend();        break;                  case 12:        TestResume();        break;                  case 13:        TestCreateNeeds();        break;                  case 14:        TestDestroyNeeds();        break;                  case 15:        TestNeedsEvents();        break;                  case 16:        TestConfiguration();        break;                  case 17:        EnableDeviceClass(kISpDeviceClass_Mouse, true);        EnableDeviceClass(kISpDeviceClass_Keyboard, true);        break;                  case 18:        EnableDeviceClass(kISpDeviceClass_Mouse, false);        EnableDeviceClass(kISpDeviceClass_Keyboard, false);        break;            case 19:        ADBReInit();        break;              case 30:        TestAllocateDeallocate();        break;        #if DEBUG_DRIVER      case 31:        TestAllocatePushData();        break;    #endif            case 32:        TestArbitraryAllocate();        break;            case 33:        TestAcceleration();        break;              case 34:        EnableDeviceClass(kISpDeviceClass_SpeechRecognition, true);        break;                  case 35:        EnableDeviceClass(kISpDeviceClass_SpeechRecognition, false);        break;            case 36:        TestAcceleration2();        break;      default:        printf(&quot;\nhuh?\n&quot;);        break;          }        printf(&quot;\nThank you, please drive through.\n&quot;);  }}#endif</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/InputSprocketTestOld/listing1.html%3Fid%3DDTS10000055-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/InputSprocketTestOld/listing1.html%3Fid%3DDTS10000055-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/InputSprocketTestOld/listing1.html%3Fid%3DDTS10000055-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>