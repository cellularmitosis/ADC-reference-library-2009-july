<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>AEObject-Edition Sample - /Publish.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxCarbon-date.html">Carbon</a> &gt; <A HREF="javascript:location.replace('index.html');">AEObject-Edition Sample</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxInterapplicationCommunication-date.html" target="_blank">Carbon > Interapplication Communication</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">AEObject-Edition Sample</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Publish.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/AEObject-Edition Sample.r</option>
<option value="listing2.html">/AEObject.c</option>
<option value="listing3.html">/AEUtilities.c</option>
<option value="listing4.html">/AppleEventCore.c</option>
<option value="listing5.html">/BuildHeaders.c</option>
<option value="listing6.html">/Files.c</option>
<option value="listing7.html">/globals.c</option>
<option value="listing8.html">/Initialize.c</option>
<option value="listing9.html">/Macros.h</option>
<option value="listing10.html">/main.c</option>
<option value="listing11.html">/Menu.c</option>
<option value="listing12.html">/Print.c</option>
<option value="listing13.html">/prototypes.h</option>
<option value="listing14.html">/Publish.c</option>
<option value="listing15.html">/SampConstants.h</option>
<option value="listing16.html">/Sampdefines.h</option>
<option value="listing17.html">/Structs.h</option>
<option value="listing18.html">/Subscribe.c</option>
<option value="listing19.html">/TextSections.c</option>
<option value="listing20.html">/Utilities.c</option>
<option value="listing21.html">/Windows.c</option></select>
				</p>
				</form>
				<p><strong><a href="AEObject-Edition_Sample.zip">Download Sample</a></strong> (&#147;AEObject-Edition_Sample.zip&#148;, 895.6K)<BR>
<strong><a href="AEObject-Edition_Sample.dmg">Download Sample</a></strong> (&#147;AEObject-Edition_Sample.dmg&#148;, 1.22M)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*------------------------------------------------------------------------------ * *  Apple Developer Technical Support * *  Edition publishing routines * *  Program:    AEObject-Edition Sample *  File:       Publish.c - C Source * *  by:         C.K. Haun &lt;TR&gt; * *  Copyright &copy; 1990-1992 Apple Computer, Inc. *  All rights reserved. * *------------------------------------------------------------------------------ * Publish handles most of the publishing housekeeping.  There is (are,am,be,whatever)  * some routines that are common to both publishing and subscribing, they  * are located in Subscribe.c  *----------------------------------------------------------------------------*/#define __PUBLISH__#pragma segment Publish#include &quot;Sampdefines.h&quot;/*  CreatePublisher takes the currently selected area in the current window *       and creates an edition.  It starts by setting up some default data *       structures and creating a preview picture.  *       Then the user is prompted for a location and name for the publisher*       with the NewPublisherDialog.  If the user clicks OK, then the edition*       is created and the section handle and rectangle for this edition is*       stored in my data structure for this window, and the first edition*       is written out.*/OSErr CreatePublisher(OSType typeToMake,Boolean fromEvent,FSSpecPtr theSpec){    NewPublisherReply myreply;    Handle theData;    Rect currentRect;    mySectionDataHandle pubText;    Str31 addPub;    static pubCounter;    OSErr myErr;  FSSpecPtr theOwningDoc = nil;    FSSpec tempSpec;    windowCHandle shortName;    extern Point expPoint;    extern Boolean gExpanded;  Boolean myWasChanged;    /* we're publishing from the current, topmost window */    shortName = (windowCHandle)GetWRefCon(FrontWindow());    HLock((Handle)shortName);    switch (typeToMake) {        case kGenericPICTWord:            currentRect = (*shortName)-&gt;selectionRect;            /* take the rectangle we currently have selected, and make it a picture */            theData = (Handle)MyMakePicture(&amp;currentRect);      /* my function to make a PICT */            /* Set up the reply record for the publisher dialog.  */            myreply.usePart = false;                        /* must be false */            myreply.previewFormat = kGenericPICTWord;                 /* type of data we're publishing */            myreply.preview = theData;                      /* handle to the pict data */            break;        case kGenericTEXTWord:            /* make text preview */            myreply.usePart = false;                        /* must be false */            myreply.previewFormat = kGenericTEXTWord;                 /* type of data we're publishing */            pubText = GetTextSection(shortName, stPublisher);            HLock((Handle)pubText);            theData = (*pubText)-&gt;additionalData;                  /* duplicate the text for our preview */            HandToHand(&amp;theData);            if (GetHandleSize(theData) &gt; kMaxTextPreview)                SetHandleSize(theData, kMaxTextPreview);                        myreply.preview = theData;            break;        case kCustomType:            break;    }    GetLastEditionContainerUsed(&amp;gEdSpec);                  /* get a new edition containter.  */    /* this call gives us a duplicate of the last used, or if none used last, gives */    /* us a default container */    /* BY THE WAY - the 'last used' means the last used by the Edition Manager, not */    /* by your application, so if you don't specify a default name then the */    /* name that comes up as the default for the edition may be the last */    /* name used by another application, or from the last time your */    /* application was run.  So if you are concerned about this (like you */    /* think it may confuse the user) set your own default */    /* As a sidelight (and not guarenteed) an alias to the last edition container used */    /* is stored in the 'Preferences' folder in the system folder */    myreply.container = gEdSpec;                            /* put our file spec in the container to be filled */    /* now set the default name to be the same as the window plus a count */    GetWTitle(FrontWindow(), &amp;myreply.container.theFile.name);    GetIndString(addPub, kGeneralStrings, kDotPub);    AppendString(myreply.container.theFile.name, addPub);    NumToString((long)((*shortName)-&gt;numPubs) + 1, addPub);    AppendString(myreply.container.theFile.name, addPub);  if(!fromEvent){    if (!gExpanded)        myErr = NewPublisherDialog(&amp;myreply);               /* run the dialog */    else  {    ExpDlgHookUPP dhUPP = NewExpDlgHookProc(ExpOptHook);    ExpModalFilterUPP mfUPP = NewExpModalFilterProc(ExpOptFilter);        myErr = NewPublisherExpDialog(&amp;myreply, expPoint, kExpandedDITL, dhUPP, mfUPP, nil);    DisposeRoutineDescriptor(dhUPP);    DisposeRoutineDescriptor(mfUPP);  }      if (myErr) {        ShowMe(&quot;\pPubisher dialog&quot;, myErr,__LINE__);        return(myErr);    }    if (myreply.canceled) {                                 /* they canceled.  release memory, reset our */        /* menus and cursors, and go away */        switch (typeToMake) {            case kGenericPICTWord:                KillPicture((PicHandle)theData);                InvalRect(&amp;(*shortName)-&gt;selectionRect);                gShowPub = false;                (*shortName)-&gt;hasSelection = false;                SetMyCursor(0);                SwitchChecks(kSelectStuff);                                break;            case kGenericTEXTWord:                DisposeHandle((*pubText)-&gt;additionalData);                DisposeHandle((Handle)pubText);                DisposeHandle(theData);                break;            case kCustomType:                break;        }        return(userCanceledErr);    }}    /* They clicked Publish.  First create the container (file) to hold the data */    /* See if thye are replacing a file */    if (!myreply.replacing) {    /* If we were given a spec by the event, the put that file in */    if(theSpec)myreply.container.theFile=*theSpec;        if (myErr = CreateEditionContainerFile(&amp;myreply.container.theFile, kMySignature, myreply.container.theFileScript)) {            ShowMe(&quot;\pCreateEditionContainerFIle&quot;, myErr,__LINE__);            return(myErr);        }     } else {    /* they agreed to delete an existing file.  Kill it. */    FSpDelete(&amp;myreply.container.theFile);    if (myErr = CreateEditionContainerFile(&amp;myreply.container.theFile, kMySignature, myreply.container.theFileScript)) {            ShowMe(&quot;\pCreateEditionContainerFIle&quot;, myErr,__LINE__);            return(myErr);    }    }    /* now create the section record to describe this data to the edition manager */    /*  The section handle that is returned by this function will be the */    /* way that you will reference this edition for as long as the edition is */    /* active. */    /* The main way you'll keep track is through the section ID number. */    /* In this case, I have a base ID number for the window, and I just increment */    /* my general ID (gSectionID) every time I create an edition, and add it to the window ID.  */    if (GetHandleSize((Handle)(*shortName)-&gt;fileAliasHandle) == 0) {        myErr = NewSection(&amp;myreply.container, nil, stPublisher, (*shortName)-&gt;windowID + gSectionID, pumOnSave, &amp;gSecHandle);        /* nil for sectionDocument if it's never been saved */    } else {        /* if the file has been saved once, then we can store a reference to the 'parent' file */        /* in the edition */        myErr = ResolveAlias(nil, ((*shortName)-&gt;fileAliasHandle), &amp;tempSpec, &amp;myWasChanged);        myErr = NewSection(&amp;myreply.container, &amp;tempSpec, stPublisher, (*shortName)-&gt;windowID + gSectionID, pumOnSave,                           &amp;gSecHandle);        theOwningDoc=&amp;tempSpec;    }      if (!myErr) {        /* put the section handle into our window structure */        (*gSecHandle)-&gt;refCon = kNeverSaved;                /*            meaning that this _document_ has not been saved */        /* put what type of thing this is in the refcon of the section handle */        switch (typeToMake) {            /* This is a little kludgy because I want to */            case kGenericPICTWord:                (*gSecHandle)-&gt;refCon = kPictType;                break;            case kGenericTEXTWord:                (*gSecHandle)-&gt;refCon = kTextType;                break;        }        StorePublisher(shortName, gSecHandle, &amp;(*shortName)-&gt;selectionRect, pubText, typeToMake);        /* now write the data to the container */    /* first make a spec from the saved alias, if there is one */  MyWriteSection(gSecHandle, theData, typeToMake,theOwningDoc);   } else {    /* error creating the section */    ShowMe(&quot;\p Couldn't create section&quot;, myErr,__LINE__);    }    HUnlock(theData);    switch (typeToMake) {        case kGenericPICTWord:            KillPicture((PicHandle)theData);            break;        case kGenericTEXTWord:            break;        case kCustomType:            break;    }     (*shortName)-&gt;hasSelection = false;    InvalRect(&amp;(*shortName)-&gt;selectionRect);                /* get rid of border once publish has happened */    gShowPub = false;    (*shortName)-&gt;hasSelection = false;    SetMyCursor(0);    SwitchChecks(kSelectStuff);    HUnlock((Handle)shortName);}/* end CreatePublisher *//* MyUpdateEdition publishes the latest data for this edition.  This will* be called when the user selects 'Send Edition Now' from the options* dialog, or when the document is saved (if automatic saving is * enabled), or if a section write AppleEvent happens*/OSErr MyUpdateEdition(SectionHandle theSection){    WindowPtr tempWindow;    Boolean tempSub, tempPub;  Boolean wasChanged;    windowCHandle shortName;    SectionHandle *tempPtr;  FSSpecPtr theOwningDoc=nil;  FSSpec owner;    register qq;    Rect *tempRectPtr;    extern Rect gShowPubRect;    extern Rect gShowSubRect;  WindowPtr owningWindow = FindSection(theSection);    GetPort(&amp;tempWindow);    shortName = (windowCHandle)GetWRefCon(owningWindow);    HLock((Handle)shortName);  if(GetHandleSize((Handle)(*shortName)-&gt;fileAliasHandle)){  ResolveAlias(nil,(*shortName)-&gt;fileAliasHandle,&amp;owner,&amp;wasChanged);  theOwningDoc=&amp;owner;  }    if (((*theSection)-&gt;refCon &amp; 0xf) == kPictType) {        HLock((Handle)theSection);        /* kill the borders, if any are showing right now */        tempSub = gShowSub;        tempPub = gShowPub;        if (gShowSub)            InvalRect(&amp;gShowSubRect);        if (gShowPub)            InvalRect(&amp;gShowPubRect);        gShowSub = gShowPub = false;        SetPort(owningWindow);        (ProcPtr)((*shortName)-&gt;drawMe)(shortName, owningWindow);     /* draw without borders */    /*         /* search this window for the section asked for */        HLock((*shortName)-&gt;pubs);        tempPtr = (SectionHandle *)*(*shortName)-&gt;pubs;        for (qq = 0; qq &lt; (*shortName)-&gt;numPubs; qq++) {            HLock((Handle)*tempPtr);            if ((*theSection)-&gt;sectionID == (*(*tempPtr))-&gt;sectionID) {                PicHandle tempPic;                /* it's this one, grab the rect, pic it, publish it, and go away */                HLock((*shortName)-&gt;pubRects);                tempRectPtr = (Rect *)*(*shortName)-&gt;pubRects;                tempRectPtr += qq;                tempPic = MyMakePicture(tempRectPtr);                HUnlock((*shortName)-&gt;pubRects);                MyWriteSection(*tempPtr, (Handle)tempPic, kGenericPICTWord,theOwningDoc);                KillPicture(tempPic);                HUnlock((Handle)*tempPtr);                break;            }        }        HUnlock((Handle)theSection);        HUnlock((Handle)shortName);    } else {        mySectionDataHandle theTS = TextSectionFromSecHandle(theSection);        /* it's a text pub */        MyWriteSection(theSection, (*theTS)-&gt;additionalData, kGenericTEXTWord,theOwningDoc);            }    InvalRect(&amp;owningWindow-&gt;portRect);    SetPort(tempWindow);    return(noErr);}/* end MyUpdateEdition *//* MyMakePicture is a handy place to create our PICT demo data item.* It's called to create the actual edition data as well as the 'preview'* picture.*/PicHandle MyMakePicture(Rect *thisRect){    PicHandle thepic;    windowCHandle drawers;    Boolean tempPub, tempSub;    RgnHandle tempClip;    /* make sure borders aren't included in the picture */    tempPub = gShowPub;    tempSub = gShowSub;    gShowPub = false;    gShowSub = false;    tempClip = NewRgn();    GetClip(tempClip);    ClipRect(thisRect);    thepic = OpenPicture(thisRect);    drawers = (windowCHandle)GetWRefCon(FrontWindow() );    HLock((Handle)drawers);    (ProcPtr)((*drawers)-&gt;drawMe)(drawers, FrontWindow() );    HUnlock((Handle)drawers);    ClosePicture();    SetClip(tempClip);    DisposeRgn(tempClip);    /* restore old border states */    gShowPub = tempPub;    gShowSub = tempSub;    return(thepic);}/* end MyMakePicture *//* AEWriteSectionHandler is the AppleEvent handler for section write* events.   It first pulls the SectionHandle out of the AppleEvent record,* then verifies that this is a registered section (still active, not canceled)* and then calls MyUpdateEdition to write the edition*/pascal OSErr AEWriteSectionHandler(AppleEvent *messagein, AppleEvent *reply, long refIn){#pragma unused (reply,refIn)    SectionHandle theSection;    OSErr myErr;    myErr = GetSectionHandleFromEvent(messagein, &amp;theSection);    if (myErr = IsRegisteredSection((SectionHandle)theSection)) {        ShowMe(&quot;\p Write IsRegisteredSection&quot;, myErr,__LINE__);        return(myErr);    }    MyUpdateEdition(theSection);    }/* end AEWriteSectionHandler *//* ***** REVISED!  This event has been revised since it's initial release *//* to reflect the final definition of this event, and the object that it accepts  *//* as a parameter *//* **** NEW EVENT **** *//* ** Please read the description and code in the Inside Mac vol VI chapters on *//* the Edition Manager and APpleEvents for a full description *//* AECreatePubHandler handles the new create publisher event */pascal OSErr AECreatePubHandler(AppleEvent *messagein, AppleEvent *reply, long refIn){#pragma unused (reply,refIn)windowCHandle tempWC;OSErr myErr = noErr;Size returnedSize;long savedStart,savedEnd;Rect savedRect;DescType returnedType = typeNull;OSType theType;AEDesc returnedToken;AEDesc theObject;FSSpec theFSSpec;FSSpecPtr theFSS = nil;CTextObjHandle cTextBack;CWordObjHandle cWordBack;CShapeObjHandle cShapeback;WindowPtr containingWindow;WindowPtr oldFront=nil;theObject.descriptorType = typeNull;returnedToken.descriptorType = typeNull;oldFront = FrontWindow();/* this event has two parameters, a object specifier and an alias handle. *//* Both parameters are optional. *//* if the object doesn't exsist, then we publish the current selection *//* if the alias doesn't exsist, then we put up the options dialog */AEGetParamDesc(messagein,keyDirectObject,typeObjectSpecifier,&amp;theObject);/* the AEM has a built-in coercion from alias to FSSpec */AEGetParamPtr(messagein,keyAEEditionFileLoc,typeAlias,&amp;returnedType,(Ptr)&amp;theFSSpec,sizeof(FSSpec),&amp;returnedSize);if(typeFSS == returnedType)  theFSS = &amp;theFSSpec;/* checking for null instead of for an error because I don't care if either of these error out, I just care if they return a descriptor or not.  Which I could do with two error variables, but you know.... *//* Now resolve the object I got (if I got one)  */if(theObject.descriptorType != typeNull)   myErr = AEResolve(&amp;theObject, kAEIDoMinimum, &amp;returnedToken);if(!myErr){/* so the action, will be something like this, since I am but a lowly  *//* example program *//* if the value returned from AEResolve is a graphic-type thing, I will put it's *//* rectangle into the current selection, and call CreatePub. *//* if it's a text thing, I will save the current selection, reset the selction, and *//* call CreatePub.  I'm typing this in as a comment because I don't know if I'll *//* get it implemented within my release timeframe, but that is the idea. *//* Also, because of the way I initially designed this program, the publisher must *//* be the front window.  Not a good idea, I will re-write that in a future release, *//* but for now we live with it. */  switch(returnedToken.descriptorType){  /* get the owning window */  case cText:  theType = kGenericTEXTWord;  cTextBack = (CTextObjHandle)returnedToken.dataHandle;  containingWindow=(*cTextBack)-&gt;theOwningWindow;  tempWC = (windowCHandle)GetWRefCon(containingWindow);  /* save off current  */  savedStart = (*(*tempWC)-&gt;boxHandle)-&gt;selStart;  savedEnd=(*(*tempWC)-&gt;boxHandle)-&gt;selEnd;  /* and since they asked for the whole text, make the end equal the beginning */  (*(*tempWC)-&gt;boxHandle)-&gt;selEnd = (*(*tempWC)-&gt;boxHandle)-&gt;teLength;  (*(*tempWC)-&gt;boxHandle)-&gt;selStart=0;  /* and do the thing */  SelectWindow(containingWindow);    myErr = CreatePublisher(theType,true,theFSS);  /* restore */  (*(*tempWC)-&gt;boxHandle)-&gt;selStart = savedStart;  (*(*tempWC)-&gt;boxHandle)-&gt;selEnd = savedEnd;  break;    case cWord:  theType = kGenericTEXTWord;  cWordBack = (CWordObjHandle)returnedToken.dataHandle;  containingWindow=(*cWordBack)-&gt;theOwningWindow;  tempWC = (windowCHandle)GetWRefCon(containingWindow);  savedStart = (*(*tempWC)-&gt;boxHandle)-&gt;selStart;  savedEnd=(*(*tempWC)-&gt;boxHandle)-&gt;selEnd;  (*(*tempWC)-&gt;boxHandle)-&gt;selStart = (*cWordBack)-&gt;startPos;  (*(*tempWC)-&gt;boxHandle)-&gt;selEnd = (*cWordBack)-&gt;endPos;  /* do the thing */  SelectWindow(containingWindow);  myErr = CreatePublisher(theType,true,theFSS);  (*(*tempWC)-&gt;boxHandle)-&gt;selStart = savedStart;  (*(*tempWC)-&gt;boxHandle)-&gt;selEnd = savedEnd;  break;  case cGraphicLine:  case cRectangle:  case cOval:  theType = kGenericPICTWord;  /* save the current selection rect if any */  cShapeback = (CShapeObjHandle)returnedToken.dataHandle;  containingWindow=(*cShapeback)-&gt;theOwningWindow;  tempWC = (windowCHandle)GetWRefCon(containingWindow);  savedRect=(*tempWC)-&gt;selectionRect;  (*tempWC)-&gt;selectionRect = (*(*cShapeback)-&gt;theShape)-&gt;theRect;  SelectWindow(containingWindow);  myErr = CreatePublisher(theType,true,theFSS);  (*tempWC)-&gt;selectionRect = savedRect;   break;  default:  myErr = errAEEventNotHandled;  /* I don't know how to publish this object */  break;  }} else {/* Here, there was an object, but I couldn't understand it.  That is an _error_ *//* condition, which is different from no object being available */myErr= errAENoSuchObject;}/* if there was an old front window, make it frontmost agin */if(oldFront)ChangePlane(oldFront);return(myErr);}/* end AECreatePubHandler *//* AEScrollSectionHandler handles the scroll section event.  You'll get this* event when the user clicks 'Open Publisher' either from the * Subcriber Options dialog, or from the Finder window.* This may also have happened after an ODOC AppleEvent, so * don't assume anything about your state that wouldn't be true * after an initial application launch*/pascal OSErr AEScrollSectionHandler(AppleEvent *messagein, AppleEvent *reply, long refIn){#pragma unused (reply,refIn)    WindowPtr tempWindow;    SectionHandle theSection;    OSErr myErr;    myErr = GetSectionHandleFromEvent(messagein, &amp;theSection);    tempWindow = FindSection(theSection);    /* First bring our application to the front, then */    /* treat this the same way you would a click in a back window */  myErr=AEInteractWithUser(kAEDefaultTimeout,nil, gCommonIdleFunctionUPP);    if(!myErr)SetFrontProcess(&amp;gOurSN);    else ShowMe(&quot;\ptheEr&quot;,myErr,__LINE__);    if (tempWindow != nil)        ChangePlane(tempWindow);    return(noErr);}/* end AEScrollSectionHandler *//* AECancelSectionHandler cancels a current section, either a publisher* or subscriber.  This function pulls the section handle out of the * AppleEvent, then dispatches to the proper cancel routine for a* pub or sub.*/pascal OSErr AECancelSectionHandler(AppleEvent *messagein, AppleEvent *reply, long refIn){#pragma unused (reply,refIn)    SectionHandle theSection;    OSErr myErr;    myErr = GetSectionHandleFromEvent(messagein, &amp;theSection);    myErr = IsRegisteredSection(theSection);    if (myErr != noErr)        return(myErr);                                      /* already killed by someone */    MyCancelSection(theSection, FindSection(theSection));    }/* end AECancelSectionHandler *//* MyWriteSection actually opens and writes the section data.  This will* be called in response to a click in 'Send Edition Now' in the pub options* box, from the section event 'write section', or when the file is being saved* and 'pumAuto' is enabled*/OSErr MyWriteSection(SectionHandle secHandle, Handle theData, OSType theType,FSSpecPtr inSpec){    OSErr myErr;    /* update the time in the section handle please */    /* this tells the Edition Manager that the eidtion has changed, and */    /* to alert all the subscribers to the change */    SpinCursor();    HLock((Handle)secHandle);    GetDateTime(&amp;(*secHandle)-&gt;mdDate);                     /* *** Please see NOTE in main.c about mdDate (find mdDate) */    HUnlock((Handle)secHandle);    /* OpenNewEdition, _NOT_ OpenEdition.  You need to use OpenNewEdition */    /* to get write access and to let the Edition Manager determine if you */    /* are allowed to write to this section */    myErr = OpenNewEdition(secHandle, kMySignature,inSpec, &amp;gEdRefNum);    if (myErr)        ShowMe(&quot;\pOpenNewEdition&quot;, myErr,__LINE__);    HLock(theData);    /* And actually write the data (finally) */  SpinCursor();    myErr = WriteEdition(gEdRefNum, theType, *theData, GetHandleSize(theData));    if (myErr)        ShowMe(&quot;\pWriteEdition&quot;, myErr,__LINE__);    if (myErr)        myErr = 0;    else        myErr = -1;    /* The Boolean tells the Edition Manager if you were successful in */    /* writing the data. */  myErr = CloseEdition(gEdRefNum, (Boolean)myErr);          if(myErr)ShowMe(&quot;\pCloseEdition&quot;, myErr,__LINE__);    return(myErr);}/* end MyWriteSection *//* StorePublisher moves the window data struct storing function to here *//* shortName is locked on entry */void StorePublisher(windowCHandle shortName, SectionHandle storeSection, Rect *inRect, mySectionDataHandle textIn, OSType typeIn){    Rect *tempRectPtr;    SectionHandle *tempPtr;    OSErr myErr;    switch (typeIn) {        case kGenericPICTWord:            HUnlock((*shortName)-&gt;pubs);            MySetHandleSize((*shortName)-&gt;pubs, GetHandleSize((*shortName)-&gt;pubs) + sizeof(Handle));            myErr = MemError();            if (myErr)                ShowMe(&quot;\pMemory&quot;, myErr,__LINE__);            HLock((*shortName)-&gt;pubs);            tempPtr = (SectionHandle *)((*(*shortName)-&gt;pubs) + (sizeof(Handle) * ((*shortName)-&gt;numPubs)));            *tempPtr = (SectionHandle)storeSection;            /* **** NOTE, please look at the note in the Subscribe.c file concerning the dirty flag and  */            /* editions.  Open Subscribe.c and find the string 'Human Interface' */            /*    (*shortName)-&gt;windowDirty = true;  */            /* save the rectangle to show the published rectangle if the user wants to see it. */            HUnlock((*shortName)-&gt;pubRects);            MySetHandleSize((*shortName)-&gt;pubRects, (GetHandleSize((*shortName)-&gt;pubRects) + sizeof(Rect)));            myErr = MemError();            if (myErr)                ShowMe(&quot;\pMemory&quot;, myErr,__LINE__);            HLock((*shortName)-&gt;pubRects);            tempRectPtr = (Rect *)*(*shortName)-&gt;pubRects;            tempRectPtr += (*shortName)-&gt;numPubs;            *tempRectPtr = *inRect;            (*shortName)-&gt;numPubs++;            HUnlock((*shortName)-&gt;pubRects);            HUnlock((*shortName)-&gt;pubs);            break;        case kGenericTEXTWord:            /* set my text section ID to the same as the actual section ID, again, it keeps */            /* dereferencing down */            (*textIn)-&gt;theID = (*storeSection)-&gt;sectionID;            /* tell myself that this is a publisher */            (*textIn)-&gt;publishing = true;            if ((*shortName)-&gt;textSections == nil) {                (*shortName)-&gt;textSections = textIn;            } else {                mySectionDataHandle tempTS = (*shortName)-&gt;textSections;                while ((*tempTS)-&gt;nextSection != nil) {                    tempTS = (*tempTS)-&gt;nextSection;                }                (*tempTS)-&gt;nextSection = textIn;            }            (*textIn)-&gt;theSection = storeSection;            break;    }    gSectionID++;}/* Find Section returns the window that this section is included in *//* Need to look in both the PICT and TEXT lists */WindowPtr FindSection(SectionHandle inSection){     long subIDtofind;    Boolean secFound = false;    SectionHandle *tempPtr;    SectionRecord *tempRecord;    Handle tempHandle;    WindowPtr tempNextWindow;    register jj;    subIDtofind = (*inSection)-&gt;sectionID;    tempNextWindow = (WindowPtr)LMGetWindowList();  /* start at the beginning of the chain */  while(tempNextWindow){  if (((WindowPeek)tempNextWindow)-&gt;windowKind == kDocumentWindow){ /* the clipboard is not publishing */        windowCHandle tempWC;        /* do housekeeping to get to the section handle list */        tempWC = (windowCHandle)GetWRefCon(tempNextWindow);        HLock((Handle)tempWC);        if (((*inSection)-&gt;refCon &amp; 0xf) == kPictType) {            tempHandle = (*tempWC)-&gt;pubs;                   /* handle containing SectionHandles */            HLock(tempHandle);            tempPtr = (SectionHandle *)*tempHandle;            /* Loop through all our sections until we find this edition */            for (jj = 0; jj &lt; (*tempWC)-&gt;numPubs; jj++) {                HLock((Handle)*tempPtr);                tempRecord = *(*tempPtr);                if (tempRecord-&gt;sectionID == subIDtofind) {                    HUnlock((Handle)*tempPtr);                    HUnlock((Handle)tempWC);                    return(tempNextWindow);                } else {                    HUnlock((Handle)tempWC);                    HUnlock((Handle)*tempPtr);                    tempPtr += 1;                }            }            HUnlock(tempHandle);            /* same thing for subscribers */            tempHandle = (*tempWC)-&gt;subs;                   /* handle containing SectionHandles */            HLock(tempHandle);            tempPtr = (SectionHandle *)*tempHandle;            /* Loop through all our sections until we find this edition */            for (jj = 0; jj &lt; (*tempWC)-&gt;numSubs; jj++) {                HLock((Handle)*tempPtr);                tempRecord = *(*tempPtr);                if (tempRecord-&gt;sectionID == subIDtofind) {                    HUnlock((Handle)*tempPtr);                    HUnlock((Handle)tempWC);                    return(tempNextWindow);                } else {                    HUnlock((Handle)tempWC);                    HUnlock((Handle)*tempPtr);                    tempPtr += 1;                }            }            HUnlock(tempHandle);        } else {            /* Look in the TEXT lists */            if ((*tempWC)-&gt;textSections) {                mySectionDataHandle tempTS = (*tempWC)-&gt;textSections;                do {                    if ((*((*tempTS)-&gt;theSection))-&gt;sectionID == subIDtofind) {                        HUnlock((Handle)tempWC);                        return(tempNextWindow);                    }                    tempTS = (*tempTS)-&gt;nextSection;                } while (tempTS);                            }        }        tempNextWindow = (WindowPtr)((WindowPeek)tempNextWindow)-&gt;nextWindow;                 HUnlock((Handle)tempWC);    }  /* if document */    tempNextWindow = (WindowPtr) ((WindowPeek)tempNextWindow)-&gt;nextWindow;    } /* while windows */    return(nil);}pascal short ExpOptHook(short itemOffset, short itemHit, DialogPtr theDialog, Ptr yourDataPtr){ #pragma unused (yourDataPtr)   short myHit;    short itemType;    ControlHandle theButton;    Rect theRect;    /* first make sure that a sub-dialog is not frontmost */    /* so we don't filter keys or hits to a sub-dialog */    if (GetWRefCon((WindowPtr)theDialog) == sfMainDialogRefCon || GetWRefCon((WindowPtr)theDialog) == emOptionsDialogRefCon) {        /* only have one item in this expansion, but we'll check the range anyway */        myHit = itemHit - itemOffset;                       /* since our item numbers are relative to the total number */        /* of items in the dialog, and the system may change.  Always do your item numbering based */        /* on the offset, this will prevent incompatability when the system dialog grows or shrinks */        if (myHit == 1) {                                   /* I only added one item, so this be the one */            /* Pass itemHit here, not myHit, since the dialog manager has no idea that this is an */            /* additive dialog.  It is counting from the actual start of the DITL, not the start of */            /* your custom items */            GetDialogItem(theDialog, itemHit, &amp;itemType, (Handle *)&amp;theButton, &amp;theRect);            if (GetControlValue(theButton))                SetControlValue(theButton, false);            else                SetControlValue(theButton, true);        }    }    return(itemHit);                                        /* the return value must be absolute */}pascal Boolean ExpOptFilter(DialogPtr theDialog, EventRecord *theEvent, short itemOffset, short *itemHit, Ptr yourDataPtr){#pragma unused (itemHit,yourDataPtr)    short itemType;    ControlHandle theButton;    Rect theRect;    /* first make sure that a sub-dialog is not frontmost */    /* so we don't filter keys or hits to a sub-dialog */    if (GetWRefCon((WindowPtr)theDialog) == sfMainDialogRefCon || GetWRefCon((WindowPtr)theDialog) == emOptionsDialogRefCon) {        /* standard filter proc kinda stuff here */        if ((theEvent-&gt;what) == keyDown) {            char tempChar;            tempChar = theEvent-&gt;message &amp; charCodeMask;                        if (((tempChar == 'A') || (tempChar == 'a')) &amp;&amp; (theEvent-&gt;modifiers &amp; cmdKey)) {                /* they pressed an A with the command key down, we get to handle it. */                GetDialogItem(theDialog, itemOffset + 1, &amp;itemType, (Handle *)&amp;theButton, &amp;theRect);                if (GetControlValue(theButton))                    SetControlValue(theButton, false);                else                    SetControlValue(theButton, true);                                return(true);                               /* tell folks we handled it */            }        }    }    return(false);                                          /* was not a keystroke we wanted */    }/* shortName is locked on entry */mySectionDataHandle GetTextSection(windowCHandle shortName, SectionType what){    CharsHandle theRawText;    TEHandle tempTE;    mySectionDataHandle theTextSection;    Handle theSelection;    theTextSection = (mySectionDataHandle)NewHandle(sizeof(mySectionData));    HLock((Handle)theTextSection);    (*theTextSection)-&gt;bordered = gShowingAll;              /* create section reflecting current */    /* global border state */    tempTE = (*shortName)-&gt;boxHandle;    (*theTextSection)-&gt;startChar = (*tempTE)-&gt;selStart;    if (what == stPublisher) {        /* initialize it if it's a publisher */        (*theTextSection)-&gt;endChar = (*tempTE)-&gt;selEnd;                theRawText = TEGetText(tempTE);        theSelection = NewHandle(((*tempTE)-&gt;selEnd) - ((*tempTE)-&gt;selStart));                HLock(theSelection);        HLock((Handle)theRawText);        BlockMove((Ptr)*theRawText + (*tempTE)-&gt;selStart, (Ptr)*theSelection, (*tempTE)-&gt;selEnd - (*tempTE)-&gt;selStart);        HUnlock(theSelection);        HUnlock((Handle)theRawText);        (*theTextSection)-&gt;additionalData = theSelection;    } else {        /* set start same as end for subscribers */        (*theTextSection)-&gt;endChar = (*tempTE)-&gt;selStart;        (*theTextSection)-&gt;additionalData = NewHandle(0);    }    (*theTextSection)-&gt;nextSection = nil;    return(theTextSection);}mySectionDataHandle TextSectionFromSecHandle(SectionHandle theSection){    windowCHandle tempWC = (windowCHandle)GetWRefCon(FindSection(theSection));      /* gets the window it's in */    mySectionDataHandle tempTS = (*tempWC)-&gt;textSections;    unsigned long idToFind;        idToFind = (*theSection)-&gt;sectionID;    /* find the ID that matches this thang */    do {        if ((*tempTS)-&gt;theID == idToFind)            return(tempTS);        tempTS = (*tempTS)-&gt;nextSection;    } while (tempTS);    return(nil);                                            /* failed */}/* In SearchPubs we'll search the publishers in this window for a publisher *//* that was clicked in.  If we find one, hilite it and outline it. *//* Point is already in local coordinates */Boolean SearchPubs(Point thePoint){    register qq;    Rect rectToCheck;    Rect cornerRect;    Rect *theRects;  Str63 pubString;    Boolean gotIt = false;    windowCHandle shortname = (windowCHandle)GetWRefCon(FrontWindow());    HLock((Handle)shortname);    if ((*shortname)-&gt;numPubs) {                            /* does this window have any publishers? */        /* yes, see if one was clicked in */        HLock((*shortname)-&gt;pubRects);                      /* lock the rect handle down */        theRects = (Rect *)*(*shortname)-&gt;pubRects;        /* dereference it and cast it to a rect pointer so checking will be         *   conceptually easier (i.e. you can read it)         */        for (qq = 0; qq &lt; (*shortname)-&gt;numPubs; qq++) {        /* step through 'em */            SectionHandle *tempPtr;            rectToCheck = *theRects;            if (PtInRect(thePoint, &amp;rectToCheck)) {         /* thePoint is coming from your */                /* last event record */                /* We've found a section that has been clicked in */                if (gShowPub &amp;&amp; (rectToCheck != gShowPubRect))                    InvalRect(&amp;gShowPubRect);               /* clear previous, if there was one */                gShowPub = true;                if (gShowSub) {/* clear previous, if there was one */          InsetRect(&amp;gShowSubRect, -4, -4);          InvalRect(&amp;gShowSubRect);          InsetRect(&amp;gShowSubRect, 4, 4);                    gShowSub = false;                }        /* make sure the border gets draw next update */        InsetRect(&amp;rectToCheck,-4,-4);        InvalRect(&amp;rectToCheck);        InsetRect(&amp;rectToCheck,4,4);                /* we've found it with it's rectangle, so now dig out the */                /* section handle */                HLock((*shortname)-&gt;pubs);                tempPtr = (SectionHandle *)*(*shortname)-&gt;pubs;                tempPtr += qq;                /* and move the section handle into our global variable that */                /* contains the currently highlighted section, so we can */                /* access it from the Options function and dialog */                gShowingSecHandle = *tempPtr;                /* done with the pointer handle */                HUnlock((*shortname)-&gt;pubs);                /* change the menu item name now */        GetIndString(pubString, kGeneralStrings, kPubOptString);                        SetMenuItemText(gEditMenuHandle, kSoptionsItem,pubString);                gShowPubRect = rectToCheck;                gotIt = true;                /* Now we need to stretch the thing if the user wants too */                /* See if it was in the corner rect first */                cornerRect = gShowPubRect;                cornerRect.top = cornerRect.bottom - 7;                cornerRect.left = cornerRect.right - 7;                if (PtInRect(thePoint, &amp;cornerRect)) {                    PullRect(shortname, &amp;gShowPubRect, false, true,true);                    if (*theRects != gShowPubRect) {                        *theRects = gShowPubRect;                        InvalRect(theRects);                    }                }            }            if (gotIt)                break;            theRects++;                                     /* increase by one Rect */        }        HUnlock((*shortname)-&gt;pubRects);    }    HUnlock((Handle)shortname);    return(gotIt);}/* end SearchPubs */#undef __PUBLISH__</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/AEObject-Edition_Sample/listing14.html%3Fid%3DDTS10000204-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/AEObject-Edition_Sample/listing14.html%3Fid%3DDTS10000204-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/AEObject-Edition_Sample/listing14.html%3Fid%3DDTS10000204-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>